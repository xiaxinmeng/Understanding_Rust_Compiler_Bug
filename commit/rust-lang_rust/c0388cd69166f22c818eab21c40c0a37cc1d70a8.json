{"sha": "c0388cd69166f22c818eab21c40c0a37cc1d70a8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMwMzg4Y2Q2OTE2NmYyMmM4MThlYWIyMWM0MGMwYTM3Y2MxZDcwYTg=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-10-02T18:29:29Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-10-03T17:25:14Z"}, "message": "Rewrite lint passes with less visitor cruft\n\nThis purges about 500 lines of visitor cruft from lint passes. All lints are\nhandled in a much more sane way at this point. The other huge bonus of this\ncommit is that there are no more @-boxes in the lint passes, fixing the 500MB\nmemory regression seen when the lint passes were refactored.\n\nCloses #8589", "tree": {"sha": "17b06ba76cdf19081d05e0655d3c5cb60d014fb3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/17b06ba76cdf19081d05e0655d3c5cb60d014fb3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c0388cd69166f22c818eab21c40c0a37cc1d70a8", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c0388cd69166f22c818eab21c40c0a37cc1d70a8", "html_url": "https://github.com/rust-lang/rust/commit/c0388cd69166f22c818eab21c40c0a37cc1d70a8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c0388cd69166f22c818eab21c40c0a37cc1d70a8/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ccd9a963f75074da506c05fece1e3c965e742c51", "url": "https://api.github.com/repos/rust-lang/rust/commits/ccd9a963f75074da506c05fece1e3c965e742c51", "html_url": "https://github.com/rust-lang/rust/commit/ccd9a963f75074da506c05fece1e3c965e742c51"}], "stats": {"total": 1349, "additions": 423, "deletions": 926}, "files": [{"sha": "b6a782c09b79d151949ddc5d8e1db9b739ede194", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c0388cd69166f22c818eab21c40c0a37cc1d70a8/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0388cd69166f22c818eab21c40c0a37cc1d70a8/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=c0388cd69166f22c818eab21c40c0a37cc1d70a8", "patch": "@@ -880,13 +880,13 @@ fn encode_side_tables_for_ii(ecx: &e::EncodeContext,\n     // Because the ast visitor uses @IdVisitingOperation, I can't pass in\n     // ecx directly, but /I/ know that it'll be fine since the lifetime is\n     // tied to the CrateContext that lives throughout this entire section.\n-    ast_util::visit_ids_for_inlined_item(ii, @SideTableEncodingIdVisitor {\n+    ast_util::visit_ids_for_inlined_item(ii, &SideTableEncodingIdVisitor {\n         ecx_ptr: unsafe {\n             cast::transmute(ecx)\n         },\n         new_ebml_w: new_ebml_w,\n         maps: maps,\n-    } as @ast_util::IdVisitingOperation);\n+    });\n     ebml_w.end_tag();\n }\n "}, {"sha": "a44223fba83a82fb158dabcf76a1060f4652d809", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 404, "deletions": 901, "changes": 1305, "blob_url": "https://github.com/rust-lang/rust/blob/c0388cd69166f22c818eab21c40c0a37cc1d70a8/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0388cd69166f22c818eab21c40c0a37cc1d70a8/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=c0388cd69166f22c818eab21c40c0a37cc1d70a8", "patch": "@@ -8,6 +8,30 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+//! A 'lint' check is a kind of miscellaneous constraint that a user _might_\n+//! want to enforce, but might reasonably want to permit as well, on a\n+//! module-by-module basis. They contrast with static constraints enforced by\n+//! other phases of the compiler, which are generally required to hold in order\n+//! to compile the program at all.\n+//!\n+//! The lint checking is all consolidated into one pass which runs just before\n+//! translation to LLVM bytecode. Throughout compilation, lint warnings can be\n+//! added via the `add_lint` method on the Session structure. This requires a\n+//! span and an id of the node that the lint is being added to. The lint isn't\n+//! actually emitted at that time because it is unknown what the actual lint\n+//! level at that location is.\n+//!\n+//! To actually emit lint warnings/errors, a separate pass is used just before\n+//! translation. A context keeps track of the current state of all lint levels.\n+//! Upon entering a node of the ast which can modify the lint settings, the\n+//! previous lint state is pushed onto a stack and the ast is then recursed\n+//! upon.  As the ast is traversed, this keeps track of the current lint level\n+//! for all lint attributes.\n+//!\n+//! To add a new lint warning, all you need to do is to either invoke `add_lint`\n+//! on the session at the appropriate time, or write a few linting functions and\n+//! modify the Context visitor appropriately. If you're adding lints from the\n+//! Context itself, span_lint should be used instead of add_lint.\n \n use driver::session;\n use middle::ty;\n@@ -35,43 +59,6 @@ use syntax::parse::token;\n use syntax::{ast, ast_util, visit};\n use syntax::visit::Visitor;\n \n-/**\n- * A 'lint' check is a kind of miscellaneous constraint that a user _might_\n- * want to enforce, but might reasonably want to permit as well, on a\n- * module-by-module basis. They contrast with static constraints enforced by\n- * other phases of the compiler, which are generally required to hold in order\n- * to compile the program at all.\n- *\n- * The lint checking is all consolidated into one pass which runs just before\n- * translation to LLVM bytecode. Throughout compilation, lint warnings can be\n- * added via the `add_lint` method on the Session structure. This requires a\n- * span and an id of the node that the lint is being added to. The lint isn't\n- * actually emitted at that time because it is unknown what the actual lint\n- * level at that location is.\n- *\n- * To actually emit lint warnings/errors, a separate pass is used just before\n- * translation. A context keeps track of the current state of all lint levels.\n- * Upon entering a node of the ast which can modify the lint settings, the\n- * previous lint state is pushed onto a stack and the ast is then recursed upon.\n- * As the ast is traversed, this keeps track of the current lint level for all\n- * lint attributes.\n- *\n- * At each node of the ast which can modify lint attributes, all known lint\n- * passes are also applied.  Each lint pass is a visit::Visitor implementator.\n- * The visitors are constructed via the lint_*() functions below. There are\n- * also some lint checks which operate directly on ast nodes (such as\n- * @ast::item), and those are organized as check_item_*(). Each visitor added\n- * to the lint context is modified to stop once it reaches a node which could\n- * alter the lint levels. This means that everything is looked at once and\n- * only once by every lint pass.\n- *\n- * With this all in place, to add a new lint warning, all you need to do is to\n- * either invoke `add_lint` on the session at the appropriate time, or write a\n- * lint pass in this module which is just an ast visitor. The context used when\n- * traversing the ast has a `span_lint` method which only needs the span of the\n- * item that's being warned about.\n- */\n-\n #[deriving(Clone, Eq)]\n pub enum lint {\n     ctypes,\n@@ -133,12 +120,6 @@ impl Ord for LintSpec {\n \n pub type LintDict = HashMap<&'static str, LintSpec>;\n \n-enum AttributedNode<'self> {\n-    Item(@ast::item),\n-    Method(&'self ast::method),\n-    Crate(&'self ast::Crate),\n-}\n-\n #[deriving(Eq)]\n enum LintSource {\n     Node(Span),\n@@ -335,100 +316,40 @@ pub fn get_lint_dict() -> LintDict {\n     return map;\n }\n \n-trait OuterLint {\n-    fn process_item(@mut self, i:@ast::item, e:@mut Context);\n-    fn process_fn(@mut self, fk:&visit::fn_kind, fd:&ast::fn_decl,\n-                  b:&ast::Block, s:Span, n:ast::NodeId, e:@mut Context);\n-\n-    // Returned inner variant will not proceed past subitems.\n-    // Supports decomposition of simple lints into subitem-traversing\n-    // outer lint visitor and subitem-stopping inner lint visitor.\n-    fn inner_variant(@mut self) -> @mut InnerLint;\n-}\n-\n-trait InnerLint {\n-    fn descend_item(@mut self, i:&ast::item, e:@mut Context);\n-    fn descend_crate(@mut self, crate: &ast::Crate, env: @mut Context);\n-    fn descend_fn(@mut self,\n-                  function_kind: &visit::fn_kind,\n-                  function_declaration: &ast::fn_decl,\n-                  function_body: &ast::Block,\n-                  sp: Span,\n-                  id: ast::NodeId,\n-                  env: @mut Context);\n-}\n-\n-impl<V:Visitor<@mut Context>> InnerLint for V {\n-    fn descend_item(@mut self, i:&ast::item, e:@mut Context) {\n-        visit::walk_item(self, i, e);\n-    }\n-    fn descend_crate(@mut self, crate: &ast::Crate, env: @mut Context) {\n-        visit::walk_crate(self, crate, env);\n-    }\n-    fn descend_fn(@mut self, fk: &visit::fn_kind, fd: &ast::fn_decl, fb: &ast::Block,\n-                  sp: Span, id: ast::NodeId, env: @mut Context) {\n-        visit::walk_fn(self, fk, fd, fb, sp, id, env);\n-    }\n-}\n-\n-enum AnyVisitor {\n-    // This is a pair so every visitor can visit every node. When a lint pass\n-    // is registered, another visitor is created which stops at all items\n-    // which can alter the attributes of the ast. This \"item stopping visitor\"\n-    // is the second element of the pair, while the original visitor is the\n-    // first element. This means that when visiting a node, the original\n-    // recursive call can use the original visitor's method, although the\n-    // recursing visitor supplied to the method is the item stopping visitor.\n-    OldVisitor(@mut OuterLint, @mut InnerLint),\n-    NewVisitor(@mut visit::Visitor<()>),\n-}\n-\n struct Context {\n     // All known lint modes (string versions)\n     dict: @LintDict,\n     // Current levels of each lint warning\n-    curr: SmallIntMap<(level, LintSource)>,\n+    cur: SmallIntMap<(level, LintSource)>,\n     // context we're checking in (used to access fields like sess)\n     tcx: ty::ctxt,\n-    // Just a simple flag if we're currently recursing into a trait\n-    // implementation. This is only used by the lint_missing_doc() pass\n-    in_trait_impl: bool,\n-    // Another flag for doc lint emissions. Does some parent of the current node\n-    // have the doc(hidden) attribute? Treating this as allow(missing_doc) would\n-    // play badly with forbid(missing_doc) when it shouldn't.\n-    doc_hidden: bool,\n+\n     // When recursing into an attributed node of the ast which modifies lint\n     // levels, this stack keeps track of the previous lint levels of whatever\n     // was modified.\n     lint_stack: ~[(lint, level, LintSource)],\n-    // Each of these visitors represents a lint pass. A number of the lint\n-    // attributes are registered by adding a visitor to iterate over the ast.\n-    // Others operate directly on @ast::item structures (or similar). Finally,\n-    // others still are added to the Session object via `add_lint`, and these\n-    // are all passed with the lint_session visitor.\n-    visitors: ~[AnyVisitor],\n }\n \n impl Context {\n     fn get_level(&self, lint: lint) -> level {\n-        match self.curr.find(&(lint as uint)) {\n+        match self.cur.find(&(lint as uint)) {\n           Some(&(lvl, _)) => lvl,\n           None => allow\n         }\n     }\n \n     fn get_source(&self, lint: lint) -> LintSource {\n-        match self.curr.find(&(lint as uint)) {\n+        match self.cur.find(&(lint as uint)) {\n           Some(&(_, src)) => src,\n           None => Default\n         }\n     }\n \n     fn set_level(&mut self, lint: lint, level: level, src: LintSource) {\n         if level == allow {\n-            self.curr.remove(&(lint as uint));\n+            self.cur.remove(&(lint as uint));\n         } else {\n-            self.curr.insert(lint as uint, (level, src));\n+            self.cur.insert(lint as uint, (level, src));\n         }\n     }\n \n@@ -442,7 +363,7 @@ impl Context {\n     }\n \n     fn span_lint(&self, lint: lint, span: Span, msg: &str) {\n-        let (level, src) = match self.curr.find(&(lint as uint)) {\n+        let (level, src) = match self.cur.find(&(lint as uint)) {\n             None => { return }\n             Some(&(warn, src)) => (self.get_level(warnings), src),\n             Some(&pair) => pair,\n@@ -479,7 +400,8 @@ impl Context {\n      * current lint context, call the provided function, then reset the\n      * lints in effect to their previous state.\n      */\n-    fn with_lint_attrs(@mut self, attrs: &[ast::Attribute], f: &fn()) {\n+    fn with_lint_attrs(&mut self, attrs: &[ast::Attribute],\n+                       f: &fn(&mut Context)) {\n         // Parse all of the lint attributes, and then add them all to the\n         // current dictionary of lint information. Along the way, keep a history\n         // of what we changed so we can roll everything back after invoking the\n@@ -513,99 +435,22 @@ impl Context {\n             true\n         };\n \n-        // detect doc(hidden)\n-        let mut doc_hidden = do attrs.iter().any |attr| {\n-            \"doc\" == attr.name() &&\n-                match attr.meta_item_list() {\n-                    Some(l) => attr::contains_name(l, \"hidden\"),\n-                    None    => false // not of the form #[doc(...)]\n-                }\n-        };\n-\n-        if doc_hidden && !self.doc_hidden {\n-            self.doc_hidden = true;\n-        } else {\n-            doc_hidden = false;\n-        }\n-\n-        f();\n+        f(self);\n \n         // rollback\n-        if doc_hidden && self.doc_hidden {\n-            self.doc_hidden = false;\n-        }\n         do pushed.times {\n             let (lint, lvl, src) = self.lint_stack.pop();\n             self.set_level(lint, lvl, src);\n         }\n     }\n \n-    fn add_old_lint(&mut self, v: @mut OuterLint) {\n-        self.visitors.push(OldVisitor(v, v.inner_variant()));\n-    }\n-\n-    fn add_lint(&mut self, v: @mut visit::Visitor<()>) {\n-        self.visitors.push(NewVisitor(v));\n-    }\n-\n-    fn process(@mut self, n: AttributedNode) {\n-        // see comment of the `visitors` field in the struct for why there's a\n-        // pair instead of just one visitor.\n-        match n {\n-            Item(it) => {\n-                for visitor in self.visitors.iter() {\n-                    match *visitor {\n-                        OldVisitor(orig, stopping) => {\n-                            orig.process_item(it, self);\n-                            stopping.descend_item(it, self);\n-                        }\n-                        NewVisitor(new_visitor) => {\n-                            let new_visitor = new_visitor;\n-                            new_visitor.visit_item(it, ());\n-                        }\n-                    }\n-                }\n-            }\n-            Crate(c) => {\n-                for visitor in self.visitors.iter() {\n-                    match *visitor {\n-                        OldVisitor(_, stopping) => {\n-                            stopping.descend_crate(c, self)\n-                        }\n-                        NewVisitor(new_visitor) => {\n-                            let mut new_visitor = new_visitor;\n-                            visit::walk_crate(&mut new_visitor, c, ())\n-                        }\n-                    }\n-                }\n-            }\n-            // Can't use visit::walk_method_helper because the\n-            // item_stopping_visitor has overridden visit_fn(&fk_method(... ))\n-            // to be a no-op, so manually invoke visit_fn.\n-            Method(m) => {\n-                for visitor in self.visitors.iter() {\n-                    match *visitor {\n-                        OldVisitor(orig, stopping) => {\n-                            let fk = visit::fk_method(m.ident, &m.generics, m);\n-                            orig.process_fn(&fk, &m.decl, &m.body, m.span, m.id, self);\n-                            stopping.descend_fn(&fk, &m.decl, &m.body, m.span, m.id, self);\n-                        }\n-                        NewVisitor(new_visitor) => {\n-                            let fk = visit::fk_method(m.ident,\n-                                                      &m.generics,\n-                                                      m);\n-                            let new_visitor = new_visitor;\n-                            new_visitor.visit_fn(&fk,\n-                                                 &m.decl,\n-                                                 &m.body,\n-                                                 m.span,\n-                                                 m.id,\n-                                                 ())\n-                        }\n-                    }\n-                }\n-            }\n-        }\n+    fn visit_ids(&self, f: &fn(&mut ast_util::IdVisitor<Context>)) {\n+        let mut v = ast_util::IdVisitor {\n+            operation: self,\n+            pass_through_items: false,\n+            visited_outermost: false,\n+        };\n+        f(&mut v);\n     }\n }\n \n@@ -641,124 +486,36 @@ pub fn each_lint(sess: session::Session,\n     true\n }\n \n-trait SubitemStoppableVisitor : Visitor<@mut Context> {\n-    fn is_running_on_items(&mut self) -> bool;\n-\n-    fn visit_item_action(&mut self, _i:@ast::item, _e:@mut Context) {\n-        // fill in with particular action without recursion if desired\n-    }\n-\n-    fn visit_fn_action(&mut self, _fk:&visit::fn_kind, _fd:&ast::fn_decl,\n-                       _b:&ast::Block, _s:Span, _n:ast::NodeId, _e:@mut Context) {\n-        // fill in with particular action without recursion if desired\n-    }\n-\n-    // The two OVERRIDE methods:\n-    //\n-    //   OVERRIDE_visit_item\n-    //   OVERRIDE_visit_fn\n-    //\n-    // *must* be included as initial reimplementations of the standard\n-    // default behavior of visit_item and visit_fn for every impl of\n-    // Visitor, in order to recreate the effect of having two variant\n-    // Outer/Inner behaviors of lint visitors.  (See earlier versions\n-    // of this module to see what the original encoding was of this\n-    // emulated behavior.)\n-\n-    fn OVERRIDE_visit_item(&mut self, i:@ast::item, e:@mut Context) {\n-        if self.is_running_on_items() {\n-            self.visit_item_action(i, e);\n-            visit::walk_item(self, i, e);\n-        }\n-    }\n-\n-    fn OVERRIDE_visit_fn(&mut self, fk:&visit::fn_kind, fd:&ast::fn_decl,\n-                b:&ast::Block, s:Span, n:ast::NodeId, e:@mut Context) {\n-        if self.is_running_on_items() {\n-            self.visit_fn_action(fk, fd, b, s, n, e);\n-            visit::walk_fn(self, fk, fd, b, s, n, e);\n-        } else {\n-            match *fk {\n-                visit::fk_method(*) => {}\n-                _ => {\n-                    self.visit_fn_action(fk, fd, b, s, n, e);\n-                    visit::walk_fn(self, fk, fd, b, s, n, e);\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-struct WhileTrueLintVisitor { stopping_on_items: bool }\n-\n-\n-impl SubitemStoppableVisitor for WhileTrueLintVisitor {\n-    fn is_running_on_items(&mut self) -> bool { !self.stopping_on_items }\n-}\n-\n-impl Visitor<@mut Context> for WhileTrueLintVisitor {\n-    fn visit_item(&mut self, i:@ast::item, e:@mut Context) {\n-        self.OVERRIDE_visit_item(i, e);\n-    }\n-\n-    fn visit_fn(&mut self, fk:&visit::fn_kind, fd:&ast::fn_decl,\n-                b:&ast::Block, s:Span, n:ast::NodeId, e:@mut Context) {\n-        self.OVERRIDE_visit_fn(fk, fd, b, s, n, e);\n-    }\n-\n-    fn visit_expr(&mut self, e:@ast::Expr, cx:@mut Context) {\n-\n-            match e.node {\n-                ast::ExprWhile(cond, _) => {\n-                    match cond.node {\n-                        ast::ExprLit(@codemap::Spanned {\n-                            node: ast::lit_bool(true), _}) =>\n-                        {\n-                            cx.span_lint(while_true, e.span,\n-                                         \"denote infinite loops with \\\n-                                          loop { ... }\");\n-                        }\n-                        _ => ()\n-                    }\n+fn check_while_true_expr(cx: &Context, e: &ast::Expr) {\n+    match e.node {\n+        ast::ExprWhile(cond, _) => {\n+            match cond.node {\n+                ast::ExprLit(@codemap::Spanned {\n+                    node: ast::lit_bool(true), _}) =>\n+                {\n+                    cx.span_lint(while_true, e.span,\n+                                 \"denote infinite loops with loop { ... }\");\n                 }\n                 _ => ()\n             }\n-            visit::walk_expr(self, e, cx);\n+        }\n+        _ => ()\n     }\n }\n \n-macro_rules! outer_lint_boilerplate_impl(\n-    ($Visitor:ident) =>\n-    (\n-        impl OuterLint for $Visitor {\n-            fn process_item(@mut self, i:@ast::item, e:@mut Context) {\n-                self.visit_item_action(i, e);\n-            }\n-            fn process_fn(@mut self, fk:&visit::fn_kind, fd:&ast::fn_decl,\n-                          b:&ast::Block, s:Span, n:ast::NodeId, e:@mut Context) {\n-                self.visit_fn_action(fk, fd, b, s, n, e);\n-            }\n-            fn inner_variant(@mut self) -> @mut InnerLint {\n-                @mut $Visitor { stopping_on_items: true } as @mut InnerLint\n+fn check_type_limits(cx: &Context, e: &ast::Expr) {\n+    return match e.node {\n+        ast::ExprBinary(_, binop, l, r) => {\n+            if is_comparison(binop) && !check_limits(cx.tcx, binop, l, r) {\n+                cx.span_lint(type_limits, e.span,\n+                             \"comparison is useless due to type limits\");\n             }\n         }\n-    ))\n-\n-outer_lint_boilerplate_impl!(WhileTrueLintVisitor)\n-\n-fn lint_while_true() -> @mut OuterLint {\n-    @mut WhileTrueLintVisitor{ stopping_on_items: false } as @mut OuterLint\n-}\n-\n-struct TypeLimitsLintVisitor { stopping_on_items: bool }\n-\n-impl SubitemStoppableVisitor for TypeLimitsLintVisitor {\n-    fn is_running_on_items(&mut self) -> bool { !self.stopping_on_items }\n-}\n+        _ => ()\n+    };\n \n-impl TypeLimitsLintVisitor {\n-    fn is_valid<T:cmp::Ord>(&mut self, binop: ast::BinOp, v: T,\n-            min: T, max: T) -> bool {\n+    fn is_valid<T:cmp::Ord>(binop: ast::BinOp, v: T,\n+                            min: T, max: T) -> bool {\n         match binop {\n             ast::BiLt => v <= max,\n             ast::BiLe => v < max,\n@@ -769,7 +526,7 @@ impl TypeLimitsLintVisitor {\n         }\n     }\n \n-    fn rev_binop(&mut self, binop: ast::BinOp) -> ast::BinOp {\n+    fn rev_binop(binop: ast::BinOp) -> ast::BinOp {\n         match binop {\n             ast::BiLt => ast::BiGt,\n             ast::BiLe => ast::BiGe,\n@@ -781,7 +538,7 @@ impl TypeLimitsLintVisitor {\n \n     // for int & uint, be conservative with the warnings, so that the\n     // warnings are consistent between 32- and 64-bit platforms\n-    fn int_ty_range(&mut self, int_ty: ast::int_ty) -> (i64, i64) {\n+    fn int_ty_range(int_ty: ast::int_ty) -> (i64, i64) {\n         match int_ty {\n             ast::ty_i =>    (i64::min_value,        i64::max_value),\n             ast::ty_i8 =>   (i8::min_value  as i64, i8::max_value  as i64),\n@@ -791,7 +548,7 @@ impl TypeLimitsLintVisitor {\n         }\n     }\n \n-    fn uint_ty_range(&mut self, uint_ty: ast::uint_ty) -> (u64, u64) {\n+    fn uint_ty_range(uint_ty: ast::uint_ty) -> (u64, u64) {\n         match uint_ty {\n             ast::ty_u =>   (u64::min_value,         u64::max_value),\n             ast::ty_u8 =>  (u8::min_value   as u64, u8::max_value   as u64),\n@@ -801,56 +558,48 @@ impl TypeLimitsLintVisitor {\n         }\n     }\n \n-    fn check_limits(&mut self,\n-                    cx: &Context,\n-                    binop: ast::BinOp,\n-                    l: @ast::Expr,\n-                    r: @ast::Expr)\n-                    -> bool {\n+    fn check_limits(tcx: ty::ctxt, binop: ast::BinOp,\n+                    l: &ast::Expr, r: &ast::Expr) -> bool {\n         let (lit, expr, swap) = match (&l.node, &r.node) {\n             (&ast::ExprLit(_), _) => (l, r, true),\n             (_, &ast::ExprLit(_)) => (r, l, false),\n             _ => return true\n         };\n         // Normalize the binop so that the literal is always on the RHS in\n         // the comparison\n-        let norm_binop = if swap {\n-            self.rev_binop(binop)\n-        } else {\n-            binop\n-        };\n-        match ty::get(ty::expr_ty(cx.tcx, expr)).sty {\n+        let norm_binop = if swap { rev_binop(binop) } else { binop };\n+        match ty::get(ty::expr_ty(tcx, expr)).sty {\n             ty::ty_int(int_ty) => {\n-                let (min, max) = self.int_ty_range(int_ty);\n+                let (min, max) = int_ty_range(int_ty);\n                 let lit_val: i64 = match lit.node {\n-                    ast::ExprLit(@li) => match li.node {\n+                    ast::ExprLit(li) => match li.node {\n                         ast::lit_int(v, _) => v,\n                         ast::lit_uint(v, _) => v as i64,\n                         ast::lit_int_unsuffixed(v) => v,\n                         _ => return true\n                     },\n                     _ => fail2!()\n                 };\n-                self.is_valid(norm_binop, lit_val, min, max)\n+                is_valid(norm_binop, lit_val, min, max)\n             }\n             ty::ty_uint(uint_ty) => {\n-                let (min, max): (u64, u64) = self.uint_ty_range(uint_ty);\n+                let (min, max): (u64, u64) = uint_ty_range(uint_ty);\n                 let lit_val: u64 = match lit.node {\n-                    ast::ExprLit(@li) => match li.node {\n+                    ast::ExprLit(li) => match li.node {\n                         ast::lit_int(v, _) => v as u64,\n                         ast::lit_uint(v, _) => v,\n                         ast::lit_int_unsuffixed(v) => v as u64,\n                         _ => return true\n                     },\n                     _ => fail2!()\n                 };\n-                self.is_valid(norm_binop, lit_val, min, max)\n+                is_valid(norm_binop, lit_val, min, max)\n             }\n             _ => true\n         }\n     }\n \n-    fn is_comparison(&mut self, binop: ast::BinOp) -> bool {\n+    fn is_comparison(binop: ast::BinOp) -> bool {\n         match binop {\n             ast::BiEq | ast::BiLt | ast::BiLe |\n             ast::BiNe | ast::BiGe | ast::BiGt => true,\n@@ -859,38 +608,6 @@ impl TypeLimitsLintVisitor {\n     }\n }\n \n-impl Visitor<@mut Context> for TypeLimitsLintVisitor {\n-    fn visit_item(&mut self, i:@ast::item, e:@mut Context) {\n-        self.OVERRIDE_visit_item(i, e);\n-    }\n-\n-    fn visit_fn(&mut self, fk:&visit::fn_kind, fd:&ast::fn_decl,\n-                b:&ast::Block, s:Span, n:ast::NodeId, e:@mut Context) {\n-        self.OVERRIDE_visit_fn(fk, fd, b, s, n, e);\n-    }\n-\n-    fn visit_expr(&mut self, e:@ast::Expr, cx:@mut Context) {\n-\n-            match e.node {\n-                ast::ExprBinary(_, ref binop, l, r) => {\n-                    if self.is_comparison(*binop)\n-                        && !self.check_limits(cx, *binop, l, r) {\n-                        cx.span_lint(type_limits, e.span,\n-                                     \"comparison is useless due to type limits\");\n-                    }\n-                }\n-                _ => ()\n-            }\n-            visit::walk_expr(self, e, cx);\n-    }\n-}\n-\n-outer_lint_boilerplate_impl!(TypeLimitsLintVisitor)\n-\n-fn lint_type_limits() -> @mut OuterLint {\n-    @mut TypeLimitsLintVisitor{ stopping_on_items: false } as @mut OuterLint\n-}\n-\n fn check_item_ctypes(cx: &Context, it: &ast::item) {\n     fn check_ty(cx: &Context, ty: &ast::Ty) {\n         match ty.node {\n@@ -936,133 +653,75 @@ fn check_item_ctypes(cx: &Context, it: &ast::item) {\n     }\n }\n \n-fn check_type_for_lint(cx: &Context, lint: lint, span: Span, ty: ty::t) {\n-    if cx.get_level(lint) == allow { return }\n-\n-    let mut n_box = 0;\n-    let mut n_uniq = 0;\n-    ty::fold_ty(cx.tcx, ty, |t| {\n-        match ty::get(t).sty {\n-          ty::ty_box(_) => n_box += 1,\n-          ty::ty_uniq(_) => n_uniq += 1,\n-          _ => ()\n-        };\n-        t\n-    });\n-\n-    if n_uniq > 0 && lint != managed_heap_memory {\n-        let s = ty_to_str(cx.tcx, ty);\n-        let m = ~\"type uses owned (~ type) pointers: \" + s;\n-        cx.span_lint(lint, span, m);\n-    }\n+fn check_heap_type(cx: &Context, span: Span, ty: ty::t) {\n+    let xs = [managed_heap_memory, owned_heap_memory, heap_memory];\n+    for &lint in xs.iter() {\n+        if cx.get_level(lint) == allow { continue }\n+\n+        let mut n_box = 0;\n+        let mut n_uniq = 0;\n+        ty::fold_ty(cx.tcx, ty, |t| {\n+            match ty::get(t).sty {\n+              ty::ty_box(_) => n_box += 1,\n+              ty::ty_uniq(_) => n_uniq += 1,\n+              _ => ()\n+            };\n+            t\n+        });\n \n-    if n_box > 0 && lint != owned_heap_memory {\n-        let s = ty_to_str(cx.tcx, ty);\n-        let m = ~\"type uses managed (@ type) pointers: \" + s;\n-        cx.span_lint(lint, span, m);\n-    }\n-}\n+        if n_uniq > 0 && lint != managed_heap_memory {\n+            let s = ty_to_str(cx.tcx, ty);\n+            let m = format!(\"type uses owned (~ type) pointers: {}\", s);\n+            cx.span_lint(lint, span, m);\n+        }\n \n-fn check_type(cx: &Context, span: Span, ty: ty::t) {\n-    let xs = [managed_heap_memory, owned_heap_memory, heap_memory];\n-    for lint in xs.iter() {\n-        check_type_for_lint(cx, *lint, span, ty);\n+        if n_box > 0 && lint != owned_heap_memory {\n+            let s = ty_to_str(cx.tcx, ty);\n+            let m = format!(\"type uses managed (@ type) pointers: {}\", s);\n+            cx.span_lint(lint, span, m);\n+        }\n     }\n }\n \n-fn check_item_heap(cx: &Context, it: &ast::item) {\n+fn check_heap_item(cx: &Context, it: &ast::item) {\n     match it.node {\n-      ast::item_fn(*) |\n-      ast::item_ty(*) |\n-      ast::item_enum(*) |\n-      ast::item_struct(*) => check_type(cx, it.span,\n-                                        ty::node_id_to_type(cx.tcx,\n-                                                            it.id)),\n-      _ => ()\n+        ast::item_fn(*) |\n+        ast::item_ty(*) |\n+        ast::item_enum(*) |\n+        ast::item_struct(*) => check_heap_type(cx, it.span,\n+                                               ty::node_id_to_type(cx.tcx,\n+                                                                   it.id)),\n+        _ => ()\n     }\n \n     // If it's a struct, we also have to check the fields' types\n     match it.node {\n         ast::item_struct(struct_def, _) => {\n             for struct_field in struct_def.fields.iter() {\n-                check_type(cx, struct_field.span,\n-                           ty::node_id_to_type(cx.tcx,\n-                                               struct_field.node.id));\n+                check_heap_type(cx, struct_field.span,\n+                                ty::node_id_to_type(cx.tcx,\n+                                                    struct_field.node.id));\n             }\n         }\n         _ => ()\n     }\n }\n \n-struct HeapLintVisitor { stopping_on_items: bool }\n-\n-impl SubitemStoppableVisitor for HeapLintVisitor {\n-    fn is_running_on_items(&mut self) -> bool { !self.stopping_on_items }\n-}\n-\n-impl Visitor<@mut Context> for HeapLintVisitor {\n-    fn visit_item(&mut self, i:@ast::item, e:@mut Context) {\n-        self.OVERRIDE_visit_item(i, e);\n-    }\n-\n-    fn visit_fn(&mut self, fk:&visit::fn_kind, fd:&ast::fn_decl,\n-                b:&ast::Block, s:Span, n:ast::NodeId, e:@mut Context) {\n-        self.OVERRIDE_visit_fn(fk, fd, b, s, n, e);\n-    }\n-\n-    fn visit_expr(&mut self, e:@ast::Expr, cx:@mut Context) {\n-            let ty = ty::expr_ty(cx.tcx, e);\n-            check_type(cx, e.span, ty);\n-            visit::walk_expr(self, e, cx);\n-    }\n-}\n-\n-outer_lint_boilerplate_impl!(HeapLintVisitor)\n-\n-fn lint_heap() -> @mut OuterLint {\n-    @mut HeapLintVisitor { stopping_on_items: false } as @mut OuterLint\n-}\n-\n-struct PathStatementLintVisitor {\n-    stopping_on_items: bool\n-}\n-\n-impl SubitemStoppableVisitor for PathStatementLintVisitor {\n-    fn is_running_on_items(&mut self) -> bool { !self.stopping_on_items }\n+fn check_heap_expr(cx: &Context, e: &ast::Expr) {\n+    let ty = ty::expr_ty(cx.tcx, e);\n+    check_heap_type(cx, e.span, ty);\n }\n \n-impl Visitor<@mut Context> for PathStatementLintVisitor {\n-    fn visit_item(&mut self, i:@ast::item, e:@mut Context) {\n-        self.OVERRIDE_visit_item(i, e);\n-    }\n-\n-    fn visit_fn(&mut self, fk:&visit::fn_kind, fd:&ast::fn_decl,\n-                b:&ast::Block, s:Span, n:ast::NodeId, e:@mut Context) {\n-        self.OVERRIDE_visit_fn(fk, fd, b, s, n, e);\n-    }\n-\n-    fn visit_stmt(&mut self, s:@ast::Stmt, cx:@mut Context) {\n-            match s.node {\n-                ast::StmtSemi(\n-                    @ast::Expr { node: ast::ExprPath(_), _ },\n-                    _\n-                ) => {\n-                    cx.span_lint(path_statement, s.span,\n-                                 \"path statement with no effect\");\n-                }\n-                _ => ()\n-            }\n-            visit::walk_stmt(self, s, cx);\n-\n+fn check_path_statement(cx: &Context, s: &ast::Stmt) {\n+    match s.node {\n+        ast::StmtSemi(@ast::Expr { node: ast::ExprPath(_), _ }, _) => {\n+            cx.span_lint(path_statement, s.span,\n+                         \"path statement with no effect\");\n+        }\n+        _ => ()\n     }\n }\n \n-outer_lint_boilerplate_impl!(PathStatementLintVisitor)\n-\n-fn lint_path_statement() -> @mut OuterLint {\n-    @mut PathStatementLintVisitor{ stopping_on_items: false } as @mut OuterLint\n-}\n-\n fn check_item_non_camel_case_types(cx: &Context, it: &ast::item) {\n     fn is_camel_case(cx: ty::ctxt, ident: ast::Ident) -> bool {\n         let ident = cx.sess.str_of(ident);\n@@ -1134,549 +793,393 @@ fn check_pat_non_uppercase_statics(cx: &Context, p: &ast::Pat) {\n     }\n }\n \n-struct UnusedUnsafeLintVisitor { stopping_on_items: bool }\n-\n-impl SubitemStoppableVisitor for UnusedUnsafeLintVisitor {\n-    fn is_running_on_items(&mut self) -> bool { !self.stopping_on_items }\n-}\n-\n-impl Visitor<@mut Context> for UnusedUnsafeLintVisitor {\n-    fn visit_item(&mut self, i:@ast::item, e:@mut Context) {\n-        self.OVERRIDE_visit_item(i, e);\n-    }\n-\n-    fn visit_fn(&mut self, fk:&visit::fn_kind, fd:&ast::fn_decl,\n-                b:&ast::Block, s:Span, n:ast::NodeId, e:@mut Context) {\n-        self.OVERRIDE_visit_fn(fk, fd, b, s, n, e);\n-    }\n-\n-    fn visit_expr(&mut self, e:@ast::Expr, cx:@mut Context) {\n-\n-            match e.node {\n-                // Don't warn about generated blocks, that'll just pollute the\n-                // output.\n-                ast::ExprBlock(ref blk) => {\n-                    if blk.rules == ast::UnsafeBlock(ast::UserProvided) &&\n-                       !cx.tcx.used_unsafe.contains(&blk.id) {\n-                        cx.span_lint(unused_unsafe, blk.span,\n-                                     \"unnecessary `unsafe` block\");\n-                    }\n-                }\n-                _ => ()\n-            }\n-            visit::walk_expr(self, e, cx);\n-    }\n-}\n-\n-outer_lint_boilerplate_impl!(UnusedUnsafeLintVisitor)\n-\n-fn lint_unused_unsafe() -> @mut OuterLint {\n-    @mut UnusedUnsafeLintVisitor{ stopping_on_items: false } as @mut OuterLint\n-}\n-\n-struct UnusedMutLintVisitor { stopping_on_items: bool }\n-\n-impl UnusedMutLintVisitor {\n-    fn check_pat(&mut self, cx: &Context, p: @ast::Pat) {\n-        let mut used = false;\n-        let mut bindings = 0;\n-        do pat_util::pat_bindings(cx.tcx.def_map, p) |_, id, _, _| {\n-            used = used || cx.tcx.used_mut_nodes.contains(&id);\n-            bindings += 1;\n-        }\n-        if !used {\n-            let msg = if bindings == 1 {\n-                \"variable does not need to be mutable\"\n-            } else {\n-                \"variables do not need to be mutable\"\n-            };\n-            cx.span_lint(unused_mut, p.span, msg);\n-        }\n-    }\n-\n-    fn visit_fn_decl(&mut self, cx: &Context, fd: &ast::fn_decl) {\n-        for arg in fd.inputs.iter() {\n-            if arg.is_mutbl {\n-                self.check_pat(cx, arg.pat);\n+fn check_unused_unsafe(cx: &Context, e: &ast::Expr) {\n+    match e.node {\n+        // Don't warn about generated blocks, that'll just pollute the\n+        // output.\n+        ast::ExprBlock(ref blk) => {\n+            if blk.rules == ast::UnsafeBlock(ast::UserProvided) &&\n+                !cx.tcx.used_unsafe.contains(&blk.id) {\n+                cx.span_lint(unused_unsafe, blk.span,\n+                             \"unnecessary `unsafe` block\");\n             }\n         }\n+        _ => ()\n     }\n }\n \n-impl SubitemStoppableVisitor for UnusedMutLintVisitor {\n-    fn is_running_on_items(&mut self) -> bool { !self.stopping_on_items }\n-\n-    fn visit_fn_action(&mut self, _a:&visit::fn_kind, fd:&ast::fn_decl,\n-                       _b:&ast::Block, _c:Span, _d:ast::NodeId, cx:@mut Context) {\n-            self.visit_fn_decl(cx, fd);\n-    }\n-}\n-\n-impl Visitor<@mut Context> for UnusedMutLintVisitor {\n-    fn visit_item(&mut self, i:@ast::item, e:@mut Context) {\n-        self.OVERRIDE_visit_item(i, e);\n-    }\n-\n-    fn visit_fn(&mut self, fk:&visit::fn_kind, fd:&ast::fn_decl,\n-                b:&ast::Block, s:Span, n:ast::NodeId, e:@mut Context) {\n-        self.OVERRIDE_visit_fn(fk, fd, b, s, n, e);\n+fn check_unused_mut_pat(cx: &Context, p: @ast::Pat) {\n+    let mut used = false;\n+    let mut bindings = 0;\n+    do pat_util::pat_bindings(cx.tcx.def_map, p) |_, id, _, _| {\n+        used = used || cx.tcx.used_mut_nodes.contains(&id);\n+        bindings += 1;\n     }\n-\n-\n-    fn visit_local(&mut self, l:@ast::Local, cx:@mut Context) {\n-            if l.is_mutbl {\n-                self.check_pat(cx, l.pat);\n-            }\n-            visit::walk_local(self, l, cx);\n-    }\n-\n-    fn visit_ty_method(&mut self, tm:&ast::TypeMethod, cx:@mut Context) {\n-            self.visit_fn_decl(cx, &tm.decl);\n-            visit::walk_ty_method(self, tm, cx);\n-    }\n-\n-    fn visit_trait_method(&mut self, tm:&ast::trait_method, cx:@mut Context) {\n-            match *tm {\n-                ast::required(ref tm) => self.visit_fn_decl(cx, &tm.decl),\n-                ast::provided(m) => self.visit_fn_decl(cx, &m.decl)\n-            }\n-            visit::walk_trait_method(self, tm, cx);\n+    if !used {\n+        let msg = if bindings == 1 {\n+            \"variable does not need to be mutable\"\n+        } else {\n+            \"variables do not need to be mutable\"\n+        };\n+        cx.span_lint(unused_mut, p.span, msg);\n     }\n }\n \n-outer_lint_boilerplate_impl!(UnusedMutLintVisitor)\n-\n-fn lint_unused_mut() -> @mut OuterLint {\n-    @mut UnusedMutLintVisitor{ stopping_on_items: false } as @mut OuterLint\n-}\n-\n-struct LintReportingIdVisitor {\n-    cx: @mut Context,\n-}\n-\n-impl ast_util::IdVisitingOperation for LintReportingIdVisitor {\n-    fn visit_id(&self, id: ast::NodeId) {\n-        match self.cx.tcx.sess.lints.pop(&id) {\n-            None => {}\n-            Some(l) => {\n-                for (lint, span, msg) in l.move_iter() {\n-                    self.cx.span_lint(lint, span, msg)\n-                }\n-            }\n+fn check_unused_mut_fn_decl(cx: &Context, fd: &ast::fn_decl) {\n+    for arg in fd.inputs.iter() {\n+        if arg.is_mutbl {\n+            check_unused_mut_pat(cx, arg.pat);\n         }\n     }\n }\n \n-fn lint_session(cx: @mut Context) -> @mut visit::Visitor<()> {\n-    ast_util::id_visitor(@LintReportingIdVisitor {\n-        cx: cx,\n-    } as @ast_util::IdVisitingOperation, false)\n-}\n-\n-struct UnnecessaryAllocationLintVisitor { stopping_on_items: bool }\n-\n-impl SubitemStoppableVisitor for UnnecessaryAllocationLintVisitor {\n-    fn is_running_on_items(&mut self) -> bool { !self.stopping_on_items }\n-}\n-\n-impl Visitor<@mut Context> for UnnecessaryAllocationLintVisitor {\n-    fn visit_item(&mut self, i:@ast::item, e:@mut Context) {\n-        self.OVERRIDE_visit_item(i, e);\n-    }\n-\n-    fn visit_fn(&mut self, fk:&visit::fn_kind, fd:&ast::fn_decl,\n-                b:&ast::Block, s:Span, n:ast::NodeId, e:@mut Context) {\n-        self.OVERRIDE_visit_fn(fk, fd, b, s, n, e);\n-    }\n-\n-    fn visit_expr(&mut self, e:@ast::Expr, cx:@mut Context) {\n-            self.check(cx, e);\n-            visit::walk_expr(self, e, cx);\n-    }\n-}\n-\n-impl UnnecessaryAllocationLintVisitor {\n+fn check_unnecessary_allocation(cx: &Context, e: &ast::Expr) {\n     // Warn if string and vector literals with sigils are immediately borrowed.\n     // Those can have the sigil removed.\n-    fn check(&mut self, cx: &Context, e: &ast::Expr) {\n-        match e.node {\n-            ast::ExprVstore(e2, ast::ExprVstoreUniq) |\n-            ast::ExprVstore(e2, ast::ExprVstoreBox) => {\n-                match e2.node {\n-                    ast::ExprLit(@codemap::Spanned{\n-                            node: ast::lit_str(*), _}) |\n-                    ast::ExprVec(*) => {}\n-                    _ => return\n-                }\n+    match e.node {\n+        ast::ExprVstore(e2, ast::ExprVstoreUniq) |\n+        ast::ExprVstore(e2, ast::ExprVstoreBox) => {\n+            match e2.node {\n+                ast::ExprLit(@codemap::Spanned{node: ast::lit_str(*), _}) |\n+                ast::ExprVec(*) => {}\n+                _ => return\n             }\n-\n-            _ => return\n         }\n \n-        match cx.tcx.adjustments.find_copy(&e.id) {\n-            Some(@ty::AutoDerefRef(ty::AutoDerefRef {\n-                autoref: Some(ty::AutoBorrowVec(*)), _ })) => {\n-                cx.span_lint(unnecessary_allocation,\n-                             e.span, \"unnecessary allocation, the sigil can be \\\n-                                      removed\");\n-            }\n-\n-            _ => ()\n-        }\n+        _ => return\n     }\n-}\n \n-outer_lint_boilerplate_impl!(UnnecessaryAllocationLintVisitor)\n+    match cx.tcx.adjustments.find_copy(&e.id) {\n+        Some(@ty::AutoDerefRef(ty::AutoDerefRef {\n+            autoref: Some(ty::AutoBorrowVec(*)), _ })) => {\n+            cx.span_lint(unnecessary_allocation, e.span,\n+                         \"unnecessary allocation, the sigil can be removed\");\n+        }\n \n-fn lint_unnecessary_allocations() -> @mut OuterLint {\n-    @mut UnnecessaryAllocationLintVisitor{ stopping_on_items: false } as @mut OuterLint\n+        _ => ()\n+    }\n }\n \n-struct MissingDocLintVisitor { stopping_on_items: bool }\n+struct MissingDocLintVisitor(ty::ctxt);\n \n impl MissingDocLintVisitor {\n-    fn check_attrs(&mut self,\n-                   cx: @mut Context,\n-                   attrs: &[ast::Attribute],\n-                   sp: Span,\n-                   msg: &str) {\n-        // If we're building a test harness, then warning about documentation is\n-        // probably not really relevant right now\n-        if cx.tcx.sess.opts.test { return }\n-        // If we have doc(hidden), nothing to do\n-        if cx.doc_hidden { return }\n-        // If we're documented, nothing to do\n-        if attrs.iter().any(|a| a.node.is_sugared_doc) { return }\n-\n-        // otherwise, warn!\n-        cx.span_lint(missing_doc, sp, msg);\n+    fn check_attrs(&self, attrs: &[ast::Attribute], id: ast::NodeId,\n+                   sp: Span, msg: ~str) {\n+        if !attrs.iter().any(|a| a.node.is_sugared_doc) {\n+            self.sess.add_lint(missing_doc, id, sp, msg);\n+        }\n     }\n \n-    fn check_struct(&mut self, cx: @mut Context, sdef: @ast::struct_def) {\n-                        for field in sdef.fields.iter() {\n-        match field.node.kind {\n-            ast::named_field(_, vis) if vis != ast::private => {\n-                self.check_attrs(cx, field.node.attrs, field.span,\n-                        \"missing documentation for a field\");\n+    fn check_struct(&self, sdef: &ast::struct_def) {\n+        for field in sdef.fields.iter() {\n+            match field.node.kind {\n+                ast::named_field(_, vis) if vis != ast::private => {\n+                    self.check_attrs(field.node.attrs, field.node.id, field.span,\n+                                     ~\"missing documentation for a field\");\n                 }\n                 ast::unnamed_field | ast::named_field(*) => {}\n             }\n         }\n     }\n-}\n \n-impl Visitor<@mut Context> for MissingDocLintVisitor {\n-    fn visit_item(&mut self, i:@ast::item, e:@mut Context) {\n-        self.OVERRIDE_visit_item(i, e);\n+    fn doc_hidden(&self, attrs: &[ast::Attribute]) -> bool {\n+        do attrs.iter().any |attr| {\n+            \"doc\" == attr.name() &&\n+                match attr.meta_item_list() {\n+                    Some(l) => attr::contains_name(l, \"hidden\"),\n+                    None    => false // not of the form #[doc(...)]\n+                }\n+        }\n     }\n+}\n \n-    fn visit_fn(&mut self, fk:&visit::fn_kind, fd:&ast::fn_decl,\n-                b:&ast::Block, s:Span, n:ast::NodeId, e:@mut Context) {\n-        self.OVERRIDE_visit_fn(fk, fd, b, s, n, e);\n-    }\n+impl Visitor<()> for MissingDocLintVisitor {\n+    fn visit_ty_method(&mut self, m:&ast::TypeMethod, _: ()) {\n+        if self.doc_hidden(m.attrs) { return }\n \n-    fn visit_ty_method(&mut self, m:&ast::TypeMethod, cx:@mut Context) {\n-            // All ty_method objects are linted about because they're part of a\n-            // trait (no visibility)\n-            self.check_attrs(cx, m.attrs, m.span,\n-                        \"missing documentation for a method\");\n-            visit::walk_ty_method(self, m, cx);\n+        // All ty_method objects are linted about because they're part of a\n+        // trait (no visibility)\n+        self.check_attrs(m.attrs, m.id, m.span,\n+                         ~\"missing documentation for a method\");\n+        visit::walk_ty_method(self, m, ());\n     }\n-}\n \n-impl SubitemStoppableVisitor for MissingDocLintVisitor {\n-    fn is_running_on_items(&mut self) -> bool { !self.stopping_on_items }\n-\n-    fn visit_fn_action(&mut self, fk:&visit::fn_kind, _d:&ast::fn_decl,\n-                       _b:&ast::Block, sp:Span, _id:ast::NodeId, cx:@mut Context) {\n-\n-            // Only warn about explicitly public methods. Soon implicit\n-            // public-ness will hopefully be going away.\n-            match *fk {\n-                visit::fk_method(_, _, m) if m.vis == ast::public => {\n-                    // If we're in a trait implementation, no need to duplicate\n-                    // documentation\n-                    if !cx.in_trait_impl {\n-                        self.check_attrs(cx, m.attrs, sp,\n-                                    \"missing documentation for a method\");\n-                    }\n+    fn visit_fn(&mut self, fk: &visit::fn_kind, d: &ast::fn_decl,\n+                b: &ast::Block, sp: Span, id: ast::NodeId, _: ()) {\n+        // Only warn about explicitly public methods.\n+        match *fk {\n+            visit::fk_method(_, _, m) => {\n+                if self.doc_hidden(m.attrs) {\n+                    return;\n+                }\n+                // If we're in a trait implementation, no need to duplicate\n+                // documentation\n+                if m.vis == ast::public {\n+                    self.check_attrs(m.attrs, id, sp,\n+                                     ~\"missing documentation for a method\");\n                 }\n-\n-                _ => {}\n             }\n+            _ => {}\n+        }\n+        visit::walk_fn(self, fk, d, b, sp, id, ());\n     }\n \n-    fn visit_item_action(&mut self, it:@ast::item, cx:@mut Context) {\n-            if it.vis != ast::public {\n-                return;\n+    fn visit_item(&mut self, it: @ast::item, _: ()) {\n+        // If we're building a test harness, then warning about documentation is\n+        // probably not really relevant right now\n+        if self.sess.opts.test { return }\n+        if self.doc_hidden(it.attrs) { return }\n+\n+        match it.node {\n+            ast::item_struct(sdef, _) if it.vis == ast::public => {\n+                self.check_attrs(it.attrs, it.id, it.span,\n+                                 ~\"missing documentation for a struct\");\n+                self.check_struct(sdef);\n             }\n \n-            match it.node {\n-                // Go ahead and match the fields here instead of using\n-                // visit_struct_field while we have access to the enclosing\n-                // struct's visibility\n-                ast::item_struct(sdef, _) => {\n-                    self.check_attrs(cx, it.attrs, it.span,\n-                                \"missing documentation for a struct\");\n-                    self.check_struct(cx, sdef);\n-                }\n-\n-                ast::item_trait(*) => {\n-                    self.check_attrs(cx, it.attrs, it.span,\n-                                \"missing documentation for a trait\");\n-                }\n+            // Skip implementations because they inherit documentation from the\n+            // trait (which was already linted)\n+            ast::item_impl(_, Some(*), _, _) => return,\n \n-                ast::item_fn(*) => {\n-                    self.check_attrs(cx, it.attrs, it.span,\n-                                \"missing documentation for a function\");\n-                }\n+            ast::item_trait(*) if it.vis == ast::public => {\n+                self.check_attrs(it.attrs, it.id, it.span,\n+                                 ~\"missing documentation for a trait\");\n+            }\n \n-                ast::item_enum(ref edef, _) => {\n-                    self.check_attrs(cx, it.attrs, it.span,\n-                                \"missing documentation for an enum\");\n-                    for variant in edef.variants.iter() {\n-                        if variant.node.vis == ast::private {\n-                            continue;\n-                        }\n+            ast::item_fn(*) if it.vis == ast::public => {\n+                self.check_attrs(it.attrs, it.id, it.span,\n+                                 ~\"missing documentation for a function\");\n+            }\n \n-                        self.check_attrs(cx, variant.node.attrs, variant.span,\n-                                        \"missing documentation for a variant\");\n-                        match variant.node.kind {\n-                            ast::struct_variant_kind(sdef) => {\n-                                self.check_struct(cx, sdef);\n-                            }\n-                            _ => ()\n+            ast::item_enum(ref edef, _) if it.vis == ast::public => {\n+                self.check_attrs(it.attrs, it.id, it.span,\n+                                 ~\"missing documentation for an enum\");\n+                for variant in edef.variants.iter() {\n+                    if variant.node.vis == ast::private { continue; }\n+\n+                    self.check_attrs(variant.node.attrs, variant.node.id,\n+                                     variant.span,\n+                                     ~\"missing documentation for a variant\");\n+                    match variant.node.kind {\n+                        ast::struct_variant_kind(sdef) => {\n+                            self.check_struct(sdef);\n                         }\n+                        _ => ()\n                     }\n                 }\n-\n-                _ => {}\n             }\n-    }\n-}\n-\n-outer_lint_boilerplate_impl!(MissingDocLintVisitor)\n \n-fn lint_missing_doc() -> @mut OuterLint {\n-    @mut MissingDocLintVisitor { stopping_on_items: false } as @mut OuterLint\n+            _ => {}\n+        }\n+        visit::walk_item(self, it, ());\n+    }\n }\n \n /// Checks for use of items with #[deprecated], #[experimental] and\n /// #[unstable] (or none of them) attributes.\n-struct StabilityLintVisitor { stopping_on_items: bool }\n-\n-impl StabilityLintVisitor {\n-    fn handle_def(&mut self, sp: Span, def: &ast::Def, cx: @mut Context) {\n-        let id = ast_util::def_id_of_def(*def);\n-\n-        let stability = if ast_util::is_local(id) {\n-            // this crate\n-            match cx.tcx.items.find(&id.node) {\n-                Some(ast_node) => {\n-                    let s = do ast_node.with_attrs |attrs| {\n-                        do attrs.map_move |a| {\n-                            attr::find_stability(a.iter().map(|a| a.meta()))\n-                        }\n-                    };\n-                    match s {\n-                        Some(s) => s,\n-\n-                        // no possibility of having attributes\n-                        // (e.g. it's a local variable), so just\n-                        // ignore it.\n-                        None => return\n+fn check_stability(cx: &Context, e: &ast::Expr) {\n+    let def = match e.node {\n+        ast::ExprMethodCall(*) |\n+        ast::ExprPath(*) |\n+        ast::ExprStruct(*) => {\n+            match cx.tcx.def_map.find(&e.id) {\n+                Some(&def) => def,\n+                None => return\n+            }\n+        }\n+        _ => return\n+    };\n+\n+    let id = ast_util::def_id_of_def(def);\n+\n+    let stability = if ast_util::is_local(id) {\n+        // this crate\n+        match cx.tcx.items.find(&id.node) {\n+            Some(ast_node) => {\n+                let s = do ast_node.with_attrs |attrs| {\n+                    do attrs.map_move |a| {\n+                        attr::find_stability(a.iter().map(|a| a.meta()))\n                     }\n+                };\n+                match s {\n+                    Some(s) => s,\n+\n+                    // no possibility of having attributes\n+                    // (e.g. it's a local variable), so just\n+                    // ignore it.\n+                    None => return\n                 }\n-                _ => cx.tcx.sess.bug(format!(\"handle_def: {:?} not found\", id))\n             }\n-        } else {\n-            // cross-crate\n-\n-            let mut s = None;\n-            // run through all the attributes and take the first\n-            // stability one.\n-            do csearch::get_item_attrs(cx.tcx.cstore, id) |meta_items| {\n-                if s.is_none() {\n-                    s = attr::find_stability(meta_items.move_iter())\n-                }\n+            _ => cx.tcx.sess.bug(format!(\"handle_def: {:?} not found\", id))\n+        }\n+    } else {\n+        // cross-crate\n+\n+        let mut s = None;\n+        // run through all the attributes and take the first\n+        // stability one.\n+        do csearch::get_item_attrs(cx.tcx.cstore, id) |meta_items| {\n+            if s.is_none() {\n+                s = attr::find_stability(meta_items.move_iter())\n             }\n-            s\n-        };\n+        }\n+        s\n+    };\n \n-        let (lint, label) = match stability {\n-            // no stability attributes == Unstable\n-            None => (unstable, \"unmarked\"),\n-            Some(attr::Stability { level: attr::Unstable, _ }) => (unstable, \"unstable\"),\n-            Some(attr::Stability { level: attr::Experimental, _ }) => {\n-                (experimental, \"experimental\")\n-            }\n-            Some(attr::Stability { level: attr::Deprecated, _ }) => (deprecated, \"deprecated\"),\n-            _ => return\n-        };\n+    let (lint, label) = match stability {\n+        // no stability attributes == Unstable\n+        None => (unstable, \"unmarked\"),\n+        Some(attr::Stability { level: attr::Unstable, _ }) =>\n+                (unstable, \"unstable\"),\n+        Some(attr::Stability { level: attr::Experimental, _ }) =>\n+                (experimental, \"experimental\"),\n+        Some(attr::Stability { level: attr::Deprecated, _ }) =>\n+                (deprecated, \"deprecated\"),\n+        _ => return\n+    };\n \n-        let msg = match stability {\n-            Some(attr::Stability { text: Some(ref s), _ }) => {\n-                format!(\"use of {} item: {}\", label, *s)\n-            }\n-            _ => format!(\"use of {} item\", label)\n-        };\n+    let msg = match stability {\n+        Some(attr::Stability { text: Some(ref s), _ }) => {\n+            format!(\"use of {} item: {}\", label, *s)\n+        }\n+        _ => format!(\"use of {} item\", label)\n+    };\n \n-        cx.span_lint(lint, sp, msg);\n-    }\n+    cx.span_lint(lint, e.span, msg);\n }\n \n-impl SubitemStoppableVisitor for StabilityLintVisitor {\n-    fn is_running_on_items(&mut self) -> bool { !self.stopping_on_items }\n-}\n+impl Visitor<()> for Context {\n+    fn visit_item(&mut self, it: @ast::item, _: ()) {\n+        do self.with_lint_attrs(it.attrs) |cx| {\n+            check_item_ctypes(cx, it);\n+            check_item_non_camel_case_types(cx, it);\n+            check_item_non_uppercase_statics(cx, it);\n+            check_heap_item(cx, it);\n+\n+            do cx.visit_ids |v| {\n+                v.visit_item(it, ());\n+            }\n \n-impl Visitor<@mut Context> for StabilityLintVisitor {\n-    fn visit_item(&mut self, i:@ast::item, e:@mut Context) {\n-        self.OVERRIDE_visit_item(i, e);\n+            visit::walk_item(cx, it, ());\n+        }\n     }\n \n-    fn visit_fn(&mut self, fk:&visit::fn_kind, fd:&ast::fn_decl,\n-                b:&ast::Block, s:Span, n:ast::NodeId, e:@mut Context) {\n-        self.OVERRIDE_visit_fn(fk, fd, b, s, n, e);\n+    fn visit_pat(&mut self, p: @ast::Pat, _: ()) {\n+        check_pat_non_uppercase_statics(self, p);\n+        visit::walk_pat(self, p, ());\n     }\n \n-    fn visit_expr(&mut self, ex: @ast::Expr, cx: @mut Context) {\n-        match ex.node {\n-            ast::ExprMethodCall(*) |\n-            ast::ExprPath(*) |\n-            ast::ExprStruct(*) => {\n-                match cx.tcx.def_map.find(&ex.id) {\n-                    Some(def) => self.handle_def(ex.span, def, cx),\n-                    None => {}\n-                }\n-            }\n-            _ => {}\n-        }\n+    fn visit_expr(&mut self, e: @ast::Expr, _: ()) {\n+        check_while_true_expr(self, e);\n+        check_stability(self, e);\n+        check_unused_unsafe(self, e);\n+        check_unnecessary_allocation(self, e);\n+        check_heap_expr(self, e);\n+        check_type_limits(self, e);\n \n-        visit::walk_expr(self, ex, cx)\n+        visit::walk_expr(self, e, ());\n     }\n-}\n \n-outer_lint_boilerplate_impl!(StabilityLintVisitor)\n+    fn visit_stmt(&mut self, s: @ast::Stmt, _: ()) {\n+        check_path_statement(self, s);\n \n-fn lint_stability() -> @mut OuterLint {\n-    @mut StabilityLintVisitor { stopping_on_items: false } as @mut OuterLint\n-}\n+        visit::walk_stmt(self, s, ());\n+    }\n \n-struct LintCheckVisitor;\n+    fn visit_ty_method(&mut self, tm: &ast::TypeMethod, _: ()) {\n+        check_unused_mut_fn_decl(self, &tm.decl);\n+        visit::walk_ty_method(self, tm, ());\n+    }\n \n-impl Visitor<@mut Context> for LintCheckVisitor {\n+    fn visit_trait_method(&mut self, tm: &ast::trait_method, _: ()) {\n+        match *tm {\n+            ast::required(ref m) => check_unused_mut_fn_decl(self, &m.decl),\n+            ast::provided(ref m) => check_unused_mut_fn_decl(self, &m.decl)\n+        }\n+        visit::walk_trait_method(self, tm, ());\n+    }\n \n-    fn visit_pat(&mut self, p:@ast::Pat, cx: @mut Context) {\n-        check_pat_non_uppercase_statics(cx, p);\n-        visit::walk_pat(self, p, cx);\n+    fn visit_local(&mut self, l: @ast::Local, _: ()) {\n+        if l.is_mutbl {\n+            check_unused_mut_pat(self, l.pat);\n+        }\n+        visit::walk_local(self, l, ());\n     }\n \n-    fn visit_item(&mut self, it:@ast::item, cx: @mut Context) {\n+    fn visit_fn(&mut self, fk: &visit::fn_kind, decl: &ast::fn_decl,\n+                body: &ast::Block, span: Span, id: ast::NodeId, _: ()) {\n+        let recurse = |this: &mut Context| {\n+            check_unused_mut_fn_decl(this, decl);\n+            visit::walk_fn(this, fk, decl, body, span, id, ());\n+        };\n \n-                do cx.with_lint_attrs(it.attrs) {\n-                    match it.node {\n-                        ast::item_impl(_, Some(*), _, _) => {\n-                            cx.in_trait_impl = true;\n-                        }\n-                        _ => {}\n+        match *fk {\n+            visit::fk_method(_, _, m) => {\n+                do self.with_lint_attrs(m.attrs) |cx| {\n+                    do cx.visit_ids |v| {\n+                        v.visit_fn(fk, decl, body, span, id, ());\n                     }\n-                    check_item_ctypes(cx, it);\n-                    check_item_non_camel_case_types(cx, it);\n-                    check_item_non_uppercase_statics(cx, it);\n-                    check_item_heap(cx, it);\n-\n-                    cx.process(Item(it));\n-                    visit::walk_item(self, it, cx);\n-                    cx.in_trait_impl = false;\n+                    recurse(cx);\n                 }\n+            }\n+            _ => recurse(self),\n+        }\n     }\n+}\n \n-    fn visit_fn(&mut self, fk:&visit::fn_kind, decl:&ast::fn_decl,\n-                body:&ast::Block, span:Span, id:ast::NodeId, cx:@mut Context) {\n-\n-                match *fk {\n-                    visit::fk_method(_, _, m) => {\n-                        do cx.with_lint_attrs(m.attrs) {\n-                            cx.process(Method(m));\n-                            visit::walk_fn(self,\n-                                               fk,\n-                                               decl,\n-                                               body,\n-                                               span,\n-                                               id,\n-                                               cx);\n-                        }\n-                    }\n-                    _ => {\n-                        visit::walk_fn(self,\n-                                           fk,\n-                                           decl,\n-                                           body,\n-                                           span,\n-                                           id,\n-                                           cx);\n-                    }\n+impl ast_util::IdVisitingOperation for Context {\n+    fn visit_id(&self, id: ast::NodeId) {\n+        match self.tcx.sess.lints.pop(&id) {\n+            None => {}\n+            Some(l) => {\n+                for (lint, span, msg) in l.move_iter() {\n+                    self.span_lint(lint, span, msg)\n                 }\n+            }\n+        }\n     }\n }\n \n pub fn check_crate(tcx: ty::ctxt, crate: &ast::Crate) {\n-    let cx = @mut Context {\n+    // This visitor contains more state than is currently maintained in Context,\n+    // and there's no reason for the Context to keep track of this information\n+    // really\n+    let mut dox = MissingDocLintVisitor(tcx);\n+    visit::walk_crate(&mut dox, crate, ());\n+\n+    let mut cx = Context {\n         dict: @get_lint_dict(),\n-        curr: SmallIntMap::new(),\n+        cur: SmallIntMap::new(),\n         tcx: tcx,\n         lint_stack: ~[],\n-        visitors: ~[],\n-        in_trait_impl: false,\n-        doc_hidden: false,\n     };\n \n-    // Install defaults.\n+    // Install default lint levels, followed by the command line levels, and\n+    // then actually visit the whole crate.\n     for (_, spec) in cx.dict.iter() {\n         cx.set_level(spec.lint, spec.default, Default);\n     }\n-\n-    // Install command-line options, overriding defaults.\n     for &(lint, level) in tcx.sess.opts.lint_opts.iter() {\n         cx.set_level(lint, level, CommandLine);\n     }\n-\n-    // Register each of the lint passes with the context\n-    cx.add_old_lint(lint_while_true());\n-    cx.add_old_lint(lint_path_statement());\n-    cx.add_old_lint(lint_heap());\n-    cx.add_old_lint(lint_type_limits());\n-    cx.add_old_lint(lint_unused_unsafe());\n-    cx.add_old_lint(lint_unused_mut());\n-    cx.add_old_lint(lint_unnecessary_allocations());\n-    cx.add_old_lint(lint_missing_doc());\n-    cx.add_old_lint(lint_stability());\n-    cx.add_lint(lint_session(cx));\n-\n-    // Actually perform the lint checks (iterating the ast)\n-    do cx.with_lint_attrs(crate.attrs) {\n-        cx.process(Crate(crate));\n-\n-        let mut visitor = LintCheckVisitor;\n-\n-        visit::walk_crate(&mut visitor, crate, cx);\n+    do cx.with_lint_attrs(crate.attrs) |cx| {\n+        do cx.visit_ids |v| {\n+            v.visited_outermost = true;\n+            visit::walk_crate(v, crate, ());\n+        }\n+        visit::walk_crate(cx, crate, ());\n     }\n \n     // If we missed any lints added to the session, then there's a bug somewhere\n     // in the iteration code.\n     for (id, v) in tcx.sess.lints.iter() {\n-        for t in v.iter() {\n-            match *t {\n-                (lint, span, ref msg) =>\n-                    tcx.sess.span_bug(span, format!(\"unprocessed lint {:?} at {}: \\\n-                                                  {}\",\n-                                                 lint,\n-                                                 ast_map::node_id_to_str(\n-                                                 tcx.items,\n-                                                 *id,\n-                                                 token::get_ident_interner()),\n-                                                 *msg))\n-            }\n+        for &(lint, span, ref msg) in v.iter() {\n+            tcx.sess.span_bug(span, format!(\"unprocessed lint {:?} at {}: {}\",\n+                                            lint,\n+                                            ast_map::node_id_to_str(tcx.items,\n+                                                *id,\n+                                                token::get_ident_interner()),\n+                                            *msg))\n         }\n     }\n "}, {"sha": "2c01f246c5f3d435a6ae48bd7ef2375441f044cf", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 17, "deletions": 23, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/c0388cd69166f22c818eab21c40c0a37cc1d70a8/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0388cd69166f22c818eab21c40c0a37cc1d70a8/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=c0388cd69166f22c818eab21c40c0a37cc1d70a8", "patch": "@@ -397,27 +397,17 @@ impl id_range {\n     }\n }\n \n-pub fn id_visitor(operation: @IdVisitingOperation, pass_through_items: bool)\n-                  -> @mut Visitor<()> {\n-    let visitor = @mut IdVisitor {\n-        operation: operation,\n-        pass_through_items: pass_through_items,\n-        visited_outermost: false,\n-    };\n-    visitor as @mut Visitor<()>\n-}\n-\n pub trait IdVisitingOperation {\n     fn visit_id(&self, node_id: NodeId);\n }\n \n-pub struct IdVisitor {\n-    operation: @IdVisitingOperation,\n+pub struct IdVisitor<'self, O> {\n+    operation: &'self O,\n     pass_through_items: bool,\n     visited_outermost: bool,\n }\n \n-impl IdVisitor {\n+impl<'self, O: IdVisitingOperation> IdVisitor<'self, O> {\n     fn visit_generics_helper(&self, generics: &Generics) {\n         for type_parameter in generics.ty_params.iter() {\n             self.operation.visit_id(type_parameter.id)\n@@ -428,7 +418,7 @@ impl IdVisitor {\n     }\n }\n \n-impl Visitor<()> for IdVisitor {\n+impl<'self, O: IdVisitingOperation> Visitor<()> for IdVisitor<'self, O> {\n     fn visit_mod(&mut self,\n                  module: &_mod,\n                  _: Span,\n@@ -601,10 +591,18 @@ impl Visitor<()> for IdVisitor {\n         struct_def.ctor_id.map(|&ctor_id| self.operation.visit_id(ctor_id));\n         visit::walk_struct_def(self, struct_def, ident, generics, id, ());\n     }\n+\n+    fn visit_trait_method(&mut self, tm: &ast::trait_method, _: ()) {\n+        match *tm {\n+            ast::required(ref m) => self.operation.visit_id(m.id),\n+            ast::provided(ref m) => self.operation.visit_id(m.id),\n+        }\n+        visit::walk_trait_method(self, tm, ());\n+    }\n }\n \n-pub fn visit_ids_for_inlined_item(item: &inlined_item,\n-                                  operation: @IdVisitingOperation) {\n+pub fn visit_ids_for_inlined_item<O: IdVisitingOperation>(item: &inlined_item,\n+                                                          operation: &O) {\n     let mut id_visitor = IdVisitor {\n         operation: operation,\n         pass_through_items: true,\n@@ -623,18 +621,14 @@ impl IdVisitingOperation for IdRangeComputingVisitor {\n     }\n }\n \n-pub fn compute_id_range(visit_ids_fn: &fn(@IdVisitingOperation)) -> id_range {\n+pub fn compute_id_range_for_inlined_item(item: &inlined_item) -> id_range {\n     let result = @mut id_range::max();\n-    visit_ids_fn(@IdRangeComputingVisitor {\n+    visit_ids_for_inlined_item(item, &IdRangeComputingVisitor {\n         result: result,\n-    } as @IdVisitingOperation);\n+    });\n     *result\n }\n \n-pub fn compute_id_range_for_inlined_item(item: &inlined_item) -> id_range {\n-    compute_id_range(|f| visit_ids_for_inlined_item(item, f))\n-}\n-\n pub fn is_item_impl(item: @ast::item) -> bool {\n     match item.node {\n        item_impl(*) => true,"}]}