{"sha": "f4ae9a4dbb79758a2e3d16ff0854301ce5846ae1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY0YWU5YTRkYmI3OTc1OGEyZTNkMTZmZjA4NTQzMDFjZTU4NDZhZTE=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2018-11-24T10:23:49Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2018-11-24T10:23:49Z"}, "message": "Rustup to rustc 1.32.0-nightly (1f57e4841 2018-11-23)", "tree": {"sha": "3ae6c7a2f92244c7ac0c9c0ca1b22ad2fd4a1d38", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3ae6c7a2f92244c7ac0c9c0ca1b22ad2fd4a1d38"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f4ae9a4dbb79758a2e3d16ff0854301ce5846ae1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f4ae9a4dbb79758a2e3d16ff0854301ce5846ae1", "html_url": "https://github.com/rust-lang/rust/commit/f4ae9a4dbb79758a2e3d16ff0854301ce5846ae1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f4ae9a4dbb79758a2e3d16ff0854301ce5846ae1/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "06202c007c7000148ed2901b9f50dc99de9b1d30", "url": "https://api.github.com/repos/rust-lang/rust/commits/06202c007c7000148ed2901b9f50dc99de9b1d30", "html_url": "https://github.com/rust-lang/rust/commit/06202c007c7000148ed2901b9f50dc99de9b1d30"}], "stats": {"total": 323, "additions": 33, "deletions": 290}, "files": [{"sha": "999353c4cfa3f0c60b37d26c2fafe5a5702fc57f", "filename": "Cargo.lock", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f4ae9a4dbb79758a2e3d16ff0854301ce5846ae1/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/f4ae9a4dbb79758a2e3d16ff0854301ce5846ae1/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=f4ae9a4dbb79758a2e3d16ff0854301ce5846ae1", "patch": "@@ -482,7 +482,6 @@ dependencies = [\n  \"ar 0.6.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"bitflags 1.0.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"byteorder 1.2.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"cc 1.0.25 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"cranelift 0.23.0 (git+https://github.com/CraneStation/cranelift.git)\",\n  \"cranelift-faerie 0.23.0 (git+https://github.com/CraneStation/cranelift.git)\",\n  \"cranelift-module 0.23.0 (git+https://github.com/CraneStation/cranelift.git)\","}, {"sha": "ee7ea811ad3204f0ca1b719061ac938a50497770", "filename": "Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f4ae9a4dbb79758a2e3d16ff0854301ce5846ae1/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f4ae9a4dbb79758a2e3d16ff0854301ce5846ae1/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=f4ae9a4dbb79758a2e3d16ff0854301ce5846ae1", "patch": "@@ -25,7 +25,6 @@ faerie = \"0.6.0\"\n ar = \"0.6.1\"\n bitflags = \"1.0.3\"\n byteorder = \"1.2.6\"\n-cc = \"1.0.25\"\n libc = \"0.2.43\"\n tempfile = \"3.0.4\"\n "}, {"sha": "d7edf23af7fd885664e8a644cb6ecdf7d21ed987", "filename": "src/base.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f4ae9a4dbb79758a2e3d16ff0854301ce5846ae1/src%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4ae9a4dbb79758a2e3d16ff0854301ce5846ae1/src%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbase.rs?ref=f4ae9a4dbb79758a2e3d16ff0854301ce5846ae1", "patch": "@@ -604,9 +604,9 @@ fn trans_stmt<'a, 'tcx: 'a>(\n                     use rustc::middle::lang_items::ExchangeMallocFnLangItem;\n \n                     let usize_type = fx.clif_type(fx.tcx.types.usize).unwrap();\n-                    let (size, align) = fx.layout_of(content_ty).size_and_align();\n-                    let llsize = fx.bcx.ins().iconst(usize_type, size.bytes() as i64);\n-                    let llalign = fx.bcx.ins().iconst(usize_type, align.abi() as i64);\n+                    let layout = fx.layout_of(content_ty);\n+                    let llsize = fx.bcx.ins().iconst(usize_type, layout.size.bytes() as i64);\n+                    let llalign = fx.bcx.ins().iconst(usize_type, layout.align.abi.bytes() as i64);\n                     let box_layout = fx.layout_of(fx.tcx.mk_box(content_ty));\n \n                     // Allocate space:"}, {"sha": "d3c8a3b570487fe69cdbdbb5ea37265907d9e232", "filename": "src/constant.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f4ae9a4dbb79758a2e3d16ff0854301ce5846ae1/src%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4ae9a4dbb79758a2e3d16ff0854301ce5846ae1/src%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconstant.rs?ref=f4ae9a4dbb79758a2e3d16ff0854301ce5846ae1", "patch": "@@ -5,7 +5,7 @@ use rustc::mir::interpret::{\n };\n use rustc::ty::Const;\n use rustc_mir::interpret::{\n-    EvalContext, MPlaceTy, Machine, Memory, MemoryKind, OpTy, PlaceTy, Pointer,\n+    EvalContext, MPlaceTy, Machine, Memory, MemoryKind, OpTy, PlaceTy, Pointer, StackPopCleanup,\n };\n \n use cranelift_module::*;\n@@ -133,7 +133,13 @@ fn trans_const_place<'a, 'tcx: 'a>(\n             ty::ParamEnv::reveal_all(),\n             TransPlaceInterpreter,\n         );\n-        let op = ecx.const_to_op(const_)?;\n+        ecx.push_stack_frame(fx.instance, DUMMY_SP, fx.mir, None, StackPopCleanup::None { cleanup: false }).unwrap();\n+        let op = ecx.eval_operand(&Operand::Constant(Box::new(Constant {\n+            span: DUMMY_SP,\n+            ty: const_.ty,\n+            user_ty: None,\n+            literal: const_,\n+        })), None)?;\n         let ptr = ecx.allocate(op.layout, MemoryKind::Stack)?;\n         ecx.copy_op(op, ptr.into())?;\n         let alloc = ecx.memory().get(ptr.to_ptr()?.alloc_id)?;"}, {"sha": "bb565ea38a51b28aa1cba650813587829a511070", "filename": "src/intrinsics.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f4ae9a4dbb79758a2e3d16ff0854301ce5846ae1/src%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4ae9a4dbb79758a2e3d16ff0854301ce5846ae1/src%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsics.rs?ref=f4ae9a4dbb79758a2e3d16ff0854301ce5846ae1", "patch": "@@ -169,7 +169,7 @@ pub fn codegen_intrinsic_call<'a, 'tcx: 'a>(\n             ret.write_cvalue(fx, CValue::ByVal(size, usize_layout));\n         };\n         min_align_of, <T> () {\n-            let min_align = fx.layout_of(T).align.abi();\n+            let min_align = fx.layout_of(T).align.abi.bytes();\n             let min_align = CValue::const_val(fx, usize_layout.ty, min_align as i64);\n             ret.write_cvalue(fx, min_align);\n         };\n@@ -179,9 +179,9 @@ pub fn codegen_intrinsic_call<'a, 'tcx: 'a>(\n                 _ if !layout.is_unsized() => fx\n                     .bcx\n                     .ins()\n-                    .iconst(fx.pointer_type, layout.align.abi() as i64),\n+                    .iconst(fx.pointer_type, layout.align.abi.bytes() as i64),\n                 ty::Slice(elem) => {\n-                    let align = fx.layout_of(elem).align.abi() as i64;\n+                    let align = fx.layout_of(elem).align.abi.bytes() as i64;\n                     fx.bcx.ins().iconst(fx.pointer_type, align)\n                 }\n                 ty::Dynamic(..) => crate::vtable::min_align_of_obj(fx, ptr),"}, {"sha": "e1dcab738bc9933258567a8230479bf7315ca8f3", "filename": "src/lib.rs", "status": "modified", "additions": 9, "deletions": 130, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/f4ae9a4dbb79758a2e3d16ff0854301ce5846ae1/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4ae9a4dbb79758a2e3d16ff0854301ce5846ae1/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=f4ae9a4dbb79758a2e3d16ff0854301ce5846ae1", "patch": "@@ -2,14 +2,14 @@\n     rustc_private,\n     macro_at_most_once_rep,\n     never_type,\n-    extern_crate_item_prelude,\n     decl_macro,\n )]\n #![allow(intra_doc_link_resolution_failure)]\n \n extern crate syntax;\n extern crate rustc;\n extern crate rustc_allocator;\n+extern crate rustc_codegen_ssa;\n extern crate rustc_codegen_utils;\n extern crate rustc_incremental;\n extern crate rustc_mir;\n@@ -25,19 +25,16 @@ use std::sync::mpsc;\n use syntax::symbol::Symbol;\n \n use rustc::dep_graph::DepGraph;\n-use rustc::middle::cstore::{\n-    self, CrateSource, LibSource, LinkagePreference, MetadataLoader, NativeLibrary,\n-};\n-use rustc::middle::lang_items::LangItem;\n-use rustc::middle::weak_lang_items;\n+use rustc::middle::cstore::MetadataLoader;\n use rustc::session::{\n-    config::{self, OutputFilenames, OutputType},\n+    config::{OutputFilenames, OutputType},\n     CompileIncomplete,\n };\n use rustc::ty::query::Providers;\n use rustc_codegen_utils::codegen_backend::CodegenBackend;\n use rustc_codegen_utils::link::out_filename;\n-use rustc_codegen_utils::linker::LinkerInfo;\n+use rustc_codegen_ssa::CrateInfo;\n+use rustc_codegen_ssa::back::linker::LinkerInfo;\n \n use cranelift::codegen::settings;\n use cranelift_faerie::*;\n@@ -81,7 +78,7 @@ mod prelude {\n         self, subst::Substs, FnSig, Instance, InstanceDef, ParamEnv, PolyFnSig, Ty, TyCtxt,\n         TypeAndMut, TypeFoldable,\n     };\n-    pub use rustc_codegen_utils::{CompiledModule, ModuleKind};\n+    pub use rustc_codegen_ssa::{CompiledModule, ModuleKind};\n     pub use rustc_data_structures::{\n         fx::{FxHashMap, FxHashSet},\n         indexed_vec::Idx,\n@@ -103,7 +100,7 @@ mod prelude {\n     pub use crate::common::*;\n     pub use crate::trap::*;\n     pub use crate::unimpl::{unimpl, with_unimpl_span};\n-    pub use crate::{Caches, CodegenResults, CrateInfo};\n+    pub use crate::{Caches, CodegenResults};\n }\n \n pub struct Caches<'tcx> {\n@@ -122,124 +119,6 @@ impl<'tcx> Caches<'tcx> {\n \n struct CraneliftCodegenBackend;\n \n-pub struct CrateInfo {\n-    panic_runtime: Option<CrateNum>,\n-    compiler_builtins: Option<CrateNum>,\n-    profiler_runtime: Option<CrateNum>,\n-    sanitizer_runtime: Option<CrateNum>,\n-    is_no_builtins: FxHashSet<CrateNum>,\n-    native_libraries: FxHashMap<CrateNum, Lrc<Vec<NativeLibrary>>>,\n-    crate_name: FxHashMap<CrateNum, String>,\n-    used_libraries: Lrc<Vec<NativeLibrary>>,\n-    link_args: Lrc<Vec<String>>,\n-    used_crate_source: FxHashMap<CrateNum, Lrc<CrateSource>>,\n-    used_crates_static: Vec<(CrateNum, LibSource)>,\n-    used_crates_dynamic: Vec<(CrateNum, LibSource)>,\n-    wasm_imports: FxHashMap<String, String>,\n-    lang_item_to_crate: FxHashMap<LangItem, CrateNum>,\n-    missing_lang_items: FxHashMap<CrateNum, Vec<LangItem>>,\n-}\n-\n-impl CrateInfo {\n-    pub fn new(tcx: TyCtxt) -> CrateInfo {\n-        let mut info = CrateInfo {\n-            panic_runtime: None,\n-            compiler_builtins: None,\n-            profiler_runtime: None,\n-            sanitizer_runtime: None,\n-            is_no_builtins: Default::default(),\n-            native_libraries: Default::default(),\n-            used_libraries: tcx.native_libraries(LOCAL_CRATE),\n-            link_args: tcx.link_args(LOCAL_CRATE),\n-            crate_name: Default::default(),\n-            used_crates_dynamic: cstore::used_crates(tcx, LinkagePreference::RequireDynamic),\n-            used_crates_static: cstore::used_crates(tcx, LinkagePreference::RequireStatic),\n-            used_crate_source: Default::default(),\n-            wasm_imports: Default::default(),\n-            lang_item_to_crate: Default::default(),\n-            missing_lang_items: Default::default(),\n-        };\n-        let lang_items = tcx.lang_items();\n-\n-        let load_wasm_items = tcx\n-            .sess\n-            .crate_types\n-            .borrow()\n-            .iter()\n-            .any(|c| *c != config::CrateType::Rlib)\n-            && tcx.sess.opts.target_triple.triple() == \"wasm32-unknown-unknown\";\n-\n-        if load_wasm_items {\n-            info.load_wasm_imports(tcx, LOCAL_CRATE);\n-        }\n-\n-        let crates = tcx.crates();\n-\n-        let n_crates = crates.len();\n-        info.native_libraries.reserve(n_crates);\n-        info.crate_name.reserve(n_crates);\n-        info.used_crate_source.reserve(n_crates);\n-        info.missing_lang_items.reserve(n_crates);\n-\n-        for &cnum in crates.iter() {\n-            info.native_libraries\n-                .insert(cnum, tcx.native_libraries(cnum));\n-            info.crate_name\n-                .insert(cnum, tcx.crate_name(cnum).to_string());\n-            info.used_crate_source\n-                .insert(cnum, tcx.used_crate_source(cnum));\n-            if tcx.is_panic_runtime(cnum) {\n-                info.panic_runtime = Some(cnum);\n-            }\n-            if tcx.is_compiler_builtins(cnum) {\n-                info.compiler_builtins = Some(cnum);\n-            }\n-            if tcx.is_profiler_runtime(cnum) {\n-                info.profiler_runtime = Some(cnum);\n-            }\n-            if tcx.is_sanitizer_runtime(cnum) {\n-                info.sanitizer_runtime = Some(cnum);\n-            }\n-            if tcx.is_no_builtins(cnum) {\n-                info.is_no_builtins.insert(cnum);\n-            }\n-            if load_wasm_items {\n-                info.load_wasm_imports(tcx, cnum);\n-            }\n-            let missing = tcx.missing_lang_items(cnum);\n-            for &item in missing.iter() {\n-                if let Ok(id) = lang_items.require(item) {\n-                    info.lang_item_to_crate.insert(item, id.krate);\n-                }\n-            }\n-\n-            // No need to look for lang items that are whitelisted and don't\n-            // actually need to exist.\n-            let missing = missing\n-                .iter()\n-                .cloned()\n-                .filter(|&l| !weak_lang_items::whitelisted(tcx, l))\n-                .collect();\n-            info.missing_lang_items.insert(cnum, missing);\n-        }\n-\n-        return info;\n-    }\n-\n-    fn load_wasm_imports(&mut self, tcx: TyCtxt, cnum: CrateNum) {\n-        self.wasm_imports.extend(\n-            tcx.wasm_import_module_map(cnum)\n-                .iter()\n-                .map(|(&id, module)| {\n-                    let instance = Instance::mono(tcx, id);\n-                    let import_name = tcx.symbol_name(instance);\n-\n-                    (import_name.to_string(), module.clone())\n-                }),\n-        );\n-    }\n-}\n-\n pub struct CodegenResults {\n     artifact: faerie::Artifact,\n     modules: Vec<CompiledModule>,\n@@ -283,12 +162,12 @@ impl CodegenBackend for CraneliftCodegenBackend {\n \n     fn provide(&self, providers: &mut Providers) {\n         rustc_codegen_utils::symbol_names::provide(providers);\n-        rustc_codegen_utils::symbol_export::provide(providers);\n+        rustc_codegen_ssa::back::symbol_export::provide(providers);\n \n         providers.target_features_whitelist = |_tcx, _cnum| Lrc::new(Default::default());\n     }\n     fn provide_extern(&self, providers: &mut Providers) {\n-        rustc_codegen_utils::symbol_export::provide_extern(providers);\n+        rustc_codegen_ssa::back::symbol_export::provide_extern(providers);\n     }\n \n     fn codegen_crate<'a, 'tcx>("}, {"sha": "28cc73797453e0d5c89ecbf81fe7e7c1b17a7edf", "filename": "src/link.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f4ae9a4dbb79758a2e3d16ff0854301ce5846ae1/src%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4ae9a4dbb79758a2e3d16ff0854301ce5846ae1/src%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flink.rs?ref=f4ae9a4dbb79758a2e3d16ff0854301ce5846ae1", "patch": "@@ -8,8 +8,9 @@ use tempfile::Builder as TempFileBuilder;\n use rustc::session::config::{self, CrateType, DebugInfo, RUST_CGU_EXT};\n use rustc::session::search_paths::PathKind;\n use rustc::session::Session;\n-use rustc_codegen_utils::command::Command;\n-use rustc_codegen_utils::linker::*;\n+use rustc_codegen_ssa::back::command::Command;\n+use rustc_codegen_ssa::back::linker::*;\n+use rustc_codegen_ssa::back::link::*;\n use rustc_fs_util::fix_windows_verbatim_for_gcc;\n use rustc_target::spec::{LinkerFlavor, PanicStrategy, RelroLevel};\n "}, {"sha": "bf5be809a0e557bf412d7af27043b9a5e20941df", "filename": "src/link_copied.rs", "status": "modified", "additions": 3, "deletions": 142, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/f4ae9a4dbb79758a2e3d16ff0854301ce5846ae1/src%2Flink_copied.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4ae9a4dbb79758a2e3d16ff0854301ce5846ae1/src%2Flink_copied.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flink_copied.rs?ref=f4ae9a4dbb79758a2e3d16ff0854301ce5846ae1", "patch": "@@ -1,14 +1,12 @@\n //! All functions here are copied from https://github.com/rust-lang/rust/blob/942864a000efd74b73e36bda5606b2cdb55ecf39/src/librustc_codegen_llvm/back/link.rs\n \n-use std::env;\n use std::fmt;\n use std::fs;\n use std::io;\n use std::iter;\n use std::path::{Path, PathBuf};\n use std::process::{Output, Stdio};\n \n-use cc::windows_registry;\n use log::info;\n \n use rustc::middle::cstore::{NativeLibrary, NativeLibraryKind};\n@@ -17,11 +15,11 @@ use rustc::session::config::{self, OutputType, RUST_CGU_EXT};\n use rustc::session::search_paths::PathKind;\n use rustc::session::Session;\n use rustc::util::common::time;\n-use rustc_codegen_utils::command::Command;\n-use rustc_codegen_utils::linker::*;\n+use rustc_codegen_ssa::back::command::Command;\n+use rustc_codegen_ssa::back::linker::*;\n+use rustc_codegen_ssa::back::link::*;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_fs_util::fix_windows_verbatim_for_gcc;\n-use rustc_target::spec::LinkerFlavor;\n use syntax::attr;\n \n use crate::prelude::*;\n@@ -52,125 +50,6 @@ fn archive_config<'a>(sess: &'a Session,\n     }\n }\n \n-// The third parameter is for env vars, used on windows to set up the\n-// path for MSVC to find its DLLs, and gcc to find its bundled\n-// toolchain\n-pub fn get_linker(sess: &Session, linker: &Path, flavor: LinkerFlavor) -> (PathBuf, Command) {\n-    let msvc_tool = windows_registry::find_tool(&sess.opts.target_triple.triple(), \"link.exe\");\n-\n-    // If our linker looks like a batch script on Windows then to execute this\n-    // we'll need to spawn `cmd` explicitly. This is primarily done to handle\n-    // emscripten where the linker is `emcc.bat` and needs to be spawned as\n-    // `cmd /c emcc.bat ...`.\n-    //\n-    // This worked historically but is needed manually since #42436 (regression\n-    // was tagged as #42791) and some more info can be found on #44443 for\n-    // emscripten itself.\n-    let mut cmd = match linker.to_str() {\n-        Some(linker) if cfg!(windows) && linker.ends_with(\".bat\") => Command::bat_script(linker),\n-        _ => match flavor {\n-            LinkerFlavor::Lld(f) => Command::lld(linker, f),\n-            LinkerFlavor::Msvc\n-                if sess.opts.cg.linker.is_none() && sess.target.target.options.linker.is_none() =>\n-            {\n-                Command::new(msvc_tool.as_ref().map(|t| t.path()).unwrap_or(linker))\n-            },\n-            _ => Command::new(linker),\n-        }\n-    };\n-\n-    // The compiler's sysroot often has some bundled tools, so add it to the\n-    // PATH for the child.\n-    let mut new_path = sess.host_filesearch(PathKind::All)\n-                           .get_tools_search_paths();\n-    let mut msvc_changed_path = false;\n-    if sess.target.target.options.is_like_msvc {\n-        if let Some(ref tool) = msvc_tool {\n-            cmd.args(tool.args());\n-            for &(ref k, ref v) in tool.env() {\n-                if k == \"PATH\" {\n-                    new_path.extend(env::split_paths(v));\n-                    msvc_changed_path = true;\n-                } else {\n-                    cmd.env(k, v);\n-                }\n-            }\n-        }\n-    }\n-\n-    if !msvc_changed_path {\n-        if let Some(path) = env::var_os(\"PATH\") {\n-            new_path.extend(env::split_paths(&path));\n-        }\n-    }\n-    cmd.env(\"PATH\", env::join_paths(new_path).unwrap());\n-\n-    (linker.to_path_buf(), cmd)\n-}\n-\n-pub fn linker_and_flavor(sess: &Session) -> (PathBuf, LinkerFlavor) {\n-    fn infer_from(\n-        sess: &Session,\n-        linker: Option<PathBuf>,\n-        flavor: Option<LinkerFlavor>,\n-    ) -> Option<(PathBuf, LinkerFlavor)> {\n-        match (linker, flavor) {\n-            (Some(linker), Some(flavor)) => Some((linker, flavor)),\n-            // only the linker flavor is known; use the default linker for the selected flavor\n-            (None, Some(flavor)) => Some((PathBuf::from(match flavor {\n-                LinkerFlavor::Em  => if cfg!(windows) { \"emcc.bat\" } else { \"emcc\" },\n-                LinkerFlavor::Gcc => \"cc\",\n-                LinkerFlavor::Ld => \"ld\",\n-                LinkerFlavor::Msvc => \"link.exe\",\n-                LinkerFlavor::Lld(_) => \"lld\",\n-            }), flavor)),\n-            (Some(linker), None) => {\n-                let stem = linker.file_stem().and_then(|stem| stem.to_str()).unwrap_or_else(|| {\n-                    sess.fatal(\"couldn't extract file stem from specified linker\");\n-                }).to_owned();\n-\n-                let flavor = if stem == \"emcc\" {\n-                    LinkerFlavor::Em\n-                } else if stem == \"gcc\" || stem.ends_with(\"-gcc\") {\n-                    LinkerFlavor::Gcc\n-                } else if stem == \"ld\" || stem == \"ld.lld\" || stem.ends_with(\"-ld\") {\n-                    LinkerFlavor::Ld\n-                } else if stem == \"link\" || stem == \"lld-link\" {\n-                    LinkerFlavor::Msvc\n-                } else if stem == \"lld\" || stem == \"rust-lld\" {\n-                    LinkerFlavor::Lld(sess.target.target.options.lld_flavor)\n-                } else {\n-                    // fall back to the value in the target spec\n-                    sess.target.target.linker_flavor\n-                };\n-\n-                Some((linker, flavor))\n-            },\n-            (None, None) => None,\n-        }\n-    }\n-\n-    // linker and linker flavor specified via command line have precedence over what the target\n-    // specification specifies\n-    if let Some(ret) = infer_from(\n-        sess,\n-        sess.opts.cg.linker.clone(),\n-        sess.opts.debugging_opts.linker_flavor,\n-    ) {\n-        return ret;\n-    }\n-\n-    if let Some(ret) = infer_from(\n-        sess,\n-        sess.target.target.options.linker.clone().map(PathBuf::from),\n-        Some(sess.target.target.linker_flavor),\n-    ) {\n-        return ret;\n-    }\n-\n-    bug!(\"Not enough information provided to determine how to invoke the linker\");\n-}\n-\n pub fn exec_linker(sess: &Session, cmd: &mut Command, out_filename: &Path, tmpdir: &Path)\n     -> io::Result<Output>\n {\n@@ -739,24 +618,6 @@ pub fn add_upstream_native_libraries(cmd: &mut dyn Linker,\n     }\n }\n \n-/// Returns a boolean indicating whether the specified crate should be ignored\n-/// during LTO.\n-///\n-/// Crates ignored during LTO are not lumped together in the \"massive object\n-/// file\" that we create and are linked in their normal rlib states. See\n-/// comments below for what crates do not participate in LTO.\n-///\n-/// It's unusual for a crate to not participate in LTO. Typically only\n-/// compiler-specific and unstable crates have a reason to not participate in\n-/// LTO.\n-fn ignored_for_lto(sess: &Session, info: &CrateInfo, cnum: CrateNum) -> bool {\n-    // If our target enables builtin function lowering in LLVM then the\n-    // crates providing these functions don't participate in LTO (e.g.\n-    // no_builtins or compiler builtins crates).\n-    !sess.target.target.options.no_builtins &&\n-        (info.is_no_builtins.contains(&cnum) || info.compiler_builtins == Some(cnum))\n-}\n-\n fn relevant_lib(sess: &Session, lib: &NativeLibrary) -> bool {\n     match lib.cfg {\n         Some(ref cfg) => attr::cfg_matches(cfg, &sess.parse_sess, None),"}, {"sha": "b9045a8eeba3f338309c49f1a1be746e7ad474f3", "filename": "src/vtable.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f4ae9a4dbb79758a2e3d16ff0854301ce5846ae1/src%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4ae9a4dbb79758a2e3d16ff0854301ce5846ae1/src%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvtable.rs?ref=f4ae9a4dbb79758a2e3d16ff0854301ce5846ae1", "patch": "@@ -75,10 +75,6 @@ fn build_vtable<'a, 'tcx: 'a>(\n     let tcx = fx.tcx;\n     let usize_size = fx.layout_of(fx.tcx.types.usize).size.bytes() as usize;\n \n-    let (size, align) = tcx\n-        .layout_of(ParamEnv::reveal_all().and(ty))\n-        .unwrap()\n-        .size_and_align();\n     let drop_in_place_fn = fx.get_function_id(\n         crate::rustc_mir::monomorphize::resolve_drop_in_place(tcx, ty),\n     );\n@@ -101,8 +97,10 @@ fn build_vtable<'a, 'tcx: 'a>(\n         .take(components.len() * usize_size)\n         .collect::<Vec<u8>>()\n         .into_boxed_slice();\n-    write_usize(fx.tcx, &mut data, SIZE_INDEX, size.bytes());\n-    write_usize(fx.tcx, &mut data, ALIGN_INDEX, align.abi());\n+\n+    let layout = tcx.layout_of(ParamEnv::reveal_all().and(ty)).unwrap();\n+    write_usize(fx.tcx, &mut data, SIZE_INDEX, layout.size.bytes());\n+    write_usize(fx.tcx, &mut data, ALIGN_INDEX, layout.align.abi.bytes());\n     data_ctx.define(data);\n \n     for (i, component) in components.into_iter().enumerate() {"}]}