{"sha": "11e407aaa917dbd646f80aaff2457942481877c8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjExZTQwN2FhYTkxN2RiZDY0NmY4MGFhZmYyNDU3OTQyNDgxODc3Yzg=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-10-05T00:05:16Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-10-05T00:05:16Z"}, "message": "Revert \"Reorganize translation of expr_field\"\n\nThis reverts commit 007ec666ad4a529682c35936d85ac81f7979f1b6.", "tree": {"sha": "6b997f3e6ba3ec3c541ecb7c7d0512f4122510b1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6b997f3e6ba3ec3c541ecb7c7d0512f4122510b1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/11e407aaa917dbd646f80aaff2457942481877c8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/11e407aaa917dbd646f80aaff2457942481877c8", "html_url": "https://github.com/rust-lang/rust/commit/11e407aaa917dbd646f80aaff2457942481877c8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/11e407aaa917dbd646f80aaff2457942481877c8/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "af60cf407ca54d2ac594de67f73b188533b3297d", "url": "https://api.github.com/repos/rust-lang/rust/commits/af60cf407ca54d2ac594de67f73b188533b3297d", "html_url": "https://github.com/rust-lang/rust/commit/af60cf407ca54d2ac594de67f73b188533b3297d"}], "stats": {"total": 110, "additions": 56, "deletions": 54}, "files": [{"sha": "6decfda3f8afcacce4dbc812ea53c2857bbc10a1", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 56, "deletions": 54, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/11e407aaa917dbd646f80aaff2457942481877c8/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11e407aaa917dbd646f80aaff2457942481877c8/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=11e407aaa917dbd646f80aaff2457942481877c8", "patch": "@@ -2366,6 +2366,7 @@ fn trans_assign_op(bcx: @block_ctxt, op: ast::binop, dst: @ast::expr,\n           _ { }\n         }\n     }\n+    \n     ret trans_eager_binop(bcx, op, Load(bcx, lhs_res.val), t, rhs_val, t,\n                           save_in(lhs_res.val));\n }\n@@ -3148,49 +3149,54 @@ fn trans_var(cx: @block_ctxt, sp: span, def: ast::def, id: ast::node_id)\n     }\n }\n \n-fn trans_object_field(bcx: @block_ctxt, o: @ast::expr, field: ast::ident)\n-    -> {bcx: @block_ctxt, mthptr: ValueRef, objptr: ValueRef} {\n-    let {bcx, val} = trans_expr(bcx, o);\n-    let {bcx, val, ty} = autoderef(bcx, val, ty::expr_ty(bcx_tcx(bcx), o));\n-    ret trans_object_field_inner(bcx, val, field, ty);\n+fn trans_field(cx: @block_ctxt, sp: span, base: @ast::expr,\n+               field: ast::ident) -> lval_maybe_callee {\n+    let {bcx, val} = trans_expr(cx, base);\n+    ret trans_field_inner(bcx, sp, val, ty::expr_ty(bcx_tcx(cx), base),\n+                          field);\n }\n \n-fn trans_object_field_inner(bcx: @block_ctxt, o: ValueRef,\n-                            field: ast::ident, o_ty: ty::t)\n-    -> {bcx: @block_ctxt, mthptr: ValueRef, objptr: ValueRef} {\n-    let ccx = bcx_ccx(bcx), tcx = ccx.tcx;\n-    let mths = alt ty::struct(tcx, o_ty) { ty::ty_obj(ms) { ms } };\n-\n-    let ix = ty::method_idx(ccx.sess, bcx.sp, field, mths);\n-    let vtbl = Load(bcx, GEP(bcx, o, [C_int(0), C_int(abi::obj_field_vtbl)]));\n-    let vtbl_type = T_ptr(T_array(T_ptr(T_nil()), ix + 1u));\n-    vtbl = PointerCast(bcx, vtbl, vtbl_type);\n+fn trans_field_inner(cx: @block_ctxt, sp: span, v: ValueRef, t0: ty::t,\n+                     field: ast::ident) -> lval_maybe_callee {\n+    let r = autoderef(cx, v, t0);\n+    let t = r.ty;\n+    alt ty::struct(bcx_tcx(cx), t) {\n+      ty::ty_rec(fields) {\n+        let ix: uint = ty::field_idx(bcx_ccx(cx).sess, sp, field, fields);\n+        let r_bcx = r.bcx;\n+        // Silly check\n+        check type_is_tup_like(r_bcx, t);\n+        let v = GEP_tup_like(r_bcx, t, r.val, [0, ix as int]);\n+        ret lval_no_env(v.bcx, v.val, true);\n+      }\n+      ty::ty_obj(methods) {\n+        let ix: uint = ty::method_idx(bcx_ccx(cx).sess, sp, field, methods);\n+        let vtbl = GEP(r.bcx, r.val, [C_int(0), C_int(abi::obj_field_vtbl)]);\n+        vtbl = Load(r.bcx, vtbl);\n \n-    let v = GEP(bcx, vtbl, [C_int(0), C_int(ix as int)]);\n-    let fn_ty: ty::t = ty::method_ty_to_fn_ty(tcx, mths[ix]);\n-    let ret_ty = ty::ty_fn_ret(tcx, fn_ty);\n-    let ret_ref = ast_util::ret_by_ref(ty::ty_fn_ret_style(tcx, fn_ty));\n-    // FIXME: constrain ty_obj?\n-    check non_ty_var(ccx, ret_ty);\n+        let vtbl_type = T_ptr(T_array(T_ptr(T_nil()), ix + 1u));\n+        vtbl = PointerCast(cx, vtbl, vtbl_type);\n \n-    let ll_fn_ty = type_of_fn(ccx, bcx.sp, ty::ty_fn_proto(tcx, fn_ty),\n-                              true, ret_ref, ty::ty_fn_args(tcx, fn_ty),\n-                              ret_ty, 0u);\n-    v = Load(bcx, PointerCast(bcx, v, T_ptr(T_ptr(ll_fn_ty))));\n-    ret {bcx: bcx, mthptr: v, objptr: o};\n-}\n+        let v = GEP(r.bcx, vtbl, [C_int(0), C_int(ix as int)]);\n+        let tcx = bcx_tcx(cx);\n+        let ccx = bcx_ccx(cx);\n \n+        let fn_ty: ty::t = ty::method_ty_to_fn_ty(tcx, methods[ix]);\n+        let ret_ty = ty::ty_fn_ret(tcx, fn_ty);\n+        let ret_ref = ast_util::ret_by_ref(ty::ty_fn_ret_style(tcx, fn_ty));\n+        // FIXME: constrain ty_obj?\n+        check non_ty_var(ccx, ret_ty);\n \n-fn trans_rec_field(bcx: @block_ctxt, base: @ast::expr,\n-                   field: ast::ident) -> lval_result {\n-    let {bcx, val} = trans_expr(bcx, base);\n-    let {bcx, val, ty} = autoderef(bcx, val, ty::expr_ty(bcx_tcx(bcx), base));\n-    let fields = alt ty::struct(bcx_tcx(bcx), ty) { ty::ty_rec(fs) { fs } };\n-    let ix = ty::field_idx(bcx_ccx(bcx).sess, bcx.sp, field, fields);\n-    // Silly check\n-    check type_is_tup_like(bcx, ty);\n-    let {bcx, val} = GEP_tup_like(bcx, ty, val, [0, ix as int]);\n-    ret {bcx: bcx, val: val, is_mem: true};\n+        let ll_fn_ty =\n+            type_of_fn(ccx, sp, ty::ty_fn_proto(tcx, fn_ty),\n+                       true, ret_ref, ty::ty_fn_args(tcx, fn_ty),\n+                       ret_ty, 0u);\n+        v = Load(r.bcx, PointerCast(r.bcx, v, T_ptr(T_ptr(ll_fn_ty))));\n+        ret {bcx: r.bcx, val: v, is_mem: true,\n+             env: obj_env(r.val), generic: none};\n+      }\n+      _ { bcx_ccx(cx).sess.unimpl(\"field variant in trans_field\"); }\n+    }\n }\n \n fn trans_index(cx: @block_ctxt, sp: span, base: @ast::expr, idx: @ast::expr,\n@@ -3242,30 +3248,24 @@ fn trans_index(cx: @block_ctxt, sp: span, base: @ast::expr, idx: @ast::expr,\n     ret lval_mem(next_cx, elt);\n }\n \n-fn trans_callee(bcx: @block_ctxt, e: @ast::expr) -> lval_maybe_callee {\n+fn trans_callee(cx: @block_ctxt, e: @ast::expr) -> lval_maybe_callee {\n     alt e.node {\n-      ast::expr_path(p) { ret trans_path(bcx, p, e.id); }\n+      ast::expr_path(p) { ret trans_path(cx, p, e.id); }\n       ast::expr_field(base, ident) {\n-        // Lval means record field, so not a method\n-        if !expr_is_lval(bcx_tcx(bcx), e) {\n-            let of = trans_object_field(bcx, base, ident);\n-            ret {bcx: of.bcx, val: of.mthptr, is_mem: true,\n-                 env: obj_env(of.objptr), generic: none};\n-        }\n+        ret trans_field(cx, e.span, base, ident);\n       }\n       ast::expr_self_method(ident) {\n-        alt bcx.fcx.llself {\n+        alt cx.fcx.llself {\n           some(pair) {\n-            let fld = trans_object_field_inner(bcx, pair.v, ident, pair.t);\n-            ret {bcx: fld.bcx, val: fld.mthptr, is_mem: true,\n-                 env: obj_env(fld.objptr), generic: none};\n+            ret trans_field_inner(cx, e.span, pair.v, pair.t, ident);\n           }\n         }\n       }\n-      _ {}\n+      _ {\n+        let lv = trans_lval(cx, e);\n+        ret lval_no_env(lv.bcx, lv.val, lv.is_mem);\n+      }\n     }\n-    let lv = trans_lval(bcx, e);\n-    ret lval_no_env(lv.bcx, lv.val, lv.is_mem);\n }\n \n fn expr_is_lval(tcx: ty::ctxt, e: @ast::expr) -> bool {\n@@ -3298,7 +3298,8 @@ fn trans_lval(cx: @block_ctxt, e: @ast::expr) -> lval_result {\n         ret lval_maybe_callee_to_lval(v, ty::expr_ty(bcx_tcx(cx), e));\n       }\n       ast::expr_field(base, ident) {\n-        ret trans_rec_field(cx, base, ident);\n+        let f = trans_field(cx, e.span, base, ident);\n+        ret lval_maybe_callee_to_lval(f, ty::expr_ty(bcx_tcx(cx), e));\n       }\n       ast::expr_index(base, idx) {\n         ret trans_index(cx, e.span, base, idx, e.id);\n@@ -4324,8 +4325,9 @@ fn trans_expr_dps(bcx: @block_ctxt, e: @ast::expr, dest: dest)\n       ast::expr_call(f, args) {\n         ret trans_call(bcx, f, none, args, e.id, dest);\n       }\n+      // FIXME[DPS] untangle non-lval fields from trans_lval\n       ast::expr_field(_, _) {\n-        fail \"Taking the value of a method does not work yet (issue #435)\";\n+        ret lval_to_dps(bcx, e, dest);\n       }\n \n       // These return nothing"}]}