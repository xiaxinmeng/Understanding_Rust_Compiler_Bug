{"sha": "74bd806b05b16528ff773e469145df215760a88b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc0YmQ4MDZiMDViMTY1MjhmZjc3M2U0NjkxNDVkZjIxNTc2MGE4OGI=", "commit": {"author": {"name": "Yoshitomo Nakanishi", "email": "yurayura.rounin.3@gmail.com", "date": "2021-03-02T03:41:06Z"}, "committer": {"name": "Yoshitomo Nakanishi", "email": "yurayura.rounin.3@gmail.com", "date": "2021-03-02T09:14:20Z"}, "message": "Simplify check_for_loop_arg", "tree": {"sha": "c75cdc7d0afdb7fcb8b1e1cb33decdd14c74fd14", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c75cdc7d0afdb7fcb8b1e1cb33decdd14c74fd14"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/74bd806b05b16528ff773e469145df215760a88b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/74bd806b05b16528ff773e469145df215760a88b", "html_url": "https://github.com/rust-lang/rust/commit/74bd806b05b16528ff773e469145df215760a88b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/74bd806b05b16528ff773e469145df215760a88b/comments", "author": {"login": "Y-Nak", "id": 6376004, "node_id": "MDQ6VXNlcjYzNzYwMDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6376004?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Y-Nak", "html_url": "https://github.com/Y-Nak", "followers_url": "https://api.github.com/users/Y-Nak/followers", "following_url": "https://api.github.com/users/Y-Nak/following{/other_user}", "gists_url": "https://api.github.com/users/Y-Nak/gists{/gist_id}", "starred_url": "https://api.github.com/users/Y-Nak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Y-Nak/subscriptions", "organizations_url": "https://api.github.com/users/Y-Nak/orgs", "repos_url": "https://api.github.com/users/Y-Nak/repos", "events_url": "https://api.github.com/users/Y-Nak/events{/privacy}", "received_events_url": "https://api.github.com/users/Y-Nak/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Y-Nak", "id": 6376004, "node_id": "MDQ6VXNlcjYzNzYwMDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6376004?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Y-Nak", "html_url": "https://github.com/Y-Nak", "followers_url": "https://api.github.com/users/Y-Nak/followers", "following_url": "https://api.github.com/users/Y-Nak/following{/other_user}", "gists_url": "https://api.github.com/users/Y-Nak/gists{/gist_id}", "starred_url": "https://api.github.com/users/Y-Nak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Y-Nak/subscriptions", "organizations_url": "https://api.github.com/users/Y-Nak/orgs", "repos_url": "https://api.github.com/users/Y-Nak/repos", "events_url": "https://api.github.com/users/Y-Nak/events{/privacy}", "received_events_url": "https://api.github.com/users/Y-Nak/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eaf63d6df75e0a046ba65d8b3cad0314b447f63e", "url": "https://api.github.com/repos/rust-lang/rust/commits/eaf63d6df75e0a046ba65d8b3cad0314b447f63e", "html_url": "https://github.com/rust-lang/rust/commit/eaf63d6df75e0a046ba65d8b3cad0314b447f63e"}], "stats": {"total": 157, "additions": 90, "deletions": 67}, "files": [{"sha": "1d778205a2ad1f3d118dd5f7461933a8387989b3", "filename": "clippy_lints/src/loops/explicit_into_iter_loop.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/74bd806b05b16528ff773e469145df215760a88b/clippy_lints%2Fsrc%2Floops%2Fexplicit_into_iter_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74bd806b05b16528ff773e469145df215760a88b/clippy_lints%2Fsrc%2Floops%2Fexplicit_into_iter_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fexplicit_into_iter_loop.rs?ref=74bd806b05b16528ff773e469145df215760a88b", "patch": "@@ -3,10 +3,17 @@ use crate::utils::{snippet_with_applicability, span_lint_and_sugg};\n use rustc_errors::Applicability;\n use rustc_hir::Expr;\n use rustc_lint::LateContext;\n+use rustc_middle::ty::TyS;\n+\n+pub(super) fn check(cx: &LateContext<'_>, args: &'hir [Expr<'hir>], arg: &Expr<'_>) {\n+    let receiver_ty = cx.typeck_results().expr_ty(&args[0]);\n+    let receiver_ty_adjusted = cx.typeck_results().expr_ty_adjusted(&args[0]);\n+    if !TyS::same_type(receiver_ty, receiver_ty_adjusted) {\n+        return;\n+    }\n \n-pub(super) fn check(cx: &LateContext<'_>, method_args: &'hir [Expr<'hir>], arg: &Expr<'_>) {\n     let mut applicability = Applicability::MachineApplicable;\n-    let object = snippet_with_applicability(cx, method_args[0].span, \"_\", &mut applicability);\n+    let object = snippet_with_applicability(cx, args[0].span, \"_\", &mut applicability);\n     span_lint_and_sugg(\n         cx,\n         EXPLICIT_INTO_ITER_LOOP,"}, {"sha": "44d08916891051939e6694c68b81384b2825e9f4", "filename": "clippy_lints/src/loops/explicit_iter_loop.rs", "status": "modified", "additions": 55, "deletions": 2, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/74bd806b05b16528ff773e469145df215760a88b/clippy_lints%2Fsrc%2Floops%2Fexplicit_iter_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74bd806b05b16528ff773e469145df215760a88b/clippy_lints%2Fsrc%2Floops%2Fexplicit_iter_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fexplicit_iter_loop.rs?ref=74bd806b05b16528ff773e469145df215760a88b", "patch": "@@ -1,10 +1,35 @@\n use super::EXPLICIT_ITER_LOOP;\n-use crate::utils::{snippet_with_applicability, span_lint_and_sugg};\n+use crate::utils::{match_trait_method, snippet_with_applicability, span_lint_and_sugg};\n use rustc_errors::Applicability;\n-use rustc_hir::Expr;\n+use rustc_hir::{Expr, Mutability};\n use rustc_lint::LateContext;\n+use rustc_middle::ty::{self, Ty, TyS};\n+use rustc_span::symbol::sym;\n+\n+use crate::utils::{is_type_diagnostic_item, match_type, paths};\n \n pub(super) fn check(cx: &LateContext<'_>, args: &[Expr<'_>], arg: &Expr<'_>, method_name: &str) {\n+    let should_lint = match method_name {\n+        \"iter\" | \"iter_mut\" => is_ref_iterable_type(cx, &args[0]),\n+        \"into_iter\" if match_trait_method(cx, arg, &paths::INTO_ITERATOR) => {\n+            let receiver_ty = cx.typeck_results().expr_ty(&args[0]);\n+            let receiver_ty_adjusted = cx.typeck_results().expr_ty_adjusted(&args[0]);\n+            let ref_receiver_ty = cx.tcx.mk_ref(\n+                cx.tcx.lifetimes.re_erased,\n+                ty::TypeAndMut {\n+                    ty: receiver_ty,\n+                    mutbl: Mutability::Not,\n+                },\n+            );\n+            TyS::same_type(receiver_ty_adjusted, ref_receiver_ty)\n+        },\n+        _ => false,\n+    };\n+\n+    if !should_lint {\n+        return;\n+    }\n+\n     let mut applicability = Applicability::MachineApplicable;\n     let object = snippet_with_applicability(cx, args[0].span, \"_\", &mut applicability);\n     let muta = if method_name == \"iter_mut\" { \"mut \" } else { \"\" };\n@@ -19,3 +44,31 @@ pub(super) fn check(cx: &LateContext<'_>, args: &[Expr<'_>], arg: &Expr<'_>, met\n         applicability,\n     )\n }\n+\n+/// Returns `true` if the type of expr is one that provides `IntoIterator` impls\n+/// for `&T` and `&mut T`, such as `Vec`.\n+#[rustfmt::skip]\n+fn is_ref_iterable_type(cx: &LateContext<'_>, e: &Expr<'_>) -> bool {\n+    // no walk_ptrs_ty: calling iter() on a reference can make sense because it\n+    // will allow further borrows afterwards\n+    let ty = cx.typeck_results().expr_ty(e);\n+    is_iterable_array(ty, cx) ||\n+    is_type_diagnostic_item(cx, ty, sym::vec_type) ||\n+    match_type(cx, ty, &paths::LINKED_LIST) ||\n+    is_type_diagnostic_item(cx, ty, sym!(hashmap_type)) ||\n+    is_type_diagnostic_item(cx, ty, sym!(hashset_type)) ||\n+    is_type_diagnostic_item(cx, ty, sym!(vecdeque_type)) ||\n+    match_type(cx, ty, &paths::BINARY_HEAP) ||\n+    match_type(cx, ty, &paths::BTREEMAP) ||\n+    match_type(cx, ty, &paths::BTREESET)\n+}\n+\n+fn is_iterable_array<'tcx>(ty: Ty<'tcx>, cx: &LateContext<'tcx>) -> bool {\n+    // IntoIterator is currently only implemented for array sizes <= 32 in rustc\n+    match ty.kind() {\n+        ty::Array(_, n) => n\n+            .try_eval_usize(cx.tcx, cx.param_env)\n+            .map_or(false, |val| (0..=32).contains(&val)),\n+        _ => false,\n+    }\n+}"}, {"sha": "cf78bbc49a3623a3f2e5b5a569fc7d19cd3da161", "filename": "clippy_lints/src/loops/iter_next_loop.rs", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/74bd806b05b16528ff773e469145df215760a88b/clippy_lints%2Fsrc%2Floops%2Fiter_next_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74bd806b05b16528ff773e469145df215760a88b/clippy_lints%2Fsrc%2Floops%2Fiter_next_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fiter_next_loop.rs?ref=74bd806b05b16528ff773e469145df215760a88b", "patch": "@@ -1,14 +1,19 @@\n use super::ITER_NEXT_LOOP;\n-use crate::utils::span_lint;\n+use crate::utils::{match_trait_method, paths, span_lint};\n use rustc_hir::Expr;\n use rustc_lint::LateContext;\n \n-pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>) {\n-    span_lint(\n-        cx,\n-        ITER_NEXT_LOOP,\n-        expr.span,\n-        \"you are iterating over `Iterator::next()` which is an Option; this will compile but is \\\n-        probably not what you want\",\n-    );\n+pub(super) fn check(cx: &LateContext<'_>, arg: &Expr<'_>, expr: &Expr<'_>) -> bool {\n+    if match_trait_method(cx, arg, &paths::ITERATOR) {\n+        span_lint(\n+            cx,\n+            ITER_NEXT_LOOP,\n+            expr.span,\n+            \"you are iterating over `Iterator::next()` which is an Option; this will compile but is \\\n+            probably not what you want\",\n+        );\n+        true\n+    } else {\n+        false\n+    }\n }"}, {"sha": "2a372c6307eabfa6417b7af4368c12708d5bb22f", "filename": "clippy_lints/src/loops/mod.rs", "status": "modified", "additions": 12, "deletions": 54, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/74bd806b05b16528ff773e469145df215760a88b/clippy_lints%2Fsrc%2Floops%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74bd806b05b16528ff773e469145df215760a88b/clippy_lints%2Fsrc%2Floops%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fmod.rs?ref=74bd806b05b16528ff773e469145df215760a88b", "patch": "@@ -18,13 +18,11 @@ mod while_immutable_condition;\n mod while_let_loop;\n mod while_let_on_iterator;\n \n-use crate::utils::{higher, is_type_diagnostic_item, match_trait_method, match_type, paths};\n-use rustc_hir::{Expr, ExprKind, LoopSource, Mutability, Pat};\n+use crate::utils::higher;\n+use rustc_hir::{Expr, ExprKind, LoopSource, Pat};\n use rustc_lint::{LateContext, LateLintPass};\n-use rustc_middle::ty::{self, Ty, TyS};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::Span;\n-use rustc_span::symbol::sym;\n use utils::{get_span_of_entire_for_loop, make_iterator_snippet, IncrementVisitor, InitializeVisitor};\n \n declare_clippy_lint! {\n@@ -603,67 +601,27 @@ fn check_for_loop<'tcx>(\n \n fn check_for_loop_arg(cx: &LateContext<'_>, pat: &Pat<'_>, arg: &Expr<'_>, expr: &Expr<'_>) {\n     let mut next_loop_linted = false; // whether or not ITER_NEXT_LOOP lint was used\n+\n     if let ExprKind::MethodCall(ref method, _, ref args, _) = arg.kind {\n         // just the receiver, no arguments\n         if args.len() == 1 {\n             let method_name = &*method.ident.as_str();\n             // check for looping over x.iter() or x.iter_mut(), could use &x or &mut x\n-            if method_name == \"iter\" || method_name == \"iter_mut\" {\n-                if is_ref_iterable_type(cx, &args[0]) {\n+            match method_name {\n+                \"iter\" | \"iter_mut\" => explicit_iter_loop::check(cx, args, arg, method_name),\n+                \"into_iter\" => {\n                     explicit_iter_loop::check(cx, args, arg, method_name);\n-                }\n-            } else if method_name == \"into_iter\" && match_trait_method(cx, arg, &paths::INTO_ITERATOR) {\n-                let receiver_ty = cx.typeck_results().expr_ty(&args[0]);\n-                let receiver_ty_adjusted = cx.typeck_results().expr_ty_adjusted(&args[0]);\n-                if TyS::same_type(receiver_ty, receiver_ty_adjusted) {\n                     explicit_into_iter_loop::check(cx, args, arg);\n-                } else {\n-                    let ref_receiver_ty = cx.tcx.mk_ref(\n-                        cx.tcx.lifetimes.re_erased,\n-                        ty::TypeAndMut {\n-                            ty: receiver_ty,\n-                            mutbl: Mutability::Not,\n-                        },\n-                    );\n-                    if TyS::same_type(receiver_ty_adjusted, ref_receiver_ty) {\n-                        explicit_iter_loop::check(cx, args, arg, method_name)\n-                    }\n-                }\n-            } else if method_name == \"next\" && match_trait_method(cx, arg, &paths::ITERATOR) {\n-                iter_next_loop::check(cx, expr);\n-                next_loop_linted = true;\n+                },\n+                \"next\" => {\n+                    next_loop_linted = iter_next_loop::check(cx, arg, expr);\n+                },\n+                _ => {},\n             }\n         }\n     }\n+\n     if !next_loop_linted {\n         for_loops_over_fallibles::check(cx, pat, arg);\n     }\n }\n-\n-/// Returns `true` if the type of expr is one that provides `IntoIterator` impls\n-/// for `&T` and `&mut T`, such as `Vec`.\n-#[rustfmt::skip]\n-fn is_ref_iterable_type(cx: &LateContext<'_>, e: &Expr<'_>) -> bool {\n-    // no walk_ptrs_ty: calling iter() on a reference can make sense because it\n-    // will allow further borrows afterwards\n-    let ty = cx.typeck_results().expr_ty(e);\n-    is_iterable_array(ty, cx) ||\n-    is_type_diagnostic_item(cx, ty, sym::vec_type) ||\n-    match_type(cx, ty, &paths::LINKED_LIST) ||\n-    is_type_diagnostic_item(cx, ty, sym!(hashmap_type)) ||\n-    is_type_diagnostic_item(cx, ty, sym!(hashset_type)) ||\n-    is_type_diagnostic_item(cx, ty, sym!(vecdeque_type)) ||\n-    match_type(cx, ty, &paths::BINARY_HEAP) ||\n-    match_type(cx, ty, &paths::BTREEMAP) ||\n-    match_type(cx, ty, &paths::BTREESET)\n-}\n-\n-fn is_iterable_array<'tcx>(ty: Ty<'tcx>, cx: &LateContext<'tcx>) -> bool {\n-    // IntoIterator is currently only implemented for array sizes <= 32 in rustc\n-    match ty.kind() {\n-        ty::Array(_, n) => n\n-            .try_eval_usize(cx.tcx, cx.param_env)\n-            .map_or(false, |val| (0..=32).contains(&val)),\n-        _ => false,\n-    }\n-}"}]}