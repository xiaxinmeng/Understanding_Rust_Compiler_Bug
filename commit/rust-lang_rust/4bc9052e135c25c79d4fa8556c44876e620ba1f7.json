{"sha": "4bc9052e135c25c79d4fa8556c44876e620ba1f7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRiYzkwNTJlMTM1YzI1Yzc5ZDRmYTg1NTZjNDQ4NzZlNjIwYmExZjc=", "commit": {"author": {"name": "Brian Anderson", "email": "andersrb@gmail.com", "date": "2011-03-02T02:03:44Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-03-02T18:28:15Z"}, "message": "Add debug logging for #fmt conv. Implement peek_num fn", "tree": {"sha": "5b87b839290a0531af8f27477127f0f5a86b5d75", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5b87b839290a0531af8f27477127f0f5a86b5d75"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4bc9052e135c25c79d4fa8556c44876e620ba1f7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4bc9052e135c25c79d4fa8556c44876e620ba1f7", "html_url": "https://github.com/rust-lang/rust/commit/4bc9052e135c25c79d4fa8556c44876e620ba1f7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4bc9052e135c25c79d4fa8556c44876e620ba1f7/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "77a0dc06a7cead4a1d38cdb68f1465cbeccf48c1", "url": "https://api.github.com/repos/rust-lang/rust/commits/77a0dc06a7cead4a1d38cdb68f1465cbeccf48c1", "html_url": "https://github.com/rust-lang/rust/commit/77a0dc06a7cead4a1d38cdb68f1465cbeccf48c1"}], "stats": {"total": 144, "additions": 123, "deletions": 21}, "files": [{"sha": "5ca50c051decf4e489aff48dd0fe8554fa4a6915", "filename": "src/comp/front/extfmt.rs", "status": "modified", "additions": 123, "deletions": 21, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/4bc9052e135c25c79d4fa8556c44876e620ba1f7/src%2Fcomp%2Ffront%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bc9052e135c25c79d4fa8556c44876e620ba1f7/src%2Fcomp%2Ffront%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fextfmt.rs?ref=4bc9052e135c25c79d4fa8556c44876e620ba1f7", "patch": "@@ -71,17 +71,13 @@ tag piece {\n     piece_conv(conv);\n }\n \n-fn bad_fmt_call() {\n-    log \"malformed #fmt call\";\n-    fail;\n-}\n-\n // TODO: Need to thread parser through here to handle errors correctly\n fn expand_syntax_ext(vec[@ast.expr] args,\n                      option.t[@ast.expr] body) -> @ast.expr {\n \n     if (_vec.len[@ast.expr](args) == 0u) {\n-        bad_fmt_call();\n+        log \"malformed #fmt call\";\n+        fail;\n     }\n \n     auto fmt = expr_to_str(args.(0));\n@@ -101,7 +97,7 @@ fn expr_to_str(@ast.expr expr) -> str {\n             }\n         }\n     }\n-    bad_fmt_call();\n+    log \"malformed #fmt call\";\n     fail;\n }\n \n@@ -146,19 +142,29 @@ fn parse_fmt_string(str s) -> vec[piece] {\n     ret pieces;\n }\n \n-fn peek_num(str s, uint i, uint lim) -> option.t[tup(int, int)] {\n+fn peek_num(str s, uint i, uint lim) -> option.t[tup(uint, uint)] {\n     if (i >= lim) {\n-        ret none[tup(int, int)];\n-    } else {\n-        ret none[tup(int, int)];\n-        /*if ('0' <= c && c <= '9') {\n-            log c;\n-            fail;\n-        } else {\n-            ret option.none[tup(int, int)];\n+        ret none[tup(uint, uint)];\n+    }\n+\n+    // FIXME: Presumably s.(i) will return char eventually\n+    auto c = s.(i);\n+    if (!('0' as u8 <= c && c <= '9' as u8)) {\n+        ret option.none[tup(uint, uint)];\n+    }\n+\n+    auto n = (c - ('0' as u8)) as uint;\n+    alt (peek_num(s, i + 1u, lim)) {\n+        case (none[tup(uint, uint)]) {\n+            ret some[tup(uint, uint)](tup(n, i + 1u));\n+        }\n+        case (some[tup(uint, uint)](?next)) {\n+            auto m = next._0;\n+            auto j = next._1;\n+            ret some[tup(uint, uint)](tup(n * 10u + m, j));\n         }\n-        */\n     }\n+\n }\n \n fn parse_conversion(str s, uint i, uint lim) -> tup(piece, uint) {\n@@ -182,10 +188,10 @@ fn parse_parameter(str s, uint i, uint lim) -> tup(option.t[int], uint) {\n \n     auto num = peek_num(s, i, lim);\n     alt (num) {\n-        case (none[tup(int, int)]) {\n+        case (none[tup(uint, uint)]) {\n             ret tup(none[int], i);\n         }\n-        case (some[tup(int, int)](?t)) {\n+        case (some[tup(uint, uint)](?t)) {\n             fail;\n         }\n     }\n@@ -342,6 +348,98 @@ fn pieces_to_expr(vec[piece] pieces, vec[@ast.expr] args) -> @ast.expr {\n         }\n     }\n \n+    fn log_conv(conv c) {\n+        alt (c.param) {\n+            case (some[int](?p)) {\n+                log \"param: \" + std._int.to_str(p, 10u);\n+            }\n+            case (_) {\n+                log \"param: none\";\n+            }\n+        }\n+        for (flag f in c.flags) {\n+            alt (f) {\n+                case (flag_left_justify) {\n+                    log \"flag: left justify\";\n+                }\n+                case (flag_left_zero_pad) {\n+                    log \"flag: left zero pad\";\n+                }\n+                case (flag_left_space_pad) {\n+                    log \"flag: left space pad\";\n+                }\n+                case (flag_plus_if_positive) {\n+                    log \"flag: plus if positive\";\n+                }\n+                case (flag_alternate) {\n+                    log \"flag: alternate\";\n+                }\n+            }\n+        }\n+        alt (c.width) {\n+            case (count_is(?i)) {\n+                log \"width: count is \" + std._int.to_str(i, 10u);\n+            }\n+            case (count_is_param(?i)) {\n+                log \"width: count is param \" + std._int.to_str(i, 10u);\n+            }\n+            case (count_is_next_param) {\n+                log \"width: count is next param\";\n+            }\n+            case (count_implied) {\n+                log \"width: count is implied\";\n+            }\n+        }\n+        alt (c.precision) {\n+            case (count_is(?i)) {\n+                log \"prec: count is \" + std._int.to_str(i, 10u);\n+            }\n+            case (count_is_param(?i)) {\n+                log \"prec: count is param \" + std._int.to_str(i, 10u);\n+            }\n+            case (count_is_next_param) {\n+                log \"prec: count is next param\";\n+            }\n+            case (count_implied) {\n+                log \"prec: count is implied\";\n+            }\n+        }\n+        alt (c.ty) {\n+            case (ty_bool) {\n+                log \"type: bool\";\n+            }\n+            case (ty_str) {\n+                log \"type: str\";\n+            }\n+            case (ty_char) {\n+                log \"type: char\";\n+            }\n+            case (ty_int(?s)) {\n+                alt (s) {\n+                    case (signed) {\n+                        log \"type: signed\";\n+                    }\n+                    case (unsigned) {\n+                        log \"type: unsigned\";\n+                    }\n+                }\n+            }\n+            case (ty_bits) {\n+                log \"type: bits\";\n+            }\n+            case (ty_hex(?cs)) {\n+                alt (cs) {\n+                    case (case_upper) {\n+                        log \"type: uhex\";\n+                    }\n+                    case (case_lower) {\n+                        log \"type: lhex\";\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n     auto sp = args.(0).span;\n     auto n = 0u;\n     auto tmp_expr = make_new_str(sp, \"\");\n@@ -358,6 +456,10 @@ fn pieces_to_expr(vec[piece] pieces, vec[@ast.expr] args) -> @ast.expr {\n                     fail;\n                 }\n \n+                // TODO: Remove debug logging\n+                log \"Building conversion:\";\n+                log_conv(conv);\n+\n                 n += 1u;\n                 auto arg_expr = args.(n);\n                 auto c_expr = make_new_conv(conv, arg_expr);\n@@ -366,10 +468,10 @@ fn pieces_to_expr(vec[piece] pieces, vec[@ast.expr] args) -> @ast.expr {\n         }\n     }\n \n-    // TODO: Remove this print and return the real expanded AST\n+    // TODO: Remove this debug logging\n     log \"dumping expanded ast:\";\n     log pretty.print_expr(tmp_expr);\n-    ret make_new_str(sp, \"TODO\");\n+    ret tmp_expr;\n }\n \n //"}]}