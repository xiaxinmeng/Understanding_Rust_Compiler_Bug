{"sha": "a2a6720959d1fce9c2ca4963edaa9ad67becfeef", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEyYTY3MjA5NTlkMWZjZTljMmNhNDk2M2VkYWE5YWQ2N2JlY2ZlZWY=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-12-08T19:12:25Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-01-03T08:41:24Z"}, "message": "Add read_to_str and write_{str, line}\n\nThese methods are sorely needed on readers and writers, and I believe that the\nencoding story should be solved with composition. This commit adds back the\nmissed functions when reading/writing strings onto generic Readers/Writers.", "tree": {"sha": "40ae613e6b9e497a99a42eefc773781d0be0ffe5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/40ae613e6b9e497a99a42eefc773781d0be0ffe5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a2a6720959d1fce9c2ca4963edaa9ad67becfeef", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a2a6720959d1fce9c2ca4963edaa9ad67becfeef", "html_url": "https://github.com/rust-lang/rust/commit/a2a6720959d1fce9c2ca4963edaa9ad67becfeef", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a2a6720959d1fce9c2ca4963edaa9ad67becfeef/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3249de8c4f5d4c7cf34a4bda5e98f047b6b72263", "url": "https://api.github.com/repos/rust-lang/rust/commits/3249de8c4f5d4c7cf34a4bda5e98f047b6b72263", "html_url": "https://github.com/rust-lang/rust/commit/3249de8c4f5d4c7cf34a4bda5e98f047b6b72263"}], "stats": {"total": 97, "additions": 73, "deletions": 24}, "files": [{"sha": "5096e9237e3e32b29dc6b6a5d2f9fd3004919680", "filename": "src/libstd/io/mem.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a2a6720959d1fce9c2ca4963edaa9ad67becfeef/src%2Flibstd%2Fio%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2a6720959d1fce9c2ca4963edaa9ad67becfeef/src%2Flibstd%2Fio%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmem.rs?ref=a2a6720959d1fce9c2ca4963edaa9ad67becfeef", "patch": "@@ -408,4 +408,24 @@ mod test {\n         let mut r = BufReader::new(bytes!(0x80));\n         assert_eq!(r.read_char(), None);\n     }\n+\n+    #[test]\n+    fn test_write_strings() {\n+        let mut writer = MemWriter::new();\n+        writer.write_str(\"testing\");\n+        writer.write_line(\"testing\");\n+        writer.write_str(\"testing\");\n+        let mut r = BufReader::new(*writer.inner_ref());\n+        assert_eq!(r.read_to_str(), ~\"testingtesting\\ntesting\");\n+    }\n+\n+    #[test]\n+    fn test_read_whole_string_bad() {\n+        let buf = [0xff];\n+        let mut r = BufReader::new(buf);\n+        match result(|| r.read_to_str()) {\n+            Ok(..) => fail!(),\n+            Err(..) => {}\n+        }\n+    }\n }"}, {"sha": "53b25f6fe98a28e444d3856d6d78e5e1ce70dc13", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 53, "deletions": 24, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/a2a6720959d1fce9c2ca4963edaa9ad67becfeef/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2a6720959d1fce9c2ca4963edaa9ad67becfeef/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=a2a6720959d1fce9c2ca4963edaa9ad67becfeef", "patch": "@@ -407,6 +407,7 @@ pub enum IoErrorKind {\n     MismatchedFileTypeForOperation,\n     ResourceUnavailable,\n     IoUnavailable,\n+    InvalidInput,\n }\n \n // FIXME: #8242 implementing manually because deriving doesn't work for some reason\n@@ -430,6 +431,7 @@ impl ToStr for IoErrorKind {\n             IoUnavailable => ~\"IoUnavailable\",\n             ResourceUnavailable => ~\"ResourceUnavailable\",\n             ConnectionAborted => ~\"ConnectionAborted\",\n+            InvalidInput => ~\"InvalidInput\",\n         }\n     }\n }\n@@ -601,6 +603,23 @@ pub trait Reader {\n         return buf;\n     }\n \n+    /// Reads all of the remaining bytes of this stream, interpreting them as a\n+    /// UTF-8 encoded stream. The corresponding string is returned.\n+    ///\n+    /// # Failure\n+    ///\n+    /// This function will raise all the same conditions as the `read` method,\n+    /// along with raising a condition if the input is not valid UTF-8.\n+    fn read_to_str(&mut self) -> ~str {\n+        match str::from_utf8_owned_opt(self.read_to_end()) {\n+            Some(s) => s,\n+            None => {\n+                io_error::cond.raise(standard_error(InvalidInput));\n+                ~\"\"\n+            }\n+        }\n+    }\n+\n     /// Create an iterator that reads a single byte on\n     /// each iteration, until EOF.\n     ///\n@@ -861,6 +880,28 @@ pub trait Writer {\n     /// decide whether their stream needs to be buffered or not.\n     fn flush(&mut self) {}\n \n+    /// Write a rust string into this sink.\n+    ///\n+    /// The bytes written will be the UTF-8 encoded version of the input string.\n+    /// If other encodings are desired, it is recommended to compose this stream\n+    /// with another performing the conversion, or to use `write` with a\n+    /// converted byte-array instead.\n+    fn write_str(&mut self, s: &str) {\n+        self.write(s.as_bytes());\n+    }\n+\n+    /// Writes a string into this sink, and then writes a literal newline (`\\n`)\n+    /// byte afterwards. Note that the writing of the newline is *not* atomic in\n+    /// the sense that the call to `write` is invoked twice (once with the\n+    /// string and once with a newline character).\n+    ///\n+    /// If other encodings or line ending flavors are desired, it is recommended\n+    /// that the `write` method is used specifically instead.\n+    fn write_line(&mut self, s: &str) {\n+        self.write_str(s);\n+        self.write(['\\n' as u8]);\n+    }\n+\n     /// Write the result of passing n through `int::to_str_bytes`.\n     fn write_int(&mut self, n: int) {\n         int::to_str_bytes(n, 10u, |bytes| self.write(bytes))\n@@ -1053,7 +1094,7 @@ pub trait Buffer: Reader {\n     /// so they should no longer be returned in calls to `fill` or `read`.\n     fn consume(&mut self, amt: uint);\n \n-    /// Reads the next line of input, interpreted as a sequence of utf-8\n+    /// Reads the next line of input, interpreted as a sequence of UTF-8\n     /// encoded unicode codepoints. If a newline is encountered, then the\n     /// newline is contained in the returned string.\n     ///\n@@ -1062,7 +1103,7 @@ pub trait Buffer: Reader {\n     /// This function will raise on the `io_error` condition (except for\n     /// `EndOfFile` which is swallowed) if a read error is encountered.\n     /// The task will also fail if sequence of bytes leading up to\n-    /// the newline character are not valid utf-8.\n+    /// the newline character are not valid UTF-8.\n     fn read_line(&mut self) -> Option<~str> {\n         self.read_until('\\n' as u8).map(str::from_utf8_owned)\n     }\n@@ -1246,29 +1287,17 @@ pub trait Decorator<T> {\n }\n \n pub fn standard_error(kind: IoErrorKind) -> IoError {\n-    match kind {\n-        PreviousIoError => {\n-            IoError {\n-                kind: PreviousIoError,\n-                desc: \"Failing due to a previous I/O error\",\n-                detail: None\n-            }\n-        }\n-        EndOfFile => {\n-            IoError {\n-                kind: EndOfFile,\n-                desc: \"End of file\",\n-                detail: None\n-            }\n-        }\n-        IoUnavailable => {\n-            IoError {\n-                kind: IoUnavailable,\n-                desc: \"I/O is unavailable\",\n-                detail: None\n-            }\n-        }\n+    let desc = match kind {\n+        PreviousIoError => \"failing due to previous I/O error\",\n+        EndOfFile => \"end of file\",\n+        IoUnavailable => \"I/O is unavailable\",\n+        InvalidInput => \"invalid input\",\n         _ => fail!()\n+    };\n+    IoError {\n+        kind: kind,\n+        desc: desc,\n+        detail: None,\n     }\n }\n "}]}