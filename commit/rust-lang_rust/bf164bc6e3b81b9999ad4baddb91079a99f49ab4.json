{"sha": "bf164bc6e3b81b9999ad4baddb91079a99f49ab4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJmMTY0YmM2ZTNiODFiOTk5OWFkNGJhZGRiOTEwNzlhOTlmNDlhYjQ=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "arielb1@mail.tau.ac.il", "date": "2015-06-29T21:32:39Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "arielb1@mail.tau.ac.il", "date": "2015-06-29T22:33:16Z"}, "message": "Fix lifetime elision region accounting\n\nThis merges accumulate_regions_in_type with ty_fold::collect_regions.\nFixes #26638", "tree": {"sha": "641501a489ffa73e43bb5d38761f36e671101945", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/641501a489ffa73e43bb5d38761f36e671101945"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bf164bc6e3b81b9999ad4baddb91079a99f49ab4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bf164bc6e3b81b9999ad4baddb91079a99f49ab4", "html_url": "https://github.com/rust-lang/rust/commit/bf164bc6e3b81b9999ad4baddb91079a99f49ab4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bf164bc6e3b81b9999ad4baddb91079a99f49ab4/comments", "author": null, "committer": null, "parents": [{"sha": "a1110bc3a33e1fd4e08e7532bb9cd28a0216016e", "url": "https://api.github.com/repos/rust-lang/rust/commits/a1110bc3a33e1fd4e08e7532bb9cd28a0216016e", "html_url": "https://github.com/rust-lang/rust/commit/a1110bc3a33e1fd4e08e7532bb9cd28a0216016e"}], "stats": {"total": 366, "additions": 187, "deletions": 179}, "files": [{"sha": "64063623f6776f7a92840bf81086e87267d5556e", "filename": "src/librustc/middle/infer/higher_ranked/mod.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/bf164bc6e3b81b9999ad4baddb91079a99f49ab4/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf164bc6e3b81b9999ad4baddb91079a99f49ab4/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=bf164bc6e3b81b9999ad4baddb91079a99f49ab4", "patch": "@@ -359,7 +359,7 @@ fn fold_regions_in<'tcx, T, F>(tcx: &ty::ctxt<'tcx>,\n     where T: TypeFoldable<'tcx>,\n           F: FnMut(ty::Region, ty::DebruijnIndex) -> ty::Region,\n {\n-    unbound_value.fold_with(&mut ty_fold::RegionFolder::new(tcx, &mut |region, current_depth| {\n+    ty_fold::fold_regions(tcx, unbound_value, &mut false, |region, current_depth| {\n         // we should only be encountering \"escaping\" late-bound regions here,\n         // because the ones at the current level should have been replaced\n         // with fresh variables\n@@ -369,7 +369,7 @@ fn fold_regions_in<'tcx, T, F>(tcx: &ty::ctxt<'tcx>,\n         });\n \n         fldr(region, ty::DebruijnIndex::new(current_depth))\n-    }))\n+    })\n }\n \n impl<'a,'tcx> InferCtxtExt for InferCtxt<'a,'tcx> {\n@@ -437,11 +437,10 @@ impl<'a,'tcx> InferCtxtExt for InferCtxt<'a,'tcx> {\n         let escaping_types =\n             self.type_variables.borrow().types_escaping_snapshot(&snapshot.type_snapshot);\n \n-        let escaping_region_vars: FnvHashSet<_> =\n-            escaping_types\n-            .iter()\n-            .flat_map(|&t| ty_fold::collect_regions(self.tcx, &t))\n-            .collect();\n+        let mut escaping_region_vars = FnvHashSet();\n+        for ty in &escaping_types {\n+            ty_fold::collect_regions(self.tcx, ty, &mut escaping_region_vars);\n+        }\n \n         region_vars.retain(|&region_vid| {\n             let r = ty::ReInfer(ty::ReVar(region_vid));\n@@ -649,7 +648,7 @@ pub fn plug_leaks<'a,'tcx,T>(infcx: &InferCtxt<'a,'tcx>,\n     // binder is that we encountered in `value`. The caller is\n     // responsible for ensuring that (a) `value` contains at least one\n     // binder and (b) that binder is the one we want to use.\n-    let result = ty_fold::fold_regions(infcx.tcx, &value, |r, current_depth| {\n+    let result = ty_fold::fold_regions(infcx.tcx, &value, &mut false, |r, current_depth| {\n         match inv_skol_map.get(&r) {\n             None => r,\n             Some(br) => {"}, {"sha": "1bed9c4e0a834514cbdd6f863c8d966ee9396977", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 12, "deletions": 55, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/bf164bc6e3b81b9999ad4baddb91079a99f49ab4/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf164bc6e3b81b9999ad4baddb91079a99f49ab4/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=bf164bc6e3b81b9999ad4baddb91079a99f49ab4", "patch": "@@ -1713,6 +1713,16 @@ impl Region {\n             _ => false,\n         }\n     }\n+\n+    /// Returns the depth of `self` from the (1-based) binding level `depth`\n+    pub fn from_depth(&self, depth: u32) -> Region {\n+        match *self {\n+            ty::ReLateBound(debruijn, r) => ty::ReLateBound(DebruijnIndex {\n+                depth: debruijn.depth - (depth - 1)\n+            }, r),\n+            r => r\n+        }\n+    }\n }\n \n #[derive(Clone, PartialEq, PartialOrd, Eq, Ord, Hash,\n@@ -6783,60 +6793,6 @@ pub enum ExplicitSelfCategory {\n     ByBoxExplicitSelfCategory,\n }\n \n-impl<'tcx> TyS<'tcx> {\n-    /// Pushes all the lifetimes in the given type onto the given list. A\n-    /// \"lifetime in a type\" is a lifetime specified by a reference or a lifetime\n-    /// in a list of type substitutions. This does *not* traverse into nominal\n-    /// types, nor does it resolve fictitious types.\n-    pub fn accumulate_lifetimes_in_type(&self, accumulator: &mut Vec<ty::Region>) {\n-        for ty in self.walk() {\n-            match ty.sty {\n-                TyRef(region, _) => {\n-                    accumulator.push(*region)\n-                }\n-                TyTrait(ref t) => {\n-                    accumulator.push_all(t.principal.0.substs.regions().as_slice());\n-                }\n-                TyEnum(_, substs) |\n-                TyStruct(_, substs) => {\n-                    accum_substs(accumulator, substs);\n-                }\n-                TyClosure(_, substs) => {\n-                    accum_substs(accumulator, substs);\n-                }\n-                TyBool |\n-                TyChar |\n-                TyInt(_) |\n-                TyUint(_) |\n-                TyFloat(_) |\n-                TyBox(_) |\n-                TyStr |\n-                TyArray(_, _) |\n-                TySlice(_) |\n-                TyRawPtr(_) |\n-                TyBareFn(..) |\n-                TyTuple(_) |\n-                TyProjection(_) |\n-                TyParam(_) |\n-                TyInfer(_) |\n-                TyError => {\n-                }\n-            }\n-        }\n-\n-        fn accum_substs(accumulator: &mut Vec<Region>, substs: &Substs) {\n-            match substs.regions {\n-                subst::ErasedRegions => {}\n-                subst::NonerasedRegions(ref regions) => {\n-                    for region in regions {\n-                        accumulator.push(*region)\n-                    }\n-                }\n-            }\n-        }\n-    }\n-}\n-\n /// A free variable referred to in a function.\n #[derive(Copy, Clone, RustcEncodable, RustcDecodable)]\n pub struct Freevar {\n@@ -6917,7 +6873,8 @@ impl<'tcx> ctxt<'tcx> {\n         where T: TypeFoldable<'tcx>\n     {\n         let bound0_value = bound2_value.skip_binder().skip_binder();\n-        let value = ty_fold::fold_regions(self, bound0_value, |region, current_depth| {\n+        let value = ty_fold::fold_regions(self, bound0_value, &mut false,\n+                                          |region, current_depth| {\n             match region {\n                 ty::ReLateBound(debruijn, br) if debruijn.depth >= current_depth => {\n                     // should be true if no escaping regions from bound2_value"}, {"sha": "284d26b3cd6d773331005b21799490dc0b5b7403", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 22, "deletions": 8, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/bf164bc6e3b81b9999ad4baddb91079a99f49ab4/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf164bc6e3b81b9999ad4baddb91079a99f49ab4/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=bf164bc6e3b81b9999ad4baddb91079a99f49ab4", "patch": "@@ -44,7 +44,7 @@ use std::rc::Rc;\n use syntax::abi;\n use syntax::ast;\n use syntax::owned_slice::OwnedSlice;\n-use util::nodemap::FnvHashMap;\n+use util::nodemap::{FnvHashMap, FnvHashSet};\n \n ///////////////////////////////////////////////////////////////////////////\n // Two generic traits\n@@ -783,38 +783,51 @@ impl<'a, 'tcx, F> TypeFolder<'tcx> for BottomUpFolder<'a, 'tcx, F> where\n \n pub struct RegionFolder<'a, 'tcx: 'a> {\n     tcx: &'a ty::ctxt<'tcx>,\n+    skipped_regions: &'a mut bool,\n     current_depth: u32,\n     fld_r: &'a mut (FnMut(ty::Region, u32) -> ty::Region + 'a),\n }\n \n impl<'a, 'tcx> RegionFolder<'a, 'tcx> {\n-    pub fn new<F>(tcx: &'a ty::ctxt<'tcx>, fld_r: &'a mut F) -> RegionFolder<'a, 'tcx>\n+    pub fn new<F>(tcx: &'a ty::ctxt<'tcx>,\n+                  skipped_regions: &'a mut bool,\n+                  fld_r: &'a mut F) -> RegionFolder<'a, 'tcx>\n         where F : FnMut(ty::Region, u32) -> ty::Region\n     {\n         RegionFolder {\n             tcx: tcx,\n+            skipped_regions: skipped_regions,\n             current_depth: 1,\n             fld_r: fld_r,\n         }\n     }\n }\n \n-pub fn collect_regions<'tcx,T>(tcx: &ty::ctxt<'tcx>, value: &T) -> Vec<ty::Region>\n+/// Collects the free and escaping regions in `value` into `region_set`. Returns\n+/// whether any late-bound regions were skipped\n+pub fn collect_regions<'tcx,T>(tcx: &ty::ctxt<'tcx>,\n+                               value: &T,\n+                               region_set: &mut FnvHashSet<ty::Region>) -> bool\n     where T : TypeFoldable<'tcx>\n {\n-    let mut vec = Vec::new();\n-    fold_regions(tcx, value, |r, _| { vec.push(r); r });\n-    vec\n+    let mut have_bound_regions = false;\n+    fold_regions(tcx, value, &mut have_bound_regions,\n+                 |r, d| { region_set.insert(r.from_depth(d)); r });\n+    have_bound_regions\n }\n \n+/// Folds the escaping and free regions in `value` using `f`, and\n+/// sets `skipped_regions` to true if any late-bound region was found\n+/// and skipped.\n pub fn fold_regions<'tcx,T,F>(tcx: &ty::ctxt<'tcx>,\n                               value: &T,\n+                              skipped_regions: &mut bool,\n                               mut f: F)\n                               -> T\n     where F : FnMut(ty::Region, u32) -> ty::Region,\n           T : TypeFoldable<'tcx>,\n {\n-    value.fold_with(&mut RegionFolder::new(tcx, &mut f))\n+    value.fold_with(&mut RegionFolder::new(tcx, skipped_regions, &mut f))\n }\n \n impl<'a, 'tcx> TypeFolder<'tcx> for RegionFolder<'a, 'tcx>\n@@ -834,6 +847,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for RegionFolder<'a, 'tcx>\n             ty::ReLateBound(debruijn, _) if debruijn.depth < self.current_depth => {\n                 debug!(\"RegionFolder.fold_region({:?}) skipped bound region (current depth={})\",\n                        r, self.current_depth);\n+                *self.skipped_regions = true;\n                 r\n             }\n             _ => {\n@@ -989,7 +1003,7 @@ pub fn shift_regions<'tcx, T:TypeFoldable<'tcx>>(tcx: &ty::ctxt<'tcx>,\n     debug!(\"shift_regions(value={:?}, amount={})\",\n            value, amount);\n \n-    value.fold_with(&mut RegionFolder::new(tcx, &mut |region, _current_depth| {\n+    value.fold_with(&mut RegionFolder::new(tcx, &mut false, &mut |region, _current_depth| {\n         shift_region(region, amount)\n     }))\n }"}, {"sha": "3e9a402f9499c15666a731ff5ab58ea7069f8f6e", "filename": "src/librustc/middle/ty_walk.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bf164bc6e3b81b9999ad4baddb91079a99f49ab4/src%2Flibrustc%2Fmiddle%2Fty_walk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf164bc6e3b81b9999ad4baddb91079a99f49ab4/src%2Flibrustc%2Fmiddle%2Fty_walk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_walk.rs?ref=bf164bc6e3b81b9999ad4baddb91079a99f49ab4", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n //! An iterator over the type substructure.\n+//! WARNING: this does not keep track of the region depth.\n \n use middle::ty::{self, Ty};\n use std::iter::Iterator;"}, {"sha": "a55a8ff109e662a47858b939c75e8c9f3fbfd94a", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 104, "deletions": 95, "changes": 199, "blob_url": "https://github.com/rust-lang/rust/blob/bf164bc6e3b81b9999ad4baddb91079a99f49ab4/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf164bc6e3b81b9999ad4baddb91079a99f49ab4/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=bf164bc6e3b81b9999ad4baddb91079a99f49ab4", "patch": "@@ -59,7 +59,8 @@ use middle::traits;\n use middle::ty::{self, RegionEscape, Ty, ToPredicate, HasTypeFlags};\n use middle::ty_fold;\n use rscope::{self, UnelidableRscope, RegionScope, ElidableRscope, ExplicitRscope,\n-             ObjectLifetimeDefaultRscope, ShiftedRscope, BindingRscope};\n+             ObjectLifetimeDefaultRscope, ShiftedRscope, BindingRscope,\n+             ElisionFailureInfo, ElidedLifetime};\n use util::common::{ErrorReported, FN_OUTPUT_NAME};\n use util::nodemap::FnvHashSet;\n \n@@ -186,6 +187,58 @@ pub fn ast_region_to_region(tcx: &ty::ctxt, lifetime: &ast::Lifetime)\n     r\n }\n \n+fn report_elision_failure(\n+    tcx: &ty::ctxt,\n+    default_span: Span,\n+    params: Vec<ElisionFailureInfo>)\n+{\n+    let mut m = String::new();\n+    let len = params.len();\n+    for (i, info) in params.into_iter().enumerate() {\n+        let ElisionFailureInfo {\n+            name, lifetime_count: n, have_bound_regions\n+        } = info;\n+\n+        let help_name = if name.is_empty() {\n+            format!(\"argument {}\", i + 1)\n+        } else {\n+            format!(\"`{}`\", name)\n+        };\n+\n+        m.push_str(&(if n == 1 {\n+            help_name\n+        } else {\n+            format!(\"one of {}'s {} elided {}lifetimes\", help_name, n,\n+                    if have_bound_regions { \"free \" } else { \"\" } )\n+        })[..]);\n+\n+        if len == 2 && i == 0 {\n+            m.push_str(\" or \");\n+        } else if i + 2 == len {\n+            m.push_str(\", or \");\n+        } else if i + 1 != len {\n+            m.push_str(\", \");\n+        }\n+    }\n+    if len == 1 {\n+        fileline_help!(tcx.sess, default_span,\n+                       \"this function's return type contains a borrowed value, but \\\n+                        the signature does not say which {} it is borrowed from\",\n+                       m);\n+    } else if len == 0 {\n+        fileline_help!(tcx.sess, default_span,\n+                       \"this function's return type contains a borrowed value, but \\\n+                        there is no value for it to be borrowed from\");\n+        fileline_help!(tcx.sess, default_span,\n+                       \"consider giving it a 'static lifetime\");\n+    } else {\n+        fileline_help!(tcx.sess, default_span,\n+                       \"this function's return type contains a borrowed value, but \\\n+                        the signature does not say whether it is borrowed from {}\",\n+                       m);\n+    }\n+}\n+\n pub fn opt_ast_region_to_region<'tcx>(\n     this: &AstConv<'tcx>,\n     rscope: &RegionScope,\n@@ -197,61 +250,15 @@ pub fn opt_ast_region_to_region<'tcx>(\n             ast_region_to_region(this.tcx(), lifetime)\n         }\n \n-        None => {\n-            match rscope.anon_regions(default_span, 1) {\n-                Err(v) => {\n-                    debug!(\"optional region in illegal location\");\n-                    span_err!(this.tcx().sess, default_span, E0106,\n-                        \"missing lifetime specifier\");\n-                    match v {\n-                        Some(v) => {\n-                            let mut m = String::new();\n-                            let len = v.len();\n-                            for (i, (name, n)) in v.into_iter().enumerate() {\n-                                let help_name = if name.is_empty() {\n-                                    format!(\"argument {}\", i + 1)\n-                                } else {\n-                                    format!(\"`{}`\", name)\n-                                };\n-\n-                                m.push_str(&(if n == 1 {\n-                                    help_name\n-                                } else {\n-                                    format!(\"one of {}'s {} elided lifetimes\", help_name, n)\n-                                })[..]);\n-\n-                                if len == 2 && i == 0 {\n-                                    m.push_str(\" or \");\n-                                } else if i + 2 == len {\n-                                    m.push_str(\", or \");\n-                                } else if i + 1 != len {\n-                                    m.push_str(\", \");\n-                                }\n-                            }\n-                            if len == 1 {\n-                                fileline_help!(this.tcx().sess, default_span,\n-                                    \"this function's return type contains a borrowed value, but \\\n-                                     the signature does not say which {} it is borrowed from\",\n-                                    m);\n-                            } else if len == 0 {\n-                                fileline_help!(this.tcx().sess, default_span,\n-                                    \"this function's return type contains a borrowed value, but \\\n-                                     there is no value for it to be borrowed from\");\n-                                fileline_help!(this.tcx().sess, default_span,\n-                                    \"consider giving it a 'static lifetime\");\n-                            } else {\n-                                fileline_help!(this.tcx().sess, default_span,\n-                                    \"this function's return type contains a borrowed value, but \\\n-                                     the signature does not say whether it is borrowed from {}\",\n-                                    m);\n-                            }\n-                        }\n-                        None => {},\n-                    }\n-                    ty::ReStatic\n+        None => match rscope.anon_regions(default_span, 1) {\n+            Ok(rs) => rs[0],\n+            Err(params) => {\n+                span_err!(this.tcx().sess, default_span, E0106,\n+                          \"missing lifetime specifier\");\n+                if let Some(params) = params {\n+                    report_elision_failure(this.tcx(), default_span, params);\n                 }\n-\n-                Ok(rs) => rs[0],\n+                ty::ReStatic\n             }\n         }\n     };\n@@ -505,48 +512,54 @@ fn convert_angle_bracketed_parameters<'tcx>(this: &AstConv<'tcx>,\n /// Returns the appropriate lifetime to use for any output lifetimes\n /// (if one exists) and a vector of the (pattern, number of lifetimes)\n /// corresponding to each input type/pattern.\n-fn find_implied_output_region(input_tys: &[Ty], input_pats: Vec<String>)\n-                              -> (Option<ty::Region>, Vec<(String, usize)>)\n+fn find_implied_output_region<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                    input_tys: &[Ty<'tcx>],\n+                                    input_pats: Vec<String>) -> ElidedLifetime\n {\n-    let mut lifetimes_for_params: Vec<(String, usize)> = Vec::new();\n+    let mut lifetimes_for_params = Vec::new();\n     let mut possible_implied_output_region = None;\n \n     for (input_type, input_pat) in input_tys.iter().zip(input_pats) {\n-        let mut accumulator = Vec::new();\n-        input_type.accumulate_lifetimes_in_type(&mut accumulator);\n+        let mut regions = FnvHashSet();\n+        let have_bound_regions = ty_fold::collect_regions(tcx,\n+                                                          input_type,\n+                                                          &mut regions);\n \n-        if accumulator.len() == 1 {\n+        debug!(\"find_implied_output_regions: collected {:?} from {:?} \\\n+                have_bound_regions={:?}\", &regions, input_type, have_bound_regions);\n+\n+        if regions.len() == 1 {\n             // there's a chance that the unique lifetime of this\n             // iteration will be the appropriate lifetime for output\n             // parameters, so lets store it.\n-            possible_implied_output_region = Some(accumulator[0])\n+            possible_implied_output_region = regions.iter().cloned().next();\n         }\n \n-        lifetimes_for_params.push((input_pat, accumulator.len()));\n+        lifetimes_for_params.push(ElisionFailureInfo {\n+            name: input_pat,\n+            lifetime_count: regions.len(),\n+            have_bound_regions: have_bound_regions\n+        });\n     }\n \n-    let implied_output_region =\n-        if lifetimes_for_params.iter().map(|&(_, n)| n).sum::<usize>() == 1 {\n-            assert!(possible_implied_output_region.is_some());\n-            possible_implied_output_region\n-        } else {\n-            None\n-        };\n-    (implied_output_region, lifetimes_for_params)\n+    if lifetimes_for_params.iter().map(|e| e.lifetime_count).sum::<usize>() == 1 {\n+        Ok(possible_implied_output_region.unwrap())\n+    } else {\n+        Err(Some(lifetimes_for_params))\n+    }\n }\n \n fn convert_ty_with_lifetime_elision<'tcx>(this: &AstConv<'tcx>,\n-                                          implied_output_region: Option<ty::Region>,\n-                                          param_lifetimes: Vec<(String, usize)>,\n+                                          elided_lifetime: ElidedLifetime,\n                                           ty: &ast::Ty)\n                                           -> Ty<'tcx>\n {\n-    match implied_output_region {\n-        Some(implied_output_region) => {\n+    match elided_lifetime {\n+        Ok(implied_output_region) => {\n             let rb = ElidableRscope::new(implied_output_region);\n             ast_ty_to_ty(this, &rb, ty)\n         }\n-        None => {\n+        Err(param_lifetimes) => {\n             // All regions must be explicitly specified in the output\n             // if the lifetime elision rules do not apply. This saves\n             // the user from potentially-confusing errors.\n@@ -576,17 +589,15 @@ fn convert_parenthesized_parameters<'tcx>(this: &AstConv<'tcx>,\n                    .collect::<Vec<Ty<'tcx>>>();\n \n     let input_params: Vec<_> = repeat(String::new()).take(inputs.len()).collect();\n-    let (implied_output_region,\n-         params_lifetimes) = find_implied_output_region(&*inputs, input_params);\n+    let implied_output_region = find_implied_output_region(this.tcx(), &inputs, input_params);\n \n     let input_ty = this.tcx().mk_tup(inputs);\n \n     let (output, output_span) = match data.output {\n         Some(ref output_ty) => {\n             (convert_ty_with_lifetime_elision(this,\n                                               implied_output_region,\n-                                              params_lifetimes,\n-                                              &**output_ty),\n+                                              &output_ty),\n              output_ty.span)\n         }\n         None => {\n@@ -1705,7 +1716,7 @@ fn ty_of_method_or_bare_fn<'a, 'tcx>(this: &AstConv<'tcx>,\n     // here), if self is by-reference, then the implied output region is the\n     // region of the self parameter.\n     let mut explicit_self_category_result = None;\n-    let (self_ty, mut implied_output_region) = match opt_self_info {\n+    let (self_ty, implied_output_region) = match opt_self_info {\n         None => (None, None),\n         Some(self_info) => {\n             // This type comes from an impl or trait; no late-bound\n@@ -1756,19 +1767,18 @@ fn ty_of_method_or_bare_fn<'a, 'tcx>(this: &AstConv<'tcx>,\n     // Second, if there was exactly one lifetime (either a substitution or a\n     // reference) in the arguments, then any anonymous regions in the output\n     // have that lifetime.\n-    let lifetimes_for_params = if implied_output_region.is_none() {\n-        let input_tys = if self_ty.is_some() {\n-            // Skip the first argument if `self` is present.\n-            &self_and_input_tys[1..]\n-        } else {\n-            &self_and_input_tys[..]\n-        };\n+    let implied_output_region = match implied_output_region {\n+        Some(r) => Ok(r),\n+        None => {\n+            let input_tys = if self_ty.is_some() {\n+                // Skip the first argument if `self` is present.\n+                &self_and_input_tys[1..]\n+            } else {\n+                &self_and_input_tys[..]\n+            };\n \n-        let (ior, lfp) = find_implied_output_region(input_tys, input_pats);\n-        implied_output_region = ior;\n-        lfp\n-    } else {\n-        vec![]\n+            find_implied_output_region(this.tcx(), input_tys, input_pats)\n+        }\n     };\n \n     let output_ty = match decl.output {\n@@ -1777,8 +1787,7 @@ fn ty_of_method_or_bare_fn<'a, 'tcx>(this: &AstConv<'tcx>,\n         ast::Return(ref output) =>\n             ty::FnConverging(convert_ty_with_lifetime_elision(this,\n                                                               implied_output_region,\n-                                                              lifetimes_for_params,\n-                                                              &**output)),\n+                                                              &output)),\n         ast::DefaultReturn(..) => ty::FnConverging(this.tcx().mk_nil()),\n         ast::NoReturn(..) => ty::FnDiverging\n     };"}, {"sha": "2db1598db4bee02fb758a85e544e21163f6230e5", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bf164bc6e3b81b9999ad4baddb91079a99f49ab4/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf164bc6e3b81b9999ad4baddb91079a99f49ab4/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=bf164bc6e3b81b9999ad4baddb91079a99f49ab4", "patch": "@@ -97,7 +97,7 @@ use middle::ty::{Disr, ParamTy, ParameterEnvironment};\n use middle::ty::{self, HasTypeFlags, RegionEscape, ToPolyTraitRef, Ty};\n use middle::ty::{MethodCall, MethodCallee};\n use middle::ty_fold::{TypeFolder, TypeFoldable};\n-use rscope::RegionScope;\n+use rscope::{ElisionFailureInfo, RegionScope};\n use session::Session;\n use {CrateCtxt, lookup_full_def, require_same_types};\n use TypeAndSubsts;\n@@ -1796,7 +1796,7 @@ impl<'a, 'tcx> RegionScope for FnCtxt<'a, 'tcx> {\n     }\n \n     fn anon_regions(&self, span: Span, count: usize)\n-                    -> Result<Vec<ty::Region>, Option<Vec<(String, usize)>>> {\n+                    -> Result<Vec<ty::Region>, Option<Vec<ElisionFailureInfo>>> {\n         Ok((0..count).map(|_| {\n             self.infcx().next_region_var(infer::MiscVariable(span))\n         }).collect())"}, {"sha": "7909908079fb38ca1938887dc0cffc643605870e", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf164bc6e3b81b9999ad4baddb91079a99f49ab4/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf164bc6e3b81b9999ad4baddb91079a99f49ab4/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=bf164bc6e3b81b9999ad4baddb91079a99f49ab4", "patch": "@@ -2248,7 +2248,7 @@ fn check_method_self_type<'a, 'tcx, RS:RegionScope>(\n          * before we really have a `ParameterEnvironment` to check.\n          */\n \n-        ty_fold::fold_regions(tcx, value, |region, _| {\n+        ty_fold::fold_regions(tcx, value, &mut false, |region, _| {\n             match region {\n                 ty::ReEarlyBound(data) => {\n                     let def_id = local_def(data.param_id);"}, {"sha": "b416026ba01340d7bc5f71b32b2e5b5c9c61a270", "filename": "src/librustc_typeck/rscope.rs", "status": "modified", "additions": 19, "deletions": 10, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/bf164bc6e3b81b9999ad4baddb91079a99f49ab4/src%2Flibrustc_typeck%2Frscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf164bc6e3b81b9999ad4baddb91079a99f49ab4/src%2Flibrustc_typeck%2Frscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Frscope.rs?ref=bf164bc6e3b81b9999ad4baddb91079a99f49ab4", "patch": "@@ -16,6 +16,15 @@ use std::cell::Cell;\n use std::iter::repeat;\n use syntax::codemap::Span;\n \n+#[derive(Clone)]\n+pub struct ElisionFailureInfo {\n+    pub name: String,\n+    pub lifetime_count: usize,\n+    pub have_bound_regions: bool\n+}\n+\n+pub type ElidedLifetime = Result<ty::Region, Option<Vec<ElisionFailureInfo>>>;\n+\n /// Defines strategies for handling regions that are omitted.  For\n /// example, if one writes the type `&Foo`, then the lifetime of\n /// this reference has been omitted. When converting this\n@@ -30,7 +39,7 @@ pub trait RegionScope {\n     fn anon_regions(&self,\n                     span: Span,\n                     count: usize)\n-                    -> Result<Vec<ty::Region>, Option<Vec<(String, usize)>>>;\n+                    -> Result<Vec<ty::Region>, Option<Vec<ElisionFailureInfo>>>;\n \n     /// If an object omits any explicit lifetime bound, and none can\n     /// be derived from the object traits, what should we use? If\n@@ -51,16 +60,16 @@ impl RegionScope for ExplicitRscope {\n     fn anon_regions(&self,\n                     _span: Span,\n                     _count: usize)\n-                    -> Result<Vec<ty::Region>, Option<Vec<(String, usize)>>> {\n+                    -> Result<Vec<ty::Region>, Option<Vec<ElisionFailureInfo>>> {\n         Err(None)\n     }\n }\n \n // Same as `ExplicitRscope`, but provides some extra information for diagnostics\n-pub struct UnelidableRscope(Vec<(String, usize)>);\n+pub struct UnelidableRscope(Option<Vec<ElisionFailureInfo>>);\n \n impl UnelidableRscope {\n-    pub fn new(v: Vec<(String, usize)>) -> UnelidableRscope {\n+    pub fn new(v: Option<Vec<ElisionFailureInfo>>) -> UnelidableRscope {\n         UnelidableRscope(v)\n     }\n }\n@@ -73,9 +82,9 @@ impl RegionScope for UnelidableRscope {\n     fn anon_regions(&self,\n                     _span: Span,\n                     _count: usize)\n-                    -> Result<Vec<ty::Region>, Option<Vec<(String, usize)>>> {\n+                    -> Result<Vec<ty::Region>, Option<Vec<ElisionFailureInfo>>> {\n         let UnelidableRscope(ref v) = *self;\n-        Err(Some(v.clone()))\n+        Err(v.clone())\n     }\n }\n \n@@ -104,7 +113,7 @@ impl RegionScope for ElidableRscope {\n     fn anon_regions(&self,\n                     _span: Span,\n                     count: usize)\n-                    -> Result<Vec<ty::Region>, Option<Vec<(String, usize)>>>\n+                    -> Result<Vec<ty::Region>, Option<Vec<ElisionFailureInfo>>>\n     {\n         Ok(repeat(self.default).take(count).collect())\n     }\n@@ -141,7 +150,7 @@ impl RegionScope for BindingRscope {\n     fn anon_regions(&self,\n                     _: Span,\n                     count: usize)\n-                    -> Result<Vec<ty::Region>, Option<Vec<(String, usize)>>>\n+                    -> Result<Vec<ty::Region>, Option<Vec<ElisionFailureInfo>>>\n     {\n         Ok((0..count).map(|_| self.next_region()).collect())\n     }\n@@ -177,7 +186,7 @@ impl<'r> RegionScope for ObjectLifetimeDefaultRscope<'r> {\n     fn anon_regions(&self,\n                     span: Span,\n                     count: usize)\n-                    -> Result<Vec<ty::Region>, Option<Vec<(String, usize)>>>\n+                    -> Result<Vec<ty::Region>, Option<Vec<ElisionFailureInfo>>>\n     {\n         self.base_scope.anon_regions(span, count)\n     }\n@@ -204,7 +213,7 @@ impl<'r> RegionScope for ShiftedRscope<'r> {\n     fn anon_regions(&self,\n                     span: Span,\n                     count: usize)\n-                    -> Result<Vec<ty::Region>, Option<Vec<(String, usize)>>>\n+                    -> Result<Vec<ty::Region>, Option<Vec<ElisionFailureInfo>>>\n     {\n         match self.base_scope.anon_regions(span, count) {\n             Ok(mut v) => {"}, {"sha": "edb9ab47fc611c0a656d560846b2c556a4927fb3", "filename": "src/test/compile-fail/issue-26638.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/bf164bc6e3b81b9999ad4baddb91079a99f49ab4/src%2Ftest%2Fcompile-fail%2Fissue-26638.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf164bc6e3b81b9999ad4baddb91079a99f49ab4/src%2Ftest%2Fcompile-fail%2Fissue-26638.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-26638.rs?ref=bf164bc6e3b81b9999ad4baddb91079a99f49ab4", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn parse_type(iter: Box<Iterator<Item=&str>+'static>) -> &str { iter.next() }\n+//~^ ERROR missing lifetime specifier [E0106]\n+//~^^ HELP 2 elided lifetimes\n+\n+fn parse_type_2(iter: fn(&u8)->&u8) -> &str { iter() }\n+//~^ ERROR missing lifetime specifier [E0106]\n+//~^^ HELP 0 elided free lifetimes\n+\n+fn main() {}"}]}