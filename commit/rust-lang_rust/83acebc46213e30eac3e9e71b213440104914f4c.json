{"sha": "83acebc46213e30eac3e9e71b213440104914f4c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgzYWNlYmM0NjIxM2UzMGVhYzNlOWU3MWIyMTM0NDAxMDQ5MTRmNGM=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "arielb1@mail.tau.ac.il", "date": "2015-05-05T16:36:47Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2015-05-19T14:42:14Z"}, "message": "Overhaul cast semantics and make them follow RFC401\n\nThis should hopefully fix all cast-related ICEs once and for all.\n\nI managed to make diagnostics hate me and give me spurious \"decoder error\"\n - removing $build/tmp/extended-errors seems to fix it.", "tree": {"sha": "340faa875f6734c4fb7d3def83a5e68b204134a4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/340faa875f6734c4fb7d3def83a5e68b204134a4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/83acebc46213e30eac3e9e71b213440104914f4c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/83acebc46213e30eac3e9e71b213440104914f4c", "html_url": "https://github.com/rust-lang/rust/commit/83acebc46213e30eac3e9e71b213440104914f4c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/83acebc46213e30eac3e9e71b213440104914f4c/comments", "author": null, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a172f4022dd8d63607860733f0ae8647d4651090", "url": "https://api.github.com/repos/rust-lang/rust/commits/a172f4022dd8d63607860733f0ae8647d4651090", "html_url": "https://github.com/rust-lang/rust/commit/a172f4022dd8d63607860733f0ae8647d4651090"}], "stats": {"total": 976, "additions": 611, "deletions": 365}, "files": [{"sha": "f5cb1bd25d60da512b5a725778be7e76d3e73296", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/83acebc46213e30eac3e9e71b213440104914f4c/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83acebc46213e30eac3e9e71b213440104914f4c/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=83acebc46213e30eac3e9e71b213440104914f4c", "patch": "@@ -801,7 +801,6 @@ struct Foo<T: 'static> {\n \n register_diagnostics! {\n     E0011,\n-    E0012,\n     E0014,\n     E0016,\n     E0017,"}, {"sha": "993d0dcf115df3313d638dbe3c533cf28956ce49", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/83acebc46213e30eac3e9e71b213440104914f4c/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83acebc46213e30eac3e9e71b213440104914f4c/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=83acebc46213e30eac3e9e71b213440104914f4c", "patch": "@@ -94,6 +94,7 @@ pub mod back {\n pub mod middle {\n     pub mod astconv_util;\n     pub mod astencode;\n+    pub mod cast;\n     pub mod cfg;\n     pub mod check_const;\n     pub mod check_static_recursion;"}, {"sha": "478c0f2f564f8dce1ab0860766bebc019ce4c60e", "filename": "src/librustc/metadata/common.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/83acebc46213e30eac3e9e71b213440104914f4c/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83acebc46213e30eac3e9e71b213440104914f4c/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcommon.rs?ref=83acebc46213e30eac3e9e71b213440104914f4c", "patch": "@@ -148,6 +148,7 @@ enum_from_u32! {\n         tag_table_capture_modes = 0x67,\n         tag_table_object_cast_map = 0x68,\n         tag_table_const_qualif = 0x69,\n+        tag_table_cast_kinds = 0x6a,\n     }\n }\n "}, {"sha": "e325c03d52db6bdc9060c8723c71dedbda0c5672", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/83acebc46213e30eac3e9e71b213440104914f4c/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83acebc46213e30eac3e9e71b213440104914f4c/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=83acebc46213e30eac3e9e71b213440104914f4c", "patch": "@@ -23,6 +23,7 @@ use metadata::tydecode;\n use metadata::tydecode::{DefIdSource, NominalType, TypeWithId, TypeParameter};\n use metadata::tydecode::{RegionParameter, ClosureSource};\n use metadata::tyencode;\n+use middle::cast;\n use middle::check_const::ConstQualif;\n use middle::mem_categorization::Typer;\n use middle::privacy::{AllPublic, LastMod};\n@@ -688,6 +689,10 @@ pub fn encode_closure_kind(ebml_w: &mut Encoder, kind: ty::ClosureKind) {\n     kind.encode(ebml_w).unwrap();\n }\n \n+pub fn encode_cast_kind(ebml_w: &mut Encoder, kind: cast::CastKind) {\n+    kind.encode(ebml_w).unwrap();\n+}\n+\n pub trait vtable_decoder_helpers<'tcx> {\n     fn read_vec_per_param_space<T, F>(&mut self, f: F) -> VecPerParamSpace<T> where\n         F: FnMut(&mut Self) -> T;\n@@ -1248,6 +1253,13 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n         })\n     }\n \n+    if let Some(cast_kind) = tcx.cast_kinds.borrow().get(&id) {\n+        rbml_w.tag(c::tag_table_cast_kinds, |rbml_w| {\n+            rbml_w.id(id);\n+            encode_cast_kind(rbml_w, *cast_kind)\n+        })\n+    }\n+\n     for &qualif in tcx.const_qualif_map.borrow().get(&id).iter() {\n         rbml_w.tag(c::tag_table_const_qualif, |rbml_w| {\n             rbml_w.id(id);\n@@ -1289,6 +1301,8 @@ trait rbml_decoder_decoder_helpers<'tcx> {\n                            -> subst::Substs<'tcx>;\n     fn read_auto_adjustment<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n                                     -> ty::AutoAdjustment<'tcx>;\n+    fn read_cast_kind<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n+                                 -> cast::CastKind;\n     fn read_closure_kind<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n                                  -> ty::ClosureKind;\n     fn read_closure_ty<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n@@ -1641,6 +1655,12 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n         }).unwrap()\n     }\n \n+    fn read_cast_kind<'b, 'c>(&mut self, _dcx: &DecodeContext<'b, 'c, 'tcx>)\n+                              -> cast::CastKind\n+    {\n+        Decodable::decode(self).unwrap()\n+    }\n+\n     fn read_closure_kind<'b, 'c>(&mut self, _dcx: &DecodeContext<'b, 'c, 'tcx>)\n                                  -> ty::ClosureKind\n     {\n@@ -1801,6 +1821,11 @@ fn decode_side_tables(dcx: &DecodeContext,\n                         dcx.tcx.closure_kinds.borrow_mut().insert(ast_util::local_def(id),\n                                                                   closure_kind);\n                     }\n+                    c::tag_table_cast_kinds => {\n+                        let cast_kind =\n+                            val_dsr.read_cast_kind(dcx);\n+                        dcx.tcx.cast_kinds.borrow_mut().insert(id, cast_kind);\n+                    }\n                     c::tag_table_const_qualif => {\n                         let qualif: ConstQualif = Decodable::decode(val_dsr).unwrap();\n                         dcx.tcx.const_qualif_map.borrow_mut().insert(id, qualif);"}, {"sha": "4b876cfd80fb6a08298c6a2569a89649daa0cb97", "filename": "src/librustc/middle/cast.rs", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/83acebc46213e30eac3e9e71b213440104914f4c/src%2Flibrustc%2Fmiddle%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83acebc46213e30eac3e9e71b213440104914f4c/src%2Flibrustc%2Fmiddle%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcast.rs?ref=83acebc46213e30eac3e9e71b213440104914f4c", "patch": "@@ -0,0 +1,71 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Helpers for handling cast expressions, used in both\n+// typeck and trans.\n+\n+use middle::ty::{self, Ty};\n+\n+use syntax::ast;\n+\n+\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+pub enum IntTy {\n+    U(ast::UintTy),\n+    I,\n+    CEnum,\n+    Bool,\n+    Char\n+}\n+\n+// Valid types for the result of a non-coercion cast\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+pub enum CastTy<'tcx> {\n+    Int(IntTy),\n+    Float,\n+    FPtr,\n+    Ptr(&'tcx ty::mt<'tcx>),\n+    RPtr(&'tcx ty::mt<'tcx>),\n+}\n+\n+/// Cast Kind. See RFC 401 (or librustc_typeck/check/cast.rs)\n+#[derive(Copy, Clone, Debug, RustcEncodable, RustcDecodable)]\n+pub enum CastKind {\n+    CoercionCast,\n+    PtrPtrCast,\n+    PtrAddrCast,\n+    AddrPtrCast,\n+    NumericCast,\n+    EnumCast,\n+    PrimIntCast,\n+    U8CharCast,\n+    ArrayPtrCast,\n+    FPtrPtrCast,\n+    FPtrAddrCast\n+}\n+\n+impl<'tcx> CastTy<'tcx> {\n+    pub fn recognize(tcx: &ty::ctxt<'tcx>, t: Ty<'tcx>)\n+                     -> Option<CastTy<'tcx>> {\n+        match t.sty {\n+            ty::ty_bool => Some(CastTy::Int(IntTy::Bool)),\n+            ty::ty_char => Some(CastTy::Int(IntTy::Char)),\n+            ty::ty_int(_) => Some(CastTy::Int(IntTy::I)),\n+            ty::ty_uint(u) => Some(CastTy::Int(IntTy::U(u))),\n+            ty::ty_float(_) => Some(CastTy::Float),\n+            ty::ty_enum(..) if ty::type_is_c_like_enum(\n+                tcx, t) => Some(CastTy::Int(IntTy::CEnum)),\n+            ty::ty_ptr(ref mt) => Some(CastTy::Ptr(mt)),\n+            ty::ty_rptr(_, ref mt) => Some(CastTy::RPtr(mt)),\n+            ty::ty_bare_fn(..) => Some(CastTy::FPtr),\n+            _ => None,\n+        }\n+    }\n+}"}, {"sha": "6d2465a5cb9d2e14bd5346bd91626c19338943f3", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 13, "deletions": 22, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/83acebc46213e30eac3e9e71b213440104914f4c/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83acebc46213e30eac3e9e71b213440104914f4c/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=83acebc46213e30eac3e9e71b213440104914f4c", "patch": "@@ -24,6 +24,7 @@\n // - It's not possible to take the address of a static item with unsafe interior. This is enforced\n // by borrowck::gather_loans\n \n+use middle::cast::{CastKind};\n use middle::const_eval;\n use middle::def;\n use middle::expr_use_visitor as euv;\n@@ -32,11 +33,10 @@ use middle::mem_categorization as mc;\n use middle::traits;\n use middle::ty::{self, Ty};\n use util::nodemap::NodeMap;\n-use util::ppaux;\n+use util::ppaux::Repr;\n \n use syntax::ast;\n use syntax::codemap::Span;\n-use syntax::print::pprust;\n use syntax::visit::{self, Visitor};\n \n use std::collections::hash_map::Entry;\n@@ -197,7 +197,7 @@ impl<'a, 'tcx> CheckCrateVisitor<'a, 'tcx> {\n \n impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, i: &ast::Item) {\n-        debug!(\"visit_item(item={})\", pprust::item_to_string(i));\n+        debug!(\"visit_item(item={})\", i.repr(self.tcx));\n         match i.node {\n             ast::ItemStatic(_, ast::MutImmutable, ref expr) => {\n                 self.check_static_type(&**expr);\n@@ -440,26 +440,17 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n             }\n         }\n         ast::ExprCast(ref from, _) => {\n-            let toty = ty::expr_ty(v.tcx, e);\n-            let fromty = ty::expr_ty(v.tcx, &**from);\n-            let is_legal_cast =\n-                ty::type_is_numeric(toty) ||\n-                ty::type_is_unsafe_ptr(toty) ||\n-                (ty::type_is_bare_fn(toty) && ty::type_is_bare_fn_item(fromty));\n-            if !is_legal_cast {\n-                v.add_qualif(ConstQualif::NOT_CONST);\n-                if v.mode != Mode::Var {\n-                    span_err!(v.tcx.sess, e.span, E0012,\n-                              \"can not cast to `{}` in {}s\",\n-                              ppaux::ty_to_string(v.tcx, toty), v.msg());\n-                }\n-            }\n-            if ty::type_is_unsafe_ptr(fromty) && ty::type_is_numeric(toty) {\n-                v.add_qualif(ConstQualif::NOT_CONST);\n-                if v.mode != Mode::Var {\n-                    span_err!(v.tcx.sess, e.span, E0018,\n-                              \"can not cast a pointer to an integer in {}s\", v.msg());\n+            debug!(\"Checking const cast(id={})\", from.id);\n+            match v.tcx.cast_kinds.borrow().get(&from.id) {\n+                None => v.tcx.sess.span_bug(e.span, \"no kind for cast\"),\n+                Some(&CastKind::PtrAddrCast) | Some(&CastKind::FPtrAddrCast) => {\n+                    v.add_qualif(ConstQualif::NOT_CONST);\n+                    if v.mode != Mode::Var {\n+                        span_err!(v.tcx.sess, e.span, E0018,\n+                                  \"can not cast a pointer to an integer in {}s\", v.msg());\n+                    }\n                 }\n+                _ => {}\n             }\n         }\n         ast::ExprPath(..) => {"}, {"sha": "03de553e648d8d49dd47c39d9c70c03accc29c7e", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/83acebc46213e30eac3e9e71b213440104914f4c/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83acebc46213e30eac3e9e71b213440104914f4c/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=83acebc46213e30eac3e9e71b213440104914f4c", "patch": "@@ -1002,7 +1002,7 @@ fn cast_const<'tcx>(tcx: &ty::ctxt<'tcx>, val: const_val, ty: Ty) -> CastResult\n     macro_rules! convert_val {\n         ($intermediate_ty:ty, $const_type:ident, $target_ty:ty) => {\n             match val {\n-                const_bool(b) => Ok($const_type(b as $intermediate_ty as $target_ty)),\n+                const_bool(b) => Ok($const_type(b as u64 as $intermediate_ty as $target_ty)),\n                 const_uint(u) => Ok($const_type(u as $intermediate_ty as $target_ty)),\n                 const_int(i) => Ok($const_type(i as $intermediate_ty as $target_ty)),\n                 const_float(f) => Ok($const_type(f as $intermediate_ty as $target_ty)),"}, {"sha": "15e1ac2f2c65e1867f8be316ad02d20cca743425", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/83acebc46213e30eac3e9e71b213440104914f4c/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83acebc46213e30eac3e9e71b213440104914f4c/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=83acebc46213e30eac3e9e71b213440104914f4c", "patch": "@@ -41,6 +41,7 @@ use session::Session;\n use lint;\n use metadata::csearch;\n use middle;\n+use middle::cast;\n use middle::check_const;\n use middle::const_eval;\n use middle::def::{self, DefMap, ExportMap};\n@@ -288,15 +289,6 @@ pub struct field_ty {\n     pub origin: ast::DefId,  // The DefId of the struct in which the field is declared.\n }\n \n-// Contains information needed to resolve types and (in the future) look up\n-// the types of AST nodes.\n-#[derive(Copy, Clone, PartialEq, Eq, Hash)]\n-pub struct creader_cache_key {\n-    pub cnum: CrateNum,\n-    pub pos: usize,\n-    pub len: usize\n-}\n-\n #[derive(Clone, PartialEq, RustcDecodable, RustcEncodable)]\n pub struct ItemVariances {\n     pub types: VecPerParamSpace<Variance>,\n@@ -562,6 +554,15 @@ pub enum vtable_origin<'tcx> {\n // expr to the associated trait ref.\n pub type ObjectCastMap<'tcx> = RefCell<NodeMap<ty::PolyTraitRef<'tcx>>>;\n \n+// Contains information needed to resolve types and (in the future) look up\n+// the types of AST nodes.\n+#[derive(Copy, Clone, PartialEq, Eq, Hash)]\n+pub struct creader_cache_key {\n+    pub cnum: CrateNum,\n+    pub pos: usize,\n+    pub len: usize\n+}\n+\n /// A restriction that certain types must be the same size. The use of\n /// `transmute` gives rise to these restrictions. These generally\n /// cannot be checked until trans; therefore, each call to `transmute`\n@@ -827,6 +828,10 @@ pub struct ctxt<'tcx> {\n \n     /// Caches CoerceUnsized kinds for impls on custom types.\n     pub custom_coerce_unsized_kinds: RefCell<DefIdMap<CustomCoerceUnsized>>,\n+\n+    /// Maps a cast expression to its kind. This is keyed on the\n+    /// *from* expression of the cast, not the cast itself.\n+    pub cast_kinds: RefCell<NodeMap<cast::CastKind>>,\n }\n \n impl<'tcx> ctxt<'tcx> {\n@@ -2817,6 +2822,7 @@ pub fn mk_ctxt<'tcx>(s: Session,\n         type_impls_sized_cache: RefCell::new(HashMap::new()),\n         const_qualif_map: RefCell::new(NodeMap()),\n         custom_coerce_unsized_kinds: RefCell::new(DefIdMap()),\n+        cast_kinds: RefCell::new(NodeMap()),\n    }\n }\n "}, {"sha": "29430ad10e6403039b7d541ec305da0b2ebef55c", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 40, "deletions": 30, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/83acebc46213e30eac3e9e71b213440104914f4c/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83acebc46213e30eac3e9e71b213440104914f4c/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=83acebc46213e30eac3e9e71b213440104914f4c", "patch": "@@ -29,6 +29,7 @@ use trans::declare;\n use trans::monomorphize;\n use trans::type_::Type;\n use trans::type_of;\n+use middle::cast::{CastTy,IntTy};\n use middle::subst::Substs;\n use middle::ty::{self, Ty};\n use util::ppaux::{Repr, ty_to_string};\n@@ -616,53 +617,62 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n               }\n           }\n           ast::ExprCast(ref base, _) => {\n-            let llty = type_of::type_of(cx, ety);\n-            let (v, basety) = const_expr(cx, &**base, param_substs);\n-            if expr::cast_is_noop(basety, ety) {\n+            let t_1 = ety;\n+            let llty = type_of::type_of(cx, t_1);\n+            let (v, t_e) = const_expr(cx, &**base, param_substs);\n+            debug!(\"trans_const_cast({} as {})\", t_e.repr(cx.tcx()), t_1.repr(cx.tcx()));\n+            if expr::cast_is_noop(cx.tcx(), base, t_e, t_1) {\n                 return v;\n             }\n-            match (expr::cast_type_kind(cx.tcx(), basety),\n-                   expr::cast_type_kind(cx.tcx(), ety)) {\n-\n-              (expr::cast_integral, expr::cast_integral) => {\n-                let s = ty::type_is_signed(basety) as Bool;\n+            if type_is_fat_ptr(cx.tcx(), t_e) {\n+                // Fat pointer casts.\n+                let t_1_inner = ty::deref(t_1, true).expect(\"cast to non-pointer\").ty;\n+                let ptr_ty = type_of::in_memory_type_of(cx, t_1_inner).ptr_to();\n+                let addr = ptrcast(const_get_elt(cx, v, &[abi::FAT_PTR_ADDR as u32]),\n+                                   ptr_ty);\n+                if type_is_fat_ptr(cx.tcx(), t_1) {\n+                    let info = const_get_elt(cx, v, &[abi::FAT_PTR_EXTRA as u32]);\n+                    return C_struct(cx, &[addr, info], false)\n+                } else {\n+                    return addr;\n+                }\n+            }\n+            match (CastTy::recognize(cx.tcx(), t_e).expect(\"bad input type for cast\"),\n+                   CastTy::recognize(cx.tcx(), t_1).expect(\"bad output type for cast\")) {\n+              (CastTy::Int(IntTy::CEnum), CastTy::Int(_)) => {\n+                let repr = adt::represent_type(cx, t_e);\n+                let discr = adt::const_get_discrim(cx, &*repr, v);\n+                let iv = C_integral(cx.int_type(), discr, false);\n+                let s = adt::is_discr_signed(&*repr) as Bool;\n+                llvm::LLVMConstIntCast(iv, llty.to_ref(), s)\n+              }\n+              (CastTy::Int(_), CastTy::Int(_)) => {\n+                let s = ty::type_is_signed(t_e) as Bool;\n                 llvm::LLVMConstIntCast(v, llty.to_ref(), s)\n               }\n-              (expr::cast_integral, expr::cast_float) => {\n-                if ty::type_is_signed(basety) {\n+              (CastTy::Int(_), CastTy::Float) => {\n+                if ty::type_is_signed(t_e) {\n                     llvm::LLVMConstSIToFP(v, llty.to_ref())\n                 } else {\n                     llvm::LLVMConstUIToFP(v, llty.to_ref())\n                 }\n               }\n-              (expr::cast_float, expr::cast_float) => {\n+              (CastTy::Float, CastTy::Float) => {\n                 llvm::LLVMConstFPCast(v, llty.to_ref())\n               }\n-              (expr::cast_float, expr::cast_integral) => {\n-                if ty::type_is_signed(ety) { llvm::LLVMConstFPToSI(v, llty.to_ref()) }\n+              (CastTy::Float, CastTy::Int(_)) => {\n+                if ty::type_is_signed(t_1) { llvm::LLVMConstFPToSI(v, llty.to_ref()) }\n                 else { llvm::LLVMConstFPToUI(v, llty.to_ref()) }\n               }\n-              (expr::cast_enum, expr::cast_integral) => {\n-                let repr = adt::represent_type(cx, basety);\n-                let discr = adt::const_get_discrim(cx, &*repr, v);\n-                let iv = C_integral(cx.int_type(), discr, false);\n-                let ety_cast = expr::cast_type_kind(cx.tcx(), ety);\n-                match ety_cast {\n-                    expr::cast_integral => {\n-                        let s = ty::type_is_signed(ety) as Bool;\n-                        llvm::LLVMConstIntCast(iv, llty.to_ref(), s)\n-                    }\n-                    _ => cx.sess().bug(\"enum cast destination is not \\\n-                                        integral\")\n-                }\n-              }\n-              (expr::cast_pointer, expr::cast_pointer) => {\n+              (CastTy::Ptr(_), CastTy::Ptr(_)) | (CastTy::FPtr, CastTy::Ptr(_))\n+                    | (CastTy::RPtr(_), CastTy::Ptr(_)) => {\n                 ptrcast(v, llty)\n               }\n-              (expr::cast_integral, expr::cast_pointer) => {\n+              (CastTy::FPtr, CastTy::FPtr) => ptrcast(v, llty), // isn't this a coercion?\n+              (CastTy::Int(_), CastTy::Ptr(_)) => {\n                 llvm::LLVMConstIntToPtr(v, llty.to_ref())\n               }\n-              (expr::cast_pointer, expr::cast_integral) => {\n+              (CastTy::Ptr(_), CastTy::Int(_)) | (CastTy::FPtr, CastTy::Int(_)) => {\n                 llvm::LLVMConstPtrToInt(v, llty.to_ref())\n               }\n               _ => {"}, {"sha": "a65d4225a1f4d4adffe8c7cad6975b887e0cc227", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 109, "deletions": 143, "changes": 252, "blob_url": "https://github.com/rust-lang/rust/blob/83acebc46213e30eac3e9e71b213440104914f4c/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83acebc46213e30eac3e9e71b213440104914f4c/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=83acebc46213e30eac3e9e71b213440104914f4c", "patch": "@@ -48,7 +48,6 @@\n \n #![allow(non_camel_case_types)]\n \n-pub use self::cast_kind::*;\n pub use self::Dest::*;\n use self::lazy_binop_ty::*;\n \n@@ -73,6 +72,7 @@ use trans::meth;\n use trans::monomorphize;\n use trans::tvec;\n use trans::type_of;\n+use middle::cast::{CastKind, CastTy};\n use middle::ty::{struct_fields, tup_fields};\n use middle::ty::{AdjustDerefRef, AdjustReifyFnPointer, AdjustUnsafeFnPointer};\n use middle::ty::{self, Ty};\n@@ -1981,177 +1981,143 @@ fn trans_overloaded_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     bcx\n }\n \n-fn int_cast(bcx: Block,\n-            lldsttype: Type,\n-            llsrctype: Type,\n-            llsrc: ValueRef,\n-            signed: bool)\n-            -> ValueRef {\n-    let _icx = push_ctxt(\"int_cast\");\n-    let srcsz = llsrctype.int_width();\n-    let dstsz = lldsttype.int_width();\n-    return if dstsz == srcsz {\n-        BitCast(bcx, llsrc, lldsttype)\n-    } else if srcsz > dstsz {\n-        TruncOrBitCast(bcx, llsrc, lldsttype)\n-    } else if signed {\n-        SExtOrBitCast(bcx, llsrc, lldsttype)\n-    } else {\n-        ZExtOrBitCast(bcx, llsrc, lldsttype)\n-    }\n-}\n-\n-fn float_cast(bcx: Block,\n-              lldsttype: Type,\n-              llsrctype: Type,\n-              llsrc: ValueRef)\n-              -> ValueRef {\n-    let _icx = push_ctxt(\"float_cast\");\n-    let srcsz = llsrctype.float_width();\n-    let dstsz = lldsttype.float_width();\n-    return if dstsz > srcsz {\n-        FPExt(bcx, llsrc, lldsttype)\n-    } else if srcsz > dstsz {\n-        FPTrunc(bcx, llsrc, lldsttype)\n-    } else { llsrc };\n-}\n-\n-#[derive(Copy, Clone, PartialEq, Debug)]\n-pub enum cast_kind {\n-    cast_pointer,\n-    cast_fat_ptr,\n-    cast_integral,\n-    cast_float,\n-    cast_enum,\n-    cast_other,\n-}\n-\n-pub fn cast_type_kind<'tcx>(tcx: &ty::ctxt<'tcx>, t: Ty<'tcx>) -> cast_kind {\n-    match t.sty {\n-        ty::ty_char        => cast_integral,\n-        ty::ty_float(..)   => cast_float,\n-        ty::ty_rptr(_, mt) | ty::ty_ptr(mt) => {\n-            if type_is_sized(tcx, mt.ty) {\n-                cast_pointer\n-            } else {\n-                cast_fat_ptr\n-            }\n-        }\n-        ty::ty_bare_fn(..) => cast_pointer,\n-        ty::ty_int(..)     => cast_integral,\n-        ty::ty_uint(..)    => cast_integral,\n-        ty::ty_bool        => cast_integral,\n-        ty::ty_enum(..)    => cast_enum,\n-        _                  => cast_other\n+pub fn cast_is_noop<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                          expr: &ast::Expr,\n+                          t_in: Ty<'tcx>,\n+                          t_out: Ty<'tcx>)\n+                          -> bool {\n+    if let Some(&CastKind::CoercionCast) = tcx.cast_kinds.borrow().get(&expr.id) {\n+        return true;\n     }\n-}\n \n-pub fn cast_is_noop<'tcx>(t_in: Ty<'tcx>, t_out: Ty<'tcx>) -> bool {\n     match (ty::deref(t_in, true), ty::deref(t_out, true)) {\n         (Some(ty::mt{ ty: t_in, .. }), Some(ty::mt{ ty: t_out, .. })) => {\n             t_in == t_out\n         }\n-        _ => false\n+        _ => {\n+            // This condition isn't redundant with the check for CoercionCast:\n+            // different types can be substituted into the same type, and\n+            // == equality can be overconservative if there are regions.\n+            t_in == t_out\n+        }\n     }\n }\n \n fn trans_imm_cast<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                               expr: &ast::Expr,\n                               id: ast::NodeId)\n-                              -> DatumBlock<'blk, 'tcx, Expr> {\n+                              -> DatumBlock<'blk, 'tcx, Expr>\n+{\n+    use middle::cast::CastTy::*;\n+    use middle::cast::IntTy::*;\n+\n+    fn int_cast(bcx: Block,\n+                lldsttype: Type,\n+                llsrctype: Type,\n+                llsrc: ValueRef,\n+                signed: bool)\n+                -> ValueRef\n+    {\n+        let _icx = push_ctxt(\"int_cast\");\n+        let srcsz = llsrctype.int_width();\n+        let dstsz = lldsttype.int_width();\n+        return if dstsz == srcsz {\n+            BitCast(bcx, llsrc, lldsttype)\n+        } else if srcsz > dstsz {\n+            TruncOrBitCast(bcx, llsrc, lldsttype)\n+        } else if signed {\n+            SExtOrBitCast(bcx, llsrc, lldsttype)\n+        } else {\n+            ZExtOrBitCast(bcx, llsrc, lldsttype)\n+        }\n+    }\n+\n+    fn float_cast(bcx: Block,\n+                  lldsttype: Type,\n+                  llsrctype: Type,\n+                  llsrc: ValueRef)\n+                  -> ValueRef\n+    {\n+        let _icx = push_ctxt(\"float_cast\");\n+        let srcsz = llsrctype.float_width();\n+        let dstsz = lldsttype.float_width();\n+        return if dstsz > srcsz {\n+            FPExt(bcx, llsrc, lldsttype)\n+        } else if srcsz > dstsz {\n+            FPTrunc(bcx, llsrc, lldsttype)\n+        } else { llsrc };\n+    }\n+\n     let _icx = push_ctxt(\"trans_cast\");\n     let mut bcx = bcx;\n     let ccx = bcx.ccx();\n \n     let t_in = expr_ty_adjusted(bcx, expr);\n     let t_out = node_id_type(bcx, id);\n-    let k_in = cast_type_kind(bcx.tcx(), t_in);\n-    let k_out = cast_type_kind(bcx.tcx(), t_out);\n-    let s_in = k_in == cast_integral && ty::type_is_signed(t_in);\n-    let ll_t_in = type_of::arg_type_of(ccx, t_in);\n-    let ll_t_out = type_of::arg_type_of(ccx, t_out);\n \n+    debug!(\"trans_cast({} as {})\", t_in.repr(bcx.tcx()), t_out.repr(bcx.tcx()));\n+    let mut ll_t_in = type_of::arg_type_of(ccx, t_in);\n+    let ll_t_out = type_of::arg_type_of(ccx, t_out);\n     // Convert the value to be cast into a ValueRef, either by-ref or\n     // by-value as appropriate given its type:\n     let mut datum = unpack_datum!(bcx, trans(bcx, expr));\n \n     let datum_ty = monomorphize_type(bcx, datum.ty);\n-    if cast_is_noop(datum_ty, t_out) {\n+\n+    if cast_is_noop(bcx.tcx(), expr, datum_ty, t_out) {\n         datum.ty = t_out;\n         return DatumBlock::new(bcx, datum);\n     }\n \n-    let newval = match (k_in, k_out) {\n-        (cast_integral, cast_integral) => {\n-            let llexpr = datum.to_llscalarish(bcx);\n-            int_cast(bcx, ll_t_out, ll_t_in, llexpr, s_in)\n-        }\n-        (cast_float, cast_float) => {\n-            let llexpr = datum.to_llscalarish(bcx);\n-            float_cast(bcx, ll_t_out, ll_t_in, llexpr)\n-        }\n-        (cast_integral, cast_float) => {\n-            let llexpr = datum.to_llscalarish(bcx);\n-            if s_in {\n-                SIToFP(bcx, llexpr, ll_t_out)\n-            } else { UIToFP(bcx, llexpr, ll_t_out) }\n-        }\n-        (cast_float, cast_integral) => {\n-            let llexpr = datum.to_llscalarish(bcx);\n-            if ty::type_is_signed(t_out) {\n-                FPToSI(bcx, llexpr, ll_t_out)\n-            } else { FPToUI(bcx, llexpr, ll_t_out) }\n-        }\n-        (cast_integral, cast_pointer) => {\n-            let llexpr = datum.to_llscalarish(bcx);\n-            IntToPtr(bcx, llexpr, ll_t_out)\n-        }\n-        (cast_pointer, cast_integral) => {\n-            let llexpr = datum.to_llscalarish(bcx);\n-            PtrToInt(bcx, llexpr, ll_t_out)\n-        }\n-        (cast_fat_ptr, cast_integral) => {\n-            let data_ptr = Load(bcx, get_dataptr(bcx, datum.val));\n-            PtrToInt(bcx, data_ptr, ll_t_out)\n-        }\n-        (cast_pointer, cast_pointer) => {\n-            let llexpr = datum.to_llscalarish(bcx);\n-            PointerCast(bcx, llexpr, ll_t_out)\n-        }\n-        (cast_fat_ptr, cast_pointer) => {\n-            let data_ptr = Load(bcx, get_dataptr(bcx, datum.val));\n-            PointerCast(bcx, data_ptr, ll_t_out)\n-        }\n-        (cast_enum, cast_integral) |\n-        (cast_enum, cast_float) => {\n-            let mut bcx = bcx;\n-            let repr = adt::represent_type(ccx, t_in);\n-            let datum = unpack_datum!(\n-                bcx, datum.to_lvalue_datum(bcx, \"trans_imm_cast\", expr.id));\n-            let llexpr_ptr = datum.to_llref();\n-            let lldiscrim_a =\n-                adt::trans_get_discr(bcx, &*repr, llexpr_ptr, Some(Type::i64(ccx)));\n-            match k_out {\n-                cast_integral => int_cast(bcx, ll_t_out,\n-                                          val_ty(lldiscrim_a),\n-                                          lldiscrim_a, true),\n-                cast_float => SIToFP(bcx, lldiscrim_a, ll_t_out),\n-                _ => {\n-                    ccx.sess().bug(&format!(\"translating unsupported cast: \\\n-                                            {} ({:?}) -> {} ({:?})\",\n-                                            t_in.repr(bcx.tcx()),\n-                                            k_in,\n-                                            t_out.repr(bcx.tcx()),\n-                                            k_out))\n-                }\n-            }\n+    if type_is_fat_ptr(bcx.tcx(), t_in) {\n+        assert!(datum.kind.is_by_ref());\n+        if type_is_fat_ptr(bcx.tcx(), t_out) {\n+            return DatumBlock::new(bcx, Datum::new(\n+                PointerCast(bcx, datum.val, ll_t_out.ptr_to()),\n+                t_out,\n+                Rvalue::new(ByRef)\n+            )).to_expr_datumblock();\n+        } else {\n+            // Return the address\n+            return immediate_rvalue_bcx(bcx,\n+                                        Load(bcx, get_dataptr(bcx, datum.val)),\n+                                        t_out).to_expr_datumblock();\n         }\n-        _ => ccx.sess().bug(&format!(\"translating unsupported cast: \\\n-                                    {} ({:?}) -> {} ({:?})\",\n-                                    t_in.repr(bcx.tcx()),\n-                                    k_in,\n-                                    t_out.repr(bcx.tcx()),\n-                                    k_out))\n+    }\n+\n+    let r_t_in = CastTy::recognize(bcx.tcx(), t_in).expect(\"bad input type for cast\");\n+    let r_t_out = CastTy::recognize(bcx.tcx(), t_out).expect(\"bad output type for cast\");\n+\n+    let (llexpr, signed) = if let Int(CEnum) = r_t_in {\n+        let repr = adt::represent_type(ccx, t_in);\n+        let datum = unpack_datum!(\n+            bcx, datum.to_lvalue_datum(bcx, \"trans_imm_cast\", expr.id));\n+        let llexpr_ptr = datum.to_llref();\n+        let discr = adt::trans_get_discr(bcx, &*repr, llexpr_ptr, Some(Type::i64(ccx)));\n+        ll_t_in = val_ty(discr);\n+        (discr, adt::is_discr_signed(&*repr))\n+    } else {\n+        (datum.to_llscalarish(bcx), ty::type_is_signed(t_in))\n+    };\n+\n+    let newval = match (r_t_in, r_t_out) {\n+        (Ptr(_), Ptr(_)) | (FPtr, Ptr(_)) | (RPtr(_), Ptr(_)) => PointerCast(bcx, llexpr, ll_t_out),\n+        (Ptr(_), Int(_)) | (FPtr, Int(_)) => PtrToInt(bcx, llexpr, ll_t_out),\n+        (Int(_), Ptr(_)) => IntToPtr(bcx, llexpr, ll_t_out),\n+\n+        (Int(_), Int(_)) => int_cast(bcx, ll_t_out, ll_t_in, llexpr, signed),\n+        (Float, Float) => float_cast(bcx, ll_t_out, ll_t_in, llexpr),\n+        (Int(_), Float) if signed => SIToFP(bcx, llexpr, ll_t_out),\n+        (Int(_), Float) => UIToFP(bcx, llexpr, ll_t_out),\n+        (Float, Int(I)) => FPToSI(bcx, llexpr, ll_t_out),\n+        (Float, Int(_)) => FPToUI(bcx, llexpr, ll_t_out),\n+\n+        _ => ccx.sess().span_bug(expr.span,\n+                                  &format!(\"translating unsupported cast: \\\n+                                            {} -> {}\",\n+                                           t_in.repr(bcx.tcx()),\n+                                           t_out.repr(bcx.tcx()))\n+                                 )\n     };\n     return immediate_rvalue_bcx(bcx, newval, t_out).to_expr_datumblock();\n }"}, {"sha": "6ae6d21f9874d6d9c85daf21821785ae3a258ae4", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 317, "deletions": 136, "changes": 453, "blob_url": "https://github.com/rust-lang/rust/blob/83acebc46213e30eac3e9e71b213440104914f4c/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83acebc46213e30eac3e9e71b213440104914f4c/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=83acebc46213e30eac3e9e71b213440104914f4c", "patch": "@@ -9,18 +9,43 @@\n // except according to those terms.\n \n //! Code for type-checking cast expressions.\n+//!\n+//! A cast `e as U` is valid if one of the following holds:\n+//! * `e` has type `T` and `T` coerces to `U`; *coercion-cast*\n+//! * `e` has type `*T`, `U` is `*U_0`, and either `U_0: Sized` or\n+//!    unsize_kind(`T`) = unsize_kind(`U_0`); *ptr-ptr-cast*\n+//! * `e` has type `*T` and `U` is a numeric type, while `T: Sized`; *ptr-addr-cast*\n+//! * `e` is an integer and `U` is `*U_0`, while `U_0: Sized`; *addr-ptr-cast*\n+//! * `e` has type `T` and `T` and `U` are any numeric types; *numeric-cast*\n+//! * `e` is a C-like enum and `U` is an integer type; *enum-cast*\n+//! * `e` has type `bool` or `char` and `U` is an integer; *prim-int-cast*\n+//! * `e` has type `u8` and `U` is `char`; *u8-char-cast*\n+//! * `e` has type `&[T; n]` and `U` is `*const T`; *array-ptr-cast*\n+//! * `e` is a function pointer type and `U` has type `*T`,\n+//!   while `T: Sized`; *fptr-ptr-cast*\n+//! * `e` is a function pointer type and `U` is an integer; *fptr-addr-cast*\n+//!\n+//! where `&.T` and `*T` are references of either mutability,\n+//! and where unsize_kind(`T`) is the kind of the unsize info\n+//! in `T` - a vtable or a length (or `()` if `T: Sized`).\n+//!\n+//! Casting is not transitive, that is, even if `e as U1 as U2` is a valid\n+//! expression, `e as U2` is not necessarily so (in fact it will only be valid if\n+//! `U1` coerces to `U2`).\n \n use super::coercion;\n use super::demand;\n use super::FnCtxt;\n use super::structurally_resolved_type;\n \n use lint;\n-use middle::infer;\n+use middle::cast::{CastKind, CastTy};\n use middle::ty;\n use middle::ty::Ty;\n use syntax::ast;\n+use syntax::ast::UintTy::{TyU8};\n use syntax::codemap::Span;\n+use util::ppaux::Repr;\n \n /// Reifies a cast check to be checked once we have full type information for\n /// a function context.\n@@ -31,6 +56,46 @@ pub struct CastCheck<'tcx> {\n     span: Span,\n }\n \n+#[derive(Copy, Clone, PartialEq, Eq)]\n+enum UnsizeKind<'tcx> {\n+    Vtable,\n+    Length,\n+    OfTy(Ty<'tcx>)\n+}\n+\n+/// Returns the kind of unsize information of t, or None\n+/// if t is sized or it is unknown.\n+fn unsize_kind<'a,'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                        t: Ty<'tcx>)\n+                        -> Option<UnsizeKind<'tcx>> {\n+    match t.sty {\n+        ty::ty_vec(_, None) | ty::ty_str => Some(UnsizeKind::Length),\n+        ty::ty_trait(_) => Some(UnsizeKind::Vtable),\n+        ty::ty_struct(did, substs) => {\n+            match ty::struct_fields(fcx.tcx(), did, substs).pop() {\n+                None => None,\n+                Some(f) => unsize_kind(fcx, f.mt.ty)\n+            }\n+        }\n+        ty::ty_projection(..) | ty::ty_param(..) =>\n+            Some(UnsizeKind::OfTy(t)),\n+        _ => None\n+    }\n+}\n+\n+#[derive(Copy, Clone)]\n+enum CastError {\n+    CastToBool,\n+    CastToChar,\n+    DifferingKinds,\n+    IllegalCast,\n+    NeedViaPtr,\n+    NeedViaInt,\n+    NeedViaUsize,\n+    NonScalar,\n+    RefToMutPtr\n+}\n+\n impl<'tcx> CastCheck<'tcx> {\n     pub fn new(expr: ast::Expr, expr_ty: Ty<'tcx>, cast_ty: Ty<'tcx>, span: Span)\n                -> CastCheck<'tcx> {\n@@ -41,155 +106,271 @@ impl<'tcx> CastCheck<'tcx> {\n             span: span,\n         }\n     }\n-}\n \n-pub fn check_cast<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>, cast: &CastCheck<'tcx>) {\n-    fn cast_through_integer_err<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n-                                          span: Span,\n-                                          t_1: Ty<'tcx>,\n-                                          t_e: Ty<'tcx>) {\n-        fcx.type_error_message(span, |actual| {\n-            format!(\"illegal cast; cast through an \\\n-                    integer first: `{}` as `{}`\",\n-                    actual,\n-                    fcx.infcx().ty_to_string(t_1))\n-        }, t_e, None);\n+    fn report_cast_error<'a>(&self, fcx: &FnCtxt<'a, 'tcx>,\n+                             e: CastError) {\n+        match e {\n+            CastError::NeedViaPtr |\n+            CastError::NeedViaInt |\n+            CastError::NeedViaUsize => {\n+                fcx.type_error_message(self.span, |actual| {\n+                    format!(\"illegal cast; cast through {} first: `{}` as `{}`\",\n+                            match e {\n+                                CastError::NeedViaPtr => \"a raw pointer\",\n+                                CastError::NeedViaInt => \"an integer\",\n+                                CastError::NeedViaUsize => \"a usize\",\n+                                _ => unreachable!()\n+                            },\n+                            actual,\n+                            fcx.infcx().ty_to_string(self.cast_ty))\n+                }, self.expr_ty, None)\n+            }\n+            CastError::CastToBool => {\n+                span_err!(fcx.tcx().sess, self.span, E0054,\n+                          \"cannot cast as `bool`, compare with zero instead\");\n+            }\n+            CastError::CastToChar => {\n+                fcx.type_error_message(self.span, |actual| {\n+                    format!(\"only `u8` can be cast as `char`, not `{}`\", actual)\n+                }, self.expr_ty, None);\n+            }\n+            CastError::NonScalar => {\n+                fcx.type_error_message(self.span, |actual| {\n+                    format!(\"non-scalar cast: `{}` as `{}`\",\n+                            actual,\n+                            fcx.infcx().ty_to_string(self.cast_ty))\n+                }, self.expr_ty, None);\n+            }\n+            CastError::IllegalCast => {\n+                fcx.type_error_message(self.span, |actual| {\n+                    format!(\"illegal cast: `{}` as `{}`\",\n+                            actual,\n+                            fcx.infcx().ty_to_string(self.cast_ty))\n+                }, self.expr_ty, None);\n+            }\n+            CastError::DifferingKinds => {\n+                fcx.type_error_message(self.span, |actual| {\n+                    format!(\"illegal cast: `{}` as `{}`; vtable kinds may not match\",\n+                            actual,\n+                            fcx.infcx().ty_to_string(self.cast_ty))\n+                }, self.expr_ty, None);\n+            }\n+            CastError::RefToMutPtr => {\n+                span_err!(fcx.tcx().sess, self.span, E0188,\n+                          \"cannot cast an immutable reference to a \\\n+                           mutable pointer\");\n+            }\n+        }\n+    }\n+\n+    fn trivial_cast_lint<'a>(&self, fcx: &FnCtxt<'a, 'tcx>) {\n+        let t_1 = self.cast_ty;\n+        let t_e = self.expr_ty;\n+        if ty::type_is_numeric(t_1) && ty::type_is_numeric(t_e) {\n+            fcx.tcx().sess.add_lint(lint::builtin::TRIVIAL_NUMERIC_CASTS,\n+                                    self.expr.id,\n+                                    self.span,\n+                                    format!(\"trivial numeric cast: `{}` as `{}`. Cast can be \\\n+                                             replaced by coercion, this might require type \\\n+                                             ascription or a temporary variable\",\n+                                            fcx.infcx().ty_to_string(t_e),\n+                                            fcx.infcx().ty_to_string(t_1)));\n+        } else {\n+            fcx.tcx().sess.add_lint(lint::builtin::TRIVIAL_CASTS,\n+                                    self.expr.id,\n+                                    self.span,\n+                                    format!(\"trivial cast: `{}` as `{}`. Cast can be \\\n+                                             replaced by coercion, this might require type \\\n+                                             ascription or a temporary variable\",\n+                                            fcx.infcx().ty_to_string(t_e),\n+                                            fcx.infcx().ty_to_string(t_1)));\n+        }\n+\n     }\n \n-    let span = cast.span;\n-    let e = &cast.expr;\n-    let t_e = structurally_resolved_type(fcx, span, cast.expr_ty);\n-    let t_1 = structurally_resolved_type(fcx, span, cast.cast_ty);\n-    let tcx = fcx.tcx();\n-\n-    // Check for trivial casts.\n-    if !ty::type_has_ty_infer(t_1) {\n-        if let Ok(()) = coercion::mk_assignty(fcx, e, t_e, t_1) {\n-            if ty::type_is_numeric(t_1) && ty::type_is_numeric(t_e) {\n-                tcx.sess.add_lint(lint::builtin::TRIVIAL_NUMERIC_CASTS,\n-                                  e.id,\n-                                  span,\n-                                  format!(\"trivial numeric cast: `{}` as `{}`. Cast can be \\\n-                                           replaced by coercion, this might require type \\\n-                                           ascription or a temporary variable\",\n-                                          fcx.infcx().ty_to_string(t_e),\n-                                          fcx.infcx().ty_to_string(t_1)));\n-            } else {\n-                tcx.sess.add_lint(lint::builtin::TRIVIAL_CASTS,\n-                                  e.id,\n-                                  span,\n-                                  format!(\"trivial cast: `{}` as `{}`. Cast can be \\\n-                                           replaced by coercion, this might require type \\\n-                                           ascription or a temporary variable\",\n-                                          fcx.infcx().ty_to_string(t_e),\n-                                          fcx.infcx().ty_to_string(t_1)));\n+    pub fn check<'a>(mut self, fcx: &FnCtxt<'a, 'tcx>) {\n+        self.expr_ty = structurally_resolved_type(fcx, self.span, self.expr_ty);\n+        self.cast_ty = structurally_resolved_type(fcx, self.span, self.cast_ty);\n+\n+        debug!(\"check_cast({}, {} as {})\", self.expr.id, self.expr_ty.repr(fcx.tcx()),\n+               self.cast_ty.repr(fcx.tcx()));\n+\n+        if ty::type_is_error(self.expr_ty) || ty::type_is_error(self.cast_ty) {\n+            // No sense in giving duplicate error messages\n+        } else if self.try_coercion_cast(fcx) {\n+            self.trivial_cast_lint(fcx);\n+            debug!(\" -> CoercionCast\");\n+            fcx.tcx().cast_kinds.borrow_mut().insert(self.expr.id,\n+                                                     CastKind::CoercionCast);\n+        } else { match self.do_check(fcx) {\n+            Ok(k) => {\n+                debug!(\" -> {:?}\", k);\n+                fcx.tcx().cast_kinds.borrow_mut().insert(self.expr.id, k);\n             }\n-            return;\n+            Err(e) => self.report_cast_error(fcx, e)\n+        };}\n+    }\n+\n+    /// Check a cast, and report an error if one exists. In some cases,\n+    /// this can return Ok and create type errors rather than returning\n+    /// directly. coercion-cast is handled in check instead of here.\n+    fn do_check<'a>(&self, fcx: &FnCtxt<'a, 'tcx>) -> Result<CastKind, CastError> {\n+        use middle::cast::IntTy::*;\n+        use middle::cast::CastTy::*;\n+\n+        let (t_e, t_1) = match (CastTy::recognize(fcx.tcx(), self.expr_ty),\n+                                CastTy::recognize(fcx.tcx(), self.cast_ty)) {\n+            (Some(t_e), Some(t_1)) => (t_e, t_1),\n+            _ => {\n+                return Err(CastError::NonScalar)\n+            }\n+        };\n+\n+        match (t_e, t_1) {\n+            // These types have invariants! can't cast into them.\n+            (_, RPtr(_)) | (_, Int(CEnum)) | (_, FPtr) => Err(CastError::NonScalar),\n+\n+            // * -> Bool\n+            (_, Int(Bool)) => Err(CastError::CastToBool),\n+\n+            // * -> Char\n+            (Int(U(ast::TyU8)), Int(Char)) => Ok(CastKind::U8CharCast), // u8-char-cast\n+            (_, Int(Char)) => Err(CastError::CastToChar),\n+\n+            // prim -> float,ptr\n+            (Int(Bool), Float) | (Int(CEnum), Float) | (Int(Char), Float)\n+                => Err(CastError::NeedViaInt),\n+            (Int(Bool), Ptr(_)) | (Int(CEnum), Ptr(_)) | (Int(Char), Ptr(_))\n+                => Err(CastError::NeedViaUsize),\n+\n+            // ptr -> *\n+            (Ptr(m1), Ptr(m2)) => self.check_ptr_ptr_cast(fcx, m1, m2), // ptr-ptr-cast\n+            (Ptr(m_e), Int(_)) => self.check_ptr_addr_cast(fcx, m_e), // ptr-addr-cast\n+            (Ptr(_), Float) | (FPtr, Float) => Err(CastError::NeedViaUsize),\n+            (FPtr, Int(_)) => Ok(CastKind::FPtrAddrCast),\n+            (RPtr(_), Int(_)) | (RPtr(_), Float) => Err(CastError::NeedViaPtr),\n+            // * -> ptr\n+            (Int(_), Ptr(mt)) => self.check_addr_ptr_cast(fcx, mt), // addr-ptr-cast\n+            (FPtr, Ptr(mt)) => self.check_fptr_ptr_cast(fcx, mt),\n+            (Float, Ptr(_)) => Err(CastError::NeedViaUsize),\n+            (RPtr(rmt), Ptr(mt)) => self.check_ref_cast(fcx, rmt, mt), // array-ptr-cast\n+\n+            // prim -> prim\n+            (Int(CEnum), Int(_)) => Ok(CastKind::EnumCast),\n+            (Int(Char), Int(_)) | (Int(Bool), Int(_)) => Ok(CastKind::PrimIntCast),\n+\n+            (Int(_), Int(_)) |\n+            (Int(_), Float) |\n+            (Float, Int(_)) |\n+            (Float, Float) => Ok(CastKind::NumericCast),\n+\n         }\n     }\n \n-    let t_e_is_bare_fn_item = ty::type_is_bare_fn_item(t_e);\n-    let t_e_is_scalar = ty::type_is_scalar(t_e);\n-    let t_e_is_integral = ty::type_is_integral(t_e);\n-    let t_e_is_float = ty::type_is_floating_point(t_e);\n-    let t_e_is_c_enum = ty::type_is_c_like_enum(tcx, t_e);\n-\n-    let t_1_is_scalar = ty::type_is_scalar(t_1);\n-    let t_1_is_integral = ty::type_is_integral(t_1);\n-    let t_1_is_char = ty::type_is_char(t_1);\n-    let t_1_is_bare_fn = ty::type_is_bare_fn(t_1);\n-    let t_1_is_float = ty::type_is_floating_point(t_1);\n-    let t_1_is_c_enum = ty::type_is_c_like_enum(tcx, t_1);\n-    let t1_is_fat_ptr = fcx.type_is_fat_ptr(t_1, span);\n-\n-    // casts to scalars other than `char` and `bare fn` are trivial\n-    let t_1_is_trivial = t_1_is_scalar && !t_1_is_char && !t_1_is_bare_fn;\n-\n-    if t_e_is_bare_fn_item && t_1_is_bare_fn {\n-        demand::coerce(fcx, e.span, t_1, &e);\n-    } else if t_1_is_char {\n-        let t_e = fcx.infcx().shallow_resolve(t_e);\n-        if t_e.sty != ty::ty_uint(ast::TyU8) {\n-            fcx.type_error_message(span, |actual| {\n-                format!(\"only `u8` can be cast as `char`, not `{}`\", actual)\n-            }, t_e, None);\n+    fn check_ptr_ptr_cast<'a>(&self,\n+                              fcx: &FnCtxt<'a, 'tcx>,\n+                              m_e: &'tcx ty::mt<'tcx>,\n+                              m_1: &'tcx ty::mt<'tcx>)\n+                              -> Result<CastKind, CastError>\n+    {\n+        debug!(\"check_ptr_ptr_cast m_e={} m_1={}\",\n+               m_e.repr(fcx.tcx()), m_1.repr(fcx.tcx()));\n+        // ptr-ptr cast. vtables must match.\n+\n+        // Cast to sized is OK\n+        if fcx.type_is_known_to_be_sized(m_1.ty, self.span) {\n+            return Ok(CastKind::PtrPtrCast);\n         }\n-    } else if t_1.sty == ty::ty_bool {\n-        span_err!(tcx.sess, span, E0054,\n-                  \"cannot cast as `bool`, compare with zero instead\");\n-    } else if t_e_is_float && (t_1_is_scalar || t_1_is_c_enum) &&\n-        !(t_1_is_integral || t_1_is_float) {\n-        // Casts from float must go through an integer\n-        cast_through_integer_err(fcx, span, t_1, t_e)\n-    } else if t_1_is_float && (t_e_is_scalar || t_e_is_c_enum) &&\n-        !(t_e_is_integral || t_e_is_float || t_e.sty == ty::ty_bool) {\n-        // Casts to float must go through an integer or boolean\n-        cast_through_integer_err(fcx, span, t_1, t_e)\n-    } else if t_e_is_c_enum && t_1_is_trivial {\n-        if ty::type_is_unsafe_ptr(t_1) {\n-            // ... and likewise with C enum -> *T\n-            cast_through_integer_err(fcx, span, t_1, t_e)\n+\n+        // sized -> unsized? report illegal cast (don't complain about vtable kinds)\n+        if fcx.type_is_known_to_be_sized(m_e.ty, self.span) {\n+            return Err(CastError::IllegalCast);\n         }\n-        // casts from C-like enums are allowed\n-    } else if ty::type_is_region_ptr(t_e) && ty::type_is_unsafe_ptr(t_1) {\n-        fn types_compatible<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>, sp: Span,\n-                                      t1: Ty<'tcx>, t2: Ty<'tcx>) -> bool {\n-            match t1.sty {\n-                ty::ty_vec(_, Some(_)) => {}\n-                _ => return false\n-            }\n-            if ty::type_needs_infer(t2) {\n-                // This prevents this special case from going off when casting\n-                // to a type that isn't fully specified; e.g. `as *_`. (Issue\n-                // #14893.)\n-                return false\n-            }\n \n-            let el = ty::sequence_element_type(fcx.tcx(), t1);\n-            infer::mk_eqty(fcx.infcx(),\n-                           false,\n-                           infer::Misc(sp),\n-                           el,\n-                           t2).is_ok()\n+        // vtable kinds must match\n+        match (unsize_kind(fcx, m_1.ty), unsize_kind(fcx, m_e.ty)) {\n+            (Some(a), Some(b)) if a == b => Ok(CastKind::PtrPtrCast),\n+            _ => Err(CastError::DifferingKinds)\n         }\n+    }\n \n-        // Due to the limitations of LLVM global constants,\n-        // region pointers end up pointing at copies of\n-        // vector elements instead of the original values.\n-        // To allow unsafe pointers to work correctly, we\n-        // need to special-case obtaining an unsafe pointer\n-        // from a region pointer to a vector.\n-\n-        /* this cast is only allowed from &[T, ..n] to *T or\n-        &T to *T. */\n-        match (&t_e.sty, &t_1.sty) {\n-            (&ty::ty_rptr(_, ty::mt { ty: mt1, mutbl: ast::MutImmutable }),\n-             &ty::ty_ptr(ty::mt { ty: mt2, mutbl: ast::MutImmutable }))\n-            if types_compatible(fcx, e.span, mt1, mt2) => {\n-                /* this case is allowed */\n-            }\n-            _ => {\n-                demand::coerce(fcx, e.span, t_1, &e);\n+    fn check_fptr_ptr_cast<'a>(&self,\n+                               fcx: &FnCtxt<'a, 'tcx>,\n+                               m_1: &'tcx ty::mt<'tcx>)\n+                               -> Result<CastKind, CastError>\n+    {\n+        // fptr-ptr cast. must be to sized ptr\n+\n+        if fcx.type_is_known_to_be_sized(m_1.ty, self.span) {\n+            Ok(CastKind::FPtrPtrCast)\n+        } else {\n+            Err(CastError::IllegalCast)\n+        }\n+    }\n+\n+    fn check_ptr_addr_cast<'a>(&self,\n+                               fcx: &FnCtxt<'a, 'tcx>,\n+                               m_e: &'tcx ty::mt<'tcx>)\n+                               -> Result<CastKind, CastError>\n+    {\n+        // ptr-addr cast. must be from sized ptr\n+\n+        if fcx.type_is_known_to_be_sized(m_e.ty, self.span) {\n+            Ok(CastKind::PtrAddrCast)\n+        } else {\n+            Err(CastError::NeedViaPtr)\n+        }\n+    }\n+\n+    fn check_ref_cast<'a>(&self,\n+                          fcx: &FnCtxt<'a, 'tcx>,\n+                          m_e: &'tcx ty::mt<'tcx>,\n+                          m_1: &'tcx ty::mt<'tcx>)\n+                          -> Result<CastKind, CastError>\n+    {\n+        // array-ptr-cast.\n+\n+        if m_e.mutbl == ast::MutImmutable && m_1.mutbl == ast::MutImmutable {\n+            if let ty::ty_vec(ety, Some(_)) = m_e.ty.sty {\n+                // Due to the limitations of LLVM global constants,\n+                // region pointers end up pointing at copies of\n+                // vector elements instead of the original values.\n+                // To allow unsafe pointers to work correctly, we\n+                // need to special-case obtaining an unsafe pointer\n+                // from a region pointer to a vector.\n+                // TODO: explain comment.\n+\n+                 // this will report a type mismatch if needed\n+                demand::eqtype(fcx, self.span, ety, m_1.ty);\n+                return Ok(CastKind::ArrayPtrCast);\n             }\n         }\n-    } else if t1_is_fat_ptr {\n-        // FIXME This should be allowed where the lefthandside is also a fat\n-        // pointer and is the same kind of fat pointer, i.e., array to array,\n-        // trait object to trait object. That is a bit looser than the current\n-        // rquirement that they are pointers to the same type.\n-        if !(fcx.type_is_fat_ptr(t_e, span) &&\n-             ty::deref(t_1, true).unwrap().ty == ty::deref(t_e, true).unwrap().ty) {\n-            fcx.type_error_message(span, |actual| {\n-                format!(\"cast to fat pointer: `{}` as `{}`\",\n-                        actual,\n-                        fcx.infcx().ty_to_string(t_1))\n-            }, t_e, None);\n+\n+        Err(CastError::IllegalCast)\n+    }\n+\n+    fn check_addr_ptr_cast<'a>(&self,\n+                               fcx: &FnCtxt<'a, 'tcx>,\n+                               m_1: &'tcx ty::mt<'tcx>)\n+                               -> Result<CastKind, CastError>\n+    {\n+        // ptr-addr cast. pointer must be thin.\n+        if fcx.type_is_known_to_be_sized(m_1.ty, self.span) {\n+           Ok(CastKind::AddrPtrCast)\n+        } else {\n+           Err(CastError::IllegalCast)\n         }\n-    } else if !(t_e_is_scalar && t_1_is_trivial) {\n-        fcx.type_error_message(span, |actual| {\n-            format!(\"non-scalar cast: `{}` as `{}`\",\n-                    actual,\n-                    fcx.infcx().ty_to_string(t_1))\n-        }, t_e, None);\n     }\n+\n+    fn try_coercion_cast<'a>(&self, fcx: &FnCtxt<'a, 'tcx>) -> bool {\n+        if let Ok(()) = coercion::mk_assignty(fcx,\n+                                              &self.expr,\n+                                              self.expr_ty,\n+                                              self.cast_ty) {\n+            true\n+        } else {\n+            false\n+        }\n+    }\n+\n }"}, {"sha": "d3cf9ae6dff87d8df5ab918fa6287acef32a5e4a", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/83acebc46213e30eac3e9e71b213440104914f4c/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83acebc46213e30eac3e9e71b213440104914f4c/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=83acebc46213e30eac3e9e71b213440104914f4c", "patch": "@@ -1581,13 +1581,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                                  span)\n     }\n \n-    pub fn type_is_fat_ptr(&self, ty: Ty<'tcx>, span: Span) -> bool {\n-        if let Some(mt) = ty::deref(ty, true) {\n-            return !self.type_is_known_to_be_sized(mt.ty, span);\n-        }\n-        false\n-    }\n-\n     pub fn register_builtin_bound(&self,\n                                   ty: Ty<'tcx>,\n                                   builtin_bound: ty::BuiltinBound,\n@@ -1810,11 +1803,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     fn check_casts(&self) {\n         let mut deferred_cast_checks = self.inh.deferred_cast_checks.borrow_mut();\n-        for check in deferred_cast_checks.iter() {\n-            cast::check_cast(self, check);\n+        for cast in deferred_cast_checks.drain(..) {\n+            cast.check(self);\n         }\n-\n-        deferred_cast_checks.clear();\n     }\n \n     fn select_all_obligations_and_apply_defaults(&self) {"}, {"sha": "51c0f8fea1cfc0b25b6f45ebbbe60ddd08e3790d", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/83acebc46213e30eac3e9e71b213440104914f4c/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83acebc46213e30eac3e9e71b213440104914f4c/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=83acebc46213e30eac3e9e71b213440104914f4c", "patch": "@@ -825,11 +825,11 @@ register_diagnostics! {\n     E0185,\n     E0186,\n     E0187, // can't infer the kind of the closure\n-    E0188, // types differ in mutability\n-    E0189, // can only cast a boxed pointer to a boxed object\n-    E0190, // can only cast a &-pointer to an &-object\n+    E0188, // can not cast a immutable reference to a mutable pointer\n+    E0189, // deprecated: can only cast a boxed pointer to a boxed object\n+    E0190, // deprecated: can only cast a &-pointer to an &-object\n     E0191, // value of the associated type must be specified\n-    E0192, // negative imples are allowed just for `Send` and `Sync`\n+    E0192, // negative impls are allowed just for `Send` and `Sync`\n     E0193, // cannot bound type where clause bounds may only be attached to types\n            // involving type parameters\n     E0194,"}, {"sha": "25602cb0ee3a10841b5233b9c0e0718d056ed91a", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/83acebc46213e30eac3e9e71b213440104914f4c/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83acebc46213e30eac3e9e71b213440104914f4c/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=83acebc46213e30eac3e9e71b213440104914f4c", "patch": "@@ -77,7 +77,7 @@ This API is completely unstable and subject to change.\n \n #![feature(box_patterns)]\n #![feature(box_syntax)]\n-#![feature(collections)]\n+#![feature(collections, collections_drain)]\n #![feature(core)]\n #![feature(quote)]\n #![feature(rustc_diagnostic_macros)]"}, {"sha": "672dec01e94d1c9905a1fb86ad62572fc66e274d", "filename": "src/test/compile-fail/fat-ptr-cast.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/83acebc46213e30eac3e9e71b213440104914f4c/src%2Ftest%2Fcompile-fail%2Ffat-ptr-cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83acebc46213e30eac3e9e71b213440104914f4c/src%2Ftest%2Fcompile-fail%2Ffat-ptr-cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffat-ptr-cast.rs?ref=83acebc46213e30eac3e9e71b213440104914f4c", "patch": "@@ -8,20 +8,24 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// Make sure casts between thin pointer <-> fat pointer are illegal.\n+// Make sure casts between thin-pointer <-> fat pointer obey RFC401\n \n pub trait Trait {}\n \n fn main() {\n     let a: &[i32] = &[1, 2, 3];\n     let b: Box<[i32]> = Box::new([1, 2, 3]);\n+    let p = a as *const [i32];\n+    let q = a.as_ptr();\n \n-    a as usize; //~ ERROR non-scalar cast\n+    a as usize; //~ ERROR illegal cast\n     b as usize; //~ ERROR non-scalar cast\n+    p as usize; //~ ERROR illegal cast\n \n-    let a: usize = 42;\n-    a as *const [i32]; //~ ERROR cast to fat pointer: `usize` as `*const [i32]`\n+    // #22955\n+    q as *const [i32]; //~ ERROR illegal cast\n \n-    let a: *const u8 = &42;\n-    a as *const [u8]; //~ ERROR cast to fat pointer: `*const u8` as `*const [u8]`\n+    // #21397\n+    let t: *mut (Trait + 'static) = 0 as *mut _; //~ ERROR illegal cast\n+    let mut fail: *const str = 0 as *const str; //~ ERROR illegal cast\n }"}, {"sha": "bcbc414d3534bb3245dbd086701a0a2d7c68305e", "filename": "src/test/compile-fail/issue-22289.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/83acebc46213e30eac3e9e71b213440104914f4c/src%2Ftest%2Fcompile-fail%2Fissue-22289.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83acebc46213e30eac3e9e71b213440104914f4c/src%2Ftest%2Fcompile-fail%2Fissue-22289.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-22289.rs?ref=83acebc46213e30eac3e9e71b213440104914f4c", "patch": "@@ -9,5 +9,5 @@\n // except according to those terms.\n \n fn main() {\n-    0 as &std::any::Any; //~ ERROR cast to fat pointer: `i32` as `&core::any::Any`\n+    0 as &std::any::Any; //~ ERROR non-scalar cast\n }"}]}