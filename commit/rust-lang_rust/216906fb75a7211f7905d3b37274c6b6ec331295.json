{"sha": "216906fb75a7211f7905d3b37274c6b6ec331295", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIxNjkwNmZiNzVhNzIxMWY3OTA1ZDNiMzcyNzRjNmI2ZWMzMzEyOTU=", "commit": {"author": {"name": "jackh726", "email": "jack.huey@umassmed.edu", "date": "2021-08-15T07:09:47Z"}, "committer": {"name": "jackh726", "email": "jack.huey@umassmed.edu", "date": "2021-09-07T22:08:46Z"}, "message": "Change is_unsized to add_implicitly_sized", "tree": {"sha": "4a4ab62b05e779b6dec85c93f3fa30cecde97b0a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4a4ab62b05e779b6dec85c93f3fa30cecde97b0a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/216906fb75a7211f7905d3b37274c6b6ec331295", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/216906fb75a7211f7905d3b37274c6b6ec331295", "html_url": "https://github.com/rust-lang/rust/commit/216906fb75a7211f7905d3b37274c6b6ec331295", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/216906fb75a7211f7905d3b37274c6b6ec331295/comments", "author": {"login": "jackh726", "id": 31162821, "node_id": "MDQ6VXNlcjMxMTYyODIx", "avatar_url": "https://avatars.githubusercontent.com/u/31162821?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jackh726", "html_url": "https://github.com/jackh726", "followers_url": "https://api.github.com/users/jackh726/followers", "following_url": "https://api.github.com/users/jackh726/following{/other_user}", "gists_url": "https://api.github.com/users/jackh726/gists{/gist_id}", "starred_url": "https://api.github.com/users/jackh726/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jackh726/subscriptions", "organizations_url": "https://api.github.com/users/jackh726/orgs", "repos_url": "https://api.github.com/users/jackh726/repos", "events_url": "https://api.github.com/users/jackh726/events{/privacy}", "received_events_url": "https://api.github.com/users/jackh726/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jackh726", "id": 31162821, "node_id": "MDQ6VXNlcjMxMTYyODIx", "avatar_url": "https://avatars.githubusercontent.com/u/31162821?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jackh726", "html_url": "https://github.com/jackh726", "followers_url": "https://api.github.com/users/jackh726/followers", "following_url": "https://api.github.com/users/jackh726/following{/other_user}", "gists_url": "https://api.github.com/users/jackh726/gists{/gist_id}", "starred_url": "https://api.github.com/users/jackh726/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jackh726/subscriptions", "organizations_url": "https://api.github.com/users/jackh726/orgs", "repos_url": "https://api.github.com/users/jackh726/repos", "events_url": "https://api.github.com/users/jackh726/events{/privacy}", "received_events_url": "https://api.github.com/users/jackh726/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f1f1d56d93b40228296e6306fadbcc352edbafc5", "url": "https://api.github.com/repos/rust-lang/rust/commits/f1f1d56d93b40228296e6306fadbcc352edbafc5", "html_url": "https://github.com/rust-lang/rust/commit/f1f1d56d93b40228296e6306fadbcc352edbafc5"}], "stats": {"total": 186, "additions": 63, "deletions": 123}, "files": [{"sha": "b7497c713f3df32d76a8f04ce0e6e98b0a4720c4", "filename": "compiler/rustc_ast_lowering/src/item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/216906fb75a7211f7905d3b37274c6b6ec331295/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/216906fb75a7211f7905d3b37274c6b6ec331295/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs?ref=216906fb75a7211f7905d3b37274c6b6ec331295", "patch": "@@ -1353,7 +1353,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         // Error if `?Trait` bounds in where clauses don't refer directly to type paramters.\n         // Note: we used to clone these bounds directly onto the type parameter (and avoid lowering\n         // these into hir when we lower thee where clauses), but this makes it quite difficult to\n-        // keep track of the Span info. Now, `is_unsized` in `AstConv` checks both param bounds and\n+        // keep track of the Span info. Now, `add_implicitly_sized` in `AstConv` checks both param bounds and\n         // where clauses for `?Sized`.\n         for pred in &generics.where_clause.predicates {\n             if let WherePredicate::BoundPredicate(ref bound_pred) = *pred {"}, {"sha": "3b41b220ccd4cc1acee071c0d93ce72ba65d9bac", "filename": "compiler/rustc_typeck/src/astconv/mod.rs", "status": "modified", "additions": 43, "deletions": 80, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/216906fb75a7211f7905d3b37274c6b6ec331295/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/216906fb75a7211f7905d3b37274c6b6ec331295/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs?ref=216906fb75a7211f7905d3b37274c6b6ec331295", "patch": "@@ -111,11 +111,6 @@ pub trait AstConv<'tcx> {\n     fn record_ty(&self, hir_id: hir::HirId, ty: Ty<'tcx>, span: Span);\n }\n \n-pub enum SizedByDefault {\n-    Yes,\n-    No,\n-}\n-\n #[derive(Debug)]\n struct ConvertedBinding<'a, 'tcx> {\n     hir_id: hir::HirId,\n@@ -853,28 +848,31 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             .is_some()\n     }\n \n-    // Returns `true` if a bounds list includes `?Sized`.\n-    fn is_unsized(\n+    // Sets `implicitly_sized` to true on `Bounds` if necessary\n+    pub(crate) fn add_implicitly_sized<'hir>(\n         &self,\n-        ast_bounds: &[hir::GenericBound<'_>],\n-        self_ty: Option<hir::HirId>,\n-        where_clause: Option<&[hir::WherePredicate<'_>]>,\n+        bounds: &mut Bounds<'hir>,\n+        ast_bounds: &'hir [hir::GenericBound<'hir>],\n+        self_ty_where_predicates: Option<(hir::HirId, &'hir [hir::WherePredicate<'hir>])>,\n         span: Span,\n-    ) -> bool {\n+    ) {\n         let tcx = self.tcx();\n \n         // Try to find an unbound in bounds.\n         let mut unbound = None;\n-        for ab in ast_bounds {\n-            if let hir::GenericBound::Trait(ptr, hir::TraitBoundModifier::Maybe) = ab {\n-                if unbound.is_none() {\n-                    unbound = Some(&ptr.trait_ref);\n-                } else {\n-                    tcx.sess.emit_err(MultipleRelaxedDefaultBounds { span });\n+        let mut search_bounds = |ast_bounds: &'hir [hir::GenericBound<'hir>]| {\n+            for ab in ast_bounds {\n+                if let hir::GenericBound::Trait(ptr, hir::TraitBoundModifier::Maybe) = ab {\n+                    if unbound.is_none() {\n+                        unbound = Some(&ptr.trait_ref);\n+                    } else {\n+                        tcx.sess.emit_err(MultipleRelaxedDefaultBounds { span });\n+                    }\n                 }\n             }\n-        }\n-        if let (Some(self_ty), Some(where_clause)) = (self_ty, where_clause) {\n+        };\n+        search_bounds(ast_bounds);\n+        if let Some((self_ty, where_clause)) = self_ty_where_predicates {\n             let self_ty_def_id = tcx.hir().local_def_id(self_ty).to_def_id();\n             for clause in where_clause {\n                 match clause {\n@@ -886,46 +884,40 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                             },\n                             _ => continue,\n                         }\n-                        for ab in pred.bounds {\n-                            if let hir::GenericBound::Trait(ptr, hir::TraitBoundModifier::Maybe) =\n-                                ab\n-                            {\n-                                if unbound.is_none() {\n-                                    unbound = Some(&ptr.trait_ref);\n-                                } else {\n-                                    tcx.sess.emit_err(MultipleRelaxedDefaultBounds { span });\n-                                }\n-                            }\n-                        }\n+                        search_bounds(pred.bounds);\n                     }\n                     _ => {}\n                 }\n             }\n         }\n \n-        let kind_id = tcx.lang_items().require(LangItem::Sized);\n-        match unbound {\n-            Some(tpb) => {\n-                if let Ok(kind_id) = kind_id {\n-                    if tpb.path.res != Res::Def(DefKind::Trait, kind_id) {\n-                        tcx.sess.span_warn(\n-                            span,\n-                            \"default bound relaxed for a type parameter, but \\\n-                             this does nothing because the given bound is not \\\n-                             a default; only `?Sized` is supported\",\n-                        );\n-                        return false;\n-                    }\n-                }\n+        let sized_def_id = tcx.lang_items().require(LangItem::Sized);\n+        match (&sized_def_id, unbound) {\n+            (Ok(sized_def_id), Some(tpb))\n+                if tpb.path.res == Res::Def(DefKind::Trait, *sized_def_id) =>\n+            {\n+                // There was in fact a `?Sized` bound, return without doing anything\n+                return;\n             }\n-            _ if kind_id.is_ok() => {\n-                return false;\n+            (_, Some(_)) => {\n+                // There was a `?Trait` bound, but it was not `?Sized`; warn.\n+                tcx.sess.span_warn(\n+                    span,\n+                    \"default bound relaxed for a type parameter, but \\\n+                        this does nothing because the given bound is not \\\n+                        a default; only `?Sized` is supported\",\n+                );\n+                // Otherwise, add implicitly sized if `Sized` is available.\n+            }\n+            _ => {\n+                // There was no `?Sized` bound; add implicitly sized if `Sized` is available.\n             }\n+        }\n+        if sized_def_id.is_err() {\n             // No lang item for `Sized`, so we can't add it as a bound.\n-            None => {}\n+            return;\n         }\n-\n-        true\n+        bounds.implicitly_sized = Some(span);\n     }\n \n     /// This helper takes a *converted* parameter type (`param_ty`)\n@@ -1006,19 +998,8 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         &self,\n         param_ty: Ty<'tcx>,\n         ast_bounds: &[hir::GenericBound<'_>],\n-        self_ty: Option<hir::HirId>,\n-        where_clause: Option<&[hir::WherePredicate<'_>]>,\n-        sized_by_default: SizedByDefault,\n-        span: Span,\n     ) -> Bounds<'tcx> {\n-        self.compute_bounds_inner(\n-            param_ty,\n-            &ast_bounds,\n-            self_ty,\n-            where_clause,\n-            sized_by_default,\n-            span,\n-        )\n+        self.compute_bounds_inner(param_ty, &ast_bounds)\n     }\n \n     /// Convert the bounds in `ast_bounds` that refer to traits which define an associated type\n@@ -1027,10 +1008,6 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         &self,\n         param_ty: Ty<'tcx>,\n         ast_bounds: &[hir::GenericBound<'_>],\n-        self_ty: Option<hir::HirId>,\n-        where_clause: Option<&[hir::WherePredicate<'_>]>,\n-        sized_by_default: SizedByDefault,\n-        span: Span,\n         assoc_name: Ident,\n     ) -> Bounds<'tcx> {\n         let mut result = Vec::new();\n@@ -1045,32 +1022,18 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             }\n         }\n \n-        self.compute_bounds_inner(param_ty, &result, self_ty, where_clause, sized_by_default, span)\n+        self.compute_bounds_inner(param_ty, &result)\n     }\n \n     fn compute_bounds_inner(\n         &self,\n         param_ty: Ty<'tcx>,\n         ast_bounds: &[hir::GenericBound<'_>],\n-        self_ty: Option<hir::HirId>,\n-        where_clause: Option<&[hir::WherePredicate<'_>]>,\n-        sized_by_default: SizedByDefault,\n-        span: Span,\n     ) -> Bounds<'tcx> {\n         let mut bounds = Bounds::default();\n \n         self.add_bounds(param_ty, ast_bounds, &mut bounds, ty::List::empty());\n \n-        bounds.implicitly_sized = if let SizedByDefault::Yes = sized_by_default {\n-            if !self.is_unsized(ast_bounds, self_ty, where_clause, span) {\n-                Some(span)\n-            } else {\n-                None\n-            }\n-        } else {\n-            None\n-        };\n-\n         bounds\n     }\n "}, {"sha": "f02ed3304d63af5f1493c236ad2305985ec93b1c", "filename": "compiler/rustc_typeck/src/collect.rs", "status": "modified", "additions": 7, "deletions": 20, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/216906fb75a7211f7905d3b37274c6b6ec331295/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/216906fb75a7211f7905d3b37274c6b6ec331295/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs?ref=216906fb75a7211f7905d3b37274c6b6ec331295", "patch": "@@ -14,7 +14,7 @@\n //! At present, however, we do run collection across all items in the\n //! crate as a kind of pass. This should eventually be factored away.\n \n-use crate::astconv::{AstConv, SizedByDefault};\n+use crate::astconv::AstConv;\n use crate::bounds::Bounds;\n use crate::check::intrinsic::intrinsic_operation_unsafety;\n use crate::constrained_generic_params as cgp;\n@@ -1156,22 +1156,10 @@ fn super_predicates_that_define_assoc_type(\n                 &icx,\n                 self_param_ty,\n                 &bounds,\n-                None,\n-                None,\n-                SizedByDefault::No,\n-                item.span,\n                 assoc_name,\n             )\n         } else {\n-            <dyn AstConv<'_>>::compute_bounds(\n-                &icx,\n-                self_param_ty,\n-                &bounds,\n-                None,\n-                None,\n-                SizedByDefault::No,\n-                item.span,\n-            )\n+            <dyn AstConv<'_>>::compute_bounds(&icx, self_param_ty, &bounds)\n         };\n \n         let superbounds1 = superbounds1.predicates(tcx, self_param_ty);\n@@ -2180,14 +2168,13 @@ fn gather_explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericP\n                 let param_ty = ty::ParamTy::new(index, name).to_ty(tcx);\n                 index += 1;\n \n-                let sized = SizedByDefault::Yes;\n-                let bounds = <dyn AstConv<'_>>::compute_bounds(\n+                let mut bounds = <dyn AstConv<'_>>::compute_bounds(&icx, param_ty, &param.bounds);\n+                // Params are implicitly sized unless a `?Sized` bound is found\n+                <dyn AstConv<'_>>::add_implicitly_sized(\n                     &icx,\n-                    param_ty,\n+                    &mut bounds,\n                     &param.bounds,\n-                    Some(param.hir_id),\n-                    Some(ast_generics.where_clause.predicates),\n-                    sized,\n+                    Some((param.hir_id, ast_generics.where_clause.predicates)),\n                     param.span,\n                 );\n                 predicates.extend(bounds.predicates(tcx, param_ty));"}, {"sha": "2bc048ac8a0e9395fd69b79749c586cfcc9b9ac6", "filename": "compiler/rustc_typeck/src/collect/item_bounds.rs", "status": "modified", "additions": 12, "deletions": 22, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/216906fb75a7211f7905d3b37274c6b6ec331295/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Fitem_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/216906fb75a7211f7905d3b37274c6b6ec331295/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Fitem_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Fitem_bounds.rs?ref=216906fb75a7211f7905d3b37274c6b6ec331295", "patch": "@@ -1,5 +1,5 @@\n use super::ItemCtxt;\n-use crate::astconv::{AstConv, SizedByDefault};\n+use crate::astconv::AstConv;\n use rustc_hir as hir;\n use rustc_infer::traits::util;\n use rustc_middle::ty::subst::InternalSubsts;\n@@ -17,23 +17,18 @@ use rustc_span::Span;\n fn associated_type_bounds<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     assoc_item_def_id: DefId,\n-    bounds: &'tcx [hir::GenericBound<'tcx>],\n+    ast_bounds: &'tcx [hir::GenericBound<'tcx>],\n     span: Span,\n ) -> &'tcx [(ty::Predicate<'tcx>, Span)] {\n     let item_ty = tcx.mk_projection(\n         assoc_item_def_id,\n         InternalSubsts::identity_for_item(tcx, assoc_item_def_id),\n     );\n \n-    let bounds = <dyn AstConv<'_>>::compute_bounds(\n-        &ItemCtxt::new(tcx, assoc_item_def_id),\n-        item_ty,\n-        &bounds,\n-        None,\n-        None,\n-        SizedByDefault::Yes,\n-        span,\n-    );\n+    let icx = ItemCtxt::new(tcx, assoc_item_def_id);\n+    let mut bounds = <dyn AstConv<'_>>::compute_bounds(&icx, item_ty, &ast_bounds);\n+    // Associated types are implicitly sized unless a `?Sized` bound is found\n+    <dyn AstConv<'_>>::add_implicitly_sized(&icx, &mut bounds, &ast_bounds, None, span);\n \n     let trait_def_id = tcx.associated_item(assoc_item_def_id).container.id();\n     let trait_predicates = tcx.trait_explicit_predicates_and_bounds(trait_def_id.expect_local());\n@@ -61,23 +56,18 @@ fn associated_type_bounds<'tcx>(\n fn opaque_type_bounds<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     opaque_def_id: DefId,\n-    bounds: &'tcx [hir::GenericBound<'tcx>],\n+    ast_bounds: &'tcx [hir::GenericBound<'tcx>],\n     span: Span,\n ) -> &'tcx [(ty::Predicate<'tcx>, Span)] {\n     ty::print::with_no_queries(|| {\n         let item_ty =\n             tcx.mk_opaque(opaque_def_id, InternalSubsts::identity_for_item(tcx, opaque_def_id));\n \n-        let bounds = <dyn AstConv<'_>>::compute_bounds(\n-            &ItemCtxt::new(tcx, opaque_def_id),\n-            item_ty,\n-            &bounds,\n-            None,\n-            None,\n-            SizedByDefault::Yes,\n-            span,\n-        )\n-        .predicates(tcx, item_ty);\n+        let icx = ItemCtxt::new(tcx, opaque_def_id);\n+        let mut bounds = <dyn AstConv<'_>>::compute_bounds(&icx, item_ty, &ast_bounds);\n+        // Opaque types are implicitly sized unless a `?Sized` bound is found\n+        <dyn AstConv<'_>>::add_implicitly_sized(&icx, &mut bounds, &ast_bounds, None, span);\n+        let bounds = bounds.predicates(tcx, item_ty);\n \n         debug!(\"opaque_type_bounds({}) = {:?}\", tcx.def_path_str(opaque_def_id), bounds);\n "}]}