{"sha": "7b420aee3581f8d092df6e53f7be3b39890704fc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdiNDIwYWVlMzU4MWY4ZDA5MmRmNmU1M2Y3YmUzYjM5ODkwNzA0ZmM=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2020-03-21T04:33:26Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-03-21T04:33:26Z"}, "message": "Rollup merge of #70166 - CDirkx:range-inclusive-derives, r=cramertj\n\nDerive PartialEq, Eq and Hash for RangeInclusive\n\nThe manual implementation of `PartialEq`, `Eq` and `Hash` for `RangeInclusive` was functionally equivalent to a derived implementation.\n\nThis change removes the manual implementation and adds the respective derives.\nA side effect of this change is that the derives also add implementations for `StructuralPartialEq` and `StructuralEq`, which enables `RangeInclusive` to be used in const generics, closing #70155.\n\nThis change is enabled by #68835, which changed the field `is_empty: Option<bool>` to `exhausted: bool` removing the need for *semantic* equality instead of *structural* equality.\n\n## PartialEq\noriginal [`PartialEq`](https://github.com/rust-lang/rust/blob/f4c675c476c18b1a11041193f2f59d695b126bc8/src/libcore/ops/range.rs#L353-L359) implementation:\n```rust\n#[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\nimpl<Idx: PartialEq> PartialEq for RangeInclusive<Idx> {\n    #[inline]\n    fn eq(&self, other: &Self) -> bool {\n        self.start == other.start && self.end == other.end && self.exhausted == other.exhausted\n    }\n}\n```\nexpanded derive implementation (using `cargo expand ops::range`):\n```rust\n#[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\nimpl<Idx> crate::marker::StructuralPartialEq for RangeInclusive<Idx> {}\n\n#[automatically_derived]\n#[allow(unused_qualifications)]\n#[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\nimpl<Idx: crate::cmp::PartialEq> crate::cmp::PartialEq for RangeInclusive<Idx> {\n    #[inline]\n    fn eq(&self, other: &RangeInclusive<Idx>) -> bool {\n        match *other {\n            RangeInclusive { start: ref __self_1_0,end: ref __self_1_1, exhausted: ref __self_1_2 } => match *self {\n                RangeInclusive { start: ref __self_0_0, end: ref __self_0_1, exhausted: ref __self_0_2 } => {\n                    (*__self_0_0) == (*__self_1_0) && (*__self_0_1) == (*__self_1_1) && (*__self_0_2) == (*__self_1_2)\n                }\n            },\n        }\n    }\n    #[inline]\n    fn ne(&self, other: &RangeInclusive<Idx>) -> bool {\n        match *other {\n            RangeInclusive { start: ref __self_1_0, end: ref __self_1_1, exhausted: ref __self_1_2 } => match *self {\n                RangeInclusive { start: ref __self_0_0, end: ref __self_0_1exhausted: ref __self_0_2 } => {\n                    (*__self_0_0) != (*__self_1_0) || (*__self_0_1) != (*__self_1_1) || (*__self_0_2) != (*__self_1_2)\n                }\n            },\n        }\n    }\n}\n```\n\nThese implementations both test for *structural* equality, with the same order of field comparisons, and the bound `Idx: PartialEq` is the same.\n## Eq\noriginal [`Eq`](https://github.com/rust-lang/rust/blob/f4c675c476c18b1a11041193f2f59d695b126bc8/src/libcore/ops/range.rs#L361-L362) implementation:\n```rust\n#[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\nimpl<Idx: Eq> Eq for RangeInclusive<Idx> {}\n```\nexpanded derive implementation (using `cargo expand ops::range`):\n```rust\n#[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\nimpl<Idx> crate::marker::StructuralEq for RangeInclusive<Idx> {}\n\n#[automatically_derived]\n#[allow(unused_qualifications)]\n#[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\nimpl<Idx: crate::cmp::Eq> crate::cmp::Eq for RangeInclusive<Idx> {\n    #[inline]\n    #[doc(hidden)]\n    fn assert_receiver_is_total_eq(&self) -> () {\n        {\n            let _: crate::cmp::AssertParamIsEq<Idx>;\n            let _: crate::cmp::AssertParamIsEq<Idx>;\n            let _: crate::cmp::AssertParamIsEq<bool>;\n        }\n    }\n}\n```\nThese implementations are equivalent since `Eq` is just a marker trait and the bound `Idx: Eq` is the same.\n\n## Hash\noriginal [`Hash`](https://github.com/rust-lang/rust/blob/f4c675c476c18b1a11041193f2f59d695b126bc8/src/libcore/ops/range.rs#L364-L371) implementation:\n```rust\n#[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\nimpl<Idx: Hash> Hash for RangeInclusive<Idx> {\n    fn hash<H: Hasher>(&self, state: &mut H) {\n        self.start.hash(state);\n        self.end.hash(state);\n        self.exhausted.hash(state);\n    }\n}\n```\nexpanded derive implementation (using `cargo expand ops::range`):\n```rust\n#[automatically_derived]\n#[allow(unused_qualifications)]\n#[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\nimpl<Idx: crate::hash::Hash> crate::hash::Hash for RangeInclusive<Idx> {\n    fn hash<__H: crate::hash::Hasher>(&self, state: &mut __H) -> () {\n        match *self { RangeInclusive { start: ref __self_0_0, end: ref __self_0_1, exhausted: ref __self_0_2 } => {\n                crate::hash::Hash::hash(&(*__self_0_0), state);\n                crate::hash::Hash::hash(&(*__self_0_1), state);\n                crate::hash::Hash::hash(&(*__self_0_2), state)\n            }\n        }\n    }\n}\n```\nThese implementations are functionally equivalent, with the same order of field hashing, and the bound `Idx: Hash` is the same.", "tree": {"sha": "de27a9ddb9af5615ed637f4f17c5b89ddf5a3636", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/de27a9ddb9af5615ed637f4f17c5b89ddf5a3636"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7b420aee3581f8d092df6e53f7be3b39890704fc", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJedZkWCRBK7hj4Ov3rIwAAdHIIADtrEroXFROfXRuqzxRUlKKH\ntdzrZgNHQnrS5b6LkzYVovEmbih8y0CDhn91l63emEs9IdfFsHUlQJXH7nt0DUEW\ncF60QSk8cd2Df5hFLRrcUAgofn1uVXFursf6RpHwkR6GaKjCSQdjPmvgagZp5/9Z\nqqq9TOES3gK/55UDJVVR/LwYIrVEBfztZey9T8A0Ni1xHu8/QM87QkqvAEodx6m3\n2/C4kcSUg/DCyziFudCHo2swHfTUYDlbvWNNrBCIVDAMbqK4G5FwHwt7Xg7Nx2ay\nWye5ULiVyVt+29MLyxXi9+tfGZOP7wo755PDOmwUCFkRQxKMp+LCZo7RfKgvxpo=\n=5No0\n-----END PGP SIGNATURE-----\n", "payload": "tree de27a9ddb9af5615ed637f4f17c5b89ddf5a3636\nparent b24d168e1043c7e12d3c807e3b8ba14640bc7cbe\nparent 6570e275b9cfc6448c096e6bc86cddd602c333bd\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1584765206 +0100\ncommitter GitHub <noreply@github.com> 1584765206 +0100\n\nRollup merge of #70166 - CDirkx:range-inclusive-derives, r=cramertj\n\nDerive PartialEq, Eq and Hash for RangeInclusive\n\nThe manual implementation of `PartialEq`, `Eq` and `Hash` for `RangeInclusive` was functionally equivalent to a derived implementation.\n\nThis change removes the manual implementation and adds the respective derives.\nA side effect of this change is that the derives also add implementations for `StructuralPartialEq` and `StructuralEq`, which enables `RangeInclusive` to be used in const generics, closing #70155.\n\nThis change is enabled by #68835, which changed the field `is_empty: Option<bool>` to `exhausted: bool` removing the need for *semantic* equality instead of *structural* equality.\n\n## PartialEq\noriginal [`PartialEq`](https://github.com/rust-lang/rust/blob/f4c675c476c18b1a11041193f2f59d695b126bc8/src/libcore/ops/range.rs#L353-L359) implementation:\n```rust\n#[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\nimpl<Idx: PartialEq> PartialEq for RangeInclusive<Idx> {\n    #[inline]\n    fn eq(&self, other: &Self) -> bool {\n        self.start == other.start && self.end == other.end && self.exhausted == other.exhausted\n    }\n}\n```\nexpanded derive implementation (using `cargo expand ops::range`):\n```rust\n#[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\nimpl<Idx> crate::marker::StructuralPartialEq for RangeInclusive<Idx> {}\n\n#[automatically_derived]\n#[allow(unused_qualifications)]\n#[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\nimpl<Idx: crate::cmp::PartialEq> crate::cmp::PartialEq for RangeInclusive<Idx> {\n    #[inline]\n    fn eq(&self, other: &RangeInclusive<Idx>) -> bool {\n        match *other {\n            RangeInclusive { start: ref __self_1_0,end: ref __self_1_1, exhausted: ref __self_1_2 } => match *self {\n                RangeInclusive { start: ref __self_0_0, end: ref __self_0_1, exhausted: ref __self_0_2 } => {\n                    (*__self_0_0) == (*__self_1_0) && (*__self_0_1) == (*__self_1_1) && (*__self_0_2) == (*__self_1_2)\n                }\n            },\n        }\n    }\n    #[inline]\n    fn ne(&self, other: &RangeInclusive<Idx>) -> bool {\n        match *other {\n            RangeInclusive { start: ref __self_1_0, end: ref __self_1_1, exhausted: ref __self_1_2 } => match *self {\n                RangeInclusive { start: ref __self_0_0, end: ref __self_0_1exhausted: ref __self_0_2 } => {\n                    (*__self_0_0) != (*__self_1_0) || (*__self_0_1) != (*__self_1_1) || (*__self_0_2) != (*__self_1_2)\n                }\n            },\n        }\n    }\n}\n```\n\nThese implementations both test for *structural* equality, with the same order of field comparisons, and the bound `Idx: PartialEq` is the same.\n## Eq\noriginal [`Eq`](https://github.com/rust-lang/rust/blob/f4c675c476c18b1a11041193f2f59d695b126bc8/src/libcore/ops/range.rs#L361-L362) implementation:\n```rust\n#[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\nimpl<Idx: Eq> Eq for RangeInclusive<Idx> {}\n```\nexpanded derive implementation (using `cargo expand ops::range`):\n```rust\n#[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\nimpl<Idx> crate::marker::StructuralEq for RangeInclusive<Idx> {}\n\n#[automatically_derived]\n#[allow(unused_qualifications)]\n#[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\nimpl<Idx: crate::cmp::Eq> crate::cmp::Eq for RangeInclusive<Idx> {\n    #[inline]\n    #[doc(hidden)]\n    fn assert_receiver_is_total_eq(&self) -> () {\n        {\n            let _: crate::cmp::AssertParamIsEq<Idx>;\n            let _: crate::cmp::AssertParamIsEq<Idx>;\n            let _: crate::cmp::AssertParamIsEq<bool>;\n        }\n    }\n}\n```\nThese implementations are equivalent since `Eq` is just a marker trait and the bound `Idx: Eq` is the same.\n\n## Hash\noriginal [`Hash`](https://github.com/rust-lang/rust/blob/f4c675c476c18b1a11041193f2f59d695b126bc8/src/libcore/ops/range.rs#L364-L371) implementation:\n```rust\n#[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\nimpl<Idx: Hash> Hash for RangeInclusive<Idx> {\n    fn hash<H: Hasher>(&self, state: &mut H) {\n        self.start.hash(state);\n        self.end.hash(state);\n        self.exhausted.hash(state);\n    }\n}\n```\nexpanded derive implementation (using `cargo expand ops::range`):\n```rust\n#[automatically_derived]\n#[allow(unused_qualifications)]\n#[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\nimpl<Idx: crate::hash::Hash> crate::hash::Hash for RangeInclusive<Idx> {\n    fn hash<__H: crate::hash::Hasher>(&self, state: &mut __H) -> () {\n        match *self { RangeInclusive { start: ref __self_0_0, end: ref __self_0_1, exhausted: ref __self_0_2 } => {\n                crate::hash::Hash::hash(&(*__self_0_0), state);\n                crate::hash::Hash::hash(&(*__self_0_1), state);\n                crate::hash::Hash::hash(&(*__self_0_2), state)\n            }\n        }\n    }\n}\n```\nThese implementations are functionally equivalent, with the same order of field hashing, and the bound `Idx: Hash` is the same.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7b420aee3581f8d092df6e53f7be3b39890704fc", "html_url": "https://github.com/rust-lang/rust/commit/7b420aee3581f8d092df6e53f7be3b39890704fc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7b420aee3581f8d092df6e53f7be3b39890704fc/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b24d168e1043c7e12d3c807e3b8ba14640bc7cbe", "url": "https://api.github.com/repos/rust-lang/rust/commits/b24d168e1043c7e12d3c807e3b8ba14640bc7cbe", "html_url": "https://github.com/rust-lang/rust/commit/b24d168e1043c7e12d3c807e3b8ba14640bc7cbe"}, {"sha": "6570e275b9cfc6448c096e6bc86cddd602c333bd", "url": "https://api.github.com/repos/rust-lang/rust/commits/6570e275b9cfc6448c096e6bc86cddd602c333bd", "html_url": "https://github.com/rust-lang/rust/commit/6570e275b9cfc6448c096e6bc86cddd602c333bd"}], "stats": {"total": 24, "additions": 2, "deletions": 22}, "files": [{"sha": "adee8cea442b439a6c97eb0f03cdd54f07457425", "filename": "src/libcore/ops/range.rs", "status": "modified", "additions": 2, "deletions": 22, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/7b420aee3581f8d092df6e53f7be3b39890704fc/src%2Flibcore%2Fops%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b420aee3581f8d092df6e53f7be3b39890704fc/src%2Flibcore%2Fops%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Frange.rs?ref=7b420aee3581f8d092df6e53f7be3b39890704fc", "patch": "@@ -1,5 +1,5 @@\n use crate::fmt;\n-use crate::hash::{Hash, Hasher};\n+use crate::hash::Hash;\n \n /// An unbounded range (`..`).\n ///\n@@ -330,7 +330,7 @@ impl<Idx: PartialOrd<Idx>> RangeTo<Idx> {\n /// assert_eq!(arr[1..=3], [  1,2,3  ]);  // RangeInclusive\n /// ```\n #[doc(alias = \"..=\")]\n-#[derive(Clone)] // not Copy -- see #27186\n+#[derive(Clone, PartialEq, Eq, Hash)] // not Copy -- see #27186\n #[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n pub struct RangeInclusive<Idx> {\n     // Note that the fields here are not public to allow changing the\n@@ -350,26 +350,6 @@ pub struct RangeInclusive<Idx> {\n     pub(crate) exhausted: bool,\n }\n \n-#[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n-impl<Idx: PartialEq> PartialEq for RangeInclusive<Idx> {\n-    #[inline]\n-    fn eq(&self, other: &Self) -> bool {\n-        self.start == other.start && self.end == other.end && self.exhausted == other.exhausted\n-    }\n-}\n-\n-#[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n-impl<Idx: Eq> Eq for RangeInclusive<Idx> {}\n-\n-#[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n-impl<Idx: Hash> Hash for RangeInclusive<Idx> {\n-    fn hash<H: Hasher>(&self, state: &mut H) {\n-        self.start.hash(state);\n-        self.end.hash(state);\n-        self.exhausted.hash(state);\n-    }\n-}\n-\n impl<Idx> RangeInclusive<Idx> {\n     /// Creates a new inclusive range. Equivalent to writing `start..=end`.\n     ///"}]}