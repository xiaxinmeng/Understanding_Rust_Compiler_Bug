{"sha": "0beba9333754ead8febc5101fc5c35f7dcdfaadf", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBiZWJhOTMzMzc1NGVhZDhmZWJjNTEwMWZjNWMzNWY3ZGNkZmFhZGY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-11-26T14:14:57Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-11-26T14:14:57Z"}, "message": "Auto merge of #79441 - jonas-schievink:rollup-l9v00bl, r=jonas-schievink\n\nRollup of 10 pull requests\n\nSuccessful merges:\n\n - #77758 (suggest turbofish syntax for uninferred const arguments)\n - #79000 (Move lev_distance to rustc_ast, make non-generic)\n - #79362 (Lower patterns before using the bound variable)\n - #79365 (Upgrades the coverage map to Version 4)\n - #79402 (Fix typos)\n - #79412 (Clean up rustdoc tests by removing unnecessary features)\n - #79413 (Fix persisted doctests on Windows / when using workspaces)\n - #79420 (Fixes a word typo in librustdoc)\n - #79421 (Fix docs formatting for `thir::pattern::_match`)\n - #79428 (Fixup compiler docs)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "dd05baf407cc40304a2b8be15fe3ce3e4b3c7374", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dd05baf407cc40304a2b8be15fe3ce3e4b3c7374"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0beba9333754ead8febc5101fc5c35f7dcdfaadf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0beba9333754ead8febc5101fc5c35f7dcdfaadf", "html_url": "https://github.com/rust-lang/rust/commit/0beba9333754ead8febc5101fc5c35f7dcdfaadf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0beba9333754ead8febc5101fc5c35f7dcdfaadf/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aefcf1f3427a5e522a8c665d7e25529cf971bc93", "url": "https://api.github.com/repos/rust-lang/rust/commits/aefcf1f3427a5e522a8c665d7e25529cf971bc93", "html_url": "https://github.com/rust-lang/rust/commit/aefcf1f3427a5e522a8c665d7e25529cf971bc93"}, {"sha": "89ab56344d560f63481359c2687cf4819f2341be", "url": "https://api.github.com/repos/rust-lang/rust/commits/89ab56344d560f63481359c2687cf4819f2341be", "html_url": "https://github.com/rust-lang/rust/commit/89ab56344d560f63481359c2687cf4819f2341be"}], "stats": {"total": 905, "additions": 540, "deletions": 365}, "files": [{"sha": "8a20dd796859034b226135d9ddd913db84ef2721", "filename": "compiler/rustc_ast/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0beba9333754ead8febc5101fc5c35f7dcdfaadf/compiler%2Frustc_ast%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0beba9333754ead8febc5101fc5c35f7dcdfaadf/compiler%2Frustc_ast%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Flib.rs?ref=0beba9333754ead8febc5101fc5c35f7dcdfaadf", "patch": "@@ -34,7 +34,6 @@ macro_rules! unwrap_or {\n pub mod util {\n     pub mod classify;\n     pub mod comments;\n-    pub mod lev_distance;\n     pub mod literal;\n     pub mod parser;\n }"}, {"sha": "314e5103cc2de3f5ac42868c69d76a626806d9f3", "filename": "compiler/rustc_ast_lowering/src/expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0beba9333754ead8febc5101fc5c35f7dcdfaadf/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0beba9333754ead8febc5101fc5c35f7dcdfaadf/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs?ref=0beba9333754ead8febc5101fc5c35f7dcdfaadf", "patch": "@@ -353,7 +353,6 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         let else_arm = self.arm(else_pat, else_expr);\n \n         // Handle then + scrutinee:\n-        let then_expr = self.lower_block_expr(then);\n         let (then_pat, scrutinee, desugar) = match cond.kind {\n             // `<pat> => <then>`:\n             ExprKind::Let(ref pat, ref scrutinee) => {\n@@ -375,6 +374,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 (pat, cond, hir::MatchSource::IfDesugar { contains_else_clause })\n             }\n         };\n+        let then_expr = self.lower_block_expr(then);\n         let then_arm = self.arm(then_pat, self.arena.alloc(then_expr));\n \n         hir::ExprKind::Match(scrutinee, arena_vec![self; then_arm, else_arm], desugar)\n@@ -400,7 +400,6 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         };\n \n         // Handle then + scrutinee:\n-        let then_expr = self.lower_block_expr(body);\n         let (then_pat, scrutinee, desugar, source) = match cond.kind {\n             ExprKind::Let(ref pat, ref scrutinee) => {\n                 // to:\n@@ -440,6 +439,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 (pat, cond, hir::MatchSource::WhileDesugar, hir::LoopSource::While)\n             }\n         };\n+        let then_expr = self.lower_block_expr(body);\n         let then_arm = self.arm(then_pat, self.arena.alloc(then_expr));\n \n         // `match <scrutinee> { ... }`"}, {"sha": "f7c693cc94d1fdd9efc9e877046461f3c0217a73", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 5, "deletions": 43, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/0beba9333754ead8febc5101fc5c35f7dcdfaadf/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0beba9333754ead8febc5101fc5c35f7dcdfaadf/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=0beba9333754ead8febc5101fc5c35f7dcdfaadf", "patch": "@@ -425,7 +425,6 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         /// declared for every type and trait definition.\n         struct MiscCollector<'tcx, 'lowering, 'hir> {\n             lctx: &'tcx mut LoweringContext<'lowering, 'hir>,\n-            hir_id_owner: Option<NodeId>,\n         }\n \n         impl MiscCollector<'_, '_, '_> {\n@@ -452,30 +451,9 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     }\n                 }\n             }\n-\n-            fn with_hir_id_owner<T>(\n-                &mut self,\n-                owner: Option<NodeId>,\n-                f: impl FnOnce(&mut Self) -> T,\n-            ) -> T {\n-                let old = mem::replace(&mut self.hir_id_owner, owner);\n-                let r = f(self);\n-                self.hir_id_owner = old;\n-                r\n-            }\n         }\n \n         impl<'tcx> Visitor<'tcx> for MiscCollector<'tcx, '_, '_> {\n-            fn visit_pat(&mut self, p: &'tcx Pat) {\n-                if let PatKind::Paren(..) | PatKind::Rest = p.kind {\n-                    // Doesn't generate a HIR node\n-                } else if let Some(owner) = self.hir_id_owner {\n-                    self.lctx.lower_node_id_with_owner(p.id, owner);\n-                }\n-\n-                visit::walk_pat(self, p)\n-            }\n-\n             fn visit_item(&mut self, item: &'tcx Item) {\n                 let hir_id = self.lctx.allocate_hir_id_counter(item.id);\n \n@@ -499,24 +477,12 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     _ => {}\n                 }\n \n-                self.with_hir_id_owner(Some(item.id), |this| {\n-                    visit::walk_item(this, item);\n-                });\n+                visit::walk_item(self, item);\n             }\n \n             fn visit_assoc_item(&mut self, item: &'tcx AssocItem, ctxt: AssocCtxt) {\n                 self.lctx.allocate_hir_id_counter(item.id);\n-                let owner = match (&item.kind, ctxt) {\n-                    // Ignore patterns in trait methods without bodies.\n-                    (AssocItemKind::Fn(_, _, _, None), AssocCtxt::Trait) => None,\n-                    _ => Some(item.id),\n-                };\n-                self.with_hir_id_owner(owner, |this| visit::walk_assoc_item(this, item, ctxt));\n-            }\n-\n-            fn visit_foreign_item(&mut self, i: &'tcx ForeignItem) {\n-                // Ignore patterns in foreign items\n-                self.with_hir_id_owner(None, |this| visit::walk_foreign_item(this, i));\n+                visit::walk_assoc_item(self, item, ctxt);\n             }\n \n             fn visit_ty(&mut self, t: &'tcx Ty) {\n@@ -527,18 +493,14 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                         // Mirrors visit::walk_fn_decl\n                         for parameter in &f.decl.inputs {\n                             // We don't lower the ids of argument patterns\n-                            self.with_hir_id_owner(None, |this| {\n-                                this.visit_pat(&parameter.pat);\n-                            });\n+                            self.visit_pat(&parameter.pat);\n                             self.visit_ty(&parameter.ty)\n                         }\n                         self.visit_fn_ret_ty(&f.decl.output)\n                     }\n                     TyKind::ImplTrait(def_node_id, _) => {\n                         self.lctx.allocate_hir_id_counter(def_node_id);\n-                        self.with_hir_id_owner(Some(def_node_id), |this| {\n-                            visit::walk_ty(this, t);\n-                        });\n+                        visit::walk_ty(self, t);\n                     }\n                     _ => visit::walk_ty(self, t),\n                 }\n@@ -548,7 +510,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         self.lower_node_id(CRATE_NODE_ID);\n         debug_assert!(self.node_id_to_hir_id[CRATE_NODE_ID] == Some(hir::CRATE_HIR_ID));\n \n-        visit::walk_crate(&mut MiscCollector { lctx: &mut self, hir_id_owner: None }, c);\n+        visit::walk_crate(&mut MiscCollector { lctx: &mut self }, c);\n         visit::walk_crate(&mut item::ItemLowerer { lctx: &mut self }, c);\n \n         let module = self.lower_mod(&c.module);"}, {"sha": "85aaa7e8893bfa107e4985089a0a50169a943fe2", "filename": "compiler/rustc_codegen_llvm/src/coverageinfo/mapgen.rs", "status": "modified", "additions": 109, "deletions": 112, "changes": 221, "blob_url": "https://github.com/rust-lang/rust/blob/0beba9333754ead8febc5101fc5c35f7dcdfaadf/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmapgen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0beba9333754ead8febc5101fc5c35f7dcdfaadf/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmapgen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmapgen.rs?ref=0beba9333754ead8febc5101fc5c35f7dcdfaadf", "patch": "@@ -4,7 +4,7 @@ use crate::llvm;\n \n use llvm::coverageinfo::CounterMappingRegion;\n use rustc_codegen_ssa::coverageinfo::map::{Counter, CounterExpression};\n-use rustc_codegen_ssa::traits::{BaseTypeMethods, ConstMethods};\n+use rustc_codegen_ssa::traits::ConstMethods;\n use rustc_data_structures::fx::FxIndexSet;\n use rustc_llvm::RustString;\n use rustc_middle::mir::coverage::CodeRegion;\n@@ -15,9 +15,9 @@ use tracing::debug;\n \n /// Generates and exports the Coverage Map.\n ///\n-/// This Coverage Map complies with Coverage Mapping Format version 3 (zero-based encoded as 2),\n-/// as defined at [LLVM Code Coverage Mapping Format](https://github.com/rust-lang/llvm-project/blob/llvmorg-8.0.0/llvm/docs/CoverageMappingFormat.rst#llvm-code-coverage-mapping-format)\n-/// and published in Rust's current (July 2020) fork of LLVM. This version is supported by the\n+/// This Coverage Map complies with Coverage Mapping Format version 4 (zero-based encoded as 3),\n+/// as defined at [LLVM Code Coverage Mapping Format](https://github.com/rust-lang/llvm-project/blob/rustc/11.0-2020-10-12/llvm/docs/CoverageMappingFormat.rst#llvm-code-coverage-mapping-format)\n+/// and published in Rust's current (November 2020) fork of LLVM. This version is supported by the\n /// LLVM coverage tools (`llvm-profdata` and `llvm-cov`) bundled with Rust's fork of LLVM.\n ///\n /// Consequently, Rust's bundled version of Clang also generates Coverage Maps compliant with\n@@ -26,6 +26,13 @@ use tracing::debug;\n /// undocumented details in Clang's implementation (that may or may not be important) were also\n /// replicated for Rust's Coverage Map.\n pub fn finalize<'ll, 'tcx>(cx: &CodegenCx<'ll, 'tcx>) {\n+    // Ensure LLVM supports Coverage Map Version 4 (encoded as a zero-based value: 3).\n+    // If not, the LLVM Version must be less than 11.\n+    let version = coverageinfo::mapping_version();\n+    if version != 3 {\n+        cx.tcx.sess.fatal(\"rustc option `-Z instrument-coverage` requires LLVM 11 or higher.\");\n+    }\n+\n     let function_coverage_map = match cx.coverage_context() {\n         Some(ctx) => ctx.take_function_coverage_map(),\n         None => return,\n@@ -38,46 +45,50 @@ pub fn finalize<'ll, 'tcx>(cx: &CodegenCx<'ll, 'tcx>) {\n     let mut mapgen = CoverageMapGenerator::new();\n \n     // Encode coverage mappings and generate function records\n-    let mut function_records = Vec::<&'ll llvm::Value>::new();\n-    let coverage_mappings_buffer = llvm::build_byte_buffer(|coverage_mappings_buffer| {\n-        for (instance, function_coverage) in function_coverage_map.into_iter() {\n-            debug!(\"Generate coverage map for: {:?}\", instance);\n-\n-            let mangled_function_name = cx.tcx.symbol_name(instance).to_string();\n-            let function_source_hash = function_coverage.source_hash();\n-            let (expressions, counter_regions) =\n-                function_coverage.get_expressions_and_counter_regions();\n-\n-            let old_len = coverage_mappings_buffer.len();\n-            mapgen.write_coverage_mappings(expressions, counter_regions, coverage_mappings_buffer);\n-            let mapping_data_size = coverage_mappings_buffer.len() - old_len;\n-            debug_assert!(\n-                mapping_data_size > 0,\n-                \"Every `FunctionCoverage` should have at least one counter\"\n-            );\n-\n-            let function_record = mapgen.make_function_record(\n-                cx,\n-                mangled_function_name,\n-                function_source_hash,\n-                mapping_data_size,\n-            );\n-            function_records.push(function_record);\n-        }\n-    });\n+    let mut function_data = Vec::new();\n+    for (instance, function_coverage) in function_coverage_map {\n+        debug!(\"Generate coverage map for: {:?}\", instance);\n+\n+        let mangled_function_name = cx.tcx.symbol_name(instance).to_string();\n+        let function_source_hash = function_coverage.source_hash();\n+        let (expressions, counter_regions) =\n+            function_coverage.get_expressions_and_counter_regions();\n+\n+        let coverage_mapping_buffer = llvm::build_byte_buffer(|coverage_mapping_buffer| {\n+            mapgen.write_coverage_mapping(expressions, counter_regions, coverage_mapping_buffer);\n+        });\n+        debug_assert!(\n+            coverage_mapping_buffer.len() > 0,\n+            \"Every `FunctionCoverage` should have at least one counter\"\n+        );\n+\n+        function_data.push((mangled_function_name, function_source_hash, coverage_mapping_buffer));\n+    }\n \n     // Encode all filenames referenced by counters/expressions in this module\n     let filenames_buffer = llvm::build_byte_buffer(|filenames_buffer| {\n         coverageinfo::write_filenames_section_to_buffer(&mapgen.filenames, filenames_buffer);\n     });\n \n+    let filenames_size = filenames_buffer.len();\n+    let filenames_val = cx.const_bytes(&filenames_buffer[..]);\n+    let filenames_ref = coverageinfo::hash_bytes(filenames_buffer);\n+\n     // Generate the LLVM IR representation of the coverage map and store it in a well-known global\n-    mapgen.save_generated_coverage_map(\n-        cx,\n-        function_records,\n-        filenames_buffer,\n-        coverage_mappings_buffer,\n-    );\n+    let cov_data_val = mapgen.generate_coverage_map(cx, version, filenames_size, filenames_val);\n+\n+    for (mangled_function_name, function_source_hash, coverage_mapping_buffer) in function_data {\n+        save_function_record(\n+            cx,\n+            mangled_function_name,\n+            function_source_hash,\n+            filenames_ref,\n+            coverage_mapping_buffer,\n+        );\n+    }\n+\n+    // Save the coverage data value to LLVM IR\n+    coverageinfo::save_cov_data_to_mod(cx, cov_data_val);\n }\n \n struct CoverageMapGenerator {\n@@ -92,12 +103,12 @@ impl CoverageMapGenerator {\n     /// Using the `expressions` and `counter_regions` collected for the current function, generate\n     /// the `mapping_regions` and `virtual_file_mapping`, and capture any new filenames. Then use\n     /// LLVM APIs to encode the `virtual_file_mapping`, `expressions`, and `mapping_regions` into\n-    /// the given `coverage_mappings` byte buffer, compliant with the LLVM Coverage Mapping format.\n-    fn write_coverage_mappings(\n+    /// the given `coverage_mapping` byte buffer, compliant with the LLVM Coverage Mapping format.\n+    fn write_coverage_mapping(\n         &mut self,\n         expressions: Vec<CounterExpression>,\n         counter_regions: impl Iterator<Item = (Counter, &'a CodeRegion)>,\n-        coverage_mappings_buffer: &RustString,\n+        coverage_mapping_buffer: &RustString,\n     ) {\n         let mut counter_regions = counter_regions.collect::<Vec<_>>();\n         if counter_regions.is_empty() {\n@@ -145,89 +156,75 @@ impl CoverageMapGenerator {\n             virtual_file_mapping,\n             expressions,\n             mapping_regions,\n-            coverage_mappings_buffer,\n+            coverage_mapping_buffer,\n         );\n     }\n \n-    /// Generate and return the function record `Value`\n-    fn make_function_record(\n-        &mut self,\n-        cx: &CodegenCx<'ll, 'tcx>,\n-        mangled_function_name: String,\n-        function_source_hash: u64,\n-        mapping_data_size: usize,\n-    ) -> &'ll llvm::Value {\n-        let name_ref = coverageinfo::compute_hash(&mangled_function_name);\n-        let name_ref_val = cx.const_u64(name_ref);\n-        let mapping_data_size_val = cx.const_u32(mapping_data_size as u32);\n-        let func_hash_val = cx.const_u64(function_source_hash);\n-        cx.const_struct(\n-            &[name_ref_val, mapping_data_size_val, func_hash_val],\n-            /*packed=*/ true,\n-        )\n-    }\n-\n-    /// Combine the filenames and coverage mappings buffers, construct coverage map header and the\n-    /// array of function records, and combine everything into the complete coverage map. Save the\n-    /// coverage map data into the LLVM IR as a static global using a specific, well-known section\n-    /// and name.\n-    fn save_generated_coverage_map(\n+    /// Construct coverage map header and the array of function records, and combine them into the\n+    /// coverage map. Save the coverage map data into the LLVM IR as a static global using a\n+    /// specific, well-known section and name.\n+    fn generate_coverage_map(\n         self,\n         cx: &CodegenCx<'ll, 'tcx>,\n-        function_records: Vec<&'ll llvm::Value>,\n-        filenames_buffer: Vec<u8>,\n-        mut coverage_mappings_buffer: Vec<u8>,\n-    ) {\n-        // Concatenate the encoded filenames and encoded coverage mappings, and add additional zero\n-        // bytes as-needed to ensure 8-byte alignment.\n-        let mut coverage_size = coverage_mappings_buffer.len();\n-        let filenames_size = filenames_buffer.len();\n-        let remaining_bytes =\n-            (filenames_size + coverage_size) % coverageinfo::COVMAP_VAR_ALIGN_BYTES;\n-        if remaining_bytes > 0 {\n-            let pad = coverageinfo::COVMAP_VAR_ALIGN_BYTES - remaining_bytes;\n-            coverage_mappings_buffer.append(&mut [0].repeat(pad));\n-            coverage_size += pad;\n-        }\n-        let filenames_and_coverage_mappings = [filenames_buffer, coverage_mappings_buffer].concat();\n-        let filenames_and_coverage_mappings_val =\n-            cx.const_bytes(&filenames_and_coverage_mappings[..]);\n-\n-        debug!(\n-            \"cov map: n_records = {}, filenames_size = {}, coverage_size = {}, 0-based version = {}\",\n-            function_records.len(),\n-            filenames_size,\n-            coverage_size,\n-            coverageinfo::mapping_version()\n-        );\n+        version: u32,\n+        filenames_size: usize,\n+        filenames_val: &'ll llvm::Value,\n+    ) -> &'ll llvm::Value {\n+        debug!(\"cov map: filenames_size = {}, 0-based version = {}\", filenames_size, version);\n \n-        // Create the coverage data header\n-        let n_records_val = cx.const_u32(function_records.len() as u32);\n+        // Create the coverage data header (Note, fields 0 and 2 are now always zero,\n+        // as of `llvm::coverage::CovMapVersion::Version4`.)\n+        let zero_was_n_records_val = cx.const_u32(0);\n         let filenames_size_val = cx.const_u32(filenames_size as u32);\n-        let coverage_size_val = cx.const_u32(coverage_size as u32);\n-        let version_val = cx.const_u32(coverageinfo::mapping_version());\n+        let zero_was_coverage_size_val = cx.const_u32(0);\n+        let version_val = cx.const_u32(version);\n         let cov_data_header_val = cx.const_struct(\n-            &[n_records_val, filenames_size_val, coverage_size_val, version_val],\n+            &[zero_was_n_records_val, filenames_size_val, zero_was_coverage_size_val, version_val],\n             /*packed=*/ false,\n         );\n \n-        // Create the function records array\n-        let name_ref_from_u64 = cx.type_i64();\n-        let mapping_data_size_from_u32 = cx.type_i32();\n-        let func_hash_from_u64 = cx.type_i64();\n-        let function_record_ty = cx.type_struct(\n-            &[name_ref_from_u64, mapping_data_size_from_u32, func_hash_from_u64],\n-            /*packed=*/ true,\n-        );\n-        let function_records_val = cx.const_array(function_record_ty, &function_records[..]);\n-\n         // Create the complete LLVM coverage data value to add to the LLVM IR\n-        let cov_data_val = cx.const_struct(\n-            &[cov_data_header_val, function_records_val, filenames_and_coverage_mappings_val],\n-            /*packed=*/ false,\n-        );\n-\n-        // Save the coverage data value to LLVM IR\n-        coverageinfo::save_map_to_mod(cx, cov_data_val);\n+        cx.const_struct(&[cov_data_header_val, filenames_val], /*packed=*/ false)\n     }\n }\n+\n+/// Construct a function record and combine it with the function's coverage mapping data.\n+/// Save the function record into the LLVM IR as a static global using a\n+/// specific, well-known section and name.\n+fn save_function_record(\n+    cx: &CodegenCx<'ll, 'tcx>,\n+    mangled_function_name: String,\n+    function_source_hash: u64,\n+    filenames_ref: u64,\n+    coverage_mapping_buffer: Vec<u8>,\n+) {\n+    // Concatenate the encoded coverage mappings\n+    let coverage_mapping_size = coverage_mapping_buffer.len();\n+    let coverage_mapping_val = cx.const_bytes(&coverage_mapping_buffer[..]);\n+\n+    let func_name_hash = coverageinfo::hash_str(&mangled_function_name);\n+    let func_name_hash_val = cx.const_u64(func_name_hash);\n+    let coverage_mapping_size_val = cx.const_u32(coverage_mapping_size as u32);\n+    let func_hash_val = cx.const_u64(function_source_hash);\n+    let filenames_ref_val = cx.const_u64(filenames_ref);\n+    let func_record_val = cx.const_struct(\n+        &[\n+            func_name_hash_val,\n+            coverage_mapping_size_val,\n+            func_hash_val,\n+            filenames_ref_val,\n+            coverage_mapping_val,\n+        ],\n+        /*packed=*/ true,\n+    );\n+\n+    // At the present time, the coverage map for Rust assumes every instrumented function `is_used`.\n+    // Note that Clang marks functions as \"unused\" in `CodeGenPGO::emitEmptyCounterMapping`. (See:\n+    // https://github.com/rust-lang/llvm-project/blob/de02a75e398415bad4df27b4547c25b896c8bf3b/clang%2Flib%2FCodeGen%2FCodeGenPGO.cpp#L877-L878\n+    // for example.)\n+    //\n+    // It's not yet clear if or how this may be applied to Rust in the future, but the `is_used`\n+    // argument is available and handled similarly.\n+    let is_used = true;\n+    coverageinfo::save_func_record_to_mod(cx, func_name_hash, func_record_val, is_used);\n+}"}, {"sha": "e777f363eb0842ee25be12f5254eb986a7b54dea", "filename": "compiler/rustc_codegen_llvm/src/coverageinfo/mod.rs", "status": "modified", "additions": 46, "deletions": 8, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/0beba9333754ead8febc5101fc5c35f7dcdfaadf/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0beba9333754ead8febc5101fc5c35f7dcdfaadf/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmod.rs?ref=0beba9333754ead8febc5101fc5c35f7dcdfaadf", "patch": "@@ -23,7 +23,7 @@ use tracing::debug;\n \n pub mod mapgen;\n \n-const COVMAP_VAR_ALIGN_BYTES: usize = 8;\n+const VAR_ALIGN_BYTES: usize = 8;\n \n /// A context object for maintaining all state needed by the coverageinfo module.\n pub struct CrateCoverageContext<'tcx> {\n@@ -177,17 +177,20 @@ pub(crate) fn write_mapping_to_buffer(\n         );\n     }\n }\n+pub(crate) fn hash_str(strval: &str) -> u64 {\n+    let strval = CString::new(strval).expect(\"null error converting hashable str to C string\");\n+    unsafe { llvm::LLVMRustCoverageHashCString(strval.as_ptr()) }\n+}\n \n-pub(crate) fn compute_hash(name: &str) -> u64 {\n-    let name = CString::new(name).expect(\"null error converting hashable name to C string\");\n-    unsafe { llvm::LLVMRustCoverageComputeHash(name.as_ptr()) }\n+pub(crate) fn hash_bytes(bytes: Vec<u8>) -> u64 {\n+    unsafe { llvm::LLVMRustCoverageHashByteArray(bytes.as_ptr().cast(), bytes.len()) }\n }\n \n pub(crate) fn mapping_version() -> u32 {\n     unsafe { llvm::LLVMRustCoverageMappingVersion() }\n }\n \n-pub(crate) fn save_map_to_mod<'ll, 'tcx>(\n+pub(crate) fn save_cov_data_to_mod<'ll, 'tcx>(\n     cx: &CodegenCx<'ll, 'tcx>,\n     cov_data_val: &'ll llvm::Value,\n ) {\n@@ -198,16 +201,51 @@ pub(crate) fn save_map_to_mod<'ll, 'tcx>(\n     debug!(\"covmap var name: {:?}\", covmap_var_name);\n \n     let covmap_section_name = llvm::build_string(|s| unsafe {\n-        llvm::LLVMRustCoverageWriteSectionNameToString(cx.llmod, s);\n+        llvm::LLVMRustCoverageWriteMapSectionNameToString(cx.llmod, s);\n     })\n     .expect(\"Rust Coverage section name failed UTF-8 conversion\");\n     debug!(\"covmap section name: {:?}\", covmap_section_name);\n \n     let llglobal = llvm::add_global(cx.llmod, cx.val_ty(cov_data_val), &covmap_var_name);\n     llvm::set_initializer(llglobal, cov_data_val);\n     llvm::set_global_constant(llglobal, true);\n-    llvm::set_linkage(llglobal, llvm::Linkage::InternalLinkage);\n+    llvm::set_linkage(llglobal, llvm::Linkage::PrivateLinkage);\n     llvm::set_section(llglobal, &covmap_section_name);\n-    llvm::set_alignment(llglobal, COVMAP_VAR_ALIGN_BYTES);\n+    llvm::set_alignment(llglobal, VAR_ALIGN_BYTES);\n+    cx.add_used_global(llglobal);\n+}\n+\n+pub(crate) fn save_func_record_to_mod<'ll, 'tcx>(\n+    cx: &CodegenCx<'ll, 'tcx>,\n+    func_name_hash: u64,\n+    func_record_val: &'ll llvm::Value,\n+    is_used: bool,\n+) {\n+    // Assign a name to the function record. This is used to merge duplicates.\n+    //\n+    // In LLVM, a \"translation unit\" (effectively, a `Crate` in Rust) can describe functions that\n+    // are included-but-not-used. If (or when) Rust generates functions that are\n+    // included-but-not-used, note that a dummy description for a function included-but-not-used\n+    // in a Crate can be replaced by full description provided by a different Crate. The two kinds\n+    // of descriptions play distinct roles in LLVM IR; therefore, assign them different names (by\n+    // appending \"u\" to the end of the function record var name, to prevent `linkonce_odr` merging.\n+    let func_record_var_name =\n+        format!(\"__covrec_{:X}{}\", func_name_hash, if is_used { \"u\" } else { \"\" });\n+    debug!(\"function record var name: {:?}\", func_record_var_name);\n+\n+    let func_record_section_name = llvm::build_string(|s| unsafe {\n+        llvm::LLVMRustCoverageWriteFuncSectionNameToString(cx.llmod, s);\n+    })\n+    .expect(\"Rust Coverage function record section name failed UTF-8 conversion\");\n+    debug!(\"function record section name: {:?}\", func_record_section_name);\n+\n+    let llglobal = llvm::add_global(cx.llmod, cx.val_ty(func_record_val), &func_record_var_name);\n+    llvm::set_initializer(llglobal, func_record_val);\n+    llvm::set_global_constant(llglobal, true);\n+    llvm::set_linkage(llglobal, llvm::Linkage::LinkOnceODRLinkage);\n+    llvm::set_visibility(llglobal, llvm::Visibility::Hidden);\n+    llvm::set_section(llglobal, &func_record_section_name);\n+    llvm::set_alignment(llglobal, VAR_ALIGN_BYTES);\n+    llvm::set_comdat(cx.llmod, llglobal, &func_record_var_name);\n     cx.add_used_global(llglobal);\n }"}, {"sha": "41482d18946ad7f9ebbeacc625f7049b01ed6c47", "filename": "compiler/rustc_codegen_llvm/src/llvm/ffi.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0beba9333754ead8febc5101fc5c35f7dcdfaadf/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0beba9333754ead8febc5101fc5c35f7dcdfaadf/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs?ref=0beba9333754ead8febc5101fc5c35f7dcdfaadf", "patch": "@@ -642,7 +642,7 @@ pub type InlineAsmDiagHandler = unsafe extern \"C\" fn(&SMDiagnostic, *const c_voi\n pub mod coverageinfo {\n     use super::coverage_map;\n \n-    /// Aligns with [llvm::coverage::CounterMappingRegion::RegionKind](https://github.com/rust-lang/llvm-project/blob/rustc/10.0-2020-05-05/llvm/include/llvm/ProfileData/Coverage/CoverageMapping.h#L205-L221)\n+    /// Aligns with [llvm::coverage::CounterMappingRegion::RegionKind](https://github.com/rust-lang/llvm-project/blob/rustc/11.0-2020-10-12/llvm/include/llvm/ProfileData/Coverage/CoverageMapping.h#L206-L222)\n     #[derive(Copy, Clone, Debug)]\n     #[repr(C)]\n     pub enum RegionKind {\n@@ -665,13 +665,13 @@ pub mod coverageinfo {\n \n     /// This struct provides LLVM's representation of a \"CoverageMappingRegion\", encoded into the\n     /// coverage map, in accordance with the\n-    /// [LLVM Code Coverage Mapping Format](https://github.com/rust-lang/llvm-project/blob/llvmorg-8.0.0/llvm/docs/CoverageMappingFormat.rst#llvm-code-coverage-mapping-format).\n+    /// [LLVM Code Coverage Mapping Format](https://github.com/rust-lang/llvm-project/blob/rustc/11.0-2020-10-12/llvm/docs/CoverageMappingFormat.rst#llvm-code-coverage-mapping-format).\n     /// The struct composes fields representing the `Counter` type and value(s) (injected counter\n     /// ID, or expression type and operands), the source file (an indirect index into a \"filenames\n     /// array\", encoded separately), and source location (start and end positions of the represented\n     /// code region).\n     ///\n-    /// Aligns with [llvm::coverage::CounterMappingRegion](https://github.com/rust-lang/llvm-project/blob/rustc/10.0-2020-05-05/llvm/include/llvm/ProfileData/Coverage/CoverageMapping.h#L223-L226)\n+    /// Aligns with [llvm::coverage::CounterMappingRegion](https://github.com/rust-lang/llvm-project/blob/rustc/11.0-2020-10-12/llvm/include/llvm/ProfileData/Coverage/CoverageMapping.h#L224-L227)\n     /// Important: The Rust struct layout (order and types of fields) must match its C++\n     /// counterpart.\n     #[derive(Copy, Clone, Debug)]\n@@ -1791,10 +1791,14 @@ extern \"C\" {\n \n     pub fn LLVMRustCoverageCreatePGOFuncNameVar(F: &'a Value, FuncName: *const c_char)\n     -> &'a Value;\n-    pub fn LLVMRustCoverageComputeHash(Name: *const c_char) -> u64;\n+    pub fn LLVMRustCoverageHashCString(StrVal: *const c_char) -> u64;\n+    pub fn LLVMRustCoverageHashByteArray(Bytes: *const c_char, NumBytes: size_t) -> u64;\n \n     #[allow(improper_ctypes)]\n-    pub fn LLVMRustCoverageWriteSectionNameToString(M: &Module, Str: &RustString);\n+    pub fn LLVMRustCoverageWriteMapSectionNameToString(M: &Module, Str: &RustString);\n+\n+    #[allow(improper_ctypes)]\n+    pub fn LLVMRustCoverageWriteFuncSectionNameToString(M: &Module, Str: &RustString);\n \n     #[allow(improper_ctypes)]\n     pub fn LLVMRustCoverageWriteMappingVarNameToString(Str: &RustString);"}, {"sha": "fc40065a9664ea1c84e8917dea7da1fcfab1ca33", "filename": "compiler/rustc_codegen_llvm/src/llvm/mod.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0beba9333754ead8febc5101fc5c35f7dcdfaadf/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0beba9333754ead8febc5101fc5c35f7dcdfaadf/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fmod.rs?ref=0beba9333754ead8febc5101fc5c35f7dcdfaadf", "patch": "@@ -220,12 +220,24 @@ pub fn set_linkage(llglobal: &Value, linkage: Linkage) {\n     }\n }\n \n+pub fn set_visibility(llglobal: &Value, visibility: Visibility) {\n+    unsafe {\n+        LLVMRustSetVisibility(llglobal, visibility);\n+    }\n+}\n+\n pub fn set_alignment(llglobal: &Value, bytes: usize) {\n     unsafe {\n         ffi::LLVMSetAlignment(llglobal, bytes as c_uint);\n     }\n }\n \n+pub fn set_comdat(llmod: &Module, llglobal: &Value, name: &str) {\n+    unsafe {\n+        LLVMRustSetComdat(llmod, llglobal, name.as_ptr().cast(), name.len());\n+    }\n+}\n+\n /// Safe wrapper around `LLVMGetParam`, because segfaults are no fun.\n pub fn get_param(llfn: &Value, index: c_uint) -> &Value {\n     unsafe {"}, {"sha": "af6c476292bd18c3af54e50abd6c512164882260", "filename": "compiler/rustc_codegen_ssa/src/coverageinfo/ffi.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0beba9333754ead8febc5101fc5c35f7dcdfaadf/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcoverageinfo%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0beba9333754ead8febc5101fc5c35f7dcdfaadf/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcoverageinfo%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcoverageinfo%2Fffi.rs?ref=0beba9333754ead8febc5101fc5c35f7dcdfaadf", "patch": "@@ -1,6 +1,6 @@\n use rustc_middle::mir::coverage::{CounterValueReference, MappedExpressionIndex};\n \n-/// Aligns with [llvm::coverage::Counter::CounterKind](https://github.com/rust-lang/llvm-project/blob/rustc/10.0-2020-05-05/llvm/include/llvm/ProfileData/Coverage/CoverageMapping.h#L91)\n+/// Aligns with [llvm::coverage::Counter::CounterKind](https://github.com/rust-lang/llvm-project/blob/rustc/11.0-2020-10-12/llvm/include/llvm/ProfileData/Coverage/CoverageMapping.h#L206-L222)\n #[derive(Copy, Clone, Debug)]\n #[repr(C)]\n pub enum CounterKind {\n@@ -17,7 +17,7 @@ pub enum CounterKind {\n ///     `instrprof.increment()`)\n ///   * For `CounterKind::Expression`, `id` is the index into the coverage map's array of\n ///     counter expressions.\n-/// Aligns with [llvm::coverage::Counter](https://github.com/rust-lang/llvm-project/blob/rustc/10.0-2020-05-05/llvm/include/llvm/ProfileData/Coverage/CoverageMapping.h#L98-L99)\n+/// Aligns with [llvm::coverage::Counter](https://github.com/rust-lang/llvm-project/blob/rustc/11.0-2020-10-12/llvm/include/llvm/ProfileData/Coverage/CoverageMapping.h#L99-L100)\n /// Important: The Rust struct layout (order and types of fields) must match its C++ counterpart.\n #[derive(Copy, Clone, Debug)]\n #[repr(C)]\n@@ -41,15 +41,15 @@ impl Counter {\n     }\n }\n \n-/// Aligns with [llvm::coverage::CounterExpression::ExprKind](https://github.com/rust-lang/llvm-project/blob/rustc/10.0-2020-05-05/llvm/include/llvm/ProfileData/Coverage/CoverageMapping.h#L146)\n+/// Aligns with [llvm::coverage::CounterExpression::ExprKind](https://github.com/rust-lang/llvm-project/blob/rustc/11.0-2020-10-12/llvm/include/llvm/ProfileData/Coverage/CoverageMapping.h#L147)\n #[derive(Copy, Clone, Debug)]\n #[repr(C)]\n pub enum ExprKind {\n     Subtract = 0,\n     Add = 1,\n }\n \n-/// Aligns with [llvm::coverage::CounterExpression](https://github.com/rust-lang/llvm-project/blob/rustc/10.0-2020-05-05/llvm/include/llvm/ProfileData/Coverage/CoverageMapping.h#L147-L148)\n+/// Aligns with [llvm::coverage::CounterExpression](https://github.com/rust-lang/llvm-project/blob/rustc/11.0-2020-10-12/llvm/include/llvm/ProfileData/Coverage/CoverageMapping.h#L148-L149)\n /// Important: The Rust struct layout (order and types of fields) must match its C++\n /// counterpart.\n #[derive(Copy, Clone, Debug)]"}, {"sha": "373f0a602c0ef74ba6f0b11a0a91f5e8e1b26d14", "filename": "compiler/rustc_infer/src/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 27, "deletions": 5, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/0beba9333754ead8febc5101fc5c35f7dcdfaadf/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0beba9333754ead8febc5101fc5c35f7dcdfaadf/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=0beba9333754ead8febc5101fc5c35f7dcdfaadf", "patch": "@@ -124,6 +124,11 @@ impl<'a, 'tcx> Visitor<'tcx> for FindHirNodeVisitor<'a, 'tcx> {\n                 return;\n             }\n         }\n+\n+        // FIXME(const_generics): Currently, any uninferred `const` generics arguments\n+        // are handled specially, but instead they should be handled in `annotate_method_call`,\n+        // which currently doesn't work because this evaluates to `false` for const arguments.\n+        // See https://github.com/rust-lang/rust/pull/77758 for more details.\n         if self.node_ty_contains_target(expr.hir_id).is_some() {\n             match expr.kind {\n                 ExprKind::Closure(..) => self.found_closure = Some(&expr),\n@@ -345,11 +350,6 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     ) -> DiagnosticBuilder<'tcx> {\n         let arg = self.resolve_vars_if_possible(arg);\n         let arg_data = self.extract_inference_diagnostics_data(arg, None);\n-        let kind_str = match arg.unpack() {\n-            GenericArgKind::Type(_) => \"type\",\n-            GenericArgKind::Const(_) => \"the value\",\n-            GenericArgKind::Lifetime(_) => bug!(\"unexpected lifetime\"),\n-        };\n \n         let mut local_visitor = FindHirNodeVisitor::new(&self, arg, span);\n         let ty_to_string = |ty: Ty<'tcx>| -> String {\n@@ -618,6 +618,28 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             .any(|span_label| span_label.label.is_some() && span_label.span == span)\n             && local_visitor.found_arg_pattern.is_none()\n         {\n+            let (kind_str, const_value) = match arg.unpack() {\n+                GenericArgKind::Type(_) => (\"type\", None),\n+                GenericArgKind::Const(_) => (\"the value\", Some(())),\n+                GenericArgKind::Lifetime(_) => bug!(\"unexpected lifetime\"),\n+            };\n+\n+            // FIXME(const_generics): we would like to handle const arguments\n+            // as part of the normal diagnostics flow below, but there appear to\n+            // be subtleties in doing so, so for now we special-case const args\n+            // here.\n+            if let Some(suggestion) = const_value\n+                .and_then(|_| arg_data.parent_name.as_ref())\n+                .map(|parent| format!(\"{}::<{}>\", parent, arg_data.name))\n+            {\n+                err.span_suggestion_verbose(\n+                    span,\n+                    \"consider specifying the const argument\",\n+                    suggestion,\n+                    Applicability::MaybeIncorrect,\n+                );\n+            }\n+\n             // Avoid multiple labels pointing at `span`.\n             err.span_label(\n                 span,"}, {"sha": "b43cbf46d61e390f3741d88e91ed0fe2a2301f78", "filename": "compiler/rustc_interface/src/util.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0beba9333754ead8febc5101fc5c35f7dcdfaadf/compiler%2Frustc_interface%2Fsrc%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0beba9333754ead8febc5101fc5c35f7dcdfaadf/compiler%2Frustc_interface%2Fsrc%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Futil.rs?ref=0beba9333754ead8febc5101fc5c35f7dcdfaadf", "patch": "@@ -1,6 +1,5 @@\n use rustc_ast::mut_visit::{visit_clobber, MutVisitor, *};\n use rustc_ast::ptr::P;\n-use rustc_ast::util::lev_distance::find_best_match_for_name;\n use rustc_ast::{self as ast, AttrVec, BlockCheckMode};\n use rustc_codegen_ssa::traits::CodegenBackend;\n use rustc_data_structures::fingerprint::Fingerprint;\n@@ -20,6 +19,7 @@ use rustc_session::parse::CrateConfig;\n use rustc_session::CrateDisambiguator;\n use rustc_session::{early_error, filesearch, output, DiagnosticOutput, Session};\n use rustc_span::edition::Edition;\n+use rustc_span::lev_distance::find_best_match_for_name;\n use rustc_span::source_map::FileLoader;\n use rustc_span::symbol::{sym, Symbol};\n use smallvec::SmallVec;\n@@ -512,8 +512,11 @@ pub(crate) fn check_attr_crate_type(\n \n                 if let ast::MetaItemKind::NameValue(spanned) = a.meta().unwrap().kind {\n                     let span = spanned.span;\n-                    let lev_candidate =\n-                        find_best_match_for_name(CRATE_TYPES.iter().map(|(k, _)| k), n, None);\n+                    let lev_candidate = find_best_match_for_name(\n+                        &CRATE_TYPES.iter().map(|(k, _)| *k).collect::<Vec<_>>(),\n+                        n,\n+                        None,\n+                    );\n                     if let Some(candidate) = lev_candidate {\n                         lint_buffer.buffer_lint_with_diagnostic(\n                             lint::builtin::UNKNOWN_CRATE_TYPES,"}, {"sha": "16563d21ff133b5940eb977daa52b16e1fb5e3df", "filename": "compiler/rustc_lint/src/context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0beba9333754ead8febc5101fc5c35f7dcdfaadf/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0beba9333754ead8febc5101fc5c35f7dcdfaadf/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs?ref=0beba9333754ead8febc5101fc5c35f7dcdfaadf", "patch": "@@ -19,7 +19,6 @@ use self::TargetLint::*;\n use crate::levels::LintLevelsBuilder;\n use crate::passes::{EarlyLintPassObject, LateLintPassObject};\n use rustc_ast as ast;\n-use rustc_ast::util::lev_distance::find_best_match_for_name;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync;\n use rustc_errors::{add_elided_lifetime_in_path_suggestion, struct_span_err, Applicability};\n@@ -37,6 +36,7 @@ use rustc_session::lint::BuiltinLintDiagnostics;\n use rustc_session::lint::{FutureIncompatibleInfo, Level, Lint, LintBuffer, LintId};\n use rustc_session::Session;\n use rustc_session::SessionLintStore;\n+use rustc_span::lev_distance::find_best_match_for_name;\n use rustc_span::{symbol::Symbol, MultiSpan, Span, DUMMY_SP};\n use rustc_target::abi::LayoutOf;\n \n@@ -411,7 +411,7 @@ impl LintStore {\n                         self.by_name.keys().map(|name| Symbol::intern(&name)).collect::<Vec<_>>();\n \n                     let suggestion = find_best_match_for_name(\n-                        symbols.iter(),\n+                        &symbols,\n                         Symbol::intern(&lint_name.to_lowercase()),\n                         None,\n                     );"}, {"sha": "25badc3f4e17bd96cc954d6f765e5cd8ecc48cf5", "filename": "compiler/rustc_llvm/llvm-wrapper/CoverageMappingWrapper.cpp", "status": "modified", "additions": 37, "deletions": 15, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/0beba9333754ead8febc5101fc5c35f7dcdfaadf/compiler%2Frustc_llvm%2Fllvm-wrapper%2FCoverageMappingWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/0beba9333754ead8febc5101fc5c35f7dcdfaadf/compiler%2Frustc_llvm%2Fllvm-wrapper%2FCoverageMappingWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2FCoverageMappingWrapper.cpp?ref=0beba9333754ead8febc5101fc5c35f7dcdfaadf", "patch": "@@ -3,7 +3,6 @@\n #include \"llvm/ProfileData/Coverage/CoverageMappingWriter.h\"\n #include \"llvm/ProfileData/InstrProf.h\"\n #include \"llvm/ADT/ArrayRef.h\"\n-#include \"llvm/Support/LEB128.h\"\n \n #include <iostream>\n \n@@ -13,15 +12,14 @@ extern \"C\" void LLVMRustCoverageWriteFilenamesSectionToBuffer(\n     const char* const Filenames[],\n     size_t FilenamesLen,\n     RustStringRef BufferOut) {\n-  // LLVM 11's CoverageFilenamesSectionWriter uses its new `Version4` format,\n-  // so we're manually writing the `Version3` format ourselves.\n-  RawRustStringOstream OS(BufferOut);\n-  encodeULEB128(FilenamesLen, OS);\n+  SmallVector<StringRef,32> FilenameRefs;\n   for (size_t i = 0; i < FilenamesLen; i++) {\n-    StringRef Filename(Filenames[i]);\n-    encodeULEB128(Filename.size(), OS);\n-    OS << Filename;\n+    FilenameRefs.push_back(StringRef(Filenames[i]));\n   }\n+  auto FilenamesWriter = coverage::CoverageFilenamesSectionWriter(\n+    makeArrayRef(FilenameRefs));\n+  RawRustStringOstream OS(BufferOut);\n+  FilenamesWriter.write(OS);\n }\n \n extern \"C\" void LLVMRustCoverageWriteMappingToBuffer(\n@@ -45,26 +43,50 @@ extern \"C\" LLVMValueRef LLVMRustCoverageCreatePGOFuncNameVar(LLVMValueRef F, con\n   return wrap(createPGOFuncNameVar(*cast<Function>(unwrap(F)), FuncNameRef));\n }\n \n-extern \"C\" uint64_t LLVMRustCoverageComputeHash(const char *Name) {\n-  StringRef NameRef(Name);\n-  return IndexedInstrProf::ComputeHash(NameRef);\n+extern \"C\" uint64_t LLVMRustCoverageHashCString(const char *StrVal) {\n+  StringRef StrRef(StrVal);\n+  return IndexedInstrProf::ComputeHash(StrRef);\n+}\n+\n+extern \"C\" uint64_t LLVMRustCoverageHashByteArray(\n+    const char *Bytes,\n+    unsigned NumBytes) {\n+  StringRef StrRef(Bytes, NumBytes);\n+  return IndexedInstrProf::ComputeHash(StrRef);\n }\n \n-extern \"C\" void LLVMRustCoverageWriteSectionNameToString(LLVMModuleRef M,\n-                                                         RustStringRef Str) {\n+static void WriteSectionNameToString(LLVMModuleRef M,\n+                                     InstrProfSectKind SK,\n+                                     RustStringRef Str) {\n   Triple TargetTriple(unwrap(M)->getTargetTriple());\n-  auto name = getInstrProfSectionName(IPSK_covmap,\n-                                      TargetTriple.getObjectFormat());\n+  auto name = getInstrProfSectionName(SK, TargetTriple.getObjectFormat());\n   RawRustStringOstream OS(Str);\n   OS << name;\n }\n \n+extern \"C\" void LLVMRustCoverageWriteMapSectionNameToString(LLVMModuleRef M,\n+                                                            RustStringRef Str) {\n+  WriteSectionNameToString(M, IPSK_covmap, Str);\n+}\n+\n+extern \"C\" void LLVMRustCoverageWriteFuncSectionNameToString(LLVMModuleRef M,\n+                                                             RustStringRef Str) {\n+#if LLVM_VERSION_GE(11, 0)\n+  WriteSectionNameToString(M, IPSK_covfun, Str);\n+// else do nothing; the `Version` check will abort codegen on the Rust side\n+#endif\n+}\n+\n extern \"C\" void LLVMRustCoverageWriteMappingVarNameToString(RustStringRef Str) {\n   auto name = getCoverageMappingVarName();\n   RawRustStringOstream OS(Str);\n   OS << name;\n }\n \n extern \"C\" uint32_t LLVMRustCoverageMappingVersion() {\n+#if LLVM_VERSION_GE(11, 0)\n+  return coverage::CovMapVersion::Version4;\n+#else\n   return coverage::CovMapVersion::Version3;\n+#endif\n }"}, {"sha": "e17f933932e6a0649265ff6276619990aea15426", "filename": "compiler/rustc_llvm/llvm-wrapper/RustWrapper.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0beba9333754ead8febc5101fc5c35f7dcdfaadf/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/0beba9333754ead8febc5101fc5c35f7dcdfaadf/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp?ref=0beba9333754ead8febc5101fc5c35f7dcdfaadf", "patch": "@@ -1462,7 +1462,7 @@ extern \"C\" void LLVMRustSetComdat(LLVMModuleRef M, LLVMValueRef V,\n                                   const char *Name, size_t NameLen) {\n   Triple TargetTriple(unwrap(M)->getTargetTriple());\n   GlobalObject *GV = unwrap<GlobalObject>(V);\n-  if (!TargetTriple.isOSBinFormatMachO()) {\n+  if (TargetTriple.supportsCOMDAT()) {\n     StringRef NameRef(Name, NameLen);\n     GV->setComdat(unwrap(M)->getOrInsertComdat(NameRef));\n   }"}, {"sha": "8a6bf9dff7b6fb2ecb84464d239831b1a41aea34", "filename": "compiler/rustc_middle/src/mir/coverage.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0beba9333754ead8febc5101fc5c35f7dcdfaadf/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fcoverage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0beba9333754ead8febc5101fc5c35f7dcdfaadf/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fcoverage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fcoverage.rs?ref=0beba9333754ead8febc5101fc5c35f7dcdfaadf", "patch": "@@ -21,9 +21,9 @@ rustc_index::newtype_index! {\n impl ExpressionOperandId {\n     /// An expression operand for a \"zero counter\", as described in the following references:\n     ///\n-    /// * <https://github.com/rust-lang/llvm-project/blob/llvmorg-8.0.0/llvm/docs/CoverageMappingFormat.rst#counter>\n-    /// * <https://github.com/rust-lang/llvm-project/blob/llvmorg-8.0.0/llvm/docs/CoverageMappingFormat.rst#tag>\n-    /// * <https://github.com/rust-lang/llvm-project/blob/llvmorg-8.0.0/llvm/docs/CoverageMappingFormat.rst#counter-expressions>\n+    /// * <https://github.com/rust-lang/llvm-project/blob/rustc/11.0-2020-10-12/llvm/docs/CoverageMappingFormat.rst#counter>\n+    /// * <https://github.com/rust-lang/llvm-project/blob/rustc/11.0-2020-10-12/llvm/docs/CoverageMappingFormat.rst#tag>\n+    /// * <https://github.com/rust-lang/llvm-project/blob/rustc/11.0-2020-10-12/llvm/docs/CoverageMappingFormat.rst#counter-expressions>\n     ///\n     /// This operand can be used to count two or more separate code regions with a single counter,\n     /// if they run sequentially with no branches, by injecting the `Counter` in a `BasicBlock` for"}, {"sha": "d0730bd121c9815c68ccf3d9c4f1d8a06eb1ea89", "filename": "compiler/rustc_middle/src/ty/query/plumbing.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0beba9333754ead8febc5101fc5c35f7dcdfaadf/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0beba9333754ead8febc5101fc5c35f7dcdfaadf/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fplumbing.rs?ref=0beba9333754ead8febc5101fc5c35f7dcdfaadf", "patch": "@@ -128,7 +128,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     pub fn try_print_query_stack(handler: &Handler, num_frames: Option<usize>) {\n         eprintln!(\"query stack during panic:\");\n \n-        // Be careful reyling on global state here: this code is called from\n+        // Be careful relying on global state here: this code is called from\n         // a panic hook, which means that the global `Handler` may be in a weird\n         // state if it was responsible for triggering the panic.\n         let mut i = 0;\n@@ -507,7 +507,7 @@ macro_rules! define_queries_struct {\n     (tcx: $tcx:tt,\n      input: ($(([$($modifiers:tt)*] [$($attr:tt)*] [$name:ident]))*)) => {\n         pub struct Queries<$tcx> {\n-            /// This provides access to the incremental comilation on-disk cache for query results.\n+            /// This provides access to the incremental compilation on-disk cache for query results.\n             /// Do not access this directly. It is only meant to be used by\n             /// `DepGraph::try_mark_green()` and the query infrastructure.\n             /// This is `None` if we are not incremental compilation mode"}, {"sha": "e9528557b3337d9d2e96a41681fe29325e57f68c", "filename": "compiler/rustc_mir/src/transform/coverage/debug.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0beba9333754ead8febc5101fc5c35f7dcdfaadf/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0beba9333754ead8febc5101fc5c35f7dcdfaadf/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fdebug.rs?ref=0beba9333754ead8febc5101fc5c35f7dcdfaadf", "patch": "@@ -95,18 +95,18 @@\n //!\n //!     Depending on the values and combinations, counters can be labeled by:\n //!\n-//!         * `id` - counter or expression ID (ascending counter IDs, starting at 1, or descending\n-//!           expression IDs, starting at `u32:MAX`)\n-//!         * `block` - the `BasicCoverageBlock` label (for example, `bcb0`) or edge label (for\n-//!           example `bcb0->bcb1`), for counters or expressions assigned to count a\n-//!           `BasicCoverageBlock` or edge. Intermediate expressions (not directly associated with\n-//!           a BCB or edge) will be labeled by their expression ID, unless `operation` is also\n-//!           specified.\n-//!         * `operation` - applied to expressions only, labels include the left-hand-side counter\n-//!           or expression label (lhs operand), the operator (`+` or `-`), and the right-hand-side\n-//!           counter or expression (rhs operand). Expression operand labels are generated\n-//!           recursively, generating labels with nested operations, enclosed in parentheses\n-//!           (for example: `bcb2 + (bcb0 - bcb1)`).\n+//!       * `id` - counter or expression ID (ascending counter IDs, starting at 1, or descending\n+//!         expression IDs, starting at `u32:MAX`)\n+//!       * `block` - the `BasicCoverageBlock` label (for example, `bcb0`) or edge label (for\n+//!         example `bcb0->bcb1`), for counters or expressions assigned to count a\n+//!         `BasicCoverageBlock` or edge. Intermediate expressions (not directly associated with\n+//!         a BCB or edge) will be labeled by their expression ID, unless `operation` is also\n+//!         specified.\n+//!       * `operation` - applied to expressions only, labels include the left-hand-side counter\n+//!         or expression label (lhs operand), the operator (`+` or `-`), and the right-hand-side\n+//!         counter or expression (rhs operand). Expression operand labels are generated\n+//!         recursively, generating labels with nested operations, enclosed in parentheses\n+//!         (for example: `bcb2 + (bcb0 - bcb1)`).\n \n use super::graph::{BasicCoverageBlock, BasicCoverageBlockData, CoverageGraph};\n use super::spans::CoverageSpan;"}, {"sha": "f299663f6793404cc6260fc0d9a76380e678b75d", "filename": "compiler/rustc_mir_build/src/thir/pattern/_match.rs", "status": "modified", "additions": 31, "deletions": 22, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/0beba9333754ead8febc5101fc5c35f7dcdfaadf/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0beba9333754ead8febc5101fc5c35f7dcdfaadf/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2F_match.rs?ref=0beba9333754ead8febc5101fc5c35f7dcdfaadf", "patch": "@@ -1,21 +1,25 @@\n //! Note: tests specific to this file can be found in:\n-//!     - ui/pattern/usefulness\n-//!     - ui/or-patterns\n-//!     - ui/consts/const_in_pattern\n-//!     - ui/rfc-2008-non-exhaustive\n-//!     - ui/half-open-range-patterns\n-//!     - probably many others\n+//!\n+//!   - `ui/pattern/usefulness`\n+//!   - `ui/or-patterns`\n+//!   - `ui/consts/const_in_pattern`\n+//!   - `ui/rfc-2008-non-exhaustive`\n+//!   - `ui/half-open-range-patterns`\n+//!   - probably many others\n+//!\n //! I (Nadrieril) prefer to put new tests in `ui/pattern/usefulness` unless there's a specific\n-//! reason not to, for example if they depend on a particular feature like or_patterns.\n+//! reason not to, for example if they depend on a particular feature like `or_patterns`.\n+//!\n+//! -----\n //!\n //! This file includes the logic for exhaustiveness and usefulness checking for\n //! pattern-matching. Specifically, given a list of patterns for a type, we can\n //! tell whether:\n //! (a) the patterns cover every possible constructor for the type (exhaustiveness)\n //! (b) each pattern is necessary (usefulness)\n //!\n-//! The algorithm implemented here is a modified version of the one described in:\n-//! <http://moscova.inria.fr/~maranget/papers/warn/index.html>\n+//! The algorithm implemented here is a modified version of the one described in\n+//! [this paper](http://moscova.inria.fr/~maranget/papers/warn/index.html).\n //! However, to save future implementors from reading the original paper, we\n //! summarise the algorithm here to hopefully save time and be a little clearer\n //! (without being so rigorous).\n@@ -131,18 +135,22 @@\n //!\n //!    This returns zero or more new pattern-stacks, as follows. We look at the pattern `p_1`\n //!    on top of the stack, and we have four cases:\n-//!         1.1. `p_1 = c(r_1, .., r_a)`, i.e. the top of the stack has constructor `c`. We\n-//!              push onto the stack the arguments of this constructor, and return the result:\n-//!                 r_1, .., r_a, p_2, .., p_n\n-//!         1.2. `p_1 = c'(r_1, .., r_a')` where `c \u2260 c'`. We discard the current stack and\n-//!              return nothing.\n+//!\n+//!      1.1. `p_1 = c(r_1, .., r_a)`, i.e. the top of the stack has constructor `c`. We\n+//!           push onto the stack the arguments of this constructor, and return the result:\n+//!              `r_1, .., r_a, p_2, .., p_n`\n+//!\n+//!      1.2. `p_1 = c'(r_1, .., r_a')` where `c \u2260 c'`. We discard the current stack and\n+//!           return nothing.\n+//!\n //!         1.3. `p_1 = _`. We push onto the stack as many wildcards as the constructor `c` has\n //!              arguments (its arity), and return the resulting stack:\n-//!                 _, .., _, p_2, .., p_n\n+//!                 `_, .., _, p_2, .., p_n`\n+//!\n //!         1.4. `p_1 = r_1 | r_2`. We expand the OR-pattern and then recurse on each resulting\n //!              stack:\n-//!                 S(c, (r_1, p_2, .., p_n))\n-//!                 S(c, (r_2, p_2, .., p_n))\n+//!                 - `S(c, (r_1, p_2, .., p_n))`\n+//!                 - `S(c, (r_2, p_2, .., p_n))`\n //!\n //! 2. We can pop a wildcard off the top of the stack. This is called `S(_, p)`, where `p` is\n //!    a pattern-stack. Note: the paper calls this `D(p)`.\n@@ -157,8 +165,8 @@\n //!                 p_2, .., p_n\n //!         2.3. `p_1 = r_1 | r_2`. We expand the OR-pattern and then recurse on each resulting\n //!           stack.\n-//!                 S(_, (r_1, p_2, .., p_n))\n-//!                 S(_, (r_2, p_2, .., p_n))\n+//!                 - `S(_, (r_1, p_2, .., p_n))`\n+//!                 - `S(_, (r_2, p_2, .., p_n))`\n //!\n //! Note that the OR-patterns are not always used directly in Rust, but are used to derive the\n //! exhaustive integer matching rules, so they're written here for posterity.\n@@ -198,7 +206,7 @@\n //! ]\n //! ```\n //!\n-//! and `p` is [Some(false), 0], then we don't care about row 2 since we know `p` only\n+//! and `p` is `[Some(false), 0]`, then we don't care about row 2 since we know `p` only\n //! matches values that row 2 doesn't. For row 1 however, we need to dig into the\n //! arguments of `Some` to know whether some new value is covered. So we compute\n //! `U([[true, _]], [false, 0])`.\n@@ -222,7 +230,7 @@\n //! ]\n //! ```\n //!\n-//! and `p` is [_, false, _], the `Some` constructor doesn't appear in `P`. So if we\n+//! and `p` is `[_, false, _]`, the `Some` constructor doesn't appear in `P`. So if we\n //! only had row 2, we'd know that `p` is useful. However row 1 starts with a\n //! wildcard, so we need to check whether `U([[true, _]], [false, 1])`.\n //!\n@@ -243,7 +251,7 @@\n //! ]\n //! ```\n //!\n-//! and `p` is [_, false], both `None` and `Some` constructors appear in the first\n+//! and `p` is `[_, false]`, both `None` and `Some` constructors appear in the first\n //! components of `P`. We will therefore try popping both constructors in turn: we\n //! compute `U([[true, _]], [_, false])` for the `Some` constructor, and `U([[false]],\n //! [false])` for the `None` constructor. The first case returns true, so we know that\n@@ -294,6 +302,7 @@\n //!     + If some constructors are missing from the matrix, it turns out we don't need to do\n //!       anything special (because we know none of the integers are actually wildcards: i.e., we\n //!       can't span wildcards using ranges).\n+\n use self::Constructor::*;\n use self::SliceKind::*;\n use self::Usefulness::*;"}, {"sha": "809de9beff625a7b8fd8cb1f605e6f33eceade89", "filename": "compiler/rustc_resolve/src/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0beba9333754ead8febc5101fc5c35f7dcdfaadf/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0beba9333754ead8febc5101fc5c35f7dcdfaadf/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs?ref=0beba9333754ead8febc5101fc5c35f7dcdfaadf", "patch": "@@ -1,7 +1,6 @@\n use std::cmp::Reverse;\n use std::ptr;\n \n-use rustc_ast::util::lev_distance::find_best_match_for_name;\n use rustc_ast::{self as ast, Path};\n use rustc_ast_pretty::pprust;\n use rustc_data_structures::fx::FxHashSet;\n@@ -14,6 +13,7 @@ use rustc_middle::bug;\n use rustc_middle::ty::{self, DefIdTree};\n use rustc_session::Session;\n use rustc_span::hygiene::MacroKind;\n+use rustc_span::lev_distance::find_best_match_for_name;\n use rustc_span::source_map::SourceMap;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{BytePos, MultiSpan, Span};\n@@ -716,7 +716,7 @@ impl<'a> Resolver<'a> {\n         suggestions.sort_by_cached_key(|suggestion| suggestion.candidate.as_str());\n \n         match find_best_match_for_name(\n-            suggestions.iter().map(|suggestion| &suggestion.candidate),\n+            &suggestions.iter().map(|suggestion| suggestion.candidate).collect::<Vec<Symbol>>(),\n             ident.name,\n             None,\n         ) {"}, {"sha": "cb1f0834ce7acd3d763f6f6d3b10a17a39a12330", "filename": "compiler/rustc_resolve/src/imports.rs", "status": "modified", "additions": 26, "deletions": 22, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/0beba9333754ead8febc5101fc5c35f7dcdfaadf/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0beba9333754ead8febc5101fc5c35f7dcdfaadf/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs?ref=0beba9333754ead8febc5101fc5c35f7dcdfaadf", "patch": "@@ -10,7 +10,6 @@ use crate::{CrateLint, Module, ModuleOrUniformRoot, ParentScope, PerNS, ScopeSet\n use crate::{NameBinding, NameBindingKind, PathResult, PrivacyError, ToNameBinding};\n \n use rustc_ast::unwrap_or;\n-use rustc_ast::util::lev_distance::find_best_match_for_name;\n use rustc_ast::NodeId;\n use rustc_ast_lowering::ResolverAstLowering;\n use rustc_data_structures::fx::FxHashSet;\n@@ -25,6 +24,7 @@ use rustc_session::lint::builtin::{PUB_USE_OF_PRIVATE_EXTERN_CRATE, UNUSED_IMPOR\n use rustc_session::lint::BuiltinLintDiagnostics;\n use rustc_session::DiagnosticMessageId;\n use rustc_span::hygiene::ExpnId;\n+use rustc_span::lev_distance::find_best_match_for_name;\n use rustc_span::symbol::{kw, Ident, Symbol};\n use rustc_span::{MultiSpan, Span};\n \n@@ -1096,33 +1096,37 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                     _ => None,\n                 };\n                 let resolutions = resolutions.as_ref().into_iter().flat_map(|r| r.iter());\n-                let names = resolutions.filter_map(|(BindingKey { ident: i, .. }, resolution)| {\n-                    if *i == ident {\n-                        return None;\n-                    } // Never suggest the same name\n-                    match *resolution.borrow() {\n-                        NameResolution { binding: Some(name_binding), .. } => {\n-                            match name_binding.kind {\n-                                NameBindingKind::Import { binding, .. } => {\n-                                    match binding.kind {\n-                                        // Never suggest the name that has binding error\n-                                        // i.e., the name that cannot be previously resolved\n-                                        NameBindingKind::Res(Res::Err, _) => None,\n-                                        _ => Some(&i.name),\n+                let names = resolutions\n+                    .filter_map(|(BindingKey { ident: i, .. }, resolution)| {\n+                        if *i == ident {\n+                            return None;\n+                        } // Never suggest the same name\n+                        match *resolution.borrow() {\n+                            NameResolution { binding: Some(name_binding), .. } => {\n+                                match name_binding.kind {\n+                                    NameBindingKind::Import { binding, .. } => {\n+                                        match binding.kind {\n+                                            // Never suggest the name that has binding error\n+                                            // i.e., the name that cannot be previously resolved\n+                                            NameBindingKind::Res(Res::Err, _) => None,\n+                                            _ => Some(i.name),\n+                                        }\n                                     }\n+                                    _ => Some(i.name),\n                                 }\n-                                _ => Some(&i.name),\n                             }\n+                            NameResolution { ref single_imports, .. }\n+                                if single_imports.is_empty() =>\n+                            {\n+                                None\n+                            }\n+                            _ => Some(i.name),\n                         }\n-                        NameResolution { ref single_imports, .. } if single_imports.is_empty() => {\n-                            None\n-                        }\n-                        _ => Some(&i.name),\n-                    }\n-                });\n+                    })\n+                    .collect::<Vec<Symbol>>();\n \n                 let lev_suggestion =\n-                    find_best_match_for_name(names, ident.name, None).map(|suggestion| {\n+                    find_best_match_for_name(&names, ident.name, None).map(|suggestion| {\n                         (\n                             vec![(ident.span, suggestion.to_string())],\n                             String::from(\"a similar name exists in the module\"),"}, {"sha": "6ce299a94170841f3f9a3be29d8f0cefdf999c13", "filename": "compiler/rustc_resolve/src/late/diagnostics.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0beba9333754ead8febc5101fc5c35f7dcdfaadf/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0beba9333754ead8febc5101fc5c35f7dcdfaadf/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs?ref=0beba9333754ead8febc5101fc5c35f7dcdfaadf", "patch": "@@ -5,7 +5,6 @@ use crate::path_names_to_string;\n use crate::{CrateLint, Module, ModuleKind, ModuleOrUniformRoot};\n use crate::{PathResult, PathSource, Segment};\n \n-use rustc_ast::util::lev_distance::find_best_match_for_name;\n use rustc_ast::visit::FnKind;\n use rustc_ast::{self as ast, Expr, ExprKind, Item, ItemKind, NodeId, Path, Ty, TyKind};\n use rustc_ast_pretty::pprust::path_segment_to_string;\n@@ -18,6 +17,7 @@ use rustc_hir::def_id::{DefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n use rustc_hir::PrimTy;\n use rustc_session::parse::feature_err;\n use rustc_span::hygiene::MacroKind;\n+use rustc_span::lev_distance::find_best_match_for_name;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{BytePos, MultiSpan, Span, DUMMY_SP};\n \n@@ -1206,7 +1206,7 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n         names.sort_by_cached_key(|suggestion| suggestion.candidate.as_str());\n \n         match find_best_match_for_name(\n-            names.iter().map(|suggestion| &suggestion.candidate),\n+            &names.iter().map(|suggestion| suggestion.candidate).collect::<Vec<Symbol>>(),\n             name,\n             None,\n         ) {\n@@ -1592,9 +1592,10 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n             .bindings\n             .iter()\n             .filter(|(id, _)| id.span.ctxt() == label.span.ctxt())\n-            .map(|(id, _)| &id.name);\n+            .map(|(id, _)| id.name)\n+            .collect::<Vec<Symbol>>();\n \n-        find_best_match_for_name(names, label.name, None).map(|symbol| {\n+        find_best_match_for_name(&names, label.name, None).map(|symbol| {\n             // Upon finding a similar name, get the ident that it was from - the span\n             // contained within helps make a useful diagnostic. In addition, determine\n             // whether this candidate is within scope."}, {"sha": "edc6625a6ead7a94fcac4da8c5bb54f52e726e52", "filename": "compiler/rustc_span/src/lev_distance.rs", "status": "renamed", "additions": 9, "deletions": 14, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/0beba9333754ead8febc5101fc5c35f7dcdfaadf/compiler%2Frustc_span%2Fsrc%2Flev_distance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0beba9333754ead8febc5101fc5c35f7dcdfaadf/compiler%2Frustc_span%2Fsrc%2Flev_distance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Flev_distance.rs?ref=0beba9333754ead8febc5101fc5c35f7dcdfaadf", "patch": "@@ -1,6 +1,4 @@\n-// FIXME(Centril): Move to rustc_span?\n-\n-use rustc_span::symbol::Symbol;\n+use crate::symbol::Symbol;\n use std::cmp;\n \n #[cfg(test)]\n@@ -45,17 +43,14 @@ pub fn lev_distance(a: &str, b: &str) -> usize {\n ///\n /// Besides Levenshtein, we use case insensitive comparison to improve accuracy on an edge case with\n /// a lower(upper)case letters mismatch.\n-pub fn find_best_match_for_name<'a, T>(\n-    iter_names: T,\n+#[cold]\n+pub fn find_best_match_for_name(\n+    name_vec: &[Symbol],\n     lookup: Symbol,\n     dist: Option<usize>,\n-) -> Option<Symbol>\n-where\n-    T: Iterator<Item = &'a Symbol>,\n-{\n+) -> Option<Symbol> {\n     let lookup = &lookup.as_str();\n     let max_dist = dist.unwrap_or_else(|| cmp::max(lookup.len(), 3) / 3);\n-    let name_vec: Vec<&Symbol> = iter_names.collect();\n \n     let (case_insensitive_match, levenshtein_match) = name_vec\n         .iter()\n@@ -83,18 +78,18 @@ where\n     // 2. Levenshtein distance match\n     // 3. Sorted word match\n     if let Some(candidate) = case_insensitive_match {\n-        Some(*candidate)\n+        Some(candidate)\n     } else if levenshtein_match.is_some() {\n-        levenshtein_match.map(|(candidate, _)| *candidate)\n+        levenshtein_match.map(|(candidate, _)| candidate)\n     } else {\n         find_match_by_sorted_words(name_vec, lookup)\n     }\n }\n \n-fn find_match_by_sorted_words<'a>(iter_names: Vec<&'a Symbol>, lookup: &str) -> Option<Symbol> {\n+fn find_match_by_sorted_words(iter_names: &[Symbol], lookup: &str) -> Option<Symbol> {\n     iter_names.iter().fold(None, |result, candidate| {\n         if sort_by_words(&candidate.as_str()) == sort_by_words(lookup) {\n-            Some(**candidate)\n+            Some(*candidate)\n         } else {\n             result\n         }", "previous_filename": "compiler/rustc_ast/src/util/lev_distance.rs"}, {"sha": "7aa01cb8efe7e478abdf26fa06825c9413be3f1d", "filename": "compiler/rustc_span/src/lev_distance/tests.rs", "status": "renamed", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/0beba9333754ead8febc5101fc5c35f7dcdfaadf/compiler%2Frustc_span%2Fsrc%2Flev_distance%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0beba9333754ead8febc5101fc5c35f7dcdfaadf/compiler%2Frustc_span%2Fsrc%2Flev_distance%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Flev_distance%2Ftests.rs?ref=0beba9333754ead8febc5101fc5c35f7dcdfaadf", "patch": "@@ -21,38 +21,35 @@ fn test_lev_distance() {\n \n #[test]\n fn test_find_best_match_for_name() {\n-    use rustc_span::with_default_session_globals;\n+    use crate::with_default_session_globals;\n     with_default_session_globals(|| {\n         let input = vec![Symbol::intern(\"aaab\"), Symbol::intern(\"aaabc\")];\n         assert_eq!(\n-            find_best_match_for_name(input.iter(), Symbol::intern(\"aaaa\"), None),\n+            find_best_match_for_name(&input, Symbol::intern(\"aaaa\"), None),\n             Some(Symbol::intern(\"aaab\"))\n         );\n \n-        assert_eq!(\n-            find_best_match_for_name(input.iter(), Symbol::intern(\"1111111111\"), None),\n-            None\n-        );\n+        assert_eq!(find_best_match_for_name(&input, Symbol::intern(\"1111111111\"), None), None);\n \n         let input = vec![Symbol::intern(\"aAAA\")];\n         assert_eq!(\n-            find_best_match_for_name(input.iter(), Symbol::intern(\"AAAA\"), None),\n+            find_best_match_for_name(&input, Symbol::intern(\"AAAA\"), None),\n             Some(Symbol::intern(\"aAAA\"))\n         );\n \n         let input = vec![Symbol::intern(\"AAAA\")];\n         // Returns None because `lev_distance > max_dist / 3`\n-        assert_eq!(find_best_match_for_name(input.iter(), Symbol::intern(\"aaaa\"), None), None);\n+        assert_eq!(find_best_match_for_name(&input, Symbol::intern(\"aaaa\"), None), None);\n \n         let input = vec![Symbol::intern(\"AAAA\")];\n         assert_eq!(\n-            find_best_match_for_name(input.iter(), Symbol::intern(\"aaaa\"), Some(4)),\n+            find_best_match_for_name(&input, Symbol::intern(\"aaaa\"), Some(4)),\n             Some(Symbol::intern(\"AAAA\"))\n         );\n \n         let input = vec![Symbol::intern(\"a_longer_variable_name\")];\n         assert_eq!(\n-            find_best_match_for_name(input.iter(), Symbol::intern(\"a_variable_longer_name\"), None),\n+            find_best_match_for_name(&input, Symbol::intern(\"a_variable_longer_name\"), None),\n             Some(Symbol::intern(\"a_longer_variable_name\"))\n         );\n     })", "previous_filename": "compiler/rustc_ast/src/util/lev_distance/tests.rs"}, {"sha": "11a49d1ab887daf91c8deb2fc64992f44816b1eb", "filename": "compiler/rustc_span/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0beba9333754ead8febc5101fc5c35f7dcdfaadf/compiler%2Frustc_span%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0beba9333754ead8febc5101fc5c35f7dcdfaadf/compiler%2Frustc_span%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Flib.rs?ref=0beba9333754ead8febc5101fc5c35f7dcdfaadf", "patch": "@@ -34,6 +34,7 @@ use hygiene::Transparency;\n pub use hygiene::{DesugaringKind, ExpnData, ExpnId, ExpnKind, ForLoopLoc, MacroKind};\n pub mod def_id;\n use def_id::{CrateNum, DefId, LOCAL_CRATE};\n+pub mod lev_distance;\n mod span_encoding;\n pub use span_encoding::{Span, DUMMY_SP};\n "}, {"sha": "b04acd9660d4572baa9747fa789ae9813d21e505", "filename": "compiler/rustc_typeck/src/astconv/errors.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0beba9333754ead8febc5101fc5c35f7dcdfaadf/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0beba9333754ead8febc5101fc5c35f7dcdfaadf/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Ferrors.rs?ref=0beba9333754ead8febc5101fc5c35f7dcdfaadf", "patch": "@@ -1,11 +1,11 @@\n use crate::astconv::AstConv;\n-use rustc_ast::util::lev_distance::find_best_match_for_name;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_errors::{pluralize, struct_span_err, Applicability};\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_middle::ty;\n use rustc_session::parse::feature_err;\n+use rustc_span::lev_distance::find_best_match_for_name;\n use rustc_span::symbol::{sym, Ident};\n use rustc_span::{Span, DUMMY_SP};\n \n@@ -180,7 +180,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             .collect();\n \n         if let (Some(suggested_name), true) = (\n-            find_best_match_for_name(all_candidate_names.iter(), assoc_name.name, None),\n+            find_best_match_for_name(&all_candidate_names, assoc_name.name, None),\n             assoc_name.span != DUMMY_SP,\n         ) {\n             err.span_suggestion("}, {"sha": "9b814f6b7ee66a371961d63e45695356f9e7acd8", "filename": "compiler/rustc_typeck/src/astconv/mod.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0beba9333754ead8febc5101fc5c35f7dcdfaadf/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0beba9333754ead8febc5101fc5c35f7dcdfaadf/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs?ref=0beba9333754ead8febc5101fc5c35f7dcdfaadf", "patch": "@@ -13,7 +13,6 @@ use crate::errors::{\n };\n use crate::middle::resolve_lifetime as rl;\n use crate::require_c_abi_if_c_variadic;\n-use rustc_ast::util::lev_distance::find_best_match_for_name;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_errors::{struct_span_err, Applicability, ErrorReported, FatalError};\n use rustc_hir as hir;\n@@ -26,6 +25,7 @@ use rustc_middle::ty::subst::{self, InternalSubsts, Subst, SubstsRef};\n use rustc_middle::ty::GenericParamDefKind;\n use rustc_middle::ty::{self, Const, DefIdTree, Ty, TyCtxt, TypeFoldable};\n use rustc_session::lint::builtin::AMBIGUOUS_ASSOCIATED_ITEMS;\n+use rustc_span::lev_distance::find_best_match_for_name;\n use rustc_span::symbol::{Ident, Symbol};\n use rustc_span::{Span, DUMMY_SP};\n use rustc_target::spec::abi;\n@@ -1579,7 +1579,11 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n \n                     let adt_def = qself_ty.ty_adt_def().expect(\"enum is not an ADT\");\n                     if let Some(suggested_name) = find_best_match_for_name(\n-                        adt_def.variants.iter().map(|variant| &variant.ident.name),\n+                        &adt_def\n+                            .variants\n+                            .iter()\n+                            .map(|variant| variant.ident.name)\n+                            .collect::<Vec<Symbol>>(),\n                         assoc_ident.name,\n                         None,\n                     ) {"}, {"sha": "26962d2222d32f592c87264183e5e9c8372cc855", "filename": "compiler/rustc_typeck/src/check/expr.rs", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/0beba9333754ead8febc5101fc5c35f7dcdfaadf/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0beba9333754ead8febc5101fc5c35f7dcdfaadf/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs?ref=0beba9333754ead8febc5101fc5c35f7dcdfaadf", "patch": "@@ -22,7 +22,6 @@ use crate::type_error_struct;\n \n use crate::errors::{AddressOfTemporaryTaken, ReturnStmtOutsideOfFnBody, StructExprNonExhaustive};\n use rustc_ast as ast;\n-use rustc_ast::util::lev_distance::find_best_match_for_name;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::stack::ensure_sufficient_stack;\n use rustc_errors::ErrorReported;\n@@ -40,6 +39,7 @@ use rustc_middle::ty::Ty;\n use rustc_middle::ty::TypeFoldable;\n use rustc_middle::ty::{AdtKind, Visibility};\n use rustc_span::hygiene::DesugaringKind;\n+use rustc_span::lev_distance::find_best_match_for_name;\n use rustc_span::source_map::Span;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_trait_selection::traits::{self, ObligationCauseCode};\n@@ -1441,18 +1441,22 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         field: Symbol,\n         skip: Vec<Symbol>,\n     ) -> Option<Symbol> {\n-        let names = variant.fields.iter().filter_map(|field| {\n-            // ignore already set fields and private fields from non-local crates\n-            if skip.iter().any(|&x| x == field.ident.name)\n-                || (!variant.def_id.is_local() && field.vis != Visibility::Public)\n-            {\n-                None\n-            } else {\n-                Some(&field.ident.name)\n-            }\n-        });\n+        let names = variant\n+            .fields\n+            .iter()\n+            .filter_map(|field| {\n+                // ignore already set fields and private fields from non-local crates\n+                if skip.iter().any(|&x| x == field.ident.name)\n+                    || (!variant.def_id.is_local() && field.vis != Visibility::Public)\n+                {\n+                    None\n+                } else {\n+                    Some(field.ident.name)\n+                }\n+            })\n+            .collect::<Vec<Symbol>>();\n \n-        find_best_match_for_name(names, field, None)\n+        find_best_match_for_name(&names, field, None)\n     }\n \n     fn available_field_names(&self, variant: &'tcx ty::VariantDef) -> Vec<Symbol> {"}, {"sha": "39a79893b6441c603f70a78a83a608e943505ef7", "filename": "compiler/rustc_typeck/src/check/method/probe.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0beba9333754ead8febc5101fc5c35f7dcdfaadf/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0beba9333754ead8febc5101fc5c35f7dcdfaadf/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs?ref=0beba9333754ead8febc5101fc5c35f7dcdfaadf", "patch": "@@ -9,7 +9,6 @@ use crate::hir::def::DefKind;\n use crate::hir::def_id::DefId;\n \n use rustc_ast as ast;\n-use rustc_ast::util::lev_distance::{find_best_match_for_name, lev_distance};\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::sync::Lrc;\n use rustc_hir as hir;\n@@ -27,6 +26,7 @@ use rustc_middle::ty::{\n };\n use rustc_session::lint;\n use rustc_span::def_id::LocalDefId;\n+use rustc_span::lev_distance::{find_best_match_for_name, lev_distance};\n use rustc_span::{symbol::Ident, Span, Symbol, DUMMY_SP};\n use rustc_trait_selection::autoderef::{self, Autoderef};\n use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt;\n@@ -1538,8 +1538,11 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                 Ok(None)\n             } else {\n                 let best_name = {\n-                    let names = applicable_close_candidates.iter().map(|cand| &cand.ident.name);\n-                    find_best_match_for_name(names, self.method_name.unwrap().name, None)\n+                    let names = applicable_close_candidates\n+                        .iter()\n+                        .map(|cand| cand.ident.name)\n+                        .collect::<Vec<Symbol>>();\n+                    find_best_match_for_name(&names, self.method_name.unwrap().name, None)\n                 }\n                 .unwrap();\n                 Ok(applicable_close_candidates"}, {"sha": "a979bc470d8db52f80efb77fde618acbf372ef85", "filename": "compiler/rustc_typeck/src/check/method/suggest.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0beba9333754ead8febc5101fc5c35f7dcdfaadf/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0beba9333754ead8febc5101fc5c35f7dcdfaadf/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs?ref=0beba9333754ead8febc5101fc5c35f7dcdfaadf", "patch": "@@ -2,7 +2,6 @@\n //! found or is otherwise invalid.\n \n use crate::check::FnCtxt;\n-use rustc_ast::util::lev_distance;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_errors::{pluralize, struct_span_err, Applicability, DiagnosticBuilder};\n use rustc_hir as hir;\n@@ -17,6 +16,7 @@ use rustc_middle::ty::print::with_crate_prefix;\n use rustc_middle::ty::{\n     self, ToPolyTraitRef, ToPredicate, Ty, TyCtxt, TypeFoldable, WithConstness,\n };\n+use rustc_span::lev_distance;\n use rustc_span::symbol::{kw, sym, Ident};\n use rustc_span::{source_map, FileName, Span};\n use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt;\n@@ -744,7 +744,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 if actual.is_enum() {\n                     let adt_def = actual.ty_adt_def().expect(\"enum is not an ADT\");\n                     if let Some(suggestion) = lev_distance::find_best_match_for_name(\n-                        adt_def.variants.iter().map(|s| &s.ident.name),\n+                        &adt_def.variants.iter().map(|s| s.ident.name).collect::<Vec<_>>(),\n                         item_name.name,\n                         None,\n                     ) {"}, {"sha": "bcb73e1b4e74e9a4bf11fdd185d2fe7df759b623", "filename": "compiler/rustc_typeck/src/check/pat.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0beba9333754ead8febc5101fc5c35f7dcdfaadf/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0beba9333754ead8febc5101fc5c35f7dcdfaadf/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fpat.rs?ref=0beba9333754ead8febc5101fc5c35f7dcdfaadf", "patch": "@@ -1,7 +1,6 @@\n use crate::check::FnCtxt;\n use rustc_ast as ast;\n \n-use rustc_ast::util::lev_distance::find_best_match_for_name;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_errors::{pluralize, struct_span_err, Applicability, DiagnosticBuilder};\n use rustc_hir as hir;\n@@ -13,6 +12,7 @@ use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKi\n use rustc_middle::ty::subst::GenericArg;\n use rustc_middle::ty::{self, Adt, BindingMode, Ty, TypeFoldable};\n use rustc_span::hygiene::DesugaringKind;\n+use rustc_span::lev_distance::find_best_match_for_name;\n use rustc_span::source_map::{Span, Spanned};\n use rustc_span::symbol::Ident;\n use rustc_trait_selection::traits::{ObligationCause, Pattern};\n@@ -1302,8 +1302,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 ),\n             );\n             if plural == \"\" {\n-                let input = unmentioned_fields.iter().map(|(_, field)| &field.name);\n-                let suggested_name = find_best_match_for_name(input, ident.name, None);\n+                let input =\n+                    unmentioned_fields.iter().map(|(_, field)| field.name).collect::<Vec<_>>();\n+                let suggested_name = find_best_match_for_name(&input, ident.name, None);\n                 if let Some(suggested_name) = suggested_name {\n                     err.span_suggestion(\n                         ident.span,"}, {"sha": "a615701f253d322b7fa3767571bf183649d946a7", "filename": "src/librustdoc/doctest.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0beba9333754ead8febc5101fc5c35f7dcdfaadf/src%2Flibrustdoc%2Fdoctest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0beba9333754ead8febc5101fc5c35f7dcdfaadf/src%2Flibrustdoc%2Fdoctest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctest.rs?ref=0beba9333754ead8febc5101fc5c35f7dcdfaadf", "patch": "@@ -754,12 +754,14 @@ impl Tester for Collector {\n             let folder_name = filename\n                 .to_string()\n                 .chars()\n-                .map(|c| if c == '/' || c == '.' { '_' } else { c })\n+                .map(|c| if c == '\\\\' || c == '/' || c == '.' { '_' } else { c })\n                 .collect::<String>();\n \n             path.push(format!(\n-                \"{name}_{line}_{number}\",\n-                name = folder_name,\n+                \"{krate}_{file}_{line}_{number}\",\n+                krate = cratename,\n+                file = folder_name,\n+                line = line,\n                 number = {\n                     // Increases the current test number, if this file already\n                     // exists or it creates a new entry with a test number of 0.\n@@ -768,7 +770,6 @@ impl Tester for Collector {\n                         .and_modify(|v| *v += 1)\n                         .or_insert(0)\n                 },\n-                line = line,\n             ));\n \n             std::fs::create_dir_all(&path)"}, {"sha": "751f2301053926ae189b19c16d9acaf068bcad6d", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0beba9333754ead8febc5101fc5c35f7dcdfaadf/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0beba9333754ead8febc5101fc5c35f7dcdfaadf/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=0beba9333754ead8febc5101fc5c35f7dcdfaadf", "patch": "@@ -513,7 +513,7 @@ fn main_options(options: config::Options) -> MainResult {\n     }\n \n     // need to move these items separately because we lose them by the time the closure is called,\n-    // but we can't crates the Handler ahead of time because it's not Send\n+    // but we can't create the Handler ahead of time because it's not Send\n     let diag_opts = (options.error_format, options.edition, options.debugging_opts.clone());\n     let show_coverage = options.show_coverage;\n     let run_check = options.run_check;"}, {"sha": "219ba15ad116dd2d68027e8e00bb1b2185d94c63", "filename": "src/test/run-make-fulldeps/coverage-llvmir-base/Makefile", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0beba9333754ead8febc5101fc5c35f7dcdfaadf/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-llvmir-base%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/0beba9333754ead8febc5101fc5c35f7dcdfaadf/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-llvmir-base%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-llvmir-base%2FMakefile?ref=0beba9333754ead8febc5101fc5c35f7dcdfaadf", "patch": "@@ -12,10 +12,12 @@ ifeq ($(UNAME),Darwin)\n \tINSTR_PROF_DATA_SUFFIX=,regular,live_support\n \tDATA_SECTION_PREFIX=__DATA,\n \tLLVM_COV_SECTION_PREFIX=__LLVM_COV,\n+\tCOMDAT_IF_SUPPORTED=\n else\n \tINSTR_PROF_DATA_SUFFIX=\n \tDATA_SECTION_PREFIX=\n \tLLVM_COV_SECTION_PREFIX=\n+\tCOMDAT_IF_SUPPORTED=, comdat\n endif\n \n ifeq ($(LINK_DEAD_CODE),yes)\n@@ -29,28 +31,39 @@ ifdef IS_WINDOWS\n \t\t-check-prefixes=CHECK,WINDOWS \\\n \t\t-DPRIVATE_GLOBAL='internal global' \\\n \t\t-DDEFINE_INTERNAL='$(DEFINE_INTERNAL)' \\\n+\t\t-DCOMDAT_IF_SUPPORTED='$(COMDAT_IF_SUPPORTED)' \\\n \t\t-DINSTR_PROF_DATA='.lprfd$$M' \\\n \t\t-DINSTR_PROF_NAME='.lprfn$$M' \\\n \t\t-DINSTR_PROF_CNTS='.lprfc$$M' \\\n \t\t-DINSTR_PROF_VALS='.lprfv$$M' \\\n \t\t-DINSTR_PROF_VNODES='.lprfnd$$M' \\\n \t\t-DINSTR_PROF_COVMAP='.lcovmap$$M' \\\n+\t\t-DINSTR_PROF_COVFUN='.lcovfun$$M' \\\n \t\t-DINSTR_PROF_ORDERFILE='.lorderfile$$M'\n else\n \tLLVM_FILECHECK_OPTIONS=\\\n \t\t-check-prefixes=CHECK \\\n \t\t-DPRIVATE_GLOBAL='private global' \\\n \t\t-DDEFINE_INTERNAL='$(DEFINE_INTERNAL)' \\\n+\t\t-DCOMDAT_IF_SUPPORTED='$(COMDAT_IF_SUPPORTED)' \\\n \t\t-DINSTR_PROF_DATA='$(DATA_SECTION_PREFIX)__llvm_prf_data$(INSTR_PROF_DATA_SUFFIX)' \\\n \t\t-DINSTR_PROF_NAME='$(DATA_SECTION_PREFIX)__llvm_prf_names' \\\n \t\t-DINSTR_PROF_CNTS='$(DATA_SECTION_PREFIX)__llvm_prf_cnts' \\\n \t\t-DINSTR_PROF_VALS='$(DATA_SECTION_PREFIX)__llvm_prf_vals' \\\n \t\t-DINSTR_PROF_VNODES='$(DATA_SECTION_PREFIX)__llvm_prf_vnds' \\\n \t\t-DINSTR_PROF_COVMAP='$(LLVM_COV_SECTION_PREFIX)__llvm_covmap' \\\n+\t\t-DINSTR_PROF_COVFUN='$(LLVM_COV_SECTION_PREFIX)__llvm_covfun' \\\n \t\t-DINSTR_PROF_ORDERFILE='$(DATA_SECTION_PREFIX)__llvm_orderfile'\n endif\n \n+ifeq ($(LLVM_VERSION_11_PLUS),true)\n+all: test_llvm_ir\n+else\n+$(info Rust option `-Z instrument-coverage` requires LLVM 11 or higher. Test skipped.)\n all:\n+endif\n+\n+test_llvm_ir:\n \t# Compile the test program with non-experimental coverage instrumentation, and generate LLVM IR\n \t#\n \t# Note: `-Clink-dead-code=no` disables the option, needed because the option is automatically\n@@ -62,4 +75,5 @@ all:\n \t\t\t-Clink-dead-code=$(LINK_DEAD_CODE) \\\n \t\t\t--emit=llvm-ir\n \n-\tcat \"$(TMPDIR)\"/testprog.ll | \"$(LLVM_FILECHECK)\" $(BASEDIR)/filecheck.testprog.txt $(LLVM_FILECHECK_OPTIONS)\n+\tcat \"$(TMPDIR)\"/testprog.ll | \\\n+\t\t\t\"$(LLVM_FILECHECK)\" $(BASEDIR)/filecheck.testprog.txt $(LLVM_FILECHECK_OPTIONS)"}, {"sha": "a312ec48e8498fb3bf8aa58907705c68942ae3fb", "filename": "src/test/run-make-fulldeps/coverage-llvmir-base/filecheck.testprog.txt", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0beba9333754ead8febc5101fc5c35f7dcdfaadf/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-llvmir-base%2Ffilecheck.testprog.txt", "raw_url": "https://github.com/rust-lang/rust/raw/0beba9333754ead8febc5101fc5c35f7dcdfaadf/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-llvmir-base%2Ffilecheck.testprog.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-llvmir-base%2Ffilecheck.testprog.txt?ref=0beba9333754ead8febc5101fc5c35f7dcdfaadf", "patch": "@@ -3,7 +3,10 @@\n \n WINDOWS:      $__llvm_profile_runtime_user = comdat any\n \n-CHECK:        @__llvm_coverage_mapping = internal constant\n+CHECK:        @__covrec_{{[A-F0-9]+}}u = linkonce_odr hidden constant\n+CHECK-SAME:   section \"[[INSTR_PROF_COVFUN]]\"[[COMDAT_IF_SUPPORTED]], align 8\n+\n+CHECK:        @__llvm_coverage_mapping = private constant\n CHECK-SAME:   section \"[[INSTR_PROF_COVMAP]]\", align 8\n \n WINDOWS:      @__llvm_profile_runtime = external global i32"}, {"sha": "2dac8fc2225bf5010f86979c7950ea6b85b0c72b", "filename": "src/test/run-make-fulldeps/coverage-reports-base/Makefile", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0beba9333754ead8febc5101fc5c35f7dcdfaadf/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports-base%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/0beba9333754ead8febc5101fc5c35f7dcdfaadf/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports-base%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports-base%2FMakefile?ref=0beba9333754ead8febc5101fc5c35f7dcdfaadf", "patch": "@@ -18,7 +18,10 @@ SOURCEDIR=../coverage\n # `llvm/release_debuginfo`. Note that some CI builds disable debug assertions (by setting\n # `NO_LLVM_ASSERTIONS=1`), so it is not OK to fail the test, but `bless`ed test results cannot be\n # generated without debug assertions.\n-LLVM_COV_DEBUG := $(shell \"$(LLVM_BIN_DIR)\"/llvm-cov show --debug 2>&1 | grep -q \"Unknown command line argument '--debug'\"; echo $$?)\n+LLVM_COV_DEBUG := $(shell \\\n+\t\t\"$(LLVM_BIN_DIR)\"/llvm-cov show --debug 2>&1 | \\\n+\t\tgrep -q \"Unknown command line argument '--debug'\"; \\\n+\t\techo $$?)\n ifeq ($(LLVM_COV_DEBUG), 1)\n DEBUG_FLAG=--debug\n endif\n@@ -30,7 +33,12 @@ ifdef RUSTC_BLESS_TEST\n DEBUG_FLAG=--debug\n endif\n \n+ifeq ($(LLVM_VERSION_11_PLUS),true)\n all: $(patsubst $(SOURCEDIR)/%.rs,%,$(wildcard $(SOURCEDIR)/*.rs))\n+else\n+$(info Rust option `-Z instrument-coverage` requires LLVM 11 or higher. Test skipped.)\n+all:\n+endif\n \n # Ensure there are no `expected` results for tests that may have been removed or renamed\n .PHONY: clear_expected_if_blessed"}, {"sha": "9f9440340e0eddfd7f4aee505f8e3caf31d74c8e", "filename": "src/test/run-make-fulldeps/coverage-spanview-base/Makefile", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0beba9333754ead8febc5101fc5c35f7dcdfaadf/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-spanview-base%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/0beba9333754ead8febc5101fc5c35f7dcdfaadf/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-spanview-base%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-spanview-base%2FMakefile?ref=0beba9333754ead8febc5101fc5c35f7dcdfaadf", "patch": "@@ -24,7 +24,12 @@ For revisions in Pull Requests (PR):\n endef\n export SPANVIEW_HEADER\n \n+ifeq ($(LLVM_VERSION_11_PLUS),true)\n all: $(patsubst $(SOURCEDIR)/%.rs,%,$(wildcard $(SOURCEDIR)/*.rs))\n+else\n+$(info Rust option `-Z instrument-coverage` requires LLVM 11 or higher. Test skipped.)\n+all:\n+endif\n \n # Ensure there are no `expected` results for tests that may have been removed or renamed\n .PHONY: clear_expected_if_blessed"}, {"sha": "99a2e0ba9523e874c658326865df9505bfacf73d", "filename": "src/test/run-make-fulldeps/coverage/coverage_tools.mk", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0beba9333754ead8febc5101fc5c35f7dcdfaadf/src%2Ftest%2Frun-make-fulldeps%2Fcoverage%2Fcoverage_tools.mk", "raw_url": "https://github.com/rust-lang/rust/raw/0beba9333754ead8febc5101fc5c35f7dcdfaadf/src%2Ftest%2Frun-make-fulldeps%2Fcoverage%2Fcoverage_tools.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage%2Fcoverage_tools.mk?ref=0beba9333754ead8febc5101fc5c35f7dcdfaadf", "patch": "@@ -38,6 +38,13 @@ endif\n \n UNAME = $(shell uname)\n \n+# Rust option `-Z instrument-coverage` uses LLVM Coverage Mapping Format version 4,\n+# which requires LLVM 11 or greater.\n+LLVM_VERSION_11_PLUS := $(shell \\\n+\t\tLLVM_VERSION=$$(\"$(LLVM_BIN_DIR)\"/llvm-config --version) && \\\n+\t\tLLVM_VERSION_MAJOR=$${LLVM_VERSION/.*/} && \\\n+\t\t[ $$LLVM_VERSION_MAJOR -ge 11 ] && echo true || echo false)\n+\n # FIXME(richkadel): Can any of the features tested by `run-make-fulldeps/coverage-*` tests be tested\n # just as completely by more focused unit tests of the code logic itself, to reduce the number of\n # test result files generated and maintained, and to help identify specific test failures and root"}, {"sha": "3f0c094794e4121372a14d75e0c518a9207bbafb", "filename": "src/test/rustdoc-js/doc-alias-filter-out.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0beba9333754ead8febc5101fc5c35f7dcdfaadf/src%2Ftest%2Frustdoc-js%2Fdoc-alias-filter-out.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0beba9333754ead8febc5101fc5c35f7dcdfaadf/src%2Ftest%2Frustdoc-js%2Fdoc-alias-filter-out.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-js%2Fdoc-alias-filter-out.rs?ref=0beba9333754ead8febc5101fc5c35f7dcdfaadf", "patch": "@@ -1,4 +1,2 @@\n-#![feature(doc_alias)]\n-\n #[doc(alias = \"true\")]\n pub struct Foo;"}, {"sha": "d5227814c06a808d60efdd8086e423abbf8af751", "filename": "src/test/rustdoc-js/doc-alias-filter.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0beba9333754ead8febc5101fc5c35f7dcdfaadf/src%2Ftest%2Frustdoc-js%2Fdoc-alias-filter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0beba9333754ead8febc5101fc5c35f7dcdfaadf/src%2Ftest%2Frustdoc-js%2Fdoc-alias-filter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-js%2Fdoc-alias-filter.rs?ref=0beba9333754ead8febc5101fc5c35f7dcdfaadf", "patch": "@@ -1,5 +1,3 @@\n-#![feature(doc_alias)]\n-\n #[doc(alias = \"true\")]\n pub struct Foo;\n "}, {"sha": "16c022c7498906994340e3b66455608f8ceb12bf", "filename": "src/test/rustdoc-js/doc-alias-whitespace.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0beba9333754ead8febc5101fc5c35f7dcdfaadf/src%2Ftest%2Frustdoc-js%2Fdoc-alias-whitespace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0beba9333754ead8febc5101fc5c35f7dcdfaadf/src%2Ftest%2Frustdoc-js%2Fdoc-alias-whitespace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-js%2Fdoc-alias-whitespace.rs?ref=0beba9333754ead8febc5101fc5c35f7dcdfaadf", "patch": "@@ -1,4 +1,2 @@\n-#![feature(doc_alias)]\n-\n #[doc(alias = \"Demon Lord\")]\n pub struct Struct;"}, {"sha": "750b7b757bc3551de39017bf7aa5ab1fad57979b", "filename": "src/test/rustdoc-js/doc-alias.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0beba9333754ead8febc5101fc5c35f7dcdfaadf/src%2Ftest%2Frustdoc-js%2Fdoc-alias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0beba9333754ead8febc5101fc5c35f7dcdfaadf/src%2Ftest%2Frustdoc-js%2Fdoc-alias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-js%2Fdoc-alias.rs?ref=0beba9333754ead8febc5101fc5c35f7dcdfaadf", "patch": "@@ -1,5 +1,3 @@\n-#![feature(doc_alias)]\n-\n #[doc(alias = \"StructItem\")]\n pub struct Struct {\n     #[doc(alias = \"StructFieldItem\")]"}, {"sha": "7de2caa189dc724d62db4cbb443c5b31b0018c10", "filename": "src/test/rustdoc-ui/check-doc-alias-attr-location.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0beba9333754ead8febc5101fc5c35f7dcdfaadf/src%2Ftest%2Frustdoc-ui%2Fcheck-doc-alias-attr-location.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0beba9333754ead8febc5101fc5c35f7dcdfaadf/src%2Ftest%2Frustdoc-ui%2Fcheck-doc-alias-attr-location.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fcheck-doc-alias-attr-location.rs?ref=0beba9333754ead8febc5101fc5c35f7dcdfaadf", "patch": "@@ -1,5 +1,3 @@\n-#![feature(doc_alias)]\n-\n pub struct Bar;\n pub trait Foo {\n     type X;"}, {"sha": "175626f49dcac74bd2758d1179df2087a1ebe56e", "filename": "src/test/rustdoc-ui/check-doc-alias-attr-location.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0beba9333754ead8febc5101fc5c35f7dcdfaadf/src%2Ftest%2Frustdoc-ui%2Fcheck-doc-alias-attr-location.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0beba9333754ead8febc5101fc5c35f7dcdfaadf/src%2Ftest%2Frustdoc-ui%2Fcheck-doc-alias-attr-location.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fcheck-doc-alias-attr-location.stderr?ref=0beba9333754ead8febc5101fc5c35f7dcdfaadf", "patch": "@@ -1,23 +1,23 @@\n error: `#[doc(alias = \"...\")]` isn't allowed on extern block\n-  --> $DIR/check-doc-alias-attr-location.rs:9:7\n+  --> $DIR/check-doc-alias-attr-location.rs:7:7\n    |\n LL | #[doc(alias = \"foo\")]\n    |       ^^^^^^^^^^^^^\n \n error: `#[doc(alias = \"...\")]` isn't allowed on implementation block\n-  --> $DIR/check-doc-alias-attr-location.rs:12:7\n+  --> $DIR/check-doc-alias-attr-location.rs:10:7\n    |\n LL | #[doc(alias = \"bar\")]\n    |       ^^^^^^^^^^^^^\n \n error: `#[doc(alias = \"...\")]` isn't allowed on implementation block\n-  --> $DIR/check-doc-alias-attr-location.rs:18:7\n+  --> $DIR/check-doc-alias-attr-location.rs:16:7\n    |\n LL | #[doc(alias = \"foobar\")]\n    |       ^^^^^^^^^^^^^^^^\n \n error: `#[doc(alias = \"...\")]` isn't allowed on type alias in implementation block\n-  --> $DIR/check-doc-alias-attr-location.rs:20:11\n+  --> $DIR/check-doc-alias-attr-location.rs:18:11\n    |\n LL |     #[doc(alias = \"assoc\")]\n    |           ^^^^^^^^^^^^^^^"}, {"sha": "912e35f9165454defd8e64648cbc19c80488bb12", "filename": "src/test/rustdoc-ui/check-doc-alias-attr.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0beba9333754ead8febc5101fc5c35f7dcdfaadf/src%2Ftest%2Frustdoc-ui%2Fcheck-doc-alias-attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0beba9333754ead8febc5101fc5c35f7dcdfaadf/src%2Ftest%2Frustdoc-ui%2Fcheck-doc-alias-attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fcheck-doc-alias-attr.rs?ref=0beba9333754ead8febc5101fc5c35f7dcdfaadf", "patch": "@@ -1,5 +1,4 @@\n #![crate_type = \"lib\"]\n-#![feature(doc_alias)]\n \n #[doc(alias = \"foo\")] // ok!\n pub struct Bar;"}, {"sha": "8a729b02e72bf08892b2e4f49b38c5bcc2acafdd", "filename": "src/test/rustdoc-ui/check-doc-alias-attr.stderr", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0beba9333754ead8febc5101fc5c35f7dcdfaadf/src%2Ftest%2Frustdoc-ui%2Fcheck-doc-alias-attr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0beba9333754ead8febc5101fc5c35f7dcdfaadf/src%2Ftest%2Frustdoc-ui%2Fcheck-doc-alias-attr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fcheck-doc-alias-attr.stderr?ref=0beba9333754ead8febc5101fc5c35f7dcdfaadf", "patch": "@@ -1,55 +1,55 @@\n error: doc alias attribute expects a string: #[doc(alias = \"0\")]\n-  --> $DIR/check-doc-alias-attr.rs:7:7\n+  --> $DIR/check-doc-alias-attr.rs:6:7\n    |\n LL | #[doc(alias)]\n    |       ^^^^^\n \n error: doc alias attribute expects a string: #[doc(alias = \"0\")]\n-  --> $DIR/check-doc-alias-attr.rs:8:7\n+  --> $DIR/check-doc-alias-attr.rs:7:7\n    |\n LL | #[doc(alias = 0)]\n    |       ^^^^^^^^^\n \n error: doc alias attribute expects a string: #[doc(alias = \"0\")]\n-  --> $DIR/check-doc-alias-attr.rs:9:7\n+  --> $DIR/check-doc-alias-attr.rs:8:7\n    |\n LL | #[doc(alias(\"bar\"))]\n    |       ^^^^^^^^^^^^\n \n error: '\\\"' character isn't allowed in `#[doc(alias = \"...\")]`\n-  --> $DIR/check-doc-alias-attr.rs:10:7\n+  --> $DIR/check-doc-alias-attr.rs:9:7\n    |\n LL | #[doc(alias = \"\\\"\")]\n    |       ^^^^^^^^^^^^\n \n error: '\\n' character isn't allowed in `#[doc(alias = \"...\")]`\n-  --> $DIR/check-doc-alias-attr.rs:11:7\n+  --> $DIR/check-doc-alias-attr.rs:10:7\n    |\n LL | #[doc(alias = \"\\n\")]\n    |       ^^^^^^^^^^^^\n \n error: '\\n' character isn't allowed in `#[doc(alias = \"...\")]`\n-  --> $DIR/check-doc-alias-attr.rs:12:7\n+  --> $DIR/check-doc-alias-attr.rs:11:7\n    |\n LL |   #[doc(alias = \"\n    |  _______^\n LL | | \")]\n    | |_^\n \n error: '\\t' character isn't allowed in `#[doc(alias = \"...\")]`\n-  --> $DIR/check-doc-alias-attr.rs:14:7\n+  --> $DIR/check-doc-alias-attr.rs:13:7\n    |\n LL | #[doc(alias = \"\\t\")]\n    |       ^^^^^^^^^^^^\n \n error: `#[doc(alias = \"...\")]` cannot start or end with ' '\n-  --> $DIR/check-doc-alias-attr.rs:15:7\n+  --> $DIR/check-doc-alias-attr.rs:14:7\n    |\n LL | #[doc(alias = \" hello\")]\n    |       ^^^^^^^^^^^^^^^^\n \n error: `#[doc(alias = \"...\")]` cannot start or end with ' '\n-  --> $DIR/check-doc-alias-attr.rs:16:7\n+  --> $DIR/check-doc-alias-attr.rs:15:7\n    |\n LL | #[doc(alias = \"hello \")]\n    |       ^^^^^^^^^^^^^^^^"}, {"sha": "d95324734be47ac498bc1e9eb0e4352c4379b800", "filename": "src/test/rustdoc-ui/doc-alias-assoc-const.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0beba9333754ead8febc5101fc5c35f7dcdfaadf/src%2Ftest%2Frustdoc-ui%2Fdoc-alias-assoc-const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0beba9333754ead8febc5101fc5c35f7dcdfaadf/src%2Ftest%2Frustdoc-ui%2Fdoc-alias-assoc-const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fdoc-alias-assoc-const.rs?ref=0beba9333754ead8febc5101fc5c35f7dcdfaadf", "patch": "@@ -1,4 +1,3 @@\n-#![feature(doc_alias)]\n #![feature(trait_alias)]\n \n pub struct Foo;"}, {"sha": "cbca40e1364fa34508a8a317ad472e3717400e40", "filename": "src/test/rustdoc-ui/doc-alias-assoc-const.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0beba9333754ead8febc5101fc5c35f7dcdfaadf/src%2Ftest%2Frustdoc-ui%2Fdoc-alias-assoc-const.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0beba9333754ead8febc5101fc5c35f7dcdfaadf/src%2Ftest%2Frustdoc-ui%2Fdoc-alias-assoc-const.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fdoc-alias-assoc-const.stderr?ref=0beba9333754ead8febc5101fc5c35f7dcdfaadf", "patch": "@@ -1,5 +1,5 @@\n error: `#[doc(alias = \"...\")]` isn't allowed on associated constant in trait implementation block\n-  --> $DIR/doc-alias-assoc-const.rs:11:11\n+  --> $DIR/doc-alias-assoc-const.rs:10:11\n    |\n LL |     #[doc(alias = \"CONST_BAZ\")]\n    |           ^^^^^^^^^^^^^^^^^^^"}, {"sha": "2798804880ad01e7f1e47d727622242be6ea14a4", "filename": "src/test/rustdoc-ui/doc-test-doctest-feature.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0beba9333754ead8febc5101fc5c35f7dcdfaadf/src%2Ftest%2Frustdoc-ui%2Fdoc-test-doctest-feature.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0beba9333754ead8febc5101fc5c35f7dcdfaadf/src%2Ftest%2Frustdoc-ui%2Fdoc-test-doctest-feature.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fdoc-test-doctest-feature.rs?ref=0beba9333754ead8febc5101fc5c35f7dcdfaadf", "patch": "@@ -2,13 +2,10 @@\n // compile-flags:--test\n // normalize-stdout-test: \"src/test/rustdoc-ui\" -> \"$$DIR\"\n \n-#![feature(cfg_doctest)]\n-\n // Make sure `cfg(doctest)` is set when finding doctests but not inside\n // the doctests.\n \n /// ```\n-/// #![feature(cfg_doctest)]\n /// assert!(!cfg!(doctest));\n /// ```\n #[cfg(doctest)]"}, {"sha": "b1cd74bf8520ae6fdc94cabcf129b700ebd50487", "filename": "src/test/rustdoc-ui/doc-test-doctest-feature.stdout", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0beba9333754ead8febc5101fc5c35f7dcdfaadf/src%2Ftest%2Frustdoc-ui%2Fdoc-test-doctest-feature.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/0beba9333754ead8febc5101fc5c35f7dcdfaadf/src%2Ftest%2Frustdoc-ui%2Fdoc-test-doctest-feature.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fdoc-test-doctest-feature.stdout?ref=0beba9333754ead8febc5101fc5c35f7dcdfaadf", "patch": "@@ -1,6 +1,6 @@\n \n running 1 test\n-test $DIR/doc-test-doctest-feature.rs - Foo (line 10) ... ok\n+test $DIR/doc-test-doctest-feature.rs - Foo (line 8) ... ok\n \n test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n "}, {"sha": "7db8cc60281794ceb82945925ea037b3f02e7cdf", "filename": "src/test/rustdoc/deprecated-future.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0beba9333754ead8febc5101fc5c35f7dcdfaadf/src%2Ftest%2Frustdoc%2Fdeprecated-future.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0beba9333754ead8febc5101fc5c35f7dcdfaadf/src%2Ftest%2Frustdoc%2Fdeprecated-future.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fdeprecated-future.rs?ref=0beba9333754ead8febc5101fc5c35f7dcdfaadf", "patch": "@@ -1,5 +1,3 @@\n-#![feature(deprecated)]\n-\n // @has deprecated_future/index.html '//*[@class=\"stab deprecated\"]' \\\n //      'Deprecated'\n // @has deprecated_future/struct.S.html '//*[@class=\"stab deprecated\"]' \\"}, {"sha": "a286856b2c3c1db62d3633254795bb2909241d5e", "filename": "src/test/rustdoc/deprecated.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0beba9333754ead8febc5101fc5c35f7dcdfaadf/src%2Ftest%2Frustdoc%2Fdeprecated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0beba9333754ead8febc5101fc5c35f7dcdfaadf/src%2Ftest%2Frustdoc%2Fdeprecated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fdeprecated.rs?ref=0beba9333754ead8febc5101fc5c35f7dcdfaadf", "patch": "@@ -1,5 +1,3 @@\n-#![feature(deprecated)]\n-\n // @has deprecated/index.html '//*[@class=\"docblock-short\"]/span[@class=\"stab deprecated\"]' \\\n //      'Deprecated'\n // @has - '//*[@class=\"docblock-short\"]' 'Deprecated docs'"}, {"sha": "d468f35e28003242d91df42bb55fce9947c3b566", "filename": "src/test/rustdoc/issue-76501.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0beba9333754ead8febc5101fc5c35f7dcdfaadf/src%2Ftest%2Frustdoc%2Fissue-76501.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0beba9333754ead8febc5101fc5c35f7dcdfaadf/src%2Ftest%2Frustdoc%2Fissue-76501.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-76501.rs?ref=0beba9333754ead8febc5101fc5c35f7dcdfaadf", "patch": "@@ -1,5 +1,3 @@\n-#![feature(const_fn)]\n-\n // @has 'issue_76501/fn.bloop.html' '//pre' 'pub const fn bloop() -> i32'\n /// A useless function that always returns 1.\n pub const fn bloop() -> i32 {"}, {"sha": "05bf67a5ff7c6c1bf16da16dd882f02adc496bb3", "filename": "src/test/ui/const-generics/infer/cannot-infer-const-args.full.stderr", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0beba9333754ead8febc5101fc5c35f7dcdfaadf/src%2Ftest%2Fui%2Fconst-generics%2Finfer%2Fcannot-infer-const-args.full.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0beba9333754ead8febc5101fc5c35f7dcdfaadf/src%2Ftest%2Fui%2Fconst-generics%2Finfer%2Fcannot-infer-const-args.full.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Finfer%2Fcannot-infer-const-args.full.stderr?ref=0beba9333754ead8febc5101fc5c35f7dcdfaadf", "patch": "@@ -3,6 +3,11 @@ error[E0282]: type annotations needed\n    |\n LL |     foo();\n    |     ^^^ cannot infer the value of const parameter `X` declared on the function `foo`\n+   |\n+help: consider specifying the const argument\n+   |\n+LL |     foo::<X>();\n+   |     ^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "05bf67a5ff7c6c1bf16da16dd882f02adc496bb3", "filename": "src/test/ui/const-generics/infer/cannot-infer-const-args.min.stderr", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0beba9333754ead8febc5101fc5c35f7dcdfaadf/src%2Ftest%2Fui%2Fconst-generics%2Finfer%2Fcannot-infer-const-args.min.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0beba9333754ead8febc5101fc5c35f7dcdfaadf/src%2Ftest%2Fui%2Fconst-generics%2Finfer%2Fcannot-infer-const-args.min.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Finfer%2Fcannot-infer-const-args.min.stderr?ref=0beba9333754ead8febc5101fc5c35f7dcdfaadf", "patch": "@@ -3,6 +3,11 @@ error[E0282]: type annotations needed\n    |\n LL |     foo();\n    |     ^^^ cannot infer the value of const parameter `X` declared on the function `foo`\n+   |\n+help: consider specifying the const argument\n+   |\n+LL |     foo::<X>();\n+   |     ^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "99894173bc8f60c7bf88299def65e2e706b2591e", "filename": "src/test/ui/const-generics/infer/issue-77092.stderr", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0beba9333754ead8febc5101fc5c35f7dcdfaadf/src%2Ftest%2Fui%2Fconst-generics%2Finfer%2Fissue-77092.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0beba9333754ead8febc5101fc5c35f7dcdfaadf/src%2Ftest%2Fui%2Fconst-generics%2Finfer%2Fissue-77092.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Finfer%2Fissue-77092.stderr?ref=0beba9333754ead8febc5101fc5c35f7dcdfaadf", "patch": "@@ -3,6 +3,11 @@ error[E0282]: type annotations needed\n    |\n LL |         println!(\"{:?}\", take_array_from_mut(&mut arr, i));\n    |                          ^^^^^^^^^^^^^^^^^^^ cannot infer the value of const parameter `N` declared on the function `take_array_from_mut`\n+   |\n+help: consider specifying the const argument\n+   |\n+LL |         println!(\"{:?}\", take_array_from_mut::<N>(&mut arr, i));\n+   |                          ^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "7aa3bd44df84436a69d77774e66fb1baec42bd55", "filename": "src/test/ui/const-generics/infer/method-chain.full.stderr", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0beba9333754ead8febc5101fc5c35f7dcdfaadf/src%2Ftest%2Fui%2Fconst-generics%2Finfer%2Fmethod-chain.full.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0beba9333754ead8febc5101fc5c35f7dcdfaadf/src%2Ftest%2Fui%2Fconst-generics%2Finfer%2Fmethod-chain.full.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Finfer%2Fmethod-chain.full.stderr?ref=0beba9333754ead8febc5101fc5c35f7dcdfaadf", "patch": "@@ -3,6 +3,11 @@ error[E0282]: type annotations needed\n    |\n LL |     Foo.bar().bar().bar().bar().baz();\n    |                                 ^^^ cannot infer the value of const parameter `N` declared on the associated function `baz`\n+   |\n+help: consider specifying the const argument\n+   |\n+LL |     Foo.bar().bar().bar().bar().baz::<N>();\n+   |                                 ^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "7aa3bd44df84436a69d77774e66fb1baec42bd55", "filename": "src/test/ui/const-generics/infer/method-chain.min.stderr", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0beba9333754ead8febc5101fc5c35f7dcdfaadf/src%2Ftest%2Fui%2Fconst-generics%2Finfer%2Fmethod-chain.min.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0beba9333754ead8febc5101fc5c35f7dcdfaadf/src%2Ftest%2Fui%2Fconst-generics%2Finfer%2Fmethod-chain.min.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Finfer%2Fmethod-chain.min.stderr?ref=0beba9333754ead8febc5101fc5c35f7dcdfaadf", "patch": "@@ -3,6 +3,11 @@ error[E0282]: type annotations needed\n    |\n LL |     Foo.bar().bar().bar().bar().baz();\n    |                                 ^^^ cannot infer the value of const parameter `N` declared on the associated function `baz`\n+   |\n+help: consider specifying the const argument\n+   |\n+LL |     Foo.bar().bar().bar().bar().baz::<N>();\n+   |                                 ^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "cc6c9a475104c15087c050ef0619d520b63c2963", "filename": "src/test/ui/const-generics/infer/one-param-uninferred.full.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0beba9333754ead8febc5101fc5c35f7dcdfaadf/src%2Ftest%2Fui%2Fconst-generics%2Finfer%2Fone-param-uninferred.full.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0beba9333754ead8febc5101fc5c35f7dcdfaadf/src%2Ftest%2Fui%2Fconst-generics%2Finfer%2Fone-param-uninferred.full.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Finfer%2Fone-param-uninferred.full.stderr?ref=0beba9333754ead8febc5101fc5c35f7dcdfaadf", "patch": "@@ -0,0 +1,14 @@\n+error[E0282]: type annotations needed\n+  --> $DIR/one-param-uninferred.rs:15:23\n+   |\n+LL |     let _: [u8; 17] = foo();\n+   |                       ^^^ cannot infer the value of const parameter `M` declared on the function `foo`\n+   |\n+help: consider specifying the const argument\n+   |\n+LL |     let _: [u8; 17] = foo::<M>();\n+   |                       ^^^^^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0282`."}, {"sha": "cc6c9a475104c15087c050ef0619d520b63c2963", "filename": "src/test/ui/const-generics/infer/one-param-uninferred.min.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0beba9333754ead8febc5101fc5c35f7dcdfaadf/src%2Ftest%2Fui%2Fconst-generics%2Finfer%2Fone-param-uninferred.min.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0beba9333754ead8febc5101fc5c35f7dcdfaadf/src%2Ftest%2Fui%2Fconst-generics%2Finfer%2Fone-param-uninferred.min.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Finfer%2Fone-param-uninferred.min.stderr?ref=0beba9333754ead8febc5101fc5c35f7dcdfaadf", "patch": "@@ -0,0 +1,14 @@\n+error[E0282]: type annotations needed\n+  --> $DIR/one-param-uninferred.rs:15:23\n+   |\n+LL |     let _: [u8; 17] = foo();\n+   |                       ^^^ cannot infer the value of const parameter `M` declared on the function `foo`\n+   |\n+help: consider specifying the const argument\n+   |\n+LL |     let _: [u8; 17] = foo::<M>();\n+   |                       ^^^^^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0282`."}, {"sha": "0e947131f4cdb4deca473e66279a6f400eec98da", "filename": "src/test/ui/const-generics/infer/one-param-uninferred.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/0beba9333754ead8febc5101fc5c35f7dcdfaadf/src%2Ftest%2Fui%2Fconst-generics%2Finfer%2Fone-param-uninferred.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0beba9333754ead8febc5101fc5c35f7dcdfaadf/src%2Ftest%2Fui%2Fconst-generics%2Finfer%2Fone-param-uninferred.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Finfer%2Fone-param-uninferred.rs?ref=0beba9333754ead8febc5101fc5c35f7dcdfaadf", "patch": "@@ -0,0 +1,17 @@\n+// Test that we emit an error if we cannot properly infer a constant.\n+// revisions: full min\n+\n+#![cfg_attr(full, feature(const_generics))]\n+#![cfg_attr(full, allow(incomplete_features))]\n+#![cfg_attr(min, feature(min_const_generics))]\n+\n+fn foo<const N: usize, const M: usize>() -> [u8; N] {\n+    todo!()\n+}\n+\n+fn main() {\n+    // FIXME(const_generics): Currently this only suggests one const parameter,\n+    // but instead it should suggest to provide all parameters.\n+    let _: [u8; 17] = foo();\n+                  //~^ ERROR type annotations needed\n+}"}, {"sha": "4be625ba90930f475c8ceff6470a339ea13e3a0f", "filename": "src/test/ui/const-generics/infer/uninferred-consts.full.stderr", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0beba9333754ead8febc5101fc5c35f7dcdfaadf/src%2Ftest%2Fui%2Fconst-generics%2Finfer%2Funinferred-consts.full.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0beba9333754ead8febc5101fc5c35f7dcdfaadf/src%2Ftest%2Fui%2Fconst-generics%2Finfer%2Funinferred-consts.full.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Finfer%2Funinferred-consts.full.stderr?ref=0beba9333754ead8febc5101fc5c35f7dcdfaadf", "patch": "@@ -2,7 +2,12 @@ error[E0282]: type annotations needed\n   --> $DIR/uninferred-consts.rs:14:9\n    |\n LL |     Foo.foo();\n-   |         ^^^ cannot infer the value of const parameter `N` declared on the associated function `foo`\n+   |         ^^^ cannot infer the value of const parameter `A` declared on the associated function `foo`\n+   |\n+help: consider specifying the const argument\n+   |\n+LL |     Foo.foo::<A>();\n+   |         ^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "4be625ba90930f475c8ceff6470a339ea13e3a0f", "filename": "src/test/ui/const-generics/infer/uninferred-consts.min.stderr", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0beba9333754ead8febc5101fc5c35f7dcdfaadf/src%2Ftest%2Fui%2Fconst-generics%2Finfer%2Funinferred-consts.min.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0beba9333754ead8febc5101fc5c35f7dcdfaadf/src%2Ftest%2Fui%2Fconst-generics%2Finfer%2Funinferred-consts.min.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Finfer%2Funinferred-consts.min.stderr?ref=0beba9333754ead8febc5101fc5c35f7dcdfaadf", "patch": "@@ -2,7 +2,12 @@ error[E0282]: type annotations needed\n   --> $DIR/uninferred-consts.rs:14:9\n    |\n LL |     Foo.foo();\n-   |         ^^^ cannot infer the value of const parameter `N` declared on the associated function `foo`\n+   |         ^^^ cannot infer the value of const parameter `A` declared on the associated function `foo`\n+   |\n+help: consider specifying the const argument\n+   |\n+LL |     Foo.foo::<A>();\n+   |         ^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "00fb6eac9920810466362d7d3bdbb32696a9b8d9", "filename": "src/test/ui/const-generics/infer/uninferred-consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0beba9333754ead8febc5101fc5c35f7dcdfaadf/src%2Ftest%2Fui%2Fconst-generics%2Finfer%2Funinferred-consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0beba9333754ead8febc5101fc5c35f7dcdfaadf/src%2Ftest%2Fui%2Fconst-generics%2Finfer%2Funinferred-consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Finfer%2Funinferred-consts.rs?ref=0beba9333754ead8febc5101fc5c35f7dcdfaadf", "patch": "@@ -8,7 +8,7 @@\n // taken from https://github.com/rust-lang/rust/issues/70507#issuecomment-615268893\n struct Foo;\n impl Foo {\n-    fn foo<const N: usize>(self) {}\n+    fn foo<const A: usize, const B: usize>(self) {}\n }\n fn main() {\n     Foo.foo();"}, {"sha": "15505fd79f4a1f6ac0c338de623b478c6b0c1268", "filename": "src/tools/clippy/clippy_lints/src/attrs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0beba9333754ead8febc5101fc5c35f7dcdfaadf/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0beba9333754ead8febc5101fc5c35f7dcdfaadf/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fattrs.rs?ref=0beba9333754ead8febc5101fc5c35f7dcdfaadf", "patch": "@@ -5,7 +5,7 @@ use crate::utils::{\n     span_lint_and_sugg, span_lint_and_then, without_block_comments,\n };\n use if_chain::if_chain;\n-use rustc_ast::util::lev_distance::find_best_match_for_name;\n+use rustc_span::lev_distance::find_best_match_for_name;\n use rustc_ast::{AttrKind, AttrStyle, Attribute, Lit, LitKind, MetaItemKind, NestedMetaItem};\n use rustc_errors::Applicability;\n use rustc_hir::{\n@@ -427,7 +427,7 @@ fn check_clippy_lint_names(cx: &LateContext<'_>, ident: &str, items: &[NestedMet\n                             .map(|l| Symbol::intern(&l.name_lower()))\n                             .collect::<Vec<_>>();\n                         let sugg = find_best_match_for_name(\n-                            symbols.iter(),\n+                            &symbols,\n                             Symbol::intern(&format!(\"clippy::{}\", name_lower)),\n                             None,\n                         );"}]}