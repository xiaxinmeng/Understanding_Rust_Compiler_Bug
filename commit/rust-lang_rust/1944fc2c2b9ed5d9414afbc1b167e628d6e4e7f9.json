{"sha": "1944fc2c2b9ed5d9414afbc1b167e628d6e4e7f9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE5NDRmYzJjMmI5ZWQ1ZDk0MTRhZmJjMWIxNjdlNjI4ZDZlNGU3Zjk=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-05-12T17:45:34Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-05-12T17:45:34Z"}, "message": "Merge #1262\n\n1262: Where clauses and other Chalk improvements r=matklad a=flodiebold\n\nThis adds support for where clauses to the Chalk integration; it also adds FnDef lowering and partly handles auto traits.\r\n\r\nOne thing I'm not sure about is the error handling -- what do we do if we can't\r\nresolve a trait reference in a where clause? For impls, I think it's clear we\r\nneed to disregard the impl for trait solving. I've solved this for now by\r\nintroducing an 'unknown trait' that has no impls, so if we encounter an unknown\r\ntrait we can use that and basically get a where clause that's always false. (The\r\nalternative would be somehow not returning the impl to Chalk at all, but we\r\nwould need to know that we need to do that in `impls_for_trait` already, and we\r\ndon't resolve anything there.)\r\n\r\nA bit surprisingly, this has almost no impact on the type inference stats for RA, probably because of missing edge cases. Probably impl Trait support and closure support will do more.\n\nCo-authored-by: Florian Diebold <flodiebold@gmail.com>", "tree": {"sha": "50999df2191aa13204ca05f255ebe2b2105a1832", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/50999df2191aa13204ca05f255ebe2b2105a1832"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1944fc2c2b9ed5d9414afbc1b167e628d6e4e7f9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1944fc2c2b9ed5d9414afbc1b167e628d6e4e7f9", "html_url": "https://github.com/rust-lang/rust/commit/1944fc2c2b9ed5d9414afbc1b167e628d6e4e7f9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1944fc2c2b9ed5d9414afbc1b167e628d6e4e7f9/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "940c538ecf42a53e5a0e0e9ebad7267c1fe843ca", "url": "https://api.github.com/repos/rust-lang/rust/commits/940c538ecf42a53e5a0e0e9ebad7267c1fe843ca", "html_url": "https://github.com/rust-lang/rust/commit/940c538ecf42a53e5a0e0e9ebad7267c1fe843ca"}, {"sha": "cbe75676b90d93e5b0ac461dce2d916cef4c0476", "url": "https://api.github.com/repos/rust-lang/rust/commits/cbe75676b90d93e5b0ac461dce2d916cef4c0476", "html_url": "https://github.com/rust-lang/rust/commit/cbe75676b90d93e5b0ac461dce2d916cef4c0476"}], "stats": {"total": 472, "additions": 416, "deletions": 56}, "files": [{"sha": "0c4a80bfaa5be1ae93bac60f2c1aaa0129d1c1df", "filename": "crates/ra_hir/src/code_model_api.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1944fc2c2b9ed5d9414afbc1b167e628d6e4e7f9/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1944fc2c2b9ed5d9414afbc1b167e628d6e4e7f9/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs?ref=1944fc2c2b9ed5d9414afbc1b167e628d6e4e7f9", "patch": "@@ -703,6 +703,10 @@ impl Trait {\n         TraitRef::for_trait(db, self)\n     }\n \n+    pub fn is_auto(self, db: &impl DefDatabase) -> bool {\n+        self.trait_data(db).is_auto()\n+    }\n+\n     pub(crate) fn resolver(&self, db: &impl DefDatabase) -> Resolver {\n         let r = self.module(db).resolver(db);\n         // add generic params, if present"}, {"sha": "8f98ca3a5a9f5bd85955dd481357389d570cc3e6", "filename": "crates/ra_hir/src/db.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1944fc2c2b9ed5d9414afbc1b167e628d6e4e7f9/crates%2Fra_hir%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1944fc2c2b9ed5d9414afbc1b167e628d6e4e7f9/crates%2Fra_hir%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdb.rs?ref=1944fc2c2b9ed5d9414afbc1b167e628d6e4e7f9", "patch": "@@ -11,7 +11,7 @@ use crate::{\n     DefWithBody, Trait,\n     ids,\n     nameres::{Namespace, ImportSourceMap, RawItems, CrateDefMap},\n-    ty::{InferenceResult, Ty, method_resolution::CrateImplBlocks, TypableDef, CallableDef, FnSig, TypeCtor},\n+    ty::{InferenceResult, Ty, method_resolution::CrateImplBlocks, TypableDef, CallableDef, FnSig, TypeCtor, GenericPredicate},\n     adt::{StructData, EnumData},\n     impl_block::{ModuleImplBlocks, ImplSourceMap, ImplBlock},\n     generics::{GenericParams, GenericDef},\n@@ -138,6 +138,9 @@ pub trait HirDatabase: DefDatabase {\n     #[salsa::invoke(crate::ty::callable_item_sig)]\n     fn callable_item_signature(&self, def: CallableDef) -> FnSig;\n \n+    #[salsa::invoke(crate::ty::generic_predicates)]\n+    fn generic_predicates(&self, def: GenericDef) -> Arc<[GenericPredicate]>;\n+\n     #[salsa::invoke(crate::expr::body_with_source_map_query)]\n     fn body_with_source_map(\n         &self,"}, {"sha": "c29b96f508adf8576b7a1659a77283a6233f02d5", "filename": "crates/ra_hir/src/generics.rs", "status": "modified", "additions": 43, "deletions": 19, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/1944fc2c2b9ed5d9414afbc1b167e628d6e4e7f9/crates%2Fra_hir%2Fsrc%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1944fc2c2b9ed5d9414afbc1b167e628d6e4e7f9/crates%2Fra_hir%2Fsrc%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fgenerics.rs?ref=1944fc2c2b9ed5d9414afbc1b167e628d6e4e7f9", "patch": "@@ -8,7 +8,7 @@ use std::sync::Arc;\n use ra_syntax::ast::{self, NameOwner, TypeParamsOwner, TypeBoundsOwner};\n \n use crate::{\n-    db::DefDatabase,\n+    db::{ HirDatabase, DefDatabase},\n     Name, AsName, Function, Struct, Enum, Trait, TypeAlias, ImplBlock, Container, path::Path, type_ref::TypeRef, AdtDef\n };\n \n@@ -32,8 +32,8 @@ pub struct GenericParams {\n /// where clauses like `where T: Foo + Bar` are turned into multiple of these.\n #[derive(Clone, PartialEq, Eq, Debug)]\n pub struct WherePredicate {\n-    type_ref: TypeRef,\n-    trait_ref: Path,\n+    pub(crate) type_ref: TypeRef,\n+    pub(crate) trait_ref: Path,\n }\n \n // FIXME: consts can have type parameters from their parents (i.e. associated consts of traits)\n@@ -90,8 +90,17 @@ impl GenericParams {\n     fn fill_params(&mut self, params: &ast::TypeParamList, start: u32) {\n         for (idx, type_param) in params.type_params().enumerate() {\n             let name = type_param.name().map(AsName::as_name).unwrap_or_else(Name::missing);\n-            let param = GenericParam { idx: idx as u32 + start, name };\n+            let param = GenericParam { idx: idx as u32 + start, name: name.clone() };\n             self.params.push(param);\n+\n+            let type_ref = TypeRef::Path(name.into());\n+            for bound in type_param\n+                .type_bound_list()\n+                .iter()\n+                .flat_map(|type_bound_list| type_bound_list.bounds())\n+            {\n+                self.add_where_predicate_from_bound(bound, type_ref.clone());\n+            }\n         }\n     }\n \n@@ -101,26 +110,28 @@ impl GenericParams {\n                 Some(type_ref) => type_ref,\n                 None => continue,\n             };\n+            let type_ref = TypeRef::from_ast(type_ref);\n             for bound in pred.type_bound_list().iter().flat_map(|l| l.bounds()) {\n-                let path = bound\n-                    .type_ref()\n-                    .and_then(|tr| match tr.kind() {\n-                        ast::TypeRefKind::PathType(path) => path.path(),\n-                        _ => None,\n-                    })\n-                    .and_then(Path::from_ast);\n-                let path = match path {\n-                    Some(p) => p,\n-                    None => continue,\n-                };\n-                self.where_predicates.push(WherePredicate {\n-                    type_ref: TypeRef::from_ast(type_ref),\n-                    trait_ref: path,\n-                });\n+                self.add_where_predicate_from_bound(bound, type_ref.clone());\n             }\n         }\n     }\n \n+    fn add_where_predicate_from_bound(&mut self, bound: &ast::TypeBound, type_ref: TypeRef) {\n+        let path = bound\n+            .type_ref()\n+            .and_then(|tr| match tr.kind() {\n+                ast::TypeRefKind::PathType(path) => path.path(),\n+                _ => None,\n+            })\n+            .and_then(Path::from_ast);\n+        let path = match path {\n+            Some(p) => p,\n+            None => return,\n+        };\n+        self.where_predicates.push(WherePredicate { type_ref, trait_ref: path });\n+    }\n+\n     pub(crate) fn find_by_name(&self, name: &Name) -> Option<&GenericParam> {\n         self.params.iter().find(|p| &p.name == name)\n     }\n@@ -148,6 +159,19 @@ impl GenericParams {\n     }\n }\n \n+impl GenericDef {\n+    pub(crate) fn resolver(&self, db: &impl HirDatabase) -> crate::Resolver {\n+        match self {\n+            GenericDef::Function(inner) => inner.resolver(db),\n+            GenericDef::Struct(inner) => inner.resolver(db),\n+            GenericDef::Enum(inner) => inner.resolver(db),\n+            GenericDef::Trait(inner) => inner.resolver(db),\n+            GenericDef::TypeAlias(inner) => inner.resolver(db),\n+            GenericDef::ImplBlock(inner) => inner.resolver(db),\n+        }\n+    }\n+}\n+\n impl From<Container> for GenericDef {\n     fn from(c: Container) -> Self {\n         match c {"}, {"sha": "b7dd775f1b7862c22d12015210f0b35aae73c619", "filename": "crates/ra_hir/src/impl_block.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1944fc2c2b9ed5d9414afbc1b167e628d6e4e7f9/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1944fc2c2b9ed5d9414afbc1b167e628d6e4e7f9/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs?ref=1944fc2c2b9ed5d9414afbc1b167e628d6e4e7f9", "patch": "@@ -93,6 +93,10 @@ impl ImplBlock {\n         db.impls_in_module(self.module).impls[self.impl_id].items().to_vec()\n     }\n \n+    pub fn is_negative(&self, db: &impl DefDatabase) -> bool {\n+        db.impls_in_module(self.module).impls[self.impl_id].negative\n+    }\n+\n     pub(crate) fn resolver(&self, db: &impl DefDatabase) -> Resolver {\n         let r = self.module().resolver(db);\n         // add generic params, if present\n@@ -108,6 +112,7 @@ pub struct ImplData {\n     target_trait: Option<TypeRef>,\n     target_type: TypeRef,\n     items: Vec<ImplItem>,\n+    negative: bool,\n }\n \n impl ImplData {\n@@ -120,6 +125,7 @@ impl ImplData {\n         let target_trait = node.target_trait().map(TypeRef::from_ast);\n         let target_type = TypeRef::from_ast_opt(node.target_type());\n         let ctx = LocationCtx::new(db, module, file_id);\n+        let negative = node.is_negative();\n         let items = if let Some(item_list) = node.item_list() {\n             item_list\n                 .impl_items()\n@@ -132,7 +138,7 @@ impl ImplData {\n         } else {\n             Vec::new()\n         };\n-        ImplData { target_trait, target_type, items }\n+        ImplData { target_trait, target_type, items, negative }\n     }\n \n     pub fn target_trait(&self) -> Option<&TypeRef> {"}, {"sha": "2d831f0d859b08a428f18697ed0049cd89621e2b", "filename": "crates/ra_hir/src/marks.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1944fc2c2b9ed5d9414afbc1b167e628d6e4e7f9/crates%2Fra_hir%2Fsrc%2Fmarks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1944fc2c2b9ed5d9414afbc1b167e628d6e4e7f9/crates%2Fra_hir%2Fsrc%2Fmarks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmarks.rs?ref=1944fc2c2b9ed5d9414afbc1b167e628d6e4e7f9", "patch": "@@ -9,4 +9,5 @@ test_utils::marks!(\n     glob_across_crates\n     std_prelude\n     match_ergonomics_ref\n+    trait_resolution_on_fn_type\n );"}, {"sha": "dfe883fa43c19517f025425c7e22cb03029e1138", "filename": "crates/ra_hir/src/traits.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1944fc2c2b9ed5d9414afbc1b167e628d6e4e7f9/crates%2Fra_hir%2Fsrc%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1944fc2c2b9ed5d9414afbc1b167e628d6e4e7f9/crates%2Fra_hir%2Fsrc%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Ftraits.rs?ref=1944fc2c2b9ed5d9414afbc1b167e628d6e4e7f9", "patch": "@@ -11,6 +11,7 @@ use crate::{Function, Const, TypeAlias, Name, DefDatabase, Trait, ids::LocationC\n pub struct TraitData {\n     name: Option<Name>,\n     items: Vec<TraitItem>,\n+    auto: bool,\n }\n \n impl TraitData {\n@@ -19,6 +20,7 @@ impl TraitData {\n         let name = node.name().map(|n| n.as_name());\n         let module = tr.module(db);\n         let ctx = LocationCtx::new(db, module, file_id);\n+        let auto = node.is_auto();\n         let items = if let Some(item_list) = node.item_list() {\n             item_list\n                 .impl_items()\n@@ -31,7 +33,7 @@ impl TraitData {\n         } else {\n             Vec::new()\n         };\n-        Arc::new(TraitData { name, items })\n+        Arc::new(TraitData { name, items, auto })\n     }\n \n     pub(crate) fn name(&self) -> &Option<Name> {\n@@ -41,6 +43,10 @@ impl TraitData {\n     pub(crate) fn items(&self) -> &[TraitItem] {\n         &self.items\n     }\n+\n+    pub(crate) fn is_auto(&self) -> bool {\n+        self.auto\n+    }\n }\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]"}, {"sha": "cfe07156b091505cacc0378ac494669f23f22d6a", "filename": "crates/ra_hir/src/ty.rs", "status": "modified", "additions": 30, "deletions": 1, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/1944fc2c2b9ed5d9414afbc1b167e628d6e4e7f9/crates%2Fra_hir%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1944fc2c2b9ed5d9414afbc1b167e628d6e4e7f9/crates%2Fra_hir%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty.rs?ref=1944fc2c2b9ed5d9414afbc1b167e628d6e4e7f9", "patch": "@@ -19,7 +19,7 @@ use std::{fmt, mem};\n use crate::{Name, AdtDef, type_ref::Mutability, db::HirDatabase, Trait, GenericParams};\n use display::{HirDisplay, HirFormatter};\n \n-pub(crate) use lower::{TypableDef, type_for_def, type_for_field, callable_item_sig};\n+pub(crate) use lower::{TypableDef, type_for_def, type_for_field, callable_item_sig, generic_predicates};\n pub(crate) use infer::{infer, InferenceResult, InferTy};\n pub use lower::CallableDef;\n \n@@ -234,6 +234,35 @@ impl TraitRef {\n     }\n }\n \n+/// Like `generics::WherePredicate`, but with resolved types: A condition on the\n+/// parameters of a generic item.\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub enum GenericPredicate {\n+    /// The given trait needs to be implemented for its type parameters.\n+    Implemented(TraitRef),\n+    /// We couldn't resolve the trait reference. (If some type parameters can't\n+    /// be resolved, they will just be Unknown).\n+    Error,\n+}\n+\n+impl GenericPredicate {\n+    pub fn is_error(&self) -> bool {\n+        match self {\n+            GenericPredicate::Error => true,\n+            _ => false,\n+        }\n+    }\n+\n+    pub fn subst(self, substs: &Substs) -> GenericPredicate {\n+        match self {\n+            GenericPredicate::Implemented(trait_ref) => {\n+                GenericPredicate::Implemented(trait_ref.subst(substs))\n+            }\n+            GenericPredicate::Error => self,\n+        }\n+    }\n+}\n+\n /// Basically a claim (currently not validated / checked) that the contained\n /// type / trait ref contains no inference variables; any inference variables it\n /// contained have been replaced by bound variables, and `num_vars` tells us how"}, {"sha": "09d26ce5ad4df7379a42c9bf271e7288c0a426a0", "filename": "crates/ra_hir/src/ty/lower.rs", "status": "modified", "additions": 45, "deletions": 8, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/1944fc2c2b9ed5d9414afbc1b167e628d6e4e7f9/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1944fc2c2b9ed5d9414afbc1b167e628d6e4e7f9/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs?ref=1944fc2c2b9ed5d9414afbc1b167e628d6e4e7f9", "patch": "@@ -5,6 +5,7 @@\n //!  - Building the type for an item: This happens through the `type_for_def` query.\n //!\n //! This usually involves resolving names, collecting generic arguments etc.\n+use std::sync::Arc;\n use std::iter;\n \n use crate::{\n@@ -18,9 +19,9 @@ use crate::{\n     resolve::{Resolver, Resolution},\n     path::{PathSegment, GenericArg},\n     generics::{GenericParams, HasGenericParams},\n-    adt::VariantDef, Trait\n+    adt::VariantDef, Trait, generics::{ WherePredicate, GenericDef}\n };\n-use super::{Ty, primitive, FnSig, Substs, TypeCtor, TraitRef};\n+use super::{Ty, primitive, FnSig, Substs, TypeCtor, TraitRef, GenericPredicate};\n \n impl Ty {\n     pub(crate) fn from_hir(db: &impl HirDatabase, resolver: &Resolver, type_ref: &TypeRef) -> Self {\n@@ -208,16 +209,12 @@ pub(super) fn substs_from_path_segment(\n }\n \n impl TraitRef {\n-    pub(crate) fn from_hir(\n+    pub(crate) fn from_path(\n         db: &impl HirDatabase,\n         resolver: &Resolver,\n-        type_ref: &TypeRef,\n+        path: &Path,\n         explicit_self_ty: Option<Ty>,\n     ) -> Option<Self> {\n-        let path = match type_ref {\n-            TypeRef::Path(path) => path,\n-            _ => return None,\n-        };\n         let resolved = match resolver.resolve_path(db, &path).take_types()? {\n             Resolution::Def(ModuleDef::Trait(tr)) => tr,\n             _ => return None,\n@@ -232,6 +229,19 @@ impl TraitRef {\n         Some(TraitRef { trait_: resolved, substs })\n     }\n \n+    pub(crate) fn from_hir(\n+        db: &impl HirDatabase,\n+        resolver: &Resolver,\n+        type_ref: &TypeRef,\n+        explicit_self_ty: Option<Ty>,\n+    ) -> Option<Self> {\n+        let path = match type_ref {\n+            TypeRef::Path(path) => path,\n+            _ => return None,\n+        };\n+        TraitRef::from_path(db, resolver, path, explicit_self_ty)\n+    }\n+\n     fn substs_from_path(\n         db: &impl HirDatabase,\n         resolver: &Resolver,\n@@ -246,6 +256,15 @@ impl TraitRef {\n         let substs = Substs::identity(&trait_.generic_params(db));\n         TraitRef { trait_, substs }\n     }\n+\n+    pub(crate) fn for_where_predicate(\n+        db: &impl HirDatabase,\n+        resolver: &Resolver,\n+        pred: &WherePredicate,\n+    ) -> Option<TraitRef> {\n+        let self_ty = Ty::from_hir(db, resolver, &pred.type_ref);\n+        TraitRef::from_path(db, resolver, &pred.trait_ref, Some(self_ty))\n+    }\n }\n \n /// Build the declared type of an item. This depends on the namespace; e.g. for\n@@ -294,6 +313,24 @@ pub(crate) fn type_for_field(db: &impl HirDatabase, field: StructField) -> Ty {\n     Ty::from_hir(db, &resolver, type_ref)\n }\n \n+/// Resolve the where clause(s) of an item with generics.\n+pub(crate) fn generic_predicates(\n+    db: &impl HirDatabase,\n+    def: GenericDef,\n+) -> Arc<[GenericPredicate]> {\n+    let resolver = def.resolver(db);\n+    let generic_params = def.generic_params(db);\n+    let predicates = generic_params\n+        .where_predicates\n+        .iter()\n+        .map(|pred| {\n+            TraitRef::for_where_predicate(db, &resolver, pred)\n+                .map_or(GenericPredicate::Error, GenericPredicate::Implemented)\n+        })\n+        .collect::<Vec<_>>();\n+    predicates.into()\n+}\n+\n fn fn_sig_for_fn(db: &impl HirDatabase, def: Function) -> FnSig {\n     let signature = def.signature(db);\n     let resolver = def.resolver(db);"}, {"sha": "59c85daed7e43e9dfb50cb99e9549449be31ec28", "filename": "crates/ra_hir/src/ty/tests.rs", "status": "modified", "additions": 128, "deletions": 3, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/1944fc2c2b9ed5d9414afbc1b167e628d6e4e7f9/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1944fc2c2b9ed5d9414afbc1b167e628d6e4e7f9/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs?ref=1944fc2c2b9ed5d9414afbc1b167e628d6e4e7f9", "patch": "@@ -2501,6 +2501,21 @@ fn test() { (&S).foo()<|>; }\n     assert_eq!(t, \"u128\");\n }\n \n+#[test]\n+fn method_resolution_where_clause_for_unknown_trait() {\n+    // The blanket impl shouldn't apply because we can't even resolve UnknownTrait\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+trait Trait { fn foo(self) -> u128; }\n+struct S;\n+impl<T> Trait for T where T: UnknownTrait {}\n+fn test() { (&S).foo()<|>; }\n+\"#,\n+    );\n+    assert_eq!(t, \"{unknown}\");\n+}\n+\n #[test]\n fn method_resolution_where_clause_not_met() {\n     // The blanket impl shouldn't apply because we can't prove S: Clone\n@@ -2510,12 +2525,122 @@ fn method_resolution_where_clause_not_met() {\n trait Clone {}\n trait Trait { fn foo(self) -> u128; }\n struct S;\n-impl S { fn foo(self) -> i8 { 0 } }\n-impl<T> Trait for T where T: Clone { fn foo(self) -> u128 { 0 } }\n+impl<T> Trait for T where T: Clone {}\n fn test() { (&S).foo()<|>; }\n \"#,\n     );\n-    assert_eq!(t, \"i8\");\n+    // This is also to make sure that we don't resolve to the foo method just\n+    // because that's the only method named foo we can find, which would make\n+    // the below tests not work\n+    assert_eq!(t, \"{unknown}\");\n+}\n+\n+#[test]\n+fn method_resolution_where_clause_inline_not_met() {\n+    // The blanket impl shouldn't apply because we can't prove S: Clone\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+trait Clone {}\n+trait Trait { fn foo(self) -> u128; }\n+struct S;\n+impl<T: Clone> Trait for T {}\n+fn test() { (&S).foo()<|>; }\n+\"#,\n+    );\n+    assert_eq!(t, \"{unknown}\");\n+}\n+\n+#[test]\n+fn method_resolution_where_clause_1() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+trait Clone {}\n+trait Trait { fn foo(self) -> u128; }\n+struct S;\n+impl Clone for S {};\n+impl<T> Trait for T where T: Clone {}\n+fn test() { S.foo()<|>; }\n+\"#,\n+    );\n+    assert_eq!(t, \"u128\");\n+}\n+\n+#[test]\n+fn method_resolution_where_clause_2() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+trait Into<T> { fn into(self) -> T; }\n+trait From<T> { fn from(other: T) -> Self; }\n+struct S1;\n+struct S2;\n+impl From<S2> for S1 {};\n+impl<T, U> Into<U> for T where U: From<T> {}\n+fn test() { S2.into()<|>; }\n+\"#,\n+    );\n+    assert_eq!(t, \"S1\");\n+}\n+\n+#[test]\n+fn method_resolution_where_clause_inline() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+trait Into<T> { fn into(self) -> T; }\n+trait From<T> { fn from(other: T) -> Self; }\n+struct S1;\n+struct S2;\n+impl From<S2> for S1 {};\n+impl<T, U: From<T>> Into<U> for T {}\n+fn test() { S2.into()<|>; }\n+\"#,\n+    );\n+    assert_eq!(t, \"S1\");\n+}\n+\n+#[test]\n+fn method_resolution_encountering_fn_type() {\n+    covers!(trait_resolution_on_fn_type);\n+    type_at(\n+        r#\"\n+//- /main.rs\n+fn foo() {}\n+trait FnOnce { fn call(self); }\n+fn test() { foo.call()<|>; }\n+\"#,\n+    );\n+}\n+\n+#[test]\n+fn method_resolution_slow() {\n+    // this can get quite slow if we set the solver size limit too high\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+trait Send {}\n+\n+struct S1; impl Send for S1;\n+struct S2; impl Send for S2;\n+struct U1;\n+\n+trait Trait { fn method(self); }\n+\n+struct X1<A, B> {}\n+impl<A, B> Send for X1<A, B> where A: Send, B: Send {}\n+\n+struct S<B, C> {}\n+\n+trait Fn {}\n+\n+impl<B, C> Trait for S<B, C> where C: Fn, B: Send {}\n+\n+fn test() { (S {}).method()<|>; }\n+\"#,\n+    );\n+    assert_eq!(t, \"{unknown}\");\n }\n \n fn type_at_pos(db: &MockDatabase, pos: FilePosition) -> String {"}, {"sha": "4260f7ef7477890b48523671867b2bdd2c85e0c7", "filename": "crates/ra_hir/src/ty/traits.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1944fc2c2b9ed5d9414afbc1b167e628d6e4e7f9/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1944fc2c2b9ed5d9414afbc1b167e628d6e4e7f9/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits.rs?ref=1944fc2c2b9ed5d9414afbc1b167e628d6e4e7f9", "patch": "@@ -14,6 +14,11 @@ mod chalk;\n \n pub(crate) type Solver = chalk_solve::Solver;\n \n+/// This controls the maximum size of types Chalk considers. If we set this too\n+/// high, we can run into slow edge cases; if we set it too low, Chalk won't\n+/// find some solutions.\n+const CHALK_SOLVER_MAX_SIZE: usize = 2;\n+\n #[derive(Debug, Copy, Clone)]\n struct ChalkContext<'a, DB> {\n     db: &'a DB,\n@@ -22,7 +27,8 @@ struct ChalkContext<'a, DB> {\n \n pub(crate) fn solver(_db: &impl HirDatabase, _krate: Crate) -> Arc<Mutex<Solver>> {\n     // krate parameter is just so we cache a unique solver per crate\n-    let solver_choice = chalk_solve::SolverChoice::SLG { max_size: 10 };\n+    let solver_choice = chalk_solve::SolverChoice::SLG { max_size: CHALK_SOLVER_MAX_SIZE };\n+    debug!(\"Creating new solver for crate {:?}\", _krate);\n     Arc::new(Mutex::new(solver_choice.into_solver()))\n }\n \n@@ -53,6 +59,7 @@ fn solve(\n ) -> Option<chalk_solve::Solution> {\n     let context = ChalkContext { db, krate };\n     let solver = db.solver(krate);\n+    debug!(\"solve goal: {:?}\", goal);\n     let solution = solver.lock().unwrap().solve(&context, goal);\n     debug!(\"solve({:?}) => {:?}\", goal, solution);\n     solution"}, {"sha": "027c5ec4c3c7e377631a36989672ba5864059321", "filename": "crates/ra_hir/src/ty/traits/chalk.rs", "status": "modified", "additions": 129, "deletions": 21, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/1944fc2c2b9ed5d9414afbc1b167e628d6e4e7f9/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits%2Fchalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1944fc2c2b9ed5d9414afbc1b167e628d6e4e7f9/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits%2Fchalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits%2Fchalk.rs?ref=1944fc2c2b9ed5d9414afbc1b167e628d6e4e7f9", "patch": "@@ -6,15 +6,22 @@ use log::debug;\n use chalk_ir::{TypeId, ImplId, TypeKindId, ProjectionTy, Parameter, Identifier, cast::Cast, PlaceholderIndex, UniverseIndex, TypeName};\n use chalk_rust_ir::{AssociatedTyDatum, TraitDatum, StructDatum, ImplDatum};\n \n+use test_utils::tested_by;\n use ra_db::salsa::{InternId, InternKey};\n \n use crate::{\n     Trait, HasGenericParams, ImplBlock,\n     db::HirDatabase,\n-    ty::{TraitRef, Ty, ApplicationTy, TypeCtor, Substs},\n+    ty::{TraitRef, Ty, ApplicationTy, TypeCtor, Substs, GenericPredicate, CallableDef},\n+    ty::display::HirDisplay,\n+    generics::GenericDef,\n };\n use super::ChalkContext;\n \n+/// This represents a trait whose name we could not resolve.\n+const UNKNOWN_TRAIT: chalk_ir::TraitId =\n+    chalk_ir::TraitId(chalk_ir::RawId { index: u32::max_value() });\n+\n pub(super) trait ToChalk {\n     type Chalk;\n     fn to_chalk(self, db: &impl HirDatabase) -> Self::Chalk;\n@@ -45,7 +52,10 @@ impl ToChalk for Ty {\n             Ty::Infer(_infer_ty) => panic!(\"uncanonicalized infer ty\"),\n             // FIXME this is clearly incorrect, but probably not too incorrect\n             // and I'm not sure what to actually do with Ty::Unknown\n-            Ty::Unknown => PlaceholderIndex { ui: UniverseIndex::ROOT, idx: 0 }.to_ty(),\n+            // maybe an alternative would be `for<T> T`? (meaningless in rust, but expressible in chalk's Ty)\n+            Ty::Unknown => {\n+                PlaceholderIndex { ui: UniverseIndex::ROOT, idx: usize::max_value() }.to_ty()\n+            }\n         }\n     }\n     fn from_chalk(db: &impl HirDatabase, chalk: chalk_ir::Ty) -> Self {\n@@ -146,13 +156,53 @@ impl ToChalk for ImplBlock {\n     }\n }\n \n+impl ToChalk for GenericPredicate {\n+    type Chalk = chalk_ir::QuantifiedWhereClause;\n+\n+    fn to_chalk(self, db: &impl HirDatabase) -> chalk_ir::QuantifiedWhereClause {\n+        match self {\n+            GenericPredicate::Implemented(trait_ref) => {\n+                make_binders(chalk_ir::WhereClause::Implemented(trait_ref.to_chalk(db)), 0)\n+            }\n+            GenericPredicate::Error => {\n+                let impossible_trait_ref = chalk_ir::TraitRef {\n+                    trait_id: UNKNOWN_TRAIT,\n+                    parameters: vec![Ty::Unknown.to_chalk(db).cast()],\n+                };\n+                make_binders(chalk_ir::WhereClause::Implemented(impossible_trait_ref), 0)\n+            }\n+        }\n+    }\n+\n+    fn from_chalk(\n+        _db: &impl HirDatabase,\n+        _where_clause: chalk_ir::QuantifiedWhereClause,\n+    ) -> GenericPredicate {\n+        // This should never need to be called\n+        unimplemented!()\n+    }\n+}\n+\n fn make_binders<T>(value: T, num_vars: usize) -> chalk_ir::Binders<T> {\n     chalk_ir::Binders {\n         value,\n         binders: std::iter::repeat(chalk_ir::ParameterKind::Ty(())).take(num_vars).collect(),\n     }\n }\n \n+fn convert_where_clauses(\n+    db: &impl HirDatabase,\n+    def: GenericDef,\n+    substs: &Substs,\n+) -> Vec<chalk_ir::QuantifiedWhereClause> {\n+    let generic_predicates = db.generic_predicates(def);\n+    let mut result = Vec::with_capacity(generic_predicates.len());\n+    for pred in generic_predicates.iter() {\n+        result.push(pred.clone().subst(substs).to_chalk(db));\n+    }\n+    result\n+}\n+\n impl<'a, DB> chalk_solve::RustIrDatabase for ChalkContext<'a, DB>\n where\n     DB: HirDatabase,\n@@ -162,18 +212,35 @@ where\n     }\n     fn trait_datum(&self, trait_id: chalk_ir::TraitId) -> Arc<TraitDatum> {\n         debug!(\"trait_datum {:?}\", trait_id);\n+        if trait_id == UNKNOWN_TRAIT {\n+            let trait_datum_bound = chalk_rust_ir::TraitDatumBound {\n+                trait_ref: chalk_ir::TraitRef {\n+                    trait_id: UNKNOWN_TRAIT,\n+                    parameters: vec![chalk_ir::Ty::BoundVar(0).cast()],\n+                },\n+                associated_ty_ids: Vec::new(),\n+                where_clauses: Vec::new(),\n+                flags: chalk_rust_ir::TraitFlags {\n+                    auto: false,\n+                    marker: false,\n+                    upstream: true,\n+                    fundamental: false,\n+                },\n+            };\n+            return Arc::new(TraitDatum { binders: make_binders(trait_datum_bound, 1) });\n+        }\n         let trait_: Trait = from_chalk(self.db, trait_id);\n         let generic_params = trait_.generic_params(self.db);\n         let bound_vars = Substs::bound_vars(&generic_params);\n         let trait_ref = trait_.trait_ref(self.db).subst(&bound_vars).to_chalk(self.db);\n         let flags = chalk_rust_ir::TraitFlags {\n+            auto: trait_.is_auto(self.db),\n+            upstream: trait_.module(self.db).krate(self.db) != Some(self.krate),\n             // FIXME set these flags correctly\n-            auto: false,\n             marker: false,\n-            upstream: trait_.module(self.db).krate(self.db) != Some(self.krate),\n             fundamental: false,\n         };\n-        let where_clauses = Vec::new(); // FIXME add where clauses\n+        let where_clauses = convert_where_clauses(self.db, trait_.into(), &bound_vars);\n         let associated_ty_ids = Vec::new(); // FIXME add associated tys\n         let trait_datum_bound =\n             chalk_rust_ir::TraitDatumBound { trait_ref, where_clauses, flags, associated_ty_ids };\n@@ -185,21 +252,48 @@ where\n         let type_ctor = from_chalk(self.db, struct_id);\n         // FIXME might be nicer if we can create a fake GenericParams for the TypeCtor\n         // FIXME extract this to a method on Ty\n-        let (num_params, upstream) = match type_ctor {\n+        let (num_params, where_clauses, upstream) = match type_ctor {\n             TypeCtor::Bool\n             | TypeCtor::Char\n             | TypeCtor::Int(_)\n             | TypeCtor::Float(_)\n             | TypeCtor::Never\n-            | TypeCtor::Str => (0, true),\n-            TypeCtor::Slice | TypeCtor::Array | TypeCtor::RawPtr(_) | TypeCtor::Ref(_) => (1, true),\n-            TypeCtor::FnPtr { num_args } => (num_args as usize + 1, true),\n-            TypeCtor::Tuple { cardinality } => (cardinality as usize, true),\n-            TypeCtor::FnDef(_) => unimplemented!(),\n+            | TypeCtor::Str => (0, vec![], true),\n+            TypeCtor::Slice | TypeCtor::Array | TypeCtor::RawPtr(_) | TypeCtor::Ref(_) => {\n+                (1, vec![], true)\n+            }\n+            TypeCtor::FnPtr { num_args } => (num_args as usize + 1, vec![], true),\n+            TypeCtor::Tuple { cardinality } => (cardinality as usize, vec![], true),\n+            TypeCtor::FnDef(callable) => {\n+                tested_by!(trait_resolution_on_fn_type);\n+                let krate = match callable {\n+                    CallableDef::Function(f) => f.module(self.db).krate(self.db),\n+                    CallableDef::Struct(s) => s.module(self.db).krate(self.db),\n+                    CallableDef::EnumVariant(v) => {\n+                        v.parent_enum(self.db).module(self.db).krate(self.db)\n+                    }\n+                };\n+                let generic_def: GenericDef = match callable {\n+                    CallableDef::Function(f) => f.into(),\n+                    CallableDef::Struct(s) => s.into(),\n+                    CallableDef::EnumVariant(v) => v.parent_enum(self.db).into(),\n+                };\n+                let generic_params = generic_def.generic_params(self.db);\n+                let bound_vars = Substs::bound_vars(&generic_params);\n+                let where_clauses = convert_where_clauses(self.db, generic_def, &bound_vars);\n+                (\n+                    generic_params.count_params_including_parent(),\n+                    where_clauses,\n+                    krate != Some(self.krate),\n+                )\n+            }\n             TypeCtor::Adt(adt) => {\n                 let generic_params = adt.generic_params(self.db);\n+                let bound_vars = Substs::bound_vars(&generic_params);\n+                let where_clauses = convert_where_clauses(self.db, adt.into(), &bound_vars);\n                 (\n                     generic_params.count_params_including_parent(),\n+                    where_clauses,\n                     adt.krate(self.db) != Some(self.krate),\n                 )\n             }\n@@ -209,7 +303,6 @@ where\n             // FIXME set fundamental flag correctly\n             fundamental: false,\n         };\n-        let where_clauses = Vec::new(); // FIXME add where clauses\n         let self_ty = chalk_ir::ApplicationTy {\n             name: TypeName::TypeKindId(type_ctor.to_chalk(self.db).into()),\n             parameters: (0..num_params).map(|i| chalk_ir::Ty::BoundVar(i).cast()).collect(),\n@@ -237,10 +330,23 @@ where\n         } else {\n             chalk_rust_ir::ImplType::External\n         };\n+        let where_clauses = convert_where_clauses(self.db, impl_block.into(), &bound_vars);\n+        let negative = impl_block.is_negative(self.db);\n+        debug!(\n+            \"impl {:?}: {}{} where {:?}\",\n+            impl_id,\n+            if negative { \"!\" } else { \"\" },\n+            trait_ref.display(self.db),\n+            where_clauses\n+        );\n+        let trait_ref = trait_ref.to_chalk(self.db);\n         let impl_datum_bound = chalk_rust_ir::ImplDatumBound {\n-            // FIXME handle negative impls (impl !Sync for Foo)\n-            trait_ref: chalk_rust_ir::PolarizedTraitRef::Positive(trait_ref.to_chalk(self.db)),\n-            where_clauses: Vec::new(),        // FIXME add where clauses\n+            trait_ref: if negative {\n+                chalk_rust_ir::PolarizedTraitRef::Negative(trait_ref)\n+            } else {\n+                chalk_rust_ir::PolarizedTraitRef::Positive(trait_ref)\n+            },\n+            where_clauses,\n             associated_ty_values: Vec::new(), // FIXME add associated type values\n             impl_type,\n         };\n@@ -249,16 +355,18 @@ where\n     }\n     fn impls_for_trait(&self, trait_id: chalk_ir::TraitId) -> Vec<ImplId> {\n         debug!(\"impls_for_trait {:?}\", trait_id);\n+        if trait_id == UNKNOWN_TRAIT {\n+            return Vec::new();\n+        }\n         let trait_ = from_chalk(self.db, trait_id);\n-        self.db\n+        let result: Vec<_> = self\n+            .db\n             .impls_for_trait(self.krate, trait_)\n             .iter()\n-            // FIXME temporary hack -- as long as we're not lowering where clauses\n-            // correctly, ignore impls with them completely so as to not treat\n-            // impl<T> Trait for T where T: ... as a blanket impl on all types\n-            .filter(|impl_block| impl_block.generic_params(self.db).where_predicates.is_empty())\n             .map(|impl_block| impl_block.to_chalk(self.db))\n-            .collect()\n+            .collect();\n+        debug!(\"impls_for_trait returned {} impls\", result.len());\n+        result\n     }\n     fn impl_provided_for(\n         &self,"}, {"sha": "f3466c585ba06cb27a2d693f82e41cfe6dcce1bf", "filename": "crates/ra_syntax/src/ast/extensions.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1944fc2c2b9ed5d9414afbc1b167e628d6e4e7f9/crates%2Fra_syntax%2Fsrc%2Fast%2Fextensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1944fc2c2b9ed5d9414afbc1b167e628d6e4e7f9/crates%2Fra_syntax%2Fsrc%2Fast%2Fextensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fextensions.rs?ref=1944fc2c2b9ed5d9414afbc1b167e628d6e4e7f9", "patch": "@@ -170,6 +170,10 @@ impl ast::ImplBlock {\n         let second = types.next();\n         (first, second)\n     }\n+\n+    pub fn is_negative(&self) -> bool {\n+        self.syntax().children_with_tokens().any(|t| t.kind() == EXCL)\n+    }\n }\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n@@ -348,3 +352,9 @@ impl ast::WherePred {\n             .find(|it| it.kind() == LIFETIME)\n     }\n }\n+\n+impl ast::TraitDef {\n+    pub fn is_auto(&self) -> bool {\n+        self.syntax().children_with_tokens().any(|t| t.kind() == AUTO_KW)\n+    }\n+}"}]}