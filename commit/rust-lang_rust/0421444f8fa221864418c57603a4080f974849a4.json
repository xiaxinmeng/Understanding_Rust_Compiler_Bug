{"sha": "0421444f8fa221864418c57603a4080f974849a4", "node_id": "C_kwDOAAsO6NoAKDA0MjE0NDRmOGZhMjIxODY0NDE4YzU3NjAzYTQwODBmOTc0ODQ5YTQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-09-03T04:19:00Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-09-03T04:19:00Z"}, "message": "Auto merge of #101139 - nnethercote:shrink-thir-Pat, r=cjgillot\n\nShrink `thir::Pat`\n\nr? `@cjgillot`", "tree": {"sha": "fd0c2dbe246cea423aaf171beea7e3c5d84604c0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fd0c2dbe246cea423aaf171beea7e3c5d84604c0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0421444f8fa221864418c57603a4080f974849a4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0421444f8fa221864418c57603a4080f974849a4", "html_url": "https://github.com/rust-lang/rust/commit/0421444f8fa221864418c57603a4080f974849a4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0421444f8fa221864418c57603a4080f974849a4/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0209485578807b8084127f12d57771300edff87a", "url": "https://api.github.com/repos/rust-lang/rust/commits/0209485578807b8084127f12d57771300edff87a", "html_url": "https://github.com/rust-lang/rust/commit/0209485578807b8084127f12d57771300edff87a"}, {"sha": "43a0268f3a28fa53ad8290720002984cff785224", "url": "https://api.github.com/repos/rust-lang/rust/commits/43a0268f3a28fa53ad8290720002984cff785224", "html_url": "https://github.com/rust-lang/rust/commit/43a0268f3a28fa53ad8290720002984cff785224"}], "stats": {"total": 386, "additions": 205, "deletions": 181}, "files": [{"sha": "59e14337f4ed86a55fc92120be7c81c5c06aa261", "filename": "compiler/rustc_middle/src/thir.rs", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/0421444f8fa221864418c57603a4080f974849a4/compiler%2Frustc_middle%2Fsrc%2Fthir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0421444f8fa221864418c57603a4080f974849a4/compiler%2Frustc_middle%2Fsrc%2Fthir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fthir.rs?ref=0421444f8fa221864418c57603a4080f974849a4", "patch": "@@ -180,7 +180,7 @@ pub enum StmtKind<'tcx> {\n         /// `let <PAT> = ...`\n         ///\n         /// If a type annotation is included, it is added as an ascription pattern.\n-        pattern: Pat<'tcx>,\n+        pattern: Box<Pat<'tcx>>,\n \n         /// `let pat: ty = <INIT>`\n         initializer: Option<ExprId>,\n@@ -301,7 +301,7 @@ pub enum ExprKind<'tcx> {\n     },\n     Let {\n         expr: ExprId,\n-        pat: Pat<'tcx>,\n+        pat: Box<Pat<'tcx>>,\n     },\n     /// A `match` expression.\n     Match {\n@@ -467,7 +467,7 @@ pub struct FruInfo<'tcx> {\n /// A `match` arm.\n #[derive(Clone, Debug, HashStable)]\n pub struct Arm<'tcx> {\n-    pub pattern: Pat<'tcx>,\n+    pub pattern: Box<Pat<'tcx>>,\n     pub guard: Option<Guard<'tcx>>,\n     pub body: ExprId,\n     pub lint_level: LintLevel,\n@@ -479,7 +479,7 @@ pub struct Arm<'tcx> {\n #[derive(Clone, Debug, HashStable)]\n pub enum Guard<'tcx> {\n     If(ExprId),\n-    IfLet(Pat<'tcx>, ExprId),\n+    IfLet(Box<Pat<'tcx>>, ExprId),\n }\n \n #[derive(Copy, Clone, Debug, HashStable)]\n@@ -534,19 +534,19 @@ pub enum BindingMode {\n #[derive(Clone, Debug, HashStable)]\n pub struct FieldPat<'tcx> {\n     pub field: Field,\n-    pub pattern: Pat<'tcx>,\n+    pub pattern: Box<Pat<'tcx>>,\n }\n \n #[derive(Clone, Debug, HashStable)]\n pub struct Pat<'tcx> {\n     pub ty: Ty<'tcx>,\n     pub span: Span,\n-    pub kind: Box<PatKind<'tcx>>,\n+    pub kind: PatKind<'tcx>,\n }\n \n impl<'tcx> Pat<'tcx> {\n     pub fn wildcard_from_ty(ty: Ty<'tcx>) -> Self {\n-        Pat { ty, span: DUMMY_SP, kind: Box::new(PatKind::Wild) }\n+        Pat { ty, span: DUMMY_SP, kind: PatKind::Wild }\n     }\n }\n \n@@ -581,7 +581,7 @@ pub enum PatKind<'tcx> {\n \n     AscribeUserType {\n         ascription: Ascription<'tcx>,\n-        subpattern: Pat<'tcx>,\n+        subpattern: Box<Pat<'tcx>>,\n     },\n \n     /// `x`, `ref x`, `x @ P`, etc.\n@@ -591,7 +591,7 @@ pub enum PatKind<'tcx> {\n         mode: BindingMode,\n         var: LocalVarId,\n         ty: Ty<'tcx>,\n-        subpattern: Option<Pat<'tcx>>,\n+        subpattern: Option<Box<Pat<'tcx>>>,\n         /// Is this the leftmost occurrence of the binding, i.e., is `var` the\n         /// `HirId` of this pattern?\n         is_primary: bool,\n@@ -614,7 +614,7 @@ pub enum PatKind<'tcx> {\n \n     /// `box P`, `&P`, `&mut P`, etc.\n     Deref {\n-        subpattern: Pat<'tcx>,\n+        subpattern: Box<Pat<'tcx>>,\n     },\n \n     /// One of the following:\n@@ -628,32 +628,32 @@ pub enum PatKind<'tcx> {\n         value: mir::ConstantKind<'tcx>,\n     },\n \n-    Range(PatRange<'tcx>),\n+    Range(Box<PatRange<'tcx>>),\n \n     /// Matches against a slice, checking the length and extracting elements.\n     /// irrefutable when there is a slice pattern and both `prefix` and `suffix` are empty.\n     /// e.g., `&[ref xs @ ..]`.\n     Slice {\n-        prefix: Vec<Pat<'tcx>>,\n-        slice: Option<Pat<'tcx>>,\n-        suffix: Vec<Pat<'tcx>>,\n+        prefix: Box<[Box<Pat<'tcx>>]>,\n+        slice: Option<Box<Pat<'tcx>>>,\n+        suffix: Box<[Box<Pat<'tcx>>]>,\n     },\n \n     /// Fixed match against an array; irrefutable.\n     Array {\n-        prefix: Vec<Pat<'tcx>>,\n-        slice: Option<Pat<'tcx>>,\n-        suffix: Vec<Pat<'tcx>>,\n+        prefix: Box<[Box<Pat<'tcx>>]>,\n+        slice: Option<Box<Pat<'tcx>>>,\n+        suffix: Box<[Box<Pat<'tcx>>]>,\n     },\n \n     /// An or-pattern, e.g. `p | q`.\n     /// Invariant: `pats.len() >= 2`.\n     Or {\n-        pats: Vec<Pat<'tcx>>,\n+        pats: Box<[Box<Pat<'tcx>>]>,\n     },\n }\n \n-#[derive(Copy, Clone, Debug, PartialEq, HashStable)]\n+#[derive(Clone, Debug, PartialEq, HashStable)]\n pub struct PatRange<'tcx> {\n     pub lo: mir::ConstantKind<'tcx>,\n     pub hi: mir::ConstantKind<'tcx>,\n@@ -674,7 +674,7 @@ impl<'tcx> fmt::Display for Pat<'tcx> {\n         };\n         let mut start_or_comma = || start_or_continue(\", \");\n \n-        match *self.kind {\n+        match self.kind {\n             PatKind::Wild => write!(f, \"_\"),\n             PatKind::AscribeUserType { ref subpattern, .. } => write!(f, \"{}: _\", subpattern),\n             PatKind::Binding { mutability, name, mode, ref subpattern, .. } => {\n@@ -695,7 +695,7 @@ impl<'tcx> fmt::Display for Pat<'tcx> {\n                 Ok(())\n             }\n             PatKind::Variant { ref subpatterns, .. } | PatKind::Leaf { ref subpatterns } => {\n-                let variant = match *self.kind {\n+                let variant = match self.kind {\n                     PatKind::Variant { adt_def, variant_index, .. } => {\n                         Some(adt_def.variant(variant_index))\n                     }\n@@ -714,7 +714,7 @@ impl<'tcx> fmt::Display for Pat<'tcx> {\n \n                         let mut printed = 0;\n                         for p in subpatterns {\n-                            if let PatKind::Wild = *p.pattern.kind {\n+                            if let PatKind::Wild = p.pattern.kind {\n                                 continue;\n                             }\n                             let name = variant.fields[p.field.index()].name;\n@@ -767,32 +767,32 @@ impl<'tcx> fmt::Display for Pat<'tcx> {\n                 write!(f, \"{}\", subpattern)\n             }\n             PatKind::Constant { value } => write!(f, \"{}\", value),\n-            PatKind::Range(PatRange { lo, hi, end }) => {\n+            PatKind::Range(box PatRange { lo, hi, end }) => {\n                 write!(f, \"{}\", lo)?;\n                 write!(f, \"{}\", end)?;\n                 write!(f, \"{}\", hi)\n             }\n             PatKind::Slice { ref prefix, ref slice, ref suffix }\n             | PatKind::Array { ref prefix, ref slice, ref suffix } => {\n                 write!(f, \"[\")?;\n-                for p in prefix {\n+                for p in prefix.iter() {\n                     write!(f, \"{}{}\", start_or_comma(), p)?;\n                 }\n                 if let Some(ref slice) = *slice {\n                     write!(f, \"{}\", start_or_comma())?;\n-                    match *slice.kind {\n+                    match slice.kind {\n                         PatKind::Wild => {}\n                         _ => write!(f, \"{}\", slice)?,\n                     }\n                     write!(f, \"..\")?;\n                 }\n-                for p in suffix {\n+                for p in suffix.iter() {\n                     write!(f, \"{}{}\", start_or_comma(), p)?;\n                 }\n                 write!(f, \"]\")\n             }\n             PatKind::Or { ref pats } => {\n-                for pat in pats {\n+                for pat in pats.iter() {\n                     write!(f, \"{}{}\", start_or_continue(\" | \"), pat)?;\n                 }\n                 Ok(())\n@@ -809,8 +809,8 @@ mod size_asserts {\n     static_assert_size!(Block, 56);\n     static_assert_size!(Expr<'_>, 64);\n     static_assert_size!(ExprKind<'_>, 40);\n-    static_assert_size!(Pat<'_>, 24);\n-    static_assert_size!(PatKind<'_>, 112);\n-    static_assert_size!(Stmt<'_>, 72);\n-    static_assert_size!(StmtKind<'_>, 64);\n+    static_assert_size!(Pat<'_>, 72);\n+    static_assert_size!(PatKind<'_>, 56);\n+    static_assert_size!(Stmt<'_>, 56);\n+    static_assert_size!(StmtKind<'_>, 48);\n }"}, {"sha": "79a0e75aa7c788b6923047908692c748a3f8b417", "filename": "compiler/rustc_middle/src/thir/visit.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0421444f8fa221864418c57603a4080f974849a4/compiler%2Frustc_middle%2Fsrc%2Fthir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0421444f8fa221864418c57603a4080f974849a4/compiler%2Frustc_middle%2Fsrc%2Fthir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fthir%2Fvisit.rs?ref=0421444f8fa221864418c57603a4080f974849a4", "patch": "@@ -211,7 +211,7 @@ pub fn walk_arm<'a, 'tcx: 'a, V: Visitor<'a, 'tcx>>(visitor: &mut V, arm: &Arm<'\n \n pub fn walk_pat<'a, 'tcx: 'a, V: Visitor<'a, 'tcx>>(visitor: &mut V, pat: &Pat<'tcx>) {\n     use PatKind::*;\n-    match pat.kind.as_ref() {\n+    match &pat.kind {\n         AscribeUserType { subpattern, ascription: _ }\n         | Deref { subpattern }\n         | Binding {\n@@ -232,18 +232,18 @@ pub fn walk_pat<'a, 'tcx: 'a, V: Visitor<'a, 'tcx>>(visitor: &mut V, pat: &Pat<'\n         Constant { value: _ } => {}\n         Range(_) => {}\n         Slice { prefix, slice, suffix } | Array { prefix, slice, suffix } => {\n-            for subpattern in prefix {\n+            for subpattern in prefix.iter() {\n                 visitor.visit_pat(&subpattern);\n             }\n             if let Some(pat) = slice {\n-                visitor.visit_pat(pat);\n+                visitor.visit_pat(&pat);\n             }\n-            for subpattern in suffix {\n+            for subpattern in suffix.iter() {\n                 visitor.visit_pat(&subpattern);\n             }\n         }\n         Or { pats } => {\n-            for pat in pats {\n+            for pat in pats.iter() {\n                 visitor.visit_pat(&pat);\n             }\n         }"}, {"sha": "262d59f8ff8a78963c95f2fbe60717215e465ebd", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0421444f8fa221864418c57603a4080f974849a4/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0421444f8fa221864418c57603a4080f974849a4/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=0421444f8fa221864418c57603a4080f974849a4", "patch": "@@ -874,7 +874,7 @@ pub type CanonicalUserTypeAnnotations<'tcx> =\n \n #[derive(Clone, Debug, TyEncodable, TyDecodable, HashStable, TypeFoldable, TypeVisitable, Lift)]\n pub struct CanonicalUserTypeAnnotation<'tcx> {\n-    pub user_ty: CanonicalUserType<'tcx>,\n+    pub user_ty: Box<CanonicalUserType<'tcx>>,\n     pub span: Span,\n     pub inferred_ty: Ty<'tcx>,\n }"}, {"sha": "c8d4a1bf2c9e7eeb4ae48231f80208b6aeb8287c", "filename": "compiler/rustc_mir_build/src/build/block.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0421444f8fa221864418c57603a4080f974849a4/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0421444f8fa221864418c57603a4080f974849a4/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fblock.rs?ref=0421444f8fa221864418c57603a4080f974849a4", "patch": "@@ -117,7 +117,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     lint_level,\n                     else_block,\n                 } => {\n-                    let ignores_expr_result = matches!(*pattern.kind, PatKind::Wild);\n+                    let ignores_expr_result = matches!(pattern.kind, PatKind::Wild);\n                     this.block_context.push(BlockFrame::Statement { ignores_expr_result });\n \n                     // Enter the remainder scope, i.e., the bindings' destruction scope.\n@@ -160,7 +160,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                                                 ArmHasGuard(false),\n                                                 Some((None, initializer_span)),\n                                             );\n-                                            this.expr_into_pattern(block, pattern.clone(), init) // irrefutable pattern\n+                                            this.expr_into_pattern(block, pattern, init) // irrefutable pattern\n                                         }\n                                     })\n                                 },"}, {"sha": "3549b47478cbded136bc85a399c75439531a12e3", "filename": "compiler/rustc_mir_build/src/build/expr/as_constant.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0421444f8fa221864418c57603a4080f974849a4/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_constant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0421444f8fa221864418c57603a4080f974849a4/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_constant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_constant.rs?ref=0421444f8fa221864418c57603a4080f974849a4", "patch": "@@ -42,10 +42,10 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 Constant { span, user_ty: None, literal }\n             }\n             ExprKind::NonHirLiteral { lit, ref user_ty } => {\n-                let user_ty = user_ty.as_ref().map(|box user_ty| {\n+                let user_ty = user_ty.as_ref().map(|user_ty| {\n                     this.canonical_user_type_annotations.push(CanonicalUserTypeAnnotation {\n                         span,\n-                        user_ty: *user_ty,\n+                        user_ty: user_ty.clone(),\n                         inferred_ty: ty,\n                     })\n                 });\n@@ -54,10 +54,10 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 Constant { span, user_ty: user_ty, literal }\n             }\n             ExprKind::ZstLiteral { ref user_ty } => {\n-                let user_ty = user_ty.as_ref().map(|box user_ty| {\n+                let user_ty = user_ty.as_ref().map(|user_ty| {\n                     this.canonical_user_type_annotations.push(CanonicalUserTypeAnnotation {\n                         span,\n-                        user_ty: *user_ty,\n+                        user_ty: user_ty.clone(),\n                         inferred_ty: ty,\n                     })\n                 });\n@@ -66,10 +66,10 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 Constant { span, user_ty: user_ty, literal }\n             }\n             ExprKind::NamedConst { def_id, substs, ref user_ty } => {\n-                let user_ty = user_ty.as_ref().map(|box user_ty| {\n+                let user_ty = user_ty.as_ref().map(|user_ty| {\n                     this.canonical_user_type_annotations.push(CanonicalUserTypeAnnotation {\n                         span,\n-                        user_ty: *user_ty,\n+                        user_ty: user_ty.clone(),\n                         inferred_ty: ty,\n                     })\n                 });"}, {"sha": "46dbd8a136b52f1f10017e052c2bbcd68ffe0233", "filename": "compiler/rustc_mir_build/src/build/expr/as_place.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0421444f8fa221864418c57603a4080f974849a4/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0421444f8fa221864418c57603a4080f974849a4/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs?ref=0421444f8fa221864418c57603a4080f974849a4", "patch": "@@ -522,11 +522,11 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                         fake_borrow_temps,\n                     )\n                 );\n-                if let Some(box user_ty) = user_ty {\n+                if let Some(user_ty) = user_ty {\n                     let annotation_index =\n                         this.canonical_user_type_annotations.push(CanonicalUserTypeAnnotation {\n                             span: source_info.span,\n-                            user_ty: *user_ty,\n+                            user_ty: user_ty.clone(),\n                             inferred_ty: expr.ty,\n                         });\n \n@@ -551,11 +551,11 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 let source = &this.thir[source];\n                 let temp =\n                     unpack!(block = this.as_temp(block, source.temp_lifetime, source, mutability));\n-                if let Some(box user_ty) = user_ty {\n+                if let Some(user_ty) = user_ty {\n                     let annotation_index =\n                         this.canonical_user_type_annotations.push(CanonicalUserTypeAnnotation {\n                             span: source_info.span,\n-                            user_ty: *user_ty,\n+                            user_ty: user_ty.clone(),\n                             inferred_ty: expr.ty,\n                         });\n                     this.cfg.push("}, {"sha": "74509646c17c698f6ca4dc810b2d84447123938b", "filename": "compiler/rustc_mir_build/src/build/expr/into.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0421444f8fa221864418c57603a4080f974849a4/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0421444f8fa221864418c57603a4080f974849a4/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs?ref=0421444f8fa221864418c57603a4080f974849a4", "patch": "@@ -378,10 +378,10 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 };\n \n                 let inferred_ty = expr.ty;\n-                let user_ty = user_ty.as_ref().map(|box user_ty| {\n+                let user_ty = user_ty.as_ref().map(|user_ty| {\n                     this.canonical_user_type_annotations.push(CanonicalUserTypeAnnotation {\n                         span: source_info.span,\n-                        user_ty: *user_ty,\n+                        user_ty: user_ty.clone(),\n                         inferred_ty,\n                     })\n                 });"}, {"sha": "a316c2e7d6e187bf1d25a5b7da4c33543cf89695", "filename": "compiler/rustc_mir_build/src/build/matches/mod.rs", "status": "modified", "additions": 17, "deletions": 20, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/0421444f8fa221864418c57603a4080f974849a4/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0421444f8fa221864418c57603a4080f974849a4/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs?ref=0421444f8fa221864418c57603a4080f974849a4", "patch": "@@ -490,10 +490,10 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     pub(super) fn expr_into_pattern(\n         &mut self,\n         mut block: BasicBlock,\n-        irrefutable_pat: Pat<'tcx>,\n+        irrefutable_pat: &Pat<'tcx>,\n         initializer: &Expr<'tcx>,\n     ) -> BlockAnd<()> {\n-        match *irrefutable_pat.kind {\n+        match irrefutable_pat.kind {\n             // Optimize the case of `let x = ...` to write directly into `x`\n             PatKind::Binding { mode: BindingMode::ByValue, var, subpattern: None, .. } => {\n                 let place =\n@@ -518,17 +518,14 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             // broken.\n             PatKind::AscribeUserType {\n                 subpattern:\n-                    Pat {\n+                    box Pat {\n                         kind:\n-                            box PatKind::Binding {\n-                                mode: BindingMode::ByValue,\n-                                var,\n-                                subpattern: None,\n-                                ..\n+                            PatKind::Binding {\n+                                mode: BindingMode::ByValue, var, subpattern: None, ..\n                             },\n                         ..\n                     },\n-                ascription: thir::Ascription { annotation, variance: _ },\n+                ascription: thir::Ascription { ref annotation, variance: _ },\n             } => {\n                 let place =\n                     self.storage_live_binding(block, var, irrefutable_pat.span, OutsideGuard, true);\n@@ -541,7 +538,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n                 let ty_source_info = self.source_info(annotation.span);\n \n-                let base = self.canonical_user_type_annotations.push(annotation);\n+                let base = self.canonical_user_type_annotations.push(annotation.clone());\n                 self.cfg.push(\n                     block,\n                     Statement {\n@@ -581,7 +578,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     pub(crate) fn place_into_pattern(\n         &mut self,\n         block: BasicBlock,\n-        irrefutable_pat: Pat<'tcx>,\n+        irrefutable_pat: &Pat<'tcx>,\n         initializer: PlaceBuilder<'tcx>,\n         set_match_place: bool,\n     ) -> BlockAnd<()> {\n@@ -744,7 +741,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             \"visit_primary_bindings: pattern={:?} pattern_user_ty={:?}\",\n             pattern, pattern_user_ty\n         );\n-        match *pattern.kind {\n+        match pattern.kind {\n             PatKind::Binding {\n                 mutability,\n                 name,\n@@ -767,7 +764,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             | PatKind::Slice { ref prefix, ref slice, ref suffix } => {\n                 let from = u64::try_from(prefix.len()).unwrap();\n                 let to = u64::try_from(suffix.len()).unwrap();\n-                for subpattern in prefix {\n+                for subpattern in prefix.iter() {\n                     self.visit_primary_bindings(subpattern, pattern_user_ty.clone().index(), f);\n                 }\n                 for subpattern in slice {\n@@ -777,7 +774,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                         f,\n                     );\n                 }\n-                for subpattern in suffix {\n+                for subpattern in suffix.iter() {\n                     self.visit_primary_bindings(subpattern, pattern_user_ty.clone().index(), f);\n                 }\n             }\n@@ -830,7 +827,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 // may not all be in the leftmost subpattern. For example in\n                 // `let (x | y) = ...`, the primary binding of `y` occurs in\n                 // the right subpattern\n-                for subpattern in pats {\n+                for subpattern in pats.iter() {\n                     self.visit_primary_bindings(subpattern, pattern_user_ty.clone(), f);\n                 }\n             }\n@@ -982,7 +979,7 @@ enum TestKind<'tcx> {\n     },\n \n     /// Test whether the value falls within an inclusive or exclusive range\n-    Range(PatRange<'tcx>),\n+    Range(Box<PatRange<'tcx>>),\n \n     /// Test that the length of the slice is equal to `len`.\n     Len { len: u64, op: BinOp },\n@@ -1330,7 +1327,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n         // All of the or-patterns have been sorted to the end, so if the first\n         // pattern is an or-pattern we only have or-patterns.\n-        match *first_candidate.match_pairs[0].pattern.kind {\n+        match first_candidate.match_pairs[0].pattern.kind {\n             PatKind::Or { .. } => (),\n             _ => {\n                 self.test_candidates(\n@@ -1350,7 +1347,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n         let mut otherwise = None;\n         for match_pair in match_pairs {\n-            let PatKind::Or { ref pats } = &*match_pair.pattern.kind else {\n+            let PatKind::Or { ref pats } = &match_pair.pattern.kind else {\n                 bug!(\"Or-patterns should have been sorted to the end\");\n             };\n             let or_span = match_pair.pattern.span;\n@@ -1384,7 +1381,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         &mut self,\n         candidate: &mut Candidate<'pat, 'tcx>,\n         otherwise: &mut Option<BasicBlock>,\n-        pats: &'pat [Pat<'tcx>],\n+        pats: &'pat [Box<Pat<'tcx>>],\n         or_span: Span,\n         place: PlaceBuilder<'tcx>,\n         fake_borrows: &mut Option<FxIndexSet<Place<'tcx>>>,\n@@ -2289,7 +2286,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         let else_block_span = self.thir[else_block].span;\n         let (matching, failure) = self.in_if_then_scope(remainder_scope, |this| {\n             let scrutinee = unpack!(block = this.lower_scrutinee(block, init, initializer_span));\n-            let pat = Pat { ty: init.ty, span: else_block_span, kind: Box::new(PatKind::Wild) };\n+            let pat = Pat { ty: init.ty, span: else_block_span, kind: PatKind::Wild };\n             let mut wildcard = Candidate::new(scrutinee.clone(), &pat, false);\n             this.declare_bindings(\n                 visibility_scope,"}, {"sha": "55ed09da64fb866162cddda8d9d6809d360c6f5f", "filename": "compiler/rustc_mir_build/src/build/matches/simplify.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0421444f8fa221864418c57603a4080f974849a4/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0421444f8fa221864418c57603a4080f974849a4/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fsimplify.rs?ref=0421444f8fa221864418c57603a4080f974849a4", "patch": "@@ -67,7 +67,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         loop {\n             let match_pairs = mem::take(&mut candidate.match_pairs);\n \n-            if let [MatchPair { pattern: Pat { kind: box PatKind::Or { pats }, .. }, place }] =\n+            if let [MatchPair { pattern: Pat { kind: PatKind::Or { pats }, .. }, place }] =\n                 &*match_pairs\n             {\n                 existing_bindings.extend_from_slice(&new_bindings);\n@@ -113,7 +113,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 // late as possible.\n                 candidate\n                     .match_pairs\n-                    .sort_by_key(|pair| matches!(*pair.pattern.kind, PatKind::Or { .. }));\n+                    .sort_by_key(|pair| matches!(pair.pattern.kind, PatKind::Or { .. }));\n                 debug!(simplified = ?candidate, \"simplify_candidate\");\n                 return false; // if we were not able to simplify any, done.\n             }\n@@ -127,10 +127,10 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         &mut self,\n         candidate: &Candidate<'pat, 'tcx>,\n         place: PlaceBuilder<'tcx>,\n-        pats: &'pat [Pat<'tcx>],\n+        pats: &'pat [Box<Pat<'tcx>>],\n     ) -> Vec<Candidate<'pat, 'tcx>> {\n         pats.iter()\n-            .map(|pat| {\n+            .map(|box pat| {\n                 let mut candidate = Candidate::new(place.clone(), pat, candidate.has_guard);\n                 self.simplify_candidate(&mut candidate);\n                 candidate\n@@ -149,7 +149,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         candidate: &mut Candidate<'pat, 'tcx>,\n     ) -> Result<(), MatchPair<'pat, 'tcx>> {\n         let tcx = self.tcx;\n-        match *match_pair.pattern.kind {\n+        match match_pair.pattern.kind {\n             PatKind::AscribeUserType {\n                 ref subpattern,\n                 ascription: thir::Ascription { ref annotation, variance },\n@@ -208,7 +208,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 Err(match_pair)\n             }\n \n-            PatKind::Range(PatRange { lo, hi, end }) => {\n+            PatKind::Range(box PatRange { lo, hi, end }) => {\n                 let (range, bias) = match *lo.ty().kind() {\n                     ty::Char => {\n                         (Some(('\\u{0000}' as u128, '\\u{10FFFF}' as u128, Size::from_bits(32))), 0)\n@@ -254,7 +254,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                         &mut candidate.match_pairs,\n                         &match_pair.place,\n                         prefix,\n-                        slice.as_ref(),\n+                        slice,\n                         suffix,\n                     );\n                     Ok(())\n@@ -294,7 +294,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     &mut candidate.match_pairs,\n                     &match_pair.place,\n                     prefix,\n-                    slice.as_ref(),\n+                    slice,\n                     suffix,\n                 );\n                 Ok(())"}, {"sha": "19c303e0bab7400ba0d8e48552ccd0233db9dcc9", "filename": "compiler/rustc_mir_build/src/build/matches/test.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/0421444f8fa221864418c57603a4080f974849a4/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0421444f8fa221864418c57603a4080f974849a4/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs?ref=0421444f8fa221864418c57603a4080f974849a4", "patch": "@@ -29,7 +29,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     ///\n     /// It is a bug to call this with a not-fully-simplified pattern.\n     pub(super) fn test<'pat>(&mut self, match_pair: &MatchPair<'pat, 'tcx>) -> Test<'tcx> {\n-        match *match_pair.pattern.kind {\n+        match match_pair.pattern.kind {\n             PatKind::Variant { adt_def, substs: _, variant_index: _, subpatterns: _ } => Test {\n                 span: match_pair.pattern.span,\n                 kind: TestKind::Switch {\n@@ -58,10 +58,10 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 kind: TestKind::Eq { value, ty: match_pair.pattern.ty },\n             },\n \n-            PatKind::Range(range) => {\n+            PatKind::Range(ref range) => {\n                 assert_eq!(range.lo.ty(), match_pair.pattern.ty);\n                 assert_eq!(range.hi.ty(), match_pair.pattern.ty);\n-                Test { span: match_pair.pattern.span, kind: TestKind::Range(range) }\n+                Test { span: match_pair.pattern.span, kind: TestKind::Range(range.clone()) }\n             }\n \n             PatKind::Slice { ref prefix, ref slice, ref suffix } => {\n@@ -92,7 +92,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             return false;\n         };\n \n-        match *match_pair.pattern.kind {\n+        match match_pair.pattern.kind {\n             PatKind::Constant { value } => {\n                 options\n                     .entry(value)\n@@ -102,9 +102,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             PatKind::Variant { .. } => {\n                 panic!(\"you should have called add_variants_to_switch instead!\");\n             }\n-            PatKind::Range(range) => {\n+            PatKind::Range(ref range) => {\n                 // Check that none of the switch values are in the range.\n-                self.values_not_contained_in_range(range, options).unwrap_or(false)\n+                self.values_not_contained_in_range(&*range, options).unwrap_or(false)\n             }\n             PatKind::Slice { .. }\n             | PatKind::Array { .. }\n@@ -130,7 +130,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             return false;\n         };\n \n-        match *match_pair.pattern.kind {\n+        match match_pair.pattern.kind {\n             PatKind::Variant { adt_def: _, variant_index, .. } => {\n                 // We have a pattern testing for variant `variant_index`\n                 // set the corresponding index to true\n@@ -272,7 +272,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 }\n             }\n \n-            TestKind::Range(PatRange { lo, hi, ref end }) => {\n+            TestKind::Range(box PatRange { lo, hi, ref end }) => {\n                 let lower_bound_success = self.cfg.start_new_block();\n                 let target_blocks = make_target_blocks(self);\n \n@@ -506,7 +506,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         let (match_pair_index, match_pair) =\n             candidate.match_pairs.iter().enumerate().find(|&(_, mp)| mp.place == *test_place)?;\n \n-        match (&test.kind, &*match_pair.pattern.kind) {\n+        match (&test.kind, &match_pair.pattern.kind) {\n             // If we are performing a variant switch, then this\n             // informs variant patterns, but nothing else.\n             (\n@@ -540,9 +540,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 Some(index)\n             }\n \n-            (&TestKind::SwitchInt { switch_ty: _, ref options }, &PatKind::Range(range)) => {\n+            (&TestKind::SwitchInt { switch_ty: _, ref options }, &PatKind::Range(ref range)) => {\n                 let not_contained =\n-                    self.values_not_contained_in_range(range, options).unwrap_or(false);\n+                    self.values_not_contained_in_range(&*range, options).unwrap_or(false);\n \n                 if not_contained {\n                     // No switch values are contained in the pattern range,\n@@ -569,7 +569,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                             match_pair_index,\n                             candidate,\n                             prefix,\n-                            slice.as_ref(),\n+                            slice,\n                             suffix,\n                         );\n                         Some(0)\n@@ -607,7 +607,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                             match_pair_index,\n                             candidate,\n                             prefix,\n-                            slice.as_ref(),\n+                            slice,\n                             suffix,\n                         );\n                         Some(0)\n@@ -631,7 +631,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 }\n             }\n \n-            (&TestKind::Range(test), &PatKind::Range(pat)) => {\n+            (&TestKind::Range(ref test), &PatKind::Range(ref pat)) => {\n                 use std::cmp::Ordering::*;\n \n                 if test == pat {\n@@ -658,8 +658,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 no_overlap\n             }\n \n-            (&TestKind::Range(range), &PatKind::Constant { value }) => {\n-                if let Some(false) = self.const_range_contains(range, value) {\n+            (&TestKind::Range(ref range), &PatKind::Constant { value }) => {\n+                if let Some(false) = self.const_range_contains(&*range, value) {\n                     // `value` is not contained in the testing range,\n                     // so `value` can be matched only if this test fails.\n                     Some(1)\n@@ -678,7 +678,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 // However, at this point we can still encounter or-patterns that were extracted\n                 // from previous calls to `sort_candidate`, so we need to manually address that\n                 // case to avoid panicking in `self.test()`.\n-                if let PatKind::Or { .. } = &*match_pair.pattern.kind {\n+                if let PatKind::Or { .. } = &match_pair.pattern.kind {\n                     return None;\n                 }\n \n@@ -708,9 +708,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         &mut self,\n         match_pair_index: usize,\n         candidate: &mut Candidate<'pat, 'tcx>,\n-        prefix: &'pat [Pat<'tcx>],\n-        opt_slice: Option<&'pat Pat<'tcx>>,\n-        suffix: &'pat [Pat<'tcx>],\n+        prefix: &'pat [Box<Pat<'tcx>>],\n+        opt_slice: &'pat Option<Box<Pat<'tcx>>>,\n+        suffix: &'pat [Box<Pat<'tcx>>],\n     ) {\n         let removed_place = candidate.match_pairs.remove(match_pair_index).place;\n         self.prefix_slice_suffix(\n@@ -754,7 +754,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n     fn const_range_contains(\n         &self,\n-        range: PatRange<'tcx>,\n+        range: &PatRange<'tcx>,\n         value: ConstantKind<'tcx>,\n     ) -> Option<bool> {\n         use std::cmp::Ordering::*;\n@@ -772,7 +772,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n     fn values_not_contained_in_range(\n         &self,\n-        range: PatRange<'tcx>,\n+        range: &PatRange<'tcx>,\n         options: &FxIndexMap<ConstantKind<'tcx>, u128>,\n     ) -> Option<bool> {\n         for &val in options.keys() {"}, {"sha": "06f24040f7be05d80cbd277c2f41dd947cb235d2", "filename": "compiler/rustc_mir_build/src/build/matches/util.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0421444f8fa221864418c57603a4080f974849a4/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0421444f8fa221864418c57603a4080f974849a4/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Futil.rs?ref=0421444f8fa221864418c57603a4080f974849a4", "patch": "@@ -26,9 +26,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         &mut self,\n         match_pairs: &mut SmallVec<[MatchPair<'pat, 'tcx>; 1]>,\n         place: &PlaceBuilder<'tcx>,\n-        prefix: &'pat [Pat<'tcx>],\n-        opt_slice: Option<&'pat Pat<'tcx>>,\n-        suffix: &'pat [Pat<'tcx>],\n+        prefix: &'pat [Box<Pat<'tcx>>],\n+        opt_slice: &'pat Option<Box<Pat<'tcx>>>,\n+        suffix: &'pat [Box<Pat<'tcx>>],\n     ) {\n         let tcx = self.tcx;\n         let (min_length, exact_size) = if let Ok(place_resolved) ="}, {"sha": "763038c52d7fab8d54a003b1e94cc5fda9d47605", "filename": "compiler/rustc_mir_build/src/build/mod.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0421444f8fa221864418c57603a4080f974849a4/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0421444f8fa221864418c57603a4080f974849a4/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs?ref=0421444f8fa221864418c57603a4080f974849a4", "patch": "@@ -1015,7 +1015,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             let original_source_scope = self.source_scope;\n             let span = pattern.span;\n             self.set_correct_source_scope_for_arg(arg.hir_id, original_source_scope, span);\n-            match *pattern.kind {\n+            match pattern.kind {\n                 // Don't introduce extra copies for simple bindings\n                 PatKind::Binding {\n                     mutability,\n@@ -1052,7 +1052,10 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                         Some((Some(&place), span)),\n                     );\n                     let place_builder = PlaceBuilder::from(local);\n-                    unpack!(block = self.place_into_pattern(block, pattern, place_builder, false));\n+                    unpack!(\n+                        block =\n+                            self.place_into_pattern(block, pattern.as_ref(), place_builder, false)\n+                    );\n                 }\n             }\n             self.source_scope = original_source_scope;"}, {"sha": "495738ebe1c7ac9d392af26ac38f9e4bd6a309c1", "filename": "compiler/rustc_mir_build/src/check_unsafety.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0421444f8fa221864418c57603a4080f974849a4/compiler%2Frustc_mir_build%2Fsrc%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0421444f8fa221864418c57603a4080f974849a4/compiler%2Frustc_mir_build%2Fsrc%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fcheck_unsafety.rs?ref=0421444f8fa221864418c57603a4080f974849a4", "patch": "@@ -214,7 +214,7 @@ impl<'a, 'tcx> Visitor<'a, 'tcx> for UnsafetyVisitor<'a, 'tcx> {\n \n     fn visit_pat(&mut self, pat: &Pat<'tcx>) {\n         if self.in_union_destructure {\n-            match *pat.kind {\n+            match pat.kind {\n                 // binding to a variable allows getting stuff out of variable\n                 PatKind::Binding { .. }\n                 // match is conditional on having this value\n@@ -236,7 +236,7 @@ impl<'a, 'tcx> Visitor<'a, 'tcx> for UnsafetyVisitor<'a, 'tcx> {\n             }\n         };\n \n-        match &*pat.kind {\n+        match &pat.kind {\n             PatKind::Leaf { .. } => {\n                 if let ty::Adt(adt_def, ..) = pat.ty.kind() {\n                     if adt_def.is_union() {"}, {"sha": "321353ca20bae01f30992f1137fe109c582afd29", "filename": "compiler/rustc_mir_build/src/thir/cx/block.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0421444f8fa221864418c57603a4080f974849a4/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0421444f8fa221864418c57603a4080f974849a4/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fblock.rs?ref=0421444f8fa221864418c57603a4080f974849a4", "patch": "@@ -87,21 +87,21 @@ impl<'tcx> Cx<'tcx> {\n                             {\n                                 debug!(\"mirror_stmts: user_ty={:?}\", user_ty);\n                                 let annotation = CanonicalUserTypeAnnotation {\n-                                    user_ty,\n+                                    user_ty: Box::new(user_ty),\n                                     span: ty.span,\n                                     inferred_ty: self.typeck_results.node_type(ty.hir_id),\n                                 };\n-                                pattern = Pat {\n+                                pattern = Box::new(Pat {\n                                     ty: pattern.ty,\n                                     span: pattern.span,\n-                                    kind: Box::new(PatKind::AscribeUserType {\n+                                    kind: PatKind::AscribeUserType {\n                                         ascription: Ascription {\n                                             annotation,\n                                             variance: ty::Variance::Covariant,\n                                         },\n                                         subpattern: pattern,\n-                                    }),\n-                                };\n+                                    },\n+                                });\n                             }\n                         }\n "}, {"sha": "ae53df1f9b9a4166353f93f22b96d54791dfe52f", "filename": "compiler/rustc_mir_build/src/thir/cx/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0421444f8fa221864418c57603a4080f974849a4/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0421444f8fa221864418c57603a4080f974849a4/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fmod.rs?ref=0421444f8fa221864418c57603a4080f974849a4", "patch": "@@ -78,7 +78,7 @@ impl<'tcx> Cx<'tcx> {\n     }\n \n     #[instrument(level = \"debug\", skip(self))]\n-    pub(crate) fn pattern_from_hir(&mut self, p: &hir::Pat<'_>) -> Pat<'tcx> {\n+    pub(crate) fn pattern_from_hir(&mut self, p: &hir::Pat<'_>) -> Box<Pat<'tcx>> {\n         let p = match self.tcx.hir().get(p.hir_id) {\n             Node::Pat(p) => p,\n             node => bug!(\"pattern became {:?}\", node),"}, {"sha": "b58685e895809b266d76df47122f3add615fad3a", "filename": "compiler/rustc_mir_build/src/thir/pattern/const_to_pat.rs", "status": "modified", "additions": 21, "deletions": 19, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/0421444f8fa221864418c57603a4080f974849a4/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0421444f8fa221864418c57603a4080f974849a4/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs?ref=0421444f8fa221864418c57603a4080f974849a4", "patch": "@@ -26,7 +26,7 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n         id: hir::HirId,\n         span: Span,\n         mir_structural_match_violation: bool,\n-    ) -> Pat<'tcx> {\n+    ) -> Box<Pat<'tcx>> {\n         self.tcx.infer_ctxt().enter(|infcx| {\n             let mut convert = ConstToPat::new(self, id, span, infcx);\n             convert.to_pat(cv, mir_structural_match_violation)\n@@ -156,7 +156,7 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n         &mut self,\n         cv: mir::ConstantKind<'tcx>,\n         mir_structural_match_violation: bool,\n-    ) -> Pat<'tcx> {\n+    ) -> Box<Pat<'tcx>> {\n         trace!(self.treat_byte_string_as_slice);\n         // This method is just a wrapper handling a validity check; the heavy lifting is\n         // performed by the recursive `recur` method, which is not meant to be\n@@ -166,10 +166,12 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n         // level of indirection can be eliminated\n \n         let inlined_const_as_pat =\n-            self.recur(cv, mir_structural_match_violation).unwrap_or_else(|_| Pat {\n-                span: self.span,\n-                ty: cv.ty(),\n-                kind: Box::new(PatKind::Constant { value: cv }),\n+            self.recur(cv, mir_structural_match_violation).unwrap_or_else(|_| {\n+                Box::new(Pat {\n+                    span: self.span,\n+                    ty: cv.ty(),\n+                    kind: PatKind::Constant { value: cv },\n+                })\n             });\n \n         if self.include_lint_checks && !self.saw_const_match_error.get() {\n@@ -271,7 +273,7 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n         &self,\n         cv: mir::ConstantKind<'tcx>,\n         mir_structural_match_violation: bool,\n-    ) -> Result<Pat<'tcx>, FallbackToConstRef> {\n+    ) -> Result<Box<Pat<'tcx>>, FallbackToConstRef> {\n         let id = self.id;\n         let span = self.span;\n         let tcx = self.tcx();\n@@ -398,7 +400,7 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n                     .map(|val| self.recur(*val, false))\n                     .collect::<Result<_, _>>()?,\n                 slice: None,\n-                suffix: Vec::new(),\n+                suffix: Box::new([]),\n             },\n             ty::Ref(_, pointee_ty, ..) => match *pointee_ty.kind() {\n                 // These are not allowed and will error elsewhere anyway.\n@@ -425,20 +427,20 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n                     let old = self.behind_reference.replace(true);\n                     let array = tcx.deref_mir_constant(self.param_env.and(cv));\n                     let val = PatKind::Deref {\n-                        subpattern: Pat {\n-                            kind: Box::new(PatKind::Array {\n+                        subpattern: Box::new(Pat {\n+                            kind: PatKind::Array {\n                                 prefix: tcx\n                                     .destructure_mir_constant(param_env, array)\n                                     .fields\n                                     .iter()\n                                     .map(|val| self.recur(*val, false))\n                                     .collect::<Result<_, _>>()?,\n                                 slice: None,\n-                                suffix: vec![],\n-                            }),\n+                                suffix: Box::new([]),\n+                            },\n                             span,\n                             ty: *pointee_ty,\n-                        },\n+                        }),\n                     };\n                     self.behind_reference.set(old);\n                     val\n@@ -451,20 +453,20 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n                     let old = self.behind_reference.replace(true);\n                     let array = tcx.deref_mir_constant(self.param_env.and(cv));\n                     let val = PatKind::Deref {\n-                        subpattern: Pat {\n-                            kind: Box::new(PatKind::Slice {\n+                        subpattern: Box::new(Pat {\n+                            kind: PatKind::Slice {\n                                 prefix: tcx\n                                     .destructure_mir_constant(param_env, array)\n                                     .fields\n                                     .iter()\n                                     .map(|val| self.recur(*val, false))\n                                     .collect::<Result<_, _>>()?,\n                                 slice: None,\n-                                suffix: vec![],\n-                            }),\n+                                suffix: Box::new([]),\n+                            },\n                             span,\n                             ty: tcx.mk_slice(elem_ty),\n-                        },\n+                        }),\n                     };\n                     self.behind_reference.set(old);\n                     val\n@@ -598,6 +600,6 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n             );\n         }\n \n-        Ok(Pat { span, ty: cv.ty(), kind: Box::new(kind) })\n+        Ok(Box::new(Pat { span, ty: cv.ty(), kind }))\n     }\n }"}, {"sha": "5105f059f9b64797317ac251dc630389a8a1ceb8", "filename": "compiler/rustc_mir_build/src/thir/pattern/deconstruct_pat.rs", "status": "modified", "additions": 28, "deletions": 19, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/0421444f8fa221864418c57603a4080f974849a4/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0421444f8fa221864418c57603a4080f974849a4/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs?ref=0421444f8fa221864418c57603a4080f974849a4", "patch": "@@ -71,9 +71,9 @@ use std::ops::RangeInclusive;\n /// Recursively expand this pattern into its subpatterns. Only useful for or-patterns.\n fn expand_or_pat<'p, 'tcx>(pat: &'p Pat<'tcx>) -> Vec<&'p Pat<'tcx>> {\n     fn expand<'p, 'tcx>(pat: &'p Pat<'tcx>, vec: &mut Vec<&'p Pat<'tcx>>) {\n-        if let PatKind::Or { pats } = pat.kind.as_ref() {\n-            for pat in pats {\n-                expand(pat, vec);\n+        if let PatKind::Or { pats } = &pat.kind {\n+            for pat in pats.iter() {\n+                expand(&pat, vec);\n             }\n         } else {\n             vec.push(pat)\n@@ -252,10 +252,14 @@ impl IntRange {\n         let kind = if lo == hi {\n             PatKind::Constant { value: lo_const }\n         } else {\n-            PatKind::Range(PatRange { lo: lo_const, hi: hi_const, end: RangeEnd::Included })\n+            PatKind::Range(Box::new(PatRange {\n+                lo: lo_const,\n+                hi: hi_const,\n+                end: RangeEnd::Included,\n+            }))\n         };\n \n-        Pat { ty, span: DUMMY_SP, kind: Box::new(kind) }\n+        Pat { ty, span: DUMMY_SP, kind }\n     }\n \n     /// Lint on likely incorrect range patterns (#63987)\n@@ -1297,7 +1301,7 @@ impl<'p, 'tcx> DeconstructedPat<'p, 'tcx> {\n         let mkpat = |pat| DeconstructedPat::from_pat(cx, pat);\n         let ctor;\n         let fields;\n-        match pat.kind.as_ref() {\n+        match &pat.kind {\n             PatKind::AscribeUserType { subpattern, .. } => return mkpat(subpattern),\n             PatKind::Binding { subpattern: Some(subpat), .. } => return mkpat(subpat),\n             PatKind::Binding { subpattern: None, .. } | PatKind::Wild => {\n@@ -1342,9 +1346,9 @@ impl<'p, 'tcx> DeconstructedPat<'p, 'tcx> {\n                         fields = Fields::singleton(cx, pat);\n                     }\n                     ty::Adt(adt, _) => {\n-                        ctor = match pat.kind.as_ref() {\n+                        ctor = match pat.kind {\n                             PatKind::Leaf { .. } => Single,\n-                            PatKind::Variant { variant_index, .. } => Variant(*variant_index),\n+                            PatKind::Variant { variant_index, .. } => Variant(variant_index),\n                             _ => bug!(),\n                         };\n                         let variant = &adt.variant(ctor.variant_index_for_adt(*adt));\n@@ -1402,7 +1406,7 @@ impl<'p, 'tcx> DeconstructedPat<'p, 'tcx> {\n                     }\n                 }\n             }\n-            &PatKind::Range(PatRange { lo, hi, end }) => {\n+            &PatKind::Range(box PatRange { lo, hi, end }) => {\n                 let ty = lo.ty();\n                 ctor = if let Some(int_range) = IntRange::from_range(\n                     cx.tcx,\n@@ -1429,7 +1433,8 @@ impl<'p, 'tcx> DeconstructedPat<'p, 'tcx> {\n                     FixedLen(prefix.len() + suffix.len())\n                 };\n                 ctor = Slice(Slice::new(array_len, kind));\n-                fields = Fields::from_iter(cx, prefix.iter().chain(suffix).map(mkpat));\n+                fields =\n+                    Fields::from_iter(cx, prefix.iter().chain(suffix.iter()).map(|p| mkpat(&*p)));\n             }\n             PatKind::Or { .. } => {\n                 ctor = Or;\n@@ -1442,15 +1447,15 @@ impl<'p, 'tcx> DeconstructedPat<'p, 'tcx> {\n \n     pub(crate) fn to_pat(&self, cx: &MatchCheckCtxt<'p, 'tcx>) -> Pat<'tcx> {\n         let is_wildcard = |pat: &Pat<'_>| {\n-            matches!(*pat.kind, PatKind::Binding { subpattern: None, .. } | PatKind::Wild)\n+            matches!(pat.kind, PatKind::Binding { subpattern: None, .. } | PatKind::Wild)\n         };\n-        let mut subpatterns = self.iter_fields().map(|p| p.to_pat(cx));\n-        let pat = match &self.ctor {\n+        let mut subpatterns = self.iter_fields().map(|p| Box::new(p.to_pat(cx)));\n+        let kind = match &self.ctor {\n             Single | Variant(_) => match self.ty.kind() {\n                 ty::Tuple(..) => PatKind::Leaf {\n                     subpatterns: subpatterns\n                         .enumerate()\n-                        .map(|(i, p)| FieldPat { field: Field::new(i), pattern: p })\n+                        .map(|(i, pattern)| FieldPat { field: Field::new(i), pattern })\n                         .collect(),\n                 },\n                 ty::Adt(adt_def, _) if adt_def.is_box() => {\n@@ -1485,7 +1490,7 @@ impl<'p, 'tcx> DeconstructedPat<'p, 'tcx> {\n                     FixedLen(_) => PatKind::Slice {\n                         prefix: subpatterns.collect(),\n                         slice: None,\n-                        suffix: vec![],\n+                        suffix: Box::new([]),\n                     },\n                     VarLen(prefix, _) => {\n                         let mut subpatterns = subpatterns.peekable();\n@@ -1504,14 +1509,18 @@ impl<'p, 'tcx> DeconstructedPat<'p, 'tcx> {\n                                 subpatterns.next();\n                             }\n                         }\n-                        let suffix: Vec<_> = subpatterns.collect();\n+                        let suffix: Box<[_]> = subpatterns.collect();\n                         let wild = Pat::wildcard_from_ty(self.ty);\n-                        PatKind::Slice { prefix, slice: Some(wild), suffix }\n+                        PatKind::Slice {\n+                            prefix: prefix.into_boxed_slice(),\n+                            slice: Some(Box::new(wild)),\n+                            suffix,\n+                        }\n                     }\n                 }\n             }\n             &Str(value) => PatKind::Constant { value },\n-            &FloatRange(lo, hi, end) => PatKind::Range(PatRange { lo, hi, end }),\n+            &FloatRange(lo, hi, end) => PatKind::Range(Box::new(PatRange { lo, hi, end })),\n             IntRange(range) => return range.to_pat(cx.tcx, self.ty),\n             Wildcard | NonExhaustive => PatKind::Wild,\n             Missing { .. } => bug!(\n@@ -1523,7 +1532,7 @@ impl<'p, 'tcx> DeconstructedPat<'p, 'tcx> {\n             }\n         };\n \n-        Pat { ty: self.ty, span: DUMMY_SP, kind: Box::new(pat) }\n+        Pat { ty: self.ty, span: DUMMY_SP, kind }\n     }\n \n     pub(super) fn is_or_pat(&self) -> bool {"}, {"sha": "d2f93b679acc596a89525e118f23a06dfcc385eb", "filename": "compiler/rustc_mir_build/src/thir/pattern/mod.rs", "status": "modified", "additions": 40, "deletions": 27, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/0421444f8fa221864418c57603a4080f974849a4/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0421444f8fa221864418c57603a4080f974849a4/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs?ref=0421444f8fa221864418c57603a4080f974849a4", "patch": "@@ -49,7 +49,7 @@ pub(crate) fn pat_from_hir<'a, 'tcx>(\n     param_env: ty::ParamEnv<'tcx>,\n     typeck_results: &'a ty::TypeckResults<'tcx>,\n     pat: &'tcx hir::Pat<'tcx>,\n-) -> Pat<'tcx> {\n+) -> Box<Pat<'tcx>> {\n     let mut pcx = PatCtxt::new(tcx, param_env, typeck_results);\n     let result = pcx.lower_pattern(pat);\n     if !pcx.errors.is_empty() {\n@@ -74,7 +74,7 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n         self\n     }\n \n-    pub(crate) fn lower_pattern(&mut self, pat: &'tcx hir::Pat<'tcx>) -> Pat<'tcx> {\n+    pub(crate) fn lower_pattern(&mut self, pat: &'tcx hir::Pat<'tcx>) -> Box<Pat<'tcx>> {\n         // When implicit dereferences have been inserted in this pattern, the unadjusted lowered\n         // pattern has the type that results *after* dereferencing. For example, in this code:\n         //\n@@ -97,13 +97,13 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n         let unadjusted_pat = self.lower_pattern_unadjusted(pat);\n         self.typeck_results.pat_adjustments().get(pat.hir_id).unwrap_or(&vec![]).iter().rev().fold(\n             unadjusted_pat,\n-            |pat, ref_ty| {\n+            |pat: Box<_>, ref_ty| {\n                 debug!(\"{:?}: wrapping pattern with type {:?}\", pat, ref_ty);\n-                Pat {\n+                Box::new(Pat {\n                     span: pat.span,\n                     ty: *ref_ty,\n-                    kind: Box::new(PatKind::Deref { subpattern: pat }),\n-                }\n+                    kind: PatKind::Deref { subpattern: pat },\n+                })\n             },\n         )\n     }\n@@ -113,7 +113,7 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n         expr: &'tcx hir::Expr<'tcx>,\n     ) -> (PatKind<'tcx>, Option<Ascription<'tcx>>) {\n         match self.lower_lit(expr) {\n-            PatKind::AscribeUserType { ascription, subpattern: Pat { kind: box kind, .. } } => {\n+            PatKind::AscribeUserType { ascription, subpattern: box Pat { kind, .. } } => {\n                 (kind, Some(ascription))\n             }\n             kind => (kind, None),\n@@ -134,7 +134,9 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n         match (end, cmp) {\n             // `x..y` where `x < y`.\n             // Non-empty because the range includes at least `x`.\n-            (RangeEnd::Excluded, Some(Ordering::Less)) => PatKind::Range(PatRange { lo, hi, end }),\n+            (RangeEnd::Excluded, Some(Ordering::Less)) => {\n+                PatKind::Range(Box::new(PatRange { lo, hi, end }))\n+            }\n             // `x..y` where `x >= y`. The range is empty => error.\n             (RangeEnd::Excluded, _) => {\n                 struct_span_err!(\n@@ -149,7 +151,9 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n             // `x..=y` where `x == y`.\n             (RangeEnd::Included, Some(Ordering::Equal)) => PatKind::Constant { value: lo },\n             // `x..=y` where `x < y`.\n-            (RangeEnd::Included, Some(Ordering::Less)) => PatKind::Range(PatRange { lo, hi, end }),\n+            (RangeEnd::Included, Some(Ordering::Less)) => {\n+                PatKind::Range(Box::new(PatRange { lo, hi, end }))\n+            }\n             // `x..=y` where `x > y` hence the range is empty => error.\n             (RangeEnd::Included, _) => {\n                 let mut err = struct_span_err!(\n@@ -196,7 +200,7 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn lower_pattern_unadjusted(&mut self, pat: &'tcx hir::Pat<'tcx>) -> Pat<'tcx> {\n+    fn lower_pattern_unadjusted(&mut self, pat: &'tcx hir::Pat<'tcx>) -> Box<Pat<'tcx>> {\n         let mut ty = self.typeck_results.node_type(pat.hir_id);\n \n         let kind = match pat.kind {\n@@ -228,7 +232,7 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n                 // constants somewhere. Have them on the range pattern.\n                 for end in &[lo, hi] {\n                     if let Some((_, Some(ascription))) = end {\n-                        let subpattern = Pat { span: pat.span, ty, kind: Box::new(kind) };\n+                        let subpattern = Box::new(Pat { span: pat.span, ty, kind });\n                         kind =\n                             PatKind::AscribeUserType { ascription: ascription.clone(), subpattern };\n                     }\n@@ -322,7 +326,7 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n             hir::PatKind::Or(ref pats) => PatKind::Or { pats: self.lower_patterns(pats) },\n         };\n \n-        Pat { span: pat.span, ty, kind: Box::new(kind) }\n+        Box::new(Pat { span: pat.span, ty, kind })\n     }\n \n     fn lower_tuple_subpats(\n@@ -340,11 +344,14 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n             .collect()\n     }\n \n-    fn lower_patterns(&mut self, pats: &'tcx [hir::Pat<'tcx>]) -> Vec<Pat<'tcx>> {\n+    fn lower_patterns(&mut self, pats: &'tcx [hir::Pat<'tcx>]) -> Box<[Box<Pat<'tcx>>]> {\n         pats.iter().map(|p| self.lower_pattern(p)).collect()\n     }\n \n-    fn lower_opt_pattern(&mut self, pat: &'tcx Option<&'tcx hir::Pat<'tcx>>) -> Option<Pat<'tcx>> {\n+    fn lower_opt_pattern(\n+        &mut self,\n+        pat: &'tcx Option<&'tcx hir::Pat<'tcx>>,\n+    ) -> Option<Box<Pat<'tcx>>> {\n         pat.as_ref().map(|p| self.lower_pattern(p))\n     }\n \n@@ -436,12 +443,12 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n         if let Some(user_ty) = self.user_substs_applied_to_ty_of_hir_id(hir_id) {\n             debug!(\"lower_variant_or_leaf: kind={:?} user_ty={:?} span={:?}\", kind, user_ty, span);\n             let annotation = CanonicalUserTypeAnnotation {\n-                user_ty,\n+                user_ty: Box::new(user_ty),\n                 span,\n                 inferred_ty: self.typeck_results.node_type(hir_id),\n             };\n             kind = PatKind::AscribeUserType {\n-                subpattern: Pat { span, ty, kind: Box::new(kind) },\n+                subpattern: Box::new(Pat { span, ty, kind }),\n                 ascription: Ascription { annotation, variance: ty::Variance::Covariant },\n             };\n         }\n@@ -453,11 +460,11 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n     /// it to `const_to_pat`. Any other path (like enum variants without fields)\n     /// is converted to the corresponding pattern via `lower_variant_or_leaf`.\n     #[instrument(skip(self), level = \"debug\")]\n-    fn lower_path(&mut self, qpath: &hir::QPath<'_>, id: hir::HirId, span: Span) -> Pat<'tcx> {\n+    fn lower_path(&mut self, qpath: &hir::QPath<'_>, id: hir::HirId, span: Span) -> Box<Pat<'tcx>> {\n         let ty = self.typeck_results.node_type(id);\n         let res = self.typeck_results.qpath_res(qpath, id);\n \n-        let pat_from_kind = |kind| Pat { span, ty, kind: Box::new(kind) };\n+        let pat_from_kind = |kind| Box::new(Pat { span, ty, kind });\n \n         let (def_id, is_associated_const) = match res {\n             Res::Def(DefKind::Const, def_id) => (def_id, false),\n@@ -505,23 +512,23 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n                 let user_provided_types = self.typeck_results().user_provided_types();\n                 if let Some(&user_ty) = user_provided_types.get(id) {\n                     let annotation = CanonicalUserTypeAnnotation {\n-                        user_ty,\n+                        user_ty: Box::new(user_ty),\n                         span,\n                         inferred_ty: self.typeck_results().node_type(id),\n                     };\n-                    Pat {\n+                    Box::new(Pat {\n                         span,\n-                        kind: Box::new(PatKind::AscribeUserType {\n+                        kind: PatKind::AscribeUserType {\n                             subpattern: pattern,\n                             ascription: Ascription {\n                                 annotation,\n                                 /// Note that use `Contravariant` here. See the\n                                 /// `variance` field documentation for details.\n                                 variance: ty::Variance::Contravariant,\n                             },\n-                        }),\n+                        },\n                         ty: const_.ty(),\n-                    }\n+                    })\n                 } else {\n                     pattern\n                 }\n@@ -569,7 +576,7 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n                     _ => bug!(\"Expected either ConstKind::Param or ConstKind::Unevaluated\"),\n                 }\n             }\n-            mir::ConstantKind::Val(_, _) => *self.const_to_pat(value, id, span, false).kind,\n+            mir::ConstantKind::Val(_, _) => self.const_to_pat(value, id, span, false).kind,\n         }\n     }\n \n@@ -580,7 +587,7 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n     fn lower_lit(&mut self, expr: &'tcx hir::Expr<'tcx>) -> PatKind<'tcx> {\n         let (lit, neg) = match expr.kind {\n             hir::ExprKind::Path(ref qpath) => {\n-                return *self.lower_path(qpath, expr.hir_id, expr.span).kind;\n+                return self.lower_path(qpath, expr.hir_id, expr.span).kind;\n             }\n             hir::ExprKind::ConstBlock(ref anon_const) => {\n                 return self.lower_inline_const(anon_const, expr.hir_id, expr.span);\n@@ -598,7 +605,7 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n         let lit_input =\n             LitToConstInput { lit: &lit.node, ty: self.typeck_results.expr_ty(expr), neg };\n         match self.tcx.at(expr.span).lit_to_mir_constant(lit_input) {\n-            Ok(constant) => *self.const_to_pat(constant, expr.hir_id, lit.span, false).kind,\n+            Ok(constant) => self.const_to_pat(constant, expr.hir_id, lit.span, false).kind,\n             Err(LitToConstError::Reported) => PatKind::Wild,\n             Err(LitToConstError::TypeError) => bug!(\"lower_lit: had type error\"),\n         }\n@@ -646,6 +653,12 @@ impl<'tcx, T: PatternFoldable<'tcx>> PatternFoldable<'tcx> for Vec<T> {\n     }\n }\n \n+impl<'tcx, T: PatternFoldable<'tcx>> PatternFoldable<'tcx> for Box<[T]> {\n+    fn super_fold_with<F: PatternFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+        self.iter().map(|t| t.fold_with(folder)).collect()\n+    }\n+}\n+\n impl<'tcx, T: PatternFoldable<'tcx>> PatternFoldable<'tcx> for Option<T> {\n     fn super_fold_with<F: PatternFolder<'tcx>>(&self, folder: &mut F) -> Self {\n         self.as_ref().map(|t| t.fold_with(folder))\n@@ -732,7 +745,7 @@ impl<'tcx> PatternFoldable<'tcx> for PatKind<'tcx> {\n                 PatKind::Deref { subpattern: subpattern.fold_with(folder) }\n             }\n             PatKind::Constant { value } => PatKind::Constant { value },\n-            PatKind::Range(range) => PatKind::Range(range),\n+            PatKind::Range(ref range) => PatKind::Range(range.clone()),\n             PatKind::Slice { ref prefix, ref slice, ref suffix } => PatKind::Slice {\n                 prefix: prefix.fold_with(folder),\n                 slice: slice.fold_with(folder),"}, {"sha": "bb6b3e1ff5d7482f0700b3d324819ae2df70f3be", "filename": "compiler/rustc_ty_utils/src/consts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0421444f8fa221864418c57603a4080f974849a4/compiler%2Frustc_ty_utils%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0421444f8fa221864418c57603a4080f974849a4/compiler%2Frustc_ty_utils%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fconsts.rs?ref=0421444f8fa221864418c57603a4080f974849a4", "patch": "@@ -155,9 +155,9 @@ impl<'a, 'tcx> AbstractConstBuilder<'a, 'tcx> {\n                     return true;\n                 }\n \n-                match pat.kind.as_ref() {\n+                match pat.kind {\n                     thir::PatKind::Constant { value } => value.has_param_types_or_consts(),\n-                    thir::PatKind::Range(thir::PatRange { lo, hi, .. }) => {\n+                    thir::PatKind::Range(box thir::PatRange { lo, hi, .. }) => {\n                         lo.has_param_types_or_consts() || hi.has_param_types_or_consts()\n                     }\n                     _ => false,"}]}