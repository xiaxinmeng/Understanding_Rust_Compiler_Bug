{"sha": "1c48227b3c94a374c47fd5110bb76d48d7d5ada3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFjNDgyMjdiM2M5NGEzNzRjNDdmZDUxMTBiYjc2ZDQ4ZDdkNWFkYTM=", "commit": {"author": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2015-04-18T21:23:00Z"}, "committer": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2015-04-20T13:44:21Z"}, "message": "Remove inverse example from generics part of TRPL\n\nFixes #24325.", "tree": {"sha": "eab427142daae1699138857078f9e8c86628c64e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eab427142daae1699138857078f9e8c86628c64e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1c48227b3c94a374c47fd5110bb76d48d7d5ada3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1c48227b3c94a374c47fd5110bb76d48d7d5ada3", "html_url": "https://github.com/rust-lang/rust/commit/1c48227b3c94a374c47fd5110bb76d48d7d5ada3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1c48227b3c94a374c47fd5110bb76d48d7d5ada3/comments", "author": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "committer": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e289b689d4c1af7da5f665321942713cdc3be95d", "url": "https://api.github.com/repos/rust-lang/rust/commits/e289b689d4c1af7da5f665321942713cdc3be95d", "html_url": "https://github.com/rust-lang/rust/commit/e289b689d4c1af7da5f665321942713cdc3be95d"}], "stats": {"total": 85, "additions": 0, "deletions": 85}, "files": [{"sha": "b13c68c45c870cf5e05e156c494fe6cb5f794233", "filename": "src/doc/trpl/generics.md", "status": "modified", "additions": 0, "deletions": 85, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/1c48227b3c94a374c47fd5110bb76d48d7d5ada3/src%2Fdoc%2Ftrpl%2Fgenerics.md", "raw_url": "https://github.com/rust-lang/rust/raw/1c48227b3c94a374c47fd5110bb76d48d7d5ada3/src%2Fdoc%2Ftrpl%2Fgenerics.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fgenerics.md?ref=1c48227b3c94a374c47fd5110bb76d48d7d5ada3", "patch": "@@ -90,88 +90,3 @@ if we wanted to. Convention says that the first generic parameter should be\n \n The `Result<T, E>` type is intended to be used to return the result of a\n computation, and to have the ability to return an error if it didn't work out.\n-Here's an example:\n-\n-```{rust}\n-let x: Result<f64, String> = Ok(2.3f64);\n-let y: Result<f64, String> = Err(\"There was an error.\".to_string());\n-```\n-\n-This particular Result will return an `f64` if there's a success, and a\n-`String` if there's a failure. Let's write a function that uses `Result<T, E>`:\n-\n-```{rust}\n-fn inverse(x: f64) -> Result<f64, String> {\n-    if x == 0.0f64 { return Err(\"x cannot be zero!\".to_string()); }\n-\n-    Ok(1.0f64 / x)\n-}\n-```\n-\n-We don't want to take the inverse of zero, so we check to make sure that we\n-weren't passed zero. If we were, then we return an `Err`, with a message. If\n-it's okay, we return an `Ok`, with the answer.\n-\n-Why does this matter? Well, remember how `match` does exhaustive matches?\n-Here's how this function gets used:\n-\n-```{rust}\n-# fn inverse(x: f64) -> Result<f64, String> {\n-#     if x == 0.0f64 { return Err(\"x cannot be zero!\".to_string()); }\n-#     Ok(1.0f64 / x)\n-# }\n-let x = inverse(25.0f64);\n-\n-match x {\n-    Ok(x) => println!(\"The inverse of 25 is {}\", x),\n-    Err(msg) => println!(\"Error: {}\", msg),\n-}\n-```\n-\n-The `match` enforces that we handle the `Err` case. In addition, because the\n-answer is wrapped up in an `Ok`, we can't just use the result without doing\n-the match:\n-\n-```{rust,ignore}\n-let x = inverse(25.0f64);\n-println!(\"{}\", x + 2.0f64); // error: binary operation `+` cannot be applied\n-           // to type `core::result::Result<f64,collections::string::String>`\n-```\n-\n-This function is great, but there's one other problem: it only works for 64 bit\n-floating point values. What if we wanted to handle 32 bit floating point as\n-well? We'd have to write this:\n-\n-```{rust}\n-fn inverse32(x: f32) -> Result<f32, String> {\n-    if x == 0.0f32 { return Err(\"x cannot be zero!\".to_string()); }\n-\n-    Ok(1.0f32 / x)\n-}\n-```\n-\n-Bummer. What we need is a *generic function*. Luckily, we can write one!\n-However, it won't _quite_ work yet. Before we get into that, let's talk syntax.\n-A generic version of `inverse` would look something like this:\n-\n-```{rust,ignore}\n-fn inverse<T>(x: T) -> Result<T, String> {\n-    if x == 0.0 { return Err(\"x cannot be zero!\".to_string()); }\n-\n-    Ok(1.0 / x)\n-}\n-```\n-\n-Just like how we had `Option<T>`, we use a similar syntax for `inverse<T>`.\n-We can then use `T` inside the rest of the signature: `x` has type `T`, and half\n-of the `Result` has type `T`. However, if we try to compile that example, we'll get\n-an error:\n-\n-```text\n-error: binary operation `==` cannot be applied to type `T`\n-```\n-\n-Because `T` can be _any_ type, it may be a type that doesn't implement `==`,\n-and therefore, the first line would be wrong. What do we do?\n-\n-To fix this example, we need to learn about another Rust feature: traits."}]}