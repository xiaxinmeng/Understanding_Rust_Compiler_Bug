{"sha": "1ea84c80c1cade1068fab4019f58086c3e159b1c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFlYTg0YzgwYzFjYWRlMTA2OGZhYjQwMTlmNTgwODZjM2UxNTliMWM=", "commit": {"author": {"name": "Karim Snj", "email": "karim.snj@gmail.com", "date": "2018-03-05T21:20:28Z"}, "committer": {"name": "Karim Snj", "email": "karim.snj@gmail.com", "date": "2018-03-05T21:42:32Z"}, "message": "lint: while immutable condition: refactor to use ExprUseVisitor", "tree": {"sha": "23f5eed194b5bcad0d8c0389242d6cac3fca2922", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/23f5eed194b5bcad0d8c0389242d6cac3fca2922"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1ea84c80c1cade1068fab4019f58086c3e159b1c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1ea84c80c1cade1068fab4019f58086c3e159b1c", "html_url": "https://github.com/rust-lang/rust/commit/1ea84c80c1cade1068fab4019f58086c3e159b1c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1ea84c80c1cade1068fab4019f58086c3e159b1c/comments", "author": {"login": "kimsnj", "id": 302132, "node_id": "MDQ6VXNlcjMwMjEzMg==", "avatar_url": "https://avatars.githubusercontent.com/u/302132?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kimsnj", "html_url": "https://github.com/kimsnj", "followers_url": "https://api.github.com/users/kimsnj/followers", "following_url": "https://api.github.com/users/kimsnj/following{/other_user}", "gists_url": "https://api.github.com/users/kimsnj/gists{/gist_id}", "starred_url": "https://api.github.com/users/kimsnj/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kimsnj/subscriptions", "organizations_url": "https://api.github.com/users/kimsnj/orgs", "repos_url": "https://api.github.com/users/kimsnj/repos", "events_url": "https://api.github.com/users/kimsnj/events{/privacy}", "received_events_url": "https://api.github.com/users/kimsnj/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kimsnj", "id": 302132, "node_id": "MDQ6VXNlcjMwMjEzMg==", "avatar_url": "https://avatars.githubusercontent.com/u/302132?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kimsnj", "html_url": "https://github.com/kimsnj", "followers_url": "https://api.github.com/users/kimsnj/followers", "following_url": "https://api.github.com/users/kimsnj/following{/other_user}", "gists_url": "https://api.github.com/users/kimsnj/gists{/gist_id}", "starred_url": "https://api.github.com/users/kimsnj/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kimsnj/subscriptions", "organizations_url": "https://api.github.com/users/kimsnj/orgs", "repos_url": "https://api.github.com/users/kimsnj/repos", "events_url": "https://api.github.com/users/kimsnj/events{/privacy}", "received_events_url": "https://api.github.com/users/kimsnj/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7d35fab304aa154a9f0d8236e3fe176ab68f01ea", "url": "https://api.github.com/repos/rust-lang/rust/commits/7d35fab304aa154a9f0d8236e3fe176ab68f01ea", "html_url": "https://github.com/rust-lang/rust/commit/7d35fab304aa154a9f0d8236e3fe176ab68f01ea"}], "stats": {"total": 73, "additions": 39, "deletions": 34}, "files": [{"sha": "3e966daa83767752370a75e2ac2474df992aff15", "filename": "clippy_lints/src/loops.rs", "status": "modified", "additions": 39, "deletions": 34, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/1ea84c80c1cade1068fab4019f58086c3e159b1c/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ea84c80c1cade1068fab4019f58086c3e159b1c/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=1ea84c80c1cade1068fab4019f58086c3e159b1c", "patch": "@@ -1399,14 +1399,14 @@ fn check_for_loop_over_map_kv<'a, 'tcx>(\n     }\n }\n \n-struct MutateDelegate {\n+struct MutatePairDelegate {\n     node_id_low: Option<NodeId>,\n     node_id_high: Option<NodeId>,\n     span_low: Option<Span>,\n     span_high: Option<Span>,\n }\n \n-impl<'tcx> Delegate<'tcx> for MutateDelegate {\n+impl<'tcx> Delegate<'tcx> for MutatePairDelegate {\n     fn consume(&mut self, _: NodeId, _: Span, _: cmt<'tcx>, _: ConsumeMode) {}\n \n     fn matched_pat(&mut self, _: &Pat, _: cmt<'tcx>, _: MatchMode) {}\n@@ -1440,7 +1440,7 @@ impl<'tcx> Delegate<'tcx> for MutateDelegate {\n     fn decl_without_init(&mut self, _: NodeId, _: Span) {}\n }\n \n-impl<'tcx> MutateDelegate {\n+impl<'tcx> MutatePairDelegate {\n     fn mutation_span(&self) -> (Option<Span>, Option<Span>) {\n         (self.span_low, self.span_high)\n     }\n@@ -1499,7 +1499,7 @@ fn check_for_mutability(cx: &LateContext, bound: &Expr) -> Option<NodeId> {\n }\n \n fn check_for_mutation(cx: &LateContext, body: &Expr, bound_ids: &[Option<NodeId>]) -> (Option<Span>, Option<Span>) {\n-    let mut delegate = MutateDelegate {\n+    let mut delegate = MutatePairDelegate {\n         node_id_low: bound_ids[0],\n         node_id_high: bound_ids[1],\n         span_low: None,\n@@ -2143,7 +2143,7 @@ fn path_name(e: &Expr) -> Option<Name> {\n fn check_infinite_loop<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, cond: &'tcx Expr, block: &'tcx Block, expr: &'tcx Expr) {\n     let mut mut_var_visitor = MutableVarsVisitor {\n         cx,\n-        ids: HashSet::new(),\n+        ids: HashMap::new(),\n         skip: false,\n     };\n     walk_expr(&mut mut_var_visitor, expr);\n@@ -2161,13 +2161,15 @@ fn check_infinite_loop<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, cond: &'tcx Expr, b\n         return;\n     }\n \n-    let mut use_visitor = MutablyUsedVisitor {\n-        cx,\n-        ids: mut_var_visitor.ids,\n-        any_used: false,\n+\n+    let mut delegate = MutVarsDelegate {\n+        mut_spans: mut_var_visitor.ids,\n     };\n-    walk_block(&mut use_visitor, block);\n-    if !use_visitor.any_used {\n+    let def_id = def_id::DefId::local(block.hir_id.owner);\n+    let region_scope_tree = &cx.tcx.region_scope_tree(def_id);\n+    ExprUseVisitor::new(&mut delegate, cx.tcx, cx.param_env, region_scope_tree, cx.tables, None).walk_expr(expr);\n+\n+    if !delegate.mut_spans.iter().any(|(_, v)| v.is_some()) {\n         span_lint(\n             cx,\n             WHILE_IMMUTABLE_CONDITION,\n@@ -2181,15 +2183,15 @@ fn check_infinite_loop<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, cond: &'tcx Expr, b\n /// Stops analysis if a function call is found\n struct MutableVarsVisitor<'a, 'tcx: 'a> {\n     cx: &'a LateContext<'a, 'tcx>,\n-    ids: HashSet<NodeId>,\n+    ids: HashMap<NodeId, Option<Span>>,\n     skip: bool,\n }\n \n impl<'a, 'tcx> Visitor<'tcx> for MutableVarsVisitor<'a, 'tcx> {\n     fn visit_expr(&mut self, ex: &'tcx Expr) {\n         match ex.node {\n             ExprPath(_) => if let Some(node_id) = check_for_mutability(self.cx, &ex) {\n-                self.ids.insert(node_id);\n+                self.ids.insert(node_id, None);\n             },\n \n             // If there is any fuction/method call\u2026 we just stop analysis\n@@ -2206,34 +2208,37 @@ impl<'a, 'tcx> Visitor<'tcx> for MutableVarsVisitor<'a, 'tcx> {\n     }\n }\n \n-/// checks within an expression/statement if any of the variables are used mutably\n-struct MutablyUsedVisitor<'a, 'tcx: 'a> {\n-    cx: &'a LateContext<'a, 'tcx>,\n-    ids: HashSet<NodeId>,\n-    any_used: bool,\n+struct MutVarsDelegate {\n+    mut_spans: HashMap<NodeId, Option<Span>>,\n }\n \n-impl<'a, 'tcx> Visitor<'tcx> for MutablyUsedVisitor<'a, 'tcx> {\n-    fn visit_expr(&mut self, ex: &'tcx Expr) {\n-        if self.any_used { return; }\n-\n-        match ex.node {\n-            ExprAddrOf(MutMutable, ref p) | ExprAssign(ref p, _) | ExprAssignOp(_, ref p, _) =>\n-                if let Some(id) = check_for_mutability(self.cx, p) {\n-                    self.any_used = self.ids.contains(&id);\n-                }\n-            _ => walk_expr(self, ex)\n+impl<'tcx> MutVarsDelegate {\n+    fn update(&mut self, cat: &'tcx Categorization, sp: Span) {\n+        if let &Categorization::Local(id) = cat {\n+            if let Some(span) = self.mut_spans.get_mut(&id) {    \n+                *span = Some(sp)\n+            }\n         }\n     }\n+}\n+\n \n-    fn visit_stmt(&mut self, s: &'tcx Stmt) {\n-        match s.node {\n-            StmtExpr(..) | StmtSemi (..) => walk_stmt(self, s),\n-            _ => {}\n+impl<'tcx> Delegate<'tcx> for MutVarsDelegate {\n+    fn consume(&mut self, _: NodeId, _: Span, _: cmt<'tcx>, _: ConsumeMode) {}\n+\n+    fn matched_pat(&mut self, _: &Pat, _: cmt<'tcx>, _: MatchMode) {}\n+\n+    fn consume_pat(&mut self, _: &Pat, _: cmt<'tcx>, _: ConsumeMode) {}\n+\n+    fn borrow(&mut self, _: NodeId, sp: Span, cmt: cmt<'tcx>, _: ty::Region, bk: ty::BorrowKind, _: LoanCause) {\n+        if let ty::BorrowKind::MutBorrow = bk {\n+            self.update(&cmt.cat, sp)\n         }\n     }\n \n-    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n-        NestedVisitorMap::None\n+    fn mutate(&mut self, _: NodeId, sp: Span, cmt: cmt<'tcx>, _: MutateMode) {\n+            self.update(&cmt.cat, sp)\n     }\n+\n+    fn decl_without_init(&mut self, _: NodeId, _: Span) {}\n }\n\\ No newline at end of file"}]}