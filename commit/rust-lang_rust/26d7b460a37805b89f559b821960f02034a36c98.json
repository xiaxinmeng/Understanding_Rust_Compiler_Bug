{"sha": "26d7b460a37805b89f559b821960f02034a36c98", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI2ZDdiNDYwYTM3ODA1Yjg5ZjU1OWI4MjE5NjBmMDIwMzRhMzZjOTg=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-06-11T15:32:49Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-06-12T02:21:05Z"}, "message": "std: generalise .trim_chars to use CharEq.", "tree": {"sha": "47156ba0cfaae22244d7b3524ebc62052592238e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/47156ba0cfaae22244d7b3524ebc62052592238e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/26d7b460a37805b89f559b821960f02034a36c98", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/26d7b460a37805b89f559b821960f02034a36c98", "html_url": "https://github.com/rust-lang/rust/commit/26d7b460a37805b89f559b821960f02034a36c98", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/26d7b460a37805b89f559b821960f02034a36c98/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "073e82fff27497ea9b7b73173ddfc349463570b7", "url": "https://api.github.com/repos/rust-lang/rust/commits/073e82fff27497ea9b7b73173ddfc349463570b7", "html_url": "https://github.com/rust-lang/rust/commit/073e82fff27497ea9b7b73173ddfc349463570b7"}], "stats": {"total": 120, "additions": 76, "deletions": 44}, "files": [{"sha": "8c2615de26ba27388e9047dc207289e44c62156c", "filename": "src/libextra/num/bigint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/26d7b460a37805b89f559b821960f02034a36c98/src%2Flibextra%2Fnum%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26d7b460a37805b89f559b821960f02034a36c98/src%2Flibextra%2Fnum%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnum%2Fbigint.rs?ref=26d7b460a37805b89f559b821960f02034a36c98", "patch": "@@ -524,7 +524,7 @@ impl ToStrRadix for BigUint {\n                 let s = uint::to_str_radix(*n as uint, radix);\n                 str::from_chars(vec::from_elem(l - s.len(), '0')) + s\n             }).concat();\n-            s.trim_left_chars(['0']).to_owned()\n+            s.trim_left_chars(&'0').to_owned()\n         }\n     }\n }"}, {"sha": "7f57b4b0c0d7a5b3e9236e74b979394f11068c88", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/26d7b460a37805b89f559b821960f02034a36c98/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26d7b460a37805b89f559b821960f02034a36c98/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=26d7b460a37805b89f559b821960f02034a36c98", "patch": "@@ -841,7 +841,7 @@ fn check_item_non_camel_case_types(cx: &Context, it: @ast::item) {\n     fn is_camel_case(cx: ty::ctxt, ident: ast::ident) -> bool {\n         let ident = cx.sess.str_of(ident);\n         assert!(!ident.is_empty());\n-        let ident = ident.trim_chars(&['_']);\n+        let ident = ident.trim_chars(&'_');\n         char::is_uppercase(ident.char_at(0)) &&\n             !ident.contains_char('_')\n     }"}, {"sha": "0a61059cb39d633a27f05ee3107f0e746fec2d03", "filename": "src/libstd/str.rs", "status": "modified", "additions": 74, "deletions": 42, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/26d7b460a37805b89f559b821960f02034a36c98/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26d7b460a37805b89f559b821960f02034a36c98/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=26d7b460a37805b89f559b821960f02034a36c98", "patch": "@@ -255,6 +255,17 @@ impl CharEq for extern \"Rust\" fn(char) -> bool {\n     fn only_ascii(&self) -> bool { false }\n }\n \n+impl<'self, C: CharEq> CharEq for &'self [C] {\n+    #[inline(always)]\n+    fn matches(&self, c: char) -> bool {\n+        self.iter().any(|m| m.matches(c))\n+    }\n+\n+    fn only_ascii(&self) -> bool {\n+        self.iter().all(|m| m.only_ascii())\n+    }\n+}\n+\n \n /// An iterator over the substrings of a string, separated by `sep`.\n pub struct StrCharSplitIterator<'self,Sep> {\n@@ -1249,9 +1260,9 @@ pub trait StrSlice<'self> {\n     fn trim(&self) -> &'self str;\n     fn trim_left(&self) -> &'self str;\n     fn trim_right(&self) -> &'self str;\n-    fn trim_chars(&self, chars_to_trim: &[char]) -> &'self str;\n-    fn trim_left_chars(&self, chars_to_trim: &[char]) -> &'self str;\n-    fn trim_right_chars(&self, chars_to_trim: &[char]) -> &'self str;\n+    fn trim_chars<C: CharEq>(&self, to_trim: &C) -> &'self str;\n+    fn trim_left_chars<C: CharEq>(&self, to_trim: &C) -> &'self str;\n+    fn trim_right_chars<C: CharEq>(&self, to_trim: &C) -> &'self str;\n     fn replace(&self, from: &str, to: &str) -> ~str;\n     fn to_owned(&self) -> ~str;\n     fn to_managed(&self) -> @str;\n@@ -1542,49 +1553,51 @@ impl<'self> StrSlice<'self> for &'self str {\n     /// Returns a string with leading whitespace removed\n     #[inline]\n     fn trim_left(&self) -> &'self str {\n-        match self.find(|c| !char::is_whitespace(c)) {\n-            None => \"\",\n-            Some(first) => unsafe { raw::slice_bytes(*self, first, self.len()) }\n-        }\n+        self.trim_left_chars(&char::is_whitespace)\n     }\n     /// Returns a string with trailing whitespace removed\n     #[inline]\n     fn trim_right(&self) -> &'self str {\n-        match self.rfind(|c| !char::is_whitespace(c)) {\n-            None => \"\",\n-            Some(last) => {\n-                let next = self.char_range_at(last).next;\n-                unsafe { raw::slice_bytes(*self, 0u, next) }\n-            }\n-        }\n+        self.trim_right_chars(&char::is_whitespace)\n     }\n \n     /**\n-     * Returns a string with leading and trailing `chars_to_trim` removed.\n+     * Returns a string with characters that match `to_trim` removed.\n      *\n      * # Arguments\n      *\n-     * * chars_to_trim - A vector of chars\n+     * * to_trim - a character matcher\n+     *\n+     * # Example\n      *\n+     * ~~~\n+     * assert_eq!(\"11foo1bar11\".trim_chars(&'1'), \"foo1bar\")\n+     * assert_eq!(\"12foo1bar12\".trim_chars(& &['1', '2']), \"foo1bar\")\n+     * assert_eq!(\"123foo1bar123\".trim_chars(&|c: char| c.is_digit()), \"foo1bar\")\n+     * ~~~\n      */\n     #[inline]\n-    fn trim_chars(&self, chars_to_trim: &[char]) -> &'self str {\n-        self.trim_left_chars(chars_to_trim).trim_right_chars(chars_to_trim)\n+    fn trim_chars<C: CharEq>(&self, to_trim: &C) -> &'self str {\n+        self.trim_left_chars(to_trim).trim_right_chars(to_trim)\n     }\n     /**\n      * Returns a string with leading `chars_to_trim` removed.\n      *\n      * # Arguments\n      *\n-     * * s - A string\n-     * * chars_to_trim - A vector of chars\n+     * * to_trim - a character matcher\n+     *\n+     * # Example\n      *\n+     * ~~~\n+     * assert_eq!(\"11foo1bar11\".trim_left_chars(&'1'), \"foo1bar11\")\n+     * assert_eq!(\"12foo1bar12\".trim_left_chars(& &['1', '2']), \"foo1bar12\")\n+     * assert_eq!(\"123foo1bar123\".trim_left_chars(&|c: char| c.is_digit()), \"foo1bar123\")\n+     * ~~~\n      */\n     #[inline]\n-    fn trim_left_chars(&self, chars_to_trim: &[char]) -> &'self str {\n-        if chars_to_trim.is_empty() { return *self; }\n-\n-        match self.find(|c| !chars_to_trim.contains(&c)) {\n+    fn trim_left_chars<C: CharEq>(&self, to_trim: &C) -> &'self str {\n+        match self.find(|c: char| !to_trim.matches(c)) {\n             None => \"\",\n             Some(first) => unsafe { raw::slice_bytes(*self, first, self.len()) }\n         }\n@@ -1594,15 +1607,19 @@ impl<'self> StrSlice<'self> for &'self str {\n      *\n      * # Arguments\n      *\n-     * * s - A string\n-     * * chars_to_trim - A vector of chars\n+     * * to_trim - a character matcher\n+     *\n+     * # Example\n      *\n+     * ~~~\n+     * assert_eq!(\"11foo1bar11\".trim_right_chars(&'1'), \"11foo1bar\")\n+     * assert_eq!(\"12foo1bar12\".trim_right_chars(& &['1', '2']), \"12foo1bar\")\n+     * assert_eq!(\"123foo1bar123\".trim_right_chars(&|c: char| c.is_digit()), \"123foo1bar\")\n+     * ~~~\n      */\n     #[inline]\n-    fn trim_right_chars(&self, chars_to_trim: &[char]) -> &'self str {\n-        if chars_to_trim.is_empty() { return *self; }\n-\n-        match self.rfind(|c| !chars_to_trim.contains(&c)) {\n+    fn trim_right_chars<C: CharEq>(&self, to_trim: &C) -> &'self str {\n+        match self.rfind(|c: char| !to_trim.matches(c)) {\n             None => \"\",\n             Some(last) => {\n                 let next = self.char_range_at(last).next;\n@@ -2661,26 +2678,41 @@ mod tests {\n \n     #[test]\n     fn test_trim_left_chars() {\n-        assert_eq!(\" *** foo *** \".trim_left_chars([]), \" *** foo *** \");\n-        assert_eq!(\" *** foo *** \".trim_left_chars(['*', ' ']), \"foo *** \");\n-        assert_eq!(\" ***  *** \".trim_left_chars(['*', ' ']), \"\");\n-        assert_eq!(\"foo *** \".trim_left_chars(['*', ' ']), \"foo *** \");\n+        let v: &[char] = &[];\n+        assert_eq!(\" *** foo *** \".trim_left_chars(&v), \" *** foo *** \");\n+        assert_eq!(\" *** foo *** \".trim_left_chars(& &['*', ' ']), \"foo *** \");\n+        assert_eq!(\" ***  *** \".trim_left_chars(& &['*', ' ']), \"\");\n+        assert_eq!(\"foo *** \".trim_left_chars(& &['*', ' ']), \"foo *** \");\n+\n+        assert_eq!(\"11foo1bar11\".trim_left_chars(&'1'), \"foo1bar11\");\n+        assert_eq!(\"12foo1bar12\".trim_left_chars(& &['1', '2']), \"foo1bar12\");\n+        assert_eq!(\"123foo1bar123\".trim_left_chars(&|c: char| c.is_digit()), \"foo1bar123\");\n     }\n \n     #[test]\n     fn test_trim_right_chars() {\n-        assert_eq!(\" *** foo *** \".trim_right_chars([]), \" *** foo *** \");\n-        assert_eq!(\" *** foo *** \".trim_right_chars(['*', ' ']), \" *** foo\");\n-        assert_eq!(\" ***  *** \".trim_right_chars(['*', ' ']), \"\");\n-        assert_eq!(\" *** foo\".trim_right_chars(['*', ' ']), \" *** foo\");\n+        let v: &[char] = &[];\n+        assert_eq!(\" *** foo *** \".trim_right_chars(&v), \" *** foo *** \");\n+        assert_eq!(\" *** foo *** \".trim_right_chars(& &['*', ' ']), \" *** foo\");\n+        assert_eq!(\" ***  *** \".trim_right_chars(& &['*', ' ']), \"\");\n+        assert_eq!(\" *** foo\".trim_right_chars(& &['*', ' ']), \" *** foo\");\n+\n+        assert_eq!(\"11foo1bar11\".trim_right_chars(&'1'), \"11foo1bar\");\n+        assert_eq!(\"12foo1bar12\".trim_right_chars(& &['1', '2']), \"12foo1bar\");\n+        assert_eq!(\"123foo1bar123\".trim_right_chars(&|c: char| c.is_digit()), \"123foo1bar\");\n     }\n \n     #[test]\n     fn test_trim_chars() {\n-        assert_eq!(\" *** foo *** \".trim_chars([]), \" *** foo *** \");\n-        assert_eq!(\" *** foo *** \".trim_chars(['*', ' ']), \"foo\");\n-        assert_eq!(\" ***  *** \".trim_chars(['*', ' ']), \"\");\n-        assert_eq!(\"foo\".trim_chars(['*', ' ']), \"foo\");\n+        let v: &[char] = &[];\n+        assert_eq!(\" *** foo *** \".trim_chars(&v), \" *** foo *** \");\n+        assert_eq!(\" *** foo *** \".trim_chars(& &['*', ' ']), \"foo\");\n+        assert_eq!(\" ***  *** \".trim_chars(& &['*', ' ']), \"\");\n+        assert_eq!(\"foo\".trim_chars(& &['*', ' ']), \"foo\");\n+\n+        assert_eq!(\"11foo1bar11\".trim_chars(&'1'), \"foo1bar\");\n+        assert_eq!(\"12foo1bar12\".trim_chars(& &['1', '2']), \"foo1bar\");\n+        assert_eq!(\"123foo1bar123\".trim_chars(&|c: char| c.is_digit()), \"foo1bar\");\n     }\n \n     #[test]"}]}