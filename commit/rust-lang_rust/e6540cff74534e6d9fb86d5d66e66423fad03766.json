{"sha": "e6540cff74534e6d9fb86d5d66e66423fad03766", "node_id": "C_kwDOAAsO6NoAKGU2NTQwY2ZmNzQ1MzRlNmQ5ZmI4NmQ1ZDY2ZTY2NDIzZmFkMDM3NjY", "commit": {"author": {"name": "Amos Wenger", "email": "amoswenger@gmail.com", "date": "2022-11-25T12:03:10Z"}, "committer": {"name": "Amos Wenger", "email": "amoswenger@gmail.com", "date": "2022-11-25T12:03:10Z"}, "message": "Merge commit '4f55ebbd4' into HEAD", "tree": {"sha": "3fc6f9ac1884343b4b2aebe91daf5c5c73dee454", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3fc6f9ac1884343b4b2aebe91daf5c5c73dee454"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e6540cff74534e6d9fb86d5d66e66423fad03766", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e6540cff74534e6d9fb86d5d66e66423fad03766", "html_url": "https://github.com/rust-lang/rust/commit/e6540cff74534e6d9fb86d5d66e66423fad03766", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e6540cff74534e6d9fb86d5d66e66423fad03766/comments", "author": {"login": "fasterthanlime", "id": 7998310, "node_id": "MDQ6VXNlcjc5OTgzMTA=", "avatar_url": "https://avatars.githubusercontent.com/u/7998310?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fasterthanlime", "html_url": "https://github.com/fasterthanlime", "followers_url": "https://api.github.com/users/fasterthanlime/followers", "following_url": "https://api.github.com/users/fasterthanlime/following{/other_user}", "gists_url": "https://api.github.com/users/fasterthanlime/gists{/gist_id}", "starred_url": "https://api.github.com/users/fasterthanlime/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fasterthanlime/subscriptions", "organizations_url": "https://api.github.com/users/fasterthanlime/orgs", "repos_url": "https://api.github.com/users/fasterthanlime/repos", "events_url": "https://api.github.com/users/fasterthanlime/events{/privacy}", "received_events_url": "https://api.github.com/users/fasterthanlime/received_events", "type": "User", "site_admin": false}, "committer": {"login": "fasterthanlime", "id": 7998310, "node_id": "MDQ6VXNlcjc5OTgzMTA=", "avatar_url": "https://avatars.githubusercontent.com/u/7998310?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fasterthanlime", "html_url": "https://github.com/fasterthanlime", "followers_url": "https://api.github.com/users/fasterthanlime/followers", "following_url": "https://api.github.com/users/fasterthanlime/following{/other_user}", "gists_url": "https://api.github.com/users/fasterthanlime/gists{/gist_id}", "starred_url": "https://api.github.com/users/fasterthanlime/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fasterthanlime/subscriptions", "organizations_url": "https://api.github.com/users/fasterthanlime/orgs", "repos_url": "https://api.github.com/users/fasterthanlime/repos", "events_url": "https://api.github.com/users/fasterthanlime/events{/privacy}", "received_events_url": "https://api.github.com/users/fasterthanlime/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bc9b6138081526d629fc8c9dc30c823809a762a4", "url": "https://api.github.com/repos/rust-lang/rust/commits/bc9b6138081526d629fc8c9dc30c823809a762a4", "html_url": "https://github.com/rust-lang/rust/commit/bc9b6138081526d629fc8c9dc30c823809a762a4"}, {"sha": "4f55ebbd4fb2aaf6ac97e484c07504e5124422e7", "url": "https://api.github.com/repos/rust-lang/rust/commits/4f55ebbd4fb2aaf6ac97e484c07504e5124422e7", "html_url": "https://github.com/rust-lang/rust/commit/4f55ebbd4fb2aaf6ac97e484c07504e5124422e7"}], "stats": {"total": 3998, "additions": 2895, "deletions": 1103}, "files": [{"sha": "744330b142ab2f21fd93e7c88337ee66ba0b8657", "filename": "Cargo.lock", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/e6540cff74534e6d9fb86d5d66e66423fad03766/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/e6540cff74534e6d9fb86d5d66e66423fad03766/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=e6540cff74534e6d9fb86d5d66e66423fad03766", "patch": "@@ -863,7 +863,7 @@ dependencies = [\n \n [[package]]\n name = \"lsp-server\"\n-version = \"0.6.0\"\n+version = \"0.7.0\"\n dependencies = [\n  \"crossbeam-channel\",\n  \"log\",\n@@ -1190,9 +1190,9 @@ version = \"0.0.0\"\n \n [[package]]\n name = \"proc-macro2\"\n-version = \"1.0.43\"\n+version = \"1.0.46\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"0a2ca2c61bc9f3d74d2886294ab7b9853abd9c1ad903a3ac7815c58989bb7bab\"\n+checksum = \"94e2ef8dbfc347b10c094890f778ee2e36ca9bb4262e86dc99cd217e35f3470b\"\n dependencies = [\n  \"unicode-ident\",\n ]\n@@ -1502,18 +1502,18 @@ dependencies = [\n \n [[package]]\n name = \"serde\"\n-version = \"1.0.143\"\n+version = \"1.0.144\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"53e8e5d5b70924f74ff5c6d64d9a5acd91422117c60f48c4e07855238a254553\"\n+checksum = \"0f747710de3dcd43b88c9168773254e809d8ddbdf9653b84e2554ab219f17860\"\n dependencies = [\n  \"serde_derive\",\n ]\n \n [[package]]\n name = \"serde_derive\"\n-version = \"1.0.143\"\n+version = \"1.0.144\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"d3d8e8de557aee63c26b85b947f5e59b690d0454c753f3adeb5cd7835ab88391\"\n+checksum = \"94ed3a816fb1d101812f83e789f888322c34e291f894f19590dc310963e87a00\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n@@ -1522,9 +1522,9 @@ dependencies = [\n \n [[package]]\n name = \"serde_json\"\n-version = \"1.0.83\"\n+version = \"1.0.85\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"38dd04e3c8279e75b31ef29dbdceebfe5ad89f4d0937213c53f7d49d01b3d5a7\"\n+checksum = \"e55a28e3aaef9d5ce0506d0a14dbba8054ddc7e499ef522dd8b26859ec9d4a44\"\n dependencies = [\n  \"indexmap\",\n  \"itoa\",\n@@ -1593,9 +1593,9 @@ dependencies = [\n \n [[package]]\n name = \"syn\"\n-version = \"1.0.99\"\n+version = \"1.0.102\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"58dbef6ec655055e20b86b15a8cc6d439cca19b667537ac6a1369572d151ab13\"\n+checksum = \"3fcd952facd492f9be3ef0d0b7032a6e442ee9b361d4acc2b1d0c4aaa5f613a1\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n@@ -2082,18 +2082,18 @@ checksum = \"06069a848f95fceae3e5e03c0ddc8cb78452b56654ee0c8e68f938cf790fb9e3\"\n \n [[package]]\n name = \"xflags\"\n-version = \"0.2.4\"\n+version = \"0.3.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"3f14fe1ed41a5a2b5ef3f565586c4a8a559ee55d3953faab360a771135bdee00\"\n+checksum = \"cbf19f5031a1a812e96fede16f8161218883079946cea87619d3613db1efd268\"\n dependencies = [\n  \"xflags-macros\",\n ]\n \n [[package]]\n name = \"xflags-macros\"\n-version = \"0.2.4\"\n+version = \"0.3.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"45d11d5fc2a97287eded8b170ca80533b3c42646dd7fa386a5eb045817921022\"\n+checksum = \"2afbd7f2039bb6cad2dd45f0c5dff49c0d4e26118398768b7a605524d4251809\"\n \n [[package]]\n name = \"xshell\""}, {"sha": "5b7828a26996eaaacd6df0f758834f2ed8c8673d", "filename": "crates/base-db/src/fixture.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fbase-db%2Fsrc%2Ffixture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fbase-db%2Fsrc%2Ffixture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fbase-db%2Fsrc%2Ffixture.rs?ref=e6540cff74534e6d9fb86d5d66e66423fad03766", "patch": "@@ -196,7 +196,7 @@ impl ChangeFixture {\n                 Env::default(),\n                 Ok(Vec::new()),\n                 false,\n-                CrateOrigin::CratesIo { repo: None },\n+                CrateOrigin::CratesIo { repo: None, name: None },\n             );\n         } else {\n             for (from, to, prelude) in crate_deps {\n@@ -270,7 +270,7 @@ impl ChangeFixture {\n                 Env::default(),\n                 Ok(proc_macro),\n                 true,\n-                CrateOrigin::CratesIo { repo: None },\n+                CrateOrigin::CratesIo { repo: None, name: None },\n             );\n \n             for krate in all_crates {\n@@ -398,7 +398,7 @@ fn parse_crate(crate_str: String) -> (String, CrateOrigin, Option<String>) {\n         let (version, origin) = match b.split_once(':') {\n             Some((\"CratesIo\", data)) => match data.split_once(',') {\n                 Some((version, url)) => {\n-                    (version, CrateOrigin::CratesIo { repo: Some(url.to_owned()) })\n+                    (version, CrateOrigin::CratesIo { repo: Some(url.to_owned()), name: None })\n                 }\n                 _ => panic!(\"Bad crates.io parameter: {}\", data),\n             },\n@@ -409,7 +409,7 @@ fn parse_crate(crate_str: String) -> (String, CrateOrigin, Option<String>) {\n         let crate_origin = match &*crate_str {\n             \"std\" => CrateOrigin::Lang(LangCrateOrigin::Std),\n             \"core\" => CrateOrigin::Lang(LangCrateOrigin::Core),\n-            _ => CrateOrigin::CratesIo { repo: None },\n+            _ => CrateOrigin::CratesIo { repo: None, name: None },\n         };\n         (crate_str, crate_origin, None)\n     }"}, {"sha": "e7f0c4ec29bf4e9bcfca1cd98df06c457ca033b9", "filename": "crates/base-db/src/input.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fbase-db%2Fsrc%2Finput.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fbase-db%2Fsrc%2Finput.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fbase-db%2Fsrc%2Finput.rs?ref=e6540cff74534e6d9fb86d5d66e66423fad03766", "patch": "@@ -136,7 +136,7 @@ impl ops::Deref for CrateName {\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub enum CrateOrigin {\n     /// Crates that are from crates.io official registry,\n-    CratesIo { repo: Option<String> },\n+    CratesIo { repo: Option<String>, name: Option<String> },\n     /// Crates that are provided by the language, like std, core, proc-macro, ...\n     Lang(LangCrateOrigin),\n }\n@@ -648,7 +648,7 @@ mod tests {\n             Env::default(),\n             Ok(Vec::new()),\n             false,\n-            CrateOrigin::CratesIo { repo: None },\n+            CrateOrigin::CratesIo { repo: None, name: None },\n         );\n         let crate2 = graph.add_crate_root(\n             FileId(2u32),\n@@ -660,7 +660,7 @@ mod tests {\n             Env::default(),\n             Ok(Vec::new()),\n             false,\n-            CrateOrigin::CratesIo { repo: None },\n+            CrateOrigin::CratesIo { repo: None, name: None },\n         );\n         let crate3 = graph.add_crate_root(\n             FileId(3u32),\n@@ -672,7 +672,7 @@ mod tests {\n             Env::default(),\n             Ok(Vec::new()),\n             false,\n-            CrateOrigin::CratesIo { repo: None },\n+            CrateOrigin::CratesIo { repo: None, name: None },\n         );\n         assert!(graph\n             .add_dep(crate1, Dependency::new(CrateName::new(\"crate2\").unwrap(), crate2))\n@@ -698,7 +698,7 @@ mod tests {\n             Env::default(),\n             Ok(Vec::new()),\n             false,\n-            CrateOrigin::CratesIo { repo: None },\n+            CrateOrigin::CratesIo { repo: None, name: None },\n         );\n         let crate2 = graph.add_crate_root(\n             FileId(2u32),\n@@ -710,7 +710,7 @@ mod tests {\n             Env::default(),\n             Ok(Vec::new()),\n             false,\n-            CrateOrigin::CratesIo { repo: None },\n+            CrateOrigin::CratesIo { repo: None, name: None },\n         );\n         assert!(graph\n             .add_dep(crate1, Dependency::new(CrateName::new(\"crate2\").unwrap(), crate2))\n@@ -733,7 +733,7 @@ mod tests {\n             Env::default(),\n             Ok(Vec::new()),\n             false,\n-            CrateOrigin::CratesIo { repo: None },\n+            CrateOrigin::CratesIo { repo: None, name: None },\n         );\n         let crate2 = graph.add_crate_root(\n             FileId(2u32),\n@@ -745,7 +745,7 @@ mod tests {\n             Env::default(),\n             Ok(Vec::new()),\n             false,\n-            CrateOrigin::CratesIo { repo: None },\n+            CrateOrigin::CratesIo { repo: None, name: None },\n         );\n         let crate3 = graph.add_crate_root(\n             FileId(3u32),\n@@ -757,7 +757,7 @@ mod tests {\n             Env::default(),\n             Ok(Vec::new()),\n             false,\n-            CrateOrigin::CratesIo { repo: None },\n+            CrateOrigin::CratesIo { repo: None, name: None },\n         );\n         assert!(graph\n             .add_dep(crate1, Dependency::new(CrateName::new(\"crate2\").unwrap(), crate2))\n@@ -780,7 +780,7 @@ mod tests {\n             Env::default(),\n             Ok(Vec::new()),\n             false,\n-            CrateOrigin::CratesIo { repo: None },\n+            CrateOrigin::CratesIo { repo: None, name: None },\n         );\n         let crate2 = graph.add_crate_root(\n             FileId(2u32),\n@@ -792,7 +792,7 @@ mod tests {\n             Env::default(),\n             Ok(Vec::new()),\n             false,\n-            CrateOrigin::CratesIo { repo: None },\n+            CrateOrigin::CratesIo { repo: None, name: None },\n         );\n         assert!(graph\n             .add_dep("}, {"sha": "e8c63d410aa754dd428aee664c771253caa30806", "filename": "crates/flycheck/src/lib.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fflycheck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fflycheck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fflycheck%2Fsrc%2Flib.rs?ref=e6540cff74534e6d9fb86d5d66e66423fad03766", "patch": "@@ -169,21 +169,30 @@ impl FlycheckActor {\n     }\n     fn next_event(&self, inbox: &Receiver<Restart>) -> Option<Event> {\n         let check_chan = self.cargo_handle.as_ref().map(|cargo| &cargo.receiver);\n+        if let Ok(msg) = inbox.try_recv() {\n+            // give restarts a preference so check outputs don't block a restart or stop\n+            return Some(Event::Restart(msg));\n+        }\n         select! {\n             recv(inbox) -> msg => msg.ok().map(Event::Restart),\n             recv(check_chan.unwrap_or(&never())) -> msg => Some(Event::CheckEvent(msg.ok())),\n         }\n     }\n     fn run(mut self, inbox: Receiver<Restart>) {\n-        while let Some(event) = self.next_event(&inbox) {\n+        'event: while let Some(event) = self.next_event(&inbox) {\n             match event {\n                 Event::Restart(Restart::No) => {\n                     self.cancel_check_process();\n                 }\n                 Event::Restart(Restart::Yes) => {\n                     // Cancel the previously spawned process\n                     self.cancel_check_process();\n-                    while let Ok(_) = inbox.recv_timeout(Duration::from_millis(50)) {}\n+                    while let Ok(restart) = inbox.recv_timeout(Duration::from_millis(50)) {\n+                        // restart chained with a stop, so just cancel\n+                        if let Restart::No = restart {\n+                            continue 'event;\n+                        }\n+                    }\n \n                     let command = self.check_command();\n                     tracing::debug!(?command, \"will restart flycheck\");"}, {"sha": "938db032fbc8b6a79b130030750b1e48898857bd", "filename": "crates/hir-def/src/adt.rs", "status": "modified", "additions": 199, "deletions": 45, "changes": 244, "blob_url": "https://github.com/rust-lang/rust/blob/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fhir-def%2Fsrc%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fhir-def%2Fsrc%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fadt.rs?ref=e6540cff74534e6d9fb86d5d66e66423fad03766", "patch": "@@ -1,28 +1,31 @@\n //! Defines hir-level representation of structs, enums and unions\n \n-use std::sync::Arc;\n+use std::{num::NonZeroU32, sync::Arc};\n \n use base_db::CrateId;\n use either::Either;\n use hir_expand::{\n     name::{AsName, Name},\n-    InFile,\n+    HirFileId, InFile,\n };\n use la_arena::{Arena, ArenaMap};\n use syntax::ast::{self, HasName, HasVisibility};\n use tt::{Delimiter, DelimiterKind, Leaf, Subtree, TokenTree};\n \n use crate::{\n     body::{CfgExpander, LowerCtx},\n+    builtin_type::{BuiltinInt, BuiltinUint},\n     db::DefDatabase,\n     intern::Interned,\n-    item_tree::{AttrOwner, Field, Fields, ItemTree, ModItem, RawVisibilityId},\n+    item_tree::{AttrOwner, Field, FieldAstId, Fields, ItemTree, ModItem, RawVisibilityId},\n+    nameres::diagnostics::DefDiagnostic,\n     src::HasChildSource,\n     src::HasSource,\n     trace::Trace,\n     type_ref::TypeRef,\n     visibility::RawVisibility,\n-    EnumId, LocalEnumVariantId, LocalFieldId, Lookup, ModuleId, StructId, UnionId, VariantId,\n+    EnumId, LocalEnumVariantId, LocalFieldId, LocalModuleId, Lookup, ModuleId, StructId, UnionId,\n+    VariantId,\n };\n use cfg::CfgOptions;\n \n@@ -31,14 +34,15 @@ use cfg::CfgOptions;\n pub struct StructData {\n     pub name: Name,\n     pub variant_data: Arc<VariantData>,\n-    pub repr: Option<ReprKind>,\n+    pub repr: Option<ReprData>,\n     pub visibility: RawVisibility,\n }\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n pub struct EnumData {\n     pub name: Name,\n     pub variants: Arena<EnumVariantData>,\n+    pub repr: Option<ReprData>,\n     pub visibility: RawVisibility,\n }\n \n@@ -63,109 +67,226 @@ pub struct FieldData {\n     pub visibility: RawVisibility,\n }\n \n-#[derive(Debug, Clone, PartialEq, Eq)]\n+#[derive(Copy, Debug, Clone, PartialEq, Eq)]\n pub enum ReprKind {\n-    Packed,\n-    Other,\n+    C,\n+    BuiltinInt { builtin: Either<BuiltinInt, BuiltinUint>, is_c: bool },\n+    Transparent,\n+    Default,\n+}\n+\n+#[derive(Copy, Debug, Clone, PartialEq, Eq)]\n+pub struct ReprData {\n+    pub kind: ReprKind,\n+    pub packed: bool,\n+    pub align: Option<NonZeroU32>,\n }\n \n fn repr_from_value(\n     db: &dyn DefDatabase,\n     krate: CrateId,\n     item_tree: &ItemTree,\n     of: AttrOwner,\n-) -> Option<ReprKind> {\n+) -> Option<ReprData> {\n     item_tree.attrs(db, krate, of).by_key(\"repr\").tt_values().find_map(parse_repr_tt)\n }\n \n-fn parse_repr_tt(tt: &Subtree) -> Option<ReprKind> {\n+fn parse_repr_tt(tt: &Subtree) -> Option<ReprData> {\n     match tt.delimiter {\n         Some(Delimiter { kind: DelimiterKind::Parenthesis, .. }) => {}\n         _ => return None,\n     }\n \n-    let mut it = tt.token_trees.iter();\n-    match it.next()? {\n-        TokenTree::Leaf(Leaf::Ident(ident)) if ident.text == \"packed\" => Some(ReprKind::Packed),\n-        _ => Some(ReprKind::Other),\n+    let mut data = ReprData { kind: ReprKind::Default, packed: false, align: None };\n+\n+    let mut tts = tt.token_trees.iter().peekable();\n+    while let Some(tt) = tts.next() {\n+        if let TokenTree::Leaf(Leaf::Ident(ident)) = tt {\n+            match &*ident.text {\n+                \"packed\" => {\n+                    data.packed = true;\n+                    if let Some(TokenTree::Subtree(_)) = tts.peek() {\n+                        tts.next();\n+                    }\n+                }\n+                \"align\" => {\n+                    if let Some(TokenTree::Subtree(tt)) = tts.peek() {\n+                        tts.next();\n+                        if let Some(TokenTree::Leaf(Leaf::Literal(lit))) = tt.token_trees.first() {\n+                            if let Ok(align) = lit.text.parse() {\n+                                data.align = Some(align);\n+                            }\n+                        }\n+                    }\n+                }\n+                \"C\" => {\n+                    if let ReprKind::BuiltinInt { is_c, .. } = &mut data.kind {\n+                        *is_c = true;\n+                    } else {\n+                        data.kind = ReprKind::C;\n+                    }\n+                }\n+                \"transparent\" => data.kind = ReprKind::Transparent,\n+                repr => {\n+                    let is_c = matches!(data.kind, ReprKind::C);\n+                    if let Some(builtin) = BuiltinInt::from_suffix(repr)\n+                        .map(Either::Left)\n+                        .or_else(|| BuiltinUint::from_suffix(repr).map(Either::Right))\n+                    {\n+                        data.kind = ReprKind::BuiltinInt { builtin, is_c };\n+                    }\n+                }\n+            }\n+        }\n     }\n+\n+    Some(data)\n }\n \n impl StructData {\n     pub(crate) fn struct_data_query(db: &dyn DefDatabase, id: StructId) -> Arc<StructData> {\n+        db.struct_data_with_diagnostics(id).0\n+    }\n+\n+    pub(crate) fn struct_data_with_diagnostics_query(\n+        db: &dyn DefDatabase,\n+        id: StructId,\n+    ) -> (Arc<StructData>, Arc<[DefDiagnostic]>) {\n         let loc = id.lookup(db);\n         let krate = loc.container.krate;\n         let item_tree = loc.id.item_tree(db);\n         let repr = repr_from_value(db, krate, &item_tree, ModItem::from(loc.id.value).into());\n         let cfg_options = db.crate_graph()[loc.container.krate].cfg_options.clone();\n \n         let strukt = &item_tree[loc.id.value];\n-        let variant_data = lower_fields(db, krate, &item_tree, &cfg_options, &strukt.fields, None);\n-        Arc::new(StructData {\n-            name: strukt.name.clone(),\n-            variant_data: Arc::new(variant_data),\n-            repr,\n-            visibility: item_tree[strukt.visibility].clone(),\n-        })\n+        let (variant_data, diagnostics) = lower_fields(\n+            db,\n+            krate,\n+            loc.id.file_id(),\n+            loc.container.local_id,\n+            &item_tree,\n+            &cfg_options,\n+            &strukt.fields,\n+            None,\n+        );\n+        (\n+            Arc::new(StructData {\n+                name: strukt.name.clone(),\n+                variant_data: Arc::new(variant_data),\n+                repr,\n+                visibility: item_tree[strukt.visibility].clone(),\n+            }),\n+            diagnostics.into(),\n+        )\n     }\n+\n     pub(crate) fn union_data_query(db: &dyn DefDatabase, id: UnionId) -> Arc<StructData> {\n+        db.union_data_with_diagnostics(id).0\n+    }\n+\n+    pub(crate) fn union_data_with_diagnostics_query(\n+        db: &dyn DefDatabase,\n+        id: UnionId,\n+    ) -> (Arc<StructData>, Arc<[DefDiagnostic]>) {\n         let loc = id.lookup(db);\n         let krate = loc.container.krate;\n         let item_tree = loc.id.item_tree(db);\n         let repr = repr_from_value(db, krate, &item_tree, ModItem::from(loc.id.value).into());\n         let cfg_options = db.crate_graph()[loc.container.krate].cfg_options.clone();\n \n         let union = &item_tree[loc.id.value];\n-        let variant_data = lower_fields(db, krate, &item_tree, &cfg_options, &union.fields, None);\n-\n-        Arc::new(StructData {\n-            name: union.name.clone(),\n-            variant_data: Arc::new(variant_data),\n-            repr,\n-            visibility: item_tree[union.visibility].clone(),\n-        })\n+        let (variant_data, diagnostics) = lower_fields(\n+            db,\n+            krate,\n+            loc.id.file_id(),\n+            loc.container.local_id,\n+            &item_tree,\n+            &cfg_options,\n+            &union.fields,\n+            None,\n+        );\n+        (\n+            Arc::new(StructData {\n+                name: union.name.clone(),\n+                variant_data: Arc::new(variant_data),\n+                repr,\n+                visibility: item_tree[union.visibility].clone(),\n+            }),\n+            diagnostics.into(),\n+        )\n     }\n }\n \n impl EnumData {\n     pub(crate) fn enum_data_query(db: &dyn DefDatabase, e: EnumId) -> Arc<EnumData> {\n+        db.enum_data_with_diagnostics(e).0\n+    }\n+\n+    pub(crate) fn enum_data_with_diagnostics_query(\n+        db: &dyn DefDatabase,\n+        e: EnumId,\n+    ) -> (Arc<EnumData>, Arc<[DefDiagnostic]>) {\n         let loc = e.lookup(db);\n         let krate = loc.container.krate;\n         let item_tree = loc.id.item_tree(db);\n         let cfg_options = db.crate_graph()[krate].cfg_options.clone();\n+        let repr = repr_from_value(db, krate, &item_tree, ModItem::from(loc.id.value).into());\n \n         let enum_ = &item_tree[loc.id.value];\n         let mut variants = Arena::new();\n+        let mut diagnostics = Vec::new();\n         for tree_id in enum_.variants.clone() {\n-            if item_tree.attrs(db, krate, tree_id.into()).is_cfg_enabled(&cfg_options) {\n-                let var = &item_tree[tree_id];\n-                let var_data = lower_fields(\n+            let attrs = item_tree.attrs(db, krate, tree_id.into());\n+            let var = &item_tree[tree_id];\n+            if attrs.is_cfg_enabled(&cfg_options) {\n+                let (var_data, field_diagnostics) = lower_fields(\n                     db,\n                     krate,\n+                    loc.id.file_id(),\n+                    loc.container.local_id,\n                     &item_tree,\n                     &cfg_options,\n                     &var.fields,\n                     Some(enum_.visibility),\n                 );\n+                diagnostics.extend(field_diagnostics);\n \n                 variants.alloc(EnumVariantData {\n                     name: var.name.clone(),\n                     variant_data: Arc::new(var_data),\n                 });\n+            } else {\n+                diagnostics.push(DefDiagnostic::unconfigured_code(\n+                    loc.container.local_id,\n+                    InFile::new(loc.id.file_id(), var.ast_id.upcast()),\n+                    attrs.cfg().unwrap(),\n+                    cfg_options.clone(),\n+                ))\n             }\n         }\n \n-        Arc::new(EnumData {\n-            name: enum_.name.clone(),\n-            variants,\n-            visibility: item_tree[enum_.visibility].clone(),\n-        })\n+        (\n+            Arc::new(EnumData {\n+                name: enum_.name.clone(),\n+                variants,\n+                repr,\n+                visibility: item_tree[enum_.visibility].clone(),\n+            }),\n+            diagnostics.into(),\n+        )\n     }\n \n     pub fn variant(&self, name: &Name) -> Option<LocalEnumVariantId> {\n         let (id, _) = self.variants.iter().find(|(_id, data)| &data.name == name)?;\n         Some(id)\n     }\n+\n+    pub fn variant_body_type(&self) -> Either<BuiltinInt, BuiltinUint> {\n+        match self.repr {\n+            Some(ReprData { kind: ReprKind::BuiltinInt { builtin, .. }, .. }) => builtin,\n+            _ => Either::Left(BuiltinInt::Isize),\n+        }\n+    }\n }\n \n impl HasChildSource<LocalEnumVariantId> for EnumId {\n@@ -324,31 +445,64 @@ fn lower_struct(\n fn lower_fields(\n     db: &dyn DefDatabase,\n     krate: CrateId,\n+    current_file_id: HirFileId,\n+    container: LocalModuleId,\n     item_tree: &ItemTree,\n     cfg_options: &CfgOptions,\n     fields: &Fields,\n     override_visibility: Option<RawVisibilityId>,\n-) -> VariantData {\n+) -> (VariantData, Vec<DefDiagnostic>) {\n+    let mut diagnostics = Vec::new();\n     match fields {\n         Fields::Record(flds) => {\n             let mut arena = Arena::new();\n             for field_id in flds.clone() {\n-                if item_tree.attrs(db, krate, field_id.into()).is_cfg_enabled(cfg_options) {\n-                    arena.alloc(lower_field(item_tree, &item_tree[field_id], override_visibility));\n+                let attrs = item_tree.attrs(db, krate, field_id.into());\n+                let field = &item_tree[field_id];\n+                if attrs.is_cfg_enabled(cfg_options) {\n+                    arena.alloc(lower_field(item_tree, field, override_visibility));\n+                } else {\n+                    diagnostics.push(DefDiagnostic::unconfigured_code(\n+                        container,\n+                        InFile::new(\n+                            current_file_id,\n+                            match field.ast_id {\n+                                FieldAstId::Record(it) => it.upcast(),\n+                                FieldAstId::Tuple(it) => it.upcast(),\n+                            },\n+                        ),\n+                        attrs.cfg().unwrap(),\n+                        cfg_options.clone(),\n+                    ))\n                 }\n             }\n-            VariantData::Record(arena)\n+            (VariantData::Record(arena), diagnostics)\n         }\n         Fields::Tuple(flds) => {\n             let mut arena = Arena::new();\n             for field_id in flds.clone() {\n-                if item_tree.attrs(db, krate, field_id.into()).is_cfg_enabled(cfg_options) {\n-                    arena.alloc(lower_field(item_tree, &item_tree[field_id], override_visibility));\n+                let attrs = item_tree.attrs(db, krate, field_id.into());\n+                let field = &item_tree[field_id];\n+                if attrs.is_cfg_enabled(cfg_options) {\n+                    arena.alloc(lower_field(item_tree, field, override_visibility));\n+                } else {\n+                    diagnostics.push(DefDiagnostic::unconfigured_code(\n+                        container,\n+                        InFile::new(\n+                            current_file_id,\n+                            match field.ast_id {\n+                                FieldAstId::Record(it) => it.upcast(),\n+                                FieldAstId::Tuple(it) => it.upcast(),\n+                            },\n+                        ),\n+                        attrs.cfg().unwrap(),\n+                        cfg_options.clone(),\n+                    ))\n                 }\n             }\n-            VariantData::Tuple(arena)\n+            (VariantData::Tuple(arena), diagnostics)\n         }\n-        Fields::Unit => VariantData::Unit,\n+        Fields::Unit => (VariantData::Unit, diagnostics),\n     }\n }\n "}, {"sha": "2dc7714bbb540597c2cbcf881b9acdf2fba8dc74", "filename": "crates/hir-def/src/body.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fhir-def%2Fsrc%2Fbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fhir-def%2Fsrc%2Fbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fbody.rs?ref=e6540cff74534e6d9fb86d5d66e66423fad03766", "patch": "@@ -27,7 +27,7 @@ use crate::{\n     macro_id_to_def_id,\n     nameres::DefMap,\n     path::{ModPath, Path},\n-    src::HasSource,\n+    src::{HasChildSource, HasSource},\n     AsMacroCall, BlockId, DefWithBodyId, HasModule, LocalModuleId, Lookup, MacroId, ModuleId,\n     UnresolvedMacro,\n };\n@@ -324,6 +324,12 @@ impl Body {\n                 let src = s.source(db);\n                 (src.file_id, s.module(db), src.value.body())\n             }\n+            DefWithBodyId::VariantId(v) => {\n+                let e = v.parent.lookup(db);\n+                let src = v.parent.child_source(db);\n+                let variant = &src.value[v.local_id];\n+                (src.file_id, e.container, variant.expr())\n+            }\n         };\n         let expander = Expander::new(db, file_id, module);\n         let (mut body, source_map) = Body::new(db, expander, params, body);"}, {"sha": "c4f91e49a6e1b4d53d3f57df2bf2cc8da2f6efdc", "filename": "crates/hir-def/src/body/lower.rs", "status": "modified", "additions": 24, "deletions": 2, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs?ref=e6540cff74534e6d9fb86d5d66e66423fad03766", "patch": "@@ -29,8 +29,9 @@ use crate::{\n     builtin_type::{BuiltinFloat, BuiltinInt, BuiltinUint},\n     db::DefDatabase,\n     expr::{\n-        dummy_expr_id, Array, BindingAnnotation, Expr, ExprId, FloatTypeWrapper, Label, LabelId,\n-        Literal, MatchArm, Pat, PatId, RecordFieldPat, RecordLitField, Statement,\n+        dummy_expr_id, Array, BindingAnnotation, ClosureKind, Expr, ExprId, FloatTypeWrapper,\n+        Label, LabelId, Literal, MatchArm, Movability, Pat, PatId, RecordFieldPat, RecordLitField,\n+        Statement,\n     },\n     intern::Interned,\n     item_scope::BuiltinShadowMode,\n@@ -97,6 +98,7 @@ pub(super) fn lower(\n         name_to_pat_grouping: Default::default(),\n         is_lowering_inside_or_pat: false,\n         is_lowering_assignee_expr: false,\n+        is_lowering_generator: false,\n     }\n     .collect(params, body)\n }\n@@ -111,6 +113,7 @@ struct ExprCollector<'a> {\n     name_to_pat_grouping: FxHashMap<Name, Vec<PatId>>,\n     is_lowering_inside_or_pat: bool,\n     is_lowering_assignee_expr: bool,\n+    is_lowering_generator: bool,\n }\n \n impl ExprCollector<'_> {\n@@ -358,6 +361,7 @@ impl ExprCollector<'_> {\n                 self.alloc_expr(Expr::Return { expr }, syntax_ptr)\n             }\n             ast::Expr::YieldExpr(e) => {\n+                self.is_lowering_generator = true;\n                 let expr = e.expr().map(|e| self.collect_expr(e));\n                 self.alloc_expr(Expr::Yield { expr }, syntax_ptr)\n             }\n@@ -459,13 +463,31 @@ impl ExprCollector<'_> {\n                     .ret_type()\n                     .and_then(|r| r.ty())\n                     .map(|it| Interned::new(TypeRef::from_ast(&self.ctx(), it)));\n+\n+                let prev_is_lowering_generator = self.is_lowering_generator;\n+                self.is_lowering_generator = false;\n+\n                 let body = self.collect_expr_opt(e.body());\n+\n+                let closure_kind = if self.is_lowering_generator {\n+                    let movability = if e.static_token().is_some() {\n+                        Movability::Static\n+                    } else {\n+                        Movability::Movable\n+                    };\n+                    ClosureKind::Generator(movability)\n+                } else {\n+                    ClosureKind::Closure\n+                };\n+                self.is_lowering_generator = prev_is_lowering_generator;\n+\n                 self.alloc_expr(\n                     Expr::Closure {\n                         args: args.into(),\n                         arg_types: arg_types.into(),\n                         ret_type,\n                         body,\n+                        closure_kind,\n                     },\n                     syntax_ptr,\n                 )"}, {"sha": "162d173d52404d9adcc05c3eae3dde82c461a855", "filename": "crates/hir-def/src/body/pretty.rs", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fhir-def%2Fsrc%2Fbody%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fhir-def%2Fsrc%2Fbody%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fbody%2Fpretty.rs?ref=e6540cff74534e6d9fb86d5d66e66423fad03766", "patch": "@@ -2,8 +2,10 @@\n \n use std::fmt::{self, Write};\n \n+use syntax::ast::HasName;\n+\n use crate::{\n-    expr::{Array, BindingAnnotation, Literal, Statement},\n+    expr::{Array, BindingAnnotation, ClosureKind, Literal, Movability, Statement},\n     pretty::{print_generic_args, print_path, print_type_ref},\n     type_ref::TypeRef,\n };\n@@ -32,6 +34,16 @@ pub(super) fn print_body_hir(db: &dyn DefDatabase, body: &Body, owner: DefWithBo\n             };\n             format!(\"const {} = \", name)\n         }\n+        DefWithBodyId::VariantId(it) => {\n+            needs_semi = false;\n+            let src = it.parent.child_source(db);\n+            let variant = &src.value[it.local_id];\n+            let name = match &variant.name() {\n+                Some(name) => name.to_string(),\n+                None => \"_\".to_string(),\n+            };\n+            format!(\"{}\", name)\n+        }\n     };\n \n     let mut p = Printer { body, buf: header, indent_level: 0, needs_indent: false };\n@@ -350,7 +362,10 @@ impl<'a> Printer<'a> {\n                 self.print_expr(*index);\n                 w!(self, \"]\");\n             }\n-            Expr::Closure { args, arg_types, ret_type, body } => {\n+            Expr::Closure { args, arg_types, ret_type, body, closure_kind } => {\n+                if let ClosureKind::Generator(Movability::Static) = closure_kind {\n+                    w!(self, \"static \");\n+                }\n                 w!(self, \"|\");\n                 for (i, (pat, ty)) in args.iter().zip(arg_types.iter()).enumerate() {\n                     if i != 0 {"}, {"sha": "bb13165257ba416c0d32e909c67750c1e99b6fa2", "filename": "crates/hir-def/src/child_by_source.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fhir-def%2Fsrc%2Fchild_by_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fhir-def%2Fsrc%2Fchild_by_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fchild_by_source.rs?ref=e6540cff74534e6d9fb86d5d66e66423fad03766", "patch": "@@ -198,6 +198,10 @@ impl ChildBySource for EnumId {\n impl ChildBySource for DefWithBodyId {\n     fn child_by_source_to(&self, db: &dyn DefDatabase, res: &mut DynMap, file_id: HirFileId) {\n         let body = db.body(*self);\n+        if let &DefWithBodyId::VariantId(v) = self {\n+            VariantId::EnumVariantId(v).child_by_source_to(db, res, file_id)\n+        }\n+\n         for (_, def_map) in body.blocks(db) {\n             // All block expressions are merged into the same map, because they logically all add\n             // inner items to the containing `DefWithBodyId`."}, {"sha": "2dc69b00ace00d12659f844b1ceafee85a2b4957", "filename": "crates/hir-def/src/data.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fhir-def%2Fsrc%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fhir-def%2Fsrc%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fdata.rs?ref=e6540cff74534e6d9fb86d5d66e66423fad03766", "patch": "@@ -219,7 +219,7 @@ impl TraitData {\n     pub(crate) fn trait_data_with_diagnostics_query(\n         db: &dyn DefDatabase,\n         tr: TraitId,\n-    ) -> (Arc<TraitData>, Arc<Vec<DefDiagnostic>>) {\n+    ) -> (Arc<TraitData>, Arc<[DefDiagnostic]>) {\n         let tr_loc @ ItemLoc { container: module_id, id: tree_id } = tr.lookup(db);\n         let item_tree = tree_id.item_tree(db);\n         let tr_def = &item_tree[tree_id.value];\n@@ -251,7 +251,7 @@ impl TraitData {\n                 visibility,\n                 skip_array_during_method_dispatch,\n             }),\n-            Arc::new(diagnostics),\n+            diagnostics.into(),\n         )\n     }\n \n@@ -299,7 +299,7 @@ impl ImplData {\n     pub(crate) fn impl_data_with_diagnostics_query(\n         db: &dyn DefDatabase,\n         id: ImplId,\n-    ) -> (Arc<ImplData>, Arc<Vec<DefDiagnostic>>) {\n+    ) -> (Arc<ImplData>, Arc<[DefDiagnostic]>) {\n         let _p = profile::span(\"impl_data_with_diagnostics_query\");\n         let ItemLoc { container: module_id, id: tree_id } = id.lookup(db);\n \n@@ -318,7 +318,7 @@ impl ImplData {\n \n         (\n             Arc::new(ImplData { target_trait, self_ty, items, is_negative, attribute_calls }),\n-            Arc::new(diagnostics),\n+            diagnostics.into(),\n         )\n     }\n "}, {"sha": "431c8255497b62e17741350c424f069f23b04f11", "filename": "crates/hir-def/src/db.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fhir-def%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fhir-def%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fdb.rs?ref=e6540cff74534e6d9fb86d5d66e66423fad03766", "patch": "@@ -97,24 +97,33 @@ pub trait DefDatabase: InternDatabase + AstDatabase + Upcast<dyn AstDatabase> {\n     #[salsa::invoke(StructData::struct_data_query)]\n     fn struct_data(&self, id: StructId) -> Arc<StructData>;\n \n+    #[salsa::invoke(StructData::struct_data_with_diagnostics_query)]\n+    fn struct_data_with_diagnostics(&self, id: StructId)\n+        -> (Arc<StructData>, Arc<[DefDiagnostic]>);\n+\n     #[salsa::invoke(StructData::union_data_query)]\n     fn union_data(&self, id: UnionId) -> Arc<StructData>;\n \n+    #[salsa::invoke(StructData::union_data_with_diagnostics_query)]\n+    fn union_data_with_diagnostics(&self, id: UnionId) -> (Arc<StructData>, Arc<[DefDiagnostic]>);\n+\n     #[salsa::invoke(EnumData::enum_data_query)]\n     fn enum_data(&self, e: EnumId) -> Arc<EnumData>;\n \n+    #[salsa::invoke(EnumData::enum_data_with_diagnostics_query)]\n+    fn enum_data_with_diagnostics(&self, e: EnumId) -> (Arc<EnumData>, Arc<[DefDiagnostic]>);\n+\n     #[salsa::invoke(ImplData::impl_data_query)]\n     fn impl_data(&self, e: ImplId) -> Arc<ImplData>;\n \n     #[salsa::invoke(ImplData::impl_data_with_diagnostics_query)]\n-    fn impl_data_with_diagnostics(&self, e: ImplId) -> (Arc<ImplData>, Arc<Vec<DefDiagnostic>>);\n+    fn impl_data_with_diagnostics(&self, e: ImplId) -> (Arc<ImplData>, Arc<[DefDiagnostic]>);\n \n     #[salsa::invoke(TraitData::trait_data_query)]\n     fn trait_data(&self, e: TraitId) -> Arc<TraitData>;\n \n     #[salsa::invoke(TraitData::trait_data_with_diagnostics_query)]\n-    fn trait_data_with_diagnostics(&self, tr: TraitId)\n-        -> (Arc<TraitData>, Arc<Vec<DefDiagnostic>>);\n+    fn trait_data_with_diagnostics(&self, tr: TraitId) -> (Arc<TraitData>, Arc<[DefDiagnostic]>);\n \n     #[salsa::invoke(TypeAliasData::type_alias_data_query)]\n     fn type_alias_data(&self, e: TypeAliasId) -> Arc<TypeAliasData>;"}, {"sha": "16264655020712fe2caa3afcc1563c960cdbfc09", "filename": "crates/hir-def/src/expr.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fhir-def%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fhir-def%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fexpr.rs?ref=e6540cff74534e6d9fb86d5d66e66423fad03766", "patch": "@@ -198,6 +198,7 @@ pub enum Expr {\n         arg_types: Box<[Option<Interned<TypeRef>>]>,\n         ret_type: Option<Interned<TypeRef>>,\n         body: ExprId,\n+        closure_kind: ClosureKind,\n     },\n     Tuple {\n         exprs: Box<[ExprId]>,\n@@ -211,6 +212,18 @@ pub enum Expr {\n     Underscore,\n }\n \n+#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n+pub enum ClosureKind {\n+    Closure,\n+    Generator(Movability),\n+}\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n+pub enum Movability {\n+    Static,\n+    Movable,\n+}\n+\n #[derive(Debug, Clone, Eq, PartialEq)]\n pub enum Array {\n     ElementList { elements: Box<[ExprId]>, is_assignee_expr: bool },"}, {"sha": "c70e6fdccdcde56c5d6a18ba4fe5c5c235c65cdb", "filename": "crates/hir-def/src/find_path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fhir-def%2Fsrc%2Ffind_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fhir-def%2Fsrc%2Ffind_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Ffind_path.rs?ref=e6540cff74534e6d9fb86d5d66e66423fad03766", "patch": "@@ -333,8 +333,8 @@ fn calculate_best_path(\n                     db,\n                     def_map,\n                     visited_modules,\n-                    from,\n                     crate_root,\n+                    from,\n                     info.container,\n                     max_len - 1,\n                     prefixed,"}, {"sha": "570344596def80a2c62711c72ba2b1fa11358dbf", "filename": "crates/hir-def/src/item_tree.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fhir-def%2Fsrc%2Fitem_tree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fhir-def%2Fsrc%2Fitem_tree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fitem_tree.rs?ref=e6540cff74534e6d9fb86d5d66e66423fad03766", "patch": "@@ -943,6 +943,7 @@ impl AssocItem {\n pub struct Variant {\n     pub name: Name,\n     pub fields: Fields,\n+    pub ast_id: FileAstId<ast::Variant>,\n }\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n@@ -952,10 +953,17 @@ pub enum Fields {\n     Unit,\n }\n \n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub enum FieldAstId {\n+    Record(FileAstId<ast::RecordField>),\n+    Tuple(FileAstId<ast::TupleField>),\n+}\n+\n /// A single field of an enum variant or struct\n #[derive(Debug, Clone, PartialEq, Eq)]\n pub struct Field {\n     pub name: Name,\n     pub type_ref: Interned<TypeRef>,\n     pub visibility: RawVisibilityId,\n+    pub ast_id: FieldAstId,\n }"}, {"sha": "077a1b619dd5a056cd89c79a14e260b32aafc7ed", "filename": "crates/hir-def/src/item_tree/lower.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fhir-def%2Fsrc%2Fitem_tree%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fhir-def%2Fsrc%2Fitem_tree%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fitem_tree%2Flower.rs?ref=e6540cff74534e6d9fb86d5d66e66423fad03766", "patch": "@@ -184,7 +184,8 @@ impl<'a> Ctx<'a> {\n         let name = field.name()?.as_name();\n         let visibility = self.lower_visibility(field);\n         let type_ref = self.lower_type_ref_opt(field.ty());\n-        let res = Field { name, type_ref, visibility };\n+        let ast_id = FieldAstId::Record(self.source_ast_id_map.ast_id(field));\n+        let res = Field { name, type_ref, visibility, ast_id };\n         Some(res)\n     }\n \n@@ -203,7 +204,8 @@ impl<'a> Ctx<'a> {\n         let name = Name::new_tuple_field(idx);\n         let visibility = self.lower_visibility(field);\n         let type_ref = self.lower_type_ref_opt(field.ty());\n-        Field { name, type_ref, visibility }\n+        let ast_id = FieldAstId::Tuple(self.source_ast_id_map.ast_id(field));\n+        Field { name, type_ref, visibility, ast_id }\n     }\n \n     fn lower_union(&mut self, union: &ast::Union) -> Option<FileItemTreeId<Union>> {\n@@ -247,7 +249,8 @@ impl<'a> Ctx<'a> {\n     fn lower_variant(&mut self, variant: &ast::Variant) -> Option<Variant> {\n         let name = variant.name()?.as_name();\n         let fields = self.lower_fields(&variant.kind());\n-        let res = Variant { name, fields };\n+        let ast_id = self.source_ast_id_map.ast_id(variant);\n+        let res = Variant { name, fields, ast_id };\n         Some(res)\n     }\n "}, {"sha": "da1643152c2fe09f3683aeb495b67f3371e3c4ff", "filename": "crates/hir-def/src/item_tree/pretty.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fhir-def%2Fsrc%2Fitem_tree%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fhir-def%2Fsrc%2Fitem_tree%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fitem_tree%2Fpretty.rs?ref=e6540cff74534e6d9fb86d5d66e66423fad03766", "patch": "@@ -115,7 +115,7 @@ impl<'a> Printer<'a> {\n                 w!(self, \"{{\");\n                 self.indented(|this| {\n                     for field in fields.clone() {\n-                        let Field { visibility, name, type_ref } = &this.tree[field];\n+                        let Field { visibility, name, type_ref, ast_id: _ } = &this.tree[field];\n                         this.print_attrs_of(field);\n                         this.print_visibility(*visibility);\n                         w!(this, \"{}: \", name);\n@@ -129,7 +129,7 @@ impl<'a> Printer<'a> {\n                 w!(self, \"(\");\n                 self.indented(|this| {\n                     for field in fields.clone() {\n-                        let Field { visibility, name, type_ref } = &this.tree[field];\n+                        let Field { visibility, name, type_ref, ast_id: _ } = &this.tree[field];\n                         this.print_attrs_of(field);\n                         this.print_visibility(*visibility);\n                         w!(this, \"{}: \", name);\n@@ -323,7 +323,7 @@ impl<'a> Printer<'a> {\n                 self.print_where_clause_and_opening_brace(generic_params);\n                 self.indented(|this| {\n                     for variant in variants.clone() {\n-                        let Variant { name, fields } = &this.tree[variant];\n+                        let Variant { name, fields, ast_id: _ } = &this.tree[variant];\n                         this.print_attrs_of(variant);\n                         w!(this, \"{}\", name);\n                         this.print_fields(fields);"}, {"sha": "5c7aa72349f6e1c89be036ed2a539610926cc8c5", "filename": "crates/hir-def/src/lib.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fhir-def%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fhir-def%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Flib.rs?ref=e6540cff74534e6d9fb86d5d66e66423fad03766", "patch": "@@ -474,16 +474,24 @@ pub enum DefWithBodyId {\n     FunctionId(FunctionId),\n     StaticId(StaticId),\n     ConstId(ConstId),\n+    VariantId(EnumVariantId),\n }\n \n impl_from!(FunctionId, ConstId, StaticId for DefWithBodyId);\n \n+impl From<EnumVariantId> for DefWithBodyId {\n+    fn from(id: EnumVariantId) -> Self {\n+        DefWithBodyId::VariantId(id)\n+    }\n+}\n+\n impl DefWithBodyId {\n     pub fn as_generic_def_id(self) -> Option<GenericDefId> {\n         match self {\n             DefWithBodyId::FunctionId(f) => Some(f.into()),\n             DefWithBodyId::StaticId(_) => None,\n             DefWithBodyId::ConstId(c) => Some(c.into()),\n+            DefWithBodyId::VariantId(c) => Some(c.into()),\n         }\n     }\n }\n@@ -681,6 +689,7 @@ impl HasModule for DefWithBodyId {\n             DefWithBodyId::FunctionId(it) => it.lookup(db).module(db),\n             DefWithBodyId::StaticId(it) => it.lookup(db).module(db),\n             DefWithBodyId::ConstId(it) => it.lookup(db).module(db),\n+            DefWithBodyId::VariantId(it) => it.parent.lookup(db).container,\n         }\n     }\n }\n@@ -691,6 +700,7 @@ impl DefWithBodyId {\n             DefWithBodyId::FunctionId(it) => it.lookup(db).id.value.into(),\n             DefWithBodyId::StaticId(it) => it.lookup(db).id.value.into(),\n             DefWithBodyId::ConstId(it) => it.lookup(db).id.value.into(),\n+            DefWithBodyId::VariantId(it) => it.parent.lookup(db).id.value.into(),\n         }\n     }\n }"}, {"sha": "9ffc218818ca164cd91f0609941b3a7f5e80d8a2", "filename": "crates/hir-def/src/nameres/collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs?ref=e6540cff74534e6d9fb86d5d66e66423fad03766", "patch": "@@ -2122,7 +2122,7 @@ impl ModCollector<'_, '_> {\n     fn emit_unconfigured_diagnostic(&mut self, item: ModItem, cfg: &CfgExpr) {\n         let ast_id = item.ast_id(self.item_tree);\n \n-        let ast_id = InFile::new(self.file_id(), ast_id);\n+        let ast_id = InFile::new(self.file_id(), ast_id.upcast());\n         self.def_collector.def_map.diagnostics.push(DefDiagnostic::unconfigured_code(\n             self.module_id,\n             ast_id,"}, {"sha": "066142291981dd9debf879d8a1ece627f2292a32", "filename": "crates/hir-def/src/nameres/diagnostics.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fhir-def%2Fsrc%2Fnameres%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fhir-def%2Fsrc%2Fnameres%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fnameres%2Fdiagnostics.rs?ref=e6540cff74534e6d9fb86d5d66e66423fad03766", "patch": "@@ -4,7 +4,7 @@ use base_db::CrateId;\n use cfg::{CfgExpr, CfgOptions};\n use hir_expand::MacroCallKind;\n use la_arena::Idx;\n-use syntax::ast;\n+use syntax::ast::{self, AnyHasAttrs};\n \n use crate::{\n     attr::AttrId,\n@@ -22,7 +22,7 @@ pub enum DefDiagnosticKind {\n \n     UnresolvedImport { id: ItemTreeId<item_tree::Import>, index: Idx<ast::UseTree> },\n \n-    UnconfiguredCode { ast: AstId<ast::Item>, cfg: CfgExpr, opts: CfgOptions },\n+    UnconfiguredCode { ast: AstId<AnyHasAttrs>, cfg: CfgExpr, opts: CfgOptions },\n \n     UnresolvedProcMacro { ast: MacroCallKind, krate: CrateId },\n \n@@ -75,7 +75,7 @@ impl DefDiagnostic {\n \n     pub fn unconfigured_code(\n         container: LocalModuleId,\n-        ast: AstId<ast::Item>,\n+        ast: AstId<ast::AnyHasAttrs>,\n         cfg: CfgExpr,\n         opts: CfgOptions,\n     ) -> Self {"}, {"sha": "070f6837133a3b645eb16bb37282d13515d9e798", "filename": "crates/hir-def/src/resolver.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fhir-def%2Fsrc%2Fresolver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fhir-def%2Fsrc%2Fresolver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fresolver.rs?ref=e6540cff74534e6d9fb86d5d66e66423fad03766", "patch": "@@ -839,6 +839,7 @@ impl HasResolver for DefWithBodyId {\n             DefWithBodyId::ConstId(c) => c.resolver(db),\n             DefWithBodyId::FunctionId(f) => f.resolver(db),\n             DefWithBodyId::StaticId(s) => s.resolver(db),\n+            DefWithBodyId::VariantId(v) => v.parent.resolver(db),\n         }\n     }\n }"}, {"sha": "2b27db0e950630e34601f19640d691f27bad5835", "filename": "crates/hir-expand/src/ast_id_map.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fhir-expand%2Fsrc%2Fast_id_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fhir-expand%2Fsrc%2Fast_id_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-expand%2Fsrc%2Fast_id_map.rs?ref=e6540cff74534e6d9fb86d5d66e66423fad03766", "patch": "@@ -93,7 +93,12 @@ impl AstIdMap {\n         // trait does not change ids of top-level items, which helps caching.\n         bdfs(node, |it| {\n             let kind = it.kind();\n-            if ast::Item::can_cast(kind) || ast::BlockExpr::can_cast(kind) {\n+            if ast::Item::can_cast(kind)\n+                || ast::BlockExpr::can_cast(kind)\n+                || ast::Variant::can_cast(kind)\n+                || ast::RecordField::can_cast(kind)\n+                || ast::TupleField::can_cast(kind)\n+            {\n                 res.alloc(&it);\n                 true\n             } else {"}, {"sha": "a5b499fe8d9d44809e0fcbd8847e61ce3ffd5c7e", "filename": "crates/hir-expand/src/lib.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fhir-expand%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fhir-expand%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-expand%2Fsrc%2Flib.rs?ref=e6540cff74534e6d9fb86d5d66e66423fad03766", "patch": "@@ -811,6 +811,31 @@ impl<'a> InFile<&'a SyntaxNode> {\n             _ => None,\n         }\n     }\n+\n+    pub fn original_syntax_node(self, db: &dyn db::AstDatabase) -> Option<InFile<SyntaxNode>> {\n+        // This kind of upmapping can only be achieved in attribute expanded files,\n+        // as we don't have node inputs otherwise and  therefor can't find an `N` node in the input\n+        if !self.file_id.is_macro() {\n+            return Some(self.map(Clone::clone));\n+        } else if !self.file_id.is_attr_macro(db) {\n+            return None;\n+        }\n+\n+        if let Some(InFile { file_id, value: (first, last) }) = ascend_node_border_tokens(db, self)\n+        {\n+            if file_id.is_macro() {\n+                let range = first.text_range().cover(last.text_range());\n+                tracing::error!(\"Failed mapping out of macro file for {:?}\", range);\n+                return None;\n+            }\n+            // FIXME: This heuristic is brittle and with the right macro may select completely unrelated nodes\n+            let anc = algo::least_common_ancestor(&first.parent()?, &last.parent()?)?;\n+            let kind = self.value.kind();\n+            let value = anc.ancestors().find(|it| it.kind() == kind)?;\n+            return Some(InFile::new(file_id, value));\n+        }\n+        None\n+    }\n }\n \n impl InFile<SyntaxToken> {"}, {"sha": "2679a1c3602671c35fcae81ba8f9fdef4eb90042", "filename": "crates/hir-expand/src/name.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fhir-expand%2Fsrc%2Fname.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fhir-expand%2Fsrc%2Fname.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-expand%2Fsrc%2Fname.rs?ref=e6540cff74534e6d9fb86d5d66e66423fad03766", "patch": "@@ -263,6 +263,7 @@ pub mod known {\n         Iterator,\n         IntoIterator,\n         Item,\n+        IntoIter,\n         Try,\n         Ok,\n         Future,"}, {"sha": "78911d8dc0772be48ebec328c43bf0e082663c04", "filename": "crates/hir-ty/src/autoderef.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fhir-ty%2Fsrc%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fhir-ty%2Fsrc%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fautoderef.rs?ref=e6540cff74534e6d9fb86d5d66e66423fad03766", "patch": "@@ -1,7 +1,7 @@\n //! In certain situations, rust automatically inserts derefs as necessary: for\n //! example, field accesses `foo.bar` still work when `foo` is actually a\n //! reference to a type with the field `bar`. This is an approximation of the\n-//! logic in rustc (which lives in librustc_typeck/check/autoderef.rs).\n+//! logic in rustc (which lives in rustc_hir_analysis/check/autoderef.rs).\n \n use std::sync::Arc;\n \n@@ -123,13 +123,14 @@ fn deref_by_trait(table: &mut InferenceTable<'_>, ty: Ty) -> Option<Ty> {\n     let target = db.trait_data(deref_trait).associated_type_by_name(&name![Target])?;\n \n     let projection = {\n-        let b = TyBuilder::assoc_type_projection(db, target);\n+        let b = TyBuilder::subst_for_def(db, deref_trait, None);\n         if b.remaining() != 1 {\n             // the Target type + Deref trait should only have one generic parameter,\n             // namely Deref's Self type\n             return None;\n         }\n-        b.push(ty).build()\n+        let deref_subst = b.push(ty).build();\n+        TyBuilder::assoc_type_projection(db, target, Some(deref_subst)).build()\n     };\n \n     // Check that the type implements Deref at all"}, {"sha": "9ae752556d890df8161c55ea7f937f2fec581aa1", "filename": "crates/hir-ty/src/builder.rs", "status": "modified", "additions": 132, "deletions": 85, "changes": 217, "blob_url": "https://github.com/rust-lang/rust/blob/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fhir-ty%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fhir-ty%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fbuilder.rs?ref=e6540cff74534e6d9fb86d5d66e66423fad03766", "patch": "@@ -6,19 +6,19 @@ use chalk_ir::{\n     cast::{Cast, CastTo, Caster},\n     fold::TypeFoldable,\n     interner::HasInterner,\n-    AdtId, BoundVar, DebruijnIndex, Scalar,\n+    AdtId, DebruijnIndex, Scalar,\n };\n use hir_def::{\n-    builtin_type::BuiltinType, generics::TypeOrConstParamData, ConstParamId, GenericDefId, TraitId,\n-    TypeAliasId,\n+    builtin_type::BuiltinType, generics::TypeOrConstParamData, ConstParamId, DefWithBodyId,\n+    GenericDefId, TraitId, TypeAliasId,\n };\n use smallvec::SmallVec;\n \n use crate::{\n     consteval::unknown_const_as_generic, db::HirDatabase, infer::unify::InferenceTable, primitive,\n-    to_assoc_type_id, to_chalk_trait_id, utils::generics, Binders, CallableSig, ConstData,\n-    ConstValue, GenericArg, GenericArgData, Interner, ProjectionTy, Substitution, TraitRef, Ty,\n-    TyDefId, TyExt, TyKind, ValueTyDefId,\n+    to_assoc_type_id, to_chalk_trait_id, utils::generics, Binders, BoundVar, CallableSig,\n+    GenericArg, Interner, ProjectionTy, Substitution, TraitRef, Ty, TyDefId, TyExt, TyKind,\n+    ValueTyDefId,\n };\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n@@ -34,31 +34,51 @@ pub struct TyBuilder<D> {\n     data: D,\n     vec: SmallVec<[GenericArg; 2]>,\n     param_kinds: SmallVec<[ParamKind; 2]>,\n+    parent_subst: Substitution,\n }\n \n impl<A> TyBuilder<A> {\n     fn with_data<B>(self, data: B) -> TyBuilder<B> {\n-        TyBuilder { data, param_kinds: self.param_kinds, vec: self.vec }\n+        TyBuilder {\n+            data,\n+            vec: self.vec,\n+            param_kinds: self.param_kinds,\n+            parent_subst: self.parent_subst,\n+        }\n     }\n }\n \n impl<D> TyBuilder<D> {\n-    fn new(data: D, param_kinds: SmallVec<[ParamKind; 2]>) -> TyBuilder<D> {\n-        TyBuilder { data, vec: SmallVec::with_capacity(param_kinds.len()), param_kinds }\n+    fn new(\n+        data: D,\n+        param_kinds: SmallVec<[ParamKind; 2]>,\n+        parent_subst: Option<Substitution>,\n+    ) -> Self {\n+        let parent_subst = parent_subst.unwrap_or_else(|| Substitution::empty(Interner));\n+        Self { data, vec: SmallVec::with_capacity(param_kinds.len()), param_kinds, parent_subst }\n+    }\n+\n+    fn new_empty(data: D) -> Self {\n+        TyBuilder::new(data, SmallVec::new(), None)\n     }\n \n     fn build_internal(self) -> (D, Substitution) {\n         assert_eq!(self.vec.len(), self.param_kinds.len());\n         for (a, e) in self.vec.iter().zip(self.param_kinds.iter()) {\n             self.assert_match_kind(a, e);\n         }\n-        let subst = Substitution::from_iter(Interner, self.vec);\n+        let subst = Substitution::from_iter(\n+            Interner,\n+            self.vec.into_iter().chain(self.parent_subst.iter(Interner).cloned()),\n+        );\n         (self.data, subst)\n     }\n \n     pub fn push(mut self, arg: impl CastTo<GenericArg>) -> Self {\n+        assert!(self.remaining() > 0);\n         let arg = arg.cast(Interner);\n         let expected_kind = &self.param_kinds[self.vec.len()];\n+\n         let arg_kind = match arg.data(Interner) {\n             chalk_ir::GenericArgData::Ty(_) => ParamKind::Type,\n             chalk_ir::GenericArgData::Lifetime(_) => panic!(\"Got lifetime in TyBuilder::push\"),\n@@ -68,7 +88,9 @@ impl<D> TyBuilder<D> {\n             }\n         };\n         assert_eq!(*expected_kind, arg_kind);\n+\n         self.vec.push(arg);\n+\n         self\n     }\n \n@@ -79,20 +101,12 @@ impl<D> TyBuilder<D> {\n     pub fn fill_with_bound_vars(self, debruijn: DebruijnIndex, starting_from: usize) -> Self {\n         // self.fill is inlined to make borrow checker happy\n         let mut this = self;\n-        let other = this.param_kinds.iter().skip(this.vec.len());\n+        let other = &this.param_kinds[this.vec.len()..];\n         let filler = (starting_from..).zip(other).map(|(idx, kind)| match kind {\n-            ParamKind::Type => {\n-                GenericArgData::Ty(TyKind::BoundVar(BoundVar::new(debruijn, idx)).intern(Interner))\n-                    .intern(Interner)\n+            ParamKind::Type => BoundVar::new(debruijn, idx).to_ty(Interner).cast(Interner),\n+            ParamKind::Const(ty) => {\n+                BoundVar::new(debruijn, idx).to_const(Interner, ty.clone()).cast(Interner)\n             }\n-            ParamKind::Const(ty) => GenericArgData::Const(\n-                ConstData {\n-                    value: ConstValue::BoundVar(BoundVar::new(debruijn, idx)),\n-                    ty: ty.clone(),\n-                }\n-                .intern(Interner),\n-            )\n-            .intern(Interner),\n         });\n         this.vec.extend(filler.take(this.remaining()).casted(Interner));\n         assert_eq!(this.remaining(), 0);\n@@ -102,8 +116,8 @@ impl<D> TyBuilder<D> {\n     pub fn fill_with_unknown(self) -> Self {\n         // self.fill is inlined to make borrow checker happy\n         let mut this = self;\n-        let filler = this.param_kinds.iter().skip(this.vec.len()).map(|x| match x {\n-            ParamKind::Type => GenericArgData::Ty(TyKind::Error.intern(Interner)).intern(Interner),\n+        let filler = this.param_kinds[this.vec.len()..].iter().map(|x| match x {\n+            ParamKind::Type => TyKind::Error.intern(Interner).cast(Interner),\n             ParamKind::Const(ty) => unknown_const_as_generic(ty.clone()),\n         });\n         this.vec.extend(filler.casted(Interner));\n@@ -113,33 +127,17 @@ impl<D> TyBuilder<D> {\n \n     pub(crate) fn fill_with_inference_vars(self, table: &mut InferenceTable<'_>) -> Self {\n         self.fill(|x| match x {\n-            ParamKind::Type => GenericArgData::Ty(table.new_type_var()).intern(Interner),\n-            ParamKind::Const(ty) => {\n-                GenericArgData::Const(table.new_const_var(ty.clone())).intern(Interner)\n-            }\n+            ParamKind::Type => table.new_type_var().cast(Interner),\n+            ParamKind::Const(ty) => table.new_const_var(ty.clone()).cast(Interner),\n         })\n     }\n \n     pub fn fill(mut self, filler: impl FnMut(&ParamKind) -> GenericArg) -> Self {\n-        self.vec.extend(self.param_kinds.iter().skip(self.vec.len()).map(filler));\n+        self.vec.extend(self.param_kinds[self.vec.len()..].iter().map(filler));\n         assert_eq!(self.remaining(), 0);\n         self\n     }\n \n-    pub fn use_parent_substs(mut self, parent_substs: &Substitution) -> Self {\n-        assert!(self.vec.is_empty());\n-        assert!(parent_substs.len(Interner) <= self.param_kinds.len());\n-        self.extend(parent_substs.iter(Interner).cloned());\n-        self\n-    }\n-\n-    fn extend(&mut self, it: impl Iterator<Item = GenericArg> + Clone) {\n-        for x in it.clone().zip(self.param_kinds.iter().skip(self.vec.len())) {\n-            self.assert_match_kind(&x.0, &x.1);\n-        }\n-        self.vec.extend(it);\n-    }\n-\n     fn assert_match_kind(&self, a: &chalk_ir::GenericArg<Interner>, e: &ParamKind) {\n         match (a.data(Interner), e) {\n             (chalk_ir::GenericArgData::Ty(_), ParamKind::Type)\n@@ -188,21 +186,42 @@ impl TyBuilder<()> {\n         params.placeholder_subst(db)\n     }\n \n-    pub fn subst_for_def(db: &dyn HirDatabase, def: impl Into<GenericDefId>) -> TyBuilder<()> {\n-        let def = def.into();\n-        let params = generics(db.upcast(), def);\n-        TyBuilder::new(\n-            (),\n-            params\n-                .iter()\n-                .map(|(id, data)| match data {\n-                    TypeOrConstParamData::TypeParamData(_) => ParamKind::Type,\n-                    TypeOrConstParamData::ConstParamData(_) => {\n-                        ParamKind::Const(db.const_param_ty(ConstParamId::from_unchecked(id)))\n-                    }\n-                })\n-                .collect(),\n-        )\n+    pub fn subst_for_def(\n+        db: &dyn HirDatabase,\n+        def: impl Into<GenericDefId>,\n+        parent_subst: Option<Substitution>,\n+    ) -> TyBuilder<()> {\n+        let generics = generics(db.upcast(), def.into());\n+        assert!(generics.parent_generics().is_some() == parent_subst.is_some());\n+        let params = generics\n+            .iter_self()\n+            .map(|(id, data)| match data {\n+                TypeOrConstParamData::TypeParamData(_) => ParamKind::Type,\n+                TypeOrConstParamData::ConstParamData(_) => {\n+                    ParamKind::Const(db.const_param_ty(ConstParamId::from_unchecked(id)))\n+                }\n+            })\n+            .collect();\n+        TyBuilder::new((), params, parent_subst)\n+    }\n+\n+    /// Creates a `TyBuilder` to build `Substitution` for a generator defined in `parent`.\n+    ///\n+    /// A generator's substitution consists of:\n+    /// - resume type of generator\n+    /// - yield type of generator ([`Generator::Yield`](std::ops::Generator::Yield))\n+    /// - return type of generator ([`Generator::Return`](std::ops::Generator::Return))\n+    /// - generic parameters in scope on `parent`\n+    /// in this order.\n+    ///\n+    /// This method prepopulates the builder with placeholder substitution of `parent`, so you\n+    /// should only push exactly 3 `GenericArg`s before building.\n+    pub fn subst_for_generator(db: &dyn HirDatabase, parent: DefWithBodyId) -> TyBuilder<()> {\n+        let parent_subst =\n+            parent.as_generic_def_id().map(|p| generics(db.upcast(), p).placeholder_subst(db));\n+        // These represent resume type, yield type, and return type of generator.\n+        let params = std::iter::repeat(ParamKind::Type).take(3).collect();\n+        TyBuilder::new((), params, parent_subst)\n     }\n \n     pub fn build(self) -> Substitution {\n@@ -213,24 +232,35 @@ impl TyBuilder<()> {\n \n impl TyBuilder<hir_def::AdtId> {\n     pub fn adt(db: &dyn HirDatabase, def: hir_def::AdtId) -> TyBuilder<hir_def::AdtId> {\n-        TyBuilder::subst_for_def(db, def).with_data(def)\n+        TyBuilder::subst_for_def(db, def, None).with_data(def)\n     }\n \n     pub fn fill_with_defaults(\n         mut self,\n         db: &dyn HirDatabase,\n         mut fallback: impl FnMut() -> Ty,\n     ) -> Self {\n+        // Note that we're building ADT, so we never have parent generic parameters.\n         let defaults = db.generic_defaults(self.data.into());\n+        let dummy_ty = TyKind::Error.intern(Interner).cast(Interner);\n         for default_ty in defaults.iter().skip(self.vec.len()) {\n-            if let GenericArgData::Ty(x) = default_ty.skip_binders().data(Interner) {\n+            // NOTE(skip_binders): we only check if the arg type is error type.\n+            if let Some(x) = default_ty.skip_binders().ty(Interner) {\n                 if x.is_unknown() {\n                     self.vec.push(fallback().cast(Interner));\n                     continue;\n                 }\n-            };\n-            // each default can depend on the previous parameters\n-            let subst_so_far = Substitution::from_iter(Interner, self.vec.clone());\n+            }\n+            // Each default can only depend on the previous parameters.\n+            // FIXME: we don't handle const generics here.\n+            let subst_so_far = Substitution::from_iter(\n+                Interner,\n+                self.vec\n+                    .iter()\n+                    .cloned()\n+                    .chain(iter::repeat(dummy_ty.clone()))\n+                    .take(self.param_kinds.len()),\n+            );\n             self.vec.push(default_ty.clone().substitute(Interner, &subst_so_far).cast(Interner));\n         }\n         self\n@@ -245,7 +275,7 @@ impl TyBuilder<hir_def::AdtId> {\n pub struct Tuple(usize);\n impl TyBuilder<Tuple> {\n     pub fn tuple(size: usize) -> TyBuilder<Tuple> {\n-        TyBuilder::new(Tuple(size), iter::repeat(ParamKind::Type).take(size).collect())\n+        TyBuilder::new(Tuple(size), iter::repeat(ParamKind::Type).take(size).collect(), None)\n     }\n \n     pub fn build(self) -> Ty {\n@@ -256,7 +286,7 @@ impl TyBuilder<Tuple> {\n \n impl TyBuilder<TraitId> {\n     pub fn trait_ref(db: &dyn HirDatabase, def: TraitId) -> TyBuilder<TraitId> {\n-        TyBuilder::subst_for_def(db, def).with_data(def)\n+        TyBuilder::subst_for_def(db, def, None).with_data(def)\n     }\n \n     pub fn build(self) -> TraitRef {\n@@ -266,8 +296,12 @@ impl TyBuilder<TraitId> {\n }\n \n impl TyBuilder<TypeAliasId> {\n-    pub fn assoc_type_projection(db: &dyn HirDatabase, def: TypeAliasId) -> TyBuilder<TypeAliasId> {\n-        TyBuilder::subst_for_def(db, def).with_data(def)\n+    pub fn assoc_type_projection(\n+        db: &dyn HirDatabase,\n+        def: TypeAliasId,\n+        parent_subst: Option<Substitution>,\n+    ) -> TyBuilder<TypeAliasId> {\n+        TyBuilder::subst_for_def(db, def, parent_subst).with_data(def)\n     }\n \n     pub fn build(self) -> ProjectionTy {\n@@ -277,35 +311,48 @@ impl TyBuilder<TypeAliasId> {\n }\n \n impl<T: HasInterner<Interner = Interner> + TypeFoldable<Interner>> TyBuilder<Binders<T>> {\n-    fn subst_binders(b: Binders<T>) -> Self {\n-        let param_kinds = b\n-            .binders\n-            .iter(Interner)\n-            .map(|x| match x {\n-                chalk_ir::VariableKind::Ty(_) => ParamKind::Type,\n-                chalk_ir::VariableKind::Lifetime => panic!(\"Got lifetime parameter\"),\n-                chalk_ir::VariableKind::Const(ty) => ParamKind::Const(ty.clone()),\n-            })\n-            .collect();\n-        TyBuilder::new(b, param_kinds)\n-    }\n-\n     pub fn build(self) -> T {\n         let (b, subst) = self.build_internal();\n         b.substitute(Interner, &subst)\n     }\n }\n \n impl TyBuilder<Binders<Ty>> {\n-    pub fn def_ty(db: &dyn HirDatabase, def: TyDefId) -> TyBuilder<Binders<Ty>> {\n-        TyBuilder::subst_binders(db.ty(def))\n+    pub fn def_ty(\n+        db: &dyn HirDatabase,\n+        def: TyDefId,\n+        parent_subst: Option<Substitution>,\n+    ) -> TyBuilder<Binders<Ty>> {\n+        let poly_ty = db.ty(def);\n+        let id: GenericDefId = match def {\n+            TyDefId::BuiltinType(_) => {\n+                assert!(parent_subst.is_none());\n+                return TyBuilder::new_empty(poly_ty);\n+            }\n+            TyDefId::AdtId(id) => id.into(),\n+            TyDefId::TypeAliasId(id) => id.into(),\n+        };\n+        TyBuilder::subst_for_def(db, id, parent_subst).with_data(poly_ty)\n     }\n \n     pub fn impl_self_ty(db: &dyn HirDatabase, def: hir_def::ImplId) -> TyBuilder<Binders<Ty>> {\n-        TyBuilder::subst_binders(db.impl_self_ty(def))\n+        TyBuilder::subst_for_def(db, def, None).with_data(db.impl_self_ty(def))\n     }\n \n-    pub fn value_ty(db: &dyn HirDatabase, def: ValueTyDefId) -> TyBuilder<Binders<Ty>> {\n-        TyBuilder::subst_binders(db.value_ty(def))\n+    pub fn value_ty(\n+        db: &dyn HirDatabase,\n+        def: ValueTyDefId,\n+        parent_subst: Option<Substitution>,\n+    ) -> TyBuilder<Binders<Ty>> {\n+        let poly_value_ty = db.value_ty(def);\n+        let id = match def.to_generic_def_id() {\n+            Some(id) => id,\n+            None => {\n+                // static items\n+                assert!(parent_subst.is_none());\n+                return TyBuilder::new_empty(poly_value_ty);\n+            }\n+        };\n+        TyBuilder::subst_for_def(db, id, parent_subst).with_data(poly_value_ty)\n     }\n }"}, {"sha": "3f3f8f7d0f2a2ac9d82b02fdb0439dd978713f0c", "filename": "crates/hir-ty/src/chalk_db.rs", "status": "modified", "additions": 61, "deletions": 10, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fhir-ty%2Fsrc%2Fchalk_db.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fhir-ty%2Fsrc%2Fchalk_db.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fchalk_db.rs?ref=e6540cff74534e6d9fb86d5d66e66423fad03766", "patch": "@@ -11,6 +11,7 @@ use chalk_solve::rust_ir::{self, OpaqueTyDatumBound, WellKnownTrait};\n \n use base_db::CrateId;\n use hir_def::{\n+    expr::Movability,\n     lang_item::{lang_attr, LangItemTarget},\n     AssocItemId, GenericDefId, HasModule, ItemContainerId, Lookup, ModuleId, TypeAliasId,\n };\n@@ -26,9 +27,9 @@ use crate::{\n     to_assoc_type_id, to_chalk_trait_id,\n     traits::ChalkContext,\n     utils::generics,\n-    AliasEq, AliasTy, BoundVar, CallableDefId, DebruijnIndex, FnDefId, Interner, ProjectionTy,\n-    ProjectionTyExt, QuantifiedWhereClause, Substitution, TraitRef, TraitRefExt, Ty, TyBuilder,\n-    TyExt, TyKind, WhereClause,\n+    wrap_empty_binders, AliasEq, AliasTy, BoundVar, CallableDefId, DebruijnIndex, FnDefId,\n+    Interner, ProjectionTy, ProjectionTyExt, QuantifiedWhereClause, Substitution, TraitRef,\n+    TraitRefExt, Ty, TyBuilder, TyExt, TyKind, WhereClause,\n };\n \n pub(crate) type AssociatedTyDatum = chalk_solve::rust_ir::AssociatedTyDatum<Interner>;\n@@ -372,17 +373,62 @@ impl<'a> chalk_solve::RustIrDatabase<Interner> for ChalkContext<'a> {\n     }\n     fn generator_datum(\n         &self,\n-        _: chalk_ir::GeneratorId<Interner>,\n+        id: chalk_ir::GeneratorId<Interner>,\n     ) -> std::sync::Arc<chalk_solve::rust_ir::GeneratorDatum<Interner>> {\n-        // FIXME\n-        unimplemented!()\n+        let (parent, expr) = self.db.lookup_intern_generator(id.into());\n+\n+        // We fill substitution with unknown type, because we only need to know whether the generic\n+        // params are types or consts to build `Binders` and those being filled up are for\n+        // `resume_type`, `yield_type`, and `return_type` of the generator in question.\n+        let subst = TyBuilder::subst_for_generator(self.db, parent).fill_with_unknown().build();\n+\n+        let input_output = rust_ir::GeneratorInputOutputDatum {\n+            resume_type: TyKind::BoundVar(BoundVar::new(DebruijnIndex::INNERMOST, 0))\n+                .intern(Interner),\n+            yield_type: TyKind::BoundVar(BoundVar::new(DebruijnIndex::INNERMOST, 1))\n+                .intern(Interner),\n+            return_type: TyKind::BoundVar(BoundVar::new(DebruijnIndex::INNERMOST, 2))\n+                .intern(Interner),\n+            // FIXME: calculate upvars\n+            upvars: vec![],\n+        };\n+\n+        let it = subst\n+            .iter(Interner)\n+            .map(|it| it.constant(Interner).map(|c| c.data(Interner).ty.clone()));\n+        let input_output = crate::make_type_and_const_binders(it, input_output);\n+\n+        let movability = match self.db.body(parent)[expr] {\n+            hir_def::expr::Expr::Closure {\n+                closure_kind: hir_def::expr::ClosureKind::Generator(movability),\n+                ..\n+            } => movability,\n+            _ => unreachable!(\"non generator expression interned as generator\"),\n+        };\n+        let movability = match movability {\n+            Movability::Static => rust_ir::Movability::Static,\n+            Movability::Movable => rust_ir::Movability::Movable,\n+        };\n+\n+        Arc::new(rust_ir::GeneratorDatum { movability, input_output })\n     }\n     fn generator_witness_datum(\n         &self,\n-        _: chalk_ir::GeneratorId<Interner>,\n+        id: chalk_ir::GeneratorId<Interner>,\n     ) -> std::sync::Arc<chalk_solve::rust_ir::GeneratorWitnessDatum<Interner>> {\n-        // FIXME\n-        unimplemented!()\n+        // FIXME: calculate inner types\n+        let inner_types =\n+            rust_ir::GeneratorWitnessExistential { types: wrap_empty_binders(vec![]) };\n+\n+        let (parent, _) = self.db.lookup_intern_generator(id.into());\n+        // See the comment in `generator_datum()` for unknown types.\n+        let subst = TyBuilder::subst_for_generator(self.db, parent).fill_with_unknown().build();\n+        let it = subst\n+            .iter(Interner)\n+            .map(|it| it.constant(Interner).map(|c| c.data(Interner).ty.clone()));\n+        let inner_types = crate::make_type_and_const_binders(it, inner_types);\n+\n+        Arc::new(rust_ir::GeneratorWitnessDatum { inner_types })\n     }\n \n     fn unification_database(&self) -> &dyn chalk_ir::UnificationDatabase<Interner> {\n@@ -429,10 +475,15 @@ pub(crate) fn associated_ty_data_query(\n     let resolver = hir_def::resolver::HasResolver::resolver(type_alias, db.upcast());\n     let ctx = crate::TyLoweringContext::new(db, &resolver)\n         .with_type_param_mode(crate::lower::ParamLoweringMode::Variable);\n-    let pro_ty = TyBuilder::assoc_type_projection(db, type_alias)\n+\n+    let trait_subst = TyBuilder::subst_for_def(db, trait_, None)\n+        .fill_with_bound_vars(crate::DebruijnIndex::INNERMOST, generic_params.len_self())\n+        .build();\n+    let pro_ty = TyBuilder::assoc_type_projection(db, type_alias, Some(trait_subst))\n         .fill_with_bound_vars(crate::DebruijnIndex::INNERMOST, 0)\n         .build();\n     let self_ty = TyKind::Alias(AliasTy::Projection(pro_ty)).intern(Interner);\n+\n     let mut bounds: Vec<_> = type_alias_data\n         .bounds\n         .iter()"}, {"sha": "4f0e9dbf1e4e9f1ab313bf3bec2d533c8ae4c2f6", "filename": "crates/hir-ty/src/chalk_ext.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fhir-ty%2Fsrc%2Fchalk_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fhir-ty%2Fsrc%2Fchalk_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fchalk_ext.rs?ref=e6540cff74534e6d9fb86d5d66e66423fad03766", "patch": "@@ -152,7 +152,7 @@ impl TyExt for Ty {\n             TyKind::FnDef(def, parameters) => {\n                 let callable_def = db.lookup_intern_callable_def((*def).into());\n                 let sig = db.callable_item_signature(callable_def);\n-                Some(sig.substitute(Interner, &parameters))\n+                Some(sig.substitute(Interner, parameters))\n             }\n             TyKind::Closure(.., substs) => {\n                 let sig_param = substs.at(Interner, 0).assert_ty_ref(Interner);\n@@ -166,6 +166,8 @@ impl TyExt for Ty {\n         let trait_ref = match self.kind(Interner) {\n             // The principal trait bound should be the first element of the bounds. This is an\n             // invariant ensured by `TyLoweringContext::lower_dyn_trait()`.\n+            // FIXME: dyn types may not have principal trait and we don't want to return auto trait\n+            // here.\n             TyKind::Dyn(dyn_ty) => dyn_ty.bounds.skip_binders().interned().get(0).and_then(|b| {\n                 match b.skip_binders() {\n                     WhereClause::Implemented(trait_ref) => Some(trait_ref),"}, {"sha": "2c0c6e0b8394fb14e8e819bc6fa6ea99eef71a1b", "filename": "crates/hir-ty/src/consteval.rs", "status": "modified", "additions": 92, "deletions": 16, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fhir-ty%2Fsrc%2Fconsteval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fhir-ty%2Fsrc%2Fconsteval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fconsteval.rs?ref=e6540cff74534e6d9fb86d5d66e66423fad03766", "patch": "@@ -7,14 +7,17 @@ use std::{\n \n use chalk_ir::{BoundVar, DebruijnIndex, GenericArgData, IntTy, Scalar};\n use hir_def::{\n+    builtin_type::BuiltinInt,\n     expr::{ArithOp, BinaryOp, Expr, ExprId, Literal, Pat, PatId},\n     path::ModPath,\n     resolver::{resolver_for_expr, ResolveValueResult, Resolver, ValueNs},\n+    src::HasChildSource,\n     type_ref::ConstScalar,\n-    ConstId, DefWithBodyId,\n+    ConstId, DefWithBodyId, EnumVariantId, Lookup,\n };\n-use la_arena::{Arena, Idx};\n+use la_arena::{Arena, Idx, RawIdx};\n use stdx::never;\n+use syntax::ast::HasName;\n \n use crate::{\n     db::HirDatabase, infer::InferenceContext, lower::ParamLoweringMode, to_placeholder_idx,\n@@ -77,6 +80,7 @@ pub enum ConstEvalError {\n #[derive(Debug, Clone, PartialEq, Eq)]\n pub enum ComputedExpr {\n     Literal(Literal),\n+    Enum(String, EnumVariantId, Literal),\n     Tuple(Box<[ComputedExpr]>),\n }\n \n@@ -104,6 +108,7 @@ impl Display for ComputedExpr {\n                 Literal::String(x) => std::fmt::Debug::fmt(x, f),\n                 Literal::ByteString(x) => std::fmt::Debug::fmt(x, f),\n             },\n+            ComputedExpr::Enum(name, _, _) => name.fmt(f),\n             ComputedExpr::Tuple(t) => {\n                 f.write_char('(')?;\n                 for x in &**t {\n@@ -148,13 +153,51 @@ fn is_valid(scalar: &Scalar, value: i128) -> bool {\n     }\n }\n \n+fn get_name(ctx: &mut ConstEvalCtx<'_>, variant: EnumVariantId) -> String {\n+    let loc = variant.parent.lookup(ctx.db.upcast());\n+    let children = variant.parent.child_source(ctx.db.upcast());\n+    let item_tree = loc.id.item_tree(ctx.db.upcast());\n+\n+    let variant_name = children.value[variant.local_id].name();\n+    let enum_name = item_tree[loc.id.value].name.to_string();\n+    enum_name + \"::\" + &variant_name.unwrap().to_string()\n+}\n+\n pub fn eval_const(\n     expr_id: ExprId,\n     ctx: &mut ConstEvalCtx<'_>,\n ) -> Result<ComputedExpr, ConstEvalError> {\n+    let u128_to_i128 = |it: u128| -> Result<i128, ConstEvalError> {\n+        it.try_into().map_err(|_| ConstEvalError::NotSupported(\"u128 is too big\"))\n+    };\n+\n     let expr = &ctx.exprs[expr_id];\n     match expr {\n-        Expr::Missing => Err(ConstEvalError::IncompleteExpr),\n+        Expr::Missing => match ctx.owner {\n+            // evaluate the implicit variant index of an enum variant without expression\n+            // FIXME: This should return the type of the enum representation\n+            DefWithBodyId::VariantId(variant) => {\n+                let prev_idx: u32 = variant.local_id.into_raw().into();\n+                let prev_idx = prev_idx.checked_sub(1).map(RawIdx::from).map(Idx::from_raw);\n+                let value = match prev_idx {\n+                    Some(local_id) => {\n+                        let prev_variant = EnumVariantId { local_id, parent: variant.parent };\n+                        1 + match ctx.db.const_eval_variant(prev_variant)? {\n+                            ComputedExpr::Literal(Literal::Int(v, _)) => v,\n+                            ComputedExpr::Literal(Literal::Uint(v, _)) => u128_to_i128(v)?,\n+                            _ => {\n+                                return Err(ConstEvalError::NotSupported(\n+                                    \"Enum can't contain this kind of value\",\n+                                ))\n+                            }\n+                        }\n+                    }\n+                    _ => 0,\n+                };\n+                Ok(ComputedExpr::Literal(Literal::Int(value, Some(BuiltinInt::I128))))\n+            }\n+            _ => Err(ConstEvalError::IncompleteExpr),\n+        },\n         Expr::Literal(l) => Ok(ComputedExpr::Literal(l.clone())),\n         &Expr::UnaryOp { expr, op } => {\n             let ty = &ctx.expr_ty(expr);\n@@ -167,9 +210,7 @@ pub fn eval_const(\n                             return Ok(ComputedExpr::Literal(Literal::Bool(!b)))\n                         }\n                         ComputedExpr::Literal(Literal::Int(v, _)) => v,\n-                        ComputedExpr::Literal(Literal::Uint(v, _)) => v\n-                            .try_into()\n-                            .map_err(|_| ConstEvalError::NotSupported(\"too big u128\"))?,\n+                        ComputedExpr::Literal(Literal::Uint(v, _)) => u128_to_i128(v)?,\n                         _ => return Err(ConstEvalError::NotSupported(\"this kind of operator\")),\n                     };\n                     let r = match ty.kind(Interner) {\n@@ -198,9 +239,7 @@ pub fn eval_const(\n                 hir_def::expr::UnaryOp::Neg => {\n                     let v = match ev {\n                         ComputedExpr::Literal(Literal::Int(v, _)) => v,\n-                        ComputedExpr::Literal(Literal::Uint(v, _)) => v\n-                            .try_into()\n-                            .map_err(|_| ConstEvalError::NotSupported(\"too big u128\"))?,\n+                        ComputedExpr::Literal(Literal::Uint(v, _)) => u128_to_i128(v)?,\n                         _ => return Err(ConstEvalError::NotSupported(\"this kind of operator\")),\n                     };\n                     Ok(ComputedExpr::Literal(Literal::Int(\n@@ -219,16 +258,12 @@ pub fn eval_const(\n             let op = op.ok_or(ConstEvalError::IncompleteExpr)?;\n             let v1 = match lhs {\n                 ComputedExpr::Literal(Literal::Int(v, _)) => v,\n-                ComputedExpr::Literal(Literal::Uint(v, _)) => {\n-                    v.try_into().map_err(|_| ConstEvalError::NotSupported(\"too big u128\"))?\n-                }\n+                ComputedExpr::Literal(Literal::Uint(v, _)) => u128_to_i128(v)?,\n                 _ => return Err(ConstEvalError::NotSupported(\"this kind of operator\")),\n             };\n             let v2 = match rhs {\n                 ComputedExpr::Literal(Literal::Int(v, _)) => v,\n-                ComputedExpr::Literal(Literal::Uint(v, _)) => {\n-                    v.try_into().map_err(|_| ConstEvalError::NotSupported(\"too big u128\"))?\n-                }\n+                ComputedExpr::Literal(Literal::Uint(v, _)) => u128_to_i128(v)?,\n                 _ => return Err(ConstEvalError::NotSupported(\"this kind of operator\")),\n             };\n             match op {\n@@ -339,9 +374,22 @@ pub fn eval_const(\n                 ValueNs::GenericParam(_) => {\n                     Err(ConstEvalError::NotSupported(\"const generic without substitution\"))\n                 }\n+                ValueNs::EnumVariantId(id) => match ctx.db.const_eval_variant(id)? {\n+                    ComputedExpr::Literal(lit) => {\n+                        Ok(ComputedExpr::Enum(get_name(ctx, id), id, lit))\n+                    }\n+                    _ => Err(ConstEvalError::NotSupported(\n+                        \"Enums can't evalute to anything but numbers\",\n+                    )),\n+                },\n                 _ => Err(ConstEvalError::NotSupported(\"path that are not const or local\")),\n             }\n         }\n+        // FIXME: Handle the cast target\n+        &Expr::Cast { expr, .. } => match eval_const(expr, ctx)? {\n+            ComputedExpr::Enum(_, _, lit) => Ok(ComputedExpr::Literal(lit)),\n+            _ => Err(ConstEvalError::NotSupported(\"Can't cast these types\")),\n+        },\n         _ => Err(ConstEvalError::NotSupported(\"This kind of expression\")),\n     }\n }\n@@ -412,7 +460,15 @@ pub(crate) fn const_eval_recover(\n     Err(ConstEvalError::Loop)\n }\n \n-pub(crate) fn const_eval_query(\n+pub(crate) fn const_eval_variant_recover(\n+    _: &dyn HirDatabase,\n+    _: &[String],\n+    _: &EnumVariantId,\n+) -> Result<ComputedExpr, ConstEvalError> {\n+    Err(ConstEvalError::Loop)\n+}\n+\n+pub(crate) fn const_eval_variant_query(\n     db: &dyn HirDatabase,\n     const_id: ConstId,\n ) -> Result<ComputedExpr, ConstEvalError> {\n@@ -433,6 +489,26 @@ pub(crate) fn const_eval_query(\n     result\n }\n \n+pub(crate) fn const_eval_query_variant(\n+    db: &dyn HirDatabase,\n+    variant_id: EnumVariantId,\n+) -> Result<ComputedExpr, ConstEvalError> {\n+    let def = variant_id.into();\n+    let body = db.body(def);\n+    let infer = &db.infer(def);\n+    eval_const(\n+        body.body_expr,\n+        &mut ConstEvalCtx {\n+            db,\n+            owner: def,\n+            exprs: &body.exprs,\n+            pats: &body.pats,\n+            local_data: HashMap::default(),\n+            infer,\n+        },\n+    )\n+}\n+\n pub(crate) fn eval_to_const<'a>(\n     expr: Idx<Expr>,\n     mode: ParamLoweringMode,"}, {"sha": "b76506f6ebc2c867f3b19dcdfcaf31886f60527e", "filename": "crates/hir-ty/src/consteval/tests.rs", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fhir-ty%2Fsrc%2Fconsteval%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fhir-ty%2Fsrc%2Fconsteval%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fconsteval%2Ftests.rs?ref=e6540cff74534e6d9fb86d5d66e66423fad03766", "patch": "@@ -87,6 +87,49 @@ fn consts() {\n     );\n }\n \n+#[test]\n+fn enums() {\n+    check_number(\n+        r#\"\n+    enum E {\n+        F1 = 1,\n+        F2 = 2 * E::F1 as u8,\n+        F3 = 3 * E::F2 as u8,\n+    }\n+    const GOAL: i32 = E::F3 as u8;\n+    \"#,\n+        6,\n+    );\n+    check_number(\n+        r#\"\n+    enum E { F1 = 1, F2, }\n+    const GOAL: i32 = E::F2 as u8;\n+    \"#,\n+        2,\n+    );\n+    check_number(\n+        r#\"\n+    enum E { F1, }\n+    const GOAL: i32 = E::F1 as u8;\n+    \"#,\n+        0,\n+    );\n+    let r = eval_goal(\n+        r#\"\n+        enum E { A = 1, }\n+        const GOAL: E = E::A;\n+        \"#,\n+    )\n+    .unwrap();\n+    match r {\n+        ComputedExpr::Enum(name, _, Literal::Uint(val, _)) => {\n+            assert_eq!(name, \"E::A\");\n+            assert_eq!(val, 1);\n+        }\n+        x => panic!(\"Expected enum but found {:?}\", x),\n+    }\n+}\n+\n #[test]\n fn const_loop() {\n     check_fail("}, {"sha": "932fce83563d7ea22d0904fbc7038eebd91d6cbf", "filename": "crates/hir-ty/src/db.rs", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fhir-ty%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fhir-ty%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fdb.rs?ref=e6540cff74534e6d9fb86d5d66e66423fad03766", "patch": "@@ -6,8 +6,8 @@ use std::sync::Arc;\n use arrayvec::ArrayVec;\n use base_db::{impl_intern_key, salsa, CrateId, Upcast};\n use hir_def::{\n-    db::DefDatabase, expr::ExprId, BlockId, ConstId, ConstParamId, DefWithBodyId, FunctionId,\n-    GenericDefId, ImplId, LifetimeParamId, LocalFieldId, TypeOrConstParamId, VariantId,\n+    db::DefDatabase, expr::ExprId, BlockId, ConstId, ConstParamId, DefWithBodyId, EnumVariantId,\n+    FunctionId, GenericDefId, ImplId, LifetimeParamId, LocalFieldId, TypeOrConstParamId, VariantId,\n };\n use la_arena::ArenaMap;\n \n@@ -43,10 +43,14 @@ pub trait HirDatabase: DefDatabase + Upcast<dyn DefDatabase> {\n     #[salsa::invoke(crate::lower::const_param_ty_query)]\n     fn const_param_ty(&self, def: ConstParamId) -> Ty;\n \n-    #[salsa::invoke(crate::consteval::const_eval_query)]\n+    #[salsa::invoke(crate::consteval::const_eval_variant_query)]\n     #[salsa::cycle(crate::consteval::const_eval_recover)]\n     fn const_eval(&self, def: ConstId) -> Result<ComputedExpr, ConstEvalError>;\n \n+    #[salsa::invoke(crate::consteval::const_eval_query_variant)]\n+    #[salsa::cycle(crate::consteval::const_eval_variant_recover)]\n+    fn const_eval_variant(&self, def: EnumVariantId) -> Result<ComputedExpr, ConstEvalError>;\n+\n     #[salsa::invoke(crate::lower::impl_trait_query)]\n     fn impl_trait(&self, def: ImplId) -> Option<Binders<TraitRef>>;\n \n@@ -116,6 +120,8 @@ pub trait HirDatabase: DefDatabase + Upcast<dyn DefDatabase> {\n     fn intern_impl_trait_id(&self, id: ImplTraitId) -> InternedOpaqueTyId;\n     #[salsa::interned]\n     fn intern_closure(&self, id: (DefWithBodyId, ExprId)) -> InternedClosureId;\n+    #[salsa::interned]\n+    fn intern_generator(&self, id: (DefWithBodyId, ExprId)) -> InternedGeneratorId;\n \n     #[salsa::invoke(chalk_db::associated_ty_data_query)]\n     fn associated_ty_data(&self, id: chalk_db::AssocTypeId) -> Arc<chalk_db::AssociatedTyDatum>;\n@@ -188,6 +194,9 @@ fn infer_wait(db: &dyn HirDatabase, def: DefWithBodyId) -> Arc<InferenceResult>\n         DefWithBodyId::ConstId(it) => {\n             db.const_data(it).name.clone().unwrap_or_else(Name::missing).to_string()\n         }\n+        DefWithBodyId::VariantId(it) => {\n+            db.enum_data(it.parent).variants[it.local_id].name.to_string()\n+        }\n     });\n     db.infer_query(def)\n }\n@@ -226,6 +235,10 @@ impl_intern_key!(InternedOpaqueTyId);\n pub struct InternedClosureId(salsa::InternId);\n impl_intern_key!(InternedClosureId);\n \n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct InternedGeneratorId(salsa::InternId);\n+impl_intern_key!(InternedGeneratorId);\n+\n /// This exists just for Chalk, because Chalk just has a single `FnDefId` where\n /// we have different IDs for struct and enum variant constructors.\n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Ord, PartialOrd)]"}, {"sha": "431ab949b46243ae2f8b0621454fe76614212334", "filename": "crates/hir-ty/src/diagnostics/unsafe_check.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Funsafe_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Funsafe_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Funsafe_check.rs?ref=e6540cff74534e6d9fb86d5d66e66423fad03766", "patch": "@@ -18,7 +18,9 @@ pub fn missing_unsafe(db: &dyn HirDatabase, def: DefWithBodyId) -> Vec<ExprId> {\n \n     let is_unsafe = match def {\n         DefWithBodyId::FunctionId(it) => db.function_data(it).has_unsafe_kw(),\n-        DefWithBodyId::StaticId(_) | DefWithBodyId::ConstId(_) => false,\n+        DefWithBodyId::StaticId(_) | DefWithBodyId::ConstId(_) | DefWithBodyId::VariantId(_) => {\n+            false\n+        }\n     };\n     if is_unsafe {\n         return res;"}, {"sha": "7f0baf49dadce9e510a0b133d811b2fde49ff19c", "filename": "crates/hir-ty/src/display.rs", "status": "modified", "additions": 41, "deletions": 6, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fhir-ty%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fhir-ty%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fdisplay.rs?ref=e6540cff74534e6d9fb86d5d66e66423fad03766", "patch": "@@ -20,13 +20,14 @@ use hir_def::{\n };\n use hir_expand::{hygiene::Hygiene, name::Name};\n use itertools::Itertools;\n+use smallvec::SmallVec;\n use syntax::SmolStr;\n \n use crate::{\n     db::HirDatabase,\n     from_assoc_type_id, from_foreign_def_id, from_placeholder_idx, lt_from_placeholder_idx,\n     mapping::from_chalk,\n-    primitive, subst_prefix, to_assoc_type_id,\n+    primitive, to_assoc_type_id,\n     utils::{self, generics},\n     AdtId, AliasEq, AliasTy, Binders, CallableDefId, CallableSig, Const, ConstValue, DomainGoal,\n     GenericArg, ImplTraitId, Interner, Lifetime, LifetimeData, LifetimeOutlives, Mutability,\n@@ -221,6 +222,7 @@ pub enum DisplaySourceCodeError {\n     PathNotFound,\n     UnknownType,\n     Closure,\n+    Generator,\n }\n \n pub enum HirDisplayError {\n@@ -504,8 +506,15 @@ impl HirDisplay for Ty {\n                     let total_len = parent_params + self_param + type_params + const_params;\n                     // We print all params except implicit impl Trait params. Still a bit weird; should we leave out parent and self?\n                     if total_len > 0 {\n+                        // `parameters` are in the order of fn's params (including impl traits),\n+                        // parent's params (those from enclosing impl or trait, if any).\n+                        let parameters = parameters.as_slice(Interner);\n+                        let fn_params_len = self_param + type_params + const_params;\n+                        let fn_params = parameters.get(..fn_params_len);\n+                        let parent_params = parameters.get(parameters.len() - parent_params..);\n+                        let params = parent_params.into_iter().chain(fn_params).flatten();\n                         write!(f, \"<\")?;\n-                        f.write_joined(&parameters.as_slice(Interner)[..total_len], \", \")?;\n+                        f.write_joined(params, \", \")?;\n                         write!(f, \">\")?;\n                     }\n                 }\n@@ -577,9 +586,8 @@ impl HirDisplay for Ty {\n                                         Some(x) => x,\n                                         None => return true,\n                                     };\n-                                    let actual_default = default_parameter\n-                                        .clone()\n-                                        .substitute(Interner, &subst_prefix(parameters, i));\n+                                    let actual_default =\n+                                        default_parameter.clone().substitute(Interner, &parameters);\n                                     parameter != &actual_default\n                                 }\n                                 let mut default_from = 0;\n@@ -783,7 +791,34 @@ impl HirDisplay for Ty {\n                 write!(f, \"{{unknown}}\")?;\n             }\n             TyKind::InferenceVar(..) => write!(f, \"_\")?,\n-            TyKind::Generator(..) => write!(f, \"{{generator}}\")?,\n+            TyKind::Generator(_, subst) => {\n+                if f.display_target.is_source_code() {\n+                    return Err(HirDisplayError::DisplaySourceCodeError(\n+                        DisplaySourceCodeError::Generator,\n+                    ));\n+                }\n+\n+                let subst = subst.as_slice(Interner);\n+                let a: Option<SmallVec<[&Ty; 3]>> = subst\n+                    .get(subst.len() - 3..)\n+                    .map(|args| args.iter().map(|arg| arg.ty(Interner)).collect())\n+                    .flatten();\n+\n+                if let Some([resume_ty, yield_ty, ret_ty]) = a.as_deref() {\n+                    write!(f, \"|\")?;\n+                    resume_ty.hir_fmt(f)?;\n+                    write!(f, \"|\")?;\n+\n+                    write!(f, \" yields \")?;\n+                    yield_ty.hir_fmt(f)?;\n+\n+                    write!(f, \" -> \")?;\n+                    ret_ty.hir_fmt(f)?;\n+                } else {\n+                    // This *should* be unreachable, but fallback just in case.\n+                    write!(f, \"{{generator}}\")?;\n+                }\n+            }\n             TyKind::GeneratorWitness(..) => write!(f, \"{{generator witness}}\")?,\n         }\n         Ok(())"}, {"sha": "0efff651cc174f91fcdcd5af56d4ab6c10ec07ae", "filename": "crates/hir-ty/src/infer.rs", "status": "modified", "additions": 34, "deletions": 5, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fhir-ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fhir-ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer.rs?ref=e6540cff74534e6d9fb86d5d66e66423fad03766", "patch": "@@ -2,7 +2,7 @@\n //! the type of each expression and pattern.\n //!\n //! For type inference, compare the implementations in rustc (the various\n-//! check_* methods in librustc_typeck/check/mod.rs are a good entry point) and\n+//! check_* methods in rustc_hir_analysis/check/mod.rs are a good entry point) and\n //! IntelliJ-Rust (org.rust.lang.core.types.infer). Our entry point for\n //! inference here is the `infer` function, which infers the types of all\n //! expressions in a given function.\n@@ -19,14 +19,15 @@ use std::sync::Arc;\n use chalk_ir::{cast::Cast, ConstValue, DebruijnIndex, Mutability, Safety, Scalar, TypeFlags};\n use hir_def::{\n     body::Body,\n+    builtin_type::BuiltinType,\n     data::{ConstData, StaticData},\n     expr::{BindingAnnotation, ExprId, PatId},\n     lang_item::LangItemTarget,\n     path::{path, Path},\n     resolver::{HasResolver, ResolveValueResult, Resolver, TypeNs, ValueNs},\n     type_ref::TypeRef,\n-    AdtId, AssocItemId, DefWithBodyId, EnumVariantId, FieldId, FunctionId, HasModule, Lookup,\n-    TraitId, TypeAliasId, VariantId,\n+    AdtId, AssocItemId, DefWithBodyId, EnumVariantId, FieldId, FunctionId, HasModule,\n+    ItemContainerId, Lookup, TraitId, TypeAliasId, VariantId,\n };\n use hir_expand::name::{name, Name};\n use itertools::Either;\n@@ -67,6 +68,12 @@ pub(crate) fn infer_query(db: &dyn HirDatabase, def: DefWithBodyId) -> Arc<Infer\n         DefWithBodyId::ConstId(c) => ctx.collect_const(&db.const_data(c)),\n         DefWithBodyId::FunctionId(f) => ctx.collect_fn(f),\n         DefWithBodyId::StaticId(s) => ctx.collect_static(&db.static_data(s)),\n+        DefWithBodyId::VariantId(v) => {\n+            ctx.return_ty = TyBuilder::builtin(match db.enum_data(v.parent).variant_body_type() {\n+                Either::Left(builtin) => BuiltinType::Int(builtin),\n+                Either::Right(builtin) => BuiltinType::Uint(builtin),\n+            });\n+        }\n     }\n \n     ctx.infer_body();\n@@ -332,7 +339,7 @@ pub struct InferenceResult {\n     /// unresolved or missing subpatterns or subpatterns of mismatched types.\n     pub type_of_pat: ArenaMap<PatId, Ty>,\n     type_mismatches: FxHashMap<ExprOrPatId, TypeMismatch>,\n-    /// Interned Unknown to return references to.\n+    /// Interned common types to return references to.\n     standard_types: InternedStandardTypes,\n     /// Stores the types which were implicitly dereferenced in pattern binding modes.\n     pub pat_adjustments: FxHashMap<PatId, Vec<Ty>>,\n@@ -412,6 +419,8 @@ pub(crate) struct InferenceContext<'a> {\n     /// closures, but currently this is the only field that will change there,\n     /// so it doesn't make sense.\n     return_ty: Ty,\n+    /// The resume type and the yield type, respectively, of the generator being inferred.\n+    resume_yield_tys: Option<(Ty, Ty)>,\n     diverges: Diverges,\n     breakables: Vec<BreakableContext>,\n }\n@@ -476,6 +485,7 @@ impl<'a> InferenceContext<'a> {\n             table: unify::InferenceTable::new(db, trait_env.clone()),\n             trait_env,\n             return_ty: TyKind::Error.intern(Interner), // set in collect_fn_signature\n+            resume_yield_tys: None,\n             db,\n             owner,\n             body,\n@@ -703,6 +713,8 @@ impl<'a> InferenceContext<'a> {\n         &mut self,\n         inner_ty: Ty,\n         assoc_ty: Option<TypeAliasId>,\n+        // FIXME(GATs): these are args for the trait ref, args for assoc type itself should be\n+        // handled when we support them.\n         params: &[GenericArg],\n     ) -> Ty {\n         match assoc_ty {\n@@ -794,7 +806,18 @@ impl<'a> InferenceContext<'a> {\n                 self.resolve_variant_on_alias(ty, unresolved, path)\n             }\n             TypeNs::TypeAliasId(it) => {\n-                let ty = TyBuilder::def_ty(self.db, it.into())\n+                let container = it.lookup(self.db.upcast()).container;\n+                let parent_subst = match container {\n+                    ItemContainerId::TraitId(id) => {\n+                        let subst = TyBuilder::subst_for_def(self.db, id, None)\n+                            .fill_with_inference_vars(&mut self.table)\n+                            .build();\n+                        Some(subst)\n+                    }\n+                    // Type aliases do not exist in impls.\n+                    _ => None,\n+                };\n+                let ty = TyBuilder::def_ty(self.db, it.into(), parent_subst)\n                     .fill_with_inference_vars(&mut self.table)\n                     .build();\n                 self.resolve_variant_on_alias(ty, unresolved, path)\n@@ -873,6 +896,12 @@ impl<'a> InferenceContext<'a> {\n     fn resolve_into_iter_item(&self) -> Option<TypeAliasId> {\n         let path = path![core::iter::IntoIterator];\n         let trait_ = self.resolver.resolve_known_trait(self.db.upcast(), &path)?;\n+        self.db.trait_data(trait_).associated_type_by_name(&name![IntoIter])\n+    }\n+\n+    fn resolve_iterator_item(&self) -> Option<TypeAliasId> {\n+        let path = path![core::iter::Iterator];\n+        let trait_ = self.resolver.resolve_known_trait(self.db.upcast(), &path)?;\n         self.db.trait_data(trait_).associated_type_by_name(&name![Item])\n     }\n "}, {"sha": "094e460dbf79b0b08b35f2911c0bf83d78d8faca", "filename": "crates/hir-ty/src/infer/closure.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fhir-ty%2Fsrc%2Finfer%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fhir-ty%2Fsrc%2Finfer%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fclosure.rs?ref=e6540cff74534e6d9fb86d5d66e66423fad03766", "patch": "@@ -12,6 +12,7 @@ use crate::{\n use super::{Expectation, InferenceContext};\n \n impl InferenceContext<'_> {\n+    // This function handles both closures and generators.\n     pub(super) fn deduce_closure_type_from_expectations(\n         &mut self,\n         closure_expr: ExprId,\n@@ -27,6 +28,11 @@ impl InferenceContext<'_> {\n         // Deduction from where-clauses in scope, as well as fn-pointer coercion are handled here.\n         let _ = self.coerce(Some(closure_expr), closure_ty, &expected_ty);\n \n+        // Generators are not Fn* so return early.\n+        if matches!(closure_ty.kind(Interner), TyKind::Generator(..)) {\n+            return;\n+        }\n+\n         // Deduction based on the expected `dyn Fn` is done separately.\n         if let TyKind::Dyn(dyn_ty) = expected_ty.kind(Interner) {\n             if let Some(sig) = self.deduce_sig_from_dyn_ty(dyn_ty) {"}, {"sha": "8df25c83c6eb7d5b35a910881403186861be2a11", "filename": "crates/hir-ty/src/infer/coerce.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fhir-ty%2Fsrc%2Finfer%2Fcoerce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fhir-ty%2Fsrc%2Finfer%2Fcoerce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fcoerce.rs?ref=e6540cff74534e6d9fb86d5d66e66423fad03766", "patch": "@@ -3,7 +3,7 @@\n //! like going from `&Vec<T>` to `&[T]`.\n //!\n //! See <https://doc.rust-lang.org/nomicon/coercions.html> and\n-//! `librustc_typeck/check/coercion.rs`.\n+//! `rustc_hir_analysis/check/coercion.rs`.\n \n use std::{iter, sync::Arc};\n "}, {"sha": "f56108b26c45bdaea3096f4616828c28ba260d12", "filename": "crates/hir-ty/src/infer/expr.rs", "status": "modified", "additions": 74, "deletions": 40, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs?ref=e6540cff74534e6d9fb86d5d66e66423fad03766", "patch": "@@ -10,7 +10,10 @@ use chalk_ir::{\n     cast::Cast, fold::Shift, DebruijnIndex, GenericArgData, Mutability, TyVariableKind,\n };\n use hir_def::{\n-    expr::{ArithOp, Array, BinaryOp, CmpOp, Expr, ExprId, LabelId, Literal, Statement, UnaryOp},\n+    expr::{\n+        ArithOp, Array, BinaryOp, ClosureKind, CmpOp, Expr, ExprId, LabelId, Literal, Statement,\n+        UnaryOp,\n+    },\n     generics::TypeOrConstParamData,\n     path::{GenericArg, GenericArgs},\n     resolver::resolver_for_expr,\n@@ -204,8 +207,10 @@ impl<'a> InferenceContext<'a> {\n             }\n             &Expr::For { iterable, body, pat, label } => {\n                 let iterable_ty = self.infer_expr(iterable, &Expectation::none());\n-                let pat_ty =\n+                let into_iter_ty =\n                     self.resolve_associated_type(iterable_ty, self.resolve_into_iter_item());\n+                let pat_ty =\n+                    self.resolve_associated_type(into_iter_ty, self.resolve_iterator_item());\n \n                 self.infer_pat(pat, &pat_ty, BindingMode::default());\n                 self.with_breakable_ctx(BreakableKind::Loop, self.err_ty(), label, |this| {\n@@ -216,7 +221,7 @@ impl<'a> InferenceContext<'a> {\n                 self.diverges = Diverges::Maybe;\n                 TyBuilder::unit()\n             }\n-            Expr::Closure { body, args, ret_type, arg_types } => {\n+            Expr::Closure { body, args, ret_type, arg_types, closure_kind } => {\n                 assert_eq!(args.len(), arg_types.len());\n \n                 let mut sig_tys = Vec::new();\n@@ -244,20 +249,40 @@ impl<'a> InferenceContext<'a> {\n                     ),\n                 })\n                 .intern(Interner);\n-                let closure_id = self.db.intern_closure((self.owner, tgt_expr)).into();\n-                let closure_ty =\n-                    TyKind::Closure(closure_id, Substitution::from1(Interner, sig_ty.clone()))\n-                        .intern(Interner);\n+\n+                let (ty, resume_yield_tys) = if matches!(closure_kind, ClosureKind::Generator(_)) {\n+                    // FIXME: report error when there are more than 1 parameter.\n+                    let resume_ty = match sig_tys.first() {\n+                        // When `sig_tys.len() == 1` the first type is the return type, not the\n+                        // first parameter type.\n+                        Some(ty) if sig_tys.len() > 1 => ty.clone(),\n+                        _ => self.result.standard_types.unit.clone(),\n+                    };\n+                    let yield_ty = self.table.new_type_var();\n+\n+                    let subst = TyBuilder::subst_for_generator(self.db, self.owner)\n+                        .push(resume_ty.clone())\n+                        .push(yield_ty.clone())\n+                        .push(ret_ty.clone())\n+                        .build();\n+\n+                    let generator_id = self.db.intern_generator((self.owner, tgt_expr)).into();\n+                    let generator_ty = TyKind::Generator(generator_id, subst).intern(Interner);\n+\n+                    (generator_ty, Some((resume_ty, yield_ty)))\n+                } else {\n+                    let closure_id = self.db.intern_closure((self.owner, tgt_expr)).into();\n+                    let closure_ty =\n+                        TyKind::Closure(closure_id, Substitution::from1(Interner, sig_ty.clone()))\n+                            .intern(Interner);\n+\n+                    (closure_ty, None)\n+                };\n \n                 // Eagerly try to relate the closure type with the expected\n                 // type, otherwise we often won't have enough information to\n                 // infer the body.\n-                self.deduce_closure_type_from_expectations(\n-                    tgt_expr,\n-                    &closure_ty,\n-                    &sig_ty,\n-                    expected,\n-                );\n+                self.deduce_closure_type_from_expectations(tgt_expr, &ty, &sig_ty, expected);\n \n                 // Now go through the argument patterns\n                 for (arg_pat, arg_ty) in args.iter().zip(sig_tys) {\n@@ -266,15 +291,18 @@ impl<'a> InferenceContext<'a> {\n \n                 let prev_diverges = mem::replace(&mut self.diverges, Diverges::Maybe);\n                 let prev_ret_ty = mem::replace(&mut self.return_ty, ret_ty.clone());\n+                let prev_resume_yield_tys =\n+                    mem::replace(&mut self.resume_yield_tys, resume_yield_tys);\n \n                 self.with_breakable_ctx(BreakableKind::Border, self.err_ty(), None, |this| {\n                     this.infer_expr_coerce(*body, &Expectation::has_type(ret_ty));\n                 });\n \n                 self.diverges = prev_diverges;\n                 self.return_ty = prev_ret_ty;\n+                self.resume_yield_tys = prev_resume_yield_tys;\n \n-                closure_ty\n+                ty\n             }\n             Expr::Call { callee, args, .. } => {\n                 let callee_ty = self.infer_expr(*callee, &Expectation::none());\n@@ -423,11 +451,18 @@ impl<'a> InferenceContext<'a> {\n                 TyKind::Never.intern(Interner)\n             }\n             Expr::Yield { expr } => {\n-                // FIXME: track yield type for coercion\n-                if let Some(expr) = expr {\n-                    self.infer_expr(*expr, &Expectation::none());\n+                if let Some((resume_ty, yield_ty)) = self.resume_yield_tys.clone() {\n+                    if let Some(expr) = expr {\n+                        self.infer_expr_coerce(*expr, &Expectation::has_type(yield_ty));\n+                    } else {\n+                        let unit = self.result.standard_types.unit.clone();\n+                        let _ = self.coerce(Some(tgt_expr), &unit, &yield_ty);\n+                    }\n+                    resume_ty\n+                } else {\n+                    // FIXME: report error (yield expr in non-generator)\n+                    TyKind::Error.intern(Interner)\n                 }\n-                TyKind::Never.intern(Interner)\n             }\n             Expr::RecordLit { path, fields, spread, .. } => {\n                 let (ty, def_id) = self.resolve_variant(path.as_deref(), false);\n@@ -952,11 +987,13 @@ impl<'a> InferenceContext<'a> {\n         let lhs_ty = self.infer_expr(lhs, &lhs_expectation);\n         let rhs_ty = self.table.new_type_var();\n \n-        let func = lang_names_for_bin_op(op).and_then(|(name, lang_item)| {\n-            self.db.trait_data(self.resolve_lang_item(lang_item)?.as_trait()?).method_by_name(&name)\n+        let trait_func = lang_names_for_bin_op(op).and_then(|(name, lang_item)| {\n+            let trait_id = self.resolve_lang_item(lang_item)?.as_trait()?;\n+            let func = self.db.trait_data(trait_id).method_by_name(&name)?;\n+            Some((trait_id, func))\n         });\n-        let func = match func {\n-            Some(func) => func,\n+        let (trait_, func) = match trait_func {\n+            Some(it) => it,\n             None => {\n                 let rhs_ty = self.builtin_binary_op_rhs_expectation(op, lhs_ty.clone());\n                 let rhs_ty = self.infer_expr_coerce(rhs, &Expectation::from_option(rhs_ty));\n@@ -966,7 +1003,9 @@ impl<'a> InferenceContext<'a> {\n             }\n         };\n \n-        let subst = TyBuilder::subst_for_def(self.db, func)\n+        // HACK: We can use this substitution for the function because the function itself doesn't\n+        // have its own generic parameters.\n+        let subst = TyBuilder::subst_for_def(self.db, trait_, None)\n             .push(lhs_ty.clone())\n             .push(rhs_ty.clone())\n             .build();\n@@ -1245,19 +1284,7 @@ impl<'a> InferenceContext<'a> {\n         assert_eq!(self_params, 0); // method shouldn't have another Self param\n         let total_len = parent_params + type_params + const_params + impl_trait_params;\n         let mut substs = Vec::with_capacity(total_len);\n-        // Parent arguments are unknown\n-        for (id, param) in def_generics.iter_parent() {\n-            match param {\n-                TypeOrConstParamData::TypeParamData(_) => {\n-                    substs.push(GenericArgData::Ty(self.table.new_type_var()).intern(Interner));\n-                }\n-                TypeOrConstParamData::ConstParamData(_) => {\n-                    let ty = self.db.const_param_ty(ConstParamId::from_unchecked(id));\n-                    substs\n-                        .push(GenericArgData::Const(self.table.new_const_var(ty)).intern(Interner));\n-                }\n-            }\n-        }\n+\n         // handle provided arguments\n         if let Some(generic_args) = generic_args {\n             // if args are provided, it should be all of them, but we can't rely on that\n@@ -1266,7 +1293,7 @@ impl<'a> InferenceContext<'a> {\n                 .iter()\n                 .filter(|arg| !matches!(arg, GenericArg::Lifetime(_)))\n                 .take(type_params + const_params)\n-                .zip(def_generics.iter_id().skip(parent_params))\n+                .zip(def_generics.iter_id())\n             {\n                 if let Some(g) = generic_arg_to_chalk(\n                     self.db,\n@@ -1290,6 +1317,9 @@ impl<'a> InferenceContext<'a> {\n                 }\n             }\n         };\n+\n+        // Handle everything else as unknown. This also handles generic arguments for the method's\n+        // parent (impl or trait), which should come after those for the method.\n         for (id, data) in def_generics.iter().skip(substs.len()) {\n             match data {\n                 TypeOrConstParamData::TypeParamData(_) => {\n@@ -1327,9 +1357,13 @@ impl<'a> InferenceContext<'a> {\n                 CallableDefId::FunctionId(f) => {\n                     if let ItemContainerId::TraitId(trait_) = f.lookup(self.db.upcast()).container {\n                         // construct a TraitRef\n-                        let substs = crate::subst_prefix(\n-                            &*parameters,\n-                            generics(self.db.upcast(), trait_.into()).len(),\n+                        let params_len = parameters.len(Interner);\n+                        let trait_params_len = generics(self.db.upcast(), trait_.into()).len();\n+                        let substs = Substitution::from_iter(\n+                            Interner,\n+                            // The generic parameters for the trait come after those for the\n+                            // function.\n+                            &parameters.as_slice(Interner)[params_len - trait_params_len..],\n                         );\n                         self.push_obligation(\n                             TraitRef { trait_id: to_chalk_trait_id(trait_), substitution: substs }"}, {"sha": "7a4754cdc7bb899848ea9b032825945407e13850", "filename": "crates/hir-ty/src/infer/path.rs", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fhir-ty%2Fsrc%2Finfer%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fhir-ty%2Fsrc%2Finfer%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fpath.rs?ref=e6540cff74534e6d9fb86d5d66e66423fad03766", "patch": "@@ -12,8 +12,8 @@ use crate::{\n     builder::ParamKind,\n     consteval,\n     method_resolution::{self, VisibleFromModule},\n-    GenericArgData, Interner, Substitution, TraitRefExt, Ty, TyBuilder, TyExt, TyKind,\n-    ValueTyDefId,\n+    utils::generics,\n+    Interner, Substitution, TraitRefExt, Ty, TyBuilder, TyExt, TyKind, ValueTyDefId,\n };\n \n use super::{ExprOrPatId, InferenceContext, TraitRef};\n@@ -96,17 +96,21 @@ impl<'a> InferenceContext<'a> {\n             ValueNs::GenericParam(it) => return Some(self.db.const_param_ty(it)),\n         };\n \n-        let parent_substs = self_subst.unwrap_or_else(|| Substitution::empty(Interner));\n         let ctx = crate::lower::TyLoweringContext::new(self.db, &self.resolver);\n         let substs = ctx.substs_from_path(path, typable, true);\n-        let mut it = substs.as_slice(Interner)[parent_substs.len(Interner)..].iter().cloned();\n-        let ty = TyBuilder::value_ty(self.db, typable)\n-            .use_parent_substs(&parent_substs)\n+        let substs = substs.as_slice(Interner);\n+        let parent_substs = self_subst.or_else(|| {\n+            let generics = generics(self.db.upcast(), typable.to_generic_def_id()?);\n+            let parent_params_len = generics.parent_generics()?.len();\n+            let parent_args = &substs[substs.len() - parent_params_len..];\n+            Some(Substitution::from_iter(Interner, parent_args))\n+        });\n+        let parent_substs_len = parent_substs.as_ref().map_or(0, |s| s.len(Interner));\n+        let mut it = substs.iter().take(substs.len() - parent_substs_len).cloned();\n+        let ty = TyBuilder::value_ty(self.db, typable, parent_substs)\n             .fill(|x| {\n                 it.next().unwrap_or_else(|| match x {\n-                    ParamKind::Type => {\n-                        GenericArgData::Ty(TyKind::Error.intern(Interner)).intern(Interner)\n-                    }\n+                    ParamKind::Type => TyKind::Error.intern(Interner).cast(Interner),\n                     ParamKind::Const(ty) => consteval::unknown_const_as_generic(ty.clone()),\n                 })\n             })\n@@ -249,7 +253,7 @@ impl<'a> InferenceContext<'a> {\n                 };\n                 let substs = match container {\n                     ItemContainerId::ImplId(impl_id) => {\n-                        let impl_substs = TyBuilder::subst_for_def(self.db, impl_id)\n+                        let impl_substs = TyBuilder::subst_for_def(self.db, impl_id, None)\n                             .fill_with_inference_vars(&mut self.table)\n                             .build();\n                         let impl_self_ty ="}, {"sha": "6ccd0b215c6e480e72e17ed62a663ffc2d02ad9c", "filename": "crates/hir-ty/src/infer/unify.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fhir-ty%2Fsrc%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fhir-ty%2Fsrc%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Funify.rs?ref=e6540cff74534e6d9fb86d5d66e66423fad03766", "patch": "@@ -598,11 +598,14 @@ impl<'a> InferenceTable<'a> {\n             .build();\n \n         let projection = {\n-            let b = TyBuilder::assoc_type_projection(self.db, output_assoc_type);\n+            let b = TyBuilder::subst_for_def(self.db, fn_once_trait, None);\n             if b.remaining() != 2 {\n                 return None;\n             }\n-            b.push(ty.clone()).push(arg_ty).build()\n+            let fn_once_subst = b.push(ty.clone()).push(arg_ty).build();\n+\n+            TyBuilder::assoc_type_projection(self.db, output_assoc_type, Some(fn_once_subst))\n+                .build()\n         };\n \n         let trait_env = self.trait_env.env.clone();"}, {"sha": "223d705b157b32c03755a65e416ae380c1d22916", "filename": "crates/hir-ty/src/lower.rs", "status": "modified", "additions": 156, "deletions": 79, "changes": 235, "blob_url": "https://github.com/rust-lang/rust/blob/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fhir-ty%2Fsrc%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fhir-ty%2Fsrc%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Flower.rs?ref=e6540cff74534e6d9fb86d5d66e66423fad03766", "patch": "@@ -306,7 +306,7 @@ impl<'a> TyLoweringContext<'a> {\n                         // FIXME we're probably doing something wrong here\n                         self.impl_trait_counter.set(idx + count_impl_traits(type_ref) as u16);\n                         let (\n-                            parent_params,\n+                            _parent_params,\n                             self_params,\n                             list_params,\n                             const_params,\n@@ -319,7 +319,7 @@ impl<'a> TyLoweringContext<'a> {\n                         };\n                         TyKind::BoundVar(BoundVar::new(\n                             self.in_binders,\n-                            idx as usize + parent_params + self_params + list_params + const_params,\n+                            idx as usize + self_params + list_params + const_params,\n                         ))\n                         .intern(Interner)\n                     }\n@@ -499,14 +499,31 @@ impl<'a> TyLoweringContext<'a> {\n                 .intern(Interner)\n             }\n             TypeNs::SelfType(impl_id) => {\n-                let generics = generics(self.db.upcast(), impl_id.into());\n-                let substs = match self.type_param_mode {\n-                    ParamLoweringMode::Placeholder => generics.placeholder_subst(self.db),\n+                let def =\n+                    self.resolver.generic_def().expect(\"impl should have generic param scope\");\n+                let generics = generics(self.db.upcast(), def);\n+\n+                match self.type_param_mode {\n+                    ParamLoweringMode::Placeholder => {\n+                        // `def` can be either impl itself or item within, and we need impl itself\n+                        // now.\n+                        let generics = generics.parent_generics().unwrap_or(&generics);\n+                        let subst = generics.placeholder_subst(self.db);\n+                        self.db.impl_self_ty(impl_id).substitute(Interner, &subst)\n+                    }\n                     ParamLoweringMode::Variable => {\n-                        generics.bound_vars_subst(self.db, self.in_binders)\n+                        let starting_from = match def {\n+                            GenericDefId::ImplId(_) => 0,\n+                            // `def` is an item within impl. We need to substitute `BoundVar`s but\n+                            // remember that they are for parent (i.e. impl) generic params so they\n+                            // come after our own params.\n+                            _ => generics.len_self(),\n+                        };\n+                        TyBuilder::impl_self_ty(self.db, impl_id)\n+                            .fill_with_bound_vars(self.in_binders, starting_from)\n+                            .build()\n                     }\n-                };\n-                self.db.impl_self_ty(impl_id).substitute(Interner, &substs)\n+                }\n             }\n             TypeNs::AdtSelfType(adt) => {\n                 let generics = generics(self.db.upcast(), adt.into());\n@@ -663,40 +680,31 @@ impl<'a> TyLoweringContext<'a> {\n     fn substs_from_path_segment(\n         &self,\n         segment: PathSegment<'_>,\n-        def_generic: Option<GenericDefId>,\n+        def: Option<GenericDefId>,\n         infer_args: bool,\n         explicit_self_ty: Option<Ty>,\n     ) -> Substitution {\n+        // Remember that the item's own generic args come before its parent's.\n         let mut substs = Vec::new();\n-        let def_generics = if let Some(def) = def_generic {\n-            generics(self.db.upcast(), def)\n+        let def = if let Some(d) = def {\n+            d\n         } else {\n             return Substitution::empty(Interner);\n         };\n+        let def_generics = generics(self.db.upcast(), def);\n         let (parent_params, self_params, type_params, const_params, impl_trait_params) =\n             def_generics.provenance_split();\n-        let total_len =\n-            parent_params + self_params + type_params + const_params + impl_trait_params;\n+        let item_len = self_params + type_params + const_params + impl_trait_params;\n+        let total_len = parent_params + item_len;\n \n-        let ty_error = GenericArgData::Ty(TyKind::Error.intern(Interner)).intern(Interner);\n+        let ty_error = TyKind::Error.intern(Interner).cast(Interner);\n \n         let mut def_generic_iter = def_generics.iter_id();\n \n-        for _ in 0..parent_params {\n-            if let Some(eid) = def_generic_iter.next() {\n-                match eid {\n-                    Either::Left(_) => substs.push(ty_error.clone()),\n-                    Either::Right(x) => {\n-                        substs.push(unknown_const_as_generic(self.db.const_param_ty(x)))\n-                    }\n-                }\n-            }\n-        }\n-\n         let fill_self_params = || {\n             for x in explicit_self_ty\n                 .into_iter()\n-                .map(|x| GenericArgData::Ty(x).intern(Interner))\n+                .map(|x| x.cast(Interner))\n                 .chain(iter::repeat(ty_error.clone()))\n                 .take(self_params)\n             {\n@@ -757,37 +765,40 @@ impl<'a> TyLoweringContext<'a> {\n             fill_self_params();\n         }\n \n+        // These params include those of parent.\n+        let remaining_params: SmallVec<[_; 2]> = def_generic_iter\n+            .map(|eid| match eid {\n+                Either::Left(_) => ty_error.clone(),\n+                Either::Right(x) => unknown_const_as_generic(self.db.const_param_ty(x)),\n+            })\n+            .collect();\n+        assert_eq!(remaining_params.len() + substs.len(), total_len);\n+\n         // handle defaults. In expression or pattern path segments without\n         // explicitly specified type arguments, missing type arguments are inferred\n         // (i.e. defaults aren't used).\n         if !infer_args || had_explicit_args {\n-            if let Some(def_generic) = def_generic {\n-                let defaults = self.db.generic_defaults(def_generic);\n-                assert_eq!(total_len, defaults.len());\n-\n-                for default_ty in defaults.iter().skip(substs.len()) {\n-                    // each default can depend on the previous parameters\n-                    let substs_so_far = Substitution::from_iter(Interner, substs.clone());\n-                    if let Some(_id) = def_generic_iter.next() {\n-                        substs.push(default_ty.clone().substitute(Interner, &substs_so_far));\n-                    }\n-                }\n+            let defaults = self.db.generic_defaults(def);\n+            assert_eq!(total_len, defaults.len());\n+            let parent_from = item_len - substs.len();\n+\n+            for (idx, default_ty) in defaults[substs.len()..item_len].iter().enumerate() {\n+                // each default can depend on the previous parameters\n+                let substs_so_far = Substitution::from_iter(\n+                    Interner,\n+                    substs.iter().cloned().chain(remaining_params[idx..].iter().cloned()),\n+                );\n+                substs.push(default_ty.clone().substitute(Interner, &substs_so_far));\n             }\n-        }\n \n-        // add placeholders for args that were not provided\n-        // FIXME: emit diagnostics in contexts where this is not allowed\n-        for eid in def_generic_iter {\n-            match eid {\n-                Either::Left(_) => substs.push(ty_error.clone()),\n-                Either::Right(x) => {\n-                    substs.push(unknown_const_as_generic(self.db.const_param_ty(x)))\n-                }\n-            }\n+            // Keep parent's params as unknown.\n+            let mut remaining_params = remaining_params;\n+            substs.extend(remaining_params.drain(parent_from..));\n+        } else {\n+            substs.extend(remaining_params);\n         }\n-        // If this assert fails, it means you pushed into subst but didn't call .next() of def_generic_iter\n-        assert_eq!(substs.len(), total_len);\n \n+        assert_eq!(substs.len(), total_len);\n         Substitution::from_iter(Interner, substs)\n     }\n \n@@ -981,10 +992,11 @@ impl<'a> TyLoweringContext<'a> {\n \n     fn lower_dyn_trait(&self, bounds: &[Interned<TypeBound>]) -> Ty {\n         let self_ty = TyKind::BoundVar(BoundVar::new(DebruijnIndex::INNERMOST, 0)).intern(Interner);\n-        // INVARIANT: The principal trait bound must come first. Others may be in any order but\n-        // should be in the same order for the same set but possibly different order of bounds in\n-        // the input.\n-        // This invariant is used by `TyExt::dyn_trait()` and chalk.\n+        // INVARIANT: The principal trait bound, if present, must come first. Others may be in any\n+        // order but should be in the same order for the same set but possibly different order of\n+        // bounds in the input.\n+        // INVARIANT: If this function returns `DynTy`, there should be at least one trait bound.\n+        // These invariants are utilized by `TyExt::dyn_trait()` and chalk.\n         let bounds = self.with_shifted_in(DebruijnIndex::ONE, |ctx| {\n             let mut bounds: Vec<_> = bounds\n                 .iter()\n@@ -1035,6 +1047,12 @@ impl<'a> TyLoweringContext<'a> {\n                 return None;\n             }\n \n+            if bounds.first().and_then(|b| b.trait_id()).is_none() {\n+                // When there's no trait bound, that's an error. This happens when the trait refs\n+                // are unresolved.\n+                return None;\n+            }\n+\n             // As multiple occurrences of the same auto traits *are* permitted, we dedulicate the\n             // bounds. We shouldn't have repeated elements besides auto traits at this point.\n             bounds.dedup();\n@@ -1046,7 +1064,8 @@ impl<'a> TyLoweringContext<'a> {\n             let bounds = crate::make_single_type_binders(bounds);\n             TyKind::Dyn(DynTy { bounds, lifetime: static_lifetime() }).intern(Interner)\n         } else {\n-            // FIXME: report error (additional non-auto traits or associated type rebound)\n+            // FIXME: report error\n+            // (additional non-auto traits, associated type rebound, or no resolved trait)\n             TyKind::Error.intern(Interner)\n         }\n     }\n@@ -1139,11 +1158,28 @@ fn named_associated_type_shorthand_candidates<R>(\n     };\n \n     match res {\n-        TypeNs::SelfType(impl_id) => search(\n+        TypeNs::SelfType(impl_id) => {\n             // we're _in_ the impl -- the binders get added back later. Correct,\n             // but it would be nice to make this more explicit\n-            db.impl_trait(impl_id)?.into_value_and_skipped_binders().0,\n-        ),\n+            let trait_ref = db.impl_trait(impl_id)?.into_value_and_skipped_binders().0;\n+\n+            let impl_id_as_generic_def: GenericDefId = impl_id.into();\n+            if impl_id_as_generic_def != def {\n+                // `trait_ref` contains `BoundVar`s bound by impl's `Binders`, but here we need\n+                // `BoundVar`s from `def`'s point of view.\n+                // FIXME: A `HirDatabase` query may be handy if this process is needed in more\n+                // places. It'd be almost identical as `impl_trait_query` where `resolver` would be\n+                // of `def` instead of `impl_id`.\n+                let starting_idx = generics(db.upcast(), def).len_self();\n+                let subst = TyBuilder::subst_for_def(db, impl_id, None)\n+                    .fill_with_bound_vars(DebruijnIndex::INNERMOST, starting_idx)\n+                    .build();\n+                let trait_ref = subst.apply(trait_ref, Interner);\n+                search(trait_ref)\n+            } else {\n+                search(trait_ref)\n+            }\n+        }\n         TypeNs::GenericParam(param_id) => {\n             let predicates = db.generic_predicates_for_param(def, param_id.into(), assoc_name);\n             let res = predicates.iter().find_map(|pred| match pred.skip_binders().skip_binders() {\n@@ -1160,10 +1196,18 @@ fn named_associated_type_shorthand_candidates<R>(\n             }\n             // Handle `Self::Type` referring to own associated type in trait definitions\n             if let GenericDefId::TraitId(trait_id) = param_id.parent() {\n-                let generics = generics(db.upcast(), trait_id.into());\n-                if generics.params.type_or_consts[param_id.local_id()].is_trait_self() {\n+                let trait_generics = generics(db.upcast(), trait_id.into());\n+                if trait_generics.params.type_or_consts[param_id.local_id()].is_trait_self() {\n+                    let def_generics = generics(db.upcast(), def);\n+                    let starting_idx = match def {\n+                        GenericDefId::TraitId(_) => 0,\n+                        // `def` is an item within trait. We need to substitute `BoundVar`s but\n+                        // remember that they are for parent (i.e. trait) generic params so they\n+                        // come after our own params.\n+                        _ => def_generics.len_self(),\n+                    };\n                     let trait_ref = TyBuilder::trait_ref(db, trait_id)\n-                        .fill_with_bound_vars(DebruijnIndex::INNERMOST, 0)\n+                        .fill_with_bound_vars(DebruijnIndex::INNERMOST, starting_idx)\n                         .build();\n                     return search(trait_ref);\n                 }\n@@ -1405,6 +1449,7 @@ pub(crate) fn generic_defaults_query(\n     let ctx =\n         TyLoweringContext::new(db, &resolver).with_type_param_mode(ParamLoweringMode::Variable);\n     let generic_params = generics(db.upcast(), def);\n+    let parent_start_idx = generic_params.len_self();\n \n     let defaults = generic_params\n         .iter()\n@@ -1417,19 +1462,17 @@ pub(crate) fn generic_defaults_query(\n                     let val = unknown_const_as_generic(\n                         db.const_param_ty(ConstParamId::from_unchecked(id)),\n                     );\n-                    return crate::make_binders_with_count(db, idx, &generic_params, val);\n+                    return make_binders(db, &generic_params, val);\n                 }\n             };\n             let mut ty =\n                 p.default.as_ref().map_or(TyKind::Error.intern(Interner), |t| ctx.lower_ty(t));\n \n             // Each default can only refer to previous parameters.\n-            // type variable default referring to parameter coming\n-            // after it. This is forbidden (FIXME: report\n-            // diagnostic)\n-            ty = fallback_bound_vars(ty, idx);\n-            let val = GenericArgData::Ty(ty).intern(Interner);\n-            crate::make_binders_with_count(db, idx, &generic_params, val)\n+            // Type variable default referring to parameter coming\n+            // after it is forbidden (FIXME: report diagnostic)\n+            ty = fallback_bound_vars(ty, idx, parent_start_idx);\n+            crate::make_binders(db, &generic_params, ty.cast(Interner))\n         })\n         .collect();\n \n@@ -1446,15 +1489,14 @@ pub(crate) fn generic_defaults_recover(\n     // we still need one default per parameter\n     let defaults = generic_params\n         .iter_id()\n-        .enumerate()\n-        .map(|(count, id)| {\n+        .map(|id| {\n             let val = match id {\n                 itertools::Either::Left(_) => {\n                     GenericArgData::Ty(TyKind::Error.intern(Interner)).intern(Interner)\n                 }\n                 itertools::Either::Right(id) => unknown_const_as_generic(db.const_param_ty(id)),\n             };\n-            crate::make_binders_with_count(db, count, &generic_params, val)\n+            crate::make_binders(db, &generic_params, val)\n         })\n         .collect();\n \n@@ -1633,6 +1675,19 @@ pub enum ValueTyDefId {\n }\n impl_from!(FunctionId, StructId, UnionId, EnumVariantId, ConstId, StaticId for ValueTyDefId);\n \n+impl ValueTyDefId {\n+    pub(crate) fn to_generic_def_id(self) -> Option<GenericDefId> {\n+        match self {\n+            Self::FunctionId(id) => Some(id.into()),\n+            Self::StructId(id) => Some(id.into()),\n+            Self::UnionId(id) => Some(id.into()),\n+            Self::EnumVariantId(var) => Some(var.into()),\n+            Self::ConstId(id) => Some(id.into()),\n+            Self::StaticId(_) => None,\n+        }\n+    }\n+}\n+\n /// Build the declared type of an item. This depends on the namespace; e.g. for\n /// `struct Foo(usize)`, we have two types: The type of the struct itself, and\n /// the constructor function `(usize) -> Foo` which lives in the values\n@@ -1816,26 +1871,48 @@ pub(crate) fn const_or_path_to_chalk(\n     }\n }\n \n-/// This replaces any 'free' Bound vars in `s` (i.e. those with indices past\n-/// num_vars_to_keep) by `TyKind::Unknown`.\n+/// Replaces any 'free' `BoundVar`s in `s` by `TyKind::Error` from the perspective of generic\n+/// parameter whose index is `param_index`. A `BoundVar` is free when it is or (syntactically)\n+/// appears after the generic parameter of `param_index`.\n fn fallback_bound_vars<T: TypeFoldable<Interner> + HasInterner<Interner = Interner>>(\n     s: T,\n-    num_vars_to_keep: usize,\n+    param_index: usize,\n+    parent_start: usize,\n ) -> T {\n+    // Keep in mind that parent generic parameters, if any, come *after* those of the item in\n+    // question. In the diagrams below, `c*` and `p*` represent generic parameters of the item and\n+    // its parent respectively.\n+    let is_allowed = |index| {\n+        if param_index < parent_start {\n+            // The parameter of `param_index` is one from the item in question. Any parent generic\n+            // parameters or the item's generic parameters that come before `param_index` is\n+            // allowed.\n+            // [c1, .., cj, .., ck, p1, .., pl] where cj is `param_index`\n+            //  ^^^^^^              ^^^^^^^^^^ these are allowed\n+            !(param_index..parent_start).contains(&index)\n+        } else {\n+            // The parameter of `param_index` is one from the parent generics. Only parent generic\n+            // parameters that come before `param_index` are allowed.\n+            // [c1, .., ck, p1, .., pj, .., pl] where pj is `param_index`\n+            //              ^^^^^^ these are allowed\n+            (parent_start..param_index).contains(&index)\n+        }\n+    };\n+\n     crate::fold_free_vars(\n         s,\n         |bound, binders| {\n-            if bound.index >= num_vars_to_keep && bound.debruijn == DebruijnIndex::INNERMOST {\n-                TyKind::Error.intern(Interner)\n-            } else {\n+            if bound.index_if_innermost().map_or(true, is_allowed) {\n                 bound.shifted_in_from(binders).to_ty(Interner)\n+            } else {\n+                TyKind::Error.intern(Interner)\n             }\n         },\n         |ty, bound, binders| {\n-            if bound.index >= num_vars_to_keep && bound.debruijn == DebruijnIndex::INNERMOST {\n-                unknown_const(ty.clone())\n-            } else {\n+            if bound.index_if_innermost().map_or(true, is_allowed) {\n                 bound.shifted_in_from(binders).to_const(Interner, ty)\n+            } else {\n+                unknown_const(ty.clone())\n             }\n         },\n     )"}, {"sha": "f80fb39c1f84e24854bfecbe3fd06a06786f86b2", "filename": "crates/hir-ty/src/mapping.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fhir-ty%2Fsrc%2Fmapping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fhir-ty%2Fsrc%2Fmapping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmapping.rs?ref=e6540cff74534e6d9fb86d5d66e66423fad03766", "patch": "@@ -103,6 +103,18 @@ impl From<crate::db::InternedClosureId> for chalk_ir::ClosureId<Interner> {\n     }\n }\n \n+impl From<chalk_ir::GeneratorId<Interner>> for crate::db::InternedGeneratorId {\n+    fn from(id: chalk_ir::GeneratorId<Interner>) -> Self {\n+        Self::from_intern_id(id.0)\n+    }\n+}\n+\n+impl From<crate::db::InternedGeneratorId> for chalk_ir::GeneratorId<Interner> {\n+    fn from(id: crate::db::InternedGeneratorId) -> Self {\n+        chalk_ir::GeneratorId(id.as_intern_id())\n+    }\n+}\n+\n pub fn to_foreign_def_id(id: TypeAliasId) -> ForeignDefId {\n     chalk_ir::ForeignDefId(salsa::InternKey::as_intern_id(&id))\n }"}, {"sha": "3a1a3f4fdeb3b70d66d95c5415598723b6324c6c", "filename": "crates/hir-ty/src/method_resolution.rs", "status": "modified", "additions": 15, "deletions": 21, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs?ref=e6540cff74534e6d9fb86d5d66e66423fad03766", "patch": "@@ -1,7 +1,7 @@\n //! This module is concerned with finding methods that a given type provides.\n //! For details about how this works in rustc, see the method lookup page in the\n //! [rustc guide](https://rust-lang.github.io/rustc-guide/method-lookup.html)\n-//! and the corresponding code mostly in librustc_typeck/check/method/probe.rs.\n+//! and the corresponding code mostly in rustc_hir_analysis/check/method/probe.rs.\n use std::{iter, ops::ControlFlow, sync::Arc};\n \n use arrayvec::ArrayVec;\n@@ -654,7 +654,7 @@ fn find_matching_impl(\n         let r = table.run_in_snapshot(|table| {\n             let impl_data = db.impl_data(impl_);\n             let substs =\n-                TyBuilder::subst_for_def(db, impl_).fill_with_inference_vars(table).build();\n+                TyBuilder::subst_for_def(db, impl_, None).fill_with_inference_vars(table).build();\n             let impl_ty = db.impl_self_ty(impl_).substitute(Interner, &substs);\n \n             table\n@@ -1147,10 +1147,9 @@ fn is_valid_candidate(\n             }));\n             if let ItemContainerId::ImplId(impl_id) = c.lookup(db.upcast()).container {\n                 let self_ty_matches = table.run_in_snapshot(|table| {\n-                    let subst =\n-                        TyBuilder::subst_for_def(db, c).fill_with_inference_vars(table).build();\n-                    let expected_self_ty =\n-                        subst.apply(db.impl_self_ty(impl_id).skip_binders().clone(), Interner);\n+                    let expected_self_ty = TyBuilder::impl_self_ty(db, impl_id)\n+                        .fill_with_inference_vars(table)\n+                        .build();\n                     table.unify(&expected_self_ty, &self_ty)\n                 });\n                 if !self_ty_matches {\n@@ -1186,31 +1185,26 @@ fn is_valid_fn_candidate(\n \n     table.run_in_snapshot(|table| {\n         let container = fn_id.lookup(db.upcast()).container;\n-        let impl_subst = match container {\n+        let (impl_subst, expect_self_ty) = match container {\n             ItemContainerId::ImplId(it) => {\n-                TyBuilder::subst_for_def(db, it).fill_with_inference_vars(table).build()\n+                let subst =\n+                    TyBuilder::subst_for_def(db, it, None).fill_with_inference_vars(table).build();\n+                let self_ty = db.impl_self_ty(it).substitute(Interner, &subst);\n+                (subst, self_ty)\n             }\n             ItemContainerId::TraitId(it) => {\n-                TyBuilder::subst_for_def(db, it).fill_with_inference_vars(table).build()\n+                let subst =\n+                    TyBuilder::subst_for_def(db, it, None).fill_with_inference_vars(table).build();\n+                let self_ty = subst.at(Interner, 0).assert_ty_ref(Interner).clone();\n+                (subst, self_ty)\n             }\n             _ => unreachable!(),\n         };\n \n-        let fn_subst = TyBuilder::subst_for_def(db, fn_id)\n-            .use_parent_substs(&impl_subst)\n+        let fn_subst = TyBuilder::subst_for_def(db, fn_id, Some(impl_subst.clone()))\n             .fill_with_inference_vars(table)\n             .build();\n \n-        let expect_self_ty = match container {\n-            ItemContainerId::TraitId(_) => fn_subst.at(Interner, 0).assert_ty_ref(Interner).clone(),\n-            ItemContainerId::ImplId(impl_id) => {\n-                fn_subst.apply(db.impl_self_ty(impl_id).skip_binders().clone(), Interner)\n-            }\n-            // We should only get called for associated items (impl/trait)\n-            ItemContainerId::ModuleId(_) | ItemContainerId::ExternBlockId(_) => {\n-                unreachable!()\n-            }\n-        };\n         check_that!(table.unify(&expect_self_ty, self_ty));\n \n         if let Some(receiver_ty) = receiver_ty {"}, {"sha": "ebbc5410147c6b8d63e8b4df5623fba06db5b4d5", "filename": "crates/hir-ty/src/tests.rs", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fhir-ty%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fhir-ty%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftests.rs?ref=e6540cff74534e6d9fb86d5d66e66423fad03766", "patch": "@@ -16,7 +16,7 @@ use base_db::{fixture::WithFixture, FileRange, SourceDatabaseExt};\n use expect_test::Expect;\n use hir_def::{\n     body::{Body, BodySourceMap, SyntheticSyntax},\n-    db::DefDatabase,\n+    db::{DefDatabase, InternDatabase},\n     expr::{ExprId, PatId},\n     item_scope::ItemScope,\n     nameres::DefMap,\n@@ -135,6 +135,10 @@ fn check_impl(ra_fixture: &str, allow_none: bool, only_types: bool, display_sour\n             let loc = it.lookup(&db);\n             loc.source(&db).value.syntax().text_range().start()\n         }\n+        DefWithBodyId::VariantId(it) => {\n+            let loc = db.lookup_intern_enum(it.parent);\n+            loc.source(&db).value.syntax().text_range().start()\n+        }\n     });\n     let mut unexpected_type_mismatches = String::new();\n     for def in defs {\n@@ -388,6 +392,10 @@ fn infer_with_mismatches(content: &str, include_mismatches: bool) -> String {\n             let loc = it.lookup(&db);\n             loc.source(&db).value.syntax().text_range().start()\n         }\n+        DefWithBodyId::VariantId(it) => {\n+            let loc = db.lookup_intern_enum(it.parent);\n+            loc.source(&db).value.syntax().text_range().start()\n+        }\n     });\n     for def in defs {\n         let (_body, source_map) = db.body_with_source_map(def);\n@@ -453,6 +461,18 @@ fn visit_module(\n                     let body = db.body(def);\n                     visit_body(db, &body, cb);\n                 }\n+                ModuleDefId::AdtId(hir_def::AdtId::EnumId(it)) => {\n+                    db.enum_data(it)\n+                        .variants\n+                        .iter()\n+                        .map(|(id, _)| hir_def::EnumVariantId { parent: it, local_id: id })\n+                        .for_each(|it| {\n+                            let def = it.into();\n+                            cb(def);\n+                            let body = db.body(def);\n+                            visit_body(db, &body, cb);\n+                        });\n+                }\n                 ModuleDefId::TraitId(it) => {\n                     let trait_data = db.trait_data(it);\n                     for &(_, item) in trait_data.items.iter() {"}, {"sha": "d301595bcd98a5ac3f29fda2bc5626cf8e546a8c", "filename": "crates/hir-ty/src/tests/coercion.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fhir-ty%2Fsrc%2Ftests%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fhir-ty%2Fsrc%2Ftests%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftests%2Fcoercion.rs?ref=e6540cff74534e6d9fb86d5d66e66423fad03766", "patch": "@@ -294,6 +294,24 @@ fn foo() {\n     );\n }\n \n+#[test]\n+fn generator_yield_return_coerce() {\n+    check_no_mismatches(\n+        r#\"\n+fn test() {\n+    let g = || {\n+        yield &1u32;\n+        yield &&1u32;\n+        if true {\n+            return &1u32;\n+        }\n+        &&1u32\n+    };\n+}\n+        \"#,\n+    );\n+}\n+\n #[test]\n fn assign_coerce() {\n     check_no_mismatches("}, {"sha": "a155adcec6c33b43335dbcaff4ae864cfb88f8a6", "filename": "crates/hir-ty/src/tests/regression.rs", "status": "modified", "additions": 35, "deletions": 19, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fhir-ty%2Fsrc%2Ftests%2Fregression.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fhir-ty%2Fsrc%2Ftests%2Fregression.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftests%2Fregression.rs?ref=e6540cff74534e6d9fb86d5d66e66423fad03766", "patch": "@@ -1488,7 +1488,6 @@ fn regression_11688_4() {\n \n #[test]\n fn gat_crash_1() {\n-    cov_mark::check!(ignore_gats);\n     check_no_mismatches(\n         r#\"\n trait ATrait {}\n@@ -1527,30 +1526,22 @@ unsafe impl Storage for InlineStorage {\n \n #[test]\n fn gat_crash_3() {\n-    // FIXME: This test currently crashes rust analyzer in a debug build but not in a\n-    // release build (i.e. for the user). With the assumption that tests will always be run\n-    // in debug mode, we catch the unwind and expect that it panicked. See the\n-    // [`crate::utils::generics`] function for more information.\n-    cov_mark::check!(ignore_gats);\n-    std::panic::catch_unwind(|| {\n-        check_no_mismatches(\n-            r#\"\n+    check_no_mismatches(\n+        r#\"\n trait Collection {\n-    type Item;\n-    type Member<T>: Collection<Item = T>;\n-    fn add(&mut self, value: Self::Item) -> Result<(), Self::Error>;\n+type Item;\n+type Member<T>: Collection<Item = T>;\n+fn add(&mut self, value: Self::Item) -> Result<(), Self::Error>;\n }\n struct ConstGen<T, const N: usize> {\n-    data: [T; N],\n+data: [T; N],\n }\n impl<T, const N: usize> Collection for ConstGen<T, N> {\n-    type Item = T;\n-    type Member<U> = ConstGen<U, N>;\n+type Item = T;\n+type Member<U> = ConstGen<U, N>;\n }\n-        \"#,\n-        );\n-    })\n-    .expect_err(\"must panic\");\n+    \"#,\n+    );\n }\n \n #[test]\n@@ -1691,3 +1682,28 @@ fn macrostmts() -> u8 {\n     \"#,\n     );\n }\n+\n+#[test]\n+fn dyn_with_unresolved_trait() {\n+    check_types(\n+        r#\"\n+fn foo(a: &dyn DoesNotExist) {\n+    a.bar();\n+  //^&{unknown}\n+}\n+        \"#,\n+    );\n+}\n+\n+#[test]\n+fn self_assoc_with_const_generics_crash() {\n+    check_no_mismatches(\n+        r#\"\n+trait Trait { type Item; }\n+impl<T, const N: usize> Trait for [T; N] {\n+    type Item = ();\n+    fn f<U>(_: Self::Item) {}\n+}\n+        \"#,\n+    );\n+}"}, {"sha": "080e2ac1b8e1e4a1a6ced3cb7227614a998bfa88", "filename": "crates/hir-ty/src/tests/simple.rs", "status": "modified", "additions": 138, "deletions": 21, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fhir-ty%2Fsrc%2Ftests%2Fsimple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fhir-ty%2Fsrc%2Ftests%2Fsimple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftests%2Fsimple.rs?ref=e6540cff74534e6d9fb86d5d66e66423fad03766", "patch": "@@ -1693,16 +1693,16 @@ fn infer_type_param() {\n fn infer_const() {\n     check_infer(\n         r#\"\n-        struct Foo;\n-        impl Foo { const ASSOC_CONST: u32 = 0; }\n-        const GLOBAL_CONST: u32 = 101;\n-        fn test() {\n-            const LOCAL_CONST: u32 = 99;\n-            let x = LOCAL_CONST;\n-            let z = GLOBAL_CONST;\n-            let id = Foo::ASSOC_CONST;\n-        }\n-        \"#,\n+struct Foo;\n+impl Foo { const ASSOC_CONST: u32 = 0; }\n+const GLOBAL_CONST: u32 = 101;\n+fn test() {\n+    const LOCAL_CONST: u32 = 99;\n+    let x = LOCAL_CONST;\n+    let z = GLOBAL_CONST;\n+    let id = Foo::ASSOC_CONST;\n+}\n+\"#,\n         expect![[r#\"\n             48..49 '0': u32\n             79..82 '101': u32\n@@ -1722,17 +1722,17 @@ fn infer_const() {\n fn infer_static() {\n     check_infer(\n         r#\"\n-        static GLOBAL_STATIC: u32 = 101;\n-        static mut GLOBAL_STATIC_MUT: u32 = 101;\n-        fn test() {\n-            static LOCAL_STATIC: u32 = 99;\n-            static mut LOCAL_STATIC_MUT: u32 = 99;\n-            let x = LOCAL_STATIC;\n-            let y = LOCAL_STATIC_MUT;\n-            let z = GLOBAL_STATIC;\n-            let w = GLOBAL_STATIC_MUT;\n-        }\n-        \"#,\n+static GLOBAL_STATIC: u32 = 101;\n+static mut GLOBAL_STATIC_MUT: u32 = 101;\n+fn test() {\n+    static LOCAL_STATIC: u32 = 99;\n+    static mut LOCAL_STATIC_MUT: u32 = 99;\n+    let x = LOCAL_STATIC;\n+    let y = LOCAL_STATIC_MUT;\n+    let z = GLOBAL_STATIC;\n+    let w = GLOBAL_STATIC_MUT;\n+}\n+\"#,\n         expect![[r#\"\n             28..31 '101': u32\n             69..72 '101': u32\n@@ -1751,6 +1751,41 @@ fn infer_static() {\n     );\n }\n \n+#[test]\n+fn infer_enum_variant() {\n+    check_infer(\n+        r#\"\n+enum Foo {\n+    A = 15,\n+    B = Foo::A as isize + 1\n+}\n+\"#,\n+        expect![[r#\"\n+            19..21 '15': isize\n+            31..37 'Foo::A': Foo\n+            31..46 'Foo::A as isize': isize\n+            31..50 'Foo::A...ze + 1': isize\n+            49..50 '1': isize\n+        \"#]],\n+    );\n+    check_infer(\n+        r#\"\n+#[repr(u32)]\n+enum Foo {\n+    A = 15,\n+    B = Foo::A as u32 + 1\n+}\n+\"#,\n+        expect![[r#\"\n+            32..34 '15': u32\n+            44..50 'Foo::A': Foo\n+            44..57 'Foo::A as u32': u32\n+            44..61 'Foo::A...32 + 1': u32\n+            60..61 '1': u32\n+        \"#]],\n+    );\n+}\n+\n #[test]\n fn shadowing_primitive() {\n     check_types(\n@@ -1917,6 +1952,88 @@ fn closure_return_inferred() {\n     );\n }\n \n+#[test]\n+fn generator_types_inferred() {\n+    check_infer(\n+        r#\"\n+//- minicore: generator, deref\n+use core::ops::{Generator, GeneratorState};\n+use core::pin::Pin;\n+\n+fn f(v: i64) {}\n+fn test() {\n+    let mut g = |r| {\n+        let a = yield 0;\n+        let a = yield 1;\n+        let a = yield 2;\n+        \"return value\"\n+    };\n+\n+    match Pin::new(&mut g).resume(0usize) {\n+        GeneratorState::Yielded(y) => { f(y); }\n+        GeneratorState::Complete(r) => {}\n+    }\n+}\n+        \"#,\n+        expect![[r#\"\n+            70..71 'v': i64\n+            78..80 '{}': ()\n+            91..362 '{     ...   } }': ()\n+            101..106 'mut g': |usize| yields i64 -> &str\n+            109..218 '|r| { ...     }': |usize| yields i64 -> &str\n+            110..111 'r': usize\n+            113..218 '{     ...     }': &str\n+            127..128 'a': usize\n+            131..138 'yield 0': usize\n+            137..138 '0': i64\n+            152..153 'a': usize\n+            156..163 'yield 1': usize\n+            162..163 '1': i64\n+            177..178 'a': usize\n+            181..188 'yield 2': usize\n+            187..188 '2': i64\n+            198..212 '\"return value\"': &str\n+            225..360 'match ...     }': ()\n+            231..239 'Pin::new': fn new<&mut |usize| yields i64 -> &str>(&mut |usize| yields i64 -> &str) -> Pin<&mut |usize| yields i64 -> &str>\n+            231..247 'Pin::n...mut g)': Pin<&mut |usize| yields i64 -> &str>\n+            231..262 'Pin::n...usize)': GeneratorState<i64, &str>\n+            240..246 '&mut g': &mut |usize| yields i64 -> &str\n+            245..246 'g': |usize| yields i64 -> &str\n+            255..261 '0usize': usize\n+            273..299 'Genera...ded(y)': GeneratorState<i64, &str>\n+            297..298 'y': i64\n+            303..312 '{ f(y); }': ()\n+            305..306 'f': fn f(i64)\n+            305..309 'f(y)': ()\n+            307..308 'y': i64\n+            321..348 'Genera...ete(r)': GeneratorState<i64, &str>\n+            346..347 'r': &str\n+            352..354 '{}': ()\n+        \"#]],\n+    );\n+}\n+\n+#[test]\n+fn generator_resume_yield_return_unit() {\n+    check_no_mismatches(\n+        r#\"\n+//- minicore: generator, deref\n+use core::ops::{Generator, GeneratorState};\n+use core::pin::Pin;\n+fn test() {\n+    let mut g = || {\n+        let () = yield;\n+    };\n+\n+    match Pin::new(&mut g).resume(()) {\n+        GeneratorState::Yielded(()) => {}\n+        GeneratorState::Complete(()) => {}\n+    }\n+}\n+        \"#,\n+    );\n+}\n+\n #[test]\n fn fn_pointer_return() {\n     check_infer("}, {"sha": "555b6972fb71eecb775979f640b33baa2e3a712e", "filename": "crates/hir-ty/src/tests/traits.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fhir-ty%2Fsrc%2Ftests%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fhir-ty%2Fsrc%2Ftests%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftests%2Ftraits.rs?ref=e6540cff74534e6d9fb86d5d66e66423fad03766", "patch": "@@ -279,6 +279,10 @@ fn test() {\n pub mod iter {\n     pub trait IntoIterator {\n         type Item;\n+        type IntoIter: Iterator<Item = Self::Item>;\n+    }\n+    pub trait Iterator {\n+        type Item;\n     }\n }\n pub mod prelude {\n@@ -297,7 +301,13 @@ pub mod collections {\n     }\n \n     impl<T> IntoIterator for Vec<T> {\n-        type Item=T;\n+        type Item = T;\n+        type IntoIter = IntoIter<T>;\n+    }\n+\n+    struct IntoIter<T> {}\n+    impl<T> Iterator for IntoIter<T> {\n+        type Item = T;\n     }\n }\n \"#,"}, {"sha": "e54bcb421a222222b8a21be500079c034ce737f2", "filename": "crates/hir-ty/src/utils.rs", "status": "modified", "additions": 38, "deletions": 63, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fhir-ty%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fhir-ty%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Futils.rs?ref=e6540cff74534e6d9fb86d5d66e66423fad03766", "patch": "@@ -4,7 +4,7 @@\n use std::iter;\n \n use base_db::CrateId;\n-use chalk_ir::{fold::Shift, BoundVar, DebruijnIndex};\n+use chalk_ir::{cast::Cast, fold::Shift, BoundVar, DebruijnIndex};\n use hir_def::{\n     db::DefDatabase,\n     generics::{\n@@ -24,8 +24,7 @@ use smallvec::{smallvec, SmallVec};\n use syntax::SmolStr;\n \n use crate::{\n-    db::HirDatabase, ChalkTraitId, ConstData, ConstValue, GenericArgData, Interner, Substitution,\n-    TraitRef, TraitRefExt, TyKind, WhereClause,\n+    db::HirDatabase, ChalkTraitId, Interner, Substitution, TraitRef, TraitRefExt, WhereClause,\n };\n \n pub(crate) fn fn_traits(db: &dyn DefDatabase, krate: CrateId) -> impl Iterator<Item = TraitId> {\n@@ -174,31 +173,6 @@ pub(super) fn associated_type_by_name_including_super_traits(\n \n pub(crate) fn generics(db: &dyn DefDatabase, def: GenericDefId) -> Generics {\n     let parent_generics = parent_generic_def(db, def).map(|def| Box::new(generics(db, def)));\n-    if parent_generics.is_some() && matches!(def, GenericDefId::TypeAliasId(_)) {\n-        let params = db.generic_params(def);\n-        let parent_params = &parent_generics.as_ref().unwrap().params;\n-        let has_consts =\n-            params.iter().any(|(_, x)| matches!(x, TypeOrConstParamData::ConstParamData(_)));\n-        let parent_has_consts =\n-            parent_params.iter().any(|(_, x)| matches!(x, TypeOrConstParamData::ConstParamData(_)));\n-        return if has_consts || parent_has_consts {\n-            // XXX: treat const generic associated types as not existing to avoid crashes\n-            // (#11769)\n-            //\n-            // Note: Also crashes when the parent has const generics (also even if the GAT\n-            // doesn't use them), see `tests::regression::gat_crash_3` for an example.\n-            // Avoids that by disabling GATs when the parent (i.e. `impl` block) has\n-            // const generics (#12193).\n-            //\n-            // Chalk expects the inner associated type's parameters to come\n-            // *before*, not after the trait's generics as we've always done it.\n-            // Adapting to this requires a larger refactoring\n-            cov_mark::hit!(ignore_gats);\n-            Generics { def, params: Interned::new(Default::default()), parent_generics }\n-        } else {\n-            Generics { def, params, parent_generics }\n-        };\n-    }\n     Generics { def, params: db.generic_params(def), parent_generics }\n }\n \n@@ -221,36 +195,49 @@ impl Generics {\n         })\n     }\n \n-    /// Iterator over types and const params of parent, then self.\n+    /// Iterator over types and const params of self, then parent.\n     pub(crate) fn iter<'a>(\n         &'a self,\n     ) -> impl DoubleEndedIterator<Item = (TypeOrConstParamId, &'a TypeOrConstParamData)> + 'a {\n         let to_toc_id = |it: &'a Generics| {\n             move |(local_id, p)| (TypeOrConstParamId { parent: it.def, local_id }, p)\n         };\n-        self.parent_generics()\n-            .into_iter()\n-            .flat_map(move |it| it.params.iter().map(to_toc_id(it)))\n-            .chain(self.params.iter().map(to_toc_id(self)))\n+        self.params.iter().map(to_toc_id(self)).chain(self.iter_parent())\n+    }\n+\n+    /// Iterate over types and const params without parent params.\n+    pub(crate) fn iter_self<'a>(\n+        &'a self,\n+    ) -> impl DoubleEndedIterator<Item = (TypeOrConstParamId, &'a TypeOrConstParamData)> + 'a {\n+        let to_toc_id = |it: &'a Generics| {\n+            move |(local_id, p)| (TypeOrConstParamId { parent: it.def, local_id }, p)\n+        };\n+        self.params.iter().map(to_toc_id(self))\n     }\n \n     /// Iterator over types and const params of parent.\n     pub(crate) fn iter_parent<'a>(\n         &'a self,\n-    ) -> impl Iterator<Item = (TypeOrConstParamId, &'a TypeOrConstParamData)> + 'a {\n+    ) -> impl DoubleEndedIterator<Item = (TypeOrConstParamId, &'a TypeOrConstParamData)> + 'a {\n         self.parent_generics().into_iter().flat_map(|it| {\n             let to_toc_id =\n                 move |(local_id, p)| (TypeOrConstParamId { parent: it.def, local_id }, p);\n             it.params.iter().map(to_toc_id)\n         })\n     }\n \n+    /// Returns total number of generic parameters in scope, including those from parent.\n     pub(crate) fn len(&self) -> usize {\n         let parent = self.parent_generics().map_or(0, Generics::len);\n         let child = self.params.type_or_consts.len();\n         parent + child\n     }\n \n+    /// Returns numbers of generic parameters excluding those from parent.\n+    pub(crate) fn len_self(&self) -> usize {\n+        self.params.type_or_consts.len()\n+    }\n+\n     /// (parent total, self param, type param list, const param list, impl trait)\n     pub(crate) fn provenance_split(&self) -> (usize, usize, usize, usize, usize) {\n         let ty_iter = || self.params.iter().filter_map(|x| x.1.type_param());\n@@ -275,15 +262,17 @@ impl Generics {\n         if param.parent == self.def {\n             let (idx, (_local_id, data)) =\n                 self.params.iter().enumerate().find(|(_, (idx, _))| *idx == param.local_id)?;\n-            let parent_len = self.parent_generics().map_or(0, Generics::len);\n-            Some((parent_len + idx, data))\n+            Some((idx, data))\n         } else {\n-            self.parent_generics().and_then(|g| g.find_param(param))\n+            self.parent_generics()\n+                .and_then(|g| g.find_param(param))\n+                // Remember that parent parameters come after parameters for self.\n+                .map(|(idx, data)| (self.len_self() + idx, data))\n         }\n     }\n \n-    fn parent_generics(&self) -> Option<&Generics> {\n-        self.parent_generics.as_ref().map(|it| &**it)\n+    pub(crate) fn parent_generics(&self) -> Option<&Generics> {\n+        self.parent_generics.as_deref()\n     }\n \n     /// Returns a Substitution that replaces each parameter by a bound variable.\n@@ -295,18 +284,10 @@ impl Generics {\n         Substitution::from_iter(\n             Interner,\n             self.iter_id().enumerate().map(|(idx, id)| match id {\n-                Either::Left(_) => GenericArgData::Ty(\n-                    TyKind::BoundVar(BoundVar::new(debruijn, idx)).intern(Interner),\n-                )\n-                .intern(Interner),\n-                Either::Right(id) => GenericArgData::Const(\n-                    ConstData {\n-                        value: ConstValue::BoundVar(BoundVar::new(debruijn, idx)),\n-                        ty: db.const_param_ty(id),\n-                    }\n-                    .intern(Interner),\n-                )\n-                .intern(Interner),\n+                Either::Left(_) => BoundVar::new(debruijn, idx).to_ty(Interner).cast(Interner),\n+                Either::Right(id) => BoundVar::new(debruijn, idx)\n+                    .to_const(Interner, db.const_param_ty(id))\n+                    .cast(Interner),\n             }),\n         )\n     }\n@@ -316,18 +297,12 @@ impl Generics {\n         Substitution::from_iter(\n             Interner,\n             self.iter_id().map(|id| match id {\n-                Either::Left(id) => GenericArgData::Ty(\n-                    TyKind::Placeholder(crate::to_placeholder_idx(db, id.into())).intern(Interner),\n-                )\n-                .intern(Interner),\n-                Either::Right(id) => GenericArgData::Const(\n-                    ConstData {\n-                        value: ConstValue::Placeholder(crate::to_placeholder_idx(db, id.into())),\n-                        ty: db.const_param_ty(id),\n-                    }\n-                    .intern(Interner),\n-                )\n-                .intern(Interner),\n+                Either::Left(id) => {\n+                    crate::to_placeholder_idx(db, id.into()).to_ty(Interner).cast(Interner)\n+                }\n+                Either::Right(id) => crate::to_placeholder_idx(db, id.into())\n+                    .to_const(Interner, db.const_param_ty(id))\n+                    .cast(Interner),\n             }),\n         )\n     }"}, {"sha": "c5dc60f1ec5f962e319af3c48191fe2769984243", "filename": "crates/hir/src/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fhir%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fhir%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fdiagnostics.rs?ref=e6540cff74534e6d9fb86d5d66e66423fad03766", "patch": "@@ -1,7 +1,7 @@\n //! Re-export diagnostics such that clients of `hir` don't have to depend on\n //! low-level crates.\n //!\n-//! This probably isn't the best way to do this -- ideally, diagnistics should\n+//! This probably isn't the best way to do this -- ideally, diagnostics should\n //! be expressed in terms of hir types themselves.\n use base_db::CrateId;\n use cfg::{CfgExpr, CfgOptions};"}, {"sha": "27b2f445d73cabfb415cf8d7b5625569e6355767", "filename": "crates/hir/src/display.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fhir%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fhir%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fdisplay.rs?ref=e6540cff74534e6d9fb86d5d66e66423fad03766", "patch": "@@ -492,6 +492,9 @@ impl HirDisplay for TypeAlias {\n         write_visibility(self.module(f.db).id, self.visibility(f.db), f)?;\n         let data = f.db.type_alias_data(self.id);\n         write!(f, \"type {}\", data.name)?;\n+        let def_id = GenericDefId::TypeAliasId(self.id);\n+        write_generic_params(def_id, f)?;\n+        write_where_clause(def_id, f)?;\n         if !data.bounds.is_empty() {\n             f.write_str(\": \")?;\n             f.write_joined(&data.bounds, \" + \")?;"}, {"sha": "f825a72c0f58a63998d2cc32aca59b4727b02dba", "filename": "crates/hir/src/from_id.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fhir%2Fsrc%2Ffrom_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fhir%2Fsrc%2Ffrom_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Ffrom_id.rs?ref=e6540cff74534e6d9fb86d5d66e66423fad03766", "patch": "@@ -140,6 +140,7 @@ impl From<DefWithBody> for DefWithBodyId {\n             DefWithBody::Function(it) => DefWithBodyId::FunctionId(it.id),\n             DefWithBody::Static(it) => DefWithBodyId::StaticId(it.id),\n             DefWithBody::Const(it) => DefWithBodyId::ConstId(it.id),\n+            DefWithBody::Variant(it) => DefWithBodyId::VariantId(it.into()),\n         }\n     }\n }\n@@ -150,6 +151,7 @@ impl From<DefWithBodyId> for DefWithBody {\n             DefWithBodyId::FunctionId(it) => DefWithBody::Function(it.into()),\n             DefWithBodyId::StaticId(it) => DefWithBody::Static(it.into()),\n             DefWithBodyId::ConstId(it) => DefWithBody::Const(it.into()),\n+            DefWithBodyId::VariantId(it) => DefWithBody::Variant(it.into()),\n         }\n     }\n }\n@@ -172,9 +174,7 @@ impl From<GenericDef> for GenericDefId {\n             GenericDef::Trait(it) => GenericDefId::TraitId(it.id),\n             GenericDef::TypeAlias(it) => GenericDefId::TypeAliasId(it.id),\n             GenericDef::Impl(it) => GenericDefId::ImplId(it.id),\n-            GenericDef::Variant(it) => {\n-                GenericDefId::EnumVariantId(EnumVariantId { parent: it.parent.id, local_id: it.id })\n-            }\n+            GenericDef::Variant(it) => GenericDefId::EnumVariantId(it.into()),\n             GenericDef::Const(it) => GenericDefId::ConstId(it.id),\n         }\n     }\n@@ -188,9 +188,7 @@ impl From<GenericDefId> for GenericDef {\n             GenericDefId::TraitId(it) => GenericDef::Trait(it.into()),\n             GenericDefId::TypeAliasId(it) => GenericDef::TypeAlias(it.into()),\n             GenericDefId::ImplId(it) => GenericDef::Impl(it.into()),\n-            GenericDefId::EnumVariantId(it) => {\n-                GenericDef::Variant(Variant { parent: it.parent.into(), id: it.local_id })\n-            }\n+            GenericDefId::EnumVariantId(it) => GenericDef::Variant(it.into()),\n             GenericDefId::ConstId(it) => GenericDef::Const(it.into()),\n         }\n     }"}, {"sha": "f5324208c9a4ef12cf6704f1a9066b11c7378b27", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 95, "deletions": 13, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=e6540cff74534e6d9fb86d5d66e66423fad03766", "patch": "@@ -39,7 +39,7 @@ use arrayvec::ArrayVec;\n use base_db::{CrateDisplayName, CrateId, CrateOrigin, Edition, FileId, ProcMacroKind};\n use either::Either;\n use hir_def::{\n-    adt::{ReprKind, VariantData},\n+    adt::{ReprData, VariantData},\n     body::{BodyDiagnostic, SyntheticSyntax},\n     expr::{BindingAnnotation, LabelId, Pat, PatId},\n     generics::{TypeOrConstParamData, TypeParamProvenance},\n@@ -50,7 +50,7 @@ use hir_def::{\n     resolver::{HasResolver, Resolver},\n     src::HasSource as _,\n     AdtId, AssocItemId, AssocItemLoc, AttrDefId, ConstId, ConstParamId, DefWithBodyId, EnumId,\n-    FunctionId, GenericDefId, HasModule, ImplId, ItemContainerId, LifetimeParamId,\n+    EnumVariantId, FunctionId, GenericDefId, HasModule, ImplId, ItemContainerId, LifetimeParamId,\n     LocalEnumVariantId, LocalFieldId, Lookup, MacroExpander, MacroId, ModuleId, StaticId, StructId,\n     TraitId, TypeAliasId, TypeOrConstParamId, TypeParamId, UnionId,\n };\n@@ -61,7 +61,6 @@ use hir_ty::{\n     diagnostics::BodyValidationDiagnostic,\n     method_resolution::{self, TyFingerprint},\n     primitive::UintTy,\n-    subst_prefix,\n     traits::FnTrait,\n     AliasTy, CallableDefId, CallableSig, Canonical, CanonicalVarKinds, Cast, ClosureId,\n     GenericArgData, Interner, ParamKind, QuantifiedWhereClause, Scalar, Substitution,\n@@ -73,7 +72,7 @@ use once_cell::unsync::Lazy;\n use rustc_hash::FxHashSet;\n use stdx::{impl_from, never};\n use syntax::{\n-    ast::{self, HasAttrs as _, HasDocComments, HasName},\n+    ast::{self, Expr, HasAttrs as _, HasDocComments, HasName},\n     AstNode, AstPtr, SmolStr, SyntaxNodePtr, TextRange, T,\n };\n \n@@ -348,7 +347,10 @@ impl ModuleDef {\n             ModuleDef::Module(it) => it.id.into(),\n             ModuleDef::Const(it) => it.id.into(),\n             ModuleDef::Static(it) => it.id.into(),\n-            _ => return Vec::new(),\n+            ModuleDef::Variant(it) => {\n+                EnumVariantId { parent: it.parent.into(), local_id: it.id }.into()\n+            }\n+            ModuleDef::BuiltinType(_) | ModuleDef::Macro(_) => return Vec::new(),\n         };\n \n         let module = match self.module(db) {\n@@ -377,10 +379,10 @@ impl ModuleDef {\n             ModuleDef::Function(it) => Some(it.into()),\n             ModuleDef::Const(it) => Some(it.into()),\n             ModuleDef::Static(it) => Some(it.into()),\n+            ModuleDef::Variant(it) => Some(it.into()),\n \n             ModuleDef::Module(_)\n             | ModuleDef::Adt(_)\n-            | ModuleDef::Variant(_)\n             | ModuleDef::Trait(_)\n             | ModuleDef::TypeAlias(_)\n             | ModuleDef::Macro(_)\n@@ -537,6 +539,30 @@ impl Module {\n                     }\n                     acc.extend(decl.diagnostics(db))\n                 }\n+                ModuleDef::Adt(adt) => {\n+                    match adt {\n+                        Adt::Struct(s) => {\n+                            for diag in db.struct_data_with_diagnostics(s.id).1.iter() {\n+                                emit_def_diagnostic(db, acc, diag);\n+                            }\n+                        }\n+                        Adt::Union(u) => {\n+                            for diag in db.union_data_with_diagnostics(u.id).1.iter() {\n+                                emit_def_diagnostic(db, acc, diag);\n+                            }\n+                        }\n+                        Adt::Enum(e) => {\n+                            for v in e.variants(db) {\n+                                acc.extend(ModuleDef::Variant(v).diagnostics(db));\n+                            }\n+\n+                            for diag in db.enum_data_with_diagnostics(e.id).1.iter() {\n+                                emit_def_diagnostic(db, acc, diag);\n+                            }\n+                        }\n+                    }\n+                    acc.extend(decl.diagnostics(db))\n+                }\n                 _ => acc.extend(decl.diagnostics(db)),\n             }\n         }\n@@ -874,7 +900,7 @@ impl Struct {\n         Type::from_def(db, self.id)\n     }\n \n-    pub fn repr(self, db: &dyn HirDatabase) -> Option<ReprKind> {\n+    pub fn repr(self, db: &dyn HirDatabase) -> Option<ReprData> {\n         db.struct_data(self.id).repr.clone()\n     }\n \n@@ -952,6 +978,21 @@ impl Enum {\n     pub fn ty(self, db: &dyn HirDatabase) -> Type {\n         Type::from_def(db, self.id)\n     }\n+\n+    /// The type of the enum variant bodies.\n+    pub fn variant_body_ty(self, db: &dyn HirDatabase) -> Type {\n+        Type::new_for_crate(\n+            self.id.lookup(db.upcast()).container.krate(),\n+            TyBuilder::builtin(match db.enum_data(self.id).variant_body_type() {\n+                Either::Left(builtin) => hir_def::builtin_type::BuiltinType::Int(builtin),\n+                Either::Right(builtin) => hir_def::builtin_type::BuiltinType::Uint(builtin),\n+            }),\n+        )\n+    }\n+\n+    pub fn is_data_carrying(self, db: &dyn HirDatabase) -> bool {\n+        self.variants(db).iter().any(|v| !matches!(v.kind(db), StructKind::Unit))\n+    }\n }\n \n impl HasVisibility for Enum {\n@@ -960,6 +1001,12 @@ impl HasVisibility for Enum {\n     }\n }\n \n+impl From<&Variant> for DefWithBodyId {\n+    fn from(&v: &Variant) -> Self {\n+        DefWithBodyId::VariantId(v.into())\n+    }\n+}\n+\n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct Variant {\n     pub(crate) parent: Enum,\n@@ -994,6 +1041,14 @@ impl Variant {\n     pub(crate) fn variant_data(self, db: &dyn HirDatabase) -> Arc<VariantData> {\n         db.enum_data(self.parent.id).variants[self.id].variant_data.clone()\n     }\n+\n+    pub fn value(self, db: &dyn HirDatabase) -> Option<Expr> {\n+        self.source(db)?.value.expr()\n+    }\n+\n+    pub fn eval(self, db: &dyn HirDatabase) -> Result<ComputedExpr, ConstEvalError> {\n+        db.const_eval_variant(self.into())\n+    }\n }\n \n /// Variants inherit visibility from the parent enum.\n@@ -1034,7 +1089,7 @@ impl Adt {\n     pub fn ty_with_args(self, db: &dyn HirDatabase, args: &[Type]) -> Type {\n         let id = AdtId::from(self);\n         let mut it = args.iter().map(|t| t.ty.clone());\n-        let ty = TyBuilder::def_ty(db, id.into())\n+        let ty = TyBuilder::def_ty(db, id.into(), None)\n             .fill(|x| {\n                 let r = it.next().unwrap_or_else(|| TyKind::Error.intern(Interner));\n                 match x {\n@@ -1129,15 +1184,17 @@ pub enum DefWithBody {\n     Function(Function),\n     Static(Static),\n     Const(Const),\n+    Variant(Variant),\n }\n-impl_from!(Function, Const, Static for DefWithBody);\n+impl_from!(Function, Const, Static, Variant for DefWithBody);\n \n impl DefWithBody {\n     pub fn module(self, db: &dyn HirDatabase) -> Module {\n         match self {\n             DefWithBody::Const(c) => c.module(db),\n             DefWithBody::Function(f) => f.module(db),\n             DefWithBody::Static(s) => s.module(db),\n+            DefWithBody::Variant(v) => v.module(db),\n         }\n     }\n \n@@ -1146,6 +1203,7 @@ impl DefWithBody {\n             DefWithBody::Function(f) => Some(f.name(db)),\n             DefWithBody::Static(s) => Some(s.name(db)),\n             DefWithBody::Const(c) => c.name(db),\n+            DefWithBody::Variant(v) => Some(v.name(db)),\n         }\n     }\n \n@@ -1155,6 +1213,7 @@ impl DefWithBody {\n             DefWithBody::Function(it) => it.ret_type(db),\n             DefWithBody::Static(it) => it.ty(db),\n             DefWithBody::Const(it) => it.ty(db),\n+            DefWithBody::Variant(it) => it.parent.variant_body_ty(db),\n         }\n     }\n \n@@ -1163,6 +1222,7 @@ impl DefWithBody {\n             DefWithBody::Function(it) => it.id.into(),\n             DefWithBody::Static(it) => it.id.into(),\n             DefWithBody::Const(it) => it.id.into(),\n+            DefWithBody::Variant(it) => it.into(),\n         }\n     }\n \n@@ -1379,6 +1439,7 @@ impl DefWithBody {\n             DefWithBody::Function(it) => it.into(),\n             DefWithBody::Static(it) => it.into(),\n             DefWithBody::Const(it) => it.into(),\n+            DefWithBody::Variant(it) => it.into(),\n         };\n         for diag in hir_ty::diagnostics::incorrect_case(db, krate, def.into()) {\n             acc.push(diag.into())\n@@ -2485,7 +2546,7 @@ impl TypeParam {\n         let resolver = self.id.parent().resolver(db.upcast());\n         let ty = params.get(local_idx)?.clone();\n         let subst = TyBuilder::placeholder_subst(db, self.id.parent());\n-        let ty = ty.substitute(Interner, &subst_prefix(&subst, local_idx));\n+        let ty = ty.substitute(Interner, &subst);\n         match ty.data(Interner) {\n             GenericArgData::Ty(x) => Some(Type::new_with_resolver_inner(db, &resolver, x.clone())),\n             _ => None,\n@@ -2739,7 +2800,22 @@ impl Type {\n     }\n \n     fn from_def(db: &dyn HirDatabase, def: impl HasResolver + Into<TyDefId>) -> Type {\n-        let ty = TyBuilder::def_ty(db, def.into()).fill_with_unknown().build();\n+        let ty_def = def.into();\n+        let parent_subst = match ty_def {\n+            TyDefId::TypeAliasId(id) => match id.lookup(db.upcast()).container {\n+                ItemContainerId::TraitId(id) => {\n+                    let subst = TyBuilder::subst_for_def(db, id, None).fill_with_unknown().build();\n+                    Some(subst)\n+                }\n+                ItemContainerId::ImplId(id) => {\n+                    let subst = TyBuilder::subst_for_def(db, id, None).fill_with_unknown().build();\n+                    Some(subst)\n+                }\n+                _ => None,\n+            },\n+            _ => None,\n+        };\n+        let ty = TyBuilder::def_ty(db, ty_def, parent_subst).fill_with_unknown().build();\n         Type::new(db, def, ty)\n     }\n \n@@ -2879,7 +2955,11 @@ impl Type {\n         alias: TypeAlias,\n     ) -> Option<Type> {\n         let mut args = args.iter();\n-        let projection = TyBuilder::assoc_type_projection(db, alias.id)\n+        let trait_id = match alias.id.lookup(db.upcast()).container {\n+            ItemContainerId::TraitId(id) => id,\n+            _ => unreachable!(\"non assoc type alias reached in normalize_trait_assoc_type()\"),\n+        };\n+        let parent_subst = TyBuilder::subst_for_def(db, trait_id, None)\n             .push(self.ty.clone())\n             .fill(|x| {\n                 // FIXME: this code is not covered in tests.\n@@ -2891,6 +2971,8 @@ impl Type {\n                 }\n             })\n             .build();\n+        // FIXME: We don't handle GATs yet.\n+        let projection = TyBuilder::assoc_type_projection(db, alias.id, Some(parent_subst)).build();\n \n         let ty = db.normalize_projection(projection, self.env.clone());\n         if ty.is_unknown() {\n@@ -2940,7 +3022,7 @@ impl Type {\n \n         let adt = adt_id.into();\n         match adt {\n-            Adt::Struct(s) => matches!(s.repr(db), Some(ReprKind::Packed)),\n+            Adt::Struct(s) => matches!(s.repr(db), Some(ReprData { packed: true, .. })),\n             _ => false,\n         }\n     }"}, {"sha": "119ec3210e175b0ca417420c3c480f57805b9156", "filename": "crates/hir/src/semantics.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fhir%2Fsrc%2Fsemantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fhir%2Fsrc%2Fsemantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsemantics.rs?ref=e6540cff74534e6d9fb86d5d66e66423fad03766", "patch": "@@ -257,6 +257,11 @@ impl<'db, DB: HirDatabase> Semantics<'db, DB> {\n     pub fn original_ast_node<N: AstNode>(&self, node: N) -> Option<N> {\n         self.imp.original_ast_node(node)\n     }\n+    /// Attempts to map the node out of macro expanded files.\n+    /// This only work for attribute expansions, as other ones do not have nodes as input.\n+    pub fn original_syntax_node(&self, node: &SyntaxNode) -> Option<SyntaxNode> {\n+        self.imp.original_syntax_node(node)\n+    }\n \n     pub fn diagnostics_display_range(&self, diagnostics: InFile<SyntaxNodePtr>) -> FileRange {\n         self.imp.diagnostics_display_range(diagnostics)\n@@ -956,6 +961,16 @@ impl<'db> SemanticsImpl<'db> {\n         )\n     }\n \n+    fn original_syntax_node(&self, node: &SyntaxNode) -> Option<SyntaxNode> {\n+        let InFile { file_id, .. } = self.find_file(node);\n+        InFile::new(file_id, node).original_syntax_node(self.db.upcast()).map(\n+            |InFile { file_id, value }| {\n+                self.cache(find_root(&value), file_id);\n+                value\n+            },\n+        )\n+    }\n+\n     fn diagnostics_display_range(&self, src: InFile<SyntaxNodePtr>) -> FileRange {\n         let root = self.parse_or_expand(src.file_id).unwrap();\n         let node = src.map(|it| it.to_node(&root));"}, {"sha": "fa45e3c12eb009b37a00aaf71ad95d94993897f3", "filename": "crates/hir/src/semantics/source_to_def.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fhir%2Fsrc%2Fsemantics%2Fsource_to_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fhir%2Fsrc%2Fsemantics%2Fsource_to_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsemantics%2Fsource_to_def.rs?ref=e6540cff74534e6d9fb86d5d66e66423fad03766", "patch": "@@ -115,7 +115,7 @@ pub(super) struct SourceToDefCtx<'a, 'b> {\n }\n \n impl SourceToDefCtx<'_, '_> {\n-    pub(super) fn file_to_def(&mut self, file: FileId) -> SmallVec<[ModuleId; 1]> {\n+    pub(super) fn file_to_def(&self, file: FileId) -> SmallVec<[ModuleId; 1]> {\n         let _p = profile::span(\"SourceBinder::to_module_def\");\n         let mut mods = SmallVec::new();\n         for &crate_id in self.db.relevant_crates(file).iter() {\n@@ -130,7 +130,7 @@ impl SourceToDefCtx<'_, '_> {\n         mods\n     }\n \n-    pub(super) fn module_to_def(&mut self, src: InFile<ast::Module>) -> Option<ModuleId> {\n+    pub(super) fn module_to_def(&self, src: InFile<ast::Module>) -> Option<ModuleId> {\n         let _p = profile::span(\"module_to_def\");\n         let parent_declaration = src\n             .syntax()\n@@ -151,7 +151,7 @@ impl SourceToDefCtx<'_, '_> {\n         Some(def_map.module_id(child_id))\n     }\n \n-    pub(super) fn source_file_to_def(&mut self, src: InFile<ast::SourceFile>) -> Option<ModuleId> {\n+    pub(super) fn source_file_to_def(&self, src: InFile<ast::SourceFile>) -> Option<ModuleId> {\n         let _p = profile::span(\"source_file_to_def\");\n         let file_id = src.file_id.original_file(self.db.upcast());\n         self.file_to_def(file_id).get(0).copied()\n@@ -384,7 +384,7 @@ impl SourceToDefCtx<'_, '_> {\n         } else {\n             let it = ast::Variant::cast(container.value)?;\n             let def = self.enum_variant_to_def(InFile::new(container.file_id, it))?;\n-            VariantId::from(def).into()\n+            DefWithBodyId::from(def).into()\n         };\n         Some(cont)\n     }"}, {"sha": "07bae2b38c796b3ee6698ae09785e61e71bcf7a9", "filename": "crates/hir/src/source_analyzer.rs", "status": "modified", "additions": 33, "deletions": 13, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs?ref=e6540cff74534e6d9fb86d5d66e66423fad03766", "patch": "@@ -22,7 +22,7 @@ use hir_def::{\n     resolver::{resolver_for_scope, Resolver, TypeNs, ValueNs},\n     type_ref::Mutability,\n     AsMacroCall, AssocItemId, DefWithBodyId, FieldId, FunctionId, ItemContainerId, LocalFieldId,\n-    Lookup, ModuleDefId, VariantId,\n+    Lookup, ModuleDefId, TraitId, VariantId,\n };\n use hir_expand::{\n     builtin_fn_macro::BuiltinFnLikeExpander,\n@@ -302,10 +302,15 @@ impl SourceAnalyzer {\n             }\n         }\n \n+        let future_trait = db\n+            .lang_item(self.resolver.krate(), hir_expand::name![future_trait].to_smol_str())?\n+            .as_trait()?;\n         let poll_fn = db\n             .lang_item(self.resolver.krate(), hir_expand::name![poll].to_smol_str())?\n             .as_function()?;\n-        let substs = hir_ty::TyBuilder::subst_for_def(db, poll_fn).push(ty.clone()).build();\n+        // HACK: subst for `poll()` coincides with that for `Future` because `poll()` itself\n+        // doesn't have any generic parameters, so we skip building another subst for `poll()`.\n+        let substs = hir_ty::TyBuilder::subst_for_def(db, future_trait, None).push(ty).build();\n         Some(self.resolve_impl_method_or_trait_def(db, poll_fn, &substs))\n     }\n \n@@ -321,8 +326,10 @@ impl SourceAnalyzer {\n         };\n         let ty = self.ty_of_expr(db, &prefix_expr.expr()?.into())?;\n \n-        let op_fn = self.lang_trait_fn(db, &lang_item_name, &lang_item_name)?;\n-        let substs = hir_ty::TyBuilder::subst_for_def(db, op_fn).push(ty.clone()).build();\n+        let (op_trait, op_fn) = self.lang_trait_fn(db, &lang_item_name, &lang_item_name)?;\n+        // HACK: subst for all methods coincides with that for their trait because the methods\n+        // don't have any generic parameters, so we skip building another subst for the methods.\n+        let substs = hir_ty::TyBuilder::subst_for_def(db, op_trait, None).push(ty.clone()).build();\n \n         Some(self.resolve_impl_method_or_trait_def(db, op_fn, &substs))\n     }\n@@ -337,8 +344,10 @@ impl SourceAnalyzer {\n \n         let lang_item_name = name![index];\n \n-        let op_fn = self.lang_trait_fn(db, &lang_item_name, &lang_item_name)?;\n-        let substs = hir_ty::TyBuilder::subst_for_def(db, op_fn)\n+        let (op_trait, op_fn) = self.lang_trait_fn(db, &lang_item_name, &lang_item_name)?;\n+        // HACK: subst for all methods coincides with that for their trait because the methods\n+        // don't have any generic parameters, so we skip building another subst for the methods.\n+        let substs = hir_ty::TyBuilder::subst_for_def(db, op_trait, None)\n             .push(base_ty.clone())\n             .push(index_ty.clone())\n             .build();\n@@ -354,10 +363,14 @@ impl SourceAnalyzer {\n         let lhs = self.ty_of_expr(db, &binop_expr.lhs()?.into())?;\n         let rhs = self.ty_of_expr(db, &binop_expr.rhs()?.into())?;\n \n-        let op_fn = lang_names_for_bin_op(op)\n+        let (op_trait, op_fn) = lang_names_for_bin_op(op)\n             .and_then(|(name, lang_item)| self.lang_trait_fn(db, &lang_item, &name))?;\n-        let substs =\n-            hir_ty::TyBuilder::subst_for_def(db, op_fn).push(lhs.clone()).push(rhs.clone()).build();\n+        // HACK: subst for `index()` coincides with that for `Index` because `index()` itself\n+        // doesn't have any generic parameters, so we skip building another subst for `index()`.\n+        let substs = hir_ty::TyBuilder::subst_for_def(db, op_trait, None)\n+            .push(lhs.clone())\n+            .push(rhs.clone())\n+            .build();\n \n         Some(self.resolve_impl_method_or_trait_def(db, op_fn, &substs))\n     }\n@@ -371,7 +384,13 @@ impl SourceAnalyzer {\n \n         let op_fn =\n             db.lang_item(self.resolver.krate(), name![branch].to_smol_str())?.as_function()?;\n-        let substs = hir_ty::TyBuilder::subst_for_def(db, op_fn).push(ty.clone()).build();\n+        let op_trait = match op_fn.lookup(db.upcast()).container {\n+            ItemContainerId::TraitId(id) => id,\n+            _ => return None,\n+        };\n+        // HACK: subst for `branch()` coincides with that for `Try` because `branch()` itself\n+        // doesn't have any generic parameters, so we skip building another subst for `branch()`.\n+        let substs = hir_ty::TyBuilder::subst_for_def(db, op_trait, None).push(ty.clone()).build();\n \n         Some(self.resolve_impl_method_or_trait_def(db, op_fn, &substs))\n     }\n@@ -799,9 +818,10 @@ impl SourceAnalyzer {\n         db: &dyn HirDatabase,\n         lang_trait: &Name,\n         method_name: &Name,\n-    ) -> Option<FunctionId> {\n-        db.trait_data(db.lang_item(self.resolver.krate(), lang_trait.to_smol_str())?.as_trait()?)\n-            .method_by_name(method_name)\n+    ) -> Option<(TraitId, FunctionId)> {\n+        let trait_id = db.lang_item(self.resolver.krate(), lang_trait.to_smol_str())?.as_trait()?;\n+        let fn_id = db.trait_data(trait_id).method_by_name(method_name)?;\n+        Some((trait_id, fn_id))\n     }\n \n     fn ty_of_expr(&self, db: &dyn HirDatabase, expr: &ast::Expr) -> Option<&Ty> {"}, {"sha": "fd78decda4e648b4373d86d2a6c2de5233d4de76", "filename": "crates/hir/src/symbols.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fhir%2Fsrc%2Fsymbols.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fhir%2Fsrc%2Fsymbols.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsymbols.rs?ref=e6540cff74534e6d9fb86d5d66e66423fad03766", "patch": "@@ -244,6 +244,10 @@ impl<'a> SymbolCollector<'a> {\n             DefWithBodyId::ConstId(id) => Some(\n                 id.lookup(self.db.upcast()).source(self.db.upcast()).value.name()?.text().into(),\n             ),\n+            DefWithBodyId::VariantId(id) => Some({\n+                let db = self.db.upcast();\n+                id.parent.lookup(db).source(db).value.name()?.text().into()\n+            }),\n         }\n     }\n "}, {"sha": "aa710d2ce6513d4c96846a95a0e4836b863cb065", "filename": "crates/ide-assists/src/handlers/move_format_string_arg.rs", "status": "modified", "additions": 35, "deletions": 7, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fmove_format_string_arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fmove_format_string_arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fmove_format_string_arg.rs?ref=e6540cff74534e6d9fb86d5d66e66423fad03766", "patch": "@@ -7,6 +7,7 @@ use ide_db::{\n     },\n };\n use itertools::Itertools;\n+use stdx::format_to;\n use syntax::{ast, AstNode, AstToken, NodeOrToken, SyntaxKind::COMMA, TextRange};\n \n // Assist: move_format_string_arg\n@@ -78,20 +79,26 @@ pub(crate) fn move_format_string_arg(acc: &mut Assists, ctx: &AssistContext<'_>)\n \n             // Extract existing arguments in macro\n             let tokens =\n-                tt.token_trees_and_tokens().filter_map(NodeOrToken::into_token).collect_vec();\n+                tt.token_trees_and_tokens().collect_vec();\n \n             let mut existing_args: Vec<String> = vec![];\n \n             let mut current_arg = String::new();\n-            if let [_opening_bracket, format_string, _args_start_comma, tokens @ .., end_bracket] =\n+            if let [_opening_bracket, NodeOrToken::Token(format_string), _args_start_comma, tokens @ .., NodeOrToken::Token(end_bracket)] =\n                 tokens.as_slice()\n             {\n                 for t in tokens {\n-                    if t.kind() == COMMA {\n-                        existing_args.push(current_arg.trim().into());\n-                        current_arg.clear();\n-                    } else {\n-                        current_arg.push_str(t.text());\n+                    match t {\n+                        NodeOrToken::Node(n) => {\n+                            format_to!(current_arg, \"{n}\");\n+                        },\n+                        NodeOrToken::Token(t) if t.kind() == COMMA=> {\n+                            existing_args.push(current_arg.trim().into());\n+                            current_arg.clear();\n+                        },\n+                        NodeOrToken::Token(t) => {\n+                            current_arg.push_str(t.text());\n+                        },\n                     }\n                 }\n                 existing_args.push(current_arg.trim().into());\n@@ -261,6 +268,27 @@ fn main() {\n fn main() {\n     print!(\"{} {:b} {}\"$0, 1, x + 1, Struct(1, 2));\n }\n+\"#,\n+            ),\n+        );\n+    }\n+\n+    #[test]\n+    fn nested_tt() {\n+        check_assist(\n+            move_format_string_arg,\n+            &add_macro_decl(\n+                r#\"\n+fn main() {\n+    print!(\"My name is {} {x$0 + x}\", stringify!(Paperino))\n+}\n+\"#,\n+            ),\n+            &add_macro_decl(\n+                r#\"\n+fn main() {\n+    print!(\"My name is {} {}\"$0, stringify!(Paperino), x + x)\n+}\n \"#,\n             ),\n         );"}, {"sha": "25c58d086e977d71f3711fb2c09d65fdd26df653", "filename": "crates/ide-assists/src/handlers/unwrap_tuple.rs", "status": "added", "additions": 159, "deletions": 0, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fide-assists%2Fsrc%2Fhandlers%2Funwrap_tuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fide-assists%2Fsrc%2Fhandlers%2Funwrap_tuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Funwrap_tuple.rs?ref=e6540cff74534e6d9fb86d5d66e66423fad03766", "patch": "@@ -0,0 +1,159 @@\n+use syntax::{\n+    ast::{self, edit::AstNodeEdit},\n+    AstNode, T,\n+};\n+\n+use crate::{AssistContext, AssistId, AssistKind, Assists};\n+\n+// Assist: unwrap_tuple\n+//\n+// Unwrap the tuple to different variables.\n+//\n+// ```\n+// # //- minicore: result\n+// fn main() {\n+//     $0let (foo, bar) = (\"Foo\", \"Bar\");\n+// }\n+// ```\n+// ->\n+// ```\n+// fn main() {\n+//     let foo = \"Foo\";\n+//     let bar = \"Bar\";\n+// }\n+// ```\n+pub(crate) fn unwrap_tuple(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n+    let let_kw = ctx.find_token_syntax_at_offset(T![let])?;\n+    let let_stmt = let_kw.parent().and_then(ast::LetStmt::cast)?;\n+    let indent_level = let_stmt.indent_level().0 as usize;\n+    let pat = let_stmt.pat()?;\n+    let ty = let_stmt.ty();\n+    let init = let_stmt.initializer()?;\n+\n+    // This only applies for tuple patterns, types, and initializers.\n+    let tuple_pat = match pat {\n+        ast::Pat::TuplePat(pat) => pat,\n+        _ => return None,\n+    };\n+    let tuple_ty = ty.and_then(|it| match it {\n+        ast::Type::TupleType(ty) => Some(ty),\n+        _ => None,\n+    });\n+    let tuple_init = match init {\n+        ast::Expr::TupleExpr(expr) => expr,\n+        _ => return None,\n+    };\n+\n+    if tuple_pat.fields().count() != tuple_init.fields().count() {\n+        return None;\n+    }\n+    if let Some(tys) = &tuple_ty {\n+        if tuple_pat.fields().count() != tys.fields().count() {\n+            return None;\n+        }\n+    }\n+\n+    let parent = let_kw.parent()?;\n+\n+    acc.add(\n+        AssistId(\"unwrap_tuple\", AssistKind::RefactorRewrite),\n+        \"Unwrap tuple\",\n+        let_kw.text_range(),\n+        |edit| {\n+            let indents = \"    \".repeat(indent_level);\n+\n+            // If there is an ascribed type, insert that type for each declaration,\n+            // otherwise, omit that type.\n+            if let Some(tys) = tuple_ty {\n+                let mut zipped_decls = String::new();\n+                for (pat, ty, expr) in\n+                    itertools::izip!(tuple_pat.fields(), tys.fields(), tuple_init.fields())\n+                {\n+                    zipped_decls.push_str(&format!(\"{}let {pat}: {ty} = {expr};\\n\", indents))\n+                }\n+                edit.replace(parent.text_range(), zipped_decls.trim());\n+            } else {\n+                let mut zipped_decls = String::new();\n+                for (pat, expr) in itertools::izip!(tuple_pat.fields(), tuple_init.fields()) {\n+                    zipped_decls.push_str(&format!(\"{}let {pat} = {expr};\\n\", indents));\n+                }\n+                edit.replace(parent.text_range(), zipped_decls.trim());\n+            }\n+        },\n+    )\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::tests::check_assist;\n+\n+    use super::*;\n+\n+    #[test]\n+    fn unwrap_tuples() {\n+        check_assist(\n+            unwrap_tuple,\n+            r#\"\n+fn main() {\n+    $0let (foo, bar) = (\"Foo\", \"Bar\");\n+}\n+\"#,\n+            r#\"\n+fn main() {\n+    let foo = \"Foo\";\n+    let bar = \"Bar\";\n+}\n+\"#,\n+        );\n+\n+        check_assist(\n+            unwrap_tuple,\n+            r#\"\n+fn main() {\n+    $0let (foo, bar, baz) = (\"Foo\", \"Bar\", \"Baz\");\n+}\n+\"#,\n+            r#\"\n+fn main() {\n+    let foo = \"Foo\";\n+    let bar = \"Bar\";\n+    let baz = \"Baz\";\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn unwrap_tuple_with_types() {\n+        check_assist(\n+            unwrap_tuple,\n+            r#\"\n+fn main() {\n+    $0let (foo, bar): (u8, i32) = (5, 10);\n+}\n+\"#,\n+            r#\"\n+fn main() {\n+    let foo: u8 = 5;\n+    let bar: i32 = 10;\n+}\n+\"#,\n+        );\n+\n+        check_assist(\n+            unwrap_tuple,\n+            r#\"\n+fn main() {\n+    $0let (foo, bar, baz): (u8, i32, f64) = (5, 10, 17.5);\n+}\n+\"#,\n+            r#\"\n+fn main() {\n+    let foo: u8 = 5;\n+    let bar: i32 = 10;\n+    let baz: f64 = 17.5;\n+}\n+\"#,\n+        );\n+    }\n+}"}, {"sha": "82bcc3dfa5d9a97c03142218498b715a0b75318b", "filename": "crates/ide-assists/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fide-assists%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fide-assists%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Flib.rs?ref=e6540cff74534e6d9fb86d5d66e66423fad03766", "patch": "@@ -189,6 +189,7 @@ mod handlers {\n     mod replace_turbofish_with_explicit_type;\n     mod split_import;\n     mod unmerge_match_arm;\n+    mod unwrap_tuple;\n     mod sort_items;\n     mod toggle_ignore;\n     mod unmerge_use;\n@@ -291,6 +292,7 @@ mod handlers {\n             unnecessary_async::unnecessary_async,\n             unwrap_block::unwrap_block,\n             unwrap_result_return_type::unwrap_result_return_type,\n+            unwrap_tuple::unwrap_tuple,\n             wrap_return_type_in_result::wrap_return_type_in_result,\n             // These are manually sorted for better priorities. By default,\n             // priority is determined by the size of the target range (smaller"}, {"sha": "a3bb66e379eb81887f221b9cdb54d73bdc9e3b19", "filename": "crates/ide-assists/src/tests.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fide-assists%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fide-assists%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Ftests.rs?ref=e6540cff74534e6d9fb86d5d66e66423fad03766", "patch": "@@ -96,8 +96,10 @@ fn check_doc_test(assist_id: &str, before: &str, after: &str) {\n         });\n \n     let actual = {\n-        let source_change =\n-            assist.source_change.expect(\"Assist did not contain any source changes\");\n+        let source_change = assist\n+            .source_change\n+            .filter(|it| !it.source_file_edits.is_empty() || !it.file_system_edits.is_empty())\n+            .expect(\"Assist did not contain any source changes\");\n         let mut actual = before;\n         if let Some(source_file_edit) = source_change.get_source_edit(file_id) {\n             source_file_edit.apply(&mut actual);\n@@ -140,8 +142,10 @@ fn check(handler: Handler, before: &str, expected: ExpectedResult<'_>, assist_la\n \n     match (assist, expected) {\n         (Some(assist), ExpectedResult::After(after)) => {\n-            let source_change =\n-                assist.source_change.expect(\"Assist did not contain any source changes\");\n+            let source_change = assist\n+                .source_change\n+                .filter(|it| !it.source_file_edits.is_empty() || !it.file_system_edits.is_empty())\n+                .expect(\"Assist did not contain any source changes\");\n             let skip_header = source_change.source_file_edits.len() == 1\n                 && source_change.file_system_edits.len() == 0;\n "}, {"sha": "d403f86c6d8c9ff9cc20c1d2c51e2a5ebbb12d57", "filename": "crates/ide-assists/src/tests/generated.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fide-assists%2Fsrc%2Ftests%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fide-assists%2Fsrc%2Ftests%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Ftests%2Fgenerated.rs?ref=e6540cff74534e6d9fb86d5d66e66423fad03766", "patch": "@@ -2386,6 +2386,25 @@ fn foo() -> i32 { 42i32 }\n     )\n }\n \n+#[test]\n+fn doctest_unwrap_tuple() {\n+    check_doc_test(\n+        \"unwrap_tuple\",\n+        r#####\"\n+//- minicore: result\n+fn main() {\n+    $0let (foo, bar) = (\"Foo\", \"Bar\");\n+}\n+\"#####,\n+        r#####\"\n+fn main() {\n+    let foo = \"Foo\";\n+    let bar = \"Bar\";\n+}\n+\"#####,\n+    )\n+}\n+\n #[test]\n fn doctest_wrap_return_type_in_result() {\n     check_doc_test("}, {"sha": "e82cbfdcb8402e6dbc0518c60a8d8621bc38922b", "filename": "crates/ide-completion/src/completions/item_list/trait_impl.rs", "status": "modified", "additions": 28, "deletions": 23, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fitem_list%2Ftrait_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fitem_list%2Ftrait_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fitem_list%2Ftrait_impl.rs?ref=e6540cff74534e6d9fb86d5d66e66423fad03766", "patch": "@@ -38,7 +38,7 @@ use ide_db::{\n };\n use syntax::{\n     ast::{self, edit_in_place::AttrsOwnerEdit},\n-    AstNode, SyntaxElement, SyntaxKind, SyntaxNode, TextRange, T,\n+    AstNode, SyntaxElement, SyntaxKind, TextRange, T,\n };\n use text_edit::TextEdit;\n \n@@ -85,20 +85,36 @@ fn complete_trait_impl_name(\n     name: &Option<ast::Name>,\n     kind: ImplCompletionKind,\n ) -> Option<()> {\n-    let token = ctx.token.clone();\n     let item = match name {\n         Some(name) => name.syntax().parent(),\n-        None => if token.kind() == SyntaxKind::WHITESPACE { token.prev_token()? } else { token }\n-            .parent(),\n+        None => {\n+            let token = &ctx.token;\n+            match token.kind() {\n+                SyntaxKind::WHITESPACE => token.prev_token()?,\n+                _ => token.clone(),\n+            }\n+            .parent()\n+        }\n     }?;\n-    complete_trait_impl(\n-        acc,\n-        ctx,\n-        kind,\n-        replacement_range(ctx, &item),\n-        // item -> ASSOC_ITEM_LIST -> IMPL\n-        &ast::Impl::cast(item.parent()?.parent()?)?,\n-    );\n+    let item = ctx.sema.original_syntax_node(&item)?;\n+    // item -> ASSOC_ITEM_LIST -> IMPL\n+    let impl_def = ast::Impl::cast(item.parent()?.parent()?)?;\n+    let replacement_range = {\n+        // ctx.sema.original_ast_node(item)?;\n+        let first_child = item\n+            .children_with_tokens()\n+            .find(|child| {\n+                !matches!(\n+                    child.kind(),\n+                    SyntaxKind::COMMENT | SyntaxKind::WHITESPACE | SyntaxKind::ATTR\n+                )\n+            })\n+            .unwrap_or_else(|| SyntaxElement::Node(item.clone()));\n+\n+        TextRange::new(first_child.text_range().start(), ctx.source_range().end())\n+    };\n+\n+    complete_trait_impl(acc, ctx, kind, replacement_range, &impl_def);\n     Some(())\n }\n \n@@ -341,17 +357,6 @@ fn function_declaration(node: &ast::Fn, needs_whitespace: bool) -> String {\n     syntax.trim_end().to_owned()\n }\n \n-fn replacement_range(ctx: &CompletionContext<'_>, item: &SyntaxNode) -> TextRange {\n-    let first_child = item\n-        .children_with_tokens()\n-        .find(|child| {\n-            !matches!(child.kind(), SyntaxKind::COMMENT | SyntaxKind::WHITESPACE | SyntaxKind::ATTR)\n-        })\n-        .unwrap_or_else(|| SyntaxElement::Node(item.clone()));\n-\n-    TextRange::new(first_child.text_range().start(), ctx.source_range().end())\n-}\n-\n #[cfg(test)]\n mod tests {\n     use expect_test::{expect, Expect};"}, {"sha": "371d642c15d1d43b468213be0535284e9dc96d05", "filename": "crates/ide-db/src/imports/merge_imports.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fide-db%2Fsrc%2Fimports%2Fmerge_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fide-db%2Fsrc%2Fimports%2Fmerge_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-db%2Fsrc%2Fimports%2Fmerge_imports.rs?ref=e6540cff74534e6d9fb86d5d66e66423fad03766", "patch": "@@ -225,7 +225,7 @@ fn path_cmp_short(a: &ast::Path, b: &ast::Path) -> Ordering {\n }\n \n /// Compares two paths, if one ends earlier than the other the has_tl parameters decide which is\n-/// greater as a a path that has a tree list should be greater, while one that just ends without\n+/// greater as a path that has a tree list should be greater, while one that just ends without\n /// a tree list should be considered less.\n pub(super) fn use_tree_path_cmp(\n     a: &ast::Path,"}, {"sha": "82b85f2fa5edd58ed58c59aa172c1599bb7c994d", "filename": "crates/ide-db/src/search.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fide-db%2Fsrc%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fide-db%2Fsrc%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-db%2Fsrc%2Fsearch.rs?ref=e6540cff74534e6d9fb86d5d66e66423fad03766", "patch": "@@ -239,6 +239,7 @@ impl Definition {\n                 DefWithBody::Function(f) => f.source(db).map(|src| src.syntax().cloned()),\n                 DefWithBody::Const(c) => c.source(db).map(|src| src.syntax().cloned()),\n                 DefWithBody::Static(s) => s.source(db).map(|src| src.syntax().cloned()),\n+                DefWithBody::Variant(v) => v.source(db).map(|src| src.syntax().cloned()),\n             };\n             return match def {\n                 Some(def) => SearchScope::file_range(def.as_ref().original_file_range(db)),"}, {"sha": "f558b7256a4c6473aad6f452d57aea3a0bca0fa1", "filename": "crates/ide-diagnostics/src/handlers/inactive_code.rs", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Finactive_code.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Finactive_code.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Finactive_code.rs?ref=e6540cff74534e6d9fb86d5d66e66423fad03766", "patch": "@@ -137,6 +137,37 @@ trait Bar {\n \n     #[cfg_attr(not(never), inline, cfg(no))] fn h() {}\n   //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ weak: code is inactive due to #[cfg] directives: no is disabled\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn inactive_fields_and_variants() {\n+        check(\n+            r#\"\n+enum Foo {\n+  #[cfg(a)] Bar,\n+//^^^^^^^^^^^^^ weak: code is inactive due to #[cfg] directives: a is disabled\n+  Baz {\n+    #[cfg(a)] baz: String,\n+  //^^^^^^^^^^^^^^^^^^^^^ weak: code is inactive due to #[cfg] directives: a is disabled\n+  },\n+  Qux(#[cfg(a)] String),\n+    //^^^^^^^^^^^^^^^^ weak: code is inactive due to #[cfg] directives: a is disabled\n+}\n+\n+struct Baz {\n+  #[cfg(a)] baz: String,\n+//^^^^^^^^^^^^^^^^^^^^^ weak: code is inactive due to #[cfg] directives: a is disabled\n+}\n+\n+struct Qux(#[cfg(a)] String);\n+         //^^^^^^^^^^^^^^^^ weak: code is inactive due to #[cfg] directives: a is disabled\n+\n+union FooBar {\n+  #[cfg(a)] baz: u32,\n+//^^^^^^^^^^^^^^^^^^ weak: code is inactive due to #[cfg] directives: a is disabled\n+}\n \"#,\n         );\n     }"}, {"sha": "f994c284c713a7153cd18f26784f3934099cff09", "filename": "crates/ide/src/annotations.rs", "status": "modified", "additions": 165, "deletions": 99, "changes": 264, "blob_url": "https://github.com/rust-lang/rust/blob/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fide%2Fsrc%2Fannotations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fide%2Fsrc%2Fannotations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fannotations.rs?ref=e6540cff74534e6d9fb86d5d66e66423fad03766", "patch": "@@ -8,13 +8,15 @@ use ide_db::{\n use syntax::{ast::HasName, AstNode, TextRange};\n \n use crate::{\n-    fn_references::find_all_methods,\n+    annotations::fn_references::find_all_methods,\n     goto_implementation::goto_implementation,\n     references::find_all_refs,\n     runnables::{runnables, Runnable},\n     NavigationTarget, RunnableKind,\n };\n \n+mod fn_references;\n+\n // Feature: Annotations\n //\n // Provides user with annotations above items for looking up references or impl blocks\n@@ -30,8 +32,8 @@ pub struct Annotation {\n #[derive(Debug)]\n pub enum AnnotationKind {\n     Runnable(Runnable),\n-    HasImpls { file_id: FileId, data: Option<Vec<NavigationTarget>> },\n-    HasReferences { file_id: FileId, data: Option<Vec<FileRange>> },\n+    HasImpls { pos: FilePosition, data: Option<Vec<NavigationTarget>> },\n+    HasReferences { pos: FilePosition, data: Option<Vec<FileRange>> },\n }\n \n pub struct AnnotationConfig {\n@@ -68,13 +70,23 @@ pub(crate) fn annotations(\n         }\n     }\n \n+    let mk_ranges = |(range, focus): (_, Option<_>)| {\n+        let cmd_target: TextRange = focus.unwrap_or(range);\n+        let annotation_range = match config.location {\n+            AnnotationLocation::AboveName => cmd_target,\n+            AnnotationLocation::AboveWholeItem => range,\n+        };\n+        let target_pos = FilePosition { file_id, offset: cmd_target.start() };\n+        (annotation_range, target_pos)\n+    };\n+\n     visit_file_defs(&Semantics::new(db), file_id, &mut |def| {\n         let range = match def {\n             Definition::Const(konst) if config.annotate_references => {\n-                konst.source(db).and_then(|node| name_range(db, config, node, file_id))\n+                konst.source(db).and_then(|node| name_range(db, node, file_id))\n             }\n             Definition::Trait(trait_) if config.annotate_references || config.annotate_impls => {\n-                trait_.source(db).and_then(|node| name_range(db, config, node, file_id))\n+                trait_.source(db).and_then(|node| name_range(db, node, file_id))\n             }\n             Definition::Adt(adt) => match adt {\n                 hir::Adt::Enum(enum_) => {\n@@ -83,27 +95,29 @@ pub(crate) fn annotations(\n                             .variants(db)\n                             .into_iter()\n                             .map(|variant| {\n-                                variant\n-                                    .source(db)\n-                                    .and_then(|node| name_range(db, config, node, file_id))\n+                                variant.source(db).and_then(|node| name_range(db, node, file_id))\n                             })\n                             .flatten()\n                             .for_each(|range| {\n+                                let (annotation_range, target_position) = mk_ranges(range);\n                                 annotations.push(Annotation {\n-                                    range,\n-                                    kind: AnnotationKind::HasReferences { file_id, data: None },\n+                                    range: annotation_range,\n+                                    kind: AnnotationKind::HasReferences {\n+                                        pos: target_position,\n+                                        data: None,\n+                                    },\n                                 })\n                             })\n                     }\n                     if config.annotate_references || config.annotate_impls {\n-                        enum_.source(db).and_then(|node| name_range(db, config, node, file_id))\n+                        enum_.source(db).and_then(|node| name_range(db, node, file_id))\n                     } else {\n                         None\n                     }\n                 }\n                 _ => {\n                     if config.annotate_references || config.annotate_impls {\n-                        adt.source(db).and_then(|node| name_range(db, config, node, file_id))\n+                        adt.source(db).and_then(|node| name_range(db, node, file_id))\n                     } else {\n                         None\n                     }\n@@ -116,65 +130,58 @@ pub(crate) fn annotations(\n             Some(range) => range,\n             None => return,\n         };\n-\n+        let (annotation_range, target_pos) = mk_ranges(range);\n         if config.annotate_impls && !matches!(def, Definition::Const(_)) {\n-            annotations\n-                .push(Annotation { range, kind: AnnotationKind::HasImpls { file_id, data: None } });\n+            annotations.push(Annotation {\n+                range: annotation_range,\n+                kind: AnnotationKind::HasImpls { pos: target_pos, data: None },\n+            });\n         }\n \n         if config.annotate_references {\n             annotations.push(Annotation {\n-                range,\n-                kind: AnnotationKind::HasReferences { file_id, data: None },\n+                range: annotation_range,\n+                kind: AnnotationKind::HasReferences { pos: target_pos, data: None },\n             });\n         }\n \n         fn name_range<T: HasName>(\n             db: &RootDatabase,\n-            config: &AnnotationConfig,\n             node: InFile<T>,\n             source_file_id: FileId,\n-        ) -> Option<TextRange> {\n+        ) -> Option<(TextRange, Option<TextRange>)> {\n             if let Some(InFile { file_id, value }) = node.original_ast_node(db) {\n                 if file_id == source_file_id.into() {\n-                    return match config.location {\n-                        AnnotationLocation::AboveName => {\n-                            value.name().map(|name| name.syntax().text_range())\n-                        }\n-                        AnnotationLocation::AboveWholeItem => Some(value.syntax().text_range()),\n-                    };\n+                    return Some((\n+                        value.syntax().text_range(),\n+                        value.name().map(|name| name.syntax().text_range()),\n+                    ));\n                 }\n             }\n             None\n         }\n     });\n \n     if config.annotate_method_references {\n-        annotations.extend(find_all_methods(db, file_id).into_iter().map(\n-            |FileRange { file_id, range }| Annotation {\n-                range,\n-                kind: AnnotationKind::HasReferences { file_id, data: None },\n-            },\n-        ));\n+        annotations.extend(find_all_methods(db, file_id).into_iter().map(|range| {\n+            let (annotation_range, target_range) = mk_ranges(range);\n+            Annotation {\n+                range: annotation_range,\n+                kind: AnnotationKind::HasReferences { pos: target_range, data: None },\n+            }\n+        }));\n     }\n \n     annotations\n }\n \n pub(crate) fn resolve_annotation(db: &RootDatabase, mut annotation: Annotation) -> Annotation {\n     match annotation.kind {\n-        AnnotationKind::HasImpls { file_id, ref mut data } => {\n-            *data =\n-                goto_implementation(db, FilePosition { file_id, offset: annotation.range.start() })\n-                    .map(|range| range.info);\n+        AnnotationKind::HasImpls { pos, ref mut data } => {\n+            *data = goto_implementation(db, pos).map(|range| range.info);\n         }\n-        AnnotationKind::HasReferences { file_id, ref mut data } => {\n-            *data = find_all_refs(\n-                &Semantics::new(db),\n-                FilePosition { file_id, offset: annotation.range.start() },\n-                None,\n-            )\n-            .map(|result| {\n+        AnnotationKind::HasReferences { pos, ref mut data } => {\n+            *data = find_all_refs(&Semantics::new(db), pos, None).map(|result| {\n                 result\n                     .into_iter()\n                     .flat_map(|res| res.references)\n@@ -268,9 +275,12 @@ fn main() {\n                     Annotation {\n                         range: 6..10,\n                         kind: HasReferences {\n-                            file_id: FileId(\n-                                0,\n-                            ),\n+                            pos: FilePosition {\n+                                file_id: FileId(\n+                                    0,\n+                                ),\n+                                offset: 6,\n+                            },\n                             data: Some(\n                                 [\n                                     FileRange {\n@@ -286,9 +296,12 @@ fn main() {\n                     Annotation {\n                         range: 30..36,\n                         kind: HasReferences {\n-                            file_id: FileId(\n-                                0,\n-                            ),\n+                            pos: FilePosition {\n+                                file_id: FileId(\n+                                    0,\n+                                ),\n+                                offset: 30,\n+                            },\n                             data: Some(\n                                 [],\n                             ),\n@@ -297,9 +310,12 @@ fn main() {\n                     Annotation {\n                         range: 53..57,\n                         kind: HasReferences {\n-                            file_id: FileId(\n-                                0,\n-                            ),\n+                            pos: FilePosition {\n+                                file_id: FileId(\n+                                    0,\n+                                ),\n+                                offset: 53,\n+                            },\n                             data: Some(\n                                 [],\n                             ),\n@@ -344,9 +360,12 @@ fn main() {\n                     Annotation {\n                         range: 7..11,\n                         kind: HasImpls {\n-                            file_id: FileId(\n-                                0,\n-                            ),\n+                            pos: FilePosition {\n+                                file_id: FileId(\n+                                    0,\n+                                ),\n+                                offset: 7,\n+                            },\n                             data: Some(\n                                 [],\n                             ),\n@@ -355,9 +374,12 @@ fn main() {\n                     Annotation {\n                         range: 7..11,\n                         kind: HasReferences {\n-                            file_id: FileId(\n-                                0,\n-                            ),\n+                            pos: FilePosition {\n+                                file_id: FileId(\n+                                    0,\n+                                ),\n+                                offset: 7,\n+                            },\n                             data: Some(\n                                 [\n                                     FileRange {\n@@ -373,9 +395,12 @@ fn main() {\n                     Annotation {\n                         range: 17..21,\n                         kind: HasReferences {\n-                            file_id: FileId(\n-                                0,\n-                            ),\n+                            pos: FilePosition {\n+                                file_id: FileId(\n+                                    0,\n+                                ),\n+                                offset: 17,\n+                            },\n                             data: Some(\n                                 [],\n                             ),\n@@ -424,9 +449,12 @@ fn main() {\n                     Annotation {\n                         range: 7..11,\n                         kind: HasImpls {\n-                            file_id: FileId(\n-                                0,\n-                            ),\n+                            pos: FilePosition {\n+                                file_id: FileId(\n+                                    0,\n+                                ),\n+                                offset: 7,\n+                            },\n                             data: Some(\n                                 [\n                                     NavigationTarget {\n@@ -445,9 +473,12 @@ fn main() {\n                     Annotation {\n                         range: 7..11,\n                         kind: HasReferences {\n-                            file_id: FileId(\n-                                0,\n-                            ),\n+                            pos: FilePosition {\n+                                file_id: FileId(\n+                                    0,\n+                                ),\n+                                offset: 7,\n+                            },\n                             data: Some(\n                                 [\n                                     FileRange {\n@@ -469,9 +500,12 @@ fn main() {\n                     Annotation {\n                         range: 20..31,\n                         kind: HasImpls {\n-                            file_id: FileId(\n-                                0,\n-                            ),\n+                            pos: FilePosition {\n+                                file_id: FileId(\n+                                    0,\n+                                ),\n+                                offset: 20,\n+                            },\n                             data: Some(\n                                 [\n                                     NavigationTarget {\n@@ -490,9 +524,12 @@ fn main() {\n                     Annotation {\n                         range: 20..31,\n                         kind: HasReferences {\n-                            file_id: FileId(\n-                                0,\n-                            ),\n+                            pos: FilePosition {\n+                                file_id: FileId(\n+                                    0,\n+                                ),\n+                                offset: 20,\n+                            },\n                             data: Some(\n                                 [\n                                     FileRange {\n@@ -508,9 +545,12 @@ fn main() {\n                     Annotation {\n                         range: 69..73,\n                         kind: HasReferences {\n-                            file_id: FileId(\n-                                0,\n-                            ),\n+                            pos: FilePosition {\n+                                file_id: FileId(\n+                                    0,\n+                                ),\n+                                offset: 69,\n+                            },\n                             data: Some(\n                                 [],\n                             ),\n@@ -551,9 +591,12 @@ fn main() {}\n                     Annotation {\n                         range: 3..7,\n                         kind: HasReferences {\n-                            file_id: FileId(\n-                                0,\n-                            ),\n+                            pos: FilePosition {\n+                                file_id: FileId(\n+                                    0,\n+                                ),\n+                                offset: 3,\n+                            },\n                             data: Some(\n                                 [],\n                             ),\n@@ -602,9 +645,12 @@ fn main() {\n                     Annotation {\n                         range: 7..11,\n                         kind: HasImpls {\n-                            file_id: FileId(\n-                                0,\n-                            ),\n+                            pos: FilePosition {\n+                                file_id: FileId(\n+                                    0,\n+                                ),\n+                                offset: 7,\n+                            },\n                             data: Some(\n                                 [\n                                     NavigationTarget {\n@@ -623,9 +669,12 @@ fn main() {\n                     Annotation {\n                         range: 7..11,\n                         kind: HasReferences {\n-                            file_id: FileId(\n-                                0,\n-                            ),\n+                            pos: FilePosition {\n+                                file_id: FileId(\n+                                    0,\n+                                ),\n+                                offset: 7,\n+                            },\n                             data: Some(\n                                 [\n                                     FileRange {\n@@ -647,9 +696,12 @@ fn main() {\n                     Annotation {\n                         range: 33..44,\n                         kind: HasReferences {\n-                            file_id: FileId(\n-                                0,\n-                            ),\n+                            pos: FilePosition {\n+                                file_id: FileId(\n+                                    0,\n+                                ),\n+                                offset: 33,\n+                            },\n                             data: Some(\n                                 [\n                                     FileRange {\n@@ -665,9 +717,12 @@ fn main() {\n                     Annotation {\n                         range: 61..65,\n                         kind: HasReferences {\n-                            file_id: FileId(\n-                                0,\n-                            ),\n+                            pos: FilePosition {\n+                                file_id: FileId(\n+                                    0,\n+                                ),\n+                                offset: 61,\n+                            },\n                             data: Some(\n                                 [],\n                             ),\n@@ -761,9 +816,12 @@ mod tests {\n                     Annotation {\n                         range: 3..7,\n                         kind: HasReferences {\n-                            file_id: FileId(\n-                                0,\n-                            ),\n+                            pos: FilePosition {\n+                                file_id: FileId(\n+                                    0,\n+                                ),\n+                                offset: 3,\n+                            },\n                             data: Some(\n                                 [],\n                             ),\n@@ -821,9 +879,12 @@ struct Foo;\n                     Annotation {\n                         range: 0..71,\n                         kind: HasImpls {\n-                            file_id: FileId(\n-                                0,\n-                            ),\n+                            pos: FilePosition {\n+                                file_id: FileId(\n+                                    0,\n+                                ),\n+                                offset: 67,\n+                            },\n                             data: Some(\n                                 [],\n                             ),\n@@ -832,10 +893,15 @@ struct Foo;\n                     Annotation {\n                         range: 0..71,\n                         kind: HasReferences {\n-                            file_id: FileId(\n-                                0,\n+                            pos: FilePosition {\n+                                file_id: FileId(\n+                                    0,\n+                                ),\n+                                offset: 67,\n+                            },\n+                            data: Some(\n+                                [],\n                             ),\n-                            data: None,\n                         },\n                     },\n                 ]"}, {"sha": "0cadf125fecaec37f3f9e44d9c3c66f614e4e2ba", "filename": "crates/ide/src/annotations/fn_references.rs", "status": "renamed", "additions": 23, "deletions": 14, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fide%2Fsrc%2Fannotations%2Ffn_references.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fide%2Fsrc%2Fannotations%2Ffn_references.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fannotations%2Ffn_references.rs?ref=e6540cff74534e6d9fb86d5d66e66423fad03766", "patch": "@@ -4,30 +4,38 @@\n use hir::Semantics;\n use ide_assists::utils::test_related_attribute;\n use ide_db::RootDatabase;\n-use syntax::{ast, ast::HasName, AstNode, SyntaxNode};\n+use syntax::{ast, ast::HasName, AstNode, SyntaxNode, TextRange};\n \n-use crate::{FileId, FileRange};\n+use crate::FileId;\n \n-pub(crate) fn find_all_methods(db: &RootDatabase, file_id: FileId) -> Vec<FileRange> {\n+pub(super) fn find_all_methods(\n+    db: &RootDatabase,\n+    file_id: FileId,\n+) -> Vec<(TextRange, Option<TextRange>)> {\n     let sema = Semantics::new(db);\n     let source_file = sema.parse(file_id);\n-    source_file.syntax().descendants().filter_map(|it| method_range(it, file_id)).collect()\n+    source_file.syntax().descendants().filter_map(|it| method_range(it)).collect()\n }\n \n-fn method_range(item: SyntaxNode, file_id: FileId) -> Option<FileRange> {\n+fn method_range(item: SyntaxNode) -> Option<(TextRange, Option<TextRange>)> {\n     ast::Fn::cast(item).and_then(|fn_def| {\n         if test_related_attribute(&fn_def).is_some() {\n             None\n         } else {\n-            fn_def.name().map(|name| FileRange { file_id, range: name.syntax().text_range() })\n+            Some((\n+                fn_def.syntax().text_range(),\n+                fn_def.name().map(|name| name.syntax().text_range()),\n+            ))\n         }\n     })\n }\n \n #[cfg(test)]\n mod tests {\n+    use syntax::TextRange;\n+\n     use crate::fixture;\n-    use crate::{FileRange, TextSize};\n+    use crate::TextSize;\n     use std::ops::RangeInclusive;\n \n     #[test]\n@@ -42,7 +50,7 @@ mod tests {\n         \"#,\n         );\n \n-        let refs = analysis.find_all_methods(pos.file_id).unwrap();\n+        let refs = super::find_all_methods(&analysis.db, pos.file_id);\n         check_result(&refs, &[3..=13, 27..=33, 47..=57]);\n     }\n \n@@ -57,7 +65,7 @@ mod tests {\n         \"#,\n         );\n \n-        let refs = analysis.find_all_methods(pos.file_id).unwrap();\n+        let refs = super::find_all_methods(&analysis.db, pos.file_id);\n         check_result(&refs, &[19..=22, 35..=38]);\n     }\n \n@@ -78,17 +86,18 @@ mod tests {\n         \"#,\n         );\n \n-        let refs = analysis.find_all_methods(pos.file_id).unwrap();\n+        let refs = super::find_all_methods(&analysis.db, pos.file_id);\n         check_result(&refs, &[28..=34]);\n     }\n \n-    fn check_result(refs: &[FileRange], expected: &[RangeInclusive<u32>]) {\n+    fn check_result(refs: &[(TextRange, Option<TextRange>)], expected: &[RangeInclusive<u32>]) {\n         assert_eq!(refs.len(), expected.len());\n \n-        for (i, item) in refs.iter().enumerate() {\n+        for (i, &(full, focus)) in refs.iter().enumerate() {\n             let range = &expected[i];\n-            assert_eq!(TextSize::from(*range.start()), item.range.start());\n-            assert_eq!(TextSize::from(*range.end()), item.range.end());\n+            let item = focus.unwrap_or(full);\n+            assert_eq!(TextSize::from(*range.start()), item.start());\n+            assert_eq!(TextSize::from(*range.end()), item.end());\n         }\n     }\n }", "previous_filename": "crates/ide/src/fn_references.rs"}, {"sha": "d96827326cfd8a322d5234b6f6765a90271d57c5", "filename": "crates/ide/src/doc_links.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fide%2Fsrc%2Fdoc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fide%2Fsrc%2Fdoc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdoc_links.rs?ref=e6540cff74534e6d9fb86d5d66e66423fad03766", "patch": "@@ -232,8 +232,13 @@ pub(crate) fn token_as_doc_comment(doc_token: &SyntaxToken) -> Option<DocComment\n     (match_ast! {\n         match doc_token {\n             ast::Comment(comment) => TextSize::try_from(comment.prefix().len()).ok(),\n-            ast::String(string) => doc_token.parent_ancestors().find_map(ast::Attr::cast)\n-                .filter(|attr| attr.simple_name().as_deref() == Some(\"doc\")).and_then(|_| string.open_quote_text_range().map(|it| it.len())),\n+            ast::String(string) => {\n+                doc_token.parent_ancestors().find_map(ast::Attr::cast).filter(|attr| attr.simple_name().as_deref() == Some(\"doc\"))?;\n+                if doc_token.parent_ancestors().find_map(ast::MacroCall::cast).filter(|mac| mac.path().and_then(|p| p.segment()?.name_ref()).as_ref().map(|n| n.text()).as_deref() == Some(\"include_str\")).is_some() {\n+                    return None;\n+                }\n+                string.open_quote_text_range().map(|it| it.len())\n+            },\n             _ => None,\n         }\n     }).map(|prefix_len| DocCommentToken { prefix_len, doc_token: doc_token.clone() })"}, {"sha": "f86ea61d1586febd45d96994b91eb179eddde5f9", "filename": "crates/ide/src/goto_definition.rs", "status": "modified", "additions": 48, "deletions": 3, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fide%2Fsrc%2Fgoto_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fide%2Fsrc%2Fgoto_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fgoto_definition.rs?ref=e6540cff74534e6d9fb86d5d66e66423fad03766", "patch": "@@ -95,6 +95,14 @@ fn try_lookup_include_path(\n     if !matches!(&*name.text(), \"include\" | \"include_str\" | \"include_bytes\") {\n         return None;\n     }\n+\n+    // Ignore non-built-in macros to account for shadowing\n+    if let Some(it) = sema.resolve_macro_call(&macro_call) {\n+        if !matches!(it.kind(sema.db), hir::MacroKind::BuiltIn) {\n+            return None;\n+        }\n+    }\n+\n     let file_id = sema.db.resolve_path(AnchoredPath { anchor: file_id, path: &path })?;\n     let size = sema.db.file_text(file_id).len().try_into().ok()?;\n     Some(NavigationTarget {\n@@ -156,9 +164,6 @@ mod tests {\n     fn check(ra_fixture: &str) {\n         let (analysis, position, expected) = fixture::annotations(ra_fixture);\n         let navs = analysis.goto_definition(position).unwrap().expect(\"no definition found\").info;\n-        if navs.is_empty() {\n-            panic!(\"unresolved reference\")\n-        }\n \n         let cmp = |&FileRange { file_id, range }: &_| (file_id, range.start());\n         let navs = navs\n@@ -1348,6 +1353,10 @@ fn f(e: Enum) {\n         check(\n             r#\"\n //- /main.rs\n+\n+#[rustc_builtin_macro]\n+macro_rules! include_str {}\n+\n fn main() {\n     let str = include_str!(\"foo.txt$0\");\n }\n@@ -1357,6 +1366,42 @@ fn main() {\n \"#,\n         );\n     }\n+\n+    #[test]\n+    fn goto_doc_include_str() {\n+        check(\n+            r#\"\n+//- /main.rs\n+#[rustc_builtin_macro]\n+macro_rules! include_str {}\n+\n+#[doc = include_str!(\"docs.md$0\")]\n+struct Item;\n+\n+//- /docs.md\n+// docs\n+//^file\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn goto_shadow_include() {\n+        check(\n+            r#\"\n+//- /main.rs\n+macro_rules! include {\n+    (\"included.rs\") => {}\n+}\n+\n+include!(\"included.rs$0\");\n+\n+//- /included.rs\n+// empty\n+\"#,\n+        );\n+    }\n+\n     #[cfg(test)]\n     mod goto_impl_of_trait_fn {\n         use super::check;"}, {"sha": "540a115832d3ef0331ec4ca1e829f5d4b4ad603a", "filename": "crates/ide/src/highlight_related.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fide%2Fsrc%2Fhighlight_related.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fide%2Fsrc%2Fhighlight_related.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhighlight_related.rs?ref=e6540cff74534e6d9fb86d5d66e66423fad03766", "patch": "@@ -1373,6 +1373,22 @@ fn main() {\n     ().func$0();\n      //^^^^\n }\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_assoc_type_highlighting() {\n+        check(\n+            r#\"\n+trait Trait {\n+    type Output;\n+      // ^^^^^^\n+}\n+impl Trait for () {\n+    type Output$0 = ();\n+      // ^^^^^^\n+}\n \"#,\n         );\n     }"}, {"sha": "d109c0769194fbdb376da4f55c2f56e49278261e", "filename": "crates/ide/src/hover/render.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fide%2Fsrc%2Fhover%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fide%2Fsrc%2Fhover%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhover%2Frender.rs?ref=e6540cff74534e6d9fb86d5d66e66423fad03766", "patch": "@@ -346,7 +346,16 @@ pub(super) fn definition(\n         Definition::Module(it) => label_and_docs(db, it),\n         Definition::Function(it) => label_and_docs(db, it),\n         Definition::Adt(it) => label_and_docs(db, it),\n-        Definition::Variant(it) => label_and_docs(db, it),\n+        Definition::Variant(it) => label_value_and_docs(db, it, |&it| {\n+            if !it.parent_enum(db).is_data_carrying(db) {\n+                match it.eval(db) {\n+                    Ok(x) => Some(format!(\"{}\", x)),\n+                    Err(_) => it.value(db).map(|x| format!(\"{:?}\", x)),\n+                }\n+            } else {\n+                None\n+            }\n+        }),\n         Definition::Const(it) => label_value_and_docs(db, it, |it| {\n             let body = it.eval(db);\n             match body {"}, {"sha": "eb997e6fef83022f726dec8a2ff0e5cbcd6fdc86", "filename": "crates/ide/src/hover/tests.rs", "status": "modified", "additions": 136, "deletions": 0, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fide%2Fsrc%2Fhover%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fide%2Fsrc%2Fhover%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhover%2Ftests.rs?ref=e6540cff74534e6d9fb86d5d66e66423fad03766", "patch": "@@ -698,6 +698,7 @@ fn hover_enum_variant() {\n     check(\n         r#\"\n enum Option<T> {\n+    Some(T)\n     /// The None variant\n     Non$0e\n }\n@@ -3527,6 +3528,112 @@ impl<const LEN: usize> Foo<LEN$0> {}\n     );\n }\n \n+#[test]\n+fn hover_const_eval_variant() {\n+    // show hex for <10\n+    check(\n+        r#\"\n+#[repr(u8)]\n+enum E {\n+    /// This is a doc\n+    A$0 = 1 << 3,\n+}\n+\"#,\n+        expect![[r#\"\n+            *A*\n+\n+            ```rust\n+            test::E\n+            ```\n+\n+            ```rust\n+            A = 8\n+            ```\n+\n+            ---\n+\n+            This is a doc\n+        \"#]],\n+    );\n+    // show hex for >10\n+    check(\n+        r#\"\n+#[repr(u8)]\n+enum E {\n+    /// This is a doc\n+    A$0 = (1 << 3) + (1 << 2),\n+}\n+\"#,\n+        expect![[r#\"\n+            *A*\n+\n+            ```rust\n+            test::E\n+            ```\n+\n+            ```rust\n+            A = 12 (0xC)\n+            ```\n+\n+            ---\n+\n+            This is a doc\n+        \"#]],\n+    );\n+    // enums in const eval\n+    check(\n+        r#\"\n+#[repr(u8)]\n+enum E {\n+    A = 1,\n+    /// This is a doc\n+    B$0 = E::A as u8 + 1,\n+}\n+\"#,\n+        expect![[r#\"\n+            *B*\n+\n+            ```rust\n+            test::E\n+            ```\n+\n+            ```rust\n+            B = 2\n+            ```\n+\n+            ---\n+\n+            This is a doc\n+        \"#]],\n+    );\n+    // unspecified variant should increment by one\n+    check(\n+        r#\"\n+#[repr(u8)]\n+enum E {\n+    A = 4,\n+    /// This is a doc\n+    B$0,\n+}\n+\"#,\n+        expect![[r#\"\n+            *B*\n+\n+            ```rust\n+            test::E\n+            ```\n+\n+            ```rust\n+            B = 5\n+            ```\n+\n+            ---\n+\n+            This is a doc\n+        \"#]],\n+    );\n+}\n+\n #[test]\n fn hover_const_eval() {\n     // show hex for <10\n@@ -3820,6 +3927,35 @@ fn foo() {\n \n             ---\n \n+            This is a doc\n+        \"#]],\n+    );\n+    check(\n+        r#\"\n+enum E {\n+    /// This is a doc\n+    A = 3,\n+}\n+fn foo(e: E) {\n+    match e {\n+        E::A$0 => (),\n+        _ => ()\n+    }\n+}\n+\"#,\n+        expect![[r#\"\n+            *A*\n+\n+            ```rust\n+            test::E\n+            ```\n+\n+            ```rust\n+            A = 3\n+            ```\n+\n+            ---\n+\n             This is a doc\n         \"#]],\n     );"}, {"sha": "34d8bf67a3016edd55ffe4083870684aa9cb00b6", "filename": "crates/ide/src/inlay_hints.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fide%2Fsrc%2Finlay_hints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fide%2Fsrc%2Finlay_hints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Finlay_hints.rs?ref=e6540cff74534e6d9fb86d5d66e66423fad03766", "patch": "@@ -176,12 +176,6 @@ impl fmt::Debug for InlayHintLabelPart {\n // * elided lifetimes\n // * compiler inserted reborrows\n //\n-// |===\n-// | Editor  | Action Name\n-//\n-// | VS Code | **rust-analyzer: Toggle inlay hints*\n-// |===\n-//\n // image::https://user-images.githubusercontent.com/48062697/113020660-b5f98b80-917a-11eb-8d70-3be3fd558cdd.png[]\n pub(crate) fn inlay_hints(\n     db: &RootDatabase,\n@@ -2030,7 +2024,14 @@ impl<T> Vec<T> {\n }\n \n impl<T> IntoIterator for Vec<T> {\n-    type Item=T;\n+    type Item = T;\n+    type IntoIter = IntoIter<T>;\n+}\n+\n+struct IntoIter<T> {}\n+\n+impl<T> Iterator for IntoIter<T> {\n+    type Item = T;\n }\n \n fn main() {"}, {"sha": "77fe0dbf5565866dd035718bc009b668cfc0365f", "filename": "crates/ide/src/lib.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fide%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fide%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Flib.rs?ref=e6540cff74534e6d9fb86d5d66e66423fad03766", "patch": "@@ -31,7 +31,6 @@ mod highlight_related;\n mod expand_macro;\n mod extend_selection;\n mod file_structure;\n-mod fn_references;\n mod folding_ranges;\n mod goto_declaration;\n mod goto_definition;\n@@ -236,7 +235,7 @@ impl Analysis {\n             Env::default(),\n             Ok(Vec::new()),\n             false,\n-            CrateOrigin::CratesIo { repo: None },\n+            CrateOrigin::CratesIo { repo: None, name: None },\n         );\n         change.change_file(file_id, Some(Arc::new(text)));\n         change.set_crate_graph(crate_graph);\n@@ -429,11 +428,6 @@ impl Analysis {\n         self.with_db(|db| references::find_all_refs(&Semantics::new(db), position, search_scope))\n     }\n \n-    /// Finds all methods and free functions for the file. Does not return tests!\n-    pub fn find_all_methods(&self, file_id: FileId) -> Cancellable<Vec<FileRange>> {\n-        self.with_db(|db| fn_references::find_all_methods(db, file_id))\n-    }\n-\n     /// Returns a short text describing element at position.\n     pub fn hover(\n         &self,"}, {"sha": "852a8fd837616ab3c0a2fb4c1bdf75e99774fe8d", "filename": "crates/ide/src/moniker.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fide%2Fsrc%2Fmoniker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fide%2Fsrc%2Fmoniker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fmoniker.rs?ref=e6540cff74534e6d9fb86d5d66e66423fad03766", "patch": "@@ -253,10 +253,14 @@ pub(crate) fn def_to_moniker(\n         },\n         kind: if krate == from_crate { MonikerKind::Export } else { MonikerKind::Import },\n         package_information: {\n-            let name = krate.display_name(db)?.to_string();\n-            let (repo, version) = match krate.origin(db) {\n-                CrateOrigin::CratesIo { repo } => (repo?, krate.version(db)?),\n+            let (name, repo, version) = match krate.origin(db) {\n+                CrateOrigin::CratesIo { repo, name } => (\n+                    name.unwrap_or(krate.display_name(db)?.canonical_name().to_string()),\n+                    repo?,\n+                    krate.version(db)?,\n+                ),\n                 CrateOrigin::Lang(lang) => (\n+                    krate.display_name(db)?.canonical_name().to_string(),\n                     \"https://github.com/rust-lang/rust/\".to_string(),\n                     match lang {\n                         LangCrateOrigin::Other => {"}, {"sha": "e7d0a8be7f57316f2ce92ade5164fc4c9e3f996a", "filename": "crates/ide/src/syntax_highlighting/highlight.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fhighlight.rs?ref=e6540cff74534e6d9fb86d5d66e66423fad03766", "patch": "@@ -87,9 +87,9 @@ fn punctuation(\n     let parent = token.parent();\n     let parent_kind = parent.as_ref().map_or(EOF, SyntaxNode::kind);\n     match (kind, parent_kind) {\n-        (T![?], _) => HlTag::Operator(HlOperator::Other) | HlMod::ControlFlow,\n+        (T![?], TRY_EXPR) => HlTag::Operator(HlOperator::Other) | HlMod::ControlFlow,\n         (T![&], BIN_EXPR) => HlOperator::Bitwise.into(),\n-        (T![&], _) => {\n+        (T![&], REF_EXPR) => {\n             let h = HlTag::Operator(HlOperator::Other).into();\n             let is_unsafe = parent\n                 .and_then(ast::RefExpr::cast)\n@@ -100,7 +100,9 @@ fn punctuation(\n                 h\n             }\n         }\n-        (T![::] | T![->] | T![=>] | T![..] | T![=] | T![@] | T![.], _) => HlOperator::Other.into(),\n+        (T![::] | T![->] | T![=>] | T![..] | T![..=] | T![=] | T![@] | T![.], _) => {\n+            HlOperator::Other.into()\n+        }\n         (T![!], MACRO_CALL | MACRO_RULES) => HlPunct::MacroBang.into(),\n         (T![!], NEVER_TYPE) => HlTag::BuiltinType.into(),\n         (T![!], PREFIX_EXPR) => HlOperator::Logical.into(),\n@@ -129,15 +131,14 @@ fn punctuation(\n         (T![+=] | T![-=] | T![*=] | T![/=] | T![%=], BIN_EXPR) => {\n             Highlight::from(HlOperator::Arithmetic) | HlMod::Mutable\n         }\n-        (T![|] | T![&] | T![!] | T![^] | T![>>] | T![<<], BIN_EXPR) => HlOperator::Bitwise.into(),\n+        (T![|] | T![&] | T![^] | T![>>] | T![<<], BIN_EXPR) => HlOperator::Bitwise.into(),\n         (T![|=] | T![&=] | T![^=] | T![>>=] | T![<<=], BIN_EXPR) => {\n             Highlight::from(HlOperator::Bitwise) | HlMod::Mutable\n         }\n         (T![&&] | T![||], BIN_EXPR) => HlOperator::Logical.into(),\n         (T![>] | T![<] | T![==] | T![>=] | T![<=] | T![!=], BIN_EXPR) => {\n             HlOperator::Comparison.into()\n         }\n-        (_, PREFIX_EXPR | BIN_EXPR | RANGE_EXPR | RANGE_PAT | REST_PAT) => HlOperator::Other.into(),\n         (_, ATTR) => HlTag::AttributeBracket.into(),\n         (kind, _) => match kind {\n             T!['['] | T![']'] => HlPunct::Bracket,"}, {"sha": "9ed65fbc8548d1dba4f1a50bbe2d51f175ccc6f8", "filename": "crates/ide/src/syntax_highlighting/test_data/highlight_assoc_functions.html", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftest_data%2Fhighlight_assoc_functions.html", "raw_url": "https://github.com/rust-lang/rust/raw/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftest_data%2Fhighlight_assoc_functions.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftest_data%2Fhighlight_assoc_functions.html?ref=e6540cff74534e6d9fb86d5d66e66423fad03766", "patch": "@@ -48,15 +48,15 @@\n \n <span class=\"keyword\">impl</span> <span class=\"struct\">foo</span> <span class=\"brace\">{</span>\n     <span class=\"keyword\">pub</span> <span class=\"keyword\">fn</span> <span class=\"function associated declaration public static\">is_static</span><span class=\"parenthesis\">(</span><span class=\"parenthesis\">)</span> <span class=\"brace\">{</span><span class=\"brace\">}</span>\n-    <span class=\"keyword\">pub</span> <span class=\"keyword\">fn</span> <span class=\"function associated declaration public reference\">is_not_static</span><span class=\"parenthesis\">(</span><span class=\"operator\">&</span><span class=\"self_keyword declaration reference\">self</span><span class=\"parenthesis\">)</span> <span class=\"brace\">{</span><span class=\"brace\">}</span>\n+    <span class=\"keyword\">pub</span> <span class=\"keyword\">fn</span> <span class=\"function associated declaration public reference\">is_not_static</span><span class=\"parenthesis\">(</span><span class=\"punctuation\">&</span><span class=\"self_keyword declaration reference\">self</span><span class=\"parenthesis\">)</span> <span class=\"brace\">{</span><span class=\"brace\">}</span>\n <span class=\"brace\">}</span>\n \n <span class=\"keyword\">trait</span> <span class=\"trait declaration\">t</span> <span class=\"brace\">{</span>\n     <span class=\"keyword\">fn</span> <span class=\"function associated declaration static trait\">t_is_static</span><span class=\"parenthesis\">(</span><span class=\"parenthesis\">)</span> <span class=\"brace\">{</span><span class=\"brace\">}</span>\n-    <span class=\"keyword\">fn</span> <span class=\"function associated declaration reference trait\">t_is_not_static</span><span class=\"parenthesis\">(</span><span class=\"operator\">&</span><span class=\"self_keyword declaration reference\">self</span><span class=\"parenthesis\">)</span> <span class=\"brace\">{</span><span class=\"brace\">}</span>\n+    <span class=\"keyword\">fn</span> <span class=\"function associated declaration reference trait\">t_is_not_static</span><span class=\"parenthesis\">(</span><span class=\"punctuation\">&</span><span class=\"self_keyword declaration reference\">self</span><span class=\"parenthesis\">)</span> <span class=\"brace\">{</span><span class=\"brace\">}</span>\n <span class=\"brace\">}</span>\n \n <span class=\"keyword\">impl</span> <span class=\"trait\">t</span> <span class=\"keyword\">for</span> <span class=\"struct\">foo</span> <span class=\"brace\">{</span>\n     <span class=\"keyword\">pub</span> <span class=\"keyword\">fn</span> <span class=\"function associated declaration public static trait\">is_static</span><span class=\"parenthesis\">(</span><span class=\"parenthesis\">)</span> <span class=\"brace\">{</span><span class=\"brace\">}</span>\n-    <span class=\"keyword\">pub</span> <span class=\"keyword\">fn</span> <span class=\"function associated declaration public reference trait\">is_not_static</span><span class=\"parenthesis\">(</span><span class=\"operator\">&</span><span class=\"self_keyword declaration reference\">self</span><span class=\"parenthesis\">)</span> <span class=\"brace\">{</span><span class=\"brace\">}</span>\n+    <span class=\"keyword\">pub</span> <span class=\"keyword\">fn</span> <span class=\"function associated declaration public reference trait\">is_not_static</span><span class=\"parenthesis\">(</span><span class=\"punctuation\">&</span><span class=\"self_keyword declaration reference\">self</span><span class=\"parenthesis\">)</span> <span class=\"brace\">{</span><span class=\"brace\">}</span>\n <span class=\"brace\">}</span></code></pre>\n\\ No newline at end of file"}, {"sha": "18045f1f55afdb2742da743e2eabe6f8aff6ab7f", "filename": "crates/ide/src/syntax_highlighting/test_data/highlight_doctest.html", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftest_data%2Fhighlight_doctest.html", "raw_url": "https://github.com/rust-lang/rust/raw/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftest_data%2Fhighlight_doctest.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftest_data%2Fhighlight_doctest.html?ref=e6540cff74534e6d9fb86d5d66e66423fad03766", "patch": "@@ -125,7 +125,7 @@\n     <span class=\"comment documentation\">/// ```sh</span>\n     <span class=\"comment documentation\">/// echo 1</span>\n     <span class=\"comment documentation\">/// ```</span>\n-    <span class=\"keyword\">pub</span> <span class=\"keyword\">fn</span> <span class=\"function associated declaration public reference\">foo</span><span class=\"parenthesis\">(</span><span class=\"operator\">&</span><span class=\"self_keyword declaration reference\">self</span><span class=\"parenthesis\">)</span> <span class=\"operator\">-&gt;</span> <span class=\"builtin_type\">bool</span> <span class=\"brace\">{</span>\n+    <span class=\"keyword\">pub</span> <span class=\"keyword\">fn</span> <span class=\"function associated declaration public reference\">foo</span><span class=\"parenthesis\">(</span><span class=\"punctuation\">&</span><span class=\"self_keyword declaration reference\">self</span><span class=\"parenthesis\">)</span> <span class=\"operator\">-&gt;</span> <span class=\"builtin_type\">bool</span> <span class=\"brace\">{</span>\n         <span class=\"bool_literal\">true</span>\n     <span class=\"brace\">}</span>\n <span class=\"brace\">}</span>"}, {"sha": "9f2b1926b511d270a9ea5e7ad926ec5c51722788", "filename": "crates/ide/src/syntax_highlighting/test_data/highlight_general.html", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftest_data%2Fhighlight_general.html", "raw_url": "https://github.com/rust-lang/rust/raw/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftest_data%2Fhighlight_general.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftest_data%2Fhighlight_general.html?ref=e6540cff74534e6d9fb86d5d66e66423fad03766", "patch": "@@ -61,11 +61,11 @@\n <span class=\"brace\">}</span>\n \n <span class=\"keyword\">trait</span> <span class=\"trait declaration\">Bar</span> <span class=\"brace\">{</span>\n-    <span class=\"keyword\">fn</span> <span class=\"function associated declaration reference trait\">bar</span><span class=\"parenthesis\">(</span><span class=\"operator\">&</span><span class=\"self_keyword declaration reference\">self</span><span class=\"parenthesis\">)</span> <span class=\"operator\">-&gt;</span> <span class=\"builtin_type\">i32</span><span class=\"semicolon\">;</span>\n+    <span class=\"keyword\">fn</span> <span class=\"function associated declaration reference trait\">bar</span><span class=\"parenthesis\">(</span><span class=\"punctuation\">&</span><span class=\"self_keyword declaration reference\">self</span><span class=\"parenthesis\">)</span> <span class=\"operator\">-&gt;</span> <span class=\"builtin_type\">i32</span><span class=\"semicolon\">;</span>\n <span class=\"brace\">}</span>\n \n <span class=\"keyword\">impl</span> <span class=\"trait\">Bar</span> <span class=\"keyword\">for</span> <span class=\"struct\">Foo</span> <span class=\"brace\">{</span>\n-    <span class=\"keyword\">fn</span> <span class=\"function associated declaration reference trait\">bar</span><span class=\"parenthesis\">(</span><span class=\"operator\">&</span><span class=\"self_keyword declaration reference\">self</span><span class=\"parenthesis\">)</span> <span class=\"operator\">-&gt;</span> <span class=\"builtin_type\">i32</span> <span class=\"brace\">{</span>\n+    <span class=\"keyword\">fn</span> <span class=\"function associated declaration reference trait\">bar</span><span class=\"parenthesis\">(</span><span class=\"punctuation\">&</span><span class=\"self_keyword declaration reference\">self</span><span class=\"parenthesis\">)</span> <span class=\"operator\">-&gt;</span> <span class=\"builtin_type\">i32</span> <span class=\"brace\">{</span>\n         <span class=\"self_keyword reference\">self</span><span class=\"operator\">.</span><span class=\"field\">x</span>\n     <span class=\"brace\">}</span>\n <span class=\"brace\">}</span>\n@@ -75,11 +75,11 @@\n         <span class=\"value_param\">f</span><span class=\"operator\">.</span><span class=\"function associated consuming\">baz</span><span class=\"parenthesis\">(</span><span class=\"self_keyword consuming mutable\">self</span><span class=\"parenthesis\">)</span>\n     <span class=\"brace\">}</span>\n \n-    <span class=\"keyword\">fn</span> <span class=\"function associated declaration mutable reference\">qux</span><span class=\"parenthesis\">(</span><span class=\"operator\">&</span><span class=\"keyword\">mut</span> <span class=\"self_keyword declaration mutable reference\">self</span><span class=\"parenthesis\">)</span> <span class=\"brace\">{</span>\n+    <span class=\"keyword\">fn</span> <span class=\"function associated declaration mutable reference\">qux</span><span class=\"parenthesis\">(</span><span class=\"punctuation\">&</span><span class=\"keyword\">mut</span> <span class=\"self_keyword declaration mutable reference\">self</span><span class=\"parenthesis\">)</span> <span class=\"brace\">{</span>\n         <span class=\"self_keyword mutable reference\">self</span><span class=\"operator\">.</span><span class=\"field\">x</span> <span class=\"operator\">=</span> <span class=\"numeric_literal\">0</span><span class=\"semicolon\">;</span>\n     <span class=\"brace\">}</span>\n \n-    <span class=\"keyword\">fn</span> <span class=\"function associated declaration reference\">quop</span><span class=\"parenthesis\">(</span><span class=\"operator\">&</span><span class=\"self_keyword declaration reference\">self</span><span class=\"parenthesis\">)</span> <span class=\"operator\">-&gt;</span> <span class=\"builtin_type\">i32</span> <span class=\"brace\">{</span>\n+    <span class=\"keyword\">fn</span> <span class=\"function associated declaration reference\">quop</span><span class=\"parenthesis\">(</span><span class=\"punctuation\">&</span><span class=\"self_keyword declaration reference\">self</span><span class=\"parenthesis\">)</span> <span class=\"operator\">-&gt;</span> <span class=\"builtin_type\">i32</span> <span class=\"brace\">{</span>\n         <span class=\"self_keyword reference\">self</span><span class=\"operator\">.</span><span class=\"field\">x</span>\n     <span class=\"brace\">}</span>\n <span class=\"brace\">}</span>\n@@ -96,11 +96,11 @@\n         <span class=\"value_param\">f</span><span class=\"operator\">.</span><span class=\"function associated\">baz</span><span class=\"parenthesis\">(</span><span class=\"self_keyword\">self</span><span class=\"parenthesis\">)</span>\n     <span class=\"brace\">}</span>\n \n-    <span class=\"keyword\">fn</span> <span class=\"function associated declaration mutable reference\">qux</span><span class=\"parenthesis\">(</span><span class=\"operator\">&</span><span class=\"keyword\">mut</span> <span class=\"self_keyword declaration mutable reference\">self</span><span class=\"parenthesis\">)</span> <span class=\"brace\">{</span>\n+    <span class=\"keyword\">fn</span> <span class=\"function associated declaration mutable reference\">qux</span><span class=\"parenthesis\">(</span><span class=\"punctuation\">&</span><span class=\"keyword\">mut</span> <span class=\"self_keyword declaration mutable reference\">self</span><span class=\"parenthesis\">)</span> <span class=\"brace\">{</span>\n         <span class=\"self_keyword mutable reference\">self</span><span class=\"operator\">.</span><span class=\"field\">x</span> <span class=\"operator\">=</span> <span class=\"numeric_literal\">0</span><span class=\"semicolon\">;</span>\n     <span class=\"brace\">}</span>\n \n-    <span class=\"keyword\">fn</span> <span class=\"function associated declaration reference\">quop</span><span class=\"parenthesis\">(</span><span class=\"operator\">&</span><span class=\"self_keyword declaration reference\">self</span><span class=\"parenthesis\">)</span> <span class=\"operator\">-&gt;</span> <span class=\"builtin_type\">u32</span> <span class=\"brace\">{</span>\n+    <span class=\"keyword\">fn</span> <span class=\"function associated declaration reference\">quop</span><span class=\"parenthesis\">(</span><span class=\"punctuation\">&</span><span class=\"self_keyword declaration reference\">self</span><span class=\"parenthesis\">)</span> <span class=\"operator\">-&gt;</span> <span class=\"builtin_type\">u32</span> <span class=\"brace\">{</span>\n         <span class=\"self_keyword reference\">self</span><span class=\"operator\">.</span><span class=\"field\">x</span>\n     <span class=\"brace\">}</span>\n <span class=\"brace\">}</span>"}, {"sha": "abcd80c280bf3d072f990b69352e83241544f8c1", "filename": "crates/ide/src/syntax_highlighting/test_data/highlight_injection.html", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftest_data%2Fhighlight_injection.html", "raw_url": "https://github.com/rust-lang/rust/raw/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftest_data%2Fhighlight_injection.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftest_data%2Fhighlight_injection.html?ref=e6540cff74534e6d9fb86d5d66e66423fad03766", "patch": "@@ -42,7 +42,7 @@\n \n .unresolved_reference { color: #FC5555; text-decoration: wavy underline; }\n </style>\n-<pre><code><span class=\"keyword\">fn</span> <span class=\"function declaration\">fixture</span><span class=\"parenthesis\">(</span><span class=\"value_param declaration reference\">ra_fixture</span><span class=\"colon\">:</span> <span class=\"operator\">&</span><span class=\"builtin_type\">str</span><span class=\"parenthesis\">)</span> <span class=\"brace\">{</span><span class=\"brace\">}</span>\n+<pre><code><span class=\"keyword\">fn</span> <span class=\"function declaration\">fixture</span><span class=\"parenthesis\">(</span><span class=\"value_param declaration reference\">ra_fixture</span><span class=\"colon\">:</span> <span class=\"punctuation\">&</span><span class=\"builtin_type\">str</span><span class=\"parenthesis\">)</span> <span class=\"brace\">{</span><span class=\"brace\">}</span>\n \n <span class=\"keyword\">fn</span> <span class=\"function declaration\">main</span><span class=\"parenthesis\">(</span><span class=\"parenthesis\">)</span> <span class=\"brace\">{</span>\n     <span class=\"function\">fixture</span><span class=\"parenthesis\">(</span><span class=\"string_literal\">r#\"</span>"}, {"sha": "f98e0b1cda6e920c6a6b884d366d78f33d5cdff8", "filename": "crates/ide/src/syntax_highlighting/test_data/highlight_lifetimes.html", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftest_data%2Fhighlight_lifetimes.html", "raw_url": "https://github.com/rust-lang/rust/raw/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftest_data%2Fhighlight_lifetimes.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftest_data%2Fhighlight_lifetimes.html?ref=e6540cff74534e6d9fb86d5d66e66423fad03766", "patch": "@@ -45,8 +45,8 @@\n <pre><code>\n <span class=\"attribute_bracket attribute\">#</span><span class=\"attribute_bracket attribute\">[</span><span class=\"attribute attribute default_library library\">derive</span><span class=\"parenthesis attribute\">(</span><span class=\"parenthesis attribute\">)</span><span class=\"attribute_bracket attribute\">]</span>\n <span class=\"keyword\">struct</span> <span class=\"struct declaration\">Foo</span><span class=\"angle\">&lt;</span><span class=\"lifetime declaration\">'a</span><span class=\"comma\">,</span> <span class=\"lifetime declaration\">'b</span><span class=\"comma\">,</span> <span class=\"lifetime declaration\">'c</span><span class=\"angle\">&gt;</span> <span class=\"keyword\">where</span> <span class=\"lifetime\">'a</span><span class=\"colon\">:</span> <span class=\"lifetime\">'a</span><span class=\"comma\">,</span> <span class=\"lifetime\">'static</span><span class=\"colon\">:</span> <span class=\"lifetime\">'static</span> <span class=\"brace\">{</span>\n-    <span class=\"field declaration\">field</span><span class=\"colon\">:</span> <span class=\"operator\">&</span><span class=\"lifetime\">'a</span> <span class=\"parenthesis\">(</span><span class=\"parenthesis\">)</span><span class=\"comma\">,</span>\n-    <span class=\"field declaration\">field2</span><span class=\"colon\">:</span> <span class=\"operator\">&</span><span class=\"lifetime\">'static</span> <span class=\"parenthesis\">(</span><span class=\"parenthesis\">)</span><span class=\"comma\">,</span>\n+    <span class=\"field declaration\">field</span><span class=\"colon\">:</span> <span class=\"punctuation\">&</span><span class=\"lifetime\">'a</span> <span class=\"parenthesis\">(</span><span class=\"parenthesis\">)</span><span class=\"comma\">,</span>\n+    <span class=\"field declaration\">field2</span><span class=\"colon\">:</span> <span class=\"punctuation\">&</span><span class=\"lifetime\">'static</span> <span class=\"parenthesis\">(</span><span class=\"parenthesis\">)</span><span class=\"comma\">,</span>\n <span class=\"brace\">}</span>\n <span class=\"keyword\">impl</span><span class=\"angle\">&lt;</span><span class=\"lifetime declaration\">'a</span><span class=\"angle\">&gt;</span> <span class=\"struct\">Foo</span><span class=\"angle\">&lt;</span><span class=\"lifetime\">'_</span><span class=\"comma\">,</span> <span class=\"lifetime\">'a</span><span class=\"comma\">,</span> <span class=\"lifetime\">'static</span><span class=\"angle\">&gt;</span>\n <span class=\"keyword\">where</span>"}, {"sha": "a626cda3fe8b437c98c09aa9c8f468c2534fa1d0", "filename": "crates/ide/src/syntax_highlighting/test_data/highlight_strings.html", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftest_data%2Fhighlight_strings.html", "raw_url": "https://github.com/rust-lang/rust/raw/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftest_data%2Fhighlight_strings.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftest_data%2Fhighlight_strings.html?ref=e6540cff74534e6d9fb86d5d66e66423fad03766", "patch": "@@ -62,16 +62,16 @@\n         <span class=\"parenthesis\">(</span><span class=\"parenthesis\">)</span> <span class=\"operator\">=</span><span class=\"angle\">&gt;</span> <span class=\"parenthesis\">(</span>\n             <span class=\"punctuation\">$</span>crate<span class=\"colon\">:</span><span class=\"colon\">:</span>panicking<span class=\"colon\">:</span><span class=\"colon\">:</span>panic<span class=\"parenthesis\">(</span><span class=\"string_literal\">\"explicit panic\"</span><span class=\"parenthesis\">)</span>\n         <span class=\"parenthesis\">)</span><span class=\"comma\">,</span>\n-        <span class=\"parenthesis\">(</span><span class=\"punctuation\">$</span>msg<span class=\"colon\">:</span>literal <span class=\"punctuation\">$</span><span class=\"parenthesis\">(</span><span class=\"comma\">,</span><span class=\"parenthesis\">)</span><span class=\"operator control\">?</span><span class=\"parenthesis\">)</span> <span class=\"operator\">=</span><span class=\"angle\">&gt;</span> <span class=\"parenthesis\">(</span>\n+        <span class=\"parenthesis\">(</span><span class=\"punctuation\">$</span>msg<span class=\"colon\">:</span>literal <span class=\"punctuation\">$</span><span class=\"parenthesis\">(</span><span class=\"comma\">,</span><span class=\"parenthesis\">)</span><span class=\"punctuation\">?</span><span class=\"parenthesis\">)</span> <span class=\"operator\">=</span><span class=\"angle\">&gt;</span> <span class=\"parenthesis\">(</span>\n             <span class=\"punctuation\">$</span>crate<span class=\"colon\">:</span><span class=\"colon\">:</span>panicking<span class=\"colon\">:</span><span class=\"colon\">:</span>panic<span class=\"parenthesis\">(</span><span class=\"punctuation\">$</span>msg<span class=\"parenthesis\">)</span>\n         <span class=\"parenthesis\">)</span><span class=\"comma\">,</span>\n         <span class=\"comment\">// Use `panic_str` instead of `panic_display::&lt;&str&gt;` for non_fmt_panic lint.</span>\n-        <span class=\"parenthesis\">(</span><span class=\"punctuation\">$</span>msg<span class=\"colon\">:</span>expr <span class=\"punctuation\">$</span><span class=\"parenthesis\">(</span><span class=\"comma\">,</span><span class=\"parenthesis\">)</span><span class=\"operator control\">?</span><span class=\"parenthesis\">)</span> <span class=\"operator\">=</span><span class=\"angle\">&gt;</span> <span class=\"parenthesis\">(</span>\n+        <span class=\"parenthesis\">(</span><span class=\"punctuation\">$</span>msg<span class=\"colon\">:</span>expr <span class=\"punctuation\">$</span><span class=\"parenthesis\">(</span><span class=\"comma\">,</span><span class=\"parenthesis\">)</span><span class=\"punctuation\">?</span><span class=\"parenthesis\">)</span> <span class=\"operator\">=</span><span class=\"angle\">&gt;</span> <span class=\"parenthesis\">(</span>\n             <span class=\"punctuation\">$</span>crate<span class=\"colon\">:</span><span class=\"colon\">:</span>panicking<span class=\"colon\">:</span><span class=\"colon\">:</span>panic_str<span class=\"parenthesis\">(</span><span class=\"punctuation\">$</span>msg<span class=\"parenthesis\">)</span>\n         <span class=\"parenthesis\">)</span><span class=\"comma\">,</span>\n         <span class=\"comment\">// Special-case the single-argument case for const_panic.</span>\n-        <span class=\"parenthesis\">(</span><span class=\"string_literal\">\"{}\"</span><span class=\"comma\">,</span> <span class=\"punctuation\">$</span>arg<span class=\"colon\">:</span>expr <span class=\"punctuation\">$</span><span class=\"parenthesis\">(</span><span class=\"comma\">,</span><span class=\"parenthesis\">)</span><span class=\"operator control\">?</span><span class=\"parenthesis\">)</span> <span class=\"operator\">=</span><span class=\"angle\">&gt;</span> <span class=\"parenthesis\">(</span>\n-            <span class=\"punctuation\">$</span>crate<span class=\"colon\">:</span><span class=\"colon\">:</span>panicking<span class=\"colon\">:</span><span class=\"colon\">:</span>panic_display<span class=\"parenthesis\">(</span><span class=\"operator\">&</span><span class=\"punctuation\">$</span>arg<span class=\"parenthesis\">)</span>\n+        <span class=\"parenthesis\">(</span><span class=\"string_literal\">\"{}\"</span><span class=\"comma\">,</span> <span class=\"punctuation\">$</span>arg<span class=\"colon\">:</span>expr <span class=\"punctuation\">$</span><span class=\"parenthesis\">(</span><span class=\"comma\">,</span><span class=\"parenthesis\">)</span><span class=\"punctuation\">?</span><span class=\"parenthesis\">)</span> <span class=\"operator\">=</span><span class=\"angle\">&gt;</span> <span class=\"parenthesis\">(</span>\n+            <span class=\"punctuation\">$</span>crate<span class=\"colon\">:</span><span class=\"colon\">:</span>panicking<span class=\"colon\">:</span><span class=\"colon\">:</span>panic_display<span class=\"parenthesis\">(</span><span class=\"punctuation\">&</span><span class=\"punctuation\">$</span>arg<span class=\"parenthesis\">)</span>\n         <span class=\"parenthesis\">)</span><span class=\"comma\">,</span>\n         <span class=\"parenthesis\">(</span><span class=\"punctuation\">$</span>fmt<span class=\"colon\">:</span>expr<span class=\"comma\">,</span> <span class=\"punctuation\">$</span><span class=\"parenthesis\">(</span><span class=\"punctuation\">$</span>arg<span class=\"colon\">:</span>tt<span class=\"parenthesis\">)</span><span class=\"punctuation\">+</span><span class=\"parenthesis\">)</span> <span class=\"operator\">=</span><span class=\"angle\">&gt;</span> <span class=\"parenthesis\">(</span>\n             <span class=\"punctuation\">$</span>crate<span class=\"colon\">:</span><span class=\"colon\">:</span>panicking<span class=\"colon\">:</span><span class=\"colon\">:</span>panic_fmt<span class=\"parenthesis\">(</span><span class=\"punctuation\">$</span>crate<span class=\"colon\">:</span><span class=\"colon\">:</span>const_format_args<span class=\"punctuation\">!</span><span class=\"parenthesis\">(</span><span class=\"punctuation\">$</span>fmt<span class=\"comma\">,</span> <span class=\"punctuation\">$</span><span class=\"parenthesis\">(</span><span class=\"punctuation\">$</span>arg<span class=\"parenthesis\">)</span><span class=\"punctuation\">+</span><span class=\"parenthesis\">)</span><span class=\"parenthesis\">)</span>"}, {"sha": "1992bdc6ae35f3861fbef26415ebdca75be2ae95", "filename": "crates/ide/src/syntax_highlighting/test_data/highlight_unsafe.html", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftest_data%2Fhighlight_unsafe.html", "raw_url": "https://github.com/rust-lang/rust/raw/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftest_data%2Fhighlight_unsafe.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftest_data%2Fhighlight_unsafe.html?ref=e6540cff74534e6d9fb86d5d66e66423fad03766", "patch": "@@ -49,7 +49,7 @@\n <span class=\"brace\">}</span>\n <span class=\"keyword\">macro_rules</span><span class=\"macro_bang\">!</span> <span class=\"macro declaration\">unsafe_deref</span> <span class=\"brace\">{</span>\n     <span class=\"parenthesis\">(</span><span class=\"parenthesis\">)</span> <span class=\"operator\">=</span><span class=\"angle\">&gt;</span> <span class=\"brace\">{</span>\n-        <span class=\"punctuation\">*</span><span class=\"parenthesis\">(</span><span class=\"operator\">&</span><span class=\"parenthesis\">(</span><span class=\"parenthesis\">)</span> <span class=\"keyword\">as</span> <span class=\"punctuation\">*</span><span class=\"keyword\">const</span> <span class=\"parenthesis\">(</span><span class=\"parenthesis\">)</span><span class=\"parenthesis\">)</span>\n+        <span class=\"punctuation\">*</span><span class=\"parenthesis\">(</span><span class=\"punctuation\">&</span><span class=\"parenthesis\">(</span><span class=\"parenthesis\">)</span> <span class=\"keyword\">as</span> <span class=\"punctuation\">*</span><span class=\"keyword\">const</span> <span class=\"parenthesis\">(</span><span class=\"parenthesis\">)</span><span class=\"parenthesis\">)</span>\n     <span class=\"brace\">}</span><span class=\"semicolon\">;</span>\n <span class=\"brace\">}</span>\n <span class=\"keyword\">static</span> <span class=\"keyword\">mut</span> <span class=\"static declaration mutable unsafe\">MUT_GLOBAL</span><span class=\"colon\">:</span> <span class=\"struct\">Struct</span> <span class=\"operator\">=</span> <span class=\"struct\">Struct</span> <span class=\"brace\">{</span> <span class=\"field\">field</span><span class=\"colon\">:</span> <span class=\"numeric_literal\">0</span> <span class=\"brace\">}</span><span class=\"semicolon\">;</span>\n@@ -63,7 +63,7 @@\n \n <span class=\"keyword\">struct</span> <span class=\"struct declaration\">Struct</span> <span class=\"brace\">{</span> <span class=\"field declaration\">field</span><span class=\"colon\">:</span> <span class=\"builtin_type\">i32</span> <span class=\"brace\">}</span>\n <span class=\"keyword\">impl</span> <span class=\"struct\">Struct</span> <span class=\"brace\">{</span>\n-    <span class=\"keyword unsafe\">unsafe</span> <span class=\"keyword\">fn</span> <span class=\"function associated declaration reference unsafe\">unsafe_method</span><span class=\"parenthesis\">(</span><span class=\"operator\">&</span><span class=\"self_keyword declaration reference\">self</span><span class=\"parenthesis\">)</span> <span class=\"brace\">{</span><span class=\"brace\">}</span>\n+    <span class=\"keyword unsafe\">unsafe</span> <span class=\"keyword\">fn</span> <span class=\"function associated declaration reference unsafe\">unsafe_method</span><span class=\"parenthesis\">(</span><span class=\"punctuation\">&</span><span class=\"self_keyword declaration reference\">self</span><span class=\"parenthesis\">)</span> <span class=\"brace\">{</span><span class=\"brace\">}</span>\n <span class=\"brace\">}</span>\n \n <span class=\"attribute_bracket attribute\">#</span><span class=\"attribute_bracket attribute\">[</span><span class=\"builtin_attr attribute library\">repr</span><span class=\"parenthesis attribute\">(</span><span class=\"none attribute\">packed</span><span class=\"parenthesis attribute\">)</span><span class=\"attribute_bracket attribute\">]</span>\n@@ -78,11 +78,11 @@\n <span class=\"keyword\">fn</span> <span class=\"function declaration\">unsafe_trait_bound</span><span class=\"angle\">&lt;</span><span class=\"type_param declaration\">T</span><span class=\"colon\">:</span> <span class=\"trait\">UnsafeTrait</span><span class=\"angle\">&gt;</span><span class=\"parenthesis\">(</span><span class=\"punctuation\">_</span><span class=\"colon\">:</span> <span class=\"type_param\">T</span><span class=\"parenthesis\">)</span> <span class=\"brace\">{</span><span class=\"brace\">}</span>\n \n <span class=\"keyword\">trait</span> <span class=\"trait declaration\">DoTheAutoref</span> <span class=\"brace\">{</span>\n-    <span class=\"keyword\">fn</span> <span class=\"function associated declaration reference trait\">calls_autoref</span><span class=\"parenthesis\">(</span><span class=\"operator\">&</span><span class=\"self_keyword declaration reference\">self</span><span class=\"parenthesis\">)</span><span class=\"semicolon\">;</span>\n+    <span class=\"keyword\">fn</span> <span class=\"function associated declaration reference trait\">calls_autoref</span><span class=\"parenthesis\">(</span><span class=\"punctuation\">&</span><span class=\"self_keyword declaration reference\">self</span><span class=\"parenthesis\">)</span><span class=\"semicolon\">;</span>\n <span class=\"brace\">}</span>\n \n <span class=\"keyword\">impl</span> <span class=\"trait\">DoTheAutoref</span> <span class=\"keyword\">for</span> <span class=\"builtin_type\">u16</span> <span class=\"brace\">{</span>\n-    <span class=\"keyword\">fn</span> <span class=\"function associated declaration reference trait\">calls_autoref</span><span class=\"parenthesis\">(</span><span class=\"operator\">&</span><span class=\"self_keyword declaration reference\">self</span><span class=\"parenthesis\">)</span> <span class=\"brace\">{</span><span class=\"brace\">}</span>\n+    <span class=\"keyword\">fn</span> <span class=\"function associated declaration reference trait\">calls_autoref</span><span class=\"parenthesis\">(</span><span class=\"punctuation\">&</span><span class=\"self_keyword declaration reference\">self</span><span class=\"parenthesis\">)</span> <span class=\"brace\">{</span><span class=\"brace\">}</span>\n <span class=\"brace\">}</span>\n \n <span class=\"keyword\">fn</span> <span class=\"function declaration\">main</span><span class=\"parenthesis\">(</span><span class=\"parenthesis\">)</span> <span class=\"brace\">{</span>"}, {"sha": "243972b04997cc6128a582d3e9b62f18a802655e", "filename": "crates/proc-macro-srv/src/abis/abi_sysroot/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_sysroot%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_sysroot%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_sysroot%2Fmod.rs?ref=e6540cff74534e6d9fb86d5d66e66423fad03766", "patch": "@@ -11,6 +11,8 @@ use proc_macro_api::ProcMacroKind;\n \n use super::PanicMessage;\n \n+pub use ra_server::TokenStream;\n+\n pub(crate) struct Abi {\n     exported_macros: Vec<proc_macro::bridge::client::ProcMacro>,\n }"}, {"sha": "2f854bc1595489e95ebf72041a28fb7c753b0489", "filename": "crates/proc-macro-srv/src/abis/mod.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fmod.rs?ref=e6540cff74534e6d9fb86d5d66e66423fad03766", "patch": "@@ -32,8 +32,8 @@ mod abi_sysroot;\n include!(concat!(env!(\"OUT_DIR\"), \"/rustc_version.rs\"));\n \n // Used by `test/utils.rs`\n-#[cfg(test)]\n-pub(crate) use abi_1_63::TokenStream as TestTokenStream;\n+#[cfg(all(test, feature = \"sysroot-abi\"))]\n+pub(crate) use abi_sysroot::TokenStream as TestTokenStream;\n \n use super::dylib::LoadProcMacroDylibError;\n pub(crate) use abi_1_58::Abi as Abi_1_58;\n@@ -144,3 +144,10 @@ impl Abi {\n         }\n     }\n }\n+\n+#[test]\n+fn test_version_check() {\n+    let path = paths::AbsPathBuf::assert(crate::proc_macro_test_dylib_path());\n+    let info = proc_macro_api::read_dylib_info(&path).unwrap();\n+    assert!(info.version.1 >= 50);\n+}"}, {"sha": "72a2dfe72d3742f24049e2181e070e1159cbc98d", "filename": "crates/proc-macro-srv/src/lib.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fproc-macro-srv%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fproc-macro-srv%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc-macro-srv%2Fsrc%2Flib.rs?ref=e6540cff74534e6d9fb86d5d66e66423fad03766", "patch": "@@ -20,6 +20,8 @@\n mod dylib;\n mod abis;\n \n+pub mod cli;\n+\n use std::{\n     collections::{hash_map::Entry, HashMap},\n     env,\n@@ -149,7 +151,10 @@ impl EnvSnapshot {\n     }\n }\n \n-pub mod cli;\n+#[cfg(all(feature = \"sysroot-abi\", test))]\n+mod tests;\n \n #[cfg(test)]\n-mod tests;\n+pub fn proc_macro_test_dylib_path() -> std::path::PathBuf {\n+    proc_macro_test::PROC_MACRO_TEST_LOCATION.into()\n+}"}, {"sha": "b46cdddcf6b1090314e8fe4b513167cfc77877cc", "filename": "crates/proc-macro-srv/src/tests/mod.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fproc-macro-srv%2Fsrc%2Ftests%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fproc-macro-srv%2Fsrc%2Ftests%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc-macro-srv%2Fsrc%2Ftests%2Fmod.rs?ref=e6540cff74534e6d9fb86d5d66e66423fad03766", "patch": "@@ -2,10 +2,10 @@\n \n #[macro_use]\n mod utils;\n-use expect_test::expect;\n-use paths::AbsPathBuf;\n use utils::*;\n \n+use expect_test::expect;\n+\n #[test]\n fn test_derive_empty() {\n     assert_expand(\"DeriveEmpty\", r#\"struct S;\"#, expect![[r#\"SUBTREE $\"#]]);\n@@ -157,10 +157,3 @@ fn list_test_macros() {\n         DeriveError [CustomDerive]\"#]]\n     .assert_eq(&res);\n }\n-\n-#[test]\n-fn test_version_check() {\n-    let path = AbsPathBuf::assert(fixtures::proc_macro_test_dylib_path());\n-    let info = proc_macro_api::read_dylib_info(&path).unwrap();\n-    assert!(info.version.1 >= 50);\n-}"}, {"sha": "44b1b6588da0a2c2ddddc50af9bdfb1789b92e54", "filename": "crates/proc-macro-srv/src/tests/utils.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fproc-macro-srv%2Fsrc%2Ftests%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fproc-macro-srv%2Fsrc%2Ftests%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc-macro-srv%2Fsrc%2Ftests%2Futils.rs?ref=e6540cff74534e6d9fb86d5d66e66423fad03766", "patch": "@@ -1,15 +1,9 @@\n //! utils used in proc-macro tests\n \n-use crate::dylib;\n-use crate::ProcMacroSrv;\n use expect_test::Expect;\n use std::str::FromStr;\n \n-pub mod fixtures {\n-    pub fn proc_macro_test_dylib_path() -> std::path::PathBuf {\n-        proc_macro_test::PROC_MACRO_TEST_LOCATION.into()\n-    }\n-}\n+use crate::{dylib, proc_macro_test_dylib_path, ProcMacroSrv};\n \n fn parse_string(code: &str) -> Option<crate::abis::TestTokenStream> {\n     // This is a bit strange. We need to parse a string into a token stream into\n@@ -30,7 +24,7 @@ pub fn assert_expand_attr(macro_name: &str, ra_fixture: &str, attr_args: &str, e\n }\n \n fn assert_expand_impl(macro_name: &str, input: &str, attr: Option<&str>, expect: Expect) {\n-    let path = fixtures::proc_macro_test_dylib_path();\n+    let path = proc_macro_test_dylib_path();\n     let expander = dylib::Expander::new(&path).unwrap();\n     let fixture = parse_string(input).unwrap();\n     let attr = attr.map(|attr| parse_string(attr).unwrap().into_subtree());\n@@ -40,7 +34,7 @@ fn assert_expand_impl(macro_name: &str, input: &str, attr: Option<&str>, expect:\n }\n \n pub(crate) fn list() -> Vec<String> {\n-    let dylib_path = fixtures::proc_macro_test_dylib_path();\n+    let dylib_path = proc_macro_test_dylib_path();\n     let mut srv = ProcMacroSrv::default();\n     let res = srv.list_macros(&dylib_path).unwrap();\n     res.into_iter().map(|(name, kind)| format!(\"{} [{:?}]\", name, kind)).collect()"}, {"sha": "32db42f1db75eabcebbd7be69d3dc9d155bfef98", "filename": "crates/project-model/src/build_scripts.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fproject-model%2Fsrc%2Fbuild_scripts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fproject-model%2Fsrc%2Fbuild_scripts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproject-model%2Fsrc%2Fbuild_scripts.rs?ref=e6540cff74534e6d9fb86d5d66e66423fad03766", "patch": "@@ -15,7 +15,7 @@ use rustc_hash::FxHashMap;\n use semver::Version;\n use serde::Deserialize;\n \n-use crate::{cfg_flag::CfgFlag, CargoConfig, CargoWorkspace, Package};\n+use crate::{cfg_flag::CfgFlag, CargoConfig, CargoFeatures, CargoWorkspace, Package};\n \n #[derive(Debug, Default, Clone, PartialEq, Eq)]\n pub struct WorkspaceBuildScripts {\n@@ -49,7 +49,6 @@ impl WorkspaceBuildScripts {\n \n         let mut cmd = Command::new(toolchain::cargo());\n         cmd.envs(&config.extra_env);\n-\n         cmd.args(&[\"check\", \"--quiet\", \"--workspace\", \"--message-format=json\"]);\n \n         // --all-targets includes tests, benches and examples in addition to the\n@@ -61,15 +60,18 @@ impl WorkspaceBuildScripts {\n             cmd.args(&[\"--target\", target]);\n         }\n \n-        if config.all_features {\n-            cmd.arg(\"--all-features\");\n-        } else {\n-            if config.no_default_features {\n-                cmd.arg(\"--no-default-features\");\n+        match &config.features {\n+            CargoFeatures::All => {\n+                cmd.arg(\"--all-features\");\n             }\n-            if !config.features.is_empty() {\n-                cmd.arg(\"--features\");\n-                cmd.arg(config.features.join(\" \"));\n+            CargoFeatures::Selected { features, no_default_features } => {\n+                if *no_default_features {\n+                    cmd.arg(\"--no-default-features\");\n+                }\n+                if !features.is_empty() {\n+                    cmd.arg(\"--features\");\n+                    cmd.arg(features.join(\" \"));\n+                }\n             }\n         }\n "}, {"sha": "8e690f1125a015fd82725255a71bca4b3bbda411", "filename": "crates/project-model/src/cargo_workspace.rs", "status": "modified", "additions": 60, "deletions": 74, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fproject-model%2Fsrc%2Fcargo_workspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fproject-model%2Fsrc%2Fcargo_workspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproject-model%2Fsrc%2Fcargo_workspace.rs?ref=e6540cff74534e6d9fb86d5d66e66423fad03766", "patch": "@@ -71,35 +71,40 @@ impl Default for UnsetTestCrates {\n     }\n }\n \n-#[derive(Default, Clone, Debug, PartialEq, Eq)]\n-pub struct CargoConfig {\n-    /// Do not activate the `default` feature.\n-    pub no_default_features: bool,\n+#[derive(Clone, Debug, PartialEq, Eq)]\n+pub enum CargoFeatures {\n+    All,\n+    Selected {\n+        /// List of features to activate.\n+        features: Vec<String>,\n+        /// Do not activate the `default` feature.\n+        no_default_features: bool,\n+    },\n+}\n \n-    /// Activate all available features\n-    pub all_features: bool,\n+impl Default for CargoFeatures {\n+    fn default() -> Self {\n+        CargoFeatures::Selected { features: vec![], no_default_features: false }\n+    }\n+}\n \n+#[derive(Default, Clone, Debug, PartialEq, Eq)]\n+pub struct CargoConfig {\n     /// List of features to activate.\n-    /// This will be ignored if `cargo_all_features` is true.\n-    pub features: Vec<String>,\n-\n+    pub features: CargoFeatures,\n     /// rustc target\n     pub target: Option<String>,\n-\n-    /// Don't load sysroot crates (`std`, `core` & friends). Might be useful\n-    /// when debugging isolated issues.\n-    pub no_sysroot: bool,\n-\n+    /// Sysroot loading behavior\n+    pub sysroot: Option<RustcSource>,\n     /// rustc private crate source\n     pub rustc_source: Option<RustcSource>,\n-\n     /// crates to disable `#[cfg(test)]` on\n     pub unset_test_crates: UnsetTestCrates,\n-\n+    /// Invoke `cargo check` through the RUSTC_WRAPPER.\n     pub wrap_rustc_in_build_scripts: bool,\n-\n+    /// The command to run instead of `cargo check` for building build scripts.\n     pub run_build_script_command: Option<Vec<String>>,\n-\n+    /// Extra env vars to set when invoking the cargo command\n     pub extra_env: FxHashMap<String, String>,\n }\n \n@@ -143,7 +148,7 @@ pub struct PackageData {\n     pub targets: Vec<Target>,\n     /// Does this package come from the local filesystem (and is editable)?\n     pub is_local: bool,\n-    // Whether this package is a member of the workspace\n+    /// Whether this package is a member of the workspace\n     pub is_member: bool,\n     /// List of packages this package depends on\n     pub dependencies: Vec<PackageDependency>,\n@@ -249,8 +254,8 @@ impl TargetKind {\n     }\n }\n \n+// Deserialize helper for the cargo metadata\n #[derive(Deserialize, Default)]\n-// Deserialise helper for the cargo metadata\n struct PackageMetadata {\n     #[serde(rename = \"rust-analyzer\")]\n     rust_analyzer: Option<RustAnalyzerPackageMetaData>,\n@@ -266,22 +271,25 @@ impl CargoWorkspace {\n         let target = config\n             .target\n             .clone()\n-            .or_else(|| cargo_config_build_target(cargo_toml, config))\n-            .or_else(|| rustc_discover_host_triple(cargo_toml, config));\n+            .or_else(|| cargo_config_build_target(cargo_toml, &config.extra_env))\n+            .or_else(|| rustc_discover_host_triple(cargo_toml, &config.extra_env));\n \n         let mut meta = MetadataCommand::new();\n         meta.cargo_path(toolchain::cargo());\n         meta.manifest_path(cargo_toml.to_path_buf());\n-        if config.all_features {\n-            meta.features(CargoOpt::AllFeatures);\n-        } else {\n-            if config.no_default_features {\n-                // FIXME: `NoDefaultFeatures` is mutual exclusive with `SomeFeatures`\n-                // https://github.com/oli-obk/cargo_metadata/issues/79\n-                meta.features(CargoOpt::NoDefaultFeatures);\n+        match &config.features {\n+            CargoFeatures::All => {\n+                meta.features(CargoOpt::AllFeatures);\n             }\n-            if !config.features.is_empty() {\n-                meta.features(CargoOpt::SomeFeatures(config.features.clone()));\n+            CargoFeatures::Selected { features, no_default_features } => {\n+                if *no_default_features {\n+                    // FIXME: `NoDefaultFeatures` is mutual exclusive with `SomeFeatures`\n+                    // https://github.com/oli-obk/cargo_metadata/issues/79\n+                    meta.features(CargoOpt::NoDefaultFeatures);\n+                }\n+                if !features.is_empty() {\n+                    meta.features(CargoOpt::SomeFeatures(features.clone()));\n+                }\n             }\n         }\n         meta.current_dir(current_dir.as_os_str());\n@@ -295,12 +303,9 @@ impl CargoWorkspace {\n         // unclear whether cargo itself supports it.\n         progress(\"metadata\".to_string());\n \n-        fn exec_with_env(\n-            command: &cargo_metadata::MetadataCommand,\n-            extra_env: &FxHashMap<String, String>,\n-        ) -> Result<cargo_metadata::Metadata, cargo_metadata::Error> {\n-            let mut command = command.cargo_command();\n-            command.envs(extra_env);\n+        (|| -> Result<cargo_metadata::Metadata, cargo_metadata::Error> {\n+            let mut command = meta.cargo_command();\n+            command.envs(&config.extra_env);\n             let output = command.output()?;\n             if !output.status.success() {\n                 return Err(cargo_metadata::Error::CargoMetadata {\n@@ -312,12 +317,8 @@ impl CargoWorkspace {\n                 .find(|line| line.starts_with('{'))\n                 .ok_or(cargo_metadata::Error::NoJson)?;\n             cargo_metadata::MetadataCommand::parse(stdout)\n-        }\n-\n-        let meta = exec_with_env(&meta, &config.extra_env)\n-            .with_context(|| format!(\"Failed to run `{:?}`\", meta.cargo_command()))?;\n-\n-        Ok(meta)\n+        })()\n+        .with_context(|| format!(\"Failed to run `{:?}`\", meta.cargo_command()))\n     }\n \n     pub fn new(mut meta: cargo_metadata::Metadata) -> CargoWorkspace {\n@@ -386,32 +387,14 @@ impl CargoWorkspace {\n         }\n         let resolve = meta.resolve.expect(\"metadata executed with deps\");\n         for mut node in resolve.nodes {\n-            let source = match pkg_by_id.get(&node.id) {\n-                Some(&src) => src,\n-                // FIXME: replace this and a similar branch below with `.unwrap`, once\n-                // https://github.com/rust-lang/cargo/issues/7841\n-                // is fixed and hits stable (around 1.43-is probably?).\n-                None => {\n-                    tracing::error!(\"Node id do not match in cargo metadata, ignoring {}\", node.id);\n-                    continue;\n-                }\n-            };\n+            let &source = pkg_by_id.get(&node.id).unwrap();\n             node.deps.sort_by(|a, b| a.pkg.cmp(&b.pkg));\n-            for (dep_node, kind) in node\n+            let dependencies = node\n                 .deps\n                 .iter()\n-                .flat_map(|dep| DepKind::iter(&dep.dep_kinds).map(move |kind| (dep, kind)))\n-            {\n-                let pkg = match pkg_by_id.get(&dep_node.pkg) {\n-                    Some(&pkg) => pkg,\n-                    None => {\n-                        tracing::error!(\n-                            \"Dep node id do not match in cargo metadata, ignoring {}\",\n-                            dep_node.pkg\n-                        );\n-                        continue;\n-                    }\n-                };\n+                .flat_map(|dep| DepKind::iter(&dep.dep_kinds).map(move |kind| (dep, kind)));\n+            for (dep_node, kind) in dependencies {\n+                let &pkg = pkg_by_id.get(&dep_node.pkg).unwrap();\n                 let dep = PackageDependency { name: dep_node.name.clone(), pkg, kind };\n                 packages[source].dependencies.push(dep);\n             }\n@@ -456,10 +439,7 @@ impl CargoWorkspace {\n                     found = true\n                 }\n                 self[pkg].dependencies.iter().find_map(|dep| {\n-                    if &self[dep.pkg].manifest == manifest_path {\n-                        return Some(self[pkg].manifest.clone());\n-                    }\n-                    None\n+                    (&self[dep.pkg].manifest == manifest_path).then(|| self[pkg].manifest.clone())\n                 })\n             })\n             .collect::<Vec<ManifestPath>>();\n@@ -485,9 +465,12 @@ impl CargoWorkspace {\n     }\n }\n \n-fn rustc_discover_host_triple(cargo_toml: &ManifestPath, config: &CargoConfig) -> Option<String> {\n+fn rustc_discover_host_triple(\n+    cargo_toml: &ManifestPath,\n+    extra_env: &FxHashMap<String, String>,\n+) -> Option<String> {\n     let mut rustc = Command::new(toolchain::rustc());\n-    rustc.envs(&config.extra_env);\n+    rustc.envs(extra_env);\n     rustc.current_dir(cargo_toml.parent()).arg(\"-vV\");\n     tracing::debug!(\"Discovering host platform by {:?}\", rustc);\n     match utf8_stdout(rustc) {\n@@ -509,9 +492,12 @@ fn rustc_discover_host_triple(cargo_toml: &ManifestPath, config: &CargoConfig) -\n     }\n }\n \n-fn cargo_config_build_target(cargo_toml: &ManifestPath, config: &CargoConfig) -> Option<String> {\n+fn cargo_config_build_target(\n+    cargo_toml: &ManifestPath,\n+    extra_env: &FxHashMap<String, String>,\n+) -> Option<String> {\n     let mut cargo_config = Command::new(toolchain::cargo());\n-    cargo_config.envs(&config.extra_env);\n+    cargo_config.envs(extra_env);\n     cargo_config\n         .current_dir(cargo_toml.parent())\n         .args(&[\"-Z\", \"unstable-options\", \"config\", \"get\", \"build.target\"])"}, {"sha": "ce78ce85697afd23170359c5ebf572ca69a93e5a", "filename": "crates/project-model/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fproject-model%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fproject-model%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproject-model%2Fsrc%2Flib.rs?ref=e6540cff74534e6d9fb86d5d66e66423fad03766", "patch": "@@ -42,8 +42,8 @@ use rustc_hash::FxHashSet;\n pub use crate::{\n     build_scripts::WorkspaceBuildScripts,\n     cargo_workspace::{\n-        CargoConfig, CargoWorkspace, Package, PackageData, PackageDependency, RustcSource, Target,\n-        TargetData, TargetKind, UnsetTestCrates,\n+        CargoConfig, CargoFeatures, CargoWorkspace, Package, PackageData, PackageDependency,\n+        RustcSource, Target, TargetData, TargetKind, UnsetTestCrates,\n     },\n     manifest_path::ManifestPath,\n     project_json::{ProjectJson, ProjectJsonData},"}, {"sha": "5133a14d532bb2467934d058678a5dae6bb5bfaf", "filename": "crates/project-model/src/project_json.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fproject-model%2Fsrc%2Fproject_json.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fproject-model%2Fsrc%2Fproject_json.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproject-model%2Fsrc%2Fproject_json.rs?ref=e6540cff74534e6d9fb86d5d66e66423fad03766", "patch": "@@ -110,14 +110,17 @@ impl ProjectJson {\n                 .collect::<Vec<_>>(),\n         }\n     }\n+\n     /// Returns the number of crates in the project.\n     pub fn n_crates(&self) -> usize {\n         self.crates.len()\n     }\n+\n     /// Returns an iterator over the crates in the project.\n     pub fn crates(&self) -> impl Iterator<Item = (CrateId, &Crate)> + '_ {\n         self.crates.iter().enumerate().map(|(idx, krate)| (CrateId(idx as u32), krate))\n     }\n+\n     /// Returns the path to the project's root folder.\n     pub fn path(&self) -> &AbsPath {\n         &self.project_root"}, {"sha": "3231361836634a179171a9367722ecad23da9510", "filename": "crates/project-model/src/rustc_cfg.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fproject-model%2Fsrc%2Frustc_cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fproject-model%2Fsrc%2Frustc_cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproject-model%2Fsrc%2Frustc_cfg.rs?ref=e6540cff74534e6d9fb86d5d66e66423fad03766", "patch": "@@ -3,13 +3,14 @@\n use std::process::Command;\n \n use anyhow::Result;\n+use rustc_hash::FxHashMap;\n \n-use crate::{cfg_flag::CfgFlag, utf8_stdout, CargoConfig, ManifestPath};\n+use crate::{cfg_flag::CfgFlag, utf8_stdout, ManifestPath};\n \n pub(crate) fn get(\n     cargo_toml: Option<&ManifestPath>,\n     target: Option<&str>,\n-    config: &CargoConfig,\n+    extra_env: &FxHashMap<String, String>,\n ) -> Vec<CfgFlag> {\n     let _p = profile::span(\"rustc_cfg::get\");\n     let mut res = Vec::with_capacity(6 * 2 + 1);\n@@ -22,7 +23,7 @@ pub(crate) fn get(\n         }\n     }\n \n-    match get_rust_cfgs(cargo_toml, target, config) {\n+    match get_rust_cfgs(cargo_toml, target, extra_env) {\n         Ok(rustc_cfgs) => {\n             tracing::debug!(\n                 \"rustc cfgs found: {:?}\",\n@@ -42,11 +43,11 @@ pub(crate) fn get(\n fn get_rust_cfgs(\n     cargo_toml: Option<&ManifestPath>,\n     target: Option<&str>,\n-    config: &CargoConfig,\n+    extra_env: &FxHashMap<String, String>,\n ) -> Result<String> {\n     if let Some(cargo_toml) = cargo_toml {\n         let mut cargo_config = Command::new(toolchain::cargo());\n-        cargo_config.envs(&config.extra_env);\n+        cargo_config.envs(extra_env);\n         cargo_config\n             .current_dir(cargo_toml.parent())\n             .args(&[\"-Z\", \"unstable-options\", \"rustc\", \"--print\", \"cfg\"])\n@@ -61,7 +62,7 @@ fn get_rust_cfgs(\n     }\n     // using unstable cargo features failed, fall back to using plain rustc\n     let mut cmd = Command::new(toolchain::rustc());\n-    cmd.envs(&config.extra_env);\n+    cmd.envs(extra_env);\n     cmd.args(&[\"--print\", \"cfg\", \"-O\"]);\n     if let Some(target) = target {\n         cmd.args(&[\"--target\", target]);"}, {"sha": "bc37e3d132a6ce6f70da3ab54cf3abe4a89f3091", "filename": "crates/project-model/src/sysroot.rs", "status": "modified", "additions": 44, "deletions": 21, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fproject-model%2Fsrc%2Fsysroot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fproject-model%2Fsrc%2Fsysroot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproject-model%2Fsrc%2Fsysroot.rs?ref=e6540cff74534e6d9fb86d5d66e66423fad03766", "patch": "@@ -9,8 +9,9 @@ use std::{env, fs, iter, ops, path::PathBuf, process::Command};\n use anyhow::{format_err, Result};\n use la_arena::{Arena, Idx};\n use paths::{AbsPath, AbsPathBuf};\n+use rustc_hash::FxHashMap;\n \n-use crate::{utf8_stdout, CargoConfig, ManifestPath};\n+use crate::{utf8_stdout, ManifestPath};\n \n #[derive(Debug, Clone, Eq, PartialEq)]\n pub struct Sysroot {\n@@ -66,23 +67,37 @@ impl Sysroot {\n     pub fn crates<'a>(&'a self) -> impl Iterator<Item = SysrootCrate> + ExactSizeIterator + 'a {\n         self.crates.iter().map(|(id, _data)| id)\n     }\n+}\n \n-    pub fn discover(dir: &AbsPath, config: &CargoConfig) -> Result<Sysroot> {\n+impl Sysroot {\n+    pub fn discover(dir: &AbsPath, extra_env: &FxHashMap<String, String>) -> Result<Sysroot> {\n         tracing::debug!(\"Discovering sysroot for {}\", dir.display());\n-        let sysroot_dir = discover_sysroot_dir(dir, config)?;\n-        let sysroot_src_dir = discover_sysroot_src_dir(&sysroot_dir, dir, config)?;\n+        let sysroot_dir = discover_sysroot_dir(dir, extra_env)?;\n+        let sysroot_src_dir =\n+            discover_sysroot_src_dir_or_add_component(&sysroot_dir, dir, extra_env)?;\n         let res = Sysroot::load(sysroot_dir, sysroot_src_dir)?;\n         Ok(res)\n     }\n \n-    pub fn discover_rustc(cargo_toml: &ManifestPath, config: &CargoConfig) -> Option<ManifestPath> {\n+    pub fn discover_rustc(\n+        cargo_toml: &ManifestPath,\n+        extra_env: &FxHashMap<String, String>,\n+    ) -> Option<ManifestPath> {\n         tracing::debug!(\"Discovering rustc source for {}\", cargo_toml.display());\n         let current_dir = cargo_toml.parent();\n-        discover_sysroot_dir(current_dir, config)\n+        discover_sysroot_dir(current_dir, extra_env)\n             .ok()\n             .and_then(|sysroot_dir| get_rustc_src(&sysroot_dir))\n     }\n \n+    pub fn with_sysroot_dir(sysroot_dir: AbsPathBuf) -> Result<Sysroot> {\n+        let sysroot_src_dir = discover_sysroot_src_dir(&sysroot_dir).ok_or_else(|| {\n+            format_err!(\"can't load standard library from sysroot {}\", sysroot_dir.display())\n+        })?;\n+        let res = Sysroot::load(sysroot_dir, sysroot_src_dir)?;\n+        Ok(res)\n+    }\n+\n     pub fn load(sysroot_dir: AbsPathBuf, sysroot_src_dir: AbsPathBuf) -> Result<Sysroot> {\n         let mut sysroot =\n             Sysroot { root: sysroot_dir, src_root: sysroot_src_dir, crates: Arena::default() };\n@@ -146,35 +161,43 @@ impl Sysroot {\n     }\n }\n \n-fn discover_sysroot_dir(current_dir: &AbsPath, config: &CargoConfig) -> Result<AbsPathBuf> {\n+fn discover_sysroot_dir(\n+    current_dir: &AbsPath,\n+    extra_env: &FxHashMap<String, String>,\n+) -> Result<AbsPathBuf> {\n     let mut rustc = Command::new(toolchain::rustc());\n-    rustc.envs(&config.extra_env);\n+    rustc.envs(extra_env);\n     rustc.current_dir(current_dir).args(&[\"--print\", \"sysroot\"]);\n     tracing::debug!(\"Discovering sysroot by {:?}\", rustc);\n     let stdout = utf8_stdout(rustc)?;\n     Ok(AbsPathBuf::assert(PathBuf::from(stdout)))\n }\n \n-fn discover_sysroot_src_dir(\n-    sysroot_path: &AbsPathBuf,\n-    current_dir: &AbsPath,\n-    config: &CargoConfig,\n-) -> Result<AbsPathBuf> {\n+fn discover_sysroot_src_dir(sysroot_path: &AbsPathBuf) -> Option<AbsPathBuf> {\n     if let Ok(path) = env::var(\"RUST_SRC_PATH\") {\n-        let path = AbsPathBuf::try_from(path.as_str())\n-            .map_err(|path| format_err!(\"RUST_SRC_PATH must be absolute: {}\", path.display()))?;\n-        let core = path.join(\"core\");\n-        if fs::metadata(&core).is_ok() {\n-            tracing::debug!(\"Discovered sysroot by RUST_SRC_PATH: {}\", path.display());\n-            return Ok(path);\n+        if let Ok(path) = AbsPathBuf::try_from(path.as_str()) {\n+            let core = path.join(\"core\");\n+            if fs::metadata(&core).is_ok() {\n+                tracing::debug!(\"Discovered sysroot by RUST_SRC_PATH: {}\", path.display());\n+                return Some(path);\n+            }\n+            tracing::debug!(\"RUST_SRC_PATH is set, but is invalid (no core: {:?}), ignoring\", core);\n+        } else {\n+            tracing::debug!(\"RUST_SRC_PATH is set, but is invalid, ignoring\");\n         }\n-        tracing::debug!(\"RUST_SRC_PATH is set, but is invalid (no core: {:?}), ignoring\", core);\n     }\n \n     get_rust_src(sysroot_path)\n+}\n+fn discover_sysroot_src_dir_or_add_component(\n+    sysroot_path: &AbsPathBuf,\n+    current_dir: &AbsPath,\n+    extra_env: &FxHashMap<String, String>,\n+) -> Result<AbsPathBuf> {\n+    discover_sysroot_src_dir(sysroot_path)\n         .or_else(|| {\n             let mut rustup = Command::new(toolchain::rustup());\n-            rustup.envs(&config.extra_env);\n+            rustup.envs(extra_env);\n             rustup.current_dir(current_dir).args(&[\"component\", \"add\", \"rust-src\"]);\n             utf8_stdout(rustup).ok()?;\n             get_rust_src(sysroot_path)"}, {"sha": "e2444e24974a75fcdf163dd0e4764f051f4731cf", "filename": "crates/project-model/src/tests.rs", "status": "modified", "additions": 51, "deletions": 3, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fproject-model%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fproject-model%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproject-model%2Fsrc%2Ftests.rs?ref=e6540cff74534e6d9fb86d5d66e66423fad03766", "patch": "@@ -10,8 +10,8 @@ use paths::{AbsPath, AbsPathBuf};\n use serde::de::DeserializeOwned;\n \n use crate::{\n-    CargoConfig, CargoWorkspace, CfgOverrides, ProjectJson, ProjectJsonData, ProjectWorkspace,\n-    Sysroot, WorkspaceBuildScripts,\n+    CargoWorkspace, CfgOverrides, ProjectJson, ProjectJsonData, ProjectWorkspace, Sysroot,\n+    WorkspaceBuildScripts,\n };\n \n fn load_cargo(file: &str) -> CrateGraph {\n@@ -101,7 +101,7 @@ fn to_crate_graph(project_workspace: ProjectWorkspace) -> CrateGraph {\n                 Some(FileId(counter))\n             }\n         },\n-        &CargoConfig::default(),\n+        &Default::default(),\n     )\n }\n \n@@ -185,6 +185,9 @@ fn cargo_hello_world_project_model_with_wildcard_overrides() {\n                         ),\n                         origin: CratesIo {\n                             repo: None,\n+                            name: Some(\n+                                \"hello-world\",\n+                            ),\n                         },\n                         is_proc_macro: false,\n                     },\n@@ -260,6 +263,9 @@ fn cargo_hello_world_project_model_with_wildcard_overrides() {\n                         ),\n                         origin: CratesIo {\n                             repo: None,\n+                            name: Some(\n+                                \"hello-world\",\n+                            ),\n                         },\n                         is_proc_macro: false,\n                     },\n@@ -335,6 +341,9 @@ fn cargo_hello_world_project_model_with_wildcard_overrides() {\n                         ),\n                         origin: CratesIo {\n                             repo: None,\n+                            name: Some(\n+                                \"hello-world\",\n+                            ),\n                         },\n                         is_proc_macro: false,\n                     },\n@@ -410,6 +419,9 @@ fn cargo_hello_world_project_model_with_wildcard_overrides() {\n                         ),\n                         origin: CratesIo {\n                             repo: None,\n+                            name: Some(\n+                                \"hello-world\",\n+                            ),\n                         },\n                         is_proc_macro: false,\n                     },\n@@ -477,6 +489,9 @@ fn cargo_hello_world_project_model_with_wildcard_overrides() {\n                             repo: Some(\n                                 \"https://github.com/rust-lang/libc\",\n                             ),\n+                            name: Some(\n+                                \"libc\",\n+                            ),\n                         },\n                         is_proc_macro: false,\n                     },\n@@ -567,6 +582,9 @@ fn cargo_hello_world_project_model_with_selective_overrides() {\n                         ),\n                         origin: CratesIo {\n                             repo: None,\n+                            name: Some(\n+                                \"hello-world\",\n+                            ),\n                         },\n                         is_proc_macro: false,\n                     },\n@@ -644,6 +662,9 @@ fn cargo_hello_world_project_model_with_selective_overrides() {\n                         ),\n                         origin: CratesIo {\n                             repo: None,\n+                            name: Some(\n+                                \"hello-world\",\n+                            ),\n                         },\n                         is_proc_macro: false,\n                     },\n@@ -721,6 +742,9 @@ fn cargo_hello_world_project_model_with_selective_overrides() {\n                         ),\n                         origin: CratesIo {\n                             repo: None,\n+                            name: Some(\n+                                \"hello-world\",\n+                            ),\n                         },\n                         is_proc_macro: false,\n                     },\n@@ -798,6 +822,9 @@ fn cargo_hello_world_project_model_with_selective_overrides() {\n                         ),\n                         origin: CratesIo {\n                             repo: None,\n+                            name: Some(\n+                                \"hello-world\",\n+                            ),\n                         },\n                         is_proc_macro: false,\n                     },\n@@ -865,6 +892,9 @@ fn cargo_hello_world_project_model_with_selective_overrides() {\n                             repo: Some(\n                                 \"https://github.com/rust-lang/libc\",\n                             ),\n+                            name: Some(\n+                                \"libc\",\n+                            ),\n                         },\n                         is_proc_macro: false,\n                     },\n@@ -946,6 +976,9 @@ fn cargo_hello_world_project_model() {\n                         ),\n                         origin: CratesIo {\n                             repo: None,\n+                            name: Some(\n+                                \"hello-world\",\n+                            ),\n                         },\n                         is_proc_macro: false,\n                     },\n@@ -1023,6 +1056,9 @@ fn cargo_hello_world_project_model() {\n                         ),\n                         origin: CratesIo {\n                             repo: None,\n+                            name: Some(\n+                                \"hello-world\",\n+                            ),\n                         },\n                         is_proc_macro: false,\n                     },\n@@ -1100,6 +1136,9 @@ fn cargo_hello_world_project_model() {\n                         ),\n                         origin: CratesIo {\n                             repo: None,\n+                            name: Some(\n+                                \"hello-world\",\n+                            ),\n                         },\n                         is_proc_macro: false,\n                     },\n@@ -1177,6 +1216,9 @@ fn cargo_hello_world_project_model() {\n                         ),\n                         origin: CratesIo {\n                             repo: None,\n+                            name: Some(\n+                                \"hello-world\",\n+                            ),\n                         },\n                         is_proc_macro: false,\n                     },\n@@ -1244,6 +1286,9 @@ fn cargo_hello_world_project_model() {\n                             repo: Some(\n                                 \"https://github.com/rust-lang/libc\",\n                             ),\n+                            name: Some(\n+                                \"libc\",\n+                            ),\n                         },\n                         is_proc_macro: false,\n                     },\n@@ -1804,6 +1849,9 @@ fn rust_project_hello_world_project_model() {\n                         ),\n                         origin: CratesIo {\n                             repo: None,\n+                            name: Some(\n+                                \"hello_world\",\n+                            ),\n                         },\n                         is_proc_macro: false,\n                     },"}, {"sha": "72ddf809288aa35338ac2a283db0ed30336cd677", "filename": "crates/project-model/src/workspace.rs", "status": "modified", "additions": 77, "deletions": 55, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fproject-model%2Fsrc%2Fworkspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fproject-model%2Fsrc%2Fworkspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproject-model%2Fsrc%2Fworkspace.rs?ref=e6540cff74534e6d9fb86d5d66e66423fad03766", "patch": "@@ -21,8 +21,8 @@ use crate::{\n     cfg_flag::CfgFlag,\n     rustc_cfg,\n     sysroot::SysrootCrate,\n-    utf8_stdout, CargoConfig, CargoWorkspace, ManifestPath, ProjectJson, ProjectManifest, Sysroot,\n-    TargetKind, WorkspaceBuildScripts,\n+    utf8_stdout, CargoConfig, CargoWorkspace, ManifestPath, Package, ProjectJson, ProjectManifest,\n+    Sysroot, TargetKind, WorkspaceBuildScripts,\n };\n \n /// A set of cfg-overrides per crate.\n@@ -156,7 +156,11 @@ impl ProjectWorkspace {\n                 })?;\n                 let project_location = project_json.parent().to_path_buf();\n                 let project_json = ProjectJson::new(&project_location, data);\n-                ProjectWorkspace::load_inline(project_json, config.target.as_deref(), config)?\n+                ProjectWorkspace::load_inline(\n+                    project_json,\n+                    config.target.as_deref(),\n+                    &config.extra_env,\n+                )?\n             }\n             ProjectManifest::CargoToml(cargo_toml) => {\n                 let cargo_version = utf8_stdout({\n@@ -184,20 +188,33 @@ impl ProjectWorkspace {\n                 })?;\n                 let cargo = CargoWorkspace::new(meta);\n \n-                let sysroot = if config.no_sysroot {\n-                    None\n-                } else {\n-                    Some(Sysroot::discover(cargo_toml.parent(), config).with_context(|| {\n-                        format!(\n+                let sysroot = match &config.sysroot {\n+                    Some(RustcSource::Path(path)) => {\n+                        Some(Sysroot::with_sysroot_dir(path.clone()).with_context(|| {\n+                            format!(\n+                                \"Failed to find sysroot for Cargo.toml file {}.\",\n+                                cargo_toml.display()\n+                            )\n+                        })?)\n+                    }\n+                    Some(RustcSource::Discover) => Some(\n+                        Sysroot::discover(cargo_toml.parent(), &config.extra_env).with_context(\n+                            || {\n+                                format!(\n                             \"Failed to find sysroot for Cargo.toml file {}. Is rust-src installed?\",\n                             cargo_toml.display()\n                         )\n-                    })?)\n+                            },\n+                        )?,\n+                    ),\n+                    None => None,\n                 };\n \n                 let rustc_dir = match &config.rustc_source {\n                     Some(RustcSource::Path(path)) => ManifestPath::try_from(path.clone()).ok(),\n-                    Some(RustcSource::Discover) => Sysroot::discover_rustc(&cargo_toml, config),\n+                    Some(RustcSource::Discover) => {\n+                        Sysroot::discover_rustc(&cargo_toml, &config.extra_env)\n+                    }\n                     None => None,\n                 };\n \n@@ -217,7 +234,8 @@ impl ProjectWorkspace {\n                     None => None,\n                 };\n \n-                let rustc_cfg = rustc_cfg::get(Some(&cargo_toml), config.target.as_deref(), config);\n+                let rustc_cfg =\n+                    rustc_cfg::get(Some(&cargo_toml), config.target.as_deref(), &config.extra_env);\n \n                 let cfg_overrides = config.cfg_overrides();\n                 ProjectWorkspace::Cargo {\n@@ -238,7 +256,7 @@ impl ProjectWorkspace {\n     pub fn load_inline(\n         project_json: ProjectJson,\n         target: Option<&str>,\n-        config: &CargoConfig,\n+        extra_env: &FxHashMap<String, String>,\n     ) -> Result<ProjectWorkspace> {\n         let sysroot = match (project_json.sysroot.clone(), project_json.sysroot_src.clone()) {\n             (Some(sysroot), Some(sysroot_src)) => Some(Sysroot::load(sysroot, sysroot_src)?),\n@@ -260,7 +278,7 @@ impl ProjectWorkspace {\n             (None, None) => None,\n         };\n \n-        let rustc_cfg = rustc_cfg::get(None, target, config);\n+        let rustc_cfg = rustc_cfg::get(None, target, extra_env);\n         Ok(ProjectWorkspace::Json { project: project_json, sysroot, rustc_cfg })\n     }\n \n@@ -270,9 +288,9 @@ impl ProjectWorkspace {\n                 .first()\n                 .and_then(|it| it.parent())\n                 .ok_or_else(|| format_err!(\"No detached files to load\"))?,\n-            &CargoConfig::default(),\n+            &Default::default(),\n         )?;\n-        let rustc_cfg = rustc_cfg::get(None, None, &CargoConfig::default());\n+        let rustc_cfg = rustc_cfg::get(None, None, &Default::default());\n         Ok(ProjectWorkspace::DetachedFiles { files: detached_files, sysroot, rustc_cfg })\n     }\n \n@@ -306,6 +324,13 @@ impl ProjectWorkspace {\n     /// The return type contains the path and whether or not\n     /// the root is a member of the current workspace\n     pub fn to_roots(&self) -> Vec<PackageRoot> {\n+        let mk_sysroot = |sysroot: Option<&Sysroot>| {\n+            sysroot.map(|sysroot| PackageRoot {\n+                is_local: false,\n+                include: vec![sysroot.src_root().to_path_buf()],\n+                exclude: Vec::new(),\n+            })\n+        };\n         match self {\n             ProjectWorkspace::Json { project, sysroot, rustc_cfg: _ } => project\n                 .crates()\n@@ -316,13 +341,7 @@ impl ProjectWorkspace {\n                 })\n                 .collect::<FxHashSet<_>>()\n                 .into_iter()\n-                .chain(sysroot.as_ref().into_iter().flat_map(|sysroot| {\n-                    sysroot.crates().map(move |krate| PackageRoot {\n-                        is_local: false,\n-                        include: vec![sysroot[krate].root.parent().to_path_buf()],\n-                        exclude: Vec::new(),\n-                    })\n-                }))\n+                .chain(mk_sysroot(sysroot.as_ref()))\n                 .collect::<Vec<_>>(),\n             ProjectWorkspace::Cargo {\n                 cargo,\n@@ -371,11 +390,7 @@ impl ProjectWorkspace {\n                         }\n                         PackageRoot { is_local, include, exclude }\n                     })\n-                    .chain(sysroot.iter().map(|sysroot| PackageRoot {\n-                        is_local: false,\n-                        include: vec![sysroot.src_root().to_path_buf()],\n-                        exclude: Vec::new(),\n-                    }))\n+                    .chain(mk_sysroot(sysroot.as_ref()))\n                     .chain(rustc.iter().flat_map(|rustc| {\n                         rustc.packages().map(move |krate| PackageRoot {\n                             is_local: false,\n@@ -392,11 +407,7 @@ impl ProjectWorkspace {\n                     include: vec![detached_file.clone()],\n                     exclude: Vec::new(),\n                 })\n-                .chain(sysroot.crates().map(|krate| PackageRoot {\n-                    is_local: false,\n-                    include: vec![sysroot[krate].root.parent().to_path_buf()],\n-                    exclude: Vec::new(),\n-                }))\n+                .chain(mk_sysroot(Some(sysroot)))\n                 .collect(),\n         }\n     }\n@@ -419,7 +430,7 @@ impl ProjectWorkspace {\n         &self,\n         load_proc_macro: &mut dyn FnMut(&str, &AbsPath) -> ProcMacroLoadResult,\n         load: &mut dyn FnMut(&AbsPath) -> Option<FileId>,\n-        config: &CargoConfig,\n+        extra_env: &FxHashMap<String, String>,\n     ) -> CrateGraph {\n         let _p = profile::span(\"ProjectWorkspace::to_crate_graph\");\n \n@@ -430,7 +441,7 @@ impl ProjectWorkspace {\n                 load,\n                 project,\n                 sysroot,\n-                config,\n+                extra_env,\n             ),\n             ProjectWorkspace::Cargo {\n                 cargo,\n@@ -469,7 +480,7 @@ fn project_json_to_crate_graph(\n     load: &mut dyn FnMut(&AbsPath) -> Option<FileId>,\n     project: &ProjectJson,\n     sysroot: &Option<Sysroot>,\n-    config: &CargoConfig,\n+    extra_env: &FxHashMap<String, String>,\n ) -> CrateGraph {\n     let mut crate_graph = CrateGraph::default();\n     let sysroot_deps = sysroot\n@@ -497,7 +508,7 @@ fn project_json_to_crate_graph(\n             let target_cfgs = match krate.target.as_deref() {\n                 Some(target) => cfg_cache\n                     .entry(target)\n-                    .or_insert_with(|| rustc_cfg::get(None, Some(target), config)),\n+                    .or_insert_with(|| rustc_cfg::get(None, Some(target), extra_env)),\n                 None => &rustc_cfg,\n             };\n \n@@ -516,9 +527,15 @@ fn project_json_to_crate_graph(\n                     proc_macro,\n                     krate.is_proc_macro,\n                     if krate.display_name.is_some() {\n-                        CrateOrigin::CratesIo { repo: krate.repository.clone() }\n+                        CrateOrigin::CratesIo {\n+                            repo: krate.repository.clone(),\n+                            name: krate\n+                                .display_name\n+                                .clone()\n+                                .map(|n| n.canonical_name().to_string()),\n+                        }\n                     } else {\n-                        CrateOrigin::CratesIo { repo: None }\n+                        CrateOrigin::CratesIo { repo: None, name: None }\n                     },\n                 ),\n             )\n@@ -630,6 +647,8 @@ fn cargo_to_crate_graph(\n                     lib_tgt = Some((crate_id, cargo[tgt].name.clone()));\n                     pkg_to_lib_crate.insert(pkg, crate_id);\n                 }\n+                // Even crates that don't set proc-macro = true are allowed to depend on proc_macro\n+                // (just none of the APIs work when called outside of a proc macro).\n                 if let Some(proc_macro) = libproc_macro {\n                     add_dep_with_prelude(\n                         &mut crate_graph,\n@@ -645,19 +664,19 @@ fn cargo_to_crate_graph(\n         }\n \n         // Set deps to the core, std and to the lib target of the current package\n-        for (from, kind) in pkg_crates.get(&pkg).into_iter().flatten() {\n+        for &(from, kind) in pkg_crates.get(&pkg).into_iter().flatten() {\n             // Add sysroot deps first so that a lib target named `core` etc. can overwrite them.\n-            public_deps.add(*from, &mut crate_graph);\n+            public_deps.add(from, &mut crate_graph);\n \n             if let Some((to, name)) = lib_tgt.clone() {\n-                if to != *from && *kind != TargetKind::BuildScript {\n+                if to != from && kind != TargetKind::BuildScript {\n                     // (build script can not depend on its library target)\n \n                     // For root projects with dashes in their name,\n                     // cargo metadata does not do any normalization,\n                     // so we do it ourselves currently\n                     let name = CrateName::normalize_dashes(&name);\n-                    add_dep(&mut crate_graph, *from, name, to);\n+                    add_dep(&mut crate_graph, from, name, to);\n                 }\n             }\n         }\n@@ -669,17 +688,17 @@ fn cargo_to_crate_graph(\n         for dep in cargo[pkg].dependencies.iter() {\n             let name = CrateName::new(&dep.name).unwrap();\n             if let Some(&to) = pkg_to_lib_crate.get(&dep.pkg) {\n-                for (from, kind) in pkg_crates.get(&pkg).into_iter().flatten() {\n-                    if dep.kind == DepKind::Build && *kind != TargetKind::BuildScript {\n+                for &(from, kind) in pkg_crates.get(&pkg).into_iter().flatten() {\n+                    if dep.kind == DepKind::Build && kind != TargetKind::BuildScript {\n                         // Only build scripts may depend on build dependencies.\n                         continue;\n                     }\n-                    if dep.kind != DepKind::Build && *kind == TargetKind::BuildScript {\n+                    if dep.kind != DepKind::Build && kind == TargetKind::BuildScript {\n                         // Build scripts may only depend on build dependencies.\n                         continue;\n                     }\n \n-                    add_dep(&mut crate_graph, *from, name.clone(), to)\n+                    add_dep(&mut crate_graph, from, name.clone(), to)\n                 }\n             }\n         }\n@@ -690,9 +709,9 @@ fn cargo_to_crate_graph(\n         // and create dependencies on them for the crates which opt-in to that\n         if let Some(rustc_workspace) = rustc {\n             handle_rustc_crates(\n+                &mut crate_graph,\n                 rustc_workspace,\n                 load,\n-                &mut crate_graph,\n                 &cfg_options,\n                 override_cfg,\n                 load_proc_macro,\n@@ -736,14 +755,17 @@ fn detached_files_to_crate_graph(\n         let detached_file_crate = crate_graph.add_crate_root(\n             file_id,\n             Edition::CURRENT,\n-            display_name,\n+            display_name.clone(),\n             None,\n             cfg_options.clone(),\n             cfg_options.clone(),\n             Env::default(),\n             Ok(Vec::new()),\n             false,\n-            CrateOrigin::CratesIo { repo: None },\n+            CrateOrigin::CratesIo {\n+                repo: None,\n+                name: display_name.map(|n| n.canonical_name().to_string()),\n+            },\n         );\n \n         public_deps.add(detached_file_crate, &mut crate_graph);\n@@ -752,16 +774,16 @@ fn detached_files_to_crate_graph(\n }\n \n fn handle_rustc_crates(\n+    crate_graph: &mut CrateGraph,\n     rustc_workspace: &CargoWorkspace,\n     load: &mut dyn FnMut(&AbsPath) -> Option<FileId>,\n-    crate_graph: &mut CrateGraph,\n     cfg_options: &CfgOptions,\n     override_cfg: &CfgOverrides,\n     load_proc_macro: &mut dyn FnMut(&str, &AbsPath) -> ProcMacroLoadResult,\n-    pkg_to_lib_crate: &mut FxHashMap<la_arena::Idx<crate::PackageData>, CrateId>,\n+    pkg_to_lib_crate: &mut FxHashMap<Package, CrateId>,\n     public_deps: &SysrootPublicDeps,\n     cargo: &CargoWorkspace,\n-    pkg_crates: &FxHashMap<la_arena::Idx<crate::PackageData>, Vec<(CrateId, TargetKind)>>,\n+    pkg_crates: &FxHashMap<Package, Vec<(CrateId, TargetKind)>>,\n     build_scripts: &WorkspaceBuildScripts,\n ) {\n     let mut rustc_pkg_crates = FxHashMap::default();\n@@ -775,8 +797,8 @@ fn handle_rustc_crates(\n         let mut queue = VecDeque::new();\n         queue.push_back(root_pkg);\n         while let Some(pkg) = queue.pop_front() {\n-            // Don't duplicate packages if they are dependended on a diamond pattern\n-            // N.B. if this line is omitted, we try to analyse over 4_800_000 crates\n+            // Don't duplicate packages if they are dependent on a diamond pattern\n+            // N.B. if this line is omitted, we try to analyze over 4_800_000 crates\n             // which is not ideal\n             if rustc_pkg_crates.contains_key(&pkg) {\n                 continue;\n@@ -919,7 +941,7 @@ fn add_target_crate_root(\n         env,\n         proc_macro,\n         is_proc_macro,\n-        CrateOrigin::CratesIo { repo: pkg.repository.clone() },\n+        CrateOrigin::CratesIo { repo: pkg.repository.clone(), name: Some(pkg.name.clone()) },\n     )\n }\n "}, {"sha": "a4e6550984ee8b577a8a581f96072b7867cb5d70", "filename": "crates/rust-analyzer/Cargo.toml", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Frust-analyzer%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Frust-analyzer%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2FCargo.toml?ref=e6540cff74534e6d9fb86d5d66e66423fad03766", "patch": "@@ -25,7 +25,7 @@ itertools = \"0.10.3\"\n scip = \"0.1.1\"\n lsp-types = { version = \"0.93.1\", features = [\"proposed\"] }\n parking_lot = \"0.12.1\"\n-xflags = \"0.2.4\"\n+xflags = \"0.3.0\"\n oorandom = \"11.1.3\"\n rustc-hash = \"1.1.0\"\n serde = { version = \"1.0.137\", features = [\"derive\"] }\n@@ -34,7 +34,7 @@ threadpool = \"1.8.1\"\n rayon = \"1.5.3\"\n num_cpus = \"1.13.1\"\n mimalloc = { version = \"0.1.29\", default-features = false, optional = true }\n-lsp-server = { version = \"0.6.0\", path = \"../../lib/lsp-server\" }\n+lsp-server = { version = \"0.7.0\", path = \"../../lib/lsp-server\" }\n tracing = \"0.1.35\"\n tracing-subscriber = { version = \"0.3.14\", default-features = false, features = [\n     \"env-filter\",\n@@ -87,7 +87,6 @@ jemalloc = [\"jemallocator\", \"profile/jemalloc\"]\n force-always-assert = [\"always-assert/force\"]\n in-rust-tree = [\n     \"proc-macro-srv/sysroot-abi\",\n-    \"sourcegen/in-rust-tree\",\n     \"ide/in-rust-tree\",\n     \"syntax/in-rust-tree\",\n ]"}, {"sha": "ac10721d95514049baa41f351b7a2a4c0a989811", "filename": "crates/rust-analyzer/src/bin/logger.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Frust-analyzer%2Fsrc%2Fbin%2Flogger.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Frust-analyzer%2Fsrc%2Fbin%2Flogger.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fbin%2Flogger.rs?ref=e6540cff74534e6d9fb86d5d66e66423fad03766", "patch": "@@ -132,7 +132,7 @@ where\n \n             let ext = span.extensions();\n \n-            // `FormattedFields` is a a formatted representation of the span's\n+            // `FormattedFields` is a formatted representation of the span's\n             // fields, which is stored in its extensions by the `fmt` layer's\n             // `new_span` method. The fields will have been formatted\n             // by the same field formatter that's provided to the event"}, {"sha": "eabfcf1944dfd4f47c44a97d9e2b5c5c4ce63aaf", "filename": "crates/rust-analyzer/src/bin/main.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Frust-analyzer%2Fsrc%2Fbin%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Frust-analyzer%2Fsrc%2Fbin%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fbin%2Fmain.rs?ref=e6540cff74534e6d9fb86d5d66e66423fad03766", "patch": "@@ -37,16 +37,15 @@ fn main() {\n         process::exit(code);\n     }\n \n-    if let Err(err) = try_main() {\n+    let flags = flags::RustAnalyzer::from_env_or_exit();\n+    if let Err(err) = try_main(flags) {\n         tracing::error!(\"Unexpected error: {}\", err);\n         eprintln!(\"{}\", err);\n         process::exit(101);\n     }\n }\n \n-fn try_main() -> Result<()> {\n-    let flags = flags::RustAnalyzer::from_env()?;\n-\n+fn try_main(flags: flags::RustAnalyzer) -> Result<()> {\n     #[cfg(debug_assertions)]\n     if flags.wait_dbg || env::var(\"RA_WAIT_DBG\").is_ok() {\n         #[allow(unused_mut)]\n@@ -76,10 +75,6 @@ fn try_main() -> Result<()> {\n                 println!(\"rust-analyzer {}\", rust_analyzer::version());\n                 return Ok(());\n             }\n-            if cmd.help {\n-                println!(\"{}\", flags::RustAnalyzer::HELP);\n-                return Ok(());\n-            }\n             with_extra_thread(\"LspServer\", run_server)?;\n         }\n         flags::RustAnalyzerCmd::ProcMacro(flags::ProcMacro) => {"}, {"sha": "e1675a030c0f6f19f36b5d4bf12e975db471ba9d", "filename": "crates/rust-analyzer/src/cargo_target_spec.rs", "status": "modified", "additions": 44, "deletions": 38, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Frust-analyzer%2Fsrc%2Fcargo_target_spec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Frust-analyzer%2Fsrc%2Fcargo_target_spec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcargo_target_spec.rs?ref=e6540cff74534e6d9fb86d5d66e66423fad03766", "patch": "@@ -4,7 +4,7 @@ use std::mem;\n \n use cfg::{CfgAtom, CfgExpr};\n use ide::{FileId, RunnableKind, TestId};\n-use project_model::{self, ManifestPath, TargetKind};\n+use project_model::{self, CargoFeatures, ManifestPath, TargetKind};\n use vfs::AbsPathBuf;\n \n use crate::{global_state::GlobalStateSnapshot, Result};\n@@ -35,41 +35,41 @@ impl CargoTargetSpec {\n \n         match kind {\n             RunnableKind::Test { test_id, attr } => {\n-                args.push(\"test\".to_string());\n+                args.push(\"test\".to_owned());\n                 extra_args.push(test_id.to_string());\n                 if let TestId::Path(_) = test_id {\n-                    extra_args.push(\"--exact\".to_string());\n+                    extra_args.push(\"--exact\".to_owned());\n                 }\n-                extra_args.push(\"--nocapture\".to_string());\n+                extra_args.push(\"--nocapture\".to_owned());\n                 if attr.ignore {\n-                    extra_args.push(\"--ignored\".to_string());\n+                    extra_args.push(\"--ignored\".to_owned());\n                 }\n             }\n             RunnableKind::TestMod { path } => {\n-                args.push(\"test\".to_string());\n-                extra_args.push(path.to_string());\n-                extra_args.push(\"--nocapture\".to_string());\n+                args.push(\"test\".to_owned());\n+                extra_args.push(path.clone());\n+                extra_args.push(\"--nocapture\".to_owned());\n             }\n             RunnableKind::Bench { test_id } => {\n-                args.push(\"bench\".to_string());\n+                args.push(\"bench\".to_owned());\n                 extra_args.push(test_id.to_string());\n                 if let TestId::Path(_) = test_id {\n-                    extra_args.push(\"--exact\".to_string());\n+                    extra_args.push(\"--exact\".to_owned());\n                 }\n-                extra_args.push(\"--nocapture\".to_string());\n+                extra_args.push(\"--nocapture\".to_owned());\n             }\n             RunnableKind::DocTest { test_id } => {\n-                args.push(\"test\".to_string());\n-                args.push(\"--doc\".to_string());\n+                args.push(\"test\".to_owned());\n+                args.push(\"--doc\".to_owned());\n                 extra_args.push(test_id.to_string());\n-                extra_args.push(\"--nocapture\".to_string());\n+                extra_args.push(\"--nocapture\".to_owned());\n             }\n             RunnableKind::Bin => {\n                 let subcommand = match spec {\n                     Some(CargoTargetSpec { target_kind: TargetKind::Test, .. }) => \"test\",\n                     _ => \"run\",\n                 };\n-                args.push(subcommand.to_string());\n+                args.push(subcommand.to_owned());\n             }\n         }\n \n@@ -82,29 +82,35 @@ impl CargoTargetSpec {\n         };\n \n         let cargo_config = snap.config.cargo();\n-        if cargo_config.all_features {\n-            args.push(\"--all-features\".to_string());\n \n-            for feature in target_required_features {\n-                args.push(\"--features\".to_string());\n-                args.push(feature);\n-            }\n-        } else {\n-            let mut features = Vec::new();\n-            if let Some(cfg) = cfg.as_ref() {\n-                required_features(cfg, &mut features);\n+        match &cargo_config.features {\n+            CargoFeatures::All => {\n+                args.push(\"--all-features\".to_owned());\n+                for feature in target_required_features {\n+                    args.push(\"--features\".to_owned());\n+                    args.push(feature);\n+                }\n             }\n+            CargoFeatures::Selected { features, no_default_features } => {\n+                let mut feats = Vec::new();\n+                if let Some(cfg) = cfg.as_ref() {\n+                    required_features(cfg, &mut feats);\n+                }\n \n-            features.extend(cargo_config.features);\n-            features.extend(target_required_features);\n+                feats.extend(features.iter().cloned());\n+                feats.extend(target_required_features);\n \n-            features.dedup();\n-            for feature in features {\n-                args.push(\"--features\".to_string());\n-                args.push(feature);\n+                feats.dedup();\n+                for feature in feats {\n+                    args.push(\"--features\".to_owned());\n+                    args.push(feature);\n+                }\n+\n+                if *no_default_features {\n+                    args.push(\"--no-default-features\".to_owned());\n+                }\n             }\n         }\n-\n         Ok((args, extra_args))\n     }\n \n@@ -136,7 +142,7 @@ impl CargoTargetSpec {\n     }\n \n     pub(crate) fn push_to(self, buf: &mut Vec<String>, kind: &RunnableKind) {\n-        buf.push(\"--package\".to_string());\n+        buf.push(\"--package\".to_owned());\n         buf.push(self.package);\n \n         // Can't mix --doc with other target flags\n@@ -145,23 +151,23 @@ impl CargoTargetSpec {\n         }\n         match self.target_kind {\n             TargetKind::Bin => {\n-                buf.push(\"--bin\".to_string());\n+                buf.push(\"--bin\".to_owned());\n                 buf.push(self.target);\n             }\n             TargetKind::Test => {\n-                buf.push(\"--test\".to_string());\n+                buf.push(\"--test\".to_owned());\n                 buf.push(self.target);\n             }\n             TargetKind::Bench => {\n-                buf.push(\"--bench\".to_string());\n+                buf.push(\"--bench\".to_owned());\n                 buf.push(self.target);\n             }\n             TargetKind::Example => {\n-                buf.push(\"--example\".to_string());\n+                buf.push(\"--example\".to_owned());\n                 buf.push(self.target);\n             }\n             TargetKind::Lib => {\n-                buf.push(\"--lib\".to_string());\n+                buf.push(\"--lib\".to_owned());\n             }\n             TargetKind::Other | TargetKind::BuildScript => (),\n         }"}, {"sha": "01fccc83e8227be05109dd1ada0528c24ed92a28", "filename": "crates/rust-analyzer/src/cli/analysis_stats.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fanalysis_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fanalysis_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fanalysis_stats.rs?ref=e6540cff74534e6d9fb86d5d66e66423fad03766", "patch": "@@ -24,7 +24,7 @@ use ide_db::base_db::{\n use itertools::Itertools;\n use oorandom::Rand32;\n use profile::{Bytes, StopWatch};\n-use project_model::{CargoConfig, ProjectManifest, ProjectWorkspace};\n+use project_model::{CargoConfig, ProjectManifest, ProjectWorkspace, RustcSource};\n use rayon::prelude::*;\n use rustc_hash::FxHashSet;\n use stdx::format_to;\n@@ -55,7 +55,10 @@ impl flags::AnalysisStats {\n         };\n \n         let mut cargo_config = CargoConfig::default();\n-        cargo_config.no_sysroot = self.no_sysroot;\n+        cargo_config.sysroot = match self.no_sysroot {\n+            true => None,\n+            false => Some(RustcSource::Discover),\n+        };\n         let load_cargo_config = LoadCargoConfig {\n             load_out_dirs_from_check: !self.disable_build_scripts,\n             with_proc_macro: !self.disable_proc_macros,\n@@ -81,7 +84,7 @@ impl flags::AnalysisStats {\n         };\n \n         let (host, vfs, _proc_macro) =\n-            load_workspace(workspace, &cargo_config, &load_cargo_config)?;\n+            load_workspace(workspace, &cargo_config.extra_env, &load_cargo_config)?;\n         let db = host.raw_database();\n         eprint!(\"{:<20} {}\", \"Database loaded:\", db_load_sw.elapsed());\n         eprint!(\" (metadata {}\", metadata_time);"}, {"sha": "5bcc97e22612257f8e025d2dbd24ff16e0f64bf8", "filename": "crates/rust-analyzer/src/cli/flags.rs", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fflags.rs?ref=e6540cff74534e6d9fb86d5d66e66423fad03766", "patch": "@@ -31,8 +31,6 @@ xflags::xflags! {\n         default cmd lsp-server {\n             /// Print version.\n             optional --version\n-            /// Print help.\n-            optional -h, --help\n \n             /// Dump a LSP config JSON schema.\n             optional --print-config-schema\n@@ -54,10 +52,10 @@ xflags::xflags! {\n         }\n \n         /// Batch typecheck project and print summary statistics\n-        cmd analysis-stats\n+        cmd analysis-stats {\n             /// Directory with Cargo.toml.\n             required path: PathBuf\n-        {\n+\n             optional --output format: OutputFormat\n \n             /// Randomize order in which crates, modules, and items are processed.\n@@ -84,38 +82,37 @@ xflags::xflags! {\n             optional --skip-inference\n         }\n \n-        cmd diagnostics\n+        cmd diagnostics {\n             /// Directory with Cargo.toml.\n             required path: PathBuf\n-        {\n+\n             /// Don't run build scripts or load `OUT_DIR` values by running `cargo check` before analysis.\n             optional --disable-build-scripts\n             /// Don't use expand proc macros.\n             optional --disable-proc-macros\n         }\n \n-        cmd ssr\n+        cmd ssr {\n             /// A structured search replace rule (`$a.foo($b) ==> bar($a, $b)`)\n             repeated rule: SsrRule\n-        {}\n+        }\n \n-        cmd search\n+        cmd search {\n             /// A structured search replace pattern (`$a.foo($b)`)\n             repeated pattern: SsrPattern\n-        {\n             /// Prints debug information for any nodes with source exactly equal to snippet.\n             optional --debug snippet: String\n         }\n \n         cmd proc-macro {}\n \n-        cmd lsif\n+        cmd lsif {\n             required path: PathBuf\n-        {}\n+        }\n \n-        cmd scip\n+        cmd scip {\n             required path: PathBuf\n-        {}\n+        }\n     }\n }\n \n@@ -150,7 +147,6 @@ pub enum RustAnalyzerCmd {\n #[derive(Debug)]\n pub struct LspServer {\n     pub version: bool,\n-    pub help: bool,\n     pub print_config_schema: bool,\n }\n \n@@ -218,7 +214,10 @@ pub struct Scip {\n }\n \n impl RustAnalyzer {\n-    pub const HELP: &'static str = Self::HELP_;\n+    #[allow(dead_code)]\n+    pub fn from_env_or_exit() -> Self {\n+        Self::from_env_or_exit_()\n+    }\n \n     #[allow(dead_code)]\n     pub fn from_env() -> xflags::Result<Self> {"}, {"sha": "5dba545b871844f37f25917fce8bb15926165aa8", "filename": "crates/rust-analyzer/src/cli/load_cargo.rs", "status": "modified", "additions": 23, "deletions": 7, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fload_cargo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fload_cargo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fload_cargo.rs?ref=e6540cff74534e6d9fb86d5d66e66423fad03766", "patch": "@@ -6,7 +6,7 @@ use anyhow::Result;\n use crossbeam_channel::{unbounded, Receiver};\n use hir::db::DefDatabase;\n use ide::{AnalysisHost, Change};\n-use ide_db::base_db::CrateGraph;\n+use ide_db::{base_db::CrateGraph, FxHashMap};\n use proc_macro_api::ProcMacroServer;\n use project_model::{CargoConfig, ProjectManifest, ProjectWorkspace};\n use vfs::{loader::Handle, AbsPath, AbsPathBuf};\n@@ -38,7 +38,7 @@ pub fn load_workspace_at(\n         workspace.set_build_scripts(build_scripts)\n     }\n \n-    load_workspace(workspace, cargo_config, load_config)\n+    load_workspace(workspace, &cargo_config.extra_env, load_config)\n }\n \n // Note: Since this function is used by external tools that use rust-analyzer as a library\n@@ -48,7 +48,7 @@ pub fn load_workspace_at(\n // these tools need access to `ProjectWorkspace`, too, which `load_workspace_at` hides.\n pub fn load_workspace(\n     ws: ProjectWorkspace,\n-    cargo_config: &CargoConfig,\n+    extra_env: &FxHashMap<String, String>,\n     load_config: &LoadCargoConfig,\n ) -> Result<(AnalysisHost, vfs::Vfs, Option<ProcMacroServer>)> {\n     let (sender, receiver) = unbounded();\n@@ -60,10 +60,26 @@ pub fn load_workspace(\n     };\n \n     let proc_macro_client = if load_config.with_proc_macro {\n-        let path = AbsPathBuf::assert(std::env::current_exe()?);\n-        Ok(ProcMacroServer::spawn(path, &[\"proc-macro\"]).unwrap())\n+        let mut path = AbsPathBuf::assert(std::env::current_exe()?);\n+        let mut args = vec![\"proc-macro\"];\n+\n+        if let ProjectWorkspace::Cargo { sysroot, .. } | ProjectWorkspace::Json { sysroot, .. } =\n+            &ws\n+        {\n+            if let Some(sysroot) = sysroot.as_ref() {\n+                let standalone_server_name =\n+                    format!(\"rust-analyzer-proc-macro-srv{}\", std::env::consts::EXE_SUFFIX);\n+                let server_path = sysroot.root().join(\"libexec\").join(&standalone_server_name);\n+                if std::fs::metadata(&server_path).is_ok() {\n+                    path = server_path;\n+                    args = vec![];\n+                }\n+            }\n+        }\n+\n+        ProcMacroServer::spawn(path.clone(), args.clone()).map_err(|e| e.to_string())\n     } else {\n-        Err(\"proc macro server not started\".to_owned())\n+        Err(\"proc macro server disabled\".to_owned())\n     };\n \n     let crate_graph = ws.to_crate_graph(\n@@ -76,7 +92,7 @@ pub fn load_workspace(\n             vfs.set_file_contents(path.clone(), contents);\n             vfs.file_id(&path)\n         },\n-        cargo_config,\n+        extra_env,\n     );\n \n     let project_folders = ProjectFolders::new(&[ws], &[]);"}, {"sha": "748306ea57d4ee25babc020925925e1a624b8fcf", "filename": "crates/rust-analyzer/src/cli/lsif.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Frust-analyzer%2Fsrc%2Fcli%2Flsif.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Frust-analyzer%2Fsrc%2Fcli%2Flsif.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcli%2Flsif.rs?ref=e6540cff74534e6d9fb86d5d66e66423fad03766", "patch": "@@ -300,7 +300,7 @@ impl flags::Lsif {\n         let workspace = ProjectWorkspace::load(manifest, &cargo_config, no_progress)?;\n \n         let (host, vfs, _proc_macro) =\n-            load_workspace(workspace, &cargo_config, &load_cargo_config)?;\n+            load_workspace(workspace, &cargo_config.extra_env, &load_cargo_config)?;\n         let db = host.raw_database();\n         let analysis = host.analysis();\n "}, {"sha": "2c29b3ee3a6f7d82e76892855c48ef70b56a5206", "filename": "crates/rust-analyzer/src/cli/scip.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fscip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fscip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fscip.rs?ref=e6540cff74534e6d9fb86d5d66e66423fad03766", "patch": "@@ -40,7 +40,8 @@ impl flags::Scip {\n \n         let workspace = ProjectWorkspace::load(manifest, &cargo_config, no_progress)?;\n \n-        let (host, vfs, _) = load_workspace(workspace, &cargo_config, &load_cargo_config)?;\n+        let (host, vfs, _) =\n+            load_workspace(workspace, &cargo_config.extra_env, &load_cargo_config)?;\n         let db = host.raw_database();\n         let analysis = host.analysis();\n "}, {"sha": "577a8640a4c00acd659e6dfe6b6e3cadb5e95aca", "filename": "crates/rust-analyzer/src/config.rs", "status": "modified", "additions": 41, "deletions": 24, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs?ref=e6540cff74534e6d9fb86d5d66e66423fad03766", "patch": "@@ -7,7 +7,7 @@\n //! configure the server itself, feature flags are passed into analysis, and\n //! tweak things like automatic insertion of `()` in completions.\n \n-use std::{ffi::OsString, fmt, iter, path::PathBuf};\n+use std::{fmt, iter, path::PathBuf};\n \n use flycheck::FlycheckConfig;\n use ide::{\n@@ -22,7 +22,8 @@ use ide_db::{\n use itertools::Itertools;\n use lsp_types::{ClientCapabilities, MarkupKind};\n use project_model::{\n-    CargoConfig, ProjectJson, ProjectJsonData, ProjectManifest, RustcSource, UnsetTestCrates,\n+    CargoConfig, CargoFeatures, ProjectJson, ProjectJsonData, ProjectManifest, RustcSource,\n+    UnsetTestCrates,\n };\n use rustc_hash::{FxHashMap, FxHashSet};\n use serde::{de::DeserializeOwned, Deserialize};\n@@ -90,11 +91,16 @@ config_data! {\n         /// List of features to activate.\n         ///\n         /// Set this to `\"all\"` to pass `--all-features` to cargo.\n-        cargo_features: CargoFeatures      = \"[]\",\n+        cargo_features: CargoFeaturesDef      = \"[]\",\n         /// Whether to pass `--no-default-features` to cargo.\n         cargo_noDefaultFeatures: bool    = \"false\",\n-        /// Internal config for debugging, disables loading of sysroot crates.\n-        cargo_noSysroot: bool            = \"false\",\n+        /// Relative path to the sysroot, or \"discover\" to try to automatically find it via\n+        /// \"rustc --print sysroot\".\n+        ///\n+        /// Unsetting this disables sysroot loading.\n+        ///\n+        /// This option does not take effect until rust-analyzer is restarted.\n+        cargo_sysroot: Option<String>    = \"\\\"discover\\\"\",\n         /// Compilation target override (target triple).\n         cargo_target: Option<String>     = \"null\",\n         /// Unsets `#[cfg(test)]` for the specified crates.\n@@ -109,12 +115,13 @@ config_data! {\n         /// Extra arguments for `cargo check`.\n         checkOnSave_extraArgs: Vec<String>               = \"[]\",\n         /// Extra environment variables that will be set when running `cargo check`.\n+        /// Extends `#rust-analyzer.cargo.extraEnv#`.\n         checkOnSave_extraEnv: FxHashMap<String, String> = \"{}\",\n         /// List of features to activate. Defaults to\n         /// `#rust-analyzer.cargo.features#`.\n         ///\n         /// Set to `\"all\"` to pass `--all-features` to Cargo.\n-        checkOnSave_features: Option<CargoFeatures>      = \"null\",\n+        checkOnSave_features: Option<CargoFeaturesDef>      = \"null\",\n         /// Whether to pass `--no-default-features` to Cargo. Defaults to\n         /// `#rust-analyzer.cargo.noDefaultFeatures#`.\n         checkOnSave_noDefaultFeatures: Option<bool>      = \"null\",\n@@ -975,15 +982,17 @@ impl Config {\n         self.data.lru_capacity\n     }\n \n-    pub fn proc_macro_srv(&self) -> Option<(AbsPathBuf, Vec<OsString>)> {\n+    pub fn proc_macro_srv(&self) -> Option<(AbsPathBuf, /* is path explicitly set */ bool)> {\n         if !self.data.procMacro_enable {\n             return None;\n         }\n-        let path = match &self.data.procMacro_server {\n-            Some(it) => self.root_path.join(it),\n-            None => AbsPathBuf::assert(std::env::current_exe().ok()?),\n-        };\n-        Some((path, vec![\"proc-macro\".into()]))\n+        Some(match &self.data.procMacro_server {\n+            Some(it) => (\n+                AbsPathBuf::try_from(it.clone()).unwrap_or_else(|path| self.root_path.join(path)),\n+                true,\n+            ),\n+            None => (AbsPathBuf::assert(std::env::current_exe().ok()?), false),\n+        })\n     }\n \n     pub fn dummy_replacements(&self) -> &FxHashMap<Box<str>, Box<[Box<str>]>> {\n@@ -1026,16 +1035,24 @@ impl Config {\n                 RustcSource::Path(self.root_path.join(rustc_src))\n             }\n         });\n+        let sysroot = self.data.cargo_sysroot.as_ref().map(|sysroot| {\n+            if sysroot == \"discover\" {\n+                RustcSource::Discover\n+            } else {\n+                RustcSource::Path(self.root_path.join(sysroot))\n+            }\n+        });\n \n         CargoConfig {\n-            no_default_features: self.data.cargo_noDefaultFeatures,\n-            all_features: matches!(self.data.cargo_features, CargoFeatures::All),\n             features: match &self.data.cargo_features {\n-                CargoFeatures::All => vec![],\n-                CargoFeatures::Listed(it) => it.clone(),\n+                CargoFeaturesDef::All => CargoFeatures::All,\n+                CargoFeaturesDef::Selected(features) => CargoFeatures::Selected {\n+                    features: features.clone(),\n+                    no_default_features: self.data.cargo_noDefaultFeatures,\n+                },\n             },\n             target: self.data.cargo_target.clone(),\n-            no_sysroot: self.data.cargo_noSysroot,\n+            sysroot,\n             rustc_source,\n             unset_test_crates: UnsetTestCrates::Only(self.data.cargo_unsetTest.clone()),\n             wrap_rustc_in_build_scripts: self.data.cargo_buildScripts_useRustcWrapper,\n@@ -1086,16 +1103,16 @@ impl Config {\n                     .unwrap_or(self.data.cargo_noDefaultFeatures),\n                 all_features: matches!(\n                     self.data.checkOnSave_features.as_ref().unwrap_or(&self.data.cargo_features),\n-                    CargoFeatures::All\n+                    CargoFeaturesDef::All\n                 ),\n                 features: match self\n                     .data\n                     .checkOnSave_features\n                     .clone()\n                     .unwrap_or_else(|| self.data.cargo_features.clone())\n                 {\n-                    CargoFeatures::All => vec![],\n-                    CargoFeatures::Listed(it) => it,\n+                    CargoFeaturesDef::All => vec![],\n+                    CargoFeaturesDef::Selected(it) => it,\n                 },\n                 extra_args: self.data.checkOnSave_extraArgs.clone(),\n                 extra_env: self.check_on_save_extra_env(),\n@@ -1564,10 +1581,10 @@ enum CallableCompletionDef {\n \n #[derive(Deserialize, Debug, Clone)]\n #[serde(untagged)]\n-enum CargoFeatures {\n+enum CargoFeaturesDef {\n     #[serde(deserialize_with = \"de_unit_v::all\")]\n     All,\n-    Listed(Vec<String>),\n+    Selected(Vec<String>),\n }\n \n #[derive(Deserialize, Debug, Clone)]\n@@ -1912,7 +1929,7 @@ fn field_props(field: &str, ty: &str, doc: &[&str], default: &str) -> serde_json\n                 \"Only show mutable reborrow hints.\"\n             ]\n         },\n-        \"CargoFeatures\" => set! {\n+        \"CargoFeaturesDef\" => set! {\n             \"anyOf\": [\n                 {\n                     \"type\": \"string\",\n@@ -1929,7 +1946,7 @@ fn field_props(field: &str, ty: &str, doc: &[&str], default: &str) -> serde_json\n                 }\n             ],\n         },\n-        \"Option<CargoFeatures>\" => set! {\n+        \"Option<CargoFeaturesDef>\" => set! {\n             \"anyOf\": [\n                 {\n                     \"type\": \"string\","}, {"sha": "f2db9a27334979da9b2185f0e651c6f071081969", "filename": "crates/rust-analyzer/src/from_proto.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Frust-analyzer%2Fsrc%2Ffrom_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Frust-analyzer%2Fsrc%2Ffrom_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Ffrom_proto.rs?ref=e6540cff74534e6d9fb86d5d66e66423fad03766", "patch": "@@ -95,22 +95,22 @@ pub(crate) fn annotation(\n \n     match resolve {\n         lsp_ext::CodeLensResolveData::Impls(params) => {\n-            let file_id =\n-                snap.url_to_file_id(&params.text_document_position_params.text_document.uri)?;\n+            let pos @ FilePosition { file_id, .. } =\n+                file_position(snap, params.text_document_position_params)?;\n             let line_index = snap.file_line_index(file_id)?;\n \n             Ok(Annotation {\n                 range: text_range(&line_index, code_lens.range)?,\n-                kind: AnnotationKind::HasImpls { file_id, data: None },\n+                kind: AnnotationKind::HasImpls { pos, data: None },\n             })\n         }\n         lsp_ext::CodeLensResolveData::References(params) => {\n-            let file_id = snap.url_to_file_id(&params.text_document.uri)?;\n+            let pos @ FilePosition { file_id, .. } = file_position(snap, params)?;\n             let line_index = snap.file_line_index(file_id)?;\n \n             Ok(Annotation {\n                 range: text_range(&line_index, code_lens.range)?,\n-                kind: AnnotationKind::HasReferences { file_id, data: None },\n+                kind: AnnotationKind::HasReferences { pos, data: None },\n             })\n         }\n     }"}, {"sha": "000ff88e458f6e4256a227138490369d9cbbbfb1", "filename": "crates/rust-analyzer/src/global_state.rs", "status": "modified", "additions": 42, "deletions": 1, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs?ref=e6540cff74534e6d9fb86d5d66e66423fad03766", "patch": "@@ -185,11 +185,48 @@ impl GlobalState {\n         let (change, changed_files) = {\n             let mut change = Change::new();\n             let (vfs, line_endings_map) = &mut *self.vfs.write();\n-            let changed_files = vfs.take_changes();\n+            let mut changed_files = vfs.take_changes();\n             if changed_files.is_empty() {\n                 return false;\n             }\n \n+            // important: this needs to be a stable sort, the order between changes is relevant\n+            // for the same file ids\n+            changed_files.sort_by_key(|file| file.file_id);\n+            // We need to fix up the changed events a bit, if we have a create or modify for a file\n+            // id that is followed by a delete we actually no longer observe the file text from the\n+            // create or modify which may cause problems later on\n+            changed_files.dedup_by(|a, b| {\n+                use vfs::ChangeKind::*;\n+\n+                if a.file_id != b.file_id {\n+                    return false;\n+                }\n+\n+                match (a.change_kind, b.change_kind) {\n+                    // duplicate can be merged\n+                    (Create, Create) | (Modify, Modify) | (Delete, Delete) => true,\n+                    // just leave the create, modify is irrelevant\n+                    (Create, Modify) => {\n+                        std::mem::swap(a, b);\n+                        true\n+                    }\n+                    // modify becomes irrelevant if the file is deleted\n+                    (Modify, Delete) => true,\n+                    // we should fully remove this occurrence,\n+                    // but leaving just a delete works as well\n+                    (Create, Delete) => true,\n+                    // this is equivalent to a modify\n+                    (Delete, Create) => {\n+                        a.change_kind = Modify;\n+                        true\n+                    }\n+                    // can't really occur\n+                    (Modify, Create) => false,\n+                    (Delete, Modify) => false,\n+                }\n+            });\n+\n             for file in &changed_files {\n                 if let Some(path) = vfs.file_path(file.file_id).as_path() {\n                     let path = path.to_path_buf();\n@@ -317,6 +354,10 @@ impl GlobalState {\n         }\n     }\n \n+    pub(crate) fn is_completed(&self, request: &lsp_server::Request) -> bool {\n+        self.req_queue.incoming.is_completed(&request.id)\n+    }\n+\n     fn send(&mut self, message: lsp_server::Message) {\n         self.sender.send(message).unwrap()\n     }"}, {"sha": "15922dac651cce834818de41cc479e50248632d6", "filename": "crates/rust-analyzer/src/main_loop.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs?ref=e6540cff74534e6d9fb86d5d66e66423fad03766", "patch": "@@ -425,7 +425,9 @@ impl GlobalState {\n     fn handle_task(&mut self, prime_caches_progress: &mut Vec<PrimeCachesProgress>, task: Task) {\n         match task {\n             Task::Response(response) => self.respond(response),\n-            Task::Retry(req) => self.on_request(req),\n+            // Only retry requests that haven't been cancelled. Otherwise we do unnecessary work.\n+            Task::Retry(req) if !self.is_completed(&req) => self.on_request(req),\n+            Task::Retry(_) => (),\n             Task::Diagnostics(diagnostics_per_file) => {\n                 for (file_id, diagnostics) in diagnostics_per_file {\n                     self.diagnostics.set_native_diagnostics(file_id, diagnostics)"}, {"sha": "f8734893944624e169bc8969da9759707945b9ad", "filename": "crates/rust-analyzer/src/reload.rs", "status": "modified", "additions": 37, "deletions": 28, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Frust-analyzer%2Fsrc%2Freload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Frust-analyzer%2Fsrc%2Freload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Freload.rs?ref=e6540cff74534e6d9fb86d5d66e66423fad03766", "patch": "@@ -143,7 +143,7 @@ impl GlobalState {\n                             project_model::ProjectWorkspace::load_inline(\n                                 it.clone(),\n                                 cargo_config.target.as_deref(),\n-                                &cargo_config,\n+                                &cargo_config.extra_env,\n                             )\n                         }\n                     })\n@@ -306,41 +306,50 @@ impl GlobalState {\n             format!(\"rust-analyzer-proc-macro-srv{}\", std::env::consts::EXE_SUFFIX);\n \n         if self.proc_macro_clients.is_empty() {\n-            if let Some((path, args)) = self.config.proc_macro_srv() {\n+            if let Some((path, path_manually_set)) = self.config.proc_macro_srv() {\n                 tracing::info!(\"Spawning proc-macro servers\");\n                 self.proc_macro_clients = self\n                     .workspaces\n                     .iter()\n                     .map(|ws| {\n-                        let mut args = args.clone();\n-                        let mut path = path.clone();\n-\n-                        if let ProjectWorkspace::Cargo { sysroot, .. }\n-                        | ProjectWorkspace::Json { sysroot, .. } = ws\n-                        {\n-                            tracing::debug!(\"Found a cargo workspace...\");\n-                            if let Some(sysroot) = sysroot.as_ref() {\n-                                tracing::debug!(\"Found a cargo workspace with a sysroot...\");\n-                                let server_path =\n-                                    sysroot.root().join(\"libexec\").join(&standalone_server_name);\n-                                if std::fs::metadata(&server_path).is_ok() {\n-                                    tracing::debug!(\n-                                        \"And the server exists at {}\",\n-                                        server_path.display()\n-                                    );\n-                                    path = server_path;\n-                                    args = vec![];\n-                                } else {\n-                                    tracing::debug!(\n-                                        \"And the server does not exist at {}\",\n-                                        server_path.display()\n-                                    );\n+                        let (path, args) = if path_manually_set {\n+                            tracing::debug!(\n+                                \"Pro-macro server path explicitly set: {}\",\n+                                path.display()\n+                            );\n+                            (path.clone(), vec![])\n+                        } else {\n+                            let mut sysroot_server = None;\n+                            if let ProjectWorkspace::Cargo { sysroot, .. }\n+                            | ProjectWorkspace::Json { sysroot, .. } = ws\n+                            {\n+                                if let Some(sysroot) = sysroot.as_ref() {\n+                                    let server_path = sysroot\n+                                        .root()\n+                                        .join(\"libexec\")\n+                                        .join(&standalone_server_name);\n+                                    if std::fs::metadata(&server_path).is_ok() {\n+                                        tracing::debug!(\n+                                            \"Sysroot proc-macro server exists at {}\",\n+                                            server_path.display()\n+                                        );\n+                                        sysroot_server = Some(server_path);\n+                                    } else {\n+                                        tracing::debug!(\n+                                            \"Sysroot proc-macro server does not exist at {}\",\n+                                            server_path.display()\n+                                        );\n+                                    }\n                                 }\n                             }\n-                        }\n+                            sysroot_server.map_or_else(\n+                                || (path.clone(), vec![\"proc-macro\".to_owned()]),\n+                                |path| (path, vec![]),\n+                            )\n+                        };\n \n                         tracing::info!(?args, \"Using proc-macro server at {}\", path.display(),);\n-                        ProcMacroServer::spawn(path.clone(), args.clone()).map_err(|err| {\n+                        ProcMacroServer::spawn(path.clone(), args).map_err(|err| {\n                             let error = format!(\n                                 \"Failed to run proc-macro server from path {}, error: {:?}\",\n                                 path.display(),\n@@ -402,7 +411,7 @@ impl GlobalState {\n                 crate_graph.extend(ws.to_crate_graph(\n                     &mut load_proc_macro,\n                     &mut load,\n-                    &self.config.cargo(),\n+                    &self.config.cargo().extra_env,\n                 ));\n             }\n             crate_graph"}, {"sha": "5936454a7c546e487122b0f06dc822a36890755b", "filename": "crates/rust-analyzer/src/to_proto.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs?ref=e6540cff74534e6d9fb86d5d66e66423fad03766", "patch": "@@ -1177,13 +1177,13 @@ pub(crate) fn code_lens(\n                 })\n             }\n         }\n-        AnnotationKind::HasImpls { file_id, data } => {\n+        AnnotationKind::HasImpls { pos: file_range, data } => {\n             if !client_commands_config.show_reference {\n                 return Ok(());\n             }\n-            let line_index = snap.file_line_index(file_id)?;\n+            let line_index = snap.file_line_index(file_range.file_id)?;\n             let annotation_range = range(&line_index, annotation.range);\n-            let url = url(snap, file_id);\n+            let url = url(snap, file_range.file_id);\n \n             let id = lsp_types::TextDocumentIdentifier { uri: url.clone() };\n \n@@ -1221,13 +1221,13 @@ pub(crate) fn code_lens(\n                 data: Some(to_value(lsp_ext::CodeLensResolveData::Impls(goto_params)).unwrap()),\n             })\n         }\n-        AnnotationKind::HasReferences { file_id, data } => {\n+        AnnotationKind::HasReferences { pos: file_range, data } => {\n             if !client_commands_config.show_reference {\n                 return Ok(());\n             }\n-            let line_index = snap.file_line_index(file_id)?;\n+            let line_index = snap.file_line_index(file_range.file_id)?;\n             let annotation_range = range(&line_index, annotation.range);\n-            let url = url(snap, file_id);\n+            let url = url(snap, file_range.file_id);\n \n             let id = lsp_types::TextDocumentIdentifier { uri: url.clone() };\n "}, {"sha": "fa55f7d90c49db01e7a0d8019615599a43dafdd3", "filename": "crates/rust-analyzer/tests/slow-tests/main.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Frust-analyzer%2Ftests%2Fslow-tests%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Frust-analyzer%2Ftests%2Fslow-tests%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Ftests%2Fslow-tests%2Fmain.rs?ref=e6540cff74534e6d9fb86d5d66e66423fad03766", "patch": "@@ -18,7 +18,6 @@ mod tidy;\n \n use std::{collections::HashMap, path::PathBuf, time::Instant};\n \n-use expect_test::expect;\n use lsp_types::{\n     notification::DidOpenTextDocument,\n     request::{\n@@ -60,7 +59,7 @@ use std::collections::Spam;\n \"#,\n     )\n     .with_config(serde_json::json!({\n-        \"cargo\": { \"noSysroot\": false }\n+        \"cargo\": { \"sysroot\": \"discover\" }\n     }))\n     .server()\n     .wait_until_workspace_is_loaded();\n@@ -615,7 +614,7 @@ fn main() {{}}\n         librs, libs\n     ))\n     .with_config(serde_json::json!({\n-        \"cargo\": { \"noSysroot\": false }\n+        \"cargo\": { \"sysroot\": \"discover\" }\n     }))\n     .server()\n     .wait_until_workspace_is_loaded();\n@@ -743,7 +742,7 @@ fn main() {\n             \"buildScripts\": {\n                 \"enable\": true\n             },\n-            \"noSysroot\": true,\n+            \"sysroot\": null,\n         }\n     }))\n     .server()\n@@ -821,7 +820,10 @@ fn main() {\n }\n \n #[test]\n+// FIXME: Re-enable once we can run proc-macro tests on rust-lang/rust-analyzer again\n+#[cfg(any())]\n fn resolve_proc_macro() {\n+    use expect_test::expect;\n     if skip_slow_tests() {\n         return;\n     }\n@@ -898,7 +900,7 @@ pub fn foo(_input: TokenStream) -> TokenStream {\n             \"buildScripts\": {\n                 \"enable\": true\n             },\n-            \"noSysroot\": true,\n+            \"sysroot\": null,\n         },\n         \"procMacro\": {\n             \"enable\": true,"}, {"sha": "7257445dabe05f108da9bebcb6c61162bc72137b", "filename": "crates/rust-analyzer/tests/slow-tests/support.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Frust-analyzer%2Ftests%2Fslow-tests%2Fsupport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Frust-analyzer%2Ftests%2Fslow-tests%2Fsupport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Ftests%2Fslow-tests%2Fsupport.rs?ref=e6540cff74534e6d9fb86d5d66e66423fad03766", "patch": "@@ -34,7 +34,7 @@ impl<'a> Project<'a> {\n             config: serde_json::json!({\n                 \"cargo\": {\n                     // Loading standard library is costly, let's ignore it by default\n-                    \"noSysroot\": true,\n+                    \"sysroot\": null,\n                     // Can't use test binary as rustc wrapper.\n                     \"buildScripts\": {\n                         \"useRustcWrapper\": false"}, {"sha": "e75867e2d81cf59bf75b46a2a2f7af1b59a3ede0", "filename": "crates/sourcegen/Cargo.toml", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fsourcegen%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fsourcegen%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsourcegen%2FCargo.toml?ref=e6540cff74534e6d9fb86d5d66e66423fad03766", "patch": "@@ -11,6 +11,3 @@ doctest = false\n \n [dependencies]\n xshell = \"0.2.2\"\n-\n-[features]\n-in-rust-tree = []"}, {"sha": "fe82aa907222f7d4e97d03c69cd91d420c276c3c", "filename": "crates/syntax/src/ast/node_ext.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fsyntax%2Fsrc%2Fast%2Fnode_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Fsyntax%2Fsrc%2Fast%2Fnode_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fnode_ext.rs?ref=e6540cff74534e6d9fb86d5d66e66423fad03766", "patch": "@@ -873,3 +873,33 @@ impl ast::MatchGuard {\n         support::child(&self.syntax)\n     }\n }\n+\n+impl From<ast::Item> for ast::AnyHasAttrs {\n+    fn from(node: ast::Item) -> Self {\n+        Self::new(node)\n+    }\n+}\n+\n+impl From<ast::AssocItem> for ast::AnyHasAttrs {\n+    fn from(node: ast::AssocItem) -> Self {\n+        Self::new(node)\n+    }\n+}\n+\n+impl From<ast::Variant> for ast::AnyHasAttrs {\n+    fn from(node: ast::Variant) -> Self {\n+        Self::new(node)\n+    }\n+}\n+\n+impl From<ast::RecordField> for ast::AnyHasAttrs {\n+    fn from(node: ast::RecordField) -> Self {\n+        Self::new(node)\n+    }\n+}\n+\n+impl From<ast::TupleField> for ast::AnyHasAttrs {\n+    fn from(node: ast::TupleField) -> Self {\n+        Self::new(node)\n+    }\n+}"}, {"sha": "10386b5b7bcdd41e033144c705702b71d3dd27a5", "filename": "crates/test-utils/src/minicore.rs", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Ftest-utils%2Fsrc%2Fminicore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6540cff74534e6d9fb86d5d66e66423fad03766/crates%2Ftest-utils%2Fsrc%2Fminicore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest-utils%2Fsrc%2Fminicore.rs?ref=e6540cff74534e6d9fb86d5d66e66423fad03766", "patch": "@@ -37,6 +37,7 @@\n //!     add:\n //!     as_ref: sized\n //!     drop:\n+//!     generator: pin\n \n pub mod marker {\n     // region:sized\n@@ -182,6 +183,19 @@ pub mod ops {\n             type Target: ?Sized;\n             fn deref(&self) -> &Self::Target;\n         }\n+\n+        impl<T: ?Sized> Deref for &T {\n+            type Target = T;\n+            fn deref(&self) -> &T {\n+                loop {}\n+            }\n+        }\n+        impl<T: ?Sized> Deref for &mut T {\n+            type Target = T;\n+            fn deref(&self) -> &T {\n+                loop {}\n+            }\n+        }\n         // region:deref_mut\n         #[lang = \"deref_mut\"]\n         pub trait DerefMut: Deref {\n@@ -347,6 +361,27 @@ pub mod ops {\n         fn add(self, rhs: Rhs) -> Self::Output;\n     }\n     // endregion:add\n+\n+    // region:generator\n+    mod generator {\n+        use crate::pin::Pin;\n+\n+        #[lang = \"generator\"]\n+        pub trait Generator<R = ()> {\n+            type Yield;\n+            #[lang = \"generator_return\"]\n+            type Return;\n+            fn resume(self: Pin<&mut Self>, arg: R) -> GeneratorState<Self::Yield, Self::Return>;\n+        }\n+\n+        #[lang = \"generator_state\"]\n+        pub enum GeneratorState<Y, R> {\n+            Yielded(Y),\n+            Complete(R),\n+        }\n+    }\n+    pub use self::generator::{Generator, GeneratorState};\n+    // endregion:generator\n }\n \n // region:eq\n@@ -455,6 +490,19 @@ pub mod pin {\n     pub struct Pin<P> {\n         pointer: P,\n     }\n+    impl<P> Pin<P> {\n+        pub fn new(pointer: P) -> Pin<P> {\n+            loop {}\n+        }\n+    }\n+    // region:deref\n+    impl<P: crate::ops::Deref> crate::ops::Deref for Pin<P> {\n+        type Target = P::Target;\n+        fn deref(&self) -> &P::Target {\n+            loop {}\n+        }\n+    }\n+    // endregion:deref\n }\n // endregion:pin\n "}, {"sha": "4ac75b4bbfd965712d6415c7f888eb77d10cb975", "filename": "docs/dev/README.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e6540cff74534e6d9fb86d5d66e66423fad03766/docs%2Fdev%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/e6540cff74534e6d9fb86d5d66e66423fad03766/docs%2Fdev%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fdev%2FREADME.md?ref=e6540cff74534e6d9fb86d5d66e66423fad03766", "patch": "@@ -98,7 +98,7 @@ After I am done with the fix, I use `cargo xtask install --client` to try the ne\n If I need to fix something in the `rust-analyzer` crate, I feel sad because it's on the boundary between the two processes, and working there is slow.\n I usually just `cargo xtask install --server` and poke changes from my live environment.\n Note that this uses `--release`, which is usually faster overall, because loading stdlib into debug version of rust-analyzer takes a lot of time.\n-To speed things up, sometimes I open a temporary hello-world project which has `\"rust-analyzer.cargo.noSysroot\": true` in `.code/settings.json`.\n+To speed things up, sometimes I open a temporary hello-world project which has `\"rust-analyzer.cargo.sysroot\": null` in `.code/settings.json`.\n This flag causes rust-analyzer to skip loading the sysroot, which greatly reduces the amount of things rust-analyzer needs to do, and makes printf's more useful.\n Note that you should only use the `eprint!` family of macros for debugging: stdout is used for LSP communication, and `print!` would break it.\n "}, {"sha": "c9ff0b6c29e379799461968dea5416af44eafcd1", "filename": "docs/dev/guide.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e6540cff74534e6d9fb86d5d66e66423fad03766/docs%2Fdev%2Fguide.md", "raw_url": "https://github.com/rust-lang/rust/raw/e6540cff74534e6d9fb86d5d66e66423fad03766/docs%2Fdev%2Fguide.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fdev%2Fguide.md?ref=e6540cff74534e6d9fb86d5d66e66423fad03766", "patch": "@@ -40,8 +40,8 @@ terms of files and offsets, and **not** in terms of Rust concepts like structs,\n traits, etc. The \"typed\" API with Rust specific types is slightly lower in the\n stack, we'll talk about it later.\n \n-[`AnalysisHost`]: https://github.com/rust-lang/rust-analyzer/blob/guide-2019-01/crates/ide_api/src/lib.rs#L265-L284\n-[`Analysis`]: https://github.com/rust-lang/rust-analyzer/blob/guide-2019-01/crates/ide_api/src/lib.rs#L291-L478\n+[`AnalysisHost`]: https://github.com/rust-lang/rust-analyzer/blob/guide-2019-01/crates/ra_ide_api/src/lib.rs#L265-L284\n+[`Analysis`]: https://github.com/rust-lang/rust-analyzer/blob/guide-2019-01/crates/ra_ide_api/src/lib.rs#L291-L478\n \n The reason for this separation of `Analysis` and `AnalysisHost` is that we want to apply\n changes \"uniquely\", but we might also want to fork an `Analysis` and send it to"}, {"sha": "acf0aaea859a28c988bbcf682f01b07a64789fcc", "filename": "docs/user/generated_config.adoc", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e6540cff74534e6d9fb86d5d66e66423fad03766/docs%2Fuser%2Fgenerated_config.adoc", "raw_url": "https://github.com/rust-lang/rust/raw/e6540cff74534e6d9fb86d5d66e66423fad03766/docs%2Fuser%2Fgenerated_config.adoc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fuser%2Fgenerated_config.adoc?ref=e6540cff74534e6d9fb86d5d66e66423fad03766", "patch": "@@ -64,10 +64,15 @@ Set this to `\"all\"` to pass `--all-features` to cargo.\n --\n Whether to pass `--no-default-features` to cargo.\n --\n-[[rust-analyzer.cargo.noSysroot]]rust-analyzer.cargo.noSysroot (default: `false`)::\n+[[rust-analyzer.cargo.sysroot]]rust-analyzer.cargo.sysroot (default: `\"discover\"`)::\n +\n --\n-Internal config for debugging, disables loading of sysroot crates.\n+Relative path to the sysroot, or \"discover\" to try to automatically find it via\n+\"rustc --print sysroot\".\n+\n+Unsetting this disables sysroot loading.\n+\n+This option does not take effect until rust-analyzer is restarted.\n --\n [[rust-analyzer.cargo.target]]rust-analyzer.cargo.target (default: `null`)::\n +\n@@ -103,6 +108,7 @@ Extra arguments for `cargo check`.\n +\n --\n Extra environment variables that will be set when running `cargo check`.\n+Extends `#rust-analyzer.cargo.extraEnv#`.\n --\n [[rust-analyzer.checkOnSave.features]]rust-analyzer.checkOnSave.features (default: `null`)::\n +"}, {"sha": "f1dd3aa79ff043b664b519cea469bfe32d520116", "filename": "editors/code/package.json", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e6540cff74534e6d9fb86d5d66e66423fad03766/editors%2Fcode%2Fpackage.json", "raw_url": "https://github.com/rust-lang/rust/raw/e6540cff74534e6d9fb86d5d66e66423fad03766/editors%2Fcode%2Fpackage.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fpackage.json?ref=e6540cff74534e6d9fb86d5d66e66423fad03766", "patch": "@@ -468,10 +468,13 @@\n                     \"default\": false,\n                     \"type\": \"boolean\"\n                 },\n-                \"rust-analyzer.cargo.noSysroot\": {\n-                    \"markdownDescription\": \"Internal config for debugging, disables loading of sysroot crates.\",\n-                    \"default\": false,\n-                    \"type\": \"boolean\"\n+                \"rust-analyzer.cargo.sysroot\": {\n+                    \"markdownDescription\": \"Relative path to the sysroot, or \\\"discover\\\" to try to automatically find it via\\n\\\"rustc --print sysroot\\\".\\n\\nUnsetting this disables sysroot loading.\\n\\nThis option does not take effect until rust-analyzer is restarted.\",\n+                    \"default\": \"discover\",\n+                    \"type\": [\n+                        \"null\",\n+                        \"string\"\n+                    ]\n                 },\n                 \"rust-analyzer.cargo.target\": {\n                     \"markdownDescription\": \"Compilation target override (target triple).\",\n@@ -515,7 +518,7 @@\n                     }\n                 },\n                 \"rust-analyzer.checkOnSave.extraEnv\": {\n-                    \"markdownDescription\": \"Extra environment variables that will be set when running `cargo check`.\",\n+                    \"markdownDescription\": \"Extra environment variables that will be set when running `cargo check`.\\nExtends `#rust-analyzer.cargo.extraEnv#`.\",\n                     \"default\": {},\n                     \"type\": \"object\"\n                 },"}, {"sha": "b236b156cf99a505fec68c9302328211480b1e78", "filename": "lib/lsp-server/Cargo.toml", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e6540cff74534e6d9fb86d5d66e66423fad03766/lib%2Flsp-server%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/e6540cff74534e6d9fb86d5d66e66423fad03766/lib%2Flsp-server%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/lib%2Flsp-server%2FCargo.toml?ref=e6540cff74534e6d9fb86d5d66e66423fad03766", "patch": "@@ -1,16 +1,16 @@\n [package]\n name = \"lsp-server\"\n-version = \"0.6.0\"\n+version = \"0.7.0\"\n description = \"Generic LSP server scaffold.\"\n license = \"MIT OR Apache-2.0\"\n repository = \"https://github.com/rust-lang/rust-analyzer/tree/master/lib/lsp-server\"\n edition = \"2021\"\n \n [dependencies]\n log = \"0.4.17\"\n-serde_json = \"1.0.81\"\n-serde = { version = \"1.0.137\", features = [\"derive\"] }\n-crossbeam-channel = \"0.5.5\"\n+serde_json = \"1.0.85\"\n+serde = { version = \"1.0.144\", features = [\"derive\"] }\n+crossbeam-channel = \"0.5.6\"\n \n [dev-dependencies]\n-lsp-types = \"0.93.0\"\n+lsp-types = \"0.93.1\""}, {"sha": "b241561f9c0ddc80f4b821a01a46ddece489e8b4", "filename": "lib/lsp-server/src/msg.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e6540cff74534e6d9fb86d5d66e66423fad03766/lib%2Flsp-server%2Fsrc%2Fmsg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6540cff74534e6d9fb86d5d66e66423fad03766/lib%2Flsp-server%2Fsrc%2Fmsg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/lib%2Flsp-server%2Fsrc%2Fmsg.rs?ref=e6540cff74534e6d9fb86d5d66e66423fad03766", "patch": "@@ -98,7 +98,7 @@ pub struct ResponseError {\n }\n \n #[derive(Clone, Copy, Debug)]\n-#[allow(unused)]\n+#[non_exhaustive]\n pub enum ErrorCode {\n     // Defined by JSON RPC:\n     ParseError = -32700,\n@@ -135,6 +135,14 @@ pub enum ErrorCode {\n     ///\n     /// @since 3.17.0\n     ServerCancelled = -32802,\n+\n+    /// A request failed but it was syntactically correct, e.g the\n+    /// method name was known and the parameters were valid. The error\n+    /// message should contain human readable information about why\n+    /// the request failed.\n+    ///\n+    /// @since 3.17.0\n+    RequestFailed = -32803,\n }\n \n #[derive(Debug, Serialize, Deserialize, Clone)]"}, {"sha": "e5f19be20b069d5a7df710fe1fcf6a0a6913dccf", "filename": "lib/lsp-server/src/req_queue.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e6540cff74534e6d9fb86d5d66e66423fad03766/lib%2Flsp-server%2Fsrc%2Freq_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6540cff74534e6d9fb86d5d66e66423fad03766/lib%2Flsp-server%2Fsrc%2Freq_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/lib%2Flsp-server%2Fsrc%2Freq_queue.rs?ref=e6540cff74534e6d9fb86d5d66e66423fad03766", "patch": "@@ -35,6 +35,7 @@ impl<I> Incoming<I> {\n     pub fn register(&mut self, id: RequestId, data: I) {\n         self.pending.insert(id, data);\n     }\n+\n     pub fn cancel(&mut self, id: RequestId) -> Option<Response> {\n         let _data = self.complete(id.clone())?;\n         let error = ResponseError {\n@@ -44,9 +45,14 @@ impl<I> Incoming<I> {\n         };\n         Some(Response { id, result: None, error: Some(error) })\n     }\n+\n     pub fn complete(&mut self, id: RequestId) -> Option<I> {\n         self.pending.remove(&id)\n     }\n+\n+    pub fn is_completed(&self, id: &RequestId) -> bool {\n+        !self.pending.contains_key(id)\n+    }\n }\n \n impl<O> Outgoing<O> {\n@@ -56,6 +62,7 @@ impl<O> Outgoing<O> {\n         self.next_id += 1;\n         Request::new(id, method, params)\n     }\n+\n     pub fn complete(&mut self, id: RequestId) -> Option<O> {\n         self.pending.remove(&id)\n     }"}, {"sha": "14816912b720d369a7cb75178bd5557f9d81a18f", "filename": "xtask/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e6540cff74534e6d9fb86d5d66e66423fad03766/xtask%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/e6540cff74534e6d9fb86d5d66e66423fad03766/xtask%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2FCargo.toml?ref=e6540cff74534e6d9fb86d5d66e66423fad03766", "patch": "@@ -11,5 +11,5 @@ anyhow = \"1.0.57\"\n flate2 = \"1.0.24\"\n write-json = \"0.1.2\"\n xshell = \"0.2.2\"\n-xflags = \"0.2.4\"\n+xflags = \"0.3.0\"\n # Avoid adding more dependencies to this crate"}, {"sha": "0fce48898349a8580c046e9dbcc0a6587c2374df", "filename": "xtask/src/flags.rs", "status": "modified", "additions": 6, "deletions": 13, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e6540cff74534e6d9fb86d5d66e66423fad03766/xtask%2Fsrc%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6540cff74534e6d9fb86d5d66e66423fad03766/xtask%2Fsrc%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Fflags.rs?ref=e6540cff74534e6d9fb86d5d66e66423fad03766", "patch": "@@ -7,10 +7,6 @@ xflags::xflags! {\n \n     /// Run custom build command.\n     cmd xtask {\n-        default cmd help {\n-            /// Print help information.\n-            optional -h, --help\n-        }\n \n         /// Install rust-analyzer server or editor plugin.\n         cmd install {\n@@ -42,9 +38,9 @@ xflags::xflags! {\n             optional --dry-run\n         }\n         /// Builds a benchmark version of rust-analyzer and puts it into `./target`.\n-        cmd bb\n+        cmd bb {\n             required suffix: String\n-        {}\n+        }\n     }\n }\n \n@@ -58,7 +54,6 @@ pub struct Xtask {\n \n #[derive(Debug)]\n pub enum XtaskCmd {\n-    Help(Help),\n     Install(Install),\n     FuzzTests(FuzzTests),\n     Release(Release),\n@@ -68,11 +63,6 @@ pub enum XtaskCmd {\n     Bb(Bb),\n }\n \n-#[derive(Debug)]\n-pub struct Help {\n-    pub help: bool,\n-}\n-\n #[derive(Debug)]\n pub struct Install {\n     pub client: bool,\n@@ -111,7 +101,10 @@ pub struct Bb {\n }\n \n impl Xtask {\n-    pub const HELP: &'static str = Self::HELP_;\n+    #[allow(dead_code)]\n+    pub fn from_env_or_exit() -> Self {\n+        Self::from_env_or_exit_()\n+    }\n \n     #[allow(dead_code)]\n     pub fn from_env() -> xflags::Result<Self> {"}, {"sha": "a37f469adcb60771ef7c0e393b6d39e7cc7daf8b", "filename": "xtask/src/main.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e6540cff74534e6d9fb86d5d66e66423fad03766/xtask%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6540cff74534e6d9fb86d5d66e66423fad03766/xtask%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Fmain.rs?ref=e6540cff74534e6d9fb86d5d66e66423fad03766", "patch": "@@ -25,15 +25,12 @@ use std::{\n use xshell::{cmd, Shell};\n \n fn main() -> anyhow::Result<()> {\n+    let flags = flags::Xtask::from_env_or_exit();\n+\n     let sh = &Shell::new()?;\n     sh.change_dir(project_root());\n \n-    let flags = flags::Xtask::from_env()?;\n     match flags.subcommand {\n-        flags::XtaskCmd::Help(_) => {\n-            println!(\"{}\", flags::Xtask::HELP);\n-            Ok(())\n-        }\n         flags::XtaskCmd::Install(cmd) => cmd.run(sh),\n         flags::XtaskCmd::FuzzTests(_) => run_fuzzer(sh),\n         flags::XtaskCmd::Release(cmd) => cmd.run(sh),"}]}