{"sha": "5ac917dbb224de8445d1526c62b75941db5e5254", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVhYzkxN2RiYjIyNGRlODQ0NWQxNTI2YzYyYjc1OTQxZGI1ZTUyNTQ=", "commit": {"author": {"name": "lcnr", "email": "rust@lcnr.de", "date": "2021-03-12T10:48:05Z"}, "committer": {"name": "lcnr", "email": "rust@lcnr.de", "date": "2021-03-26T20:22:03Z"}, "message": "fix rustc_on_implemented `_Self` paths", "tree": {"sha": "51c45f0f1a6617cc42c211e349cd81fec17e325c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/51c45f0f1a6617cc42c211e349cd81fec17e325c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5ac917dbb224de8445d1526c62b75941db5e5254", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5ac917dbb224de8445d1526c62b75941db5e5254", "html_url": "https://github.com/rust-lang/rust/commit/5ac917dbb224de8445d1526c62b75941db5e5254", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5ac917dbb224de8445d1526c62b75941db5e5254/comments", "author": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "addc51a85f264e208385a8a1d10b6accb737ea8d", "url": "https://api.github.com/repos/rust-lang/rust/commits/addc51a85f264e208385a8a1d10b6accb737ea8d", "html_url": "https://github.com/rust-lang/rust/commit/addc51a85f264e208385a8a1d10b6accb737ea8d"}], "stats": {"total": 133, "additions": 71, "deletions": 62}, "files": [{"sha": "49ebca0502c089bee6303cccacd113c460b87df8", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/on_unimplemented.rs", "status": "modified", "additions": 51, "deletions": 47, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/5ac917dbb224de8445d1526c62b75941db5e5254/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ac917dbb224de8445d1526c62b75941db5e5254/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs?ref=5ac917dbb224de8445d1526c62b75941db5e5254", "patch": "@@ -163,61 +163,65 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             flags.push((sym::from_desugaring, None));\n             flags.push((sym::from_desugaring, Some(format!(\"{:?}\", k))));\n         }\n-        let generics = self.tcx.generics_of(def_id);\n-        let self_ty = trait_ref.self_ty();\n-        // This is also included through the generics list as `Self`,\n-        // but the parser won't allow you to use it\n-        flags.push((sym::_Self, Some(self_ty.to_string())));\n-        if let Some(def) = self_ty.ty_adt_def() {\n-            // We also want to be able to select self's original\n-            // signature with no type arguments resolved\n-            flags.push((sym::_Self, Some(self.tcx.type_of(def.did).to_string())));\n-        }\n \n-        for param in generics.params.iter() {\n-            let value = match param.kind {\n-                GenericParamDefKind::Type { .. } | GenericParamDefKind::Const { .. } => {\n-                    trait_ref.substs[param.index as usize].to_string()\n-                }\n-                GenericParamDefKind::Lifetime => continue,\n-            };\n-            let name = param.name;\n-            flags.push((name, Some(value)));\n-        }\n+        // Add all types without trimmed paths.\n+        ty::print::with_no_trimmed_paths(|| {\n+            let generics = self.tcx.generics_of(def_id);\n+            let self_ty = trait_ref.self_ty();\n+            // This is also included through the generics list as `Self`,\n+            // but the parser won't allow you to use it\n+            flags.push((sym::_Self, Some(self_ty.to_string())));\n+            if let Some(def) = self_ty.ty_adt_def() {\n+                // We also want to be able to select self's original\n+                // signature with no type arguments resolved\n+                flags.push((sym::_Self, Some(self.tcx.type_of(def.did).to_string())));\n+            }\n \n-        if let Some(true) = self_ty.ty_adt_def().map(|def| def.did.is_local()) {\n-            flags.push((sym::crate_local, None));\n-        }\n+            for param in generics.params.iter() {\n+                let value = match param.kind {\n+                    GenericParamDefKind::Type { .. } | GenericParamDefKind::Const { .. } => {\n+                        trait_ref.substs[param.index as usize].to_string()\n+                    }\n+                    GenericParamDefKind::Lifetime => continue,\n+                };\n+                let name = param.name;\n+                flags.push((name, Some(value)));\n+            }\n \n-        // Allow targeting all integers using `{integral}`, even if the exact type was resolved\n-        if self_ty.is_integral() {\n-            flags.push((sym::_Self, Some(\"{integral}\".to_owned())));\n-        }\n+            if let Some(true) = self_ty.ty_adt_def().map(|def| def.did.is_local()) {\n+                flags.push((sym::crate_local, None));\n+            }\n \n-        if let ty::Array(aty, len) = self_ty.kind() {\n-            flags.push((sym::_Self, Some(\"[]\".to_owned())));\n-            flags.push((sym::_Self, Some(format!(\"[{}]\", aty))));\n-            if let Some(def) = aty.ty_adt_def() {\n-                // We also want to be able to select the array's type's original\n-                // signature with no type arguments resolved\n-                let type_string = self.tcx.type_of(def.did).to_string();\n-                flags.push((sym::_Self, Some(format!(\"[{}]\", type_string))));\n+            // Allow targeting all integers using `{integral}`, even if the exact type was resolved\n+            if self_ty.is_integral() {\n+                flags.push((sym::_Self, Some(\"{integral}\".to_owned())));\n+            }\n \n-                let len = len.val.try_to_value().and_then(|v| v.try_to_machine_usize(self.tcx));\n-                let string = match len {\n-                    Some(n) => format!(\"[{}; {}]\", type_string, n),\n-                    None => format!(\"[{}; _]\", type_string),\n-                };\n-                flags.push((sym::_Self, Some(string)));\n+            if let ty::Array(aty, len) = self_ty.kind() {\n+                flags.push((sym::_Self, Some(\"[]\".to_owned())));\n+                flags.push((sym::_Self, Some(format!(\"[{}]\", aty))));\n+                if let Some(def) = aty.ty_adt_def() {\n+                    // We also want to be able to select the array's type's original\n+                    // signature with no type arguments resolved\n+                    let type_string = self.tcx.type_of(def.did).to_string();\n+                    flags.push((sym::_Self, Some(format!(\"[{}]\", type_string))));\n+\n+                    let len = len.val.try_to_value().and_then(|v| v.try_to_machine_usize(self.tcx));\n+                    let string = match len {\n+                        Some(n) => format!(\"[{}; {}]\", type_string, n),\n+                        None => format!(\"[{}; _]\", type_string),\n+                    };\n+                    flags.push((sym::_Self, Some(string)));\n+                }\n             }\n-        }\n-        if let ty::Dynamic(traits, _) = self_ty.kind() {\n-            for t in traits.iter() {\n-                if let ty::ExistentialPredicate::Trait(trait_ref) = t.skip_binder() {\n-                    flags.push((sym::_Self, Some(self.tcx.def_path_str(trait_ref.def_id))))\n+            if let ty::Dynamic(traits, _) = self_ty.kind() {\n+                for t in traits.iter() {\n+                    if let ty::ExistentialPredicate::Trait(trait_ref) = t.skip_binder() {\n+                        flags.push((sym::_Self, Some(self.tcx.def_path_str(trait_ref.def_id))))\n+                    }\n                 }\n             }\n-        }\n+        });\n \n         if let Ok(Some(command)) =\n             OnUnimplementedDirective::of_item(self.tcx, trait_ref.def_id, def_id)"}, {"sha": "7d58eb948ea815991b79245d2e926b075d1fd9c8", "filename": "src/test/ui/iterators/array-of-ranges.stderr", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5ac917dbb224de8445d1526c62b75941db5e5254/src%2Ftest%2Fui%2Fiterators%2Farray-of-ranges.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5ac917dbb224de8445d1526c62b75941db5e5254/src%2Ftest%2Fui%2Fiterators%2Farray-of-ranges.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fiterators%2Farray-of-ranges.stderr?ref=5ac917dbb224de8445d1526c62b75941db5e5254", "patch": "@@ -13,43 +13,43 @@ error[E0277]: `[RangeInclusive<{integer}>; 1]` is not an iterator\n   --> $DIR/array-of-ranges.rs:4:14\n    |\n LL |     for _ in [0..=1] {}\n-   |              ^^^^^^^ arrays do not yet implement `IntoIterator`; try using `std::array::IntoIter::new(arr)`\n+   |              ^^^^^^^ if you meant to iterate between two values, remove the square brackets\n    |\n    = help: the trait `Iterator` is not implemented for `[RangeInclusive<{integer}>; 1]`\n-   = note: see <https://github.com/rust-lang/rust/pull/65819> for more details\n+   = note: `[start..=end]` is an array of one `RangeInclusive`; you might have meant to have a `RangeInclusive` without the brackets: `start..=end`\n    = note: required because of the requirements on the impl of `IntoIterator` for `[RangeInclusive<{integer}>; 1]`\n    = note: required by `into_iter`\n \n error[E0277]: `[RangeFrom<{integer}>; 1]` is not an iterator\n   --> $DIR/array-of-ranges.rs:6:14\n    |\n LL |     for _ in [0..] {}\n-   |              ^^^^^ arrays do not yet implement `IntoIterator`; try using `std::array::IntoIter::new(arr)`\n+   |              ^^^^^ if you meant to iterate from a value onwards, remove the square brackets\n    |\n    = help: the trait `Iterator` is not implemented for `[RangeFrom<{integer}>; 1]`\n-   = note: see <https://github.com/rust-lang/rust/pull/65819> for more details\n+   = note: `[start..]` is an array of one `RangeFrom`; you might have meant to have a `RangeFrom` without the brackets: `start..`, keeping in mind that iterating over an unbounded iterator will run forever unless you `break` or `return` from within the loop\n    = note: required because of the requirements on the impl of `IntoIterator` for `[RangeFrom<{integer}>; 1]`\n    = note: required by `into_iter`\n \n error[E0277]: `[RangeTo<{integer}>; 1]` is not an iterator\n   --> $DIR/array-of-ranges.rs:8:14\n    |\n LL |     for _ in [..1] {}\n-   |              ^^^^^ arrays do not yet implement `IntoIterator`; try using `std::array::IntoIter::new(arr)`\n+   |              ^^^^^ if you meant to iterate until a value, remove the square brackets and add a starting value\n    |\n    = help: the trait `Iterator` is not implemented for `[RangeTo<{integer}>; 1]`\n-   = note: see <https://github.com/rust-lang/rust/pull/65819> for more details\n+   = note: `[..end]` is an array of one `RangeTo`; you might have meant to have a bounded `Range` without the brackets: `0..end`\n    = note: required because of the requirements on the impl of `IntoIterator` for `[RangeTo<{integer}>; 1]`\n    = note: required by `into_iter`\n \n error[E0277]: `[RangeToInclusive<{integer}>; 1]` is not an iterator\n   --> $DIR/array-of-ranges.rs:10:14\n    |\n LL |     for _ in [..=1] {}\n-   |              ^^^^^^ arrays do not yet implement `IntoIterator`; try using `std::array::IntoIter::new(arr)`\n+   |              ^^^^^^ if you meant to iterate until a value (including it), remove the square brackets and add a starting value\n    |\n    = help: the trait `Iterator` is not implemented for `[RangeToInclusive<{integer}>; 1]`\n-   = note: see <https://github.com/rust-lang/rust/pull/65819> for more details\n+   = note: `[..=end]` is an array of one `RangeToInclusive`; you might have meant to have a bounded `RangeInclusive` without the brackets: `0..=end`\n    = note: required because of the requirements on the impl of `IntoIterator` for `[RangeToInclusive<{integer}>; 1]`\n    = note: required by `into_iter`\n \n@@ -90,10 +90,10 @@ error[E0277]: `[RangeInclusive<{integer}>; 1]` is not an iterator\n   --> $DIR/array-of-ranges.rs:21:14\n    |\n LL |     for _ in [0..=1] {}\n-   |              ^^^^^^^ arrays do not yet implement `IntoIterator`; try using `std::array::IntoIter::new(arr)`\n+   |              ^^^^^^^ if you meant to iterate between two values, remove the square brackets\n    |\n    = help: the trait `Iterator` is not implemented for `[RangeInclusive<{integer}>; 1]`\n-   = note: see <https://github.com/rust-lang/rust/pull/65819> for more details\n+   = note: `[start..=end]` is an array of one `RangeInclusive`; you might have meant to have a `RangeInclusive` without the brackets: `start..=end`\n    = note: required because of the requirements on the impl of `IntoIterator` for `[RangeInclusive<{integer}>; 1]`\n    = note: required by `into_iter`\n "}, {"sha": "73844329e361d5d69c8773d8bae997318df9aa3e", "filename": "src/test/ui/iterators/ranges.stderr", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5ac917dbb224de8445d1526c62b75941db5e5254/src%2Ftest%2Fui%2Fiterators%2Franges.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5ac917dbb224de8445d1526c62b75941db5e5254/src%2Ftest%2Fui%2Fiterators%2Franges.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fiterators%2Franges.stderr?ref=5ac917dbb224de8445d1526c62b75941db5e5254", "patch": "@@ -2,19 +2,21 @@ error[E0277]: `RangeTo<{integer}>` is not an iterator\n   --> $DIR/ranges.rs:2:14\n    |\n LL |     for _ in ..10 {}\n-   |              ^^^^ `RangeTo<{integer}>` is not an iterator\n+   |              ^^^^ if you meant to iterate until a value, add a starting value\n    |\n    = help: the trait `Iterator` is not implemented for `RangeTo<{integer}>`\n+   = note: `..end` is a `RangeTo`, which cannot be iterated on; you might have meant to have a bounded `Range`: `0..end`\n    = note: required because of the requirements on the impl of `IntoIterator` for `RangeTo<{integer}>`\n    = note: required by `into_iter`\n \n error[E0277]: `RangeToInclusive<{integer}>` is not an iterator\n   --> $DIR/ranges.rs:4:14\n    |\n LL |     for _ in ..=10 {}\n-   |              ^^^^^ `RangeToInclusive<{integer}>` is not an iterator\n+   |              ^^^^^ if you meant to iterate until a value (including it), add a starting value\n    |\n    = help: the trait `Iterator` is not implemented for `RangeToInclusive<{integer}>`\n+   = note: `..=end` is a `RangeToInclusive`, which cannot be iterated on; you might have meant to have a bounded `RangeInclusive`: `0..=end`\n    = note: required because of the requirements on the impl of `IntoIterator` for `RangeToInclusive<{integer}>`\n    = note: required by `into_iter`\n "}, {"sha": "1d77bcb753630f860ce28fd2999e59ce91a3751e", "filename": "src/test/ui/iterators/string.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5ac917dbb224de8445d1526c62b75941db5e5254/src%2Ftest%2Fui%2Fiterators%2Fstring.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5ac917dbb224de8445d1526c62b75941db5e5254/src%2Ftest%2Fui%2Fiterators%2Fstring.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fiterators%2Fstring.stderr?ref=5ac917dbb224de8445d1526c62b75941db5e5254", "patch": "@@ -2,7 +2,7 @@ error[E0277]: `String` is not an iterator\n   --> $DIR/string.rs:2:14\n    |\n LL |     for _ in \"\".to_owned() {}\n-   |              ^^^^^^^^^^^^^ `String` is not an iterator\n+   |              ^^^^^^^^^^^^^ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n    |\n    = help: the trait `Iterator` is not implemented for `String`\n    = note: required because of the requirements on the impl of `IntoIterator` for `String`"}, {"sha": "3786457fb1ae3ac5fc54a2d2f83cd59ec9e5944f", "filename": "src/test/ui/suggestions/expected-boxed-future-isnt-pinned.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5ac917dbb224de8445d1526c62b75941db5e5254/src%2Ftest%2Fui%2Fsuggestions%2Fexpected-boxed-future-isnt-pinned.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5ac917dbb224de8445d1526c62b75941db5e5254/src%2Ftest%2Fui%2Fsuggestions%2Fexpected-boxed-future-isnt-pinned.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fexpected-boxed-future-isnt-pinned.stderr?ref=5ac917dbb224de8445d1526c62b75941db5e5254", "patch": "@@ -46,6 +46,7 @@ error[E0277]: `dyn Future<Output = i32> + Send` cannot be unpinned\n LL |     Pin::new(x)\n    |     ^^^^^^^^ the trait `Unpin` is not implemented for `dyn Future<Output = i32> + Send`\n    |\n+   = note: consider using `Box::pin`\n    = note: required by `Pin::<P>::new`\n \n error[E0277]: `dyn Future<Output = i32> + Send` cannot be unpinned\n@@ -54,6 +55,7 @@ error[E0277]: `dyn Future<Output = i32> + Send` cannot be unpinned\n LL |     Pin::new(Box::new(x))\n    |     ^^^^^^^^ the trait `Unpin` is not implemented for `dyn Future<Output = i32> + Send`\n    |\n+   = note: consider using `Box::pin`\n    = note: required by `Pin::<P>::new`\n \n error[E0308]: mismatched types"}, {"sha": "26efd50bb8fd3479c2eaaff85cf6e9109696a73b", "filename": "src/test/ui/suggestions/into-str.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5ac917dbb224de8445d1526c62b75941db5e5254/src%2Ftest%2Fui%2Fsuggestions%2Finto-str.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5ac917dbb224de8445d1526c62b75941db5e5254/src%2Ftest%2Fui%2Fsuggestions%2Finto-str.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Finto-str.stderr?ref=5ac917dbb224de8445d1526c62b75941db5e5254", "patch": "@@ -7,6 +7,7 @@ LL | fn foo<'a, T>(_t: T) where T: Into<&'a str> {}\n LL |     foo(String::new());\n    |     ^^^ the trait `From<String>` is not implemented for `&str`\n    |\n+   = note: to coerce a `String` into a `&str`, use `&*` as a prefix\n    = note: required because of the requirements on the impl of `Into<&str>` for `String`\n \n error: aborting due to previous error"}, {"sha": "3ee2860b4ffc7033b91131d17c06ce1bb59b5116", "filename": "src/test/ui/suggestions/path-display.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5ac917dbb224de8445d1526c62b75941db5e5254/src%2Ftest%2Fui%2Fsuggestions%2Fpath-display.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5ac917dbb224de8445d1526c62b75941db5e5254/src%2Ftest%2Fui%2Fsuggestions%2Fpath-display.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fpath-display.stderr?ref=5ac917dbb224de8445d1526c62b75941db5e5254", "patch": "@@ -2,10 +2,10 @@ error[E0277]: `Path` doesn't implement `std::fmt::Display`\n   --> $DIR/path-display.rs:5:20\n    |\n LL |     println!(\"{}\", path);\n-   |                    ^^^^ `Path` cannot be formatted with the default formatter\n+   |                    ^^^^ `Path` cannot be formatted with the default formatter; call `.display()` on it\n    |\n    = help: the trait `std::fmt::Display` is not implemented for `Path`\n-   = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead\n+   = note: call `.display()` or `.to_string_lossy()` to safely print paths, as they may contain non-Unicode data\n    = note: required because of the requirements on the impl of `std::fmt::Display` for `&Path`\n    = note: required by `std::fmt::Display::fmt`\n    = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)"}]}