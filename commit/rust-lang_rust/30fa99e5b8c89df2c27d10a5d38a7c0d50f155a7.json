{"sha": "30fa99e5b8c89df2c27d10a5d38a7c0d50f155a7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMwZmE5OWU1YjhjODlkZjJjMjdkMTBhNWQzOGE3YzBkNTBmMTU1YTc=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-07-03T10:31:52Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-07-04T06:08:45Z"}, "message": "move constructors to top", "tree": {"sha": "133ae8a9b706fc9ed9b9575d9edfd646eb50625c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/133ae8a9b706fc9ed9b9575d9edfd646eb50625c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/30fa99e5b8c89df2c27d10a5d38a7c0d50f155a7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/30fa99e5b8c89df2c27d10a5d38a7c0d50f155a7", "html_url": "https://github.com/rust-lang/rust/commit/30fa99e5b8c89df2c27d10a5d38a7c0d50f155a7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/30fa99e5b8c89df2c27d10a5d38a7c0d50f155a7/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "601bad86b227a73970a6912d1efea48553728b3d", "url": "https://api.github.com/repos/rust-lang/rust/commits/601bad86b227a73970a6912d1efea48553728b3d", "html_url": "https://github.com/rust-lang/rust/commit/601bad86b227a73970a6912d1efea48553728b3d"}], "stats": {"total": 102, "additions": 51, "deletions": 51}, "files": [{"sha": "b764f9678c5b4897891f4d8b6e9116a9ddd00fca", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 51, "deletions": 51, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/30fa99e5b8c89df2c27d10a5d38a7c0d50f155a7/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30fa99e5b8c89df2c27d10a5d38a7c0d50f155a7/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=30fa99e5b8c89df2c27d10a5d38a7c0d50f155a7", "patch": "@@ -46,6 +46,57 @@ pub struct StringReader<'a> {\n }\n \n impl<'a> StringReader<'a> {\n+    pub fn new(sess: &'a ParseSess,\n+               source_file: Lrc<syntax_pos::SourceFile>,\n+               override_span: Option<Span>) -> Self {\n+        let mut sr = StringReader::new_internal(sess, source_file, override_span);\n+        sr.bump();\n+        sr\n+    }\n+\n+    pub fn retokenize(sess: &'a ParseSess, mut span: Span) -> Self {\n+        let begin = sess.source_map().lookup_byte_offset(span.lo());\n+        let end = sess.source_map().lookup_byte_offset(span.hi());\n+\n+        // Make the range zero-length if the span is invalid.\n+        if span.lo() > span.hi() || begin.sf.start_pos != end.sf.start_pos {\n+            span = span.shrink_to_lo();\n+        }\n+\n+        let mut sr = StringReader::new_internal(sess, begin.sf, None);\n+\n+        // Seek the lexer to the right byte range.\n+        sr.next_pos = span.lo();\n+        sr.end_src_index = sr.src_index(span.hi());\n+\n+        sr.bump();\n+\n+        sr\n+    }\n+\n+    fn new_internal(sess: &'a ParseSess, source_file: Lrc<syntax_pos::SourceFile>,\n+        override_span: Option<Span>) -> Self\n+    {\n+        if source_file.src.is_none() {\n+            sess.span_diagnostic.bug(&format!(\"Cannot lex source_file without source: {}\",\n+                                              source_file.name));\n+        }\n+\n+        let src = (*source_file.src.as_ref().unwrap()).clone();\n+\n+        StringReader {\n+            sess,\n+            next_pos: source_file.start_pos,\n+            pos: source_file.start_pos,\n+            ch: Some('\\n'),\n+            source_file,\n+            end_src_index: src.len(),\n+            src,\n+            fatal_errs: Vec::new(),\n+            override_span,\n+        }\n+    }\n+\n     fn mk_sp(&self, lo: BytePos, hi: BytePos) -> Span {\n         self.mk_sp_and_raw(lo, hi).0\n     }\n@@ -149,57 +200,6 @@ impl<'a> StringReader<'a> {\n         buffer\n     }\n \n-    pub fn new(sess: &'a ParseSess,\n-               source_file: Lrc<syntax_pos::SourceFile>,\n-               override_span: Option<Span>) -> Self {\n-        let mut sr = StringReader::new_internal(sess, source_file, override_span);\n-        sr.bump();\n-        sr\n-    }\n-\n-    fn new_internal(sess: &'a ParseSess, source_file: Lrc<syntax_pos::SourceFile>,\n-        override_span: Option<Span>) -> Self\n-    {\n-        if source_file.src.is_none() {\n-            sess.span_diagnostic.bug(&format!(\"Cannot lex source_file without source: {}\",\n-                                              source_file.name));\n-        }\n-\n-        let src = (*source_file.src.as_ref().unwrap()).clone();\n-\n-        StringReader {\n-            sess,\n-            next_pos: source_file.start_pos,\n-            pos: source_file.start_pos,\n-            ch: Some('\\n'),\n-            source_file,\n-            end_src_index: src.len(),\n-            src,\n-            fatal_errs: Vec::new(),\n-            override_span,\n-        }\n-    }\n-\n-    pub fn retokenize(sess: &'a ParseSess, mut span: Span) -> Self {\n-        let begin = sess.source_map().lookup_byte_offset(span.lo());\n-        let end = sess.source_map().lookup_byte_offset(span.hi());\n-\n-        // Make the range zero-length if the span is invalid.\n-        if span.lo() > span.hi() || begin.sf.start_pos != end.sf.start_pos {\n-            span = span.shrink_to_lo();\n-        }\n-\n-        let mut sr = StringReader::new_internal(sess, begin.sf, None);\n-\n-        // Seek the lexer to the right byte range.\n-        sr.next_pos = span.lo();\n-        sr.end_src_index = sr.src_index(span.hi());\n-\n-        sr.bump();\n-\n-        sr\n-    }\n-\n     #[inline]\n     fn ch_is(&self, c: char) -> bool {\n         self.ch == Some(c)"}]}