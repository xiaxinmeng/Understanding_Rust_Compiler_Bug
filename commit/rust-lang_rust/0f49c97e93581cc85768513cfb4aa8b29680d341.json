{"sha": "0f49c97e93581cc85768513cfb4aa8b29680d341", "node_id": "C_kwDOAAsO6NoAKDBmNDljOTdlOTM1ODFjYzg1NzY4NTEzY2ZiNGFhOGIyOTY4MGQzNDE", "commit": {"author": {"name": "hamidreza kalbasi", "email": "hamidrezakalbasi@protonmail.com", "date": "2021-10-01T13:07:11Z"}, "committer": {"name": "hkalbasi", "email": "hamidrezakalbasi@protonmail.com", "date": "2021-10-12T08:24:00Z"}, "message": "internal changes for mdbook", "tree": {"sha": "76e0930d819f0b7421b7bd6c7d91a67f5b81633d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/76e0930d819f0b7421b7bd6c7d91a67f5b81633d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0f49c97e93581cc85768513cfb4aa8b29680d341", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0f49c97e93581cc85768513cfb4aa8b29680d341", "html_url": "https://github.com/rust-lang/rust/commit/0f49c97e93581cc85768513cfb4aa8b29680d341", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0f49c97e93581cc85768513cfb4aa8b29680d341/comments", "author": {"login": "HKalbasi", "id": 45197576, "node_id": "MDQ6VXNlcjQ1MTk3NTc2", "avatar_url": "https://avatars.githubusercontent.com/u/45197576?v=4", "gravatar_id": "", "url": "https://api.github.com/users/HKalbasi", "html_url": "https://github.com/HKalbasi", "followers_url": "https://api.github.com/users/HKalbasi/followers", "following_url": "https://api.github.com/users/HKalbasi/following{/other_user}", "gists_url": "https://api.github.com/users/HKalbasi/gists{/gist_id}", "starred_url": "https://api.github.com/users/HKalbasi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/HKalbasi/subscriptions", "organizations_url": "https://api.github.com/users/HKalbasi/orgs", "repos_url": "https://api.github.com/users/HKalbasi/repos", "events_url": "https://api.github.com/users/HKalbasi/events{/privacy}", "received_events_url": "https://api.github.com/users/HKalbasi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "HKalbasi", "id": 45197576, "node_id": "MDQ6VXNlcjQ1MTk3NTc2", "avatar_url": "https://avatars.githubusercontent.com/u/45197576?v=4", "gravatar_id": "", "url": "https://api.github.com/users/HKalbasi", "html_url": "https://github.com/HKalbasi", "followers_url": "https://api.github.com/users/HKalbasi/followers", "following_url": "https://api.github.com/users/HKalbasi/following{/other_user}", "gists_url": "https://api.github.com/users/HKalbasi/gists{/gist_id}", "starred_url": "https://api.github.com/users/HKalbasi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/HKalbasi/subscriptions", "organizations_url": "https://api.github.com/users/HKalbasi/orgs", "repos_url": "https://api.github.com/users/HKalbasi/repos", "events_url": "https://api.github.com/users/HKalbasi/events{/privacy}", "received_events_url": "https://api.github.com/users/HKalbasi/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5bd0f50111cce297b397c6549427e78c7c1da5c0", "url": "https://api.github.com/repos/rust-lang/rust/commits/5bd0f50111cce297b397c6549427e78c7c1da5c0", "html_url": "https://github.com/rust-lang/rust/commit/5bd0f50111cce297b397c6549427e78c7c1da5c0"}], "stats": {"total": 50, "additions": 41, "deletions": 9}, "files": [{"sha": "94caa5bbb13bc7fabd340d2c42bb77f86c845863", "filename": "crates/ide/src/static_index.rs", "status": "modified", "additions": 33, "deletions": 7, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/0f49c97e93581cc85768513cfb4aa8b29680d341/crates%2Fide%2Fsrc%2Fstatic_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f49c97e93581cc85768513cfb4aa8b29680d341/crates%2Fide%2Fsrc%2Fstatic_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fstatic_index.rs?ref=0f49c97e93581cc85768513cfb4aa8b29680d341", "patch": "@@ -14,11 +14,14 @@ use syntax::{SyntaxToken, TextRange};\n \n use crate::display::TryToNav;\n use crate::hover::hover_for_definition;\n-use crate::{Analysis, Fold, HoverConfig, HoverDocFormat, HoverResult};\n+use crate::{\n+    Analysis, Fold, HoverConfig, HoverDocFormat, HoverResult, InlayHint, InlayHintsConfig,\n+};\n \n /// A static representation of fully analyzed source code.\n ///\n /// The intended use-case is powering read-only code browsers and emitting LSIF\n+#[derive(Debug)]\n pub struct StaticIndex<'a> {\n     pub files: Vec<StaticIndexedFile>,\n     pub tokens: TokenStore,\n@@ -27,21 +30,29 @@ pub struct StaticIndex<'a> {\n     def_map: HashMap<Definition, TokenId>,\n }\n \n+#[derive(Debug)]\n pub struct ReferenceData {\n     pub range: FileRange,\n     pub is_definition: bool,\n }\n \n+#[derive(Debug)]\n pub struct TokenStaticData {\n     pub hover: Option<HoverResult>,\n     pub definition: Option<FileRange>,\n     pub references: Vec<ReferenceData>,\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, Hash)]\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct TokenId(usize);\n \n-#[derive(Default)]\n+impl TokenId {\n+    pub fn raw(self) -> usize {\n+        self.0\n+    }\n+}\n+\n+#[derive(Default, Debug)]\n pub struct TokenStore(Vec<TokenStaticData>);\n \n impl TokenStore {\n@@ -64,9 +75,11 @@ impl TokenStore {\n     }\n }\n \n+#[derive(Debug)]\n pub struct StaticIndexedFile {\n     pub file_id: FileId,\n     pub folds: Vec<Fold>,\n+    pub inlay_hints: Vec<InlayHint>,\n     pub tokens: Vec<(TextRange, TokenId)>,\n }\n \n@@ -86,6 +99,18 @@ fn all_modules(db: &dyn HirDatabase) -> Vec<Module> {\n impl StaticIndex<'_> {\n     fn add_file(&mut self, file_id: FileId) {\n         let folds = self.analysis.folding_ranges(file_id).unwrap();\n+        let inlay_hints = self\n+            .analysis\n+            .inlay_hints(\n+                &InlayHintsConfig {\n+                    type_hints: true,\n+                    parameter_hints: true,\n+                    chaining_hints: true,\n+                    max_length: Some(25),\n+                },\n+                file_id,\n+            )\n+            .unwrap();\n         // hovers\n         let sema = hir::Semantics::new(self.db);\n         let tokens_or_nodes = sema.parse(file_id).syntax().clone();\n@@ -99,7 +124,7 @@ impl StaticIndex<'_> {\n             IDENT | INT_NUMBER | LIFETIME_IDENT | T![self] | T![super] | T![crate] => true,\n             _ => false,\n         });\n-        let mut result = StaticIndexedFile { file_id, folds, tokens: vec![] };\n+        let mut result = StaticIndexedFile { file_id, inlay_hints, folds, tokens: vec![] };\n         for token in tokens {\n             let range = token.text_range();\n             let node = token.parent().unwrap();\n@@ -135,7 +160,8 @@ impl StaticIndex<'_> {\n         self.files.push(result);\n     }\n \n-    pub fn compute<'a>(db: &'a RootDatabase, analysis: &'a Analysis) -> StaticIndex<'a> {\n+    pub fn compute<'a>(analysis: &'a Analysis) -> StaticIndex<'a> {\n+        let db = &*analysis.db;\n         let work = all_modules(db).into_iter().filter(|module| {\n             let file_id = module.definition_source(db).file_id.original_file(db);\n             let source_root = db.file_source_root(file_id);\n@@ -183,7 +209,7 @@ mod tests {\n \n     fn check_all_ranges(ra_fixture: &str) {\n         let (analysis, ranges) = fixture::annotations_without_marker(ra_fixture);\n-        let s = StaticIndex::compute(&*analysis.db, &analysis);\n+        let s = StaticIndex::compute(&analysis);\n         let mut range_set: HashSet<_> = ranges.iter().map(|x| x.0).collect();\n         for f in s.files {\n             for (range, _) in f.tokens {\n@@ -201,7 +227,7 @@ mod tests {\n \n     fn check_definitions(ra_fixture: &str) {\n         let (analysis, ranges) = fixture::annotations_without_marker(ra_fixture);\n-        let s = StaticIndex::compute(&*analysis.db, &analysis);\n+        let s = StaticIndex::compute(&analysis);\n         let mut range_set: HashSet<_> = ranges.iter().map(|x| x.0).collect();\n         for (_, t) in s.tokens.iter() {\n             if let Some(x) = t.definition {"}, {"sha": "1b57dd3b30edb4f454257d00003cb531b412bbc5", "filename": "crates/rust-analyzer/src/cli/lsif.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f49c97e93581cc85768513cfb4aa8b29680d341/crates%2Frust-analyzer%2Fsrc%2Fcli%2Flsif.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f49c97e93581cc85768513cfb4aa8b29680d341/crates%2Frust-analyzer%2Fsrc%2Fcli%2Flsif.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcli%2Flsif.rs?ref=0f49c97e93581cc85768513cfb4aa8b29680d341", "patch": "@@ -186,7 +186,7 @@ impl LsifManager<'_> {\n     }\n \n     fn add_file(&mut self, file: StaticIndexedFile) {\n-        let StaticIndexedFile { file_id, tokens, folds } = file;\n+        let StaticIndexedFile { file_id, tokens, folds, .. } = file;\n         let doc_id = self.get_file_id(file_id);\n         let text = self.analysis.file_text(file_id).unwrap();\n         let line_index = self.db.line_index(file_id);\n@@ -247,7 +247,7 @@ impl flags::Lsif {\n         let db = host.raw_database();\n         let analysis = host.analysis();\n \n-        let si = StaticIndex::compute(db, &analysis);\n+        let si = StaticIndex::compute(&analysis);\n \n         let mut lsif = LsifManager::new(&analysis, db, &vfs);\n         lsif.add_vertex(lsif::Vertex::MetaData(lsif::MetaData {"}, {"sha": "9b1a013b6d6cb4457902ee2e885fcea64c8a8db9", "filename": "crates/vfs/src/vfs_path.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0f49c97e93581cc85768513cfb4aa8b29680d341/crates%2Fvfs%2Fsrc%2Fvfs_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f49c97e93581cc85768513cfb4aa8b29680d341/crates%2Fvfs%2Fsrc%2Fvfs_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fvfs%2Fsrc%2Fvfs_path.rs?ref=0f49c97e93581cc85768513cfb4aa8b29680d341", "patch": "@@ -25,6 +25,12 @@ impl VfsPath {\n         VfsPath(VfsPathRepr::VirtualPath(VirtualPath(path)))\n     }\n \n+    /// Create a path from string. Input should be a string representation of\n+    /// an absolute path inside filesystem\n+    pub fn new_real_path(path: String) -> VfsPath {\n+        VfsPath::from(AbsPathBuf::assert(path.into()))\n+    }\n+\n     /// Returns the `AbsPath` representation of `self` if `self` is on the file system.\n     pub fn as_path(&self) -> Option<&AbsPath> {\n         match &self.0 {"}]}