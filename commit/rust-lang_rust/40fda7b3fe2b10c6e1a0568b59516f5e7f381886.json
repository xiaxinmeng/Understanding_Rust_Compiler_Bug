{"sha": "40fda7b3fe2b10c6e1a0568b59516f5e7f381886", "node_id": "C_kwDOAAsO6NoAKDQwZmRhN2IzZmUyYjEwYzZlMWEwNTY4YjU5NTE2ZjVlN2YzODE4ODY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-01-26T09:14:05Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-01-26T09:14:05Z"}, "message": "Auto merge of #107318 - matthiaskrgr:rollup-776kd81, r=matthiaskrgr\n\nRollup of 9 pull requests\n\nSuccessful merges:\n\n - #97373 (impl DispatchFromDyn for Cell and UnsafeCell)\n - #106625 (Remove backwards compat for LLVM 12 coverage format)\n - #106779 (Avoid __cxa_thread_atexit_impl on Emscripten)\n - #106811 (Append .dwp to the binary filename instead of replacing the existing extension.)\n - #106836 (Remove optimistic spinning from `mpsc::SyncSender`)\n - #106946 (implement Hash for proc_macro::LineColumn)\n - #107074 (remove unnecessary check for opaque types)\n - #107287 (Improve fn pointer notes)\n - #107304 (Use `can_eq` to compare types for default assoc type error)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "ae294b803823ef3df187e049bbee2d16c0eddbc6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ae294b803823ef3df187e049bbee2d16c0eddbc6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/40fda7b3fe2b10c6e1a0568b59516f5e7f381886", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/40fda7b3fe2b10c6e1a0568b59516f5e7f381886", "html_url": "https://github.com/rust-lang/rust/commit/40fda7b3fe2b10c6e1a0568b59516f5e7f381886", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/40fda7b3fe2b10c6e1a0568b59516f5e7f381886/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e187f8871e3d553181c9d2d4ac111197a139ca0d", "url": "https://api.github.com/repos/rust-lang/rust/commits/e187f8871e3d553181c9d2d4ac111197a139ca0d", "html_url": "https://github.com/rust-lang/rust/commit/e187f8871e3d553181c9d2d4ac111197a139ca0d"}, {"sha": "3aeafca070dbb6234646714db2fe0b960d7e2d80", "url": "https://api.github.com/repos/rust-lang/rust/commits/3aeafca070dbb6234646714db2fe0b960d7e2d80", "html_url": "https://github.com/rust-lang/rust/commit/3aeafca070dbb6234646714db2fe0b960d7e2d80"}], "stats": {"total": 1674, "additions": 942, "deletions": 732}, "files": [{"sha": "d9a73c7a5c9043fe42934215ee4789e974010fe6", "filename": "compiler/rustc_codegen_llvm/src/coverageinfo/mapgen.rs", "status": "modified", "additions": 17, "deletions": 28, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/40fda7b3fe2b10c6e1a0568b59516f5e7f381886/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmapgen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40fda7b3fe2b10c6e1a0568b59516f5e7f381886/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmapgen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmapgen.rs?ref=40fda7b3fe2b10c6e1a0568b59516f5e7f381886", "patch": "@@ -1,6 +1,5 @@\n use crate::common::CodegenCx;\n use crate::coverageinfo;\n-use crate::errors::InstrumentCoverageRequiresLLVM12;\n use crate::llvm;\n \n use llvm::coverageinfo::CounterMappingRegion;\n@@ -19,8 +18,8 @@ use std::ffi::CString;\n \n /// Generates and exports the Coverage Map.\n ///\n-/// Rust Coverage Map generation supports LLVM Coverage Mapping Format versions\n-/// 5 (LLVM 12, only) and 6 (zero-based encoded as 4 and 5, respectively), as defined at\n+/// Rust Coverage Map generation supports LLVM Coverage Mapping Format version\n+/// 6 (zero-based encoded as 5), as defined at\n /// [LLVM Code Coverage Mapping Format](https://github.com/rust-lang/llvm-project/blob/rustc/13.0-2021-09-30/llvm/docs/CoverageMappingFormat.rst#llvm-code-coverage-mapping-format).\n /// These versions are supported by the LLVM coverage tools (`llvm-profdata` and `llvm-cov`)\n /// bundled with Rust's fork of LLVM.\n@@ -33,13 +32,10 @@ use std::ffi::CString;\n pub fn finalize(cx: &CodegenCx<'_, '_>) {\n     let tcx = cx.tcx;\n \n-    // Ensure the installed version of LLVM supports at least Coverage Map\n-    // Version 5 (encoded as a zero-based value: 4), which was introduced with\n-    // LLVM 12.\n+    // Ensure the installed version of LLVM supports Coverage Map Version 6\n+    // (encoded as a zero-based value: 5), which was introduced with LLVM 13.\n     let version = coverageinfo::mapping_version();\n-    if version < 4 {\n-        tcx.sess.emit_fatal(InstrumentCoverageRequiresLLVM12);\n-    }\n+    assert_eq!(version, 5, \"The `CoverageMappingVersion` exposed by `llvm-wrapper` is out of sync\");\n \n     debug!(\"Generating coverage map for CodegenUnit: `{}`\", cx.codegen_unit.name());\n \n@@ -61,7 +57,7 @@ pub fn finalize(cx: &CodegenCx<'_, '_>) {\n         return;\n     }\n \n-    let mut mapgen = CoverageMapGenerator::new(tcx, version);\n+    let mut mapgen = CoverageMapGenerator::new(tcx);\n \n     // Encode coverage mappings and generate function records\n     let mut function_data = Vec::new();\n@@ -124,25 +120,18 @@ struct CoverageMapGenerator {\n }\n \n impl CoverageMapGenerator {\n-    fn new(tcx: TyCtxt<'_>, version: u32) -> Self {\n+    fn new(tcx: TyCtxt<'_>) -> Self {\n         let mut filenames = FxIndexSet::default();\n-        if version >= 5 {\n-            // LLVM Coverage Mapping Format version 6 (zero-based encoded as 5)\n-            // requires setting the first filename to the compilation directory.\n-            // Since rustc generates coverage maps with relative paths, the\n-            // compilation directory can be combined with the relative paths\n-            // to get absolute paths, if needed.\n-            let working_dir = tcx\n-                .sess\n-                .opts\n-                .working_dir\n-                .remapped_path_if_available()\n-                .to_string_lossy()\n-                .to_string();\n-            let c_filename =\n-                CString::new(working_dir).expect(\"null error converting filename to C string\");\n-            filenames.insert(c_filename);\n-        }\n+        // LLVM Coverage Mapping Format version 6 (zero-based encoded as 5)\n+        // requires setting the first filename to the compilation directory.\n+        // Since rustc generates coverage maps with relative paths, the\n+        // compilation directory can be combined with the relative paths\n+        // to get absolute paths, if needed.\n+        let working_dir =\n+            tcx.sess.opts.working_dir.remapped_path_if_available().to_string_lossy().to_string();\n+        let c_filename =\n+            CString::new(working_dir).expect(\"null error converting filename to C string\");\n+        filenames.insert(c_filename);\n         Self { filenames }\n     }\n "}, {"sha": "001d1ce93d8b479ee6184658373b78504813dab9", "filename": "compiler/rustc_codegen_llvm/src/errors.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/40fda7b3fe2b10c6e1a0568b59516f5e7f381886/compiler%2Frustc_codegen_llvm%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40fda7b3fe2b10c6e1a0568b59516f5e7f381886/compiler%2Frustc_codegen_llvm%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Ferrors.rs?ref=40fda7b3fe2b10c6e1a0568b59516f5e7f381886", "patch": "@@ -39,10 +39,6 @@ pub(crate) struct ErrorCreatingImportLibrary<'a> {\n     pub error: String,\n }\n \n-#[derive(Diagnostic)]\n-#[diag(codegen_llvm_instrument_coverage_requires_llvm_12)]\n-pub(crate) struct InstrumentCoverageRequiresLLVM12;\n-\n #[derive(Diagnostic)]\n #[diag(codegen_llvm_symbol_already_defined)]\n pub(crate) struct SymbolAlreadyDefined<'a> {"}, {"sha": "0a7bf6ff00c73b6d2eeb0b66f11a4c67793afdaf", "filename": "compiler/rustc_codegen_ssa/src/back/link.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/40fda7b3fe2b10c6e1a0568b59516f5e7f381886/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40fda7b3fe2b10c6e1a0568b59516f5e7f381886/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs?ref=40fda7b3fe2b10c6e1a0568b59516f5e7f381886", "patch": "@@ -599,7 +599,8 @@ fn link_dwarf_object<'a>(\n     cg_results: &CodegenResults,\n     executable_out_filename: &Path,\n ) {\n-    let dwp_out_filename = executable_out_filename.with_extension(\"dwp\");\n+    let mut dwp_out_filename = executable_out_filename.to_path_buf().into_os_string();\n+    dwp_out_filename.push(\".dwp\");\n     debug!(?dwp_out_filename, ?executable_out_filename);\n \n     #[derive(Default)]"}, {"sha": "3f83d40755ad8ea49116e5f2fa5cb538206da37d", "filename": "compiler/rustc_const_eval/src/transform/validate.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/40fda7b3fe2b10c6e1a0568b59516f5e7f381886/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40fda7b3fe2b10c6e1a0568b59516f5e7f381886/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs?ref=40fda7b3fe2b10c6e1a0568b59516f5e7f381886", "patch": "@@ -13,7 +13,7 @@ use rustc_middle::mir::{\n     ProjectionElem, RetagKind, RuntimePhase, Rvalue, SourceScope, Statement, StatementKind,\n     Terminator, TerminatorKind, UnOp, START_BLOCK,\n };\n-use rustc_middle::ty::{self, InstanceDef, ParamEnv, Ty, TyCtxt, TypeVisitable};\n+use rustc_middle::ty::{self, InstanceDef, ParamEnv, Ty, TyCtxt};\n use rustc_mir_dataflow::impls::MaybeStorageLive;\n use rustc_mir_dataflow::storage::always_storage_live_locals;\n use rustc_mir_dataflow::{Analysis, ResultsCursor};\n@@ -230,11 +230,6 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             // Equal types, all is good.\n             return true;\n         }\n-        // Normalization reveals opaque types, but we may be validating MIR while computing\n-        // said opaque types, causing cycles.\n-        if (src, dest).has_opaque_types() {\n-            return true;\n-        }\n \n         crate::util::is_subtype(self.tcx, self.param_env, src, dest)\n     }"}, {"sha": "b82c903290b9a2c10c42db4fcfd036335bbdd8d4", "filename": "compiler/rustc_error_messages/locales/en-US/codegen_llvm.ftl", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/40fda7b3fe2b10c6e1a0568b59516f5e7f381886/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fcodegen_llvm.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/40fda7b3fe2b10c6e1a0568b59516f5e7f381886/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fcodegen_llvm.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fcodegen_llvm.ftl?ref=40fda7b3fe2b10c6e1a0568b59516f5e7f381886", "patch": "@@ -11,9 +11,6 @@ codegen_llvm_unknown_ctarget_feature_prefix =\n codegen_llvm_error_creating_import_library =\n     Error creating import library for {$lib_name}: {$error}\n \n-codegen_llvm_instrument_coverage_requires_llvm_12 =\n-    rustc option `-C instrument-coverage` requires LLVM 12 or higher.\n-\n codegen_llvm_symbol_already_defined =\n     symbol `{$symbol_name}` is already defined\n "}, {"sha": "d19a0007f0880f7ac0f7083ea5cef9bbb23444dc", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/40fda7b3fe2b10c6e1a0568b59516f5e7f381886/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40fda7b3fe2b10c6e1a0568b59516f5e7f381886/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=40fda7b3fe2b10c6e1a0568b59516f5e7f381886", "patch": "@@ -79,6 +79,7 @@ use std::path::PathBuf;\n use std::{cmp, fmt, iter};\n \n mod note;\n+mod note_and_explain;\n mod suggest;\n \n pub(crate) mod need_type_info;\n@@ -1846,7 +1847,8 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n         }\n \n         self.check_and_note_conflicting_crates(diag, terr);\n-        self.tcx.note_and_explain_type_err(diag, terr, cause, span, cause.body_id.to_def_id());\n+\n+        self.note_and_explain_type_err(diag, terr, cause, span, cause.body_id.to_def_id());\n \n         if let Some(ValuePairs::PolyTraitRefs(exp_found)) = values\n             && let ty::Closure(def_id, _) = exp_found.expected.skip_binder().self_ty().kind()"}, {"sha": "425cde3302db8b64aa8e5d1bc391e06025278dc0", "filename": "compiler/rustc_infer/src/infer/error_reporting/note_and_explain.rs", "status": "added", "additions": 654, "deletions": 0, "changes": 654, "blob_url": "https://github.com/rust-lang/rust/blob/40fda7b3fe2b10c6e1a0568b59516f5e7f381886/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote_and_explain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40fda7b3fe2b10c6e1a0568b59516f5e7f381886/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote_and_explain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote_and_explain.rs?ref=40fda7b3fe2b10c6e1a0568b59516f5e7f381886", "patch": "@@ -0,0 +1,654 @@\n+use super::TypeErrCtxt;\n+use rustc_errors::Applicability::{MachineApplicable, MaybeIncorrect};\n+use rustc_errors::{pluralize, Diagnostic, MultiSpan};\n+use rustc_hir::{self as hir, def::DefKind};\n+use rustc_middle::traits::ObligationCauseCode;\n+use rustc_middle::ty::error::ExpectedFound;\n+use rustc_middle::ty::print::Printer;\n+use rustc_middle::{\n+    traits::ObligationCause,\n+    ty::{self, error::TypeError, print::FmtPrinter, suggest_constraining_type_param, Ty},\n+};\n+use rustc_span::{def_id::DefId, sym, BytePos, Span, Symbol};\n+\n+impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n+    pub fn note_and_explain_type_err(\n+        &self,\n+        diag: &mut Diagnostic,\n+        err: TypeError<'tcx>,\n+        cause: &ObligationCause<'tcx>,\n+        sp: Span,\n+        body_owner_def_id: DefId,\n+    ) {\n+        use ty::error::TypeError::*;\n+        debug!(\"note_and_explain_type_err err={:?} cause={:?}\", err, cause);\n+\n+        let tcx = self.tcx;\n+\n+        match err {\n+            ArgumentSorts(values, _) | Sorts(values) => {\n+                match (values.expected.kind(), values.found.kind()) {\n+                    (ty::Closure(..), ty::Closure(..)) => {\n+                        diag.note(\"no two closures, even if identical, have the same type\");\n+                        diag.help(\"consider boxing your closure and/or using it as a trait object\");\n+                    }\n+                    (ty::Alias(ty::Opaque, ..), ty::Alias(ty::Opaque, ..)) => {\n+                        // Issue #63167\n+                        diag.note(\"distinct uses of `impl Trait` result in different opaque types\");\n+                    }\n+                    (ty::Float(_), ty::Infer(ty::IntVar(_)))\n+                        if let Ok(\n+                            // Issue #53280\n+                            snippet,\n+                        ) = tcx.sess.source_map().span_to_snippet(sp) =>\n+                    {\n+                        if snippet.chars().all(|c| c.is_digit(10) || c == '-' || c == '_') {\n+                            diag.span_suggestion(\n+                                sp,\n+                                \"use a float literal\",\n+                                format!(\"{}.0\", snippet),\n+                                MachineApplicable,\n+                            );\n+                        }\n+                    }\n+                    (ty::Param(expected), ty::Param(found)) => {\n+                        let generics = tcx.generics_of(body_owner_def_id);\n+                        let e_span = tcx.def_span(generics.type_param(expected, tcx).def_id);\n+                        if !sp.contains(e_span) {\n+                            diag.span_label(e_span, \"expected type parameter\");\n+                        }\n+                        let f_span = tcx.def_span(generics.type_param(found, tcx).def_id);\n+                        if !sp.contains(f_span) {\n+                            diag.span_label(f_span, \"found type parameter\");\n+                        }\n+                        diag.note(\n+                            \"a type parameter was expected, but a different one was found; \\\n+                             you might be missing a type parameter or trait bound\",\n+                        );\n+                        diag.note(\n+                            \"for more information, visit \\\n+                             https://doc.rust-lang.org/book/ch10-02-traits.html\\\n+                             #traits-as-parameters\",\n+                        );\n+                    }\n+                    (ty::Alias(ty::Projection, _), ty::Alias(ty::Projection, _)) => {\n+                        diag.note(\"an associated type was expected, but a different one was found\");\n+                    }\n+                    (ty::Param(p), ty::Alias(ty::Projection, proj)) | (ty::Alias(ty::Projection, proj), ty::Param(p))\n+                        if tcx.def_kind(proj.def_id) != DefKind::ImplTraitPlaceholder =>\n+                    {\n+                        let generics = tcx.generics_of(body_owner_def_id);\n+                        let p_span = tcx.def_span(generics.type_param(p, tcx).def_id);\n+                        if !sp.contains(p_span) {\n+                            diag.span_label(p_span, \"this type parameter\");\n+                        }\n+                        let hir = tcx.hir();\n+                        let mut note = true;\n+                        if let Some(generics) = generics\n+                            .type_param(p, tcx)\n+                            .def_id\n+                            .as_local()\n+                            .map(|id| hir.local_def_id_to_hir_id(id))\n+                            .and_then(|id| tcx.hir().find_parent(id))\n+                            .as_ref()\n+                            .and_then(|node| node.generics())\n+                        {\n+                            // Synthesize the associated type restriction `Add<Output = Expected>`.\n+                            // FIXME: extract this logic for use in other diagnostics.\n+                            let (trait_ref, assoc_substs) = proj.trait_ref_and_own_substs(tcx);\n+                            let path =\n+                                tcx.def_path_str_with_substs(trait_ref.def_id, trait_ref.substs);\n+                            let item_name = tcx.item_name(proj.def_id);\n+                            let item_args = self.format_generic_args(assoc_substs);\n+\n+                            let path = if path.ends_with('>') {\n+                                format!(\n+                                    \"{}, {}{} = {}>\",\n+                                    &path[..path.len() - 1],\n+                                    item_name,\n+                                    item_args,\n+                                    p\n+                                )\n+                            } else {\n+                                format!(\"{}<{}{} = {}>\", path, item_name, item_args, p)\n+                            };\n+                            note = !suggest_constraining_type_param(\n+                                tcx,\n+                                generics,\n+                                diag,\n+                                &format!(\"{}\", proj.self_ty()),\n+                                &path,\n+                                None,\n+                            );\n+                        }\n+                        if note {\n+                            diag.note(\"you might be missing a type parameter or trait bound\");\n+                        }\n+                    }\n+                    (ty::Param(p), ty::Dynamic(..) | ty::Alias(ty::Opaque, ..))\n+                    | (ty::Dynamic(..) | ty::Alias(ty::Opaque, ..), ty::Param(p)) => {\n+                        let generics = tcx.generics_of(body_owner_def_id);\n+                        let p_span = tcx.def_span(generics.type_param(p, tcx).def_id);\n+                        if !sp.contains(p_span) {\n+                            diag.span_label(p_span, \"this type parameter\");\n+                        }\n+                        diag.help(\"type parameters must be constrained to match other types\");\n+                        if tcx.sess.teach(&diag.get_code().unwrap()) {\n+                            diag.help(\n+                                \"given a type parameter `T` and a method `foo`:\n+```\n+trait Trait<T> { fn foo(&tcx) -> T; }\n+```\n+the only ways to implement method `foo` are:\n+- constrain `T` with an explicit type:\n+```\n+impl Trait<String> for X {\n+    fn foo(&tcx) -> String { String::new() }\n+}\n+```\n+- add a trait bound to `T` and call a method on that trait that returns `Self`:\n+```\n+impl<T: std::default::Default> Trait<T> for X {\n+    fn foo(&tcx) -> T { <T as std::default::Default>::default() }\n+}\n+```\n+- change `foo` to return an argument of type `T`:\n+```\n+impl<T> Trait<T> for X {\n+    fn foo(&tcx, x: T) -> T { x }\n+}\n+```\",\n+                            );\n+                        }\n+                        diag.note(\n+                            \"for more information, visit \\\n+                             https://doc.rust-lang.org/book/ch10-02-traits.html\\\n+                             #traits-as-parameters\",\n+                        );\n+                    }\n+                    (ty::Param(p), ty::Closure(..) | ty::Generator(..)) => {\n+                        let generics = tcx.generics_of(body_owner_def_id);\n+                        let p_span = tcx.def_span(generics.type_param(p, tcx).def_id);\n+                        if !sp.contains(p_span) {\n+                            diag.span_label(p_span, \"this type parameter\");\n+                        }\n+                        diag.help(&format!(\n+                            \"every closure has a distinct type and so could not always match the \\\n+                             caller-chosen type of parameter `{}`\",\n+                            p\n+                        ));\n+                    }\n+                    (ty::Param(p), _) | (_, ty::Param(p)) => {\n+                        let generics = tcx.generics_of(body_owner_def_id);\n+                        let p_span = tcx.def_span(generics.type_param(p, tcx).def_id);\n+                        if !sp.contains(p_span) {\n+                            diag.span_label(p_span, \"this type parameter\");\n+                        }\n+                    }\n+                    (ty::Alias(ty::Projection, proj_ty), _) if tcx.def_kind(proj_ty.def_id) != DefKind::ImplTraitPlaceholder => {\n+                        self.expected_projection(\n+                            diag,\n+                            proj_ty,\n+                            values,\n+                            body_owner_def_id,\n+                            cause.code(),\n+                        );\n+                    }\n+                    (_, ty::Alias(ty::Projection, proj_ty)) if tcx.def_kind(proj_ty.def_id) != DefKind::ImplTraitPlaceholder => {\n+                        let msg = format!(\n+                            \"consider constraining the associated type `{}` to `{}`\",\n+                            values.found, values.expected,\n+                        );\n+                        if !(self.suggest_constraining_opaque_associated_type(\n+                            diag,\n+                            &msg,\n+                            proj_ty,\n+                            values.expected,\n+                        ) || self.suggest_constraint(\n+                            diag,\n+                            &msg,\n+                            body_owner_def_id,\n+                            proj_ty,\n+                            values.expected,\n+                        )) {\n+                            diag.help(&msg);\n+                            diag.note(\n+                                \"for more information, visit \\\n+                                https://doc.rust-lang.org/book/ch19-03-advanced-traits.html\",\n+                            );\n+                        }\n+                    }\n+                    _ => {}\n+                }\n+                debug!(\n+                    \"note_and_explain_type_err expected={:?} ({:?}) found={:?} ({:?})\",\n+                    values.expected,\n+                    values.expected.kind(),\n+                    values.found,\n+                    values.found.kind(),\n+                );\n+            }\n+            CyclicTy(ty) => {\n+                // Watch out for various cases of cyclic types and try to explain.\n+                if ty.is_closure() || ty.is_generator() {\n+                    diag.note(\n+                        \"closures cannot capture themselves or take themselves as argument;\\n\\\n+                         this error may be the result of a recent compiler bug-fix,\\n\\\n+                         see issue #46062 <https://github.com/rust-lang/rust/issues/46062>\\n\\\n+                         for more information\",\n+                    );\n+                }\n+            }\n+            TargetFeatureCast(def_id) => {\n+                let target_spans = tcx.get_attrs(def_id, sym::target_feature).map(|attr| attr.span);\n+                diag.note(\n+                    \"functions with `#[target_feature]` can only be coerced to `unsafe` function pointers\"\n+                );\n+                diag.span_labels(target_spans, \"`#[target_feature]` added here\");\n+            }\n+            _ => {}\n+        }\n+    }\n+\n+    fn suggest_constraint(\n+        &self,\n+        diag: &mut Diagnostic,\n+        msg: &str,\n+        body_owner_def_id: DefId,\n+        proj_ty: &ty::AliasTy<'tcx>,\n+        ty: Ty<'tcx>,\n+    ) -> bool {\n+        let tcx = self.tcx;\n+        let assoc = tcx.associated_item(proj_ty.def_id);\n+        let (trait_ref, assoc_substs) = proj_ty.trait_ref_and_own_substs(tcx);\n+        if let Some(item) = tcx.hir().get_if_local(body_owner_def_id) {\n+            if let Some(hir_generics) = item.generics() {\n+                // Get the `DefId` for the type parameter corresponding to `A` in `<A as T>::Foo`.\n+                // This will also work for `impl Trait`.\n+                let def_id = if let ty::Param(param_ty) = proj_ty.self_ty().kind() {\n+                    let generics = tcx.generics_of(body_owner_def_id);\n+                    generics.type_param(param_ty, tcx).def_id\n+                } else {\n+                    return false;\n+                };\n+                let Some(def_id) = def_id.as_local() else {\n+                    return false;\n+                };\n+\n+                // First look in the `where` clause, as this might be\n+                // `fn foo<T>(x: T) where T: Trait`.\n+                for pred in hir_generics.bounds_for_param(def_id) {\n+                    if self.constrain_generic_bound_associated_type_structured_suggestion(\n+                        diag,\n+                        &trait_ref,\n+                        pred.bounds,\n+                        &assoc,\n+                        assoc_substs,\n+                        ty,\n+                        msg,\n+                        false,\n+                    ) {\n+                        return true;\n+                    }\n+                }\n+            }\n+        }\n+        false\n+    }\n+\n+    /// An associated type was expected and a different type was found.\n+    ///\n+    /// We perform a few different checks to see what we can suggest:\n+    ///\n+    ///  - In the current item, look for associated functions that return the expected type and\n+    ///    suggest calling them. (Not a structured suggestion.)\n+    ///  - If any of the item's generic bounds can be constrained, we suggest constraining the\n+    ///    associated type to the found type.\n+    ///  - If the associated type has a default type and was expected inside of a `trait`, we\n+    ///    mention that this is disallowed.\n+    ///  - If all other things fail, and the error is not because of a mismatch between the `trait`\n+    ///    and the `impl`, we provide a generic `help` to constrain the assoc type or call an assoc\n+    ///    fn that returns the type.\n+    fn expected_projection(\n+        &self,\n+        diag: &mut Diagnostic,\n+        proj_ty: &ty::AliasTy<'tcx>,\n+        values: ExpectedFound<Ty<'tcx>>,\n+        body_owner_def_id: DefId,\n+        cause_code: &ObligationCauseCode<'_>,\n+    ) {\n+        let tcx = self.tcx;\n+\n+        let msg = format!(\n+            \"consider constraining the associated type `{}` to `{}`\",\n+            values.expected, values.found\n+        );\n+        let body_owner = tcx.hir().get_if_local(body_owner_def_id);\n+        let current_method_ident = body_owner.and_then(|n| n.ident()).map(|i| i.name);\n+\n+        // We don't want to suggest calling an assoc fn in a scope where that isn't feasible.\n+        let callable_scope = matches!(\n+            body_owner,\n+            Some(\n+                hir::Node::Item(hir::Item { kind: hir::ItemKind::Fn(..), .. })\n+                    | hir::Node::TraitItem(hir::TraitItem { kind: hir::TraitItemKind::Fn(..), .. })\n+                    | hir::Node::ImplItem(hir::ImplItem { kind: hir::ImplItemKind::Fn(..), .. }),\n+            )\n+        );\n+        let impl_comparison =\n+            matches!(cause_code, ObligationCauseCode::CompareImplItemObligation { .. });\n+        let assoc = tcx.associated_item(proj_ty.def_id);\n+        if !callable_scope || impl_comparison {\n+            // We do not want to suggest calling functions when the reason of the\n+            // type error is a comparison of an `impl` with its `trait` or when the\n+            // scope is outside of a `Body`.\n+        } else {\n+            // If we find a suitable associated function that returns the expected type, we don't\n+            // want the more general suggestion later in this method about \"consider constraining\n+            // the associated type or calling a method that returns the associated type\".\n+            let point_at_assoc_fn = self.point_at_methods_that_satisfy_associated_type(\n+                diag,\n+                assoc.container_id(tcx),\n+                current_method_ident,\n+                proj_ty.def_id,\n+                values.expected,\n+            );\n+            // Possibly suggest constraining the associated type to conform to the\n+            // found type.\n+            if self.suggest_constraint(diag, &msg, body_owner_def_id, proj_ty, values.found)\n+                || point_at_assoc_fn\n+            {\n+                return;\n+            }\n+        }\n+\n+        self.suggest_constraining_opaque_associated_type(diag, &msg, proj_ty, values.found);\n+\n+        if self.point_at_associated_type(diag, body_owner_def_id, values.found) {\n+            return;\n+        }\n+\n+        if !impl_comparison {\n+            // Generic suggestion when we can't be more specific.\n+            if callable_scope {\n+                diag.help(&format!(\n+                    \"{} or calling a method that returns `{}`\",\n+                    msg, values.expected\n+                ));\n+            } else {\n+                diag.help(&msg);\n+            }\n+            diag.note(\n+                \"for more information, visit \\\n+                 https://doc.rust-lang.org/book/ch19-03-advanced-traits.html\",\n+            );\n+        }\n+        if tcx.sess.teach(&diag.get_code().unwrap()) {\n+            diag.help(\n+                \"given an associated type `T` and a method `foo`:\n+```\n+trait Trait {\n+type T;\n+fn foo(&tcx) -> Self::T;\n+}\n+```\n+the only way of implementing method `foo` is to constrain `T` with an explicit associated type:\n+```\n+impl Trait for X {\n+type T = String;\n+fn foo(&tcx) -> Self::T { String::new() }\n+}\n+```\",\n+            );\n+        }\n+    }\n+\n+    /// When the expected `impl Trait` is not defined in the current item, it will come from\n+    /// a return type. This can occur when dealing with `TryStream` (#71035).\n+    fn suggest_constraining_opaque_associated_type(\n+        &self,\n+        diag: &mut Diagnostic,\n+        msg: &str,\n+        proj_ty: &ty::AliasTy<'tcx>,\n+        ty: Ty<'tcx>,\n+    ) -> bool {\n+        let tcx = self.tcx;\n+\n+        let assoc = tcx.associated_item(proj_ty.def_id);\n+        if let ty::Alias(ty::Opaque, ty::AliasTy { def_id, .. }) = *proj_ty.self_ty().kind() {\n+            let opaque_local_def_id = def_id.as_local();\n+            let opaque_hir_ty = if let Some(opaque_local_def_id) = opaque_local_def_id {\n+                match &tcx.hir().expect_item(opaque_local_def_id).kind {\n+                    hir::ItemKind::OpaqueTy(opaque_hir_ty) => opaque_hir_ty,\n+                    _ => bug!(\"The HirId comes from a `ty::Opaque`\"),\n+                }\n+            } else {\n+                return false;\n+            };\n+\n+            let (trait_ref, assoc_substs) = proj_ty.trait_ref_and_own_substs(tcx);\n+\n+            self.constrain_generic_bound_associated_type_structured_suggestion(\n+                diag,\n+                &trait_ref,\n+                opaque_hir_ty.bounds,\n+                assoc,\n+                assoc_substs,\n+                ty,\n+                msg,\n+                true,\n+            )\n+        } else {\n+            false\n+        }\n+    }\n+\n+    fn point_at_methods_that_satisfy_associated_type(\n+        &self,\n+        diag: &mut Diagnostic,\n+        assoc_container_id: DefId,\n+        current_method_ident: Option<Symbol>,\n+        proj_ty_item_def_id: DefId,\n+        expected: Ty<'tcx>,\n+    ) -> bool {\n+        let tcx = self.tcx;\n+\n+        let items = tcx.associated_items(assoc_container_id);\n+        // Find all the methods in the trait that could be called to construct the\n+        // expected associated type.\n+        // FIXME: consider suggesting the use of associated `const`s.\n+        let methods: Vec<(Span, String)> = items\n+            .in_definition_order()\n+            .filter(|item| {\n+                ty::AssocKind::Fn == item.kind && Some(item.name) != current_method_ident\n+            })\n+            .filter_map(|item| {\n+                let method = tcx.fn_sig(item.def_id);\n+                match *method.output().skip_binder().kind() {\n+                    ty::Alias(ty::Projection, ty::AliasTy { def_id: item_def_id, .. })\n+                        if item_def_id == proj_ty_item_def_id =>\n+                    {\n+                        Some((\n+                            tcx.def_span(item.def_id),\n+                            format!(\"consider calling `{}`\", tcx.def_path_str(item.def_id)),\n+                        ))\n+                    }\n+                    _ => None,\n+                }\n+            })\n+            .collect();\n+        if !methods.is_empty() {\n+            // Use a single `help:` to show all the methods in the trait that can\n+            // be used to construct the expected associated type.\n+            let mut span: MultiSpan =\n+                methods.iter().map(|(sp, _)| *sp).collect::<Vec<Span>>().into();\n+            let msg = format!(\n+                \"{some} method{s} {are} available that return{r} `{ty}`\",\n+                some = if methods.len() == 1 { \"a\" } else { \"some\" },\n+                s = pluralize!(methods.len()),\n+                are = pluralize!(\"is\", methods.len()),\n+                r = if methods.len() == 1 { \"s\" } else { \"\" },\n+                ty = expected\n+            );\n+            for (sp, label) in methods.into_iter() {\n+                span.push_span_label(sp, label);\n+            }\n+            diag.span_help(span, &msg);\n+            return true;\n+        }\n+        false\n+    }\n+\n+    fn point_at_associated_type(\n+        &self,\n+        diag: &mut Diagnostic,\n+        body_owner_def_id: DefId,\n+        found: Ty<'tcx>,\n+    ) -> bool {\n+        let tcx = self.tcx;\n+\n+        let Some(hir_id) = body_owner_def_id.as_local() else {\n+            return false;\n+        };\n+        let hir_id = tcx.hir().local_def_id_to_hir_id(hir_id);\n+        // When `body_owner` is an `impl` or `trait` item, look in its associated types for\n+        // `expected` and point at it.\n+        let parent_id = tcx.hir().get_parent_item(hir_id);\n+        let item = tcx.hir().find_by_def_id(parent_id.def_id);\n+\n+        debug!(\"expected_projection parent item {:?}\", item);\n+\n+        let param_env = tcx.param_env(body_owner_def_id);\n+\n+        match item {\n+            Some(hir::Node::Item(hir::Item { kind: hir::ItemKind::Trait(.., items), .. })) => {\n+                // FIXME: account for `#![feature(specialization)]`\n+                for item in &items[..] {\n+                    match item.kind {\n+                        hir::AssocItemKind::Type => {\n+                            // FIXME: account for returning some type in a trait fn impl that has\n+                            // an assoc type as a return type (#72076).\n+                            if let hir::Defaultness::Default { has_value: true } =\n+                                tcx.impl_defaultness(item.id.owner_id)\n+                            {\n+                                let assoc_ty = tcx.bound_type_of(item.id.owner_id).subst_identity();\n+                                if self.infcx.can_eq(param_env, assoc_ty, found).is_ok() {\n+                                    diag.span_label(\n+                                        item.span,\n+                                        \"associated type defaults can't be assumed inside the \\\n+                                            trait defining them\",\n+                                    );\n+                                    return true;\n+                                }\n+                            }\n+                        }\n+                        _ => {}\n+                    }\n+                }\n+            }\n+            Some(hir::Node::Item(hir::Item {\n+                kind: hir::ItemKind::Impl(hir::Impl { items, .. }),\n+                ..\n+            })) => {\n+                for item in &items[..] {\n+                    if let hir::AssocItemKind::Type = item.kind {\n+                        let assoc_ty = tcx.bound_type_of(item.id.owner_id).subst_identity();\n+\n+                        if self.infcx.can_eq(param_env, assoc_ty, found).is_ok() {\n+                            diag.span_label(item.span, \"expected this associated type\");\n+                            return true;\n+                        }\n+                    }\n+                }\n+            }\n+            _ => {}\n+        }\n+        false\n+    }\n+\n+    /// Given a slice of `hir::GenericBound`s, if any of them corresponds to the `trait_ref`\n+    /// requirement, provide a structured suggestion to constrain it to a given type `ty`.\n+    ///\n+    /// `is_bound_surely_present` indicates whether we know the bound we're looking for is\n+    /// inside `bounds`. If that's the case then we can consider `bounds` containing only one\n+    /// trait bound as the one we're looking for. This can help in cases where the associated\n+    /// type is defined on a supertrait of the one present in the bounds.\n+    fn constrain_generic_bound_associated_type_structured_suggestion(\n+        &self,\n+        diag: &mut Diagnostic,\n+        trait_ref: &ty::TraitRef<'tcx>,\n+        bounds: hir::GenericBounds<'_>,\n+        assoc: &ty::AssocItem,\n+        assoc_substs: &[ty::GenericArg<'tcx>],\n+        ty: Ty<'tcx>,\n+        msg: &str,\n+        is_bound_surely_present: bool,\n+    ) -> bool {\n+        // FIXME: we would want to call `resolve_vars_if_possible` on `ty` before suggesting.\n+\n+        let trait_bounds = bounds.iter().filter_map(|bound| match bound {\n+            hir::GenericBound::Trait(ptr, hir::TraitBoundModifier::None) => Some(ptr),\n+            _ => None,\n+        });\n+\n+        let matching_trait_bounds = trait_bounds\n+            .clone()\n+            .filter(|ptr| ptr.trait_ref.trait_def_id() == Some(trait_ref.def_id))\n+            .collect::<Vec<_>>();\n+\n+        let span = match &matching_trait_bounds[..] {\n+            &[ptr] => ptr.span,\n+            &[] if is_bound_surely_present => match &trait_bounds.collect::<Vec<_>>()[..] {\n+                &[ptr] => ptr.span,\n+                _ => return false,\n+            },\n+            _ => return false,\n+        };\n+\n+        self.constrain_associated_type_structured_suggestion(\n+            diag,\n+            span,\n+            assoc,\n+            assoc_substs,\n+            ty,\n+            msg,\n+        )\n+    }\n+\n+    /// Given a span corresponding to a bound, provide a structured suggestion to set an\n+    /// associated type to a given type `ty`.\n+    fn constrain_associated_type_structured_suggestion(\n+        &self,\n+        diag: &mut Diagnostic,\n+        span: Span,\n+        assoc: &ty::AssocItem,\n+        assoc_substs: &[ty::GenericArg<'tcx>],\n+        ty: Ty<'tcx>,\n+        msg: &str,\n+    ) -> bool {\n+        let tcx = self.tcx;\n+\n+        if let Ok(has_params) =\n+            tcx.sess.source_map().span_to_snippet(span).map(|snippet| snippet.ends_with('>'))\n+        {\n+            let (span, sugg) = if has_params {\n+                let pos = span.hi() - BytePos(1);\n+                let span = Span::new(pos, pos, span.ctxt(), span.parent());\n+                (span, format!(\", {} = {}\", assoc.ident(tcx), ty))\n+            } else {\n+                let item_args = self.format_generic_args(assoc_substs);\n+                (span.shrink_to_hi(), format!(\"<{}{} = {}>\", assoc.ident(tcx), item_args, ty))\n+            };\n+            diag.span_suggestion_verbose(span, msg, sugg, MaybeIncorrect);\n+            return true;\n+        }\n+        false\n+    }\n+\n+    pub fn format_generic_args(&self, args: &[ty::GenericArg<'tcx>]) -> String {\n+        FmtPrinter::new(self.tcx, hir::def::Namespace::TypeNS)\n+            .path_generic_args(Ok, args)\n+            .expect(\"could not write to `String`.\")\n+            .into_buffer()\n+    }\n+}"}, {"sha": "768cef89f3c439b2c61092d4bdcfa7a65ea5151b", "filename": "compiler/rustc_infer/src/infer/error_reporting/suggest.rs", "status": "modified", "additions": 44, "deletions": 8, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/40fda7b3fe2b10c6e1a0568b59516f5e7f381886/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40fda7b3fe2b10c6e1a0568b59516f5e7f381886/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fsuggest.rs?ref=40fda7b3fe2b10c6e1a0568b59516f5e7f381886", "patch": "@@ -380,7 +380,7 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n                     return;\n                 }\n \n-                let (msg, sugg) = match (expected.is_ref(), found.is_ref()) {\n+                let (msg, sug) = match (expected.is_ref(), found.is_ref()) {\n                     (true, false) => {\n                         let msg = \"consider using a reference\";\n                         let sug = format!(\"&{fn_name}\");\n@@ -404,22 +404,58 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n                         (msg, sug)\n                     }\n                 };\n-                diag.span_suggestion(span, msg, &sugg, Applicability::MaybeIncorrect);\n+                diag.span_suggestion(span, msg, sug, Applicability::MaybeIncorrect);\n             }\n             (ty::FnDef(did1, substs1), ty::FnDef(did2, substs2)) => {\n                 let expected_sig =\n                     &(self.normalize_fn_sig)(self.tcx.bound_fn_sig(*did1).subst(self.tcx, substs1));\n                 let found_sig =\n                     &(self.normalize_fn_sig)(self.tcx.bound_fn_sig(*did2).subst(self.tcx, substs2));\n \n-                if self.same_type_modulo_infer(*found_sig, *expected_sig) {\n-                    diag.note(\n-                    \"different fn items have unique types, even if their signatures are the same\",\n-                    );\n+                if self.same_type_modulo_infer(*expected_sig, *found_sig) {\n+                    diag.note(\"different fn items have unique types, even if their signatures are the same\");\n+                }\n+\n+                if !self.same_type_modulo_infer(*found_sig, *expected_sig)\n+                    || !found_sig.is_suggestable(self.tcx, true)\n+                    || !expected_sig.is_suggestable(self.tcx, true)\n+                    || ty::util::is_intrinsic(self.tcx, *did1)\n+                    || ty::util::is_intrinsic(self.tcx, *did2)\n+                {\n+                    return;\n                 }\n+\n+                let fn_name = self.tcx.def_path_str_with_substs(*did2, substs2);\n+                let sug = if found.is_ref() {\n+                    format!(\"&({fn_name} as {found_sig})\")\n+                } else {\n+                    format!(\"{fn_name} as {found_sig}\")\n+                };\n+\n+                let msg = format!(\n+                    \"consider casting both fn items to fn pointers using `as {expected_sig}`\"\n+                );\n+\n+                diag.span_suggestion_hidden(span, msg, sug, Applicability::MaybeIncorrect);\n             }\n-            (ty::FnDef(_, _), ty::FnPtr(_)) => {\n-                diag.note(\"fn items are distinct from fn pointers\");\n+            (ty::FnDef(did, substs), ty::FnPtr(sig)) => {\n+                let expected_sig =\n+                    &(self.normalize_fn_sig)(self.tcx.bound_fn_sig(*did).subst(self.tcx, substs));\n+                let found_sig = &(self.normalize_fn_sig)(*sig);\n+\n+                if !self.same_type_modulo_infer(*found_sig, *expected_sig) {\n+                    return;\n+                }\n+\n+                let fn_name = self.tcx.def_path_str_with_substs(*did, substs);\n+\n+                let casting = if expected.is_ref() {\n+                    format!(\"&({fn_name} as {found_sig})\")\n+                } else {\n+                    format!(\"{fn_name} as {found_sig}\")\n+                };\n+\n+                diag.help(&format!(\"consider casting the fn item to a fn pointer: `{}`\", casting));\n             }\n             _ => {\n                 return;"}, {"sha": "47091ca1d69a719ce275a439356088f890294d10", "filename": "compiler/rustc_middle/src/ty/assoc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/40fda7b3fe2b10c6e1a0568b59516f5e7f381886/compiler%2Frustc_middle%2Fsrc%2Fty%2Fassoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40fda7b3fe2b10c6e1a0568b59516f5e7f381886/compiler%2Frustc_middle%2Fsrc%2Fty%2Fassoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fassoc.rs?ref=40fda7b3fe2b10c6e1a0568b59516f5e7f381886", "patch": "@@ -130,7 +130,7 @@ impl std::fmt::Display for AssocKind {\n /// done only on items with the same name.\n #[derive(Debug, Clone, PartialEq, HashStable)]\n pub struct AssocItems<'tcx> {\n-    pub(super) items: SortedIndexMultiMap<u32, Symbol, &'tcx ty::AssocItem>,\n+    items: SortedIndexMultiMap<u32, Symbol, &'tcx ty::AssocItem>,\n }\n \n impl<'tcx> AssocItems<'tcx> {"}, {"sha": "c8a700c4e280d6eccd2d19ba8face8a430a6d31f", "filename": "compiler/rustc_middle/src/ty/error.rs", "status": "modified", "additions": 5, "deletions": 632, "changes": 637, "blob_url": "https://github.com/rust-lang/rust/blob/40fda7b3fe2b10c6e1a0568b59516f5e7f381886/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40fda7b3fe2b10c6e1a0568b59516f5e7f381886/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs?ref=40fda7b3fe2b10c6e1a0568b59516f5e7f381886", "patch": "@@ -1,24 +1,18 @@\n-use crate::traits::{ObligationCause, ObligationCauseCode};\n-use crate::ty::diagnostics::suggest_constraining_type_param;\n-use crate::ty::print::{with_forced_trimmed_paths, FmtPrinter, Printer};\n+use crate::ty::print::{with_forced_trimmed_paths, FmtPrinter, PrettyPrinter};\n use crate::ty::{self, BoundRegionKind, Region, Ty, TyCtxt};\n-use rustc_errors::Applicability::{MachineApplicable, MaybeIncorrect};\n-use rustc_errors::{pluralize, Diagnostic, MultiSpan};\n+use rustc_errors::pluralize;\n use rustc_hir as hir;\n use rustc_hir::def::{CtorOf, DefKind};\n use rustc_hir::def_id::DefId;\n-use rustc_span::symbol::{sym, Symbol};\n-use rustc_span::{BytePos, Span};\n+use rustc_span::symbol::Symbol;\n use rustc_target::spec::abi;\n-\n use std::borrow::Cow;\n use std::collections::hash_map::DefaultHasher;\n use std::fmt;\n-use std::hash::{Hash, Hasher};\n+use std::hash::Hash;\n+use std::hash::Hasher;\n use std::path::PathBuf;\n \n-use super::print::PrettyPrinter;\n-\n #[derive(Clone, Copy, Debug, PartialEq, Eq, TypeFoldable, TypeVisitable, Lift)]\n pub struct ExpectedFound<T> {\n     pub expected: T,\n@@ -391,620 +385,6 @@ impl<'tcx> Ty<'tcx> {\n }\n \n impl<'tcx> TyCtxt<'tcx> {\n-    pub fn note_and_explain_type_err(\n-        self,\n-        diag: &mut Diagnostic,\n-        err: TypeError<'tcx>,\n-        cause: &ObligationCause<'tcx>,\n-        sp: Span,\n-        body_owner_def_id: DefId,\n-    ) {\n-        use self::TypeError::*;\n-        debug!(\"note_and_explain_type_err err={:?} cause={:?}\", err, cause);\n-        match err {\n-            ArgumentSorts(values, _) | Sorts(values) => {\n-                match (values.expected.kind(), values.found.kind()) {\n-                    (ty::Closure(..), ty::Closure(..)) => {\n-                        diag.note(\"no two closures, even if identical, have the same type\");\n-                        diag.help(\"consider boxing your closure and/or using it as a trait object\");\n-                    }\n-                    (ty::Alias(ty::Opaque, ..), ty::Alias(ty::Opaque, ..)) => {\n-                        // Issue #63167\n-                        diag.note(\"distinct uses of `impl Trait` result in different opaque types\");\n-                    }\n-                    (ty::Float(_), ty::Infer(ty::IntVar(_)))\n-                        if let Ok(\n-                            // Issue #53280\n-                            snippet,\n-                        ) = self.sess.source_map().span_to_snippet(sp) =>\n-                    {\n-                        if snippet.chars().all(|c| c.is_digit(10) || c == '-' || c == '_') {\n-                            diag.span_suggestion(\n-                                sp,\n-                                \"use a float literal\",\n-                                format!(\"{}.0\", snippet),\n-                                MachineApplicable,\n-                            );\n-                        }\n-                    }\n-                    (ty::Param(expected), ty::Param(found)) => {\n-                        let generics = self.generics_of(body_owner_def_id);\n-                        let e_span = self.def_span(generics.type_param(expected, self).def_id);\n-                        if !sp.contains(e_span) {\n-                            diag.span_label(e_span, \"expected type parameter\");\n-                        }\n-                        let f_span = self.def_span(generics.type_param(found, self).def_id);\n-                        if !sp.contains(f_span) {\n-                            diag.span_label(f_span, \"found type parameter\");\n-                        }\n-                        diag.note(\n-                            \"a type parameter was expected, but a different one was found; \\\n-                             you might be missing a type parameter or trait bound\",\n-                        );\n-                        diag.note(\n-                            \"for more information, visit \\\n-                             https://doc.rust-lang.org/book/ch10-02-traits.html\\\n-                             #traits-as-parameters\",\n-                        );\n-                    }\n-                    (ty::Alias(ty::Projection, _), ty::Alias(ty::Projection, _)) => {\n-                        diag.note(\"an associated type was expected, but a different one was found\");\n-                    }\n-                    (ty::Param(p), ty::Alias(ty::Projection, proj)) | (ty::Alias(ty::Projection, proj), ty::Param(p))\n-                        if self.def_kind(proj.def_id) != DefKind::ImplTraitPlaceholder =>\n-                    {\n-                        let generics = self.generics_of(body_owner_def_id);\n-                        let p_span = self.def_span(generics.type_param(p, self).def_id);\n-                        if !sp.contains(p_span) {\n-                            diag.span_label(p_span, \"this type parameter\");\n-                        }\n-                        let hir = self.hir();\n-                        let mut note = true;\n-                        if let Some(generics) = generics\n-                            .type_param(p, self)\n-                            .def_id\n-                            .as_local()\n-                            .map(|id| hir.local_def_id_to_hir_id(id))\n-                            .and_then(|id| self.hir().find_parent(id))\n-                            .as_ref()\n-                            .and_then(|node| node.generics())\n-                        {\n-                            // Synthesize the associated type restriction `Add<Output = Expected>`.\n-                            // FIXME: extract this logic for use in other diagnostics.\n-                            let (trait_ref, assoc_substs) = proj.trait_ref_and_own_substs(self);\n-                            let path =\n-                                self.def_path_str_with_substs(trait_ref.def_id, trait_ref.substs);\n-                            let item_name = self.item_name(proj.def_id);\n-                            let item_args = self.format_generic_args(assoc_substs);\n-\n-                            let path = if path.ends_with('>') {\n-                                format!(\n-                                    \"{}, {}{} = {}>\",\n-                                    &path[..path.len() - 1],\n-                                    item_name,\n-                                    item_args,\n-                                    p\n-                                )\n-                            } else {\n-                                format!(\"{}<{}{} = {}>\", path, item_name, item_args, p)\n-                            };\n-                            note = !suggest_constraining_type_param(\n-                                self,\n-                                generics,\n-                                diag,\n-                                &format!(\"{}\", proj.self_ty()),\n-                                &path,\n-                                None,\n-                            );\n-                        }\n-                        if note {\n-                            diag.note(\"you might be missing a type parameter or trait bound\");\n-                        }\n-                    }\n-                    (ty::Param(p), ty::Dynamic(..) | ty::Alias(ty::Opaque, ..))\n-                    | (ty::Dynamic(..) | ty::Alias(ty::Opaque, ..), ty::Param(p)) => {\n-                        let generics = self.generics_of(body_owner_def_id);\n-                        let p_span = self.def_span(generics.type_param(p, self).def_id);\n-                        if !sp.contains(p_span) {\n-                            diag.span_label(p_span, \"this type parameter\");\n-                        }\n-                        diag.help(\"type parameters must be constrained to match other types\");\n-                        if self.sess.teach(&diag.get_code().unwrap()) {\n-                            diag.help(\n-                                \"given a type parameter `T` and a method `foo`:\n-```\n-trait Trait<T> { fn foo(&self) -> T; }\n-```\n-the only ways to implement method `foo` are:\n-- constrain `T` with an explicit type:\n-```\n-impl Trait<String> for X {\n-    fn foo(&self) -> String { String::new() }\n-}\n-```\n-- add a trait bound to `T` and call a method on that trait that returns `Self`:\n-```\n-impl<T: std::default::Default> Trait<T> for X {\n-    fn foo(&self) -> T { <T as std::default::Default>::default() }\n-}\n-```\n-- change `foo` to return an argument of type `T`:\n-```\n-impl<T> Trait<T> for X {\n-    fn foo(&self, x: T) -> T { x }\n-}\n-```\",\n-                            );\n-                        }\n-                        diag.note(\n-                            \"for more information, visit \\\n-                             https://doc.rust-lang.org/book/ch10-02-traits.html\\\n-                             #traits-as-parameters\",\n-                        );\n-                    }\n-                    (ty::Param(p), ty::Closure(..) | ty::Generator(..)) => {\n-                        let generics = self.generics_of(body_owner_def_id);\n-                        let p_span = self.def_span(generics.type_param(p, self).def_id);\n-                        if !sp.contains(p_span) {\n-                            diag.span_label(p_span, \"this type parameter\");\n-                        }\n-                        diag.help(&format!(\n-                            \"every closure has a distinct type and so could not always match the \\\n-                             caller-chosen type of parameter `{}`\",\n-                            p\n-                        ));\n-                    }\n-                    (ty::Param(p), _) | (_, ty::Param(p)) => {\n-                        let generics = self.generics_of(body_owner_def_id);\n-                        let p_span = self.def_span(generics.type_param(p, self).def_id);\n-                        if !sp.contains(p_span) {\n-                            diag.span_label(p_span, \"this type parameter\");\n-                        }\n-                    }\n-                    (ty::Alias(ty::Projection, proj_ty), _) if self.def_kind(proj_ty.def_id) != DefKind::ImplTraitPlaceholder => {\n-                        self.expected_projection(\n-                            diag,\n-                            proj_ty,\n-                            values,\n-                            body_owner_def_id,\n-                            cause.code(),\n-                        );\n-                    }\n-                    (_, ty::Alias(ty::Projection, proj_ty)) if self.def_kind(proj_ty.def_id) != DefKind::ImplTraitPlaceholder => {\n-                        let msg = format!(\n-                            \"consider constraining the associated type `{}` to `{}`\",\n-                            values.found, values.expected,\n-                        );\n-                        if !(self.suggest_constraining_opaque_associated_type(\n-                            diag,\n-                            &msg,\n-                            proj_ty,\n-                            values.expected,\n-                        ) || self.suggest_constraint(\n-                            diag,\n-                            &msg,\n-                            body_owner_def_id,\n-                            proj_ty,\n-                            values.expected,\n-                        )) {\n-                            diag.help(&msg);\n-                            diag.note(\n-                                \"for more information, visit \\\n-                                https://doc.rust-lang.org/book/ch19-03-advanced-traits.html\",\n-                            );\n-                        }\n-                    }\n-                    _ => {}\n-                }\n-                debug!(\n-                    \"note_and_explain_type_err expected={:?} ({:?}) found={:?} ({:?})\",\n-                    values.expected,\n-                    values.expected.kind(),\n-                    values.found,\n-                    values.found.kind(),\n-                );\n-            }\n-            CyclicTy(ty) => {\n-                // Watch out for various cases of cyclic types and try to explain.\n-                if ty.is_closure() || ty.is_generator() {\n-                    diag.note(\n-                        \"closures cannot capture themselves or take themselves as argument;\\n\\\n-                         this error may be the result of a recent compiler bug-fix,\\n\\\n-                         see issue #46062 <https://github.com/rust-lang/rust/issues/46062>\\n\\\n-                         for more information\",\n-                    );\n-                }\n-            }\n-            TargetFeatureCast(def_id) => {\n-                let target_spans =\n-                    self.get_attrs(def_id, sym::target_feature).map(|attr| attr.span);\n-                diag.note(\n-                    \"functions with `#[target_feature]` can only be coerced to `unsafe` function pointers\"\n-                );\n-                diag.span_labels(target_spans, \"`#[target_feature]` added here\");\n-            }\n-            _ => {}\n-        }\n-    }\n-\n-    fn suggest_constraint(\n-        self,\n-        diag: &mut Diagnostic,\n-        msg: &str,\n-        body_owner_def_id: DefId,\n-        proj_ty: &ty::AliasTy<'tcx>,\n-        ty: Ty<'tcx>,\n-    ) -> bool {\n-        let assoc = self.associated_item(proj_ty.def_id);\n-        let (trait_ref, assoc_substs) = proj_ty.trait_ref_and_own_substs(self);\n-        if let Some(item) = self.hir().get_if_local(body_owner_def_id) {\n-            if let Some(hir_generics) = item.generics() {\n-                // Get the `DefId` for the type parameter corresponding to `A` in `<A as T>::Foo`.\n-                // This will also work for `impl Trait`.\n-                let def_id = if let ty::Param(param_ty) = proj_ty.self_ty().kind() {\n-                    let generics = self.generics_of(body_owner_def_id);\n-                    generics.type_param(param_ty, self).def_id\n-                } else {\n-                    return false;\n-                };\n-                let Some(def_id) = def_id.as_local() else {\n-                    return false;\n-                };\n-\n-                // First look in the `where` clause, as this might be\n-                // `fn foo<T>(x: T) where T: Trait`.\n-                for pred in hir_generics.bounds_for_param(def_id) {\n-                    if self.constrain_generic_bound_associated_type_structured_suggestion(\n-                        diag,\n-                        &trait_ref,\n-                        pred.bounds,\n-                        &assoc,\n-                        assoc_substs,\n-                        ty,\n-                        msg,\n-                        false,\n-                    ) {\n-                        return true;\n-                    }\n-                }\n-            }\n-        }\n-        false\n-    }\n-\n-    /// An associated type was expected and a different type was found.\n-    ///\n-    /// We perform a few different checks to see what we can suggest:\n-    ///\n-    ///  - In the current item, look for associated functions that return the expected type and\n-    ///    suggest calling them. (Not a structured suggestion.)\n-    ///  - If any of the item's generic bounds can be constrained, we suggest constraining the\n-    ///    associated type to the found type.\n-    ///  - If the associated type has a default type and was expected inside of a `trait`, we\n-    ///    mention that this is disallowed.\n-    ///  - If all other things fail, and the error is not because of a mismatch between the `trait`\n-    ///    and the `impl`, we provide a generic `help` to constrain the assoc type or call an assoc\n-    ///    fn that returns the type.\n-    fn expected_projection(\n-        self,\n-        diag: &mut Diagnostic,\n-        proj_ty: &ty::AliasTy<'tcx>,\n-        values: ExpectedFound<Ty<'tcx>>,\n-        body_owner_def_id: DefId,\n-        cause_code: &ObligationCauseCode<'_>,\n-    ) {\n-        let msg = format!(\n-            \"consider constraining the associated type `{}` to `{}`\",\n-            values.expected, values.found\n-        );\n-        let body_owner = self.hir().get_if_local(body_owner_def_id);\n-        let current_method_ident = body_owner.and_then(|n| n.ident()).map(|i| i.name);\n-\n-        // We don't want to suggest calling an assoc fn in a scope where that isn't feasible.\n-        let callable_scope = matches!(\n-            body_owner,\n-            Some(\n-                hir::Node::Item(hir::Item { kind: hir::ItemKind::Fn(..), .. })\n-                    | hir::Node::TraitItem(hir::TraitItem { kind: hir::TraitItemKind::Fn(..), .. })\n-                    | hir::Node::ImplItem(hir::ImplItem { kind: hir::ImplItemKind::Fn(..), .. }),\n-            )\n-        );\n-        let impl_comparison =\n-            matches!(cause_code, ObligationCauseCode::CompareImplItemObligation { .. });\n-        let assoc = self.associated_item(proj_ty.def_id);\n-        if !callable_scope || impl_comparison {\n-            // We do not want to suggest calling functions when the reason of the\n-            // type error is a comparison of an `impl` with its `trait` or when the\n-            // scope is outside of a `Body`.\n-        } else {\n-            // If we find a suitable associated function that returns the expected type, we don't\n-            // want the more general suggestion later in this method about \"consider constraining\n-            // the associated type or calling a method that returns the associated type\".\n-            let point_at_assoc_fn = self.point_at_methods_that_satisfy_associated_type(\n-                diag,\n-                assoc.container_id(self),\n-                current_method_ident,\n-                proj_ty.def_id,\n-                values.expected,\n-            );\n-            // Possibly suggest constraining the associated type to conform to the\n-            // found type.\n-            if self.suggest_constraint(diag, &msg, body_owner_def_id, proj_ty, values.found)\n-                || point_at_assoc_fn\n-            {\n-                return;\n-            }\n-        }\n-\n-        self.suggest_constraining_opaque_associated_type(diag, &msg, proj_ty, values.found);\n-\n-        if self.point_at_associated_type(diag, body_owner_def_id, values.found) {\n-            return;\n-        }\n-\n-        if !impl_comparison {\n-            // Generic suggestion when we can't be more specific.\n-            if callable_scope {\n-                diag.help(&format!(\n-                    \"{} or calling a method that returns `{}`\",\n-                    msg, values.expected\n-                ));\n-            } else {\n-                diag.help(&msg);\n-            }\n-            diag.note(\n-                \"for more information, visit \\\n-                 https://doc.rust-lang.org/book/ch19-03-advanced-traits.html\",\n-            );\n-        }\n-        if self.sess.teach(&diag.get_code().unwrap()) {\n-            diag.help(\n-                \"given an associated type `T` and a method `foo`:\n-```\n-trait Trait {\n-type T;\n-fn foo(&self) -> Self::T;\n-}\n-```\n-the only way of implementing method `foo` is to constrain `T` with an explicit associated type:\n-```\n-impl Trait for X {\n-type T = String;\n-fn foo(&self) -> Self::T { String::new() }\n-}\n-```\",\n-            );\n-        }\n-    }\n-\n-    /// When the expected `impl Trait` is not defined in the current item, it will come from\n-    /// a return type. This can occur when dealing with `TryStream` (#71035).\n-    fn suggest_constraining_opaque_associated_type(\n-        self,\n-        diag: &mut Diagnostic,\n-        msg: &str,\n-        proj_ty: &ty::AliasTy<'tcx>,\n-        ty: Ty<'tcx>,\n-    ) -> bool {\n-        let assoc = self.associated_item(proj_ty.def_id);\n-        if let ty::Alias(ty::Opaque, ty::AliasTy { def_id, .. }) = *proj_ty.self_ty().kind() {\n-            let opaque_local_def_id = def_id.as_local();\n-            let opaque_hir_ty = if let Some(opaque_local_def_id) = opaque_local_def_id {\n-                match &self.hir().expect_item(opaque_local_def_id).kind {\n-                    hir::ItemKind::OpaqueTy(opaque_hir_ty) => opaque_hir_ty,\n-                    _ => bug!(\"The HirId comes from a `ty::Opaque`\"),\n-                }\n-            } else {\n-                return false;\n-            };\n-\n-            let (trait_ref, assoc_substs) = proj_ty.trait_ref_and_own_substs(self);\n-\n-            self.constrain_generic_bound_associated_type_structured_suggestion(\n-                diag,\n-                &trait_ref,\n-                opaque_hir_ty.bounds,\n-                assoc,\n-                assoc_substs,\n-                ty,\n-                msg,\n-                true,\n-            )\n-        } else {\n-            false\n-        }\n-    }\n-\n-    fn point_at_methods_that_satisfy_associated_type(\n-        self,\n-        diag: &mut Diagnostic,\n-        assoc_container_id: DefId,\n-        current_method_ident: Option<Symbol>,\n-        proj_ty_item_def_id: DefId,\n-        expected: Ty<'tcx>,\n-    ) -> bool {\n-        let items = self.associated_items(assoc_container_id);\n-        // Find all the methods in the trait that could be called to construct the\n-        // expected associated type.\n-        // FIXME: consider suggesting the use of associated `const`s.\n-        let methods: Vec<(Span, String)> = items\n-            .items\n-            .iter()\n-            .filter(|(name, item)| {\n-                ty::AssocKind::Fn == item.kind && Some(**name) != current_method_ident\n-            })\n-            .filter_map(|(_, item)| {\n-                let method = self.fn_sig(item.def_id);\n-                match *method.output().skip_binder().kind() {\n-                    ty::Alias(ty::Projection, ty::AliasTy { def_id: item_def_id, .. })\n-                        if item_def_id == proj_ty_item_def_id =>\n-                    {\n-                        Some((\n-                            self.def_span(item.def_id),\n-                            format!(\"consider calling `{}`\", self.def_path_str(item.def_id)),\n-                        ))\n-                    }\n-                    _ => None,\n-                }\n-            })\n-            .collect();\n-        if !methods.is_empty() {\n-            // Use a single `help:` to show all the methods in the trait that can\n-            // be used to construct the expected associated type.\n-            let mut span: MultiSpan =\n-                methods.iter().map(|(sp, _)| *sp).collect::<Vec<Span>>().into();\n-            let msg = format!(\n-                \"{some} method{s} {are} available that return{r} `{ty}`\",\n-                some = if methods.len() == 1 { \"a\" } else { \"some\" },\n-                s = pluralize!(methods.len()),\n-                are = pluralize!(\"is\", methods.len()),\n-                r = if methods.len() == 1 { \"s\" } else { \"\" },\n-                ty = expected\n-            );\n-            for (sp, label) in methods.into_iter() {\n-                span.push_span_label(sp, label);\n-            }\n-            diag.span_help(span, &msg);\n-            return true;\n-        }\n-        false\n-    }\n-\n-    fn point_at_associated_type(\n-        self,\n-        diag: &mut Diagnostic,\n-        body_owner_def_id: DefId,\n-        found: Ty<'tcx>,\n-    ) -> bool {\n-        let Some(hir_id) = body_owner_def_id.as_local() else {\n-            return false;\n-        };\n-        let hir_id = self.hir().local_def_id_to_hir_id(hir_id);\n-        // When `body_owner` is an `impl` or `trait` item, look in its associated types for\n-        // `expected` and point at it.\n-        let parent_id = self.hir().get_parent_item(hir_id);\n-        let item = self.hir().find_by_def_id(parent_id.def_id);\n-        debug!(\"expected_projection parent item {:?}\", item);\n-        match item {\n-            Some(hir::Node::Item(hir::Item { kind: hir::ItemKind::Trait(.., items), .. })) => {\n-                // FIXME: account for `#![feature(specialization)]`\n-                for item in &items[..] {\n-                    match item.kind {\n-                        hir::AssocItemKind::Type => {\n-                            // FIXME: account for returning some type in a trait fn impl that has\n-                            // an assoc type as a return type (#72076).\n-                            if let hir::Defaultness::Default { has_value: true } =\n-                                self.impl_defaultness(item.id.owner_id)\n-                            {\n-                                if self.type_of(item.id.owner_id) == found {\n-                                    diag.span_label(\n-                                        item.span,\n-                                        \"associated type defaults can't be assumed inside the \\\n-                                            trait defining them\",\n-                                    );\n-                                    return true;\n-                                }\n-                            }\n-                        }\n-                        _ => {}\n-                    }\n-                }\n-            }\n-            Some(hir::Node::Item(hir::Item {\n-                kind: hir::ItemKind::Impl(hir::Impl { items, .. }),\n-                ..\n-            })) => {\n-                for item in &items[..] {\n-                    if let hir::AssocItemKind::Type = item.kind {\n-                        if self.type_of(item.id.owner_id) == found {\n-                            diag.span_label(item.span, \"expected this associated type\");\n-                            return true;\n-                        }\n-                    }\n-                }\n-            }\n-            _ => {}\n-        }\n-        false\n-    }\n-\n-    /// Given a slice of `hir::GenericBound`s, if any of them corresponds to the `trait_ref`\n-    /// requirement, provide a structured suggestion to constrain it to a given type `ty`.\n-    ///\n-    /// `is_bound_surely_present` indicates whether we know the bound we're looking for is\n-    /// inside `bounds`. If that's the case then we can consider `bounds` containing only one\n-    /// trait bound as the one we're looking for. This can help in cases where the associated\n-    /// type is defined on a supertrait of the one present in the bounds.\n-    fn constrain_generic_bound_associated_type_structured_suggestion(\n-        self,\n-        diag: &mut Diagnostic,\n-        trait_ref: &ty::TraitRef<'tcx>,\n-        bounds: hir::GenericBounds<'_>,\n-        assoc: &ty::AssocItem,\n-        assoc_substs: &[ty::GenericArg<'tcx>],\n-        ty: Ty<'tcx>,\n-        msg: &str,\n-        is_bound_surely_present: bool,\n-    ) -> bool {\n-        // FIXME: we would want to call `resolve_vars_if_possible` on `ty` before suggesting.\n-\n-        let trait_bounds = bounds.iter().filter_map(|bound| match bound {\n-            hir::GenericBound::Trait(ptr, hir::TraitBoundModifier::None) => Some(ptr),\n-            _ => None,\n-        });\n-\n-        let matching_trait_bounds = trait_bounds\n-            .clone()\n-            .filter(|ptr| ptr.trait_ref.trait_def_id() == Some(trait_ref.def_id))\n-            .collect::<Vec<_>>();\n-\n-        let span = match &matching_trait_bounds[..] {\n-            &[ptr] => ptr.span,\n-            &[] if is_bound_surely_present => match &trait_bounds.collect::<Vec<_>>()[..] {\n-                &[ptr] => ptr.span,\n-                _ => return false,\n-            },\n-            _ => return false,\n-        };\n-\n-        self.constrain_associated_type_structured_suggestion(\n-            diag,\n-            span,\n-            assoc,\n-            assoc_substs,\n-            ty,\n-            msg,\n-        )\n-    }\n-\n-    /// Given a span corresponding to a bound, provide a structured suggestion to set an\n-    /// associated type to a given type `ty`.\n-    fn constrain_associated_type_structured_suggestion(\n-        self,\n-        diag: &mut Diagnostic,\n-        span: Span,\n-        assoc: &ty::AssocItem,\n-        assoc_substs: &[ty::GenericArg<'tcx>],\n-        ty: Ty<'tcx>,\n-        msg: &str,\n-    ) -> bool {\n-        if let Ok(has_params) =\n-            self.sess.source_map().span_to_snippet(span).map(|snippet| snippet.ends_with('>'))\n-        {\n-            let (span, sugg) = if has_params {\n-                let pos = span.hi() - BytePos(1);\n-                let span = Span::new(pos, pos, span.ctxt(), span.parent());\n-                (span, format!(\", {} = {}\", assoc.ident(self), ty))\n-            } else {\n-                let item_args = self.format_generic_args(assoc_substs);\n-                (span.shrink_to_hi(), format!(\"<{}{} = {}>\", assoc.ident(self), item_args, ty))\n-            };\n-            diag.span_suggestion_verbose(span, msg, sugg, MaybeIncorrect);\n-            return true;\n-        }\n-        false\n-    }\n-\n     pub fn short_ty_string(self, ty: Ty<'tcx>) -> (String, Option<PathBuf>) {\n         let width = self.sess.diagnostic_width();\n         let length_limit = width.saturating_sub(30);\n@@ -1047,11 +427,4 @@ fn foo(&self) -> Self::T { String::new() }\n             Err(_) => (regular, None),\n         }\n     }\n-\n-    fn format_generic_args(self, args: &[ty::GenericArg<'tcx>]) -> String {\n-        FmtPrinter::new(self, hir::def::Namespace::TypeNS)\n-            .path_generic_args(Ok, args)\n-            .expect(\"could not write to `String`.\")\n-            .into_buffer()\n-    }\n }"}, {"sha": "28b9bdf566018b06c4dab41fdb7b15d601dcb851", "filename": "compiler/rustc_middle/src/ty/query.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/40fda7b3fe2b10c6e1a0568b59516f5e7f381886/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40fda7b3fe2b10c6e1a0568b59516f5e7f381886/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs?ref=40fda7b3fe2b10c6e1a0568b59516f5e7f381886", "patch": "@@ -441,6 +441,10 @@ impl<'tcx> TyCtxt<'tcx> {\n         self.opt_def_kind(def_id)\n             .unwrap_or_else(|| bug!(\"def_kind: unsupported node: {:?}\", def_id))\n     }\n+\n+    pub fn bound_type_of(self, def_id: impl IntoQueryParam<DefId>) -> ty::EarlyBinder<Ty<'tcx>> {\n+        ty::EarlyBinder(self.type_of(def_id))\n+    }\n }\n \n impl<'tcx> TyCtxtAt<'tcx> {\n@@ -449,4 +453,8 @@ impl<'tcx> TyCtxtAt<'tcx> {\n         self.opt_def_kind(def_id)\n             .unwrap_or_else(|| bug!(\"def_kind: unsupported node: {:?}\", def_id))\n     }\n+\n+    pub fn bound_type_of(self, def_id: impl IntoQueryParam<DefId>) -> ty::EarlyBinder<Ty<'tcx>> {\n+        ty::EarlyBinder(self.type_of(def_id))\n+    }\n }"}, {"sha": "95abbb50380176be8da44382f48cc725816a1186", "filename": "compiler/rustc_middle/src/ty/util.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/40fda7b3fe2b10c6e1a0568b59516f5e7f381886/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40fda7b3fe2b10c6e1a0568b59516f5e7f381886/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs?ref=40fda7b3fe2b10c6e1a0568b59516f5e7f381886", "patch": "@@ -3,7 +3,6 @@\n use crate::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n use crate::mir;\n use crate::ty::layout::IntegerExt;\n-use crate::ty::query::TyCtxtAt;\n use crate::ty::{\n     self, DefIdTree, FallibleTypeFolder, Ty, TyCtxt, TypeFoldable, TypeFolder, TypeSuperFoldable,\n     TypeVisitable,\n@@ -637,10 +636,6 @@ impl<'tcx> TyCtxt<'tcx> {\n         if visitor.found_recursion { Err(expanded_type) } else { Ok(expanded_type) }\n     }\n \n-    pub fn bound_type_of(self, def_id: DefId) -> ty::EarlyBinder<Ty<'tcx>> {\n-        ty::EarlyBinder(self.type_of(def_id))\n-    }\n-\n     pub fn bound_return_position_impl_trait_in_trait_tys(\n         self,\n         def_id: DefId,\n@@ -738,12 +733,6 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n }\n \n-impl<'tcx> TyCtxtAt<'tcx> {\n-    pub fn bound_type_of(self, def_id: DefId) -> ty::EarlyBinder<Ty<'tcx>> {\n-        ty::EarlyBinder(self.type_of(def_id))\n-    }\n-}\n-\n struct OpaqueTypeExpander<'tcx> {\n     // Contains the DefIds of the opaque types that are currently being\n     // expanded. When we expand an opaque type we insert the DefId of"}, {"sha": "7f109491350f0a21c2bbb5bc3f6b0badd193e4e8", "filename": "library/core/src/cell.rs", "status": "modified", "additions": 32, "deletions": 1, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/40fda7b3fe2b10c6e1a0568b59516f5e7f381886/library%2Fcore%2Fsrc%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40fda7b3fe2b10c6e1a0568b59516f5e7f381886/library%2Fcore%2Fsrc%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fcell.rs?ref=40fda7b3fe2b10c6e1a0568b59516f5e7f381886", "patch": "@@ -196,7 +196,7 @@ use crate::cmp::Ordering;\n use crate::fmt::{self, Debug, Display};\n use crate::marker::{PhantomData, Unsize};\n use crate::mem;\n-use crate::ops::{CoerceUnsized, Deref, DerefMut};\n+use crate::ops::{CoerceUnsized, Deref, DerefMut, DispatchFromDyn};\n use crate::ptr::{self, NonNull};\n \n mod lazy;\n@@ -571,6 +571,16 @@ impl<T: Default> Cell<T> {\n #[unstable(feature = \"coerce_unsized\", issue = \"18598\")]\n impl<T: CoerceUnsized<U>, U> CoerceUnsized<Cell<U>> for Cell<T> {}\n \n+// Allow types that wrap `Cell` to also implement `DispatchFromDyn`\n+// and become object safe method receivers.\n+// Note that currently `Cell` itself cannot be a method receiver\n+// because it does not implement Deref.\n+// In other words:\n+// `self: Cell<&Self>` won't work\n+// `self: CellWrapper<Self>` becomes possible\n+#[unstable(feature = \"dispatch_from_dyn\", issue = \"none\")]\n+impl<T: DispatchFromDyn<U>, U> DispatchFromDyn<Cell<U>> for Cell<T> {}\n+\n impl<T> Cell<[T]> {\n     /// Returns a `&[Cell<T>]` from a `&Cell<[T]>`\n     ///\n@@ -2078,6 +2088,16 @@ impl<T> const From<T> for UnsafeCell<T> {\n #[unstable(feature = \"coerce_unsized\", issue = \"18598\")]\n impl<T: CoerceUnsized<U>, U> CoerceUnsized<UnsafeCell<U>> for UnsafeCell<T> {}\n \n+// Allow types that wrap `UnsafeCell` to also implement `DispatchFromDyn`\n+// and become object safe method receivers.\n+// Note that currently `UnsafeCell` itself cannot be a method receiver\n+// because it does not implement Deref.\n+// In other words:\n+// `self: UnsafeCell<&Self>` won't work\n+// `self: UnsafeCellWrapper<Self>` becomes possible\n+#[unstable(feature = \"dispatch_from_dyn\", issue = \"none\")]\n+impl<T: DispatchFromDyn<U>, U> DispatchFromDyn<UnsafeCell<U>> for UnsafeCell<T> {}\n+\n /// [`UnsafeCell`], but [`Sync`].\n ///\n /// This is just an `UnsafeCell`, except it implements `Sync`\n@@ -2169,6 +2189,17 @@ impl<T> const From<T> for SyncUnsafeCell<T> {\n //#[unstable(feature = \"sync_unsafe_cell\", issue = \"95439\")]\n impl<T: CoerceUnsized<U>, U> CoerceUnsized<SyncUnsafeCell<U>> for SyncUnsafeCell<T> {}\n \n+// Allow types that wrap `SyncUnsafeCell` to also implement `DispatchFromDyn`\n+// and become object safe method receivers.\n+// Note that currently `SyncUnsafeCell` itself cannot be a method receiver\n+// because it does not implement Deref.\n+// In other words:\n+// `self: SyncUnsafeCell<&Self>` won't work\n+// `self: SyncUnsafeCellWrapper<Self>` becomes possible\n+#[unstable(feature = \"dispatch_from_dyn\", issue = \"none\")]\n+//#[unstable(feature = \"sync_unsafe_cell\", issue = \"95439\")]\n+impl<T: DispatchFromDyn<U>, U> DispatchFromDyn<SyncUnsafeCell<U>> for SyncUnsafeCell<T> {}\n+\n #[allow(unused)]\n fn assert_coerce_unsized(\n     a: UnsafeCell<&i32>,"}, {"sha": "938935771d64e24c84d775cd2c59472344a02a04", "filename": "library/proc_macro/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/40fda7b3fe2b10c6e1a0568b59516f5e7f381886/library%2Fproc_macro%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40fda7b3fe2b10c6e1a0568b59516f5e7f381886/library%2Fproc_macro%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fproc_macro%2Fsrc%2Flib.rs?ref=40fda7b3fe2b10c6e1a0568b59516f5e7f381886", "patch": "@@ -582,7 +582,7 @@ impl fmt::Debug for Span {\n \n /// A line-column pair representing the start or end of a `Span`.\n #[unstable(feature = \"proc_macro_span\", issue = \"54725\")]\n-#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n pub struct LineColumn {\n     /// The 1-indexed line in the source file on which the span starts or ends (inclusive).\n     #[unstable(feature = \"proc_macro_span\", issue = \"54725\")]"}, {"sha": "c6bb09b0417f3c918fd06b2b3a377b9829d2f592", "filename": "library/std/src/sync/mpmc/array.rs", "status": "modified", "additions": 5, "deletions": 13, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/40fda7b3fe2b10c6e1a0568b59516f5e7f381886/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Farray.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40fda7b3fe2b10c6e1a0568b59516f5e7f381886/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Farray.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Farray.rs?ref=40fda7b3fe2b10c6e1a0568b59516f5e7f381886", "patch": "@@ -319,19 +319,10 @@ impl<T> Channel<T> {\n     ) -> Result<(), SendTimeoutError<T>> {\n         let token = &mut Token::default();\n         loop {\n-            // Try sending a message several times.\n-            let backoff = Backoff::new();\n-            loop {\n-                if self.start_send(token) {\n-                    let res = unsafe { self.write(token, msg) };\n-                    return res.map_err(SendTimeoutError::Disconnected);\n-                }\n-\n-                if backoff.is_completed() {\n-                    break;\n-                } else {\n-                    backoff.spin_light();\n-                }\n+            // Try sending a message.\n+            if self.start_send(token) {\n+                let res = unsafe { self.write(token, msg) };\n+                return res.map_err(SendTimeoutError::Disconnected);\n             }\n \n             if let Some(d) = deadline {\n@@ -379,6 +370,7 @@ impl<T> Channel<T> {\n     pub(crate) fn recv(&self, deadline: Option<Instant>) -> Result<T, RecvTimeoutError> {\n         let token = &mut Token::default();\n         loop {\n+            // Try receiving a message.\n             if self.start_recv(token) {\n                 let res = unsafe { self.read(token) };\n                 return res.map_err(|_| RecvTimeoutError::Disconnected);"}, {"sha": "d053d69e26eeeb819c9da040bf8141870fc914b1", "filename": "library/std/src/sync/mpmc/utils.rs", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/40fda7b3fe2b10c6e1a0568b59516f5e7f381886/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40fda7b3fe2b10c6e1a0568b59516f5e7f381886/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Futils.rs?ref=40fda7b3fe2b10c6e1a0568b59516f5e7f381886", "patch": "@@ -105,10 +105,8 @@ impl Backoff {\n \n     /// Backs off using lightweight spinning.\n     ///\n-    /// This method should be used for:\n-    ///     - Retrying an operation because another thread made progress. i.e. on CAS failure.\n-    ///     - Waiting for an operation to complete by spinning optimistically for a few iterations\n-    ///     before falling back to parking the thread (see `Backoff::is_completed`).\n+    /// This method should be used for retrying an operation because another thread made\n+    /// progress. i.e. on CAS failure.\n     #[inline]\n     pub fn spin_light(&self) {\n         let step = self.step.get().min(SPIN_LIMIT);\n@@ -134,10 +132,4 @@ impl Backoff {\n \n         self.step.set(self.step.get() + 1);\n     }\n-\n-    /// Returns `true` if quadratic backoff has completed and parking the thread is advised.\n-    #[inline]\n-    pub fn is_completed(&self) -> bool {\n-        self.step.get() > SPIN_LIMIT\n-    }\n }"}, {"sha": "236d2f2ee29280cac96ce34c512c7bae291a0786", "filename": "library/std/src/sys/unix/thread_local_dtor.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/40fda7b3fe2b10c6e1a0568b59516f5e7f381886/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_local_dtor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40fda7b3fe2b10c6e1a0568b59516f5e7f381886/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_local_dtor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_local_dtor.rs?ref=40fda7b3fe2b10c6e1a0568b59516f5e7f381886", "patch": "@@ -11,13 +11,7 @@\n // Note, however, that we run on lots older linuxes, as well as cross\n // compiling from a newer linux to an older linux, so we also have a\n // fallback implementation to use as well.\n-#[cfg(any(\n-    target_os = \"linux\",\n-    target_os = \"fuchsia\",\n-    target_os = \"redox\",\n-    target_os = \"emscripten\"\n-))]\n-#[cfg_attr(target_family = \"wasm\", allow(unused))] // might remain unused depending on target details (e.g. wasm32-unknown-emscripten)\n+#[cfg(any(target_os = \"linux\", target_os = \"fuchsia\", target_os = \"redox\"))]\n pub unsafe fn register_dtor(t: *mut u8, dtor: unsafe extern \"C\" fn(*mut u8)) {\n     use crate::mem;\n     use crate::sys_common::thread_local_dtor::register_dtor_fallback;\n@@ -89,7 +83,8 @@ pub unsafe fn register_dtor(t: *mut u8, dtor: unsafe extern \"C\" fn(*mut u8)) {\n     }\n }\n \n-#[cfg(any(target_os = \"vxworks\", target_os = \"horizon\"))]\n+#[cfg(any(target_os = \"vxworks\", target_os = \"horizon\", target_os = \"emscripten\"))]\n+#[cfg_attr(target_family = \"wasm\", allow(unused))] // might remain unused depending on target details (e.g. wasm32-unknown-emscripten)\n pub unsafe fn register_dtor(t: *mut u8, dtor: unsafe extern \"C\" fn(*mut u8)) {\n     use crate::sys_common::thread_local_dtor::register_dtor_fallback;\n     register_dtor_fallback(t, dtor);"}, {"sha": "f263809552fdf3d88a0af7c0cadc9238a85b2ab8", "filename": "tests/ui/associated-types/defaults-in-other-trait-items.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/40fda7b3fe2b10c6e1a0568b59516f5e7f381886/tests%2Fui%2Fassociated-types%2Fdefaults-in-other-trait-items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40fda7b3fe2b10c6e1a0568b59516f5e7f381886/tests%2Fui%2Fassociated-types%2Fdefaults-in-other-trait-items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-types%2Fdefaults-in-other-trait-items.rs?ref=40fda7b3fe2b10c6e1a0568b59516f5e7f381886", "patch": "@@ -44,4 +44,18 @@ impl AssocConst for () {\n     const C: Self::Ty = 0u8;\n }\n \n+pub trait Trait {\n+    type Res = isize; //~ NOTE associated type defaults can't be assumed inside the trait defining them\n+\n+    fn infer_me_correctly() -> Self::Res {\n+        //~^ NOTE expected `<Self as Trait>::Res` because of return type\n+\n+        // {integer} == isize\n+        2\n+        //~^ ERROR mismatched types\n+        //~| NOTE expected associated type, found integer\n+        //~| NOTE expected associated type `<Self as Trait>::Res`\n+    }\n+}\n+\n fn main() {}"}, {"sha": "bdcfadd3955d26d39632304f4e2cd5cd245bb125", "filename": "tests/ui/associated-types/defaults-in-other-trait-items.stderr", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/40fda7b3fe2b10c6e1a0568b59516f5e7f381886/tests%2Fui%2Fassociated-types%2Fdefaults-in-other-trait-items.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/40fda7b3fe2b10c6e1a0568b59516f5e7f381886/tests%2Fui%2Fassociated-types%2Fdefaults-in-other-trait-items.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-types%2Fdefaults-in-other-trait-items.stderr?ref=40fda7b3fe2b10c6e1a0568b59516f5e7f381886", "patch": "@@ -24,6 +24,21 @@ LL |     const C: Self::Ty = 0u8;\n    = note: expected associated type `<Self as AssocConst>::Ty`\n                          found type `u8`\n \n-error: aborting due to 2 previous errors\n+error[E0308]: mismatched types\n+  --> $DIR/defaults-in-other-trait-items.rs:54:9\n+   |\n+LL |     type Res = isize;\n+   |     ----------------- associated type defaults can't be assumed inside the trait defining them\n+LL |\n+LL |     fn infer_me_correctly() -> Self::Res {\n+   |                                --------- expected `<Self as Trait>::Res` because of return type\n+...\n+LL |         2\n+   |         ^ expected associated type, found integer\n+   |\n+   = note: expected associated type `<Self as Trait>::Res`\n+                         found type `{integer}`\n+\n+error: aborting due to 3 previous errors\n \n For more information about this error, try `rustc --explain E0308`."}, {"sha": "977620d9052f271b37244490edf6d8c311cdaf21", "filename": "tests/ui/associated-types/issue-26681.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/40fda7b3fe2b10c6e1a0568b59516f5e7f381886/tests%2Fui%2Fassociated-types%2Fissue-26681.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/40fda7b3fe2b10c6e1a0568b59516f5e7f381886/tests%2Fui%2Fassociated-types%2Fissue-26681.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-types%2Fissue-26681.stderr?ref=40fda7b3fe2b10c6e1a0568b59516f5e7f381886", "patch": "@@ -1,13 +1,13 @@\n error[E0308]: mismatched types\n   --> $DIR/issue-26681.rs:17:39\n    |\n+LL |     type Fv: Foo = u8;\n+   |     ------------------ associated type defaults can't be assumed inside the trait defining them\n LL |     const C: <Self::Fv as Foo>::Bar = 6665;\n    |                                       ^^^^ expected associated type, found integer\n    |\n    = note: expected associated type `<<Self as Baz>::Fv as Foo>::Bar`\n                          found type `{integer}`\n-   = help: consider constraining the associated type `<<Self as Baz>::Fv as Foo>::Bar` to `{integer}`\n-   = note: for more information, visit https://doc.rust-lang.org/book/ch19-03-advanced-traits.html\n \n error: aborting due to previous error\n "}, {"sha": "83366ea02b09a4be662212c0425827ea4497c1d0", "filename": "tests/ui/feature-gates/feature-gate-dispatch-from-dyn-cell.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/40fda7b3fe2b10c6e1a0568b59516f5e7f381886/tests%2Fui%2Ffeature-gates%2Ffeature-gate-dispatch-from-dyn-cell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40fda7b3fe2b10c6e1a0568b59516f5e7f381886/tests%2Fui%2Ffeature-gates%2Ffeature-gate-dispatch-from-dyn-cell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffeature-gates%2Ffeature-gate-dispatch-from-dyn-cell.rs?ref=40fda7b3fe2b10c6e1a0568b59516f5e7f381886", "patch": "@@ -0,0 +1,9 @@\n+// Check that even though Cell: DispatchFromDyn it remains an invalid self parameter type\n+\n+use std::cell::Cell;\n+\n+trait Trait{\n+    fn cell(self: Cell<&Self>); //~ ERROR invalid `self` parameter type: Cell<&Self>\n+}\n+\n+fn main() {}"}, {"sha": "ce06ce916a7587823dfa66a8427635cca3b0102c", "filename": "tests/ui/feature-gates/feature-gate-dispatch-from-dyn-cell.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/40fda7b3fe2b10c6e1a0568b59516f5e7f381886/tests%2Fui%2Ffeature-gates%2Ffeature-gate-dispatch-from-dyn-cell.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/40fda7b3fe2b10c6e1a0568b59516f5e7f381886/tests%2Fui%2Ffeature-gates%2Ffeature-gate-dispatch-from-dyn-cell.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffeature-gates%2Ffeature-gate-dispatch-from-dyn-cell.stderr?ref=40fda7b3fe2b10c6e1a0568b59516f5e7f381886", "patch": "@@ -0,0 +1,12 @@\n+error[E0307]: invalid `self` parameter type: Cell<&Self>\n+  --> $DIR/feature-gate-dispatch-from-dyn-cell.rs:6:19\n+   |\n+LL |     fn cell(self: Cell<&Self>);\n+   |                   ^^^^^^^^^^^\n+   |\n+   = note: type of `self` must be `Self` or a type that dereferences to it\n+   = help: consider changing to `self`, `&self`, `&mut self`, `self: Box<Self>`, `self: Rc<Self>`, `self: Arc<Self>`, or `self: Pin<P>` (where P is one of the previous types except `Self`)\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0307`."}, {"sha": "23857cbaca85e700de69af8bc9b663edb77eb2cd", "filename": "tests/ui/feature-gates/feature-gate-dispatch-from-dyn-missing-impl.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/40fda7b3fe2b10c6e1a0568b59516f5e7f381886/tests%2Fui%2Ffeature-gates%2Ffeature-gate-dispatch-from-dyn-missing-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40fda7b3fe2b10c6e1a0568b59516f5e7f381886/tests%2Fui%2Ffeature-gates%2Ffeature-gate-dispatch-from-dyn-missing-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffeature-gates%2Ffeature-gate-dispatch-from-dyn-missing-impl.rs?ref=40fda7b3fe2b10c6e1a0568b59516f5e7f381886", "patch": "@@ -0,0 +1,35 @@\n+// Check that a self parameter type requires a DispatchFromDyn impl to be object safe\n+\n+#![feature(arbitrary_self_types, unsize, coerce_unsized)]\n+\n+use std::{\n+    marker::Unsize,\n+    ops::{CoerceUnsized, Deref},\n+};\n+\n+struct Ptr<T: ?Sized>(Box<T>);\n+\n+impl<T: ?Sized> Deref for Ptr<T> {\n+    type Target = T;\n+\n+    fn deref(&self) -> &T {\n+        &*self.0\n+    }\n+}\n+\n+impl<T: Unsize<U> + ?Sized, U: ?Sized> CoerceUnsized<Ptr<U>> for Ptr<T> {}\n+// Because this impl is missing the coercion below fails.\n+// impl<T: Unsize<U> + ?Sized, U: ?Sized> DispatchFromDyn<Ptr<U>> for Ptr<T> {}\n+\n+trait Trait {\n+    fn ptr(self: Ptr<Self>);\n+}\n+impl Trait for i32 {\n+    fn ptr(self: Ptr<Self>) {}\n+}\n+\n+fn main() {\n+    Ptr(Box::new(4)) as Ptr<dyn Trait>;\n+    //~^ ERROR the trait `Trait` cannot be made into an object\n+    //~^^ ERROR the trait `Trait` cannot be made into an object\n+}"}, {"sha": "d81eade8e9bfb74dd62e2013e51240cb54832d20", "filename": "tests/ui/feature-gates/feature-gate-dispatch-from-dyn-missing-impl.stderr", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/40fda7b3fe2b10c6e1a0568b59516f5e7f381886/tests%2Fui%2Ffeature-gates%2Ffeature-gate-dispatch-from-dyn-missing-impl.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/40fda7b3fe2b10c6e1a0568b59516f5e7f381886/tests%2Fui%2Ffeature-gates%2Ffeature-gate-dispatch-from-dyn-missing-impl.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffeature-gates%2Ffeature-gate-dispatch-from-dyn-missing-impl.stderr?ref=40fda7b3fe2b10c6e1a0568b59516f5e7f381886", "patch": "@@ -0,0 +1,45 @@\n+error[E0038]: the trait `Trait` cannot be made into an object\n+  --> $DIR/feature-gate-dispatch-from-dyn-missing-impl.rs:32:25\n+   |\n+LL |     fn ptr(self: Ptr<Self>);\n+   |                  --------- help: consider changing method `ptr`'s `self` parameter to be `&self`: `&Self`\n+...\n+LL |     Ptr(Box::new(4)) as Ptr<dyn Trait>;\n+   |                         ^^^^^^^^^^^^^^ `Trait` cannot be made into an object\n+   |\n+note: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n+  --> $DIR/feature-gate-dispatch-from-dyn-missing-impl.rs:25:18\n+   |\n+LL | trait Trait {\n+   |       ----- this trait cannot be made into an object...\n+LL |     fn ptr(self: Ptr<Self>);\n+   |                  ^^^^^^^^^ ...because method `ptr`'s `self` parameter cannot be dispatched on\n+\n+error[E0038]: the trait `Trait` cannot be made into an object\n+  --> $DIR/feature-gate-dispatch-from-dyn-missing-impl.rs:32:5\n+   |\n+LL |     fn ptr(self: Ptr<Self>);\n+   |                  --------- help: consider changing method `ptr`'s `self` parameter to be `&self`: `&Self`\n+...\n+LL |     Ptr(Box::new(4)) as Ptr<dyn Trait>;\n+   |     ^^^^^^^^^^^^^^^^ `Trait` cannot be made into an object\n+   |\n+note: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n+  --> $DIR/feature-gate-dispatch-from-dyn-missing-impl.rs:25:18\n+   |\n+LL | trait Trait {\n+   |       ----- this trait cannot be made into an object...\n+LL |     fn ptr(self: Ptr<Self>);\n+   |                  ^^^^^^^^^ ...because method `ptr`'s `self` parameter cannot be dispatched on\n+note: required for `Ptr<{integer}>` to implement `CoerceUnsized<Ptr<dyn Trait>>`\n+  --> $DIR/feature-gate-dispatch-from-dyn-missing-impl.rs:20:40\n+   |\n+LL | impl<T: Unsize<U> + ?Sized, U: ?Sized> CoerceUnsized<Ptr<U>> for Ptr<T> {}\n+   |         ---------                      ^^^^^^^^^^^^^^^^^^^^^     ^^^^^^\n+   |         |\n+   |         unsatisfied trait bound introduced here\n+   = note: required by cast to type `Ptr<dyn Trait>`\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0038`."}, {"sha": "b4e71e75fdb9a196a556be0afb8eafffd5bf869d", "filename": "tests/ui/fn/fn-compare-mismatch.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/40fda7b3fe2b10c6e1a0568b59516f5e7f381886/tests%2Fui%2Ffn%2Ffn-compare-mismatch.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/40fda7b3fe2b10c6e1a0568b59516f5e7f381886/tests%2Fui%2Ffn%2Ffn-compare-mismatch.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffn%2Ffn-compare-mismatch.stderr?ref=40fda7b3fe2b10c6e1a0568b59516f5e7f381886", "patch": "@@ -20,6 +20,7 @@ LL |     let x = f == g;\n    = note: expected fn item `fn() {f}`\n               found fn item `fn() {g}`\n    = note: different fn items have unique types, even if their signatures are the same\n+   = help: consider casting both fn items to fn pointers using `as fn()`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "9d41243ef11917479aca7c97468b5e5768578352", "filename": "tests/ui/fn/fn-item-type.stderr", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/40fda7b3fe2b10c6e1a0568b59516f5e7f381886/tests%2Fui%2Ffn%2Ffn-item-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/40fda7b3fe2b10c6e1a0568b59516f5e7f381886/tests%2Fui%2Ffn%2Ffn-item-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffn%2Ffn-item-type.stderr?ref=40fda7b3fe2b10c6e1a0568b59516f5e7f381886", "patch": "@@ -14,6 +14,7 @@ note: function defined here\n    |\n LL | fn eq<T>(x: T, y: T) {}\n    |    ^^          ----\n+   = help: consider casting both fn items to fn pointers using `as fn(isize) -> isize`\n \n error[E0308]: mismatched types\n   --> $DIR/fn-item-type.rs:29:19\n@@ -31,6 +32,7 @@ note: function defined here\n    |\n LL | fn eq<T>(x: T, y: T) {}\n    |    ^^          ----\n+   = help: consider casting both fn items to fn pointers using `as fn(isize) -> isize`\n \n error[E0308]: mismatched types\n   --> $DIR/fn-item-type.rs:34:23\n@@ -48,6 +50,7 @@ note: function defined here\n    |\n LL | fn eq<T>(x: T, y: T) {}\n    |    ^^          ----\n+   = help: consider casting both fn items to fn pointers using `as fn(isize) -> isize`\n \n error[E0308]: mismatched types\n   --> $DIR/fn-item-type.rs:41:26\n@@ -65,6 +68,7 @@ note: function defined here\n    |\n LL | fn eq<T>(x: T, y: T) {}\n    |    ^^          ----\n+   = help: consider casting both fn items to fn pointers using `as fn()`\n \n error[E0308]: mismatched types\n   --> $DIR/fn-item-type.rs:46:19\n@@ -76,7 +80,7 @@ LL |     eq(foo::<u8>, bar::<u8> as fn(isize) -> isize);\n    |\n    = note: expected fn item `fn(_) -> _ {foo::<u8>}`\n            found fn pointer `fn(_) -> _`\n-   = note: fn items are distinct from fn pointers\n+   = help: consider casting the fn item to a fn pointer: `foo::<u8> as fn(isize) -> isize`\n note: function defined here\n   --> $DIR/fn-item-type.rs:11:4\n    |"}, {"sha": "e0bd60fbc0b5ececeb825f217bc42413b073d26d", "filename": "tests/ui/fn/fn-pointer-mismatch.stderr", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/40fda7b3fe2b10c6e1a0568b59516f5e7f381886/tests%2Fui%2Ffn%2Ffn-pointer-mismatch.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/40fda7b3fe2b10c6e1a0568b59516f5e7f381886/tests%2Fui%2Ffn%2Ffn-pointer-mismatch.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffn%2Ffn-pointer-mismatch.stderr?ref=40fda7b3fe2b10c6e1a0568b59516f5e7f381886", "patch": "@@ -9,6 +9,7 @@ LL |     let g = if n % 2 == 0 { &foo } else { &bar };\n    = note: expected reference `&fn(u32) -> u32 {foo}`\n               found reference `&fn(u32) -> u32 {bar}`\n    = note: different fn items have unique types, even if their signatures are the same\n+   = help: consider casting both fn items to fn pointers using `as fn(u32) -> u32`\n \n error[E0308]: mismatched types\n   --> $DIR/fn-pointer-mismatch.rs:23:9\n@@ -21,6 +22,7 @@ LL |     a = bar;\n    = note: expected fn item `fn(_) -> _ {foo}`\n               found fn item `fn(_) -> _ {bar}`\n    = note: different fn items have unique types, even if their signatures are the same\n+   = help: consider casting both fn items to fn pointers using `as fn(u32) -> u32`\n \n error[E0308]: mismatched types\n   --> $DIR/fn-pointer-mismatch.rs:31:18\n@@ -35,6 +37,7 @@ LL |     b = Box::new(bar);\n    = note: different fn items have unique types, even if their signatures are the same\n note: associated function defined here\n   --> $SRC_DIR/alloc/src/boxed.rs:LL:COL\n+   = help: consider casting both fn items to fn pointers using `as fn(u32) -> u32`\n \n error[E0308]: mismatched types\n   --> $DIR/fn-pointer-mismatch.rs:36:29"}, {"sha": "91aacedfc577897b70c0bad4de441d3633bd38a4", "filename": "tests/ui/self/arbitrary_self_types_pointers_and_wrappers.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/40fda7b3fe2b10c6e1a0568b59516f5e7f381886/tests%2Fui%2Fself%2Farbitrary_self_types_pointers_and_wrappers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40fda7b3fe2b10c6e1a0568b59516f5e7f381886/tests%2Fui%2Fself%2Farbitrary_self_types_pointers_and_wrappers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fself%2Farbitrary_self_types_pointers_and_wrappers.rs?ref=40fda7b3fe2b10c6e1a0568b59516f5e7f381886", "patch": "@@ -3,6 +3,7 @@\n #![feature(rustc_attrs)]\n \n use std::{\n+    cell::Cell,\n     ops::{Deref, CoerceUnsized, DispatchFromDyn},\n     marker::Unsize,\n };\n@@ -20,6 +21,20 @@ impl<T: ?Sized> Deref for Ptr<T> {\n impl<T: Unsize<U> + ?Sized, U: ?Sized> CoerceUnsized<Ptr<U>> for Ptr<T> {}\n impl<T: Unsize<U> + ?Sized, U: ?Sized> DispatchFromDyn<Ptr<U>> for Ptr<T> {}\n \n+\n+struct CellPtr<'a, T: ?Sized>(Cell<&'a T>);\n+\n+impl<'a, T: ?Sized> Deref for CellPtr<'a, T> {\n+    type Target = T;\n+\n+    fn deref(&self) -> &T {\n+        self.0.get()\n+    }\n+}\n+\n+impl<'a, T: Unsize<U> + ?Sized, U: ?Sized> CoerceUnsized<CellPtr<'a, U>> for CellPtr<'a, T> {}\n+impl<'a, T: Unsize<U> + ?Sized, U: ?Sized> DispatchFromDyn<CellPtr<'a, U>> for CellPtr<'a, T> {}\n+\n struct Wrapper<T: ?Sized>(T);\n \n impl<T: ?Sized> Deref for Wrapper<T> {\n@@ -42,6 +57,7 @@ trait Trait {\n     fn ptr_wrapper(self: Ptr<Wrapper<Self>>) -> i32;\n     fn wrapper_ptr(self: Wrapper<Ptr<Self>>) -> i32;\n     fn wrapper_ptr_wrapper(self: Wrapper<Ptr<Wrapper<Self>>>) -> i32;\n+    fn cell(self: CellPtr<Self>) -> i32;\n }\n \n impl Trait for i32 {\n@@ -54,6 +70,9 @@ impl Trait for i32 {\n     fn wrapper_ptr_wrapper(self: Wrapper<Ptr<Wrapper<Self>>>) -> i32 {\n         ***self\n     }\n+    fn cell(self: CellPtr<Self>) -> i32 {\n+        *self\n+    }\n }\n \n fn main() {\n@@ -65,4 +84,7 @@ fn main() {\n \n     let wpw = Wrapper(Ptr(Box::new(Wrapper(7)))) as Wrapper<Ptr<Wrapper<dyn Trait>>>;\n     assert_eq!(wpw.wrapper_ptr_wrapper(), 7);\n+\n+    let c = CellPtr(Cell::new(&8)) as CellPtr<dyn Trait>;\n+    assert_eq!(c.cell(), 8);\n }"}]}