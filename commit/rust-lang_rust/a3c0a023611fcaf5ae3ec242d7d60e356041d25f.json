{"sha": "a3c0a023611fcaf5ae3ec242d7d60e356041d25f", "node_id": "C_kwDOAAsO6NoAKGEzYzBhMDIzNjExZmNhZjVhZTNlYzI0MmQ3ZDYwZTM1NjA0MWQyNWY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-10T16:22:59Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-10T16:22:59Z"}, "message": "Auto merge of #104246 - Manishearth:rollup-9o3txc7, r=Manishearth\n\nRollup of 9 pull requests\n\nSuccessful merges:\n\n - #101939 (Add loongarch64 abi support)\n - #103863 (Use `TraitEngine` in more places, restrict visibility of `FulfillmentCtxt` constructor)\n - #104036 (Suggest `is_some` when we've found `Option` but expected `bool`)\n - #104060 (Make `Hash`, `Hasher` and `BuildHasher` `#[const_trait]` and make `Sip` const `Hasher`)\n - #104077 (Use aapcs for efiapi calling convention on arm)\n - #104186 (Tighten the 'introduce new binding' suggestion)\n - #104194 (`EarlyBinder` docs)\n - #104233 (Don't ICE when encountering `ConstKind::Error` in `RequiredConstsVisitor`)\n - #104235 (Use `const_error_with_guaranteed` more)\n\nFailed merges:\n\n - #104078 (Print \"Checking/Building ...\" message even when --dry-run is passed)\n - #104169 (Migrate `:target` rules to use CSS variables)\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "a67c0f2b109fa36f3146b0c893fc9ed5212d625a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a67c0f2b109fa36f3146b0c893fc9ed5212d625a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a3c0a023611fcaf5ae3ec242d7d60e356041d25f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a3c0a023611fcaf5ae3ec242d7d60e356041d25f", "html_url": "https://github.com/rust-lang/rust/commit/a3c0a023611fcaf5ae3ec242d7d60e356041d25f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a3c0a023611fcaf5ae3ec242d7d60e356041d25f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "01a6f30324deb8f9c9ec4a70c53690c5d073a244", "url": "https://api.github.com/repos/rust-lang/rust/commits/01a6f30324deb8f9c9ec4a70c53690c5d073a244", "html_url": "https://github.com/rust-lang/rust/commit/01a6f30324deb8f9c9ec4a70c53690c5d073a244"}, {"sha": "ea56e807268db5b9ad929fc2cdd149c8c457c6e8", "url": "https://api.github.com/repos/rust-lang/rust/commits/ea56e807268db5b9ad929fc2cdd149c8c457c6e8", "html_url": "https://github.com/rust-lang/rust/commit/ea56e807268db5b9ad929fc2cdd149c8c457c6e8"}], "stats": {"total": 931, "additions": 827, "deletions": 104}, "files": [{"sha": "71949b4211819b79d08c09b5b32872504294a3a7", "filename": "compiler/rustc_hir_typeck/src/coercion.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a3c0a023611fcaf5ae3ec242d7d60e356041d25f/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3c0a023611fcaf5ae3ec242d7d60e356041d25f/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs?ref=a3c0a023611fcaf5ae3ec242d7d60e356041d25f", "patch": "@@ -62,6 +62,7 @@ use rustc_span::{self, BytePos, DesugaringKind, Span};\n use rustc_target::spec::abi::Abi;\n use rustc_trait_selection::infer::InferCtxtExt as _;\n use rustc_trait_selection::traits::error_reporting::TypeErrCtxtExt as _;\n+use rustc_trait_selection::traits::TraitEngineExt as _;\n use rustc_trait_selection::traits::{self, ObligationCause, ObligationCauseCode};\n \n use smallvec::{smallvec, SmallVec};\n@@ -1038,7 +1039,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             let Ok(ok) = coerce.coerce(source, target) else {\n                 return false;\n             };\n-            let mut fcx = traits::FulfillmentContext::new_in_snapshot();\n+            let mut fcx = <dyn TraitEngine<'tcx>>::new_in_snapshot(self.tcx);\n             fcx.register_predicate_obligations(self, ok.obligations);\n             fcx.select_where_possible(&self).is_empty()\n         })"}, {"sha": "7f78f5fb8a7b2091f39a70ae5927cb2dfa1d6259", "filename": "compiler/rustc_hir_typeck/src/demand.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a3c0a023611fcaf5ae3ec242d7d60e356041d25f/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3c0a023611fcaf5ae3ec242d7d60e356041d25f/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs?ref=a3c0a023611fcaf5ae3ec242d7d60e356041d25f", "patch": "@@ -42,7 +42,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             || self.suggest_boxing_when_appropriate(err, expr, expected, expr_ty)\n             || self.suggest_block_to_brackets_peeling_refs(err, expr, expr_ty, expected)\n             || self.suggest_copied_or_cloned(err, expr, expr_ty, expected)\n-            || self.suggest_into(err, expr, expr_ty, expected);\n+            || self.suggest_into(err, expr, expr_ty, expected)\n+            || self.suggest_option_to_bool(err, expr, expr_ty, expected);\n \n         self.note_type_is_not_clone(err, expected, expr_ty, expr);\n         self.note_need_for_fn_pointer(err, expected, expr_ty);"}, {"sha": "e948d832e3280997fd134daf86d38b42712ce606", "filename": "compiler/rustc_hir_typeck/src/expr.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a3c0a023611fcaf5ae3ec242d7d60e356041d25f/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3c0a023611fcaf5ae3ec242d7d60e356041d25f/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs?ref=a3c0a023611fcaf5ae3ec242d7d60e356041d25f", "patch": "@@ -103,8 +103,16 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n \n         if let Some(mut err) = self.demand_suptype_diag(expr.span, expected_ty, ty) {\n-            let expr = expr.peel_drop_temps();\n-            self.suggest_deref_ref_or_into(&mut err, expr, expected_ty, ty, None);\n+            // FIXME(compiler-errors): We probably should fold some of the\n+            // `suggest_` functions from  `emit_coerce_suggestions` into here,\n+            // since some of those aren't necessarily just coerce suggestions.\n+            let _ = self.suggest_deref_ref_or_into(\n+                &mut err,\n+                expr.peel_drop_temps(),\n+                expected_ty,\n+                ty,\n+                None,\n+            ) || self.suggest_option_to_bool(&mut err, expr, ty, expected_ty);\n             extend_err(&mut err);\n             err.emit();\n         }"}, {"sha": "a14759e254c49216940a4604acd162f48ce3f393", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/suggestions.rs", "status": "modified", "additions": 48, "deletions": 1, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/a3c0a023611fcaf5ae3ec242d7d60e356041d25f/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3c0a023611fcaf5ae3ec242d7d60e356041d25f/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs?ref=a3c0a023611fcaf5ae3ec242d7d60e356041d25f", "patch": "@@ -13,7 +13,7 @@ use rustc_hir_analysis::astconv::AstConv;\n use rustc_infer::infer::{self, TyCtxtInferExt};\n use rustc_infer::traits::{self, StatementAsExpression};\n use rustc_middle::lint::in_external_macro;\n-use rustc_middle::ty::{self, Binder, IsSuggestable, ToPredicate, Ty};\n+use rustc_middle::ty::{self, Binder, DefIdTree, IsSuggestable, ToPredicate, Ty};\n use rustc_session::errors::ExprParenthesesNeeded;\n use rustc_span::symbol::sym;\n use rustc_span::Span;\n@@ -1116,6 +1116,53 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         false\n     }\n \n+    /// When expecting a `bool` and finding an `Option`, suggests using `let Some(..)` or `.is_some()`\n+    pub(crate) fn suggest_option_to_bool(\n+        &self,\n+        diag: &mut Diagnostic,\n+        expr: &hir::Expr<'_>,\n+        expr_ty: Ty<'tcx>,\n+        expected_ty: Ty<'tcx>,\n+    ) -> bool {\n+        if !expected_ty.is_bool() {\n+            return false;\n+        }\n+\n+        let ty::Adt(def, _) = expr_ty.peel_refs().kind() else { return false; };\n+        if !self.tcx.is_diagnostic_item(sym::Option, def.did()) {\n+            return false;\n+        }\n+\n+        let hir = self.tcx.hir();\n+        let cond_parent = hir.parent_iter(expr.hir_id).skip_while(|(_, node)| {\n+            matches!(node, hir::Node::Expr(hir::Expr { kind: hir::ExprKind::Binary(op, _, _), .. }) if op.node == hir::BinOpKind::And)\n+        }).next();\n+        // Don't suggest:\n+        //     `let Some(_) = a.is_some() && b`\n+        //                     ++++++++++\n+        // since the user probably just misunderstood how `let else`\n+        // and `&&` work together.\n+        if let Some((_, hir::Node::Local(local))) = cond_parent\n+            && let hir::PatKind::Path(qpath) | hir::PatKind::TupleStruct(qpath, _, _) = &local.pat.kind\n+            && let hir::QPath::Resolved(None, path) = qpath\n+            && let Some(did) = path.res.opt_def_id()\n+                .and_then(|did| self.tcx.opt_parent(did))\n+                .and_then(|did| self.tcx.opt_parent(did))\n+            && self.tcx.is_diagnostic_item(sym::Option, did)\n+        {\n+            return false;\n+        }\n+\n+        diag.span_suggestion(\n+            expr.span.shrink_to_hi(),\n+            \"use `Option::is_some` to test if the `Option` has a value\",\n+            \".is_some()\",\n+            Applicability::MachineApplicable,\n+        );\n+\n+        true\n+    }\n+\n     /// Suggest wrapping the block in square brackets instead of curly braces\n     /// in case the block was mistaken array syntax, e.g. `{ 1 }` -> `[ 1 ]`.\n     pub(crate) fn suggest_block_to_brackets("}, {"sha": "32ec585576920948dbdd5438039f934005d315ac", "filename": "compiler/rustc_middle/src/mir/interpret/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a3c0a023611fcaf5ae3ec242d7d60e356041d25f/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3c0a023611fcaf5ae3ec242d7d60e356041d25f/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs?ref=a3c0a023611fcaf5ae3ec242d7d60e356041d25f", "patch": "@@ -106,6 +106,7 @@ use rustc_ast::LitKind;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::{HashMapExt, Lock};\n use rustc_data_structures::tiny_list::TinyList;\n+use rustc_errors::ErrorGuaranteed;\n use rustc_hir::def_id::DefId;\n use rustc_macros::HashStable;\n use rustc_middle::ty::print::with_no_trimmed_paths;\n@@ -176,7 +177,7 @@ pub enum LitToConstError {\n     /// This is used for graceful error handling (`delay_span_bug`) in\n     /// type checking (`Const::from_anon_const`).\n     TypeError,\n-    Reported,\n+    Reported(ErrorGuaranteed),\n }\n \n #[derive(Copy, Clone, Eq, Hash, Ord, PartialEq, PartialOrd)]"}, {"sha": "54f3964d28f06db97db31c92405e9b17a047b5f4", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3c0a023611fcaf5ae3ec242d7d60e356041d25f/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3c0a023611fcaf5ae3ec242d7d60e356041d25f/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=a3c0a023611fcaf5ae3ec242d7d60e356041d25f", "patch": "@@ -2251,7 +2251,9 @@ impl<'tcx> ConstantKind<'tcx> {\n                 match tcx.const_eval_resolve(param_env, uneval, None) {\n                     Ok(val) => Self::Val(val, ty),\n                     Err(ErrorHandled::TooGeneric | ErrorHandled::Linted) => self,\n-                    Err(_) => Self::Ty(tcx.const_error(ty)),\n+                    Err(ErrorHandled::Reported(guar)) => {\n+                        Self::Ty(tcx.const_error_with_guaranteed(ty, guar))\n+                    }\n                 }\n             }\n         }"}, {"sha": "e2e2761501b48c5cf0e544e9befbf8100c18d940", "filename": "compiler/rustc_middle/src/ty/consts.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a3c0a023611fcaf5ae3ec242d7d60e356041d25f/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3c0a023611fcaf5ae3ec242d7d60e356041d25f/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts.rs?ref=a3c0a023611fcaf5ae3ec242d7d60e356041d25f", "patch": "@@ -2,7 +2,6 @@ use crate::mir::interpret::LitToConstInput;\n use crate::mir::ConstantKind;\n use crate::ty::{self, InternalSubsts, ParamEnv, ParamEnvAnd, Ty, TyCtxt};\n use rustc_data_structures::intern::Interned;\n-use rustc_errors::ErrorGuaranteed;\n use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_macros::HashStable;\n@@ -225,7 +224,7 @@ impl<'tcx> Const<'tcx> {\n         if let Some(val) = self.kind().try_eval_for_typeck(tcx, param_env) {\n             match val {\n                 Ok(val) => Const::from_value(tcx, val, self.ty()),\n-                Err(ErrorGuaranteed { .. }) => tcx.const_error(self.ty()),\n+                Err(guar) => tcx.const_error_with_guaranteed(self.ty(), guar),\n             }\n         } else {\n             // Either the constant isn't evaluatable or ValTree creation failed.\n@@ -240,7 +239,7 @@ impl<'tcx> Const<'tcx> {\n         if let Some(val) = self.kind().try_eval_for_mir(tcx, param_env) {\n             match val {\n                 Ok(const_val) => ConstantKind::from_value(const_val, self.ty()),\n-                Err(ErrorGuaranteed { .. }) => ConstantKind::Ty(tcx.const_error(self.ty())),\n+                Err(guar) => ConstantKind::Ty(tcx.const_error_with_guaranteed(self.ty(), guar)),\n             }\n         } else {\n             ConstantKind::Ty(self)"}, {"sha": "2bcb2d824842efc5e1a0683a89c8aad6cead84bd", "filename": "compiler/rustc_middle/src/ty/subst.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a3c0a023611fcaf5ae3ec242d7d60e356041d25f/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3c0a023611fcaf5ae3ec242d7d60e356041d25f/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs?ref=a3c0a023611fcaf5ae3ec242d7d60e356041d25f", "patch": "@@ -506,6 +506,9 @@ impl<'tcx, T: TypeVisitable<'tcx>> TypeVisitable<'tcx> for &'tcx ty::List<T> {\n     }\n }\n \n+/// Similar to [`super::Binder`] except that it tracks early bound generics, i.e. `struct Foo<T>(T)`\n+/// needs `T` substituted immediately. This type primarily exists to avoid forgetting to call\n+/// `subst`.\n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]\n #[derive(Encodable, Decodable, HashStable)]\n pub struct EarlyBinder<T>(pub T);"}, {"sha": "7d8a940bde5cefc78c9d5988c364f90bff270786", "filename": "compiler/rustc_mir_build/src/build/expr/as_constant.rs", "status": "modified", "additions": 25, "deletions": 6, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/a3c0a023611fcaf5ae3ec242d7d60e356041d25f/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_constant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3c0a023611fcaf5ae3ec242d7d60e356041d25f/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_constant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_constant.rs?ref=a3c0a023611fcaf5ae3ec242d7d60e356041d25f", "patch": "@@ -9,6 +9,7 @@ use rustc_middle::mir::interpret::{\n use rustc_middle::mir::*;\n use rustc_middle::thir::*;\n use rustc_middle::ty::{self, CanonicalUserTypeAnnotation, TyCtxt};\n+use rustc_span::DUMMY_SP;\n use rustc_target::abi::Size;\n \n impl<'a, 'tcx> Builder<'a, 'tcx> {\n@@ -26,7 +27,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 let literal =\n                     match lit_to_mir_constant(tcx, LitToConstInput { lit: &lit.node, ty, neg }) {\n                         Ok(c) => c,\n-                        Err(LitToConstError::Reported) => ConstantKind::Ty(tcx.const_error(ty)),\n+                        Err(LitToConstError::Reported(guar)) => {\n+                            ConstantKind::Ty(tcx.const_error_with_guaranteed(ty, guar))\n+                        }\n                         Err(LitToConstError::TypeError) => {\n                             bug!(\"encountered type error in `lit_to_mir_constant\")\n                         }\n@@ -105,7 +108,15 @@ pub(crate) fn lit_to_mir_constant<'tcx>(\n     let LitToConstInput { lit, ty, neg } = lit_input;\n     let trunc = |n| {\n         let param_ty = ty::ParamEnv::reveal_all().and(ty);\n-        let width = tcx.layout_of(param_ty).map_err(|_| LitToConstError::Reported)?.size;\n+        let width = tcx\n+            .layout_of(param_ty)\n+            .map_err(|_| {\n+                LitToConstError::Reported(tcx.sess.delay_span_bug(\n+                    DUMMY_SP,\n+                    format!(\"couldn't compute width of literal: {:?}\", lit_input.lit),\n+                ))\n+            })?\n+            .size;\n         trace!(\"trunc {} with size {} and shift {}\", n, width.bits(), 128 - width.bits());\n         let result = width.truncate(n);\n         trace!(\"trunc result: {}\", result);\n@@ -136,12 +147,20 @@ pub(crate) fn lit_to_mir_constant<'tcx>(\n         (ast::LitKind::Int(n, _), ty::Uint(_)) | (ast::LitKind::Int(n, _), ty::Int(_)) => {\n             trunc(if neg { (*n as i128).overflowing_neg().0 as u128 } else { *n })?\n         }\n-        (ast::LitKind::Float(n, _), ty::Float(fty)) => {\n-            parse_float_into_constval(*n, *fty, neg).ok_or(LitToConstError::Reported)?\n-        }\n+        (ast::LitKind::Float(n, _), ty::Float(fty)) => parse_float_into_constval(*n, *fty, neg)\n+            .ok_or_else(|| {\n+                LitToConstError::Reported(tcx.sess.delay_span_bug(\n+                    DUMMY_SP,\n+                    format!(\"couldn't parse float literal: {:?}\", lit_input.lit),\n+                ))\n+            })?,\n         (ast::LitKind::Bool(b), ty::Bool) => ConstValue::Scalar(Scalar::from_bool(*b)),\n         (ast::LitKind::Char(c), ty::Char) => ConstValue::Scalar(Scalar::from_char(*c)),\n-        (ast::LitKind::Err, _) => return Err(LitToConstError::Reported),\n+        (ast::LitKind::Err, _) => {\n+            return Err(LitToConstError::Reported(\n+                tcx.sess.delay_span_bug(DUMMY_SP, \"encountered LitKind::Err during mir build\"),\n+            ));\n+        }\n         _ => return Err(LitToConstError::TypeError),\n     };\n "}, {"sha": "85e8801bda3ec929453c3473eaf01d2ce06dcbe1", "filename": "compiler/rustc_mir_build/src/thir/constant.rs", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a3c0a023611fcaf5ae3ec242d7d60e356041d25f/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3c0a023611fcaf5ae3ec242d7d60e356041d25f/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fconstant.rs?ref=a3c0a023611fcaf5ae3ec242d7d60e356041d25f", "patch": "@@ -1,6 +1,7 @@\n use rustc_ast as ast;\n use rustc_middle::mir::interpret::{LitToConstError, LitToConstInput};\n use rustc_middle::ty::{self, ParamEnv, ScalarInt, TyCtxt};\n+use rustc_span::DUMMY_SP;\n \n pub(crate) fn lit_to_const<'tcx>(\n     tcx: TyCtxt<'tcx>,\n@@ -10,7 +11,15 @@ pub(crate) fn lit_to_const<'tcx>(\n \n     let trunc = |n| {\n         let param_ty = ParamEnv::reveal_all().and(ty);\n-        let width = tcx.layout_of(param_ty).map_err(|_| LitToConstError::Reported)?.size;\n+        let width = tcx\n+            .layout_of(param_ty)\n+            .map_err(|_| {\n+                LitToConstError::Reported(tcx.sess.delay_span_bug(\n+                    DUMMY_SP,\n+                    format!(\"couldn't compute width of literal: {:?}\", lit_input.lit),\n+                ))\n+            })?\n+            .size;\n         trace!(\"trunc {} with size {} and shift {}\", n, width.bits(), 128 - width.bits());\n         let result = width.truncate(n);\n         trace!(\"trunc result: {}\", result);\n@@ -44,7 +53,11 @@ pub(crate) fn lit_to_const<'tcx>(\n         }\n         (ast::LitKind::Bool(b), ty::Bool) => ty::ValTree::from_scalar_int((*b).into()),\n         (ast::LitKind::Char(c), ty::Char) => ty::ValTree::from_scalar_int((*c).into()),\n-        (ast::LitKind::Err, _) => return Err(LitToConstError::Reported),\n+        (ast::LitKind::Err, _) => {\n+            return Err(LitToConstError::Reported(\n+                tcx.sess.delay_span_bug(DUMMY_SP, \"encountered LitKind::Err during mir build\"),\n+            ));\n+        }\n         _ => return Err(LitToConstError::TypeError),\n     };\n "}, {"sha": "776c748c7e5fe626fc09e999597ed05baa0ee99e", "filename": "compiler/rustc_mir_build/src/thir/pattern/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3c0a023611fcaf5ae3ec242d7d60e356041d25f/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3c0a023611fcaf5ae3ec242d7d60e356041d25f/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs?ref=a3c0a023611fcaf5ae3ec242d7d60e356041d25f", "patch": "@@ -614,7 +614,7 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n             LitToConstInput { lit: &lit.node, ty: self.typeck_results.expr_ty(expr), neg };\n         match self.tcx.at(expr.span).lit_to_mir_constant(lit_input) {\n             Ok(constant) => self.const_to_pat(constant, expr.hir_id, lit.span, false).kind,\n-            Err(LitToConstError::Reported) => PatKind::Wild,\n+            Err(LitToConstError::Reported(_)) => PatKind::Wild,\n             Err(LitToConstError::TypeError) => bug!(\"lower_lit: had type error\"),\n         }\n     }"}, {"sha": "0ea8f2ba93fd8a1c621338441d08255aab439e21", "filename": "compiler/rustc_mir_transform/src/required_consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3c0a023611fcaf5ae3ec242d7d60e356041d25f/compiler%2Frustc_mir_transform%2Fsrc%2Frequired_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3c0a023611fcaf5ae3ec242d7d60e356041d25f/compiler%2Frustc_mir_transform%2Fsrc%2Frequired_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Frequired_consts.rs?ref=a3c0a023611fcaf5ae3ec242d7d60e356041d25f", "patch": "@@ -17,7 +17,7 @@ impl<'tcx> Visitor<'tcx> for RequiredConstsVisitor<'_, 'tcx> {\n         let literal = constant.literal;\n         match literal {\n             ConstantKind::Ty(c) => match c.kind() {\n-                ConstKind::Param(_) => {}\n+                ConstKind::Param(_) | ConstKind::Error(_) => {}\n                 _ => bug!(\"only ConstKind::Param should be encountered here, got {:#?}\", c),\n             },\n             ConstantKind::Unevaluated(..) => self.required_consts.push(*constant),"}, {"sha": "ede67813883d6b2643464e886c8f769156b6c7e8", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a3c0a023611fcaf5ae3ec242d7d60e356041d25f/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3c0a023611fcaf5ae3ec242d7d60e356041d25f/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=a3c0a023611fcaf5ae3ec242d7d60e356041d25f", "patch": "@@ -527,6 +527,7 @@ struct DiagnosticMetadata<'ast> {\n \n     /// Used to detect possible new binding written without `let` and to provide structured suggestion.\n     in_assignment: Option<&'ast Expr>,\n+    is_assign_rhs: bool,\n \n     /// If we are currently in a trait object definition. Used to point at the bounds when\n     /// encountering a struct or enum.\n@@ -3963,10 +3964,15 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                 self.resolve_expr(elem, Some(expr));\n                 self.visit_expr(idx);\n             }\n-            ExprKind::Assign(..) => {\n-                let old = self.diagnostic_metadata.in_assignment.replace(expr);\n-                visit::walk_expr(self, expr);\n-                self.diagnostic_metadata.in_assignment = old;\n+            ExprKind::Assign(ref lhs, ref rhs, _) => {\n+                if !self.diagnostic_metadata.is_assign_rhs {\n+                    self.diagnostic_metadata.in_assignment = Some(expr);\n+                }\n+                self.visit_expr(lhs);\n+                self.diagnostic_metadata.is_assign_rhs = true;\n+                self.diagnostic_metadata.in_assignment = None;\n+                self.visit_expr(rhs);\n+                self.diagnostic_metadata.is_assign_rhs = false;\n             }\n             _ => {\n                 visit::walk_expr(self, expr);"}, {"sha": "2587a9c4b3498aa8085a9c599fe927a939dc8827", "filename": "compiler/rustc_resolve/src/late/diagnostics.rs", "status": "modified", "additions": 7, "deletions": 14, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/a3c0a023611fcaf5ae3ec242d7d60e356041d25f/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3c0a023611fcaf5ae3ec242d7d60e356041d25f/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs?ref=a3c0a023611fcaf5ae3ec242d7d60e356041d25f", "patch": "@@ -1810,29 +1810,22 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n         false\n     }\n \n-    fn let_binding_suggestion(&self, err: &mut Diagnostic, ident_span: Span) -> bool {\n-        // try to give a suggestion for this pattern: `name = 1`, which is common in other languages\n-        let mut added_suggestion = false;\n-        if let Some(Expr { kind: ExprKind::Assign(lhs, _rhs, _), .. }) = self.diagnostic_metadata.in_assignment &&\n+    // try to give a suggestion for this pattern: `name = blah`, which is common in other languages\n+    // suggest `let name = blah` to introduce a new binding\n+    fn let_binding_suggestion(&mut self, err: &mut Diagnostic, ident_span: Span) -> bool {\n+        if let Some(Expr { kind: ExprKind::Assign(lhs, .. ), .. }) = self.diagnostic_metadata.in_assignment &&\n             let ast::ExprKind::Path(None, _) = lhs.kind {\n-                let sm = self.r.session.source_map();\n-                let line_span = sm.span_extend_to_line(ident_span);\n-                let ident_name = sm.span_to_snippet(ident_span).unwrap();\n-                // HACK(chenyukang): make sure ident_name is at the starting of the line to protect against macros\n-                if sm\n-                    .span_to_snippet(line_span)\n-                    .map_or(false, |s| s.trim().starts_with(&ident_name))\n-                {\n+                if !ident_span.from_expansion() {\n                     err.span_suggestion_verbose(\n                         ident_span.shrink_to_lo(),\n                         \"you might have meant to introduce a new binding\",\n                         \"let \".to_string(),\n                         Applicability::MaybeIncorrect,\n                     );\n-                    added_suggestion = true;\n+                    return true;\n                 }\n             }\n-        added_suggestion\n+        false\n     }\n \n     fn find_module(&mut self, def_id: DefId) -> Option<(Module<'a>, ImportSuggestion)> {"}, {"sha": "d29b479de5da6e4497ae96030eb83bb0e0013829", "filename": "compiler/rustc_target/src/abi/call/loongarch.rs", "status": "added", "additions": 342, "deletions": 0, "changes": 342, "blob_url": "https://github.com/rust-lang/rust/blob/a3c0a023611fcaf5ae3ec242d7d60e356041d25f/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Floongarch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3c0a023611fcaf5ae3ec242d7d60e356041d25f/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Floongarch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Floongarch.rs?ref=a3c0a023611fcaf5ae3ec242d7d60e356041d25f", "patch": "@@ -0,0 +1,342 @@\n+use crate::abi::call::{ArgAbi, ArgExtension, CastTarget, FnAbi, PassMode, Reg, RegKind, Uniform};\n+use crate::abi::{self, Abi, FieldsShape, HasDataLayout, Size, TyAbiInterface, TyAndLayout};\n+use crate::spec::HasTargetSpec;\n+\n+#[derive(Copy, Clone)]\n+enum RegPassKind {\n+    Float(Reg),\n+    Integer(Reg),\n+    Unknown,\n+}\n+\n+#[derive(Copy, Clone)]\n+enum FloatConv {\n+    FloatPair(Reg, Reg),\n+    Float(Reg),\n+    MixedPair(Reg, Reg),\n+}\n+\n+#[derive(Copy, Clone)]\n+struct CannotUseFpConv;\n+\n+fn is_loongarch_aggregate<'a, Ty>(arg: &ArgAbi<'a, Ty>) -> bool {\n+    match arg.layout.abi {\n+        Abi::Vector { .. } => true,\n+        _ => arg.layout.is_aggregate(),\n+    }\n+}\n+\n+fn should_use_fp_conv_helper<'a, Ty, C>(\n+    cx: &C,\n+    arg_layout: &TyAndLayout<'a, Ty>,\n+    xlen: u64,\n+    flen: u64,\n+    field1_kind: &mut RegPassKind,\n+    field2_kind: &mut RegPassKind,\n+) -> Result<(), CannotUseFpConv>\n+where\n+    Ty: TyAbiInterface<'a, C> + Copy,\n+{\n+    match arg_layout.abi {\n+        Abi::Scalar(scalar) => match scalar.primitive() {\n+            abi::Int(..) | abi::Pointer => {\n+                if arg_layout.size.bits() > xlen {\n+                    return Err(CannotUseFpConv);\n+                }\n+                match (*field1_kind, *field2_kind) {\n+                    (RegPassKind::Unknown, _) => {\n+                        *field1_kind = RegPassKind::Integer(Reg {\n+                            kind: RegKind::Integer,\n+                            size: arg_layout.size,\n+                        });\n+                    }\n+                    (RegPassKind::Float(_), RegPassKind::Unknown) => {\n+                        *field2_kind = RegPassKind::Integer(Reg {\n+                            kind: RegKind::Integer,\n+                            size: arg_layout.size,\n+                        });\n+                    }\n+                    _ => return Err(CannotUseFpConv),\n+                }\n+            }\n+            abi::F32 | abi::F64 => {\n+                if arg_layout.size.bits() > flen {\n+                    return Err(CannotUseFpConv);\n+                }\n+                match (*field1_kind, *field2_kind) {\n+                    (RegPassKind::Unknown, _) => {\n+                        *field1_kind =\n+                            RegPassKind::Float(Reg { kind: RegKind::Float, size: arg_layout.size });\n+                    }\n+                    (_, RegPassKind::Unknown) => {\n+                        *field2_kind =\n+                            RegPassKind::Float(Reg { kind: RegKind::Float, size: arg_layout.size });\n+                    }\n+                    _ => return Err(CannotUseFpConv),\n+                }\n+            }\n+        },\n+        Abi::Vector { .. } | Abi::Uninhabited => return Err(CannotUseFpConv),\n+        Abi::ScalarPair(..) | Abi::Aggregate { .. } => match arg_layout.fields {\n+            FieldsShape::Primitive => {\n+                unreachable!(\"aggregates can't have `FieldsShape::Primitive`\")\n+            }\n+            FieldsShape::Union(_) => {\n+                if !arg_layout.is_zst() {\n+                    return Err(CannotUseFpConv);\n+                }\n+            }\n+            FieldsShape::Array { count, .. } => {\n+                for _ in 0..count {\n+                    let elem_layout = arg_layout.field(cx, 0);\n+                    should_use_fp_conv_helper(\n+                        cx,\n+                        &elem_layout,\n+                        xlen,\n+                        flen,\n+                        field1_kind,\n+                        field2_kind,\n+                    )?;\n+                }\n+            }\n+            FieldsShape::Arbitrary { .. } => {\n+                match arg_layout.variants {\n+                    abi::Variants::Multiple { .. } => return Err(CannotUseFpConv),\n+                    abi::Variants::Single { .. } => (),\n+                }\n+                for i in arg_layout.fields.index_by_increasing_offset() {\n+                    let field = arg_layout.field(cx, i);\n+                    should_use_fp_conv_helper(cx, &field, xlen, flen, field1_kind, field2_kind)?;\n+                }\n+            }\n+        },\n+    }\n+    Ok(())\n+}\n+\n+fn should_use_fp_conv<'a, Ty, C>(\n+    cx: &C,\n+    arg: &TyAndLayout<'a, Ty>,\n+    xlen: u64,\n+    flen: u64,\n+) -> Option<FloatConv>\n+where\n+    Ty: TyAbiInterface<'a, C> + Copy,\n+{\n+    let mut field1_kind = RegPassKind::Unknown;\n+    let mut field2_kind = RegPassKind::Unknown;\n+    if should_use_fp_conv_helper(cx, arg, xlen, flen, &mut field1_kind, &mut field2_kind).is_err() {\n+        return None;\n+    }\n+    match (field1_kind, field2_kind) {\n+        (RegPassKind::Integer(l), RegPassKind::Float(r)) => Some(FloatConv::MixedPair(l, r)),\n+        (RegPassKind::Float(l), RegPassKind::Integer(r)) => Some(FloatConv::MixedPair(l, r)),\n+        (RegPassKind::Float(l), RegPassKind::Float(r)) => Some(FloatConv::FloatPair(l, r)),\n+        (RegPassKind::Float(f), RegPassKind::Unknown) => Some(FloatConv::Float(f)),\n+        _ => None,\n+    }\n+}\n+\n+fn classify_ret<'a, Ty, C>(cx: &C, arg: &mut ArgAbi<'a, Ty>, xlen: u64, flen: u64) -> bool\n+where\n+    Ty: TyAbiInterface<'a, C> + Copy,\n+{\n+    if let Some(conv) = should_use_fp_conv(cx, &arg.layout, xlen, flen) {\n+        match conv {\n+            FloatConv::Float(f) => {\n+                arg.cast_to(f);\n+            }\n+            FloatConv::FloatPair(l, r) => {\n+                arg.cast_to(CastTarget::pair(l, r));\n+            }\n+            FloatConv::MixedPair(l, r) => {\n+                arg.cast_to(CastTarget::pair(l, r));\n+            }\n+        }\n+        return false;\n+    }\n+\n+    let total = arg.layout.size;\n+\n+    // \"Scalars wider than 2\u2715XLEN are passed by reference and are replaced in\n+    // the argument list with the address.\"\n+    // \"Aggregates larger than 2\u2715XLEN bits are passed by reference and are\n+    // replaced in the argument list with the address, as are C++ aggregates\n+    // with nontrivial copy constructors, destructors, or vtables.\"\n+    if total.bits() > 2 * xlen {\n+        // We rely on the LLVM backend lowering code to lower passing a scalar larger than 2*XLEN.\n+        if is_loongarch_aggregate(arg) {\n+            arg.make_indirect();\n+        }\n+        return true;\n+    }\n+\n+    let xlen_reg = match xlen {\n+        32 => Reg::i32(),\n+        64 => Reg::i64(),\n+        _ => unreachable!(\"Unsupported XLEN: {}\", xlen),\n+    };\n+    if is_loongarch_aggregate(arg) {\n+        if total.bits() <= xlen {\n+            arg.cast_to(xlen_reg);\n+        } else {\n+            arg.cast_to(Uniform { unit: xlen_reg, total: Size::from_bits(xlen * 2) });\n+        }\n+        return false;\n+    }\n+\n+    // \"When passed in registers, scalars narrower than XLEN bits are widened\n+    // according to the sign of their type up to 32 bits, then sign-extended to\n+    // XLEN bits.\"\n+    extend_integer_width(arg, xlen);\n+    false\n+}\n+\n+fn classify_arg<'a, Ty, C>(\n+    cx: &C,\n+    arg: &mut ArgAbi<'a, Ty>,\n+    xlen: u64,\n+    flen: u64,\n+    is_vararg: bool,\n+    avail_gprs: &mut u64,\n+    avail_fprs: &mut u64,\n+) where\n+    Ty: TyAbiInterface<'a, C> + Copy,\n+{\n+    if !is_vararg {\n+        match should_use_fp_conv(cx, &arg.layout, xlen, flen) {\n+            Some(FloatConv::Float(f)) if *avail_fprs >= 1 => {\n+                *avail_fprs -= 1;\n+                arg.cast_to(f);\n+                return;\n+            }\n+            Some(FloatConv::FloatPair(l, r)) if *avail_fprs >= 2 => {\n+                *avail_fprs -= 2;\n+                arg.cast_to(CastTarget::pair(l, r));\n+                return;\n+            }\n+            Some(FloatConv::MixedPair(l, r)) if *avail_fprs >= 1 && *avail_gprs >= 1 => {\n+                *avail_gprs -= 1;\n+                *avail_fprs -= 1;\n+                arg.cast_to(CastTarget::pair(l, r));\n+                return;\n+            }\n+            _ => (),\n+        }\n+    }\n+\n+    let total = arg.layout.size;\n+    let align = arg.layout.align.abi.bits();\n+\n+    // \"Scalars wider than 2\u2715XLEN are passed by reference and are replaced in\n+    // the argument list with the address.\"\n+    // \"Aggregates larger than 2\u2715XLEN bits are passed by reference and are\n+    // replaced in the argument list with the address, as are C++ aggregates\n+    // with nontrivial copy constructors, destructors, or vtables.\"\n+    if total.bits() > 2 * xlen {\n+        // We rely on the LLVM backend lowering code to lower passing a scalar larger than 2*XLEN.\n+        if is_loongarch_aggregate(arg) {\n+            arg.make_indirect();\n+        }\n+        if *avail_gprs >= 1 {\n+            *avail_gprs -= 1;\n+        }\n+        return;\n+    }\n+\n+    let double_xlen_reg = match xlen {\n+        32 => Reg::i64(),\n+        64 => Reg::i128(),\n+        _ => unreachable!(\"Unsupported XLEN: {}\", xlen),\n+    };\n+\n+    let xlen_reg = match xlen {\n+        32 => Reg::i32(),\n+        64 => Reg::i64(),\n+        _ => unreachable!(\"Unsupported XLEN: {}\", xlen),\n+    };\n+\n+    if total.bits() > xlen {\n+        let align_regs = align > xlen;\n+        if is_loongarch_aggregate(arg) {\n+            arg.cast_to(Uniform {\n+                unit: if align_regs { double_xlen_reg } else { xlen_reg },\n+                total: Size::from_bits(xlen * 2),\n+            });\n+        }\n+        if align_regs && is_vararg {\n+            *avail_gprs -= *avail_gprs % 2;\n+        }\n+        if *avail_gprs >= 2 {\n+            *avail_gprs -= 2;\n+        } else {\n+            *avail_gprs = 0;\n+        }\n+        return;\n+    } else if is_loongarch_aggregate(arg) {\n+        arg.cast_to(xlen_reg);\n+        if *avail_gprs >= 1 {\n+            *avail_gprs -= 1;\n+        }\n+        return;\n+    }\n+\n+    // \"When passed in registers, scalars narrower than XLEN bits are widened\n+    // according to the sign of their type up to 32 bits, then sign-extended to\n+    // XLEN bits.\"\n+    if *avail_gprs >= 1 {\n+        extend_integer_width(arg, xlen);\n+        *avail_gprs -= 1;\n+    }\n+}\n+\n+fn extend_integer_width<'a, Ty>(arg: &mut ArgAbi<'a, Ty>, xlen: u64) {\n+    if let Abi::Scalar(scalar) = arg.layout.abi {\n+        if let abi::Int(i, _) = scalar.primitive() {\n+            // 32-bit integers are always sign-extended\n+            if i.size().bits() == 32 && xlen > 32 {\n+                if let PassMode::Direct(ref mut attrs) = arg.mode {\n+                    attrs.ext(ArgExtension::Sext);\n+                    return;\n+                }\n+            }\n+        }\n+    }\n+\n+    arg.extend_integer_width_to(xlen);\n+}\n+\n+pub fn compute_abi_info<'a, Ty, C>(cx: &C, fn_abi: &mut FnAbi<'a, Ty>)\n+where\n+    Ty: TyAbiInterface<'a, C> + Copy,\n+    C: HasDataLayout + HasTargetSpec,\n+{\n+    let xlen = cx.data_layout().pointer_size.bits();\n+    let flen = match &cx.target_spec().llvm_abiname[..] {\n+        \"ilp32f\" | \"lp64f\" => 32,\n+        \"ilp32d\" | \"lp64d\" => 64,\n+        _ => 0,\n+    };\n+\n+    let mut avail_gprs = 8;\n+    let mut avail_fprs = 8;\n+\n+    if !fn_abi.ret.is_ignore() && classify_ret(cx, &mut fn_abi.ret, xlen, flen) {\n+        avail_gprs -= 1;\n+    }\n+\n+    for (i, arg) in fn_abi.args.iter_mut().enumerate() {\n+        if arg.is_ignore() {\n+            continue;\n+        }\n+        classify_arg(\n+            cx,\n+            arg,\n+            xlen,\n+            flen,\n+            i >= fn_abi.fixed_count as usize,\n+            &mut avail_gprs,\n+            &mut avail_fprs,\n+        );\n+    }\n+}"}, {"sha": "c5a6f9893b6f9ec49a0a49123a2ae974bf3228d2", "filename": "compiler/rustc_target/src/abi/call/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3c0a023611fcaf5ae3ec242d7d60e356041d25f/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3c0a023611fcaf5ae3ec242d7d60e356041d25f/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmod.rs?ref=a3c0a023611fcaf5ae3ec242d7d60e356041d25f", "patch": "@@ -10,6 +10,7 @@ mod arm;\n mod avr;\n mod bpf;\n mod hexagon;\n+mod loongarch;\n mod m68k;\n mod mips;\n mod mips64;\n@@ -696,6 +697,7 @@ impl<'a, Ty> FnAbi<'a, Ty> {\n             \"amdgpu\" => amdgpu::compute_abi_info(cx, self),\n             \"arm\" => arm::compute_abi_info(cx, self),\n             \"avr\" => avr::compute_abi_info(self),\n+            \"loongarch64\" => loongarch::compute_abi_info(cx, self),\n             \"m68k\" => m68k::compute_abi_info(self),\n             \"mips\" => mips::compute_abi_info(cx, self),\n             \"mips64\" => mips64::compute_abi_info(cx, self),"}, {"sha": "77d9a0920036a7cc8bf05a5d47386a6dea56cf64", "filename": "compiler/rustc_target/src/spec/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a3c0a023611fcaf5ae3ec242d7d60e356041d25f/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3c0a023611fcaf5ae3ec242d7d60e356041d25f/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs?ref=a3c0a023611fcaf5ae3ec242d7d60e356041d25f", "patch": "@@ -1911,6 +1911,7 @@ impl Target {\n                 Abi::Stdcall { unwind }\n             }\n             Abi::System { unwind } => Abi::C { unwind },\n+            Abi::EfiApi if self.arch == \"arm\" => Abi::Aapcs { unwind: false },\n             Abi::EfiApi if self.arch == \"x86_64\" => Abi::Win64 { unwind: false },\n             Abi::EfiApi => Abi::C { unwind: false },\n "}, {"sha": "54c738d8389759859103ae149b82fe915934ca59", "filename": "compiler/rustc_trait_selection/src/autoderef.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3c0a023611fcaf5ae3ec242d7d60e356041d25f/compiler%2Frustc_trait_selection%2Fsrc%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3c0a023611fcaf5ae3ec242d7d60e356041d25f/compiler%2Frustc_trait_selection%2Fsrc%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fautoderef.rs?ref=a3c0a023611fcaf5ae3ec242d7d60e356041d25f", "patch": "@@ -1,6 +1,6 @@\n use crate::errors::AutoDerefReachedRecursionLimit;\n use crate::traits::query::evaluate_obligation::InferCtxtExt;\n-use crate::traits::{self, TraitEngine};\n+use crate::traits::{self, TraitEngine, TraitEngineExt};\n use rustc_hir as hir;\n use rustc_infer::infer::InferCtxt;\n use rustc_middle::ty::{self, TraitRef, Ty, TyCtxt};\n@@ -139,7 +139,7 @@ impl<'a, 'tcx> Autoderef<'a, 'tcx> {\n             return None;\n         }\n \n-        let mut fulfillcx = traits::FulfillmentContext::new_in_snapshot();\n+        let mut fulfillcx = <dyn TraitEngine<'tcx>>::new_in_snapshot(tcx);\n         let normalized_ty = fulfillcx.normalize_projection_type(\n             &self.infcx,\n             self.param_env,"}, {"sha": "8f9d5eaac9d1d5ac9e35adb52ef62d7d9dfcc6b3", "filename": "compiler/rustc_trait_selection/src/traits/chalk_fulfill.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3c0a023611fcaf5ae3ec242d7d60e356041d25f/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fchalk_fulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3c0a023611fcaf5ae3ec242d7d60e356041d25f/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fchalk_fulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fchalk_fulfill.rs?ref=a3c0a023611fcaf5ae3ec242d7d60e356041d25f", "patch": "@@ -19,7 +19,7 @@ pub struct FulfillmentContext<'tcx> {\n }\n \n impl FulfillmentContext<'_> {\n-    pub(crate) fn new() -> Self {\n+    pub(super) fn new() -> Self {\n         FulfillmentContext {\n             obligations: FxIndexSet::default(),\n             relationships: FxHashMap::default(),"}, {"sha": "98c13ffdafb029f12aa273587a287cc7f9c8977d", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a3c0a023611fcaf5ae3ec242d7d60e356041d25f/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3c0a023611fcaf5ae3ec242d7d60e356041d25f/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=a3c0a023611fcaf5ae3ec242d7d60e356041d25f", "patch": "@@ -3,13 +3,14 @@ pub mod on_unimplemented;\n pub mod suggestions;\n \n use super::{\n-    FulfillmentContext, FulfillmentError, FulfillmentErrorCode, MismatchedProjectionTypes,\n-    Obligation, ObligationCause, ObligationCauseCode, OutputTypeParameterMismatch, Overflow,\n-    PredicateObligation, SelectionContext, SelectionError, TraitNotObjectSafe,\n+    FulfillmentError, FulfillmentErrorCode, MismatchedProjectionTypes, Obligation, ObligationCause,\n+    ObligationCauseCode, OutputTypeParameterMismatch, Overflow, PredicateObligation,\n+    SelectionContext, SelectionError, TraitNotObjectSafe,\n };\n use crate::infer::error_reporting::{TyCategory, TypeAnnotationNeeded as ErrorCode};\n use crate::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use crate::infer::{self, InferCtxt, TyCtxtInferExt};\n+use crate::traits::engine::TraitEngineExt as _;\n use crate::traits::query::evaluate_obligation::InferCtxtExt as _;\n use crate::traits::query::normalize::AtExt as _;\n use crate::traits::specialize::to_pretty_impl_header;\n@@ -352,7 +353,7 @@ impl<'tcx> InferCtxtExt<'tcx> for InferCtxt<'tcx> {\n                     })\n                     .to_predicate(self.tcx),\n                 );\n-                let mut fulfill_cx = FulfillmentContext::new_in_snapshot();\n+                let mut fulfill_cx = <dyn TraitEngine<'tcx>>::new_in_snapshot(self.tcx);\n                 fulfill_cx.register_predicate_obligation(self, obligation);\n                 if fulfill_cx.select_all_or_error(self).is_empty() {\n                     return Ok(("}, {"sha": "b486c07f354b93bbf26f57cf3e1f8ace88d89286", "filename": "compiler/rustc_trait_selection/src/traits/fulfill.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3c0a023611fcaf5ae3ec242d7d60e356041d25f/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3c0a023611fcaf5ae3ec242d7d60e356041d25f/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs?ref=a3c0a023611fcaf5ae3ec242d7d60e356041d25f", "patch": "@@ -85,15 +85,15 @@ static_assert_size!(PendingPredicateObligation<'_>, 72);\n \n impl<'a, 'tcx> FulfillmentContext<'tcx> {\n     /// Creates a new fulfillment context.\n-    pub fn new() -> FulfillmentContext<'tcx> {\n+    pub(super) fn new() -> FulfillmentContext<'tcx> {\n         FulfillmentContext {\n             predicates: ObligationForest::new(),\n             relationships: FxHashMap::default(),\n             usable_in_snapshot: false,\n         }\n     }\n \n-    pub fn new_in_snapshot() -> FulfillmentContext<'tcx> {\n+    pub(super) fn new_in_snapshot() -> FulfillmentContext<'tcx> {\n         FulfillmentContext {\n             predicates: ObligationForest::new(),\n             relationships: FxHashMap::default(),"}, {"sha": "cb41c4f94e2e69b803caaba802a51c7fc06f2b25", "filename": "compiler/rustc_ty_utils/src/consts.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3c0a023611fcaf5ae3ec242d7d60e356041d25f/compiler%2Frustc_ty_utils%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3c0a023611fcaf5ae3ec242d7d60e356041d25f/compiler%2Frustc_ty_utils%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fconsts.rs?ref=a3c0a023611fcaf5ae3ec242d7d60e356041d25f", "patch": "@@ -235,7 +235,9 @@ impl<'a, 'tcx> AbstractConstBuilder<'a, 'tcx> {\n                     neg,\n                 }) {\n                     Ok(c) => c,\n-                    Err(LitToConstError::Reported) => self.tcx.const_error(node.ty),\n+                    Err(LitToConstError::Reported(guar)) => {\n+                        self.tcx.const_error_with_guaranteed(node.ty, guar)\n+                    }\n                     Err(LitToConstError::TypeError) => {\n                         bug!(\"encountered type error in lit_to_const\")\n                     }"}, {"sha": "c755afa39eb608de9ffffd576b0b4d5fa443b0f5", "filename": "library/core/src/hash/mod.rs", "status": "modified", "additions": 56, "deletions": 27, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/a3c0a023611fcaf5ae3ec242d7d60e356041d25f/library%2Fcore%2Fsrc%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3c0a023611fcaf5ae3ec242d7d60e356041d25f/library%2Fcore%2Fsrc%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fhash%2Fmod.rs?ref=a3c0a023611fcaf5ae3ec242d7d60e356041d25f", "patch": "@@ -86,7 +86,8 @@\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use crate::fmt;\n-use crate::marker;\n+use crate::intrinsics::const_eval_select;\n+use crate::marker::{self, Destruct};\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[allow(deprecated)]\n@@ -183,6 +184,7 @@ mod sip;\n /// [impl]: ../../std/primitive.str.html#impl-Hash-for-str\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_diagnostic_item = \"Hash\"]\n+#[const_trait]\n pub trait Hash {\n     /// Feeds this value into the given [`Hasher`].\n     ///\n@@ -234,13 +236,25 @@ pub trait Hash {\n     /// [`hash`]: Hash::hash\n     /// [`hash_slice`]: Hash::hash_slice\n     #[stable(feature = \"hash_slice\", since = \"1.3.0\")]\n-    fn hash_slice<H: Hasher>(data: &[Self], state: &mut H)\n+    fn hash_slice<H: ~const Hasher>(data: &[Self], state: &mut H)\n     where\n         Self: Sized,\n     {\n-        for piece in data {\n-            piece.hash(state);\n+        //FIXME(const_trait_impl): revert to only a for loop\n+        fn rt<T: Hash, H: Hasher>(data: &[T], state: &mut H) {\n+            for piece in data {\n+                piece.hash(state)\n+            }\n+        }\n+        const fn ct<T: ~const Hash, H: ~const Hasher>(data: &[T], state: &mut H) {\n+            let mut i = 0;\n+            while i < data.len() {\n+                data[i].hash(state);\n+                i += 1;\n+            }\n         }\n+        // SAFETY: same behavior, CT just uses while instead of for\n+        unsafe { const_eval_select((data, state), ct, rt) };\n     }\n }\n \n@@ -313,6 +327,7 @@ pub use macros::Hash;\n /// [`write_u8`]: Hasher::write_u8\n /// [`write_u32`]: Hasher::write_u32\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[const_trait]\n pub trait Hasher {\n     /// Returns the hash value for the values written so far.\n     ///\n@@ -558,7 +573,8 @@ pub trait Hasher {\n }\n \n #[stable(feature = \"indirect_hasher_impl\", since = \"1.22.0\")]\n-impl<H: Hasher + ?Sized> Hasher for &mut H {\n+#[rustc_const_unstable(feature = \"const_hash\", issue = \"104061\")]\n+impl<H: ~const Hasher + ?Sized> const Hasher for &mut H {\n     fn finish(&self) -> u64 {\n         (**self).finish()\n     }\n@@ -638,6 +654,7 @@ impl<H: Hasher + ?Sized> Hasher for &mut H {\n /// [`build_hasher`]: BuildHasher::build_hasher\n /// [`HashMap`]: ../../std/collections/struct.HashMap.html\n #[stable(since = \"1.7.0\", feature = \"build_hasher\")]\n+#[const_trait]\n pub trait BuildHasher {\n     /// Type of the hasher that will be created.\n     #[stable(since = \"1.7.0\", feature = \"build_hasher\")]\n@@ -698,9 +715,10 @@ pub trait BuildHasher {\n     /// );\n     /// ```\n     #[unstable(feature = \"build_hasher_simple_hash_one\", issue = \"86161\")]\n-    fn hash_one<T: Hash>(&self, x: T) -> u64\n+    fn hash_one<T: ~const Hash + ~const Destruct>(&self, x: T) -> u64\n     where\n         Self: Sized,\n+        Self::Hasher: ~const Hasher + ~const Destruct,\n     {\n         let mut hasher = self.build_hasher();\n         x.hash(&mut hasher);\n@@ -764,7 +782,8 @@ impl<H> fmt::Debug for BuildHasherDefault<H> {\n }\n \n #[stable(since = \"1.7.0\", feature = \"build_hasher\")]\n-impl<H: Default + Hasher> BuildHasher for BuildHasherDefault<H> {\n+#[rustc_const_unstable(feature = \"const_hash\", issue = \"104061\")]\n+impl<H: ~const Default + Hasher> const BuildHasher for BuildHasherDefault<H> {\n     type Hasher = H;\n \n     fn build_hasher(&self) -> H {\n@@ -806,14 +825,15 @@ mod impls {\n     macro_rules! impl_write {\n         ($(($ty:ident, $meth:ident),)*) => {$(\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            impl Hash for $ty {\n+            #[rustc_const_unstable(feature = \"const_hash\", issue = \"104061\")]\n+            impl const Hash for $ty {\n                 #[inline]\n-                fn hash<H: Hasher>(&self, state: &mut H) {\n+                fn hash<H: ~const Hasher>(&self, state: &mut H) {\n                     state.$meth(*self)\n                 }\n \n                 #[inline]\n-                fn hash_slice<H: Hasher>(data: &[$ty], state: &mut H) {\n+                fn hash_slice<H: ~const Hasher>(data: &[$ty], state: &mut H) {\n                     let newlen = data.len() * mem::size_of::<$ty>();\n                     let ptr = data.as_ptr() as *const u8;\n                     // SAFETY: `ptr` is valid and aligned, as this macro is only used\n@@ -842,54 +862,60 @@ mod impls {\n     }\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl Hash for bool {\n+    #[rustc_const_unstable(feature = \"const_hash\", issue = \"104061\")]\n+    impl const Hash for bool {\n         #[inline]\n-        fn hash<H: Hasher>(&self, state: &mut H) {\n+        fn hash<H: ~const Hasher>(&self, state: &mut H) {\n             state.write_u8(*self as u8)\n         }\n     }\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl Hash for char {\n+    #[rustc_const_unstable(feature = \"const_hash\", issue = \"104061\")]\n+    impl const Hash for char {\n         #[inline]\n-        fn hash<H: Hasher>(&self, state: &mut H) {\n+        fn hash<H: ~const Hasher>(&self, state: &mut H) {\n             state.write_u32(*self as u32)\n         }\n     }\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl Hash for str {\n+    #[rustc_const_unstable(feature = \"const_hash\", issue = \"104061\")]\n+    impl const Hash for str {\n         #[inline]\n-        fn hash<H: Hasher>(&self, state: &mut H) {\n+        fn hash<H: ~const Hasher>(&self, state: &mut H) {\n             state.write_str(self);\n         }\n     }\n \n     #[stable(feature = \"never_hash\", since = \"1.29.0\")]\n-    impl Hash for ! {\n+    #[rustc_const_unstable(feature = \"const_hash\", issue = \"104061\")]\n+    impl const Hash for ! {\n         #[inline]\n-        fn hash<H: Hasher>(&self, _: &mut H) {\n+        fn hash<H: ~const Hasher>(&self, _: &mut H) {\n             *self\n         }\n     }\n \n     macro_rules! impl_hash_tuple {\n         () => (\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            impl Hash for () {\n+            #[rustc_const_unstable(feature = \"const_hash\", issue = \"104061\")]\n+            impl const Hash for () {\n                 #[inline]\n-                fn hash<H: Hasher>(&self, _state: &mut H) {}\n+                fn hash<H: ~const Hasher>(&self, _state: &mut H) {}\n             }\n         );\n \n         ( $($name:ident)+) => (\n             maybe_tuple_doc! {\n                 $($name)+ @\n                 #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-                impl<$($name: Hash),+> Hash for ($($name,)+) where last_type!($($name,)+): ?Sized {\n+                #[rustc_const_unstable(feature = \"const_hash\", issue = \"104061\")]\n+                impl<$($name: ~const Hash),+> const Hash for ($($name,)+) where last_type!($($name,)+): ?Sized {\n                     #[allow(non_snake_case)]\n                     #[inline]\n-                    fn hash<S: Hasher>(&self, state: &mut S) {\n+                    fn hash<S: ~const Hasher>(&self, state: &mut S) {\n                         let ($(ref $name,)+) = *self;\n                         $($name.hash(state);)+\n                     }\n@@ -932,24 +958,27 @@ mod impls {\n     impl_hash_tuple! { T B C D E F G H I J K L }\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl<T: Hash> Hash for [T] {\n+    #[rustc_const_unstable(feature = \"const_hash\", issue = \"104061\")]\n+    impl<T: ~const Hash> const Hash for [T] {\n         #[inline]\n-        fn hash<H: Hasher>(&self, state: &mut H) {\n+        fn hash<H: ~const Hasher>(&self, state: &mut H) {\n             state.write_length_prefix(self.len());\n             Hash::hash_slice(self, state)\n         }\n     }\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl<T: ?Sized + Hash> Hash for &T {\n+    #[rustc_const_unstable(feature = \"const_hash\", issue = \"104061\")]\n+    impl<T: ?Sized + ~const Hash> const Hash for &T {\n         #[inline]\n-        fn hash<H: Hasher>(&self, state: &mut H) {\n+        fn hash<H: ~const Hasher>(&self, state: &mut H) {\n             (**self).hash(state);\n         }\n     }\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl<T: ?Sized + Hash> Hash for &mut T {\n+    #[rustc_const_unstable(feature = \"const_hash\", issue = \"104061\")]\n+    impl<T: ?Sized + ~const Hash> const Hash for &mut T {\n         #[inline]\n         fn hash<H: Hasher>(&self, state: &mut H) {\n             (**self).hash(state);"}, {"sha": "7f8287bf56f645d40d4a3f4658641539d55bb765", "filename": "library/core/src/hash/sip.rs", "status": "modified", "additions": 22, "deletions": 14, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/a3c0a023611fcaf5ae3ec242d7d60e356041d25f/library%2Fcore%2Fsrc%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3c0a023611fcaf5ae3ec242d7d60e356041d25f/library%2Fcore%2Fsrc%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fhash%2Fsip.rs?ref=a3c0a023611fcaf5ae3ec242d7d60e356041d25f", "patch": "@@ -118,7 +118,7 @@ macro_rules! load_int_le {\n /// Safety: this performs unchecked indexing of `buf` at `start..start+len`, so\n /// that must be in-bounds.\n #[inline]\n-unsafe fn u8to64_le(buf: &[u8], start: usize, len: usize) -> u64 {\n+const unsafe fn u8to64_le(buf: &[u8], start: usize, len: usize) -> u64 {\n     debug_assert!(len < 8);\n     let mut i = 0; // current byte index (from LSB) in the output u64\n     let mut out = 0;\n@@ -138,7 +138,8 @@ unsafe fn u8to64_le(buf: &[u8], start: usize, len: usize) -> u64 {\n         out |= (unsafe { *buf.get_unchecked(start + i) } as u64) << (i * 8);\n         i += 1;\n     }\n-    debug_assert_eq!(i, len);\n+    //FIXME(fee1-dead): use debug_assert_eq\n+    debug_assert!(i == len);\n     out\n }\n \n@@ -150,8 +151,9 @@ impl SipHasher {\n         since = \"1.13.0\",\n         note = \"use `std::collections::hash_map::DefaultHasher` instead\"\n     )]\n+    #[rustc_const_unstable(feature = \"const_hash\", issue = \"104061\")]\n     #[must_use]\n-    pub fn new() -> SipHasher {\n+    pub const fn new() -> SipHasher {\n         SipHasher::new_with_keys(0, 0)\n     }\n \n@@ -162,8 +164,9 @@ impl SipHasher {\n         since = \"1.13.0\",\n         note = \"use `std::collections::hash_map::DefaultHasher` instead\"\n     )]\n+    #[rustc_const_unstable(feature = \"const_hash\", issue = \"104061\")]\n     #[must_use]\n-    pub fn new_with_keys(key0: u64, key1: u64) -> SipHasher {\n+    pub const fn new_with_keys(key0: u64, key1: u64) -> SipHasher {\n         SipHasher(SipHasher24 { hasher: Hasher::new_with_keys(key0, key1) })\n     }\n }\n@@ -176,7 +179,8 @@ impl SipHasher13 {\n         since = \"1.13.0\",\n         note = \"use `std::collections::hash_map::DefaultHasher` instead\"\n     )]\n-    pub fn new() -> SipHasher13 {\n+    #[rustc_const_unstable(feature = \"const_hash\", issue = \"104061\")]\n+    pub const fn new() -> SipHasher13 {\n         SipHasher13::new_with_keys(0, 0)\n     }\n \n@@ -187,14 +191,15 @@ impl SipHasher13 {\n         since = \"1.13.0\",\n         note = \"use `std::collections::hash_map::DefaultHasher` instead\"\n     )]\n-    pub fn new_with_keys(key0: u64, key1: u64) -> SipHasher13 {\n+    #[rustc_const_unstable(feature = \"const_hash\", issue = \"104061\")]\n+    pub const fn new_with_keys(key0: u64, key1: u64) -> SipHasher13 {\n         SipHasher13 { hasher: Hasher::new_with_keys(key0, key1) }\n     }\n }\n \n impl<S: Sip> Hasher<S> {\n     #[inline]\n-    fn new_with_keys(key0: u64, key1: u64) -> Hasher<S> {\n+    const fn new_with_keys(key0: u64, key1: u64) -> Hasher<S> {\n         let mut state = Hasher {\n             k0: key0,\n             k1: key1,\n@@ -209,7 +214,7 @@ impl<S: Sip> Hasher<S> {\n     }\n \n     #[inline]\n-    fn reset(&mut self) {\n+    const fn reset(&mut self) {\n         self.length = 0;\n         self.state.v0 = self.k0 ^ 0x736f6d6570736575;\n         self.state.v1 = self.k1 ^ 0x646f72616e646f6d;\n@@ -220,7 +225,8 @@ impl<S: Sip> Hasher<S> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl super::Hasher for SipHasher {\n+#[rustc_const_unstable(feature = \"const_hash\", issue = \"104061\")]\n+impl const super::Hasher for SipHasher {\n     #[inline]\n     fn write(&mut self, msg: &[u8]) {\n         self.0.hasher.write(msg)\n@@ -238,7 +244,8 @@ impl super::Hasher for SipHasher {\n }\n \n #[unstable(feature = \"hashmap_internals\", issue = \"none\")]\n-impl super::Hasher for SipHasher13 {\n+#[rustc_const_unstable(feature = \"const_hash\", issue = \"104061\")]\n+impl const super::Hasher for SipHasher13 {\n     #[inline]\n     fn write(&mut self, msg: &[u8]) {\n         self.hasher.write(msg)\n@@ -255,7 +262,7 @@ impl super::Hasher for SipHasher13 {\n     }\n }\n \n-impl<S: Sip> super::Hasher for Hasher<S> {\n+impl<S: ~const Sip> const super::Hasher for Hasher<S> {\n     // Note: no integer hashing methods (`write_u*`, `write_i*`) are defined\n     // for this type. We could add them, copy the `short_write` implementation\n     // in librustc_data_structures/sip128.rs, and add `write_u*`/`write_i*`\n@@ -335,7 +342,7 @@ impl<S: Sip> super::Hasher for Hasher<S> {\n     }\n }\n \n-impl<S: Sip> Clone for Hasher<S> {\n+impl<S: Sip> const Clone for Hasher<S> {\n     #[inline]\n     fn clone(&self) -> Hasher<S> {\n         Hasher {\n@@ -359,6 +366,7 @@ impl<S: Sip> Default for Hasher<S> {\n }\n \n #[doc(hidden)]\n+#[const_trait]\n trait Sip {\n     fn c_rounds(_: &mut State);\n     fn d_rounds(_: &mut State);\n@@ -367,7 +375,7 @@ trait Sip {\n #[derive(Debug, Clone, Default)]\n struct Sip13Rounds;\n \n-impl Sip for Sip13Rounds {\n+impl const Sip for Sip13Rounds {\n     #[inline]\n     fn c_rounds(state: &mut State) {\n         compress!(state);\n@@ -384,7 +392,7 @@ impl Sip for Sip13Rounds {\n #[derive(Debug, Clone, Default)]\n struct Sip24Rounds;\n \n-impl Sip for Sip24Rounds {\n+impl const Sip for Sip24Rounds {\n     #[inline]\n     fn c_rounds(state: &mut State) {\n         compress!(state);"}, {"sha": "5dc7427bee003c5cca37685b594f13babb3cc5de", "filename": "library/core/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a3c0a023611fcaf5ae3ec242d7d60e356041d25f/library%2Fcore%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3c0a023611fcaf5ae3ec242d7d60e356041d25f/library%2Fcore%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Flib.rs?ref=a3c0a023611fcaf5ae3ec242d7d60e356041d25f", "patch": "@@ -112,6 +112,7 @@\n #![feature(const_float_bits_conv)]\n #![feature(const_float_classify)]\n #![feature(const_fmt_arguments_new)]\n+#![feature(const_hash)]\n #![feature(const_heap)]\n #![feature(const_convert)]\n #![feature(const_index_range_slice_index)]"}, {"sha": "267245f05dcd2203eb7c8d6a77d086c2c81f0720", "filename": "library/core/tests/hash/mod.rs", "status": "modified", "additions": 28, "deletions": 10, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/a3c0a023611fcaf5ae3ec242d7d60e356041d25f/library%2Fcore%2Ftests%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3c0a023611fcaf5ae3ec242d7d60e356041d25f/library%2Fcore%2Ftests%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fhash%2Fmod.rs?ref=a3c0a023611fcaf5ae3ec242d7d60e356041d25f", "patch": "@@ -9,16 +9,19 @@ struct MyHasher {\n     hash: u64,\n }\n \n-impl Default for MyHasher {\n+impl const Default for MyHasher {\n     fn default() -> MyHasher {\n         MyHasher { hash: 0 }\n     }\n }\n \n-impl Hasher for MyHasher {\n+impl const Hasher for MyHasher {\n     fn write(&mut self, buf: &[u8]) {\n-        for byte in buf {\n-            self.hash += *byte as u64;\n+        // FIXME(const_trait_impl): change to for loop\n+        let mut i = 0;\n+        while i < buf.len() {\n+            self.hash += buf[i] as u64;\n+            i += 1;\n         }\n     }\n     fn write_str(&mut self, s: &str) {\n@@ -32,12 +35,25 @@ impl Hasher for MyHasher {\n \n #[test]\n fn test_writer_hasher() {\n-    fn hash<T: Hash>(t: &T) -> u64 {\n+    const fn hash<T: ~const Hash>(t: &T) -> u64 {\n         let mut s = MyHasher { hash: 0 };\n         t.hash(&mut s);\n         s.finish()\n     }\n \n+    const {\n+        // FIXME(fee1-dead): assert_eq\n+        assert!(hash(&()) == 0);\n+        assert!(hash(&5_u8) == 5);\n+        assert!(hash(&5_u16) == 5);\n+        assert!(hash(&5_u32) == 5);\n+\n+        assert!(hash(&'a') == 97);\n+\n+        let s: &str = \"a\";\n+        assert!(hash(&s) == 97 + 0xFF);\n+    };\n+\n     assert_eq!(hash(&()), 0);\n \n     assert_eq!(hash(&5_u8), 5);\n@@ -97,7 +113,7 @@ struct CustomHasher {\n     output: u64,\n }\n \n-impl Hasher for CustomHasher {\n+impl const Hasher for CustomHasher {\n     fn finish(&self) -> u64 {\n         self.output\n     }\n@@ -109,27 +125,29 @@ impl Hasher for CustomHasher {\n     }\n }\n \n-impl Default for CustomHasher {\n+impl const Default for CustomHasher {\n     fn default() -> CustomHasher {\n         CustomHasher { output: 0 }\n     }\n }\n \n-impl Hash for Custom {\n-    fn hash<H: Hasher>(&self, state: &mut H) {\n+impl const Hash for Custom {\n+    fn hash<H: ~const Hasher>(&self, state: &mut H) {\n         state.write_u64(self.hash);\n     }\n }\n \n #[test]\n fn test_custom_state() {\n-    fn hash<T: Hash>(t: &T) -> u64 {\n+    const fn hash<T: ~const Hash>(t: &T) -> u64 {\n         let mut c = CustomHasher { output: 0 };\n         t.hash(&mut c);\n         c.finish()\n     }\n \n     assert_eq!(hash(&Custom { hash: 5 }), 5);\n+\n+    const { assert!(hash(&Custom { hash: 6 }) == 6) };\n }\n \n // FIXME: Instantiated functions with i128 in the signature is not supported in Emscripten."}, {"sha": "3abf6efcfa9ba842d312f4bc4deb1a29a5b61d9b", "filename": "library/core/tests/hash/sip.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a3c0a023611fcaf5ae3ec242d7d60e356041d25f/library%2Fcore%2Ftests%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3c0a023611fcaf5ae3ec242d7d60e356041d25f/library%2Fcore%2Ftests%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fhash%2Fsip.rs?ref=a3c0a023611fcaf5ae3ec242d7d60e356041d25f", "patch": "@@ -8,7 +8,6 @@ use core::{mem, slice};\n struct Bytes<'a>(&'a [u8]);\n \n impl<'a> Hash for Bytes<'a> {\n-    #[allow(unused_must_use)]\n     fn hash<H: Hasher>(&self, state: &mut H) {\n         let Bytes(v) = *self;\n         state.write(v);\n@@ -24,6 +23,20 @@ fn hash<T: Hash>(x: &T) -> u64 {\n     hash_with(SipHasher::new(), x)\n }\n \n+#[test]\n+const fn test_const_sip() {\n+    let val1 = 0x45;\n+    let val2 = 0xfeed;\n+\n+    const fn const_hash<T: ~const Hash>(x: &T) -> u64 {\n+        let mut st = SipHasher::new();\n+        x.hash(&mut st);\n+        st.finish()\n+    }\n+\n+    assert!(const_hash(&(val1)) != const_hash(&(val2)));\n+}\n+\n #[test]\n #[allow(unused_must_use)]\n fn test_siphash_1_3() {"}, {"sha": "61d31b3448734349b7c5b06ba5bf68de895d18b3", "filename": "library/core/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a3c0a023611fcaf5ae3ec242d7d60e356041d25f/library%2Fcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3c0a023611fcaf5ae3ec242d7d60e356041d25f/library%2Fcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Flib.rs?ref=a3c0a023611fcaf5ae3ec242d7d60e356041d25f", "patch": "@@ -11,6 +11,7 @@\n #![feature(const_caller_location)]\n #![feature(const_cell_into_inner)]\n #![feature(const_convert)]\n+#![feature(const_hash)]\n #![feature(const_heap)]\n #![feature(const_maybe_uninit_as_mut_ptr)]\n #![feature(const_maybe_uninit_assume_init_read)]"}, {"sha": "df490358827e7ae9c8fd777450dc776a19f66b10", "filename": "library/std/src/collections/hash/map.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a3c0a023611fcaf5ae3ec242d7d60e356041d25f/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3c0a023611fcaf5ae3ec242d7d60e356041d25f/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap.rs?ref=a3c0a023611fcaf5ae3ec242d7d60e356041d25f", "patch": "@@ -3161,14 +3161,16 @@ impl DefaultHasher {\n     #[stable(feature = \"hashmap_default_hasher\", since = \"1.13.0\")]\n     #[inline]\n     #[allow(deprecated)]\n+    #[rustc_const_unstable(feature = \"const_hash\", issue = \"104061\")]\n     #[must_use]\n-    pub fn new() -> DefaultHasher {\n+    pub const fn new() -> DefaultHasher {\n         DefaultHasher(SipHasher13::new_with_keys(0, 0))\n     }\n }\n \n #[stable(feature = \"hashmap_default_hasher\", since = \"1.13.0\")]\n-impl Default for DefaultHasher {\n+#[rustc_const_unstable(feature = \"const_hash\", issue = \"104061\")]\n+impl const Default for DefaultHasher {\n     /// Creates a new `DefaultHasher` using [`new`].\n     /// See its documentation for more.\n     ///\n@@ -3180,7 +3182,8 @@ impl Default for DefaultHasher {\n }\n \n #[stable(feature = \"hashmap_default_hasher\", since = \"1.13.0\")]\n-impl Hasher for DefaultHasher {\n+#[rustc_const_unstable(feature = \"const_hash\", issue = \"104061\")]\n+impl const Hasher for DefaultHasher {\n     // The underlying `SipHasher13` doesn't override the other\n     // `write_*` methods, so it's ok not to forward them here.\n "}, {"sha": "9334c833bb6509c82e3fb2a4b3cfb55125740f33", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a3c0a023611fcaf5ae3ec242d7d60e356041d25f/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3c0a023611fcaf5ae3ec242d7d60e356041d25f/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=a3c0a023611fcaf5ae3ec242d7d60e356041d25f", "patch": "@@ -352,6 +352,7 @@\n //\n // Only for const-ness:\n #![feature(const_collections_with_hasher)]\n+#![feature(const_hash)]\n #![feature(const_io_structs)]\n #![feature(const_ip)]\n #![feature(const_ipv4)]"}, {"sha": "9061d7432a3fa862018919df76baa71f36febb2e", "filename": "src/test/codegen/abi-efiapi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3c0a023611fcaf5ae3ec242d7d60e356041d25f/src%2Ftest%2Fcodegen%2Fabi-efiapi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3c0a023611fcaf5ae3ec242d7d60e356041d25f/src%2Ftest%2Fcodegen%2Fabi-efiapi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fabi-efiapi.rs?ref=a3c0a023611fcaf5ae3ec242d7d60e356041d25f", "patch": "@@ -27,7 +27,7 @@ trait Copy { }\n //x86_64: define win64cc void @has_efiapi\n //i686: define void @has_efiapi\n //aarch64: define dso_local void @has_efiapi\n-//arm: define dso_local void @has_efiapi\n+//arm: define dso_local arm_aapcscc void @has_efiapi\n //riscv: define dso_local void @has_efiapi\n #[no_mangle]\n pub extern \"efiapi\" fn has_efiapi() {}"}, {"sha": "422d39742eb552c3be5bb82da23b193fc778a877", "filename": "src/test/ui/chalkify/trait-objects.stderr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3c0a023611fcaf5ae3ec242d7d60e356041d25f/src%2Ftest%2Fui%2Fchalkify%2Ftrait-objects.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a3c0a023611fcaf5ae3ec242d7d60e356041d25f/src%2Ftest%2Fui%2Fchalkify%2Ftrait-objects.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Ftrait-objects.stderr?ref=a3c0a023611fcaf5ae3ec242d7d60e356041d25f", "patch": "@@ -22,6 +22,10 @@ LL |     f(2);\n    |     ^^^^ expected an `Fn<(i32,)>` closure, found `dyn Fn(i32) -> i32`\n    |\n    = help: the trait `Fn<(i32,)>` is not implemented for `dyn Fn(i32) -> i32`\n+help: consider introducing a `where` clause, but there might be an alternative better way to express this requirement\n+   |\n+LL | fn main() where dyn Fn(i32) -> i32: Fn<(i32,)> {\n+   |           ++++++++++++++++++++++++++++++++++++\n \n error: aborting due to 3 previous errors\n "}, {"sha": "f0fa3bb7bd13622ce111a12d1705c851decc96b3", "filename": "src/test/ui/consts/invalid-const-in-body.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a3c0a023611fcaf5ae3ec242d7d60e356041d25f/src%2Ftest%2Fui%2Fconsts%2Finvalid-const-in-body.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3c0a023611fcaf5ae3ec242d7d60e356041d25f/src%2Ftest%2Fui%2Fconsts%2Finvalid-const-in-body.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Finvalid-const-in-body.rs?ref=a3c0a023611fcaf5ae3ec242d7d60e356041d25f", "patch": "@@ -0,0 +1,6 @@\n+fn f() -> impl Sized {\n+    2.0E\n+    //~^ ERROR expected at least one digit in exponent\n+}\n+\n+fn main() {}"}, {"sha": "3be65835946127c2099a751de98ff019510eee43", "filename": "src/test/ui/consts/invalid-const-in-body.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a3c0a023611fcaf5ae3ec242d7d60e356041d25f/src%2Ftest%2Fui%2Fconsts%2Finvalid-const-in-body.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a3c0a023611fcaf5ae3ec242d7d60e356041d25f/src%2Ftest%2Fui%2Fconsts%2Finvalid-const-in-body.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Finvalid-const-in-body.stderr?ref=a3c0a023611fcaf5ae3ec242d7d60e356041d25f", "patch": "@@ -0,0 +1,8 @@\n+error: expected at least one digit in exponent\n+  --> $DIR/invalid-const-in-body.rs:2:5\n+   |\n+LL |     2.0E\n+   |     ^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "d22ad27d0e031f066fca66ea24e63348e92ddfd3", "filename": "src/test/ui/suggestions/issue-104086-suggest-let.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/a3c0a023611fcaf5ae3ec242d7d60e356041d25f/src%2Ftest%2Fui%2Fsuggestions%2Fissue-104086-suggest-let.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3c0a023611fcaf5ae3ec242d7d60e356041d25f/src%2Ftest%2Fui%2Fsuggestions%2Fissue-104086-suggest-let.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fissue-104086-suggest-let.rs?ref=a3c0a023611fcaf5ae3ec242d7d60e356041d25f", "patch": "@@ -0,0 +1,30 @@\n+fn main() {\n+    x = x = x;\n+    //~^ ERROR cannot find value `x` in this scope\n+    //~| ERROR cannot find value `x` in this scope\n+    //~| ERROR cannot find value `x` in this scope\n+\n+    x = y = y = y;\n+    //~^ ERROR cannot find value `y` in this scope\n+    //~| ERROR cannot find value `y` in this scope\n+    //~| ERROR cannot find value `y` in this scope\n+    //~| ERROR cannot find value `x` in this scope\n+\n+    x = y = y;\n+    //~^ ERROR cannot find value `x` in this scope\n+    //~| ERROR cannot find value `y` in this scope\n+    //~| ERROR cannot find value `y` in this scope\n+\n+    x = x = y;\n+    //~^ ERROR cannot find value `x` in this scope\n+    //~| ERROR cannot find value `x` in this scope\n+    //~| ERROR cannot find value `y` in this scope\n+\n+    x = x; // will suggest add `let`\n+    //~^ ERROR cannot find value `x` in this scope\n+    //~| ERROR cannot find value `x` in this scope\n+\n+    x = y // will suggest add `let`\n+    //~^ ERROR cannot find value `x` in this scope\n+    //~| ERROR cannot find value `y` in this scope\n+}"}, {"sha": "fb4ea3121ac677b7a4b6dababc59f7c1952f6ddb", "filename": "src/test/ui/suggestions/issue-104086-suggest-let.stderr", "status": "added", "additions": 135, "deletions": 0, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/a3c0a023611fcaf5ae3ec242d7d60e356041d25f/src%2Ftest%2Fui%2Fsuggestions%2Fissue-104086-suggest-let.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a3c0a023611fcaf5ae3ec242d7d60e356041d25f/src%2Ftest%2Fui%2Fsuggestions%2Fissue-104086-suggest-let.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fissue-104086-suggest-let.stderr?ref=a3c0a023611fcaf5ae3ec242d7d60e356041d25f", "patch": "@@ -0,0 +1,135 @@\n+error[E0425]: cannot find value `x` in this scope\n+  --> $DIR/issue-104086-suggest-let.rs:2:5\n+   |\n+LL |     x = x = x;\n+   |     ^\n+   |\n+help: you might have meant to introduce a new binding\n+   |\n+LL |     let x = x = x;\n+   |     +++\n+\n+error[E0425]: cannot find value `x` in this scope\n+  --> $DIR/issue-104086-suggest-let.rs:2:9\n+   |\n+LL |     x = x = x;\n+   |         ^ not found in this scope\n+\n+error[E0425]: cannot find value `x` in this scope\n+  --> $DIR/issue-104086-suggest-let.rs:2:13\n+   |\n+LL |     x = x = x;\n+   |             ^ not found in this scope\n+\n+error[E0425]: cannot find value `x` in this scope\n+  --> $DIR/issue-104086-suggest-let.rs:7:5\n+   |\n+LL |     x = y = y = y;\n+   |     ^\n+   |\n+help: you might have meant to introduce a new binding\n+   |\n+LL |     let x = y = y = y;\n+   |     +++\n+\n+error[E0425]: cannot find value `y` in this scope\n+  --> $DIR/issue-104086-suggest-let.rs:7:9\n+   |\n+LL |     x = y = y = y;\n+   |         ^ not found in this scope\n+\n+error[E0425]: cannot find value `y` in this scope\n+  --> $DIR/issue-104086-suggest-let.rs:7:13\n+   |\n+LL |     x = y = y = y;\n+   |             ^ not found in this scope\n+\n+error[E0425]: cannot find value `y` in this scope\n+  --> $DIR/issue-104086-suggest-let.rs:7:17\n+   |\n+LL |     x = y = y = y;\n+   |                 ^ not found in this scope\n+\n+error[E0425]: cannot find value `x` in this scope\n+  --> $DIR/issue-104086-suggest-let.rs:13:5\n+   |\n+LL |     x = y = y;\n+   |     ^\n+   |\n+help: you might have meant to introduce a new binding\n+   |\n+LL |     let x = y = y;\n+   |     +++\n+\n+error[E0425]: cannot find value `y` in this scope\n+  --> $DIR/issue-104086-suggest-let.rs:13:9\n+   |\n+LL |     x = y = y;\n+   |         ^ not found in this scope\n+\n+error[E0425]: cannot find value `y` in this scope\n+  --> $DIR/issue-104086-suggest-let.rs:13:13\n+   |\n+LL |     x = y = y;\n+   |             ^ not found in this scope\n+\n+error[E0425]: cannot find value `x` in this scope\n+  --> $DIR/issue-104086-suggest-let.rs:18:5\n+   |\n+LL |     x = x = y;\n+   |     ^\n+   |\n+help: you might have meant to introduce a new binding\n+   |\n+LL |     let x = x = y;\n+   |     +++\n+\n+error[E0425]: cannot find value `x` in this scope\n+  --> $DIR/issue-104086-suggest-let.rs:18:9\n+   |\n+LL |     x = x = y;\n+   |         ^ not found in this scope\n+\n+error[E0425]: cannot find value `y` in this scope\n+  --> $DIR/issue-104086-suggest-let.rs:18:13\n+   |\n+LL |     x = x = y;\n+   |             ^ not found in this scope\n+\n+error[E0425]: cannot find value `x` in this scope\n+  --> $DIR/issue-104086-suggest-let.rs:23:5\n+   |\n+LL |     x = x; // will suggest add `let`\n+   |     ^\n+   |\n+help: you might have meant to introduce a new binding\n+   |\n+LL |     let x = x; // will suggest add `let`\n+   |     +++\n+\n+error[E0425]: cannot find value `x` in this scope\n+  --> $DIR/issue-104086-suggest-let.rs:23:9\n+   |\n+LL |     x = x; // will suggest add `let`\n+   |         ^ not found in this scope\n+\n+error[E0425]: cannot find value `x` in this scope\n+  --> $DIR/issue-104086-suggest-let.rs:27:5\n+   |\n+LL |     x = y // will suggest add `let`\n+   |     ^\n+   |\n+help: you might have meant to introduce a new binding\n+   |\n+LL |     let x = y // will suggest add `let`\n+   |     +++\n+\n+error[E0425]: cannot find value `y` in this scope\n+  --> $DIR/issue-104086-suggest-let.rs:27:9\n+   |\n+LL |     x = y // will suggest add `let`\n+   |         ^ not found in this scope\n+\n+error: aborting due to 17 previous errors\n+\n+For more information about this error, try `rustc --explain E0425`."}, {"sha": "2a1823b15f589d61e913ac8394eff1487691bf24", "filename": "src/test/ui/suggestions/option-to-bool.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a3c0a023611fcaf5ae3ec242d7d60e356041d25f/src%2Ftest%2Fui%2Fsuggestions%2Foption-to-bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3c0a023611fcaf5ae3ec242d7d60e356041d25f/src%2Ftest%2Fui%2Fsuggestions%2Foption-to-bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Foption-to-bool.rs?ref=a3c0a023611fcaf5ae3ec242d7d60e356041d25f", "patch": "@@ -0,0 +1,9 @@\n+#![cfg_attr(let_chains, feature(let_chains))]\n+\n+fn foo(x: Option<i32>) {\n+    if true && x {}\n+    //~^ ERROR mismatched types\n+    //~| HELP use `Option::is_some` to test if the `Option` has a value\n+}\n+\n+fn main() {}"}, {"sha": "57a934b83420cc0da80c5d74b191c946cafb1d0c", "filename": "src/test/ui/suggestions/option-to-bool.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a3c0a023611fcaf5ae3ec242d7d60e356041d25f/src%2Ftest%2Fui%2Fsuggestions%2Foption-to-bool.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a3c0a023611fcaf5ae3ec242d7d60e356041d25f/src%2Ftest%2Fui%2Fsuggestions%2Foption-to-bool.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Foption-to-bool.stderr?ref=a3c0a023611fcaf5ae3ec242d7d60e356041d25f", "patch": "@@ -0,0 +1,16 @@\n+error[E0308]: mismatched types\n+  --> $DIR/option-to-bool.rs:4:16\n+   |\n+LL |     if true && x {}\n+   |                ^ expected `bool`, found enum `Option`\n+   |\n+   = note: expected type `bool`\n+              found enum `Option<i32>`\n+help: use `Option::is_some` to test if the `Option` has a value\n+   |\n+LL |     if true && x.is_some() {}\n+   |                 ++++++++++\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0308`."}]}