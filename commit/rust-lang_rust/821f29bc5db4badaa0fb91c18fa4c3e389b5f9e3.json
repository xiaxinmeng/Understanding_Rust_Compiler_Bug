{"sha": "821f29bc5db4badaa0fb91c18fa4c3e389b5f9e3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgyMWYyOWJjNWRiNGJhZGFhMGZiOTFjMThmYTRjM2UzODliNWY5ZTM=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-12-24T23:12:38Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-12-24T23:12:38Z"}, "message": "Merge pull request #586 from solson/rustup\n\nfix for infallible allocation", "tree": {"sha": "9346a1350dfca6dfced39747b89acaee7a880a42", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9346a1350dfca6dfced39747b89acaee7a880a42"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/821f29bc5db4badaa0fb91c18fa4c3e389b5f9e3", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJcIWfmCRBK7hj4Ov3rIwAAdHIIAGUz3rkfqdyDEdVhfHRysr9Y\nAVwezAE0r2Yn/QhpJFDFaXI/P9N6VweuRR8MYuAVvw/8GcyZtkPYEX1zr0ZQvuGg\nUQshZDnzYAzDkaaExmrTGham3dcP+sT+TQlYFNhk9NsTlzqGWwR9F9iTSmCQL3/R\ndgB+AxDBlVQikQYzvbnwWHEGC3bTFOo7I91II11xiXdFk4WDgm3UvXeDD3Fyl0Sm\nHKNBB6ikbgPfhXxZ035equQU8IkAv1rRczIcU0IoMvnRSovK0okp9bMrw5KAd9dc\nduvW0TeuCUJA4Bgdl0XWpI0gb7VhVX07H9QSu+oHhexNIKDrA16coFYc1KUSncI=\n=2FVL\n-----END PGP SIGNATURE-----\n", "payload": "tree 9346a1350dfca6dfced39747b89acaee7a880a42\nparent fd12f95305c9193fa95c8089cb5b6eefaf375b81\nparent d0f06a5f0daa73731f2ebe7763f2c48192220392\nauthor Ralf Jung <post@ralfj.de> 1545693158 +0100\ncommitter GitHub <noreply@github.com> 1545693158 +0100\n\nMerge pull request #586 from solson/rustup\n\nfix for infallible allocation"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/821f29bc5db4badaa0fb91c18fa4c3e389b5f9e3", "html_url": "https://github.com/rust-lang/rust/commit/821f29bc5db4badaa0fb91c18fa4c3e389b5f9e3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/821f29bc5db4badaa0fb91c18fa4c3e389b5f9e3/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fd12f95305c9193fa95c8089cb5b6eefaf375b81", "url": "https://api.github.com/repos/rust-lang/rust/commits/fd12f95305c9193fa95c8089cb5b6eefaf375b81", "html_url": "https://github.com/rust-lang/rust/commit/fd12f95305c9193fa95c8089cb5b6eefaf375b81"}, {"sha": "d0f06a5f0daa73731f2ebe7763f2c48192220392", "url": "https://api.github.com/repos/rust-lang/rust/commits/d0f06a5f0daa73731f2ebe7763f2c48192220392", "html_url": "https://github.com/rust-lang/rust/commit/d0f06a5f0daa73731f2ebe7763f2c48192220392"}], "stats": {"total": 71, "additions": 37, "deletions": 34}, "files": [{"sha": "879d27dc97e079c896ed0569cbf2fbd3d88c3eff", "filename": "README.md", "status": "modified", "additions": 24, "deletions": 21, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/821f29bc5db4badaa0fb91c18fa4c3e389b5f9e3/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/821f29bc5db4badaa0fb91c18fa4c3e389b5f9e3/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=821f29bc5db4badaa0fb91c18fa4c3e389b5f9e3", "patch": "@@ -90,15 +90,15 @@ things (like adding support for a new intrinsic) can be done by working just on\n the miri side.\n \n To prepare, make sure you are using a nightly Rust compiler.  You also need to\n-set up a libstd that enables execution with miri:\n+set up a libstd that enables execution with Miri:\n \n ```sh\n rustup override set nightly # or the nightly in `rust-version`\n cargo run --bin cargo-miri -- miri setup\n ```\n \n The last command should end in printing the directory where the libstd was\n-built.  Set that as your MIRI_SYSROOT environment variable:\n+built.  Set that as your `MIRI_SYSROOT` environment variable:\n \n ```sh\n export MIRI_SYSROOT=~/.cache/miri/HOST # or whatever the previous command said\n@@ -109,7 +109,7 @@ export MIRI_SYSROOT=~/.cache/miri/HOST # or whatever the previous command said\n Now you can run Miri directly, without going through `cargo miri`:\n \n ```sh\n-cargo run tests/run-pass-fullmir/format.rs # or whatever test you like\n+cargo run tests/run-pass/format.rs # or whatever test you like\n ```\n \n You can also run the test suite with `cargo test --release`.  `cargo test\n@@ -120,14 +120,33 @@ less time.\n \n Now you are set up!  You can write a failing test case, and tweak miri until it\n fails no more.\n+You can get a trace of which MIR statements are being executed by setting the\n+`MIRI_LOG` environment variable.  For example:\n+\n+```sh\n+MIRI_LOG=info cargo run tests/run-pass/vecs.rs\n+```\n+\n+Setting `MIRI_LOG` like this will configure logging for miri itself as well as\n+the `rustc::mir::interpret` and `rustc_mir::interpret` modules in rustc.  You\n+can also do more targeted configuration, e.g. to debug the stacked borrows\n+implementation:\n+```sh\n+MIRI_LOG=rustc_mir::interpret=info,miri::stacked_borrows cargo run tests/run-pass/vecs.rs\n+```\n+\n+In addition, you can set `MIRI_BACKTRACE=1` to get a backtrace of where an\n+evaluation error was originally created.\n+\n \n ### Using a locally built rustc\n \n Since the heart of Miri (the main interpreter engine) lives in rustc, working on\n Miri will often require using a locally built rustc.  The bug you want to fix\n may actually be on the rustc side, or you just need to get more detailed trace\n-of the execution -- in both cases, you should develop miri against a rustc you\n-compiled yourself, with debug assertions (and hence tracing) enabled.\n+of the execution than what is possible with release builds -- in both cases, you\n+should develop miri against a rustc you compiled yourself, with debug assertions\n+(and hence tracing) enabled.\n \n The setup for a local rustc works as follows:\n ```sh\n@@ -149,22 +168,6 @@ rustup override set custom\n With this, you should now have a working development setup!  See\n [\"Testing Miri\"](#testing-miri) above for how to proceed.\n \n-Moreover, you can now run Miri with a trace of all execution steps:\n-```sh\n-MIRI_LOG=debug cargo run tests/run-pass/vecs.rs\n-```\n-\n-Setting `MIRI_LOG` like this will configure logging for miri itself as well as\n-the `rustc::mir::interpret` and `rustc_mir::interpret` modules in rustc.  You\n-can also do more targeted configuration, e.g. to debug the stacked borrows\n-implementation:\n-```sh\n-MIRI_LOG=rustc_mir::interpret=debug,miri::stacked_borrows cargo run tests/run-pass/vecs.rs\n-```\n-\n-In addition, you can set `MIRI_BACKTRACE=1` to get a backtrace of where an\n-evaluation error was originally created.\n-\n ### Miri `-Z` flags and environment variables\n \n Several `-Z` flags are relevant for Miri:"}, {"sha": "ea30c4512ee7cf2796a76f8f48019406599811a4", "filename": "rust-version", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/821f29bc5db4badaa0fb91c18fa4c3e389b5f9e3/rust-version", "raw_url": "https://github.com/rust-lang/rust/raw/821f29bc5db4badaa0fb91c18fa4c3e389b5f9e3/rust-version", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rust-version?ref=821f29bc5db4badaa0fb91c18fa4c3e389b5f9e3", "patch": "@@ -1 +1 @@\n-nightly-2018-12-22\n+nightly-2018-12-24"}, {"sha": "0f5429518239978446750fc62448f6e263959da0", "filename": "src/fn_call.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/821f29bc5db4badaa0fb91c18fa4c3e389b5f9e3/src%2Ffn_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/821f29bc5db4badaa0fb91c18fa4c3e389b5f9e3/src%2Ffn_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffn_call.rs?ref=821f29bc5db4badaa0fb91c18fa4c3e389b5f9e3", "patch": "@@ -84,7 +84,7 @@ pub trait EvalContextExt<'a, 'mir, 'tcx: 'a+'mir>: crate::MiriEvalContextExt<'a,\n                     this.write_null(dest)?;\n                 } else {\n                     let align = this.tcx.data_layout.pointer_align.abi;\n-                    let ptr = this.memory_mut().allocate(Size::from_bytes(size), align, MiriMemoryKind::C.into())?;\n+                    let ptr = this.memory_mut().allocate(Size::from_bytes(size), align, MiriMemoryKind::C.into());\n                     this.write_scalar(Scalar::Ptr(ptr.with_default_tag()), dest)?;\n                 }\n             }\n@@ -114,7 +114,7 @@ pub trait EvalContextExt<'a, 'mir, 'tcx: 'a+'mir>: crate::MiriEvalContextExt<'a,\n                         Size::from_bytes(size),\n                         Align::from_bytes(align).unwrap(),\n                         MiriMemoryKind::Rust.into()\n-                    )?\n+                    )\n                     .with_default_tag();\n                 this.write_scalar(Scalar::Ptr(ptr), dest)?;\n             }\n@@ -132,7 +132,7 @@ pub trait EvalContextExt<'a, 'mir, 'tcx: 'a+'mir>: crate::MiriEvalContextExt<'a,\n                         Size::from_bytes(size),\n                         Align::from_bytes(align).unwrap(),\n                         MiriMemoryKind::Rust.into()\n-                    )?\n+                    )\n                     .with_default_tag();\n                 this.memory_mut()\n                     .get_mut(ptr.alloc_id)?\n@@ -358,7 +358,7 @@ pub trait EvalContextExt<'a, 'mir, 'tcx: 'a+'mir>: crate::MiriEvalContextExt<'a,\n                         Size::from_bytes((value.len() + 1) as u64),\n                         Align::from_bytes(1).unwrap(),\n                         MiriMemoryKind::Env.into(),\n-                    )?.with_default_tag();\n+                    ).with_default_tag();\n                     {\n                         let alloc = this.memory_mut().get_mut(value_copy.alloc_id)?;\n                         alloc.write_bytes(tcx, value_copy, &value)?;"}, {"sha": "7643f93fdc2cf63ad34c4a1a8064e02062e2a352", "filename": "src/lib.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/821f29bc5db4badaa0fb91c18fa4c3e389b5f9e3/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/821f29bc5db4badaa0fb91c18fa4c3e389b5f9e3/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=821f29bc5db4badaa0fb91c18fa4c3e389b5f9e3", "patch": "@@ -101,7 +101,7 @@ pub fn create_ecx<'a, 'mir: 'a, 'tcx: 'mir>(\n \n     // Return value (in static memory so that it does not count as leak)\n     let ret = ecx.layout_of(start_mir.return_ty())?;\n-    let ret_ptr = ecx.allocate(ret, MiriMemoryKind::MutStatic.into())?;\n+    let ret_ptr = ecx.allocate(ret, MiriMemoryKind::MutStatic.into());\n \n     // Push our stack frame\n     ecx.push_stack_frame(\n@@ -125,7 +125,7 @@ pub fn create_ecx<'a, 'mir: 'a, 'tcx: 'mir>(\n     ecx.write_scalar(argc, dest)?;\n     // Store argc for macOS _NSGetArgc\n     {\n-        let argc_place = ecx.allocate(dest.layout, MiriMemoryKind::Env.into())?;\n+        let argc_place = ecx.allocate(dest.layout, MiriMemoryKind::Env.into());\n         ecx.write_scalar(argc, argc_place.into())?;\n         ecx.machine.argc = Some(argc_place.ptr.to_ptr()?);\n     }\n@@ -136,14 +136,14 @@ pub fn create_ecx<'a, 'mir: 'a, 'tcx: 'mir>(\n     let dest = ecx.eval_place(&mir::Place::Local(args.next().unwrap()))?;\n     let cmd = ecx.memory_mut().allocate_static_bytes(CMD.as_bytes()).with_default_tag();\n     let raw_str_layout = ecx.layout_of(ecx.tcx.mk_imm_ptr(ecx.tcx.types.u8))?;\n-    let cmd_place = ecx.allocate(raw_str_layout, MiriMemoryKind::Env.into())?;\n+    let cmd_place = ecx.allocate(raw_str_layout, MiriMemoryKind::Env.into());\n     ecx.write_scalar(Scalar::Ptr(cmd), cmd_place.into())?;\n     ecx.memory_mut().mark_immutable(cmd_place.to_ptr()?.alloc_id)?;\n     // Store argv for macOS _NSGetArgv\n     {\n         let argv = cmd_place.ptr;\n         ecx.write_scalar(argv, dest)?;\n-        let argv_place = ecx.allocate(dest.layout, MiriMemoryKind::Env.into())?;\n+        let argv_place = ecx.allocate(dest.layout, MiriMemoryKind::Env.into());\n         ecx.write_scalar(argv, argv_place.into())?;\n         ecx.machine.argv = Some(argv_place.ptr.to_ptr()?);\n     }\n@@ -155,7 +155,7 @@ pub fn create_ecx<'a, 'mir: 'a, 'tcx: 'mir>(\n             Size::from_bytes(cmd_utf16.len() as u64 * 2),\n             Align::from_bytes(2).unwrap(),\n             MiriMemoryKind::Env.into(),\n-        )?.with_default_tag();\n+        ).with_default_tag();\n         ecx.machine.cmd_line = Some(cmd_ptr);\n         // store the UTF-16 string\n         let char_size = Size::from_bytes(2);\n@@ -516,13 +516,13 @@ impl<'a, 'mir, 'tcx> Machine<'a, 'mir, 'tcx> for Evaluator<'tcx> {\n         ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n         ptr: Pointer,\n         kind: MemoryKind<Self::MemoryKinds>,\n-    ) -> EvalResult<'tcx, Pointer<Borrow>> {\n+    ) -> Pointer<Borrow> {\n         if !ecx.machine.validate {\n             // No tracking\n-            Ok(ptr.with_default_tag())\n+            ptr.with_default_tag()\n         } else {\n             let tag = ecx.tag_new_allocation(ptr.alloc_id, kind);\n-            Ok(Pointer::new_with_tag(ptr.alloc_id, ptr.offset, tag))\n+            Pointer::new_with_tag(ptr.alloc_id, ptr.offset, tag)\n         }\n     }\n "}]}