{"sha": "5a341ecfc985c190d8c359a8c995a094ef22ab9e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVhMzQxZWNmYzk4NWMxOTBkOGMzNTlhOGM5OTVhMDk0ZWYyMmFiOWU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-05-13T21:56:56Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-05-13T21:56:56Z"}, "message": "Auto merge of #25384 - steveklabnik:rollup, r=steveklabnik\n\n- Successful merges: #25308, #25360, #25363, #25365, #25371, #25372, #25376, #25379, #25382\n- Failed merges:", "tree": {"sha": "c5fd94331e86bb61116ae06b99ada1f7b08aa4d8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c5fd94331e86bb61116ae06b99ada1f7b08aa4d8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5a341ecfc985c190d8c359a8c995a094ef22ab9e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5a341ecfc985c190d8c359a8c995a094ef22ab9e", "html_url": "https://github.com/rust-lang/rust/commit/5a341ecfc985c190d8c359a8c995a094ef22ab9e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5a341ecfc985c190d8c359a8c995a094ef22ab9e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "222cd73b8a422d2c4124375f6aaffd2663bb9718", "url": "https://api.github.com/repos/rust-lang/rust/commits/222cd73b8a422d2c4124375f6aaffd2663bb9718", "html_url": "https://github.com/rust-lang/rust/commit/222cd73b8a422d2c4124375f6aaffd2663bb9718"}, {"sha": "87c903a95caacee1eef516ccde5b08a470017392", "url": "https://api.github.com/repos/rust-lang/rust/commits/87c903a95caacee1eef516ccde5b08a470017392", "html_url": "https://github.com/rust-lang/rust/commit/87c903a95caacee1eef516ccde5b08a470017392"}], "stats": {"total": 283, "additions": 252, "deletions": 31}, "files": [{"sha": "7d3cf64e9f031936964bce654be7a7ddf5635fed", "filename": "src/doc/reference.md", "status": "modified", "additions": 60, "deletions": 7, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/5a341ecfc985c190d8c359a8c995a094ef22ab9e/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/5a341ecfc985c190d8c359a8c995a094ef22ab9e/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=5a341ecfc985c190d8c359a8c995a094ef22ab9e", "patch": "@@ -1346,6 +1346,8 @@ vtable when the trait is used as a [trait object](#trait-objects).\n Traits are implemented for specific types through separate\n [implementations](#implementations).\n \n+Consider the following trait:\n+\n ```\n # type Surface = i32;\n # type BoundingBox = i32;\n@@ -1360,6 +1362,20 @@ This defines a trait with two methods. All values that have\n `draw` and `bounding_box` methods called, using `value.bounding_box()`\n [syntax](#method-call-expressions).\n \n+Traits can include default implementations of methods, as in:\n+\n+```\n+trait Foo {\n+    fn bar(&self);\n+\n+    fn baz(&self) { println!(\"We called baz.\"); }\n+}\n+```\n+\n+Here the `baz` method has a default implementation, so types that implement\n+`Foo` need only implement `bar`. It is also possible for implementing types\n+to override a method that has a default implementation.\n+\n Type parameters can be specified for a trait to make it generic. These appear\n after the trait name, using the same syntax used in [generic\n functions](#generic-functions).\n@@ -1372,6 +1388,35 @@ trait Seq<T> {\n }\n ```\n \n+It is also possible to define associated types for a trait. Consider the\n+following example of a `Container` trait. Notice how the type is available\n+for use in the method signatures:\n+\n+```\n+trait Container {\n+    type E;\n+    fn empty() -> Self;\n+    fn insert(&mut self, Self::E);\n+}\n+```\n+\n+In order for a type to implement this trait, it must not only provide\n+implementations for every method, but it must specify the type `E`. Here's\n+an implementation of `Container` for the standard library type `Vec`:\n+\n+```\n+# trait Container {\n+#     type E;\n+#     fn empty() -> Self;\n+#     fn insert(&mut self, Self::E);\n+# }\n+impl<T> Container for Vec<T> {\n+    type E = T;\n+    fn empty() -> Vec<T> { Vec::new() }\n+    fn insert(&mut self, x: T) { self.push(x); }\n+}\n+```\n+\n Generic functions may use traits as _bounds_ on their type parameters. This\n will have two effects: only types that have the trait may instantiate the\n parameter, and within the generic function, the methods of the trait can be\n@@ -3470,13 +3515,21 @@ more of the closure traits:\n \n ### Trait objects\n \n-Every trait item (see [traits](#traits)) defines a type with the same name as\n-the trait. This type is called the _trait object_ of the trait. Trait objects\n-permit \"late binding\" of methods, dispatched using _virtual method tables_\n-(\"vtables\"). Whereas most calls to trait methods are \"early bound\" (statically\n-resolved) to specific implementations at compile time, a call to a method on an\n-trait objects is only resolved to a vtable entry at compile time. The actual\n-implementation for each vtable entry can vary on an object-by-object basis.\n+In Rust, a type like `&SomeTrait` or `Box<SomeTrait>` is called a _trait object_.\n+Each instance of a trait object includes:\n+\n+ - a pointer to an instance of a type `T` that implements `SomeTrait`\n+ - a _virtual method table_, often just called a _vtable_, which contains, for\n+   each method of `SomeTrait` that `T` implements, a pointer to `T`'s\n+   implementation (i.e. a function pointer).\n+\n+The purpose of trait objects is to permit \"late binding\" of methods. A call to\n+a method on a trait object is only resolved to a vtable entry at compile time.\n+The actual implementation for each vtable entry can vary on an object-by-object\n+basis.\n+\n+Note that for a trait object to be instantiated, the trait must be\n+_object-safe_. Object safety rules are defined in [RFC 255][rfc255].\n \n Given a pointer-typed expression `E` of type `&T` or `Box<T>`, where `T`\n implements trait `R`, casting `E` to the corresponding pointer type `&R` or"}, {"sha": "9ca5de2b50a4d6898e4bde1ab7e69e3e2af55853", "filename": "src/doc/trpl/README.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a341ecfc985c190d8c359a8c995a094ef22ab9e/src%2Fdoc%2Ftrpl%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/5a341ecfc985c190d8c359a8c995a094ef22ab9e/src%2Fdoc%2Ftrpl%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2FREADME.md?ref=5a341ecfc985c190d8c359a8c995a094ef22ab9e", "patch": "@@ -175,7 +175,7 @@ data, we call the `clone()` method. In this example, `y` is no longer a referenc\n to the vector stored in `x`, but a copy of its first element, `\"Hello\"`. Now\n that we don\u2019t have a reference, our `push()` works just fine.\n \n-[move]: move-semantics.html\n+[move]: ownership.html#move-semantics\n \n If we truly want a reference, we need the other option: ensure that our reference\n goes out of scope before we try to do the mutation. That looks like this:"}, {"sha": "81280e8920ca9419df1b2f7fd8e2a0564728a6f4", "filename": "src/doc/trpl/dining-philosophers.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a341ecfc985c190d8c359a8c995a094ef22ab9e/src%2Fdoc%2Ftrpl%2Fdining-philosophers.md", "raw_url": "https://github.com/rust-lang/rust/raw/5a341ecfc985c190d8c359a8c995a094ef22ab9e/src%2Fdoc%2Ftrpl%2Fdining-philosophers.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fdining-philosophers.md?ref=5a341ecfc985c190d8c359a8c995a094ef22ab9e", "patch": "@@ -450,7 +450,7 @@ which blocks execution until the thread has completed execution. This ensures\n that the threads complete their work before the program exits.\n \n If you run this program, you\u2019ll see that the philosophers eat out of order!\n-We have mult-threading!\n+We have multi-threading!\n \n ```text\n Gilles Deleuze is eating."}, {"sha": "dcaf698fd3c9d2d34377a8ba2fca5fb49d1981e7", "filename": "src/doc/trpl/error-handling.md", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a341ecfc985c190d8c359a8c995a094ef22ab9e/src%2Fdoc%2Ftrpl%2Ferror-handling.md", "raw_url": "https://github.com/rust-lang/rust/raw/5a341ecfc985c190d8c359a8c995a094ef22ab9e/src%2Fdoc%2Ftrpl%2Ferror-handling.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Ferror-handling.md?ref=5a341ecfc985c190d8c359a8c995a094ef22ab9e", "patch": "@@ -181,6 +181,8 @@ match version {\n This function makes use of an enum, `ParseError`, to enumerate the various\n errors that can occur.\n \n+The [`Debug`](../std/fmt/trait.Debug.html) trait is what lets us print the enum value using the `{:?}` format operation.\n+\n # Non-recoverable errors with `panic!`\n \n In the case of an error that is unexpected and not recoverable, the `panic!`"}, {"sha": "f5654d6293991b88147172845439fbfc2a329663", "filename": "src/doc/trpl/the-stack-and-the-heap.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a341ecfc985c190d8c359a8c995a094ef22ab9e/src%2Fdoc%2Ftrpl%2Fthe-stack-and-the-heap.md", "raw_url": "https://github.com/rust-lang/rust/raw/5a341ecfc985c190d8c359a8c995a094ef22ab9e/src%2Fdoc%2Ftrpl%2Fthe-stack-and-the-heap.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fthe-stack-and-the-heap.md?ref=5a341ecfc985c190d8c359a8c995a094ef22ab9e", "patch": "@@ -266,7 +266,7 @@ Rust programs use [jemalloc][jemalloc] for this purpose.\n Anyway, back to our example. Since this memory is on the heap, it can stay\n alive longer than the function which allocates the box. In this case, however,\n it doesn\u2019t.[^moving] When the function is over, we need to free the stack frame\n-for `main()`. `Box<T>`, though, has a trick up its sleve: [Drop][drop]. The\n+for `main()`. `Box<T>`, though, has a trick up its sleeve: [Drop][drop]. The\n implementation of `Drop` for `Box` deallocates the memory that was allocated\n when it was created. Great! So when `x` goes away, it first frees the memory\n allocated on the heap:"}, {"sha": "e35d81d3996b359e1e3a90f849b465105fcaa26d", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/5a341ecfc985c190d8c359a8c995a094ef22ab9e/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a341ecfc985c190d8c359a8c995a094ef22ab9e/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=5a341ecfc985c190d8c359a8c995a094ef22ab9e", "patch": "@@ -18,39 +18,41 @@\n //! You can explicitly create a `Vec<T>` with `new()`:\n //!\n //! ```\n-//! let xs: Vec<i32> = Vec::new();\n+//! let v: Vec<i32> = Vec::new();\n //! ```\n //!\n //! ...or by using the `vec!` macro:\n //!\n //! ```\n-//! let ys: Vec<i32> = vec![];\n+//! let v: Vec<i32> = vec![];\n //!\n-//! let zs = vec![1i32, 2, 3, 4, 5];\n+//! let v = vec![1, 2, 3, 4, 5];\n+//!\n+//! let v = vec![0; 10]; // ten zeroes\n //! ```\n //!\n //! You can `push` values onto the end of a vector (which will grow the vector as needed):\n //!\n //! ```\n-//! let mut xs = vec![1i32, 2];\n+//! let mut v = vec![1, 2];\n //!\n-//! xs.push(3);\n+//! v.push(3);\n //! ```\n //!\n //! Popping values works in much the same way:\n //!\n //! ```\n-//! let mut xs = vec![1i32, 2];\n+//! let mut v = vec![1, 2];\n //!\n-//! let two = xs.pop();\n+//! let two = v.pop();\n //! ```\n //!\n //! Vectors also support indexing (through the `Index` and `IndexMut` traits):\n //!\n //! ```\n-//! let mut xs = vec![1i32, 2, 3];\n-//! let three = xs[2];\n-//! xs[1] = xs[1] + 5;\n+//! let mut v = vec![1, 2, 3];\n+//! let three = v[2];\n+//! v[1] = v[1] + 5;\n //! ```\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "64eb75ea530f10f7f5d349a5660c764c4ef9e4b4", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a341ecfc985c190d8c359a8c995a094ef22ab9e/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a341ecfc985c190d8c359a8c995a094ef22ab9e/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=5a341ecfc985c190d8c359a8c995a094ef22ab9e", "patch": "@@ -167,7 +167,7 @@ macro_rules! try {\n     })\n }\n \n-/// Use the `format!` syntax to write data into a buffer of type `&mut Writer`.\n+/// Use the `format!` syntax to write data into a buffer of type `&mut Write`.\n /// See `std::fmt` for more information.\n ///\n /// # Examples"}, {"sha": "e9f4860f4514e12049c0ee554de37ae08794fa63", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5a341ecfc985c190d8c359a8c995a094ef22ab9e/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a341ecfc985c190d8c359a8c995a094ef22ab9e/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=5a341ecfc985c190d8c359a8c995a094ef22ab9e", "patch": "@@ -427,8 +427,8 @@ be taken.\n \n E0271: r##\"\n This is because of a type mismatch between the associated type of some\n-trait (e.g. T::Bar, where T implements trait Quux { type Bar; })\n-and another type U that is required to be equal to T::Bar, but is not.\n+trait (e.g. `T::Bar`, where `T` implements `trait Quux { type Bar; }`)\n+and another type `U` that is required to be equal to `T::Bar`, but is not.\n Examples follow.\n \n Here is a basic example:"}, {"sha": "1e0b627a8e031b870f16634ac04f6dccf11a638d", "filename": "src/librustc_resolve/diagnostics.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5a341ecfc985c190d8c359a8c995a094ef22ab9e/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a341ecfc985c190d8c359a8c995a094ef22ab9e/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=5a341ecfc985c190d8c359a8c995a094ef22ab9e", "patch": "@@ -20,6 +20,7 @@ Imports (`use` statements) are not allowed after non-item statements, such as\n variable declarations and expression statements.\n \n Here is an example that demonstrates the error:\n+\n ```\n fn f() {\n     // Variable declaration before import\n@@ -33,6 +34,7 @@ The solution is to declare the imports at the top of the block, function, or\n file.\n \n Here is the previous example again, with the correct order:\n+\n ```\n fn f() {\n     use std::io::Read;\n@@ -52,6 +54,7 @@ The name chosen for an external crate conflicts with another external crate that\n has been imported into the current module.\n \n Wrong example:\n+\n ```\n extern crate a;\n extern crate crate_a as a;\n@@ -61,6 +64,7 @@ The solution is to choose a different name that doesn't conflict with any\n external crate imported into the current module.\n \n Correct example:\n+\n ```\n extern crate a;\n extern crate crate_a as other_name;\n@@ -71,6 +75,7 @@ E0260: r##\"\n The name for an item declaration conflicts with an external crate's name.\n \n For instance,\n+\n ```\n extern crate abc;\n "}, {"sha": "a11a4edbd316b71f5221bb7b1898b241ba85a52a", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 167, "deletions": 8, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/5a341ecfc985c190d8c359a8c995a094ef22ab9e/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a341ecfc985c190d8c359a8c995a094ef22ab9e/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=5a341ecfc985c190d8c359a8c995a094ef22ab9e", "patch": "@@ -19,6 +19,51 @@ methods that do not have default implementations), as well as any required\n trait items like associated types or constants.\n \"##,\n \n+E0049: r##\"\n+This error indicates that an attempted implementation of a trait method\n+has the wrong number of type parameters.\n+\n+For example, the trait below has a method `foo` with a type parameter `T`,\n+but the implementation of `foo` for the type `Bar` is missing this parameter:\n+\n+```\n+trait Foo {\n+    fn foo<T: Default>(x: T) -> Self;\n+}\n+\n+struct Bar;\n+\n+// error: method `foo` has 0 type parameters but its trait declaration has 1\n+// type parameter\n+impl Foo for Bar {\n+    fn foo(x: bool) -> Self { Bar }\n+}\n+```\n+\"##,\n+\n+E0050: r##\"\n+This error indicates that an attempted implementation of a trait method\n+has the wrong number of function parameters.\n+\n+For example, the trait below has a method `foo` with two function parameters\n+(`&self` and `u8`), but the implementation of `foo` for the type `Bar` omits\n+the `u8` parameter:\n+\n+```\n+trait Foo {\n+    fn foo(&self, x: u8) -> bool;\n+}\n+\n+struct Bar;\n+\n+// error: method `foo` has 1 parameter but the declaration in trait `Foo::foo`\n+// has 2\n+impl Foo for Bar {\n+    fn foo(&self) -> bool { true }\n+}\n+```\n+\"##,\n+\n E0054: r##\"\n It is not allowed to cast to a bool. If you are trying to cast a numeric type\n to a bool, you can compare it with zero instead:\n@@ -138,6 +183,88 @@ enum Empty {}\n ```\n \"##,\n \n+E0106: r##\"\n+This error indicates that a lifetime is missing from a type. If it is an error\n+inside a function signature, the problem may be with failing to adhere to the\n+lifetime elision rules (see below).\n+\n+Here are some simple examples of where you'll run into this error:\n+\n+```\n+struct Foo { x: &bool }        // error\n+struct Foo<'a> { x: &'a bool } // correct\n+\n+enum Bar { A(u8), B(&bool), }        // error\n+enum Bar<'a> { A(u8), B(&'a bool), } // correct\n+\n+type MyStr = &str;        // error\n+type MyStr<'a> = &'a str; //correct\n+\n+```\n+\n+Lifetime elision is a special, limited kind of inference for lifetimes in\n+function signatures which allows you to leave out lifetimes in certain cases.\n+For more background on lifetime elision see [the book][book-le].\n+\n+The lifetime elision rules require that any function signature with an elided\n+output lifetime must either have\n+\n+ - exactly one input lifetime\n+ - or, multiple input lifetimes, but the function must also be a method with a\n+   `&self` or `&mut self` receiver\n+\n+In the first case, the output lifetime is inferred to be the same as the unique\n+input lifetime. In the second case, the lifetime is instead inferred to be the\n+same as the lifetime on `&self` or `&mut self`.\n+\n+Here are some examples of elision errors:\n+\n+```\n+// error, no input lifetimes\n+fn foo() -> &str { ... }\n+\n+// error, `x` and `y` have distinct lifetimes inferred\n+fn bar(x: &str, y: &str) -> &str { ... }\n+\n+// error, `y`'s lifetime is inferred to be distinct from `x`'s\n+fn baz<'a>(x: &'a str, y: &str) -> &str { ... }\n+```\n+\n+[book-le]: http://doc.rust-lang.org/nightly/book/lifetimes.html#lifetime-elision\n+\"##,\n+\n+E0107: r##\"\n+This error means that an incorrect number of lifetime parameters were provided\n+for a type (like a struct or enum) or trait.\n+\n+Some basic examples include:\n+\n+```\n+struct Foo<'a>(&'a str);\n+enum Bar { A, B, C }\n+\n+struct Baz<'a> {\n+    foo: Foo,     // error: expected 1, found 0\n+    bar: Bar<'a>, // error: expected 0, found 1\n+}\n+```\n+\n+Here's an example that is currently an error, but may work in a future version\n+of Rust:\n+\n+```\n+struct Foo<'a>(&'a str);\n+\n+trait Quux { }\n+impl Quux for Foo { } // error: expected 1, found 0\n+```\n+\n+Lifetime elision in implementation headers was part of the lifetime elision\n+RFC. It is, however, [currently unimplemented][iss15872].\n+\n+[iss15872]: https://github.com/rust-lang/rust/issues/15872\n+\"##,\n+\n E0131: r##\"\n It is not possible to define `main` with type parameters, or even with function\n parameters. When `main` is present, it must take no arguments and return `()`.\n@@ -152,6 +279,20 @@ fn(isize, *const *const u8) -> isize\n ```\n \"##,\n \n+E0166: r##\"\n+This error means that the compiler found a return expression in a function\n+marked as diverging. A function diverges if it has `!` in the place of the\n+return type in its signature. For example:\n+\n+```\n+fn foo() -> ! { return; } // error\n+```\n+\n+For a function that diverges, every control path in the function must never\n+return, for example with a `loop` that never breaks or a call to another\n+diverging function (such as `panic!()`).\n+\"##,\n+\n E0184: r##\"\n Explicitly implementing both Drop and Copy for a type is currently disallowed.\n This feature can make some sense in theory, but the current implementation is\n@@ -161,6 +302,24 @@ it has been disabled for now.\n [iss20126]: https://github.com/rust-lang/rust/issues/20126\n \"##,\n \n+E0201: r##\"\n+It is an error to define a method--a trait method or an inherent method--more\n+than once.\n+\n+For example,\n+\n+```\n+struct Foo(u8);\n+\n+impl Foo {\n+    fn bar() {}\n+\n+    // error: duplicate method\n+    fn bar(&self) -> bool { self.0 > 5 }\n+}\n+```\n+\"##,\n+\n E0204: r##\"\n An attempt to implement the `Copy` trait for a struct failed because one of the\n fields does not implement `Copy`. To fix this, you must implement `Copy` for the\n@@ -292,6 +451,13 @@ const B: [u32; foo()] = [];\n use std::{f64, u8};\n const C: [u32; u8::MAX + f64::EPSILON] = [];\n ```\n+\"##,\n+\n+E0322: r##\"\n+The `Sized` trait is a special trait built-in to the compiler for types with a\n+constant size known at compile-time. This trait is automatically implemented\n+for types as needed by the compiler, and it is currently disallowed to\n+explicitly implement it for a type.\n \"##\n \n }\n@@ -312,8 +478,6 @@ register_diagnostics! {\n     E0040, // explicit use of destructor method\n     E0044, // foreign items may not have type parameters\n     E0045, // variadic function must have C calling convention\n-    E0049,\n-    E0050,\n     E0053,\n     E0055, // method has an incompatible type for trait\n     E0057, // method has an incompatible type for trait\n@@ -345,8 +509,6 @@ register_diagnostics! {\n     E0102,\n     E0103,\n     E0104,\n-    E0106,\n-    E0107,\n     E0116,\n     E0117,\n     E0118,\n@@ -364,7 +526,6 @@ register_diagnostics! {\n     E0159,\n     E0163,\n     E0164,\n-    E0166,\n     E0167,\n     E0168,\n     E0172,\n@@ -390,7 +551,6 @@ register_diagnostics! {\n     E0198, // negative implementations are not unsafe\n     E0199, // implementing trait is not unsafe\n     E0200, // trait requires an `unsafe impl` declaration\n-    E0201, // duplicate method in trait impl\n     E0202, // associated items are not allowed in inherent impls\n     E0203, // type parameter has more than one relaxed default bound,\n            // and only one is supported\n@@ -421,7 +581,7 @@ register_diagnostics! {\n     E0231, // only named substitution parameters are allowed\n     E0232, // this attribute must have a value\n     E0233,\n-    E0234, // `for` loop expression has type which does not implement the `Iterator` trait\n+    E0234,\n     E0235, // structure constructor specifies a structure of type but\n     E0236, // no lang item for range syntax\n     E0237, // no lang item for range syntax\n@@ -438,7 +598,6 @@ register_diagnostics! {\n     E0319, // trait impls for defaulted traits allowed just for structs/enums\n     E0320, // recursive overflow during dropck\n     E0321, // extended coherence rules for defaulted traits violated\n-    E0322, // cannot implement Sized explicitly\n     E0323, // implemented an associated const when another trait item expected\n     E0324, // implemented a method when another trait item expected\n     E0325, // implemented an associated type when another trait item expected"}]}