{"sha": "08bf9f69b9cd96cf2871af1c2ec4dad0258728f2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA4YmY5ZjY5YjljZDk2Y2YyODcxYWYxYzJlYzRkYWQwMjU4NzI4ZjI=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-07-28T15:27:11Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-08-12T03:46:31Z"}, "message": "typeck: leak auto trait obligations through impl Trait.", "tree": {"sha": "970287c7db6efa4dd9c51c236cb547ae9591dfc2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/970287c7db6efa4dd9c51c236cb547ae9591dfc2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/08bf9f69b9cd96cf2871af1c2ec4dad0258728f2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/08bf9f69b9cd96cf2871af1c2ec4dad0258728f2", "html_url": "https://github.com/rust-lang/rust/commit/08bf9f69b9cd96cf2871af1c2ec4dad0258728f2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/08bf9f69b9cd96cf2871af1c2ec4dad0258728f2/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d92e594c3801a8066f95305c87e53a7ecfb24e9b", "url": "https://api.github.com/repos/rust-lang/rust/commits/d92e594c3801a8066f95305c87e53a7ecfb24e9b", "html_url": "https://github.com/rust-lang/rust/commit/d92e594c3801a8066f95305c87e53a7ecfb24e9b"}], "stats": {"total": 776, "additions": 613, "deletions": 163}, "files": [{"sha": "5ba7b914d6591ba57c6cf42452c853165e477dcd", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 137, "deletions": 12, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/08bf9f69b9cd96cf2871af1c2ec4dad0258728f2/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08bf9f69b9cd96cf2871af1c2ec4dad0258728f2/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=08bf9f69b9cd96cf2871af1c2ec4dad0258728f2", "patch": "@@ -10,7 +10,8 @@\n \n use dep_graph::DepGraph;\n use infer::{InferCtxt, InferOk};\n-use ty::{self, Ty, TypeFoldable, ToPolyTraitRef, TyCtxt};\n+use ty::{self, Ty, TypeFoldable, ToPolyTraitRef, TyCtxt, ToPredicate};\n+use ty::subst::{Substs, Subst};\n use rustc_data_structures::obligation_forest::{ObligationForest, Error};\n use rustc_data_structures::obligation_forest::{ForestObligation, ObligationProcessor};\n use std::marker::PhantomData;\n@@ -22,10 +23,9 @@ use util::nodemap::{FnvHashSet, NodeMap};\n use super::CodeAmbiguity;\n use super::CodeProjectionError;\n use super::CodeSelectionError;\n-use super::FulfillmentError;\n-use super::FulfillmentErrorCode;\n-use super::ObligationCause;\n-use super::PredicateObligation;\n+use super::{FulfillmentError, FulfillmentErrorCode, SelectionError};\n+use super::{ObligationCause, BuiltinDerivedObligation};\n+use super::{PredicateObligation, TraitObligation, Obligation};\n use super::project;\n use super::select::SelectionContext;\n use super::Unimplemented;\n@@ -51,6 +51,7 @@ pub struct GlobalFulfilledPredicates<'tcx> {\n /// along. Once all type inference constraints have been generated, the\n /// method `select_all_or_error` can be used to report any remaining\n /// ambiguous cases as errors.\n+\n pub struct FulfillmentContext<'tcx> {\n     // A list of all obligations that have been registered with this\n     // fulfillment context.\n@@ -84,6 +85,10 @@ pub struct FulfillmentContext<'tcx> {\n     // obligations (otherwise, it's easy to fail to walk to a\n     // particular node-id).\n     region_obligations: NodeMap<Vec<RegionObligation<'tcx>>>,\n+\n+    // A list of obligations that need to be deferred to\n+    // a later time for them to be properly fulfilled.\n+    deferred_obligations: Vec<DeferredObligation<'tcx>>,\n }\n \n #[derive(Clone)]\n@@ -99,13 +104,98 @@ pub struct PendingPredicateObligation<'tcx> {\n     pub stalled_on: Vec<Ty<'tcx>>,\n }\n \n+/// An obligation which cannot be fulfilled in the context\n+/// it was registered in, such as auto trait obligations on\n+/// `impl Trait`, which require the concrete type to be\n+/// available, only guaranteed after finishing type-checking.\n+#[derive(Clone, Debug)]\n+pub struct DeferredObligation<'tcx> {\n+    pub predicate: ty::PolyTraitPredicate<'tcx>,\n+    pub cause: ObligationCause<'tcx>\n+}\n+\n+impl<'a, 'gcx, 'tcx> DeferredObligation<'tcx> {\n+    /// If possible, create a `DeferredObligation` from\n+    /// a trait predicate which had failed selection,\n+    /// but could succeed later.\n+    pub fn from_select_error(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                             obligation: &TraitObligation<'tcx>,\n+                             selection_err: &SelectionError<'tcx>)\n+                             -> Option<DeferredObligation<'tcx>> {\n+        if let Unimplemented = *selection_err {\n+            if DeferredObligation::must_defer(tcx, &obligation.predicate) {\n+                return Some(DeferredObligation {\n+                    predicate: obligation.predicate.clone(),\n+                    cause: obligation.cause.clone()\n+                });\n+            }\n+        }\n+\n+        None\n+    }\n+\n+    /// Returns true if the given trait predicate can be\n+    /// fulfilled at a later time.\n+    pub fn must_defer(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                      predicate: &ty::PolyTraitPredicate<'tcx>)\n+                      -> bool {\n+        // Auto trait obligations on `impl Trait`.\n+        if tcx.trait_has_default_impl(predicate.def_id()) {\n+            let substs = predicate.skip_binder().trait_ref.substs;\n+            if substs.types.as_slice().len() == 1 && substs.regions.is_empty() {\n+                if let ty::TyAnon(..) = predicate.skip_binder().self_ty().sty {\n+                    return true;\n+                }\n+            }\n+        }\n+\n+        false\n+    }\n+\n+    /// If possible, return the nested obligations required\n+    /// to fulfill this obligation.\n+    pub fn try_select(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>)\n+                      -> Option<Vec<PredicateObligation<'tcx>>> {\n+        if let ty::TyAnon(def_id, substs) = self.predicate.skip_binder().self_ty().sty {\n+            // We can resolve the `impl Trait` to its concrete type.\n+            if let Some(ty_scheme) = tcx.opt_lookup_item_type(def_id) {\n+                let concrete_ty = ty_scheme.ty.subst(tcx, substs);\n+                let concrete_substs = Substs::new_trait(vec![], vec![], concrete_ty);\n+                let predicate = ty::TraitRef {\n+                    def_id: self.predicate.def_id(),\n+                    substs: tcx.mk_substs(concrete_substs)\n+                }.to_predicate();\n+\n+                let original_obligation = Obligation::new(self.cause.clone(),\n+                                                          self.predicate.clone());\n+                let cause = original_obligation.derived_cause(BuiltinDerivedObligation);\n+                return Some(vec![Obligation::new(cause, predicate)]);\n+            }\n+        }\n+\n+        None\n+    }\n+\n+    /// Return the `PredicateObligation` this was created from.\n+    pub fn to_obligation(&self) -> PredicateObligation<'tcx> {\n+        let predicate = ty::Predicate::Trait(self.predicate.clone());\n+        Obligation::new(self.cause.clone(), predicate)\n+    }\n+\n+    /// Return an error as if this obligation had failed.\n+    pub fn to_error(&self) -> FulfillmentError<'tcx> {\n+        FulfillmentError::new(self.to_obligation(), CodeSelectionError(Unimplemented))\n+    }\n+}\n+\n impl<'a, 'gcx, 'tcx> FulfillmentContext<'tcx> {\n     /// Creates a new fulfillment context.\n     pub fn new() -> FulfillmentContext<'tcx> {\n         FulfillmentContext {\n             predicates: ObligationForest::new(),\n             rfc1592_obligations: Vec::new(),\n             region_obligations: NodeMap(),\n+            deferred_obligations: vec![],\n         }\n     }\n \n@@ -224,10 +314,16 @@ impl<'a, 'gcx, 'tcx> FulfillmentContext<'tcx> {\n     {\n         self.select_where_possible(infcx)?;\n \n+        // Fail all of the deferred obligations that haven't\n+        // been otherwise removed from the context.\n+        let deferred_errors = self.deferred_obligations.iter()\n+                                  .map(|d| d.to_error());\n+\n         let errors: Vec<_> =\n             self.predicates.to_errors(CodeAmbiguity)\n                            .into_iter()\n                            .map(|e| to_fulfillment_error(e))\n+                           .chain(deferred_errors)\n                            .collect();\n         if errors.is_empty() {\n             Ok(())\n@@ -248,6 +344,10 @@ impl<'a, 'gcx, 'tcx> FulfillmentContext<'tcx> {\n         self.predicates.pending_obligations()\n     }\n \n+    pub fn take_deferred_obligations(&mut self) -> Vec<DeferredObligation<'tcx>> {\n+        mem::replace(&mut self.deferred_obligations, vec![])\n+    }\n+\n     /// Attempts to select obligations using `selcx`. If `only_new_obligations` is true, then it\n     /// only attempts to select obligations that haven't been seen before.\n     fn select(&mut self, selcx: &mut SelectionContext<'a, 'gcx, 'tcx>)\n@@ -261,9 +361,10 @@ impl<'a, 'gcx, 'tcx> FulfillmentContext<'tcx> {\n \n             // Process pending obligations.\n             let outcome = self.predicates.process_obligations(&mut FulfillProcessor {\n-                    selcx: selcx,\n-                    region_obligations: &mut self.region_obligations,\n-                    rfc1592_obligations: &mut self.rfc1592_obligations\n+                selcx: selcx,\n+                region_obligations: &mut self.region_obligations,\n+                rfc1592_obligations: &mut self.rfc1592_obligations,\n+                deferred_obligations: &mut self.deferred_obligations\n             });\n             debug!(\"select: outcome={:?}\", outcome);\n \n@@ -298,7 +399,8 @@ impl<'a, 'gcx, 'tcx> FulfillmentContext<'tcx> {\n struct FulfillProcessor<'a, 'b: 'a, 'gcx: 'tcx, 'tcx: 'b> {\n     selcx: &'a mut SelectionContext<'b, 'gcx, 'tcx>,\n     region_obligations: &'a mut NodeMap<Vec<RegionObligation<'tcx>>>,\n-    rfc1592_obligations: &'a mut Vec<PredicateObligation<'tcx>>\n+    rfc1592_obligations: &'a mut Vec<PredicateObligation<'tcx>>,\n+    deferred_obligations: &'a mut Vec<DeferredObligation<'tcx>>\n }\n \n impl<'a, 'b, 'gcx, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'gcx, 'tcx> {\n@@ -312,7 +414,8 @@ impl<'a, 'b, 'gcx, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'gcx,\n         process_predicate(self.selcx,\n                           obligation,\n                           self.region_obligations,\n-                          self.rfc1592_obligations)\n+                          self.rfc1592_obligations,\n+                          self.deferred_obligations)\n             .map(|os| os.map(|os| os.into_iter().map(|o| PendingPredicateObligation {\n                 obligation: o,\n                 stalled_on: vec![]\n@@ -354,7 +457,8 @@ fn process_predicate<'a, 'gcx, 'tcx>(\n     selcx: &mut SelectionContext<'a, 'gcx, 'tcx>,\n     pending_obligation: &mut PendingPredicateObligation<'tcx>,\n     region_obligations: &mut NodeMap<Vec<RegionObligation<'tcx>>>,\n-    rfc1592_obligations: &mut Vec<PredicateObligation<'tcx>>)\n+    rfc1592_obligations: &mut Vec<PredicateObligation<'tcx>>,\n+    deferred_obligations: &mut Vec<DeferredObligation<'tcx>>)\n     -> Result<Option<Vec<PredicateObligation<'tcx>>>,\n               FulfillmentErrorCode<'tcx>>\n {\n@@ -422,7 +526,22 @@ fn process_predicate<'a, 'gcx, 'tcx>(\n                 Err(selection_err) => {\n                     info!(\"selecting trait `{:?}` at depth {} yielded Err\",\n                           data, obligation.recursion_depth);\n-                    Err(CodeSelectionError(selection_err))\n+\n+                    let defer = DeferredObligation::from_select_error(selcx.tcx(),\n+                                                                      &trait_obligation,\n+                                                                      &selection_err);\n+                    if let Some(deferred_obligation) = defer {\n+                        if let Some(nested) = deferred_obligation.try_select(selcx.tcx()) {\n+                            Ok(Some(nested))\n+                        } else {\n+                            // Pretend that the obligation succeeded,\n+                            // but record it for later.\n+                            deferred_obligations.push(deferred_obligation);\n+                            Ok(Some(vec![]))\n+                        }\n+                    } else {\n+                        Err(CodeSelectionError(selection_err))\n+                    }\n                 }\n             }\n         }\n@@ -629,6 +748,12 @@ impl<'a, 'gcx, 'tcx> GlobalFulfilledPredicates<'gcx> {\n             // already has the required read edges, so we don't need\n             // to add any more edges here.\n             if data.is_global() {\n+                // Don't cache predicates which were fulfilled\n+                // by deferring them for later fulfillment.\n+                if DeferredObligation::must_defer(tcx, data) {\n+                    return;\n+                }\n+\n                 if let Some(data) = tcx.lift_to_global(data) {\n                     if self.set.insert(data.clone()) {\n                         debug!(\"add_if_global: global predicate `{:?}` added\", data);"}, {"sha": "dc0807ba38faea39962ab3f576f55087a11f9223", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/08bf9f69b9cd96cf2871af1c2ec4dad0258728f2/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08bf9f69b9cd96cf2871af1c2ec4dad0258728f2/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=08bf9f69b9cd96cf2871af1c2ec4dad0258728f2", "patch": "@@ -30,6 +30,7 @@ pub use self::coherence::orphan_check;\n pub use self::coherence::overlapping_impls;\n pub use self::coherence::OrphanCheckErr;\n pub use self::fulfill::{FulfillmentContext, GlobalFulfilledPredicates, RegionObligation};\n+pub use self::fulfill::DeferredObligation;\n pub use self::project::MismatchedProjectionTypes;\n pub use self::project::{normalize, normalize_projection_type, Normalized};\n pub use self::project::{ProjectionCache, ProjectionCacheSnapshot, Reveal};"}, {"sha": "2df492e507bdcd5ea0b7757370201b18a997206c", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/08bf9f69b9cd96cf2871af1c2ec4dad0258728f2/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08bf9f69b9cd96cf2871af1c2ec4dad0258728f2/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=08bf9f69b9cd96cf2871af1c2ec4dad0258728f2", "patch": "@@ -2128,7 +2128,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                           obligation)\n             };\n \n-            let cause = self.derived_cause(obligation, BuiltinDerivedObligation);\n+            let cause = obligation.derived_cause(BuiltinDerivedObligation);\n             self.collect_predicates_for_types(cause,\n                                               obligation.recursion_depth+1,\n                                               trait_def,\n@@ -2208,7 +2208,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     {\n         debug!(\"vtable_default_impl: nested={:?}\", nested);\n \n-        let cause = self.derived_cause(obligation, BuiltinDerivedObligation);\n+        let cause = obligation.derived_cause(BuiltinDerivedObligation);\n         let mut obligations = self.collect_predicates_for_types(\n             cause,\n             obligation.recursion_depth+1,\n@@ -2219,7 +2219,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             let poly_trait_ref = obligation.predicate.to_poly_trait_ref();\n             let (trait_ref, skol_map) =\n                 this.infcx().skolemize_late_bound_regions(&poly_trait_ref, snapshot);\n-            let cause = this.derived_cause(obligation, ImplDerivedObligation);\n+            let cause = obligation.derived_cause(ImplDerivedObligation);\n             this.impl_or_trait_obligations(cause,\n                                            obligation.recursion_depth + 1,\n                                            trait_def_id,\n@@ -2254,7 +2254,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 this.rematch_impl(impl_def_id, obligation,\n                                   snapshot);\n             debug!(\"confirm_impl_candidate substs={:?}\", substs);\n-            let cause = this.derived_cause(obligation, ImplDerivedObligation);\n+            let cause = obligation.derived_cause(ImplDerivedObligation);\n             this.vtable_impl(impl_def_id, substs, cause,\n                              obligation.recursion_depth + 1,\n                              skol_map, snapshot)\n@@ -2907,12 +2907,13 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             }).collect();\n         self.infcx().plug_leaks(skol_map, snapshot, &predicates)\n     }\n+}\n \n+impl<'tcx> TraitObligation<'tcx> {\n     #[allow(unused_comparisons)]\n-    fn derived_cause(&self,\n-                     obligation: &TraitObligation<'tcx>,\n-                     variant: fn(DerivedObligationCause<'tcx>) -> ObligationCauseCode<'tcx>)\n-                     -> ObligationCause<'tcx>\n+    pub fn derived_cause(&self,\n+                        variant: fn(DerivedObligationCause<'tcx>) -> ObligationCauseCode<'tcx>)\n+                        -> ObligationCause<'tcx>\n     {\n         /*!\n          * Creates a cause for obligations that are derived from\n@@ -2924,6 +2925,8 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n          * reporting.\n          */\n \n+        let obligation = self;\n+\n         // NOTE(flaper87): As of now, it keeps track of the whole error\n         // chain. Ideally, we should have a way to configure this either\n         // by using -Z verbose or just a CLI argument."}, {"sha": "022566642f646720f467a417e9349fc43a6d010c", "filename": "src/librustc/traits/structural_impls.rs", "status": "modified", "additions": 181, "deletions": 0, "changes": 181, "blob_url": "https://github.com/rust-lang/rust/blob/08bf9f69b9cd96cf2871af1c2ec4dad0258728f2/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08bf9f69b9cd96cf2871af1c2ec4dad0258728f2/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs?ref=08bf9f69b9cd96cf2871af1c2ec4dad0258728f2", "patch": "@@ -14,6 +14,7 @@ use ty::{Lift, TyCtxt};\n use ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n \n use std::fmt;\n+use std::rc::Rc;\n \n // structural impls for the structs in traits\n \n@@ -162,6 +163,86 @@ impl<'a, 'tcx> Lift<'tcx> for traits::SelectionError<'a> {\n     }\n }\n \n+impl<'a, 'tcx> Lift<'tcx> for traits::ObligationCauseCode<'a> {\n+    type Lifted = traits::ObligationCauseCode<'tcx>;\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+        match *self {\n+            super::MiscObligation => Some(super::MiscObligation),\n+            super::SliceOrArrayElem => Some(super::SliceOrArrayElem),\n+            super::TupleElem => Some(super::TupleElem),\n+            super::ProjectionWf(proj) => tcx.lift(&proj).map(super::ProjectionWf),\n+            super::ItemObligation(def_id) => Some(super::ItemObligation(def_id)),\n+            super::ReferenceOutlivesReferent(ty) => {\n+                tcx.lift(&ty).map(super::ReferenceOutlivesReferent)\n+            }\n+            super::ObjectCastObligation(ty) => {\n+                tcx.lift(&ty).map(super::ObjectCastObligation)\n+            }\n+            super::AssignmentLhsSized => Some(super::AssignmentLhsSized),\n+            super::StructInitializerSized => Some(super::StructInitializerSized),\n+            super::VariableType(id) => Some(super::VariableType(id)),\n+            super::ReturnType => Some(super::ReturnType),\n+            super::RepeatVec => Some(super::RepeatVec),\n+            super::ClosureCapture(node_id, span, bound) => {\n+                Some(super::ClosureCapture(node_id, span, bound))\n+            }\n+            super::FieldSized => Some(super::FieldSized),\n+            super::ConstSized => Some(super::ConstSized),\n+            super::SharedStatic => Some(super::SharedStatic),\n+            super::BuiltinDerivedObligation(ref cause) => {\n+                tcx.lift(cause).map(super::BuiltinDerivedObligation)\n+            }\n+            super::ImplDerivedObligation(ref cause) => {\n+                tcx.lift(cause).map(super::ImplDerivedObligation)\n+            }\n+            super::CompareImplMethodObligation => {\n+                Some(super::CompareImplMethodObligation)\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> Lift<'tcx> for traits::DerivedObligationCause<'a> {\n+    type Lifted = traits::DerivedObligationCause<'tcx>;\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+        tcx.lift(&self.parent_trait_ref).and_then(|trait_ref| {\n+            tcx.lift(&*self.parent_code).map(|code| {\n+                traits::DerivedObligationCause {\n+                    parent_trait_ref: trait_ref,\n+                    parent_code: Rc::new(code)\n+                }\n+            })\n+        })\n+    }\n+}\n+\n+impl<'a, 'tcx> Lift<'tcx> for traits::ObligationCause<'a> {\n+    type Lifted = traits::ObligationCause<'tcx>;\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+        tcx.lift(&self.code).map(|code| {\n+            traits::ObligationCause {\n+                span: self.span,\n+                body_id: self.body_id,\n+                code: code,\n+            }\n+        })\n+    }\n+}\n+\n+impl<'a, 'tcx> Lift<'tcx> for traits::DeferredObligation<'a> {\n+    type Lifted = traits::DeferredObligation<'tcx>;\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+        tcx.lift(&self.predicate).and_then(|predicate| {\n+            tcx.lift(&self.cause).map(|cause| {\n+                traits::DeferredObligation {\n+                    predicate: predicate,\n+                    cause: cause\n+                }\n+            })\n+        })\n+    }\n+}\n+\n // For trans only.\n impl<'a, 'tcx> Lift<'tcx> for traits::Vtable<'a, ()> {\n     type Lifted = traits::Vtable<'tcx, ()>;\n@@ -361,3 +442,103 @@ impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Normalized<'tcx, T> {\n         self.value.visit_with(visitor) || self.obligations.visit_with(visitor)\n     }\n }\n+\n+impl<'tcx> TypeFoldable<'tcx> for traits::ObligationCauseCode<'tcx> {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n+        match *self {\n+            super::MiscObligation |\n+            super::SliceOrArrayElem |\n+            super::TupleElem |\n+            super::ItemObligation(_) |\n+            super::AssignmentLhsSized |\n+            super::StructInitializerSized |\n+            super::VariableType(_) |\n+            super::ReturnType |\n+            super::RepeatVec |\n+            super::ClosureCapture(..) |\n+            super::FieldSized |\n+            super::ConstSized |\n+            super::SharedStatic |\n+            super::CompareImplMethodObligation => self.clone(),\n+\n+            super::ProjectionWf(proj) => super::ProjectionWf(proj.fold_with(folder)),\n+            super::ReferenceOutlivesReferent(ty) => {\n+                super::ReferenceOutlivesReferent(ty.fold_with(folder))\n+            }\n+            super::ObjectCastObligation(ty) => {\n+                super::ObjectCastObligation(ty.fold_with(folder))\n+            }\n+            super::BuiltinDerivedObligation(ref cause) => {\n+                super::BuiltinDerivedObligation(cause.fold_with(folder))\n+            }\n+            super::ImplDerivedObligation(ref cause) => {\n+                super::ImplDerivedObligation(cause.fold_with(folder))\n+            }\n+        }\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        match *self {\n+            super::MiscObligation |\n+            super::SliceOrArrayElem |\n+            super::TupleElem |\n+            super::ItemObligation(_) |\n+            super::AssignmentLhsSized |\n+            super::StructInitializerSized |\n+            super::VariableType(_) |\n+            super::ReturnType |\n+            super::RepeatVec |\n+            super::ClosureCapture(..) |\n+            super::FieldSized |\n+            super::ConstSized |\n+            super::SharedStatic |\n+            super::CompareImplMethodObligation => false,\n+\n+            super::ProjectionWf(proj) => proj.visit_with(visitor),\n+            super::ReferenceOutlivesReferent(ty) => ty.visit_with(visitor),\n+            super::ObjectCastObligation(ty) => ty.visit_with(visitor),\n+            super::BuiltinDerivedObligation(ref cause) => cause.visit_with(visitor),\n+            super::ImplDerivedObligation(ref cause) => cause.visit_with(visitor)\n+        }\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for traits::DerivedObligationCause<'tcx> {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n+        traits::DerivedObligationCause {\n+            parent_trait_ref: self.parent_trait_ref.fold_with(folder),\n+            parent_code: self.parent_code.fold_with(folder)\n+        }\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        self.parent_trait_ref.visit_with(visitor) || self.parent_code.visit_with(visitor)\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for traits::ObligationCause<'tcx> {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n+        traits::ObligationCause {\n+            span: self.span,\n+            body_id: self.body_id,\n+            code: self.code.fold_with(folder),\n+        }\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        self.code.visit_with(visitor)\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for traits::DeferredObligation<'tcx> {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n+        traits::DeferredObligation {\n+            predicate: self.predicate.fold_with(folder),\n+            cause: self.cause.fold_with(folder)\n+        }\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        self.predicate.visit_with(visitor) || self.cause.visit_with(visitor)\n+    }\n+}"}, {"sha": "8e89b3c60879f4555d8f95d57493e61b44d2d38a", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/08bf9f69b9cd96cf2871af1c2ec4dad0258728f2/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08bf9f69b9cd96cf2871af1c2ec4dad0258728f2/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=08bf9f69b9cd96cf2871af1c2ec4dad0258728f2", "patch": "@@ -1404,9 +1404,13 @@ impl<'a, 'tcx> ParameterEnvironment<'tcx> {\n                     }\n                 }\n             }\n-            Some(ast_map::NodeExpr(..)) => {\n+            Some(ast_map::NodeExpr(expr)) => {\n                 // This is a convenience to allow closures to work.\n-                ParameterEnvironment::for_item(tcx, tcx.map.get_parent(id))\n+                if let hir::ExprClosure(..) = expr.node {\n+                    ParameterEnvironment::for_item(tcx, tcx.map.get_parent(id))\n+                } else {\n+                    tcx.empty_parameter_environment()\n+                }\n             }\n             Some(ast_map::NodeForeignItem(item)) => {\n                 let def_id = tcx.map.local_def_id(id);"}, {"sha": "8c10806fda768a46c0e31a9103470d5273f939e5", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/08bf9f69b9cd96cf2871af1c2ec4dad0258728f2/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08bf9f69b9cd96cf2871af1c2ec4dad0258728f2/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=08bf9f69b9cd96cf2871af1c2ec4dad0258728f2", "patch": "@@ -115,16 +115,26 @@ impl<'tcx, A: Copy+Lift<'tcx>, B: Copy+Lift<'tcx>> Lift<'tcx> for ty::OutlivesPr\n     }\n }\n \n+impl<'a, 'tcx> Lift<'tcx> for ty::ProjectionTy<'a> {\n+    type Lifted = ty::ProjectionTy<'tcx>;\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>)\n+                             -> Option<ty::ProjectionTy<'tcx>> {\n+        tcx.lift(&self.trait_ref).map(|trait_ref| {\n+            ty::ProjectionTy {\n+                trait_ref: trait_ref,\n+                item_name: self.item_name\n+            }\n+        })\n+    }\n+}\n+\n impl<'a, 'tcx> Lift<'tcx> for ty::ProjectionPredicate<'a> {\n     type Lifted = ty::ProjectionPredicate<'tcx>;\n     fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>)\n                              -> Option<ty::ProjectionPredicate<'tcx>> {\n-        tcx.lift(&(self.projection_ty.trait_ref, self.ty)).map(|(trait_ref, ty)| {\n+        tcx.lift(&(self.projection_ty, self.ty)).map(|(projection_ty, ty)| {\n             ty::ProjectionPredicate {\n-                projection_ty: ty::ProjectionTy {\n-                    trait_ref: trait_ref,\n-                    item_name: self.projection_ty.item_name\n-                },\n+                projection_ty: projection_ty,\n                 ty: ty\n             }\n         })"}, {"sha": "c2c93161ce703473e02f90bb0928809b7cb03aed", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 110, "deletions": 125, "changes": 235, "blob_url": "https://github.com/rust-lang/rust/blob/08bf9f69b9cd96cf2871af1c2ec4dad0258728f2/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08bf9f69b9cd96cf2871af1c2ec4dad0258728f2/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=08bf9f69b9cd96cf2871af1c2ec4dad0258728f2", "patch": "@@ -178,6 +178,10 @@ pub struct Inherited<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     // variables to get the concrete type, which can be used to\n     // deanonymize TyAnon, after typeck is done with all functions.\n     anon_types: RefCell<DefIdMap<Ty<'tcx>>>,\n+\n+    // Obligations which will have to be checked at the end of\n+    // type-checking, after all functions have been inferred.\n+    deferred_obligations: RefCell<Vec<traits::DeferredObligation<'tcx>>>,\n }\n \n impl<'a, 'gcx, 'tcx> Deref for Inherited<'a, 'gcx, 'tcx> {\n@@ -390,12 +394,13 @@ pub struct InheritedBuilder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n }\n \n impl<'a, 'gcx, 'tcx> CrateCtxt<'a, 'gcx> {\n-    pub fn inherited(&'a self, param_env: Option<ty::ParameterEnvironment<'gcx>>)\n+    pub fn inherited(&'a self, id: ast::NodeId)\n                      -> InheritedBuilder<'a, 'gcx, 'tcx> {\n+        let param_env = ParameterEnvironment::for_item(self.tcx, id);\n         InheritedBuilder {\n             ccx: self,\n             infcx: self.tcx.infer_ctxt(Some(ty::Tables::empty()),\n-                                       param_env,\n+                                       Some(param_env),\n                                        Reveal::NotSpecializable)\n         }\n     }\n@@ -415,6 +420,7 @@ impl<'a, 'gcx, 'tcx> InheritedBuilder<'a, 'gcx, 'tcx> {\n                 deferred_call_resolutions: RefCell::new(DefIdMap()),\n                 deferred_cast_checks: RefCell::new(Vec::new()),\n                 anon_types: RefCell::new(DefIdMap()),\n+                deferred_obligations: RefCell::new(Vec::new()),\n             })\n         })\n     }\n@@ -449,7 +455,7 @@ impl<'a, 'tcx> Visitor<'tcx> for CheckItemTypesVisitor<'a, 'tcx> {\n     fn visit_ty(&mut self, t: &'tcx hir::Ty) {\n         match t.node {\n             hir::TyFixedLengthVec(_, ref expr) => {\n-                check_const_in_type(self.ccx, &expr, self.ccx.tcx.types.usize);\n+                check_const_with_type(self.ccx, &expr, self.ccx.tcx.types.usize, expr.id);\n             }\n             _ => {}\n         }\n@@ -482,6 +488,31 @@ pub fn check_item_bodies(ccx: &CrateCtxt) -> CompileResult {\n     ccx.tcx.sess.track_errors(|| {\n         let mut visit = CheckItemBodiesVisitor { ccx: ccx };\n         ccx.tcx.visit_all_items_in_krate(DepNode::TypeckItemBody, &mut visit);\n+\n+        // Process deferred obligations, now that all functions\n+        // bodies have been fully inferred.\n+        for (&item_id, obligations) in ccx.deferred_obligations.borrow().iter() {\n+            // Use the same DepNode as for the body of the original function/item.\n+            let def_id = ccx.tcx.map.local_def_id(item_id);\n+            let _task = ccx.tcx.dep_graph.in_task(DepNode::TypeckItemBody(def_id));\n+\n+            let param_env = ParameterEnvironment::for_item(ccx.tcx, item_id);\n+            ccx.tcx.infer_ctxt(None, Some(param_env),\n+                               Reveal::NotSpecializable).enter(|infcx| {\n+                let mut fulfillment_cx = traits::FulfillmentContext::new();\n+                for obligation in obligations.iter().map(|o| o.to_obligation()) {\n+                    fulfillment_cx.register_predicate_obligation(&infcx, obligation);\n+                }\n+\n+                if let Err(errors) = fulfillment_cx.select_all_or_error(&infcx) {\n+                    infcx.report_fulfillment_errors(&errors);\n+                }\n+\n+                if let Err(errors) = fulfillment_cx.select_rfc1592_obligations(&infcx) {\n+                    infcx.report_fulfillment_errors_as_warnings(&errors, item_id);\n+                }\n+            });\n+        }\n     })\n }\n \n@@ -508,17 +539,14 @@ pub fn check_drop_impls(ccx: &CrateCtxt) -> CompileResult {\n fn check_bare_fn<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                            decl: &'tcx hir::FnDecl,\n                            body: &'tcx hir::Block,\n-                           fn_id: ast::NodeId,\n-                           fn_span: Span,\n-                           raw_fty: Ty<'tcx>,\n-                           param_env: ty::ParameterEnvironment<'tcx>)\n-{\n+                           fn_id: ast::NodeId) {\n+    let raw_fty = ccx.tcx.lookup_item_type(ccx.tcx.map.local_def_id(fn_id)).ty;\n     let fn_ty = match raw_fty.sty {\n         ty::TyFnDef(_, _, f) => f,\n         _ => span_bug!(body.span, \"check_bare_fn: function type expected\")\n     };\n \n-    ccx.inherited(Some(param_env)).enter(|inh| {\n+    ccx.inherited(fn_id).enter(|inh| {\n         // Compute the fty from point of view of inside fn.\n         let fn_scope = inh.tcx.region_maps.call_site_extent(fn_id, body.id);\n         let fn_sig =\n@@ -536,8 +564,8 @@ fn check_bare_fn<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         fcx.check_casts();\n         fcx.select_all_obligations_or_error(); // Casts can introduce new obligations.\n \n-        fcx.regionck_fn(fn_id, fn_span, decl, body);\n-        fcx.resolve_type_vars_in_fn(decl, body);\n+        fcx.regionck_fn(fn_id, decl, body);\n+        fcx.resolve_type_vars_in_fn(decl, body, fn_id);\n     });\n }\n \n@@ -711,7 +739,7 @@ pub fn check_item_type<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx hir::Item) {\n     match it.node {\n       // Consts can play a role in type-checking, so they are included here.\n       hir::ItemStatic(_, _, ref e) |\n-      hir::ItemConst(_, ref e) => check_const(ccx, it.span, &e, it.id),\n+      hir::ItemConst(_, ref e) => check_const(ccx, &e, it.id),\n       hir::ItemEnum(ref enum_definition, _) => {\n         check_enum_variants(ccx,\n                             it.span,\n@@ -790,23 +818,18 @@ pub fn check_item_body<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx hir::Item) {\n     let _indenter = indenter();\n     match it.node {\n       hir::ItemFn(ref decl, _, _, _, _, ref body) => {\n-        let fn_pty = ccx.tcx.lookup_item_type(ccx.tcx.map.local_def_id(it.id));\n-        let param_env = ParameterEnvironment::for_item(ccx.tcx, it.id);\n-        check_bare_fn(ccx, &decl, &body, it.id, it.span, fn_pty.ty, param_env);\n+        check_bare_fn(ccx, &decl, &body, it.id);\n       }\n       hir::ItemImpl(_, _, _, _, _, ref impl_items) => {\n         debug!(\"ItemImpl {} with id {}\", it.name, it.id);\n \n-        let impl_pty = ccx.tcx.lookup_item_type(ccx.tcx.map.local_def_id(it.id));\n-\n         for impl_item in impl_items {\n             match impl_item.node {\n                 hir::ImplItemKind::Const(_, ref expr) => {\n-                    check_const(ccx, impl_item.span, &expr, impl_item.id)\n+                    check_const(ccx, &expr, impl_item.id)\n                 }\n                 hir::ImplItemKind::Method(ref sig, ref body) => {\n-                    check_method_body(ccx, &impl_pty.generics, sig, body,\n-                                      impl_item.id, impl_item.span);\n+                    check_bare_fn(ccx, &sig.decl, body, impl_item.id);\n                 }\n                 hir::ImplItemKind::Type(_) => {\n                     // Nothing to do here.\n@@ -815,17 +838,15 @@ pub fn check_item_body<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx hir::Item) {\n         }\n       }\n       hir::ItemTrait(_, _, _, ref trait_items) => {\n-        let trait_def = ccx.tcx.lookup_trait_def(ccx.tcx.map.local_def_id(it.id));\n         for trait_item in trait_items {\n             match trait_item.node {\n                 hir::ConstTraitItem(_, Some(ref expr)) => {\n-                    check_const(ccx, trait_item.span, &expr, trait_item.id)\n+                    check_const(ccx, &expr, trait_item.id)\n                 }\n                 hir::MethodTraitItem(ref sig, Some(ref body)) => {\n                     check_trait_fn_not_const(ccx, trait_item.span, sig.constness);\n \n-                    check_method_body(ccx, &trait_def.generics, sig, body,\n-                                      trait_item.id, trait_item.span);\n+                    check_bare_fn(ccx, &sig.decl, body, trait_item.id);\n                 }\n                 hir::MethodTraitItem(ref sig, None) => {\n                     check_trait_fn_not_const(ccx, trait_item.span, sig.constness);\n@@ -902,29 +923,6 @@ fn check_on_unimplemented<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     }\n }\n \n-/// Type checks a method body.\n-///\n-/// # Parameters\n-///\n-/// * `item_generics`: generics defined on the impl/trait that contains\n-///   the method\n-/// * `self_bound`: bound for the `Self` type parameter, if any\n-/// * `method`: the method definition\n-fn check_method_body<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n-                               item_generics: &ty::Generics<'tcx>,\n-                               sig: &'tcx hir::MethodSig,\n-                               body: &'tcx hir::Block,\n-                               id: ast::NodeId, span: Span) {\n-    debug!(\"check_method_body(item_generics={:?}, id={})\",\n-            item_generics, id);\n-    let param_env = ParameterEnvironment::for_item(ccx.tcx, id);\n-\n-    let fty = ccx.tcx.node_id_to_type(id);\n-    debug!(\"check_method_body: fty={:?}\", fty);\n-\n-    check_bare_fn(ccx, &sig.decl, body, id, span, fty, param_env);\n-}\n-\n fn report_forbidden_specialization<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                              impl_item: &hir::ImplItem,\n                                              parent_impl: DefId)\n@@ -1163,30 +1161,39 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     }\n }\n \n-/// Checks a constant appearing in a type. At the moment this is just the\n-/// length expression in a fixed-length vector, but someday it might be\n-/// extended to type-level numeric literals.\n-fn check_const_in_type<'a,'tcx>(ccx: &'a CrateCtxt<'a,'tcx>,\n-                                expr: &'tcx hir::Expr,\n-                                expected_type: Ty<'tcx>) {\n-    ccx.inherited(None).enter(|inh| {\n+/// Checks a constant with a given type.\n+fn check_const_with_type<'a, 'tcx>(ccx: &'a CrateCtxt<'a, 'tcx>,\n+                                   expr: &'tcx hir::Expr,\n+                                   expected_type: Ty<'tcx>,\n+                                   id: ast::NodeId) {\n+    ccx.inherited(id).enter(|inh| {\n         let fcx = FnCtxt::new(&inh, ty::FnConverging(expected_type), expr.id);\n-        fcx.check_const_with_ty(expr.span, expr, expected_type);\n+        fcx.require_type_is_sized(expected_type, expr.span, traits::ConstSized);\n+\n+        // Gather locals in statics (because of block expressions).\n+        // This is technically unnecessary because locals in static items are forbidden,\n+        // but prevents type checking from blowing up before const checking can properly\n+        // emit an error.\n+        GatherLocalsVisitor { fcx: &fcx }.visit_expr(expr);\n+\n+        fcx.check_expr_coercable_to_type(expr, expected_type);\n+\n+        fcx.select_all_obligations_and_apply_defaults();\n+        fcx.closure_analyze_const(expr);\n+        fcx.select_obligations_where_possible();\n+        fcx.check_casts();\n+        fcx.select_all_obligations_or_error();\n+\n+        fcx.regionck_expr(expr);\n+        fcx.resolve_type_vars_in_expr(expr, id);\n     });\n }\n \n-fn check_const<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n-                        sp: Span,\n-                        e: &'tcx hir::Expr,\n-                        id: ast::NodeId) {\n-    let param_env = ParameterEnvironment::for_item(ccx.tcx, id);\n-    ccx.inherited(Some(param_env)).enter(|inh| {\n-        let rty = ccx.tcx.node_id_to_type(id);\n-        let fcx = FnCtxt::new(&inh, ty::FnConverging(rty), e.id);\n-        let declty = fcx.tcx.lookup_item_type(ccx.tcx.map.local_def_id(id)).ty;\n-        fcx.require_type_is_sized(declty, e.span, traits::ConstSized);\n-        fcx.check_const_with_ty(sp, e, declty);\n-    });\n+fn check_const<'a, 'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n+                         expr: &'tcx hir::Expr,\n+                         id: ast::NodeId) {\n+    let decl_ty = ccx.tcx.lookup_item_type(ccx.tcx.map.local_def_id(id)).ty;\n+    check_const_with_type(ccx, expr, decl_ty, id);\n }\n \n /// Checks whether a type can be represented in memory. In particular, it\n@@ -1255,45 +1262,40 @@ pub fn check_enum_variants<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n             \"unsupported representation for zero-variant enum\");\n     }\n \n-    ccx.inherited(None).enter(|inh| {\n-        let rty = ccx.tcx.node_id_to_type(id);\n-        let fcx = FnCtxt::new(&inh, ty::FnConverging(rty), id);\n-\n-        let repr_type_ty = ccx.tcx.enum_repr_type(Some(&hint)).to_ty(ccx.tcx);\n-        for v in vs {\n-            if let Some(ref e) = v.node.disr_expr {\n-                fcx.check_const_with_ty(e.span, e, repr_type_ty);\n-            }\n+    let repr_type_ty = ccx.tcx.enum_repr_type(Some(&hint)).to_ty(ccx.tcx);\n+    for v in vs {\n+        if let Some(ref e) = v.node.disr_expr {\n+            check_const_with_type(ccx, e, repr_type_ty, e.id);\n         }\n+    }\n \n-        let def_id = ccx.tcx.map.local_def_id(id);\n-\n-        let variants = &ccx.tcx.lookup_adt_def(def_id).variants;\n-        let mut disr_vals: Vec<ty::Disr> = Vec::new();\n-        for (v, variant) in vs.iter().zip(variants.iter()) {\n-            let current_disr_val = variant.disr_val;\n+    let def_id = ccx.tcx.map.local_def_id(id);\n \n-            // Check for duplicate discriminant values\n-            if let Some(i) = disr_vals.iter().position(|&x| x == current_disr_val) {\n-                let variant_i_node_id = ccx.tcx.map.as_local_node_id(variants[i].did).unwrap();\n-                let variant_i = ccx.tcx.map.expect_variant(variant_i_node_id);\n-                let i_span = match variant_i.node.disr_expr {\n-                    Some(ref expr) => expr.span,\n-                    None => ccx.tcx.map.span(variant_i_node_id)\n-                };\n-                let span = match v.node.disr_expr {\n-                    Some(ref expr) => expr.span,\n-                    None => v.span\n-                };\n-                struct_span_err!(ccx.tcx.sess, span, E0081,\n-                                 \"discriminant value `{}` already exists\", disr_vals[i])\n-                    .span_label(i_span, &format!(\"first use of `{}`\", disr_vals[i]))\n-                    .span_label(span , &format!(\"enum already has `{}`\", disr_vals[i]))\n-                    .emit();\n-            }\n-            disr_vals.push(current_disr_val);\n+    let variants = &ccx.tcx.lookup_adt_def(def_id).variants;\n+    let mut disr_vals: Vec<ty::Disr> = Vec::new();\n+    for (v, variant) in vs.iter().zip(variants.iter()) {\n+        let current_disr_val = variant.disr_val;\n+\n+        // Check for duplicate discriminant values\n+        if let Some(i) = disr_vals.iter().position(|&x| x == current_disr_val) {\n+            let variant_i_node_id = ccx.tcx.map.as_local_node_id(variants[i].did).unwrap();\n+            let variant_i = ccx.tcx.map.expect_variant(variant_i_node_id);\n+            let i_span = match variant_i.node.disr_expr {\n+                Some(ref expr) => expr.span,\n+                None => ccx.tcx.map.span(variant_i_node_id)\n+            };\n+            let span = match v.node.disr_expr {\n+                Some(ref expr) => expr.span,\n+                None => v.span\n+            };\n+            struct_span_err!(ccx.tcx.sess, span, E0081,\n+                             \"discriminant value `{}` already exists\", disr_vals[i])\n+                .span_label(i_span, &format!(\"first use of `{}`\", disr_vals[i]))\n+                .span_label(span , &format!(\"enum already has `{}`\", disr_vals[i]))\n+                .emit();\n         }\n-    });\n+        disr_vals.push(current_disr_val);\n+    }\n \n     check_representable(ccx.tcx, sp, id, \"enum\");\n }\n@@ -2228,6 +2230,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         self.select_all_obligations_and_apply_defaults();\n \n         let mut fulfillment_cx = self.fulfillment_cx.borrow_mut();\n+\n+        // Steal the deferred obligations before the fulfillment\n+        // context can turn all of them into errors.\n+        let obligations = fulfillment_cx.take_deferred_obligations();\n+        self.deferred_obligations.borrow_mut().extend(obligations);\n+\n         match fulfillment_cx.select_all_or_error(self) {\n             Ok(()) => { }\n             Err(errors) => { self.report_fulfillment_errors(&errors); }\n@@ -4036,29 +4044,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         *self.ps.borrow_mut() = prev;\n     }\n \n-\n-    fn check_const_with_ty(&self,\n-                           _: Span,\n-                           e: &'gcx hir::Expr,\n-                           declty: Ty<'tcx>) {\n-        // Gather locals in statics (because of block expressions).\n-        // This is technically unnecessary because locals in static items are forbidden,\n-        // but prevents type checking from blowing up before const checking can properly\n-        // emit an error.\n-        GatherLocalsVisitor { fcx: self }.visit_expr(e);\n-\n-        self.check_expr_coercable_to_type(e, declty);\n-\n-        self.select_all_obligations_and_apply_defaults();\n-        self.closure_analyze_const(e);\n-        self.select_obligations_where_possible();\n-        self.check_casts();\n-        self.select_all_obligations_or_error();\n-\n-        self.regionck_expr(e);\n-        self.resolve_type_vars_in_expr(e);\n-    }\n-\n     // Returns the type parameter count and the type for the given definition.\n     fn type_scheme_and_predicates_for_def(&self,\n                                           sp: Span,"}, {"sha": "f3a6442f35d1127721bf424710b864d8e4d26847", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/08bf9f69b9cd96cf2871af1c2ec4dad0258728f2/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08bf9f69b9cd96cf2871af1c2ec4dad0258728f2/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=08bf9f69b9cd96cf2871af1c2ec4dad0258728f2", "patch": "@@ -141,15 +141,14 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n     pub fn regionck_fn(&self,\n                        fn_id: ast::NodeId,\n-                       fn_span: Span,\n                        decl: &hir::FnDecl,\n                        blk: &hir::Block) {\n         debug!(\"regionck_fn(id={})\", fn_id);\n         let mut rcx = RegionCtxt::new(self, RepeatingScope(blk.id), blk.id, Subject(fn_id));\n \n         if self.err_count_since_creation() == 0 {\n             // regionck assumes typeck succeeded\n-            rcx.visit_fn_body(fn_id, decl, blk, fn_span);\n+            rcx.visit_fn_body(fn_id, decl, blk, self.tcx.map.span(fn_id));\n         }\n \n         rcx.free_region_map.relate_free_regions_from_predicates("}, {"sha": "e2080906ca24294c9f029cdbcfbe7a6bf1e08c8a", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/08bf9f69b9cd96cf2871af1c2ec4dad0258728f2/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08bf9f69b9cd96cf2871af1c2ec4dad0258728f2/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=08bf9f69b9cd96cf2871af1c2ec4dad0258728f2", "patch": "@@ -209,9 +209,8 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n \n     fn for_id<'tcx>(&self, id: ast::NodeId, span: Span)\n                     -> CheckWfFcxBuilder<'ccx, 'gcx, 'tcx> {\n-        let param_env = ty::ParameterEnvironment::for_item(self.ccx.tcx, id);\n         CheckWfFcxBuilder {\n-            inherited: self.ccx.inherited(Some(param_env)),\n+            inherited: self.ccx.inherited(id),\n             code: self.code.clone(),\n             id: id,\n             span: span"}, {"sha": "9026920e7f48abb0936f7e02165516c39bc5e72a", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 28, "deletions": 5, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/08bf9f69b9cd96cf2871af1c2ec4dad0258728f2/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08bf9f69b9cd96cf2871af1c2ec4dad0258728f2/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=08bf9f69b9cd96cf2871af1c2ec4dad0258728f2", "patch": "@@ -37,17 +37,21 @@ use rustc::hir::{self, PatKind};\n // Entry point functions\n \n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n-    pub fn resolve_type_vars_in_expr(&self, e: &hir::Expr) {\n+    pub fn resolve_type_vars_in_expr(&self, e: &hir::Expr, item_id: ast::NodeId) {\n         assert_eq!(self.writeback_errors.get(), false);\n         let mut wbcx = WritebackCx::new(self);\n         wbcx.visit_expr(e);\n         wbcx.visit_upvar_borrow_map();\n         wbcx.visit_closures();\n         wbcx.visit_liberated_fn_sigs();\n         wbcx.visit_fru_field_types();\n+        wbcx.visit_deferred_obligations(item_id);\n     }\n \n-    pub fn resolve_type_vars_in_fn(&self, decl: &hir::FnDecl, blk: &hir::Block) {\n+    pub fn resolve_type_vars_in_fn(&self,\n+                                   decl: &hir::FnDecl,\n+                                   blk: &hir::Block,\n+                                   item_id: ast::NodeId) {\n         assert_eq!(self.writeback_errors.get(), false);\n         let mut wbcx = WritebackCx::new(self);\n         wbcx.visit_block(blk);\n@@ -65,6 +69,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         wbcx.visit_liberated_fn_sigs();\n         wbcx.visit_fru_field_types();\n         wbcx.visit_anon_types();\n+        wbcx.visit_deferred_obligations(item_id);\n     }\n }\n \n@@ -445,6 +450,19 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n         }\n     }\n \n+    fn visit_deferred_obligations(&self, item_id: ast::NodeId) {\n+        let deferred_obligations = self.fcx.deferred_obligations.borrow();\n+        let obligations: Vec<_> = deferred_obligations.iter().map(|obligation| {\n+            let reason = ResolvingDeferredObligation(obligation.cause.span);\n+            self.resolve(obligation, reason)\n+        }).collect();\n+\n+        if !obligations.is_empty() {\n+            assert!(self.fcx.ccx.deferred_obligations.borrow_mut()\n+                                .insert(item_id, obligations).is_none());\n+        }\n+    }\n+\n     fn resolve<T>(&self, x: &T, reason: ResolveReason) -> T::Lifted\n         where T: TypeFoldable<'tcx> + ty::Lift<'gcx>\n     {\n@@ -461,7 +479,7 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n ///////////////////////////////////////////////////////////////////////////\n // Resolution reason.\n \n-#[derive(Copy, Clone)]\n+#[derive(Copy, Clone, Debug)]\n enum ResolveReason {\n     ResolvingExpr(Span),\n     ResolvingLocal(Span),\n@@ -471,6 +489,7 @@ enum ResolveReason {\n     ResolvingFnSig(ast::NodeId),\n     ResolvingFieldTypes(ast::NodeId),\n     ResolvingAnonTy(DefId),\n+    ResolvingDeferredObligation(Span),\n }\n \n impl<'a, 'gcx, 'tcx> ResolveReason {\n@@ -492,6 +511,7 @@ impl<'a, 'gcx, 'tcx> ResolveReason {\n             ResolvingAnonTy(did) => {\n                 tcx.map.def_id_span(did, DUMMY_SP)\n             }\n+            ResolvingDeferredObligation(span) => span\n         }\n     }\n }\n@@ -564,14 +584,17 @@ impl<'cx, 'gcx, 'tcx> Resolver<'cx, 'gcx, 'tcx> {\n                               \"cannot determine a type for this closure\")\n                 }\n \n-                ResolvingFnSig(id) | ResolvingFieldTypes(id) => {\n+                ResolvingFnSig(_) |\n+                ResolvingFieldTypes(_) |\n+                ResolvingDeferredObligation(_) => {\n                     // any failures here should also fail when\n                     // resolving the patterns, closure types, or\n                     // something else.\n                     let span = self.reason.span(self.tcx);\n                     self.tcx.sess.delay_span_bug(\n                         span,\n-                        &format!(\"cannot resolve some aspect of data for {:?}\", id));\n+                        &format!(\"cannot resolve some aspect of data for {:?}: {}\",\n+                                 self.reason, e));\n                 }\n \n                 ResolvingAnonTy(_) => {"}, {"sha": "0dd4bc4143927ce6dd0081a4e8767d3c727cb30d", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/08bf9f69b9cd96cf2871af1c2ec4dad0258728f2/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08bf9f69b9cd96cf2871af1c2ec4dad0258728f2/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=08bf9f69b9cd96cf2871af1c2ec4dad0258728f2", "patch": "@@ -107,7 +107,7 @@ use hir::map as hir_map;\n use rustc::infer::TypeOrigin;\n use rustc::ty::subst::Substs;\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n-use rustc::traits::Reveal;\n+use rustc::traits::{self, Reveal};\n use session::{config, CompileResult};\n use util::common::time;\n \n@@ -150,6 +150,11 @@ pub struct CrateCtxt<'a, 'tcx: 'a> {\n     pub stack: RefCell<Vec<collect::AstConvRequest>>,\n \n     pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+\n+    /// Obligations which will have to be checked at the end of\n+    /// type-checking, after all functions have been inferred.\n+    /// The key is the NodeId of the item the obligations were from.\n+    pub deferred_obligations: RefCell<NodeMap<Vec<traits::DeferredObligation<'tcx>>>>,\n }\n \n // Functions that write types into the node type table\n@@ -328,7 +333,8 @@ pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>)\n         ast_ty_to_ty_cache: RefCell::new(NodeMap()),\n         all_traits: RefCell::new(None),\n         stack: RefCell::new(Vec::new()),\n-        tcx: tcx\n+        tcx: tcx,\n+        deferred_obligations: RefCell::new(NodeMap()),\n     };\n \n     // this ensures that later parts of type checking can assume that items"}, {"sha": "2c78ce2db29afe76ebf64ff08ea381c4e4f45e47", "filename": "src/test/compile-fail/impl-trait/auto-trait-leak.rs", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/08bf9f69b9cd96cf2871af1c2ec4dad0258728f2/src%2Ftest%2Fcompile-fail%2Fimpl-trait%2Fauto-trait-leak.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08bf9f69b9cd96cf2871af1c2ec4dad0258728f2/src%2Ftest%2Fcompile-fail%2Fimpl-trait%2Fauto-trait-leak.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimpl-trait%2Fauto-trait-leak.rs?ref=08bf9f69b9cd96cf2871af1c2ec4dad0258728f2", "patch": "@@ -0,0 +1,70 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-tidy-linelength\n+\n+#![feature(conservative_impl_trait)]\n+\n+use std::cell::Cell;\n+use std::rc::Rc;\n+\n+// Fast path, main can see the concrete type returned.\n+fn before() -> impl Fn(i32) {\n+    let p = Rc::new(Cell::new(0));\n+    move |x| p.set(x)\n+}\n+\n+fn send<T: Send>(_: T) {}\n+\n+fn main() {\n+    send(before());\n+    //~^ ERROR the trait bound `std::rc::Rc<std::cell::Cell<i32>>: std::marker::Send` is not satisfied\n+    //~| NOTE `std::rc::Rc<std::cell::Cell<i32>>` cannot be sent between threads safely\n+    //~| NOTE required because it appears within the type `[closure\n+    //~| NOTE required because it appears within the type `impl std::ops::Fn<(i32,)>`\n+    //~| NOTE required by `send`\n+\n+    send(after());\n+    //~^ ERROR the trait bound `std::rc::Rc<std::cell::Cell<i32>>: std::marker::Send` is not satisfied\n+    //~| NOTE `std::rc::Rc<std::cell::Cell<i32>>` cannot be sent between threads safely\n+    //~| NOTE required because it appears within the type `[closure\n+    //~| NOTE required because it appears within the type `impl std::ops::Fn<(i32,)>`\n+    //~| NOTE required by `send`\n+}\n+\n+// Deferred path, main has to wait until typeck finishes,\n+// to check if the return type of after is Send.\n+fn after() -> impl Fn(i32) {\n+    let p = Rc::new(Cell::new(0));\n+    move |x| p.set(x)\n+}\n+\n+// Cycles should work as the deferred obligations are\n+// independently resolved and only require the concrete\n+// return type, which can't depend on the obligation.\n+fn cycle1() -> impl Clone {\n+    send(cycle2().clone());\n+    //~^ ERROR the trait bound `std::rc::Rc<std::string::String>: std::marker::Send` is not satisfied\n+    //~| NOTE `std::rc::Rc<std::string::String>` cannot be sent between threads safely\n+    //~| NOTE required because it appears within the type `impl std::clone::Clone`\n+    //~| NOTE required by `send`\n+\n+    Rc::new(Cell::new(5))\n+}\n+\n+fn cycle2() -> impl Clone {\n+    send(cycle1().clone());\n+    //~^ ERROR the trait bound `std::rc::Rc<std::cell::Cell<i32>>: std::marker::Send` is not satisfied\n+    //~| NOTE `std::rc::Rc<std::cell::Cell<i32>>` cannot be sent between threads safely\n+    //~| NOTE required because it appears within the type `impl std::clone::Clone`\n+    //~| NOTE required by `send`\n+\n+    Rc::new(String::from(\"foo\"))\n+}"}, {"sha": "c1201e7fa4f4c589c21f875aa26ef3d659defa71", "filename": "src/test/run-pass/impl-trait/auto-trait-leak.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/08bf9f69b9cd96cf2871af1c2ec4dad0258728f2/src%2Ftest%2Frun-pass%2Fimpl-trait%2Fauto-trait-leak.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08bf9f69b9cd96cf2871af1c2ec4dad0258728f2/src%2Ftest%2Frun-pass%2Fimpl-trait%2Fauto-trait-leak.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fimpl-trait%2Fauto-trait-leak.rs?ref=08bf9f69b9cd96cf2871af1c2ec4dad0258728f2", "patch": "@@ -0,0 +1,44 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(conservative_impl_trait)]\n+\n+// Fast path, main can see the concrete type returned.\n+fn before() -> impl FnMut(i32) {\n+    let mut p = Box::new(0);\n+    move |x| *p = x\n+}\n+\n+fn send<T: Send>(_: T) {}\n+\n+fn main() {\n+    send(before());\n+    send(after());\n+}\n+\n+// Deferred path, main has to wait until typeck finishes,\n+// to check if the return type of after is Send.\n+fn after() -> impl FnMut(i32) {\n+    let mut p = Box::new(0);\n+    move |x| *p = x\n+}\n+\n+// Cycles should work as the deferred obligations are\n+// independently resolved and only require the concrete\n+// return type, which can't depend on the obligation.\n+fn cycle1() -> impl Clone {\n+    send(cycle2().clone());\n+    5\n+}\n+\n+fn cycle2() -> impl Clone {\n+    send(cycle1().clone());\n+    String::from(\"foo\")\n+}"}]}