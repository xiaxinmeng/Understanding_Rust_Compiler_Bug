{"sha": "2e8c522c6206eacb8f8d5e2d30590c4080cbed7a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJlOGM1MjJjNjIwNmVhY2I4ZjhkNWUyZDMwNTkwYzQwODBjYmVkN2E=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-12-20T03:42:00Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-12-22T07:16:50Z"}, "message": "std::vec: make the sorting closure use `Ordering` rather than just being\n(implicitly) less_eq.", "tree": {"sha": "93ebeaa7880139d5ec21114aeec644c872b9c254", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/93ebeaa7880139d5ec21114aeec644c872b9c254"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2e8c522c6206eacb8f8d5e2d30590c4080cbed7a", "comment_count": 4, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2e8c522c6206eacb8f8d5e2d30590c4080cbed7a", "html_url": "https://github.com/rust-lang/rust/commit/2e8c522c6206eacb8f8d5e2d30590c4080cbed7a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2e8c522c6206eacb8f8d5e2d30590c4080cbed7a/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1b1e4caa79077d48c1bf56bf5bfa7bfc83fdf941", "url": "https://api.github.com/repos/rust-lang/rust/commits/1b1e4caa79077d48c1bf56bf5bfa7bfc83fdf941", "html_url": "https://github.com/rust-lang/rust/commit/1b1e4caa79077d48c1bf56bf5bfa7bfc83fdf941"}], "stats": {"total": 258, "additions": 118, "deletions": 140}, "files": [{"sha": "1182d526fa4532fda20847baac00ff3a15703032", "filename": "src/libextra/glob.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2e8c522c6206eacb8f8d5e2d30590c4080cbed7a/src%2Flibextra%2Fglob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e8c522c6206eacb8f8d5e2d30590c4080cbed7a/src%2Flibextra%2Fglob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fglob.rs?ref=2e8c522c6206eacb8f8d5e2d30590c4080cbed7a", "patch": "@@ -148,7 +148,7 @@ impl Iterator<Path> for GlobIterator {\n fn list_dir_sorted(path: &Path) -> ~[Path] {\n     match io::result(|| fs::readdir(path)) {\n         Ok(mut children) => {\n-            children.sort_by(|p1, p2| p2.filename() <= p1.filename());\n+            children.sort_by(|p1, p2| p2.filename().cmp(&p1.filename()));\n             children\n         }\n         Err(..) => ~[]"}, {"sha": "bba7d767732935ec6c3544f642433438fef74b88", "filename": "src/libextra/priority_queue.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2e8c522c6206eacb8f8d5e2d30590c4080cbed7a/src%2Flibextra%2Fpriority_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e8c522c6206eacb8f8d5e2d30590c4080cbed7a/src%2Flibextra%2Fpriority_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fpriority_queue.rs?ref=2e8c522c6206eacb8f8d5e2d30590c4080cbed7a", "patch": "@@ -231,11 +231,7 @@ mod tests {\n     fn test_top_and_pop() {\n         let data = ~[2u, 4, 6, 2, 1, 8, 10, 3, 5, 7, 0, 9, 1];\n         let mut sorted = data.clone();\n-<<<<<<< HEAD\n-        sorted.sort(|x, y| x.le(y));\n-=======\n         sorted.sort();\n->>>>>>> 9ceda35... std::vec: add a sugary .sort() method for plain Ord sorting.\n         let mut heap = PriorityQueue::from_vec(data);\n         while !heap.is_empty() {\n             assert_eq!(heap.top(), sorted.last());"}, {"sha": "5f3700fec07900b1317751a004f3702fdf7dfc9c", "filename": "src/libextra/stats.rs", "status": "modified", "additions": 22, "deletions": 3, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/2e8c522c6206eacb8f8d5e2d30590c4080cbed7a/src%2Flibextra%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e8c522c6206eacb8f8d5e2d30590c4080cbed7a/src%2Flibextra%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fstats.rs?ref=2e8c522c6206eacb8f8d5e2d30590c4080cbed7a", "patch": "@@ -19,6 +19,25 @@ use std::util;\n // NB: this can probably be rewritten in terms of num::Num\n // to be less f64-specific.\n \n+fn f64_cmp(x: f64, y: f64) -> Ordering {\n+    // arbitrarily decide that NaNs are larger than everything.\n+    if y.is_nan() {\n+        Less\n+    } else if x.is_nan() {\n+        Greater\n+    } else if x < y {\n+        Less\n+    } else if x == y {\n+        Equal\n+    } else {\n+        Greater\n+    }\n+}\n+\n+fn f64_sort(v: &mut [f64]) {\n+    v.sort_by(|x: &f64, y: &f64| f64_cmp(*x, *y));\n+}\n+\n /// Trait that provides simple descriptive statistics on a univariate set of numeric samples.\n pub trait Stats {\n \n@@ -239,13 +258,13 @@ impl<'a> Stats for &'a [f64] {\n \n     fn percentile(self, pct: f64) -> f64 {\n         let mut tmp = self.to_owned();\n-        tmp.sort();\n+        f64_sort(tmp);\n         percentile_of_sorted(tmp, pct)\n     }\n \n     fn quartiles(self) -> (f64,f64,f64) {\n         let mut tmp = self.to_owned();\n-        tmp.sort();\n+        f64_sort(tmp);\n         let a = percentile_of_sorted(tmp, 25.0);\n         let b = percentile_of_sorted(tmp, 50.0);\n         let c = percentile_of_sorted(tmp, 75.0);\n@@ -290,7 +309,7 @@ fn percentile_of_sorted(sorted_samples: &[f64],\n /// See: http://en.wikipedia.org/wiki/Winsorising\n pub fn winsorize(samples: &mut [f64], pct: f64) {\n     let mut tmp = samples.to_owned();\n-    tmp.sort();\n+    f64_sort(tmp);\n     let lo = percentile_of_sorted(tmp, pct);\n     let hi = percentile_of_sorted(tmp, 100.0-pct);\n     for samp in samples.mut_iter() {"}, {"sha": "3d6dfd612f25442c31892dc1fa1620f4bd671d69", "filename": "src/libextra/test.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2e8c522c6206eacb8f8d5e2d30590c4080cbed7a/src%2Flibextra%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e8c522c6206eacb8f8d5e2d30590c4080cbed7a/src%2Flibextra%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftest.rs?ref=2e8c522c6206eacb8f8d5e2d30590c4080cbed7a", "patch": "@@ -837,10 +837,7 @@ pub fn filter_tests(\n     };\n \n     // Sort the tests alphabetically\n-    fn lteq(t1: &TestDescAndFn, t2: &TestDescAndFn) -> bool {\n-        t1.desc.name.to_str() <= t2.desc.name.to_str()\n-    }\n-    filtered.sort_by(lteq);\n+    filtered.sort_by(|t1, t2| t1.desc.name.to_str().cmp(&t2.desc.name.to_str()));\n \n     // Shard the remaining tests, if sharding requested.\n     match opts.test_shard {"}, {"sha": "d6c79e7861c7380337c543ea4f5ab686286d8500", "filename": "src/librustc/metadata/cstore.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2e8c522c6206eacb8f8d5e2d30590c4080cbed7a/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e8c522c6206eacb8f8d5e2d30590c4080cbed7a/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcstore.rs?ref=2e8c522c6206eacb8f8d5e2d30590c4080cbed7a", "patch": "@@ -167,7 +167,7 @@ pub fn find_extern_mod_stmt_cnum(cstore: &CStore,\n     cstore.extern_mod_crate_map.find(&emod_id).map(|x| *x)\n }\n \n-#[deriving(Clone)]\n+#[deriving(Clone, TotalEq, TotalOrd)]\n struct crate_hash {\n     name: @str,\n     vers: @str,"}, {"sha": "5b2a51e419f8554cc9a5cff451c72a3be6280af8", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2e8c522c6206eacb8f8d5e2d30590c4080cbed7a/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e8c522c6206eacb8f8d5e2d30590c4080cbed7a/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=2e8c522c6206eacb8f8d5e2d30590c4080cbed7a", "patch": "@@ -1531,7 +1531,7 @@ fn encode_crate_deps(ecx: &EncodeContext,\n         });\n \n         // Sort by cnum\n-        deps.sort_by(|kv1, kv2| kv1.cnum <= kv2.cnum);\n+        deps.sort_by(|kv1, kv2| kv1.cnum.cmp(&kv2.cnum));\n \n         // Sanity-check the crate numbers\n         let mut expected_cnum = 1;"}, {"sha": "948c7932ca0dc592e239a7f84ddca9a3fcf7fed7", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2e8c522c6206eacb8f8d5e2d30590c4080cbed7a/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e8c522c6206eacb8f8d5e2d30590c4080cbed7a/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=2e8c522c6206eacb8f8d5e2d30590c4080cbed7a", "patch": "@@ -466,9 +466,9 @@ fn missing_ctor(cx: &MatchCheckCtxt,\n         // those with a destructured slice come first.\n         vec_pat_lens.sort_by(|&(len1, slice1), &(len2, slice2)| {\n                     if len1 == len2 {\n-                        slice1 > slice2\n+                        slice2.cmp(&slice1)\n                     } else {\n-                        len1 <= len2\n+                        len1.cmp(&len2)\n                     }\n                 });\n         vec_pat_lens.dedup();"}, {"sha": "9ec0fa337168cbaac97bbc080f421b797b5c7676", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2e8c522c6206eacb8f8d5e2d30590c4080cbed7a/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e8c522c6206eacb8f8d5e2d30590c4080cbed7a/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=2e8c522c6206eacb8f8d5e2d30590c4080cbed7a", "patch": "@@ -63,7 +63,7 @@ use syntax::{ast, ast_util, visit};\n use syntax::ast_util::IdVisitingOperation;\n use syntax::visit::Visitor;\n \n-#[deriving(Clone, Eq)]\n+#[deriving(Clone, Eq, Ord, TotalEq, TotalOrd)]\n pub enum lint {\n     ctypes,\n     unused_imports,\n@@ -110,20 +110,16 @@ pub fn level_to_str(lv: level) -> &'static str {\n     }\n }\n \n-#[deriving(Clone, Eq, Ord)]\n+#[deriving(Clone, Eq, Ord, TotalEq, TotalOrd)]\n pub enum level {\n     allow, warn, deny, forbid\n }\n \n-#[deriving(Clone, Eq)]\n+#[deriving(Clone, Eq, Ord, TotalEq, TotalOrd)]\n pub struct LintSpec {\n+    default: level,\n     lint: lint,\n     desc: &'static str,\n-    default: level\n-}\n-\n-impl Ord for LintSpec {\n-    fn lt(&self, other: &LintSpec) -> bool { self.default < other.default }\n }\n \n pub type LintDict = HashMap<&'static str, LintSpec>;"}, {"sha": "c562a78b961ccf366aeebfb90d98fe0156260327", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2e8c522c6206eacb8f8d5e2d30590c4080cbed7a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e8c522c6206eacb8f8d5e2d30590c4080cbed7a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=2e8c522c6206eacb8f8d5e2d30590c4080cbed7a", "patch": "@@ -3163,7 +3163,7 @@ pub fn trans_crate(sess: session::Session,\n         println!(\"n_closures: {}\", ccx.stats.n_closures);\n         println(\"fn stats:\");\n \n-        ccx.stats.fn_stats.sort_by(|&(_, _, insns_a), &(_, _, insns_b)| insns_a >= insns_b);\n+        ccx.stats.fn_stats.sort_by(|&(_, _, insns_a), &(_, _, insns_b)| insns_b.cmp(&insns_a));\n \n         for tuple in ccx.stats.fn_stats.iter() {\n             match *tuple {"}, {"sha": "8a14e37c816899137edfb18f2d8d318d57e4db4c", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/2e8c522c6206eacb8f8d5e2d30590c4080cbed7a/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e8c522c6206eacb8f8d5e2d30590c4080cbed7a/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=2e8c522c6206eacb8f8d5e2d30590c4080cbed7a", "patch": "@@ -898,44 +898,44 @@ fn item_module(w: &mut Writer, cx: &Context,\n     debug!(\"{:?}\", items);\n     let mut indices = vec::from_fn(items.len(), |i| i);\n \n-    fn le(i1: &clean::Item, i2: &clean::Item, idx1: uint, idx2: uint) -> bool {\n+    fn cmp(i1: &clean::Item, i2: &clean::Item, idx1: uint, idx2: uint) -> Ordering {\n         if shortty(i1) == shortty(i2) {\n-            return i1.name <= i2.name;\n+            return i1.name.cmp(&i2.name);\n         }\n         match (&i1.inner, &i2.inner) {\n             (&clean::ViewItemItem(ref a), &clean::ViewItemItem(ref b)) => {\n                 match (&a.inner, &b.inner) {\n-                    (&clean::ExternMod(..), _) => true,\n-                    (_, &clean::ExternMod(..)) => false,\n-                    _ => idx1 <= idx2,\n+                    (&clean::ExternMod(..), _) => Less,\n+                    (_, &clean::ExternMod(..)) => Greater,\n+                    _ => idx1.cmp(&idx2),\n                 }\n             }\n-            (&clean::ViewItemItem(..), _) => true,\n-            (_, &clean::ViewItemItem(..)) => false,\n-            (&clean::ModuleItem(..), _) => true,\n-            (_, &clean::ModuleItem(..)) => false,\n-            (&clean::StructItem(..), _) => true,\n-            (_, &clean::StructItem(..)) => false,\n-            (&clean::EnumItem(..), _) => true,\n-            (_, &clean::EnumItem(..)) => false,\n-            (&clean::StaticItem(..), _) => true,\n-            (_, &clean::StaticItem(..)) => false,\n-            (&clean::ForeignFunctionItem(..), _) => true,\n-            (_, &clean::ForeignFunctionItem(..)) => false,\n-            (&clean::ForeignStaticItem(..), _) => true,\n-            (_, &clean::ForeignStaticItem(..)) => false,\n-            (&clean::TraitItem(..), _) => true,\n-            (_, &clean::TraitItem(..)) => false,\n-            (&clean::FunctionItem(..), _) => true,\n-            (_, &clean::FunctionItem(..)) => false,\n-            (&clean::TypedefItem(..), _) => true,\n-            (_, &clean::TypedefItem(..)) => false,\n-            _ => idx1 <= idx2,\n+            (&clean::ViewItemItem(..), _) => Less,\n+            (_, &clean::ViewItemItem(..)) => Greater,\n+            (&clean::ModuleItem(..), _) => Less,\n+            (_, &clean::ModuleItem(..)) => Greater,\n+            (&clean::StructItem(..), _) => Less,\n+            (_, &clean::StructItem(..)) => Greater,\n+            (&clean::EnumItem(..), _) => Less,\n+            (_, &clean::EnumItem(..)) => Greater,\n+            (&clean::StaticItem(..), _) => Less,\n+            (_, &clean::StaticItem(..)) => Greater,\n+            (&clean::ForeignFunctionItem(..), _) => Less,\n+            (_, &clean::ForeignFunctionItem(..)) => Greater,\n+            (&clean::ForeignStaticItem(..), _) => Less,\n+            (_, &clean::ForeignStaticItem(..)) => Greater,\n+            (&clean::TraitItem(..), _) => Less,\n+            (_, &clean::TraitItem(..)) => Greater,\n+            (&clean::FunctionItem(..), _) => Less,\n+            (_, &clean::FunctionItem(..)) => Greater,\n+            (&clean::TypedefItem(..), _) => Less,\n+            (_, &clean::TypedefItem(..)) => Greater,\n+            _ => idx1.cmp(&idx2),\n         }\n     }\n \n     debug!(\"{:?}\", indices);\n-    indices.sort_by(|&i1, &i2| le(&items[i1], &items[i2], i1, i2));\n+    indices.sort_by(|&i1, &i2| cmp(&items[i1], &items[i2], i1, i2));\n \n     debug!(\"{:?}\", indices);\n     let mut curty = \"\";\n@@ -1530,7 +1530,7 @@ fn build_sidebar(m: &clean::Module) -> HashMap<~str, ~[~str]> {\n     }\n \n     for (_, items) in map.mut_iter() {\n-        items.sort(|i1, i2| i1 <= i2);\n+        items.sort();\n     }\n     return map;\n }"}, {"sha": "583e87370bc72f11a46f441328ca4f209127fb36", "filename": "src/libstd/prelude.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2e8c522c6206eacb8f8d5e2d30590c4080cbed7a/src%2Flibstd%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e8c522c6206eacb8f8d5e2d30590c4080cbed7a/src%2Flibstd%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude.rs?ref=2e8c522c6206eacb8f8d5e2d30590c4080cbed7a", "patch": "@@ -79,7 +79,8 @@ pub use tuple::{Tuple1, Tuple2, Tuple3, Tuple4};\n pub use tuple::{Tuple5, Tuple6, Tuple7, Tuple8};\n pub use tuple::{Tuple9, Tuple10, Tuple11, Tuple12};\n pub use vec::{ImmutableEqVector, ImmutableTotalOrdVector, ImmutableCopyableVector};\n-pub use vec::{OwnedVector, OwnedCopyableVector,OwnedEqVector, MutableVector, MutableOrdVector};\n+pub use vec::{OwnedVector, OwnedCopyableVector,OwnedEqVector};\n+pub use vec::{MutableVector, MutableTotalOrdVector};\n pub use vec::{Vector, VectorVector, CopyableVector, ImmutableVector};\n \n // Reexported runtime types"}, {"sha": "d31fe0ee43401b5aa2ff2529fd29672c2af7fda0", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 32, "deletions": 54, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/2e8c522c6206eacb8f8d5e2d30590c4080cbed7a/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e8c522c6206eacb8f8d5e2d30590c4080cbed7a/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=2e8c522c6206eacb8f8d5e2d30590c4080cbed7a", "patch": "@@ -1921,7 +1921,7 @@ impl<T:Eq> OwnedEqVector<T> for ~[T] {\n     }\n }\n \n-fn merge_sort<T>(v: &mut [T], less_eq: |&T, &T| -> bool) {\n+fn merge_sort<T>(v: &mut [T], compare: |&T, &T| -> Ordering) {\n     // warning: this wildly uses unsafe.\n     static INSERTION: uint = 8;\n \n@@ -1930,7 +1930,7 @@ fn merge_sort<T>(v: &mut [T], less_eq: |&T, &T| -> bool) {\n     // allocate some memory to use as scratch memory, we keep the\n     // length 0 so we can keep shallow copies of the contents of `v`\n     // without risking the dtors running on an object twice if\n-    // `less_eq` fails.\n+    // `compare` fails.\n     let mut working_space = with_capacity(2 * len);\n     // these both are buffers of length `len`.\n     let mut buf_dat = working_space.as_mut_ptr();\n@@ -1960,7 +1960,8 @@ fn merge_sort<T>(v: &mut [T], less_eq: |&T, &T| -> bool) {\n \n                 // start <= j - 1 < len, so .offset(j - 1) is in\n                 // bounds.\n-                while j > start as int && !less_eq(&*buf_dat.offset(j - 1), &*read_ptr) {\n+                while j > start as int &&\n+                        compare(&*read_ptr, &*buf_dat.offset(j - 1)) == Less {\n                     j -= 1;\n                 }\n \n@@ -2034,10 +2035,10 @@ fn merge_sort<T>(v: &mut [T], less_eq: |&T, &T| -> bool) {\n \n                     // `left < right_start` and `right < right_end`,\n                     // so these are valid.\n-                    let to_copy = if less_eq(&*left, &*right) {\n-                        step(&mut left)\n-                    } else {\n+                    let to_copy = if compare(&*left, &*right) == Greater {\n                         step(&mut right)\n+                    } else {\n+                        step(&mut left)\n                     };\n                     ptr::copy_nonoverlapping_memory(out, to_copy, 1);\n                     step(&mut out);\n@@ -2164,8 +2165,8 @@ pub trait MutableVector<'a, T> {\n     /// Reverse the order of elements in a vector, in place\n     fn reverse(self);\n \n-    /// Sort the vector, in place, using `less_eq` to compare `a <=\n-    /// b`.\n+    /// Sort the vector, in place, using `compare` to compare\n+    /// elements.\n     ///\n     /// This sort is `O(n log n)` worst-case and stable, but allocates\n     /// approximately `2 * n`, where `n` is the length of `self`.\n@@ -2174,14 +2175,14 @@ pub trait MutableVector<'a, T> {\n     ///\n     /// ```rust\n     /// let mut v = [5, 4, 1, 3, 2];\n-    /// v.sort(|a, b| *a <= *b);\n+    /// v.sort(|a, b| a.cmp(b));\n     /// assert_eq!(v, [1, 2, 3, 4, 5]);\n     ///\n     /// // reverse sorting\n-    /// v.sort(|a, b| *b <= *a);\n+    /// v.sort(|a, b| b.cmp(a));\n     /// assert_eq!(v, [5, 4, 3, 2, 1]);\n     /// ```\n-    fn sort_by(self, less_eq: |&T, &T| -> bool);\n+    fn sort_by(self, compare: |&T, &T| -> Ordering);\n \n     /**\n      * Consumes `src` and moves as many elements as it can into `self`\n@@ -2328,12 +2329,8 @@ impl<'a,T> MutableVector<'a, T> for &'a mut [T] {\n     }\n \n     #[inline]\n-<<<<<<< HEAD\n-    fn sort(self, less_eq: |&T, &T| -> bool) {\n-=======\n-    fn sort_by<Sort: SortComparator<T>>(self, less_eq: Sort) {\n->>>>>>> 9ceda35... std::vec: add a sugary .sort() method for plain Ord sorting.\n-        merge_sort(self, less_eq)\n+    fn sort_by(self, compare: |&T, &T| -> Ordering) {\n+        merge_sort(self, compare)\n     }\n \n     #[inline]\n@@ -2391,7 +2388,7 @@ impl<'a, T:Clone> MutableCloneableVector<T> for &'a mut [T] {\n \n /// Methods for mutable vectors with orderable elements, such as\n /// in-place sorting.\n-pub trait MutableOrdVector<T> {\n+pub trait MutableTotalOrdVector<T> {\n     /// Sort the vector, in place.\n     ///\n     /// This is equivalent to `self.sort_by(std::vec::SortForward)`.\n@@ -2408,10 +2405,10 @@ pub trait MutableOrdVector<T> {\n     /// ```\n     fn sort(self);\n }\n-impl<'a, T: Ord> MutableOrdVector<T> for &'a mut [T] {\n+impl<'a, T: TotalOrd> MutableTotalOrdVector<T> for &'a mut [T] {\n     #[inline]\n     fn sort(self) {\n-        self.sort_by(SortForward)\n+        self.sort_by(|a,b| a.cmp(b))\n     }\n }\n \n@@ -3502,41 +3499,25 @@ mod tests {\n         for len in range(4u, 25) {\n             for _ in range(0, 100) {\n                 let mut v = task_rng().gen_vec::<uint>(len);\n-                v.sort(|a,b| a <= b);\n-\n-<<<<<<< HEAD\n-                assert!(v.windows(2).all(|w| w[0] <= w[1]));\n-=======\n                 let mut v1 = v.clone();\n-                let mut v2 = v.clone();\n+\n                 v.sort();\n                 assert!(v.windows(2).all(|w| w[0] <= w[1]));\n \n-                v1.sort_by(vec::SortForward);\n+                v1.sort_by(|a, b| a.cmp(b));\n                 assert!(v1.windows(2).all(|w| w[0] <= w[1]));\n \n-                v1.sort_by(vec::SortReverse);\n+                v1.sort_by(|a, b| b.cmp(a));\n                 assert!(v1.windows(2).all(|w| w[0] >= w[1]));\n-\n-                v2.sort_by(|a: &uint, b: &uint| a <= b);\n-                assert!(v2.windows(2).all(|w| w[0] <= w[1]));\n->>>>>>> 9ceda35... std::vec: add a sugary .sort() method for plain Ord sorting.\n             }\n         }\n \n         // shouldn't fail/crash\n         let mut v: [uint, .. 0] = [];\n-<<<<<<< HEAD\n-        v.sort(|a,b| a <= b);\n+        v.sort();\n \n         let mut v = [0xDEADBEEF];\n-        v.sort(|a,b| a <= b);\n-=======\n-        v.sort_by(SortForward);\n-\n-        let mut v = [0xDEADBEEF];\n-        v.sort_by(SortForward);\n->>>>>>> 9ceda35... std::vec: add a sugary .sort() method for plain Ord sorting.\n+        v.sort();\n         assert_eq!(v, [0xDEADBEEF]);\n     }\n \n@@ -3559,11 +3540,7 @@ mod tests {\n \n                 // only sort on the first element, so an unstable sort\n                 // may mix up the counts.\n-<<<<<<< HEAD\n-                v.sort(|&(a,_), &(b,_)| a <= b);\n-=======\n-                v.sort_by(|&(a,_): &(uint, uint), &(b,_): &(uint, uint)| a <= b);\n->>>>>>> 9ceda35... std::vec: add a sugary .sort() method for plain Ord sorting.\n+                v.sort_by(|&(a,_), &(b,_)| a.cmp(&b));\n \n                 // this comparison includes the count (the second item\n                 // of the tuple), so elements with equal first items\n@@ -4398,10 +4375,10 @@ mod bench {\n     use extra::test::BenchHarness;\n     use iter::range;\n     use vec;\n-    use vec::{VectorVector, MutableOrdVector};\n+    use vec::{VectorVector, MutableTotalOrdVector};\n     use option::*;\n     use ptr;\n-    use rand::{weak_rng, task_rng, Rng};\n+    use rand::{weak_rng, Rng};\n     use mem;\n \n     #[bench]\n@@ -4604,33 +4581,34 @@ mod bench {\n             })\n     }\n \n+    #[bench]\n     fn sort_random_small(bh: &mut BenchHarness) {\n         let mut rng = weak_rng();\n         bh.iter(|| {\n-            let mut v: ~[f64] = rng.gen_vec(5);\n+            let mut v: ~[u64] = rng.gen_vec(5);\n             v.sort();\n         });\n-        bh.bytes = 5 * mem::size_of::<f64>() as u64;\n+        bh.bytes = 5 * mem::size_of::<u64>() as u64;\n     }\n \n     #[bench]\n     fn sort_random_medium(bh: &mut BenchHarness) {\n         let mut rng = weak_rng();\n         bh.iter(|| {\n-            let mut v: ~[f64] = rng.gen_vec(100);\n+            let mut v: ~[u64] = rng.gen_vec(100);\n             v.sort();\n         });\n-        bh.bytes = 100 * mem::size_of::<f64>() as u64;\n+        bh.bytes = 100 * mem::size_of::<u64>() as u64;\n     }\n \n     #[bench]\n     fn sort_random_large(bh: &mut BenchHarness) {\n         let mut rng = weak_rng();\n         bh.iter(|| {\n-            let mut v: ~[f64] = rng.gen_vec(10000);\n+            let mut v: ~[u64] = rng.gen_vec(10000);\n             v.sort();\n         });\n-        bh.bytes = 10000 * mem::size_of::<f64>() as u64;\n+        bh.bytes = 10000 * mem::size_of::<u64>() as u64;\n     }\n \n     #[bench]"}, {"sha": "8dff321ca0e6a2d94120beb6aba2f4f217feeeea", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2e8c522c6206eacb8f8d5e2d30590c4080cbed7a/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e8c522c6206eacb8f8d5e2d30590c4080cbed7a/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=2e8c522c6206eacb8f8d5e2d30590c4080cbed7a", "patch": "@@ -203,11 +203,7 @@ pub fn sort_meta_items(items: &[@MetaItem]) -> ~[@MetaItem] {\n         .map(|&mi| (mi.name(), mi))\n         .collect::<~[(@str, @MetaItem)]>();\n \n-<<<<<<< HEAD\n-    v.sort(|&(a, _), &(b, _)| a <= b);\n-=======\n-    v.sort_by(|&(a, _): &(@str, @MetaItem), &(b, _): &(@str, @MetaItem)| a <= b);\n->>>>>>> 9ceda35... std::vec: add a sugary .sort() method for plain Ord sorting.\n+    v.sort_by(|&(a, _), &(b, _)| a.cmp(&b));\n \n     // There doesn't seem to be a more optimal way to do this\n     v.move_iter().map(|(_, m)| {"}, {"sha": "2f63c6046f80fedec7b9508166cb26921b2845a2", "filename": "src/test/bench/shootout-k-nucleotide-pipes.rs", "status": "modified", "additions": 19, "deletions": 24, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/2e8c522c6206eacb8f8d5e2d30590c4080cbed7a/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e8c522c6206eacb8f8d5e2d30590c4080cbed7a/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs?ref=2e8c522c6206eacb8f8d5e2d30590c4080cbed7a", "patch": "@@ -26,37 +26,32 @@ use std::task;\n use std::util;\n use std::vec;\n \n+fn f64_cmp(x: f64, y: f64) -> Ordering {\n+    // arbitrarily decide that NaNs are larger than everything.\n+    if y.is_nan() {\n+        Less\n+    } else if x.is_nan() {\n+        Greater\n+    } else if x < y {\n+        Less\n+    } else if x == y {\n+        Equal\n+    } else {\n+        Greater\n+    }\n+}\n+\n // given a map, print a sorted version of it\n fn sort_and_fmt(mm: &HashMap<~[u8], uint>, total: uint) -> ~str {\n    fn pct(xx: uint, yy: uint) -> f64 {\n       return (xx as f64) * 100.0 / (yy as f64);\n    }\n \n-   fn le_by_val<TT:Clone,\n-                UU:Clone + Ord>(\n-                kv0: &(TT,UU),\n-                kv1: &(TT,UU))\n-                -> bool {\n-      let (_, v0) = (*kv0).clone();\n-      let (_, v1) = (*kv1).clone();\n-      return v0 >= v1;\n-   }\n-\n-   fn le_by_key<TT:Clone + Ord,\n-                UU:Clone>(\n-                kv0: &(TT,UU),\n-                kv1: &(TT,UU))\n-                -> bool {\n-      let (k0, _) = (*kv0).clone();\n-      let (k1, _) = (*kv1).clone();\n-      return k0 <= k1;\n-   }\n-\n    // sort by key, then by value\n-   fn sortKV<TT:Clone + Ord, UU:Clone + Ord>(mut orig: ~[(TT,UU)]) -> ~[(TT,UU)] {\n-        orig.sort_by(le_by_key);\n-        orig.sort_by(le_by_val);\n-        origin\n+   fn sortKV(mut orig: ~[(~[u8],f64)]) -> ~[(~[u8],f64)] {\n+        orig.sort_by(|&(ref a, _), &(ref b, _)| a.cmp(b));\n+        orig.sort_by(|&(_, a), &(_, b)| f64_cmp(b, a));\n+        orig\n    }\n \n    let mut pairs = ~[];"}, {"sha": "a45daad64b8d2079a2ebe116c32c8143ad87dd37", "filename": "src/test/run-pass/vector-sort-failure-safe.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2e8c522c6206eacb8f8d5e2d30590c4080cbed7a/src%2Ftest%2Frun-pass%2Fvector-sort-failure-safe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e8c522c6206eacb8f8d5e2d30590c4080cbed7a/src%2Ftest%2Frun-pass%2Fvector-sort-failure-safe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvector-sort-failure-safe.rs?ref=2e8c522c6206eacb8f8d5e2d30590c4080cbed7a", "patch": "@@ -14,7 +14,7 @@ static MAX_LEN: uint = 20;\n static mut drop_counts: [uint, .. MAX_LEN] = [0, .. MAX_LEN];\n static mut clone_count: uint = 0;\n \n-#[deriving(Rand, Ord)]\n+#[deriving(Rand, Ord, TotalEq, TotalOrd)]\n struct DropCounter { x: uint, clone_num: uint }\n \n impl Clone for DropCounter {\n@@ -48,7 +48,7 @@ pub fn main() {\n             // work out the total number of comparisons required to sort\n             // this array...\n             let mut count = 0;\n-            main.clone().sort_by(|a, b| { count += 1; a <= b });\n+            main.clone().sort_by(|a, b| { count += 1; a.cmp(b) });\n \n             // ... and then fail on each and every single one.\n             for fail_countdown in range(0, count) {\n@@ -68,7 +68,7 @@ pub fn main() {\n                                     fail!()\n                                 }\n                                 fail_countdown -= 1;\n-                                a <= b\n+                                a.cmp(b)\n                             })\n                     });\n "}]}