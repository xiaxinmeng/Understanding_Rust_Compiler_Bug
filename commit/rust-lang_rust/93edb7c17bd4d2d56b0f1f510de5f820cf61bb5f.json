{"sha": "93edb7c17bd4d2d56b0f1f510de5f820cf61bb5f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkzZWRiN2MxN2JkNGQyZDU2YjBmMWY1MTBkZTVmODIwY2Y2MWJiNWY=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2015-02-05T17:26:58Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2015-02-06T20:24:06Z"}, "message": "debuginfo: Fix problem with debug locations of constants in match patterns.", "tree": {"sha": "6655dfd67da9912eb5c9b28e74d17534830e5f1c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6655dfd67da9912eb5c9b28e74d17534830e5f1c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/93edb7c17bd4d2d56b0f1f510de5f820cf61bb5f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/93edb7c17bd4d2d56b0f1f510de5f820cf61bb5f", "html_url": "https://github.com/rust-lang/rust/commit/93edb7c17bd4d2d56b0f1f510de5f820cf61bb5f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/93edb7c17bd4d2d56b0f1f510de5f820cf61bb5f/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0eec22640c1f1b6d9360f5a05961f19465ca9e14", "url": "https://api.github.com/repos/rust-lang/rust/commits/0eec22640c1f1b6d9360f5a05961f19465ca9e14", "html_url": "https://github.com/rust-lang/rust/commit/0eec22640c1f1b6d9360f5a05961f19465ca9e14"}], "stats": {"total": 219, "additions": 189, "deletions": 30}, "files": [{"sha": "0d2af78ed06758209f6a94042ce289e7a0ddb580", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 53, "deletions": 12, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/93edb7c17bd4d2d56b0f1f510de5f820cf61bb5f/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93edb7c17bd4d2d56b0f1f510de5f820cf61bb5f/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=93edb7c17bd4d2d56b0f1f510de5f820cf61bb5f", "patch": "@@ -28,14 +28,15 @@ use std::iter::{range_inclusive, AdditiveIterator, FromIterator, repeat};\n use std::num::Float;\n use std::slice;\n use syntax::ast::{self, DUMMY_NODE_ID, NodeId, Pat};\n-use syntax::ast_util::walk_pat;\n+use syntax::ast_util;\n use syntax::codemap::{Span, Spanned, DUMMY_SP};\n use syntax::fold::{Folder, noop_fold_pat};\n use syntax::print::pprust::pat_to_string;\n use syntax::parse::token;\n use syntax::ptr::P;\n use syntax::visit::{self, Visitor, FnKind};\n use util::ppaux::ty_to_string;\n+use util::nodemap::FnvHashMap;\n \n pub const DUMMY_WILD_PAT: &'static Pat = &Pat {\n     id: DUMMY_NODE_ID,\n@@ -171,7 +172,7 @@ fn check_expr(cx: &mut MatchCheckCtxt, ex: &ast::Expr) {\n                 }\n             }\n \n-            let mut static_inliner = StaticInliner::new(cx.tcx);\n+            let mut static_inliner = StaticInliner::new(cx.tcx, None);\n             let inlined_arms = arms.iter().map(|arm| {\n                 (arm.pats.iter().map(|pat| {\n                     static_inliner.fold_pat((*pat).clone())\n@@ -235,7 +236,7 @@ fn is_expr_const_nan(tcx: &ty::ctxt, expr: &ast::Expr) -> bool {\n }\n \n fn check_for_bindings_named_the_same_as_variants(cx: &MatchCheckCtxt, pat: &Pat) {\n-    walk_pat(pat, |p| {\n+    ast_util::walk_pat(pat, |p| {\n         match p.node {\n             ast::PatIdent(ast::BindByValue(ast::MutImmutable), ident, None) => {\n                 let pat_ty = ty::pat_ty(cx.tcx, p);\n@@ -266,7 +267,7 @@ fn check_for_bindings_named_the_same_as_variants(cx: &MatchCheckCtxt, pat: &Pat)\n \n // Check that we do not match against a static NaN (#6804)\n fn check_for_static_nan(cx: &MatchCheckCtxt, pat: &Pat) {\n-    walk_pat(pat, |p| {\n+    ast_util::walk_pat(pat, |p| {\n         match p.node {\n             ast::PatLit(ref expr) if is_expr_const_nan(cx.tcx, &**expr) => {\n                 span_warn!(cx.tcx.sess, p.span, E0003,\n@@ -399,28 +400,50 @@ fn const_val_to_expr(value: &const_val) -> P<ast::Expr> {\n \n pub struct StaticInliner<'a, 'tcx: 'a> {\n     pub tcx: &'a ty::ctxt<'tcx>,\n-    pub failed: bool\n+    pub failed: bool,\n+    pub renaming_map: Option<&'a mut FnvHashMap<(NodeId, Span), NodeId>>,\n }\n \n impl<'a, 'tcx> StaticInliner<'a, 'tcx> {\n-    pub fn new<'b>(tcx: &'b ty::ctxt<'tcx>) -> StaticInliner<'b, 'tcx> {\n+    pub fn new<'b>(tcx: &'b ty::ctxt<'tcx>,\n+                   renaming_map: Option<&'b mut FnvHashMap<(NodeId, Span), NodeId>>)\n+                   -> StaticInliner<'b, 'tcx> {\n         StaticInliner {\n             tcx: tcx,\n-            failed: false\n+            failed: false,\n+            renaming_map: renaming_map\n         }\n     }\n }\n \n+struct RenamingRecorder<'map> {\n+    substituted_node_id: NodeId,\n+    origin_span: Span,\n+    renaming_map: &'map mut FnvHashMap<(NodeId, Span), NodeId>\n+}\n+\n+impl<'map> ast_util::IdVisitingOperation for RenamingRecorder<'map> {\n+    fn visit_id(&mut self, node_id: NodeId) {\n+        let key = (node_id, self.origin_span);\n+        self.renaming_map.insert(key, self.substituted_node_id);\n+    }\n+}\n+\n impl<'a, 'tcx> Folder for StaticInliner<'a, 'tcx> {\n     fn fold_pat(&mut self, pat: P<Pat>) -> P<Pat> {\n-        match pat.node {\n+        return match pat.node {\n             ast::PatIdent(..) | ast::PatEnum(..) => {\n                 let def = self.tcx.def_map.borrow().get(&pat.id).cloned();\n                 match def {\n                     Some(DefConst(did)) => match lookup_const_by_id(self.tcx, did) {\n                         Some(const_expr) => {\n-                            const_expr_to_pat(self.tcx, const_expr).map(|mut new_pat| {\n-                                new_pat.span = pat.span;\n+                            const_expr_to_pat(self.tcx, const_expr, pat.span).map(|new_pat| {\n+\n+                                if let Some(ref mut renaming_map) = self.renaming_map {\n+                                    // Record any renamings we do here\n+                                    record_renamings(const_expr, &pat, renaming_map);\n+                                }\n+\n                                 new_pat\n                             })\n                         }\n@@ -435,6 +458,24 @@ impl<'a, 'tcx> Folder for StaticInliner<'a, 'tcx> {\n                 }\n             }\n             _ => noop_fold_pat(pat, self)\n+        };\n+\n+        fn record_renamings(const_expr: &ast::Expr,\n+                            substituted_pat: &ast::Pat,\n+                            renaming_map: &mut FnvHashMap<(NodeId, Span), NodeId>) {\n+            let mut renaming_recorder = RenamingRecorder {\n+                substituted_node_id: substituted_pat.id,\n+                origin_span: substituted_pat.span,\n+                renaming_map: renaming_map,\n+            };\n+\n+            let mut id_visitor = ast_util::IdVisitor {\n+                operation: &mut renaming_recorder,\n+                pass_through_items: true,\n+                visited_outermost: false,\n+            };\n+\n+            id_visitor.visit_expr(const_expr);\n         }\n     }\n }\n@@ -953,7 +994,7 @@ fn check_local(cx: &mut MatchCheckCtxt, loc: &ast::Local) {\n         ast::LocalFor => \"`for` loop\"\n     };\n \n-    let mut static_inliner = StaticInliner::new(cx.tcx);\n+    let mut static_inliner = StaticInliner::new(cx.tcx, None);\n     is_refutable(cx, &*static_inliner.fold_pat(loc.pat.clone()), |pat| {\n         span_err!(cx.tcx.sess, loc.pat.span, E0005,\n             \"refutable pattern in {} binding: `{}` not covered\",\n@@ -1040,7 +1081,7 @@ fn check_legality_of_move_bindings(cx: &MatchCheckCtxt,\n     };\n \n     for pat in pats {\n-        walk_pat(&**pat, |p| {\n+        ast_util::walk_pat(&**pat, |p| {\n             if pat_is_binding(def_map, &*p) {\n                 match p.node {\n                     ast::PatIdent(ast::BindByValue(_), _, ref sub) => {"}, {"sha": "2d764518a47b2de75259b3ed427693168ab89c70", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/93edb7c17bd4d2d56b0f1f510de5f820cf61bb5f/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93edb7c17bd4d2d56b0f1f510de5f820cf61bb5f/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=93edb7c17bd4d2d56b0f1f510de5f820cf61bb5f", "patch": "@@ -22,6 +22,7 @@ use middle::astconv_util::{ast_ty_to_prim_ty};\n use util::nodemap::DefIdMap;\n \n use syntax::ast::{self, Expr};\n+use syntax::codemap::Span;\n use syntax::parse::token::InternedString;\n use syntax::ptr::P;\n use syntax::visit::{self, Visitor};\n@@ -304,10 +305,10 @@ pub enum const_val {\n     const_bool(bool)\n }\n \n-pub fn const_expr_to_pat(tcx: &ty::ctxt, expr: &Expr) -> P<ast::Pat> {\n+pub fn const_expr_to_pat(tcx: &ty::ctxt, expr: &Expr, span: Span) -> P<ast::Pat> {\n     let pat = match expr.node {\n         ast::ExprTup(ref exprs) =>\n-            ast::PatTup(exprs.iter().map(|expr| const_expr_to_pat(tcx, &**expr)).collect()),\n+            ast::PatTup(exprs.iter().map(|expr| const_expr_to_pat(tcx, &**expr, span)).collect()),\n \n         ast::ExprCall(ref callee, ref args) => {\n             let def = tcx.def_map.borrow()[callee.id].clone();\n@@ -319,7 +320,7 @@ pub fn const_expr_to_pat(tcx: &ty::ctxt, expr: &Expr) -> P<ast::Pat> {\n                 def::DefVariant(_, variant_did, _) => def_to_path(tcx, variant_did),\n                 _ => unreachable!()\n             };\n-            let pats = args.iter().map(|expr| const_expr_to_pat(tcx, &**expr)).collect();\n+            let pats = args.iter().map(|expr| const_expr_to_pat(tcx, &**expr, span)).collect();\n             ast::PatEnum(path, Some(pats))\n         }\n \n@@ -328,15 +329,15 @@ pub fn const_expr_to_pat(tcx: &ty::ctxt, expr: &Expr) -> P<ast::Pat> {\n                 span: codemap::DUMMY_SP,\n                 node: ast::FieldPat {\n                     ident: field.ident.node,\n-                    pat: const_expr_to_pat(tcx, &*field.expr),\n+                    pat: const_expr_to_pat(tcx, &*field.expr, span),\n                     is_shorthand: false,\n                 },\n             }).collect();\n             ast::PatStruct(path.clone(), field_pats, false)\n         }\n \n         ast::ExprVec(ref exprs) => {\n-            let pats = exprs.iter().map(|expr| const_expr_to_pat(tcx, &**expr)).collect();\n+            let pats = exprs.iter().map(|expr| const_expr_to_pat(tcx, &**expr, span)).collect();\n             ast::PatVec(pats, None, vec![])\n         }\n \n@@ -349,7 +350,7 @@ pub fn const_expr_to_pat(tcx: &ty::ctxt, expr: &Expr) -> P<ast::Pat> {\n                     ast::PatEnum(path.clone(), None),\n                 _ => {\n                     match lookup_const(tcx, expr) {\n-                        Some(actual) => return const_expr_to_pat(tcx, actual),\n+                        Some(actual) => return const_expr_to_pat(tcx, actual, span),\n                         _ => unreachable!()\n                     }\n                 }\n@@ -358,14 +359,14 @@ pub fn const_expr_to_pat(tcx: &ty::ctxt, expr: &Expr) -> P<ast::Pat> {\n \n         ast::ExprQPath(_) => {\n             match lookup_const(tcx, expr) {\n-                Some(actual) => return const_expr_to_pat(tcx, actual),\n+                Some(actual) => return const_expr_to_pat(tcx, actual, span),\n                 _ => unreachable!()\n             }\n         }\n \n         _ => ast::PatLit(P(expr.clone()))\n     };\n-    P(ast::Pat { id: expr.id, node: pat, span: expr.span })\n+    P(ast::Pat { id: expr.id, node: pat, span: span })\n }\n \n pub fn eval_const_expr(tcx: &ty::ctxt, e: &Expr) -> const_val {"}, {"sha": "610b6e1aa38073980dcc3de8438fa501d63bb5aa", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 35, "deletions": 10, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/93edb7c17bd4d2d56b0f1f510de5f820cf61bb5f/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93edb7c17bd4d2d56b0f1f510de5f820cf61bb5f/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=93edb7c17bd4d2d56b0f1f510de5f820cf61bb5f", "patch": "@@ -213,7 +213,7 @@ use trans::expr::{self, Dest};\n use trans::tvec;\n use trans::type_of;\n use middle::ty::{self, Ty};\n-use session::config::FullDebugInfo;\n+use session::config::{NoDebugInfo, FullDebugInfo};\n use util::common::indenter;\n use util::nodemap::FnvHashMap;\n use util::ppaux::{Repr, vec_map_to_string};\n@@ -222,7 +222,7 @@ use std;\n use std::iter::AdditiveIterator;\n use std::rc::Rc;\n use syntax::ast;\n-use syntax::ast::{DUMMY_NODE_ID, Ident};\n+use syntax::ast::{DUMMY_NODE_ID, Ident, NodeId};\n use syntax::codemap::Span;\n use syntax::fold::Folder;\n use syntax::ptr::P;\n@@ -366,6 +366,9 @@ struct Match<'a, 'p: 'a, 'blk: 'a, 'tcx: 'blk> {\n     pats: Vec<&'p ast::Pat>,\n     data: &'a ArmData<'p, 'blk, 'tcx>,\n     bound_ptrs: Vec<(Ident, ValueRef)>,\n+    // Thread along renamings done by the check_match::StaticInliner, so we can\n+    // map back to original NodeIds\n+    pat_renaming_map: Option<&'a FnvHashMap<(NodeId, Span), NodeId>>\n }\n \n impl<'a, 'p, 'blk, 'tcx> Repr<'tcx> for Match<'a, 'p, 'blk, 'tcx> {\n@@ -419,7 +422,8 @@ fn expand_nested_bindings<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         Match {\n             pats: pats,\n             data: &*br.data,\n-            bound_ptrs: bound_ptrs\n+            bound_ptrs: bound_ptrs,\n+            pat_renaming_map: br.pat_renaming_map,\n         }\n     }).collect()\n }\n@@ -463,7 +467,8 @@ fn enter_match<'a, 'b, 'p, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n             Match {\n                 pats: pats,\n                 data: br.data,\n-                bound_ptrs: bound_ptrs\n+                bound_ptrs: bound_ptrs,\n+                pat_renaming_map: br.pat_renaming_map,\n             }\n         })\n     }).collect()\n@@ -570,14 +575,23 @@ fn enter_opt<'a, 'p, 'blk, 'tcx>(\n // needs to be conditionally matched at runtime; for example, the discriminant\n // on a set of enum variants or a literal.\n fn get_branches<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                    m: &[Match<'a, 'p, 'blk, 'tcx>], col: uint)\n+                                    m: &[Match<'a, 'p, 'blk, 'tcx>],\n+                                    col: uint)\n                                     -> Vec<Opt<'p, 'tcx>> {\n     let tcx = bcx.tcx();\n \n     let mut found: Vec<Opt> = vec![];\n     for br in m {\n         let cur = br.pats[col];\n-        let debug_loc = DebugLoc::At(cur.id, cur.span);\n+        let debug_loc = match br.pat_renaming_map {\n+            Some(pat_renaming_map) => {\n+                match pat_renaming_map.get(&(cur.id, cur.span)) {\n+                    Some(&id) => DebugLoc::At(id, cur.span),\n+                    None => DebugLoc::At(cur.id, cur.span),\n+                }\n+            }\n+            None => DebugLoc::None\n+        };\n \n         let opt = match cur.node {\n             ast::PatLit(ref l) => {\n@@ -1419,16 +1433,27 @@ fn trans_match_inner<'blk, 'tcx>(scope_cx: Block<'blk, 'tcx>,\n         bindings_map: create_bindings_map(bcx, &*arm.pats[0], discr_expr, &*arm.body)\n     }).collect();\n \n-    let mut static_inliner = StaticInliner::new(scope_cx.tcx());\n-    let arm_pats: Vec<Vec<P<ast::Pat>>> = arm_datas.iter().map(|arm_data| {\n-        arm_data.arm.pats.iter().map(|p| static_inliner.fold_pat((*p).clone())).collect()\n-    }).collect();\n+    let mut pat_renaming_map = if scope_cx.sess().opts.debuginfo != NoDebugInfo {\n+        Some(FnvHashMap())\n+    } else {\n+        None\n+    };\n+\n+    let arm_pats: Vec<Vec<P<ast::Pat>>> = {\n+        let mut static_inliner = StaticInliner::new(scope_cx.tcx(),\n+                                                    pat_renaming_map.as_mut());\n+        arm_datas.iter().map(|arm_data| {\n+            arm_data.arm.pats.iter().map(|p| static_inliner.fold_pat((*p).clone())).collect()\n+        }).collect()\n+    };\n+\n     let mut matches = Vec::new();\n     for (arm_data, pats) in arm_datas.iter().zip(arm_pats.iter()) {\n         matches.extend(pats.iter().map(|p| Match {\n             pats: vec![&**p],\n             data: arm_data,\n             bound_ptrs: Vec::new(),\n+            pat_renaming_map: pat_renaming_map.as_ref()\n         }));\n     }\n "}, {"sha": "487c69a85d6acb985756545ec589ab5c7f6793df", "filename": "src/test/debuginfo/constant-in-match-pattern.rs", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/93edb7c17bd4d2d56b0f1f510de5f820cf61bb5f/src%2Ftest%2Fdebuginfo%2Fconstant-in-match-pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93edb7c17bd4d2d56b0f1f510de5f820cf61bb5f/src%2Ftest%2Fdebuginfo%2Fconstant-in-match-pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fconstant-in-match-pattern.rs?ref=93edb7c17bd4d2d56b0f1f510de5f820cf61bb5f", "patch": "@@ -0,0 +1,92 @@\n+// Copyright 2013-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-android: FIXME(#10381)\n+// min-lldb-version: 310\n+\n+// compile-flags:-g\n+\n+#![allow(unused_variables)]\n+#![allow(dead_code)]\n+#![omit_gdb_pretty_printer_section]\n+\n+// This test makes sure that the compiler doesn't crash when trying to assign\n+// debug locations to 'constant' patterns in match expressions.\n+\n+const CONSTANT: u64 = 3;\n+\n+struct Struct {\n+    a: isize,\n+    b: usize,\n+}\n+const STRUCT: Struct = Struct { a: 1, b: 2 };\n+\n+struct TupleStruct(u32);\n+const TUPLE_STRUCT: TupleStruct = TupleStruct(4);\n+\n+enum Enum {\n+    Variant1(char),\n+    Variant2 { a: u8 },\n+    Variant3\n+}\n+const VARIANT1: Enum = Enum::Variant1('v');\n+const VARIANT2: Enum = Enum::Variant2 { a: 2 };\n+const VARIANT3: Enum = Enum::Variant3;\n+\n+const STRING: &'static str = \"String\";\n+\n+fn main() {\n+\n+    match 1 {\n+        CONSTANT => {}\n+        _ => {}\n+    };\n+\n+    // if let 3 = CONSTANT {}\n+\n+    match (Struct { a: 2, b: 2 }) {\n+        STRUCT => {}\n+        _ => {}\n+    };\n+\n+    // if let STRUCT = STRUCT {}\n+\n+    match TupleStruct(3) {\n+        TUPLE_STRUCT => {}\n+        _ => {}\n+    };\n+\n+    // if let TupleStruct(4) = TUPLE_STRUCT {}\n+\n+    match VARIANT3 {\n+        VARIANT1 => {},\n+        VARIANT2 => {},\n+        VARIANT3 => {},\n+        _ => {}\n+    };\n+\n+    match (VARIANT3, VARIANT2) {\n+        (VARIANT1, VARIANT3) => {},\n+        (VARIANT2, VARIANT2) => {},\n+        (VARIANT3, VARIANT1) => {},\n+        _ => {}\n+    };\n+\n+    // if let VARIANT1 = Enum::Variant3 {}\n+    // if let VARIANT2 = Enum::Variant3 {}\n+    // if let VARIANT3 = Enum::Variant3 {}\n+\n+    match \"abc\" {\n+        STRING => {},\n+        _ => {}\n+    }\n+\n+    if let STRING = \"def\" {}\n+}"}]}