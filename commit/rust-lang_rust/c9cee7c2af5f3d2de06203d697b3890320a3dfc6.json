{"sha": "c9cee7c2af5f3d2de06203d697b3890320a3dfc6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM5Y2VlN2MyYWY1ZjNkMmRlMDYyMDNkNjk3YjM4OTAzMjBhM2RmYzY=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-10-11T17:33:32Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-10-11T17:33:32Z"}, "message": "Reorder function sections.", "tree": {"sha": "57eaee8c68f744a73cda132c982b888eb3df3275", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/57eaee8c68f744a73cda132c982b888eb3df3275"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c9cee7c2af5f3d2de06203d697b3890320a3dfc6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c9cee7c2af5f3d2de06203d697b3890320a3dfc6", "html_url": "https://github.com/rust-lang/rust/commit/c9cee7c2af5f3d2de06203d697b3890320a3dfc6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c9cee7c2af5f3d2de06203d697b3890320a3dfc6/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "860573e3e00b5a807021b8c7a94a9672de4fa687", "url": "https://api.github.com/repos/rust-lang/rust/commits/860573e3e00b5a807021b8c7a94a9672de4fa687", "html_url": "https://github.com/rust-lang/rust/commit/860573e3e00b5a807021b8c7a94a9672de4fa687"}], "stats": {"total": 174, "additions": 89, "deletions": 85}, "files": [{"sha": "9048b436911f60ab4a041d3bce4f9c6908ff16e2", "filename": "doc/rust.md", "status": "modified", "additions": 89, "deletions": 85, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/c9cee7c2af5f3d2de06203d697b3890320a3dfc6/doc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/c9cee7c2af5f3d2de06203d697b3890320a3dfc6/doc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.md?ref=c9cee7c2af5f3d2de06203d697b3890320a3dfc6", "patch": "@@ -898,51 +898,69 @@ fn add(x: int, y: int) -> int {\n }\n ~~~~\n \n-#### Diverging functions\n \n-A special kind of function can be declared with a `!` character where the\n-output slot type would normally be. For example:\n+#### Generic functions\n \n-~~~~\n-fn my_err(s: ~str) -> ! {\n-    log(info, s);\n-    fail;\n+A _generic function_ allows one or more _parameterized types_ to\n+appear in its signature. Each type parameter must be explicitly\n+declared, in an angle-bracket-enclosed, comma-separated list following\n+the function name.\n+\n+~~~~ {.xfail-test}\n+fn iter<T>(seq: ~[T], f: fn(T)) {\n+    for seq.each |elt| { f(elt); }\n+}\n+fn map<T, U>(seq: ~[T], f: fn(T) -> U) -> ~[U] {\n+    let mut acc = ~[];\n+    for seq.each |elt| { acc.push(f(elt)); }\n+    acc\n }\n ~~~~\n \n-We call such functions \"diverging\" because they never return a value to the\n-caller. Every control path in a diverging function must end with a\n-[`fail`](#fail-expressions) or a call to another diverging function on every\n-control path. The `!` annotation does *not* denote a type. Rather, the result\n-type of a diverging function is a special type called $\\bot$ (\"bottom\") that\n-unifies with any type. Rust has no syntax for $\\bot$.\n+Inside the function signature and body, the name of the type parameter\n+can be used as a type name.\n \n-It might be necessary to declare a diverging function because as mentioned\n-previously, the typechecker checks that every control path in a function ends\n-with a [`return`](#return-expressions) or diverging expression. So, if `my_err`\n-were declared without the `!` annotation, the following code would not\n-typecheck:\n+When a generic function is referenced, its type is instantiated based\n+on the context of the reference. For example, calling the `iter`\n+function defined above on `[1, 2]` will instantiate type parameter `T`\n+with `int`, and require the closure parameter to have type\n+`fn(int)`.\n \n-~~~~\n-# fn my_err(s: ~str) -> ! { fail }\n+Since a parameter type is opaque to the generic function, the set of\n+operations that can be performed on it is limited. Values of parameter\n+type can always be moved, but they can only be copied when the\n+parameter is given a [`copy` bound](#type-kinds).\n \n-fn f(i: int) -> int {\n-   if i == 42 {\n-     return 42;\n-   }\n-   else {\n-     my_err(~\"Bad number!\");\n-   }\n-}\n+~~~~\n+fn id<T: Copy>(x: T) -> T { x }\n ~~~~\n \n-This will not compile without the `!` annotation on `my_err`,\n-since the `else` branch of the conditional in `f` does not return an `int`,\n-as required by the signature of `f`.\n-Adding the `!` annotation to `my_err` informs the typechecker that,\n-should control ever enter `my_err`, no further type judgments about `f` need to hold,\n-since control will never resume in any context that relies on those judgments.\n-Thus the return type on `f` only needs to reflect the `if` branch of the conditional.\n+Similarly, [trait](#traits) bounds can be specified for type\n+parameters to allow methods with that trait to be called on values\n+of that type.\n+\n+\n+#### Unsafe functions\n+\n+Unsafe functions are those containing unsafe operations that are not contained in an [`unsafe` block](#unsafe-blocks).\n+\n+Unsafe operations are those that potentially violate the memory-safety guarantees of Rust's static semantics.\n+Specifically, the following operations are considered unsafe:\n+\n+  - Dereferencing a [raw pointer](#pointer-types)\n+  - Casting a [raw pointer](#pointer-types) to a safe pointer type\n+  - Breaking the [purity-checking rules](#pure-functions)\n+  - Calling an unsafe function\n+\n+##### Unsafe blocks\n+\n+A block of code can also be prefixed with the `unsafe` keyword,\n+to permit a sequence of unsafe operations in an otherwise-safe function.\n+This facility exists because the static semantics of a Rust are a necessary approximation of the dynamic semantics.\n+When a programmer has sufficient conviction that a sequence of unsafe operations is actually safe,\n+they can encapsulate that sequence (taken as a whole) within an `unsafe` block.\n+The compiler will consider uses of such code \"safe\", to the surrounding context.\n+\n \n #### Pure functions\n \n@@ -1003,66 +1021,52 @@ function. So, to use `foldl` in a pure list length function that a pure function\n could then use, we must use an `unsafe` block wrapped around the call to\n `pure_foldl` in the definition of `pure_length`.\n \n-#### Generic functions\n-\n-A _generic function_ allows one or more _parameterized types_ to\n-appear in its signature. Each type parameter must be explicitly\n-declared, in an angle-bracket-enclosed, comma-separated list following\n-the function name.\n-\n-~~~~ {.xfail-test}\n-fn iter<T>(seq: ~[T], f: fn(T)) {\n-    for seq.each |elt| { f(elt); }\n-}\n-fn map<T, U>(seq: ~[T], f: fn(T) -> U) -> ~[U] {\n-    let mut acc = ~[];\n-    for seq.each |elt| { acc.push(f(elt)); }\n-    acc\n-}\n-~~~~\n-\n-Inside the function signature and body, the name of the type parameter\n-can be used as a type name.\n \n-When a generic function is referenced, its type is instantiated based\n-on the context of the reference. For example, calling the `iter`\n-function defined above on `[1, 2]` will instantiate type parameter `T`\n-with `int`, and require the closure parameter to have type\n-`fn(int)`.\n+#### Diverging functions\n \n-Since a parameter type is opaque to the generic function, the set of\n-operations that can be performed on it is limited. Values of parameter\n-type can always be moved, but they can only be copied when the\n-parameter is given a [`copy` bound](#type-kinds).\n+A special kind of function can be declared with a `!` character where the\n+output slot type would normally be. For example:\n \n ~~~~\n-fn id<T: Copy>(x: T) -> T { x }\n+fn my_err(s: ~str) -> ! {\n+    log(info, s);\n+    fail;\n+}\n ~~~~\n \n-Similarly, [trait](#traits) bounds can be specified for type\n-parameters to allow methods with that trait to be called on values\n-of that type.\n-\n-#### Unsafe functions\n-\n-Unsafe functions are those containing unsafe operations that are not contained in an [`unsafe` block](#unsafe-blocks).\n+We call such functions \"diverging\" because they never return a value to the\n+caller. Every control path in a diverging function must end with a\n+[`fail`](#fail-expressions) or a call to another diverging function on every\n+control path. The `!` annotation does *not* denote a type. Rather, the result\n+type of a diverging function is a special type called $\\bot$ (\"bottom\") that\n+unifies with any type. Rust has no syntax for $\\bot$.\n \n-Unsafe operations are those that potentially violate the memory-safety guarantees of Rust's static semantics.\n-Specifically, the following operations are considered unsafe:\n+It might be necessary to declare a diverging function because as mentioned\n+previously, the typechecker checks that every control path in a function ends\n+with a [`return`](#return-expressions) or diverging expression. So, if `my_err`\n+were declared without the `!` annotation, the following code would not\n+typecheck:\n \n-  - Dereferencing a [raw pointer](#pointer-types)\n-  - Casting a [raw pointer](#pointer-types) to a safe pointer type\n-  - Breaking the [purity-checking rules](#pure-functions)\n-  - Calling an unsafe function\n+~~~~\n+# fn my_err(s: ~str) -> ! { fail }\n \n-##### Unsafe blocks\n+fn f(i: int) -> int {\n+   if i == 42 {\n+     return 42;\n+   }\n+   else {\n+     my_err(~\"Bad number!\");\n+   }\n+}\n+~~~~\n \n-A block of code can also be prefixed with the `unsafe` keyword,\n-to permit a sequence of unsafe operations in an otherwise-safe function.\n-This facility exists because the static semantics of a Rust are a necessary approximation of the dynamic semantics.\n-When a programmer has sufficient conviction that a sequence of unsafe operations is actually safe,\n-they can encapsulate that sequence (taken as a whole) within an `unsafe` block.\n-The compiler will consider uses of such code \"safe\", to the surrounding context.\n+This will not compile without the `!` annotation on `my_err`,\n+since the `else` branch of the conditional in `f` does not return an `int`,\n+as required by the signature of `f`.\n+Adding the `!` annotation to `my_err` informs the typechecker that,\n+should control ever enter `my_err`, no further type judgments about `f` need to hold,\n+since control will never resume in any context that relies on those judgments.\n+Thus the return type on `f` only needs to reflect the `if` branch of the conditional.\n \n \n #### Extern functions"}]}