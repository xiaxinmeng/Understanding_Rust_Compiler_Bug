{"sha": "a9a0ea921b20f64f0253235704889a2950f72535", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE5YTBlYTkyMWIyMGY2NGYwMjUzMjM1NzA0ODg5YTI5NTBmNzI1MzU=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@posteo.net", "date": "2017-07-31T12:51:47Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@posteo.net", "date": "2017-07-31T13:15:44Z"}, "message": "async-llvm(25): Restore -Ztime-passes output for trans and LLVM.", "tree": {"sha": "cdd3e24cf5cd444445f426a07d542ee75507443b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cdd3e24cf5cd444445f426a07d542ee75507443b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a9a0ea921b20f64f0253235704889a2950f72535", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a9a0ea921b20f64f0253235704889a2950f72535", "html_url": "https://github.com/rust-lang/rust/commit/a9a0ea921b20f64f0253235704889a2950f72535", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a9a0ea921b20f64f0253235704889a2950f72535/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bd36df84a57f2719e99c691e7ed23d0264836d41", "url": "https://api.github.com/repos/rust-lang/rust/commits/bd36df84a57f2719e99c691e7ed23d0264836d41", "html_url": "https://github.com/rust-lang/rust/commit/bd36df84a57f2719e99c691e7ed23d0264836d41"}], "stats": {"total": 91, "additions": 79, "deletions": 12}, "files": [{"sha": "244b7f35968894eed7177907624eb7d714f2b455", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 27, "deletions": 5, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/a9a0ea921b20f64f0253235704889a2950f72535/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9a0ea921b20f64f0253235704889a2950f72535/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=a9a0ea921b20f64f0253235704889a2950f72535", "patch": "@@ -57,6 +57,32 @@ pub fn time<T, F>(do_it: bool, what: &str, f: F) -> T where\n     let rv = f();\n     let dur = start.elapsed();\n \n+    print_time_passes_entry_internal(what, dur);\n+\n+    TIME_DEPTH.with(|slot| slot.set(old));\n+\n+    rv\n+}\n+\n+pub fn print_time_passes_entry(do_it: bool, what: &str, dur: Duration) {\n+    if !do_it {\n+        return\n+    }\n+\n+    let old = TIME_DEPTH.with(|slot| {\n+        let r = slot.get();\n+        slot.set(r + 1);\n+        r\n+    });\n+\n+    print_time_passes_entry_internal(what, dur);\n+\n+    TIME_DEPTH.with(|slot| slot.set(old));\n+}\n+\n+fn print_time_passes_entry_internal(what: &str, dur: Duration) {\n+    let indentation = TIME_DEPTH.with(|slot| slot.get());\n+\n     let mem_string = match get_resident() {\n         Some(n) => {\n             let mb = n as f64 / 1_000_000.0;\n@@ -65,14 +91,10 @@ pub fn time<T, F>(do_it: bool, what: &str, f: F) -> T where\n         None => \"\".to_owned(),\n     };\n     println!(\"{}time: {}{}\\t{}\",\n-             repeat(\"  \").take(old).collect::<String>(),\n+             repeat(\"  \").take(indentation).collect::<String>(),\n              duration_to_secs_str(dur),\n              mem_string,\n              what);\n-\n-    TIME_DEPTH.with(|slot| slot.set(old));\n-\n-    rv\n }\n \n // Hack up our own formatting for the duration to make it easier for scripts"}, {"sha": "b3b155c88100a3a5a6a6192f066df53f4e4a17a4", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 40, "deletions": 5, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/a9a0ea921b20f64f0253235704889a2950f72535/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9a0ea921b20f64f0253235704889a2950f72535/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=a9a0ea921b20f64f0253235704889a2950f72535", "patch": "@@ -23,7 +23,7 @@ use llvm::{ModuleRef, TargetMachineRef, PassManagerRef, DiagnosticInfoRef};\n use llvm::SMDiagnosticRef;\n use {CrateTranslation, ModuleSource, ModuleTranslation, CompiledModule, ModuleKind};\n use rustc::hir::def_id::CrateNum;\n-use rustc::util::common::{time, time_depth, set_time_depth, path2cstr};\n+use rustc::util::common::{time, time_depth, set_time_depth, path2cstr, print_time_passes_entry};\n use rustc::util::fs::{link_or_copy, rename_or_copy_remove};\n use errors::{self, Handler, Level, DiagnosticBuilder, FatalError};\n use errors::emitter::{Emitter};\n@@ -44,6 +44,7 @@ use std::str;\n use std::sync::Arc;\n use std::sync::mpsc::{channel, Sender, Receiver};\n use std::slice;\n+use std::time::Instant;\n use std::thread;\n use libc::{c_uint, c_void, c_char, size_t};\n \n@@ -498,9 +499,9 @@ unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n         diag_handler.abort_if_errors();\n \n         // Finally, run the actual optimization passes\n-        time(config.time_passes, &format!(\"llvm function passes [{}]\", cgcx.worker), ||\n+        time(config.time_passes, &format!(\"llvm function passes [{}]\", module_name.unwrap()), ||\n              llvm::LLVMRustRunFunctionPassManager(fpm, llmod));\n-        time(config.time_passes, &format!(\"llvm module passes [{}]\", cgcx.worker), ||\n+        time(config.time_passes, &format!(\"llvm module passes [{}]\", module_name.unwrap()), ||\n              llvm::LLVMRunPassManager(mpm, llmod));\n \n         // Deallocate managers that we're now done with\n@@ -563,7 +564,7 @@ unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n         llvm::LLVMWriteBitcodeToFile(llmod, bc_out_c.as_ptr());\n     }\n \n-    time(config.time_passes, &format!(\"codegen passes [{}]\", cgcx.worker),\n+    time(config.time_passes, &format!(\"codegen passes [{}]\", module_name.unwrap()),\n          || -> Result<(), FatalError> {\n         if config.emit_ir {\n             let out = output_names.temp_path(OutputType::LlvmAssembly, module_name);\n@@ -756,6 +757,11 @@ pub fn start_async_translation(sess: &Session,\n     metadata_config.set_flags(sess, no_builtins);\n     allocator_config.set_flags(sess, no_builtins);\n \n+    // Exclude metadata and allocator modules from time_passes output, since\n+    // they throw off the \"LLVM passes\" measurement.\n+    metadata_config.time_passes = false;\n+    allocator_config.time_passes = false;\n+\n     let client = sess.jobserver_from_env.clone().unwrap_or_else(|| {\n         // Pick a \"reasonable maximum\" if we don't otherwise have a jobserver in\n         // our environment, capping out at 32 so we don't take everything down\n@@ -1266,6 +1272,9 @@ fn start_executing_work(sess: &Session,\n     // manner we can ensure that the maximum number of parallel workers is\n     // capped at any one point in time.\n     return thread::spawn(move || {\n+        // We pretend to be within the top-level LLVM time-passes task here:\n+        set_time_depth(1);\n+\n         let max_workers = ::num_cpus::get();\n         let mut worker_id_counter = 0;\n         let mut free_worker_ids = Vec::new();\n@@ -1298,6 +1307,8 @@ fn start_executing_work(sess: &Session,\n         let mut main_thread_worker_state = MainThreadWorkerState::Idle;\n         let mut running = 0;\n \n+        let mut llvm_start_time = None;\n+\n         // Run the message loop while there's still anything that needs message\n         // processing:\n         while !translation_done ||\n@@ -1323,6 +1334,7 @@ fn start_executing_work(sess: &Session,\n                             worker: get_worker_id(&mut free_worker_ids),\n                             .. cgcx.clone()\n                         };\n+                        maybe_start_llvm_timer(&item, &mut llvm_start_time);\n                         main_thread_worker_state = MainThreadWorkerState::LLVMing;\n                         spawn_work(cgcx, item);\n                     }\n@@ -1338,7 +1350,7 @@ fn start_executing_work(sess: &Session,\n                                 worker: get_worker_id(&mut free_worker_ids),\n                                 .. cgcx.clone()\n                             };\n-\n+                            maybe_start_llvm_timer(&item, &mut llvm_start_time);\n                             main_thread_worker_state = MainThreadWorkerState::LLVMing;\n                             spawn_work(cgcx, item);\n                         }\n@@ -1358,6 +1370,8 @@ fn start_executing_work(sess: &Session,\n             while work_items.len() > 0 && running < tokens.len() {\n                 let (item, _) = work_items.pop().unwrap();\n \n+                maybe_start_llvm_timer(&item, &mut llvm_start_time);\n+\n                 let cgcx = CodegenContext {\n                     worker: get_worker_id(&mut free_worker_ids),\n                     .. cgcx.clone()\n@@ -1465,6 +1479,16 @@ fn start_executing_work(sess: &Session,\n             }\n         }\n \n+        if let Some(llvm_start_time) = llvm_start_time {\n+            let total_llvm_time = Instant::now().duration_since(llvm_start_time);\n+            // This is the top-level timing for all of LLVM, set the time-depth\n+            // to zero.\n+            set_time_depth(0);\n+            print_time_passes_entry(cgcx.time_passes,\n+                                    \"LLVM passes\",\n+                                    total_llvm_time);\n+        }\n+\n         CompiledModules {\n             modules: compiled_modules,\n             metadata_module: compiled_metadata_module.unwrap(),\n@@ -1480,6 +1504,17 @@ fn start_executing_work(sess: &Session,\n         // Tune me, plz.\n         items_in_queue >= max_workers.saturating_sub(workers_running / 2)\n     }\n+\n+    fn maybe_start_llvm_timer(work_item: &WorkItem,\n+                              llvm_start_time: &mut Option<Instant>) {\n+        // We keep track of the -Ztime-passes output manually,\n+        // since the closure-based interface does not fit well here.\n+        if work_item.config.time_passes {\n+            if llvm_start_time.is_none() {\n+                *llvm_start_time = Some(Instant::now());\n+            }\n+        }\n+    }\n }\n \n pub const TRANS_WORKER_ID: usize = ::std::usize::MAX;"}, {"sha": "70283ea55c5c0e9b142309b49cedf7e4421607fa", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a9a0ea921b20f64f0253235704889a2950f72535/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9a0ea921b20f64f0253235704889a2950f72535/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=a9a0ea921b20f64f0253235704889a2950f72535", "patch": "@@ -43,7 +43,7 @@ use rustc::ty::{self, Ty, TyCtxt};\n use rustc::dep_graph::AssertDepGraphSafe;\n use rustc::middle::cstore::LinkMeta;\n use rustc::hir::map as hir_map;\n-use rustc::util::common::time;\n+use rustc::util::common::{time, print_time_passes_entry};\n use rustc::session::config::{self, NoDebugInfo, OutputFilenames, OutputType};\n use rustc::session::Session;\n use rustc_incremental::{self, IncrementalHashesMap};\n@@ -80,7 +80,7 @@ use libc::c_uint;\n use std::ffi::{CStr, CString};\n use std::str;\n use std::sync::Arc;\n-use std::time::Instant;\n+use std::time::{Instant, Duration};\n use std::i32;\n use syntax_pos::Span;\n use syntax::attr;\n@@ -1093,6 +1093,8 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         codegen_units\n     };\n \n+    let mut total_trans_time = Duration::new(0, 0);\n+\n     for (cgu_index, cgu) in codegen_units.into_iter().enumerate() {\n         ongoing_translation.wait_for_signal_to_translate_item();\n         ongoing_translation.check_for_errors(tcx.sess);\n@@ -1128,6 +1130,8 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         let cost = time_to_translate.as_secs() * 1_000_000_000 +\n                    time_to_translate.subsec_nanos() as u64;\n \n+        total_trans_time += time_to_translate;\n+\n         let is_last_cgu = (cgu_index + 1) == codegen_unit_count;\n \n         ongoing_translation.submit_translated_module_to_llvm(tcx.sess,\n@@ -1137,6 +1141,12 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         ongoing_translation.check_for_errors(tcx.sess);\n     }\n \n+    // Since the main thread is sometimes blocked during trans, we keep track\n+    // -Ztime-passes output manually.\n+    print_time_passes_entry(tcx.sess.time_passes(),\n+                            \"translate to LLVM IR\",\n+                            total_trans_time);\n+\n     if let Some(module_dispositions) = module_dispositions {\n         assert_module_sources::assert_module_sources(tcx, &module_dispositions);\n     }"}]}