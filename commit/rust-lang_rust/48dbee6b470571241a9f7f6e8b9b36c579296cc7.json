{"sha": "48dbee6b470571241a9f7f6e8b9b36c579296cc7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ4ZGJlZTZiNDcwNTcxMjQxYTlmN2Y2ZThiOWIzNmM1NzkyOTZjYzc=", "commit": {"author": {"name": "Paul Stansifer", "email": "paul.stansifer@gmail.com", "date": "2011-07-08T23:35:09Z"}, "committer": {"name": "Paul Stansifer", "email": "paul.stansifer@gmail.com", "date": "2011-07-12T01:52:50Z"}, "message": "Add elipses, reorganize the macro components into their own AST node.", "tree": {"sha": "90078180a266bca002d5a4f46fbf8ee1afbed5e1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/90078180a266bca002d5a4f46fbf8ee1afbed5e1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/48dbee6b470571241a9f7f6e8b9b36c579296cc7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/48dbee6b470571241a9f7f6e8b9b36c579296cc7", "html_url": "https://github.com/rust-lang/rust/commit/48dbee6b470571241a9f7f6e8b9b36c579296cc7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/48dbee6b470571241a9f7f6e8b9b36c579296cc7/comments", "author": {"login": "paulstansifer", "id": 1431, "node_id": "MDQ6VXNlcjE0MzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1431?v=4", "gravatar_id": "", "url": "https://api.github.com/users/paulstansifer", "html_url": "https://github.com/paulstansifer", "followers_url": "https://api.github.com/users/paulstansifer/followers", "following_url": "https://api.github.com/users/paulstansifer/following{/other_user}", "gists_url": "https://api.github.com/users/paulstansifer/gists{/gist_id}", "starred_url": "https://api.github.com/users/paulstansifer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/paulstansifer/subscriptions", "organizations_url": "https://api.github.com/users/paulstansifer/orgs", "repos_url": "https://api.github.com/users/paulstansifer/repos", "events_url": "https://api.github.com/users/paulstansifer/events{/privacy}", "received_events_url": "https://api.github.com/users/paulstansifer/received_events", "type": "User", "site_admin": false}, "committer": {"login": "paulstansifer", "id": 1431, "node_id": "MDQ6VXNlcjE0MzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1431?v=4", "gravatar_id": "", "url": "https://api.github.com/users/paulstansifer", "html_url": "https://github.com/paulstansifer", "followers_url": "https://api.github.com/users/paulstansifer/followers", "following_url": "https://api.github.com/users/paulstansifer/following{/other_user}", "gists_url": "https://api.github.com/users/paulstansifer/gists{/gist_id}", "starred_url": "https://api.github.com/users/paulstansifer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/paulstansifer/subscriptions", "organizations_url": "https://api.github.com/users/paulstansifer/orgs", "repos_url": "https://api.github.com/users/paulstansifer/repos", "events_url": "https://api.github.com/users/paulstansifer/events{/privacy}", "received_events_url": "https://api.github.com/users/paulstansifer/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "425732311af6d7a4f972dff04e1abb7db6a22f3b", "url": "https://api.github.com/repos/rust-lang/rust/commits/425732311af6d7a4f972dff04e1abb7db6a22f3b", "html_url": "https://github.com/rust-lang/rust/commit/425732311af6d7a4f972dff04e1abb7db6a22f3b"}], "stats": {"total": 309, "additions": 206, "deletions": 103}, "files": [{"sha": "e732a5b83e3f222dc8b66dbb1b8b447fbbf5a6d5", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/48dbee6b470571241a9f7f6e8b9b36c579296cc7/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48dbee6b470571241a9f7f6e8b9b36c579296cc7/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=48dbee6b470571241a9f7f6e8b9b36c579296cc7", "patch": "@@ -6378,7 +6378,7 @@ fn trans_expr_out(&@block_ctxt cx, &@ast::expr e, out_method output) ->\n         case (ast::expr_rec(?args, ?base)) {\n             ret trans_rec(cx, args, base, e.id);\n         }\n-        case (ast::expr_ext(_, _, _)) {\n+        case (ast::expr_mac(_)) {\n             ret cx.fcx.lcx.ccx.sess.bug(\"unexpanded macro\");\n         }\n         case (ast::expr_fail(?expr)) {"}, {"sha": "8f6ab760012f9905553d43e78c304a8dae574509", "filename": "src/comp/middle/tstate/pre_post_conditions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/48dbee6b470571241a9f7f6e8b9b36c579296cc7/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48dbee6b470571241a9f7f6e8b9b36c579296cc7/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs?ref=48dbee6b470571241a9f7f6e8b9b36c579296cc7", "patch": "@@ -570,7 +570,7 @@ fn find_pre_post_expr(&fn_ctxt fcx, @expr e) {\n         case (expr_break) { clear_pp(expr_pp(fcx.ccx, e)); }\n         case (expr_cont) { clear_pp(expr_pp(fcx.ccx, e)); }\n         case (expr_port(_)) { clear_pp(expr_pp(fcx.ccx, e)); }\n-        case (expr_ext(_, _, _)) {\n+        case (expr_mac(_)) {\n             fcx.ccx.tcx.sess.bug(\"unexpanded macro\");\n         }\n         case (expr_anon_obj(?anon_obj, _)) {"}, {"sha": "9c41dd995500ee3be208193d93f994f60a31de4b", "filename": "src/comp/middle/tstate/states.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/48dbee6b470571241a9f7f6e8b9b36c579296cc7/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48dbee6b470571241a9f7f6e8b9b36c579296cc7/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs?ref=48dbee6b470571241a9f7f6e8b9b36c579296cc7", "patch": "@@ -367,7 +367,7 @@ fn find_pre_post_state_expr(&fn_ctxt fcx, &prestate pres, @expr e) -> bool {\n         case (expr_chan(?ex)) {\n             ret find_pre_post_state_sub(fcx, pres, ex, e.id, none);\n         }\n-        case (expr_ext(_, _, _)) {\n+        case (expr_mac(_)) {\n             fcx.ccx.tcx.sess.bug(\"unexpanded macro\");\n         }\n         case (expr_put(?maybe_e)) {"}, {"sha": "b74e49508591b61c9531aeb3058ffa10bcbb8e62", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/48dbee6b470571241a9f7f6e8b9b36c579296cc7/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48dbee6b470571241a9f7f6e8b9b36c579296cc7/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=48dbee6b470571241a9f7f6e8b9b36c579296cc7", "patch": "@@ -1780,7 +1780,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n             }\n             write::ty_only_fixup(fcx, id, tpt._1);\n         }\n-        case (ast::expr_ext(_,_,_)) {\n+        case (ast::expr_mac(_)) {\n             fcx.ccx.tcx.sess.bug(\"unexpanded macro\");\n         }\n         case (ast::expr_fail(?expr_opt)) {"}, {"sha": "71fc2b6cf96c8342a117b70614d07f521600d9ed", "filename": "src/comp/syntax/ast.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/48dbee6b470571241a9f7f6e8b9b36c579296cc7/src%2Fcomp%2Fsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48dbee6b470571241a9f7f6e8b9b36c579296cc7/src%2Fcomp%2Fsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fast.rs?ref=48dbee6b470571241a9f7f6e8b9b36c579296cc7", "patch": "@@ -305,7 +305,6 @@ tag expr_ {\n     expr_field(@expr, ident);\n     expr_index(@expr, @expr);\n     expr_path(path);\n-    expr_ext(path, (@expr)[], option::t[str]);\n     expr_fail(option::t[@expr]);\n     expr_break;\n     expr_cont;\n@@ -323,7 +322,18 @@ tag expr_ {\n       to expr_if_check. */\n     expr_if_check(@expr, block, option::t[@expr]);\n     expr_port(option::t[@ty]);\n+    expr_chan(@expr);\n     expr_anon_obj(anon_obj, ty_param[]);\n+    expr_mac(mac);\n+}\n+\n+type mac = spanned[mac_];\n+\n+tag mac_ {\n+    mac_invoc(path, (@expr)[], option::t[str]);\n+    mac_embed_type(@ty);\n+    mac_embed_block(block);\n+    mac_elipsis;\n }\n \n type lit = spanned[lit_];\n@@ -433,6 +443,7 @@ tag ty_ {\n     ty_path(path, node_id);\n     ty_type;\n     ty_constr(@ty, (@constr)[]);\n+    ty_mac(mac);\n }\n \n "}, {"sha": "0ffb4891f2eb667203a9799a88f537437ab212cf", "filename": "src/comp/syntax/ext/expand.rs", "status": "modified", "additions": 32, "deletions": 19, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/48dbee6b470571241a9f7f6e8b9b36c579296cc7/src%2Fcomp%2Fsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48dbee6b470571241a9f7f6e8b9b36c579296cc7/src%2Fcomp%2Fsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fexpand.rs?ref=48dbee6b470571241a9f7f6e8b9b36c579296cc7", "patch": "@@ -3,7 +3,8 @@ import codemap::emit_error;\n import driver::session;\n import syntax::ast::crate;\n import syntax::ast::expr_;\n-import syntax::ast::expr_ext;\n+import syntax::ast::expr_mac;\n+import syntax::ast::mac_invoc;\n import syntax::fold::*;\n \n import std::option::none;\n@@ -16,27 +17,39 @@ fn expand_expr(&hashmap[str, base::syntax_extension] exts,\n                &session::session sess, &expr_ e, ast_fold fld, \n                &fn(&ast::expr_, ast_fold) -> expr_ orig) -> expr_ {\n     ret alt(e) {\n-        case (expr_ext(?pth, ?args, ?body)) {\n-            assert(ivec::len(pth.node.idents) > 0u);\n-            auto extname = pth.node.idents.(0);\n-            auto ext_cx = base::mk_ctxt(sess);\n-            alt (exts.find(extname)) {\n-                case (none) {\n-                    emit_error(some(pth.span), \"unknown syntax expander: '\"\n-                               + extname + \"'\", sess.get_codemap());\n-                    fail\n-                }\n-                case (some(base::normal(?ext))) {\n-                    //keep going, outside-in\n-                    fld.fold_expr(ext(ext_cx, pth.span, args, body)).node\n+        case (expr_mac(?mac)) {\n+            alt(mac.node) {\n+                case (mac_invoc(?pth, ?args, ?body)) {\n+                    assert(ivec::len(pth.node.idents) > 0u);\n+                    auto extname = pth.node.idents.(0);\n+                    auto ext_cx = base::mk_ctxt(sess);\n+                    alt (exts.find(extname)) {\n+                        case (none) {\n+                            emit_error(some(pth.span), \n+                                       \"unknown syntax expander: '\"\n+                                       + extname + \"'\", sess.get_codemap());\n+                            fail\n+                        }\n+                        case (some(base::normal(?ext))) {\n+                            //keep going, outside-in\n+                            fld.fold_expr(ext(ext_cx, pth.span, \n+                                              args, body)).node\n+                        }\n+                        case (some(base::macro_defining(?ext))) {\n+                            auto named_extension \n+                                = ext(ext_cx, pth.span, args, body);\n+                            exts.insert(named_extension._0,\n+                                        named_extension._1);\n+                            ast::expr_tup(~[])\n+                        }\n+                    }\n                 }\n-                case (some(base::macro_defining(?ext))) {\n-                    auto named_extension = ext(ext_cx, pth.span, args, body);\n-                    exts.insert(named_extension._0, named_extension._1);\n-                    ast::expr_tup([])\n+                case (_) {\n+                    emit_error(some(mac.span), \"naked syntactic bit\",\n+                               sess.get_codemap());\n+                    fail\n                 }\n             }\n-\n         }\n         case (_) { orig(e, fld) }\n     };"}, {"sha": "747d634e60d7a381815f3f7d09f9cd0bc3a3d6d5", "filename": "src/comp/syntax/ext/simplext.rs", "status": "modified", "additions": 44, "deletions": 32, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/48dbee6b470571241a9f7f6e8b9b36c579296cc7/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48dbee6b470571241a9f7f6e8b9b36c579296cc7/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs?ref=48dbee6b470571241a9f7f6e8b9b36c579296cc7", "patch": "@@ -22,11 +22,12 @@ import ast::path;\n import ast::path_;\n import ast::expr_path;\n import ast::expr_vec;\n-import ast::expr_ext;\n+import ast::expr_mac;\n+import ast::mac_invoc;\n \n export add_new_extension;\n \n-fn lookup(&vec[invk_binding] ibs, ident i) -> option::t[invk_binding] {\n+fn lookup(&(invk_binding)[] ibs, ident i) -> option::t[invk_binding] {\n     for (invk_binding ib in ibs) {\n         alt (ib) {\n             case (ident_binding(?p_id, _)) { if (i == p_id) { ret some(ib); }}\n@@ -96,7 +97,7 @@ fn subst_expr(&ext_ctxt cx, &(invk_binding)[] ibs, &ast::expr_ e,\n     }\n }\n \n-type pat_ext = rec(vec[@ast::expr] invk, @ast::expr body);\n+type pat_ext = rec((@ast::expr)[] invk, @ast::expr body);\n \n // maybe box?\n tag invk_binding {\n@@ -113,6 +114,24 @@ fn path_to_ident(&path pth) -> option::t[ident] {\n     ret none;\n }\n \n+fn process_clause(&ext_ctxt cx, &mutable vec[pat_ext] pes,\n+                  &mutable option::t[str] macro_name, &path pth, \n+                  &(@ast::expr)[] invoc_args, @ast::expr body) {\n+    let str clause_name = alt(path_to_ident(pth)) {\n+        case (some(?id)) { id }\n+        case (none) {\n+            cx.span_fatal(pth.span, \"macro name must not be a path\")\n+        }\n+    };\n+    if (macro_name == none) {\n+        macro_name = some(clause_name);\n+    } else if (macro_name != some(clause_name)) {\n+        cx.span_fatal(pth.span, \"#macro can only introduce one name\");\n+    }\n+    pes += [rec(invk=invoc_args, body=body)];\n+}\n+\n+\n fn add_new_extension(&ext_ctxt cx, span sp, &(@ast::expr)[] args,\n                      option::t[str] body) -> tup(str, syntax_extension) {\n     let option::t[str] macro_name = none;\n@@ -121,28 +140,19 @@ fn add_new_extension(&ext_ctxt cx, span sp, &(@ast::expr)[] args,\n         alt(arg.node) {\n             case(expr_vec(?elts, ?mut, ?seq_kind)) {\n                 \n-                if (len(elts) != 2u) {\n+                if (ivec::len(elts) != 2u) {\n                     cx.span_fatal((*arg).span, \n                                   \"extension clause must consist of [\" + \n                                   \"macro invocation, expansion body]\");\n                 }\n                 alt(elts.(0u).node) {\n-                    case(expr_ext(?pth, ?invk_args, ?body)) {\n-                        let str clause_name = alt(path_to_ident(pth)) {\n-                            case (some(?id)) { id }\n-                            case (none) {\n-                                cx.span_fatal\n-                                (elts.(0u).span,\n-                                 \"macro name must not be a path\")\n+                    case(expr_mac(?mac)) {\n+                        alt (mac.node) {\n+                            case (mac_invoc(?pth, ?invoc_args, ?body)) {\n+                                process_clause(cx, pat_exts, macro_name,\n+                                               pth, invoc_args, elts.(1u));\n                             }\n-                        };\n-                        if (macro_name == none) {\n-                            macro_name = some(clause_name);\n-                        } else if (macro_name != some(clause_name)) {\n-                            cx.span_fatal(elts.(0u).span, \"macros must have\"\n-                                          + \" only one name\");\n                         }\n-                        pat_exts += [rec(invk=invk_args, body=elts.(1u))];\n                     }\n                     case(_) {\n                         cx.span_fatal(elts.(0u).span, \"extension clause must\"\n@@ -169,25 +179,25 @@ fn add_new_extension(&ext_ctxt cx, span sp, &(@ast::expr)[] args,\n             normal(ext));\n \n \n-    fn generic_extension(&ext_ctxt cx, span sp, &vec[@ast::expr] args,\n+    fn generic_extension(&ext_ctxt cx, span sp, &(@ast::expr)[] args,\n                          option::t[str] body, @vec[pat_ext] clauses)\n         -> @ast::expr {\n \n         /* returns a list of bindings, or none if the match fails. */\n         fn match_invk(@ast::expr pattern, @ast::expr argument)\n-            -> option::t[vec[invk_binding]] {\n+            -> option::t[(invk_binding)[]] {\n             auto pat = pattern.node;\n             auto arg = argument.node;\n             ret alt (pat) {\n                 case (expr_vec(?p_elts, _, _)) {\n                     alt (arg) {\n                         case (expr_vec(?a_elts, _, _)) {\n-                            if (vec::len(p_elts) != vec::len(a_elts)) { \n+                            if (ivec::len(p_elts) != ivec::len(a_elts)) { \n                                 none[vec[invk_binding]]\n                             }\n                             let uint i = 0u;\n-                            let vec[invk_binding] res = [];\n-                            while (i < vec::len(p_elts)) {\n+                            let (invk_binding)[] res = ~[];\n+                            while (i < ivec::len(p_elts)) {\n                                 alt (match_invk(p_elts.(i), a_elts.(i))) {\n                                     case (some(?v)) { res += v; }\n                                     case (none) { ret none; }\n@@ -207,34 +217,36 @@ fn add_new_extension(&ext_ctxt cx, span sp, &(@ast::expr)[] args,\n                                 case (expr_path(?a_pth)) {\n                                     alt (path_to_ident(a_pth)) {\n                                         case (some(?a_id)) {\n-                                            some([ident_binding\n-                                                  (p_id, respan(argument.span,\n+                                            some(~[ident_binding\n+                                                   (p_id, \n+                                                    respan(argument.span,\n                                                                  a_id))])\n                                         }\n                                         case (none) {\n-                                            some([path_binding(p_id, @a_pth)])\n+                                            some(~[path_binding(p_id, \n+                                                                @a_pth)])\n                                         }\n                                     }\n                                 }\n                                 case (_) {\n-                                    some([expr_binding(p_id, argument)])\n+                                    some(~[expr_binding(p_id, argument)])\n                                 }\n                             }\n                         }\n                         // FIXME this still compares on internal spans\n-                        case (_) { if(pat == arg) { some([]) } else { none } }\n+                        case (_) { if(pat == arg) { some(~[]) } else { none }}\n                     }\n                 }\n                 // FIXME this still compares on internal spans\n-                case (_) { if (pat == arg) { some([]) } else { none } }\n+                case (_) { if (pat == arg) { some(~[]) } else { none }}\n             }\n         }\n \n         for (pat_ext pe in *clauses) {\n-            if (vec::len(args) != vec::len(pe.invk)) { cont; }\n+            if (ivec::len(args) != ivec::len(pe.invk)) { cont; }\n             let uint i = 0u;\n-            let vec[invk_binding] bindings = [];\n-            while (i < vec::len(args)) {\n+            let (invk_binding)[] bindings = ~[];\n+            while (i < ivec::len(args)) {\n                 alt (match_invk(pe.invk.(i), args.(i))) {\n                     case (some(?v)) { bindings += v; }\n                     case (none) { cont }"}, {"sha": "b41e8bbc09a42f3c1d7f46658ef6143e65ab1fd9", "filename": "src/comp/syntax/fold.rs", "status": "modified", "additions": 22, "deletions": 9, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/48dbee6b470571241a9f7f6e8b9b36c579296cc7/src%2Fcomp%2Fsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48dbee6b470571241a9f7f6e8b9b36c579296cc7/src%2Fcomp%2Fsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Ffold.rs?ref=48dbee6b470571241a9f7f6e8b9b36c579296cc7", "patch": "@@ -126,6 +126,25 @@ fn fold_arg_(&arg a, ast_fold fld) -> arg {\n     ret rec(mode=a.mode, ty=fld.fold_ty(a.ty), \n             ident=fld.fold_ident(a.ident), id=a.id);\n }\n+//used in noop_fold_expr, and possibly elsewhere in the future\n+fn fold_mac_(&mac m, ast_fold fld) -> mac {\n+    ret rec(node=\n+            alt(m.node) {\n+                case (mac_invoc(?pth,?args,?body)) {\n+                    mac_invoc(fld.fold_path(pth), \n+                              ivec::map(fld.fold_expr, args), body)\n+                }\n+                case (mac_embed_type(?ty)) { \n+                    mac_embed_type(fld.fold_ty(ty))\n+                }\n+                case (mac_embed_block(?block)) {\n+                    mac_embed_block(fld.fold_block(block))\n+                }\n+                case (mac_elipsis) { mac_elipsis }\n+            },\n+            span=m.span);\n+}\n+\n \n \n \n@@ -319,6 +338,7 @@ fn noop_fold_expr(&expr_ e, ast_fold fld) -> expr_ {\n     }\n     auto fold_anon_obj = bind fold_anon_obj_(_,fld);\n     \n+    auto fold_mac = bind fold_mac_(_,fld);\n \n     ret alt (e) {\n         case (expr_vec(?exprs, ?mut, ?seq_kind)) {\n@@ -414,10 +434,6 @@ fn noop_fold_expr(&expr_ e, ast_fold fld) -> expr_ {\n         case (expr_path(?pth)) {\n             expr_path(fld.fold_path(pth))\n                 }\n-        case (expr_ext(?pth, ?args, ?body)) {\n-            expr_ext(fld.fold_path(pth), ivec::map(fld.fold_expr, args),\n-                     body, fld.fold_expr(expanded))\n-                }\n         case (expr_fail(?e)) { expr_fail(option::map(fld.fold_expr, e)) }\n         case (expr_break()) { e }\n         case (expr_cont()) { e }\n@@ -445,11 +461,8 @@ fn noop_fold_expr(&expr_ e, ast_fold fld) -> expr_ {\n         case (expr_anon_obj(?ao, ?typms)) {\n             expr_anon_obj(fold_anon_obj(ao), typms)\n                 }\n-        case (expr_embeded_type(?ty)) {\n-            expr_embeded_type(fld.fold_ty(ty))\n-        }\n-        case (expr_embeded_block(?blk)) {\n-            expr_embeded_block(fld.fold_block(blk))\n+        case (expr_mac(?mac)) {\n+            expr_mac(fold_mac(mac))\n         }\n     }\n }"}, {"sha": "d5c0b2c09bb050ac6c386e6a5717de71960f2459", "filename": "src/comp/syntax/parse/lexer.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/48dbee6b470571241a9f7f6e8b9b36c579296cc7/src%2Fcomp%2Fsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48dbee6b470571241a9f7f6e8b9b36c579296cc7/src%2Fcomp%2Fsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Flexer.rs?ref=48dbee6b470571241a9f7f6e8b9b36c579296cc7", "patch": "@@ -365,7 +365,15 @@ fn next_token(&reader rdr) -> token::token {\n         case ('?') { rdr.bump(); ret token::QUES; }\n         case (';') { rdr.bump(); ret token::SEMI; }\n         case (',') { rdr.bump(); ret token::COMMA; }\n-        case ('.') { rdr.bump(); ret token::DOT; }\n+        case ('.') { \n+            rdr.bump(); \n+            if (rdr.curr() == '.' && rdr.next() == '.') {\n+                rdr.bump();\n+                rdr.bump();\n+                ret token::ELIPSIS;\n+            }\n+            ret token::DOT;\n+        }\n         case ('(') { rdr.bump(); ret token::LPAREN; }\n         case (')') { rdr.bump(); ret token::RPAREN; }\n         case ('{') { rdr.bump(); ret token::LBRACE; }"}, {"sha": "79ee47ffba9d39059cf0ebbd1554419be62bde70", "filename": "src/comp/syntax/parse/parser.rs", "status": "modified", "additions": 21, "deletions": 5, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/48dbee6b470571241a9f7f6e8b9b36c579296cc7/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48dbee6b470571241a9f7f6e8b9b36c579296cc7/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs?ref=48dbee6b470571241a9f7f6e8b9b36c579296cc7", "patch": "@@ -740,6 +740,12 @@ fn mk_expr(&parser p, uint lo, uint hi, &ast::expr_ node) -> @ast::expr {\n              span=rec(lo=lo, hi=hi));\n }\n \n+fn mk_mac_expr(&parser p, uint lo, uint hi, &ast::mac_ m) -> @ast::expr {\n+    ret @rec(id=p.get_id(),\n+             node=ast::expr_mac(rec(node=m, span=rec(lo=lo, hi=hi))),\n+             span=rec(lo=lo, hi=hi));\n+}\n+\n fn parse_bottom_expr(&parser p) -> @ast::expr {\n     auto lo = p.get_lo_pos();\n     auto hi = p.get_hi_pos();\n@@ -800,11 +806,14 @@ fn parse_bottom_expr(&parser p) -> @ast::expr {\n         ex = ast::expr_vec(es, mut, ast::sk_rc);\n     } else if (p.peek() == token::POUND_LT) {\n         p.bump();\n-        ex = ast::expr_embeded_type(parse_ty(p));\n+        auto ty = parse_ty(p);\n         expect(p, token::GT);\n+        /* hack: early return to take advantage of specialized function */\n+        ret mk_mac_expr(p, lo, p.get_hi_pos(), ast::mac_embed_type(ty))\n     } else if (p.peek() == token::POUND_LBRACE) {\n         p.bump();\n-        ex = ast::expr_embeded_block(parse_block_tail(p));\n+        auto blk = ast::mac_embed_block(parse_block_tail(p));\n+        ret mk_mac_expr(p, lo, p.get_hi_pos(), blk);\n     } else if (p.peek() == token::TILDE) {\n         p.bump();\n         alt (p.peek()) {\n@@ -899,7 +908,7 @@ fn parse_bottom_expr(&parser p) -> @ast::expr {\n         ex = ast::expr_bind(e, es.node);\n     } else if (p.peek() == token::POUND) {\n         auto ex_ext = parse_syntax_ext(p);\n-        lo = ex_ext.span.lo;\n+        hi = ex_ext.span.hi;\n         ex = ex_ext.node;\n     } else if (eat_word(p, \"fail\")) {\n         if (can_begin_expr(p.peek())) {\n@@ -913,25 +922,30 @@ fn parse_bottom_expr(&parser p) -> @ast::expr {\n     } else if (eat_word(p, \"log\")) {\n         auto e = parse_expr(p);\n         ex = ast::expr_log(1, e);\n+        hi = e.span.hi;\n     } else if (eat_word(p, \"log_err\")) {\n         auto e = parse_expr(p);\n         ex = ast::expr_log(0, e);\n+        hi = e.span.hi;\n     } else if (eat_word(p, \"assert\")) {\n         auto e = parse_expr(p);\n         ex = ast::expr_assert(e);\n+        hi = e.span.hi;\n     } else if (eat_word(p, \"check\")) {\n         /* Should be a predicate (pure boolean function) applied to \n            arguments that are all either slot variables or literals.\n            but the typechecker enforces that. */\n \n         auto e = parse_expr(p);\n+        hi = e.span.hi;\n         ex = ast::expr_check(ast::checked, e);\n     } else if (eat_word(p, \"claim\")) {\n         /* Same rules as check, except that if check-claims\n          is enabled (a command-line flag), then the parser turns\n         claims into check */\n         \n         auto e = parse_expr(p);\n+        hi = e.span.hi;\n         ex = ast::expr_check(ast::unchecked, e);\n     } else if (eat_word(p, \"ret\")) {\n         alt (p.peek()) {\n@@ -946,8 +960,10 @@ fn parse_bottom_expr(&parser p) -> @ast::expr {\n         }\n     } else if (eat_word(p, \"break\")) {\n         ex = ast::expr_break;\n+        hi = p.get_hi_pos();\n     } else if (eat_word(p, \"cont\")) {\n         ex = ast::expr_cont;\n+        hi = p.get_hi_pos();\n     } else if (eat_word(p, \"put\")) {\n         alt (p.peek()) {\n             case (token::SEMI) { ex = ast::expr_put(none); }\n@@ -1022,7 +1038,7 @@ fn parse_syntax_ext_naked(&parser p, uint lo) -> @ast::expr {\n     auto es = parse_seq_ivec(token::LPAREN, token::RPAREN,\n                              some(token::COMMA), parse_expr, p);\n     auto hi = es.span.hi;\n-    ret mk_expr(p, lo, hi, ast::expr_ext(pth, es.node, none));\n+    ret mk_mac_expr(p, lo, hi, ast::mac_invoc(pth, es.node, none));\n }\n \n fn parse_self_method(&parser p) -> @ast::expr {\n@@ -1661,7 +1677,7 @@ fn stmt_ends_with_semi(&ast::stmt stmt) -> bool {\n                 case (ast::expr_field(_, _)) { true }\n                 case (ast::expr_index(_, _)) { true }\n                 case (ast::expr_path(_)) { true }\n-                case (ast::expr_ext(_, _, _)) { true }\n+                case (ast::expr_mac(_)) { true }\n                 case (ast::expr_fail(_)) { true }\n                 case (ast::expr_break) { true }\n                 case (ast::expr_cont) { true }"}, {"sha": "d96094e4d934cde46009af78bdf8b131d9a7e909", "filename": "src/comp/syntax/parse/token.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/48dbee6b470571241a9f7f6e8b9b36c579296cc7/src%2Fcomp%2Fsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48dbee6b470571241a9f7f6e8b9b36c579296cc7/src%2Fcomp%2Fsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Ftoken.rs?ref=48dbee6b470571241a9f7f6e8b9b36c579296cc7", "patch": "@@ -43,6 +43,7 @@ tag token {\n     /* Structural symbols */\n     AT;\n     DOT;\n+    ELIPSIS;\n     COMMA;\n     SEMI;\n     COLON;"}, {"sha": "2fcef0d761360a12560ded84ee695f3655f90ba9", "filename": "src/comp/syntax/print/pprust.rs", "status": "modified", "additions": 39, "deletions": 12, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/48dbee6b470571241a9f7f6e8b9b36c579296cc7/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48dbee6b470571241a9f7f6e8b9b36c579296cc7/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs?ref=48dbee6b470571241a9f7f6e8b9b36c579296cc7", "patch": "@@ -602,11 +602,19 @@ fn print_stmt(&ps s, &ast::stmt st) {\n     maybe_print_trailing_comment(s, st.span, none[uint]);\n }\n \n-fn print_block(&ps s, ast::block blk) {\n+fn print_block(&ps s, &ast::block blk) {\n+    print_possibly_embedded_block(s, blk, false);\n+} \n+\n+fn print_possibly_embedded_block(&ps s, &ast::block blk, bool embedded) {\n     maybe_print_comment(s, blk.span.lo);\n     auto ann_node = node_block(s, blk);\n     s.ann.pre(ann_node);\n-    bopen(s);\n+    if (embedded) {\n+        word(s.s, \"#{\"); end(s);\n+    } else {\n+        bopen(s);\n+    }\n     for (@ast::stmt st in blk.node.stmts) { print_stmt(s, *st) }\n     alt (blk.node.expr) {\n         case (some(?expr)) {\n@@ -662,6 +670,33 @@ fn print_if(&ps s, &@ast::expr test, &ast::block block,\n     do_else(s, elseopt);\n }\n \n+fn print_mac(&ps s, &ast::mac m) {\n+    alt (m.node) {\n+        case (ast::mac_invoc(?path, ?args, ?body)) {\n+            word(s.s, \"#\");\n+            print_path(s, path);\n+            if (ivec::len(args) > 0u) {\n+                popen(s);\n+                commasep_exprs(s, inconsistent, args);\n+                pclose(s);\n+            }\n+            // FIXME: extension 'body'\n+\n+        }\n+        case (ast::mac_embed_type(?ty)) {\n+            word(s.s, \"#<\");\n+            print_type(s, *ty);\n+            word(s.s, \">\");\n+        }\n+        case (ast::mac_embed_block(?blk)) {\n+            print_possibly_embedded_block(s, blk, true);\n+        }\n+        case (ast::mac_elipsis) {\n+            word(s.s, \"...\");\n+        }\n+    }\n+}\n+\n fn print_expr(&ps s, &@ast::expr expr) {\n     maybe_print_comment(s, expr.span.lo);\n     ibox(s, indent_unit);\n@@ -961,16 +996,8 @@ fn print_expr(&ps s, &@ast::expr expr) {\n             print_expr(s, expr);\n             pclose(s);\n         }\n-        case (ast::expr_ext(?path, ?args, ?body)) {\n-            word(s.s, \"#\");\n-            print_path(s, path);\n-            if (ivec::len(args) > 0u) {\n-                popen(s);\n-                commasep_exprs(s, inconsistent, args);\n-                pclose(s);\n-            }\n-            // FIXME: extension 'body'\n-\n+        case (ast::expr_mac(?m)) {\n+            print_mac(s, m);\n         }\n         case (ast::expr_port(?ot)) {\n             word(s.s, \"port\");"}, {"sha": "f3511e60be580b6da5debcfd6da15135077ad827", "filename": "src/comp/syntax/visit.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/48dbee6b470571241a9f7f6e8b9b36c579296cc7/src%2Fcomp%2Fsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48dbee6b470571241a9f7f6e8b9b36c579296cc7/src%2Fcomp%2Fsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fvisit.rs?ref=48dbee6b470571241a9f7f6e8b9b36c579296cc7", "patch": "@@ -256,6 +256,15 @@ fn visit_exprs[E](&(@expr)[] exprs, &E e, &vt[E] v) {\n     for (@expr ex in exprs) { v.visit_expr(ex, e, v); }\n }\n \n+fn visit_mac[E](mac m, &E e, &vt[E] v) {\n+    alt(m.node) {\n+        case (ast::mac_invoc(?pth, ?args, ?body)) { visit_exprs(args, e, v); }\n+        case (ast::mac_embed_type(?ty)) { v.visit_ty(ty, e, v); }\n+        case (ast::mac_embed_block(?blk)) { v.visit_block(blk, e, v); }\n+        case (ast::mac_elipsis) { }\n+    }\n+}\n+\n fn visit_expr[E](&@expr ex, &E e, &vt[E] v) {\n     alt (ex.node) {\n         case (expr_vec(?es, _, _)) { visit_exprs(es, e, v); }\n@@ -362,11 +371,6 @@ fn visit_expr[E](&@expr ex, &E e, &vt[E] v) {\n         case (expr_path(?p)) {\n             for (@ty tp in p.node.types) { v.visit_ty(tp, e, v); }\n         }\n-        case (expr_ext(_, ?args, _)) {\n-            for(@ast::expr arg in args) {\n-                vt(v).visit_expr(arg, e, v);\n-            }\n-        }\n         case (expr_fail(?eo)) {\n             visit_expr_opt(eo, e, v);\n         }\n@@ -399,11 +403,8 @@ fn visit_expr[E](&@expr ex, &E e, &vt[E] v) {\n                            m.node.id, e, v);\n             }\n         }\n-        case (expr_embeded_type(?ty)) {\n-            vt(v).visit_ty(ty, e, v);\n-        }\n-        case (expr_embeded_block(?blk)) {\n-            vt(v).visit_block(blk, e, v);\n+        case (expr_mac(?mac)) {\n+            visit_mac(mac, e, v);\n         }\n     }\n }"}, {"sha": "0e2e13f6dc5afe13ea33fdd4279b2f6beb9ece92", "filename": "src/comp/syntax/walk.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/48dbee6b470571241a9f7f6e8b9b36c579296cc7/src%2Fcomp%2Fsyntax%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48dbee6b470571241a9f7f6e8b9b36c579296cc7/src%2Fcomp%2Fsyntax%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fwalk.rs?ref=48dbee6b470571241a9f7f6e8b9b36c579296cc7", "patch": "@@ -269,6 +269,15 @@ fn walk_exprs(&ast_visitor v, &(@ast::expr)[] exprs) {\n     for (@ast::expr e in exprs) { walk_expr(v, e); }\n }\n \n+fn walk_mac(&ast_visitor v, ast::mac mac) {\n+    alt(mac.node) {\n+        case (ast::mac_invoc(?pth, ?args, ?body)) { walk_exprs(v, args); }\n+        case (ast::mac_embed_type(?ty)) { walk_ty(v, ty); }\n+        case (ast::mac_embed_block(?blk)) { walk_block(v, blk); }\n+        case (ast::mac_elipsis) { }\n+    }\n+}\n+\n fn walk_expr(&ast_visitor v, @ast::expr e) {\n     if (!v.keep_going()) { ret; }\n     v.visit_expr_pre(e);\n@@ -367,11 +376,6 @@ fn walk_expr(&ast_visitor v, @ast::expr e) {\n         case (ast::expr_path(?p)) {\n             for (@ast::ty tp in p.node.types) { walk_ty(v, tp); }\n         }\n-        case (ast::expr_ext(_, ?args, _)) {\n-            for (@ast::expr e in args) {\n-                walk_expr(v, e);\n-            }\n-        }\n         case (ast::expr_fail(?eo)) { walk_expr_opt(v, eo); }\n         case (ast::expr_break) { }\n         case (ast::expr_cont) { }\n@@ -410,11 +414,8 @@ fn walk_expr(&ast_visitor v, @ast::expr e) {\n                 v.visit_method_post(m);\n             }\n         }\n-        case (ast::expr_embeded_type(?ty)) {\n-            walk_ty(v, ty);\n-        }\n-        case (ast::expr_embeded_block(?blk)) {\n-            walk_block(v, blk);\n+        case (ast::expr_mac(?mac)) {\n+            walk_mac(v, mac);\n         }\n     }\n     v.visit_expr_post(e);"}]}