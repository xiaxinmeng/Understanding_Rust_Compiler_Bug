{"sha": "a8b8558f083d86247ef3260ebb4f97b276cdbf73", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE4Yjg1NThmMDgzZDg2MjQ3ZWYzMjYwZWJiNGY5N2IyNzZjZGJmNzM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-07-03T10:40:53Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-07-03T10:40:53Z"}, "message": "Auto merge of #86799 - tlyu:stdio-locked, r=joshtriplett\n\nadd owned locked stdio handles\n\nAdd stderr_locked, stdin_locked, and stdout_locked free functions\nto obtain owned locked stdio handles in a single step. Also add\ninto_lock methods to consume a stdio handle and return an owned\nlock. These methods will make it easier to use locked stdio\nhandles without having to deal with lifetime problems or keeping\nbindings to the unlocked handles around.\n\nFixes #85383; enables #86412.\n\nr? `@joshtriplett`\n`@rustbot` label +A-io +C-enhancement +D-newcomer-roadblock +T-libs-api", "tree": {"sha": "c57703fb7c819e8655b0eb624690079d74a1cf34", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c57703fb7c819e8655b0eb624690079d74a1cf34"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a8b8558f083d86247ef3260ebb4f97b276cdbf73", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a8b8558f083d86247ef3260ebb4f97b276cdbf73", "html_url": "https://github.com/rust-lang/rust/commit/a8b8558f083d86247ef3260ebb4f97b276cdbf73", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a8b8558f083d86247ef3260ebb4f97b276cdbf73/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "701496384fd2d46557b3f013b50860c69c9848cc", "url": "https://api.github.com/repos/rust-lang/rust/commits/701496384fd2d46557b3f013b50860c69c9848cc", "html_url": "https://github.com/rust-lang/rust/commit/701496384fd2d46557b3f013b50860c69c9848cc"}, {"sha": "c58ceb7a42b5e06e2d7ba5fe727b05af5d073d3e", "url": "https://api.github.com/repos/rust-lang/rust/commits/c58ceb7a42b5e06e2d7ba5fe727b05af5d073d3e", "html_url": "https://github.com/rust-lang/rust/commit/c58ceb7a42b5e06e2d7ba5fe727b05af5d073d3e"}], "stats": {"total": 338, "additions": 337, "deletions": 1}, "files": [{"sha": "328626290832e61050290acad56f47b24922d422", "filename": "library/std/src/io/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a8b8558f083d86247ef3260ebb4f97b276cdbf73/library%2Fstd%2Fsrc%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8b8558f083d86247ef3260ebb4f97b276cdbf73/library%2Fstd%2Fsrc%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fmod.rs?ref=a8b8558f083d86247ef3260ebb4f97b276cdbf73", "patch": "@@ -277,6 +277,8 @@ pub use self::error::{Error, ErrorKind, Result};\n pub use self::stdio::set_output_capture;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use self::stdio::{stderr, stdin, stdout, Stderr, Stdin, Stdout};\n+#[unstable(feature = \"stdio_locked\", issue = \"none\")]\n+pub use self::stdio::{stderr_locked, stdin_locked, stdout_locked};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use self::stdio::{StderrLock, StdinLock, StdoutLock};\n #[unstable(feature = \"print_internals\", issue = \"none\")]"}, {"sha": "293f0e31ce050e293a2fc9288dce34f3d9652570", "filename": "library/std/src/io/stdio.rs", "status": "modified", "additions": 216, "deletions": 1, "changes": 217, "blob_url": "https://github.com/rust-lang/rust/blob/a8b8558f083d86247ef3260ebb4f97b276cdbf73/library%2Fstd%2Fsrc%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8b8558f083d86247ef3260ebb4f97b276cdbf73/library%2Fstd%2Fsrc%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fstdio.rs?ref=a8b8558f083d86247ef3260ebb4f97b276cdbf73", "patch": "@@ -310,6 +310,48 @@ pub fn stdin() -> Stdin {\n     }\n }\n \n+/// Constructs a new locked handle to the standard input of the current\n+/// process.\n+///\n+/// Each handle returned is a guard granting locked access to a shared\n+/// global buffer whose access is synchronized via a mutex. If you need\n+/// more explicit control over locking, for example, in a multi-threaded\n+/// program, use the [`io::stdin`] function to obtain an unlocked handle,\n+/// along with the [`Stdin::lock`] method.\n+///\n+/// The lock is released when the returned guard goes out of scope. The\n+/// returned guard also implements the [`Read`] and [`BufRead`] traits for\n+/// accessing the underlying data.\n+///\n+/// **Note**: The mutex locked by this handle is not reentrant. Even in a\n+/// single-threaded program, calling other code that accesses [`Stdin`]\n+/// could cause a deadlock or panic, if this locked handle is held across\n+/// that call.\n+///\n+/// ### Note: Windows Portability Consideration\n+/// When operating in a console, the Windows implementation of this stream does not support\n+/// non-UTF-8 byte sequences. Attempting to read bytes that are not valid UTF-8 will return\n+/// an error.\n+///\n+/// # Examples\n+///\n+/// ```no_run\n+/// #![feature(stdio_locked)]\n+/// use std::io::{self, Read};\n+///\n+/// fn main() -> io::Result<()> {\n+///     let mut buffer = String::new();\n+///     let mut handle = io::stdin_locked();\n+///\n+///     handle.read_to_string(&mut buffer)?;\n+///     Ok(())\n+/// }\n+/// ```\n+#[unstable(feature = \"stdio_locked\", issue = \"none\")]\n+pub fn stdin_locked() -> StdinLock<'static> {\n+    stdin().into_locked()\n+}\n+\n impl Stdin {\n     /// Locks this handle to the standard input stream, returning a readable\n     /// guard.\n@@ -334,7 +376,7 @@ impl Stdin {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn lock(&self) -> StdinLock<'_> {\n-        StdinLock { inner: self.inner.lock().unwrap_or_else(|e| e.into_inner()) }\n+        self.lock_any()\n     }\n \n     /// Locks this handle and reads a line of input, appending it to the specified buffer.\n@@ -367,6 +409,43 @@ impl Stdin {\n     pub fn read_line(&self, buf: &mut String) -> io::Result<usize> {\n         self.lock().read_line(buf)\n     }\n+\n+    // Locks this handle with any lifetime. This depends on the\n+    // implementation detail that the underlying `Mutex` is static.\n+    fn lock_any<'a>(&self) -> StdinLock<'a> {\n+        StdinLock { inner: self.inner.lock().unwrap_or_else(|e| e.into_inner()) }\n+    }\n+\n+    /// Consumes this handle to the standard input stream, locking the\n+    /// shared global buffer associated with the stream and returning a\n+    /// readable guard.\n+    ///\n+    /// The lock is released when the returned guard goes out of scope. The\n+    /// returned guard also implements the [`Read`] and [`BufRead`] traits\n+    /// for accessing the underlying data.\n+    ///\n+    /// It is often simpler to directly get a locked handle using the\n+    /// [`stdin_locked`] function instead, unless nearby code also needs to\n+    /// use an unlocked handle.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// #![feature(stdio_locked)]\n+    /// use std::io::{self, Read};\n+    ///\n+    /// fn main() -> io::Result<()> {\n+    ///     let mut buffer = String::new();\n+    ///     let mut handle = io::stdin().into_locked();\n+    ///\n+    ///     handle.read_to_string(&mut buffer)?;\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[unstable(feature = \"stdio_locked\", issue = \"none\")]\n+    pub fn into_locked(self) -> StdinLock<'static> {\n+        self.lock_any()\n+    }\n }\n \n #[stable(feature = \"std_debug\", since = \"1.16.0\")]\n@@ -558,6 +637,42 @@ pub fn stdout() -> Stdout {\n     }\n }\n \n+/// Constructs a new locked handle to the standard output of the current\n+/// process.\n+///\n+/// Each handle returned is a guard granting locked access to a shared\n+/// global buffer whose access is synchronized via a mutex. If you need\n+/// more explicit control over locking, for example, in a multi-threaded\n+/// program, use the [`io::stdout`] function to obtain an unlocked handle,\n+/// along with the [`Stdout::lock`] method.\n+///\n+/// The lock is released when the returned guard goes out of scope. The\n+/// returned guard also implements the [`Write`] trait for writing data.\n+///\n+/// ### Note: Windows Portability Consideration\n+/// When operating in a console, the Windows implementation of this stream does not support\n+/// non-UTF-8 byte sequences. Attempting to write bytes that are not valid UTF-8 will return\n+/// an error.\n+///\n+/// # Examples\n+///\n+/// ```no_run\n+/// #![feature(stdio_locked)]\n+/// use std::io::{self, Write};\n+///\n+/// fn main() -> io::Result<()> {\n+///     let mut handle = io::stdout_locked();\n+///\n+///     handle.write_all(b\"hello world\")?;\n+///\n+///     Ok(())\n+/// }\n+/// ```\n+#[unstable(feature = \"stdio_locked\", issue = \"none\")]\n+pub fn stdout_locked() -> StdoutLock<'static> {\n+    stdout().into_locked()\n+}\n+\n pub fn cleanup() {\n     if let Some(instance) = STDOUT.get() {\n         // Flush the data and disable buffering during shutdown\n@@ -595,8 +710,45 @@ impl Stdout {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn lock(&self) -> StdoutLock<'_> {\n+        self.lock_any()\n+    }\n+\n+    // Locks this handle with any lifetime. This depends on the\n+    // implementation detail that the underlying `ReentrantMutex` is\n+    // static.\n+    fn lock_any<'a>(&self) -> StdoutLock<'a> {\n         StdoutLock { inner: self.inner.lock() }\n     }\n+\n+    /// Consumes this handle to the standard output stream, locking the\n+    /// shared global buffer associated with the stream and returning a\n+    /// writable guard.\n+    ///\n+    /// The lock is released when the returned lock goes out of scope. The\n+    /// returned guard also implements the [`Write`] trait for writing data.\n+    ///\n+    /// It is often simpler to directly get a locked handle using the\n+    /// [`io::stdout_locked`] function instead, unless nearby code also\n+    /// needs to use an unlocked handle.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// #![feature(stdio_locked)]\n+    /// use std::io::{self, Write};\n+    ///\n+    /// fn main() -> io::Result<()> {\n+    ///     let mut handle = io::stdout().into_locked();\n+    ///\n+    ///     handle.write_all(b\"hello world\")?;\n+    ///\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[unstable(feature = \"stdio_locked\", issue = \"none\")]\n+    pub fn into_locked(self) -> StdoutLock<'static> {\n+        self.lock_any()\n+    }\n }\n \n #[stable(feature = \"std_debug\", since = \"1.16.0\")]\n@@ -769,6 +921,35 @@ pub fn stderr() -> Stderr {\n     }\n }\n \n+/// Constructs a new locked handle to the standard error of the current\n+/// process.\n+///\n+/// This handle is not buffered.\n+///\n+/// ### Note: Windows Portability Consideration\n+/// When operating in a console, the Windows implementation of this stream does not support\n+/// non-UTF-8 byte sequences. Attempting to write bytes that are not valid UTF-8 will return\n+/// an error.\n+///\n+/// # Example\n+///\n+/// ```no_run\n+/// #![feature(stdio_locked)]\n+/// use std::io::{self, Write};\n+///\n+/// fn main() -> io::Result<()> {\n+///     let mut handle = io::stderr_locked();\n+///\n+///     handle.write_all(b\"hello world\")?;\n+///\n+///     Ok(())\n+/// }\n+/// ```\n+#[unstable(feature = \"stdio_locked\", issue = \"none\")]\n+pub fn stderr_locked() -> StderrLock<'static> {\n+    stderr().into_locked()\n+}\n+\n impl Stderr {\n     /// Locks this handle to the standard error stream, returning a writable\n     /// guard.\n@@ -792,8 +973,42 @@ impl Stderr {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn lock(&self) -> StderrLock<'_> {\n+        self.lock_any()\n+    }\n+\n+    // Locks this handle with any lifetime. This depends on the\n+    // implementation detail that the underlying `ReentrantMutex` is\n+    // static.\n+    fn lock_any<'a>(&self) -> StderrLock<'a> {\n         StderrLock { inner: self.inner.lock() }\n     }\n+\n+    /// Locks and consumes this handle to the standard error stream,\n+    /// returning a writable guard.\n+    ///\n+    /// The lock is released when the returned guard goes out of scope. The\n+    /// returned guard also implements the [`Write`] trait for writing\n+    /// data.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(stdio_locked)]\n+    /// use std::io::{self, Write};\n+    ///\n+    /// fn foo() -> io::Result<()> {\n+    ///     let stderr = io::stderr();\n+    ///     let mut handle = stderr.into_locked();\n+    ///\n+    ///     handle.write_all(b\"hello world\")?;\n+    ///\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[unstable(feature = \"stdio_locked\", issue = \"none\")]\n+    pub fn into_locked(self) -> StderrLock<'static> {\n+        self.lock_any()\n+    }\n }\n \n #[stable(feature = \"std_debug\", since = \"1.16.0\")]"}, {"sha": "b1df6b7131c8779f0fe2a3da9a51faedc9b36807", "filename": "library/std/src/io/stdio/tests.rs", "status": "modified", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/a8b8558f083d86247ef3260ebb4f97b276cdbf73/library%2Fstd%2Fsrc%2Fio%2Fstdio%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8b8558f083d86247ef3260ebb4f97b276cdbf73/library%2Fstd%2Fsrc%2Fio%2Fstdio%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fstdio%2Ftests.rs?ref=a8b8558f083d86247ef3260ebb4f97b276cdbf73", "patch": "@@ -1,5 +1,6 @@\n use super::*;\n use crate::panic::{RefUnwindSafe, UnwindSafe};\n+use crate::sync::mpsc::sync_channel;\n use crate::thread;\n \n #[test]\n@@ -45,3 +46,121 @@ fn panic_doesnt_poison() {\n     let _a = stderr();\n     let _a = _a.lock();\n }\n+\n+#[test]\n+#[cfg_attr(target_os = \"emscripten\", ignore)]\n+fn test_lock_stderr() {\n+    test_lock(stderr, stderr_locked);\n+}\n+#[test]\n+#[cfg_attr(target_os = \"emscripten\", ignore)]\n+fn test_lock_stdin() {\n+    test_lock(stdin, stdin_locked);\n+}\n+#[test]\n+#[cfg_attr(target_os = \"emscripten\", ignore)]\n+fn test_lock_stdout() {\n+    test_lock(stdout, stdout_locked);\n+}\n+\n+// Helper trait to make lock testing function generic.\n+trait Stdio<'a>: 'static\n+where\n+    Self::Lock: 'a,\n+{\n+    type Lock;\n+    fn lock(&'a self) -> Self::Lock;\n+}\n+impl<'a> Stdio<'a> for Stderr {\n+    type Lock = StderrLock<'a>;\n+    fn lock(&'a self) -> StderrLock<'a> {\n+        self.lock()\n+    }\n+}\n+impl<'a> Stdio<'a> for Stdin {\n+    type Lock = StdinLock<'a>;\n+    fn lock(&'a self) -> StdinLock<'a> {\n+        self.lock()\n+    }\n+}\n+impl<'a> Stdio<'a> for Stdout {\n+    type Lock = StdoutLock<'a>;\n+    fn lock(&'a self) -> StdoutLock<'a> {\n+        self.lock()\n+    }\n+}\n+\n+// Helper trait to make lock testing function generic.\n+trait StdioOwnedLock: 'static {}\n+impl StdioOwnedLock for StderrLock<'static> {}\n+impl StdioOwnedLock for StdinLock<'static> {}\n+impl StdioOwnedLock for StdoutLock<'static> {}\n+\n+// Tests locking on stdio handles by starting two threads and checking that\n+// they block each other appropriately.\n+fn test_lock<T, U>(get_handle: fn() -> T, get_locked: fn() -> U)\n+where\n+    T: for<'a> Stdio<'a>,\n+    U: StdioOwnedLock,\n+{\n+    // State enum to track different phases of the test, primarily when\n+    // each lock is acquired and released.\n+    #[derive(Debug, PartialEq)]\n+    enum State {\n+        Start1,\n+        Acquire1,\n+        Start2,\n+        Release1,\n+        Acquire2,\n+        Release2,\n+    }\n+    use State::*;\n+    // Logging vector to be checked to make sure lock acquisitions and\n+    // releases happened in the correct order.\n+    let log = Arc::new(Mutex::new(Vec::new()));\n+    let ((tx1, rx1), (tx2, rx2)) = (sync_channel(0), sync_channel(0));\n+    let th1 = {\n+        let (log, tx) = (Arc::clone(&log), tx1);\n+        thread::spawn(move || {\n+            log.lock().unwrap().push(Start1);\n+            let handle = get_handle();\n+            {\n+                let locked = handle.lock();\n+                log.lock().unwrap().push(Acquire1);\n+                tx.send(Acquire1).unwrap(); // notify of acquisition\n+                tx.send(Release1).unwrap(); // wait for release command\n+                log.lock().unwrap().push(Release1);\n+            }\n+            tx.send(Acquire1).unwrap(); // wait for th2 acquire\n+            {\n+                let locked = handle.lock();\n+                log.lock().unwrap().push(Acquire1);\n+            }\n+            log.lock().unwrap().push(Release1);\n+        })\n+    };\n+    let th2 = {\n+        let (log, tx) = (Arc::clone(&log), tx2);\n+        thread::spawn(move || {\n+            tx.send(Start2).unwrap(); // wait for start command\n+            let locked = get_locked();\n+            log.lock().unwrap().push(Acquire2);\n+            tx.send(Acquire2).unwrap(); // notify of acquisition\n+            tx.send(Release2).unwrap(); // wait for release command\n+            log.lock().unwrap().push(Release2);\n+        })\n+    };\n+    assert_eq!(rx1.recv().unwrap(), Acquire1); // wait for th1 acquire\n+    log.lock().unwrap().push(Start2);\n+    assert_eq!(rx2.recv().unwrap(), Start2); // block th2\n+    assert_eq!(rx1.recv().unwrap(), Release1); // release th1\n+    assert_eq!(rx2.recv().unwrap(), Acquire2); // wait for th2 acquire\n+    assert_eq!(rx1.recv().unwrap(), Acquire1); // block th1\n+    assert_eq!(rx2.recv().unwrap(), Release2); // release th2\n+    th2.join().unwrap();\n+    th1.join().unwrap();\n+    assert_eq!(\n+        *log.lock().unwrap(),\n+        [Start1, Acquire1, Start2, Release1, Acquire2, Release2, Acquire1, Release1]\n+    );\n+}"}]}