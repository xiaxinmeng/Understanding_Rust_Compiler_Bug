{"sha": "e74c55bb4adcad001b0f7373ebff795fc2aaeb1b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU3NGM1NWJiNGFkY2FkMDAxYjBmNzM3M2ViZmY3OTVmYzJhYWViMWI=", "commit": {"author": {"name": "Kirill Bulatov", "email": "mail4score@gmail.com", "date": "2021-02-28T22:05:22Z"}, "committer": {"name": "Kirill Bulatov", "email": "mail4score@gmail.com", "date": "2021-03-08T21:59:20Z"}, "message": "Refactor the import location", "tree": {"sha": "89bd5dd5a67183d5f94988f35b5c43b70846f293", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/89bd5dd5a67183d5f94988f35b5c43b70846f293"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e74c55bb4adcad001b0f7373ebff795fc2aaeb1b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e74c55bb4adcad001b0f7373ebff795fc2aaeb1b", "html_url": "https://github.com/rust-lang/rust/commit/e74c55bb4adcad001b0f7373ebff795fc2aaeb1b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e74c55bb4adcad001b0f7373ebff795fc2aaeb1b/comments", "author": {"login": "SomeoneToIgnore", "id": 2690773, "node_id": "MDQ6VXNlcjI2OTA3NzM=", "avatar_url": "https://avatars.githubusercontent.com/u/2690773?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SomeoneToIgnore", "html_url": "https://github.com/SomeoneToIgnore", "followers_url": "https://api.github.com/users/SomeoneToIgnore/followers", "following_url": "https://api.github.com/users/SomeoneToIgnore/following{/other_user}", "gists_url": "https://api.github.com/users/SomeoneToIgnore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SomeoneToIgnore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SomeoneToIgnore/subscriptions", "organizations_url": "https://api.github.com/users/SomeoneToIgnore/orgs", "repos_url": "https://api.github.com/users/SomeoneToIgnore/repos", "events_url": "https://api.github.com/users/SomeoneToIgnore/events{/privacy}", "received_events_url": "https://api.github.com/users/SomeoneToIgnore/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SomeoneToIgnore", "id": 2690773, "node_id": "MDQ6VXNlcjI2OTA3NzM=", "avatar_url": "https://avatars.githubusercontent.com/u/2690773?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SomeoneToIgnore", "html_url": "https://github.com/SomeoneToIgnore", "followers_url": "https://api.github.com/users/SomeoneToIgnore/followers", "following_url": "https://api.github.com/users/SomeoneToIgnore/following{/other_user}", "gists_url": "https://api.github.com/users/SomeoneToIgnore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SomeoneToIgnore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SomeoneToIgnore/subscriptions", "organizations_url": "https://api.github.com/users/SomeoneToIgnore/orgs", "repos_url": "https://api.github.com/users/SomeoneToIgnore/repos", "events_url": "https://api.github.com/users/SomeoneToIgnore/events{/privacy}", "received_events_url": "https://api.github.com/users/SomeoneToIgnore/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "89d410cef571f5fa7631b17e2fbe52a8f8f03990", "url": "https://api.github.com/repos/rust-lang/rust/commits/89d410cef571f5fa7631b17e2fbe52a8f8f03990", "html_url": "https://github.com/rust-lang/rust/commit/89d410cef571f5fa7631b17e2fbe52a8f8f03990"}], "stats": {"total": 288, "additions": 126, "deletions": 162}, "files": [{"sha": "c4691d34c2d360f6543630eacce4c5b5c3c75776", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e74c55bb4adcad001b0f7373ebff795fc2aaeb1b/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e74c55bb4adcad001b0f7373ebff795fc2aaeb1b/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=e74c55bb4adcad001b0f7373ebff795fc2aaeb1b", "patch": "@@ -1115,6 +1115,7 @@ pub enum AssocItem {\n     Const(Const),\n     TypeAlias(TypeAlias),\n }\n+#[derive(Debug)]\n pub enum AssocItemContainer {\n     Trait(Trait),\n     Impl(Impl),\n@@ -2148,6 +2149,16 @@ impl ScopeDef {\n     }\n }\n \n+impl From<ItemInNs> for ScopeDef {\n+    fn from(item: ItemInNs) -> Self {\n+        match item {\n+            ItemInNs::Types(id) => ScopeDef::ModuleDef(id.into()),\n+            ItemInNs::Values(id) => ScopeDef::ModuleDef(id.into()),\n+            ItemInNs::Macros(id) => ScopeDef::MacroDef(id.into()),\n+        }\n+    }\n+}\n+\n pub trait HasVisibility {\n     fn visibility(&self, db: &dyn HirDatabase) -> Visibility;\n     fn is_visible_from(&self, db: &dyn HirDatabase, module: Module) -> bool {"}, {"sha": "55439d0e590dc094d5f805ed2671f5a62f862c79", "filename": "crates/ide_completion/src/completions/flyimport.rs", "status": "modified", "additions": 5, "deletions": 60, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/e74c55bb4adcad001b0f7373ebff795fc2aaeb1b/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fflyimport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e74c55bb4adcad001b0f7373ebff795fc2aaeb1b/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fflyimport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fflyimport.rs?ref=e74c55bb4adcad001b0f7373ebff795fc2aaeb1b", "patch": "@@ -95,20 +95,20 @@ pub(crate) fn import_on_the_fly(acc: &mut Completions, ctx: &CompletionContext)\n         .search_for_imports(&ctx.sema, ctx.config.insert_use.prefix_kind)\n         .into_iter()\n         .map(|import| {\n-            let proposed_def = match import.item_to_display() {\n+            let def_to_display = match import.item_to_display() {\n                 ItemInNs::Types(id) => ScopeDef::ModuleDef(id.into()),\n                 ItemInNs::Values(id) => ScopeDef::ModuleDef(id.into()),\n                 ItemInNs::Macros(id) => ScopeDef::MacroDef(id.into()),\n             };\n-            (import, proposed_def)\n+            (import, def_to_display)\n         })\n         .collect::<Vec<_>>();\n     all_mod_paths.sort_by_cached_key(|(import, _)| {\n         compute_fuzzy_completion_order_key(import.display_path(), &user_input_lowercased)\n     });\n \n-    acc.add_all(all_mod_paths.into_iter().filter_map(|(import, definition)| {\n-        let import_for_trait_assoc_item = match definition {\n+    acc.add_all(all_mod_paths.into_iter().filter_map(|(import, def_to_display)| {\n+        let import_for_trait_assoc_item = match def_to_display {\n             ScopeDef::ModuleDef(module_def) => module_def\n                 .as_assoc_item(ctx.db)\n                 .and_then(|assoc| assoc.containing_trait(ctx.db))\n@@ -117,7 +117,7 @@ pub(crate) fn import_on_the_fly(acc: &mut Completions, ctx: &CompletionContext)\n         };\n         let import_edit =\n             ImportEdit { import, import_scope: import_scope.clone(), import_for_trait_assoc_item };\n-        render_resolution_with_import(RenderContext::new(ctx), import_edit, &definition)\n+        render_resolution_with_import(RenderContext::new(ctx), import_edit, &def_to_display)\n     }));\n     Some(())\n }\n@@ -867,61 +867,6 @@ mod foo {\n fn main() {\n     bar::Item::TEST_ASSOC\n }\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn unresolved_assoc_item_container_and_trait_with_path() {\n-        check_edit(\n-            \"TEST_ASSOC\",\n-            r#\"\n-mod foo {\n-    pub mod bar {\n-        pub trait SomeTrait {\n-            const TEST_ASSOC: usize;\n-        }\n-    }\n-\n-    pub mod baz {\n-        use super::bar::SomeTrait;\n-\n-        pub struct Item;\n-\n-        impl SomeTrait for Item {\n-            const TEST_ASSOC: usize = 3;\n-        }\n-    }\n-}\n-\n-fn main() {\n-    baz::Item::TEST_A$0\n-}\n-\"#,\n-            r#\"\n-use foo::{bar::SomeTrait, baz};\n-\n-mod foo {\n-    pub mod bar {\n-        pub trait SomeTrait {\n-            const TEST_ASSOC: usize;\n-        }\n-    }\n-\n-    pub mod baz {\n-        use super::bar::SomeTrait;\n-\n-        pub struct Item;\n-\n-        impl SomeTrait for Item {\n-            const TEST_ASSOC: usize = 3;\n-        }\n-    }\n-}\n-\n-fn main() {\n-    baz::Item::TEST_ASSOC\n-}\n \"#,\n         );\n     }"}, {"sha": "2909ecd45011366b5d63b9c2b0b9af49eb313178", "filename": "crates/ide_db/src/helpers/import_assets.rs", "status": "modified", "additions": 110, "deletions": 102, "changes": 212, "blob_url": "https://github.com/rust-lang/rust/blob/e74c55bb4adcad001b0f7373ebff795fc2aaeb1b/crates%2Fide_db%2Fsrc%2Fhelpers%2Fimport_assets.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e74c55bb4adcad001b0f7373ebff795fc2aaeb1b/crates%2Fide_db%2Fsrc%2Fhelpers%2Fimport_assets.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fhelpers%2Fimport_assets.rs?ref=e74c55bb4adcad001b0f7373ebff795fc2aaeb1b", "patch": "@@ -130,33 +130,31 @@ impl<'a> ImportAssets<'a> {\n \n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct LocatedImport {\n+    // TODO kb extract both into a separate struct + add another field:  `assoc_item_name: Optional<String|Name>`\n     import_path: ModPath,\n     item_to_import: ItemInNs,\n-    import_display_override: Option<(ModPath, ItemInNs)>,\n+    data_to_display: Option<(ModPath, ItemInNs)>,\n }\n \n impl LocatedImport {\n     pub fn new(\n         import_path: ModPath,\n         item_to_import: ItemInNs,\n-        import_display_override: Option<(ModPath, ItemInNs)>,\n+        data_to_display: Option<(ModPath, ItemInNs)>,\n     ) -> Self {\n-        Self { import_path, item_to_import, import_display_override }\n+        Self { import_path, item_to_import, data_to_display }\n     }\n \n     pub fn display_path(&self) -> &ModPath {\n-        self.import_display_override\n-            .as_ref()\n-            .map(|(mod_path, _)| mod_path)\n-            .unwrap_or(&self.import_path)\n+        self.data_to_display.as_ref().map(|(mod_pathh, _)| mod_pathh).unwrap_or(&self.import_path)\n     }\n \n     pub fn import_path(&self) -> &ModPath {\n         &self.import_path\n     }\n \n     pub fn item_to_display(&self) -> ItemInNs {\n-        self.import_display_override.as_ref().map(|&(_, item)| item).unwrap_or(self.item_to_import)\n+        self.data_to_display.as_ref().map(|&(_, item)| item).unwrap_or(self.item_to_import)\n     }\n \n     pub fn item_to_import(&self) -> ItemInNs {\n@@ -200,7 +198,7 @@ impl<'a> ImportAssets<'a> {\n         let current_crate = self.module_with_candidate.krate();\n         let scope_definitions = self.scope_definitions();\n \n-        let imports_for_candidate_name = match self.name_to_import() {\n+        let defs_for_candidate_name = match self.name_to_import() {\n             NameToImport::Exact(exact_name) => {\n                 imports_locator::find_exact_imports(sema, current_crate, exact_name.clone())\n             }\n@@ -226,7 +224,7 @@ impl<'a> ImportAssets<'a> {\n             }\n         };\n \n-        self.applicable_defs(sema.db, prefixed, imports_for_candidate_name)\n+        self.applicable_defs(sema.db, prefixed, defs_for_candidate_name)\n             .into_iter()\n             .filter(|import| import.import_path().len() > 1)\n             .filter(|import| {\n@@ -252,32 +250,31 @@ impl<'a> ImportAssets<'a> {\n         &self,\n         db: &RootDatabase,\n         prefixed: Option<PrefixKind>,\n-        unfiltered_defs: impl Iterator<Item = Either<ModuleDef, MacroDef>>,\n+        defs_for_candidate_name: impl Iterator<Item = Either<ModuleDef, MacroDef>>,\n     ) -> FxHashSet<LocatedImport> {\n         let current_crate = self.module_with_candidate.krate();\n \n-        let import_path_locator =\n-            |item| get_mod_path(db, item, &self.module_with_candidate, prefixed);\n+        let mod_path = |item| get_mod_path(db, item, &self.module_with_candidate, prefixed);\n \n         match &self.import_candidate {\n             ImportCandidate::Path(path_candidate) => {\n-                path_applicable_imports(db, path_candidate, import_path_locator, unfiltered_defs)\n+                path_applicable_imports(db, path_candidate, mod_path, defs_for_candidate_name)\n             }\n             ImportCandidate::TraitAssocItem(trait_candidate) => trait_applicable_items(\n                 db,\n                 current_crate,\n                 trait_candidate,\n                 true,\n-                import_path_locator,\n-                unfiltered_defs,\n+                mod_path,\n+                defs_for_candidate_name,\n             ),\n             ImportCandidate::TraitMethod(trait_candidate) => trait_applicable_items(\n                 db,\n                 current_crate,\n                 trait_candidate,\n                 false,\n-                import_path_locator,\n-                unfiltered_defs,\n+                mod_path,\n+                defs_for_candidate_name,\n             ),\n         }\n     }\n@@ -286,103 +283,114 @@ impl<'a> ImportAssets<'a> {\n fn path_applicable_imports(\n     db: &RootDatabase,\n     path_candidate: &PathImportCandidate,\n-    import_path_locator: impl Fn(ItemInNs) -> Option<ModPath>,\n-    unfiltered_defs: impl Iterator<Item = Either<ModuleDef, MacroDef>>,\n+    mod_path: impl Fn(ItemInNs) -> Option<ModPath> + Copy,\n+    defs_for_candidate_name: impl Iterator<Item = Either<ModuleDef, MacroDef>>,\n ) -> FxHashSet<LocatedImport> {\n-    let applicable_items = unfiltered_defs\n-        .filter_map(|def| {\n-            let (assoc_original, candidate) = match def {\n-                Either::Left(module_def) => match module_def.as_assoc_item(db) {\n-                    Some(assoc_item) => match assoc_item.container(db) {\n-                        AssocItemContainer::Trait(trait_) => {\n-                            (Some(module_def), ItemInNs::from(ModuleDef::from(trait_)))\n-                        }\n-                        AssocItemContainer::Impl(impl_) => (\n-                            Some(module_def),\n-                            ItemInNs::from(ModuleDef::from(impl_.target_ty(db).as_adt()?)),\n-                        ),\n-                    },\n-                    None => (None, ItemInNs::from(module_def)),\n-                },\n-                Either::Right(macro_def) => (None, ItemInNs::from(macro_def)),\n-            };\n-            Some((assoc_original, candidate))\n-        })\n-        .filter_map(|(assoc_original, candidate)| {\n-            import_path_locator(candidate).zip(Some((assoc_original, candidate)))\n-        });\n+    let items_for_candidate_name =\n+        defs_for_candidate_name.map(|def| def.either(ItemInNs::from, ItemInNs::from));\n \n     let (unresolved_first_segment, unresolved_qualifier) = match &path_candidate.qualifier {\n         Qualifier::Absent => {\n-            return applicable_items\n-                .map(|(candidate_path, (_, candidate))| {\n-                    LocatedImport::new(candidate_path, candidate, None)\n-                })\n+            return items_for_candidate_name\n+                .filter_map(|item| Some(LocatedImport::new(mod_path(item)?, item, None)))\n                 .collect();\n         }\n-        Qualifier::FirstSegmentUnresolved(first_segment, qualifier) => (first_segment, qualifier),\n+        Qualifier::FirstSegmentUnresolved(first_segment, qualifier) => {\n+            (first_segment.to_string(), qualifier.to_string())\n+        }\n     };\n \n-    let unresolved_qualifier_string = unresolved_qualifier.to_string();\n-    let unresolved_first_segment_string = unresolved_first_segment.to_string();\n-\n-    applicable_items\n-        .filter(|(candidate_path, _)| {\n-            let candidate_path_string = candidate_path.to_string();\n-            candidate_path_string.contains(&unresolved_qualifier_string)\n-                && candidate_path_string.contains(&unresolved_first_segment_string)\n-        })\n-        .filter_map(|(candidate_path, (assoc_original, candidate))| {\n-            let found_segment_resolution = item_name(db, candidate)\n-                .map(|name| name.to_string() == unresolved_first_segment_string)\n-                .unwrap_or(false);\n-            let (import_path, item_to_import) = if found_segment_resolution {\n-                (candidate_path.clone(), candidate)\n-            } else {\n-                let matching_module =\n-                    module_with_matching_name(db, &unresolved_first_segment_string, candidate)?;\n-                let module_item = ItemInNs::from(ModuleDef::from(matching_module));\n-                (import_path_locator(module_item)?, module_item)\n-            };\n-\n-            Some(match assoc_original {\n-                Some(assoc_original) => LocatedImport::new(\n-                    import_path.clone(),\n-                    item_to_import,\n-                    Some((import_path, ItemInNs::from(assoc_original))),\n-                ),\n-                None => LocatedImport::new(\n-                    import_path,\n-                    item_to_import,\n-                    if found_segment_resolution { None } else { Some((candidate_path, candidate)) },\n-                ),\n-            })\n+    items_for_candidate_name\n+        .filter_map(|item| {\n+            import_for_item(db, mod_path, &unresolved_first_segment, &unresolved_qualifier, item)\n         })\n         .collect()\n }\n \n-fn item_module(db: &RootDatabase, item: ItemInNs) -> Option<Module> {\n-    match item {\n-        ItemInNs::Types(module_def_id) => ModuleDef::from(module_def_id).module(db),\n-        ItemInNs::Values(module_def_id) => ModuleDef::from(module_def_id).module(db),\n-        ItemInNs::Macros(macro_def_id) => MacroDef::from(macro_def_id).module(db),\n+fn import_for_item(\n+    db: &RootDatabase,\n+    mod_path: impl Fn(ItemInNs) -> Option<ModPath>,\n+    unresolved_first_segment: &str,\n+    unresolved_qualifier: &str,\n+    original_item: ItemInNs,\n+) -> Option<LocatedImport> {\n+    let (item_candidate, trait_to_import) = match original_item {\n+        ItemInNs::Types(module_def_id) | ItemInNs::Values(module_def_id) => {\n+            match ModuleDef::from(module_def_id).as_assoc_item(db).map(|assoc| assoc.container(db))\n+            {\n+                Some(AssocItemContainer::Trait(trait_)) => {\n+                    let trait_item = ItemInNs::from(ModuleDef::from(trait_));\n+                    (trait_item, Some(trait_item))\n+                }\n+                Some(AssocItemContainer::Impl(impl_)) => {\n+                    (ItemInNs::from(ModuleDef::from(impl_.target_ty(db).as_adt()?)), None)\n+                }\n+                None => (original_item, None),\n+            }\n+        }\n+        ItemInNs::Macros(_) => (original_item, None),\n+    };\n+    let import_path_candidate = mod_path(item_candidate)?;\n+\n+    let import_path_string = import_path_candidate.to_string();\n+    if !import_path_string.contains(unresolved_first_segment)\n+        || !import_path_string.contains(unresolved_qualifier)\n+    {\n+        return None;\n     }\n+\n+    let segment_import = find_import_for_segment(db, item_candidate, &unresolved_first_segment)?;\n+    let data_to_display = Some((import_path_candidate.clone(), original_item));\n+    Some(match (segment_import == item_candidate, trait_to_import) {\n+        (true, Some(_)) => {\n+            // FIXME we should be able to import both the trait and the segment,\n+            // but it's unclear what to do with overlapping edits (merge imports?)\n+            // especially in case of lazy completion edit resolutions.\n+            return None;\n+        }\n+        (false, Some(trait_to_import)) => {\n+            LocatedImport::new(mod_path(trait_to_import)?, trait_to_import, data_to_display)\n+        }\n+        (true, None) => LocatedImport::new(import_path_candidate, item_candidate, data_to_display),\n+        (false, None) => {\n+            LocatedImport::new(mod_path(segment_import)?, segment_import, data_to_display)\n+        }\n+    })\n }\n \n-fn module_with_matching_name(\n+fn find_import_for_segment(\n     db: &RootDatabase,\n-    unresolved_first_segment_string: &str,\n+    original_item: ItemInNs,\n+    unresolved_first_segment: &str,\n+) -> Option<ItemInNs> {\n+    let segment_is_name = item_name(db, original_item)\n+        .map(|name| name.to_string() == unresolved_first_segment)\n+        .unwrap_or(false);\n+\n+    Some(if segment_is_name {\n+        original_item\n+    } else {\n+        let matching_module =\n+            module_with_segment_name(db, &unresolved_first_segment, original_item)?;\n+        ItemInNs::from(ModuleDef::from(matching_module))\n+    })\n+}\n+\n+fn module_with_segment_name(\n+    db: &RootDatabase,\n+    segment_name: &str,\n     candidate: ItemInNs,\n ) -> Option<Module> {\n-    let mut current_module = item_module(db, candidate);\n+    let mut current_module = match candidate {\n+        ItemInNs::Types(module_def_id) => ModuleDef::from(module_def_id).module(db),\n+        ItemInNs::Values(module_def_id) => ModuleDef::from(module_def_id).module(db),\n+        ItemInNs::Macros(macro_def_id) => MacroDef::from(macro_def_id).module(db),\n+    };\n     while let Some(module) = current_module {\n-        match module.name(db) {\n-            Some(module_name) => {\n-                if module_name.to_string().as_str() == unresolved_first_segment_string {\n-                    return Some(module);\n-                }\n+        if let Some(module_name) = module.name(db) {\n+            if module_name.to_string() == segment_name {\n+                return Some(module);\n             }\n-            None => {}\n         }\n         current_module = module.parent(db);\n     }\n@@ -394,12 +402,12 @@ fn trait_applicable_items(\n     current_crate: Crate,\n     trait_candidate: &TraitImportCandidate,\n     trait_assoc_item: bool,\n-    import_path_locator: impl Fn(ItemInNs) -> Option<ModPath>,\n-    unfiltered_defs: impl Iterator<Item = Either<ModuleDef, MacroDef>>,\n+    mod_path: impl Fn(ItemInNs) -> Option<ModPath>,\n+    defs_for_candidate_name: impl Iterator<Item = Either<ModuleDef, MacroDef>>,\n ) -> FxHashSet<LocatedImport> {\n     let mut required_assoc_items = FxHashSet::default();\n \n-    let trait_candidates = unfiltered_defs\n+    let trait_candidates = defs_for_candidate_name\n         .filter_map(|input| match input {\n             Either::Left(module_def) => module_def.as_assoc_item(db),\n             _ => None,\n@@ -428,12 +436,12 @@ fn trait_applicable_items(\n                     }\n \n                     let item = ItemInNs::from(ModuleDef::from(assoc.containing_trait(db)?));\n-                    let item_path = import_path_locator(item)?;\n+                    let item_path = mod_path(item)?;\n \n                     let assoc_item = assoc_to_item(assoc);\n                     let assoc_item_path = match assoc.container(db) {\n                         AssocItemContainer::Trait(_) => item_path.clone(),\n-                        AssocItemContainer::Impl(impl_) => import_path_locator(ItemInNs::from(\n+                        AssocItemContainer::Impl(impl_) => mod_path(ItemInNs::from(\n                             ModuleDef::from(impl_.target_ty(db).as_adt()?),\n                         ))?,\n                     };\n@@ -457,12 +465,12 @@ fn trait_applicable_items(\n                 let assoc = function.as_assoc_item(db)?;\n                 if required_assoc_items.contains(&assoc) {\n                     let item = ItemInNs::from(ModuleDef::from(assoc.containing_trait(db)?));\n-                    let item_path = import_path_locator(item)?;\n+                    let item_path = mod_path(item)?;\n \n                     let assoc_item = assoc_to_item(assoc);\n                     let assoc_item_path = match assoc.container(db) {\n                         AssocItemContainer::Trait(_) => item_path.clone(),\n-                        AssocItemContainer::Impl(impl_) => import_path_locator(ItemInNs::from(\n+                        AssocItemContainer::Impl(impl_) => mod_path(ItemInNs::from(\n                             ModuleDef::from(impl_.target_ty(db).as_adt()?),\n                         ))?,\n                     };"}]}