{"sha": "d61338172fa110fcf9e5f2df0e1e83635d0fde3f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ2MTMzODE3MmZhMTEwZmNmOWU1ZjJkZjBlMWU4MzYzNWQwZmRlM2Y=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-11-26T15:10:52Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-12-14T09:21:56Z"}, "message": "Rewrite threading infrastructure, introducing `Thunk` to represent\nboxed `FnOnce` closures.", "tree": {"sha": "5a022b681067ce30acf73e06aef9896f3cfd4be2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5a022b681067ce30acf73e06aef9896f3cfd4be2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d61338172fa110fcf9e5f2df0e1e83635d0fde3f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d61338172fa110fcf9e5f2df0e1e83635d0fde3f", "html_url": "https://github.com/rust-lang/rust/commit/d61338172fa110fcf9e5f2df0e1e83635d0fde3f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d61338172fa110fcf9e5f2df0e1e83635d0fde3f/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "10ac5b72f1974775bed499105c2a3cf18da98f32", "url": "https://api.github.com/repos/rust-lang/rust/commits/10ac5b72f1974775bed499105c2a3cf18da98f32", "html_url": "https://github.com/rust-lang/rust/commit/10ac5b72f1974775bed499105c2a3cf18da98f32"}], "stats": {"total": 349, "additions": 225, "deletions": 124}, "files": [{"sha": "8be77d9b34dddff5fdd8d9c49e7cabd1b05c3814", "filename": "src/librustrt/at_exit_imp.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d61338172fa110fcf9e5f2df0e1e83635d0fde3f/src%2Flibrustrt%2Fat_exit_imp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61338172fa110fcf9e5f2df0e1e83635d0fde3f/src%2Flibrustrt%2Fat_exit_imp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fat_exit_imp.rs?ref=d61338172fa110fcf9e5f2df0e1e83635d0fde3f", "patch": "@@ -18,10 +18,11 @@ use alloc::boxed::Box;\n use collections::vec::Vec;\n use core::atomic;\n use core::mem;\n+use thunk::{Thunk};\n \n use exclusive::Exclusive;\n \n-type Queue = Exclusive<Vec<proc():Send>>;\n+type Queue = Exclusive<Vec<Thunk>>;\n \n static QUEUE: atomic::AtomicUint = atomic::INIT_ATOMIC_UINT;\n static RUNNING: atomic::AtomicBool = atomic::INIT_ATOMIC_BOOL;\n@@ -34,7 +35,7 @@ pub fn init() {\n     }\n }\n \n-pub fn push(f: proc():Send) {\n+pub fn push(f: Thunk) {\n     unsafe {\n         // Note that the check against 0 for the queue pointer is not atomic at\n         // all with respect to `run`, meaning that this could theoretically be a\n@@ -59,6 +60,6 @@ pub fn run() {\n     };\n \n     for to_run in cur.into_iter() {\n-        to_run();\n+        to_run.invoke(());\n     }\n }"}, {"sha": "f12f8e49801191d6ffbbdcf86704f7e7fb61e480", "filename": "src/librustrt/lib.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d61338172fa110fcf9e5f2df0e1e83635d0fde3f/src%2Flibrustrt%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61338172fa110fcf9e5f2df0e1e83635d0fde3f/src%2Flibrustrt%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Flib.rs?ref=d61338172fa110fcf9e5f2df0e1e83635d0fde3f", "patch": "@@ -46,6 +46,7 @@ mod thread_local_storage;\n mod util;\n mod libunwind;\n mod stack_overflow;\n+pub mod thunk;\n \n pub mod args;\n pub mod bookkeeping;\n@@ -95,8 +96,8 @@ pub fn init(argc: int, argv: *const *const u8) {\n ///\n /// It is forbidden for procedures to register more `at_exit` handlers when they\n /// are running, and doing so will lead to a process abort.\n-pub fn at_exit(f: proc():Send) {\n-    at_exit_imp::push(f);\n+pub fn at_exit<F:FnOnce()+Send>(f: F) {\n+    at_exit_imp::push(thunk::Thunk::new(f));\n }\n \n /// One-time runtime cleanup."}, {"sha": "37632f509c14a089f166b3ab7d8ce22ba946cbeb", "filename": "src/librustrt/task.rs", "status": "modified", "additions": 16, "deletions": 9, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/d61338172fa110fcf9e5f2df0e1e83635d0fde3f/src%2Flibrustrt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61338172fa110fcf9e5f2df0e1e83635d0fde3f/src%2Flibrustrt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Ftask.rs?ref=d61338172fa110fcf9e5f2df0e1e83635d0fde3f", "patch": "@@ -21,6 +21,7 @@ use core::any::Any;\n use core::atomic::{AtomicUint, SeqCst};\n use core::iter::{IteratorExt, Take};\n use core::kinds::marker;\n+use core::ops::FnOnce;\n use core::mem;\n use core::ops::FnMut;\n use core::prelude::{Clone, Drop, Err, Iterator, None, Ok, Option, Send, Some};\n@@ -34,6 +35,7 @@ use stack;\n use unwind;\n use unwind::Unwinder;\n use collections::str::SendStr;\n+use thunk::Thunk;\n \n /// State associated with Rust tasks.\n ///\n@@ -67,7 +69,7 @@ enum TaskState {\n \n pub struct TaskOpts {\n     /// Invoke this procedure with the result of the task when it finishes.\n-    pub on_exit: Option<proc(Result): Send>,\n+    pub on_exit: Option<Thunk<Result>>,\n     /// A name for the task-to-be, for identification in panic messages\n     pub name: Option<SendStr>,\n     /// The size of the stack for the spawned task\n@@ -92,7 +94,7 @@ pub enum BlockedTask {\n \n /// Per-task state related to task death, killing, panic, etc.\n pub struct Death {\n-    pub on_exit: Option<proc(Result):Send>,\n+    pub on_exit: Option<Thunk<Result>>,\n     marker: marker::NoCopy,\n }\n \n@@ -116,7 +118,13 @@ impl Task {\n         }\n     }\n \n-    pub fn spawn(opts: TaskOpts, f: proc():Send) {\n+    pub fn spawn<F>(opts: TaskOpts, f: F)\n+        where F : FnOnce(), F : Send\n+    {\n+        Task::spawn_thunk(opts, Thunk::new(f))\n+    }\n+\n+    fn spawn_thunk(opts: TaskOpts, f: Thunk) {\n         let TaskOpts { name, stack_size, on_exit } = opts;\n \n         let mut task = box Task::new(None, None);\n@@ -138,7 +146,7 @@ impl Task {\n         // because by the time that this function is executing we've already\n         // consumed at least a little bit of stack (we don't know the exact byte\n         // address at which our stack started).\n-        Thread::spawn_stack(stack, proc() {\n+        Thread::spawn_stack(stack, move|| {\n             let something_around_the_top_of_the_stack = 1;\n             let addr = &something_around_the_top_of_the_stack as *const int;\n             let my_stack = addr as uint;\n@@ -150,7 +158,7 @@ impl Task {\n             task.stack_bounds = (my_stack - stack + 1024, my_stack);\n \n             let mut f = Some(f);\n-            drop(task.run(|| { f.take().unwrap()() }).destroy());\n+            drop(task.run(|| { f.take().unwrap().invoke(()) }).destroy());\n             drop(token);\n         })\n     }\n@@ -241,7 +249,7 @@ impl Task {\n         //        reconsideration to whether it's a reasonable thing to let a\n         //        task to do or not.\n         match what_to_do {\n-            Some(f) => { f(result) }\n+            Some(f) => { f.invoke(result) }\n             None => { drop(result) }\n         }\n \n@@ -500,14 +508,13 @@ mod test {\n     use super::*;\n     use std::prelude::*;\n     use std::task;\n-    use unwind;\n \n     #[test]\n     fn unwind() {\n-        let result = task::try(proc()());\n+        let result = task::try(move|| ());\n         rtdebug!(\"trying first assert\");\n         assert!(result.is_ok());\n-        let result = task::try::<()>(proc() panic!());\n+        let result = task::try(move|| -> () panic!());\n         rtdebug!(\"trying second assert\");\n         assert!(result.is_err());\n     }"}, {"sha": "175e057c22f2ea3e5f70b3147a778a6dc17c24e9", "filename": "src/librustrt/thread.rs", "status": "modified", "additions": 35, "deletions": 23, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/d61338172fa110fcf9e5f2df0e1e83635d0fde3f/src%2Flibrustrt%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61338172fa110fcf9e5f2df0e1e83635d0fde3f/src%2Flibrustrt%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fthread.rs?ref=d61338172fa110fcf9e5f2df0e1e83635d0fde3f", "patch": "@@ -22,6 +22,7 @@ use alloc::boxed::Box;\n use core::mem;\n use core::uint;\n use libc;\n+use thunk::{Thunk};\n \n use stack;\n use stack_overflow;\n@@ -60,8 +61,8 @@ fn start_thread(main: *mut libc::c_void) -> imp::rust_thread_return {\n     unsafe {\n         stack::record_os_managed_stack_bounds(0, uint::MAX);\n         let handler = stack_overflow::Handler::new();\n-        let f: Box<proc()> = mem::transmute(main);\n-        (*f)();\n+        let f: Box<Thunk> = mem::transmute(main);\n+        f.invoke(());\n         drop(handler);\n         mem::transmute(0 as imp::rust_thread_return)\n     }\n@@ -113,23 +114,29 @@ impl Thread<()> {\n     /// to finish executing. This means that even if `join` is not explicitly\n     /// called, when the `Thread` falls out of scope its destructor will block\n     /// waiting for the OS thread.\n-    pub fn start<T: Send>(main: proc():Send -> T) -> Thread<T> {\n+    pub fn start<T,F>(main: F) -> Thread<T>\n+        where T:Send, F:FnOnce() -> T, F:Send\n+    {\n         Thread::start_stack(DEFAULT_STACK_SIZE, main)\n     }\n \n     /// Performs the same functionality as `start`, but specifies an explicit\n     /// stack size for the new thread.\n-    pub fn start_stack<T: Send>(stack: uint, main: proc():Send -> T) -> Thread<T> {\n-\n+    pub fn start_stack<T, F>(stack: uint, main: F) -> Thread<T>\n+        where T:Send, F:FnOnce() -> T, F:Send\n+    {\n         // We need the address of the packet to fill in to be stable so when\n         // `main` fills it in it's still valid, so allocate an extra box to do\n         // so.\n         let packet = box None;\n         let packet2: *mut Option<T> = unsafe {\n             *mem::transmute::<&Box<Option<T>>, *const *mut Option<T>>(&packet)\n         };\n-        let main = proc() unsafe { *packet2 = Some(main()); };\n-        let native = unsafe { imp::create(stack, box main) };\n+        let native = unsafe {\n+            imp::create(stack, Thunk::new(move |:| {\n+                *packet2 = Some(main.call_once(()));\n+            }))\n+        };\n \n         Thread {\n             native: native,\n@@ -144,15 +151,19 @@ impl Thread<()> {\n     /// This corresponds to creating threads in the 'detached' state on unix\n     /// systems. Note that platforms may not keep the main program alive even if\n     /// there are detached thread still running around.\n-    pub fn spawn(main: proc():Send) {\n+    pub fn spawn<F>(main: F)\n+        where F : FnOnce() + Send\n+    {\n         Thread::spawn_stack(DEFAULT_STACK_SIZE, main)\n     }\n \n     /// Performs the same functionality as `spawn`, but explicitly specifies a\n     /// stack size for the new thread.\n-    pub fn spawn_stack(stack: uint, main: proc():Send) {\n+    pub fn spawn_stack<F>(stack: uint, main: F)\n+        where F : FnOnce() + Send\n+    {\n         unsafe {\n-            let handle = imp::create(stack, box main);\n+            let handle = imp::create(stack, Thunk::new(main));\n             imp::detach(handle);\n         }\n     }\n@@ -190,8 +201,6 @@ impl<T: Send> Drop for Thread<T> {\n #[cfg(windows)]\n #[allow(non_snake_case)]\n mod imp {\n-    use core::prelude::*;\n-\n     use alloc::boxed::Box;\n     use core::cmp;\n     use core::mem;\n@@ -200,6 +209,7 @@ mod imp {\n     use libc::types::os::arch::extra::{LPSECURITY_ATTRIBUTES, SIZE_T, BOOL,\n                                        LPVOID, DWORD, LPDWORD, HANDLE};\n     use stack::RED_ZONE;\n+    use thunk::Thunk;\n \n     pub type rust_thread = HANDLE;\n     pub type rust_thread_return = DWORD;\n@@ -217,8 +227,9 @@ mod imp {\n         }\n     }\n \n-    pub unsafe fn create(stack: uint, p: Box<proc():Send>) -> rust_thread {\n-        let arg: *mut libc::c_void = mem::transmute(p);\n+    pub unsafe fn create(stack: uint, p: Thunk) -> rust_thread {\n+        let arg: *mut libc::c_void = mem::transmute(box p);\n+\n         // FIXME On UNIX, we guard against stack sizes that are too small but\n         // that's because pthreads enforces that stacks are at least\n         // PTHREAD_STACK_MIN bytes big.  Windows has no such lower limit, it's\n@@ -234,7 +245,7 @@ mod imp {\n \n         if ret as uint == 0 {\n             // be sure to not leak the closure\n-            let _p: Box<proc():Send> = mem::transmute(arg);\n+            let _p: Box<Thunk> = mem::transmute(arg);\n             panic!(\"failed to spawn native thread: {}\", ret);\n         }\n         return ret;\n@@ -279,6 +290,7 @@ mod imp {\n     use core::ptr;\n     use libc::consts::os::posix01::{PTHREAD_CREATE_JOINABLE, PTHREAD_STACK_MIN};\n     use libc;\n+    use thunk::Thunk;\n \n     use stack::RED_ZONE;\n \n@@ -409,7 +421,7 @@ mod imp {\n         }\n     }\n \n-    pub unsafe fn create(stack: uint, p: Box<proc():Send>) -> rust_thread {\n+    pub unsafe fn create(stack: uint, p: Thunk) -> rust_thread {\n         let mut native: libc::pthread_t = mem::zeroed();\n         let mut attr: libc::pthread_attr_t = mem::zeroed();\n         assert_eq!(pthread_attr_init(&mut attr), 0);\n@@ -437,13 +449,13 @@ mod imp {\n             },\n         };\n \n-        let arg: *mut libc::c_void = mem::transmute(p);\n+        let arg: *mut libc::c_void = mem::transmute(box p); // must box since sizeof(p)=2*uint\n         let ret = pthread_create(&mut native, &attr, super::thread_start, arg);\n         assert_eq!(pthread_attr_destroy(&mut attr), 0);\n \n         if ret != 0 {\n             // be sure to not leak the closure\n-            let _p: Box<proc():Send> = mem::transmute(arg);\n+            let _p: Box<Box<FnOnce()+Send>> = mem::transmute(arg);\n             panic!(\"failed to spawn native thread: {}\", ret);\n         }\n         native\n@@ -531,17 +543,17 @@ mod tests {\n     use super::Thread;\n \n     #[test]\n-    fn smoke() { Thread::start(proc (){}).join(); }\n+    fn smoke() { Thread::start(move|| {}).join(); }\n \n     #[test]\n-    fn data() { assert_eq!(Thread::start(proc () { 1i }).join(), 1); }\n+    fn data() { assert_eq!(Thread::start(move|| { 1i }).join(), 1); }\n \n     #[test]\n-    fn detached() { Thread::spawn(proc () {}) }\n+    fn detached() { Thread::spawn(move|| {}) }\n \n     #[test]\n     fn small_stacks() {\n-        assert_eq!(42i, Thread::start_stack(0, proc () 42i).join());\n-        assert_eq!(42i, Thread::start_stack(1, proc () 42i).join());\n+        assert_eq!(42i, Thread::start_stack(0, move|| 42i).join());\n+        assert_eq!(42i, Thread::start_stack(1, move|| 42i).join());\n     }\n }"}, {"sha": "42e784959909fab1fa561399b5ef5a3979191658", "filename": "src/librustrt/thunk.rs", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/d61338172fa110fcf9e5f2df0e1e83635d0fde3f/src%2Flibrustrt%2Fthunk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61338172fa110fcf9e5f2df0e1e83635d0fde3f/src%2Flibrustrt%2Fthunk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fthunk.rs?ref=d61338172fa110fcf9e5f2df0e1e83635d0fde3f", "patch": "@@ -0,0 +1,52 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use alloc::boxed::Box;\n+use core::kinds::Send;\n+use core::ops::FnOnce;\n+\n+pub struct Thunk<A=(),R=()> {\n+    invoke: Box<Invoke<A,R>+Send>\n+}\n+\n+impl<R> Thunk<(),R> {\n+    pub fn new<F>(func: F) -> Thunk<(),R>\n+        where F : FnOnce() -> R, F : Send\n+    {\n+        Thunk::with_arg(move|: ()| func())\n+    }\n+}\n+\n+impl<A,R> Thunk<A,R> {\n+    pub fn with_arg<F>(func: F) -> Thunk<A,R>\n+        where F : FnOnce(A) -> R, F : Send\n+    {\n+        Thunk {\n+            invoke: box func\n+        }\n+    }\n+\n+    pub fn invoke(self, arg: A) -> R {\n+        self.invoke.invoke(arg)\n+    }\n+}\n+\n+pub trait Invoke<A=(),R=()> {\n+    fn invoke(self: Box<Self>, arg: A) -> R;\n+}\n+\n+impl<A,R,F> Invoke<A,R> for F\n+    where F : FnOnce(A) -> R\n+{\n+    fn invoke(self: Box<F>, arg: A) -> R {\n+        let f = *self;\n+        f(arg)\n+    }\n+}"}, {"sha": "e99aba9b673804db7736d9508a4b581286ffb85d", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d61338172fa110fcf9e5f2df0e1e83635d0fde3f/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61338172fa110fcf9e5f2df0e1e83635d0fde3f/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=d61338172fa110fcf9e5f2df0e1e83635d0fde3f", "patch": "@@ -171,6 +171,8 @@ pub use rustrt::c_str;\n \n pub use unicode::char;\n \n+pub use rustrt::thunk;\n+\n /* Exported macros */\n \n pub mod macros;"}, {"sha": "eb517047ddc0b84011a98db9017c9cf4e17fc5ee", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d61338172fa110fcf9e5f2df0e1e83635d0fde3f/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61338172fa110fcf9e5f2df0e1e83635d0fde3f/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=d61338172fa110fcf9e5f2df0e1e83635d0fde3f", "patch": "@@ -52,6 +52,7 @@ use borrow::IntoCow;\n use failure;\n use rustrt;\n use os;\n+use thunk::Thunk;\n \n // Reexport some of our utilities which are expected by other crates.\n pub use self::util::{default_sched_threads, min_stack, running_on_valgrind};\n@@ -87,10 +88,10 @@ static OS_DEFAULT_STACK_ESTIMATE: uint = 2 * (1 << 20);\n #[lang = \"start\"]\n fn lang_start(main: *const u8, argc: int, argv: *const *const u8) -> int {\n     use mem;\n-    start(argc, argv, proc() {\n+    start(argc, argv, Thunk::new(move|| {\n         let main: extern \"Rust\" fn() = unsafe { mem::transmute(main) };\n         main();\n-    })\n+    }))\n }\n \n /// Executes the given procedure after initializing the runtime with the given\n@@ -102,7 +103,7 @@ fn lang_start(main: *const u8, argc: int, argv: *const *const u8) -> int {\n ///\n /// This function will only return once *all* native threads in the system have\n /// exited.\n-pub fn start(argc: int, argv: *const *const u8, main: proc()) -> int {\n+pub fn start(argc: int, argv: *const *const u8, main: Thunk) -> int {\n     use prelude::*;\n     use rt;\n     use rustrt::task::Task;\n@@ -144,7 +145,7 @@ pub fn start(argc: int, argv: *const *const u8, main: proc()) -> int {\n         unsafe {\n             rustrt::stack::record_os_managed_stack_bounds(my_stack_bottom, my_stack_top);\n         }\n-        (main.take().unwrap())();\n+        (main.take().unwrap()).invoke(());\n         exit_code = Some(os::get_exit_status());\n     }).destroy());\n     unsafe { rt::cleanup(); }"}, {"sha": "e5a1e09967ce9d33913ad42826abfd33066a9a02", "filename": "src/libstd/sync/future.rs", "status": "modified", "additions": 18, "deletions": 13, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/d61338172fa110fcf9e5f2df0e1e83635d0fde3f/src%2Flibstd%2Fsync%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61338172fa110fcf9e5f2df0e1e83635d0fde3f/src%2Flibstd%2Fsync%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Ffuture.rs?ref=d61338172fa110fcf9e5f2df0e1e83635d0fde3f", "patch": "@@ -17,7 +17,7 @@\n //! use std::sync::Future;\n //! # fn fib(n: uint) -> uint {42};\n //! # fn make_a_sandwich() {};\n-//! let mut delayed_fib = Future::spawn(proc() { fib(5000) });\n+//! let mut delayed_fib = Future::spawn(move|| { fib(5000) });\n //! make_a_sandwich();\n //! println!(\"fib(5000) = {}\", delayed_fib.get())\n //! ```\n@@ -30,14 +30,15 @@ use core::mem::replace;\n use self::FutureState::*;\n use comm::{Receiver, channel};\n use task::spawn;\n+use thunk::{Thunk};\n \n /// A type encapsulating the result of a computation which may not be complete\n pub struct Future<A> {\n     state: FutureState<A>,\n }\n \n enum FutureState<A> {\n-    Pending(proc():Send -> A),\n+    Pending(Thunk<(),A>),\n     Evaluating,\n     Forced(A)\n }\n@@ -78,7 +79,7 @@ impl<A> Future<A> {\n                 match replace(&mut self.state, Evaluating) {\n                     Forced(_) | Evaluating => panic!(\"Logic error.\"),\n                     Pending(f) => {\n-                        self.state = Forced(f());\n+                        self.state = Forced(f.invoke(()));\n                         self.get_ref()\n                     }\n                 }\n@@ -97,7 +98,9 @@ impl<A> Future<A> {\n         Future {state: Forced(val)}\n     }\n \n-    pub fn from_fn(f: proc():Send -> A) -> Future<A> {\n+    pub fn from_fn<F>(f: F) -> Future<A>\n+        where F : FnOnce() -> A, F : Send\n+    {\n         /*!\n          * Create a future from a function.\n          *\n@@ -106,7 +109,7 @@ impl<A> Future<A> {\n          * function. It is not spawned into another task.\n          */\n \n-        Future {state: Pending(f)}\n+        Future {state: Pending(Thunk::new(f))}\n     }\n }\n \n@@ -119,12 +122,14 @@ impl<A:Send> Future<A> {\n          * waiting for the result to be received on the port.\n          */\n \n-        Future::from_fn(proc() {\n+        Future::from_fn(move|:| {\n             rx.recv()\n         })\n     }\n \n-    pub fn spawn(blk: proc():Send -> A) -> Future<A> {\n+    pub fn spawn<F>(blk: F) -> Future<A>\n+        where F : FnOnce() -> A, F : Send\n+    {\n         /*!\n          * Create a future from a unique closure.\n          *\n@@ -134,7 +139,7 @@ impl<A:Send> Future<A> {\n \n         let (tx, rx) = channel();\n \n-        spawn(proc() {\n+        spawn(move |:| {\n             // Don't panic if the other end has hung up\n             let _ = tx.send_opt(blk());\n         });\n@@ -166,7 +171,7 @@ mod test {\n \n     #[test]\n     fn test_from_fn() {\n-        let mut f = Future::from_fn(proc() \"brail\".to_string());\n+        let mut f = Future::from_fn(move|| \"brail\".to_string());\n         assert_eq!(f.get(), \"brail\");\n     }\n \n@@ -190,23 +195,23 @@ mod test {\n \n     #[test]\n     fn test_spawn() {\n-        let mut f = Future::spawn(proc() \"bale\".to_string());\n+        let mut f = Future::spawn(move|| \"bale\".to_string());\n         assert_eq!(f.get(), \"bale\");\n     }\n \n     #[test]\n     #[should_fail]\n     fn test_future_panic() {\n-        let mut f = Future::spawn(proc() panic!());\n+        let mut f = Future::spawn(move|| panic!());\n         let _x: String = f.get();\n     }\n \n     #[test]\n     fn test_sendable_future() {\n         let expected = \"schlorf\";\n         let (tx, rx) = channel();\n-        let f = Future::spawn(proc() { expected });\n-        task::spawn(proc() {\n+        let f = Future::spawn(move|| { expected });\n+        task::spawn(move|| {\n             let mut f = f;\n             tx.send(f.get());\n         });"}, {"sha": "a684c6502aee9839098f758c39f2b9f1f337663b", "filename": "src/libstd/sync/task_pool.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d61338172fa110fcf9e5f2df0e1e83635d0fde3f/src%2Flibstd%2Fsync%2Ftask_pool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61338172fa110fcf9e5f2df0e1e83635d0fde3f/src%2Flibstd%2Fsync%2Ftask_pool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Ftask_pool.rs?ref=d61338172fa110fcf9e5f2df0e1e83635d0fde3f", "patch": "@@ -72,7 +72,7 @@ pub struct TaskPool {\n     //\n     // This is the only such Sender, so when it is dropped all subtasks will\n     // quit.\n-    jobs: Sender<proc(): Send>\n+    jobs: Sender<Thunk>\n }\n \n impl TaskPool {\n@@ -84,7 +84,7 @@ impl TaskPool {\n     pub fn new(tasks: uint) -> TaskPool {\n         assert!(tasks >= 1);\n \n-        let (tx, rx) = channel::<proc(): Send>();\n+        let (tx, rx) = channel::<Thunk>();\n         let rx = Arc::new(Mutex::new(rx));\n \n         // Taskpool tasks.\n@@ -96,13 +96,15 @@ impl TaskPool {\n     }\n \n     /// Executes the function `job` on a task in the pool.\n-    pub fn execute(&self, job: proc():Send) {\n-        self.jobs.send(job);\n+    pub fn execute<F>(&self, job: F)\n+        where F : FnOnce(), F : Send\n+    {\n+        self.jobs.send(Thunk::new(job));\n     }\n }\n \n-fn spawn_in_pool(jobs: Arc<Mutex<Receiver<proc(): Send>>>) {\n-    spawn(proc() {\n+fn spawn_in_pool(jobs: Arc<Mutex<Receiver<Thunk>>>) {\n+    spawn(move |:| {\n         // Will spawn a new task on panic unless it is cancelled.\n         let sentinel = Sentinel::new(&jobs);\n \n@@ -115,7 +117,7 @@ fn spawn_in_pool(jobs: Arc<Mutex<Receiver<proc(): Send>>>) {\n             };\n \n             match message {\n-                Ok(job) => job(),\n+                Ok(job) => job.invoke(()),\n \n                 // The Taskpool was dropped.\n                 Err(..) => break"}, {"sha": "f71b34304abd65409e968109aa9f389cf46f5cf8", "filename": "src/libstd/sys/unix/process.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d61338172fa110fcf9e5f2df0e1e83635d0fde3f/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61338172fa110fcf9e5f2df0e1e83635d0fde3f/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs?ref=d61338172fa110fcf9e5f2df0e1e83635d0fde3f", "patch": "@@ -531,8 +531,11 @@ impl Process {\n     }\n }\n \n-fn with_argv<T>(prog: &CString, args: &[CString],\n-                cb: proc(*const *const libc::c_char) -> T) -> T {\n+fn with_argv<T,F>(prog: &CString, args: &[CString],\n+                  cb: F)\n+                  -> T\n+    where F : FnOnce(*const *const libc::c_char) -> T\n+{\n     let mut ptrs: Vec<*const libc::c_char> = Vec::with_capacity(args.len()+1);\n \n     // Convert the CStrings into an array of pointers. Note: the\n@@ -549,9 +552,12 @@ fn with_argv<T>(prog: &CString, args: &[CString],\n     cb(ptrs.as_ptr())\n }\n \n-fn with_envp<K, V, T>(env: Option<&collections::HashMap<K, V>>,\n-                      cb: proc(*const c_void) -> T) -> T\n-    where K: BytesContainer + Eq + Hash, V: BytesContainer\n+fn with_envp<K,V,T,F>(env: Option<&collections::HashMap<K, V>>,\n+                      cb: F)\n+                      -> T\n+    where F : FnOnce(*const c_void) -> T,\n+          K : BytesContainer + Eq + Hash,\n+          V : BytesContainer\n {\n     // On posixy systems we can pass a char** for envp, which is a\n     // null-terminated array of \"k=v\\0\" strings. Since we must create"}, {"sha": "340e283708a484a18f94555f098712a109fb9072", "filename": "src/libstd/task.rs", "status": "modified", "additions": 70, "deletions": 58, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/d61338172fa110fcf9e5f2df0e1e83635d0fde3f/src%2Flibstd%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61338172fa110fcf9e5f2df0e1e83635d0fde3f/src%2Flibstd%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask.rs?ref=d61338172fa110fcf9e5f2df0e1e83635d0fde3f", "patch": "@@ -35,7 +35,7 @@\n //! ## Example\n //!\n //! ```rust\n-//! spawn(proc() {\n+//! spawn(move|| {\n //!     println!(\"Hello, World!\");\n //! })\n //! ```\n@@ -47,6 +47,7 @@ use any::Any;\n use borrow::IntoCow;\n use boxed::Box;\n use comm::channel;\n+use core::ops::FnOnce;\n use io::{Writer, stdio};\n use kinds::{Send, marker};\n use option::Option;\n@@ -57,6 +58,7 @@ use rustrt::task::Task;\n use rustrt::task;\n use str::SendStr;\n use string::{String, ToString};\n+use thunk::{Thunk};\n use sync::Future;\n \n /// The task builder type.\n@@ -80,7 +82,7 @@ pub struct TaskBuilder {\n     // Task-local stderr\n     stderr: Option<Box<Writer + Send>>,\n     // Optionally wrap the eventual task body\n-    gen_body: Option<proc(v: proc():Send):Send -> proc():Send>,\n+    gen_body: Option<Thunk<Thunk, Thunk>>,\n     nocopy: marker::NoCopy,\n }\n \n@@ -129,41 +131,46 @@ impl TaskBuilder {\n     }\n \n     // Where spawning actually happens (whether yielding a future or not)\n-    fn spawn_internal(self, f: proc():Send,\n-                      on_exit: Option<proc(Result<(), Box<Any + Send>>):Send>) {\n+    fn spawn_internal(\n+        self,\n+        f: Thunk,\n+        on_exit: Option<Thunk<task::Result>>)\n+    {\n         let TaskBuilder {\n             name, stack_size, stdout, stderr, mut gen_body, nocopy: _\n         } = self;\n+\n         let f = match gen_body.take() {\n-            Some(gen) => gen(f),\n+            Some(gen) => gen.invoke(f),\n             None => f\n         };\n+\n         let opts = task::TaskOpts {\n             on_exit: on_exit,\n             name: name,\n             stack_size: stack_size,\n         };\n         if stdout.is_some() || stderr.is_some() {\n-            Task::spawn(opts, proc() {\n+            Task::spawn(opts, move|:| {\n                 let _ = stdout.map(stdio::set_stdout);\n                 let _ = stderr.map(stdio::set_stderr);\n-                f();\n-            })\n+                f.invoke(());\n+            });\n         } else {\n-            Task::spawn(opts, f)\n+            Task::spawn(opts, move|:| f.invoke(()))\n         }\n     }\n \n     /// Creates and executes a new child task.\n     ///\n     /// Sets up a new task with its own call stack and schedules it to run\n-    /// the provided proc. The task has the properties and behavior\n+    /// the provided function. The task has the properties and behavior\n     /// specified by the `TaskBuilder`.\n-    pub fn spawn(self, f: proc():Send) {\n-        self.spawn_internal(f, None)\n+    pub fn spawn<F:FnOnce()+Send>(self, f: F) {\n+        self.spawn_internal(Thunk::new(f), None)\n     }\n \n-    /// Execute a proc in a newly-spawned task and return a future representing\n+    /// Execute a function in a newly-spawned task and return a future representing\n     /// the task's result. The task has the properties and behavior\n     /// specified by the `TaskBuilder`.\n     ///\n@@ -178,28 +185,32 @@ impl TaskBuilder {\n     /// `result::Result::Err` containing the argument to `panic!(...)` as an\n     /// `Any` trait object.\n     #[experimental = \"Futures are experimental.\"]\n-    pub fn try_future<T:Send>(self, f: proc():Send -> T)\n-                              -> Future<Result<T, Box<Any + Send>>> {\n-        // currently, the on_exit proc provided by librustrt only works for unit\n+    pub fn try_future<T:Send,F:FnOnce()->(T)+Send>(self, f: F)\n+                                                   -> Future<Result<T, Box<Any + Send>>> {\n+        // currently, the on_exit fn provided by librustrt only works for unit\n         // results, so we use an additional side-channel to communicate the\n         // result.\n \n         let (tx_done, rx_done) = channel(); // signal that task has exited\n         let (tx_retv, rx_retv) = channel(); // return value from task\n \n-        let on_exit = proc(res) { let _ = tx_done.send_opt(res); };\n-        self.spawn_internal(proc() { let _ = tx_retv.send_opt(f()); },\n+        let on_exit: Thunk<task::Result> = Thunk::with_arg(move |: res: task::Result| {\n+            let _ = tx_done.send_opt(res);\n+        });\n+        self.spawn_internal(Thunk::new(move |:| { let _ = tx_retv.send_opt(f()); }),\n                             Some(on_exit));\n \n-        Future::from_fn(proc() {\n+        Future::from_fn(move|:| {\n             rx_done.recv().map(|_| rx_retv.recv())\n         })\n     }\n \n     /// Execute a function in a newly-spawnedtask and block until the task\n     /// completes or panics. Equivalent to `.try_future(f).unwrap()`.\n     #[unstable = \"Error type may change.\"]\n-    pub fn try<T:Send>(self, f: proc():Send -> T) -> Result<T, Box<Any + Send>> {\n+    pub fn try<T,F>(self, f: F) -> Result<T, Box<Any + Send>>\n+        where F : FnOnce() -> T, F : Send, T : Send\n+    {\n         self.try_future(f).into_inner()\n     }\n }\n@@ -212,7 +223,7 @@ impl TaskBuilder {\n /// the provided unique closure.\n ///\n /// This function is equivalent to `TaskBuilder::new().spawn(f)`.\n-pub fn spawn(f: proc(): Send) {\n+pub fn spawn<F:FnOnce()+Send>(f: F) {\n     TaskBuilder::new().spawn(f)\n }\n \n@@ -221,7 +232,9 @@ pub fn spawn(f: proc(): Send) {\n ///\n /// This is equivalent to `TaskBuilder::new().try`.\n #[unstable = \"Error type may change.\"]\n-pub fn try<T: Send>(f: proc(): Send -> T) -> Result<T, Box<Any + Send>> {\n+pub fn try<T,F>(f: F) -> Result<T, Box<Any + Send>>\n+    where T : Send, F : FnOnce() -> T, F : Send\n+{\n     TaskBuilder::new().try(f)\n }\n \n@@ -230,11 +243,12 @@ pub fn try<T: Send>(f: proc(): Send -> T) -> Result<T, Box<Any + Send>> {\n ///\n /// This is equivalent to `TaskBuilder::new().try_future`.\n #[experimental = \"Futures are experimental.\"]\n-pub fn try_future<T:Send>(f: proc():Send -> T) -> Future<Result<T, Box<Any + Send>>> {\n+pub fn try_future<T,F>(f: F) -> Future<Result<T, Box<Any + Send>>>\n+    where T:Send, F:FnOnce()->T, F:Send\n+{\n     TaskBuilder::new().try_future(f)\n }\n \n-\n /* Lifecycle functions */\n \n /// Read the name of the current task.\n@@ -274,62 +288,64 @@ mod test {\n     use result;\n     use std::io::{ChanReader, ChanWriter};\n     use string::String;\n+    use thunk::Thunk;\n+    use prelude::*;\n     use super::*;\n \n     // !!! These tests are dangerous. If something is buggy, they will hang, !!!\n     // !!! instead of exiting cleanly. This might wedge the buildbots.       !!!\n \n     #[test]\n     fn test_unnamed_task() {\n-        try(proc() {\n+        try(move|| {\n             assert!(name().is_none());\n         }).map_err(|_| ()).unwrap();\n     }\n \n     #[test]\n     fn test_owned_named_task() {\n-        TaskBuilder::new().named(\"ada lovelace\".to_string()).try(proc() {\n+        TaskBuilder::new().named(\"ada lovelace\".to_string()).try(move|| {\n             assert!(name().unwrap() == \"ada lovelace\");\n         }).map_err(|_| ()).unwrap();\n     }\n \n     #[test]\n     fn test_static_named_task() {\n-        TaskBuilder::new().named(\"ada lovelace\").try(proc() {\n+        TaskBuilder::new().named(\"ada lovelace\").try(move|| {\n             assert!(name().unwrap() == \"ada lovelace\");\n         }).map_err(|_| ()).unwrap();\n     }\n \n     #[test]\n     fn test_send_named_task() {\n-        TaskBuilder::new().named(\"ada lovelace\".into_cow()).try(proc() {\n+        TaskBuilder::new().named(\"ada lovelace\".into_cow()).try(move|| {\n             assert!(name().unwrap() == \"ada lovelace\");\n         }).map_err(|_| ()).unwrap();\n     }\n \n     #[test]\n     fn test_run_basic() {\n         let (tx, rx) = channel();\n-        TaskBuilder::new().spawn(proc() {\n+        TaskBuilder::new().spawn(move|| {\n             tx.send(());\n         });\n         rx.recv();\n     }\n \n     #[test]\n     fn test_try_future() {\n-        let result = TaskBuilder::new().try_future(proc() {});\n+        let result = TaskBuilder::new().try_future(move|| {});\n         assert!(result.unwrap().is_ok());\n \n-        let result = TaskBuilder::new().try_future(proc() -> () {\n+        let result = TaskBuilder::new().try_future(move|| -> () {\n             panic!();\n         });\n         assert!(result.unwrap().is_err());\n     }\n \n     #[test]\n     fn test_try_success() {\n-        match try(proc() {\n+        match try(move|| {\n             \"Success!\".to_string()\n         }).as_ref().map(|s| s.as_slice()) {\n             result::Result::Ok(\"Success!\") => (),\n@@ -339,7 +355,7 @@ mod test {\n \n     #[test]\n     fn test_try_panic() {\n-        match try(proc() {\n+        match try(move|| {\n             panic!()\n         }) {\n             result::Result::Err(_) => (),\n@@ -355,7 +371,7 @@ mod test {\n \n         fn f(i: int, tx: Sender<()>) {\n             let tx = tx.clone();\n-            spawn(proc() {\n+            spawn(move|| {\n                 if i == 0 {\n                     tx.send(());\n                 } else {\n@@ -372,8 +388,8 @@ mod test {\n     fn test_spawn_sched_childs_on_default_sched() {\n         let (tx, rx) = channel();\n \n-        spawn(proc() {\n-            spawn(proc() {\n+        spawn(move|| {\n+            spawn(move|| {\n                 tx.send(());\n             });\n         });\n@@ -382,43 +398,39 @@ mod test {\n     }\n \n     fn avoid_copying_the_body<F>(spawnfn: F) where\n-        F: FnOnce(proc():Send),\n+        F: FnOnce(Thunk),\n     {\n         let (tx, rx) = channel::<uint>();\n \n         let x = box 1;\n         let x_in_parent = (&*x) as *const int as uint;\n \n-        spawnfn(proc() {\n+        spawnfn(Thunk::new(move|| {\n             let x_in_child = (&*x) as *const int as uint;\n             tx.send(x_in_child);\n-        });\n+        }));\n \n         let x_in_child = rx.recv();\n         assert_eq!(x_in_parent, x_in_child);\n     }\n \n     #[test]\n     fn test_avoid_copying_the_body_spawn() {\n-        avoid_copying_the_body(spawn);\n+        avoid_copying_the_body(|t| spawn(move|| t.invoke(())));\n     }\n \n     #[test]\n     fn test_avoid_copying_the_body_task_spawn() {\n         avoid_copying_the_body(|f| {\n             let builder = TaskBuilder::new();\n-            builder.spawn(proc() {\n-                f();\n-            });\n+            builder.spawn(move|| f.invoke(()));\n         })\n     }\n \n     #[test]\n     fn test_avoid_copying_the_body_try() {\n         avoid_copying_the_body(|f| {\n-            let _ = try(proc() {\n-                f()\n-            });\n+            let _ = try(move|| f.invoke(()));\n         })\n     }\n \n@@ -429,24 +441,24 @@ mod test {\n         // (well, it would if the constant were 8000+ - I lowered it to be more\n         // valgrind-friendly. try this at home, instead..!)\n         static GENERATIONS: uint = 16;\n-        fn child_no(x: uint) -> proc(): Send {\n-            return proc() {\n+        fn child_no(x: uint) -> Thunk {\n+            return Thunk::new(move|| {\n                 if x < GENERATIONS {\n-                    TaskBuilder::new().spawn(child_no(x+1));\n+                    TaskBuilder::new().spawn(move|| child_no(x+1).invoke(()));\n                 }\n-            }\n+            });\n         }\n-        TaskBuilder::new().spawn(child_no(0));\n+        TaskBuilder::new().spawn(|| child_no(0).invoke(()));\n     }\n \n     #[test]\n     fn test_simple_newsched_spawn() {\n-        spawn(proc()())\n+        spawn(move|| ())\n     }\n \n     #[test]\n     fn test_try_panic_message_static_str() {\n-        match try(proc() {\n+        match try(move|| {\n             panic!(\"static string\");\n         }) {\n             Err(e) => {\n@@ -460,7 +472,7 @@ mod test {\n \n     #[test]\n     fn test_try_panic_message_owned_str() {\n-        match try(proc() {\n+        match try(move|| {\n             panic!(\"owned string\".to_string());\n         }) {\n             Err(e) => {\n@@ -474,7 +486,7 @@ mod test {\n \n     #[test]\n     fn test_try_panic_message_any() {\n-        match try(proc() {\n+        match try(move|| {\n             panic!(box 413u16 as Box<Any + Send>);\n         }) {\n             Err(e) => {\n@@ -492,7 +504,7 @@ mod test {\n     fn test_try_panic_message_unit_struct() {\n         struct Juju;\n \n-        match try(proc() {\n+        match try(move|| {\n             panic!(Juju)\n         }) {\n             Err(ref e) if e.is::<Juju>() => {}\n@@ -507,7 +519,7 @@ mod test {\n         let stdout = ChanWriter::new(tx);\n \n         let r = TaskBuilder::new().stdout(box stdout as Box<Writer + Send>)\n-                                  .try(proc() {\n+                                  .try(move|| {\n                 print!(\"Hello, world!\");\n             });\n         assert!(r.is_ok());\n@@ -527,7 +539,7 @@ fn task_abort_no_kill_runtime() {\n     use mem;\n \n     let tb = TaskBuilder::new();\n-    let rx = tb.try_future(proc() {});\n+    let rx = tb.try_future(move|| {});\n     mem::drop(rx);\n     timer::sleep(Duration::milliseconds(1000));\n }"}]}