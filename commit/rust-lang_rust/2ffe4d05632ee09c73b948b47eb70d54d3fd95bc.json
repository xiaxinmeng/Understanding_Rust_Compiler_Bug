{"sha": "2ffe4d05632ee09c73b948b47eb70d54d3fd95bc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJmZmU0ZDA1NjMyZWUwOWM3M2I5NDhiNDdlYjcwZDU0ZDNmZDk1YmM=", "commit": {"author": {"name": "topecongiro", "email": "seuchida@gmail.com", "date": "2017-07-26T08:40:57Z"}, "committer": {"name": "topecongiro", "email": "seuchida@gmail.com", "date": "2017-07-26T08:40:57Z"}, "message": "Simplify rewrite_pair", "tree": {"sha": "b1b50d642f6b3e18065e679a9a88e16bfbbc2269", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b1b50d642f6b3e18065e679a9a88e16bfbbc2269"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2ffe4d05632ee09c73b948b47eb70d54d3fd95bc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2ffe4d05632ee09c73b948b47eb70d54d3fd95bc", "html_url": "https://github.com/rust-lang/rust/commit/2ffe4d05632ee09c73b948b47eb70d54d3fd95bc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2ffe4d05632ee09c73b948b47eb70d54d3fd95bc/comments", "author": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "committer": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e523f053a3cd06453733f5543492d80e10bf8964", "url": "https://api.github.com/repos/rust-lang/rust/commits/e523f053a3cd06453733f5543492d80e10bf8964", "html_url": "https://github.com/rust-lang/rust/commit/e523f053a3cd06453733f5543492d80e10bf8964"}], "stats": {"total": 87, "additions": 24, "deletions": 63}, "files": [{"sha": "f6edc454a7782ad78af030e4ef419569d7a49ba3", "filename": "src/expr.rs", "status": "modified", "additions": 24, "deletions": 63, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/2ffe4d05632ee09c73b948b47eb70d54d3fd95bc/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ffe4d05632ee09c73b948b47eb70d54d3fd95bc/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=2ffe4d05632ee09c73b948b47eb70d54d3fd95bc", "patch": "@@ -370,56 +370,37 @@ where\n     LHS: Rewrite,\n     RHS: Rewrite,\n {\n-    // Get \"full width\" rhs and see if it fits on the current line. This\n-    // usually works fairly well since it tends to place operands of\n-    // operations with high precendence close together.\n-    // Note that this is non-conservative, but its just to see if it's even\n-    // worth trying to put everything on one line.\n-    let rhs_shape = try_opt!(shape.sub_width(suffix.len()));\n-    let rhs_orig_result = rhs.rewrite(context, rhs_shape);\n+    let sep = if infix.ends_with(' ') { \" \" } else { \"\" };\n+    let infix = infix.trim_right();\n+    let lhs_overhead = shape.used_width() + prefix.len() + infix.len();\n+    let lhs_shape = Shape {\n+        width: try_opt!(context.config.max_width().checked_sub(lhs_overhead)),\n+        ..shape\n+    };\n+    let lhs_result = try_opt!(\n+        lhs.rewrite(context, lhs_shape)\n+            .map(|lhs_str| format!(\"{}{}{}\", prefix, lhs_str, infix))\n+    );\n \n+    // Try to the both lhs and rhs on the same line.\n+    let rhs_orig_result = shape\n+        .offset_left(last_line_width(&lhs_result) + suffix.len() + sep.len())\n+        .and_then(|rhs_shape| rhs.rewrite(context, rhs_shape));\n     if let Some(ref rhs_result) = rhs_orig_result {\n-        // This is needed in case of line break not caused by a\n-        // shortage of space, but by end-of-line comments, for example.\n-        if !rhs_result.contains('\\n') {\n-            let lhs_shape =\n-                try_opt!(try_opt!(shape.offset_left(prefix.len())).sub_width(infix.len()));\n-            let lhs_result = lhs.rewrite(context, lhs_shape);\n-            if let Some(lhs_result) = lhs_result {\n-                let mut result = format!(\"{}{}{}\", prefix, lhs_result, infix);\n-\n-                let remaining_width = shape\n-                    .width\n-                    .checked_sub(last_line_width(&result) + suffix.len())\n-                    .unwrap_or(0);\n-\n-                if rhs_result.len() <= remaining_width {\n-                    result.push_str(&rhs_result);\n-                    result.push_str(suffix);\n-                    return Some(result);\n-                }\n-\n-                // Try rewriting the rhs into the remaining space.\n-                let rhs_shape = shape.offset_left(last_line_width(&result) + suffix.len());\n-                if let Some(rhs_shape) = rhs_shape {\n-                    if let Some(rhs_result) = rhs.rewrite(context, rhs_shape) {\n-                        // FIXME this should always hold.\n-                        if rhs_result.len() <= remaining_width {\n-                            result.push_str(&rhs_result);\n-                            result.push_str(suffix);\n-                            return Some(result);\n-                        }\n-                    }\n-                }\n-            }\n+        // If the rhs looks like block expression, we allow it to stay on the same line\n+        // with the lhs even if it is multi-lined.\n+        let allow_same_line = rhs_result\n+            .lines()\n+            .next()\n+            .map(|first_line| first_line.ends_with('{'))\n+            .unwrap_or(false);\n+        if !rhs_result.contains('\\n') || allow_same_line {\n+            return Some(format!(\"{}{}{}{}\", lhs_result, sep, rhs_result, suffix));\n         }\n     }\n \n     // We have to use multiple lines.\n-\n     // Re-evaluate the rhs because we have more space now:\n-    let sep = if infix.ends_with(' ') { \" \" } else { \"\" };\n-    let infix = infix.trim_right();\n     let rhs_shape = match context.config.control_style() {\n         Style::Legacy => {\n             try_opt!(shape.sub_width(suffix.len() + prefix.len())).visual_indent(prefix.len())\n@@ -434,26 +415,6 @@ where\n         }\n     };\n     let rhs_result = try_opt!(rhs.rewrite(context, rhs_shape));\n-    let lhs_overhead = shape.used_width() + prefix.len() + infix.len();\n-    let lhs_shape = Shape {\n-        width: try_opt!(context.config.max_width().checked_sub(lhs_overhead)),\n-        ..shape\n-    };\n-    let lhs_result = try_opt!(\n-        lhs.rewrite(context, lhs_shape)\n-            .map(|lhs_str| format!(\"{}{}{}\", prefix, lhs_str, infix))\n-    );\n-    if let Some(ref rhs_str) = rhs_orig_result {\n-        if rhs_str.lines().count() <= rhs_result.lines().count() &&\n-            rhs_str\n-                .lines()\n-                .next()\n-                .map_or(false, |first_line| first_line.ends_with('{')) &&\n-            last_line_width(&lhs_result) + sep.len() + first_line_width(rhs_str) <= shape.width\n-        {\n-            return Some(format!(\"{}{}{}{}\", lhs_result, sep, rhs_str, suffix));\n-        }\n-    }\n     Some(format!(\n         \"{}\\n{}{}{}\",\n         lhs_result,"}]}