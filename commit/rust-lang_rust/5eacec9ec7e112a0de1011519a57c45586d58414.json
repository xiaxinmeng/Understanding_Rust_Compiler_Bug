{"sha": "5eacec9ec7e112a0de1011519a57c45586d58414", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVlYWNlYzllYzdlMTEyYTBkZTEwMTE1MTlhNTdjNDU1ODZkNTg0MTQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-08-28T20:58:12Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-08-28T20:58:12Z"}, "message": "Auto merge of #85690 - bstrie:m2_arena, r=jackh726,nagisa\n\nMacros 2.0-ify rustc_arena\n\nFor the purpose of battle-testing macros 2.0 I'm looking to dogfood it in rustc, one crate at a time.\n\n(Note that there are only 12 changed lines if you ignore whitespace.)", "tree": {"sha": "94fb175062e19aebb844d4bb11627d91cc99fd86", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/94fb175062e19aebb844d4bb11627d91cc99fd86"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5eacec9ec7e112a0de1011519a57c45586d58414", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5eacec9ec7e112a0de1011519a57c45586d58414", "html_url": "https://github.com/rust-lang/rust/commit/5eacec9ec7e112a0de1011519a57c45586d58414", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5eacec9ec7e112a0de1011519a57c45586d58414/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "926f069950d7211a87fbd81778b420de420daad7", "url": "https://api.github.com/repos/rust-lang/rust/commits/926f069950d7211a87fbd81778b420de420daad7", "html_url": "https://github.com/rust-lang/rust/commit/926f069950d7211a87fbd81778b420de420daad7"}, {"sha": "71db7cc0b40306495b8bb69baea653f4b3978c21", "url": "https://api.github.com/repos/rust-lang/rust/commits/71db7cc0b40306495b8bb69baea653f4b3978c21", "html_url": "https://github.com/rust-lang/rust/commit/71db7cc0b40306495b8bb69baea653f4b3978c21"}], "stats": {"total": 154, "additions": 76, "deletions": 78}, "files": [{"sha": "2e8022d9880b243c69bc9573090de6e8a80507e9", "filename": "compiler/rustc_arena/src/lib.rs", "status": "modified", "additions": 76, "deletions": 78, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/5eacec9ec7e112a0de1011519a57c45586d58414/compiler%2Frustc_arena%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eacec9ec7e112a0de1011519a57c45586d58414/compiler%2Frustc_arena%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_arena%2Fsrc%2Flib.rs?ref=5eacec9ec7e112a0de1011519a57c45586d58414", "patch": "@@ -15,6 +15,8 @@\n #![feature(new_uninit)]\n #![feature(maybe_uninit_slice)]\n #![feature(min_specialization)]\n+#![feature(decl_macro)]\n+#![feature(rustc_attrs)]\n #![cfg_attr(test, feature(test))]\n \n use rustc_data_structures::sync;\n@@ -608,117 +610,113 @@ impl DropArena {\n     }\n }\n \n-#[macro_export]\n-macro_rules! arena_for_type {\n+pub macro arena_for_type {\n     ([][$ty:ty]) => {\n         $crate::TypedArena<$ty>\n-    };\n+    },\n     ([few $(, $attrs:ident)*][$ty:ty]) => {\n         ::std::marker::PhantomData<$ty>\n-    };\n+    },\n     ([$ignore:ident $(, $attrs:ident)*]$args:tt) => {\n         $crate::arena_for_type!([$($attrs),*]$args)\n-    };\n+    },\n }\n \n-#[macro_export]\n-macro_rules! which_arena_for_type {\n+pub macro which_arena_for_type {\n     ([][$arena:expr]) => {\n         ::std::option::Option::Some($arena)\n-    };\n+    },\n     ([few$(, $attrs:ident)*][$arena:expr]) => {\n         ::std::option::Option::None\n-    };\n+    },\n     ([$ignore:ident$(, $attrs:ident)*]$args:tt) => {\n         $crate::which_arena_for_type!([$($attrs),*]$args)\n-    };\n+    },\n }\n \n-#[macro_export]\n-macro_rules! declare_arena {\n-    ([], [$($a:tt $name:ident: $ty:ty,)*], $tcx:lifetime) => {\n-        #[derive(Default)]\n-        pub struct Arena<$tcx> {\n-            pub dropless: $crate::DroplessArena,\n-            drop: $crate::DropArena,\n-            $($name: $crate::arena_for_type!($a[$ty]),)*\n-        }\n+#[rustc_macro_transparency = \"semitransparent\"]\n+pub macro declare_arena([], [$($a:tt $name:ident: $ty:ty,)*], $tcx:lifetime) {\n+    #[derive(Default)]\n+    pub struct Arena<$tcx> {\n+        pub dropless: $crate::DroplessArena,\n+        drop: $crate::DropArena,\n+        $($name: $crate::arena_for_type!($a[$ty]),)*\n+    }\n \n-        pub trait ArenaAllocatable<'tcx, T = Self>: Sized {\n-            fn allocate_on<'a>(self, arena: &'a Arena<'tcx>) -> &'a mut Self;\n-            fn allocate_from_iter<'a>(\n-                arena: &'a Arena<'tcx>,\n-                iter: impl ::std::iter::IntoIterator<Item = Self>,\n-            ) -> &'a mut [Self];\n+    pub trait ArenaAllocatable<'tcx, T = Self>: Sized {\n+        fn allocate_on<'a>(self, arena: &'a Arena<'tcx>) -> &'a mut Self;\n+        fn allocate_from_iter<'a>(\n+            arena: &'a Arena<'tcx>,\n+            iter: impl ::std::iter::IntoIterator<Item = Self>,\n+        ) -> &'a mut [Self];\n+    }\n+\n+    impl<'tcx, T: Copy> ArenaAllocatable<'tcx, ()> for T {\n+        #[inline]\n+        fn allocate_on<'a>(self, arena: &'a Arena<'tcx>) -> &'a mut Self {\n+            arena.dropless.alloc(self)\n+        }\n+        #[inline]\n+        fn allocate_from_iter<'a>(\n+            arena: &'a Arena<'tcx>,\n+            iter: impl ::std::iter::IntoIterator<Item = Self>,\n+        ) -> &'a mut [Self] {\n+            arena.dropless.alloc_from_iter(iter)\n         }\n \n-        impl<'tcx, T: Copy> ArenaAllocatable<'tcx, ()> for T {\n+    }\n+    $(\n+        impl<$tcx> ArenaAllocatable<$tcx, $ty> for $ty {\n             #[inline]\n-            fn allocate_on<'a>(self, arena: &'a Arena<'tcx>) -> &'a mut Self {\n-                arena.dropless.alloc(self)\n+            fn allocate_on<'a>(self, arena: &'a Arena<$tcx>) -> &'a mut Self {\n+                if !::std::mem::needs_drop::<Self>() {\n+                    return arena.dropless.alloc(self);\n+                }\n+                match $crate::which_arena_for_type!($a[&arena.$name]) {\n+                    ::std::option::Option::<&$crate::TypedArena<Self>>::Some(ty_arena) => {\n+                        ty_arena.alloc(self)\n+                    }\n+                    ::std::option::Option::None => unsafe { arena.drop.alloc(self) },\n+                }\n             }\n+\n             #[inline]\n             fn allocate_from_iter<'a>(\n-                arena: &'a Arena<'tcx>,\n+                arena: &'a Arena<$tcx>,\n                 iter: impl ::std::iter::IntoIterator<Item = Self>,\n             ) -> &'a mut [Self] {\n-                arena.dropless.alloc_from_iter(iter)\n-            }\n-\n-        }\n-        $(\n-            impl<$tcx> ArenaAllocatable<$tcx, $ty> for $ty {\n-                #[inline]\n-                fn allocate_on<'a>(self, arena: &'a Arena<$tcx>) -> &'a mut Self {\n-                    if !::std::mem::needs_drop::<Self>() {\n-                        return arena.dropless.alloc(self);\n-                    }\n-                    match $crate::which_arena_for_type!($a[&arena.$name]) {\n-                        ::std::option::Option::<&$crate::TypedArena<Self>>::Some(ty_arena) => {\n-                            ty_arena.alloc(self)\n-                        }\n-                        ::std::option::Option::None => unsafe { arena.drop.alloc(self) },\n-                    }\n+                if !::std::mem::needs_drop::<Self>() {\n+                    return arena.dropless.alloc_from_iter(iter);\n                 }\n-\n-                #[inline]\n-                fn allocate_from_iter<'a>(\n-                    arena: &'a Arena<$tcx>,\n-                    iter: impl ::std::iter::IntoIterator<Item = Self>,\n-                ) -> &'a mut [Self] {\n-                    if !::std::mem::needs_drop::<Self>() {\n-                        return arena.dropless.alloc_from_iter(iter);\n-                    }\n-                    match $crate::which_arena_for_type!($a[&arena.$name]) {\n-                        ::std::option::Option::<&$crate::TypedArena<Self>>::Some(ty_arena) => {\n-                            ty_arena.alloc_from_iter(iter)\n-                        }\n-                        ::std::option::Option::None => unsafe { arena.drop.alloc_from_iter(iter) },\n+                match $crate::which_arena_for_type!($a[&arena.$name]) {\n+                    ::std::option::Option::<&$crate::TypedArena<Self>>::Some(ty_arena) => {\n+                        ty_arena.alloc_from_iter(iter)\n                     }\n+                    ::std::option::Option::None => unsafe { arena.drop.alloc_from_iter(iter) },\n                 }\n             }\n-        )*\n+        }\n+    )*\n \n-        impl<'tcx> Arena<'tcx> {\n-            #[inline]\n-            pub fn alloc<T: ArenaAllocatable<'tcx, U>, U>(&self, value: T) -> &mut T {\n-                value.allocate_on(self)\n-            }\n+    impl<'tcx> Arena<'tcx> {\n+        #[inline]\n+        pub fn alloc<T: ArenaAllocatable<'tcx, U>, U>(&self, value: T) -> &mut T {\n+            value.allocate_on(self)\n+        }\n \n-            #[inline]\n-            pub fn alloc_slice<T: ::std::marker::Copy>(&self, value: &[T]) -> &mut [T] {\n-                if value.is_empty() {\n-                    return &mut [];\n-                }\n-                self.dropless.alloc_slice(value)\n+        #[inline]\n+        pub fn alloc_slice<T: ::std::marker::Copy>(&self, value: &[T]) -> &mut [T] {\n+            if value.is_empty() {\n+                return &mut [];\n             }\n+            self.dropless.alloc_slice(value)\n+        }\n \n-            pub fn alloc_from_iter<'a, T: ArenaAllocatable<'tcx, U>, U>(\n-                &'a self,\n-                iter: impl ::std::iter::IntoIterator<Item = T>,\n-            ) -> &'a mut [T] {\n-                T::allocate_from_iter(self, iter)\n-            }\n+        pub fn alloc_from_iter<'a, T: ArenaAllocatable<'tcx, U>, U>(\n+            &'a self,\n+            iter: impl ::std::iter::IntoIterator<Item = T>,\n+        ) -> &'a mut [T] {\n+            T::allocate_from_iter(self, iter)\n         }\n     }\n }"}]}