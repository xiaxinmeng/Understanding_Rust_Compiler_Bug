{"sha": "11d40910cdc501b22e503cfe1054a7f21478785e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjExZDQwOTEwY2RjNTAxYjIyZTUwM2NmZTEwNTRhN2YyMTQ3ODc4NWU=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-08-23T13:03:21Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-08-24T17:13:06Z"}, "message": "typeck: move `check_pat_walk` and children to `pat.rs`.", "tree": {"sha": "87c69d54a7f64cda467188f795cd26e9fc967b81", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/87c69d54a7f64cda467188f795cd26e9fc967b81"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/11d40910cdc501b22e503cfe1054a7f21478785e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/11d40910cdc501b22e503cfe1054a7f21478785e", "html_url": "https://github.com/rust-lang/rust/commit/11d40910cdc501b22e503cfe1054a7f21478785e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/11d40910cdc501b22e503cfe1054a7f21478785e/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0507d49755b9f506da8770af757704eb5c2b54d7", "url": "https://api.github.com/repos/rust-lang/rust/commits/0507d49755b9f506da8770af757704eb5c2b54d7", "html_url": "https://github.com/rust-lang/rust/commit/0507d49755b9f506da8770af757704eb5c2b54d7"}], "stats": {"total": 1934, "additions": 971, "deletions": 963}, "files": [{"sha": "8cb365d91fa7941cdc321d787637e35ce7b40e85", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 2, "deletions": 963, "changes": 965, "blob_url": "https://github.com/rust-lang/rust/blob/11d40910cdc501b22e503cfe1054a7f21478785e/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11d40910cdc501b22e503cfe1054a7f21478785e/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=11d40910cdc501b22e503cfe1054a7f21478785e", "patch": "@@ -1,631 +1,12 @@\n use crate::check::{FnCtxt, Expectation, Diverges, Needs};\n use crate::check::coercion::CoerceMany;\n-use crate::util::nodemap::FxHashMap;\n-use errors::{Applicability, DiagnosticBuilder};\n-use rustc::hir::{self, PatKind, Pat, ExprKind};\n-use rustc::hir::def::{Res, DefKind, CtorKind};\n-use rustc::hir::pat_util::EnumerateAndAdjustIterator;\n-use rustc::hir::ptr::P;\n-use rustc::infer;\n+use rustc::hir::{self, ExprKind};\n use rustc::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc::traits::{ObligationCause, ObligationCauseCode};\n-use rustc::ty::{self, Ty, TypeFoldable};\n-use rustc::ty::subst::Kind;\n-use syntax::ast;\n-use syntax::util::lev_distance::find_best_match_for_name;\n+use rustc::ty::{self, Ty};\n use syntax_pos::Span;\n-use syntax_pos::hygiene::DesugaringKind;\n-\n-use std::collections::hash_map::Entry::{Occupied, Vacant};\n-use std::cmp;\n-\n-use super::report_unexpected_variant_res;\n \n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n-    /// `discrim_span` argument having a `Span` indicates that this pattern is part of a match\n-    /// expression arm guard, and it points to the match discriminant to add context in type errors.\n-    /// In the following example, `discrim_span` corresponds to the `a + b` expression:\n-    ///\n-    /// ```text\n-    /// error[E0308]: mismatched types\n-    ///  --> src/main.rs:5:9\n-    ///   |\n-    /// 4 |    let temp: usize = match a + b {\n-    ///   |                            ----- this expression has type `usize`\n-    /// 5 |         Ok(num) => num,\n-    ///   |         ^^^^^^^ expected usize, found enum `std::result::Result`\n-    ///   |\n-    ///   = note: expected type `usize`\n-    ///              found type `std::result::Result<_, _>`\n-    /// ```\n-    pub fn check_pat_walk(\n-        &self,\n-        pat: &'tcx hir::Pat,\n-        mut expected: Ty<'tcx>,\n-        mut def_bm: ty::BindingMode,\n-        discrim_span: Option<Span>,\n-    ) {\n-        let tcx = self.tcx;\n-\n-        debug!(\"check_pat_walk(pat={:?},expected={:?},def_bm={:?})\", pat, expected, def_bm);\n-\n-        let mut path_resolution = None;\n-        let is_non_ref_pat = match pat.node {\n-            PatKind::Struct(..) |\n-            PatKind::TupleStruct(..) |\n-            PatKind::Or(_) |\n-            PatKind::Tuple(..) |\n-            PatKind::Box(_) |\n-            PatKind::Range(..) |\n-            PatKind::Slice(..) => true,\n-            PatKind::Lit(ref lt) => {\n-                let ty = self.check_expr(lt);\n-                match ty.sty {\n-                    ty::Ref(..) => false,\n-                    _ => true,\n-                }\n-            }\n-            PatKind::Path(ref qpath) => {\n-                let resolution = self.resolve_ty_and_res_ufcs(qpath, pat.hir_id, pat.span);\n-                path_resolution = Some(resolution);\n-                match resolution.0 {\n-                    Res::Def(DefKind::Const, _) | Res::Def(DefKind::AssocConst, _) => false,\n-                    _ => true,\n-                }\n-            }\n-            PatKind::Wild |\n-            PatKind::Binding(..) |\n-            PatKind::Ref(..) => false,\n-        };\n-        if is_non_ref_pat {\n-            debug!(\"pattern is non reference pattern\");\n-            let mut exp_ty = self.resolve_type_vars_with_obligations(&expected);\n-\n-            // Peel off as many `&` or `&mut` from the discriminant as possible. For example,\n-            // for `match &&&mut Some(5)` the loop runs three times, aborting when it reaches\n-            // the `Some(5)` which is not of type Ref.\n-            //\n-            // For each ampersand peeled off, update the binding mode and push the original\n-            // type into the adjustments vector.\n-            //\n-            // See the examples in `ui/match-defbm*.rs`.\n-            let mut pat_adjustments = vec![];\n-            while let ty::Ref(_, inner_ty, inner_mutability) = exp_ty.sty {\n-                debug!(\"inspecting {:?}\", exp_ty);\n-\n-                debug!(\"current discriminant is Ref, inserting implicit deref\");\n-                // Preserve the reference type. We'll need it later during HAIR lowering.\n-                pat_adjustments.push(exp_ty);\n-\n-                exp_ty = inner_ty;\n-                def_bm = match def_bm {\n-                    // If default binding mode is by value, make it `ref` or `ref mut`\n-                    // (depending on whether we observe `&` or `&mut`).\n-                    ty::BindByValue(_) =>\n-                        ty::BindByReference(inner_mutability),\n-\n-                    // Once a `ref`, always a `ref`. This is because a `& &mut` can't mutate\n-                    // the underlying value.\n-                    ty::BindByReference(hir::Mutability::MutImmutable) =>\n-                        ty::BindByReference(hir::Mutability::MutImmutable),\n-\n-                    // When `ref mut`, stay a `ref mut` (on `&mut`) or downgrade to `ref`\n-                    // (on `&`).\n-                    ty::BindByReference(hir::Mutability::MutMutable) =>\n-                        ty::BindByReference(inner_mutability),\n-                };\n-            }\n-            expected = exp_ty;\n-\n-            if pat_adjustments.len() > 0 {\n-                debug!(\"default binding mode is now {:?}\", def_bm);\n-                self.inh.tables.borrow_mut()\n-                    .pat_adjustments_mut()\n-                    .insert(pat.hir_id, pat_adjustments);\n-            }\n-        } else if let PatKind::Ref(..) = pat.node {\n-            // When you encounter a `&pat` pattern, reset to \"by\n-            // value\". This is so that `x` and `y` here are by value,\n-            // as they appear to be:\n-            //\n-            // ```\n-            // match &(&22, &44) {\n-            //   (&x, &y) => ...\n-            // }\n-            // ```\n-            //\n-            // See issue #46688.\n-            def_bm = ty::BindByValue(hir::MutImmutable);\n-        }\n-\n-        // Lose mutability now that we know binding mode and discriminant type.\n-        let def_bm = def_bm;\n-        let expected = expected;\n-\n-        let ty = match pat.node {\n-            PatKind::Wild => {\n-                expected\n-            }\n-            PatKind::Lit(ref lt) => {\n-                // We've already computed the type above (when checking for a non-ref pat), so\n-                // avoid computing it again.\n-                let ty = self.node_ty(lt.hir_id);\n-\n-                // Byte string patterns behave the same way as array patterns\n-                // They can denote both statically and dynamically-sized byte arrays.\n-                let mut pat_ty = ty;\n-                if let hir::ExprKind::Lit(ref lt) = lt.node {\n-                    if let ast::LitKind::ByteStr(_) = lt.node {\n-                        let expected_ty = self.structurally_resolved_type(pat.span, expected);\n-                        if let ty::Ref(_, r_ty, _) = expected_ty.sty {\n-                            if let ty::Slice(_) = r_ty.sty {\n-                                pat_ty = tcx.mk_imm_ref(tcx.lifetimes.re_static,\n-                                                        tcx.mk_slice(tcx.types.u8))\n-                            }\n-                        }\n-                    }\n-                }\n-\n-                // Somewhat surprising: in this case, the subtyping\n-                // relation goes the opposite way as the other\n-                // cases. Actually what we really want is not a subtyping\n-                // relation at all but rather that there exists a LUB (so\n-                // that they can be compared). However, in practice,\n-                // constants are always scalars or strings.  For scalars\n-                // subtyping is irrelevant, and for strings `ty` is\n-                // type is `&'static str`, so if we say that\n-                //\n-                //     &'static str <: expected\n-                //\n-                // then that's equivalent to there existing a LUB.\n-                if let Some(mut err) = self.demand_suptype_diag(pat.span, expected, pat_ty) {\n-                    err.emit_unless(discrim_span\n-                        .filter(|&s| {\n-                            // In the case of `if`- and `while`-expressions we've already checked\n-                            // that `scrutinee: bool`. We know that the pattern is `true`,\n-                            // so an error here would be a duplicate and from the wrong POV.\n-                            s.is_desugaring(DesugaringKind::CondTemporary)\n-                        })\n-                        .is_some());\n-                }\n-\n-                pat_ty\n-            }\n-            PatKind::Range(ref begin, ref end, _) => {\n-                let lhs_ty = self.check_expr(begin);\n-                let rhs_ty = self.check_expr(end);\n-\n-                // Check that both end-points are of numeric or char type.\n-                let numeric_or_char = |ty: Ty<'_>| {\n-                    ty.is_numeric()\n-                    || ty.is_char()\n-                    || ty.references_error()\n-                };\n-                let lhs_compat = numeric_or_char(lhs_ty);\n-                let rhs_compat = numeric_or_char(rhs_ty);\n-\n-                if !lhs_compat || !rhs_compat {\n-                    let span = if !lhs_compat && !rhs_compat {\n-                        pat.span\n-                    } else if !lhs_compat {\n-                        begin.span\n-                    } else {\n-                        end.span\n-                    };\n-\n-                    let mut err = struct_span_err!(\n-                        tcx.sess,\n-                        span,\n-                        E0029,\n-                        \"only char and numeric types are allowed in range patterns\"\n-                    );\n-                    err.span_label(span, \"ranges require char or numeric types\");\n-                    err.note(&format!(\"start type: {}\", self.ty_to_string(lhs_ty)));\n-                    err.note(&format!(\"end type: {}\", self.ty_to_string(rhs_ty)));\n-                    if tcx.sess.teach(&err.get_code().unwrap()) {\n-                        err.note(\n-                            \"In a match expression, only numbers and characters can be matched \\\n-                             against a range. This is because the compiler checks that the range \\\n-                             is non-empty at compile-time, and is unable to evaluate arbitrary \\\n-                             comparison functions. If you want to capture values of an orderable \\\n-                             type between two end-points, you can use a guard.\"\n-                         );\n-                    }\n-                    err.emit();\n-                    return;\n-                }\n-\n-                // Now that we know the types can be unified we find the unified type and use\n-                // it to type the entire expression.\n-                let common_type = self.resolve_vars_if_possible(&lhs_ty);\n-\n-                // Subtyping doesn't matter here, as the value is some kind of scalar.\n-                self.demand_eqtype_pat(pat.span, expected, lhs_ty, discrim_span);\n-                self.demand_eqtype_pat(pat.span, expected, rhs_ty, discrim_span);\n-                common_type\n-            }\n-            PatKind::Binding(ba, var_id, _, ref sub) => {\n-                let bm = if ba == hir::BindingAnnotation::Unannotated {\n-                    def_bm\n-                } else {\n-                    ty::BindingMode::convert(ba)\n-                };\n-                self.inh\n-                    .tables\n-                    .borrow_mut()\n-                    .pat_binding_modes_mut()\n-                    .insert(pat.hir_id, bm);\n-                debug!(\"check_pat_walk: pat.hir_id={:?} bm={:?}\", pat.hir_id, bm);\n-                let local_ty = self.local_ty(pat.span, pat.hir_id).decl_ty;\n-                match bm {\n-                    ty::BindByReference(mutbl) => {\n-                        // If the binding is like\n-                        //     ref x | ref const x | ref mut x\n-                        // then `x` is assigned a value of type `&M T` where M is the mutability\n-                        // and T is the expected type.\n-                        let region_var = self.next_region_var(infer::PatternRegion(pat.span));\n-                        let mt = ty::TypeAndMut { ty: expected, mutbl: mutbl };\n-                        let region_ty = tcx.mk_ref(region_var, mt);\n-\n-                        // `x` is assigned a value of type `&M T`, hence `&M T <: typeof(x)` is\n-                        // required. However, we use equality, which is stronger. See (*) for\n-                        // an explanation.\n-                        self.demand_eqtype_pat(pat.span, region_ty, local_ty, discrim_span);\n-                    }\n-                    // Otherwise, the type of x is the expected type `T`.\n-                    ty::BindByValue(_) => {\n-                        // As above, `T <: typeof(x)` is required, but we\n-                        // use equality, see (*) below.\n-                        self.demand_eqtype_pat(pat.span, expected, local_ty, discrim_span);\n-                    }\n-                }\n-\n-                // If there are multiple arms, make sure they all agree on\n-                // what the type of the binding `x` ought to be.\n-                if var_id != pat.hir_id {\n-                    let vt = self.local_ty(pat.span, var_id).decl_ty;\n-                    self.demand_eqtype_pat(pat.span, vt, local_ty, discrim_span);\n-                }\n-\n-                if let Some(ref p) = *sub {\n-                    self.check_pat_walk(&p, expected, def_bm, discrim_span);\n-                }\n-\n-                local_ty\n-            }\n-            PatKind::TupleStruct(ref qpath, ref subpats, ddpos) => {\n-                self.check_pat_tuple_struct(\n-                    pat,\n-                    qpath,\n-                    &subpats,\n-                    ddpos,\n-                    expected,\n-                    def_bm,\n-                    discrim_span,\n-                )\n-            }\n-            PatKind::Path(ref qpath) => {\n-                self.check_pat_path(pat, path_resolution.unwrap(), qpath, expected)\n-            }\n-            PatKind::Struct(ref qpath, ref fields, etc) => {\n-                self.check_pat_struct(pat, qpath, fields, etc, expected, def_bm, discrim_span)\n-            }\n-            PatKind::Or(ref pats) => {\n-                let expected_ty = self.structurally_resolved_type(pat.span, expected);\n-                for pat in pats {\n-                    self.check_pat_walk(pat, expected, def_bm, discrim_span);\n-                }\n-                expected_ty\n-            }\n-            PatKind::Tuple(ref elements, ddpos) => {\n-                let mut expected_len = elements.len();\n-                if ddpos.is_some() {\n-                    // Require known type only when `..` is present.\n-                    if let ty::Tuple(ref tys) =\n-                            self.structurally_resolved_type(pat.span, expected).sty {\n-                        expected_len = tys.len();\n-                    }\n-                }\n-                let max_len = cmp::max(expected_len, elements.len());\n-\n-                let element_tys_iter = (0..max_len).map(|_| {\n-                    Kind::from(self.next_ty_var(\n-                        // FIXME: `MiscVariable` for now -- obtaining the span and name information\n-                        // from all tuple elements isn't trivial.\n-                        TypeVariableOrigin {\n-                            kind: TypeVariableOriginKind::TypeInference,\n-                            span: pat.span,\n-                        },\n-                    ))\n-                });\n-                let element_tys = tcx.mk_substs(element_tys_iter);\n-                let pat_ty = tcx.mk_ty(ty::Tuple(element_tys));\n-                if let Some(mut err) = self.demand_eqtype_diag(pat.span, expected, pat_ty) {\n-                    err.emit();\n-                    // Walk subpatterns with an expected type of `err` in this case to silence\n-                    // further errors being emitted when using the bindings. #50333\n-                    let element_tys_iter = (0..max_len).map(|_| tcx.types.err);\n-                    for (_, elem) in elements.iter().enumerate_and_adjust(max_len, ddpos) {\n-                        self.check_pat_walk(elem, &tcx.types.err, def_bm, discrim_span);\n-                    }\n-                    tcx.mk_tup(element_tys_iter)\n-                } else {\n-                    for (i, elem) in elements.iter().enumerate_and_adjust(max_len, ddpos) {\n-                        self.check_pat_walk(\n-                            elem,\n-                            &element_tys[i].expect_ty(),\n-                            def_bm,\n-                            discrim_span,\n-                        );\n-                    }\n-                    pat_ty\n-                }\n-            }\n-            PatKind::Box(ref inner) => {\n-                let inner_ty = self.next_ty_var(TypeVariableOrigin {\n-                    kind: TypeVariableOriginKind::TypeInference,\n-                    span: inner.span,\n-                });\n-                let uniq_ty = tcx.mk_box(inner_ty);\n-\n-                if self.check_dereferencable(pat.span, expected, &inner) {\n-                    // Here, `demand::subtype` is good enough, but I don't\n-                    // think any errors can be introduced by using\n-                    // `demand::eqtype`.\n-                    self.demand_eqtype_pat(pat.span, expected, uniq_ty, discrim_span);\n-                    self.check_pat_walk(&inner, inner_ty, def_bm, discrim_span);\n-                    uniq_ty\n-                } else {\n-                    self.check_pat_walk(&inner, tcx.types.err, def_bm, discrim_span);\n-                    tcx.types.err\n-                }\n-            }\n-            PatKind::Ref(ref inner, mutbl) => {\n-                let expected = self.shallow_resolve(expected);\n-                if self.check_dereferencable(pat.span, expected, &inner) {\n-                    // `demand::subtype` would be good enough, but using\n-                    // `eqtype` turns out to be equally general. See (*)\n-                    // below for details.\n-\n-                    // Take region, inner-type from expected type if we\n-                    // can, to avoid creating needless variables.  This\n-                    // also helps with the bad interactions of the given\n-                    // hack detailed in (*) below.\n-                    debug!(\"check_pat_walk: expected={:?}\", expected);\n-                    let (rptr_ty, inner_ty) = match expected.sty {\n-                        ty::Ref(_, r_ty, r_mutbl) if r_mutbl == mutbl => {\n-                            (expected, r_ty)\n-                        }\n-                        _ => {\n-                            let inner_ty = self.next_ty_var(\n-                                TypeVariableOrigin {\n-                                    kind: TypeVariableOriginKind::TypeInference,\n-                                    span: inner.span,\n-                                }\n-                            );\n-                            let mt = ty::TypeAndMut { ty: inner_ty, mutbl: mutbl };\n-                            let region = self.next_region_var(infer::PatternRegion(pat.span));\n-                            let rptr_ty = tcx.mk_ref(region, mt);\n-                            debug!(\"check_pat_walk: demanding {:?} = {:?}\", expected, rptr_ty);\n-                            let err = self.demand_eqtype_diag(pat.span, expected, rptr_ty);\n-\n-                            // Look for a case like `fn foo(&foo: u32)` and suggest\n-                            // `fn foo(foo: &u32)`\n-                            if let Some(mut err) = err {\n-                                self.borrow_pat_suggestion(&mut err, &pat, &inner, &expected);\n-                                err.emit();\n-                            }\n-                            (rptr_ty, inner_ty)\n-                        }\n-                    };\n-\n-                    self.check_pat_walk(&inner, inner_ty, def_bm, discrim_span);\n-                    rptr_ty\n-                } else {\n-                    self.check_pat_walk(&inner, tcx.types.err, def_bm, discrim_span);\n-                    tcx.types.err\n-                }\n-            }\n-            PatKind::Slice(ref before, ref slice, ref after) => {\n-                let expected_ty = self.structurally_resolved_type(pat.span, expected);\n-                let (inner_ty, slice_ty) = match expected_ty.sty {\n-                    ty::Array(inner_ty, size) => {\n-                        if let Some(size) = size.try_eval_usize(tcx, self.param_env) {\n-                            let min_len = before.len() as u64 + after.len() as u64;\n-                            if slice.is_none() {\n-                                if min_len != size {\n-                                    struct_span_err!(\n-                                        tcx.sess, pat.span, E0527,\n-                                        \"pattern requires {} elements but array has {}\",\n-                                        min_len, size)\n-                                        .span_label(pat.span, format!(\"expected {} elements\", size))\n-                                        .emit();\n-                                }\n-                                (inner_ty, tcx.types.err)\n-                            } else if let Some(rest) = size.checked_sub(min_len) {\n-                                (inner_ty, tcx.mk_array(inner_ty, rest))\n-                            } else {\n-                                struct_span_err!(tcx.sess, pat.span, E0528,\n-                                        \"pattern requires at least {} elements but array has {}\",\n-                                        min_len, size)\n-                                    .span_label(pat.span,\n-                                        format!(\"pattern cannot match array of {} elements\", size))\n-                                    .emit();\n-                                (inner_ty, tcx.types.err)\n-                            }\n-                        } else {\n-                            struct_span_err!(\n-                                tcx.sess,\n-                                pat.span,\n-                                E0730,\n-                                \"cannot pattern-match on an array without a fixed length\",\n-                            ).emit();\n-                            (inner_ty, tcx.types.err)\n-                        }\n-                    }\n-                    ty::Slice(inner_ty) => (inner_ty, expected_ty),\n-                    _ => {\n-                        if !expected_ty.references_error() {\n-                            let mut err = struct_span_err!(\n-                                tcx.sess, pat.span, E0529,\n-                                \"expected an array or slice, found `{}`\",\n-                                expected_ty);\n-                            if let ty::Ref(_, ty, _) = expected_ty.sty {\n-                                match ty.sty {\n-                                    ty::Array(..) | ty::Slice(..) => {\n-                                        err.help(\"the semantics of slice patterns changed \\\n-                                                  recently; see issue #62254\");\n-                                    }\n-                                    _ => {}\n-                                }\n-                            }\n-\n-                            err.span_label( pat.span,\n-                                format!(\"pattern cannot match with input type `{}`\", expected_ty)\n-                            ).emit();\n-                        }\n-                        (tcx.types.err, tcx.types.err)\n-                    }\n-                };\n-\n-                for elt in before {\n-                    self.check_pat_walk(&elt, inner_ty, def_bm, discrim_span);\n-                }\n-                if let Some(ref slice) = *slice {\n-                    self.check_pat_walk(&slice, slice_ty, def_bm, discrim_span);\n-                }\n-                for elt in after {\n-                    self.check_pat_walk(&elt, inner_ty, def_bm, discrim_span);\n-                }\n-                expected_ty\n-            }\n-        };\n-\n-        self.write_ty(pat.hir_id, ty);\n-\n-        // (*) In most of the cases above (literals and constants being\n-        // the exception), we relate types using strict equality, even\n-        // though subtyping would be sufficient. There are a few reasons\n-        // for this, some of which are fairly subtle and which cost me\n-        // (nmatsakis) an hour or two debugging to remember, so I thought\n-        // I'd write them down this time.\n-        //\n-        // 1. There is no loss of expressiveness here, though it does\n-        // cause some inconvenience. What we are saying is that the type\n-        // of `x` becomes *exactly* what is expected. This can cause unnecessary\n-        // errors in some cases, such as this one:\n-        //\n-        // ```\n-        // fn foo<'x>(x: &'x int) {\n-        //    let a = 1;\n-        //    let mut z = x;\n-        //    z = &a;\n-        // }\n-        // ```\n-        //\n-        // The reason we might get an error is that `z` might be\n-        // assigned a type like `&'x int`, and then we would have\n-        // a problem when we try to assign `&a` to `z`, because\n-        // the lifetime of `&a` (i.e., the enclosing block) is\n-        // shorter than `'x`.\n-        //\n-        // HOWEVER, this code works fine. The reason is that the\n-        // expected type here is whatever type the user wrote, not\n-        // the initializer's type. In this case the user wrote\n-        // nothing, so we are going to create a type variable `Z`.\n-        // Then we will assign the type of the initializer (`&'x\n-        // int`) as a subtype of `Z`: `&'x int <: Z`. And hence we\n-        // will instantiate `Z` as a type `&'0 int` where `'0` is\n-        // a fresh region variable, with the constraint that `'x :\n-        // '0`.  So basically we're all set.\n-        //\n-        // Note that there are two tests to check that this remains true\n-        // (`regions-reassign-{match,let}-bound-pointer.rs`).\n-        //\n-        // 2. Things go horribly wrong if we use subtype. The reason for\n-        // THIS is a fairly subtle case involving bound regions. See the\n-        // `givens` field in `region_constraints`, as well as the test\n-        // `regions-relate-bound-regions-on-closures-to-inference-variables.rs`,\n-        // for details. Short version is that we must sometimes detect\n-        // relationships between specific region variables and regions\n-        // bound in a closure signature, and that detection gets thrown\n-        // off when we substitute fresh region variables here to enable\n-        // subtyping.\n-    }\n-\n-    fn borrow_pat_suggestion(\n-        &self,\n-        err: &mut DiagnosticBuilder<'_>,\n-        pat: &Pat,\n-        inner: &Pat,\n-        expected: Ty<'tcx>,\n-    ) {\n-        let tcx = self.tcx;\n-        if let PatKind::Binding(..) = inner.node {\n-            let binding_parent_id = tcx.hir().get_parent_node(pat.hir_id);\n-            let binding_parent = tcx.hir().get(binding_parent_id);\n-            debug!(\"inner {:?} pat {:?} parent {:?}\", inner, pat, binding_parent);\n-            match binding_parent {\n-                hir::Node::Arg(hir::Arg { span, .. }) => {\n-                    if let Ok(snippet) = tcx.sess.source_map().span_to_snippet(inner.span) {\n-                        err.span_suggestion(\n-                            *span,\n-                            &format!(\"did you mean `{}`\", snippet),\n-                            format!(\" &{}\", expected),\n-                            Applicability::MachineApplicable,\n-                        );\n-                    }\n-                }\n-                hir::Node::Arm(_) |\n-                hir::Node::Pat(_) => {\n-                    // rely on match ergonomics or it might be nested `&&pat`\n-                    if let Ok(snippet) = tcx.sess.source_map().span_to_snippet(inner.span) {\n-                        err.span_suggestion(\n-                            pat.span,\n-                            \"you can probably remove the explicit borrow\",\n-                            snippet,\n-                            Applicability::MaybeIncorrect,\n-                        );\n-                    }\n-                }\n-                _ => {} // don't provide suggestions in other cases #55175\n-            }\n-        }\n-    }\n-\n-    pub fn check_dereferencable(&self, span: Span, expected: Ty<'tcx>, inner: &hir::Pat) -> bool {\n-        if let PatKind::Binding(..) = inner.node {\n-            if let Some(mt) = self.shallow_resolve(expected).builtin_deref(true) {\n-                if let ty::Dynamic(..) = mt.ty.sty {\n-                    // This is \"x = SomeTrait\" being reduced from\n-                    // \"let &x = &SomeTrait\" or \"let box x = Box<SomeTrait>\", an error.\n-                    let type_str = self.ty_to_string(expected);\n-                    let mut err = struct_span_err!(\n-                        self.tcx.sess,\n-                        span,\n-                        E0033,\n-                        \"type `{}` cannot be dereferenced\",\n-                        type_str\n-                    );\n-                    err.span_label(span, format!(\"type `{}` cannot be dereferenced\", type_str));\n-                    if self.tcx.sess.teach(&err.get_code().unwrap()) {\n-                        err.note(\"\\\n-This error indicates that a pointer to a trait type cannot be implicitly dereferenced by a \\\n-pattern. Every trait defines a type, but because the size of trait implementors isn't fixed, \\\n-this type has no compile-time size. Therefore, all accesses to trait types must be through \\\n-pointers. If you encounter this error you should try to avoid dereferencing the pointer.\n-\n-You can read more about trait objects in the Trait Objects section of the Reference: \\\n-https://doc.rust-lang.org/reference/types.html#trait-objects\");\n-                    }\n-                    err.emit();\n-                    return false\n-                }\n-            }\n-        }\n-        true\n-    }\n-\n     pub fn check_match(\n         &self,\n         expr: &'tcx hir::Expr,\n@@ -1038,346 +419,4 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n             discrim_ty\n         }\n     }\n-\n-    fn check_pat_struct(\n-        &self,\n-        pat: &'tcx hir::Pat,\n-        qpath: &hir::QPath,\n-        fields: &'tcx [hir::FieldPat],\n-        etc: bool,\n-        expected: Ty<'tcx>,\n-        def_bm: ty::BindingMode,\n-        discrim_span: Option<Span>,\n-    ) -> Ty<'tcx> {\n-        // Resolve the path and check the definition for errors.\n-        let (variant, pat_ty) = if let Some(variant_ty) = self.check_struct_path(qpath, pat.hir_id)\n-        {\n-            variant_ty\n-        } else {\n-            for field in fields {\n-                self.check_pat_walk(&field.pat, self.tcx.types.err, def_bm, discrim_span);\n-            }\n-            return self.tcx.types.err;\n-        };\n-\n-        // Type-check the path.\n-        self.demand_eqtype_pat(pat.span, expected, pat_ty, discrim_span);\n-\n-        // Type-check subpatterns.\n-        if self.check_struct_pat_fields(pat_ty, pat.hir_id, pat.span, variant, fields, etc, def_bm)\n-        {\n-            pat_ty\n-        } else {\n-            self.tcx.types.err\n-        }\n-    }\n-\n-    fn check_pat_path(\n-        &self,\n-        pat: &hir::Pat,\n-        path_resolution: (Res, Option<Ty<'tcx>>, &'b [hir::PathSegment]),\n-        qpath: &hir::QPath,\n-        expected: Ty<'tcx>,\n-    ) -> Ty<'tcx> {\n-        let tcx = self.tcx;\n-\n-        // We have already resolved the path.\n-        let (res, opt_ty, segments) = path_resolution;\n-        match res {\n-            Res::Err => {\n-                self.set_tainted_by_errors();\n-                return tcx.types.err;\n-            }\n-            Res::Def(DefKind::Method, _) |\n-            Res::Def(DefKind::Ctor(_, CtorKind::Fictive), _) |\n-            Res::Def(DefKind::Ctor(_, CtorKind::Fn), _) => {\n-                report_unexpected_variant_res(tcx, res, pat.span, qpath);\n-                return tcx.types.err;\n-            }\n-            Res::Def(DefKind::Ctor(_, CtorKind::Const), _) | Res::SelfCtor(..) |\n-            Res::Def(DefKind::Const, _) | Res::Def(DefKind::AssocConst, _) => {} // OK\n-            _ => bug!(\"unexpected pattern resolution: {:?}\", res)\n-        }\n-\n-        // Type-check the path.\n-        let pat_ty = self.instantiate_value_path(segments, opt_ty, res, pat.span, pat.hir_id).0;\n-        self.demand_suptype(pat.span, expected, pat_ty);\n-        pat_ty\n-    }\n-\n-    fn check_pat_tuple_struct(\n-        &self,\n-        pat: &hir::Pat,\n-        qpath: &hir::QPath,\n-        subpats: &'tcx [P<hir::Pat>],\n-        ddpos: Option<usize>,\n-        expected: Ty<'tcx>,\n-        def_bm: ty::BindingMode,\n-        match_arm_pat_span: Option<Span>,\n-    ) -> Ty<'tcx> {\n-        let tcx = self.tcx;\n-        let on_error = || {\n-            for pat in subpats {\n-                self.check_pat_walk(&pat, tcx.types.err, def_bm, match_arm_pat_span);\n-            }\n-        };\n-        let report_unexpected_res = |res: Res| {\n-            let msg = format!(\"expected tuple struct/variant, found {} `{}`\",\n-                              res.descr(),\n-                              hir::print::to_string(tcx.hir(), |s| s.print_qpath(qpath, false)));\n-            let mut err = struct_span_err!(tcx.sess, pat.span, E0164, \"{}\", msg);\n-            match (res, &pat.node) {\n-                (Res::Def(DefKind::Fn, _), _) | (Res::Def(DefKind::Method, _), _) => {\n-                    err.span_label(pat.span, \"`fn` calls are not allowed in patterns\");\n-                    err.help(\"for more information, visit \\\n-                              https://doc.rust-lang.org/book/ch18-00-patterns.html\");\n-                }\n-                _ => {\n-                    err.span_label(pat.span, \"not a tuple variant or struct\");\n-                }\n-            }\n-            err.emit();\n-            on_error();\n-        };\n-\n-        // Resolve the path and check the definition for errors.\n-        let (res, opt_ty, segments) = self.resolve_ty_and_res_ufcs(qpath, pat.hir_id, pat.span);\n-        if res == Res::Err {\n-            self.set_tainted_by_errors();\n-            on_error();\n-            return self.tcx.types.err;\n-        }\n-\n-        // Type-check the path.\n-        let (pat_ty, res) = self.instantiate_value_path(segments, opt_ty, res, pat.span,\n-            pat.hir_id);\n-        if !pat_ty.is_fn() {\n-            report_unexpected_res(res);\n-            return self.tcx.types.err;\n-        }\n-\n-        let variant = match res {\n-            Res::Err => {\n-                self.set_tainted_by_errors();\n-                on_error();\n-                return tcx.types.err;\n-            }\n-            Res::Def(DefKind::AssocConst, _) | Res::Def(DefKind::Method, _) => {\n-                report_unexpected_res(res);\n-                return tcx.types.err;\n-            }\n-            Res::Def(DefKind::Ctor(_, CtorKind::Fn), _) => {\n-                tcx.expect_variant_res(res)\n-            }\n-            _ => bug!(\"unexpected pattern resolution: {:?}\", res)\n-        };\n-\n-        // Replace constructor type with constructed type for tuple struct patterns.\n-        let pat_ty = pat_ty.fn_sig(tcx).output();\n-        let pat_ty = pat_ty.no_bound_vars().expect(\"expected fn type\");\n-\n-        self.demand_eqtype_pat(pat.span, expected, pat_ty, match_arm_pat_span);\n-\n-        // Type-check subpatterns.\n-        if subpats.len() == variant.fields.len() ||\n-                subpats.len() < variant.fields.len() && ddpos.is_some() {\n-            let substs = match pat_ty.sty {\n-                ty::Adt(_, substs) => substs,\n-                _ => bug!(\"unexpected pattern type {:?}\", pat_ty),\n-            };\n-            for (i, subpat) in subpats.iter().enumerate_and_adjust(variant.fields.len(), ddpos) {\n-                let field_ty = self.field_ty(subpat.span, &variant.fields[i], substs);\n-                self.check_pat_walk(&subpat, field_ty, def_bm, match_arm_pat_span);\n-\n-                self.tcx.check_stability(variant.fields[i].did, Some(pat.hir_id), subpat.span);\n-            }\n-        } else {\n-            let subpats_ending = if subpats.len() == 1 { \"\" } else { \"s\" };\n-            let fields_ending = if variant.fields.len() == 1 { \"\" } else { \"s\" };\n-            struct_span_err!(tcx.sess, pat.span, E0023,\n-                             \"this pattern has {} field{}, but the corresponding {} has {} field{}\",\n-                             subpats.len(), subpats_ending, res.descr(),\n-                             variant.fields.len(),  fields_ending)\n-                .span_label(pat.span, format!(\"expected {} field{}, found {}\",\n-                                              variant.fields.len(), fields_ending, subpats.len()))\n-                .emit();\n-            on_error();\n-            return tcx.types.err;\n-        }\n-        pat_ty\n-    }\n-\n-    fn check_struct_pat_fields(\n-        &self,\n-        adt_ty: Ty<'tcx>,\n-        pat_id: hir::HirId,\n-        span: Span,\n-        variant: &'tcx ty::VariantDef,\n-        fields: &'tcx [hir::FieldPat],\n-        etc: bool,\n-        def_bm: ty::BindingMode,\n-    ) -> bool {\n-        let tcx = self.tcx;\n-\n-        let (substs, adt) = match adt_ty.sty {\n-            ty::Adt(adt, substs) => (substs, adt),\n-            _ => span_bug!(span, \"struct pattern is not an ADT\")\n-        };\n-        let kind_name = adt.variant_descr();\n-\n-        // Index the struct fields' types.\n-        let field_map = variant.fields\n-            .iter()\n-            .enumerate()\n-            .map(|(i, field)| (field.ident.modern(), (i, field)))\n-            .collect::<FxHashMap<_, _>>();\n-\n-        // Keep track of which fields have already appeared in the pattern.\n-        let mut used_fields = FxHashMap::default();\n-        let mut no_field_errors = true;\n-\n-        let mut inexistent_fields = vec![];\n-        // Typecheck each field.\n-        for field in fields {\n-            let span = field.span;\n-            let ident = tcx.adjust_ident(field.ident, variant.def_id);\n-            let field_ty = match used_fields.entry(ident) {\n-                Occupied(occupied) => {\n-                    struct_span_err!(tcx.sess, span, E0025,\n-                                     \"field `{}` bound multiple times \\\n-                                      in the pattern\",\n-                                     field.ident)\n-                        .span_label(span,\n-                                    format!(\"multiple uses of `{}` in pattern\", field.ident))\n-                        .span_label(*occupied.get(), format!(\"first use of `{}`\", field.ident))\n-                        .emit();\n-                    no_field_errors = false;\n-                    tcx.types.err\n-                }\n-                Vacant(vacant) => {\n-                    vacant.insert(span);\n-                    field_map.get(&ident)\n-                        .map(|(i, f)| {\n-                            self.write_field_index(field.hir_id, *i);\n-                            self.tcx.check_stability(f.did, Some(pat_id), span);\n-                            self.field_ty(span, f, substs)\n-                        })\n-                        .unwrap_or_else(|| {\n-                            inexistent_fields.push(field.ident);\n-                            no_field_errors = false;\n-                            tcx.types.err\n-                        })\n-                }\n-            };\n-\n-            self.check_pat_walk(&field.pat, field_ty, def_bm, None);\n-        }\n-        let mut unmentioned_fields = variant.fields\n-                .iter()\n-                .map(|field| field.ident.modern())\n-                .filter(|ident| !used_fields.contains_key(&ident))\n-                .collect::<Vec<_>>();\n-        if inexistent_fields.len() > 0 && !variant.recovered {\n-            let (field_names, t, plural) = if inexistent_fields.len() == 1 {\n-                (format!(\"a field named `{}`\", inexistent_fields[0]), \"this\", \"\")\n-            } else {\n-                (format!(\"fields named {}\",\n-                         inexistent_fields.iter()\n-                            .map(|ident| format!(\"`{}`\", ident))\n-                            .collect::<Vec<String>>()\n-                            .join(\", \")), \"these\", \"s\")\n-            };\n-            let spans = inexistent_fields.iter().map(|ident| ident.span).collect::<Vec<_>>();\n-            let mut err = struct_span_err!(tcx.sess,\n-                                           spans,\n-                                           E0026,\n-                                           \"{} `{}` does not have {}\",\n-                                           kind_name,\n-                                           tcx.def_path_str(variant.def_id),\n-                                           field_names);\n-            if let Some(ident) = inexistent_fields.last() {\n-                err.span_label(ident.span,\n-                               format!(\"{} `{}` does not have {} field{}\",\n-                                       kind_name,\n-                                       tcx.def_path_str(variant.def_id),\n-                                       t,\n-                                       plural));\n-                if plural == \"\" {\n-                    let input = unmentioned_fields.iter().map(|field| &field.name);\n-                    let suggested_name =\n-                        find_best_match_for_name(input, &ident.as_str(), None);\n-                    if let Some(suggested_name) = suggested_name {\n-                        err.span_suggestion(\n-                            ident.span,\n-                            \"a field with a similar name exists\",\n-                            suggested_name.to_string(),\n-                            Applicability::MaybeIncorrect,\n-                        );\n-\n-                        // we don't want to throw `E0027` in case we have thrown `E0026` for them\n-                        unmentioned_fields.retain(|&x| x.as_str() != suggested_name.as_str());\n-                    }\n-                }\n-            }\n-            if tcx.sess.teach(&err.get_code().unwrap()) {\n-                err.note(\n-                    \"This error indicates that a struct pattern attempted to \\\n-                     extract a non-existent field from a struct. Struct fields \\\n-                     are identified by the name used before the colon : so struct \\\n-                     patterns should resemble the declaration of the struct type \\\n-                     being matched.\\n\\n\\\n-                     If you are using shorthand field patterns but want to refer \\\n-                     to the struct field by a different name, you should rename \\\n-                     it explicitly.\"\n-                );\n-            }\n-            err.emit();\n-        }\n-\n-        // Require `..` if struct has non_exhaustive attribute.\n-        if variant.is_field_list_non_exhaustive() && !adt.did.is_local() && !etc {\n-            span_err!(tcx.sess, span, E0638,\n-                      \"`..` required with {} marked as non-exhaustive\",\n-                      kind_name);\n-        }\n-\n-        // Report an error if incorrect number of the fields were specified.\n-        if kind_name == \"union\" {\n-            if fields.len() != 1 {\n-                tcx.sess.span_err(span, \"union patterns should have exactly one field\");\n-            }\n-            if etc {\n-                tcx.sess.span_err(span, \"`..` cannot be used in union patterns\");\n-            }\n-        } else if !etc {\n-            if unmentioned_fields.len() > 0 {\n-                let field_names = if unmentioned_fields.len() == 1 {\n-                    format!(\"field `{}`\", unmentioned_fields[0])\n-                } else {\n-                    format!(\"fields {}\",\n-                            unmentioned_fields.iter()\n-                                .map(|name| format!(\"`{}`\", name))\n-                                .collect::<Vec<String>>()\n-                                .join(\", \"))\n-                };\n-                let mut diag = struct_span_err!(tcx.sess, span, E0027,\n-                                                \"pattern does not mention {}\",\n-                                                field_names);\n-                diag.span_label(span, format!(\"missing {}\", field_names));\n-                if variant.ctor_kind == CtorKind::Fn {\n-                    diag.note(\"trying to match a tuple variant with a struct variant pattern\");\n-                }\n-                if tcx.sess.teach(&diag.get_code().unwrap()) {\n-                    diag.note(\n-                        \"This error indicates that a pattern for a struct fails to specify a \\\n-                         sub-pattern for every one of the struct's fields. Ensure that each field \\\n-                         from the struct's definition is mentioned in the pattern, or use `..` to \\\n-                         ignore unwanted fields.\"\n-                    );\n-                }\n-                diag.emit();\n-            }\n-        }\n-        no_field_errors\n-    }\n }"}, {"sha": "a130d11a5e64518651f3dfc54eea943c2c5151a5", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/11d40910cdc501b22e503cfe1054a7f21478785e/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11d40910cdc501b22e503cfe1054a7f21478785e/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=11d40910cdc501b22e503cfe1054a7f21478785e", "patch": "@@ -70,6 +70,7 @@ type parameter).\n mod autoderef;\n pub mod dropck;\n pub mod _match;\n+mod pat;\n pub mod writeback;\n mod regionck;\n pub mod coercion;"}, {"sha": "e2d0f485bdf01b06aa8ff2bfd076078860750557", "filename": "src/librustc_typeck/check/pat.rs", "status": "added", "additions": 968, "deletions": 0, "changes": 968, "blob_url": "https://github.com/rust-lang/rust/blob/11d40910cdc501b22e503cfe1054a7f21478785e/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11d40910cdc501b22e503cfe1054a7f21478785e/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs?ref=11d40910cdc501b22e503cfe1054a7f21478785e", "patch": "@@ -0,0 +1,968 @@\n+use crate::check::FnCtxt;\n+use crate::util::nodemap::FxHashMap;\n+use errors::{Applicability, DiagnosticBuilder};\n+use rustc::hir::{self, PatKind, Pat};\n+use rustc::hir::def::{Res, DefKind, CtorKind};\n+use rustc::hir::pat_util::EnumerateAndAdjustIterator;\n+use rustc::hir::ptr::P;\n+use rustc::infer;\n+use rustc::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n+use rustc::ty::{self, Ty, TypeFoldable};\n+use rustc::ty::subst::Kind;\n+use syntax::ast;\n+use syntax::util::lev_distance::find_best_match_for_name;\n+use syntax_pos::Span;\n+use syntax_pos::hygiene::DesugaringKind;\n+\n+use std::collections::hash_map::Entry::{Occupied, Vacant};\n+use std::cmp;\n+\n+use super::report_unexpected_variant_res;\n+\n+impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n+    /// `discrim_span` argument having a `Span` indicates that this pattern is part of a match\n+    /// expression arm guard, and it points to the match discriminant to add context in type errors.\n+    /// In the following example, `discrim_span` corresponds to the `a + b` expression:\n+    ///\n+    /// ```text\n+    /// error[E0308]: mismatched types\n+    ///  --> src/main.rs:5:9\n+    ///   |\n+    /// 4 |    let temp: usize = match a + b {\n+    ///   |                            ----- this expression has type `usize`\n+    /// 5 |         Ok(num) => num,\n+    ///   |         ^^^^^^^ expected usize, found enum `std::result::Result`\n+    ///   |\n+    ///   = note: expected type `usize`\n+    ///              found type `std::result::Result<_, _>`\n+    /// ```\n+    pub fn check_pat_walk(\n+        &self,\n+        pat: &'tcx hir::Pat,\n+        mut expected: Ty<'tcx>,\n+        mut def_bm: ty::BindingMode,\n+        discrim_span: Option<Span>,\n+    ) {\n+        let tcx = self.tcx;\n+\n+        debug!(\"check_pat_walk(pat={:?},expected={:?},def_bm={:?})\", pat, expected, def_bm);\n+\n+        let mut path_resolution = None;\n+        let is_non_ref_pat = match pat.node {\n+            PatKind::Struct(..) |\n+            PatKind::TupleStruct(..) |\n+            PatKind::Or(_) |\n+            PatKind::Tuple(..) |\n+            PatKind::Box(_) |\n+            PatKind::Range(..) |\n+            PatKind::Slice(..) => true,\n+            PatKind::Lit(ref lt) => {\n+                let ty = self.check_expr(lt);\n+                match ty.sty {\n+                    ty::Ref(..) => false,\n+                    _ => true,\n+                }\n+            }\n+            PatKind::Path(ref qpath) => {\n+                let resolution = self.resolve_ty_and_res_ufcs(qpath, pat.hir_id, pat.span);\n+                path_resolution = Some(resolution);\n+                match resolution.0 {\n+                    Res::Def(DefKind::Const, _) | Res::Def(DefKind::AssocConst, _) => false,\n+                    _ => true,\n+                }\n+            }\n+            PatKind::Wild |\n+            PatKind::Binding(..) |\n+            PatKind::Ref(..) => false,\n+        };\n+        if is_non_ref_pat {\n+            debug!(\"pattern is non reference pattern\");\n+            let mut exp_ty = self.resolve_type_vars_with_obligations(&expected);\n+\n+            // Peel off as many `&` or `&mut` from the discriminant as possible. For example,\n+            // for `match &&&mut Some(5)` the loop runs three times, aborting when it reaches\n+            // the `Some(5)` which is not of type Ref.\n+            //\n+            // For each ampersand peeled off, update the binding mode and push the original\n+            // type into the adjustments vector.\n+            //\n+            // See the examples in `ui/match-defbm*.rs`.\n+            let mut pat_adjustments = vec![];\n+            while let ty::Ref(_, inner_ty, inner_mutability) = exp_ty.sty {\n+                debug!(\"inspecting {:?}\", exp_ty);\n+\n+                debug!(\"current discriminant is Ref, inserting implicit deref\");\n+                // Preserve the reference type. We'll need it later during HAIR lowering.\n+                pat_adjustments.push(exp_ty);\n+\n+                exp_ty = inner_ty;\n+                def_bm = match def_bm {\n+                    // If default binding mode is by value, make it `ref` or `ref mut`\n+                    // (depending on whether we observe `&` or `&mut`).\n+                    ty::BindByValue(_) =>\n+                        ty::BindByReference(inner_mutability),\n+\n+                    // Once a `ref`, always a `ref`. This is because a `& &mut` can't mutate\n+                    // the underlying value.\n+                    ty::BindByReference(hir::Mutability::MutImmutable) =>\n+                        ty::BindByReference(hir::Mutability::MutImmutable),\n+\n+                    // When `ref mut`, stay a `ref mut` (on `&mut`) or downgrade to `ref`\n+                    // (on `&`).\n+                    ty::BindByReference(hir::Mutability::MutMutable) =>\n+                        ty::BindByReference(inner_mutability),\n+                };\n+            }\n+            expected = exp_ty;\n+\n+            if pat_adjustments.len() > 0 {\n+                debug!(\"default binding mode is now {:?}\", def_bm);\n+                self.inh.tables.borrow_mut()\n+                    .pat_adjustments_mut()\n+                    .insert(pat.hir_id, pat_adjustments);\n+            }\n+        } else if let PatKind::Ref(..) = pat.node {\n+            // When you encounter a `&pat` pattern, reset to \"by\n+            // value\". This is so that `x` and `y` here are by value,\n+            // as they appear to be:\n+            //\n+            // ```\n+            // match &(&22, &44) {\n+            //   (&x, &y) => ...\n+            // }\n+            // ```\n+            //\n+            // See issue #46688.\n+            def_bm = ty::BindByValue(hir::MutImmutable);\n+        }\n+\n+        // Lose mutability now that we know binding mode and discriminant type.\n+        let def_bm = def_bm;\n+        let expected = expected;\n+\n+        let ty = match pat.node {\n+            PatKind::Wild => {\n+                expected\n+            }\n+            PatKind::Lit(ref lt) => {\n+                // We've already computed the type above (when checking for a non-ref pat), so\n+                // avoid computing it again.\n+                let ty = self.node_ty(lt.hir_id);\n+\n+                // Byte string patterns behave the same way as array patterns\n+                // They can denote both statically and dynamically-sized byte arrays.\n+                let mut pat_ty = ty;\n+                if let hir::ExprKind::Lit(ref lt) = lt.node {\n+                    if let ast::LitKind::ByteStr(_) = lt.node {\n+                        let expected_ty = self.structurally_resolved_type(pat.span, expected);\n+                        if let ty::Ref(_, r_ty, _) = expected_ty.sty {\n+                            if let ty::Slice(_) = r_ty.sty {\n+                                pat_ty = tcx.mk_imm_ref(tcx.lifetimes.re_static,\n+                                                        tcx.mk_slice(tcx.types.u8))\n+                            }\n+                        }\n+                    }\n+                }\n+\n+                // Somewhat surprising: in this case, the subtyping\n+                // relation goes the opposite way as the other\n+                // cases. Actually what we really want is not a subtyping\n+                // relation at all but rather that there exists a LUB (so\n+                // that they can be compared). However, in practice,\n+                // constants are always scalars or strings.  For scalars\n+                // subtyping is irrelevant, and for strings `ty` is\n+                // type is `&'static str`, so if we say that\n+                //\n+                //     &'static str <: expected\n+                //\n+                // then that's equivalent to there existing a LUB.\n+                if let Some(mut err) = self.demand_suptype_diag(pat.span, expected, pat_ty) {\n+                    err.emit_unless(discrim_span\n+                        .filter(|&s| {\n+                            // In the case of `if`- and `while`-expressions we've already checked\n+                            // that `scrutinee: bool`. We know that the pattern is `true`,\n+                            // so an error here would be a duplicate and from the wrong POV.\n+                            s.is_desugaring(DesugaringKind::CondTemporary)\n+                        })\n+                        .is_some());\n+                }\n+\n+                pat_ty\n+            }\n+            PatKind::Range(ref begin, ref end, _) => {\n+                let lhs_ty = self.check_expr(begin);\n+                let rhs_ty = self.check_expr(end);\n+\n+                // Check that both end-points are of numeric or char type.\n+                let numeric_or_char = |ty: Ty<'_>| {\n+                    ty.is_numeric()\n+                    || ty.is_char()\n+                    || ty.references_error()\n+                };\n+                let lhs_compat = numeric_or_char(lhs_ty);\n+                let rhs_compat = numeric_or_char(rhs_ty);\n+\n+                if !lhs_compat || !rhs_compat {\n+                    let span = if !lhs_compat && !rhs_compat {\n+                        pat.span\n+                    } else if !lhs_compat {\n+                        begin.span\n+                    } else {\n+                        end.span\n+                    };\n+\n+                    let mut err = struct_span_err!(\n+                        tcx.sess,\n+                        span,\n+                        E0029,\n+                        \"only char and numeric types are allowed in range patterns\"\n+                    );\n+                    err.span_label(span, \"ranges require char or numeric types\");\n+                    err.note(&format!(\"start type: {}\", self.ty_to_string(lhs_ty)));\n+                    err.note(&format!(\"end type: {}\", self.ty_to_string(rhs_ty)));\n+                    if tcx.sess.teach(&err.get_code().unwrap()) {\n+                        err.note(\n+                            \"In a match expression, only numbers and characters can be matched \\\n+                             against a range. This is because the compiler checks that the range \\\n+                             is non-empty at compile-time, and is unable to evaluate arbitrary \\\n+                             comparison functions. If you want to capture values of an orderable \\\n+                             type between two end-points, you can use a guard.\"\n+                         );\n+                    }\n+                    err.emit();\n+                    return;\n+                }\n+\n+                // Now that we know the types can be unified we find the unified type and use\n+                // it to type the entire expression.\n+                let common_type = self.resolve_vars_if_possible(&lhs_ty);\n+\n+                // Subtyping doesn't matter here, as the value is some kind of scalar.\n+                self.demand_eqtype_pat(pat.span, expected, lhs_ty, discrim_span);\n+                self.demand_eqtype_pat(pat.span, expected, rhs_ty, discrim_span);\n+                common_type\n+            }\n+            PatKind::Binding(ba, var_id, _, ref sub) => {\n+                let bm = if ba == hir::BindingAnnotation::Unannotated {\n+                    def_bm\n+                } else {\n+                    ty::BindingMode::convert(ba)\n+                };\n+                self.inh\n+                    .tables\n+                    .borrow_mut()\n+                    .pat_binding_modes_mut()\n+                    .insert(pat.hir_id, bm);\n+                debug!(\"check_pat_walk: pat.hir_id={:?} bm={:?}\", pat.hir_id, bm);\n+                let local_ty = self.local_ty(pat.span, pat.hir_id).decl_ty;\n+                match bm {\n+                    ty::BindByReference(mutbl) => {\n+                        // If the binding is like\n+                        //     ref x | ref const x | ref mut x\n+                        // then `x` is assigned a value of type `&M T` where M is the mutability\n+                        // and T is the expected type.\n+                        let region_var = self.next_region_var(infer::PatternRegion(pat.span));\n+                        let mt = ty::TypeAndMut { ty: expected, mutbl: mutbl };\n+                        let region_ty = tcx.mk_ref(region_var, mt);\n+\n+                        // `x` is assigned a value of type `&M T`, hence `&M T <: typeof(x)` is\n+                        // required. However, we use equality, which is stronger. See (*) for\n+                        // an explanation.\n+                        self.demand_eqtype_pat(pat.span, region_ty, local_ty, discrim_span);\n+                    }\n+                    // Otherwise, the type of x is the expected type `T`.\n+                    ty::BindByValue(_) => {\n+                        // As above, `T <: typeof(x)` is required, but we\n+                        // use equality, see (*) below.\n+                        self.demand_eqtype_pat(pat.span, expected, local_ty, discrim_span);\n+                    }\n+                }\n+\n+                // If there are multiple arms, make sure they all agree on\n+                // what the type of the binding `x` ought to be.\n+                if var_id != pat.hir_id {\n+                    let vt = self.local_ty(pat.span, var_id).decl_ty;\n+                    self.demand_eqtype_pat(pat.span, vt, local_ty, discrim_span);\n+                }\n+\n+                if let Some(ref p) = *sub {\n+                    self.check_pat_walk(&p, expected, def_bm, discrim_span);\n+                }\n+\n+                local_ty\n+            }\n+            PatKind::TupleStruct(ref qpath, ref subpats, ddpos) => {\n+                self.check_pat_tuple_struct(\n+                    pat,\n+                    qpath,\n+                    &subpats,\n+                    ddpos,\n+                    expected,\n+                    def_bm,\n+                    discrim_span,\n+                )\n+            }\n+            PatKind::Path(ref qpath) => {\n+                self.check_pat_path(pat, path_resolution.unwrap(), qpath, expected)\n+            }\n+            PatKind::Struct(ref qpath, ref fields, etc) => {\n+                self.check_pat_struct(pat, qpath, fields, etc, expected, def_bm, discrim_span)\n+            }\n+            PatKind::Or(ref pats) => {\n+                let expected_ty = self.structurally_resolved_type(pat.span, expected);\n+                for pat in pats {\n+                    self.check_pat_walk(pat, expected, def_bm, discrim_span);\n+                }\n+                expected_ty\n+            }\n+            PatKind::Tuple(ref elements, ddpos) => {\n+                let mut expected_len = elements.len();\n+                if ddpos.is_some() {\n+                    // Require known type only when `..` is present.\n+                    if let ty::Tuple(ref tys) =\n+                            self.structurally_resolved_type(pat.span, expected).sty {\n+                        expected_len = tys.len();\n+                    }\n+                }\n+                let max_len = cmp::max(expected_len, elements.len());\n+\n+                let element_tys_iter = (0..max_len).map(|_| {\n+                    Kind::from(self.next_ty_var(\n+                        // FIXME: `MiscVariable` for now -- obtaining the span and name information\n+                        // from all tuple elements isn't trivial.\n+                        TypeVariableOrigin {\n+                            kind: TypeVariableOriginKind::TypeInference,\n+                            span: pat.span,\n+                        },\n+                    ))\n+                });\n+                let element_tys = tcx.mk_substs(element_tys_iter);\n+                let pat_ty = tcx.mk_ty(ty::Tuple(element_tys));\n+                if let Some(mut err) = self.demand_eqtype_diag(pat.span, expected, pat_ty) {\n+                    err.emit();\n+                    // Walk subpatterns with an expected type of `err` in this case to silence\n+                    // further errors being emitted when using the bindings. #50333\n+                    let element_tys_iter = (0..max_len).map(|_| tcx.types.err);\n+                    for (_, elem) in elements.iter().enumerate_and_adjust(max_len, ddpos) {\n+                        self.check_pat_walk(elem, &tcx.types.err, def_bm, discrim_span);\n+                    }\n+                    tcx.mk_tup(element_tys_iter)\n+                } else {\n+                    for (i, elem) in elements.iter().enumerate_and_adjust(max_len, ddpos) {\n+                        self.check_pat_walk(\n+                            elem,\n+                            &element_tys[i].expect_ty(),\n+                            def_bm,\n+                            discrim_span,\n+                        );\n+                    }\n+                    pat_ty\n+                }\n+            }\n+            PatKind::Box(ref inner) => {\n+                let inner_ty = self.next_ty_var(TypeVariableOrigin {\n+                    kind: TypeVariableOriginKind::TypeInference,\n+                    span: inner.span,\n+                });\n+                let uniq_ty = tcx.mk_box(inner_ty);\n+\n+                if self.check_dereferencable(pat.span, expected, &inner) {\n+                    // Here, `demand::subtype` is good enough, but I don't\n+                    // think any errors can be introduced by using\n+                    // `demand::eqtype`.\n+                    self.demand_eqtype_pat(pat.span, expected, uniq_ty, discrim_span);\n+                    self.check_pat_walk(&inner, inner_ty, def_bm, discrim_span);\n+                    uniq_ty\n+                } else {\n+                    self.check_pat_walk(&inner, tcx.types.err, def_bm, discrim_span);\n+                    tcx.types.err\n+                }\n+            }\n+            PatKind::Ref(ref inner, mutbl) => {\n+                let expected = self.shallow_resolve(expected);\n+                if self.check_dereferencable(pat.span, expected, &inner) {\n+                    // `demand::subtype` would be good enough, but using\n+                    // `eqtype` turns out to be equally general. See (*)\n+                    // below for details.\n+\n+                    // Take region, inner-type from expected type if we\n+                    // can, to avoid creating needless variables.  This\n+                    // also helps with the bad interactions of the given\n+                    // hack detailed in (*) below.\n+                    debug!(\"check_pat_walk: expected={:?}\", expected);\n+                    let (rptr_ty, inner_ty) = match expected.sty {\n+                        ty::Ref(_, r_ty, r_mutbl) if r_mutbl == mutbl => {\n+                            (expected, r_ty)\n+                        }\n+                        _ => {\n+                            let inner_ty = self.next_ty_var(\n+                                TypeVariableOrigin {\n+                                    kind: TypeVariableOriginKind::TypeInference,\n+                                    span: inner.span,\n+                                }\n+                            );\n+                            let mt = ty::TypeAndMut { ty: inner_ty, mutbl: mutbl };\n+                            let region = self.next_region_var(infer::PatternRegion(pat.span));\n+                            let rptr_ty = tcx.mk_ref(region, mt);\n+                            debug!(\"check_pat_walk: demanding {:?} = {:?}\", expected, rptr_ty);\n+                            let err = self.demand_eqtype_diag(pat.span, expected, rptr_ty);\n+\n+                            // Look for a case like `fn foo(&foo: u32)` and suggest\n+                            // `fn foo(foo: &u32)`\n+                            if let Some(mut err) = err {\n+                                self.borrow_pat_suggestion(&mut err, &pat, &inner, &expected);\n+                                err.emit();\n+                            }\n+                            (rptr_ty, inner_ty)\n+                        }\n+                    };\n+\n+                    self.check_pat_walk(&inner, inner_ty, def_bm, discrim_span);\n+                    rptr_ty\n+                } else {\n+                    self.check_pat_walk(&inner, tcx.types.err, def_bm, discrim_span);\n+                    tcx.types.err\n+                }\n+            }\n+            PatKind::Slice(ref before, ref slice, ref after) => {\n+                let expected_ty = self.structurally_resolved_type(pat.span, expected);\n+                let (inner_ty, slice_ty) = match expected_ty.sty {\n+                    ty::Array(inner_ty, size) => {\n+                        if let Some(size) = size.try_eval_usize(tcx, self.param_env) {\n+                            let min_len = before.len() as u64 + after.len() as u64;\n+                            if slice.is_none() {\n+                                if min_len != size {\n+                                    struct_span_err!(\n+                                        tcx.sess, pat.span, E0527,\n+                                        \"pattern requires {} elements but array has {}\",\n+                                        min_len, size)\n+                                        .span_label(pat.span, format!(\"expected {} elements\", size))\n+                                        .emit();\n+                                }\n+                                (inner_ty, tcx.types.err)\n+                            } else if let Some(rest) = size.checked_sub(min_len) {\n+                                (inner_ty, tcx.mk_array(inner_ty, rest))\n+                            } else {\n+                                struct_span_err!(tcx.sess, pat.span, E0528,\n+                                        \"pattern requires at least {} elements but array has {}\",\n+                                        min_len, size)\n+                                    .span_label(pat.span,\n+                                        format!(\"pattern cannot match array of {} elements\", size))\n+                                    .emit();\n+                                (inner_ty, tcx.types.err)\n+                            }\n+                        } else {\n+                            struct_span_err!(\n+                                tcx.sess,\n+                                pat.span,\n+                                E0730,\n+                                \"cannot pattern-match on an array without a fixed length\",\n+                            ).emit();\n+                            (inner_ty, tcx.types.err)\n+                        }\n+                    }\n+                    ty::Slice(inner_ty) => (inner_ty, expected_ty),\n+                    _ => {\n+                        if !expected_ty.references_error() {\n+                            let mut err = struct_span_err!(\n+                                tcx.sess, pat.span, E0529,\n+                                \"expected an array or slice, found `{}`\",\n+                                expected_ty);\n+                            if let ty::Ref(_, ty, _) = expected_ty.sty {\n+                                match ty.sty {\n+                                    ty::Array(..) | ty::Slice(..) => {\n+                                        err.help(\"the semantics of slice patterns changed \\\n+                                                  recently; see issue #62254\");\n+                                    }\n+                                    _ => {}\n+                                }\n+                            }\n+\n+                            err.span_label( pat.span,\n+                                format!(\"pattern cannot match with input type `{}`\", expected_ty)\n+                            ).emit();\n+                        }\n+                        (tcx.types.err, tcx.types.err)\n+                    }\n+                };\n+\n+                for elt in before {\n+                    self.check_pat_walk(&elt, inner_ty, def_bm, discrim_span);\n+                }\n+                if let Some(ref slice) = *slice {\n+                    self.check_pat_walk(&slice, slice_ty, def_bm, discrim_span);\n+                }\n+                for elt in after {\n+                    self.check_pat_walk(&elt, inner_ty, def_bm, discrim_span);\n+                }\n+                expected_ty\n+            }\n+        };\n+\n+        self.write_ty(pat.hir_id, ty);\n+\n+        // (*) In most of the cases above (literals and constants being\n+        // the exception), we relate types using strict equality, even\n+        // though subtyping would be sufficient. There are a few reasons\n+        // for this, some of which are fairly subtle and which cost me\n+        // (nmatsakis) an hour or two debugging to remember, so I thought\n+        // I'd write them down this time.\n+        //\n+        // 1. There is no loss of expressiveness here, though it does\n+        // cause some inconvenience. What we are saying is that the type\n+        // of `x` becomes *exactly* what is expected. This can cause unnecessary\n+        // errors in some cases, such as this one:\n+        //\n+        // ```\n+        // fn foo<'x>(x: &'x int) {\n+        //    let a = 1;\n+        //    let mut z = x;\n+        //    z = &a;\n+        // }\n+        // ```\n+        //\n+        // The reason we might get an error is that `z` might be\n+        // assigned a type like `&'x int`, and then we would have\n+        // a problem when we try to assign `&a` to `z`, because\n+        // the lifetime of `&a` (i.e., the enclosing block) is\n+        // shorter than `'x`.\n+        //\n+        // HOWEVER, this code works fine. The reason is that the\n+        // expected type here is whatever type the user wrote, not\n+        // the initializer's type. In this case the user wrote\n+        // nothing, so we are going to create a type variable `Z`.\n+        // Then we will assign the type of the initializer (`&'x\n+        // int`) as a subtype of `Z`: `&'x int <: Z`. And hence we\n+        // will instantiate `Z` as a type `&'0 int` where `'0` is\n+        // a fresh region variable, with the constraint that `'x :\n+        // '0`.  So basically we're all set.\n+        //\n+        // Note that there are two tests to check that this remains true\n+        // (`regions-reassign-{match,let}-bound-pointer.rs`).\n+        //\n+        // 2. Things go horribly wrong if we use subtype. The reason for\n+        // THIS is a fairly subtle case involving bound regions. See the\n+        // `givens` field in `region_constraints`, as well as the test\n+        // `regions-relate-bound-regions-on-closures-to-inference-variables.rs`,\n+        // for details. Short version is that we must sometimes detect\n+        // relationships between specific region variables and regions\n+        // bound in a closure signature, and that detection gets thrown\n+        // off when we substitute fresh region variables here to enable\n+        // subtyping.\n+    }\n+\n+    fn borrow_pat_suggestion(\n+        &self,\n+        err: &mut DiagnosticBuilder<'_>,\n+        pat: &Pat,\n+        inner: &Pat,\n+        expected: Ty<'tcx>,\n+    ) {\n+        let tcx = self.tcx;\n+        if let PatKind::Binding(..) = inner.node {\n+            let binding_parent_id = tcx.hir().get_parent_node(pat.hir_id);\n+            let binding_parent = tcx.hir().get(binding_parent_id);\n+            debug!(\"inner {:?} pat {:?} parent {:?}\", inner, pat, binding_parent);\n+            match binding_parent {\n+                hir::Node::Arg(hir::Arg { span, .. }) => {\n+                    if let Ok(snippet) = tcx.sess.source_map().span_to_snippet(inner.span) {\n+                        err.span_suggestion(\n+                            *span,\n+                            &format!(\"did you mean `{}`\", snippet),\n+                            format!(\" &{}\", expected),\n+                            Applicability::MachineApplicable,\n+                        );\n+                    }\n+                }\n+                hir::Node::Arm(_) |\n+                hir::Node::Pat(_) => {\n+                    // rely on match ergonomics or it might be nested `&&pat`\n+                    if let Ok(snippet) = tcx.sess.source_map().span_to_snippet(inner.span) {\n+                        err.span_suggestion(\n+                            pat.span,\n+                            \"you can probably remove the explicit borrow\",\n+                            snippet,\n+                            Applicability::MaybeIncorrect,\n+                        );\n+                    }\n+                }\n+                _ => {} // don't provide suggestions in other cases #55175\n+            }\n+        }\n+    }\n+\n+    pub fn check_dereferencable(&self, span: Span, expected: Ty<'tcx>, inner: &hir::Pat) -> bool {\n+        if let PatKind::Binding(..) = inner.node {\n+            if let Some(mt) = self.shallow_resolve(expected).builtin_deref(true) {\n+                if let ty::Dynamic(..) = mt.ty.sty {\n+                    // This is \"x = SomeTrait\" being reduced from\n+                    // \"let &x = &SomeTrait\" or \"let box x = Box<SomeTrait>\", an error.\n+                    let type_str = self.ty_to_string(expected);\n+                    let mut err = struct_span_err!(\n+                        self.tcx.sess,\n+                        span,\n+                        E0033,\n+                        \"type `{}` cannot be dereferenced\",\n+                        type_str\n+                    );\n+                    err.span_label(span, format!(\"type `{}` cannot be dereferenced\", type_str));\n+                    if self.tcx.sess.teach(&err.get_code().unwrap()) {\n+                        err.note(\"\\\n+This error indicates that a pointer to a trait type cannot be implicitly dereferenced by a \\\n+pattern. Every trait defines a type, but because the size of trait implementors isn't fixed, \\\n+this type has no compile-time size. Therefore, all accesses to trait types must be through \\\n+pointers. If you encounter this error you should try to avoid dereferencing the pointer.\n+\n+You can read more about trait objects in the Trait Objects section of the Reference: \\\n+https://doc.rust-lang.org/reference/types.html#trait-objects\");\n+                    }\n+                    err.emit();\n+                    return false\n+                }\n+            }\n+        }\n+        true\n+    }\n+\n+    fn check_pat_struct(\n+        &self,\n+        pat: &'tcx hir::Pat,\n+        qpath: &hir::QPath,\n+        fields: &'tcx [hir::FieldPat],\n+        etc: bool,\n+        expected: Ty<'tcx>,\n+        def_bm: ty::BindingMode,\n+        discrim_span: Option<Span>,\n+    ) -> Ty<'tcx> {\n+        // Resolve the path and check the definition for errors.\n+        let (variant, pat_ty) = if let Some(variant_ty) = self.check_struct_path(qpath, pat.hir_id)\n+        {\n+            variant_ty\n+        } else {\n+            for field in fields {\n+                self.check_pat_walk(&field.pat, self.tcx.types.err, def_bm, discrim_span);\n+            }\n+            return self.tcx.types.err;\n+        };\n+\n+        // Type-check the path.\n+        self.demand_eqtype_pat(pat.span, expected, pat_ty, discrim_span);\n+\n+        // Type-check subpatterns.\n+        if self.check_struct_pat_fields(pat_ty, pat.hir_id, pat.span, variant, fields, etc, def_bm)\n+        {\n+            pat_ty\n+        } else {\n+            self.tcx.types.err\n+        }\n+    }\n+\n+    fn check_pat_path(\n+        &self,\n+        pat: &hir::Pat,\n+        path_resolution: (Res, Option<Ty<'tcx>>, &'b [hir::PathSegment]),\n+        qpath: &hir::QPath,\n+        expected: Ty<'tcx>,\n+    ) -> Ty<'tcx> {\n+        let tcx = self.tcx;\n+\n+        // We have already resolved the path.\n+        let (res, opt_ty, segments) = path_resolution;\n+        match res {\n+            Res::Err => {\n+                self.set_tainted_by_errors();\n+                return tcx.types.err;\n+            }\n+            Res::Def(DefKind::Method, _) |\n+            Res::Def(DefKind::Ctor(_, CtorKind::Fictive), _) |\n+            Res::Def(DefKind::Ctor(_, CtorKind::Fn), _) => {\n+                report_unexpected_variant_res(tcx, res, pat.span, qpath);\n+                return tcx.types.err;\n+            }\n+            Res::Def(DefKind::Ctor(_, CtorKind::Const), _) | Res::SelfCtor(..) |\n+            Res::Def(DefKind::Const, _) | Res::Def(DefKind::AssocConst, _) => {} // OK\n+            _ => bug!(\"unexpected pattern resolution: {:?}\", res)\n+        }\n+\n+        // Type-check the path.\n+        let pat_ty = self.instantiate_value_path(segments, opt_ty, res, pat.span, pat.hir_id).0;\n+        self.demand_suptype(pat.span, expected, pat_ty);\n+        pat_ty\n+    }\n+\n+    fn check_pat_tuple_struct(\n+        &self,\n+        pat: &hir::Pat,\n+        qpath: &hir::QPath,\n+        subpats: &'tcx [P<hir::Pat>],\n+        ddpos: Option<usize>,\n+        expected: Ty<'tcx>,\n+        def_bm: ty::BindingMode,\n+        match_arm_pat_span: Option<Span>,\n+    ) -> Ty<'tcx> {\n+        let tcx = self.tcx;\n+        let on_error = || {\n+            for pat in subpats {\n+                self.check_pat_walk(&pat, tcx.types.err, def_bm, match_arm_pat_span);\n+            }\n+        };\n+        let report_unexpected_res = |res: Res| {\n+            let msg = format!(\"expected tuple struct/variant, found {} `{}`\",\n+                              res.descr(),\n+                              hir::print::to_string(tcx.hir(), |s| s.print_qpath(qpath, false)));\n+            let mut err = struct_span_err!(tcx.sess, pat.span, E0164, \"{}\", msg);\n+            match (res, &pat.node) {\n+                (Res::Def(DefKind::Fn, _), _) | (Res::Def(DefKind::Method, _), _) => {\n+                    err.span_label(pat.span, \"`fn` calls are not allowed in patterns\");\n+                    err.help(\"for more information, visit \\\n+                              https://doc.rust-lang.org/book/ch18-00-patterns.html\");\n+                }\n+                _ => {\n+                    err.span_label(pat.span, \"not a tuple variant or struct\");\n+                }\n+            }\n+            err.emit();\n+            on_error();\n+        };\n+\n+        // Resolve the path and check the definition for errors.\n+        let (res, opt_ty, segments) = self.resolve_ty_and_res_ufcs(qpath, pat.hir_id, pat.span);\n+        if res == Res::Err {\n+            self.set_tainted_by_errors();\n+            on_error();\n+            return self.tcx.types.err;\n+        }\n+\n+        // Type-check the path.\n+        let (pat_ty, res) = self.instantiate_value_path(segments, opt_ty, res, pat.span,\n+            pat.hir_id);\n+        if !pat_ty.is_fn() {\n+            report_unexpected_res(res);\n+            return self.tcx.types.err;\n+        }\n+\n+        let variant = match res {\n+            Res::Err => {\n+                self.set_tainted_by_errors();\n+                on_error();\n+                return tcx.types.err;\n+            }\n+            Res::Def(DefKind::AssocConst, _) | Res::Def(DefKind::Method, _) => {\n+                report_unexpected_res(res);\n+                return tcx.types.err;\n+            }\n+            Res::Def(DefKind::Ctor(_, CtorKind::Fn), _) => {\n+                tcx.expect_variant_res(res)\n+            }\n+            _ => bug!(\"unexpected pattern resolution: {:?}\", res)\n+        };\n+\n+        // Replace constructor type with constructed type for tuple struct patterns.\n+        let pat_ty = pat_ty.fn_sig(tcx).output();\n+        let pat_ty = pat_ty.no_bound_vars().expect(\"expected fn type\");\n+\n+        self.demand_eqtype_pat(pat.span, expected, pat_ty, match_arm_pat_span);\n+\n+        // Type-check subpatterns.\n+        if subpats.len() == variant.fields.len() ||\n+                subpats.len() < variant.fields.len() && ddpos.is_some() {\n+            let substs = match pat_ty.sty {\n+                ty::Adt(_, substs) => substs,\n+                _ => bug!(\"unexpected pattern type {:?}\", pat_ty),\n+            };\n+            for (i, subpat) in subpats.iter().enumerate_and_adjust(variant.fields.len(), ddpos) {\n+                let field_ty = self.field_ty(subpat.span, &variant.fields[i], substs);\n+                self.check_pat_walk(&subpat, field_ty, def_bm, match_arm_pat_span);\n+\n+                self.tcx.check_stability(variant.fields[i].did, Some(pat.hir_id), subpat.span);\n+            }\n+        } else {\n+            let subpats_ending = if subpats.len() == 1 { \"\" } else { \"s\" };\n+            let fields_ending = if variant.fields.len() == 1 { \"\" } else { \"s\" };\n+            struct_span_err!(tcx.sess, pat.span, E0023,\n+                             \"this pattern has {} field{}, but the corresponding {} has {} field{}\",\n+                             subpats.len(), subpats_ending, res.descr(),\n+                             variant.fields.len(),  fields_ending)\n+                .span_label(pat.span, format!(\"expected {} field{}, found {}\",\n+                                              variant.fields.len(), fields_ending, subpats.len()))\n+                .emit();\n+            on_error();\n+            return tcx.types.err;\n+        }\n+        pat_ty\n+    }\n+\n+    fn check_struct_pat_fields(\n+        &self,\n+        adt_ty: Ty<'tcx>,\n+        pat_id: hir::HirId,\n+        span: Span,\n+        variant: &'tcx ty::VariantDef,\n+        fields: &'tcx [hir::FieldPat],\n+        etc: bool,\n+        def_bm: ty::BindingMode,\n+    ) -> bool {\n+        let tcx = self.tcx;\n+\n+        let (substs, adt) = match adt_ty.sty {\n+            ty::Adt(adt, substs) => (substs, adt),\n+            _ => span_bug!(span, \"struct pattern is not an ADT\")\n+        };\n+        let kind_name = adt.variant_descr();\n+\n+        // Index the struct fields' types.\n+        let field_map = variant.fields\n+            .iter()\n+            .enumerate()\n+            .map(|(i, field)| (field.ident.modern(), (i, field)))\n+            .collect::<FxHashMap<_, _>>();\n+\n+        // Keep track of which fields have already appeared in the pattern.\n+        let mut used_fields = FxHashMap::default();\n+        let mut no_field_errors = true;\n+\n+        let mut inexistent_fields = vec![];\n+        // Typecheck each field.\n+        for field in fields {\n+            let span = field.span;\n+            let ident = tcx.adjust_ident(field.ident, variant.def_id);\n+            let field_ty = match used_fields.entry(ident) {\n+                Occupied(occupied) => {\n+                    struct_span_err!(tcx.sess, span, E0025,\n+                                     \"field `{}` bound multiple times \\\n+                                      in the pattern\",\n+                                     field.ident)\n+                        .span_label(span,\n+                                    format!(\"multiple uses of `{}` in pattern\", field.ident))\n+                        .span_label(*occupied.get(), format!(\"first use of `{}`\", field.ident))\n+                        .emit();\n+                    no_field_errors = false;\n+                    tcx.types.err\n+                }\n+                Vacant(vacant) => {\n+                    vacant.insert(span);\n+                    field_map.get(&ident)\n+                        .map(|(i, f)| {\n+                            self.write_field_index(field.hir_id, *i);\n+                            self.tcx.check_stability(f.did, Some(pat_id), span);\n+                            self.field_ty(span, f, substs)\n+                        })\n+                        .unwrap_or_else(|| {\n+                            inexistent_fields.push(field.ident);\n+                            no_field_errors = false;\n+                            tcx.types.err\n+                        })\n+                }\n+            };\n+\n+            self.check_pat_walk(&field.pat, field_ty, def_bm, None);\n+        }\n+        let mut unmentioned_fields = variant.fields\n+                .iter()\n+                .map(|field| field.ident.modern())\n+                .filter(|ident| !used_fields.contains_key(&ident))\n+                .collect::<Vec<_>>();\n+        if inexistent_fields.len() > 0 && !variant.recovered {\n+            let (field_names, t, plural) = if inexistent_fields.len() == 1 {\n+                (format!(\"a field named `{}`\", inexistent_fields[0]), \"this\", \"\")\n+            } else {\n+                (format!(\"fields named {}\",\n+                         inexistent_fields.iter()\n+                            .map(|ident| format!(\"`{}`\", ident))\n+                            .collect::<Vec<String>>()\n+                            .join(\", \")), \"these\", \"s\")\n+            };\n+            let spans = inexistent_fields.iter().map(|ident| ident.span).collect::<Vec<_>>();\n+            let mut err = struct_span_err!(tcx.sess,\n+                                           spans,\n+                                           E0026,\n+                                           \"{} `{}` does not have {}\",\n+                                           kind_name,\n+                                           tcx.def_path_str(variant.def_id),\n+                                           field_names);\n+            if let Some(ident) = inexistent_fields.last() {\n+                err.span_label(ident.span,\n+                               format!(\"{} `{}` does not have {} field{}\",\n+                                       kind_name,\n+                                       tcx.def_path_str(variant.def_id),\n+                                       t,\n+                                       plural));\n+                if plural == \"\" {\n+                    let input = unmentioned_fields.iter().map(|field| &field.name);\n+                    let suggested_name =\n+                        find_best_match_for_name(input, &ident.as_str(), None);\n+                    if let Some(suggested_name) = suggested_name {\n+                        err.span_suggestion(\n+                            ident.span,\n+                            \"a field with a similar name exists\",\n+                            suggested_name.to_string(),\n+                            Applicability::MaybeIncorrect,\n+                        );\n+\n+                        // we don't want to throw `E0027` in case we have thrown `E0026` for them\n+                        unmentioned_fields.retain(|&x| x.as_str() != suggested_name.as_str());\n+                    }\n+                }\n+            }\n+            if tcx.sess.teach(&err.get_code().unwrap()) {\n+                err.note(\n+                    \"This error indicates that a struct pattern attempted to \\\n+                     extract a non-existent field from a struct. Struct fields \\\n+                     are identified by the name used before the colon : so struct \\\n+                     patterns should resemble the declaration of the struct type \\\n+                     being matched.\\n\\n\\\n+                     If you are using shorthand field patterns but want to refer \\\n+                     to the struct field by a different name, you should rename \\\n+                     it explicitly.\"\n+                );\n+            }\n+            err.emit();\n+        }\n+\n+        // Require `..` if struct has non_exhaustive attribute.\n+        if variant.is_field_list_non_exhaustive() && !adt.did.is_local() && !etc {\n+            span_err!(tcx.sess, span, E0638,\n+                      \"`..` required with {} marked as non-exhaustive\",\n+                      kind_name);\n+        }\n+\n+        // Report an error if incorrect number of the fields were specified.\n+        if kind_name == \"union\" {\n+            if fields.len() != 1 {\n+                tcx.sess.span_err(span, \"union patterns should have exactly one field\");\n+            }\n+            if etc {\n+                tcx.sess.span_err(span, \"`..` cannot be used in union patterns\");\n+            }\n+        } else if !etc {\n+            if unmentioned_fields.len() > 0 {\n+                let field_names = if unmentioned_fields.len() == 1 {\n+                    format!(\"field `{}`\", unmentioned_fields[0])\n+                } else {\n+                    format!(\"fields {}\",\n+                            unmentioned_fields.iter()\n+                                .map(|name| format!(\"`{}`\", name))\n+                                .collect::<Vec<String>>()\n+                                .join(\", \"))\n+                };\n+                let mut diag = struct_span_err!(tcx.sess, span, E0027,\n+                                                \"pattern does not mention {}\",\n+                                                field_names);\n+                diag.span_label(span, format!(\"missing {}\", field_names));\n+                if variant.ctor_kind == CtorKind::Fn {\n+                    diag.note(\"trying to match a tuple variant with a struct variant pattern\");\n+                }\n+                if tcx.sess.teach(&diag.get_code().unwrap()) {\n+                    diag.note(\n+                        \"This error indicates that a pattern for a struct fails to specify a \\\n+                         sub-pattern for every one of the struct's fields. Ensure that each field \\\n+                         from the struct's definition is mentioned in the pattern, or use `..` to \\\n+                         ignore unwanted fields.\"\n+                    );\n+                }\n+                diag.emit();\n+            }\n+        }\n+        no_field_errors\n+    }\n+}"}]}