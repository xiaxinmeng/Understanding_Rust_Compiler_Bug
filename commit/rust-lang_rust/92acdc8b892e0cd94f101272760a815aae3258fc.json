{"sha": "92acdc8b892e0cd94f101272760a815aae3258fc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkyYWNkYzhiODkyZTBjZDk0ZjEwMTI3Mjc2MGE4MTVhYWUzMjU4ZmM=", "commit": {"author": {"name": "Stein Somers", "email": "git@steinsomers.be", "date": "2020-01-02T11:33:07Z"}, "committer": {"name": "Stein Somers", "email": "git@steinsomers.be", "date": "2020-01-04T13:07:26Z"}, "message": "Tweak and extend internal documentation, including debug asserts.\n\nCo-Authored-By: Robin Kruppe <robin.kruppe@gmail.com>", "tree": {"sha": "c5e24feb689bf305da351ffd5b039eaa49730bd6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c5e24feb689bf305da351ffd5b039eaa49730bd6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/92acdc8b892e0cd94f101272760a815aae3258fc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/92acdc8b892e0cd94f101272760a815aae3258fc", "html_url": "https://github.com/rust-lang/rust/commit/92acdc8b892e0cd94f101272760a815aae3258fc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/92acdc8b892e0cd94f101272760a815aae3258fc/comments", "author": {"login": "ssomers", "id": 10174877, "node_id": "MDQ6VXNlcjEwMTc0ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/10174877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ssomers", "html_url": "https://github.com/ssomers", "followers_url": "https://api.github.com/users/ssomers/followers", "following_url": "https://api.github.com/users/ssomers/following{/other_user}", "gists_url": "https://api.github.com/users/ssomers/gists{/gist_id}", "starred_url": "https://api.github.com/users/ssomers/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ssomers/subscriptions", "organizations_url": "https://api.github.com/users/ssomers/orgs", "repos_url": "https://api.github.com/users/ssomers/repos", "events_url": "https://api.github.com/users/ssomers/events{/privacy}", "received_events_url": "https://api.github.com/users/ssomers/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ssomers", "id": 10174877, "node_id": "MDQ6VXNlcjEwMTc0ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/10174877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ssomers", "html_url": "https://github.com/ssomers", "followers_url": "https://api.github.com/users/ssomers/followers", "following_url": "https://api.github.com/users/ssomers/following{/other_user}", "gists_url": "https://api.github.com/users/ssomers/gists{/gist_id}", "starred_url": "https://api.github.com/users/ssomers/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ssomers/subscriptions", "organizations_url": "https://api.github.com/users/ssomers/orgs", "repos_url": "https://api.github.com/users/ssomers/repos", "events_url": "https://api.github.com/users/ssomers/events{/privacy}", "received_events_url": "https://api.github.com/users/ssomers/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "766fba3fdca8fe075c370a63d2f76f8407483af5", "url": "https://api.github.com/repos/rust-lang/rust/commits/766fba3fdca8fe075c370a63d2f76f8407483af5", "html_url": "https://github.com/rust-lang/rust/commit/766fba3fdca8fe075c370a63d2f76f8407483af5"}], "stats": {"total": 54, "additions": 39, "deletions": 15}, "files": [{"sha": "302c2bcd5e4a32100d243d893b86ddc39a70c1bf", "filename": "src/liballoc/collections/btree/map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/92acdc8b892e0cd94f101272760a815aae3258fc/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92acdc8b892e0cd94f101272760a815aae3258fc/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs?ref=92acdc8b892e0cd94f101272760a815aae3258fc", "patch": "@@ -493,7 +493,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         BTreeMap { root: node::Root::shared_empty_root(), length: 0 }\n     }\n \n-    /// Clears the map, removing all values.\n+    /// Clears the map, removing all elements.\n     ///\n     /// # Examples\n     ///\n@@ -2605,7 +2605,7 @@ impl<'a, K: Ord, V> OccupiedEntry<'a, K, V> {\n \n         // Handle underflow\n         let mut cur_node = small_leaf.forget_type();\n-        while cur_node.len() < node::CAPACITY / 2 {\n+        while cur_node.len() < node::MIN_LEN {\n             match handle_underfull_node(cur_node) {\n                 AtRoot => break,\n                 EmptyParent(_) => unreachable!(),"}, {"sha": "260e51d635dbbc87a0801932847a2aea668b393e", "filename": "src/liballoc/collections/btree/node.rs", "status": "modified", "additions": 37, "deletions": 13, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/92acdc8b892e0cd94f101272760a815aae3258fc/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92acdc8b892e0cd94f101272760a815aae3258fc/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs?ref=92acdc8b892e0cd94f101272760a815aae3258fc", "patch": "@@ -308,15 +308,15 @@ impl<K, V> Root<K, V> {\n ///   `Leaf`, the `NodeRef` points to a leaf node, when this is `Internal` the\n ///   `NodeRef` points to an internal node, and when this is `LeafOrInternal` the\n ///   `NodeRef` could be pointing to either type of node.\n-///   Note that in case of a leaf node, this might still be the shared root!  Only turn\n-///   this into a `LeafNode` reference if you know it is not a root!  Shared references\n-///   must be dereferencable *for the entire size of their pointee*, so `&InternalNode`\n-///   pointing to the shared root is UB.\n-///   Turning this into a `NodeHeader` is always safe.\n+///   Note that in case of a leaf node, this might still be the shared root!\n+///   Only turn this into a `LeafNode` reference if you know it is not the shared root!\n+///   Shared references must be dereferencable *for the entire size of their pointee*,\n+///   so '&LeafNode` or `&InternalNode` pointing to the shared root is undefined behavior.\n+///   Turning this into a `NodeHeader` reference is always safe.\n pub struct NodeRef<BorrowType, K, V, Type> {\n     height: usize,\n     node: NonNull<LeafNode<K, V>>,\n-    // This is null unless the borrow type is `Mut`\n+    // `root` is null unless the borrow type is `Mut`\n     root: *const Root<K, V>,\n     _marker: PhantomData<(BorrowType, Type)>,\n }\n@@ -370,23 +370,33 @@ impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n         NodeRef { height: self.height, node: self.node, root: self.root, _marker: PhantomData }\n     }\n \n-    /// Assert that this is indeed a proper leaf node, and not the shared root.\n+    /// Exposes the leaf \"portion\" of any leaf or internal node that is not the shared root.\n+    /// If the node is a leaf, this function simply opens up its data.\n+    /// If the node is an internal node, so not a leaf, it does have all the data a leaf has\n+    /// (header, keys and values), and this function exposes that.\n+    /// See `NodeRef` on why the node may not be a shared root.\n     unsafe fn as_leaf(&self) -> &LeafNode<K, V> {\n+        debug_assert!(!self.is_shared_root());\n         self.node.as_ref()\n     }\n \n     fn as_header(&self) -> &NodeHeader<K, V> {\n         unsafe { &*(self.node.as_ptr() as *const NodeHeader<K, V>) }\n     }\n \n+    /// Returns whether the node is the shared, empty root.\n     pub fn is_shared_root(&self) -> bool {\n         self.as_header().is_shared_root()\n     }\n \n+    /// Borrows a view into the keys stored in the node.\n+    /// Works on all possible nodes, including the shared root.\n     pub fn keys(&self) -> &[K] {\n         self.reborrow().into_key_slice()\n     }\n \n+    /// Borrows a view into the values stored in the node.\n+    /// The caller must ensure that the node is not the shared root.\n     fn vals(&self) -> &[V] {\n         self.reborrow().into_val_slice()\n     }\n@@ -491,16 +501,24 @@ impl<'a, K, V, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n         NodeRef { height: self.height, node: self.node, root: self.root, _marker: PhantomData }\n     }\n \n+    /// Exposes the leaf \"portion\" of any leaf or internal node for writing.\n+    /// If the node is a leaf, this function simply opens up its data.\n+    /// If the node is an internal node, so not a leaf, it does have all the data a leaf has\n+    /// (header, keys and values), and this function exposes that.\n+    ///\n     /// Returns a raw ptr to avoid asserting exclusive access to the entire node.\n+    /// This also implies you can invoke this member on the shared root, but the resulting pointer\n+    /// might not be properly aligned and definitely would not allow accessing keys and values.\n     fn as_leaf_mut(&mut self) -> *mut LeafNode<K, V> {\n-        // We are mutable, so we cannot be the shared root, so accessing this as a leaf is okay.\n         self.node.as_ptr()\n     }\n \n+    /// The caller must ensure that the node is not the shared root.\n     fn keys_mut(&mut self) -> &mut [K] {\n         unsafe { self.reborrow_mut().into_key_slice_mut() }\n     }\n \n+    /// The caller must ensure that the node is not the shared root.\n     fn vals_mut(&mut self) -> &mut [V] {\n         unsafe { self.reborrow_mut().into_val_slice_mut() }\n     }\n@@ -551,9 +569,10 @@ impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Immut<'a>, K, V, Type> {\n         }\n     }\n \n+    /// The caller must ensure that the node is not the shared root.\n     fn into_val_slice(self) -> &'a [V] {\n         debug_assert!(!self.is_shared_root());\n-        // We cannot be the shared root, so `as_leaf` is okay\n+        // We cannot be the shared root, so `as_leaf` is okay.\n         unsafe { slice::from_raw_parts(MaybeUninit::first_ptr(&self.as_leaf().vals), self.len()) }\n     }\n \n@@ -587,6 +606,7 @@ impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n         }\n     }\n \n+    /// The caller must ensure that the node is not the shared root.\n     fn into_val_slice_mut(mut self) -> &'a mut [V] {\n         debug_assert!(!self.is_shared_root());\n         unsafe {\n@@ -597,6 +617,7 @@ impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n         }\n     }\n \n+    /// The caller must ensure that the node is not the shared root.\n     fn into_slices_mut(mut self) -> (&'a mut [K], &'a mut [V]) {\n         debug_assert!(!self.is_shared_root());\n         // We cannot use the getters here, because calling the second one\n@@ -655,6 +676,7 @@ impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n         // Necessary for correctness, but this is an internal module\n         debug_assert!(edge.height == self.height - 1);\n         debug_assert!(self.len() < CAPACITY);\n+        debug_assert!(!self.is_shared_root());\n \n         let idx = self.len();\n \n@@ -686,6 +708,7 @@ impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n         // Necessary for correctness, but this is an internal module\n         debug_assert!(edge.height == self.height - 1);\n         debug_assert!(self.len() < CAPACITY);\n+        debug_assert!(!self.is_shared_root());\n \n         unsafe {\n             slice_insert(self.keys_mut(), 0, key);\n@@ -773,6 +796,7 @@ impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal> {\n         }\n     }\n \n+    /// The caller must ensure that the node is not the shared root.\n     fn into_kv_pointers_mut(mut self) -> (*mut K, *mut V) {\n         (self.keys_mut().as_mut_ptr(), self.vals_mut().as_mut_ptr())\n     }\n@@ -1116,8 +1140,8 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::KV>\n         }\n     }\n \n-    /// Removes the key/value pair pointed to by this handle, returning the edge between the\n-    /// now adjacent key/value pairs to the left and right of this handle.\n+    /// Removes the key/value pair pointed to by this handle and returns it, along with the edge\n+    /// between the now adjacent key/value pairs (if any) to the left and right of this handle.\n     pub fn remove(\n         mut self,\n     ) -> (Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge>, K, V) {\n@@ -1260,7 +1284,7 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n         }\n     }\n \n-    /// This removes a key/value pair from the left child and replaces it with the key/value pair\n+    /// This removes a key/value pair from the left child and places it in the key/value storage\n     /// pointed to by this handle while pushing the old key/value pair of this handle into the right\n     /// child.\n     pub fn steal_left(&mut self) {\n@@ -1277,7 +1301,7 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n         }\n     }\n \n-    /// This removes a key/value pair from the right child and replaces it with the key/value pair\n+    /// This removes a key/value pair from the right child and places it in the key/value storage\n     /// pointed to by this handle while pushing the old key/value pair of this handle into the left\n     /// child.\n     pub fn steal_right(&mut self) {"}]}