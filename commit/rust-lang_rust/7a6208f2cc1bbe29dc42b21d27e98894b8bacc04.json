{"sha": "7a6208f2cc1bbe29dc42b21d27e98894b8bacc04", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdhNjIwOGYyY2MxYmJlMjlkYzQyYjIxZDI3ZTk4ODk0YjhiYWNjMDQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-07-13T19:16:28Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-07-13T19:16:28Z"}, "message": "auto merge of #15646 : jbclements/rust/method-macros, r=cmr\n\nThis patch adds support for macros in method position. It follows roughly the template for Item macros, where an outer `Method` wrapper contains a `Method_` enum which can either be a macro invocation or a standard macro definition. \r\n\r\nOne note; adding support for macros that expand into multiple methods is not included here, but should be a simple parser change, since this patch updates the type of fold_macro to return a smallvector of methods.\r\n\r\nFor reviewers, please pay special attention to the parser changes; these are the ones I'm most concerned about.\r\n\r\nBecause of the small change to the interface of fold_method, this is a ...\r\n\r\n[breaking change]", "tree": {"sha": "d4341cdd32f5d747a6289b2335012ec8f435d151", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d4341cdd32f5d747a6289b2335012ec8f435d151"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7a6208f2cc1bbe29dc42b21d27e98894b8bacc04", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7a6208f2cc1bbe29dc42b21d27e98894b8bacc04", "html_url": "https://github.com/rust-lang/rust/commit/7a6208f2cc1bbe29dc42b21d27e98894b8bacc04", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7a6208f2cc1bbe29dc42b21d27e98894b8bacc04/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fbeee04f31ac16fe61f29749145a29e562d065fe", "url": "https://api.github.com/repos/rust-lang/rust/commits/fbeee04f31ac16fe61f29749145a29e562d065fe", "html_url": "https://github.com/rust-lang/rust/commit/fbeee04f31ac16fe61f29749145a29e562d065fe"}, {"sha": "aee5917556856428072cc090fb892176eaa075b3", "url": "https://api.github.com/repos/rust-lang/rust/commits/aee5917556856428072cc090fb892176eaa075b3", "html_url": "https://github.com/rust-lang/rust/commit/aee5917556856428072cc090fb892176eaa075b3"}], "stats": {"total": 920, "additions": 561, "deletions": 359}, "files": [{"sha": "6cb0ab51ca10d074f3e09a39f8131777a9434588", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a6208f2cc1bbe29dc42b21d27e98894b8bacc04/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a6208f2cc1bbe29dc42b21d27e98894b8bacc04/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=7a6208f2cc1bbe29dc42b21d27e98894b8bacc04", "patch": "@@ -799,7 +799,7 @@ fn encode_info_for_method(ecx: &EncodeContext,\n         } else {\n             encode_symbol(ecx, ebml_w, m.def_id.node);\n         }\n-        encode_method_argument_names(ebml_w, &*ast_method.decl);\n+        encode_method_argument_names(ebml_w, method_fn_decl(&*ast_method));\n     }\n \n     ebml_w.end_tag();\n@@ -1241,7 +1241,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n                     encode_method_sort(ebml_w, 'p');\n                     encode_inlined_item(ecx, ebml_w,\n                                         IIMethodRef(def_id, true, &*m));\n-                    encode_method_argument_names(ebml_w, &*m.decl);\n+                    encode_method_argument_names(ebml_w, method_fn_decl(m));\n                 }\n             }\n "}, {"sha": "d58023a48756f00ebc3f8facec0c9e2536003dd7", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7a6208f2cc1bbe29dc42b21d27e98894b8bacc04/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a6208f2cc1bbe29dc42b21d27e98894b8bacc04/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=7a6208f2cc1bbe29dc42b21d27e98894b8bacc04", "patch": "@@ -136,7 +136,7 @@ pub fn decode_inlined_item(cdata: &cstore::crate_metadata,\n         let ident = match ii {\n             ast::IIItem(i) => i.ident,\n             ast::IIForeign(i) => i.ident,\n-            ast::IIMethod(_, _, m) => m.ident,\n+            ast::IIMethod(_, _, m) => ast_util::method_ident(&*m),\n         };\n         debug!(\"Fn named: {}\", token::get_ident(ident));\n         debug!(\"< Decoded inlined fn: {}::{}\",\n@@ -345,7 +345,9 @@ fn simplify_ast(ii: e::InlinedItemRef) -> ast::InlinedItem {\n         // HACK we're not dropping items.\n         e::IIItemRef(i) => ast::IIItem(fold::noop_fold_item(i, &mut fld)\n                                        .expect_one(\"expected one item\")),\n-        e::IIMethodRef(d, p, m) => ast::IIMethod(d, p, fold::noop_fold_method(m, &mut fld)),\n+        e::IIMethodRef(d, p, m) => ast::IIMethod(d, p, fold::noop_fold_method(m, &mut fld)\n+                                                 .expect_one(\n+                \"noop_fold_method must produce exactly one method\")),\n         e::IIForeignRef(i) => ast::IIForeign(fold::noop_fold_foreign_item(i, &mut fld))\n     }\n }\n@@ -387,7 +389,8 @@ fn renumber_and_map_ast(xcx: &ExtendedDecodeContext,\n                 ast::IIItem(fld.fold_item(i).expect_one(\"expected one item\"))\n             }\n             ast::IIMethod(d, is_provided, m) => {\n-                ast::IIMethod(xcx.tr_def_id(d), is_provided, fld.fold_method(m))\n+                ast::IIMethod(xcx.tr_def_id(d), is_provided, fld.fold_method(m)\n+                              .expect_one(\"expected one method\"))\n             }\n             ast::IIForeign(i) => ast::IIForeign(fld.fold_foreign_item(i))\n         }"}, {"sha": "d84c62f744edc21b4c49f1be1c03ce6f1ba6d4fc", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7a6208f2cc1bbe29dc42b21d27e98894b8bacc04/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a6208f2cc1bbe29dc42b21d27e98894b8bacc04/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=7a6208f2cc1bbe29dc42b21d27e98894b8bacc04", "patch": "@@ -22,6 +22,7 @@ use util::nodemap::NodeSet;\n use std::collections::HashSet;\n use syntax::ast;\n use syntax::ast_map;\n+use syntax::ast_util;\n use syntax::ast_util::{local_def, is_local};\n use syntax::attr::AttrMetaMethods;\n use syntax::attr;\n@@ -212,7 +213,7 @@ impl<'a> MarkSymbolVisitor<'a> {\n                 visit::walk_trait_method(self, &*trait_method, ctxt);\n             }\n             ast_map::NodeMethod(method) => {\n-                visit::walk_block(self, &*method.body, ctxt);\n+                visit::walk_block(self, ast_util::method_body(&*method), ctxt);\n             }\n             ast_map::NodeForeignItem(foreign_item) => {\n                 visit::walk_foreign_item(self, &*foreign_item, ctxt);\n@@ -520,7 +521,8 @@ impl<'a> Visitor<()> for DeadVisitor<'a> {\n     // Overwrite so that we don't warn the trait method itself.\n     fn visit_trait_method(&mut self, trait_method: &ast::TraitMethod, _: ()) {\n         match *trait_method {\n-            ast::Provided(ref method) => visit::walk_block(self, &*method.body, ()),\n+            ast::Provided(ref method) => visit::walk_block(self,\n+                                                           ast_util::method_body(&**method), ()),\n             ast::Required(_) => ()\n         }\n     }"}, {"sha": "415135a2d048f04ff4bb8ec38207b35fa03d7279", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7a6208f2cc1bbe29dc42b21d27e98894b8bacc04/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a6208f2cc1bbe29dc42b21d27e98894b8bacc04/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=7a6208f2cc1bbe29dc42b21d27e98894b8bacc04", "patch": "@@ -17,6 +17,7 @@ use middle::typeck::MethodCall;\n use util::ppaux;\n \n use syntax::ast;\n+use syntax::ast_util;\n use syntax::codemap::Span;\n use syntax::visit;\n use syntax::visit::Visitor;\n@@ -94,7 +95,7 @@ impl<'a> Visitor<()> for EffectCheckVisitor<'a> {\n             visit::FkItemFn(_, _, fn_style, _) =>\n                 (true, fn_style == ast::UnsafeFn),\n             visit::FkMethod(_, _, method) =>\n-                (true, method.fn_style == ast::UnsafeFn),\n+                (true, ast_util::method_fn_style(method) == ast::UnsafeFn),\n             _ => (false, false),\n         };\n "}, {"sha": "580e7b2db57c294a772070b04eba0189916541db", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/7a6208f2cc1bbe29dc42b21d27e98894b8bacc04/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a6208f2cc1bbe29dc42b21d27e98894b8bacc04/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=7a6208f2cc1bbe29dc42b21d27e98894b8bacc04", "patch": "@@ -26,6 +26,7 @@ use util::nodemap::{NodeMap, NodeSet};\n \n use syntax::ast;\n use syntax::ast_map;\n+use syntax::ast_util;\n use syntax::ast_util::{is_local, local_def};\n use syntax::attr;\n use syntax::codemap::Span;\n@@ -263,10 +264,10 @@ impl<'a> Visitor<()> for EmbargoVisitor<'a> {\n \n                 if public_ty || public_trait {\n                     for method in methods.iter() {\n-                        let meth_public = match method.explicit_self.node {\n+                        let meth_public = match ast_util::method_explicit_self(&**method).node {\n                             ast::SelfStatic => public_ty,\n                             _ => true,\n-                        } && method.vis == ast::Public;\n+                        } && ast_util::method_vis(&**method) == ast::Public;\n                         if meth_public || tr.is_some() {\n                             self.exported_items.insert(method.id);\n                         }\n@@ -456,8 +457,8 @@ impl<'a> PrivacyVisitor<'a> {\n                     let imp = self.tcx.map.get_parent_did(closest_private_id);\n                     match ty::impl_trait_ref(self.tcx, imp) {\n                         Some(..) => return Allowable,\n-                        _ if m.vis == ast::Public => return Allowable,\n-                        _ => m.vis\n+                        _ if ast_util::method_vis(&**m) == ast::Public => return Allowable,\n+                        _ => ast_util::method_vis(&**m)\n                     }\n                 }\n                 Some(ast_map::NodeTraitMethod(_)) => {\n@@ -1078,7 +1079,7 @@ impl<'a> SanePrivacyVisitor<'a> {\n                                 \"visibility qualifiers have no effect on trait \\\n                                  impls\");\n                 for m in methods.iter() {\n-                    check_inherited(m.span, m.vis, \"\");\n+                    check_inherited(m.span, ast_util::method_vis(&**m), \"\");\n                 }\n             }\n \n@@ -1110,7 +1111,7 @@ impl<'a> SanePrivacyVisitor<'a> {\n                 for m in methods.iter() {\n                     match *m {\n                         ast::Provided(ref m) => {\n-                            check_inherited(m.span, m.vis,\n+                            check_inherited(m.span, ast_util::method_vis(&**m),\n                                             \"unnecessary visibility\");\n                         }\n                         ast::Required(ref m) => {\n@@ -1148,7 +1149,7 @@ impl<'a> SanePrivacyVisitor<'a> {\n         match item.node {\n             ast::ItemImpl(_, _, _, ref methods) => {\n                 for m in methods.iter() {\n-                    check_inherited(tcx, m.span, m.vis);\n+                    check_inherited(tcx, m.span, ast_util::method_vis(&**m));\n                 }\n             }\n             ast::ItemForeignMod(ref fm) => {\n@@ -1174,7 +1175,7 @@ impl<'a> SanePrivacyVisitor<'a> {\n                     match *m {\n                         ast::Required(..) => {}\n                         ast::Provided(ref m) => check_inherited(tcx, m.span,\n-                                                                m.vis),\n+                                                                ast_util::method_vis(&**m)),\n                     }\n                 }\n             }\n@@ -1344,7 +1345,7 @@ impl<'a> Visitor<()> for VisiblePrivateTypesVisitor<'a> {\n                     // methods will be visible as `Public::foo`.\n                     let mut found_pub_static = false;\n                     for method in methods.iter() {\n-                        if method.explicit_self.node == ast::SelfStatic &&\n+                        if ast_util::method_explicit_self(&**method).node == ast::SelfStatic &&\n                             self.exported_items.contains(&method.id) {\n                             found_pub_static = true;\n                             visit::walk_method_helper(self, &**method, ());"}, {"sha": "d9324574da73f78a4afd9de153ac5c026831c1b3", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7a6208f2cc1bbe29dc42b21d27e98894b8bacc04/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a6208f2cc1bbe29dc42b21d27e98894b8bacc04/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=7a6208f2cc1bbe29dc42b21d27e98894b8bacc04", "patch": "@@ -68,7 +68,7 @@ fn item_might_be_inlined(item: &ast::Item) -> bool {\n fn method_might_be_inlined(tcx: &ty::ctxt, method: &ast::Method,\n                            impl_src: ast::DefId) -> bool {\n     if attributes_specify_inlining(method.attrs.as_slice()) ||\n-        generics_require_inlining(&method.generics) {\n+        generics_require_inlining(ast_util::method_generics(&*method)) {\n         return true\n     }\n     if is_local(impl_src) {\n@@ -200,7 +200,7 @@ impl<'a> ReachableContext<'a> {\n                 }\n             }\n             Some(ast_map::NodeMethod(method)) => {\n-                if generics_require_inlining(&method.generics) ||\n+                if generics_require_inlining(ast_util::method_generics(&*method)) ||\n                         attributes_specify_inlining(method.attrs.as_slice()) {\n                     true\n                 } else {\n@@ -316,14 +316,14 @@ impl<'a> ReachableContext<'a> {\n                         // Keep going, nothing to get exported\n                     }\n                     ast::Provided(ref method) => {\n-                        visit::walk_block(self, &*method.body, ())\n+                        visit::walk_block(self, ast_util::method_body(&**method), ())\n                     }\n                 }\n             }\n             ast_map::NodeMethod(method) => {\n                 let did = self.tcx.map.get_parent_did(search_item);\n                 if method_might_be_inlined(self.tcx, &*method, did) {\n-                    visit::walk_block(self, &*method.body, ())\n+                    visit::walk_block(self, ast_util::method_body(&*method), ())\n                 }\n             }\n             // Nothing to recurse on for these"}, {"sha": "6c6ac81b985303ba6b3dd38eb8a67bf8841953e5", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/7a6208f2cc1bbe29dc42b21d27e98894b8bacc04/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a6208f2cc1bbe29dc42b21d27e98894b8bacc04/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=7a6208f2cc1bbe29dc42b21d27e98894b8bacc04", "patch": "@@ -22,6 +22,7 @@ use util::nodemap::{NodeMap, DefIdSet, FnvHashMap};\n \n use syntax::ast::*;\n use syntax::ast;\n+use syntax::ast_util;\n use syntax::ast_util::{local_def};\n use syntax::ast_util::{walk_pat, trait_method_to_ty_method};\n use syntax::ext::mtwt;\n@@ -1298,20 +1299,20 @@ impl<'a> Resolver<'a> {\n                         // For each method...\n                         for method in methods.iter() {\n                             // Add the method to the module.\n-                            let ident = method.ident;\n+                            let ident = ast_util::method_ident(&**method);\n                             let method_name_bindings =\n                                 self.add_child(ident,\n                                                new_parent.clone(),\n                                                ForbidDuplicateValues,\n                                                method.span);\n-                            let def = match method.explicit_self.node {\n+                            let def = match ast_util::method_explicit_self(&**method).node {\n                                 SelfStatic => {\n                                     // Static methods become\n                                     // `def_static_method`s.\n                                     DefStaticMethod(local_def(method.id),\n                                                       FromImpl(local_def(\n                                                         item.id)),\n-                                                      method.fn_style)\n+                                                    ast_util::method_fn_style(&**method))\n                                 }\n                                 _ => {\n                                     // Non-static methods become\n@@ -1320,7 +1321,7 @@ impl<'a> Resolver<'a> {\n                                 }\n                             };\n \n-                            let is_public = method.vis == ast::Public;\n+                            let is_public = ast_util::method_vis(&**method) == ast::Public;\n                             method_name_bindings.define_value(def,\n                                                               method.span,\n                                                               is_public);\n@@ -4003,13 +4004,15 @@ impl<'a> Resolver<'a> {\n     fn resolve_method(&mut self,\n                       rib_kind: RibKind,\n                       method: &Method) {\n-        let method_generics = &method.generics;\n+        let method_generics = ast_util::method_generics(method);\n         let type_parameters = HasTypeParameters(method_generics,\n                                                 FnSpace,\n                                                 method.id,\n                                                 rib_kind);\n \n-        self.resolve_function(rib_kind, Some(method.decl), type_parameters, method.body);\n+        self.resolve_function(rib_kind, Some(ast_util::method_fn_decl(method)),\n+                              type_parameters,\n+                              ast_util::method_body(method));\n     }\n \n     fn with_current_self_type<T>(&mut self, self_type: &Ty, f: |&mut Resolver| -> T) -> T {\n@@ -4080,7 +4083,7 @@ impl<'a> Resolver<'a> {\n     fn check_trait_method(&self, method: &Method) {\n         // If there is a TraitRef in scope for an impl, then the method must be in the trait.\n         for &(did, ref trait_ref) in self.current_trait_ref.iter() {\n-            let method_name = method.ident.name;\n+            let method_name = ast_util::method_ident(method).name;\n \n             if self.method_map.borrow().find(&(method_name, did)).is_none() {\n                 let path_str = self.path_idents_to_string(&trait_ref.path);"}, {"sha": "a492b4ab9525e193ef67e9dced2af4aa342d8db7", "filename": "src/librustc/middle/save/mod.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7a6208f2cc1bbe29dc42b21d27e98894b8bacc04/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a6208f2cc1bbe29dc42b21d27e98894b8bacc04/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs?ref=7a6208f2cc1bbe29dc42b21d27e98894b8bacc04", "patch": "@@ -333,7 +333,7 @@ impl <'l> DxrVisitor<'l> {\n             },\n         };\n \n-        qualname.push_str(get_ident(method.ident).get());\n+        qualname.push_str(get_ident(ast_util::method_ident(&*method)).get());\n         let qualname = qualname.as_slice();\n \n         // record the decl for this def (if it has one)\n@@ -349,17 +349,18 @@ impl <'l> DxrVisitor<'l> {\n                             decl_id,\n                             scope_id);\n \n-        self.process_formals(&method.decl.inputs, qualname, e);\n+        let m_decl = ast_util::method_fn_decl(&*method);\n+        self.process_formals(&m_decl.inputs, qualname, e);\n \n         // walk arg and return types\n-        for arg in method.decl.inputs.iter() {\n+        for arg in m_decl.inputs.iter() {\n             self.visit_ty(&*arg.ty, e);\n         }\n-        self.visit_ty(&*method.decl.output, e);\n+        self.visit_ty(m_decl.output, e);\n         // walk the fn body\n-        self.visit_block(&*method.body, DxrVisitorEnv::new_nested(method.id));\n+        self.visit_block(ast_util::method_body(&*method), DxrVisitorEnv::new_nested(method.id));\n \n-        self.process_generic_params(&method.generics,\n+        self.process_generic_params(ast_util::method_generics(&*method),\n                                     method.span,\n                                     qualname,\n                                     method.id,"}, {"sha": "e3af8f93eadb3590ea50dc40d2ee9a32be786736", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7a6208f2cc1bbe29dc42b21d27e98894b8bacc04/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a6208f2cc1bbe29dc42b21d27e98894b8bacc04/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=7a6208f2cc1bbe29dc42b21d27e98894b8bacc04", "patch": "@@ -1138,10 +1138,10 @@ pub fn create_function_debug_context(cx: &CrateContext,\n             }\n         }\n         ast_map::NodeMethod(ref method) => {\n-            (method.ident,\n-             method.decl,\n-             &method.generics,\n-             method.body,\n+            (ast_util::method_ident(&**method),\n+             ast_util::method_fn_decl(&**method),\n+             ast_util::method_generics(&**method),\n+             ast_util::method_body(&**method),\n              method.span,\n              true)\n         }\n@@ -1167,10 +1167,10 @@ pub fn create_function_debug_context(cx: &CrateContext,\n         ast_map::NodeTraitMethod(ref trait_method) => {\n             match **trait_method {\n                 ast::Provided(ref method) => {\n-                    (method.ident,\n-                     method.decl,\n-                     &method.generics,\n-                     method.body,\n+                    (ast_util::method_ident(&**method),\n+                     ast_util::method_fn_decl(&**method),\n+                     ast_util::method_generics(&**method),\n+                     ast_util::method_body(&**method),\n                      method.span,\n                      true)\n                 }"}, {"sha": "f11577482b6dca9ceb3178a171047c53e5a4428b", "filename": "src/librustc/middle/trans/inline.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7a6208f2cc1bbe29dc42b21d27e98894b8bacc04/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a6208f2cc1bbe29dc42b21d27e98894b8bacc04/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs?ref=7a6208f2cc1bbe29dc42b21d27e98894b8bacc04", "patch": "@@ -128,11 +128,12 @@ pub fn maybe_instantiate_inline(ccx: &CrateContext, fn_id: ast::DefId)\n             let impl_tpt = ty::lookup_item_type(ccx.tcx(), impl_did);\n             let unparameterized =\n                 impl_tpt.generics.types.is_empty() &&\n-                mth.generics.ty_params.is_empty();\n+                ast_util::method_generics(&*mth).ty_params.is_empty();\n \n           if unparameterized {\n               let llfn = get_item_val(ccx, mth.id);\n-              trans_fn(ccx, &*mth.decl, &*mth.body, llfn,\n+              trans_fn(ccx, ast_util::method_fn_decl(&*mth),\n+                       ast_util::method_body(&*mth), llfn,\n                        &param_substs::empty(), mth.id, []);\n           }\n           local_def(mth.id)"}, {"sha": "6b54556bbe0ac82644dd25adc68b60d532d9d9cc", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7a6208f2cc1bbe29dc42b21d27e98894b8bacc04/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a6208f2cc1bbe29dc42b21d27e98894b8bacc04/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=7a6208f2cc1bbe29dc42b21d27e98894b8bacc04", "patch": "@@ -38,7 +38,7 @@ use std::c_str::ToCStr;\n use std::gc::Gc;\n use syntax::abi::Rust;\n use syntax::parse::token;\n-use syntax::{ast, ast_map, visit};\n+use syntax::{ast, ast_map, visit, ast_util};\n \n /**\n The main \"translation\" pass for methods.  Generates code\n@@ -66,9 +66,10 @@ pub fn trans_impl(ccx: &CrateContext,\n         return;\n     }\n     for method in methods.iter() {\n-        if method.generics.ty_params.len() == 0u {\n+        if ast_util::method_generics(&**method).ty_params.len() == 0u {\n             let llfn = get_item_val(ccx, method.id);\n-            trans_fn(ccx, &*method.decl, &*method.body,\n+            trans_fn(ccx, ast_util::method_fn_decl(&**method),\n+                     ast_util::method_body(&**method),\n                      llfn, &param_substs::empty(), method.id, []);\n         } else {\n             let mut v = TransItemVisitor{ ccx: ccx };\n@@ -160,7 +161,7 @@ pub fn trans_static_method_callee(bcx: &Block,\n             ast_map::NodeTraitMethod(method) => {\n                 let ident = match *method {\n                     ast::Required(ref m) => m.ident,\n-                    ast::Provided(ref m) => m.ident\n+                    ast::Provided(ref m) => ast_util::method_ident(&**m)\n                 };\n                 ident.name\n             }"}, {"sha": "01544214ccf7ff51d3f4592e74984a8ad04c86df", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7a6208f2cc1bbe29dc42b21d27e98894b8bacc04/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a6208f2cc1bbe29dc42b21d27e98894b8bacc04/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=7a6208f2cc1bbe29dc42b21d27e98894b8bacc04", "patch": "@@ -25,6 +25,7 @@ use util::ppaux::Repr;\n use syntax::abi;\n use syntax::ast;\n use syntax::ast_map;\n+use syntax::ast_util;\n use syntax::ast_util::local_def;\n use std::hash::{sip, Hash};\n \n@@ -181,15 +182,17 @@ pub fn monomorphic_fn(ccx: &CrateContext,\n         ast_map::NodeMethod(mth) => {\n             let d = mk_lldecl();\n             set_llvm_fn_attrs(mth.attrs.as_slice(), d);\n-            trans_fn(ccx, &*mth.decl, &*mth.body, d, &psubsts, mth.id, []);\n+            trans_fn(ccx, ast_util::method_fn_decl(&*mth),\n+                     ast_util::method_body(&*mth), d, &psubsts, mth.id, []);\n             d\n         }\n         ast_map::NodeTraitMethod(method) => {\n             match *method {\n                 ast::Provided(mth) => {\n                     let d = mk_lldecl();\n                     set_llvm_fn_attrs(mth.attrs.as_slice(), d);\n-                    trans_fn(ccx, &*mth.decl, &*mth.body, d, &psubsts, mth.id, []);\n+                    trans_fn(ccx, ast_util::method_fn_decl(&*mth),\n+                             ast_util::method_body(&*mth), d, &psubsts, mth.id, []);\n                     d\n                 }\n                 _ => {"}, {"sha": "fb29baeea73f2c592d5ad99303d1e3865863b82d", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7a6208f2cc1bbe29dc42b21d27e98894b8bacc04/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a6208f2cc1bbe29dc42b21d27e98894b8bacc04/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=7a6208f2cc1bbe29dc42b21d27e98894b8bacc04", "patch": "@@ -757,14 +757,16 @@ fn check_method_body(ccx: &CrateCtxt,\n     let method_def_id = local_def(method.id);\n     let method_ty = ty::method(ccx.tcx, method_def_id);\n     let method_generics = &method_ty.generics;\n+    let m_body = ast_util::method_body(&*method);\n \n     let param_env = ty::construct_parameter_environment(ccx.tcx,\n                                                         method_generics,\n-                                                        method.body.id);\n+                                                        m_body.id);\n \n     let fty = ty::node_id_to_type(ccx.tcx, method.id);\n \n-    check_bare_fn(ccx, &*method.decl, &*method.body, method.id, fty, param_env);\n+    check_bare_fn(ccx, ast_util::method_fn_decl(&*method),\n+                  m_body, method.id, fty, param_env);\n }\n \n fn check_impl_methods_against_trait(ccx: &CrateCtxt,\n@@ -792,7 +794,7 @@ fn check_impl_methods_against_trait(ccx: &CrateCtxt,\n                 compare_impl_method(ccx.tcx,\n                                     &*impl_method_ty,\n                                     impl_method.span,\n-                                    impl_method.body.id,\n+                                    ast_util::method_body(&**impl_method).id,\n                                     &**trait_method_ty,\n                                     &impl_trait_ref.substs);\n             }\n@@ -815,7 +817,7 @@ fn check_impl_methods_against_trait(ccx: &CrateCtxt,\n     for trait_method in trait_methods.iter() {\n         let is_implemented =\n             impl_methods.iter().any(\n-                |m| m.ident.name == trait_method.ident.name);\n+                |m| ast_util::method_ident(&**m).name == trait_method.ident.name);\n         let is_provided =\n             provided_methods.iter().any(\n                 |m| m.ident.name == trait_method.ident.name);"}, {"sha": "9f08dc2c924839df6f62db371a154ca097300d08", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 17, "deletions": 12, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/7a6208f2cc1bbe29dc42b21d27e98894b8bacc04/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a6208f2cc1bbe29dc42b21d27e98894b8bacc04/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=7a6208f2cc1bbe29dc42b21d27e98894b8bacc04", "patch": "@@ -57,7 +57,8 @@ use syntax::ast::{StaticRegionTyParamBound, OtherRegionTyParamBound};\n use syntax::ast::{TraitTyParamBound, UnboxedFnTyParamBound};\n use syntax::ast;\n use syntax::ast_map;\n-use syntax::ast_util::{local_def, split_trait_methods};\n+use syntax::ast_util;\n+use syntax::ast_util::{local_def, method_ident, split_trait_methods};\n use syntax::codemap::Span;\n use syntax::codemap;\n use syntax::owned_slice::OwnedSlice;\n@@ -213,8 +214,11 @@ pub fn ensure_trait_methods(ccx: &CrateCtxt,\n                             &ast::Provided(ref m) => {\n                                 ty_method_of_trait_method(\n                                     ccx, trait_id, &trait_def.generics,\n-                                    &m.id, &m.ident, &m.explicit_self,\n-                                    &m.generics, &m.fn_style, &*m.decl)\n+                                    &m.id, &ast_util::method_ident(&**m),\n+                                    ast_util::method_explicit_self(&**m),\n+                                    ast_util::method_generics(&**m),\n+                                    &ast_util::method_fn_style(&**m),\n+                                    ast_util::method_fn_decl(&**m))\n                             }\n                         });\n \n@@ -330,7 +334,7 @@ fn convert_methods(ccx: &CrateCtxt,\n     let tcx = ccx.tcx;\n     let mut seen_methods = HashSet::new();\n     for m in ms.iter() {\n-        if !seen_methods.insert(m.ident.repr(ccx.tcx)) {\n+        if !seen_methods.insert(ast_util::method_ident(&**m).repr(tcx)) {\n             tcx.sess.span_err(m.span, \"duplicate method in trait impl\");\n         }\n \n@@ -342,9 +346,9 @@ fn convert_methods(ccx: &CrateCtxt,\n                                        rcvr_visibility));\n         let fty = ty::mk_bare_fn(tcx, mty.fty.clone());\n         debug!(\"method {} (id {}) has type {}\",\n-                m.ident.repr(ccx.tcx),\n+                method_ident(&**m).repr(tcx),\n                 m.id,\n-                fty.repr(ccx.tcx));\n+                fty.repr(tcx));\n         tcx.tcache.borrow_mut().insert(\n             local_def(m.id),\n             Polytype {\n@@ -365,23 +369,24 @@ fn convert_methods(ccx: &CrateCtxt,\n                     rcvr_visibility: ast::Visibility)\n                     -> ty::Method\n     {\n-        let fty = astconv::ty_of_method(ccx, m.id, m.fn_style,\n+        let fty = astconv::ty_of_method(ccx, m.id, ast_util::method_fn_style(&*m),\n                                         untransformed_rcvr_ty,\n-                                        m.explicit_self, &*m.decl);\n+                                        *ast_util::method_explicit_self(&*m),\n+                                        ast_util::method_fn_decl(&*m));\n \n         // if the method specifies a visibility, use that, otherwise\n         // inherit the visibility from the impl (so `foo` in `pub impl\n         // { fn foo(); }` is public, but private in `priv impl { fn\n         // foo(); }`).\n-        let method_vis = m.vis.inherit_from(rcvr_visibility);\n+        let method_vis = ast_util::method_vis(&*m).inherit_from(rcvr_visibility);\n \n         let m_ty_generics =\n-            ty_generics_for_fn_or_method(ccx, &m.generics,\n+            ty_generics_for_fn_or_method(ccx, ast_util::method_generics(&*m),\n                                          (*rcvr_ty_generics).clone());\n-        ty::Method::new(m.ident,\n+        ty::Method::new(ast_util::method_ident(&*m),\n                         m_ty_generics,\n                         fty,\n-                        m.explicit_self.node,\n+                        ast_util::method_explicit_self(&*m).node,\n                         method_vis,\n                         local_def(m.id),\n                         container,"}, {"sha": "bdd6d96f394a29131e357e47eeb9adf6aff022c7", "filename": "src/librustc/middle/typeck/infer/error_reporting.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7a6208f2cc1bbe29dc42b21d27e98894b8bacc04/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a6208f2cc1bbe29dc42b21d27e98894b8bacc04/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs?ref=7a6208f2cc1bbe29dc42b21d27e98894b8bacc04", "patch": "@@ -693,15 +693,18 @@ impl<'a> ErrorReporting for InferCtxt<'a> {\n             Some(ref node) => match *node {\n                 ast_map::NodeItem(ref item) => {\n                     match item.node {\n-                        ast::ItemFn(ref fn_decl, ref pur, _, ref gen, _) => {\n+                        ast::ItemFn(fn_decl, ref pur, _, ref gen, _) => {\n                             Some((fn_decl, gen, *pur, item.ident, None, item.span))\n                         },\n                         _ => None\n                     }\n                 }\n                 ast_map::NodeMethod(ref m) => {\n-                    Some((&m.decl, &m.generics, m.fn_style,\n-                          m.ident, Some(m.explicit_self.node), m.span))\n+                    Some((ast_util::method_fn_decl(&**m),\n+                          ast_util::method_generics(&**m),\n+                          ast_util::method_fn_style(&**m),\n+                          ast_util::method_ident(&**m),\n+                          Some(ast_util::method_explicit_self(&**m).node), m.span))\n                 },\n                 _ => None\n             },\n@@ -711,7 +714,7 @@ impl<'a> ErrorReporting for InferCtxt<'a> {\n                                     = node_inner.expect(\"expect item fn\");\n         let taken = lifetimes_in_scope(self.tcx, scope_id);\n         let life_giver = LifeGiver::with_taken(taken.as_slice());\n-        let rebuilder = Rebuilder::new(self.tcx, *fn_decl, expl_self,\n+        let rebuilder = Rebuilder::new(self.tcx, fn_decl, expl_self,\n                                        generics, same_regions, &life_giver);\n         let (fn_decl, expl_self, generics) = rebuilder.rebuild();\n         self.give_expl_lifetime_param(&fn_decl, fn_style, ident,\n@@ -1452,7 +1455,7 @@ fn lifetimes_in_scope(tcx: &ty::ctxt,\n                 _ => None\n             },\n             ast_map::NodeMethod(m) => {\n-                taken.push_all(m.generics.lifetimes.as_slice());\n+                taken.push_all(ast_util::method_generics(&*m).lifetimes.as_slice());\n                 Some(m.id)\n             },\n             _ => None"}, {"sha": "2e3bb2eef7d9df7b77f14a9f1895854ad0bcc5d9", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/7a6208f2cc1bbe29dc42b21d27e98894b8bacc04/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a6208f2cc1bbe29dc42b21d27e98894b8bacc04/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=7a6208f2cc1bbe29dc42b21d27e98894b8bacc04", "patch": "@@ -695,29 +695,30 @@ pub struct Method {\n \n impl Clean<Item> for ast::Method {\n     fn clean(&self) -> Item {\n-        let inputs = match self.explicit_self.node {\n-            ast::SelfStatic => self.decl.inputs.as_slice(),\n-            _ => self.decl.inputs.slice_from(1)\n+        let fn_decl = ast_util::method_fn_decl(self);\n+        let inputs = match ast_util::method_explicit_self(self).node {\n+            ast::SelfStatic => fn_decl.inputs.as_slice(),\n+            _ => fn_decl.inputs.slice_from(1)\n         };\n         let decl = FnDecl {\n             inputs: Arguments {\n                 values: inputs.iter().map(|x| x.clean()).collect(),\n             },\n-            output: (self.decl.output.clean()),\n-            cf: self.decl.cf.clean(),\n+            output: (fn_decl.output.clean()),\n+            cf: fn_decl.cf.clean(),\n             attrs: Vec::new()\n         };\n         Item {\n-            name: Some(self.ident.clean()),\n+            name: Some(ast_util::method_ident(self).clean()),\n             attrs: self.attrs.clean().move_iter().collect(),\n             source: self.span.clean(),\n             def_id: ast_util::local_def(self.id),\n-            visibility: self.vis.clean(),\n+            visibility: ast_util::method_vis(self).clean(),\n             stability: get_stability(ast_util::local_def(self.id)),\n             inner: MethodItem(Method {\n-                generics: self.generics.clean(),\n-                self_: self.explicit_self.node.clean(),\n-                fn_style: self.fn_style.clone(),\n+                generics: ast_util::method_generics(self).clean(),\n+                self_: ast_util::method_explicit_self(self).node.clean(),\n+                fn_style: ast_util::method_fn_style(self).clone(),\n                 decl: decl,\n             }),\n         }"}, {"sha": "c7154da494f7161ce2fd38627f0dfb56fb95aa9d", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/7a6208f2cc1bbe29dc42b21d27e98894b8bacc04/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a6208f2cc1bbe29dc42b21d27e98894b8bacc04/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=7a6208f2cc1bbe29dc42b21d27e98894b8bacc04", "patch": "@@ -640,6 +640,8 @@ pub type Mac = Spanned<Mac_>;\n /// There's only one flavor, now, so this could presumably be simplified.\n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n pub enum Mac_ {\n+    // NB: the additional ident for a macro_rules-style macro is actually\n+    // stored in the enclosing item. Oog.\n     MacInvocTT(Path, Vec<TokenTree> , SyntaxContext),   // new macro-invocation\n }\n \n@@ -957,19 +959,20 @@ pub enum ExplicitSelf_ {\n \n pub type ExplicitSelf = Spanned<ExplicitSelf_>;\n \n-// Represents a method declaration\n #[deriving(PartialEq, Eq, Encodable, Decodable, Hash)]\n pub struct Method {\n-    pub ident: Ident,\n     pub attrs: Vec<Attribute>,\n-    pub generics: Generics,\n-    pub explicit_self: ExplicitSelf,\n-    pub fn_style: FnStyle,\n-    pub decl: P<FnDecl>,\n-    pub body: P<Block>,\n     pub id: NodeId,\n     pub span: Span,\n-    pub vis: Visibility,\n+    pub node: Method_\n+}\n+\n+#[deriving(PartialEq, Eq, Encodable, Decodable, Hash)]\n+pub enum Method_ {\n+    /// Represents a method declaration\n+    MethDecl(Ident, Generics, ExplicitSelf, FnStyle, P<FnDecl>, P<Block>, Visibility),\n+    /// Represents a macro in method position\n+    MethMac(Mac),\n }\n \n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]"}, {"sha": "b8a0a31f9c3b64690356098b0ddb6d10074e9aa5", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 27, "deletions": 12, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/7a6208f2cc1bbe29dc42b21d27e98894b8bacc04/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a6208f2cc1bbe29dc42b21d27e98894b8bacc04/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=7a6208f2cc1bbe29dc42b21d27e98894b8bacc04", "patch": "@@ -304,8 +304,10 @@ impl Map {\n         }\n     }\n \n+    /// returns the name associated with the given NodeId's AST\n     pub fn get_path_elem(&self, id: NodeId) -> PathElem {\n-        match self.get(id) {\n+        let node = self.get(id);\n+        match node {\n             NodeItem(item) => {\n                 match item.node {\n                     ItemMod(_) | ItemForeignMod(_) => {\n@@ -315,13 +317,19 @@ impl Map {\n                 }\n             }\n             NodeForeignItem(i) => PathName(i.ident.name),\n-            NodeMethod(m) => PathName(m.ident.name),\n+            NodeMethod(m) => match m.node {\n+                MethDecl(ident, _, _, _, _, _, _) => PathName(ident.name),\n+                MethMac(_) => fail!(\"no path elem for {:?}\", node)\n+            },\n             NodeTraitMethod(tm) => match *tm {\n                 Required(ref m) => PathName(m.ident.name),\n-                Provided(ref m) => PathName(m.ident.name)\n+                Provided(m) => match m.node {\n+                    MethDecl(ident, _, _, _, _, _, _) => PathName(ident.name),\n+                    MethMac(_) => fail!(\"no path elem for {:?}\", node),\n+                }\n             },\n             NodeVariant(v) => PathName(v.node.name.name),\n-            node => fail!(\"no path elem for {:?}\", node)\n+            _ => fail!(\"no path elem for {:?}\", node)\n         }\n     }\n \n@@ -369,6 +377,8 @@ impl Map {\n         }\n     }\n \n+    /// Given a node ID and a closure, apply the closure to the array\n+    /// of attributes associated with the AST corresponding to the Node ID\n     pub fn with_attrs<T>(&self, id: NodeId, f: |Option<&[Attribute]>| -> T) -> T {\n         let node = self.get(id);\n         let attrs = match node {\n@@ -561,13 +571,14 @@ impl<'a, F: FoldOps> Folder for Ctx<'a, F> {\n         m\n     }\n \n-    fn fold_method(&mut self, m: Gc<Method>) -> Gc<Method> {\n+    fn fold_method(&mut self, m: Gc<Method>) -> SmallVector<Gc<Method>> {\n         let parent = self.parent;\n         self.parent = DUMMY_NODE_ID;\n-        let m = fold::noop_fold_method(&*m, self);\n+        let m = fold::noop_fold_method(&*m, self).expect_one(\n+            \"noop_fold_method must produce exactly one method\");\n         assert_eq!(self.parent, m.id);\n         self.parent = parent;\n-        m\n+        SmallVector::one(m)\n     }\n \n     fn fold_fn_decl(&mut self, decl: &FnDecl) -> P<FnDecl> {\n@@ -695,11 +706,15 @@ fn node_id_to_string(map: &Map, id: NodeId) -> String {\n             let path_str = map.path_to_str_with_ident(id, item.ident);\n             format!(\"foreign item {} (id={})\", path_str, id)\n         }\n-        Some(NodeMethod(m)) => {\n-            format!(\"method {} in {} (id={})\",\n-                    token::get_ident(m.ident),\n-                    map.path_to_string(id), id)\n-        }\n+        Some(NodeMethod(m)) => match m.node {\n+            MethDecl(ident, _, _, _, _, _, _) =>\n+                format!(\"method {} in {} (id={})\",\n+                        token::get_ident(ident),\n+                        map.path_to_string(id), id),\n+            MethMac(ref mac) =>\n+                format!(\"method macro {} (id={})\",\n+                        pprust::mac_to_string(mac), id)\n+        },\n         Some(NodeTraitMethod(ref tm)) => {\n             let m = ast_util::trait_method_to_ty_method(&**tm);\n             format!(\"method {} in {} (id={})\","}, {"sha": "a18d8a81ef47f7655b9cfb55a99d9656374ae54c", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 55, "deletions": 20, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/7a6208f2cc1bbe29dc42b21d27e98894b8bacc04/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a6208f2cc1bbe29dc42b21d27e98894b8bacc04/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=7a6208f2cc1bbe29dc42b21d27e98894b8bacc04", "patch": "@@ -240,32 +240,31 @@ pub fn impl_pretty_name(trait_ref: &Option<TraitRef>, ty: &Ty) -> Ident {\n     token::gensym_ident(pretty.as_slice())\n }\n \n-pub fn public_methods(ms: Vec<Gc<Method>> ) -> Vec<Gc<Method>> {\n-    ms.move_iter().filter(|m| {\n-        match m.vis {\n-            Public => true,\n-            _   => false\n-        }\n-    }).collect()\n-}\n-\n /// extract a TypeMethod from a TraitMethod. if the TraitMethod is\n /// a default, pull out the useful fields to make a TypeMethod\n+//\n+// NB: to be used only after expansion is complete, and macros are gone.\n pub fn trait_method_to_ty_method(method: &TraitMethod) -> TypeMethod {\n     match *method {\n         Required(ref m) => (*m).clone(),\n-        Provided(ref m) => {\n-            TypeMethod {\n-                ident: m.ident,\n-                attrs: m.attrs.clone(),\n-                fn_style: m.fn_style,\n-                decl: m.decl,\n-                generics: m.generics.clone(),\n-                explicit_self: m.explicit_self,\n-                id: m.id,\n-                span: m.span,\n-                vis: m.vis,\n+        Provided(m) => {\n+            match m.node {\n+                MethDecl(ident, ref generics, explicit_self, fn_style, decl, _, vis) => {\n+                    TypeMethod {\n+                        ident: ident,\n+                        attrs: m.attrs.clone(),\n+                        fn_style: fn_style,\n+                        decl: decl,\n+                        generics: generics.clone(),\n+                        explicit_self: explicit_self,\n+                        id: m.id,\n+                        span: m.span,\n+                        vis: vis,\n+                    }\n+                },\n+                MethMac(_) => fail!(\"expected non-macro method declaration\")\n             }\n+\n         }\n     }\n }\n@@ -346,6 +345,9 @@ pub trait IdVisitingOperation {\n     fn visit_id(&self, node_id: NodeId);\n }\n \n+/// A visitor that applies its operation to all of the node IDs\n+/// in a visitable thing.\n+\n pub struct IdVisitor<'a, O> {\n     pub operation: &'a O,\n     pub pass_through_items: bool,\n@@ -740,6 +742,38 @@ pub fn static_has_significant_address(mutbl: ast::Mutability,\n     inline == InlineNever || inline == InlineNone\n }\n \n+\n+/// Macro invocations are guaranteed not to occur after expansion is complete.\n+/// extracting fields of a method requires a dynamic check to make sure that it's\n+/// not a macro invocation, though this check is guaranteed to succeed, assuming\n+/// that the invocations are indeed gone.\n+macro_rules! method_field_extractor {\n+    ($fn_name:ident, $field_ty:ty, $field_pat:pat, $result:ident) => {\n+        /// Returns the ident of a Method. To be used after expansion is complete\n+        pub fn $fn_name<'a>(method: &'a ast::Method) -> $field_ty {\n+            match method.node {\n+                $field_pat => $result,\n+                MethMac(_) => {\n+                    fail!(\"expected an AST without macro invocations\");\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+// Note: this is unhygienic in the lifetime 'a. In order to fix this, we'd have to\n+// add :lifetime as a macro argument type, so that the 'a could be supplied by the macro\n+// invocation.\n+pub method_field_extractor!(method_ident,ast::Ident,MethDecl(ident,_,_,_,_,_,_),ident)\n+pub method_field_extractor!(method_generics,&'a ast::Generics,\n+                            MethDecl(_,ref generics,_,_,_,_,_),generics)\n+pub method_field_extractor!(method_explicit_self,&'a ast::ExplicitSelf,\n+                            MethDecl(_,_,ref explicit_self,_,_,_,_),explicit_self)\n+pub method_field_extractor!(method_fn_style,ast::FnStyle,MethDecl(_,_,_,fn_style,_,_,_),fn_style)\n+pub method_field_extractor!(method_fn_decl,P<ast::FnDecl>,MethDecl(_,_,_,_,decl,_,_),decl)\n+pub method_field_extractor!(method_body,P<ast::Block>,MethDecl(_,_,_,_,_,body,_),body)\n+pub method_field_extractor!(method_vis,ast::Visibility,MethDecl(_,_,_,_,_,_,vis),vis)\n+\n #[cfg(test)]\n mod test {\n     use ast::*;\n@@ -765,3 +799,4 @@ mod test {\n                 .iter().map(ident_to_segment).collect::<Vec<PathSegment>>().as_slice()));\n     }\n }\n+"}, {"sha": "56484c4ba59dfbbda0fd1d290ad5e269374260c3", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7a6208f2cc1bbe29dc42b21d27e98894b8bacc04/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a6208f2cc1bbe29dc42b21d27e98894b8bacc04/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=7a6208f2cc1bbe29dc42b21d27e98894b8bacc04", "patch": "@@ -104,6 +104,9 @@ pub type IdentMacroExpanderFn =\n /// just into the compiler's internal macro table, for `make_def`).\n pub trait MacResult {\n     /// Define a new macro.\n+    // this should go away; the idea that a macro might expand into\n+    // either a macro definition or an expression, depending on what\n+    // the context wants, is kind of silly.\n     fn make_def(&self) -> Option<MacroDef> {\n         None\n     }\n@@ -115,6 +118,12 @@ pub trait MacResult {\n     fn make_items(&self) -> Option<SmallVector<Gc<ast::Item>>> {\n         None\n     }\n+\n+    /// Create zero or more methods.\n+    fn make_methods(&self) -> Option<SmallVector<Gc<ast::Method>>> {\n+        None\n+    }\n+\n     /// Create a pattern.\n     fn make_pat(&self) -> Option<Gc<ast::Pat>> {\n         None\n@@ -222,6 +231,7 @@ impl DummyResult {\n             span: sp,\n         }\n     }\n+\n }\n \n impl MacResult for DummyResult {\n@@ -232,6 +242,14 @@ impl MacResult for DummyResult {\n         Some(DummyResult::raw_pat(self.span))\n     }\n     fn make_items(&self) -> Option<SmallVector<Gc<ast::Item>>> {\n+        // this code needs a comment... why not always just return the Some() ?\n+        if self.expr_only {\n+            None\n+        } else {\n+            Some(SmallVector::zero())\n+        }\n+    }\n+    fn make_methods(&self) -> Option<SmallVector<Gc<ast::Method>>> {\n         if self.expr_only {\n             None\n         } else {"}, {"sha": "46efdccadec8033d16b185da5a534b31dd8a316e", "filename": "src/libsyntax/ext/deriving/generic/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7a6208f2cc1bbe29dc42b21d27e98894b8bacc04/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a6208f2cc1bbe29dc42b21d27e98894b8bacc04/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs?ref=7a6208f2cc1bbe29dc42b21d27e98894b8bacc04", "patch": "@@ -648,16 +648,16 @@ impl<'a> MethodDef<'a> {\n \n         // Create the method.\n         box(GC) ast::Method {\n-            ident: method_ident,\n             attrs: self.attributes.clone(),\n-            generics: fn_generics,\n-            explicit_self: explicit_self,\n-            fn_style: ast::NormalFn,\n-            decl: fn_decl,\n-            body: body_block,\n             id: ast::DUMMY_NODE_ID,\n             span: trait_.span,\n-            vis: ast::Inherited,\n+            node: ast::MethDecl(method_ident,\n+                                fn_generics,\n+                                explicit_self,\n+                                ast::NormalFn,\n+                                fn_decl,\n+                                body_block,\n+                                ast::Inherited)\n         }\n     }\n "}, {"sha": "58689389769c9979b063793d3cc69131cd251c0a", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 162, "deletions": 170, "changes": 332, "blob_url": "https://github.com/rust-lang/rust/blob/7a6208f2cc1bbe29dc42b21d27e98894b8bacc04/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a6208f2cc1bbe29dc42b21d27e98894b8bacc04/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=7a6208f2cc1bbe29dc42b21d27e98894b8bacc04", "patch": "@@ -37,92 +37,28 @@ pub fn expand_expr(e: Gc<ast::Expr>, fld: &mut MacroExpander) -> Gc<ast::Expr> {\n         // expr_mac should really be expr_ext or something; it's the\n         // entry-point for all syntax extensions.\n         ExprMac(ref mac) => {\n-            match (*mac).node {\n-                // it would almost certainly be cleaner to pass the whole\n-                // macro invocation in, rather than pulling it apart and\n-                // marking the tts and the ctxt separately. This also goes\n-                // for the other three macro invocation chunks of code\n-                // in this file.\n-                // Token-tree macros:\n-                MacInvocTT(ref pth, ref tts, _) => {\n-                    if pth.segments.len() > 1u {\n-                        fld.cx.span_err(pth.span,\n-                                        \"expected macro name without module \\\n-                                         separators\");\n-                        // let compilation continue\n-                        return DummyResult::raw_expr(e.span);\n-                    }\n-                    let extname = pth.segments.get(0).identifier;\n-                    let extnamestr = token::get_ident(extname);\n-                    let marked_after = match fld.extsbox.find(&extname.name) {\n-                        None => {\n-                            fld.cx.span_err(\n-                                pth.span,\n-                                format!(\"macro undefined: '{}!'\",\n-                                        extnamestr.get()).as_slice());\n-\n-                            // let compilation continue\n-                            return DummyResult::raw_expr(e.span);\n-                        }\n-                        Some(&NormalTT(ref expandfun, exp_span)) => {\n-                            fld.cx.bt_push(ExpnInfo {\n-                                call_site: e.span,\n-                                callee: NameAndSpan {\n-                                    name: extnamestr.get().to_string(),\n-                                    format: MacroBang,\n-                                    span: exp_span,\n-                                },\n-                            });\n-                            let fm = fresh_mark();\n-                            // mark before:\n-                            let marked_before = mark_tts(tts.as_slice(), fm);\n-\n-                            // The span that we pass to the expanders we want to\n-                            // be the root of the call stack. That's the most\n-                            // relevant span and it's the actual invocation of\n-                            // the macro.\n-                            let mac_span = original_span(fld.cx);\n-\n-                            let expanded = match expandfun.expand(fld.cx,\n-                                                   mac_span.call_site,\n-                                                   marked_before.as_slice()).make_expr() {\n-                                Some(e) => e,\n-                                None => {\n-                                    fld.cx.span_err(\n-                                        pth.span,\n-                                        format!(\"non-expression macro in expression position: {}\",\n-                                                extnamestr.get().as_slice()\n-                                        ).as_slice());\n-                                    return DummyResult::raw_expr(e.span);\n-                                }\n-                            };\n+            let expanded_expr = match expand_mac_invoc(mac,&e.span,\n+                                                       |r|{r.make_expr()},\n+                                                       |expr,fm|{mark_expr(expr,fm)},\n+                                                       fld) {\n+                Some(expr) => expr,\n+                None => {\n+                    return DummyResult::raw_expr(e.span);\n+                }\n+            };\n \n-                            // mark after:\n-                            mark_expr(expanded,fm)\n-                        }\n-                        _ => {\n-                            fld.cx.span_err(\n-                                pth.span,\n-                                format!(\"'{}' is not a tt-style macro\",\n-                                        extnamestr.get()).as_slice());\n-                            return DummyResult::raw_expr(e.span);\n-                        }\n-                    };\n+            // Keep going, outside-in.\n+            //\n+            // FIXME(pcwalton): Is it necessary to clone the\n+            // node here?\n+            let fully_expanded =\n+                fld.fold_expr(expanded_expr).node.clone();\n+            fld.cx.bt_pop();\n \n-                    // Keep going, outside-in.\n-                    //\n-                    // FIXME(pcwalton): Is it necessary to clone the\n-                    // node here?\n-                    let fully_expanded =\n-                        fld.fold_expr(marked_after).node.clone();\n-                    fld.cx.bt_pop();\n-\n-                    box(GC) ast::Expr {\n-                        id: ast::DUMMY_NODE_ID,\n-                        node: fully_expanded,\n-                        span: e.span,\n-                    }\n-                }\n+            box(GC) ast::Expr {\n+                id: ast::DUMMY_NODE_ID,\n+                node: fully_expanded,\n+                span: e.span,\n             }\n         }\n \n@@ -246,6 +182,88 @@ pub fn expand_expr(e: Gc<ast::Expr>, fld: &mut MacroExpander) -> Gc<ast::Expr> {\n     }\n }\n \n+/// Expand a (not-ident-style) macro invocation. Returns the result\n+/// of expansion and the mark which must be applied to the result.\n+/// Our current interface doesn't allow us to apply the mark to the\n+/// result until after calling make_expr, make_items, etc.\n+fn expand_mac_invoc<T>(mac: &ast::Mac, span: &codemap::Span,\n+                       parse_thunk: |Box<MacResult>|->Option<T>,\n+                       mark_thunk: |T,Mrk|->T,\n+                       fld: &mut MacroExpander)\n+    -> Option<T> {\n+    match (*mac).node {\n+        // it would almost certainly be cleaner to pass the whole\n+        // macro invocation in, rather than pulling it apart and\n+        // marking the tts and the ctxt separately. This also goes\n+        // for the other three macro invocation chunks of code\n+        // in this file.\n+        // Token-tree macros:\n+        MacInvocTT(ref pth, ref tts, _) => {\n+            if pth.segments.len() > 1u {\n+                fld.cx.span_err(pth.span,\n+                                \"expected macro name without module \\\n+                                separators\");\n+                // let compilation continue\n+                return None;\n+            }\n+            let extname = pth.segments.get(0).identifier;\n+            let extnamestr = token::get_ident(extname);\n+            match fld.extsbox.find(&extname.name) {\n+                None => {\n+                    fld.cx.span_err(\n+                        pth.span,\n+                        format!(\"macro undefined: '{}!'\",\n+                                extnamestr.get()).as_slice());\n+\n+                    // let compilation continue\n+                    None\n+                }\n+                Some(&NormalTT(ref expandfun, exp_span)) => {\n+                    fld.cx.bt_push(ExpnInfo {\n+                            call_site: *span,\n+                            callee: NameAndSpan {\n+                                name: extnamestr.get().to_string(),\n+                                format: MacroBang,\n+                                span: exp_span,\n+                            },\n+                        });\n+                    let fm = fresh_mark();\n+                    let marked_before = mark_tts(tts.as_slice(), fm);\n+\n+                    // The span that we pass to the expanders we want to\n+                    // be the root of the call stack. That's the most\n+                    // relevant span and it's the actual invocation of\n+                    // the macro.\n+                    let mac_span = original_span(fld.cx);\n+\n+                    let expanded = expandfun.expand(fld.cx,\n+                                                    mac_span.call_site,\n+                                                    marked_before.as_slice());\n+                    let parsed = match parse_thunk(expanded) {\n+                        Some(e) => e,\n+                        None => {\n+                            fld.cx.span_err(\n+                                pth.span,\n+                                format!(\"non-expression macro in expression position: {}\",\n+                                        extnamestr.get().as_slice()\n+                                        ).as_slice());\n+                            return None;\n+                        }\n+                    };\n+                    Some(mark_thunk(parsed,fm))\n+                }\n+                _ => {\n+                    fld.cx.span_err(\n+                        pth.span,\n+                        format!(\"'{}' is not a tt-style macro\",\n+                                extnamestr.get()).as_slice());\n+                    None\n+                }\n+            }\n+        }\n+    }\n+}\n+\n /// Rename loop label and expand its loop body\n ///\n /// The renaming procedure for loop is different in the sense that the loop\n@@ -526,7 +544,7 @@ fn expand_item_mac(it: Gc<ast::Item>, fld: &mut MacroExpander)\n             match expanded.make_items() {\n                 Some(items) => {\n                     items.move_iter()\n-                        .flat_map(|i| mark_item(i, fm).move_iter())\n+                        .map(|i| mark_item(i, fm))\n                         .flat_map(|i| fld.fold_item(i).move_iter())\n                         .collect()\n                 }\n@@ -543,79 +561,27 @@ fn expand_item_mac(it: Gc<ast::Item>, fld: &mut MacroExpander)\n     return items;\n }\n \n-// expand a stmt\n+/// Expand a stmt\n+//\n+// I don't understand why this returns a vector... it looks like we're\n+// half done adding machinery to allow macros to expand into multiple statements.\n fn expand_stmt(s: &Stmt, fld: &mut MacroExpander) -> SmallVector<Gc<Stmt>> {\n-    // why the copying here and not in expand_expr?\n-    // looks like classic changed-in-only-one-place\n-    let (pth, tts, semi) = match s.node {\n-        StmtMac(ref mac, semi) => {\n-            match mac.node {\n-                MacInvocTT(ref pth, ref tts, _) => {\n-                    (pth, (*tts).clone(), semi)\n-                }\n-            }\n-        }\n+    let (mac, semi) = match s.node {\n+        StmtMac(ref mac, semi) => (mac, semi),\n         _ => return expand_non_macro_stmt(s, fld)\n     };\n-    if pth.segments.len() > 1u {\n-        fld.cx.span_err(pth.span, \"expected macro name without module separators\");\n-        return SmallVector::zero();\n-    }\n-    let extname = pth.segments.get(0).identifier;\n-    let extnamestr = token::get_ident(extname);\n-    let marked_after = match fld.extsbox.find(&extname.name) {\n+    let expanded_stmt = match expand_mac_invoc(mac,&s.span,\n+                                                |r|{r.make_stmt()},\n+                                                |sts,mrk|{mark_stmt(sts,mrk)},\n+                                                fld) {\n+        Some(stmt) => stmt,\n         None => {\n-            fld.cx.span_err(pth.span,\n-                            format!(\"macro undefined: '{}!'\",\n-                                    extnamestr).as_slice());\n-            return SmallVector::zero();\n-        }\n-\n-        Some(&NormalTT(ref expandfun, exp_span)) => {\n-            fld.cx.bt_push(ExpnInfo {\n-                call_site: s.span,\n-                callee: NameAndSpan {\n-                    name: extnamestr.get().to_string(),\n-                    format: MacroBang,\n-                    span: exp_span,\n-                }\n-            });\n-            let fm = fresh_mark();\n-            // mark before expansion:\n-            let marked_tts = mark_tts(tts.as_slice(), fm);\n-\n-            // See the comment in expand_expr for why we want the original span,\n-            // not the current mac.span.\n-            let mac_span = original_span(fld.cx);\n-\n-            let expanded = match expandfun.expand(fld.cx,\n-                                                  mac_span.call_site,\n-                                                  marked_tts.as_slice()).make_stmt() {\n-                Some(stmt) => stmt,\n-                None => {\n-                    fld.cx.span_err(pth.span,\n-                                    format!(\"non-statement macro in statement position: {}\",\n-                                            extnamestr).as_slice());\n-                    return SmallVector::zero();\n-                }\n-            };\n-\n-            mark_stmt(&*expanded,fm)\n-        }\n-\n-        _ => {\n-            fld.cx.span_err(pth.span, format!(\"'{}' is not a tt-style macro\",\n-                                              extnamestr).as_slice());\n             return SmallVector::zero();\n         }\n     };\n \n     // Keep going, outside-in.\n-    let fully_expanded = fld.fold_stmt(&*marked_after);\n-    if fully_expanded.is_empty() {\n-        fld.cx.span_err(pth.span, \"macro didn't expand to a statement\");\n-        return SmallVector::zero();\n-    }\n+    let fully_expanded = fld.fold_stmt(&*expanded_stmt);\n     fld.cx.bt_pop();\n     let fully_expanded: SmallVector<Gc<Stmt>> = fully_expanded.move_iter()\n             .map(|s| box(GC) Spanned { span: s.span, node: s.node.clone() })\n@@ -939,23 +905,42 @@ impl<'a> Folder for PatIdentRenamer<'a> {\n }\n \n // expand a method\n-fn expand_method(m: &ast::Method, fld: &mut MacroExpander) -> Gc<ast::Method> {\n+fn expand_method(m: &ast::Method, fld: &mut MacroExpander) -> SmallVector<Gc<ast::Method>> {\n     let id = fld.new_id(m.id);\n-    let (rewritten_fn_decl, rewritten_body)\n-        = expand_and_rename_fn_decl_and_block(m.decl,m.body,fld);\n-\n-    // all of the other standard stuff:\n-    box(GC) ast::Method {\n-        id: id,\n-        ident: fld.fold_ident(m.ident),\n-        attrs: m.attrs.iter().map(|a| fld.fold_attribute(*a)).collect(),\n-        generics: fold_generics(&m.generics, fld),\n-        explicit_self: fld.fold_explicit_self(&m.explicit_self),\n-        fn_style: m.fn_style,\n-        decl: rewritten_fn_decl,\n-        body: rewritten_body,\n-        span: fld.new_span(m.span),\n-        vis: m.vis\n+    match m.node {\n+        ast::MethDecl(ident, ref generics, ref explicit_self, fn_style, decl, body, vis) => {\n+            let (rewritten_fn_decl, rewritten_body)\n+                = expand_and_rename_fn_decl_and_block(decl,body,fld);\n+            SmallVector::one(box(GC) ast::Method {\n+                    attrs: m.attrs.iter().map(|a| fld.fold_attribute(*a)).collect(),\n+                    id: id,\n+                    span: fld.new_span(m.span),\n+                    node: ast::MethDecl(fld.fold_ident(ident),\n+                                        fold_generics(generics, fld),\n+                                        fld.fold_explicit_self(explicit_self),\n+                                        fn_style,\n+                                        rewritten_fn_decl,\n+                                        rewritten_body,\n+                                        vis)\n+                })\n+        },\n+        ast::MethMac(ref mac) => {\n+            let maybe_new_methods =\n+                expand_mac_invoc(mac, &m.span,\n+                                 |r|{r.make_methods()},\n+                                 |meths,mark|{\n+                    meths.move_iter().map(|m|{mark_method(m,mark)})\n+                        .collect()},\n+                                 fld);\n+\n+            let new_methods = match maybe_new_methods {\n+                Some(methods) => methods,\n+                None => SmallVector::zero()\n+            };\n+\n+            // expand again if necessary\n+            new_methods.move_iter().flat_map(|m| fld.fold_method(m).move_iter()).collect()\n+        }\n     }\n }\n \n@@ -1013,7 +998,7 @@ impl<'a, 'b> Folder for MacroExpander<'a, 'b> {\n         expand_arm(arm, self)\n     }\n \n-    fn fold_method(&mut self, method: Gc<ast::Method>) -> Gc<ast::Method> {\n+    fn fold_method(&mut self, method: Gc<ast::Method>) -> SmallVector<Gc<ast::Method>> {\n         expand_method(method, self)\n     }\n \n@@ -1128,12 +1113,19 @@ fn mark_pat(pat: Gc<ast::Pat>, m: Mrk) -> Gc<ast::Pat> {\n // apply a given mark to the given stmt. Used following the expansion of a macro.\n fn mark_stmt(expr: &ast::Stmt, m: Mrk) -> Gc<ast::Stmt> {\n     Marker{mark:m}.fold_stmt(expr)\n-            .expect_one(\"marking a stmt didn't return a stmt\")\n+        .expect_one(\"marking a stmt didn't return exactly one stmt\")\n }\n \n // apply a given mark to the given item. Used following the expansion of a macro.\n-fn mark_item(expr: Gc<ast::Item>, m: Mrk) -> SmallVector<Gc<ast::Item>> {\n+fn mark_item(expr: Gc<ast::Item>, m: Mrk) -> Gc<ast::Item> {\n     Marker{mark:m}.fold_item(expr)\n+        .expect_one(\"marking an item didn't return exactly one item\")\n+}\n+\n+// apply a given mark to the given item. Used following the expansion of a macro.\n+fn mark_method(expr: Gc<ast::Method>, m: Mrk) -> Gc<ast::Method> {\n+    Marker{mark:m}.fold_method(expr)\n+        .expect_one(\"marking an item didn't return exactly one method\")\n }\n \n fn original_span(cx: &ExtCtxt) -> Gc<codemap::ExpnInfo> {\n@@ -1527,9 +1519,9 @@ mod test {\n     }\n \n     // macro_rules in method position. Sadly, unimplemented.\n-    #[ignore] #[test] fn macro_in_method_posn(){\n+    #[test] fn macro_in_method_posn(){\n         expand_crate_str(\n-            \"macro_rules! my_method (() => fn thirteen(&self) -> int {13})\n+            \"macro_rules! my_method (() => (fn thirteen(&self) -> int {13}))\n             struct A;\n             impl A{ my_method!()}\n             fn f(){A.thirteen;}\".to_string());"}, {"sha": "1eb37abb781a3d73e2f111fe4ebe734b707feed7", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/7a6208f2cc1bbe29dc42b21d27e98894b8bacc04/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a6208f2cc1bbe29dc42b21d27e98894b8bacc04/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=7a6208f2cc1bbe29dc42b21d27e98894b8bacc04", "patch": "@@ -38,7 +38,7 @@ struct ParserAnyMacro<'a> {\n impl<'a> ParserAnyMacro<'a> {\n     /// Make sure we don't have any tokens left to parse, so we don't\n     /// silently drop anything. `allow_semi` is so that \"optional\"\n-    /// semilons at the end of normal expressions aren't complained\n+    /// semicolons at the end of normal expressions aren't complained\n     /// about e.g. the semicolon in `macro_rules! kapow( () => {\n     /// fail!(); } )` doesn't get picked up by .parse_expr(), but it's\n     /// allowed to be there.\n@@ -73,6 +73,9 @@ impl<'a> MacResult for ParserAnyMacro<'a> {\n         let mut ret = SmallVector::zero();\n         loop {\n             let mut parser = self.parser.borrow_mut();\n+            // so... do outer attributes attached to the macro invocation\n+            // just disappear? This question applies to make_methods, as\n+            // well.\n             match parser.parse_item_with_outer_attributes() {\n                 Some(item) => ret.push(item),\n                 None => break\n@@ -81,6 +84,20 @@ impl<'a> MacResult for ParserAnyMacro<'a> {\n         self.ensure_complete_parse(false);\n         Some(ret)\n     }\n+\n+    fn make_methods(&self) -> Option<SmallVector<Gc<ast::Method>>> {\n+        let mut ret = SmallVector::zero();\n+        loop {\n+            let mut parser = self.parser.borrow_mut();\n+            match parser.token {\n+                EOF => break,\n+                _ => ret.push(parser.parse_method(None))\n+            }\n+        }\n+        self.ensure_complete_parse(false);\n+        Some(ret)\n+    }\n+\n     fn make_stmt(&self) -> Option<Gc<ast::Stmt>> {\n         let attrs = self.parser.borrow_mut().parse_outer_attributes();\n         let ret = self.parser.borrow_mut().parse_stmt(attrs);"}, {"sha": "fd786192cb48c181745bf1ed0a7b7022ec9b2440", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 42, "deletions": 18, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/7a6208f2cc1bbe29dc42b21d27e98894b8bacc04/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a6208f2cc1bbe29dc42b21d27e98894b8bacc04/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=7a6208f2cc1bbe29dc42b21d27e98894b8bacc04", "patch": "@@ -114,7 +114,7 @@ pub trait Folder {\n         noop_fold_type_method(m, self)\n     }\n \n-    fn fold_method(&mut self, m: Gc<Method>) -> Gc<Method>  {\n+    fn fold_method(&mut self, m: Gc<Method>) -> SmallVector<Gc<Method>>  {\n         noop_fold_method(&*m, self)\n     }\n \n@@ -465,10 +465,16 @@ fn fold_interpolated<T: Folder>(nt : &token::Nonterminal, fld: &mut T) -> token:\n     match *nt {\n         token::NtItem(item) =>\n             token::NtItem(fld.fold_item(item)\n+                          // this is probably okay, because the only folds likely\n+                          // to peek inside interpolated nodes will be renamings/markings,\n+                          // which map single items to single items\n                           .expect_one(\"expected fold to produce exactly one item\")),\n         token::NtBlock(block) => token::NtBlock(fld.fold_block(block)),\n         token::NtStmt(stmt) =>\n             token::NtStmt(fld.fold_stmt(stmt)\n+                          // this is probably okay, because the only folds likely\n+                          // to peek inside interpolated nodes will be renamings/markings,\n+                          // which map single items to single items\n                           .expect_one(\"expected fold to produce exactly one statement\")),\n         token::NtPat(pat) => token::NtPat(fld.fold_pat(pat)),\n         token::NtExpr(expr) => token::NtExpr(fld.fold_expr(expr)),\n@@ -683,15 +689,26 @@ pub fn noop_fold_item_underscore<T: Folder>(i: &Item_, folder: &mut T) -> Item_\n             ItemImpl(fold_generics(generics, folder),\n                      ifce.as_ref().map(|p| fold_trait_ref(p, folder)),\n                      folder.fold_ty(ty),\n-                     methods.iter().map(|x| folder.fold_method(*x)).collect()\n+                     methods.iter().flat_map(|x| folder.fold_method(*x).move_iter()).collect()\n             )\n         }\n         ItemTrait(ref generics, ref unbound, ref traits, ref methods) => {\n-            let methods = methods.iter().map(|method| {\n-                match *method {\n-                    Required(ref m) => Required(folder.fold_type_method(m)),\n-                    Provided(method) => Provided(folder.fold_method(method))\n-                }\n+            let methods = methods.iter().flat_map(|method| {\n+                let r = match *method {\n+                    Required(ref m) =>\n+                            SmallVector::one(Required(folder.fold_type_method(m))).move_iter(),\n+                    Provided(method) => {\n+                            // the awkward collect/iter idiom here is because\n+                            // even though an iter and a map satisfy the same trait bound,\n+                            // they're not actually the same type, so the method arms\n+                            // don't unify.\n+                            let methods : SmallVector<ast::TraitMethod> =\n+                                folder.fold_method(method).move_iter()\n+                                .map(|m| Provided(m)).collect();\n+                            methods.move_iter()\n+                        }\n+                };\n+                r\n             }).collect();\n             ItemTrait(fold_generics(generics, folder),\n                       unbound.clone(),\n@@ -791,20 +808,27 @@ pub fn noop_fold_foreign_item<T: Folder>(ni: &ForeignItem,\n     }\n }\n \n-pub fn noop_fold_method<T: Folder>(m: &Method, folder: &mut T) -> Gc<Method> {\n+// Default fold over a method.\n+// Invariant: produces exactly one method.\n+pub fn noop_fold_method<T: Folder>(m: &Method, folder: &mut T) -> SmallVector<Gc<Method>> {\n     let id = folder.new_id(m.id); // Needs to be first, for ast_map.\n-    box(GC) Method {\n-        id: id,\n-        ident: folder.fold_ident(m.ident),\n+    SmallVector::one(box(GC) Method {\n         attrs: m.attrs.iter().map(|a| folder.fold_attribute(*a)).collect(),\n-        generics: fold_generics(&m.generics, folder),\n-        explicit_self: folder.fold_explicit_self(&m.explicit_self),\n-        fn_style: m.fn_style,\n-        decl: folder.fold_fn_decl(&*m.decl),\n-        body: folder.fold_block(m.body),\n+        id: id,\n         span: folder.new_span(m.span),\n-        vis: m.vis\n-    }\n+        node: match m.node {\n+            MethDecl(ident, ref generics, ref explicit_self, fn_style, decl, body, vis) => {\n+                MethDecl(folder.fold_ident(ident),\n+                         fold_generics(generics, folder),\n+                         folder.fold_explicit_self(explicit_self),\n+                         fn_style,\n+                         folder.fold_fn_decl(&*decl),\n+                         folder.fold_block(body),\n+                         vis)\n+            },\n+            MethMac(ref mac) => MethMac(folder.fold_mac(mac)),\n+        }\n+    })\n }\n \n pub fn noop_fold_pat<T: Folder>(p: Gc<Pat>, folder: &mut T) -> Gc<Pat> {"}, {"sha": "e0c94dffb5cae342603ddb9cf1fcdc6e9e9dc777", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 43, "deletions": 26, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/7a6208f2cc1bbe29dc42b21d27e98894b8bacc04/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a6208f2cc1bbe29dc42b21d27e98894b8bacc04/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=7a6208f2cc1bbe29dc42b21d27e98894b8bacc04", "patch": "@@ -1249,16 +1249,10 @@ impl<'a> Parser<'a> {\n                     p.parse_inner_attrs_and_block();\n                 let attrs = attrs.append(inner_attrs.as_slice());\n                 Provided(box(GC) ast::Method {\n-                    ident: ident,\n                     attrs: attrs,\n-                    generics: generics,\n-                    explicit_self: explicit_self,\n-                    fn_style: style,\n-                    decl: d,\n-                    body: body,\n                     id: ast::DUMMY_NODE_ID,\n                     span: mk_sp(lo, hi),\n-                    vis: vis,\n+                    node: ast::MethDecl(ident, generics, explicit_self, style, d, body, vis)\n                 })\n               }\n \n@@ -3252,6 +3246,7 @@ impl<'a> Parser<'a> {\n         } else if is_ident(&self.token)\n             && !token::is_any_keyword(&self.token)\n             && self.look_ahead(1, |t| *t == token::NOT) {\n+            // it's a macro invocation:\n \n             check_expected_item(self, !item_attrs.is_empty());\n \n@@ -4027,7 +4022,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse a method in a trait impl, starting with `attrs` attributes.\n-    fn parse_method(&mut self,\n+    pub fn parse_method(&mut self,\n                     already_parsed_attrs: Option<Vec<Attribute>>) -> Gc<Method> {\n         let next_attrs = self.parse_outer_attributes();\n         let attrs = match already_parsed_attrs {\n@@ -4037,28 +4032,50 @@ impl<'a> Parser<'a> {\n \n         let lo = self.span.lo;\n \n-        let visa = self.parse_visibility();\n-        let fn_style = self.parse_fn_style();\n-        let ident = self.parse_ident();\n-        let generics = self.parse_generics();\n-        let (explicit_self, decl) = self.parse_fn_decl_with_self(|p| {\n-            p.parse_arg()\n-        });\n+        // code copied from parse_macro_use_or_failure... abstraction!\n+        let (method_, hi, new_attrs) = {\n+            if !token::is_any_keyword(&self.token)\n+                && self.look_ahead(1, |t| *t == token::NOT)\n+                && (self.look_ahead(2, |t| *t == token::LPAREN)\n+                    || self.look_ahead(2, |t| *t == token::LBRACE)) {\n+                // method macro.\n+                let pth = self.parse_path(NoTypesAllowed).path;\n+                self.expect(&token::NOT);\n \n-        let (inner_attrs, body) = self.parse_inner_attrs_and_block();\n-        let hi = body.span.hi;\n-        let attrs = attrs.append(inner_attrs.as_slice());\n+                // eat a matched-delimiter token tree:\n+                let tts = match token::close_delimiter_for(&self.token) {\n+                    Some(ket) => {\n+                        self.bump();\n+                        self.parse_seq_to_end(&ket,\n+                                              seq_sep_none(),\n+                                              |p| p.parse_token_tree())\n+                    }\n+                    None => self.fatal(\"expected open delimiter\")\n+                };\n+                let m_ = ast::MacInvocTT(pth, tts, EMPTY_CTXT);\n+                let m: ast::Mac = codemap::Spanned { node: m_,\n+                                                 span: mk_sp(self.span.lo,\n+                                                             self.span.hi) };\n+                (ast::MethMac(m), self.span.hi, attrs)\n+            } else {\n+                let visa = self.parse_visibility();\n+                let fn_style = self.parse_fn_style();\n+                let ident = self.parse_ident();\n+                let generics = self.parse_generics();\n+                let (explicit_self, decl) = self.parse_fn_decl_with_self(|p| {\n+                        p.parse_arg()\n+                    });\n+                let (inner_attrs, body) = self.parse_inner_attrs_and_block();\n+                let new_attrs = attrs.append(inner_attrs.as_slice());\n+                (ast::MethDecl(ident, generics, explicit_self, fn_style, decl, body, visa),\n+                 body.span.hi, new_attrs)\n+            }\n+        };\n         box(GC) ast::Method {\n-            ident: ident,\n-            attrs: attrs,\n-            generics: generics,\n-            explicit_self: explicit_self,\n-            fn_style: fn_style,\n-            decl: decl,\n-            body: body,\n+            attrs: new_attrs,\n             id: ast::DUMMY_NODE_ID,\n             span: mk_sp(lo, hi),\n-            vis: visa,\n+            node: method_,\n         }\n     }\n "}, {"sha": "615a4489a73de46041e29694a90db51b2776e962", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 26, "deletions": 5, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/7a6208f2cc1bbe29dc42b21d27e98894b8bacc04/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a6208f2cc1bbe29dc42b21d27e98894b8bacc04/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=7a6208f2cc1bbe29dc42b21d27e98894b8bacc04", "patch": "@@ -245,6 +245,10 @@ pub fn arg_to_string(arg: &ast::Arg) -> String {\n     to_string(|s| s.print_arg(arg))\n }\n \n+pub fn mac_to_string(arg: &ast::Mac) -> String {\n+    to_string(|s| s.print_mac(arg))\n+}\n+\n pub fn visibility_qualified(vis: ast::Visibility, s: &str) -> String {\n     match vis {\n         ast::Public => format!(\"pub {}\", s),\n@@ -342,6 +346,7 @@ impl<'a> State<'a> {\n         match self.s.last_token() { pp::End => true, _ => false }\n     }\n \n+    // is this the beginning of a line?\n     pub fn is_bol(&mut self) -> bool {\n         self.s.last_token().is_eof() || self.s.last_token().is_hardbreak_tok()\n     }\n@@ -627,6 +632,7 @@ impl<'a> State<'a> {\n         }\n     }\n \n+    /// Pretty-print an item\n     pub fn print_item(&mut self, item: &ast::Item) -> IoResult<()> {\n         try!(self.hardbreak_if_not_bol());\n         try!(self.maybe_print_comment(item.span.lo));\n@@ -998,11 +1004,26 @@ impl<'a> State<'a> {\n         try!(self.hardbreak_if_not_bol());\n         try!(self.maybe_print_comment(meth.span.lo));\n         try!(self.print_outer_attributes(meth.attrs.as_slice()));\n-        try!(self.print_fn(&*meth.decl, Some(meth.fn_style), abi::Rust,\n-                        meth.ident, &meth.generics, Some(meth.explicit_self.node),\n-                        meth.vis));\n-        try!(word(&mut self.s, \" \"));\n-        self.print_block_with_attrs(&*meth.body, meth.attrs.as_slice())\n+        match meth.node {\n+            ast::MethDecl(ident, ref generics, ref explicit_self, fn_style, decl, body, vis) => {\n+                try!(self.print_fn(&*decl, Some(fn_style), abi::Rust,\n+                                   ident, generics, Some(explicit_self.node),\n+                                   vis));\n+                try!(word(&mut self.s, \" \"));\n+                self.print_block_with_attrs(&*body, meth.attrs.as_slice())\n+            },\n+            ast::MethMac(codemap::Spanned { node: ast::MacInvocTT(ref pth, ref tts, _),\n+                                            ..}) => {\n+                // code copied from ItemMac:\n+                try!(self.print_path(pth, false));\n+                try!(word(&mut self.s, \"! \"));\n+                try!(self.cbox(indent_unit));\n+                try!(self.popen());\n+                try!(self.print_tts(tts.as_slice()));\n+                try!(self.pclose());\n+                self.end()\n+            }\n+        }\n     }\n \n     pub fn print_outer_attributes(&mut self,"}, {"sha": "795f19d0cfb06170050fea6da1206a8e09390189", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 21, "deletions": 11, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/7a6208f2cc1bbe29dc42b21d27e98894b8bacc04/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a6208f2cc1bbe29dc42b21d27e98894b8bacc04/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=7a6208f2cc1bbe29dc42b21d27e98894b8bacc04", "patch": "@@ -560,15 +560,21 @@ pub fn walk_fn_decl<E: Clone, V: Visitor<E>>(visitor: &mut V,\n pub fn walk_method_helper<E: Clone, V: Visitor<E>>(visitor: &mut V,\n                                                    method: &Method,\n                                                    env: E) {\n-    visitor.visit_ident(method.span, method.ident, env.clone());\n-    visitor.visit_fn(&FkMethod(method.ident, &method.generics, method),\n-                     &*method.decl,\n-                     &*method.body,\n-                     method.span,\n-                     method.id,\n-                     env.clone());\n-    for attr in method.attrs.iter() {\n-        visitor.visit_attribute(attr, env.clone());\n+    match method.node {\n+        MethDecl(ident, ref generics, _, _, decl, body, _) => {\n+            visitor.visit_ident(method.span, ident, env.clone());\n+            visitor.visit_fn(&FkMethod(ident, generics, method),\n+                             decl,\n+                             body,\n+                             method.span,\n+                             method.id,\n+                             env.clone());\n+            for attr in method.attrs.iter() {\n+                visitor.visit_attribute(attr, env.clone());\n+            }\n+\n+        },\n+        MethMac(ref mac) => visitor.visit_mac(mac, env.clone())\n     }\n }\n \n@@ -586,8 +592,12 @@ pub fn walk_fn<E: Clone, V: Visitor<E>>(visitor: &mut V,\n         }\n         FkMethod(_, generics, method) => {\n             visitor.visit_generics(generics, env.clone());\n-\n-            visitor.visit_explicit_self(&method.explicit_self, env.clone());\n+            match method.node {\n+                MethDecl(_, _, ref explicit_self, _, _, _, _) =>\n+                    visitor.visit_explicit_self(explicit_self, env.clone()),\n+                MethMac(ref mac) =>\n+                    visitor.visit_mac(mac, env.clone())\n+            }\n         }\n         FkFnBlock(..) => {}\n     }"}, {"sha": "99d47e4bfc097dd8488fbf6fb96b3fed3410d10c", "filename": "src/test/run-pass/macro-method-issue-4621.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/7a6208f2cc1bbe29dc42b21d27e98894b8bacc04/src%2Ftest%2Frun-pass%2Fmacro-method-issue-4621.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a6208f2cc1bbe29dc42b21d27e98894b8bacc04/src%2Ftest%2Frun-pass%2Fmacro-method-issue-4621.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-method-issue-4621.rs?ref=7a6208f2cc1bbe29dc42b21d27e98894b8bacc04", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(macro_rules)]\n+\n+struct A;\n+\n+macro_rules! make_thirteen_method {() => (pub fn thirteen(&self)->int {13})}\n+impl A { make_thirteen_method!() }\n+\n+fn main() {\n+    assert_eq!(A.thirteen(),13);\n+}\n+\n+\n+"}]}