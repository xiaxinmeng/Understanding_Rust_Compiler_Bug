{"sha": "7738ff4927f9137793e3c08c4d9306e4876e32c5", "node_id": "C_kwDOAAsO6NoAKDc3MzhmZjQ5MjdmOTEzNzc5M2UzYzA4YzRkOTMwNmU0ODc2ZTMyYzU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-06-02T13:09:31Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-06-02T13:09:31Z"}, "message": "Auto merge of #14945 - justahero:gh-14626, r=Veykril\n\nFix Assist \"replace named generic type with impl trait\"\n\nThis is a follow-up PR to fix the assist \"replace named generic type with impl trait\" described in #14626 to filter invalid param types. It integrates the feedback given in PR #14816 .\n\nThe change updates the logic to determine when a function parameter is safe to replace a type param with its trait implementation. Some parameter definitions are invalid & should not be replaced by their traits, therefore skipping the assist completely.\n\nFirst, all usages of the generic type under the cursor are determined. These usage references are checked to see if they occur outside the function parameter list. If an outside reference is found, e.g. in body, return type or where clause, the assist is skipped. All remaining usages need to appear only in the function param list. For each usage the param type is further inspected to see if it's valid. The logic to determine if a function parameter is valid, follows a heuristic and may not cover all possible parameter definitions.\n\nWith this change the following param types (as given in [this comment](https://github.com/rust-lang/rust-analyzer/pull/14816#discussion_r1206834603)) are not replaced & therefore skip the assist.\n\n```rust\nfn foo<P: Trait>(\n    _: <P as Trait>::Assoc,          // within path type qualifier\n    _: <() as OtherTrait<P>>::Assoc, // same as above\n    _: P::Assoc,                     // associated type shorthand\n    _: impl OtherTrait<P>            // generic arg in impl trait (note that associated type bindings are fine)\n    _: &dyn Fn(P)                    // param type and/or return type for Fn* traits\n) {}\n```", "tree": {"sha": "d74f4302c87cbc245a7d9e9ef77c2d670148a4ed", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d74f4302c87cbc245a7d9e9ef77c2d670148a4ed"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7738ff4927f9137793e3c08c4d9306e4876e32c5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7738ff4927f9137793e3c08c4d9306e4876e32c5", "html_url": "https://github.com/rust-lang/rust/commit/7738ff4927f9137793e3c08c4d9306e4876e32c5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7738ff4927f9137793e3c08c4d9306e4876e32c5/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0677c204ca9482f12a7ee6b5ef9e64957dfee343", "url": "https://api.github.com/repos/rust-lang/rust/commits/0677c204ca9482f12a7ee6b5ef9e64957dfee343", "html_url": "https://github.com/rust-lang/rust/commit/0677c204ca9482f12a7ee6b5ef9e64957dfee343"}, {"sha": "c0e9b5737153a15f15d400a26114ccb067a51e9d", "url": "https://api.github.com/repos/rust-lang/rust/commits/c0e9b5737153a15f15d400a26114ccb067a51e9d", "html_url": "https://github.com/rust-lang/rust/commit/c0e9b5737153a15f15d400a26114ccb067a51e9d"}], "stats": {"total": 238, "additions": 188, "deletions": 50}, "files": [{"sha": "e7b62d49bb81418c7c9ec5a1ee32695eb1352517", "filename": "crates/ide-assists/src/handlers/replace_named_generic_with_impl.rs", "status": "modified", "additions": 188, "deletions": 50, "changes": 238, "blob_url": "https://github.com/rust-lang/rust/blob/7738ff4927f9137793e3c08c4d9306e4876e32c5/crates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_named_generic_with_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7738ff4927f9137793e3c08c4d9306e4876e32c5/crates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_named_generic_with_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_named_generic_with_impl.rs?ref=7738ff4927f9137793e3c08c4d9306e4876e32c5", "patch": "@@ -2,13 +2,17 @@ use hir::Semantics;\n use ide_db::{\n     base_db::{FileId, FileRange},\n     defs::Definition,\n-    search::SearchScope,\n+    search::{SearchScope, UsageSearchResult},\n     RootDatabase,\n };\n use syntax::{\n-    ast::{self, make::impl_trait_type, HasGenericParams, HasName, HasTypeBounds},\n-    ted, AstNode,\n+    ast::{\n+        self, make::impl_trait_type, HasGenericParams, HasName, HasTypeBounds, Name, NameLike,\n+        PathType,\n+    },\n+    match_ast, ted, AstNode,\n };\n+use text_edit::TextRange;\n \n use crate::{AssistContext, AssistId, AssistKind, Assists};\n \n@@ -36,87 +40,131 @@ pub(crate) fn replace_named_generic_with_impl(\n     let type_bound_list = type_param.type_bound_list()?;\n \n     let fn_ = type_param.syntax().ancestors().find_map(ast::Fn::cast)?;\n-    let params = fn_\n-        .param_list()?\n-        .params()\n-        .filter_map(|param| {\n-            // function parameter type needs to match generic type name\n-            if let ast::Type::PathType(path_type) = param.ty()? {\n-                let left = path_type.path()?.segment()?.name_ref()?.ident_token()?.to_string();\n-                let right = type_param_name.to_string();\n-                if left == right {\n-                    Some(param)\n-                } else {\n-                    None\n-                }\n-            } else {\n-                None\n-            }\n-        })\n-        .collect::<Vec<_>>();\n-\n-    if params.is_empty() {\n-        return None;\n-    }\n+    let param_list_text_range = fn_.param_list()?.syntax().text_range();\n \n     let type_param_hir_def = ctx.sema.to_def(&type_param)?;\n     let type_param_def = Definition::GenericParam(hir::GenericParam::TypeParam(type_param_hir_def));\n \n-    if is_referenced_outside(&ctx.sema, type_param_def, &fn_, ctx.file_id()) {\n+    // get all usage references for the type param\n+    let usage_refs = find_usages(&ctx.sema, &fn_, type_param_def, ctx.file_id());\n+    if usage_refs.is_empty() {\n         return None;\n     }\n \n+    // All usage references need to be valid (inside the function param list)\n+    if !check_valid_usages(&usage_refs, param_list_text_range) {\n+        return None;\n+    }\n+\n+    let mut path_types_to_replace = Vec::new();\n+    for (_a, refs) in usage_refs.iter() {\n+        for usage_ref in refs {\n+            let param_node = find_path_type(&ctx.sema, &type_param_name, &usage_ref.name)?;\n+            path_types_to_replace.push(param_node);\n+        }\n+    }\n+\n     let target = type_param.syntax().text_range();\n \n     acc.add(\n         AssistId(\"replace_named_generic_with_impl\", AssistKind::RefactorRewrite),\n-        \"Replace named generic with impl\",\n+        \"Replace named generic with impl trait\",\n         target,\n         |edit| {\n             let type_param = edit.make_mut(type_param);\n             let fn_ = edit.make_mut(fn_);\n \n-            // get all params\n-            let param_types = params\n-                .iter()\n-                .filter_map(|param| match param.ty() {\n-                    Some(ast::Type::PathType(param_type)) => Some(edit.make_mut(param_type)),\n-                    _ => None,\n-                })\n+            let path_types_to_replace = path_types_to_replace\n+                .into_iter()\n+                .map(|param| edit.make_mut(param))\n                 .collect::<Vec<_>>();\n \n+            // remove trait from generic param list\n             if let Some(generic_params) = fn_.generic_param_list() {\n                 generic_params.remove_generic_param(ast::GenericParam::TypeParam(type_param));\n                 if generic_params.generic_params().count() == 0 {\n                     ted::remove(generic_params.syntax());\n                 }\n             }\n \n-            // get type bounds in signature type: `P` -> `impl AsRef<Path>`\n             let new_bounds = impl_trait_type(type_bound_list);\n-            for param_type in param_types.iter().rev() {\n-                ted::replace(param_type.syntax(), new_bounds.clone_for_update().syntax());\n+            for path_type in path_types_to_replace.iter().rev() {\n+                ted::replace(path_type.syntax(), new_bounds.clone_for_update().syntax());\n             }\n         },\n     )\n }\n \n-fn is_referenced_outside(\n+fn find_path_type(\n+    sema: &Semantics<'_, RootDatabase>,\n+    type_param_name: &Name,\n+    param: &NameLike,\n+) -> Option<PathType> {\n+    let path_type =\n+        sema.ancestors_with_macros(param.syntax().clone()).find_map(ast::PathType::cast)?;\n+\n+    // Ignore any path types that look like `P::Assoc`\n+    if path_type.path()?.as_single_name_ref()?.text() != type_param_name.text() {\n+        return None;\n+    }\n+\n+    let ancestors = sema.ancestors_with_macros(path_type.syntax().clone());\n+\n+    let mut in_generic_arg_list = false;\n+    let mut is_associated_type = false;\n+\n+    // walking the ancestors checks them in a heuristic way until the `Fn` node is reached.\n+    for ancestor in ancestors {\n+        match_ast! {\n+            match ancestor {\n+                ast::PathSegment(ps) => {\n+                    match ps.kind()? {\n+                        ast::PathSegmentKind::Name(_name_ref) => (),\n+                        ast::PathSegmentKind::Type { .. } => return None,\n+                        _ => return None,\n+                    }\n+                },\n+                ast::GenericArgList(_) => {\n+                    in_generic_arg_list = true;\n+                },\n+                ast::AssocTypeArg(_) => {\n+                    is_associated_type = true;\n+                },\n+                ast::ImplTraitType(_) => {\n+                    if in_generic_arg_list && !is_associated_type {\n+                        return None;\n+                    }\n+                },\n+                ast::DynTraitType(_) => {\n+                    if !is_associated_type {\n+                        return None;\n+                    }\n+                },\n+                ast::Fn(_) => return Some(path_type),\n+                _ => (),\n+            }\n+        }\n+    }\n+\n+    None\n+}\n+\n+/// Returns all usage references for the given type parameter definition.\n+fn find_usages(\n     sema: &Semantics<'_, RootDatabase>,\n-    type_param_def: Definition,\n     fn_: &ast::Fn,\n+    type_param_def: Definition,\n     file_id: FileId,\n-) -> bool {\n-    // limit search scope to function body & return type\n-    let search_ranges = vec![\n-        fn_.body().map(|body| body.syntax().text_range()),\n-        fn_.ret_type().map(|ret_type| ret_type.syntax().text_range()),\n-    ];\n-\n-    search_ranges.into_iter().flatten().any(|search_range| {\n-        let file_range = FileRange { file_id, range: search_range };\n-        !type_param_def.usages(sema).in_scope(SearchScope::file_range(file_range)).all().is_empty()\n-    })\n+) -> UsageSearchResult {\n+    let file_range = FileRange { file_id, range: fn_.syntax().text_range() };\n+    type_param_def.usages(sema).in_scope(SearchScope::file_range(file_range)).all()\n+}\n+\n+fn check_valid_usages(usages: &UsageSearchResult, param_list_range: TextRange) -> bool {\n+    usages\n+        .iter()\n+        .flat_map(|(_, usage_refs)| usage_refs)\n+        .all(|usage_ref| param_list_range.contains_range(usage_ref.range))\n }\n \n #[cfg(test)]\n@@ -152,6 +200,96 @@ mod tests {\n         );\n     }\n \n+    #[test]\n+    fn replace_generic_trait_applies_to_generic_arguments_in_params() {\n+        check_assist(\n+            replace_named_generic_with_impl,\n+            r#\"\n+            fn foo<P$0: Trait>(\n+                _: P,\n+                _: Option<P>,\n+                _: Option<Option<P>>,\n+                _: impl Iterator<Item = P>,\n+                _: &dyn Iterator<Item = P>,\n+            ) {}\n+            \"#,\n+            r#\"\n+            fn foo(\n+                _: impl Trait,\n+                _: Option<impl Trait>,\n+                _: Option<Option<impl Trait>>,\n+                _: impl Iterator<Item = impl Trait>,\n+                _: &dyn Iterator<Item = impl Trait>,\n+            ) {}\n+            \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn replace_generic_not_applicable_when_one_param_type_is_invalid() {\n+        check_assist_not_applicable(\n+            replace_named_generic_with_impl,\n+            r#\"\n+            fn foo<P$0: Trait>(\n+                _: i32,\n+                _: Option<P>,\n+                _: Option<Option<P>>,\n+                _: impl Iterator<Item = P>,\n+                _: &dyn Iterator<Item = P>,\n+                _: <P as Trait>::Assoc,\n+            ) {}\n+            \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn replace_generic_not_applicable_when_referenced_in_where_clause() {\n+        check_assist_not_applicable(\n+            replace_named_generic_with_impl,\n+            r#\"fn foo<P$0: Trait, I>() where I: FromRef<P> {}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn replace_generic_not_applicable_when_used_with_type_alias() {\n+        check_assist_not_applicable(\n+            replace_named_generic_with_impl,\n+            r#\"fn foo<P$0: Trait>(p: <P as Trait>::Assoc) {}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn replace_generic_not_applicable_when_used_as_argument_in_outer_trait_alias() {\n+        check_assist_not_applicable(\n+            replace_named_generic_with_impl,\n+            r#\"fn foo<P$0: Trait>(_: <() as OtherTrait<P>>::Assoc) {}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn replace_generic_not_applicable_with_inner_associated_type() {\n+        check_assist_not_applicable(\n+            replace_named_generic_with_impl,\n+            r#\"fn foo<P$0: Trait>(_: P::Assoc) {}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn replace_generic_not_applicable_when_passed_into_outer_impl_trait() {\n+        check_assist_not_applicable(\n+            replace_named_generic_with_impl,\n+            r#\"fn foo<P$0: Trait>(_: impl OtherTrait<P>) {}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn replace_generic_not_applicable_when_used_in_passed_function_parameter() {\n+        check_assist_not_applicable(\n+            replace_named_generic_with_impl,\n+            r#\"fn foo<P$0: Trait>(_: &dyn Fn(P)) {}\"#,\n+        );\n+    }\n+\n     #[test]\n     fn replace_generic_with_multiple_generic_params() {\n         check_assist("}]}