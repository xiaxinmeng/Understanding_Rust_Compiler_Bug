{"sha": "0a8629bff642c3c3b84bb644c0099194f063b627", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBhODYyOWJmZjY0MmMzYzNiODRiYjY0NGMwMDk5MTk0ZjA2M2I2Mjc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-06-11T16:11:20Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-06-11T16:11:20Z"}, "message": "Auto merge of #85885 - bjorn3:remove_box_region, r=cjgillot\n\nDon't use a generator for BoxedResolver\n\nThe generator is non-trivial and requires unsafe code anyway. Using regular unsafe code without a generator is much easier to follow.\n\nBased on #85810 as it touches rustc_interface too.", "tree": {"sha": "e4b4f060a7b452eabf45783d8f031a03907e08c3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e4b4f060a7b452eabf45783d8f031a03907e08c3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0a8629bff642c3c3b84bb644c0099194f063b627", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0a8629bff642c3c3b84bb644c0099194f063b627", "html_url": "https://github.com/rust-lang/rust/commit/0a8629bff642c3c3b84bb644c0099194f063b627", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0a8629bff642c3c3b84bb644c0099194f063b627/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dddebf94bccddaa7b8836380c1d90b34553d79d0", "url": "https://api.github.com/repos/rust-lang/rust/commits/dddebf94bccddaa7b8836380c1d90b34553d79d0", "html_url": "https://github.com/rust-lang/rust/commit/dddebf94bccddaa7b8836380c1d90b34553d79d0"}, {"sha": "4301d1ee7d9badf12a3e08d3642375ee754cdf03", "url": "https://api.github.com/repos/rust-lang/rust/commits/4301d1ee7d9badf12a3e08d3642375ee754cdf03", "html_url": "https://github.com/rust-lang/rust/commit/4301d1ee7d9badf12a3e08d3642375ee754cdf03"}], "stats": {"total": 306, "additions": 91, "deletions": 215}, "files": [{"sha": "eb6f4e8213ec711dac0b945cc5c2f751c9511451", "filename": "compiler/rustc_data_structures/src/box_region.rs", "status": "removed", "additions": 0, "deletions": 169, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/dddebf94bccddaa7b8836380c1d90b34553d79d0/compiler%2Frustc_data_structures%2Fsrc%2Fbox_region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dddebf94bccddaa7b8836380c1d90b34553d79d0/compiler%2Frustc_data_structures%2Fsrc%2Fbox_region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fbox_region.rs?ref=dddebf94bccddaa7b8836380c1d90b34553d79d0", "patch": "@@ -1,169 +0,0 @@\n-//! This module provides a way to deal with self-referential data.\n-//!\n-//! The main idea is to allocate such data in a generator frame and then\n-//! give access to it by executing user-provided closures inside that generator.\n-//! The module provides a safe abstraction for the latter task.\n-//!\n-//! The interface consists of two exported macros meant to be used together:\n-//! * `declare_box_region_type` wraps a generator inside a struct with `access`\n-//!   method which accepts closures.\n-//! * `box_region_allow_access` is a helper which should be called inside\n-//!   a generator to actually execute those closures.\n-\n-use std::marker::PhantomData;\n-use std::ops::{Generator, GeneratorState};\n-use std::pin::Pin;\n-\n-#[derive(Copy, Clone)]\n-pub struct AccessAction(*mut dyn FnMut());\n-\n-impl AccessAction {\n-    pub fn get(self) -> *mut dyn FnMut() {\n-        self.0\n-    }\n-}\n-\n-#[derive(Copy, Clone)]\n-pub enum Action {\n-    Initial,\n-    Access(AccessAction),\n-    Complete,\n-}\n-\n-pub struct PinnedGenerator<I, A, R> {\n-    generator: Pin<Box<dyn Generator<Action, Yield = YieldType<I, A>, Return = R>>>,\n-}\n-\n-impl<I, A, R> PinnedGenerator<I, A, R> {\n-    pub fn new<T: Generator<Action, Yield = YieldType<I, A>, Return = R> + 'static>(\n-        generator: T,\n-    ) -> (I, Self) {\n-        let mut result = PinnedGenerator { generator: Box::pin(generator) };\n-\n-        // Run it to the first yield to set it up\n-        let init = match Pin::new(&mut result.generator).resume(Action::Initial) {\n-            GeneratorState::Yielded(YieldType::Initial(y)) => y,\n-            _ => panic!(),\n-        };\n-\n-        (init, result)\n-    }\n-\n-    pub unsafe fn access(&mut self, closure: *mut dyn FnMut()) {\n-        // Call the generator, which in turn will call the closure\n-        if let GeneratorState::Complete(_) =\n-            Pin::new(&mut self.generator).resume(Action::Access(AccessAction(closure)))\n-        {\n-            panic!()\n-        }\n-    }\n-\n-    pub fn complete(&mut self) -> R {\n-        // Tell the generator we want it to complete, consuming it and yielding a result\n-        let result = Pin::new(&mut self.generator).resume(Action::Complete);\n-        if let GeneratorState::Complete(r) = result { r } else { panic!() }\n-    }\n-}\n-\n-#[derive(PartialEq)]\n-pub struct Marker<T>(PhantomData<T>);\n-\n-impl<T> Marker<T> {\n-    pub unsafe fn new() -> Self {\n-        Marker(PhantomData)\n-    }\n-}\n-\n-pub enum YieldType<I, A> {\n-    Initial(I),\n-    Accessor(Marker<A>),\n-}\n-\n-#[macro_export]\n-#[allow_internal_unstable(fn_traits)]\n-macro_rules! declare_box_region_type {\n-    (impl $v:vis\n-     $name: ident,\n-     $yield_type:ty,\n-     for($($lifetimes:tt)*),\n-     ($($args:ty),*) -> ($reti:ty, $retc:ty)\n-    ) => {\n-        $v struct $name($crate::box_region::PinnedGenerator<\n-            $reti,\n-            for<$($lifetimes)*> fn(($($args,)*)),\n-            $retc\n-        >);\n-\n-        impl $name {\n-            fn new<T: ::std::ops::Generator<$crate::box_region::Action, Yield = $yield_type, Return = $retc> + 'static>(\n-                generator: T\n-            ) -> ($reti, Self) {\n-                let (initial, pinned) = $crate::box_region::PinnedGenerator::new(generator);\n-                (initial, $name(pinned))\n-            }\n-\n-            $v fn access<F: for<$($lifetimes)*> FnOnce($($args,)*) -> R, R>(&mut self, f: F) -> R {\n-                // Turn the FnOnce closure into *mut dyn FnMut()\n-                // so we can pass it in to the generator\n-                let mut r = None;\n-                let mut f = Some(f);\n-                let mut_f: &mut dyn for<$($lifetimes)*> FnMut(($($args,)*)) =\n-                    &mut |args| {\n-                        let f = f.take().unwrap();\n-                        r = Some(FnOnce::call_once(f, args));\n-                };\n-                let mut_f = mut_f as *mut dyn for<$($lifetimes)*> FnMut(($($args,)*));\n-\n-                // Get the generator to call our closure\n-                unsafe {\n-                    self.0.access(::std::mem::transmute(mut_f));\n-                }\n-\n-                // Unwrap the result\n-                r.unwrap()\n-            }\n-\n-            $v fn complete(mut self) -> $retc {\n-                self.0.complete()\n-            }\n-\n-            fn initial_yield(value: $reti) -> $yield_type {\n-                $crate::box_region::YieldType::Initial(value)\n-            }\n-        }\n-    };\n-\n-    ($v:vis $name: ident, for($($lifetimes:tt)*), ($($args:ty),*) -> ($reti:ty, $retc:ty)) => {\n-        declare_box_region_type!(\n-            impl $v $name,\n-            $crate::box_region::YieldType<$reti, for<$($lifetimes)*> fn(($($args,)*))>,\n-            for($($lifetimes)*),\n-            ($($args),*) -> ($reti, $retc)\n-        );\n-    };\n-}\n-\n-#[macro_export]\n-#[allow_internal_unstable(fn_traits)]\n-macro_rules! box_region_allow_access {\n-    (for($($lifetimes:tt)*), ($($args:ty),*), ($($exprs:expr),*), $action:ident) => {\n-        loop {\n-            match $action {\n-                $crate::box_region::Action::Access(accessor) => {\n-                    let accessor: &mut dyn for<$($lifetimes)*> FnMut($($args),*) = unsafe {\n-                        ::std::mem::transmute(accessor.get())\n-                    };\n-                    (*accessor)(($($exprs),*));\n-                    unsafe {\n-                        let marker = $crate::box_region::Marker::<\n-                            for<$($lifetimes)*> fn(($($args,)*))\n-                        >::new();\n-                        $action = yield $crate::box_region::YieldType::Accessor(marker);\n-                    };\n-                }\n-                $crate::box_region::Action::Complete => break,\n-                $crate::box_region::Action::Initial => panic!(\"unexpected box_region action: Initial\"),\n-            }\n-        }\n-    }\n-}"}, {"sha": "16151e9dca5e039bc832b83246e3afb2ed19642d", "filename": "compiler/rustc_data_structures/src/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a8629bff642c3c3b84bb644c0099194f063b627/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a8629bff642c3c3b84bb644c0099194f063b627/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs?ref=0a8629bff642c3c3b84bb644c0099194f063b627", "patch": "@@ -10,7 +10,6 @@\n #![feature(array_windows)]\n #![feature(control_flow_enum)]\n #![feature(in_band_lifetimes)]\n-#![feature(generator_trait)]\n #![feature(min_specialization)]\n #![feature(auto_traits)]\n #![feature(nll)]\n@@ -63,7 +62,6 @@ macro_rules! unlikely {\n \n pub mod base_n;\n pub mod binary_search_util;\n-pub mod box_region;\n pub mod captures;\n pub mod flock;\n pub mod functor;"}, {"sha": "c7424b9e2a120560a39c506abd23157056f73470", "filename": "compiler/rustc_interface/src/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a8629bff642c3c3b84bb644c0099194f063b627/compiler%2Frustc_interface%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a8629bff642c3c3b84bb644c0099194f063b627/compiler%2Frustc_interface%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Flib.rs?ref=0a8629bff642c3c3b84bb644c0099194f063b627", "patch": "@@ -2,8 +2,6 @@\n #![feature(box_patterns)]\n #![feature(internal_output_capture)]\n #![feature(nll)]\n-#![feature(generator_trait)]\n-#![feature(generators)]\n #![feature(once_cell)]\n #![recursion_limit = \"256\"]\n "}, {"sha": "9e3e96df3a7f2effe50a5f0787c95d8f5eb8e8f8", "filename": "compiler/rustc_interface/src/passes.rs", "status": "modified", "additions": 87, "deletions": 38, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/0a8629bff642c3c3b84bb644c0099194f063b627/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a8629bff642c3c3b84bb644c0099194f063b627/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs?ref=0a8629bff642c3c3b84bb644c0099194f063b627", "patch": "@@ -6,10 +6,10 @@ use rustc_ast::mut_visit::MutVisitor;\n use rustc_ast::{self as ast, visit};\n use rustc_codegen_ssa::back::link::emit_metadata;\n use rustc_codegen_ssa::traits::CodegenBackend;\n+use rustc_data_structures::parallel;\n use rustc_data_structures::steal::Steal;\n use rustc_data_structures::sync::{par_iter, Lrc, OnceCell, ParallelIterator, WorkerLocal};\n use rustc_data_structures::temp_dir::MaybeTempDir;\n-use rustc_data_structures::{box_region_allow_access, declare_box_region_type, parallel};\n use rustc_errors::{ErrorReported, PResult};\n use rustc_expand::base::ExtCtxt;\n use rustc_hir::def_id::LOCAL_CRATE;\n@@ -47,7 +47,9 @@ use std::cell::RefCell;\n use std::ffi::OsString;\n use std::io::{self, BufWriter, Write};\n use std::lazy::SyncLazy;\n+use std::marker::PhantomPinned;\n use std::path::PathBuf;\n+use std::pin::Pin;\n use std::rc::Rc;\n use std::{env, fs, iter};\n \n@@ -85,11 +87,83 @@ fn count_nodes(krate: &ast::Crate) -> usize {\n     counter.count\n }\n \n-declare_box_region_type!(\n-    pub BoxedResolver,\n-    for(),\n-    (&mut Resolver<'_>) -> (Result<ast::Crate>, ResolverOutputs)\n-);\n+pub use boxed_resolver::BoxedResolver;\n+mod boxed_resolver {\n+    use super::*;\n+\n+    pub struct BoxedResolver(Pin<Box<BoxedResolverInner>>);\n+\n+    struct BoxedResolverInner {\n+        session: Lrc<Session>,\n+        resolver_arenas: Option<ResolverArenas<'static>>,\n+        resolver: Option<Resolver<'static>>,\n+        _pin: PhantomPinned,\n+    }\n+\n+    // Note: Drop order is important to prevent dangling references. Resolver must be dropped first,\n+    // then resolver_arenas and finally session.\n+    impl Drop for BoxedResolverInner {\n+        fn drop(&mut self) {\n+            self.resolver.take();\n+            self.resolver_arenas.take();\n+        }\n+    }\n+\n+    impl BoxedResolver {\n+        pub(super) fn new<F>(session: Lrc<Session>, make_resolver: F) -> Result<(ast::Crate, Self)>\n+        where\n+            F: for<'a> FnOnce(\n+                &'a Session,\n+                &'a ResolverArenas<'a>,\n+            ) -> Result<(ast::Crate, Resolver<'a>)>,\n+        {\n+            let mut boxed_resolver = Box::new(BoxedResolverInner {\n+                session,\n+                resolver_arenas: Some(Resolver::arenas()),\n+                resolver: None,\n+                _pin: PhantomPinned,\n+            });\n+            // SAFETY: `make_resolver` takes a resolver arena with an arbitrary lifetime and\n+            // returns a resolver with the same lifetime as the arena. We ensure that the arena\n+            // outlives the resolver in the drop impl and elsewhere so these transmutes are sound.\n+            unsafe {\n+                let (crate_, resolver) = make_resolver(\n+                    std::mem::transmute::<&Session, &Session>(&boxed_resolver.session),\n+                    std::mem::transmute::<&ResolverArenas<'_>, &ResolverArenas<'_>>(\n+                        boxed_resolver.resolver_arenas.as_ref().unwrap(),\n+                    ),\n+                )?;\n+                boxed_resolver.resolver = Some(resolver);\n+                Ok((crate_, BoxedResolver(Pin::new_unchecked(boxed_resolver))))\n+            }\n+        }\n+\n+        pub fn access<F: for<'a> FnOnce(&mut Resolver<'a>) -> R, R>(&mut self, f: F) -> R {\n+            // SAFETY: The resolver doesn't need to be pinned.\n+            let mut resolver = unsafe {\n+                self.0.as_mut().map_unchecked_mut(|boxed_resolver| &mut boxed_resolver.resolver)\n+            };\n+            f((&mut *resolver).as_mut().unwrap())\n+        }\n+\n+        pub fn to_resolver_outputs(resolver: Rc<RefCell<BoxedResolver>>) -> ResolverOutputs {\n+            match Rc::try_unwrap(resolver) {\n+                Ok(resolver) => {\n+                    let mut resolver = resolver.into_inner();\n+                    // SAFETY: The resolver doesn't need to be pinned.\n+                    let mut resolver = unsafe {\n+                        resolver\n+                            .0\n+                            .as_mut()\n+                            .map_unchecked_mut(|boxed_resolver| &mut boxed_resolver.resolver)\n+                    };\n+                    resolver.take().unwrap().into_outputs()\n+                }\n+                Err(resolver) => resolver.borrow_mut().access(|resolver| resolver.clone_outputs()),\n+            }\n+        }\n+    }\n+}\n \n /// Runs the \"early phases\" of the compiler: initial `cfg` processing, loading compiler plugins,\n /// syntax expansion, secondary `cfg` expansion, synthesis of a test\n@@ -111,41 +185,16 @@ pub fn configure_and_expand(\n     // its contents but the results of name resolution on those contents. Hopefully we'll push\n     // this back at some point.\n     let crate_name = crate_name.to_string();\n-    let (result, resolver) = BoxedResolver::new(static move |mut action| {\n-        let _ = action;\n-        let sess = &*sess;\n-        let resolver_arenas = Resolver::arenas();\n-        let res = configure_and_expand_inner(\n+    BoxedResolver::new(sess, move |sess, resolver_arenas| {\n+        configure_and_expand_inner(\n             sess,\n             &lint_store,\n             krate,\n             &crate_name,\n             &resolver_arenas,\n-            &*metadata_loader,\n-        );\n-        let mut resolver = match res {\n-            Err(v) => {\n-                yield BoxedResolver::initial_yield(Err(v));\n-                panic!()\n-            }\n-            Ok((krate, resolver)) => {\n-                action = yield BoxedResolver::initial_yield(Ok(krate));\n-                resolver\n-            }\n-        };\n-        box_region_allow_access!(for(), (&mut Resolver<'_>), (&mut resolver), action);\n-        resolver.into_outputs()\n-    });\n-    result.map(|k| (k, resolver))\n-}\n-\n-impl BoxedResolver {\n-    pub fn to_resolver_outputs(resolver: Rc<RefCell<BoxedResolver>>) -> ResolverOutputs {\n-        match Rc::try_unwrap(resolver) {\n-            Ok(resolver) => resolver.into_inner().complete(),\n-            Err(resolver) => resolver.borrow_mut().access(|resolver| resolver.clone_outputs()),\n-        }\n-    }\n+            metadata_loader,\n+        )\n+    })\n }\n \n pub fn register_plugins<'a>(\n@@ -231,11 +280,11 @@ fn pre_expansion_lint(\n \n fn configure_and_expand_inner<'a>(\n     sess: &'a Session,\n-    lint_store: &'a LintStore,\n+    lint_store: &LintStore,\n     mut krate: ast::Crate,\n     crate_name: &str,\n     resolver_arenas: &'a ResolverArenas<'a>,\n-    metadata_loader: &'a MetadataLoaderDyn,\n+    metadata_loader: Box<MetadataLoaderDyn>,\n ) -> Result<(ast::Crate, Resolver<'a>)> {\n     tracing::trace!(\"configure_and_expand_inner\");\n     pre_expansion_lint(sess, lint_store, &krate, crate_name);"}, {"sha": "d73cfe35dc4a13cc9c2cdd84337411027a2166b5", "filename": "compiler/rustc_metadata/src/creader.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0a8629bff642c3c3b84bb644c0099194f063b627/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a8629bff642c3c3b84bb644c0099194f063b627/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs?ref=0a8629bff642c3c3b84bb644c0099194f063b627", "patch": "@@ -54,7 +54,7 @@ pub struct CStore {\n pub struct CrateLoader<'a> {\n     // Immutable configuration.\n     sess: &'a Session,\n-    metadata_loader: &'a MetadataLoaderDyn,\n+    metadata_loader: Box<MetadataLoaderDyn>,\n     local_crate_name: Symbol,\n     // Mutable output.\n     cstore: CStore,\n@@ -219,7 +219,7 @@ impl CStore {\n impl<'a> CrateLoader<'a> {\n     pub fn new(\n         sess: &'a Session,\n-        metadata_loader: &'a MetadataLoaderDyn,\n+        metadata_loader: Box<MetadataLoaderDyn>,\n         local_crate_name: &str,\n     ) -> Self {\n         let local_crate_stable_id =\n@@ -544,7 +544,7 @@ impl<'a> CrateLoader<'a> {\n             info!(\"falling back to a load\");\n             let mut locator = CrateLocator::new(\n                 self.sess,\n-                self.metadata_loader,\n+                &*self.metadata_loader,\n                 name,\n                 hash,\n                 host_hash,"}, {"sha": "6d5531d330783257109c0fa696522b0f5a7360dc", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a8629bff642c3c3b84bb644c0099194f063b627/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a8629bff642c3c3b84bb644c0099194f063b627/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=0a8629bff642c3c3b84bb644c0099194f063b627", "patch": "@@ -1198,7 +1198,7 @@ impl<'a> Resolver<'a> {\n         session: &'a Session,\n         krate: &Crate,\n         crate_name: &str,\n-        metadata_loader: &'a MetadataLoaderDyn,\n+        metadata_loader: Box<MetadataLoaderDyn>,\n         arenas: &'a ResolverArenas<'a>,\n     ) -> Resolver<'a> {\n         let root_local_def_id = LocalDefId { local_def_index: CRATE_DEF_INDEX };"}]}