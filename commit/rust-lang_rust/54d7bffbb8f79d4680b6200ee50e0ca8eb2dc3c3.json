{"sha": "54d7bffbb8f79d4680b6200ee50e0ca8eb2dc3c3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU0ZDdiZmZiYjhmNzlkNDY4MGI2MjAwZWU1MGUwY2E4ZWIyZGMzYzM=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-02-17T20:08:03Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-02-17T20:08:03Z"}, "message": "rt: Make upcall_vec_push an intrinsic", "tree": {"sha": "a1765238a29fad32c6f3ee7f9df8a8ba6a154d19", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a1765238a29fad32c6f3ee7f9df8a8ba6a154d19"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/54d7bffbb8f79d4680b6200ee50e0ca8eb2dc3c3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/54d7bffbb8f79d4680b6200ee50e0ca8eb2dc3c3", "html_url": "https://github.com/rust-lang/rust/commit/54d7bffbb8f79d4680b6200ee50e0ca8eb2dc3c3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/54d7bffbb8f79d4680b6200ee50e0ca8eb2dc3c3/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "db62154062534a61b618f46d4c8715479ce150af", "url": "https://api.github.com/repos/rust-lang/rust/commits/db62154062534a61b618f46d4c8715479ce150af", "html_url": "https://github.com/rust-lang/rust/commit/db62154062534a61b618f46d4c8715479ce150af"}], "stats": {"total": 412, "additions": 319, "deletions": 93}, "files": [{"sha": "11883da6a0d8f8aff550f081a8d7e07739a7aad4", "filename": "src/comp/back/upcall.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/54d7bffbb8f79d4680b6200ee50e0ca8eb2dc3c3/src%2Fcomp%2Fback%2Fupcall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54d7bffbb8f79d4680b6200ee50e0ca8eb2dc3c3/src%2Fcomp%2Fback%2Fupcall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Fupcall.rs?ref=54d7bffbb8f79d4680b6200ee50e0ca8eb2dc3c3", "patch": "@@ -14,6 +14,7 @@ type upcalls =\n      validate_box: ValueRef,\n      shared_malloc: ValueRef,\n      shared_free: ValueRef,\n+     shared_realloc: ValueRef,\n      mark: ValueRef,\n      create_shared_type_desc: ValueRef,\n      free_shared_type_desc: ValueRef,\n@@ -36,15 +37,17 @@ fn declare_upcalls(targ_cfg: @session::config,\n                    _tn: type_names,\n                    tydesc_type: TypeRef,\n                    llmod: ModuleRef) -> @upcalls {\n-    fn decl(llmod: ModuleRef, name: str, tys: [TypeRef], rv: TypeRef) ->\n+    fn decl(llmod: ModuleRef, prefix: str, name: str,\n+            tys: [TypeRef], rv: TypeRef) ->\n        ValueRef {\n         let arg_tys: [TypeRef] = [];\n         for t: TypeRef in tys { arg_tys += [t]; }\n         let fn_ty = T_fn(arg_tys, rv);\n-        ret base::decl_cdecl_fn(llmod, \"upcall_\" + name, fn_ty);\n+        ret base::decl_cdecl_fn(llmod, prefix + name, fn_ty);\n     }\n-    let d = bind decl(llmod, _, _, _);\n-    let dv = bind decl(llmod, _, _, T_void());\n+    let d = bind decl(llmod, \"upcall_\", _, _, _);\n+    let dv = bind decl(llmod, \"upcall_\", _, _, T_void());\n+    let dvi = bind decl(llmod, \"upcall_intrinsic_\", _, _, T_void());\n \n     let int_t = T_int(targ_cfg);\n     let size_t = T_size_t(targ_cfg);\n@@ -65,6 +68,9 @@ fn declare_upcalls(targ_cfg: @session::config,\n                 T_ptr(T_i8())),\n           shared_free:\n               dv(\"shared_free\", [T_ptr(T_i8())]),\n+          shared_realloc:\n+              d(\"shared_realloc\", [T_ptr(T_i8()), size_t],\n+                T_ptr(T_i8())),\n           mark:\n               d(\"mark\", [T_ptr(T_i8())], int_t),\n           create_shared_type_desc:\n@@ -83,7 +89,7 @@ fn declare_upcalls(targ_cfg: @session::config,\n           vec_grow:\n               dv(\"vec_grow\", [T_ptr(T_ptr(opaque_vec_t)), int_t]),\n           vec_push:\n-              dv(\"vec_push\",\n+              dvi(\"vec_push\",\n                 [T_ptr(T_ptr(opaque_vec_t)), T_ptr(tydesc_type),\n                  T_ptr(T_i8())]),\n           cmp_type:"}, {"sha": "04fb683eb752d2aed56881f373d416720381f982", "filename": "src/rt/intrinsics/intrinsics.cpp", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/54d7bffbb8f79d4680b6200ee50e0ca8eb2dc3c3/src%2Frt%2Fintrinsics%2Fintrinsics.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/54d7bffbb8f79d4680b6200ee50e0ca8eb2dc3c3/src%2Frt%2Fintrinsics%2Fintrinsics.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fintrinsics%2Fintrinsics.cpp?ref=54d7bffbb8f79d4680b6200ee50e0ca8eb2dc3c3", "patch": "@@ -112,3 +112,57 @@ rust_intrinsic_leak(void *retptr,\n                     void *thing)\n {\n }\n+\n+extern \"C\" CDECL void *\n+upcall_shared_realloc(void *ptr, size_t size);\n+\n+inline void reserve_vec_fast(rust_vec **vpp, size_t size) {\n+    if (size > (*vpp)->alloc) {\n+      size_t new_size = next_power_of_two(size);\n+        size_t alloc_size = new_size + sizeof(rust_vec);\n+        // Because this is called from an intrinsic we need to use\n+        // the exported API\n+        *vpp = (rust_vec*)upcall_shared_realloc(*vpp, alloc_size);\n+        (*vpp)->alloc = new_size;\n+    }\n+}\n+\n+// Copy elements from one vector to another,\n+// dealing with reference counts\n+static inline void\n+copy_elements(type_desc *elem_t,\n+              void *pdst, void *psrc, size_t n) {\n+    char *dst = (char *)pdst, *src = (char *)psrc;\n+    memmove(dst, src, n);\n+\n+    // increment the refcount of each element of the vector\n+    if (elem_t->take_glue) {\n+        glue_fn *take_glue = elem_t->take_glue;\n+        size_t elem_size = elem_t->size;\n+        const type_desc **tydescs = elem_t->first_param;\n+        for (char *p = dst; p < dst+n; p += elem_size) {\n+            take_glue(NULL, NULL, tydescs, p);\n+        }\n+    }\n+}\n+\n+// Because this is used so often, and it calls take glue that must run\n+// on the rust stack, it is statically compiled into every crate.\n+extern \"C\" CDECL void\n+upcall_intrinsic_vec_push(rust_vec** vp,\n+\t\t\t  type_desc* elt_ty, void* elt) {\n+\n+    size_t new_sz = (*vp)->fill + elt_ty->size;\n+    reserve_vec_fast(vp, new_sz);\n+    rust_vec* v = *vp;\n+    copy_elements(elt_ty, &v->data[0] + v->fill,\n+                  elt, elt_ty->size);\n+    v->fill += elt_ty->size;\n+}\n+\n+// FIXME: Transational. Remove\n+extern \"C\" CDECL void\n+upcall_vec_push(rust_vec** vp,\n+\t\ttype_desc* elt_ty, void* elt) {\n+  upcall_intrinsic_vec_push(vp, elt_ty, elt);\n+}"}, {"sha": "d8373cc0b1083a39a2eacf074f39afaf12b95f8a", "filename": "src/rt/intrinsics/intrinsics.i386.ll.in", "status": "modified", "additions": 115, "deletions": 23, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/54d7bffbb8f79d4680b6200ee50e0ca8eb2dc3c3/src%2Frt%2Fintrinsics%2Fintrinsics.i386.ll.in", "raw_url": "https://github.com/rust-lang/rust/raw/54d7bffbb8f79d4680b6200ee50e0ca8eb2dc3c3/src%2Frt%2Fintrinsics%2Fintrinsics.i386.ll.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fintrinsics%2Fintrinsics.i386.ll.in?ref=54d7bffbb8f79d4680b6200ee50e0ca8eb2dc3c3", "patch": "@@ -2,22 +2,22 @@\n ; target datalayout = \"e-p:32:32:32-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:32:64-f32:32:32-f64:32:64-v64:64:64-v128:128:128-a0:0:64-f80:32:32-n8:16:32-S128\"\n target triple = \"@CFG_TARGET_TRIPLE@\"\n \n-%struct.type_desc = type { %struct.type_desc**, i32, i32, void (i8*, i8*, %struct.type_desc**, i8*)*, void (i8*, i8*, %struct.type_desc**, i8*)*, void (i8*, i8*, %struct.type_desc**, i8*)*, i8*, void (i8*, i8*, %struct.type_desc**, i8*)*, void (i8*, i8*, %struct.type_desc**, i8*)*, i32, void (i8*, i8*, %struct.type_desc**, i8*, i8*, i8)*, i8*, %struct.rust_shape_tables*, i32, i32, %struct.UT_hash_handle, i32, [0 x %struct.type_desc*] }\n+%struct.type_desc = type { %struct.type_desc**, i32, i32, void (i8*, i8*, %struct.type_desc**, i8*)*, void (i8*, i8*, %struct.type_desc**, i8*)*, void (i8*, i8*, %struct.type_desc**, i8*)*, i8*, void (i8*, i8*, %struct.type_desc**, i8*)*, void (i8*, i8*, %struct.type_desc**, i8*)*, i32, i8*, i8*, %struct.rust_shape_tables*, i32, i32, %struct.UT_hash_handle, i32, [0 x %struct.type_desc*] }\n %struct.rust_shape_tables = type { i8*, i8* }\n %struct.UT_hash_handle = type { %struct.UT_hash_table*, i8*, i8*, %struct.UT_hash_handle*, %struct.UT_hash_handle*, i8*, i32, i32 }\n %struct.UT_hash_table = type { %struct.UT_hash_bucket*, i32, i32, i32, %struct.UT_hash_handle*, i32, i32, i32, i32, i32 }\n %struct.UT_hash_bucket = type { %struct.UT_hash_handle*, i32, i32 }\n %struct.rust_vec = type { i32, i32, [0 x i8] }\n %struct.rust_fn = type { i32*, %struct.rust_box* }\n %struct.rust_box = type opaque\n-%struct.rust_task = type { %struct.rust_task_user, i32, [8 x i8], %class.context, %struct.stk_seg*, i32, %struct.rust_task_thread*, %class.rust_crate_cache*, %class.rust_kernel*, i8*, %class.rust_task_list*, %struct.rust_cond*, i8*, %struct.rust_task*, i32, i32, i32*, %class.memory_region, %class.boxed_region, i8, i8, i8, %class.lock_and_signal, %class.hash_map.4, %class.rust_obstack, i32, %\"class.debug::task_debug_info\", i32, [4 x i8] }\n-%struct.rust_task_user = type { i32, i32, %struct.chan_handle, i32 }\n+%struct.rust_task = type { i32, i32, i8, %struct.chan_handle, [12 x i8], %class.context, %struct.stk_seg*, i32, %class.rust_scheduler*, %struct.rust_task_thread*, %class.rust_crate_cache*, %class.rust_kernel*, i8*, %class.rust_task_list*, %struct.rust_cond*, i8*, %struct.rust_task*, i32, i32, i32*, %class.memory_region, %class.boxed_region, i8, i8, %class.lock_and_signal, %class.hash_map.3, %class.rust_obstack, i32, %\"class.debug::task_debug_info\", i32, i8, i8, %struct.stk_seg*, i32, i32, %class.rust_port_selector, [8 x i8] }\n %struct.chan_handle = type { i32, i32 }\n %class.context = type { %struct.registers_t, %class.context*, [12 x i8] }\n %struct.registers_t = type { i32, i32, i32, i32, i32, i32, i32, i32, i16, i16, i16, i16, i16, i16, i32, i32, [12 x i8] }\n-%struct.stk_seg = type { %struct.stk_seg*, %struct.stk_seg*, i32, i32, i32, [0 x i8] }\n-%struct.rust_task_thread = type { %class.rust_thread, i32, %class.rust_log, i32, %class.rust_srv*, i8*, %class.rust_task_list, %class.rust_task_list, %class.rust_task_list, %class.rust_task_list, %class.rust_crate_cache, %struct.randctx, %class.rust_kernel*, i32, i32, %class.lock_and_signal, i32, %union.pthread_attr_t, %struct.rust_env*, [12 x i8], %class.context, i8, [15 x i8] }\n-%class.rust_thread = type { i32 (...)**, i8, i32 }\n+%struct.stk_seg = type { %struct.stk_seg*, %struct.stk_seg*, i32, i32, i32, i32, [0 x i8] }\n+%class.rust_scheduler = type opaque\n+%struct.rust_task_thread = type { %class.rust_thread, i32, %class.rust_log, i32, %class.rust_srv*, i8*, %class.rust_task_list, %class.rust_task_list, %class.rust_task_list, %class.rust_task_list, %class.rust_crate_cache, %struct.randctx, %class.rust_kernel*, %class.rust_scheduler*, i32, i32, %class.lock_and_signal, i32, %union.pthread_attr_t, %struct.rust_env*, [8 x i8], %class.context, i8, %struct.stk_seg*, %struct.stk_seg*, [4 x i8] }\n+%class.rust_thread = type { i32 (...)**, i32, i32 }\n %class.rust_log = type { i32 (...)**, %class.rust_srv*, %struct.rust_task_thread*, i8 }\n %class.rust_srv = type { i32 (...)**, %struct.rust_env*, %class.memory_region }\n %struct.rust_env = type { i32, i32, i32, i8*, i8, i8, i8* }\n@@ -36,24 +36,30 @@ target triple = \"@CFG_TARGET_TRIPLE@\"\n %class.rust_crate_cache = type { %struct.type_desc*, %struct.rust_hashable_dict*, %struct.rust_task_thread*, i32 }\n %struct.rust_hashable_dict = type { %struct.UT_hash_handle, [0 x i8*] }\n %struct.randctx = type { i32, [256 x i32], [256 x i32], i32, i32, i32 }\n-%class.rust_kernel = type { i32 (...)**, %class.memory_region, %class.rust_log, %class.rust_srv*, %class.lock_and_signal, %class.array_list.3, %struct.randctx, i32, %class.hash_map, i32, i32, i32, %struct.rust_env* }\n-%class.array_list.3 = type { i32, %struct.rust_task_thread**, i32 }\n+%class.rust_kernel = type { %class.memory_region, %class.rust_log, %class.rust_srv*, %class.lock_and_signal, i32, i32, %class.hash_map, %class.lock_and_signal, i32, %class.lock_and_signal, i32, i32, %\"class.std::map\", %struct.rust_env* }\n %class.hash_map = type { %\"struct.hash_map<int, rust_task *>::map_entry\"* }\n %\"struct.hash_map<int, rust_task *>::map_entry\" = type opaque\n+%\"class.std::map\" = type { %\"class.std::_Rb_tree\" }\n+%\"class.std::_Rb_tree\" = type { %\"struct.std::_Rb_tree<int, std::pair<const int, rust_scheduler *>, std::_Select1st<std::pair<const int, rust_scheduler *> >, std::less<int>, std::allocator<std::pair<const int, rust_scheduler *> > >::_Rb_tree_impl\" }\n+%\"struct.std::_Rb_tree<int, std::pair<const int, rust_scheduler *>, std::_Select1st<std::pair<const int, rust_scheduler *> >, std::less<int>, std::allocator<std::pair<const int, rust_scheduler *> > >::_Rb_tree_impl\" = type { %\"struct.std::less\", %\"struct.std::_Rb_tree_node_base\", i32 }\n+%\"struct.std::less\" = type { i8 }\n+%\"struct.std::_Rb_tree_node_base\" = type { i32, %\"struct.std::_Rb_tree_node_base\"*, %\"struct.std::_Rb_tree_node_base\"*, %\"struct.std::_Rb_tree_node_base\"* }\n %union.pthread_attr_t = type { i32, [32 x i8] }\n %struct.rust_cond = type { i8 }\n %class.boxed_region = type { %class.memory_region*, %struct.rust_opaque_box* }\n %struct.rust_opaque_box = type { i32, %struct.type_desc*, %struct.rust_opaque_box*, %struct.rust_opaque_box* }\n-%class.hash_map.4 = type { %\"struct.hash_map<int, rust_port *>::map_entry\"* }\n+%class.hash_map.3 = type { %\"struct.hash_map<int, rust_port *>::map_entry\"* }\n %\"struct.hash_map<int, rust_port *>::map_entry\" = type opaque\n %class.rust_obstack = type { %struct.rust_obstack_chunk*, %struct.rust_task* }\n %struct.rust_obstack_chunk = type { %struct.rust_obstack_chunk*, i32, i32, i32, [0 x i8] }\n-%\"class.debug::task_debug_info\" = type { %\"class.std::map\" }\n-%\"class.std::map\" = type { %\"class.std::_Rb_tree\" }\n-%\"class.std::_Rb_tree\" = type { %\"struct.std::_Rb_tree<void *, std::pair<void *const, std::basic_string<char> >, std::_Select1st<std::pair<void *const, std::basic_string<char> > >, std::less<void *>, std::allocator<std::pair<void *const, std::basic_string<char> > > >::_Rb_tree_impl\" }\n-%\"struct.std::_Rb_tree<void *, std::pair<void *const, std::basic_string<char> >, std::_Select1st<std::pair<void *const, std::basic_string<char> > >, std::less<void *>, std::allocator<std::pair<void *const, std::basic_string<char> > > >::_Rb_tree_impl\" = type { %\"struct.std::less\", %\"struct.std::_Rb_tree_node_base\", i32 }\n-%\"struct.std::less\" = type { i8 }\n-%\"struct.std::_Rb_tree_node_base\" = type { i32, %\"struct.std::_Rb_tree_node_base\"*, %\"struct.std::_Rb_tree_node_base\"*, %\"struct.std::_Rb_tree_node_base\"* }\n+%\"class.debug::task_debug_info\" = type { %\"class.std::map.4\" }\n+%\"class.std::map.4\" = type { %\"class.std::_Rb_tree.5\" }\n+%\"class.std::_Rb_tree.5\" = type { %\"struct.std::_Rb_tree<void *, std::pair<void *const, std::basic_string<char> >, std::_Select1st<std::pair<void *const, std::basic_string<char> > >, std::less<void *>, std::allocator<std::pair<void *const, std::basic_string<char> > > >::_Rb_tree_impl\" }\n+%\"struct.std::_Rb_tree<void *, std::pair<void *const, std::basic_string<char> >, std::_Select1st<std::pair<void *const, std::basic_string<char> > >, std::less<void *>, std::allocator<std::pair<void *const, std::basic_string<char> > > >::_Rb_tree_impl\" = type { %\"struct.std::less.9\", %\"struct.std::_Rb_tree_node_base\", i32 }\n+%\"struct.std::less.9\" = type { i8 }\n+%class.rust_port_selector = type { %class.rust_port**, i32, %class.lock_and_signal }\n+%class.rust_port = type { i32, i32, %class.rust_kernel*, %struct.rust_task*, i32, %class.circular_buffer, %class.lock_and_signal }\n+%class.circular_buffer = type { %class.rust_kernel*, i32, i32, i32, i32, i8* }\n \n define void @rust_intrinsic_vec_len(i32* nocapture %retptr, i8* nocapture %env, %struct.type_desc* nocapture %ty, %struct.rust_vec** nocapture %vp) nounwind {\n entry:\n@@ -121,27 +127,113 @@ entry:\n declare void @rust_task_yield(%struct.rust_task*, i8*)\n \n define void @rust_intrinsic_memmove(i8* nocapture %retptr, i8* nocapture %env, %struct.type_desc* nocapture %ty, i8* nocapture %dst, i8* nocapture %src, i32 %count) nounwind {\n-  %1 = getelementptr inbounds %struct.type_desc* %ty, i32 0, i32 1\n-  %2 = load i32* %1, align 4, !tbaa !3\n-  %3 = mul i32 %2, %count\n-  tail call void @llvm.memmove.p0i8.p0i8.i32(i8* %dst, i8* %src, i32 %3, i32 1, i1 false)\n+entry:\n+  %size = getelementptr inbounds %struct.type_desc* %ty, i32 0, i32 1\n+  %0 = load i32* %size, align 4, !tbaa !3\n+  %mul = mul i32 %0, %count\n+  tail call void @llvm.memmove.p0i8.p0i8.i32(i8* %dst, i8* %src, i32 %mul, i32 1, i1 false)\n   ret void\n }\n \n define void @rust_intrinsic_memcpy(i8* nocapture %retptr, i8* nocapture %env, %struct.type_desc* nocapture %ty, i8* nocapture %dst, i8* nocapture %src, i32 %count) nounwind {\n-  %1 = getelementptr inbounds %struct.type_desc* %ty, i32 0, i32 1\n-  %2 = load i32* %1, align 4, !tbaa !3\n-  %3 = mul i32 %2, %count\n-  tail call void @llvm.memcpy.p0i8.p0i8.i32(i8* %dst, i8* %src, i32 %3, i32 1, i1 false)\n+entry:\n+  %size = getelementptr inbounds %struct.type_desc* %ty, i32 0, i32 1\n+  %0 = load i32* %size, align 4, !tbaa !3\n+  %mul = mul i32 %0, %count\n+  tail call void @llvm.memcpy.p0i8.p0i8.i32(i8* %dst, i8* %src, i32 %mul, i32 1, i1 false)\n   ret void\n }\n \n declare void @llvm.memcpy.p0i8.p0i8.i32(i8* nocapture, i8* nocapture, i32, i32, i1) nounwind\n \n define void @rust_intrinsic_leak(i8* nocapture %retptr, i8* nocapture %env, %struct.type_desc* nocapture %ty, i8* nocapture %thing) nounwind readnone {\n+entry:\n   ret void\n }\n \n+define void @upcall_intrinsic_vec_push(%struct.rust_vec** nocapture %vp, %struct.type_desc* nocapture %elt_ty, i8* nocapture %elt) {\n+entry:\n+  %0 = load %struct.rust_vec** %vp, align 4, !tbaa !0\n+  %fill = getelementptr inbounds %struct.rust_vec* %0, i32 0, i32 0\n+  %1 = load i32* %fill, align 4, !tbaa !3\n+  %size = getelementptr inbounds %struct.type_desc* %elt_ty, i32 0, i32 1\n+  %2 = load i32* %size, align 4, !tbaa !3\n+  %add = add i32 %2, %1\n+  %alloc.i = getelementptr inbounds %struct.rust_vec* %0, i32 0, i32 1\n+  %3 = load i32* %alloc.i, align 4, !tbaa !3\n+  %cmp.i = icmp ult i32 %3, %add\n+  br i1 %cmp.i, label %if.then.i, label %_Z16reserve_vec_fastPP8rust_vecj.exit\n+\n+if.then.i:                                        ; preds = %entry\n+  %sub.i.i = add i32 %add, -1\n+  %shr.i.i = lshr i32 %sub.i.i, 1\n+  %or.i.i = or i32 %shr.i.i, %sub.i.i\n+  %shr1.i.i = lshr i32 %or.i.i, 2\n+  %or2.i.i = or i32 %shr1.i.i, %or.i.i\n+  %shr3.i.i = lshr i32 %or2.i.i, 4\n+  %or4.i.i = or i32 %shr3.i.i, %or2.i.i\n+  %shr5.i.i = lshr i32 %or4.i.i, 8\n+  %or6.i.i = or i32 %shr5.i.i, %or4.i.i\n+  %shr7.i.i = lshr i32 %or6.i.i, 16\n+  %or8.i.i = or i32 %shr7.i.i, %or6.i.i\n+  %add.i.i = add i32 %or8.i.i, 1\n+  %add.i = add i32 %or8.i.i, 9\n+  %4 = bitcast %struct.rust_vec* %0 to i8*\n+  %call1.i = tail call i8* @upcall_shared_realloc(i8* %4, i32 %add.i)\n+  %5 = bitcast i8* %call1.i to %struct.rust_vec*\n+  store %struct.rust_vec* %5, %struct.rust_vec** %vp, align 4, !tbaa !0\n+  %alloc2.i = getelementptr inbounds i8* %call1.i, i32 4\n+  %6 = bitcast i8* %alloc2.i to i32*\n+  store i32 %add.i.i, i32* %6, align 4, !tbaa !3\n+  %.pr = load i32* %size, align 4\n+  %fill1.phi.trans.insert = bitcast i8* %call1.i to i32*\n+  %.pre = load i32* %fill1.phi.trans.insert, align 4, !tbaa !3\n+  br label %_Z16reserve_vec_fastPP8rust_vecj.exit\n+\n+_Z16reserve_vec_fastPP8rust_vecj.exit:            ; preds = %entry, %if.then.i\n+  %7 = phi i32 [ %1, %entry ], [ %.pre, %if.then.i ]\n+  %8 = phi %struct.rust_vec* [ %0, %entry ], [ %5, %if.then.i ]\n+  %9 = phi i32 [ %2, %entry ], [ %.pr, %if.then.i ]\n+  %fill1 = getelementptr inbounds %struct.rust_vec* %8, i32 0, i32 0\n+  %add.ptr = getelementptr inbounds %struct.rust_vec* %8, i32 0, i32 2, i32 %7\n+  tail call void @llvm.memmove.p0i8.p0i8.i32(i8* %add.ptr, i8* %elt, i32 %9, i32 1, i1 false)\n+  %take_glue.i = getelementptr inbounds %struct.type_desc* %elt_ty, i32 0, i32 3\n+  %10 = load void (i8*, i8*, %struct.type_desc**, i8*)** %take_glue.i, align 4, !tbaa !0\n+  %tobool.i = icmp eq void (i8*, i8*, %struct.type_desc**, i8*)* %10, null\n+  br i1 %tobool.i, label %_ZL13copy_elementsP9type_descPvS1_j.exit, label %if.then.i6\n+\n+if.then.i6:                                       ; preds = %_Z16reserve_vec_fastPP8rust_vecj.exit\n+  %11 = load i32* %size, align 4, !tbaa !3\n+  %first_param.i = getelementptr inbounds %struct.type_desc* %elt_ty, i32 0, i32 0\n+  %12 = load %struct.type_desc*** %first_param.i, align 4, !tbaa !0\n+  %add.ptr.sum = add i32 %7, %9\n+  %add.ptr.i = getelementptr inbounds %struct.rust_vec* %8, i32 0, i32 2, i32 %add.ptr.sum\n+  %cmp4.i = icmp sgt i32 %9, 0\n+  br i1 %cmp4.i, label %for.body.i, label %_ZL13copy_elementsP9type_descPvS1_j.exit\n+\n+for.body.i:                                       ; preds = %if.then.i6, %for.body.i\n+  %p.05.i = phi i8* [ %add.ptr3.i, %for.body.i ], [ %add.ptr, %if.then.i6 ]\n+  tail call void %10(i8* null, i8* null, %struct.type_desc** %12, i8* %p.05.i)\n+  %add.ptr3.i = getelementptr inbounds i8* %p.05.i, i32 %11\n+  %cmp.i7 = icmp ult i8* %add.ptr3.i, %add.ptr.i\n+  br i1 %cmp.i7, label %for.body.i, label %_ZL13copy_elementsP9type_descPvS1_j.exit\n+\n+_ZL13copy_elementsP9type_descPvS1_j.exit:         ; preds = %for.body.i, %_Z16reserve_vec_fastPP8rust_vecj.exit, %if.then.i6\n+  %13 = load i32* %size, align 4, !tbaa !3\n+  %14 = load i32* %fill1, align 4, !tbaa !3\n+  %add5 = add i32 %14, %13\n+  store i32 %add5, i32* %fill1, align 4, !tbaa !3\n+  ret void\n+}\n+\n+define void @upcall_vec_push(%struct.rust_vec** nocapture %vp, %struct.type_desc* nocapture %elt_ty, i8* nocapture %elt) {\n+entry:\n+  tail call void @upcall_intrinsic_vec_push(%struct.rust_vec** %vp, %struct.type_desc* %elt_ty, i8* %elt)\n+  ret void\n+}\n+\n+declare i8* @upcall_shared_realloc(i8*, i32)\n+\n !0 = metadata !{metadata !\"any pointer\", metadata !1}\n !1 = metadata !{metadata !\"omnipotent char\", metadata !2}\n !2 = metadata !{metadata !\"Simple C/C++ TBAA\", null}"}, {"sha": "7a5045050d443fdf0b7c7898184240ce9b631654", "filename": "src/rt/intrinsics/intrinsics.x86_64.ll.in", "status": "modified", "additions": 117, "deletions": 23, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/54d7bffbb8f79d4680b6200ee50e0ca8eb2dc3c3/src%2Frt%2Fintrinsics%2Fintrinsics.x86_64.ll.in", "raw_url": "https://github.com/rust-lang/rust/raw/54d7bffbb8f79d4680b6200ee50e0ca8eb2dc3c3/src%2Frt%2Fintrinsics%2Fintrinsics.x86_64.ll.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fintrinsics%2Fintrinsics.x86_64.ll.in?ref=54d7bffbb8f79d4680b6200ee50e0ca8eb2dc3c3", "patch": "@@ -2,22 +2,22 @@\n ; target datalayout = \"e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-s0:64:64-f80:128:128-n8:16:32:64-S128\"\n target triple = \"@CFG_TARGET_TRIPLE@\"\n \n-%struct.type_desc = type { %struct.type_desc**, i64, i64, void (i8*, i8*, %struct.type_desc**, i8*)*, void (i8*, i8*, %struct.type_desc**, i8*)*, void (i8*, i8*, %struct.type_desc**, i8*)*, i8*, void (i8*, i8*, %struct.type_desc**, i8*)*, void (i8*, i8*, %struct.type_desc**, i8*)*, i64, void (i8*, i8*, %struct.type_desc**, i8*, i8*, i8)*, i8*, %struct.rust_shape_tables*, i64, i64, %struct.UT_hash_handle, i64, [0 x %struct.type_desc*] }\n+%struct.type_desc = type { %struct.type_desc**, i64, i64, void (i8*, i8*, %struct.type_desc**, i8*)*, void (i8*, i8*, %struct.type_desc**, i8*)*, void (i8*, i8*, %struct.type_desc**, i8*)*, i8*, void (i8*, i8*, %struct.type_desc**, i8*)*, void (i8*, i8*, %struct.type_desc**, i8*)*, i64, i8*, i8*, %struct.rust_shape_tables*, i64, i64, %struct.UT_hash_handle, i64, [0 x %struct.type_desc*] }\n %struct.rust_shape_tables = type { i8*, i8* }\n %struct.UT_hash_handle = type { %struct.UT_hash_table*, i8*, i8*, %struct.UT_hash_handle*, %struct.UT_hash_handle*, i8*, i32, i32 }\n %struct.UT_hash_table = type { %struct.UT_hash_bucket*, i32, i32, i32, %struct.UT_hash_handle*, i64, i32, i32, i32, i32 }\n %struct.UT_hash_bucket = type { %struct.UT_hash_handle*, i32, i32 }\n %struct.rust_vec = type { i64, i64, [0 x i8] }\n %struct.rust_fn = type { i64*, %struct.rust_box* }\n %struct.rust_box = type opaque\n-%struct.rust_task = type { %struct.rust_task_user, i64, %class.context, %struct.stk_seg*, i64, %struct.rust_task_thread*, %class.rust_crate_cache*, %class.rust_kernel*, i8*, %class.rust_task_list*, %struct.rust_cond*, i8*, %struct.rust_task*, i32, i64, i64*, %class.memory_region, %class.boxed_region, i8, i8, i8, %class.lock_and_signal, %class.hash_map.4, %class.rust_obstack, i32, %\"class.debug::task_debug_info\", i64, [8 x i8] }\n-%struct.rust_task_user = type { i64, i64, %struct.chan_handle, i64 }\n+%struct.rust_task = type { i64, i64, i8, %struct.chan_handle, [8 x i8], %class.context, %struct.stk_seg*, i64, %class.rust_scheduler*, %struct.rust_task_thread*, %class.rust_crate_cache*, %class.rust_kernel*, i8*, %class.rust_task_list*, %struct.rust_cond*, i8*, %struct.rust_task*, i32, i64, i64*, %class.memory_region, %class.boxed_region, i8, i8, %class.lock_and_signal, %class.hash_map.3, %class.rust_obstack, i32, %\"class.debug::task_debug_info\", i64, i8, i8, %struct.stk_seg*, i64, i64, %class.rust_port_selector, [8 x i8] }\n %struct.chan_handle = type { i64, i64 }\n %class.context = type { %struct.registers_t, %class.context*, [8 x i8] }\n %struct.registers_t = type { [22 x i64] }\n-%struct.stk_seg = type { %struct.stk_seg*, %struct.stk_seg*, i64, i32, [0 x i8] }\n-%struct.rust_task_thread = type { %class.rust_thread, i64, %class.rust_log, i32, %class.rust_srv*, i8*, %class.rust_task_list, %class.rust_task_list, %class.rust_task_list, %class.rust_task_list, %class.rust_crate_cache, %struct.randctx, %class.rust_kernel*, i32, i32, %class.lock_and_signal, i64, %union.pthread_attr_t, %struct.rust_env*, [8 x i8], %class.context, i8, [15 x i8] }\n-%class.rust_thread = type { i32 (...)**, i8, i64 }\n+%struct.stk_seg = type { %struct.stk_seg*, %struct.stk_seg*, i64, i32, i64, [0 x i8] }\n+%class.rust_scheduler = type opaque\n+%struct.rust_task_thread = type { %class.rust_thread, i64, %class.rust_log, i32, %class.rust_srv*, i8*, %class.rust_task_list, %class.rust_task_list, %class.rust_task_list, %class.rust_task_list, %class.rust_crate_cache, %struct.randctx, %class.rust_kernel*, %class.rust_scheduler*, i32, i32, %class.lock_and_signal, i64, %union.pthread_attr_t, %struct.rust_env*, %class.context, i8, %struct.stk_seg*, %struct.stk_seg*, [8 x i8] }\n+%class.rust_thread = type { i32 (...)**, i64, i64 }\n %class.rust_log = type { i32 (...)**, %class.rust_srv*, %struct.rust_task_thread*, i8 }\n %class.rust_srv = type { i32 (...)**, %struct.rust_env*, %class.memory_region }\n %struct.rust_env = type { i64, i64, i64, i8*, i8, i8, i8* }\n@@ -36,24 +36,30 @@ target triple = \"@CFG_TARGET_TRIPLE@\"\n %class.rust_crate_cache = type { %struct.type_desc*, %struct.rust_hashable_dict*, %struct.rust_task_thread*, i64 }\n %struct.rust_hashable_dict = type { %struct.UT_hash_handle, [0 x i8*] }\n %struct.randctx = type { i64, [256 x i64], [256 x i64], i64, i64, i64 }\n-%class.rust_kernel = type { i32 (...)**, %class.memory_region, %class.rust_log, %class.rust_srv*, %class.lock_and_signal, %class.array_list.3, %struct.randctx, i64, %class.hash_map, i32, i64, i32, %struct.rust_env* }\n-%class.array_list.3 = type { i64, %struct.rust_task_thread**, i64 }\n+%class.rust_kernel = type { %class.memory_region, %class.rust_log, %class.rust_srv*, %class.lock_and_signal, i64, i64, %class.hash_map, %class.lock_and_signal, i32, %class.lock_and_signal, i64, i64, %\"class.std::map\", %struct.rust_env* }\n %class.hash_map = type { %\"struct.hash_map<long, rust_task *>::map_entry\"* }\n %\"struct.hash_map<long, rust_task *>::map_entry\" = type opaque\n+%\"class.std::map\" = type { %\"class.std::_Rb_tree\" }\n+%\"class.std::_Rb_tree\" = type { %\"struct.std::_Rb_tree<long, std::pair<const long, rust_scheduler *>, std::_Select1st<std::pair<const long, rust_scheduler *> >, std::less<long>, std::allocator<std::pair<const long, rust_scheduler *> > >::_Rb_tree_impl\" }\n+%\"struct.std::_Rb_tree<long, std::pair<const long, rust_scheduler *>, std::_Select1st<std::pair<const long, rust_scheduler *> >, std::less<long>, std::allocator<std::pair<const long, rust_scheduler *> > >::_Rb_tree_impl\" = type { %\"struct.std::less\", %\"struct.std::_Rb_tree_node_base\", i64 }\n+%\"struct.std::less\" = type { i8 }\n+%\"struct.std::_Rb_tree_node_base\" = type { i32, %\"struct.std::_Rb_tree_node_base\"*, %\"struct.std::_Rb_tree_node_base\"*, %\"struct.std::_Rb_tree_node_base\"* }\n %union.pthread_attr_t = type { i64, [48 x i8] }\n %struct.rust_cond = type { i8 }\n %class.boxed_region = type { %class.memory_region*, %struct.rust_opaque_box* }\n %struct.rust_opaque_box = type { i64, %struct.type_desc*, %struct.rust_opaque_box*, %struct.rust_opaque_box* }\n-%class.hash_map.4 = type { %\"struct.hash_map<long, rust_port *>::map_entry\"* }\n+%class.hash_map.3 = type { %\"struct.hash_map<long, rust_port *>::map_entry\"* }\n %\"struct.hash_map<long, rust_port *>::map_entry\" = type opaque\n %class.rust_obstack = type { %struct.rust_obstack_chunk*, %struct.rust_task* }\n %struct.rust_obstack_chunk = type { %struct.rust_obstack_chunk*, i64, i64, i64, [0 x i8] }\n-%\"class.debug::task_debug_info\" = type { %\"class.std::map\" }\n-%\"class.std::map\" = type { %\"class.std::_Rb_tree\" }\n-%\"class.std::_Rb_tree\" = type { %\"struct.std::_Rb_tree<void *, std::pair<void *const, std::basic_string<char> >, std::_Select1st<std::pair<void *const, std::basic_string<char> > >, std::less<void *>, std::allocator<std::pair<void *const, std::basic_string<char> > > >::_Rb_tree_impl\" }\n-%\"struct.std::_Rb_tree<void *, std::pair<void *const, std::basic_string<char> >, std::_Select1st<std::pair<void *const, std::basic_string<char> > >, std::less<void *>, std::allocator<std::pair<void *const, std::basic_string<char> > > >::_Rb_tree_impl\" = type { %\"struct.std::less\", %\"struct.std::_Rb_tree_node_base\", i64 }\n-%\"struct.std::less\" = type { i8 }\n-%\"struct.std::_Rb_tree_node_base\" = type { i32, %\"struct.std::_Rb_tree_node_base\"*, %\"struct.std::_Rb_tree_node_base\"*, %\"struct.std::_Rb_tree_node_base\"* }\n+%\"class.debug::task_debug_info\" = type { %\"class.std::map.4\" }\n+%\"class.std::map.4\" = type { %\"class.std::_Rb_tree.5\" }\n+%\"class.std::_Rb_tree.5\" = type { %\"struct.std::_Rb_tree<void *, std::pair<void *const, std::basic_string<char> >, std::_Select1st<std::pair<void *const, std::basic_string<char> > >, std::less<void *>, std::allocator<std::pair<void *const, std::basic_string<char> > > >::_Rb_tree_impl\" }\n+%\"struct.std::_Rb_tree<void *, std::pair<void *const, std::basic_string<char> >, std::_Select1st<std::pair<void *const, std::basic_string<char> > >, std::less<void *>, std::allocator<std::pair<void *const, std::basic_string<char> > > >::_Rb_tree_impl\" = type { %\"struct.std::less.9\", %\"struct.std::_Rb_tree_node_base\", i64 }\n+%\"struct.std::less.9\" = type { i8 }\n+%class.rust_port_selector = type { %class.rust_port**, i64, %class.lock_and_signal }\n+%class.rust_port = type { i64, i64, %class.rust_kernel*, %struct.rust_task*, i64, %class.circular_buffer, %class.lock_and_signal }\n+%class.circular_buffer = type { %class.rust_kernel*, i64, i64, i64, i64, i8* }\n \n define void @rust_intrinsic_vec_len(i64* nocapture %retptr, i8* nocapture %env, %struct.type_desc* nocapture %ty, %struct.rust_vec** nocapture %vp) nounwind uwtable {\n entry:\n@@ -121,27 +127,115 @@ entry:\n declare void @rust_task_yield(%struct.rust_task*, i8*)\n \n define void @rust_intrinsic_memmove(i8* nocapture %retptr, i8* nocapture %env, %struct.type_desc* nocapture %ty, i8* nocapture %dst, i8* nocapture %src, i64 %count) nounwind uwtable {\n-  %1 = getelementptr inbounds %struct.type_desc* %ty, i64 0, i32 1\n-  %2 = load i64* %1, align 8, !tbaa !3\n-  %3 = mul i64 %2, %count\n-  tail call void @llvm.memmove.p0i8.p0i8.i64(i8* %dst, i8* %src, i64 %3, i32 1, i1 false)\n+entry:\n+  %size = getelementptr inbounds %struct.type_desc* %ty, i64 0, i32 1\n+  %0 = load i64* %size, align 8, !tbaa !3\n+  %mul = mul i64 %0, %count\n+  tail call void @llvm.memmove.p0i8.p0i8.i64(i8* %dst, i8* %src, i64 %mul, i32 1, i1 false)\n   ret void\n }\n \n define void @rust_intrinsic_memcpy(i8* nocapture %retptr, i8* nocapture %env, %struct.type_desc* nocapture %ty, i8* nocapture %dst, i8* nocapture %src, i64 %count) nounwind uwtable {\n-  %1 = getelementptr inbounds %struct.type_desc* %ty, i64 0, i32 1\n-  %2 = load i64* %1, align 8, !tbaa !3\n-  %3 = mul i64 %2, %count\n-  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* %dst, i8* %src, i64 %3, i32 1, i1 false)\n+entry:\n+  %size = getelementptr inbounds %struct.type_desc* %ty, i64 0, i32 1\n+  %0 = load i64* %size, align 8, !tbaa !3\n+  %mul = mul i64 %0, %count\n+  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* %dst, i8* %src, i64 %mul, i32 1, i1 false)\n   ret void\n }\n \n declare void @llvm.memcpy.p0i8.p0i8.i64(i8* nocapture, i8* nocapture, i64, i32, i1) nounwind\n \n define void @rust_intrinsic_leak(i8* nocapture %retptr, i8* nocapture %env, %struct.type_desc* nocapture %ty, i8* nocapture %thing) nounwind uwtable readnone {\n+entry:\n   ret void\n }\n \n+define void @upcall_intrinsic_vec_push(%struct.rust_vec** nocapture %vp, %struct.type_desc* nocapture %elt_ty, i8* nocapture %elt) uwtable {\n+entry:\n+  %0 = load %struct.rust_vec** %vp, align 8, !tbaa !0\n+  %fill = getelementptr inbounds %struct.rust_vec* %0, i64 0, i32 0\n+  %1 = load i64* %fill, align 8, !tbaa !3\n+  %size = getelementptr inbounds %struct.type_desc* %elt_ty, i64 0, i32 1\n+  %2 = load i64* %size, align 8, !tbaa !3\n+  %add = add i64 %2, %1\n+  %alloc.i = getelementptr inbounds %struct.rust_vec* %0, i64 0, i32 1\n+  %3 = load i64* %alloc.i, align 8, !tbaa !3\n+  %cmp.i = icmp ult i64 %3, %add\n+  br i1 %cmp.i, label %if.then.i, label %_Z16reserve_vec_fastPP8rust_vecm.exit\n+\n+if.then.i:                                        ; preds = %entry\n+  %sub.i.i = add i64 %add, -1\n+  %shr.i.i = lshr i64 %sub.i.i, 1\n+  %or.i.i = or i64 %shr.i.i, %sub.i.i\n+  %shr1.i.i = lshr i64 %or.i.i, 2\n+  %or2.i.i = or i64 %shr1.i.i, %or.i.i\n+  %shr3.i.i = lshr i64 %or2.i.i, 4\n+  %or4.i.i = or i64 %shr3.i.i, %or2.i.i\n+  %shr5.i.i = lshr i64 %or4.i.i, 8\n+  %or6.i.i = or i64 %shr5.i.i, %or4.i.i\n+  %shr7.i.i = lshr i64 %or6.i.i, 16\n+  %or8.i.i = or i64 %shr7.i.i, %or6.i.i\n+  %shr9.i.i = lshr i64 %or8.i.i, 32\n+  %or10.i.i = or i64 %shr9.i.i, %or8.i.i\n+  %add.i.i = add i64 %or10.i.i, 1\n+  %add.i = add i64 %or10.i.i, 17\n+  %4 = bitcast %struct.rust_vec* %0 to i8*\n+  %call1.i = tail call i8* @upcall_shared_realloc(i8* %4, i64 %add.i)\n+  %5 = bitcast i8* %call1.i to %struct.rust_vec*\n+  store %struct.rust_vec* %5, %struct.rust_vec** %vp, align 8, !tbaa !0\n+  %alloc2.i = getelementptr inbounds i8* %call1.i, i64 8\n+  %6 = bitcast i8* %alloc2.i to i64*\n+  store i64 %add.i.i, i64* %6, align 8, !tbaa !3\n+  %.pr = load i64* %size, align 8\n+  %fill1.phi.trans.insert = bitcast i8* %call1.i to i64*\n+  %.pre = load i64* %fill1.phi.trans.insert, align 8, !tbaa !3\n+  br label %_Z16reserve_vec_fastPP8rust_vecm.exit\n+\n+_Z16reserve_vec_fastPP8rust_vecm.exit:            ; preds = %entry, %if.then.i\n+  %7 = phi i64 [ %1, %entry ], [ %.pre, %if.then.i ]\n+  %8 = phi %struct.rust_vec* [ %0, %entry ], [ %5, %if.then.i ]\n+  %9 = phi i64 [ %2, %entry ], [ %.pr, %if.then.i ]\n+  %fill1 = getelementptr inbounds %struct.rust_vec* %8, i64 0, i32 0\n+  %add.ptr = getelementptr inbounds %struct.rust_vec* %8, i64 0, i32 2, i64 %7\n+  tail call void @llvm.memmove.p0i8.p0i8.i64(i8* %add.ptr, i8* %elt, i64 %9, i32 1, i1 false)\n+  %take_glue.i = getelementptr inbounds %struct.type_desc* %elt_ty, i64 0, i32 3\n+  %10 = load void (i8*, i8*, %struct.type_desc**, i8*)** %take_glue.i, align 8, !tbaa !0\n+  %tobool.i = icmp eq void (i8*, i8*, %struct.type_desc**, i8*)* %10, null\n+  br i1 %tobool.i, label %_ZL13copy_elementsP9type_descPvS1_m.exit, label %if.then.i6\n+\n+if.then.i6:                                       ; preds = %_Z16reserve_vec_fastPP8rust_vecm.exit\n+  %11 = load i64* %size, align 8, !tbaa !3\n+  %first_param.i = getelementptr inbounds %struct.type_desc* %elt_ty, i64 0, i32 0\n+  %12 = load %struct.type_desc*** %first_param.i, align 8, !tbaa !0\n+  %add.ptr.sum = add i64 %7, %9\n+  %add.ptr.i = getelementptr inbounds %struct.rust_vec* %8, i64 0, i32 2, i64 %add.ptr.sum\n+  %cmp4.i = icmp sgt i64 %9, 0\n+  br i1 %cmp4.i, label %for.body.i, label %_ZL13copy_elementsP9type_descPvS1_m.exit\n+\n+for.body.i:                                       ; preds = %if.then.i6, %for.body.i\n+  %p.05.i = phi i8* [ %add.ptr3.i, %for.body.i ], [ %add.ptr, %if.then.i6 ]\n+  tail call void %10(i8* null, i8* null, %struct.type_desc** %12, i8* %p.05.i)\n+  %add.ptr3.i = getelementptr inbounds i8* %p.05.i, i64 %11\n+  %cmp.i7 = icmp ult i8* %add.ptr3.i, %add.ptr.i\n+  br i1 %cmp.i7, label %for.body.i, label %_ZL13copy_elementsP9type_descPvS1_m.exit\n+\n+_ZL13copy_elementsP9type_descPvS1_m.exit:         ; preds = %for.body.i, %_Z16reserve_vec_fastPP8rust_vecm.exit, %if.then.i6\n+  %13 = load i64* %size, align 8, !tbaa !3\n+  %14 = load i64* %fill1, align 8, !tbaa !3\n+  %add5 = add i64 %14, %13\n+  store i64 %add5, i64* %fill1, align 8, !tbaa !3\n+  ret void\n+}\n+\n+define void @upcall_vec_push(%struct.rust_vec** nocapture %vp, %struct.type_desc* nocapture %elt_ty, i8* nocapture %elt) uwtable {\n+entry:\n+  tail call void @upcall_intrinsic_vec_push(%struct.rust_vec** %vp, %struct.type_desc* %elt_ty, i8* %elt)\n+  ret void\n+}\n+\n+declare i8* @upcall_shared_realloc(i8*, i64)\n+\n !0 = metadata !{metadata !\"any pointer\", metadata !1}\n !1 = metadata !{metadata !\"omnipotent char\", metadata !2}\n !2 = metadata !{metadata !\"Simple C/C++ TBAA\", null}"}, {"sha": "fcd9483eb6324f61006c45eb3bb401228464fbd3", "filename": "src/rt/rust_upcall.cpp", "status": "modified", "additions": 20, "deletions": 30, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/54d7bffbb8f79d4680b6200ee50e0ca8eb2dc3c3/src%2Frt%2Frust_upcall.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/54d7bffbb8f79d4680b6200ee50e0ca8eb2dc3c3/src%2Frt%2Frust_upcall.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_upcall.cpp?ref=54d7bffbb8f79d4680b6200ee50e0ca8eb2dc3c3", "patch": "@@ -270,6 +270,26 @@ upcall_shared_free(void* ptr) {\n     UPCALL_SWITCH_STACK(&args, upcall_s_shared_free);\n }\n \n+struct s_shared_realloc_args {\n+    void *retval;\n+    void *ptr;\n+    size_t size;\n+};\n+\n+extern \"C\" CDECL void\n+upcall_s_shared_realloc(s_shared_realloc_args *args) {\n+    rust_task *task = rust_task_thread::get_task();\n+    LOG_UPCALL_ENTRY(task);\n+    args->retval = task->kernel->realloc(args->ptr, args->size);\n+}\n+\n+extern \"C\" CDECL void *\n+upcall_shared_realloc(void *ptr, size_t size) {\n+    s_shared_realloc_args args = {NULL, ptr, size};\n+    UPCALL_SWITCH_STACK(&args, upcall_s_shared_realloc);\n+    return args.retval;\n+}\n+\n /**********************************************************************\n  * Called to deep copy a type descriptor onto the exchange heap.\n  * Used when sending closures.  It's possible that we should have\n@@ -431,36 +451,6 @@ upcall_vec_grow(rust_vec** vp, size_t new_sz) {\n     UPCALL_SWITCH_STACK(&args, upcall_s_vec_grow);\n }\n \n-// Copy elements from one vector to another,\n-// dealing with reference counts\n-static inline void\n-copy_elements(type_desc *elem_t,\n-              void *pdst, void *psrc, size_t n) {\n-    char *dst = (char *)pdst, *src = (char *)psrc;\n-    memmove(dst, src, n);\n-\n-    // increment the refcount of each element of the vector\n-    if (elem_t->take_glue) {\n-        glue_fn *take_glue = elem_t->take_glue;\n-        size_t elem_size = elem_t->size;\n-        const type_desc **tydescs = elem_t->first_param;\n-        for (char *p = dst; p < dst+n; p += elem_size) {\n-            take_glue(NULL, NULL, tydescs, p);\n-        }\n-    }\n-}\n-\n-extern \"C\" CDECL void\n-upcall_vec_push(rust_vec** vp, type_desc* elt_ty, void* elt) {\n-    // NB: This runs entirely on the Rust stack because it invokes take glue\n-\n-    size_t new_sz = (*vp)->fill + elt_ty->size;\n-    reserve_vec_fast(vp, new_sz);\n-    rust_vec* v = *vp;\n-    copy_elements(elt_ty, &v->data[0] + v->fill,\n-                  elt, elt_ty->size);\n-    v->fill += elt_ty->size;\n-}\n \n /**********************************************************************\n  * Returns a token that can be used to deallocate all of the allocated space"}, {"sha": "2a842a67f4ac61336cebf45744fcc7cf926f5f88", "filename": "src/rt/rust_util.h", "status": "modified", "additions": 1, "deletions": 11, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/54d7bffbb8f79d4680b6200ee50e0ca8eb2dc3c3/src%2Frt%2Frust_util.h", "raw_url": "https://github.com/rust-lang/rust/raw/54d7bffbb8f79d4680b6200ee50e0ca8eb2dc3c3/src%2Frt%2Frust_util.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_util.h?ref=54d7bffbb8f79d4680b6200ee50e0ca8eb2dc3c3", "patch": "@@ -189,17 +189,7 @@ inline void reserve_vec(rust_task* task, rust_vec** vpp, size_t size) {\n     reserve_vec_exact(task, vpp, next_power_of_two(size));\n }\n \n-// Call this when you don't already have a task pointer and it will\n-// avoid hitting the TLS if it doesn't have to\n-inline void reserve_vec_fast(rust_vec **vpp, size_t size) {\n-    size_t new_size = next_power_of_two(size);\n-    if (new_size > (*vpp)->alloc) {\n-        rust_task *task = rust_task_thread::get_task();\n-        size_t alloc_size = new_size + sizeof(rust_vec);\n-        *vpp = (rust_vec*)task->kernel->realloc(*vpp, alloc_size);\n-        (*vpp)->alloc = new_size;\n-    }\n-}\n+extern \"C\" void *rust_realloc_shared(void * p, size_t size);\n \n typedef rust_vec rust_str;\n "}, {"sha": "d4fbc0b90bd87f768036691a3daee0606ce26cb4", "filename": "src/rt/rustrt.def.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/54d7bffbb8f79d4680b6200ee50e0ca8eb2dc3c3/src%2Frt%2Frustrt.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/54d7bffbb8f79d4680b6200ee50e0ca8eb2dc3c3/src%2Frt%2Frustrt.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frustrt.def.in?ref=54d7bffbb8f79d4680b6200ee50e0ca8eb2dc3c3", "patch": "@@ -73,8 +73,8 @@ upcall_rust_personality\n upcall_s_shared_malloc\n upcall_shared_malloc\n upcall_shared_free\n+upcall_shared_realloc\n upcall_vec_grow\n-upcall_vec_push\n upcall_call_shim_on_c_stack\n upcall_call_shim_on_rust_stack\n upcall_new_stack"}]}