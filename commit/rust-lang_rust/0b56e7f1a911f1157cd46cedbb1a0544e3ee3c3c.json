{"sha": "0b56e7f1a911f1157cd46cedbb1a0544e3ee3c3c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBiNTZlN2YxYTkxMWYxMTU3Y2Q0NmNlZGJiMWEwNTQ0ZTNlZTNjM2M=", "commit": {"author": {"name": "jD91mZM2", "email": "me@krake.one", "date": "2018-07-08T18:48:11Z"}, "committer": {"name": "jD91mZM2", "email": "me@krake.one", "date": "2018-07-08T18:48:11Z"}, "message": "Delete leftover files", "tree": {"sha": "5b4b498b7608d2d8eef14fe177e5dcc67537ee54", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5b4b498b7608d2d8eef14fe177e5dcc67537ee54"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0b56e7f1a911f1157cd46cedbb1a0544e3ee3c3c", "comment_count": 0, "verification": {"verified": false, "reason": "unverified_email", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQEzBAABCAAdFiEEvF2uTsFosfm5TJhQMFXVRymnJmYFAltCXGsACgkQMFXVRymn\nJmbUvwf/R4cCyOHRx7INH/KijM9f3yplq3Fe+Q/DEXoe+1hIeXALCkE6apJt8l3S\nScvTYP3jWBgpuyFYKYv/DL8f5+9wwSb3z6Z3iwrsqlmUNso3DDO3EadPvxN8otrH\n9nIMk7NuN72dgXBBP3VoWF/JupE3pNvJpEHyBoeCX2Mrt/Ihs94HuOV6RU73tZ/D\nZbjWP+4i7HT6uWVSSkLCLII/+0XZW7YDYLeC90pdBPx/HOtYMpDj1X9HHwFE3me1\nyKeInQnGjKTO37tFYxJ7G18SIcIsbsktX+kMe5oa7wtN/jpR0ZoZNNYLVE7Plg4k\nlG8D06h1yCHhEoCwfSQcr+FSunf76g==\n=TJ72\n-----END PGP SIGNATURE-----", "payload": "tree 5b4b498b7608d2d8eef14fe177e5dcc67537ee54\nparent c007a78d23b684b8edaf624a93ec2d0579a37a86\nauthor jD91mZM2 <me@krake.one> 1531075691 +0200\ncommitter jD91mZM2 <me@krake.one> 1531075691 +0200\n\nDelete leftover files\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0b56e7f1a911f1157cd46cedbb1a0544e3ee3c3c", "html_url": "https://github.com/rust-lang/rust/commit/0b56e7f1a911f1157cd46cedbb1a0544e3ee3c3c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0b56e7f1a911f1157cd46cedbb1a0544e3ee3c3c/comments", "author": {"login": "jD91mZM2", "id": 12830969, "node_id": "MDQ6VXNlcjEyODMwOTY5", "avatar_url": "https://avatars.githubusercontent.com/u/12830969?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jD91mZM2", "html_url": "https://github.com/jD91mZM2", "followers_url": "https://api.github.com/users/jD91mZM2/followers", "following_url": "https://api.github.com/users/jD91mZM2/following{/other_user}", "gists_url": "https://api.github.com/users/jD91mZM2/gists{/gist_id}", "starred_url": "https://api.github.com/users/jD91mZM2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jD91mZM2/subscriptions", "organizations_url": "https://api.github.com/users/jD91mZM2/orgs", "repos_url": "https://api.github.com/users/jD91mZM2/repos", "events_url": "https://api.github.com/users/jD91mZM2/events{/privacy}", "received_events_url": "https://api.github.com/users/jD91mZM2/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jD91mZM2", "id": 12830969, "node_id": "MDQ6VXNlcjEyODMwOTY5", "avatar_url": "https://avatars.githubusercontent.com/u/12830969?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jD91mZM2", "html_url": "https://github.com/jD91mZM2", "followers_url": "https://api.github.com/users/jD91mZM2/followers", "following_url": "https://api.github.com/users/jD91mZM2/following{/other_user}", "gists_url": "https://api.github.com/users/jD91mZM2/gists{/gist_id}", "starred_url": "https://api.github.com/users/jD91mZM2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jD91mZM2/subscriptions", "organizations_url": "https://api.github.com/users/jD91mZM2/orgs", "repos_url": "https://api.github.com/users/jD91mZM2/repos", "events_url": "https://api.github.com/users/jD91mZM2/events{/privacy}", "received_events_url": "https://api.github.com/users/jD91mZM2/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c007a78d23b684b8edaf624a93ec2d0579a37a86", "url": "https://api.github.com/repos/rust-lang/rust/commits/c007a78d23b684b8edaf624a93ec2d0579a37a86", "html_url": "https://github.com/rust-lang/rust/commit/c007a78d23b684b8edaf624a93ec2d0579a37a86"}], "stats": {"total": 1337, "additions": 0, "deletions": 1337}, "files": [{"sha": "5f7b2df89923a8a610d6762b6a8eaa554ca8735b", "filename": "src/libstd/sys/redox/ext/unixsocket.rs", "status": "removed", "additions": 0, "deletions": 252, "changes": 252, "blob_url": "https://github.com/rust-lang/rust/blob/c007a78d23b684b8edaf624a93ec2d0579a37a86/src%2Flibstd%2Fsys%2Fredox%2Fext%2Funixsocket.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c007a78d23b684b8edaf624a93ec2d0579a37a86/src%2Flibstd%2Fsys%2Fredox%2Fext%2Funixsocket.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fext%2Funixsocket.rs?ref=c007a78d23b684b8edaf624a93ec2d0579a37a86", "patch": "@@ -1,252 +0,0 @@\n-// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use fmt;\n-use io::{self, Error, ErrorKind, Initializer};\n-use net::Shutdown;\n-use os::unix::io::{RawFd, AsRawFd, FromRawFd, IntoRawFd};\n-use path::Path;\n-use time::Duration;\n-use sys::{cvt, fd::FileDesc, syscall};\n-\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-#[derive(Clone)]\n-pub struct SocketAddr(());\n-\n-impl SocketAddr {\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn is_unnamed(&self) -> bool {\n-        false\n-    }\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn as_pathname(&self) -> Option<&Path> {\n-        None\n-    }\n-}\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-impl fmt::Debug for SocketAddr {\n-    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        write!(fmt, \"SocketAddr\")\n-    }\n-}\n-\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-pub struct UnixStream(FileDesc);\n-\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-impl fmt::Debug for UnixStream {\n-    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        let mut builder = fmt.debug_struct(\"UnixStream\");\n-        builder.field(\"fd\", &self.0.raw());\n-        if let Ok(addr) = self.local_addr() {\n-            builder.field(\"local\", &addr);\n-        }\n-        if let Ok(addr) = self.peer_addr() {\n-            builder.field(\"peer\", &addr);\n-        }\n-        builder.finish()\n-    }\n-}\n-\n-impl UnixStream {\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn connect(path: &Path) -> io::Result<UnixStream> {\n-        if let Some(s) = path.to_str() {\n-            cvt(syscall::open(format!(\"chan:{}\", s), syscall::O_CLOEXEC))\n-                .map(FileDesc::new)\n-                .map(UnixStream)\n-        } else {\n-            Err(Error::new(\n-                ErrorKind::Other,\n-                \"UnixStream::connect: non-utf8 paths not supported on redox\"\n-            ))\n-        }\n-    }\n-\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn pair() -> io::Result<(UnixStream, UnixStream)> {\n-        let server = cvt(syscall::open(\"chan:\", syscall::O_CREAT | syscall::O_CLOEXEC))\n-            .map(FileDesc::new)?;\n-        let client = server.duplicate_path(b\"connect\")?;\n-        let stream = server.duplicate_path(b\"listen\")?;\n-        Ok((UnixStream(client), UnixStream(stream)))\n-    }\n-\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn try_clone(&self) -> io::Result<UnixStream> {\n-        self.0.duplicate().map(UnixStream)\n-    }\n-\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn local_addr(&self) -> io::Result<SocketAddr> {\n-        Err(Error::new(ErrorKind::Other, \"UnixStream::local_addr unimplemented on redox\"))\n-    }\n-\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn peer_addr(&self) -> io::Result<SocketAddr> {\n-        Err(Error::new(ErrorKind::Other, \"UnixStream::peer_addr unimplemented on redox\"))\n-    }\n-\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn set_read_timeout(&self, _timeout: Option<Duration>) -> io::Result<()> {\n-        Err(Error::new(ErrorKind::Other, \"UnixStream::set_read_timeout unimplemented on redox\"))\n-    }\n-\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn set_write_timeout(&self, _timeout: Option<Duration>) -> io::Result<()> {\n-        Err(Error::new(ErrorKind::Other, \"UnixStream::set_write_timeout unimplemented on redox\"))\n-    }\n-\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn read_timeout(&self) -> io::Result<Option<Duration>> {\n-        Err(Error::new(ErrorKind::Other, \"UnixStream::read_timeout unimplemented on redox\"))\n-    }\n-\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn write_timeout(&self) -> io::Result<Option<Duration>> {\n-        Err(Error::new(ErrorKind::Other, \"UnixStream::write_timeout unimplemented on redox\"))\n-    }\n-\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {\n-        self.0.set_nonblocking(nonblocking)\n-    }\n-\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n-        Ok(None)\n-    }\n-\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn shutdown(&self, _how: Shutdown) -> io::Result<()> {\n-        Err(Error::new(ErrorKind::Other, \"UnixStream::shutdown unimplemented on redox\"))\n-    }\n-}\n-\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-impl<'a> io::Read for &'a UnixStream {\n-    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n-        self.0.read(buf)\n-    }\n-\n-    #[inline]\n-    unsafe fn initializer(&self) -> Initializer {\n-        Initializer::nop()\n-    }\n-}\n-\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-impl<'a> io::Write for &'a UnixStream {\n-    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n-        self.0.write(buf)\n-    }\n-\n-    fn flush(&mut self) -> io::Result<()> {\n-        Ok(())\n-    }\n-}\n-\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-impl AsRawFd for UnixStream {\n-    fn as_raw_fd(&self) -> RawFd {\n-        self.0.raw()\n-    }\n-}\n-\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-impl FromRawFd for UnixStream {\n-    unsafe fn from_raw_fd(fd: RawFd) -> UnixStream {\n-        UnixStream(FileDesc::new(fd))\n-    }\n-}\n-\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-impl IntoRawFd for UnixStream {\n-    fn into_raw_fd(self) -> RawFd {\n-        self.0.into_raw()\n-    }\n-}\n-\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-pub struct UnixListener(FileDesc);\n-\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-impl fmt::Debug for UnixListener {\n-    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        let mut builder = fmt.debug_struct(\"UnixListener\");\n-        builder.field(\"fd\", &self.0.raw());\n-        if let Ok(addr) = self.local_addr() {\n-            builder.field(\"local\", &addr);\n-        }\n-        builder.finish()\n-    }\n-}\n-\n-impl UnixListener {\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn bind(path: &Path) -> io::Result<UnixListener> {\n-        if let Some(s) = path.to_str() {\n-            cvt(syscall::open(format!(\"chan:{}\", s), syscall::O_CREAT | syscall::O_CLOEXEC))\n-                .map(FileDesc::new)\n-                .map(UnixListener)\n-        } else {\n-            Err(Error::new(\n-                ErrorKind::Other,\n-                \"UnixListener::bind: non-utf8 paths not supported on redox\"\n-            ))\n-        }\n-    }\n-\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn accept(&self) -> io::Result<(UnixStream, SocketAddr)> {\n-        self.0.duplicate_path(b\"listen\").map(|fd| (UnixStream(fd), SocketAddr(())))\n-    }\n-\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn try_clone(&self) -> io::Result<UnixListener> {\n-        self.0.duplicate().map(UnixListener)\n-    }\n-\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn local_addr(&self) -> io::Result<SocketAddr> {\n-        Err(Error::new(ErrorKind::Other, \"UnixListener::local_addr unimplemented on redox\"))\n-    }\n-\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {\n-        self.0.set_nonblocking(nonblocking)\n-    }\n-\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n-        Ok(None)\n-    }\n-}\n-\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-impl AsRawFd for UnixListener {\n-    fn as_raw_fd(&self) -> RawFd {\n-        self.0.raw()\n-    }\n-}\n-\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-impl FromRawFd for UnixListener {\n-    unsafe fn from_raw_fd(fd: RawFd) -> UnixListener {\n-        UnixListener(FileDesc::new(fd))\n-    }\n-}\n-\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-impl IntoRawFd for UnixListener {\n-    fn into_raw_fd(self) -> RawFd {\n-        self.0.into_raw()\n-    }\n-}"}, {"sha": "ad2d7019cb8cee770398f553772eb520d844f77e", "filename": "src/libstd/sys/unix/ext/unixsocket.rs", "status": "removed", "additions": 0, "deletions": 354, "changes": 354, "blob_url": "https://github.com/rust-lang/rust/blob/c007a78d23b684b8edaf624a93ec2d0579a37a86/src%2Flibstd%2Fsys%2Funix%2Fext%2Funixsocket.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c007a78d23b684b8edaf624a93ec2d0579a37a86/src%2Flibstd%2Fsys%2Funix%2Fext%2Funixsocket.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fext%2Funixsocket.rs?ref=c007a78d23b684b8edaf624a93ec2d0579a37a86", "patch": "@@ -1,354 +0,0 @@\n-// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Unix-specific networking functionality\n-\n-#[cfg(unix)]\n-use libc;\n-\n-// FIXME(#43348): Make libc adapt #[doc(cfg(...))] so we don't need these fake definitions here?\n-#[cfg(not(unix))]\n-mod libc {\n-    pub use libc::c_int;\n-    pub type socklen_t = u32;\n-    pub struct sockaddr;\n-    #[derive(Clone)]\n-    pub struct sockaddr_un;\n-}\n-\n-use ascii;\n-use ffi::OsStr;\n-use fmt;\n-use io::{self, Initializer};\n-use mem;\n-use net::Shutdown;\n-use os::unix::ffi::OsStrExt;\n-use os::unix::io::{RawFd, AsRawFd, FromRawFd, IntoRawFd};\n-use path::Path;\n-use time::Duration;\n-use sys::cvt;\n-use sys::net::Socket;\n-use sys::ext::net::*;\n-use sys_common::{AsInner, FromInner, IntoInner};\n-\n-enum AddressKind<'a> {\n-    Unnamed,\n-    Pathname(&'a Path),\n-    Abstract(&'a [u8]),\n-}\n-\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-#[derive(Clone)]\n-pub struct SocketAddr {\n-    addr: libc::sockaddr_un,\n-    len: libc::socklen_t,\n-}\n-\n-impl SocketAddr {\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn new<F>(f: F) -> io::Result<SocketAddr>\n-        where F: FnOnce(*mut libc::sockaddr, *mut libc::socklen_t) -> libc::c_int\n-    {\n-        unsafe {\n-            let mut addr: libc::sockaddr_un = mem::zeroed();\n-            let mut len = mem::size_of::<libc::sockaddr_un>() as libc::socklen_t;\n-            cvt(f(&mut addr as *mut _ as *mut _, &mut len))?;\n-            SocketAddr::from_parts(addr, len)\n-        }\n-    }\n-\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn from_parts(addr: libc::sockaddr_un, mut len: libc::socklen_t)\n-        -> io::Result<SocketAddr>\n-    {\n-        if len == 0 {\n-            // When there is a datagram from unnamed unix socket\n-            // linux returns zero bytes of address\n-            len = sun_path_offset() as libc::socklen_t;  // i.e. zero-length address\n-        } else if addr.sun_family != libc::AF_UNIX as libc::sa_family_t {\n-            return Err(io::Error::new(io::ErrorKind::InvalidInput,\n-                                      \"file descriptor did not correspond to a Unix socket\"));\n-        }\n-\n-        Ok(SocketAddr {\n-            addr,\n-            len,\n-        })\n-    }\n-\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn is_unnamed(&self) -> bool {\n-        if let AddressKind::Unnamed = self.address() {\n-            true\n-        } else {\n-            false\n-        }\n-    }\n-\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn as_pathname(&self) -> Option<&Path> {\n-        if let AddressKind::Pathname(path) = self.address() {\n-            Some(path)\n-        } else {\n-            None\n-        }\n-    }\n-\n-    fn address<'a>(&'a self) -> AddressKind<'a> {\n-        let len = self.len as usize - sun_path_offset();\n-        let path = unsafe { mem::transmute::<&[libc::c_char], &[u8]>(&self.addr.sun_path) };\n-\n-        // macOS seems to return a len of 16 and a zeroed sun_path for unnamed addresses\n-        if len == 0\n-            || (cfg!(not(any(target_os = \"linux\", target_os = \"android\")))\n-                && self.addr.sun_path[0] == 0)\n-        {\n-            AddressKind::Unnamed\n-        } else if self.addr.sun_path[0] == 0 {\n-            AddressKind::Abstract(&path[1..len])\n-        } else {\n-            AddressKind::Pathname(OsStr::from_bytes(&path[..len - 1]).as_ref())\n-        }\n-    }\n-}\n-\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-impl fmt::Debug for SocketAddr {\n-    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        match self.address() {\n-            AddressKind::Unnamed => write!(fmt, \"(unnamed)\"),\n-            AddressKind::Abstract(name) => write!(fmt, \"{} (abstract)\", AsciiEscaped(name)),\n-            AddressKind::Pathname(path) => write!(fmt, \"{:?} (pathname)\", path),\n-        }\n-    }\n-}\n-\n-struct AsciiEscaped<'a>(&'a [u8]);\n-\n-impl<'a> fmt::Display for AsciiEscaped<'a> {\n-    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        write!(fmt, \"\\\"\")?;\n-        for byte in self.0.iter().cloned().flat_map(ascii::escape_default) {\n-            write!(fmt, \"{}\", byte as char)?;\n-        }\n-        write!(fmt, \"\\\"\")\n-    }\n-}\n-\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-pub struct UnixStream(Socket);\n-\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-impl fmt::Debug for UnixStream {\n-    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        let mut builder = fmt.debug_struct(\"UnixStream\");\n-        builder.field(\"fd\", self.0.as_inner());\n-        if let Ok(addr) = self.local_addr() {\n-            builder.field(\"local\", &addr);\n-        }\n-        if let Ok(addr) = self.peer_addr() {\n-            builder.field(\"peer\", &addr);\n-        }\n-        builder.finish()\n-    }\n-}\n-\n-impl UnixStream {\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn connect(path: &Path) -> io::Result<UnixStream> {\n-        unsafe {\n-            let inner = Socket::new_raw(libc::AF_UNIX, libc::SOCK_STREAM)?;\n-            let (addr, len) = sockaddr_un(path)?;\n-\n-            cvt(libc::connect(*inner.as_inner(), &addr as *const _ as *const _, len))?;\n-            Ok(UnixStream(inner))\n-        }\n-    }\n-\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn pair() -> io::Result<(UnixStream, UnixStream)> {\n-        let (i1, i2) = Socket::new_pair(libc::AF_UNIX, libc::SOCK_STREAM)?;\n-        Ok((UnixStream(i1), UnixStream(i2)))\n-    }\n-\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn try_clone(&self) -> io::Result<UnixStream> {\n-        self.0.duplicate().map(UnixStream)\n-    }\n-\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn local_addr(&self) -> io::Result<SocketAddr> {\n-        SocketAddr::new(|addr, len| unsafe { libc::getsockname(*self.0.as_inner(), addr, len) })\n-    }\n-\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn peer_addr(&self) -> io::Result<SocketAddr> {\n-        SocketAddr::new(|addr, len| unsafe { libc::getpeername(*self.0.as_inner(), addr, len) })\n-    }\n-\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn set_read_timeout(&self, timeout: Option<Duration>) -> io::Result<()> {\n-        self.0.set_timeout(timeout, libc::SO_RCVTIMEO)\n-    }\n-\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn set_write_timeout(&self, timeout: Option<Duration>) -> io::Result<()> {\n-        self.0.set_timeout(timeout, libc::SO_SNDTIMEO)\n-    }\n-\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn read_timeout(&self) -> io::Result<Option<Duration>> {\n-        self.0.timeout(libc::SO_RCVTIMEO)\n-    }\n-\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn write_timeout(&self) -> io::Result<Option<Duration>> {\n-        self.0.timeout(libc::SO_SNDTIMEO)\n-    }\n-\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {\n-        self.0.set_nonblocking(nonblocking)\n-    }\n-\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n-        self.0.take_error()\n-    }\n-\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn shutdown(&self, how: Shutdown) -> io::Result<()> {\n-        self.0.shutdown(how)\n-    }\n-}\n-\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-impl<'a> io::Read for &'a UnixStream {\n-    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n-        self.0.read(buf)\n-    }\n-\n-    #[inline]\n-    unsafe fn initializer(&self) -> Initializer {\n-        Initializer::nop()\n-    }\n-}\n-\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-impl<'a> io::Write for &'a UnixStream {\n-    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n-        self.0.write(buf)\n-    }\n-\n-    fn flush(&mut self) -> io::Result<()> {\n-        Ok(())\n-    }\n-}\n-\n-#[stable(feature = \"into_raw_os\", since = \"1.4.0\")]\n-impl AsRawFd for UnixStream {\n-    fn as_raw_fd(&self) -> RawFd {\n-        *self.0.as_inner()\n-    }\n-}\n-\n-#[stable(feature = \"into_raw_os\", since = \"1.4.0\")]\n-impl FromRawFd for UnixStream {\n-    unsafe fn from_raw_fd(fd: RawFd) -> UnixStream {\n-        UnixStream(Socket::from_inner(fd))\n-    }\n-}\n-\n-#[stable(feature = \"into_raw_os\", since = \"1.4.0\")]\n-impl IntoRawFd for UnixStream {\n-    fn into_raw_fd(self) -> RawFd {\n-        self.0.into_inner()\n-    }\n-}\n-\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-pub struct UnixListener(Socket);\n-\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-impl fmt::Debug for UnixListener {\n-    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        let mut builder = fmt.debug_struct(\"UnixListener\");\n-        builder.field(\"fd\", self.0.as_inner());\n-        if let Ok(addr) = self.local_addr() {\n-            builder.field(\"local\", &addr);\n-        }\n-        builder.finish()\n-    }\n-}\n-\n-impl UnixListener {\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn bind(path: &Path) -> io::Result<UnixListener> {\n-        unsafe {\n-            let inner = Socket::new_raw(libc::AF_UNIX, libc::SOCK_STREAM)?;\n-            let (addr, len) = sockaddr_un(path)?;\n-\n-            cvt(libc::bind(*inner.as_inner(), &addr as *const _ as *const _, len as _))?;\n-            cvt(libc::listen(*inner.as_inner(), 128))?;\n-\n-            Ok(UnixListener(inner))\n-        }\n-    }\n-\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn accept(&self) -> io::Result<(UnixStream, SocketAddr)> {\n-        let mut storage: libc::sockaddr_un = unsafe { mem::zeroed() };\n-        let mut len = mem::size_of_val(&storage) as libc::socklen_t;\n-        let sock = self.0.accept(&mut storage as *mut _ as *mut _, &mut len)?;\n-        let addr = SocketAddr::from_parts(storage, len)?;\n-        Ok((UnixStream(sock), addr))\n-    }\n-\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn try_clone(&self) -> io::Result<UnixListener> {\n-        self.0.duplicate().map(UnixListener)\n-    }\n-\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn local_addr(&self) -> io::Result<SocketAddr> {\n-        SocketAddr::new(|addr, len| unsafe { libc::getsockname(*self.0.as_inner(), addr, len) })\n-    }\n-\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {\n-        self.0.set_nonblocking(nonblocking)\n-    }\n-\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n-        self.0.take_error()\n-    }\n-}\n-\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-impl AsRawFd for UnixListener {\n-    fn as_raw_fd(&self) -> RawFd {\n-        *self.0.as_inner()\n-    }\n-}\n-\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-impl FromRawFd for UnixListener {\n-    unsafe fn from_raw_fd(fd: RawFd) -> UnixListener {\n-        UnixListener(Socket::from_inner(fd))\n-    }\n-}\n-\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-impl IntoRawFd for UnixListener {\n-    fn into_raw_fd(self) -> RawFd {\n-        self.0.into_inner()\n-    }\n-}"}, {"sha": "c7d71ae67902af2853c0da47cf9c9e737771689b", "filename": "src/libstd/sys_common/unixsocket.rs", "status": "removed", "additions": 0, "deletions": 731, "changes": 731, "blob_url": "https://github.com/rust-lang/rust/blob/c007a78d23b684b8edaf624a93ec2d0579a37a86/src%2Flibstd%2Fsys_common%2Funixsocket.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c007a78d23b684b8edaf624a93ec2d0579a37a86/src%2Flibstd%2Fsys_common%2Funixsocket.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Funixsocket.rs?ref=c007a78d23b684b8edaf624a93ec2d0579a37a86", "patch": "@@ -1,731 +0,0 @@\n-// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-\n-//! Unix-specific networking functionality\n-\n-use fmt;\n-use io::{self, Initializer};\n-use net::Shutdown;\n-use os::unix::io::{RawFd, AsRawFd, FromRawFd, IntoRawFd};\n-use path::Path;\n-use time::Duration;\n-\n-use sys::ext::unixsocket as inner;\n-\n-/// An address associated with a Unix socket.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// use std::os::unix::net::UnixListener;\n-///\n-/// let socket = match UnixListener::bind(\"/tmp/sock\") {\n-///     Ok(sock) => sock,\n-///     Err(e) => {\n-///         println!(\"Couldn't bind: {:?}\", e);\n-///         return\n-///     }\n-/// };\n-/// let addr = socket.local_addr().expect(\"Couldn't get local address\");\n-/// ```\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-#[derive(Clone)]\n-pub struct SocketAddr(pub(crate) inner::SocketAddr);\n-\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-impl fmt::Debug for SocketAddr {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"{:?}\", self.0)\n-    }\n-}\n-\n-#[stable(feature = \"into_raw_os\", since = \"1.4.0\")]\n-impl IntoRawFd for UnixStream {\n-    fn into_raw_fd(self) -> RawFd {\n-        self.0.into_raw_fd()\n-    }\n-}\n-#[stable(feature = \"into_raw_os\", since = \"1.4.0\")]\n-impl AsRawFd for UnixStream {\n-    fn as_raw_fd(&self) -> RawFd {\n-        self.0.as_raw_fd()\n-    }\n-}\n-#[stable(feature = \"into_raw_os\", since = \"1.4.0\")]\n-impl FromRawFd for UnixStream {\n-    unsafe fn from_raw_fd(fd: RawFd) -> Self {\n-        UnixStream(inner::UnixStream::from_raw_fd(fd))\n-    }\n-}\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-impl io::Read for UnixStream {\n-    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n-        io::Read::read(&mut &self.0, buf)\n-    }\n-\n-    #[inline]\n-    unsafe fn initializer(&self) -> Initializer {\n-        io::Read::initializer(&&self.0)\n-    }\n-}\n-\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-impl<'a> io::Read for &'a UnixStream {\n-    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n-        io::Read::read(&mut &self.0, buf)\n-    }\n-\n-    #[inline]\n-    unsafe fn initializer(&self) -> Initializer {\n-        io::Read::initializer(&&self.0)\n-    }\n-}\n-\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-impl io::Write for UnixStream {\n-    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n-        io::Write::write(&mut &self.0, buf)\n-    }\n-\n-    fn flush(&mut self) -> io::Result<()> {\n-        io::Write::flush(&mut &self.0)\n-    }\n-}\n-\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-impl<'a> io::Write for &'a UnixStream {\n-    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n-        io::Write::write(&mut &self.0, buf)\n-    }\n-\n-    fn flush(&mut self) -> io::Result<()> {\n-        io::Write::flush(&mut &self.0)\n-    }\n-}\n-\n-impl SocketAddr {\n-    /// Returns true if and only if the address is unnamed.\n-    ///\n-    /// # Examples\n-    ///\n-    /// A named address:\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixListener;\n-    ///\n-    /// let socket = UnixListener::bind(\"/tmp/sock\").unwrap();\n-    /// let addr = socket.local_addr().expect(\"Couldn't get local address\");\n-    /// assert_eq!(addr.is_unnamed(), false);\n-    /// ```\n-    ///\n-    /// An unnamed address:\n-    ///\n-    /// ```\n-    /// use std::os::unix::net::UnixDatagram;\n-    ///\n-    /// let socket = UnixDatagram::unbound().unwrap();\n-    /// let addr = socket.local_addr().expect(\"Couldn't get local address\");\n-    /// assert_eq!(addr.is_unnamed(), true);\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn is_unnamed(&self) -> bool {\n-        self.0.is_unnamed()\n-    }\n-\n-    /// Returns the contents of this address if it is a `pathname` address.\n-    ///\n-    /// # Examples\n-    ///\n-    /// With a pathname:\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixListener;\n-    /// use std::path::Path;\n-    ///\n-    /// let socket = UnixListener::bind(\"/tmp/sock\").unwrap();\n-    /// let addr = socket.local_addr().expect(\"Couldn't get local address\");\n-    /// assert_eq!(addr.as_pathname(), Some(Path::new(\"/tmp/sock\")));\n-    /// ```\n-    ///\n-    /// Without a pathname:\n-    ///\n-    /// ```\n-    /// use std::os::unix::net::UnixDatagram;\n-    ///\n-    /// let socket = UnixDatagram::unbound().unwrap();\n-    /// let addr = socket.local_addr().expect(\"Couldn't get local address\");\n-    /// assert_eq!(addr.as_pathname(), None);\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn as_pathname(&self) -> Option<&Path> {\n-        self.0.as_pathname()\n-    }\n-}\n-\n-/// A Unix stream socket.\n-///\n-/// # Examples\n-///\n-/// ```no_run\n-/// use std::os::unix::net::UnixStream;\n-/// use std::io::prelude::*;\n-///\n-/// let mut stream = UnixStream::connect(\"/path/to/my/socket\").unwrap();\n-/// stream.write_all(b\"hello world\").unwrap();\n-/// let mut response = String::new();\n-/// stream.read_to_string(&mut response).unwrap();\n-/// println!(\"{}\", response);\n-/// ```\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-pub struct UnixStream(inner::UnixStream);\n-\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-impl fmt::Debug for UnixStream {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"{:?}\", self.0)\n-    }\n-}\n-\n-impl UnixStream {\n-    /// Connects to the socket named by `path`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixStream;\n-    ///\n-    /// let socket = match UnixStream::connect(\"/tmp/sock\") {\n-    ///     Ok(sock) => sock,\n-    ///     Err(e) => {\n-    ///         println!(\"Couldn't connect: {:?}\", e);\n-    ///         return\n-    ///     }\n-    /// };\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn connect<P: AsRef<Path>>(path: P) -> io::Result<UnixStream> {\n-        inner::UnixStream::connect(path.as_ref()).map(UnixStream)\n-    }\n-\n-    /// Creates an unnamed pair of connected sockets.\n-    ///\n-    /// Returns two `UnixStream`s which are connected to each other.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixStream;\n-    ///\n-    /// let (sock1, sock2) = match UnixStream::pair() {\n-    ///     Ok((sock1, sock2)) => (sock1, sock2),\n-    ///     Err(e) => {\n-    ///         println!(\"Couldn't create a pair of sockets: {:?}\", e);\n-    ///         return\n-    ///     }\n-    /// };\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn pair() -> io::Result<(UnixStream, UnixStream)> {\n-        inner::UnixStream::pair().map(|(s1, s2)| (UnixStream(s1), UnixStream(s2)))\n-    }\n-\n-    /// Creates a new independently owned handle to the underlying socket.\n-    ///\n-    /// The returned `UnixStream` is a reference to the same stream that this\n-    /// object references. Both handles will read and write the same stream of\n-    /// data, and options set on one stream will be propagated to the other\n-    /// stream.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixStream;\n-    ///\n-    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n-    /// let sock_copy = socket.try_clone().expect(\"Couldn't clone socket\");\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn try_clone(&self) -> io::Result<UnixStream> {\n-        self.0.try_clone().map(UnixStream)\n-    }\n-\n-    /// Returns the socket address of the local half of this connection.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixStream;\n-    ///\n-    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n-    /// let addr = socket.local_addr().expect(\"Couldn't get local address\");\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn local_addr(&self) -> io::Result<SocketAddr> {\n-        self.0.local_addr().map(SocketAddr)\n-    }\n-\n-    /// Returns the socket address of the remote half of this connection.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixStream;\n-    ///\n-    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n-    /// let addr = socket.peer_addr().expect(\"Couldn't get peer address\");\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn peer_addr(&self) -> io::Result<SocketAddr> {\n-        self.0.peer_addr().map(SocketAddr)\n-    }\n-\n-    /// Sets the read timeout for the socket.\n-    ///\n-    /// If the provided value is [`None`], then [`read`] calls will block\n-    /// indefinitely. An [`Err`] is returned if the zero [`Duration`] is passed to this\n-    /// method.\n-    ///\n-    /// [`None`]: ../../../../std/option/enum.Option.html#variant.None\n-    /// [`Err`]: ../../../../std/result/enum.Result.html#variant.Err\n-    /// [`read`]: ../../../../std/io/trait.Read.html#tymethod.read\n-    /// [`Duration`]: ../../../../std/time/struct.Duration.html\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixStream;\n-    /// use std::time::Duration;\n-    ///\n-    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n-    /// socket.set_read_timeout(Some(Duration::new(1, 0))).expect(\"Couldn't set read timeout\");\n-    /// ```\n-    ///\n-    /// An [`Err`] is returned if the zero [`Duration`] is passed to this\n-    /// method:\n-    ///\n-    /// ```no_run\n-    /// use std::io;\n-    /// use std::os::unix::net::UnixStream;\n-    /// use std::time::Duration;\n-    ///\n-    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n-    /// let result = socket.set_read_timeout(Some(Duration::new(0, 0)));\n-    /// let err = result.unwrap_err();\n-    /// assert_eq!(err.kind(), io::ErrorKind::InvalidInput)\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn set_read_timeout(&self, timeout: Option<Duration>) -> io::Result<()> {\n-        self.0.set_read_timeout(timeout)\n-    }\n-\n-    /// Sets the write timeout for the socket.\n-    ///\n-    /// If the provided value is [`None`], then [`write`] calls will block\n-    /// indefinitely. An [`Err`] is returned if the zero [`Duration`] is\n-    /// passed to this method.\n-    ///\n-    /// [`None`]: ../../../../std/option/enum.Option.html#variant.None\n-    /// [`Err`]: ../../../../std/result/enum.Result.html#variant.Err\n-    /// [`write`]: ../../../../std/io/trait.Write.html#tymethod.write\n-    /// [`Duration`]: ../../../../std/time/struct.Duration.html\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixStream;\n-    /// use std::time::Duration;\n-    ///\n-    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n-    /// socket.set_write_timeout(Some(Duration::new(1, 0))).expect(\"Couldn't set write timeout\");\n-    /// ```\n-    ///\n-    /// An [`Err`] is returned if the zero [`Duration`] is passed to this\n-    /// method:\n-    ///\n-    /// ```no_run\n-    /// use std::io;\n-    /// use std::net::UdpSocket;\n-    /// use std::time::Duration;\n-    ///\n-    /// let socket = UdpSocket::bind(\"127.0.0.1:34254\").unwrap();\n-    /// let result = socket.set_write_timeout(Some(Duration::new(0, 0)));\n-    /// let err = result.unwrap_err();\n-    /// assert_eq!(err.kind(), io::ErrorKind::InvalidInput)\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn set_write_timeout(&self, timeout: Option<Duration>) -> io::Result<()> {\n-        self.0.set_write_timeout(timeout)\n-    }\n-\n-    /// Returns the read timeout of this socket.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixStream;\n-    /// use std::time::Duration;\n-    ///\n-    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n-    /// socket.set_read_timeout(Some(Duration::new(1, 0))).expect(\"Couldn't set read timeout\");\n-    /// assert_eq!(socket.read_timeout().unwrap(), Some(Duration::new(1, 0)));\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn read_timeout(&self) -> io::Result<Option<Duration>> {\n-        self.0.read_timeout()\n-    }\n-\n-    /// Returns the write timeout of this socket.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixStream;\n-    /// use std::time::Duration;\n-    ///\n-    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n-    /// socket.set_write_timeout(Some(Duration::new(1, 0))).expect(\"Couldn't set write timeout\");\n-    /// assert_eq!(socket.write_timeout().unwrap(), Some(Duration::new(1, 0)));\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn write_timeout(&self) -> io::Result<Option<Duration>> {\n-        self.0.write_timeout()\n-    }\n-\n-    /// Moves the socket into or out of nonblocking mode.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixStream;\n-    ///\n-    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n-    /// socket.set_nonblocking(true).expect(\"Couldn't set nonblocking\");\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {\n-        self.0.set_nonblocking(nonblocking)\n-    }\n-\n-    /// Returns the value of the `SO_ERROR` option.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixStream;\n-    ///\n-    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n-    /// if let Ok(Some(err)) = socket.take_error() {\n-    ///     println!(\"Got error: {:?}\", err);\n-    /// }\n-    /// ```\n-    ///\n-    /// # Platform specific\n-    /// On Redox this always returns None.\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n-        self.0.take_error()\n-    }\n-\n-    /// Shuts down the read, write, or both halves of this connection.\n-    ///\n-    /// This function will cause all pending and future I/O calls on the\n-    /// specified portions to immediately return with an appropriate value\n-    /// (see the documentation of [`Shutdown`]).\n-    ///\n-    /// [`Shutdown`]: ../../../../std/net/enum.Shutdown.html\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixStream;\n-    /// use std::net::Shutdown;\n-    ///\n-    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n-    /// socket.shutdown(Shutdown::Both).expect(\"shutdown function failed\");\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn shutdown(&self, how: Shutdown) -> io::Result<()> {\n-        self.0.shutdown(how)\n-    }\n-}\n-\n-/// A structure representing a Unix domain socket server.\n-///\n-/// # Examples\n-///\n-/// ```no_run\n-/// use std::thread;\n-/// use std::os::unix::net::{UnixStream, UnixListener};\n-///\n-/// pub fn handle_client(stream: UnixStream) {\n-///     // ...\n-/// }\n-///\n-/// let listener = UnixListener::bind(\"/path/to/the/socket\").unwrap();\n-///\n-/// // accept connections and process them, spawning a new thread for each one\n-/// for stream in listener.incoming() {\n-///     match stream {\n-///         Ok(stream) => {\n-///             /* connection succeeded */\n-///             thread::spawn(|| handle_client(stream));\n-///         }\n-///         Err(err) => {\n-///             /* connection failed */\n-///             break;\n-///         }\n-///     }\n-/// }\n-/// ```\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-pub struct UnixListener(inner::UnixListener);\n-\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-impl fmt::Debug for UnixListener {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"{:?}\", self.0)\n-    }\n-}\n-\n-#[stable(feature = \"into_raw_os\", since = \"1.4.0\")]\n-impl IntoRawFd for UnixListener {\n-    fn into_raw_fd(self) -> RawFd {\n-        self.0.into_raw_fd()\n-    }\n-}\n-#[stable(feature = \"into_raw_os\", since = \"1.4.0\")]\n-impl AsRawFd for UnixListener {\n-    fn as_raw_fd(&self) -> RawFd {\n-        self.0.as_raw_fd()\n-    }\n-}\n-#[stable(feature = \"into_raw_os\", since = \"1.4.0\")]\n-impl FromRawFd for UnixListener {\n-    unsafe fn from_raw_fd(fd: RawFd) -> Self {\n-        UnixListener(inner::UnixListener::from_raw_fd(fd))\n-    }\n-}\n-\n-impl UnixListener {\n-    /// Creates a new `UnixListener` bound to the specified socket.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixListener;\n-    ///\n-    /// let listener = match UnixListener::bind(\"/path/to/the/socket\") {\n-    ///     Ok(sock) => sock,\n-    ///     Err(e) => {\n-    ///         println!(\"Couldn't connect: {:?}\", e);\n-    ///         return\n-    ///     }\n-    /// };\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn bind<P: AsRef<Path>>(path: P) -> io::Result<UnixListener> {\n-        inner::UnixListener::bind(path.as_ref()).map(UnixListener)\n-    }\n-\n-    /// Accepts a new incoming connection to this listener.\n-    ///\n-    /// This function will block the calling thread until a new Unix connection\n-    /// is established. When established, the corresponding [`UnixStream`] and\n-    /// the remote peer's address will be returned.\n-    ///\n-    /// [`UnixStream`]: ../../../../std/os/unix/net/struct.UnixStream.html\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixListener;\n-    ///\n-    /// let listener = UnixListener::bind(\"/path/to/the/socket\").unwrap();\n-    ///\n-    /// match listener.accept() {\n-    ///     Ok((socket, addr)) => println!(\"Got a client: {:?}\", addr),\n-    ///     Err(e) => println!(\"accept function failed: {:?}\", e),\n-    /// }\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn accept(&self) -> io::Result<(UnixStream, SocketAddr)> {\n-        self.0.accept().map(|(s, a)| (UnixStream(s), SocketAddr(a)))\n-    }\n-\n-    /// Creates a new independently owned handle to the underlying socket.\n-    ///\n-    /// The returned `UnixListener` is a reference to the same socket that this\n-    /// object references. Both handles can be used to accept incoming\n-    /// connections and options set on one listener will affect the other.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixListener;\n-    ///\n-    /// let listener = UnixListener::bind(\"/path/to/the/socket\").unwrap();\n-    ///\n-    /// let listener_copy = listener.try_clone().expect(\"try_clone failed\");\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn try_clone(&self) -> io::Result<UnixListener> {\n-        self.0.try_clone().map(UnixListener)\n-    }\n-\n-    /// Returns the local socket address of this listener.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixListener;\n-    ///\n-    /// let listener = UnixListener::bind(\"/path/to/the/socket\").unwrap();\n-    ///\n-    /// let addr = listener.local_addr().expect(\"Couldn't get local address\");\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn local_addr(&self) -> io::Result<SocketAddr> {\n-        self.0.local_addr().map(SocketAddr)\n-    }\n-\n-    /// Moves the socket into or out of nonblocking mode.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixListener;\n-    ///\n-    /// let listener = UnixListener::bind(\"/path/to/the/socket\").unwrap();\n-    ///\n-    /// listener.set_nonblocking(true).expect(\"Couldn't set non blocking\");\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {\n-        self.0.set_nonblocking(nonblocking)\n-    }\n-\n-    /// Returns the value of the `SO_ERROR` option.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixListener;\n-    ///\n-    /// let listener = UnixListener::bind(\"/tmp/sock\").unwrap();\n-    ///\n-    /// if let Ok(Some(err)) = listener.take_error() {\n-    ///     println!(\"Got error: {:?}\", err);\n-    /// }\n-    /// ```\n-    ///\n-    /// # Platform specific\n-    /// On Redox this always returns None.\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n-        self.0.take_error()\n-    }\n-\n-    /// Returns an iterator over incoming connections.\n-    ///\n-    /// The iterator will never return [`None`] and will also not yield the\n-    /// peer's [`SocketAddr`] structure.\n-    ///\n-    /// [`None`]: ../../../../std/option/enum.Option.html#variant.None\n-    /// [`SocketAddr`]: struct.SocketAddr.html\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::thread;\n-    /// use std::os::unix::net::{UnixStream, UnixListener};\n-    ///\n-    /// pub fn handle_client(stream: UnixStream) {\n-    ///     // ...\n-    /// }\n-    ///\n-    /// let listener = UnixListener::bind(\"/path/to/the/socket\").unwrap();\n-    ///\n-    /// for stream in listener.incoming() {\n-    ///     match stream {\n-    ///         Ok(stream) => {\n-    ///             thread::spawn(|| handle_client(stream));\n-    ///         }\n-    ///         Err(err) => {\n-    ///             break;\n-    ///         }\n-    ///     }\n-    /// }\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn incoming<'a>(&'a self) -> Incoming<'a> {\n-        Incoming { listener: self }\n-    }\n-}\n-\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-impl<'a> IntoIterator for &'a UnixListener {\n-    type Item = io::Result<UnixStream>;\n-    type IntoIter = Incoming<'a>;\n-\n-    fn into_iter(self) -> Incoming<'a> {\n-        self.incoming()\n-    }\n-}\n-\n-/// An iterator over incoming connections to a [`UnixListener`].\n-///\n-/// It will never return [`None`].\n-///\n-/// [`None`]: ../../../../std/option/enum.Option.html#variant.None\n-/// [`UnixListener`]: struct.UnixListener.html\n-///\n-/// # Examples\n-///\n-/// ```no_run\n-/// use std::thread;\n-/// use std::os::unix::net::{UnixStream, UnixListener};\n-///\n-/// pub fn handle_client(stream: UnixStream) {\n-///     // ...\n-/// }\n-///\n-/// let listener = UnixListener::bind(\"/path/to/the/socket\").unwrap();\n-///\n-/// for stream in listener.incoming() {\n-///     match stream {\n-///         Ok(stream) => {\n-///             thread::spawn(|| handle_client(stream));\n-///         }\n-///         Err(err) => {\n-///             break;\n-///         }\n-///     }\n-/// }\n-/// ```\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-#[derive(Debug)]\n-pub struct Incoming<'a> {\n-    listener: &'a UnixListener,\n-}\n-\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-impl<'a> Iterator for Incoming<'a> {\n-    type Item = io::Result<UnixStream>;\n-\n-    fn next(&mut self) -> Option<io::Result<UnixStream>> {\n-        Some(self.listener.accept().map(|s| s.0))\n-    }\n-\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        (usize::max_value(), None)\n-    }\n-}"}]}