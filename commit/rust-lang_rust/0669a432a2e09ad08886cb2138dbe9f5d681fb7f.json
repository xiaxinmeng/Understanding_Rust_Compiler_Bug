{"sha": "0669a432a2e09ad08886cb2138dbe9f5d681fb7f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA2NjlhNDMyYTJlMDlhZDA4ODg2Y2IyMTM4ZGJlOWY1ZDY4MWZiN2Y=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-12-15T22:11:44Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-12-15T22:11:44Z"}, "message": "auto merge of #19448 : japaric/rust/binops-by-value, r=nikomatsakis\n\n- The following operator traits now take their arguments by value: `Add`, `Sub`, `Mul`, `Div`, `Rem`, `BitAnd`, `BitOr`, `BitXor`, `Shl`, `Shr`. This breaks all existing implementations of these traits.\r\n\r\n- The binary operation `a OP b` now \"desugars\" to `OpTrait::op_method(a, b)` and consumes both arguments.\r\n\r\n- `String` and `Vec` addition have been changed to reuse the LHS owned value, and to avoid internal cloning. Only the following asymmetric operations are available: `String + &str` and `Vec<T> + &[T]`, which are now a short-hand for the \"append\" operation.\r\n\r\n[breaking-change]\r\n\r\n---\r\n\r\nThis passes `make check` locally. I haven't touch the unary operators in this PR, but converting them to by value should be very similar to this PR. I can work on them after this gets the thumbs up.\r\n\r\n@nikomatsakis r? the compiler changes\r\n@aturon r? the library changes. I think the only controversial bit is the semantic change of the `Vec`/`String` `Add` implementation.\r\ncc #19148", "tree": {"sha": "5183544df317d80a6bce406242596dd997e61b64", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5183544df317d80a6bce406242596dd997e61b64"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0669a432a2e09ad08886cb2138dbe9f5d681fb7f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0669a432a2e09ad08886cb2138dbe9f5d681fb7f", "html_url": "https://github.com/rust-lang/rust/commit/0669a432a2e09ad08886cb2138dbe9f5d681fb7f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0669a432a2e09ad08886cb2138dbe9f5d681fb7f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "92e9e70d15bcf8d29890bf93793be402ad629229", "url": "https://api.github.com/repos/rust-lang/rust/commits/92e9e70d15bcf8d29890bf93793be402ad629229", "html_url": "https://github.com/rust-lang/rust/commit/92e9e70d15bcf8d29890bf93793be402ad629229"}, {"sha": "89d2061c8f1cc2bcd5e9bb8a97e214f482d5ff2c", "url": "https://api.github.com/repos/rust-lang/rust/commits/89d2061c8f1cc2bcd5e9bb8a97e214f482d5ff2c", "html_url": "https://github.com/rust-lang/rust/commit/89d2061c8f1cc2bcd5e9bb8a97e214f482d5ff2c"}], "stats": {"total": 1551, "additions": 1388, "deletions": 163}, "files": [{"sha": "c6d1898b87efe6045d01d395c768bdc2779a7305", "filename": "src/libcollections/btree/set.rs", "status": "modified", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/0669a432a2e09ad08886cb2138dbe9f5d681fb7f/src%2Flibcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0669a432a2e09ad08886cb2138dbe9f5d681fb7f/src%2Flibcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fset.rs?ref=0669a432a2e09ad08886cb2138dbe9f5d681fb7f", "patch": "@@ -443,6 +443,8 @@ impl<T: Ord> Default for BTreeSet<T> {\n }\n \n #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+// NOTE(stage0): Remove impl after a snapshot\n+#[cfg(stage0)]\n impl<T: Ord + Clone> Sub<BTreeSet<T>,BTreeSet<T>> for BTreeSet<T> {\n     /// Returns the difference of `self` and `rhs` as a new `BTreeSet<T>`.\n     ///\n@@ -464,6 +466,30 @@ impl<T: Ord + Clone> Sub<BTreeSet<T>,BTreeSet<T>> for BTreeSet<T> {\n }\n \n #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n+impl<'a, 'b, T: Ord + Clone> Sub<&'b BTreeSet<T>, BTreeSet<T>> for &'a BTreeSet<T> {\n+    /// Returns the difference of `self` and `rhs` as a new `BTreeSet<T>`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeSet;\n+    ///\n+    /// let a: BTreeSet<int> = vec![1, 2, 3].into_iter().collect();\n+    /// let b: BTreeSet<int> = vec![3, 4, 5].into_iter().collect();\n+    ///\n+    /// let result: BTreeSet<int> = &a - &b;\n+    /// let result_vec: Vec<int> = result.into_iter().collect();\n+    /// assert_eq!(result_vec, vec![1, 2]);\n+    /// ```\n+    fn sub(self, rhs: &BTreeSet<T>) -> BTreeSet<T> {\n+        self.difference(rhs).cloned().collect()\n+    }\n+}\n+\n+#[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+// NOTE(stage0): Remove impl after a snapshot\n+#[cfg(stage0)]\n impl<T: Ord + Clone> BitXor<BTreeSet<T>,BTreeSet<T>> for BTreeSet<T> {\n     /// Returns the symmetric difference of `self` and `rhs` as a new `BTreeSet<T>`.\n     ///\n@@ -485,6 +511,30 @@ impl<T: Ord + Clone> BitXor<BTreeSet<T>,BTreeSet<T>> for BTreeSet<T> {\n }\n \n #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n+impl<'a, 'b, T: Ord + Clone> BitXor<&'b BTreeSet<T>, BTreeSet<T>> for &'a BTreeSet<T> {\n+    /// Returns the symmetric difference of `self` and `rhs` as a new `BTreeSet<T>`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeSet;\n+    ///\n+    /// let a: BTreeSet<int> = vec![1, 2, 3].into_iter().collect();\n+    /// let b: BTreeSet<int> = vec![2, 3, 4].into_iter().collect();\n+    ///\n+    /// let result: BTreeSet<int> = &a ^ &b;\n+    /// let result_vec: Vec<int> = result.into_iter().collect();\n+    /// assert_eq!(result_vec, vec![1, 4]);\n+    /// ```\n+    fn bitxor(self, rhs: &BTreeSet<T>) -> BTreeSet<T> {\n+        self.symmetric_difference(rhs).cloned().collect()\n+    }\n+}\n+\n+#[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+// NOTE(stage0): Remove impl after a snapshot\n+#[cfg(stage0)]\n impl<T: Ord + Clone> BitAnd<BTreeSet<T>,BTreeSet<T>> for BTreeSet<T> {\n     /// Returns the intersection of `self` and `rhs` as a new `BTreeSet<T>`.\n     ///\n@@ -506,6 +556,30 @@ impl<T: Ord + Clone> BitAnd<BTreeSet<T>,BTreeSet<T>> for BTreeSet<T> {\n }\n \n #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n+impl<'a, 'b, T: Ord + Clone> BitAnd<&'b BTreeSet<T>, BTreeSet<T>> for &'a BTreeSet<T> {\n+    /// Returns the intersection of `self` and `rhs` as a new `BTreeSet<T>`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeSet;\n+    ///\n+    /// let a: BTreeSet<int> = vec![1, 2, 3].into_iter().collect();\n+    /// let b: BTreeSet<int> = vec![2, 3, 4].into_iter().collect();\n+    ///\n+    /// let result: BTreeSet<int> = &a & &b;\n+    /// let result_vec: Vec<int> = result.into_iter().collect();\n+    /// assert_eq!(result_vec, vec![2, 3]);\n+    /// ```\n+    fn bitand(self, rhs: &BTreeSet<T>) -> BTreeSet<T> {\n+        self.intersection(rhs).cloned().collect()\n+    }\n+}\n+\n+#[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+// NOTE(stage0): Remove impl after a snapshot\n+#[cfg(stage0)]\n impl<T: Ord + Clone> BitOr<BTreeSet<T>,BTreeSet<T>> for BTreeSet<T> {\n     /// Returns the union of `self` and `rhs` as a new `BTreeSet<T>`.\n     ///\n@@ -526,6 +600,28 @@ impl<T: Ord + Clone> BitOr<BTreeSet<T>,BTreeSet<T>> for BTreeSet<T> {\n     }\n }\n \n+#[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n+impl<'a, 'b, T: Ord + Clone> BitOr<&'b BTreeSet<T>, BTreeSet<T>> for &'a BTreeSet<T> {\n+    /// Returns the union of `self` and `rhs` as a new `BTreeSet<T>`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeSet;\n+    ///\n+    /// let a: BTreeSet<int> = vec![1, 2, 3].into_iter().collect();\n+    /// let b: BTreeSet<int> = vec![3, 4, 5].into_iter().collect();\n+    ///\n+    /// let result: BTreeSet<int> = &a | &b;\n+    /// let result_vec: Vec<int> = result.into_iter().collect();\n+    /// assert_eq!(result_vec, vec![1, 2, 3, 4, 5]);\n+    /// ```\n+    fn bitor(self, rhs: &BTreeSet<T>) -> BTreeSet<T> {\n+        self.union(rhs).cloned().collect()\n+    }\n+}\n+\n impl<T: Show> Show for BTreeSet<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         try!(write!(f, \"{{\"));"}, {"sha": "4df1be1bb355cf157aa9bb2f62beca501b098989", "filename": "src/libcollections/enum_set.rs", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/0669a432a2e09ad08886cb2138dbe9f5d681fb7f/src%2Flibcollections%2Fenum_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0669a432a2e09ad08886cb2138dbe9f5d681fb7f/src%2Flibcollections%2Fenum_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fenum_set.rs?ref=0669a432a2e09ad08886cb2138dbe9f5d681fb7f", "patch": "@@ -183,30 +183,66 @@ impl<E:CLike> EnumSet<E> {\n     }\n }\n \n+// NOTE(stage0): Remove impl after a snapshot\n+#[cfg(stage0)]\n impl<E:CLike> Sub<EnumSet<E>, EnumSet<E>> for EnumSet<E> {\n     fn sub(&self, e: &EnumSet<E>) -> EnumSet<E> {\n         EnumSet {bits: self.bits & !e.bits}\n     }\n }\n \n+#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n+impl<E:CLike> Sub<EnumSet<E>, EnumSet<E>> for EnumSet<E> {\n+    fn sub(self, e: EnumSet<E>) -> EnumSet<E> {\n+        EnumSet {bits: self.bits & !e.bits}\n+    }\n+}\n+\n+// NOTE(stage0): Remove impl after a snapshot\n+#[cfg(stage0)]\n impl<E:CLike> BitOr<EnumSet<E>, EnumSet<E>> for EnumSet<E> {\n     fn bitor(&self, e: &EnumSet<E>) -> EnumSet<E> {\n         EnumSet {bits: self.bits | e.bits}\n     }\n }\n \n+#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n+impl<E:CLike> BitOr<EnumSet<E>, EnumSet<E>> for EnumSet<E> {\n+    fn bitor(self, e: EnumSet<E>) -> EnumSet<E> {\n+        EnumSet {bits: self.bits | e.bits}\n+    }\n+}\n+\n+// NOTE(stage0): Remove impl after a snapshot\n+#[cfg(stage0)]\n impl<E:CLike> BitAnd<EnumSet<E>, EnumSet<E>> for EnumSet<E> {\n     fn bitand(&self, e: &EnumSet<E>) -> EnumSet<E> {\n         EnumSet {bits: self.bits & e.bits}\n     }\n }\n \n+#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n+impl<E:CLike> BitAnd<EnumSet<E>, EnumSet<E>> for EnumSet<E> {\n+    fn bitand(self, e: EnumSet<E>) -> EnumSet<E> {\n+        EnumSet {bits: self.bits & e.bits}\n+    }\n+}\n+\n+// NOTE(stage0): Remove impl after a snapshot\n+#[cfg(stage0)]\n impl<E:CLike> BitXor<EnumSet<E>, EnumSet<E>> for EnumSet<E> {\n     fn bitxor(&self, e: &EnumSet<E>) -> EnumSet<E> {\n         EnumSet {bits: self.bits ^ e.bits}\n     }\n }\n \n+#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n+impl<E:CLike> BitXor<EnumSet<E>, EnumSet<E>> for EnumSet<E> {\n+    fn bitxor(self, e: EnumSet<E>) -> EnumSet<E> {\n+        EnumSet {bits: self.bits ^ e.bits}\n+    }\n+}\n+\n /// An iterator over an EnumSet\n pub struct Items<E> {\n     index: uint,"}, {"sha": "f3a9e7b1867585b78f46bd9b2d5203a46a59057f", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0669a432a2e09ad08886cb2138dbe9f5d681fb7f/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0669a432a2e09ad08886cb2138dbe9f5d681fb7f/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=0669a432a2e09ad08886cb2138dbe9f5d681fb7f", "patch": "@@ -855,6 +855,8 @@ impl<'a, S: Str> Equiv<S> for String {\n     }\n }\n \n+// NOTE(stage0): Remove impl after a snapshot\n+#[cfg(stage0)]\n #[experimental = \"waiting on Add stabilization\"]\n impl<S: Str> Add<S, String> for String {\n     fn add(&self, other: &S) -> String {\n@@ -864,6 +866,22 @@ impl<S: Str> Add<S, String> for String {\n     }\n }\n \n+#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n+impl<'a> Add<&'a str, String> for String {\n+    fn add(mut self, other: &str) -> String {\n+        self.push_str(other);\n+        self\n+    }\n+}\n+\n+#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n+impl<'a> Add<String, String> for &'a str {\n+    fn add(self, mut other: String) -> String {\n+        other.push_str(self);\n+        other\n+    }\n+}\n+\n impl ops::Slice<uint, str> for String {\n     #[inline]\n     fn as_slice_<'a>(&'a self) -> &'a str {\n@@ -1280,7 +1298,7 @@ mod tests {\n     fn test_str_add() {\n         let a = String::from_str(\"12345\");\n         let b = a + \"2\";\n-        let b = b + String::from_str(\"2\");\n+        let b = b + \"2\";\n         assert_eq!(b.len(), 7);\n         assert_eq!(b, \"1234522\");\n     }"}, {"sha": "6a0986d32837fa55e64ec54bd110e33243162ae5", "filename": "src/libcollections/tree/set.rs", "status": "modified", "additions": 100, "deletions": 4, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/0669a432a2e09ad08886cb2138dbe9f5d681fb7f/src%2Flibcollections%2Ftree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0669a432a2e09ad08886cb2138dbe9f5d681fb7f/src%2Flibcollections%2Ftree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftree%2Fset.rs?ref=0669a432a2e09ad08886cb2138dbe9f5d681fb7f", "patch": "@@ -668,6 +668,8 @@ impl<'a, T: Ord> Iterator<&'a T> for UnionItems<'a, T> {\n }\n \n #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+// NOTE(stage0): Remove impl after a snapshot\n+#[cfg(stage0)]\n impl<T: Ord + Clone> BitOr<TreeSet<T>, TreeSet<T>> for TreeSet<T> {\n     /// Returns the union of `self` and `rhs` as a new `TreeSet<T>`.\n     ///\n@@ -689,6 +691,30 @@ impl<T: Ord + Clone> BitOr<TreeSet<T>, TreeSet<T>> for TreeSet<T> {\n }\n \n #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n+impl<'a, 'b, T: Ord + Clone> BitOr<&'b TreeSet<T>, TreeSet<T>> for &'a TreeSet<T> {\n+    /// Returns the union of `self` and `rhs` as a new `TreeSet<T>`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::TreeSet;\n+    ///\n+    /// let a: TreeSet<int> = vec![1, 2, 3].into_iter().collect();\n+    /// let b: TreeSet<int> = vec![3, 4, 5].into_iter().collect();\n+    ///\n+    /// let set: TreeSet<int> = &a | &b;\n+    /// let v: Vec<int> = set.into_iter().collect();\n+    /// assert_eq!(v, vec![1, 2, 3, 4, 5]);\n+    /// ```\n+    fn bitor(self, rhs: &TreeSet<T>) -> TreeSet<T> {\n+        self.union(rhs).cloned().collect()\n+    }\n+}\n+\n+#[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+// NOTE(stage0): Remove impl after a snapshot\n+#[cfg(stage0)]\n impl<T: Ord + Clone> BitAnd<TreeSet<T>, TreeSet<T>> for TreeSet<T> {\n     /// Returns the intersection of `self` and `rhs` as a new `TreeSet<T>`.\n     ///\n@@ -710,6 +736,30 @@ impl<T: Ord + Clone> BitAnd<TreeSet<T>, TreeSet<T>> for TreeSet<T> {\n }\n \n #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n+impl<'a, 'b, T: Ord + Clone> BitAnd<&'b TreeSet<T>, TreeSet<T>> for &'a TreeSet<T> {\n+    /// Returns the intersection of `self` and `rhs` as a new `TreeSet<T>`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::TreeSet;\n+    ///\n+    /// let a: TreeSet<int> = vec![1, 2, 3].into_iter().collect();\n+    /// let b: TreeSet<int> = vec![2, 3, 4].into_iter().collect();\n+    ///\n+    /// let set: TreeSet<int> = &a & &b;\n+    /// let v: Vec<int> = set.into_iter().collect();\n+    /// assert_eq!(v, vec![2, 3]);\n+    /// ```\n+    fn bitand(self, rhs: &TreeSet<T>) -> TreeSet<T> {\n+        self.intersection(rhs).cloned().collect()\n+    }\n+}\n+\n+#[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+// NOTE(stage0): Remove impl after a snapshot\n+#[cfg(stage0)]\n impl<T: Ord + Clone> BitXor<TreeSet<T>, TreeSet<T>> for TreeSet<T> {\n     /// Returns the symmetric difference of `self` and `rhs` as a new `TreeSet<T>`.\n     ///\n@@ -731,6 +781,30 @@ impl<T: Ord + Clone> BitXor<TreeSet<T>, TreeSet<T>> for TreeSet<T> {\n }\n \n #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n+impl<'a, 'b, T: Ord + Clone> BitXor<&'b TreeSet<T>, TreeSet<T>> for &'a TreeSet<T> {\n+    /// Returns the symmetric difference of `self` and `rhs` as a new `TreeSet<T>`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::TreeSet;\n+    ///\n+    /// let a: TreeSet<int> = vec![1, 2, 3].into_iter().collect();\n+    /// let b: TreeSet<int> = vec![3, 4, 5].into_iter().collect();\n+    ///\n+    /// let set: TreeSet<int> = &a ^ &b;\n+    /// let v: Vec<int> = set.into_iter().collect();\n+    /// assert_eq!(v, vec![1, 2, 4, 5]);\n+    /// ```\n+    fn bitxor(self, rhs: &TreeSet<T>) -> TreeSet<T> {\n+        self.symmetric_difference(rhs).cloned().collect()\n+    }\n+}\n+\n+#[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+// NOTE(stage0): Remove impl after a snapshot\n+#[cfg(stage0)]\n impl<T: Ord + Clone> Sub<TreeSet<T>, TreeSet<T>> for TreeSet<T> {\n     /// Returns the difference of `self` and `rhs` as a new `TreeSet<T>`.\n     ///\n@@ -751,6 +825,28 @@ impl<T: Ord + Clone> Sub<TreeSet<T>, TreeSet<T>> for TreeSet<T> {\n     }\n }\n \n+#[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n+impl<'a, 'b, T: Ord + Clone> Sub<&'b TreeSet<T>, TreeSet<T>> for &'a TreeSet<T> {\n+    /// Returns the difference of `self` and `rhs` as a new `TreeSet<T>`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::TreeSet;\n+    ///\n+    /// let a: TreeSet<int> = vec![1, 2, 3].into_iter().collect();\n+    /// let b: TreeSet<int> = vec![3, 4, 5].into_iter().collect();\n+    ///\n+    /// let set: TreeSet<int> = &a - &b;\n+    /// let v: Vec<int> = set.into_iter().collect();\n+    /// assert_eq!(v, vec![1, 2]);\n+    /// ```\n+    fn sub(self, rhs: &TreeSet<T>) -> TreeSet<T> {\n+        self.difference(rhs).cloned().collect()\n+    }\n+}\n+\n impl<T: Ord> FromIterator<T> for TreeSet<T> {\n     fn from_iter<Iter: Iterator<T>>(iter: Iter) -> TreeSet<T> {\n         let mut set = TreeSet::new();\n@@ -1032,7 +1128,7 @@ mod test {\n         let a: TreeSet<int> = vec![1, 3, 5, 9, 11, 16, 19, 24].into_iter().collect();\n         let b: TreeSet<int> = vec![-2, 1, 5, 9, 13, 19].into_iter().collect();\n \n-        let set: TreeSet<int> = a | b;\n+        let set: TreeSet<int> = &a | &b;\n         let v: Vec<int> = set.into_iter().collect();\n         assert_eq!(v, vec![-2, 1, 3, 5, 9, 11, 13, 16, 19, 24]);\n     }\n@@ -1042,7 +1138,7 @@ mod test {\n         let a: TreeSet<int> = vec![11, 1, 3, 77, 103, 5, -5].into_iter().collect();\n         let b: TreeSet<int> = vec![2, 11, 77, -9, -42, 5, 3].into_iter().collect();\n \n-        let set: TreeSet<int> = a & b;\n+        let set: TreeSet<int> = &a & &b;\n         let v: Vec<int> = set.into_iter().collect();\n         assert_eq!(v, vec![3, 5, 11, 77]);\n     }\n@@ -1052,7 +1148,7 @@ mod test {\n         let a: TreeSet<int> = vec![1, 3, 5, 9, 11].into_iter().collect();\n         let b: TreeSet<int> = vec![-2, 3, 9, 14, 22].into_iter().collect();\n \n-        let set: TreeSet<int> = a ^ b;\n+        let set: TreeSet<int> = &a ^ &b;\n         let v: Vec<int> = set.into_iter().collect();\n         assert_eq!(v, vec![-2, 1, 5, 11, 14, 22]);\n     }\n@@ -1062,7 +1158,7 @@ mod test {\n         let a: TreeSet<int> = vec![-5, 11, 22, 33, 40, 42].into_iter().collect();\n         let b: TreeSet<int> = vec![-12, -5, 14, 23, 34, 38, 39, 50].into_iter().collect();\n \n-        let set: TreeSet<int> = a - b;\n+        let set: TreeSet<int> = &a - &b;\n         let v: Vec<int> = set.into_iter().collect();\n         assert_eq!(v, vec![11, 22, 33, 40, 42]);\n     }"}, {"sha": "7b7b4d8280b786148895ff685040f6b9ea49fa5e", "filename": "src/libcollections/trie/set.rs", "status": "modified", "additions": 100, "deletions": 4, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/0669a432a2e09ad08886cb2138dbe9f5d681fb7f/src%2Flibcollections%2Ftrie%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0669a432a2e09ad08886cb2138dbe9f5d681fb7f/src%2Flibcollections%2Ftrie%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftrie%2Fset.rs?ref=0669a432a2e09ad08886cb2138dbe9f5d681fb7f", "patch": "@@ -462,6 +462,8 @@ impl Extend<uint> for TrieSet {\n     }\n }\n \n+// NOTE(stage0): Remove impl after a snapshot\n+#[cfg(stage0)]\n #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n impl BitOr<TrieSet, TrieSet> for TrieSet {\n     /// Returns the union of `self` and `rhs` as a new `TrieSet`.\n@@ -483,6 +485,30 @@ impl BitOr<TrieSet, TrieSet> for TrieSet {\n     }\n }\n \n+#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n+#[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+impl<'a, 'b> BitOr<&'b TrieSet, TrieSet> for &'a TrieSet {\n+    /// Returns the union of `self` and `rhs` as a new `TrieSet`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TrieSet;\n+    ///\n+    /// let a: TrieSet = vec![1, 2, 3].into_iter().collect();\n+    /// let b: TrieSet = vec![3, 4, 5].into_iter().collect();\n+    ///\n+    /// let set: TrieSet = &a | &b;\n+    /// let v: Vec<uint> = set.iter().collect();\n+    /// assert_eq!(v, vec![1u, 2, 3, 4, 5]);\n+    /// ```\n+    fn bitor(self, rhs: &TrieSet) -> TrieSet {\n+        self.union(rhs).collect()\n+    }\n+}\n+\n+// NOTE(stage0): Remove impl after a snapshot\n+#[cfg(stage0)]\n #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n impl BitAnd<TrieSet, TrieSet> for TrieSet {\n     /// Returns the intersection of `self` and `rhs` as a new `TrieSet`.\n@@ -504,6 +530,30 @@ impl BitAnd<TrieSet, TrieSet> for TrieSet {\n     }\n }\n \n+#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n+#[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+impl<'a, 'b> BitAnd<&'b TrieSet, TrieSet> for &'a TrieSet {\n+    /// Returns the intersection of `self` and `rhs` as a new `TrieSet`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TrieSet;\n+    ///\n+    /// let a: TrieSet = vec![1, 2, 3].into_iter().collect();\n+    /// let b: TrieSet = vec![2, 3, 4].into_iter().collect();\n+    ///\n+    /// let set: TrieSet = &a & &b;\n+    /// let v: Vec<uint> = set.iter().collect();\n+    /// assert_eq!(v, vec![2u, 3]);\n+    /// ```\n+    fn bitand(self, rhs: &TrieSet) -> TrieSet {\n+        self.intersection(rhs).collect()\n+    }\n+}\n+\n+// NOTE(stage0): Remove impl after a snapshot\n+#[cfg(stage0)]\n #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n impl BitXor<TrieSet, TrieSet> for TrieSet {\n     /// Returns the symmetric difference of `self` and `rhs` as a new `TrieSet`.\n@@ -525,6 +575,30 @@ impl BitXor<TrieSet, TrieSet> for TrieSet {\n     }\n }\n \n+#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n+#[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+impl<'a, 'b> BitXor<&'b TrieSet, TrieSet> for &'a TrieSet {\n+    /// Returns the symmetric difference of `self` and `rhs` as a new `TrieSet`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TrieSet;\n+    ///\n+    /// let a: TrieSet = vec![1, 2, 3].into_iter().collect();\n+    /// let b: TrieSet = vec![3, 4, 5].into_iter().collect();\n+    ///\n+    /// let set: TrieSet = &a ^ &b;\n+    /// let v: Vec<uint> = set.iter().collect();\n+    /// assert_eq!(v, vec![1u, 2, 4, 5]);\n+    /// ```\n+    fn bitxor(self, rhs: &TrieSet) -> TrieSet {\n+        self.symmetric_difference(rhs).collect()\n+    }\n+}\n+\n+// NOTE(stage0): Remove impl after a snapshot\n+#[cfg(stage0)]\n #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n impl Sub<TrieSet, TrieSet> for TrieSet {\n     /// Returns the difference of `self` and `rhs` as a new `TrieSet`.\n@@ -546,6 +620,28 @@ impl Sub<TrieSet, TrieSet> for TrieSet {\n     }\n }\n \n+#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n+#[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+impl<'a, 'b> Sub<&'b TrieSet, TrieSet> for &'a TrieSet {\n+    /// Returns the difference of `self` and `rhs` as a new `TrieSet`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TrieSet;\n+    ///\n+    /// let a: TrieSet = vec![1, 2, 3].into_iter().collect();\n+    /// let b: TrieSet = vec![3, 4, 5].into_iter().collect();\n+    ///\n+    /// let set: TrieSet = &a - &b;\n+    /// let v: Vec<uint> = set.iter().collect();\n+    /// assert_eq!(v, vec![1u, 2]);\n+    /// ```\n+    fn sub(self, rhs: &TrieSet) -> TrieSet {\n+        self.difference(rhs).collect()\n+    }\n+}\n+\n /// A forward iterator over a set.\n pub struct SetItems<'a> {\n     iter: Entries<'a, ()>\n@@ -837,7 +933,7 @@ mod test {\n         let a: TrieSet = vec![1, 2, 3].into_iter().collect();\n         let b: TrieSet = vec![3, 4, 5].into_iter().collect();\n \n-        let set: TrieSet = a | b;\n+        let set: TrieSet = &a | &b;\n         let v: Vec<uint> = set.iter().collect();\n         assert_eq!(v, vec![1u, 2, 3, 4, 5]);\n     }\n@@ -847,7 +943,7 @@ mod test {\n         let a: TrieSet = vec![1, 2, 3].into_iter().collect();\n         let b: TrieSet = vec![2, 3, 4].into_iter().collect();\n \n-        let set: TrieSet = a & b;\n+        let set: TrieSet = &a & &b;\n         let v: Vec<uint> = set.iter().collect();\n         assert_eq!(v, vec![2u, 3]);\n     }\n@@ -857,7 +953,7 @@ mod test {\n         let a: TrieSet = vec![1, 2, 3].into_iter().collect();\n         let b: TrieSet = vec![3, 4, 5].into_iter().collect();\n \n-        let set: TrieSet = a ^ b;\n+        let set: TrieSet = &a ^ &b;\n         let v: Vec<uint> = set.iter().collect();\n         assert_eq!(v, vec![1u, 2, 4, 5]);\n     }\n@@ -867,7 +963,7 @@ mod test {\n         let a: TrieSet = vec![1, 2, 3].into_iter().collect();\n         let b: TrieSet = vec![3, 4, 5].into_iter().collect();\n \n-        let set: TrieSet = a - b;\n+        let set: TrieSet = &a - &b;\n         let v: Vec<uint> = set.iter().collect();\n         assert_eq!(v, vec![1u, 2]);\n     }"}, {"sha": "275825da3b55ffb67f5393650da6995de49937d9", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/0669a432a2e09ad08886cb2138dbe9f5d681fb7f/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0669a432a2e09ad08886cb2138dbe9f5d681fb7f/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=0669a432a2e09ad08886cb2138dbe9f5d681fb7f", "patch": "@@ -1273,6 +1273,8 @@ impl<T> AsSlice<T> for Vec<T> {\n     }\n }\n \n+// NOTE(stage0): Remove impl after a snapshot\n+#[cfg(stage0)]\n impl<T: Clone, Sized? V: AsSlice<T>> Add<V, Vec<T>> for Vec<T> {\n     #[inline]\n     fn add(&self, rhs: &V) -> Vec<T> {\n@@ -1283,6 +1285,25 @@ impl<T: Clone, Sized? V: AsSlice<T>> Add<V, Vec<T>> for Vec<T> {\n     }\n }\n \n+\n+#[cfg(not(stage0))]  // NOTE(stage0): Remove impl after a snapshot\n+impl<'a, T: Clone> Add<&'a [T], Vec<T>> for Vec<T> {\n+    #[inline]\n+    fn add(mut self, rhs: &[T]) -> Vec<T> {\n+        self.push_all(rhs);\n+        self\n+    }\n+}\n+\n+#[cfg(not(stage0))]  // NOTE(stage0): Remove impl after a snapshot\n+impl<'a, T: Clone> Add<Vec<T>, Vec<T>> for &'a [T] {\n+    #[inline]\n+    fn add(self, mut rhs: Vec<T>) -> Vec<T> {\n+        rhs.push_all(self);\n+        rhs\n+    }\n+}\n+\n #[unsafe_destructor]\n impl<T> Drop for Vec<T> {\n     fn drop(&mut self) {"}, {"sha": "5405c7aa3b7dd999d5d5bc75a72edd8e0085b153", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0669a432a2e09ad08886cb2138dbe9f5d681fb7f/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0669a432a2e09ad08886cb2138dbe9f5d681fb7f/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=0669a432a2e09ad08886cb2138dbe9f5d681fb7f", "patch": "@@ -2166,7 +2166,7 @@ impl<A: Add<A, A> + Clone> Iterator<A> for Counter<A> {\n     #[inline]\n     fn next(&mut self) -> Option<A> {\n         let result = self.state.clone();\n-        self.state = self.state + self.step;\n+        self.state = self.state.clone() + self.step.clone();\n         Some(result)\n     }\n "}, {"sha": "2416cf5bcc7ae83114f879f40748ff601526d4f3", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0669a432a2e09ad08886cb2138dbe9f5d681fb7f/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0669a432a2e09ad08886cb2138dbe9f5d681fb7f/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=0669a432a2e09ad08886cb2138dbe9f5d681fb7f", "patch": "@@ -37,8 +37,8 @@ use str::{FromStr, from_str, StrPrelude};\n /// Simultaneous division and remainder\n #[inline]\n #[deprecated = \"use division and remainder directly\"]\n-pub fn div_rem<T: Div<T, T> + Rem<T, T>>(x: T, y: T) -> (T, T) {\n-    (x / y, x % y)\n+pub fn div_rem<T: Clone + Div<T, T> + Rem<T, T>>(x: T, y: T) -> (T, T) {\n+    (x.clone() / y.clone(), x % y)\n }\n \n /// Raises a `base` to the power of `exp`, using exponentiation by squaring."}, {"sha": "7ff5026d0b9c83a5d071ca0dad8dbcc91645c54a", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 439, "deletions": 2, "changes": 441, "blob_url": "https://github.com/rust-lang/rust/blob/0669a432a2e09ad08886cb2138dbe9f5d681fb7f/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0669a432a2e09ad08886cb2138dbe9f5d681fb7f/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=0669a432a2e09ad08886cb2138dbe9f5d681fb7f", "patch": "@@ -32,13 +32,13 @@\n //! }\n //!\n //! impl Add<Point, Point> for Point {\n-//!     fn add(&self, other: &Point) -> Point {\n+//!     fn add(self, other: Point) -> Point {\n //!         Point {x: self.x + other.x, y: self.y + other.y}\n //!     }\n //! }\n //!\n //! impl Sub<Point, Point> for Point {\n-//!     fn sub(&self, other: &Point) -> Point {\n+//!     fn sub(self, other: Point) -> Point {\n //!         Point {x: self.x - other.x, y: self.y - other.y}\n //!     }\n //! }\n@@ -103,12 +103,16 @@ pub trait Drop {\n ///   Foo + Foo;\n /// }\n /// ```\n+// NOTE(stage0): Remove trait after a snapshot\n+#[cfg(stage0)]\n #[lang=\"add\"]\n pub trait Add<Sized? RHS,Result> for Sized? {\n     /// The method for the `+` operator\n     fn add(&self, rhs: &RHS) -> Result;\n }\n \n+// NOTE(stage0): Remove macro after a snapshot\n+#[cfg(stage0)]\n macro_rules! add_impl(\n     ($($t:ty)*) => ($(\n         impl Add<$t, $t> for $t {\n@@ -118,6 +122,44 @@ macro_rules! add_impl(\n     )*)\n )\n \n+/// The `Add` trait is used to specify the functionality of `+`.\n+///\n+/// # Example\n+///\n+/// A trivial implementation of `Add`. When `Foo + Foo` happens, it ends up\n+/// calling `add`, and therefore, `main` prints `Adding!`.\n+///\n+/// ```rust\n+/// struct Foo;\n+///\n+/// impl Add<Foo, Foo> for Foo {\n+///     fn add(self, _rhs: Foo) -> Foo {\n+///       println!(\"Adding!\");\n+///       self\n+///   }\n+/// }\n+///\n+/// fn main() {\n+///   Foo + Foo;\n+/// }\n+/// ```\n+#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n+#[lang=\"add\"]\n+pub trait Add<RHS, Result> {\n+    /// The method for the `+` operator\n+    fn add(self, rhs: RHS) -> Result;\n+}\n+\n+#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n+macro_rules! add_impl(\n+    ($($t:ty)*) => ($(\n+        impl Add<$t, $t> for $t {\n+            #[inline]\n+            fn add(self, other: $t) -> $t { self + other }\n+        }\n+    )*)\n+)\n+\n add_impl!(uint u8 u16 u32 u64 int i8 i16 i32 i64 f32 f64)\n \n /// The `Sub` trait is used to specify the functionality of `-`.\n@@ -143,12 +185,16 @@ add_impl!(uint u8 u16 u32 u64 int i8 i16 i32 i64 f32 f64)\n ///     Foo - Foo;\n /// }\n /// ```\n+// NOTE(stage0): Remove trait after a snapshot\n+#[cfg(stage0)]\n #[lang=\"sub\"]\n pub trait Sub<Sized? RHS, Result> for Sized? {\n     /// The method for the `-` operator\n     fn sub(&self, rhs: &RHS) -> Result;\n }\n \n+// NOTE(stage0): Remove macro after a snapshot\n+#[cfg(stage0)]\n macro_rules! sub_impl(\n     ($($t:ty)*) => ($(\n         impl Sub<$t, $t> for $t {\n@@ -158,6 +204,44 @@ macro_rules! sub_impl(\n     )*)\n )\n \n+/// The `Sub` trait is used to specify the functionality of `-`.\n+///\n+/// # Example\n+///\n+/// A trivial implementation of `Sub`. When `Foo - Foo` happens, it ends up\n+/// calling `sub`, and therefore, `main` prints `Subtracting!`.\n+///\n+/// ```rust\n+/// struct Foo;\n+///\n+/// impl Sub<Foo, Foo> for Foo {\n+///     fn sub(self, _rhs: Foo) -> Foo {\n+///         println!(\"Subtracting!\");\n+///         self\n+///     }\n+/// }\n+///\n+/// fn main() {\n+///     Foo - Foo;\n+/// }\n+/// ```\n+#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n+#[lang=\"sub\"]\n+pub trait Sub<RHS, Result> {\n+    /// The method for the `-` operator\n+    fn sub(self, rhs: RHS) -> Result;\n+}\n+\n+#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n+macro_rules! sub_impl(\n+    ($($t:ty)*) => ($(\n+        impl Sub<$t, $t> for $t {\n+            #[inline]\n+            fn sub(self, other: $t) -> $t { self - other }\n+        }\n+    )*)\n+)\n+\n sub_impl!(uint u8 u16 u32 u64 int i8 i16 i32 i64 f32 f64)\n \n /// The `Mul` trait is used to specify the functionality of `*`.\n@@ -183,12 +267,16 @@ sub_impl!(uint u8 u16 u32 u64 int i8 i16 i32 i64 f32 f64)\n ///     Foo * Foo;\n /// }\n /// ```\n+// NOTE(stage0): Remove trait after a snapshot\n+#[cfg(stage0)]\n #[lang=\"mul\"]\n pub trait Mul<Sized? RHS, Result>  for Sized? {\n     /// The method for the `*` operator\n     fn mul(&self, rhs: &RHS) -> Result;\n }\n \n+// NOTE(stage0): Remove macro after a snapshot\n+#[cfg(stage0)]\n macro_rules! mul_impl(\n     ($($t:ty)*) => ($(\n         impl Mul<$t, $t> for $t {\n@@ -198,6 +286,44 @@ macro_rules! mul_impl(\n     )*)\n )\n \n+/// The `Mul` trait is used to specify the functionality of `*`.\n+///\n+/// # Example\n+///\n+/// A trivial implementation of `Mul`. When `Foo * Foo` happens, it ends up\n+/// calling `mul`, and therefore, `main` prints `Multiplying!`.\n+///\n+/// ```rust\n+/// struct Foo;\n+///\n+/// impl Mul<Foo, Foo> for Foo {\n+///     fn mul(self, _rhs: Foo) -> Foo {\n+///         println!(\"Multiplying!\");\n+///         self\n+///     }\n+/// }\n+///\n+/// fn main() {\n+///     Foo * Foo;\n+/// }\n+/// ```\n+#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n+#[lang=\"mul\"]\n+pub trait Mul<RHS, Result> {\n+    /// The method for the `*` operator\n+    fn mul(self, rhs: RHS) -> Result;\n+}\n+\n+#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n+macro_rules! mul_impl(\n+    ($($t:ty)*) => ($(\n+        impl Mul<$t, $t> for $t {\n+            #[inline]\n+            fn mul(self, other: $t) -> $t { self * other }\n+        }\n+    )*)\n+)\n+\n mul_impl!(uint u8 u16 u32 u64 int i8 i16 i32 i64 f32 f64)\n \n /// The `Div` trait is used to specify the functionality of `/`.\n@@ -223,12 +349,16 @@ mul_impl!(uint u8 u16 u32 u64 int i8 i16 i32 i64 f32 f64)\n ///     Foo / Foo;\n /// }\n /// ```\n+// NOTE(stage0): Remove trait after a snapshot\n+#[cfg(stage0)]\n #[lang=\"div\"]\n pub trait Div<Sized? RHS, Result> for Sized? {\n     /// The method for the `/` operator\n     fn div(&self, rhs: &RHS) -> Result;\n }\n \n+// NOTE(stage0): Remove macro after a snapshot\n+#[cfg(stage0)]\n macro_rules! div_impl(\n     ($($t:ty)*) => ($(\n         impl Div<$t, $t> for $t {\n@@ -238,6 +368,44 @@ macro_rules! div_impl(\n     )*)\n )\n \n+/// The `Div` trait is used to specify the functionality of `/`.\n+///\n+/// # Example\n+///\n+/// A trivial implementation of `Div`. When `Foo / Foo` happens, it ends up\n+/// calling `div`, and therefore, `main` prints `Dividing!`.\n+///\n+/// ```\n+/// struct Foo;\n+///\n+/// impl Div<Foo, Foo> for Foo {\n+///     fn div(self, _rhs: Foo) -> Foo {\n+///         println!(\"Dividing!\");\n+///         self\n+///     }\n+/// }\n+///\n+/// fn main() {\n+///     Foo / Foo;\n+/// }\n+/// ```\n+#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n+#[lang=\"div\"]\n+pub trait Div<RHS, Result> {\n+    /// The method for the `/` operator\n+    fn div(self, rhs: RHS) -> Result;\n+}\n+\n+#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n+macro_rules! div_impl(\n+    ($($t:ty)*) => ($(\n+        impl Div<$t, $t> for $t {\n+            #[inline]\n+            fn div(self, other: $t) -> $t { self / other }\n+        }\n+    )*)\n+)\n+\n div_impl!(uint u8 u16 u32 u64 int i8 i16 i32 i64 f32 f64)\n \n /// The `Rem` trait is used to specify the functionality of `%`.\n@@ -263,12 +431,16 @@ div_impl!(uint u8 u16 u32 u64 int i8 i16 i32 i64 f32 f64)\n ///     Foo % Foo;\n /// }\n /// ```\n+// NOTE(stage0): Remove trait after a snapshot\n+#[cfg(stage0)]\n #[lang=\"rem\"]\n pub trait Rem<Sized? RHS, Result>  for Sized? {\n     /// The method for the `%` operator\n     fn rem(&self, rhs: &RHS) -> Result;\n }\n \n+// NOTE(stage0): Remove macro after a snapshot\n+#[cfg(stage0)]\n macro_rules! rem_impl(\n     ($($t:ty)*) => ($(\n         impl Rem<$t, $t> for $t {\n@@ -278,6 +450,8 @@ macro_rules! rem_impl(\n     )*)\n )\n \n+// NOTE(stage0): Remove macro after a snapshot\n+#[cfg(stage0)]\n macro_rules! rem_float_impl(\n     ($t:ty, $fmod:ident) => {\n         impl Rem<$t, $t> for $t {\n@@ -290,6 +464,57 @@ macro_rules! rem_float_impl(\n     }\n )\n \n+/// The `Rem` trait is used to specify the functionality of `%`.\n+///\n+/// # Example\n+///\n+/// A trivial implementation of `Rem`. When `Foo % Foo` happens, it ends up\n+/// calling `rem`, and therefore, `main` prints `Remainder-ing!`.\n+///\n+/// ```\n+/// struct Foo;\n+///\n+/// impl Rem<Foo, Foo> for Foo {\n+///     fn rem(self, _rhs: Foo) -> Foo {\n+///         println!(\"Remainder-ing!\");\n+///         self\n+///     }\n+/// }\n+///\n+/// fn main() {\n+///     Foo % Foo;\n+/// }\n+/// ```\n+#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n+#[lang=\"rem\"]\n+pub trait Rem<RHS, Result> {\n+    /// The method for the `%` operator\n+    fn rem(self, rhs: RHS) -> Result;\n+}\n+\n+#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n+macro_rules! rem_impl(\n+    ($($t:ty)*) => ($(\n+        impl Rem<$t, $t> for $t {\n+            #[inline]\n+            fn rem(self, other: $t) -> $t { self % other }\n+        }\n+    )*)\n+)\n+\n+#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n+macro_rules! rem_float_impl(\n+    ($t:ty, $fmod:ident) => {\n+        impl Rem<$t, $t> for $t {\n+            #[inline]\n+            fn rem(self, other: $t) -> $t {\n+                extern { fn $fmod(a: $t, b: $t) -> $t; }\n+                unsafe { $fmod(self, other) }\n+            }\n+        }\n+    }\n+)\n+\n rem_impl!(uint u8 u16 u32 u64 int i8 i16 i32 i64)\n rem_float_impl!(f32, fmodf)\n rem_float_impl!(f64, fmod)\n@@ -414,12 +639,16 @@ not_impl!(bool uint u8 u16 u32 u64 int i8 i16 i32 i64)\n ///     Foo & Foo;\n /// }\n /// ```\n+// NOTE(stage0): Remove trait after a snapshot\n+#[cfg(stage0)]\n #[lang=\"bitand\"]\n pub trait BitAnd<Sized? RHS, Result> for Sized? {\n     /// The method for the `&` operator\n     fn bitand(&self, rhs: &RHS) -> Result;\n }\n \n+// NOTE(stage0): Remove macro after a snapshot\n+#[cfg(stage0)]\n macro_rules! bitand_impl(\n     ($($t:ty)*) => ($(\n         impl BitAnd<$t, $t> for $t {\n@@ -429,6 +658,44 @@ macro_rules! bitand_impl(\n     )*)\n )\n \n+/// The `BitAnd` trait is used to specify the functionality of `&`.\n+///\n+/// # Example\n+///\n+/// A trivial implementation of `BitAnd`. When `Foo & Foo` happens, it ends up\n+/// calling `bitand`, and therefore, `main` prints `Bitwise And-ing!`.\n+///\n+/// ```\n+/// struct Foo;\n+///\n+/// impl BitAnd<Foo, Foo> for Foo {\n+///     fn bitand(self, _rhs: Foo) -> Foo {\n+///         println!(\"Bitwise And-ing!\");\n+///         self\n+///     }\n+/// }\n+///\n+/// fn main() {\n+///     Foo & Foo;\n+/// }\n+/// ```\n+#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n+#[lang=\"bitand\"]\n+pub trait BitAnd<RHS, Result> {\n+    /// The method for the `&` operator\n+    fn bitand(self, rhs: RHS) -> Result;\n+}\n+\n+#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n+macro_rules! bitand_impl(\n+    ($($t:ty)*) => ($(\n+        impl BitAnd<$t, $t> for $t {\n+            #[inline]\n+            fn bitand(self, rhs: $t) -> $t { self & rhs }\n+        }\n+    )*)\n+)\n+\n bitand_impl!(bool uint u8 u16 u32 u64 int i8 i16 i32 i64)\n \n /// The `BitOr` trait is used to specify the functionality of `|`.\n@@ -454,12 +721,16 @@ bitand_impl!(bool uint u8 u16 u32 u64 int i8 i16 i32 i64)\n ///     Foo | Foo;\n /// }\n /// ```\n+// NOTE(stage0): Remove trait after a snapshot\n+#[cfg(stage0)]\n #[lang=\"bitor\"]\n pub trait BitOr<Sized? RHS, Result> for Sized? {\n     /// The method for the `|` operator\n     fn bitor(&self, rhs: &RHS) -> Result;\n }\n \n+// NOTE(stage0): Remove macro after a snapshot\n+#[cfg(stage0)]\n macro_rules! bitor_impl(\n     ($($t:ty)*) => ($(\n         impl BitOr<$t,$t> for $t {\n@@ -469,6 +740,44 @@ macro_rules! bitor_impl(\n     )*)\n )\n \n+/// The `BitOr` trait is used to specify the functionality of `|`.\n+///\n+/// # Example\n+///\n+/// A trivial implementation of `BitOr`. When `Foo | Foo` happens, it ends up\n+/// calling `bitor`, and therefore, `main` prints `Bitwise Or-ing!`.\n+///\n+/// ```\n+/// struct Foo;\n+///\n+/// impl BitOr<Foo, Foo> for Foo {\n+///     fn bitor(self, _rhs: Foo) -> Foo {\n+///         println!(\"Bitwise Or-ing!\");\n+///         self\n+///     }\n+/// }\n+///\n+/// fn main() {\n+///     Foo | Foo;\n+/// }\n+/// ```\n+#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n+#[lang=\"bitor\"]\n+pub trait BitOr<RHS, Result> {\n+    /// The method for the `|` operator\n+    fn bitor(self, rhs: RHS) -> Result;\n+}\n+\n+#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n+macro_rules! bitor_impl(\n+    ($($t:ty)*) => ($(\n+        impl BitOr<$t,$t> for $t {\n+            #[inline]\n+            fn bitor(self, rhs: $t) -> $t { self | rhs }\n+        }\n+    )*)\n+)\n+\n bitor_impl!(bool uint u8 u16 u32 u64 int i8 i16 i32 i64)\n \n /// The `BitXor` trait is used to specify the functionality of `^`.\n@@ -494,12 +803,16 @@ bitor_impl!(bool uint u8 u16 u32 u64 int i8 i16 i32 i64)\n ///     Foo ^ Foo;\n /// }\n /// ```\n+// NOTE(stage0): Remove trait after a snapshot\n+#[cfg(stage0)]\n #[lang=\"bitxor\"]\n pub trait BitXor<Sized? RHS, Result> for Sized? {\n     /// The method for the `^` operator\n     fn bitxor(&self, rhs: &RHS) -> Result;\n }\n \n+// NOTE(stage0): Remove macro after a snapshot\n+#[cfg(stage0)]\n macro_rules! bitxor_impl(\n     ($($t:ty)*) => ($(\n         impl BitXor<$t, $t> for $t {\n@@ -509,6 +822,44 @@ macro_rules! bitxor_impl(\n     )*)\n )\n \n+/// The `BitXor` trait is used to specify the functionality of `^`.\n+///\n+/// # Example\n+///\n+/// A trivial implementation of `BitXor`. When `Foo ^ Foo` happens, it ends up\n+/// calling `bitxor`, and therefore, `main` prints `Bitwise Xor-ing!`.\n+///\n+/// ```\n+/// struct Foo;\n+///\n+/// impl BitXor<Foo, Foo> for Foo {\n+///     fn bitxor(self, _rhs: Foo) -> Foo {\n+///         println!(\"Bitwise Xor-ing!\");\n+///         self\n+///     }\n+/// }\n+///\n+/// fn main() {\n+///     Foo ^ Foo;\n+/// }\n+/// ```\n+#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n+#[lang=\"bitxor\"]\n+pub trait BitXor<RHS, Result> {\n+    /// The method for the `^` operator\n+    fn bitxor(self, rhs: RHS) -> Result;\n+}\n+\n+#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n+macro_rules! bitxor_impl(\n+    ($($t:ty)*) => ($(\n+        impl BitXor<$t, $t> for $t {\n+            #[inline]\n+            fn bitxor(self, other: $t) -> $t { self ^ other }\n+        }\n+    )*)\n+)\n+\n bitxor_impl!(bool uint u8 u16 u32 u64 int i8 i16 i32 i64)\n \n /// The `Shl` trait is used to specify the functionality of `<<`.\n@@ -534,12 +885,16 @@ bitxor_impl!(bool uint u8 u16 u32 u64 int i8 i16 i32 i64)\n ///     Foo << Foo;\n /// }\n /// ```\n+// NOTE(stage0): Remove trait after a snapshot\n+#[cfg(stage0)]\n #[lang=\"shl\"]\n pub trait Shl<Sized? RHS, Result> for Sized? {\n     /// The method for the `<<` operator\n     fn shl(&self, rhs: &RHS) -> Result;\n }\n \n+// NOTE(stage0): Remove macro after a snapshot\n+#[cfg(stage0)]\n macro_rules! shl_impl(\n     ($($t:ty)*) => ($(\n         impl Shl<uint, $t> for $t {\n@@ -551,6 +906,46 @@ macro_rules! shl_impl(\n     )*)\n )\n \n+/// The `Shl` trait is used to specify the functionality of `<<`.\n+///\n+/// # Example\n+///\n+/// A trivial implementation of `Shl`. When `Foo << Foo` happens, it ends up\n+/// calling `shl`, and therefore, `main` prints `Shifting left!`.\n+///\n+/// ```\n+/// struct Foo;\n+///\n+/// impl Shl<Foo, Foo> for Foo {\n+///     fn shl(self, _rhs: Foo) -> Foo {\n+///         println!(\"Shifting left!\");\n+///         self\n+///     }\n+/// }\n+///\n+/// fn main() {\n+///     Foo << Foo;\n+/// }\n+/// ```\n+#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n+#[lang=\"shl\"]\n+pub trait Shl<RHS, Result> {\n+    /// The method for the `<<` operator\n+    fn shl(self, rhs: RHS) -> Result;\n+}\n+\n+#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n+macro_rules! shl_impl(\n+    ($($t:ty)*) => ($(\n+        impl Shl<uint, $t> for $t {\n+            #[inline]\n+            fn shl(self, other: uint) -> $t {\n+                self << other\n+            }\n+        }\n+    )*)\n+)\n+\n shl_impl!(uint u8 u16 u32 u64 int i8 i16 i32 i64)\n \n /// The `Shr` trait is used to specify the functionality of `>>`.\n@@ -576,12 +971,16 @@ shl_impl!(uint u8 u16 u32 u64 int i8 i16 i32 i64)\n ///     Foo >> Foo;\n /// }\n /// ```\n+// NOTE(stage0): Remove trait after a snapshot\n+#[cfg(stage0)]\n #[lang=\"shr\"]\n pub trait Shr<Sized? RHS, Result> for Sized? {\n     /// The method for the `>>` operator\n     fn shr(&self, rhs: &RHS) -> Result;\n }\n \n+// NOTE(stage0): Remove macro after a snapshot\n+#[cfg(stage0)]\n macro_rules! shr_impl(\n     ($($t:ty)*) => ($(\n         impl Shr<uint, $t> for $t {\n@@ -591,6 +990,44 @@ macro_rules! shr_impl(\n     )*)\n )\n \n+/// The `Shr` trait is used to specify the functionality of `>>`.\n+///\n+/// # Example\n+///\n+/// A trivial implementation of `Shr`. When `Foo >> Foo` happens, it ends up\n+/// calling `shr`, and therefore, `main` prints `Shifting right!`.\n+///\n+/// ```\n+/// struct Foo;\n+///\n+/// impl Shr<Foo, Foo> for Foo {\n+///     fn shr(self, _rhs: Foo) -> Foo {\n+///         println!(\"Shifting right!\");\n+///         self\n+///     }\n+/// }\n+///\n+/// fn main() {\n+///     Foo >> Foo;\n+/// }\n+/// ```\n+#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n+#[lang=\"shr\"]\n+pub trait Shr<RHS, Result> {\n+    /// The method for the `>>` operator\n+    fn shr(self, rhs: RHS) -> Result;\n+}\n+\n+#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n+macro_rules! shr_impl(\n+    ($($t:ty)*) => ($(\n+        impl Shr<uint, $t> for $t {\n+            #[inline]\n+            fn shr(self, other: uint) -> $t { self >> other }\n+        }\n+    )*)\n+)\n+\n shr_impl!(uint u8 u16 u32 u64 int i8 i16 i32 i64)\n \n /// The `Index` trait is used to specify the functionality of indexing operations"}, {"sha": "87e2fe752995c096456c8e442db10c0a1d470bd8", "filename": "src/libcoretest/num/int_macros.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0669a432a2e09ad08886cb2138dbe9f5d681fb7f/src%2Flibcoretest%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0669a432a2e09ad08886cb2138dbe9f5d681fb7f/src%2Flibcoretest%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fint_macros.rs?ref=0669a432a2e09ad08886cb2138dbe9f5d681fb7f", "patch": "@@ -64,11 +64,11 @@ mod tests {\n \n     #[test]\n     fn test_bitwise_operators() {\n-        assert!(0b1110 as $T == (0b1100 as $T).bitor(&(0b1010 as $T)));\n-        assert!(0b1000 as $T == (0b1100 as $T).bitand(&(0b1010 as $T)));\n-        assert!(0b0110 as $T == (0b1100 as $T).bitxor(&(0b1010 as $T)));\n-        assert!(0b1110 as $T == (0b0111 as $T).shl(&1));\n-        assert!(0b0111 as $T == (0b1110 as $T).shr(&1));\n+        assert!(0b1110 as $T == (0b1100 as $T).bitor(0b1010 as $T));\n+        assert!(0b1000 as $T == (0b1100 as $T).bitand(0b1010 as $T));\n+        assert!(0b0110 as $T == (0b1100 as $T).bitxor(0b1010 as $T));\n+        assert!(0b1110 as $T == (0b0111 as $T).shl(1));\n+        assert!(0b0111 as $T == (0b1110 as $T).shr(1));\n         assert!(-(0b11 as $T) - (1 as $T) == (0b11 as $T).not());\n     }\n "}, {"sha": "b7f8b81f996de710e370418552ce0aacaace03e6", "filename": "src/libcoretest/num/mod.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/0669a432a2e09ad08886cb2138dbe9f5d681fb7f/src%2Flibcoretest%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0669a432a2e09ad08886cb2138dbe9f5d681fb7f/src%2Flibcoretest%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fmod.rs?ref=0669a432a2e09ad08886cb2138dbe9f5d681fb7f", "patch": "@@ -12,6 +12,7 @@ use core::cmp::PartialEq;\n use core::fmt::Show;\n use core::num::{NumCast, cast};\n use core::ops::{Add, Sub, Mul, Div, Rem};\n+use core::kinds::Copy;\n \n mod int_macros;\n mod i8;\n@@ -32,18 +33,19 @@ pub fn test_num<T>(ten: T, two: T) where\n      + Add<T, T> + Sub<T, T>\n      + Mul<T, T> + Div<T, T>\n      + Rem<T, T> + Show\n+     + Copy\n {\n-    assert_eq!(ten.add(&two),  cast(12i).unwrap());\n-    assert_eq!(ten.sub(&two),  cast(8i).unwrap());\n-    assert_eq!(ten.mul(&two),  cast(20i).unwrap());\n-    assert_eq!(ten.div(&two),  cast(5i).unwrap());\n-    assert_eq!(ten.rem(&two),  cast(0i).unwrap());\n+    assert_eq!(ten.add(two),  cast(12i).unwrap());\n+    assert_eq!(ten.sub(two),  cast(8i).unwrap());\n+    assert_eq!(ten.mul(two),  cast(20i).unwrap());\n+    assert_eq!(ten.div(two),  cast(5i).unwrap());\n+    assert_eq!(ten.rem(two),  cast(0i).unwrap());\n \n-    assert_eq!(ten.add(&two),  ten + two);\n-    assert_eq!(ten.sub(&two),  ten - two);\n-    assert_eq!(ten.mul(&two),  ten * two);\n-    assert_eq!(ten.div(&two),  ten / two);\n-    assert_eq!(ten.rem(&two),  ten % two);\n+    assert_eq!(ten.add(two),  ten + two);\n+    assert_eq!(ten.sub(two),  ten - two);\n+    assert_eq!(ten.mul(two),  ten * two);\n+    assert_eq!(ten.div(two),  ten / two);\n+    assert_eq!(ten.rem(two),  ten % two);\n }\n \n #[cfg(test)]"}, {"sha": "5657a43de1922ec8a2e1a347ea95974d9db90a56", "filename": "src/libcoretest/num/uint_macros.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0669a432a2e09ad08886cb2138dbe9f5d681fb7f/src%2Flibcoretest%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0669a432a2e09ad08886cb2138dbe9f5d681fb7f/src%2Flibcoretest%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fuint_macros.rs?ref=0669a432a2e09ad08886cb2138dbe9f5d681fb7f", "patch": "@@ -31,11 +31,11 @@ mod tests {\n \n     #[test]\n     fn test_bitwise_operators() {\n-        assert!(0b1110 as $T == (0b1100 as $T).bitor(&(0b1010 as $T)));\n-        assert!(0b1000 as $T == (0b1100 as $T).bitand(&(0b1010 as $T)));\n-        assert!(0b0110 as $T == (0b1100 as $T).bitxor(&(0b1010 as $T)));\n-        assert!(0b1110 as $T == (0b0111 as $T).shl(&1u));\n-        assert!(0b0111 as $T == (0b1110 as $T).shr(&1u));\n+        assert!(0b1110 as $T == (0b1100 as $T).bitor(0b1010 as $T));\n+        assert!(0b1000 as $T == (0b1100 as $T).bitand(0b1010 as $T));\n+        assert!(0b0110 as $T == (0b1100 as $T).bitxor(0b1010 as $T));\n+        assert!(0b1110 as $T == (0b0111 as $T).shl(1u));\n+        assert!(0b0111 as $T == (0b1110 as $T).shr(1u));\n         assert!(MAX - (0b1011 as $T) == (0b1011 as $T).not());\n     }\n "}, {"sha": "746a6fc6e70a2e1834ca1d4ef840351626c357fb", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 32, "deletions": 8, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/0669a432a2e09ad08886cb2138dbe9f5d681fb7f/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0669a432a2e09ad08886cb2138dbe9f5d681fb7f/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=0669a432a2e09ad08886cb2138dbe9f5d681fb7f", "patch": "@@ -30,7 +30,7 @@ use middle::ty::{MethodStatic, MethodStaticUnboxedClosure};\n use util::ppaux::Repr;\n \n use std::kinds;\n-use syntax::ast;\n+use syntax::{ast, ast_util};\n use syntax::ptr::P;\n use syntax::codemap::Span;\n \n@@ -329,6 +329,12 @@ macro_rules! return_if_err(\n     )\n )\n \n+/// Whether the elements of an overloaded operation are passed by value or by reference\n+enum PassArgs {\n+    ByValue,\n+    ByRef,\n+}\n+\n impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n     pub fn new(delegate: &'d mut Delegate<'tcx>,\n                typer: &'t TYPER,\n@@ -438,7 +444,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n             ast::ExprPath(..) => { }\n \n             ast::ExprUnary(ast::UnDeref, ref base) => {      // *base\n-                if !self.walk_overloaded_operator(expr, &**base, Vec::new()) {\n+                if !self.walk_overloaded_operator(expr, &**base, Vec::new(), PassArgs::ByRef) {\n                     self.select_from_expr(&**base);\n                 }\n             }\n@@ -452,7 +458,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n             }\n \n             ast::ExprIndex(ref lhs, ref rhs) => {       // lhs[rhs]\n-                if !self.walk_overloaded_operator(expr, &**lhs, vec![&**rhs]) {\n+                if !self.walk_overloaded_operator(expr, &**lhs, vec![&**rhs], PassArgs::ByRef) {\n                     self.select_from_expr(&**lhs);\n                     self.consume_expr(&**rhs);\n                 }\n@@ -465,7 +471,8 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                     (&None, &Some(ref e)) => vec![&**e],\n                     (&None, &None) => Vec::new()\n                 };\n-                let overloaded = self.walk_overloaded_operator(expr, &**base, args);\n+                let overloaded =\n+                    self.walk_overloaded_operator(expr, &**base, args, PassArgs::ByRef);\n                 assert!(overloaded);\n             }\n \n@@ -570,13 +577,19 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n             }\n \n             ast::ExprUnary(_, ref lhs) => {\n-                if !self.walk_overloaded_operator(expr, &**lhs, Vec::new()) {\n+                if !self.walk_overloaded_operator(expr, &**lhs, Vec::new(), PassArgs::ByRef) {\n                     self.consume_expr(&**lhs);\n                 }\n             }\n \n-            ast::ExprBinary(_, ref lhs, ref rhs) => {\n-                if !self.walk_overloaded_operator(expr, &**lhs, vec![&**rhs]) {\n+            ast::ExprBinary(op, ref lhs, ref rhs) => {\n+                let pass_args = if ast_util::is_by_value_binop(op) {\n+                    PassArgs::ByValue\n+                } else {\n+                    PassArgs::ByRef\n+                };\n+\n+                if !self.walk_overloaded_operator(expr, &**lhs, vec![&**rhs], pass_args) {\n                     self.consume_expr(&**lhs);\n                     self.consume_expr(&**rhs);\n                 }\n@@ -910,13 +923,24 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n     fn walk_overloaded_operator(&mut self,\n                                 expr: &ast::Expr,\n                                 receiver: &ast::Expr,\n-                                rhs: Vec<&ast::Expr>)\n+                                rhs: Vec<&ast::Expr>,\n+                                pass_args: PassArgs)\n                                 -> bool\n     {\n         if !self.typer.is_method_call(expr.id) {\n             return false;\n         }\n \n+        match pass_args {\n+            PassArgs::ByValue => {\n+                self.consume_expr(receiver);\n+                self.consume_expr(rhs[0]);\n+\n+                return true;\n+            },\n+            PassArgs::ByRef => {},\n+        }\n+\n         self.walk_expr(receiver);\n \n         // Arguments (but not receivers) to overloaded operator"}, {"sha": "50c324c49c382b5fd5dde30c808c46a3c0290f48", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/0669a432a2e09ad08886cb2138dbe9f5d681fb7f/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0669a432a2e09ad08886cb2138dbe9f5d681fb7f/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=0669a432a2e09ad08886cb2138dbe9f5d681fb7f", "patch": "@@ -2859,24 +2859,51 @@ impl TypeContents {\n     }\n }\n \n+// NOTE(stage0): Remove impl after a snapshot\n+#[cfg(stage0)]\n impl ops::BitOr<TypeContents,TypeContents> for TypeContents {\n     fn bitor(&self, other: &TypeContents) -> TypeContents {\n         TypeContents {bits: self.bits | other.bits}\n     }\n }\n \n+#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n+impl ops::BitOr<TypeContents,TypeContents> for TypeContents {\n+    fn bitor(self, other: TypeContents) -> TypeContents {\n+        TypeContents {bits: self.bits | other.bits}\n+    }\n+}\n+\n+// NOTE(stage0): Remove impl after a snapshot\n+#[cfg(stage0)]\n impl ops::BitAnd<TypeContents,TypeContents> for TypeContents {\n     fn bitand(&self, other: &TypeContents) -> TypeContents {\n         TypeContents {bits: self.bits & other.bits}\n     }\n }\n \n+#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n+impl ops::BitAnd<TypeContents, TypeContents> for TypeContents {\n+    fn bitand(self, other: TypeContents) -> TypeContents {\n+        TypeContents {bits: self.bits & other.bits}\n+    }\n+}\n+\n+// NOTE(stage0): Remove impl after a snapshot\n+#[cfg(stage0)]\n impl ops::Sub<TypeContents,TypeContents> for TypeContents {\n     fn sub(&self, other: &TypeContents) -> TypeContents {\n         TypeContents {bits: self.bits & !other.bits}\n     }\n }\n \n+#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n+impl ops::Sub<TypeContents, TypeContents> for TypeContents {\n+    fn sub(self, other: TypeContents) -> TypeContents {\n+        TypeContents {bits: self.bits & !other.bits}\n+    }\n+}\n+\n impl fmt::Show for TypeContents {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"TypeContents({:b})\", self.bits)"}, {"sha": "68d39a7e2acff279555a0b208eea309c7b8e5de3", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0669a432a2e09ad08886cb2138dbe9f5d681fb7f/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0669a432a2e09ad08886cb2138dbe9f5d681fb7f/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=0669a432a2e09ad08886cb2138dbe9f5d681fb7f", "patch": "@@ -848,10 +848,11 @@ pub enum CallArgs<'a, 'tcx> {\n     // value.\n     ArgVals(&'a [ValueRef]),\n \n-    // For overloaded operators: `(lhs, Vec(rhs, rhs_id))`. `lhs`\n+    // For overloaded operators: `(lhs, Vec(rhs, rhs_id), autoref)`. `lhs`\n     // is the left-hand-side and `rhs/rhs_id` is the datum/expr-id of\n-    // the right-hand-side arguments (if any).\n-    ArgOverloadedOp(Datum<'tcx, Expr>, Vec<(Datum<'tcx, Expr>, ast::NodeId)>),\n+    // the right-hand-side arguments (if any). `autoref` indicates whether the `rhs`\n+    // arguments should be auto-referenced\n+    ArgOverloadedOp(Datum<'tcx, Expr>, Vec<(Datum<'tcx, Expr>, ast::NodeId)>, bool),\n \n     // Supply value of arguments as a list of expressions that must be\n     // translated, for overloaded call operators.\n@@ -1023,7 +1024,7 @@ pub fn trans_args<'a, 'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n                                               arg_cleanup_scope,\n                                               ignore_self)\n         }\n-        ArgOverloadedOp(lhs, rhs) => {\n+        ArgOverloadedOp(lhs, rhs, autoref) => {\n             assert!(!variadic);\n \n             llargs.push(unpack_result!(bcx, {\n@@ -1037,7 +1038,7 @@ pub fn trans_args<'a, 'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n                 llargs.push(unpack_result!(bcx, {\n                     trans_arg_datum(bcx, arg_tys[1], rhs,\n                                     arg_cleanup_scope,\n-                                    DoAutorefArg(rhs_id))\n+                                    if autoref { DoAutorefArg(rhs_id) } else { DontAutorefArg })\n                 }));\n             }\n         }"}, {"sha": "690e7cf81f5f581e7aa5f03ab436e5849bb1adc3", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/0669a432a2e09ad08886cb2138dbe9f5d681fb7f/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0669a432a2e09ad08886cb2138dbe9f5d681fb7f/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=0669a432a2e09ad08886cb2138dbe9f5d681fb7f", "patch": "@@ -609,7 +609,8 @@ fn trans_datum_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                                method_call,\n                                                base_datum,\n                                                args,\n-                                               Some(SaveIn(scratch.val))));\n+                                               Some(SaveIn(scratch.val)),\n+                                               true));\n             DatumBlock::new(bcx, scratch.to_expr_datum())\n         }\n         ast::ExprBox(_, ref contents) => {\n@@ -762,7 +763,8 @@ fn trans_index<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                                method_call,\n                                                base_datum,\n                                                vec![(ix_datum, idx.id)],\n-                                               Some(SaveIn(scratch.val))));\n+                                               Some(SaveIn(scratch.val)),\n+                                               true));\n             let datum = scratch.to_expr_datum();\n             if ty::type_is_sized(bcx.tcx(), elt_ty) {\n                 Datum::new(datum.to_llscalarish(bcx), elt_ty, LvalueExpr)\n@@ -1091,25 +1093,26 @@ fn trans_rvalue_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                       callee::ArgExprs(args.as_slice()),\n                                       dest)\n         }\n-        ast::ExprBinary(_, ref lhs, ref rhs) => {\n+        ast::ExprBinary(op, ref lhs, ref rhs) => {\n             // if not overloaded, would be RvalueDatumExpr\n             let lhs = unpack_datum!(bcx, trans(bcx, &**lhs));\n             let rhs_datum = unpack_datum!(bcx, trans(bcx, &**rhs));\n             trans_overloaded_op(bcx, expr, MethodCall::expr(expr.id), lhs,\n-                                vec![(rhs_datum, rhs.id)], Some(dest)).bcx\n+                                vec![(rhs_datum, rhs.id)], Some(dest),\n+                                !ast_util::is_by_value_binop(op)).bcx\n         }\n         ast::ExprUnary(_, ref subexpr) => {\n             // if not overloaded, would be RvalueDatumExpr\n             let arg = unpack_datum!(bcx, trans(bcx, &**subexpr));\n             trans_overloaded_op(bcx, expr, MethodCall::expr(expr.id),\n-                                arg, Vec::new(), Some(dest)).bcx\n+                                arg, Vec::new(), Some(dest), true).bcx\n         }\n         ast::ExprIndex(ref base, ref idx) => {\n             // if not overloaded, would be RvalueDatumExpr\n             let base = unpack_datum!(bcx, trans(bcx, &**base));\n             let idx_datum = unpack_datum!(bcx, trans(bcx, &**idx));\n             trans_overloaded_op(bcx, expr, MethodCall::expr(expr.id), base,\n-                                vec![(idx_datum, idx.id)], Some(dest)).bcx\n+                                vec![(idx_datum, idx.id)], Some(dest), true).bcx\n         }\n         ast::ExprCast(ref val, _) => {\n             // DPS output mode means this is a trait cast:\n@@ -1802,7 +1805,8 @@ fn trans_overloaded_op<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                    method_call: MethodCall,\n                                    lhs: Datum<'tcx, Expr>,\n                                    rhs: Vec<(Datum<'tcx, Expr>, ast::NodeId)>,\n-                                   dest: Option<Dest>)\n+                                   dest: Option<Dest>,\n+                                   autoref: bool)\n                                    -> Result<'blk, 'tcx> {\n     let method_ty = (*bcx.tcx().method_map.borrow())[method_call].ty;\n     callee::trans_call_inner(bcx,\n@@ -1814,7 +1818,7 @@ fn trans_overloaded_op<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                                           None,\n                                                           arg_cleanup_scope)\n                              },\n-                             callee::ArgOverloadedOp(lhs, rhs),\n+                             callee::ArgOverloadedOp(lhs, rhs, autoref),\n                              dest)\n }\n \n@@ -2121,7 +2125,8 @@ fn deref_once<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             let scratch = rvalue_scratch_datum(bcx, ref_ty, \"overloaded_deref\");\n \n             unpack_result!(bcx, trans_overloaded_op(bcx, expr, method_call,\n-                                                    datum, Vec::new(), Some(SaveIn(scratch.val))));\n+                                                    datum, Vec::new(), Some(SaveIn(scratch.val)),\n+                                                    false));\n             scratch.to_expr_datum()\n         }\n         None => {"}, {"sha": "cf7868148e71f0d9db459242198f20ea0c62526b", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 23, "deletions": 22, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/0669a432a2e09ad08886cb2138dbe9f5d681fb7f/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0669a432a2e09ad08886cb2138dbe9f5d681fb7f/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=0669a432a2e09ad08886cb2138dbe9f5d681fb7f", "patch": "@@ -77,7 +77,6 @@ type parameter).\n */\n \n pub use self::LvaluePreference::*;\n-pub use self::DerefArgs::*;\n pub use self::Expectation::*;\n use self::IsBinopAssignment::*;\n use self::TupleArgumentsFlag::*;\n@@ -2115,7 +2114,7 @@ fn try_overloaded_call<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                                       method_callee.ty,\n                                                       call_expression,\n                                                       args,\n-                                                      DontDerefArgs,\n+                                                      AutorefArgs::No,\n                                                       TupleArguments);\n         fcx.inh.method_map.borrow_mut().insert(method_call, method_callee);\n         write_call(fcx, call_expression, output_type);\n@@ -2264,7 +2263,7 @@ fn try_overloaded_slice<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                 method_ty_or_err,\n                                 expr,\n                                 args.as_slice(),\n-                                DoDerefArgs,\n+                                AutorefArgs::Yes,\n                                 DontTupleArguments);\n \n     opt_method_ty.map(|method_ty| {\n@@ -2470,7 +2469,7 @@ fn lookup_method_for_for_loop<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                                   method_type,\n                                                   iterator_expr,\n                                                   &[],\n-                                                  DontDerefArgs,\n+                                                  AutorefArgs::No,\n                                                   DontTupleArguments);\n \n     match method {\n@@ -2512,7 +2511,7 @@ fn check_method_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                          method_fn_ty: Ty<'tcx>,\n                                          callee_expr: &ast::Expr,\n                                          args_no_rcvr: &[&P<ast::Expr>],\n-                                         deref_args: DerefArgs,\n+                                         autoref_args: AutorefArgs,\n                                          tuple_arguments: TupleArgumentsFlag)\n                                          -> ty::FnOutput<'tcx> {\n     if ty::type_is_error(method_fn_ty) {\n@@ -2528,7 +2527,7 @@ fn check_method_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                              err_inputs.as_slice(),\n                              callee_expr,\n                              args_no_rcvr,\n-                             deref_args,\n+                             autoref_args,\n                              false,\n                              tuple_arguments);\n         ty::FnConverging(ty::mk_err())\n@@ -2541,7 +2540,7 @@ fn check_method_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                      fty.sig.inputs.slice_from(1),\n                                      callee_expr,\n                                      args_no_rcvr,\n-                                     deref_args,\n+                                     autoref_args,\n                                      fty.sig.variadic,\n                                      tuple_arguments);\n                 fty.sig.output\n@@ -2561,7 +2560,7 @@ fn check_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                   fn_inputs: &[Ty<'tcx>],\n                                   _callee_expr: &ast::Expr,\n                                   args: &[&P<ast::Expr>],\n-                                  deref_args: DerefArgs,\n+                                  autoref_args: AutorefArgs,\n                                   variadic: bool,\n                                   tuple_arguments: TupleArgumentsFlag) {\n     let tcx = fcx.ccx.tcx;\n@@ -2664,8 +2663,8 @@ fn check_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                 debug!(\"checking the argument\");\n                 let mut formal_ty = formal_tys[i];\n \n-                match deref_args {\n-                    DoDerefArgs => {\n+                match autoref_args {\n+                    AutorefArgs::Yes => {\n                         match formal_ty.sty {\n                             ty::ty_rptr(_, mt) => formal_ty = mt.ty,\n                             ty::ty_err => (),\n@@ -2680,7 +2679,7 @@ fn check_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                             }\n                         }\n                     }\n-                    DontDerefArgs => {}\n+                    AutorefArgs::No => {}\n                 }\n \n                 check_expr_coercable_to_type(fcx, &***arg, formal_ty);\n@@ -2894,12 +2893,13 @@ pub fn lookup_tup_field_ty<'tcx>(tcx: &ty::ctxt<'tcx>,\n \n // Controls whether the arguments are automatically referenced. This is useful\n // for overloaded binary and unary operators.\n-pub enum DerefArgs {\n-    DontDerefArgs,\n-    DoDerefArgs\n+#[deriving(PartialEq)]\n+pub enum AutorefArgs {\n+    Yes,\n+    No,\n }\n \n-impl Copy for DerefArgs {}\n+impl Copy for AutorefArgs {}\n \n /// Controls whether the arguments are tupled. This is used for the call\n /// operator.\n@@ -2987,7 +2987,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                              fn_sig.inputs.as_slice(),\n                              f,\n                              args,\n-                             DontDerefArgs,\n+                             AutorefArgs::No,\n                              fn_sig.variadic,\n                              DontTupleArguments);\n \n@@ -3037,7 +3037,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                                  fn_ty,\n                                                  expr,\n                                                  args.as_slice(),\n-                                                 DontDerefArgs,\n+                                                 AutorefArgs::No,\n                                                  DontTupleArguments);\n \n         write_call(fcx, expr, ret_ty);\n@@ -3120,7 +3120,8 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                      trait_did: Option<ast::DefId>,\n                                      lhs: &'a ast::Expr,\n                                      rhs: Option<&P<ast::Expr>>,\n-                                     unbound_method: F) -> Ty<'tcx> where\n+                                     unbound_method: F,\n+                                     autoref_args: AutorefArgs) -> Ty<'tcx> where\n         F: FnOnce(),\n     {\n         let method = match trait_did {\n@@ -3173,7 +3174,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                             method_ty,\n                                             op_ex,\n                                             args.as_slice(),\n-                                            DoDerefArgs,\n+                                            autoref_args,\n                                             DontTupleArguments) {\n                     ty::FnConverging(result_type) => result_type,\n                     ty::FnDiverging => ty::mk_err()\n@@ -3189,7 +3190,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                             expected_ty,\n                                             op_ex,\n                                             args.as_slice(),\n-                                            DoDerefArgs,\n+                                            autoref_args,\n                                             DontTupleArguments);\n                 ty::mk_err()\n             }\n@@ -3337,7 +3338,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                         ast_util::binop_to_string(op),\n                         actual)\n             }, lhs_resolved_t, None)\n-        })\n+        }, if ast_util::is_by_value_binop(op) { AutorefArgs::No } else { AutorefArgs::Yes })\n     }\n \n     fn check_user_unop<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n@@ -3353,7 +3354,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                 format!(\"cannot apply unary operator `{}` to type `{}`\",\n                         op_str, actual)\n             }, rhs_t, None);\n-        })\n+        }, AutorefArgs::Yes)\n     }\n \n     // Check field access expressions"}, {"sha": "217d178fe3b93ff8e0ce574b9987f166a3038de8", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0669a432a2e09ad08886cb2138dbe9f5d681fb7f/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0669a432a2e09ad08886cb2138dbe9f5d681fb7f/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=0669a432a2e09ad08886cb2138dbe9f5d681fb7f", "patch": "@@ -131,7 +131,7 @@ use middle::pat_util;\n use util::nodemap::{DefIdMap, NodeMap, FnvHashMap};\n use util::ppaux::{ty_to_string, Repr};\n \n-use syntax::ast;\n+use syntax::{ast, ast_util};\n use syntax::codemap::Span;\n use syntax::visit;\n use syntax::visit::Visitor;\n@@ -637,14 +637,22 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n             visit::walk_expr(rcx, expr);\n         }\n \n-        ast::ExprIndex(ref lhs, ref rhs) |\n-        ast::ExprBinary(_, ref lhs, ref rhs) if has_method_map => {\n+        ast::ExprIndex(ref lhs, ref rhs) if has_method_map => {\n+            constrain_call(rcx, expr, Some(&**lhs),\n+                           Some(&**rhs).into_iter(), true);\n+\n+            visit::walk_expr(rcx, expr);\n+        },\n+\n+        ast::ExprBinary(op, ref lhs, ref rhs) if has_method_map => {\n+            let implicitly_ref_args = !ast_util::is_by_value_binop(op);\n+\n             // As `expr_method_call`, but the call is via an\n             // overloaded op.  Note that we (sadly) currently use an\n             // implicit \"by ref\" sort of passing style here.  This\n             // should be converted to an adjustment!\n             constrain_call(rcx, expr, Some(&**lhs),\n-                           Some(&**rhs).into_iter(), true);\n+                           Some(&**rhs).into_iter(), implicitly_ref_args);\n \n             visit::walk_expr(rcx, expr);\n         }"}, {"sha": "4fbd249660f9f656ebe8c0339b48d409b0fa056c", "filename": "src/librustdoc/stability_summary.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0669a432a2e09ad08886cb2138dbe9f5d681fb7f/src%2Flibrustdoc%2Fstability_summary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0669a432a2e09ad08886cb2138dbe9f5d681fb7f/src%2Flibrustdoc%2Fstability_summary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fstability_summary.rs?ref=0669a432a2e09ad08886cb2138dbe9f5d681fb7f", "patch": "@@ -42,7 +42,7 @@ pub struct Counts {\n impl Copy for Counts {}\n \n impl Add<Counts, Counts> for Counts {\n-    fn add(&self, other: &Counts) -> Counts {\n+    fn add(self, other: Counts) -> Counts {\n         Counts {\n             deprecated:   self.deprecated   + other.deprecated,\n             experimental: self.experimental + other.experimental,"}, {"sha": "2be6f5057a178c7354f4e9359203c9c54d8e8c84", "filename": "src/libstd/bitflags.rs", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/0669a432a2e09ad08886cb2138dbe9f5d681fb7f/src%2Flibstd%2Fbitflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0669a432a2e09ad08886cb2138dbe9f5d681fb7f/src%2Flibstd%2Fbitflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbitflags.rs?ref=0669a432a2e09ad08886cb2138dbe9f5d681fb7f", "patch": "@@ -205,6 +205,8 @@ macro_rules! bitflags {\n             }\n         }\n \n+        // NOTE(stage0): Remove impl after a snapshot\n+        #[cfg(stage0)]\n         impl BitOr<$BitFlags, $BitFlags> for $BitFlags {\n             /// Returns the union of the two sets of flags.\n             #[inline]\n@@ -213,6 +215,17 @@ macro_rules! bitflags {\n             }\n         }\n \n+        #[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n+        impl BitOr<$BitFlags, $BitFlags> for $BitFlags {\n+            /// Returns the union of the two sets of flags.\n+            #[inline]\n+            fn bitor(self, other: $BitFlags) -> $BitFlags {\n+                $BitFlags { bits: self.bits | other.bits }\n+            }\n+        }\n+\n+        // NOTE(stage0): Remove impl after a snapshot\n+        #[cfg(stage0)]\n         impl BitXor<$BitFlags, $BitFlags> for $BitFlags {\n             /// Returns the left flags, but with all the right flags toggled.\n             #[inline]\n@@ -221,6 +234,17 @@ macro_rules! bitflags {\n             }\n         }\n \n+        #[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n+        impl BitXor<$BitFlags, $BitFlags> for $BitFlags {\n+            /// Returns the left flags, but with all the right flags toggled.\n+            #[inline]\n+            fn bitxor(self, other: $BitFlags) -> $BitFlags {\n+                $BitFlags { bits: self.bits ^ other.bits }\n+            }\n+        }\n+\n+        // NOTE(stage0): Remove impl after a snapshot\n+        #[cfg(stage0)]\n         impl BitAnd<$BitFlags, $BitFlags> for $BitFlags {\n             /// Returns the intersection between the two sets of flags.\n             #[inline]\n@@ -229,6 +253,17 @@ macro_rules! bitflags {\n             }\n         }\n \n+        #[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n+        impl BitAnd<$BitFlags, $BitFlags> for $BitFlags {\n+            /// Returns the intersection between the two sets of flags.\n+            #[inline]\n+            fn bitand(self, other: $BitFlags) -> $BitFlags {\n+                $BitFlags { bits: self.bits & other.bits }\n+            }\n+        }\n+\n+        // NOTE(stage0): Remove impl after a snapshot\n+        #[cfg(stage0)]\n         impl Sub<$BitFlags, $BitFlags> for $BitFlags {\n             /// Returns the set difference of the two sets of flags.\n             #[inline]\n@@ -237,6 +272,15 @@ macro_rules! bitflags {\n             }\n         }\n \n+        #[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n+        impl Sub<$BitFlags, $BitFlags> for $BitFlags {\n+            /// Returns the set difference of the two sets of flags.\n+            #[inline]\n+            fn sub(self, other: $BitFlags) -> $BitFlags {\n+                $BitFlags { bits: self.bits & !other.bits }\n+            }\n+        }\n+\n         impl Not<$BitFlags> for $BitFlags {\n             /// Returns the complement of this set of flags.\n             #[inline]"}, {"sha": "9aaaceb87e6d3acf37dd87df5964abec494b2b2c", "filename": "src/libstd/num/mod.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0669a432a2e09ad08886cb2138dbe9f5d681fb7f/src%2Flibstd%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0669a432a2e09ad08886cb2138dbe9f5d681fb7f/src%2Flibstd%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fmod.rs?ref=0669a432a2e09ad08886cb2138dbe9f5d681fb7f", "patch": "@@ -19,6 +19,7 @@\n #[cfg(test)] use cmp::PartialEq;\n #[cfg(test)] use fmt::Show;\n #[cfg(test)] use ops::{Add, Sub, Mul, Div, Rem};\n+#[cfg(test)] use kinds::Copy;\n \n pub use core::num::{Num, div_rem, Zero, zero, One, one};\n pub use core::num::{Unsigned, pow, Bounded};\n@@ -130,18 +131,19 @@ pub fn test_num<T>(ten: T, two: T) where\n      + Add<T, T> + Sub<T, T>\n      + Mul<T, T> + Div<T, T>\n      + Rem<T, T> + Show\n+     + Copy\n {\n-    assert_eq!(ten.add(&two),  cast(12i).unwrap());\n-    assert_eq!(ten.sub(&two),  cast(8i).unwrap());\n-    assert_eq!(ten.mul(&two),  cast(20i).unwrap());\n-    assert_eq!(ten.div(&two),  cast(5i).unwrap());\n-    assert_eq!(ten.rem(&two),  cast(0i).unwrap());\n-\n-    assert_eq!(ten.add(&two),  ten + two);\n-    assert_eq!(ten.sub(&two),  ten - two);\n-    assert_eq!(ten.mul(&two),  ten * two);\n-    assert_eq!(ten.div(&two),  ten / two);\n-    assert_eq!(ten.rem(&two),  ten % two);\n+    assert_eq!(ten.add(two),  cast(12i).unwrap());\n+    assert_eq!(ten.sub(two),  cast(8i).unwrap());\n+    assert_eq!(ten.mul(two),  cast(20i).unwrap());\n+    assert_eq!(ten.div(two),  cast(5i).unwrap());\n+    assert_eq!(ten.rem(two),  cast(0i).unwrap());\n+\n+    assert_eq!(ten.add(two),  ten + two);\n+    assert_eq!(ten.sub(two),  ten - two);\n+    assert_eq!(ten.mul(two),  ten * two);\n+    assert_eq!(ten.div(two),  ten / two);\n+    assert_eq!(ten.rem(two),  ten % two);\n }\n \n #[cfg(test)]"}, {"sha": "f98cebd9675962ea5efdb8ef8b43ea9675e82d1f", "filename": "src/libstd/time/duration.rs", "status": "modified", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/0669a432a2e09ad08886cb2138dbe9f5d681fb7f/src%2Flibstd%2Ftime%2Fduration.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0669a432a2e09ad08886cb2138dbe9f5d681fb7f/src%2Flibstd%2Ftime%2Fduration.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime%2Fduration.rs?ref=0669a432a2e09ad08886cb2138dbe9f5d681fb7f", "patch": "@@ -276,6 +276,8 @@ impl Neg<Duration> for Duration {\n     }\n }\n \n+// NOTE(stage0): Remove impl after a snapshot\n+#[cfg(stage0)]\n impl Add<Duration,Duration> for Duration {\n     fn add(&self, rhs: &Duration) -> Duration {\n         let mut secs = self.secs + rhs.secs;\n@@ -288,6 +290,21 @@ impl Add<Duration,Duration> for Duration {\n     }\n }\n \n+#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n+impl Add<Duration, Duration> for Duration {\n+    fn add(self, rhs: Duration) -> Duration {\n+        let mut secs = self.secs + rhs.secs;\n+        let mut nanos = self.nanos + rhs.nanos;\n+        if nanos >= NANOS_PER_SEC {\n+            nanos -= NANOS_PER_SEC;\n+            secs += 1;\n+        }\n+        Duration { secs: secs, nanos: nanos }\n+    }\n+}\n+\n+// NOTE(stage0): Remove impl after a snapshot\n+#[cfg(stage0)]\n impl Sub<Duration,Duration> for Duration {\n     fn sub(&self, rhs: &Duration) -> Duration {\n         let mut secs = self.secs - rhs.secs;\n@@ -300,6 +317,21 @@ impl Sub<Duration,Duration> for Duration {\n     }\n }\n \n+#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n+impl Sub<Duration, Duration> for Duration {\n+    fn sub(self, rhs: Duration) -> Duration {\n+        let mut secs = self.secs - rhs.secs;\n+        let mut nanos = self.nanos - rhs.nanos;\n+        if nanos < 0 {\n+            nanos += NANOS_PER_SEC;\n+            secs -= 1;\n+        }\n+        Duration { secs: secs, nanos: nanos }\n+    }\n+}\n+\n+// NOTE(stage0): Remove impl after a snapshot\n+#[cfg(stage0)]\n impl Mul<i32,Duration> for Duration {\n     fn mul(&self, rhs: &i32) -> Duration {\n         // Multiply nanoseconds as i64, because it cannot overflow that way.\n@@ -310,6 +342,19 @@ impl Mul<i32,Duration> for Duration {\n     }\n }\n \n+#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n+impl Mul<i32, Duration> for Duration {\n+    fn mul(self, rhs: i32) -> Duration {\n+        // Multiply nanoseconds as i64, because it cannot overflow that way.\n+        let total_nanos = self.nanos as i64 * rhs as i64;\n+        let (extra_secs, nanos) = div_mod_floor_64(total_nanos, NANOS_PER_SEC as i64);\n+        let secs = self.secs * rhs as i64 + extra_secs;\n+        Duration { secs: secs, nanos: nanos as i32 }\n+    }\n+}\n+\n+// NOTE(stage0): Remove impl after a snapshot\n+#[cfg(stage0)]\n impl Div<i32,Duration> for Duration {\n     fn div(&self, rhs: &i32) -> Duration {\n         let mut secs = self.secs / *rhs as i64;\n@@ -328,6 +373,25 @@ impl Div<i32,Duration> for Duration {\n     }\n }\n \n+#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n+impl Div<i32, Duration> for Duration {\n+    fn div(self, rhs: i32) -> Duration {\n+        let mut secs = self.secs / rhs as i64;\n+        let carry = self.secs - secs * rhs as i64;\n+        let extra_nanos = carry * NANOS_PER_SEC as i64 / rhs as i64;\n+        let mut nanos = self.nanos / rhs + extra_nanos as i32;\n+        if nanos >= NANOS_PER_SEC {\n+            nanos -= NANOS_PER_SEC;\n+            secs += 1;\n+        }\n+        if nanos < 0 {\n+            nanos += NANOS_PER_SEC;\n+            secs -= 1;\n+        }\n+        Duration { secs: secs, nanos: nanos }\n+    }\n+}\n+\n impl fmt::Show for Duration {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         // technically speaking, negative duration is not valid ISO 8601,"}, {"sha": "2e097d455153f57d7a138214f6e4cae32bd65e3e", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0669a432a2e09ad08886cb2138dbe9f5d681fb7f/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0669a432a2e09ad08886cb2138dbe9f5d681fb7f/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=0669a432a2e09ad08886cb2138dbe9f5d681fb7f", "patch": "@@ -85,6 +85,16 @@ pub fn is_shift_binop(b: BinOp) -> bool {\n     }\n }\n \n+/// Returns `true` is the binary operator takes its arguments by value\n+pub fn is_by_value_binop(b: BinOp) -> bool {\n+    match b {\n+        BiAdd | BiSub | BiMul | BiDiv | BiRem | BiBitXor | BiBitAnd | BiBitOr | BiShl | BiShr => {\n+            true\n+        }\n+        _ => false\n+    }\n+}\n+\n pub fn unop_to_string(op: UnOp) -> &'static str {\n     match op {\n       UnUniq => \"box() \","}, {"sha": "592fdd7207c7bd96c0cb8a8e5a0e0752c2e1973b", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/0669a432a2e09ad08886cb2138dbe9f5d681fb7f/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0669a432a2e09ad08886cb2138dbe9f5d681fb7f/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=0669a432a2e09ad08886cb2138dbe9f5d681fb7f", "patch": "@@ -52,35 +52,71 @@ impl Pos for BytePos {\n     fn to_uint(&self) -> uint { let BytePos(n) = *self; n as uint }\n }\n \n+// NOTE(stage0): Remove impl after a snapshot\n+#[cfg(stage0)]\n impl Add<BytePos, BytePos> for BytePos {\n     fn add(&self, rhs: &BytePos) -> BytePos {\n         BytePos((self.to_uint() + rhs.to_uint()) as u32)\n     }\n }\n \n+#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n+impl Add<BytePos, BytePos> for BytePos {\n+    fn add(self, rhs: BytePos) -> BytePos {\n+        BytePos((self.to_uint() + rhs.to_uint()) as u32)\n+    }\n+}\n+\n+// NOTE(stage0): Remove impl after a snapshot\n+#[cfg(stage0)]\n impl Sub<BytePos, BytePos> for BytePos {\n     fn sub(&self, rhs: &BytePos) -> BytePos {\n         BytePos((self.to_uint() - rhs.to_uint()) as u32)\n     }\n }\n \n+#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n+impl Sub<BytePos, BytePos> for BytePos {\n+    fn sub(self, rhs: BytePos) -> BytePos {\n+        BytePos((self.to_uint() - rhs.to_uint()) as u32)\n+    }\n+}\n+\n impl Pos for CharPos {\n     fn from_uint(n: uint) -> CharPos { CharPos(n) }\n     fn to_uint(&self) -> uint { let CharPos(n) = *self; n }\n }\n \n+// NOTE(stage0): Remove impl after a snapshot\n+#[cfg(stage0)]\n impl Add<CharPos,CharPos> for CharPos {\n     fn add(&self, rhs: &CharPos) -> CharPos {\n         CharPos(self.to_uint() + rhs.to_uint())\n     }\n }\n \n+#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n+impl Add<CharPos, CharPos> for CharPos {\n+    fn add(self, rhs: CharPos) -> CharPos {\n+        CharPos(self.to_uint() + rhs.to_uint())\n+    }\n+}\n+\n+// NOTE(stage0): Remove impl after a snapshot\n+#[cfg(stage0)]\n impl Sub<CharPos,CharPos> for CharPos {\n     fn sub(&self, rhs: &CharPos) -> CharPos {\n         CharPos(self.to_uint() - rhs.to_uint())\n     }\n }\n \n+#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n+impl Sub<CharPos, CharPos> for CharPos {\n+    fn sub(self, rhs: CharPos) -> CharPos {\n+        CharPos(self.to_uint() - rhs.to_uint())\n+    }\n+}\n+\n /// Spans represent a region of code, used for error reporting. Positions in spans\n /// are *absolute* positions from the beginning of the codemap, not positions\n /// relative to FileMaps. Methods on the CodeMap can be used to relate spans back"}, {"sha": "e2439bad178fe5c8257f7a86a5859b6f175a2363", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0669a432a2e09ad08886cb2138dbe9f5d681fb7f/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0669a432a2e09ad08886cb2138dbe9f5d681fb7f/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=0669a432a2e09ad08886cb2138dbe9f5d681fb7f", "patch": "@@ -106,6 +106,8 @@ enum LockstepIterSize {\n     LisContradiction(String),\n }\n \n+// NOTE(stage0): Remove impl after a snapshot\n+#[cfg(stage0)]\n impl Add<LockstepIterSize, LockstepIterSize> for LockstepIterSize {\n     fn add(&self, other: &LockstepIterSize) -> LockstepIterSize {\n         match *self {\n@@ -127,6 +129,28 @@ impl Add<LockstepIterSize, LockstepIterSize> for LockstepIterSize {\n     }\n }\n \n+#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n+impl Add<LockstepIterSize, LockstepIterSize> for LockstepIterSize {\n+    fn add(self, other: LockstepIterSize) -> LockstepIterSize {\n+        match self {\n+            LisUnconstrained => other,\n+            LisContradiction(_) => self,\n+            LisConstraint(l_len, ref l_id) => match other {\n+                LisUnconstrained => self.clone(),\n+                LisContradiction(_) => other,\n+                LisConstraint(r_len, _) if l_len == r_len => self.clone(),\n+                LisConstraint(r_len, r_id) => {\n+                    let l_n = token::get_ident(l_id.clone());\n+                    let r_n = token::get_ident(r_id);\n+                    LisContradiction(format!(\"inconsistent lockstep iteration: \\\n+                                              '{}' has {} items, but '{}' has {}\",\n+                                              l_n, l_len, r_n, r_len).to_string())\n+                }\n+            },\n+        }\n+    }\n+}\n+\n fn lockstep_iter_size(t: &TokenTree, r: &TtReader) -> LockstepIterSize {\n     match *t {\n         TtDelimited(_, ref delimed) => {"}, {"sha": "4129086e9ec975ae92ea370e3d169562b4a06bba", "filename": "src/libtime/lib.rs", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/0669a432a2e09ad08886cb2138dbe9f5d681fb7f/src%2Flibtime%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0669a432a2e09ad08886cb2138dbe9f5d681fb7f/src%2Flibtime%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtime%2Flib.rs?ref=0669a432a2e09ad08886cb2138dbe9f5d681fb7f", "patch": "@@ -99,6 +99,8 @@ impl Timespec {\n     }\n }\n \n+// NOTE(stage0): Remove impl after a snapshot\n+#[cfg(stage0)]\n impl Add<Duration, Timespec> for Timespec {\n     fn add(&self, other: &Duration) -> Timespec {\n         let d_sec = other.num_seconds();\n@@ -119,6 +121,29 @@ impl Add<Duration, Timespec> for Timespec {\n     }\n }\n \n+#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n+impl Add<Duration, Timespec> for Timespec {\n+    fn add(self, other: Duration) -> Timespec {\n+        let d_sec = other.num_seconds();\n+        // It is safe to unwrap the nanoseconds, because there cannot be\n+        // more than one second left, which fits in i64 and in i32.\n+        let d_nsec = (other - Duration::seconds(d_sec))\n+                     .num_nanoseconds().unwrap() as i32;\n+        let mut sec = self.sec + d_sec;\n+        let mut nsec = self.nsec + d_nsec;\n+        if nsec >= NSEC_PER_SEC {\n+            nsec -= NSEC_PER_SEC;\n+            sec += 1;\n+        } else if nsec < 0 {\n+            nsec += NSEC_PER_SEC;\n+            sec -= 1;\n+        }\n+        Timespec::new(sec, nsec)\n+    }\n+}\n+\n+// NOTE(stage0): Remove impl after a snapshot\n+#[cfg(stage0)]\n impl Sub<Timespec, Duration> for Timespec {\n     fn sub(&self, other: &Timespec) -> Duration {\n         let sec = self.sec - other.sec;\n@@ -127,6 +152,15 @@ impl Sub<Timespec, Duration> for Timespec {\n     }\n }\n \n+#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n+impl Sub<Timespec, Duration> for Timespec {\n+    fn sub(self, other: Timespec) -> Duration {\n+        let sec = self.sec - other.sec;\n+        let nsec = self.nsec - other.nsec;\n+        Duration::seconds(sec) + Duration::nanoseconds(nsec as i64)\n+    }\n+}\n+\n /// Returns the current time as a `timespec` containing the seconds and\n /// nanoseconds since 1970-01-01T00:00:00Z.\n pub fn get_time() -> Timespec {"}, {"sha": "61854aba2790de84b2fddf282aafc89bf35c84ab", "filename": "src/test/auxiliary/trait_inheritance_overloading_xc.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0669a432a2e09ad08886cb2138dbe9f5d681fb7f/src%2Ftest%2Fauxiliary%2Ftrait_inheritance_overloading_xc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0669a432a2e09ad08886cb2138dbe9f5d681fb7f/src%2Ftest%2Fauxiliary%2Ftrait_inheritance_overloading_xc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Ftrait_inheritance_overloading_xc.rs?ref=0669a432a2e09ad08886cb2138dbe9f5d681fb7f", "patch": "@@ -10,24 +10,24 @@\n \n use std::cmp::PartialEq;\n \n-pub trait MyNum : Add<Self,Self> + Sub<Self,Self> + Mul<Self,Self> + PartialEq {\n+pub trait MyNum : Add<Self,Self> + Sub<Self,Self> + Mul<Self,Self> + PartialEq + Clone {\n }\n \n-#[deriving(Show)]\n+#[deriving(Clone, Show)]\n pub struct MyInt {\n     pub val: int\n }\n \n impl Add<MyInt, MyInt> for MyInt {\n-    fn add(&self, other: &MyInt) -> MyInt { mi(self.val + other.val) }\n+    fn add(self, other: MyInt) -> MyInt { mi(self.val + other.val) }\n }\n \n impl Sub<MyInt, MyInt> for MyInt {\n-    fn sub(&self, other: &MyInt) -> MyInt { mi(self.val - other.val) }\n+    fn sub(self, other: MyInt) -> MyInt { mi(self.val - other.val) }\n }\n \n impl Mul<MyInt, MyInt> for MyInt {\n-    fn mul(&self, other: &MyInt) -> MyInt { mi(self.val * other.val) }\n+    fn mul(self, other: MyInt) -> MyInt { mi(self.val * other.val) }\n }\n \n impl PartialEq for MyInt {"}, {"sha": "2bdd148b99bd0a528d9a9851aab96e62c47200fc", "filename": "src/test/compile-fail/binop-consume-args.rs", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/0669a432a2e09ad08886cb2138dbe9f5d681fb7f/src%2Ftest%2Fcompile-fail%2Fbinop-consume-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0669a432a2e09ad08886cb2138dbe9f5d681fb7f/src%2Ftest%2Fcompile-fail%2Fbinop-consume-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbinop-consume-args.rs?ref=0669a432a2e09ad08886cb2138dbe9f5d681fb7f", "patch": "@@ -0,0 +1,73 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that binary operators consume their arguments\n+\n+fn add<A: Add<B, ()>, B>(lhs: A, rhs: B) {\n+    lhs + rhs;\n+    drop(lhs);  //~ ERROR use of moved value: `lhs`\n+    drop(rhs);  //~ ERROR use of moved value: `rhs`\n+}\n+\n+fn sub<A: Sub<B, ()>, B>(lhs: A, rhs: B) {\n+    lhs - rhs;\n+    drop(lhs);  //~ ERROR use of moved value: `lhs`\n+    drop(rhs);  //~ ERROR use of moved value: `rhs`\n+}\n+\n+fn mul<A: Mul<B, ()>, B>(lhs: A, rhs: B) {\n+    lhs * rhs;\n+    drop(lhs);  //~ ERROR use of moved value: `lhs`\n+    drop(rhs);  //~ ERROR use of moved value: `rhs`\n+}\n+\n+fn div<A: Div<B, ()>, B>(lhs: A, rhs: B) {\n+    lhs / rhs;\n+    drop(lhs);  //~ ERROR use of moved value: `lhs`\n+    drop(rhs);  //~ ERROR use of moved value: `rhs`\n+}\n+\n+fn rem<A: Rem<B, ()>, B>(lhs: A, rhs: B) {\n+    lhs % rhs;\n+    drop(lhs);  //~ ERROR use of moved value: `lhs`\n+    drop(rhs);  //~ ERROR use of moved value: `rhs`\n+}\n+\n+fn bitand<A: BitAnd<B, ()>, B>(lhs: A, rhs: B) {\n+    lhs & rhs;\n+    drop(lhs);  //~ ERROR use of moved value: `lhs`\n+    drop(rhs);  //~ ERROR use of moved value: `rhs`\n+}\n+\n+fn bitor<A: BitOr<B, ()>, B>(lhs: A, rhs: B) {\n+    lhs | rhs;\n+    drop(lhs);  //~ ERROR use of moved value: `lhs`\n+    drop(rhs);  //~ ERROR use of moved value: `rhs`\n+}\n+\n+fn bitxor<A: BitXor<B, ()>, B>(lhs: A, rhs: B) {\n+    lhs ^ rhs;\n+    drop(lhs);  //~ ERROR use of moved value: `lhs`\n+    drop(rhs);  //~ ERROR use of moved value: `rhs`\n+}\n+\n+fn shl<A: Shl<B, ()>, B>(lhs: A, rhs: B) {\n+    lhs << rhs;\n+    drop(lhs);  //~ ERROR use of moved value: `lhs`\n+    drop(rhs);  //~ ERROR use of moved value: `rhs`\n+}\n+\n+fn shr<A: Shr<B, ()>, B>(lhs: A, rhs: B) {\n+    lhs >> rhs;\n+    drop(lhs);  //~ ERROR use of moved value: `lhs`\n+    drop(rhs);  //~ ERROR use of moved value: `rhs`\n+}\n+\n+fn main() {}"}, {"sha": "d9440e18375724196b3332e2ce9d24367bc0229f", "filename": "src/test/compile-fail/binop-move-semantics.rs", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/0669a432a2e09ad08886cb2138dbe9f5d681fb7f/src%2Ftest%2Fcompile-fail%2Fbinop-move-semantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0669a432a2e09ad08886cb2138dbe9f5d681fb7f/src%2Ftest%2Fcompile-fail%2Fbinop-move-semantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbinop-move-semantics.rs?ref=0669a432a2e09ad08886cb2138dbe9f5d681fb7f", "patch": "@@ -0,0 +1,69 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that move restrictions are enforced on overloaded binary operations\n+\n+fn double_move<T: Add<T, ()>>(x: T) {\n+    x\n+    +\n+    x;  //~ ERROR: use of moved value\n+}\n+\n+fn move_then_borrow<T: Add<T, ()> + Clone>(x: T) {\n+    x\n+    +\n+    x.clone();  //~ ERROR: use of moved value\n+}\n+\n+fn move_borrowed<T: Add<T, ()>>(x: T, mut y: T) {\n+    let m = &x;\n+    let n = &mut y;\n+\n+    x  //~ ERROR: cannot move out of `x` because it is borrowed\n+    +\n+    y;  //~ ERROR: cannot move out of `y` because it is borrowed\n+}\n+\n+fn illegal_dereference<T: Add<T, ()>>(mut x: T, y: T) {\n+    let m = &mut x;\n+    let n = &y;\n+\n+    *m  //~ ERROR: cannot move out of dereference of `&mut`-pointer\n+    +\n+    *n;  //~ ERROR: cannot move out of dereference of `&`-pointer\n+}\n+\n+struct Foo;\n+\n+impl<'a, 'b> Add<&'b Foo, ()> for &'a mut Foo {\n+    fn add(self, _: &Foo) {}\n+}\n+\n+impl<'a, 'b> Add<&'b mut Foo, ()> for &'a Foo {\n+    fn add(self, _: &mut Foo) {}\n+}\n+\n+fn mut_plus_immut() {\n+    let mut f = Foo;\n+\n+    &mut f\n+    +\n+    &f;  //~ ERROR: cannot borrow `f` as immutable because it is also borrowed as mutable\n+}\n+\n+fn immut_plus_mut() {\n+    let mut f = Foo;\n+\n+    &f\n+    +\n+    &mut f;  //~ ERROR: cannot borrow `f` as mutable because it is also borrowed as immutable\n+}\n+\n+fn main() {}"}, {"sha": "692303fc1e481f07849e3ee3ebee1ce75ffb572e", "filename": "src/test/compile-fail/borrowck-loan-in-overloaded-op.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0669a432a2e09ad08886cb2138dbe9f5d681fb7f/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-in-overloaded-op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0669a432a2e09ad08886cb2138dbe9f5d681fb7f/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-in-overloaded-op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-in-overloaded-op.rs?ref=0669a432a2e09ad08886cb2138dbe9f5d681fb7f", "patch": "@@ -9,18 +9,19 @@\n // except according to those terms.\n \n \n+#[deriving(Clone)]\n struct foo(Box<uint>);\n \n impl Add<foo, foo> for foo {\n-    fn add(&self, f: &foo) -> foo {\n-        let foo(box i) = *self;\n-        let foo(box j) = *f;\n+    fn add(self, f: foo) -> foo {\n+        let foo(box i) = self;\n+        let foo(box j) = f;\n         foo(box() (i + j))\n     }\n }\n \n fn main() {\n     let x = foo(box 3);\n-    let _y = x + {x}; // the `{x}` forces a move to occur\n-    //~^ ERROR cannot move out of `x`\n+    let _y = {x} + x.clone(); // the `{x}` forces a move to occur\n+    //~^ ERROR use of moved value: `x`\n }"}, {"sha": "b83e1544c96d39adfc5026873d41ecd8ba57547c", "filename": "src/test/compile-fail/borrowck-loan-rcvr-overloaded-op.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0669a432a2e09ad08886cb2138dbe9f5d681fb7f/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-rcvr-overloaded-op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0669a432a2e09ad08886cb2138dbe9f5d681fb7f/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-rcvr-overloaded-op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-rcvr-overloaded-op.rs?ref=0669a432a2e09ad08886cb2138dbe9f5d681fb7f", "patch": "@@ -8,15 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n+#[deriving(Copy)]\n struct Point {\n     x: int,\n     y: int,\n }\n \n-impl Add<int,int> for Point {\n-    fn add(&self, z: &int) -> int {\n-        self.x + self.y + (*z)\n+impl Add<int, int> for Point {\n+    fn add(self, z: int) -> int {\n+        self.x + self.y + z\n     }\n }\n \n@@ -41,7 +41,7 @@ fn b() {\n \n     let q = &mut p;\n \n-    p + 3;  //~ ERROR cannot borrow `p`\n+    p + 3;  //~ ERROR cannot use `p`\n     p.times(3); //~ ERROR cannot borrow `p`\n \n     *q + 3; // OK to use the new alias `q`"}, {"sha": "b5e4cac75550f37e7e834bf68ea9e1cc540dc37e", "filename": "src/test/compile-fail/wrong-mul-method-signature.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0669a432a2e09ad08886cb2138dbe9f5d681fb7f/src%2Ftest%2Fcompile-fail%2Fwrong-mul-method-signature.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0669a432a2e09ad08886cb2138dbe9f5d681fb7f/src%2Ftest%2Fcompile-fail%2Fwrong-mul-method-signature.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwrong-mul-method-signature.rs?ref=0669a432a2e09ad08886cb2138dbe9f5d681fb7f", "patch": "@@ -17,12 +17,12 @@ struct Vec1 {\n     x: f64\n }\n \n-// Expecting ref in input signature\n+// Expecting value in input signature\n impl Mul<f64, Vec1> for Vec1 {\n-    fn mul(&self, s: f64) -> Vec1 {\n-    //~^ ERROR: method `mul` has an incompatible type for trait: expected &-ptr, found f64\n+    fn mul(self, s: &f64) -> Vec1 {\n+    //~^ ERROR: method `mul` has an incompatible type for trait: expected f64, found &-ptr\n         Vec1 {\n-            x: self.x * s\n+            x: self.x * *s\n         }\n     }\n }\n@@ -34,8 +34,8 @@ struct Vec2 {\n \n // Wrong type parameter ordering\n impl Mul<Vec2, f64> for Vec2 {\n-    fn mul(&self, s: f64) -> Vec2 {\n-    //~^ ERROR: method `mul` has an incompatible type for trait: expected &-ptr, found f64\n+    fn mul(self, s: f64) -> Vec2 {\n+    //~^ ERROR: method `mul` has an incompatible type for trait: expected struct Vec2, found f64\n         Vec2 {\n             x: self.x * s,\n             y: self.y * s\n@@ -51,9 +51,9 @@ struct Vec3 {\n \n // Unexpected return type\n impl Mul<f64, i32> for Vec3 {\n-    fn mul(&self, s: &f64) -> f64 {\n+    fn mul(self, s: f64) -> f64 {\n     //~^ ERROR: method `mul` has an incompatible type for trait: expected i32, found f64\n-        *s\n+        s\n     }\n }\n "}, {"sha": "238d0ecdca7f8cc6b01b6081f45297df9b0071c4", "filename": "src/test/run-pass/bool.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0669a432a2e09ad08886cb2138dbe9f5d681fb7f/src%2Ftest%2Frun-pass%2Fbool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0669a432a2e09ad08886cb2138dbe9f5d681fb7f/src%2Ftest%2Frun-pass%2Fbool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbool.rs?ref=0669a432a2e09ad08886cb2138dbe9f5d681fb7f", "patch": "@@ -16,30 +16,30 @@ fn main() {\n     assert_eq!(false != true, true);\n     assert_eq!(false.ne(&false), false);\n \n-    assert_eq!(false.bitand(&false), false);\n-    assert_eq!(true.bitand(&false), false);\n-    assert_eq!(false.bitand(&true), false);\n-    assert_eq!(true.bitand(&true), true);\n+    assert_eq!(false.bitand(false), false);\n+    assert_eq!(true.bitand(false), false);\n+    assert_eq!(false.bitand(true), false);\n+    assert_eq!(true.bitand(true), true);\n \n     assert_eq!(false & false, false);\n     assert_eq!(true & false, false);\n     assert_eq!(false & true, false);\n     assert_eq!(true & true, true);\n \n-    assert_eq!(false.bitor(&false), false);\n-    assert_eq!(true.bitor(&false), true);\n-    assert_eq!(false.bitor(&true), true);\n-    assert_eq!(true.bitor(&true), true);\n+    assert_eq!(false.bitor(false), false);\n+    assert_eq!(true.bitor(false), true);\n+    assert_eq!(false.bitor(true), true);\n+    assert_eq!(true.bitor(true), true);\n \n     assert_eq!(false | false, false);\n     assert_eq!(true | false, true);\n     assert_eq!(false | true, true);\n     assert_eq!(true | true, true);\n \n-    assert_eq!(false.bitxor(&false), false);\n-    assert_eq!(true.bitxor(&false), true);\n-    assert_eq!(false.bitxor(&true), true);\n-    assert_eq!(true.bitxor(&true), false);\n+    assert_eq!(false.bitxor(false), false);\n+    assert_eq!(true.bitxor(false), true);\n+    assert_eq!(false.bitxor(true), true);\n+    assert_eq!(true.bitxor(true), false);\n \n     assert_eq!(false ^ false, false);\n     assert_eq!(true ^ false, true);"}, {"sha": "88f3e5775b78b8f09b10ac4786c7442f50566827", "filename": "src/test/run-pass/deriving-zero.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0669a432a2e09ad08886cb2138dbe9f5d681fb7f/src%2Ftest%2Frun-pass%2Fderiving-zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0669a432a2e09ad08886cb2138dbe9f5d681fb7f/src%2Ftest%2Frun-pass%2Fderiving-zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-zero.rs?ref=0669a432a2e09ad08886cb2138dbe9f5d681fb7f", "patch": "@@ -15,10 +15,10 @@ use std::num::Zero;\n struct Vector2<T>(T, T);\n \n impl<T: Add<T, T>> Add<Vector2<T>, Vector2<T>> for Vector2<T> {\n-    fn add(&self, other: &Vector2<T>) -> Vector2<T> {\n+    fn add(self, other: Vector2<T>) -> Vector2<T> {\n         match (self, other) {\n-            (&Vector2(ref x0, ref y0), &Vector2(ref x1, ref y1)) => {\n-                Vector2(*x0 + *x1, *y0 + *y1)\n+            (Vector2(x0, y0), Vector2(x1, y1)) => {\n+                Vector2(x0 + x1, y0 + y1)\n             }\n         }\n     }\n@@ -30,7 +30,7 @@ struct Vector3<T> {\n }\n \n impl<T: Add<T, T>> Add<Vector3<T>, Vector3<T>> for Vector3<T> {\n-    fn add(&self, other: &Vector3<T>) -> Vector3<T> {\n+    fn add(self, other: Vector3<T>) -> Vector3<T> {\n         Vector3 {\n             x: self.x + other.x,\n             y: self.y + other.y,\n@@ -47,7 +47,7 @@ struct Matrix3x2<T> {\n }\n \n impl<T: Add<T, T>> Add<Matrix3x2<T>, Matrix3x2<T>> for Matrix3x2<T> {\n-    fn add(&self, other: &Matrix3x2<T>) -> Matrix3x2<T> {\n+    fn add(self, other: Matrix3x2<T>) -> Matrix3x2<T> {\n         Matrix3x2 {\n             x: self.x + other.x,\n             y: self.y + other.y,"}, {"sha": "80d3d29bc004d1b6d7a824a42efd7975f7c2139e", "filename": "src/test/run-pass/issue-3743.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0669a432a2e09ad08886cb2138dbe9f5d681fb7f/src%2Ftest%2Frun-pass%2Fissue-3743.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0669a432a2e09ad08886cb2138dbe9f5d681fb7f/src%2Ftest%2Frun-pass%2Fissue-3743.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3743.rs?ref=0669a432a2e09ad08886cb2138dbe9f5d681fb7f", "patch": "@@ -28,7 +28,7 @@ trait RhsOfVec2Mul<Result> { fn mul_vec2_by(&self, lhs: &Vec2) -> Result; }\n \n // Vec2's implementation of Mul \"from the other side\" using the above trait\n impl<Res, Rhs: RhsOfVec2Mul<Res>> Mul<Rhs,Res> for Vec2 {\n-    fn mul(&self, rhs: &Rhs) -> Res { rhs.mul_vec2_by(self) }\n+    fn mul(self, rhs: Rhs) -> Res { rhs.mul_vec2_by(&self) }\n }\n \n // Implementation of 'f64 as right-hand-side of Vec2::Mul'"}, {"sha": "f8184d248ff0166bcd38f56180097ae7fff15e23", "filename": "src/test/run-pass/numeric-method-autoexport.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0669a432a2e09ad08886cb2138dbe9f5d681fb7f/src%2Ftest%2Frun-pass%2Fnumeric-method-autoexport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0669a432a2e09ad08886cb2138dbe9f5d681fb7f/src%2Ftest%2Frun-pass%2Fnumeric-method-autoexport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnumeric-method-autoexport.rs?ref=0669a432a2e09ad08886cb2138dbe9f5d681fb7f", "patch": "@@ -18,19 +18,19 @@\n pub fn main() {\n // ints\n     // num\n-    assert_eq!(15i.add(&6), 21);\n-    assert_eq!(15i8.add(&6i8), 21i8);\n-    assert_eq!(15i16.add(&6i16), 21i16);\n-    assert_eq!(15i32.add(&6i32), 21i32);\n-    assert_eq!(15i64.add(&6i64), 21i64);\n+    assert_eq!(15i.add(6), 21);\n+    assert_eq!(15i8.add(6i8), 21i8);\n+    assert_eq!(15i16.add(6i16), 21i16);\n+    assert_eq!(15i32.add(6i32), 21i32);\n+    assert_eq!(15i64.add(6i64), 21i64);\n \n // uints\n     // num\n-    assert_eq!(15u.add(&6u), 21u);\n-    assert_eq!(15u8.add(&6u8), 21u8);\n-    assert_eq!(15u16.add(&6u16), 21u16);\n-    assert_eq!(15u32.add(&6u32), 21u32);\n-    assert_eq!(15u64.add(&6u64), 21u64);\n+    assert_eq!(15u.add(6u), 21u);\n+    assert_eq!(15u8.add(6u8), 21u8);\n+    assert_eq!(15u16.add(6u16), 21u16);\n+    assert_eq!(15u32.add(6u32), 21u32);\n+    assert_eq!(15u64.add(6u64), 21u64);\n \n // floats\n     // num"}, {"sha": "cb3397c00bc57a1196d3859e4065ce9666218dd6", "filename": "src/test/run-pass/operator-multidispatch.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0669a432a2e09ad08886cb2138dbe9f5d681fb7f/src%2Ftest%2Frun-pass%2Foperator-multidispatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0669a432a2e09ad08886cb2138dbe9f5d681fb7f/src%2Ftest%2Frun-pass%2Foperator-multidispatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foperator-multidispatch.rs?ref=0669a432a2e09ad08886cb2138dbe9f5d681fb7f", "patch": "@@ -20,13 +20,13 @@ struct Point {\n }\n \n impl ops::Add<Point,Point> for Point {\n-    fn add(&self, other: &Point) -> Point {\n-        Point {x: self.x + (*other).x, y: self.y + (*other).y}\n+    fn add(self, other: Point) -> Point {\n+        Point {x: self.x + other.x, y: self.y + other.y}\n     }\n }\n \n impl ops::Add<int,Point> for Point {\n-    fn add(&self, &other: &int) -> Point {\n+    fn add(self, other: int) -> Point {\n         Point {x: self.x + other,\n                y: self.y + other}\n     }"}, {"sha": "8d743ba42e890417e7aa505b1499be9fb97f3c10", "filename": "src/test/run-pass/operator-overloading.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0669a432a2e09ad08886cb2138dbe9f5d681fb7f/src%2Ftest%2Frun-pass%2Foperator-overloading.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0669a432a2e09ad08886cb2138dbe9f5d681fb7f/src%2Ftest%2Frun-pass%2Foperator-overloading.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foperator-overloading.rs?ref=0669a432a2e09ad08886cb2138dbe9f5d681fb7f", "patch": "@@ -12,21 +12,21 @@\n use std::cmp;\n use std::ops;\n \n-#[deriving(Show)]\n+#[deriving(Copy, Show)]\n struct Point {\n     x: int,\n     y: int\n }\n \n impl ops::Add<Point,Point> for Point {\n-    fn add(&self, other: &Point) -> Point {\n-        Point {x: self.x + (*other).x, y: self.y + (*other).y}\n+    fn add(self, other: Point) -> Point {\n+        Point {x: self.x + other.x, y: self.y + other.y}\n     }\n }\n \n impl ops::Sub<Point,Point> for Point {\n-    fn sub(&self, other: &Point) -> Point {\n-        Point {x: self.x - (*other).x, y: self.y - (*other).y}\n+    fn sub(self, other: Point) -> Point {\n+        Point {x: self.x - other.x, y: self.y - other.y}\n     }\n }\n "}, {"sha": "2e8ec3916bd89f5c5ace9e8513c9d9bf6e007e99", "filename": "src/test/run-pass/overloaded-calls-param-vtables.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0669a432a2e09ad08886cb2138dbe9f5d681fb7f/src%2Ftest%2Frun-pass%2Foverloaded-calls-param-vtables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0669a432a2e09ad08886cb2138dbe9f5d681fb7f/src%2Ftest%2Frun-pass%2Foverloaded-calls-param-vtables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foverloaded-calls-param-vtables.rs?ref=0669a432a2e09ad08886cb2138dbe9f5d681fb7f", "patch": "@@ -18,7 +18,7 @@ struct G;\n \n impl<'a, A: Add<int, int>> Fn<(A,), int> for G {\n     extern \"rust-call\" fn call(&self, (arg,): (A,)) -> int {\n-        arg.add(&1)\n+        arg.add(1)\n     }\n }\n "}, {"sha": "42f93a97142d239138dcec06978bec3884a6ffe9", "filename": "src/test/run-pass/simd-generics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0669a432a2e09ad08886cb2138dbe9f5d681fb7f/src%2Ftest%2Frun-pass%2Fsimd-generics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0669a432a2e09ad08886cb2138dbe9f5d681fb7f/src%2Ftest%2Frun-pass%2Fsimd-generics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsimd-generics.rs?ref=0669a432a2e09ad08886cb2138dbe9f5d681fb7f", "patch": "@@ -22,8 +22,8 @@ fn add<T: ops::Add<T, T>>(lhs: T, rhs: T) -> T {\n }\n \n impl ops::Add<f32x4, f32x4> for f32x4 {\n-    fn add(&self, rhs: &f32x4) -> f32x4 {\n-        *self + *rhs\n+    fn add(self, rhs: f32x4) -> f32x4 {\n+        self + rhs\n     }\n }\n "}, {"sha": "2a087e5e425ad23d976baf8a98ab48f131ddde20", "filename": "src/test/run-pass/trait-inheritance-overloading-xc-exe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0669a432a2e09ad08886cb2138dbe9f5d681fb7f/src%2Ftest%2Frun-pass%2Ftrait-inheritance-overloading-xc-exe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0669a432a2e09ad08886cb2138dbe9f5d681fb7f/src%2Ftest%2Frun-pass%2Ftrait-inheritance-overloading-xc-exe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-inheritance-overloading-xc-exe.rs?ref=0669a432a2e09ad08886cb2138dbe9f5d681fb7f", "patch": "@@ -14,7 +14,7 @@ extern crate trait_inheritance_overloading_xc;\n use trait_inheritance_overloading_xc::{MyNum, MyInt};\n \n fn f<T:MyNum>(x: T, y: T) -> (T, T, T) {\n-    return (x + y, x - y, x * y);\n+    return (x.clone() + y.clone(), x.clone() - y.clone(), x * y);\n }\n \n fn mi(v: int) -> MyInt { MyInt { val: v } }"}, {"sha": "5f8e945cce8604d696c86ca9f2d37aecb1290e9d", "filename": "src/test/run-pass/trait-inheritance-overloading.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0669a432a2e09ad08886cb2138dbe9f5d681fb7f/src%2Ftest%2Frun-pass%2Ftrait-inheritance-overloading.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0669a432a2e09ad08886cb2138dbe9f5d681fb7f/src%2Ftest%2Frun-pass%2Ftrait-inheritance-overloading.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-inheritance-overloading.rs?ref=0669a432a2e09ad08886cb2138dbe9f5d681fb7f", "patch": "@@ -10,21 +10,21 @@\n \n use std::cmp::PartialEq;\n \n-trait MyNum : Add<Self,Self> + Sub<Self,Self> + Mul<Self,Self> + PartialEq { }\n+trait MyNum : Add<Self,Self> + Sub<Self,Self> + Mul<Self,Self> + PartialEq + Clone { }\n \n-#[deriving(Show)]\n+#[deriving(Clone, Show)]\n struct MyInt { val: int }\n \n impl Add<MyInt, MyInt> for MyInt {\n-    fn add(&self, other: &MyInt) -> MyInt { mi(self.val + other.val) }\n+    fn add(self, other: MyInt) -> MyInt { mi(self.val + other.val) }\n }\n \n impl Sub<MyInt, MyInt> for MyInt {\n-    fn sub(&self, other: &MyInt) -> MyInt { mi(self.val - other.val) }\n+    fn sub(self, other: MyInt) -> MyInt { mi(self.val - other.val) }\n }\n \n impl Mul<MyInt, MyInt> for MyInt {\n-    fn mul(&self, other: &MyInt) -> MyInt { mi(self.val * other.val) }\n+    fn mul(self, other: MyInt) -> MyInt { mi(self.val * other.val) }\n }\n \n impl PartialEq for MyInt {\n@@ -35,7 +35,7 @@ impl PartialEq for MyInt {\n impl MyNum for MyInt {}\n \n fn f<T:MyNum>(x: T, y: T) -> (T, T, T) {\n-    return (x + y, x - y, x * y);\n+    return (x.clone() + y.clone(), x.clone() - y.clone(), x * y);\n }\n \n fn mi(v: int) -> MyInt { MyInt { val: v } }"}]}