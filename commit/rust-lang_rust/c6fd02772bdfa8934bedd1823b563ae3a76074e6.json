{"sha": "c6fd02772bdfa8934bedd1823b563ae3a76074e6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM2ZmQwMjc3MmJkZmE4OTM0YmVkZDE4MjNiNTYzYWUzYTc2MDc0ZTY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-02-22T04:11:23Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-02-22T04:11:23Z"}, "message": "Auto merge of #58574 - RalfJung:pin, r=Mark-Simulacrum\n\nimprove Pin documentation\n\nIncorporates a bunch of the documentation-related comments that came up when discussing `Pin` stabilization.\n\nCc @alexcrichton @withoutboats @cramertj @jonhoo\n\nFixes https://github.com/rust-lang/rust/issues/58130", "tree": {"sha": "23fba1b9a6e94cfd650edb022dd28afa00ffeeca", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/23fba1b9a6e94cfd650edb022dd28afa00ffeeca"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c6fd02772bdfa8934bedd1823b563ae3a76074e6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c6fd02772bdfa8934bedd1823b563ae3a76074e6", "html_url": "https://github.com/rust-lang/rust/commit/c6fd02772bdfa8934bedd1823b563ae3a76074e6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c6fd02772bdfa8934bedd1823b563ae3a76074e6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d1f8970bd1f0d4fa15db73f632d92e3a055af3fc", "url": "https://api.github.com/repos/rust-lang/rust/commits/d1f8970bd1f0d4fa15db73f632d92e3a055af3fc", "html_url": "https://github.com/rust-lang/rust/commit/d1f8970bd1f0d4fa15db73f632d92e3a055af3fc"}, {"sha": "497439c199131ba65f03c116aec2e9cd5a7e63ff", "url": "https://api.github.com/repos/rust-lang/rust/commits/497439c199131ba65f03c116aec2e9cd5a7e63ff", "html_url": "https://github.com/rust-lang/rust/commit/497439c199131ba65f03c116aec2e9cd5a7e63ff"}], "stats": {"total": 359, "additions": 310, "deletions": 49}, "files": [{"sha": "29606cb19038f46dd402b7cc86afd7a1ec9c05b3", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 18, "deletions": 9, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/c6fd02772bdfa8934bedd1823b563ae3a76074e6/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6fd02772bdfa8934bedd1823b563ae3a76074e6/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=c6fd02772bdfa8934bedd1823b563ae3a76074e6", "patch": "@@ -597,34 +597,43 @@ unsafe impl<T: ?Sized> Freeze for &mut T {}\n \n /// Types which can be safely moved after being pinned.\n ///\n-/// Since Rust itself has no notion of immovable types, and will consider moves to always be safe,\n+/// Since Rust itself has no notion of immovable types, and considers moves\n+/// (e.g. through assignment or [`mem::replace`]) to always be safe,\n /// this trait cannot prevent types from moving by itself.\n ///\n-/// Instead it can be used to prevent moves through the type system,\n-/// by controlling the behavior of pointers wrapped in the [`Pin`] wrapper,\n+/// Instead it is used to prevent moves through the type system,\n+/// by controlling the behavior of pointers `P` wrapped in the [`Pin<P>`] wrapper,\n /// which \"pin\" the type in place by not allowing it to be moved out of them.\n /// See the [`pin module`] documentation for more information on pinning.\n ///\n /// Implementing this trait lifts the restrictions of pinning off a type,\n-/// which then allows it to move out with functions such as [`replace`].\n+/// which then allows it to move out with functions such as [`mem::replace`].\n+///\n+/// `Unpin` has no consequence at all for non-pinned data. In particular,\n+/// [`mem::replace`] happily moves `!Unpin` data (it works for any `&mut T`, not\n+/// just when `T: Unpin`). However, you cannot use\n+/// [`mem::replace`] on data wrapped inside a [`Pin<P>`] because you cannot get the\n+/// `&mut T` you need for that, and *that* is what makes this system work.\n ///\n /// So this, for example, can only be done on types implementing `Unpin`:\n ///\n /// ```rust\n-/// use std::mem::replace;\n+/// use std::mem;\n /// use std::pin::Pin;\n ///\n /// let mut string = \"this\".to_string();\n /// let mut pinned_string = Pin::new(&mut string);\n ///\n-/// // dereferencing the pointer mutably is only possible because String implements Unpin\n-/// replace(&mut *pinned_string, \"other\".to_string());\n+/// // We need a mutable reference to call `mem::replace`.\n+/// // We can obtain such a reference by (implicitly) invoking `Pin::deref_mut`,\n+/// // but that is only possible because `String` implements `Unpin`.\n+/// mem::replace(&mut *pinned_string, \"other\".to_string());\n /// ```\n ///\n /// This trait is automatically implemented for almost every type.\n ///\n-/// [`replace`]: ../../std/mem/fn.replace.html\n-/// [`Pin`]: ../pin/struct.Pin.html\n+/// [`mem::replace`]: ../../std/mem/fn.replace.html\n+/// [`Pin<P>`]: ../pin/struct.Pin.html\n /// [`pin module`]: ../../std/pin/index.html\n #[stable(feature = \"pin\", since = \"1.33.0\")]\n #[cfg_attr(not(stage0), lang = \"unpin\")]"}, {"sha": "f9f20dcea9e2ea86f5493232a28062ed6e0742dc", "filename": "src/libcore/pin.rs", "status": "modified", "additions": 292, "deletions": 40, "changes": 332, "blob_url": "https://github.com/rust-lang/rust/blob/c6fd02772bdfa8934bedd1823b563ae3a76074e6/src%2Flibcore%2Fpin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6fd02772bdfa8934bedd1823b563ae3a76074e6/src%2Flibcore%2Fpin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpin.rs?ref=c6fd02772bdfa8934bedd1823b563ae3a76074e6", "patch": "@@ -2,45 +2,63 @@\n //!\n //! It is sometimes useful to have objects that are guaranteed to not move,\n //! in the sense that their placement in memory does not change, and can thus be relied upon.\n-//!\n //! A prime example of such a scenario would be building self-referential structs,\n //! since moving an object with pointers to itself will invalidate them,\n //! which could cause undefined behavior.\n //!\n+//! A [`Pin<P>`] ensures that the pointee of any pointer type `P` has a stable location in memory,\n+//! meaning it cannot be moved elsewhere and its memory cannot be deallocated\n+//! until it gets dropped. We say that the pointee is \"pinned\".\n+//!\n //! By default, all types in Rust are movable. Rust allows passing all types by-value,\n-//! and common smart-pointer types such as `Box`, `Rc`, and `&mut` allow replacing and\n-//! moving the values they contain. In order to prevent objects from moving, they must\n-//! be pinned by wrapping a pointer to the data in the [`Pin`] type.\n-//! Doing this prohibits moving the value behind the pointer.\n-//! For example, `Pin<Box<T>>` functions much like a regular `Box<T>`,\n-//! but doesn't allow moving `T`. The pointer value itself (the `Box`) can still be moved,\n-//! but the value behind it cannot.\n-//!\n-//! Since data can be moved out of `&mut` and `Box` with functions such as [`swap`],\n-//! changing the location of the underlying data, [`Pin`] prohibits accessing the\n-//! underlying pointer type (the `&mut` or `Box`) directly, and provides its own set of\n-//! APIs for accessing and using the value. [`Pin`] also guarantees that no other\n-//! functions will move the pointed-to value. This allows for the creation of\n-//! self-references and other special behaviors that are only possible for unmovable\n-//! values.\n+//! and common smart-pointer types such as `Box<T>` and `&mut T` allow replacing and\n+//! moving the values they contain: you can move out of a `Box<T>`, or you can use [`mem::swap`].\n+//! [`Pin<P>`] wraps a pointer type `P`, so `Pin<Box<T>>` functions much like a regular `Box<T>`:\n+//! when a `Pin<Box<T>>` gets dropped, so do its contents, and the memory gets deallocated.\n+//! Similarily, `Pin<&mut T>` is a lot like `&mut T`. However, [`Pin<P>`] does not let clients\n+//! actually obtain a `Box<T>` or `&mut T` to pinned data, which implies that you cannot use\n+//! operations such as [`mem::swap`]:\n+//! ```\n+//! use std::pin::Pin;\n+//! fn swap_pins<T>(x: Pin<&mut T>, y: Pin<&mut T>) {\n+//!     // `mem::swap` needs `&mut T`, but we cannot get it.\n+//!     // We are stuck, we cannot swap the contents of these references.\n+//!     // We could use `Pin::get_unchecked_mut`, but that is unsafe for a reason:\n+//!     // we are not allowed to use it for moving things out of the `Pin`.\n+//! }\n+//! ```\n //!\n-//! However, these restrictions are usually not necessary. Many types are always freely\n-//! movable. These types implement the [`Unpin`] auto-trait, which nullifies the effect\n-//! of [`Pin`]. For `T: Unpin`, `Pin<Box<T>>` and `Box<T>` function identically, as do\n-//! `Pin<&mut T>` and `&mut T`.\n+//! It is worth reiterating that [`Pin<P>`] does *not* change the fact that a Rust compiler\n+//! considers all types movable. [`mem::swap`] remains callable for any `T`. Instead, `Pin<P>`\n+//! prevents certain *values* (pointed to by pointers wrapped in `Pin<P>`) from being\n+//! moved by making it impossible to call methods that require `&mut T` on them\n+//! (like [`mem::swap`]).\n //!\n-//! Note that pinning and `Unpin` only affect the pointed-to type. For example, whether\n-//! or not `Box<T>` is `Unpin` has no affect on the behavior of `Pin<Box<T>>`. Similarly,\n-//! `Pin<Box<T>>` and `Pin<&mut T>` are always `Unpin` themselves, even though the\n-//! `T` underneath them isn't, because the pointers in `Pin<Box<_>>` and `Pin<&mut _>`\n-//! are always freely movable, even if the data they point to isn't.\n+//! [`Pin<P>`] can be used to wrap any pointer type `P`, and as such it interacts with\n+//! [`Deref`] and [`DerefMut`]. A `Pin<P>` where `P: Deref` should be considered\n+//! as a \"`P`-style pointer\" to a pinned `P::Target` -- so, a `Pin<Box<T>>` is\n+//! an owned pointer to a pinned `T`, and a `Pin<Rc<T>>` is a reference-counted\n+//! pointer to a pinned `T`.\n+//! For correctness, [`Pin<P>`] relies on the [`Deref`] and [`DerefMut`] implementations\n+//! to not move out of their `self` parameter, and to only ever return a pointer\n+//! to pinned data when they are called on a pinned pointer.\n //!\n-//! [`Pin`]: struct.Pin.html\n-//! [`Unpin`]: ../../std/marker/trait.Unpin.html\n-//! [`swap`]: ../../std/mem/fn.swap.html\n-//! [`Box`]: ../../std/boxed/struct.Box.html\n+//! # `Unpin`\n+//!\n+//! However, these restrictions are usually not necessary. Many types are always freely\n+//! movable, even when pinned, because they do not rely on having a stable address.\n+//! This includes all the basic types (like `bool`, `i32`, references)\n+//! as well as types consisting solely of these types.\n+//! Types that do not care about pinning implement the [`Unpin`] auto-trait, which\n+//! cancels the effect of [`Pin<P>`]. For `T: Unpin`, `Pin<Box<T>>` and `Box<T>` function\n+//! identically, as do `Pin<&mut T>` and `&mut T`.\n+//!\n+//! Note that pinning and `Unpin` only affect the pointed-to type `P::Target`, not the pointer\n+//! type `P` itself that got wrapped in `Pin<P>`. For example, whether or not `Box<T>` is\n+//! `Unpin` has no effect on the behavior of `Pin<Box<T>>` (here, `T` is the\n+//! pointed-to type).\n //!\n-//! # Examples\n+//! # Example: self-referential struct\n //!\n //! ```rust\n //! use std::pin::Pin;\n@@ -94,6 +112,150 @@\n //! // let new_unmoved = Unmovable::new(\"world\".to_string());\n //! // std::mem::swap(&mut *still_unmoved, &mut *new_unmoved);\n //! ```\n+//!\n+//! # Example: intrusive doubly-linked list\n+//!\n+//! In an intrusive doubly-linked list, the collection does not actually allocate\n+//! the memory for the elements itself. Allocation is controlled by the clients,\n+//! and elements can live on a stack frame that lives shorter than the collection does.\n+//!\n+//! To make this work, every element has pointers to its predecessor and successor in\n+//! the list. Elements can only be added when they are pinned, because moving the elements\n+//! around would invalidate the pointers. Moreover, the `Drop` implementation of a linked\n+//! list element will patch the pointers of its predecessor and successor to remove itself\n+//! from the list.\n+//!\n+//! Crucially, we have to be able to rely on `drop` being called. If an element\n+//! could be deallocated or otherwise invalidated without calling `drop`, the pointers into it\n+//! from its neighbouring elements would become invalid, which would break the data structure.\n+//!\n+//! Therefore, pinning also comes with a `drop`-related guarantee.\n+//!\n+//! # `Drop` guarantee\n+//!\n+//! The purpose of pinning is to be able to rely on the placement of some data in memory.\n+//! To make this work, not just moving the data is restricted; deallocating, repurposing, or\n+//! otherwise invalidating the memory used to store the data is restricted, too.\n+//! Concretely, for pinned data you have to maintain the invariant\n+//! that *its memory will not get invalidated from the moment it gets pinned until\n+//! when `drop` is called*. Memory can be invalidated by deallocation, but also by\n+//! replacing a [`Some(v)`] by [`None`], or calling [`Vec::set_len`] to \"kill\" some elements\n+//! off of a vector.\n+//!\n+//! This is exactly the kind of guarantee that the intrusive linked list from the previous\n+//! section needs to function correctly.\n+//!\n+//! Notice that this guarantee does *not* mean that memory does not leak! It is still\n+//! completely okay not to ever call `drop` on a pinned element (e.g., you can still\n+//! call [`mem::forget`] on a `Pin<Box<T>>`). In the example of the doubly-linked\n+//! list, that element would just stay in the list. However you may not free or reuse the storage\n+//! *without calling `drop`*.\n+//!\n+//! # `Drop` implementation\n+//!\n+//! If your type uses pinning (such as the two examples above), you have to be careful\n+//! when implementing `Drop`. The `drop` function takes `&mut self`, but this\n+//! is called *even if your type was previously pinned*! It is as if the\n+//! compiler automatically called `get_unchecked_mut`.\n+//!\n+//! This can never cause a problem in safe code because implementing a type that relies on pinning\n+//! requires unsafe code, but be aware that deciding to make use of pinning\n+//! in your type (for example by implementing some operation on `Pin<&[mut] Self>`)\n+//! has consequences for your `Drop` implementation as well: if an element\n+//! of your type could have been pinned, you must treat Drop as implicitly taking\n+//! `Pin<&mut Self>`.\n+//!\n+//! In particular, if your type is `#[repr(packed)]`, the compiler will automatically\n+//! move fields around to be able to drop them. As a consequence, you cannot use\n+//! pinning with a `#[repr(packed)]` type.\n+//!\n+//! # Projections and Structural Pinning\n+//!\n+//! One interesting question arises when considering the interaction of pinning and\n+//! the fields of a struct. When can a struct have a \"pinning projection\", i.e.,\n+//! an operation with type `fn(Pin<&[mut] Struct>) -> Pin<&[mut] Field>`?\n+//! In a similar vein, when can a generic wrapper type (such as `Vec<T>`, `Box<T>`, or `RefCell<T>`)\n+//! have an operation with type `fn(Pin<&[mut] Wrapper<T>>) -> Pin<&[mut] T>`?\n+//!\n+//! Having a pinning projection for some field means that pinning is \"structural\":\n+//! when the wrapper is pinned, the field must be considered pinned, too.\n+//! After all, the pinning projection lets us get a `Pin<&[mut] Field>`.\n+//!\n+//! However, structural pinning comes with a few extra requirements, so not all\n+//! wrappers can be structural and hence not all wrappers can offer pinning projections:\n+//!\n+//! 1.  The wrapper must only be [`Unpin`] if all the structural fields are\n+//!     `Unpin`. This is the default, but `Unpin` is a safe trait, so as the author of\n+//!     the wrapper it is your responsibility *not* to add something like\n+//!     `impl<T> Unpin for Wrapper<T>`. (Notice that adding a projection operation\n+//!     requires unsafe code, so the fact that `Unpin` is a safe trait  does not break\n+//!     the principle that you only have to worry about any of this if you use `unsafe`.)\n+//! 2.  The destructor of the wrapper must not move structural fields out of its argument. This\n+//!     is the exact point that was raised in the [previous section][drop-impl]: `drop` takes\n+//!     `&mut self`, but the wrapper (and hence its fields) might have been pinned before.\n+//!     You have to guarantee that you do not move a field inside your `Drop` implementation.\n+//!     In particular, as explained previously, this means that your wrapper type must *not*\n+//!     be `#[repr(packed)]`.\n+//! 3.  You must make sure that you uphold the [`Drop` guarantee][drop-guarantee]:\n+//!     once your wrapper is pinned, the memory that contains the\n+//!     content is not overwritten or deallocated without calling the content's destructors.\n+//!     This can be tricky, as witnessed by `VecDeque<T>`: the destructor of `VecDeque<T>` can fail\n+//!     to call `drop` on all elements if one of the destructors panics. This violates the\n+//!     `Drop` guarantee, because it can lead to elements being deallocated without\n+//!     their destructor being called. (`VecDeque` has no pinning projections, so this\n+//!     does not cause unsoundness.)\n+//! 4.  You must not offer any other operations that could lead to data being moved out of\n+//!     the fields when your type is pinned. For example, if the wrapper contains an\n+//!     `Option<T>` and there is a `take`-like operation with type\n+//!     `fn(Pin<&mut Wrapper<T>>) -> Option<T>`,\n+//!     that operation can be used to move a `T` out of a pinned `Wrapper<T>` -- which means\n+//!     pinning cannot be structural.\n+//!\n+//!     For a more complex example of moving data out of a pinned type, imagine if `RefCell<T>`\n+//!     had a method `fn get_pin_mut(self: Pin<&mut Self>) -> Pin<&mut T>`.\n+//!     Then we could do the following:\n+//!     ```compile_fail\n+//!     fn exploit_ref_cell<T>(rc: Pin<&mut RefCell<T>) {\n+//!         { let p = rc.as_mut().get_pin_mut(); } // Here we get pinned access to the `T`.\n+//!         let rc_shr: &RefCell<T> = rc.into_ref().get_ref();\n+//!         let b = rc_shr.borrow_mut();\n+//!         let content = &mut *b; // And here we have `&mut T` to the same data.\n+//!     }\n+//!     ```\n+//!     This is catastrophic, it means we can first pin the content of the `RefCell<T>`\n+//!     (using `RefCell::get_pin_mut`) and then move that content using the mutable\n+//!     reference we got later.\n+//!\n+//! For a type like `Vec<T>`, both possibilites (structural pinning or not) make sense,\n+//! and the choice is up to the author. A `Vec<T>` with structural pinning could\n+//! have `get_pin`/`get_pin_mut` projections. However, it could *not* allow calling\n+//! `pop` on a pinned `Vec<T>` because that would move the (structurally pinned) contents!\n+//! Nor could it allow `push`, which might reallocate and thus also move the contents.\n+//! A `Vec<T>` without structural pinning could `impl<T> Unpin for Vec<T>`, because the contents\n+//! are never pinned and the `Vec<T>` itself is fine with being moved as well.\n+//!\n+//! In the standard library, pointer types generally do not have structural pinning,\n+//! and thus they do not offer pinning projections. This is why `Box<T>: Unpin` holds for all `T`.\n+//! It makes sense to do this for pointer types, because moving the `Box<T>`\n+//! does not actually move the `T`: the `Box<T>` can be freely movable (aka `Unpin`) even if the `T`\n+//! is not. In fact, even `Pin<Box<T>>` and `Pin<&mut T>` are always `Unpin` themselves,\n+//! for the same reason: their contents (the `T`) are pinned, but the pointers themselves\n+//! can be moved without moving the pinned data. For both `Box<T>` and `Pin<Box<T>>`,\n+//! whether the content is pinned is entirely independent of whether the pointer is\n+//! pinned, meaning pinning is *not* structural.\n+//!\n+//! [`Pin<P>`]: struct.Pin.html\n+//! [`Unpin`]: ../../std/marker/trait.Unpin.html\n+//! [`Deref`]: ../../std/ops/trait.Deref.html\n+//! [`DerefMut`]: ../../std/ops/trait.DerefMut.html\n+//! [`mem::swap`]: ../../std/mem/fn.swap.html\n+//! [`mem::forget`]: ../../std/mem/fn.forget.html\n+//! [`Box<T>`]: ../../std/boxed/struct.Box.html\n+//! [`Vec::set_len`]: ../../std/vec/struct.Vec.html#method.set_len\n+//! [`None`]: ../../std/option/enum.Option.html#variant.None\n+//! [`Some(v)`]: ../../std/option/enum.Option.html#variant.Some\n+//! [drop-impl]: #drop-implementation\n+//! [drop-guarantee]: #drop-guarantee\n \n #![stable(feature = \"pin\", since = \"1.33.0\")]\n \n@@ -169,8 +331,13 @@ impl<P: Deref> Pin<P>\n where\n     P::Target: Unpin,\n {\n-    /// Construct a new `Pin` around a pointer to some data of a type that\n-    /// implements `Unpin`.\n+    /// Construct a new `Pin<P>` around a pointer to some data of a type that\n+    /// implements [`Unpin`].\n+    ///\n+    /// Unlike `Pin::new_unchecked`, this method is safe because the pointer\n+    /// `P` dereferences to an [`Unpin`] type, which cancels the pinning guarantees.\n+    ///\n+    /// [`Unpin`]: ../../std/marker/trait.Unpin.html\n     #[stable(feature = \"pin\", since = \"1.33.0\")]\n     #[inline(always)]\n     pub fn new(pointer: P) -> Pin<P> {\n@@ -181,25 +348,83 @@ where\n }\n \n impl<P: Deref> Pin<P> {\n-    /// Construct a new `Pin` around a reference to some data of a type that\n+    /// Construct a new `Pin<P>` around a reference to some data of a type that\n     /// may or may not implement `Unpin`.\n     ///\n+    /// If `pointer` dereferences to an `Unpin` type, `Pin::new` should be used\n+    /// instead.\n+    ///\n     /// # Safety\n     ///\n     /// This constructor is unsafe because we cannot guarantee that the data\n-    /// pointed to by `pointer` is pinned. If the constructed `Pin<P>` does\n-    /// not guarantee that the data `P` points to is pinned, constructing a\n-    /// `Pin<P>` is undefined behavior.\n+    /// pointed to by `pointer` is pinned, meaning that the data will not be moved or\n+    /// its storage invalidated until it gets dropped. If the constructed `Pin<P>` does\n+    /// not guarantee that the data `P` points to is pinned, that is a violation of\n+    /// the API contract and may lead to undefined behavior in later (safe) operations.\n     ///\n-    /// If `pointer` dereferences to an `Unpin` type, `Pin::new` should be used\n-    /// instead.\n+    /// By using this method, you are making a promise about the `P::Deref` and\n+    /// `P::DerefMut` implementations, if they exist. Most importantly, they\n+    /// must not move out of their `self` arguments: `Pin::as_mut` and `Pin::as_ref`\n+    /// will call `DerefMut::deref_mut` and `Deref::deref` *on the pinned pointer*\n+    /// and expect these methods to uphold the pinning invariants.\n+    /// Moreover, by calling this method you promise that the reference `P`\n+    /// dereferences to will not be moved out of again; in particular, it\n+    /// must not be possible to obtain a `&mut P::Target` and then\n+    /// move out of that reference (using, for example [`mem::swap`]).\n+    ///\n+    /// For example, calling `Pin::new_unchecked` on an `&'a mut T` is unsafe because\n+    /// while you are able to pin it for the given lifetime `'a`, you have no control\n+    /// over whether it is kept pinned once `'a` ends:\n+    /// ```\n+    /// use std::mem;\n+    /// use std::pin::Pin;\n+    ///\n+    /// fn move_pinned_ref<T>(mut a: T, mut b: T) {\n+    ///     unsafe {\n+    ///         let p: Pin<&mut T> = Pin::new_unchecked(&mut a);\n+    ///         // This should mean the pointee `a` can never move again.\n+    ///     }\n+    ///     mem::swap(&mut a, &mut b);\n+    ///     // The address of `a` changed to `b`'s stack slot, so `a` got moved even\n+    ///     // though we have previously pinned it! We have violated the pinning API contract.\n+    /// }\n+    /// ```\n+    /// A value, once pinned, must remain pinned forever (unless its type implements `Unpin`).\n+    ///\n+    /// Similarily, calling `Pin::new_unchecked` on an `Rc<T>` is unsafe because there could be\n+    /// aliases to the same data that are not subject to the pinning restrictions:\n+    /// ```\n+    /// use std::rc::Rc;\n+    /// use std::pin::Pin;\n+    ///\n+    /// fn move_pinned_rc<T>(mut x: Rc<T>) {\n+    ///     let pinned = unsafe { Pin::new_unchecked(x.clone()) };\n+    ///     {\n+    ///         let p: Pin<&T> = pinned.as_ref();\n+    ///         // This should mean the pointee can never move again.\n+    ///     }\n+    ///     drop(pinned);\n+    ///     let content = Rc::get_mut(&mut x).unwrap();\n+    ///     // Now, if `x` was the only reference, we have a mutable reference to\n+    ///     // data that we pinned above, which we could use to move it as we have\n+    ///     // seen in the previous example. We have violated the pinning API contract.\n+    ///  }\n+    ///  ```\n+    ///\n+    /// [`mem::swap`]: ../../std/mem/fn.swap.html\n     #[stable(feature = \"pin\", since = \"1.33.0\")]\n     #[inline(always)]\n     pub unsafe fn new_unchecked(pointer: P) -> Pin<P> {\n         Pin { pointer }\n     }\n \n     /// Gets a pinned shared reference from this pinned pointer.\n+    ///\n+    /// This is a generic method to go from `&Pin<Pointer<T>>` to `Pin<&T>`.\n+    /// It is safe because, as part of the contract of `Pin::new_unchecked`,\n+    /// the pointee cannot move after `Pin<Pointer<T>>` got created.\n+    /// \"Malicious\" implementations of `Pointer::Deref` are likewise\n+    /// ruled out by the contract of `Pin::new_unchecked`.\n     #[stable(feature = \"pin\", since = \"1.33.0\")]\n     #[inline(always)]\n     pub fn as_ref(self: &Pin<P>) -> Pin<&P::Target> {\n@@ -209,13 +434,22 @@ impl<P: Deref> Pin<P> {\n \n impl<P: DerefMut> Pin<P> {\n     /// Gets a pinned mutable reference from this pinned pointer.\n+    ///\n+    /// This is a generic method to go from `&mut Pin<Pointer<T>>` to `Pin<&mut T>`.\n+    /// It is safe because, as part of the contract of `Pin::new_unchecked`,\n+    /// the pointee cannot move after `Pin<Pointer<T>>` got created.\n+    /// \"Malicious\" implementations of `Pointer::DerefMut` are likewise\n+    /// ruled out by the contract of `Pin::new_unchecked`.\n     #[stable(feature = \"pin\", since = \"1.33.0\")]\n     #[inline(always)]\n     pub fn as_mut(self: &mut Pin<P>) -> Pin<&mut P::Target> {\n         unsafe { Pin::new_unchecked(&mut *self.pointer) }\n     }\n \n-    /// Assign a new value to the memory behind the pinned reference.\n+    /// Assigns a new value to the memory behind the pinned reference.\n+    ///\n+    /// This overwrites pinned data, but that is okay: its destructor gets\n+    /// run before being overwritten, so no pinning guarantee is violated.\n     #[stable(feature = \"pin\", since = \"1.33.0\")]\n     #[inline(always)]\n     pub fn set(self: &mut Pin<P>, value: P::Target)\n@@ -227,17 +461,21 @@ impl<P: DerefMut> Pin<P> {\n }\n \n impl<'a, T: ?Sized> Pin<&'a T> {\n-    /// Construct a new pin by mapping the interior value.\n+    /// Constructs a new pin by mapping the interior value.\n     ///\n     /// For example, if you  wanted to get a `Pin` of a field of something,\n     /// you could use this to get access to that field in one line of code.\n+    /// However, there are several gotchas with these \"pinning projections\";\n+    /// see the [`pin` module] documentation for further details on that topic.\n     ///\n     /// # Safety\n     ///\n     /// This function is unsafe. You must guarantee that the data you return\n     /// will not move so long as the argument value does not move (for example,\n     /// because it is one of the fields of that value), and also that you do\n     /// not move out of the argument you receive to the interior function.\n+    ///\n+    /// [`pin` module]: ../../std/pin/index.html#projections-and-structural-pinning\n     #[stable(feature = \"pin\", since = \"1.33.0\")]\n     pub unsafe fn map_unchecked<U, F>(self: Pin<&'a T>, func: F) -> Pin<&'a U> where\n         F: FnOnce(&T) -> &U,\n@@ -249,11 +487,21 @@ impl<'a, T: ?Sized> Pin<&'a T> {\n \n     /// Gets a shared reference out of a pin.\n     ///\n+    /// This is safe because it is not possible to move out of a shared reference.\n+    /// It may seem like there is an issue here with interior mutability: in fact,\n+    /// it *is* possible to move a `T` out of a `&RefCell<T>`. However, this is\n+    /// not a problem as long as there does not also exist a `Pin<&T>` pointing\n+    /// to the same data, and `RefCell<T>` does not let you create a pinned reference\n+    /// to its contents. See the discussion on [\"pinning projections\"] for further\n+    /// details.\n+    ///\n     /// Note: `Pin` also implements `Deref` to the target, which can be used\n     /// to access the inner value. However, `Deref` only provides a reference\n     /// that lives for as long as the borrow of the `Pin`, not the lifetime of\n     /// the `Pin` itself. This method allows turning the `Pin` into a reference\n     /// with the same lifetime as the original `Pin`.\n+    ///\n+    /// [\"pinning projections\"]: ../../std/pin/index.html#projections-and-structural-pinning\n     #[stable(feature = \"pin\", since = \"1.33.0\")]\n     #[inline(always)]\n     pub fn get_ref(self: Pin<&'a T>) -> &'a T {\n@@ -306,13 +554,17 @@ impl<'a, T: ?Sized> Pin<&'a mut T> {\n     ///\n     /// For example, if you  wanted to get a `Pin` of a field of something,\n     /// you could use this to get access to that field in one line of code.\n+    /// However, there are several gotchas with these \"pinning projections\";\n+    /// see the [`pin` module] documentation for further details on that topic.\n     ///\n     /// # Safety\n     ///\n     /// This function is unsafe. You must guarantee that the data you return\n     /// will not move so long as the argument value does not move (for example,\n     /// because it is one of the fields of that value), and also that you do\n     /// not move out of the argument you receive to the interior function.\n+    ///\n+    /// [`pin` module]: ../../std/pin/index.html#projections-and-structural-pinning\n     #[stable(feature = \"pin\", since = \"1.33.0\")]\n     pub unsafe fn map_unchecked_mut<U, F>(self: Pin<&'a mut T>, func: F) -> Pin<&'a mut U> where\n         F: FnOnce(&mut T) -> &mut U,"}]}