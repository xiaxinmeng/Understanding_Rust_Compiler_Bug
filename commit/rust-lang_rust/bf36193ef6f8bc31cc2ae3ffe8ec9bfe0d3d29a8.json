{"sha": "bf36193ef6f8bc31cc2ae3ffe8ec9bfe0d3d29a8", "node_id": "C_kwDOAAsO6NoAKGJmMzYxOTNlZjZmOGJjMzFjYzJhZTNmZmU4ZWM5YmZlMGQzZDI5YTg", "commit": {"author": {"name": "Scott McMurray", "email": "scottmcm@users.noreply.github.com", "date": "2023-05-07T10:00:41Z"}, "committer": {"name": "Scott McMurray", "email": "scottmcm@users.noreply.github.com", "date": "2023-06-01T02:10:28Z"}, "message": "Add a distinct `OperandValue::ZeroSized` variant for ZSTs\n\nThese tend to have special handling in a bunch of places anyway, so the variant helps remember that.  And I think it's easier to grok than non-Scalar Aggregates sometimes being `Immediates` (like I got wrong and caused 109992).  As a minor bonus, it means we don't need to generate poison LLVM values for them to pass around in `OperandValue::Immediate`s.", "tree": {"sha": "db59ccdba77d3aeac89616255764b65ce5603dab", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/db59ccdba77d3aeac89616255764b65ce5603dab"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bf36193ef6f8bc31cc2ae3ffe8ec9bfe0d3d29a8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bf36193ef6f8bc31cc2ae3ffe8ec9bfe0d3d29a8", "html_url": "https://github.com/rust-lang/rust/commit/bf36193ef6f8bc31cc2ae3ffe8ec9bfe0d3d29a8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bf36193ef6f8bc31cc2ae3ffe8ec9bfe0d3d29a8/comments", "author": {"login": "scottmcm", "id": 18526288, "node_id": "MDQ6VXNlcjE4NTI2Mjg4", "avatar_url": "https://avatars.githubusercontent.com/u/18526288?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scottmcm", "html_url": "https://github.com/scottmcm", "followers_url": "https://api.github.com/users/scottmcm/followers", "following_url": "https://api.github.com/users/scottmcm/following{/other_user}", "gists_url": "https://api.github.com/users/scottmcm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scottmcm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scottmcm/subscriptions", "organizations_url": "https://api.github.com/users/scottmcm/orgs", "repos_url": "https://api.github.com/users/scottmcm/repos", "events_url": "https://api.github.com/users/scottmcm/events{/privacy}", "received_events_url": "https://api.github.com/users/scottmcm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "scottmcm", "id": 18526288, "node_id": "MDQ6VXNlcjE4NTI2Mjg4", "avatar_url": "https://avatars.githubusercontent.com/u/18526288?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scottmcm", "html_url": "https://github.com/scottmcm", "followers_url": "https://api.github.com/users/scottmcm/followers", "following_url": "https://api.github.com/users/scottmcm/following{/other_user}", "gists_url": "https://api.github.com/users/scottmcm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scottmcm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scottmcm/subscriptions", "organizations_url": "https://api.github.com/users/scottmcm/orgs", "repos_url": "https://api.github.com/users/scottmcm/repos", "events_url": "https://api.github.com/users/scottmcm/events{/privacy}", "received_events_url": "https://api.github.com/users/scottmcm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9af3865deca9c601ef32ef4ed29f7cae5fed50a9", "url": "https://api.github.com/repos/rust-lang/rust/commits/9af3865deca9c601ef32ef4ed29f7cae5fed50a9", "html_url": "https://github.com/rust-lang/rust/commit/9af3865deca9c601ef32ef4ed29f7cae5fed50a9"}], "stats": {"total": 233, "additions": 157, "deletions": 76}, "files": [{"sha": "f9ea0f004564b4a0b1f07801664e33b552c14f46", "filename": "compiler/rustc_codegen_gcc/src/builder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf36193ef6f8bc31cc2ae3ffe8ec9bfe0d3d29a8/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf36193ef6f8bc31cc2ae3ffe8ec9bfe0d3d29a8/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbuilder.rs?ref=bf36193ef6f8bc31cc2ae3ffe8ec9bfe0d3d29a8", "patch": "@@ -758,7 +758,7 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n         assert_eq!(place.llextra.is_some(), place.layout.is_unsized());\n \n         if place.layout.is_zst() {\n-            return OperandRef::new_zst(self, place.layout);\n+            return OperandRef::zero_sized(place.layout);\n         }\n \n         fn scalar_load_metadata<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>, load: RValue<'gcc>, scalar: &abi::Scalar) {"}, {"sha": "30a3fe67b854396011f70fec7c5df0f249c64d41", "filename": "compiler/rustc_codegen_gcc/src/type_of.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bf36193ef6f8bc31cc2ae3ffe8ec9bfe0d3d29a8/compiler%2Frustc_codegen_gcc%2Fsrc%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf36193ef6f8bc31cc2ae3ffe8ec9bfe0d3d29a8/compiler%2Frustc_codegen_gcc%2Fsrc%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Ftype_of.rs?ref=bf36193ef6f8bc31cc2ae3ffe8ec9bfe0d3d29a8", "patch": "@@ -159,8 +159,7 @@ impl<'tcx> LayoutGccExt<'tcx> for TyAndLayout<'tcx> {\n     fn is_gcc_immediate(&self) -> bool {\n         match self.abi {\n             Abi::Scalar(_) | Abi::Vector { .. } => true,\n-            Abi::ScalarPair(..) => false,\n-            Abi::Uninhabited | Abi::Aggregate { .. } => self.is_zst(),\n+            Abi::ScalarPair(..) | Abi::Uninhabited | Abi::Aggregate { .. } => false,\n         }\n     }\n "}, {"sha": "5968e70b1cccef32108b94113ca8ac780ea00153", "filename": "compiler/rustc_codegen_llvm/src/builder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf36193ef6f8bc31cc2ae3ffe8ec9bfe0d3d29a8/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf36193ef6f8bc31cc2ae3ffe8ec9bfe0d3d29a8/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs?ref=bf36193ef6f8bc31cc2ae3ffe8ec9bfe0d3d29a8", "patch": "@@ -486,7 +486,7 @@ impl<'a, 'll, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         assert_eq!(place.llextra.is_some(), place.layout.is_unsized());\n \n         if place.layout.is_zst() {\n-            return OperandRef::new_zst(self, place.layout);\n+            return OperandRef::zero_sized(place.layout);\n         }\n \n         #[instrument(level = \"trace\", skip(bx))]"}, {"sha": "a493c9c0548e90f505ba4b2fc092d9676b1d1db7", "filename": "compiler/rustc_codegen_llvm/src/type_of.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bf36193ef6f8bc31cc2ae3ffe8ec9bfe0d3d29a8/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf36193ef6f8bc31cc2ae3ffe8ec9bfe0d3d29a8/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_of.rs?ref=bf36193ef6f8bc31cc2ae3ffe8ec9bfe0d3d29a8", "patch": "@@ -198,8 +198,7 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyAndLayout<'tcx> {\n     fn is_llvm_immediate(&self) -> bool {\n         match self.abi {\n             Abi::Scalar(_) | Abi::Vector { .. } => true,\n-            Abi::ScalarPair(..) => false,\n-            Abi::Uninhabited | Abi::Aggregate { .. } => self.is_zst(),\n+            Abi::ScalarPair(..) | Abi::Uninhabited | Abi::Aggregate { .. } => false,\n         }\n     }\n "}, {"sha": "242d209b68425db326f234e0f016b90fc87356fe", "filename": "compiler/rustc_codegen_ssa/src/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf36193ef6f8bc31cc2ae3ffe8ec9bfe0d3d29a8/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf36193ef6f8bc31cc2ae3ffe8ec9bfe0d3d29a8/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs?ref=bf36193ef6f8bc31cc2ae3ffe8ec9bfe0d3d29a8", "patch": "@@ -295,7 +295,7 @@ pub fn coerce_unsized_into<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n             let (base, info) = match bx.load_operand(src).val {\n                 OperandValue::Pair(base, info) => unsize_ptr(bx, base, src_ty, dst_ty, Some(info)),\n                 OperandValue::Immediate(base) => unsize_ptr(bx, base, src_ty, dst_ty, None),\n-                OperandValue::Ref(..) => bug!(),\n+                OperandValue::Ref(..) | OperandValue::ZeroSized => bug!(),\n             };\n             OperandValue::Pair(base, info).store(bx, dst);\n         }"}, {"sha": "e0cb26d3ba8667548f844327b1ce084c5fac03fd", "filename": "compiler/rustc_codegen_ssa/src/mir/block.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/bf36193ef6f8bc31cc2ae3ffe8ec9bfe0d3d29a8/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf36193ef6f8bc31cc2ae3ffe8ec9bfe0d3d29a8/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs?ref=bf36193ef6f8bc31cc2ae3ffe8ec9bfe0d3d29a8", "patch": "@@ -1,5 +1,5 @@\n use super::operand::OperandRef;\n-use super::operand::OperandValue::{Immediate, Pair, Ref};\n+use super::operand::OperandValue::{Immediate, Pair, Ref, ZeroSized};\n use super::place::PlaceRef;\n use super::{CachedLlbb, FunctionCx, LocalRef};\n \n@@ -427,6 +427,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                         assert_eq!(align, op.layout.align.abi, \"return place is unaligned!\");\n                         llval\n                     }\n+                    ZeroSized => bug!(\"ZST return value shouldn't be in PassMode::Cast\"),\n                 };\n                 let ty = bx.cast_backend_type(cast_ty);\n                 let addr = bx.pointercast(llslot, bx.type_ptr_to(ty));\n@@ -1386,6 +1387,16 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     (llval, align, true)\n                 }\n             }\n+            ZeroSized => match arg.mode {\n+                PassMode::Indirect { .. } => {\n+                    // Though `extern \"Rust\"` doesn't pass ZSTs, some ABIs pass\n+                    // a pointer for `repr(C)` structs even when empty, so get\n+                    // one from an `alloca` (which can be left uninitialized).\n+                    let scratch = PlaceRef::alloca(bx, arg.layout);\n+                    (scratch.llval, scratch.align, true)\n+                }\n+                _ => bug!(\"ZST {op:?} wasn't ignored, but was passed with abi {arg:?}\"),\n+            },\n         };\n \n         if by_ref && !arg.is_indirect() {"}, {"sha": "4f79c6a3d823c83e912348e0e192a08a754020b0", "filename": "compiler/rustc_codegen_ssa/src/mir/debuginfo.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bf36193ef6f8bc31cc2ae3ffe8ec9bfe0d3d29a8/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf36193ef6f8bc31cc2ae3ffe8ec9bfe0d3d29a8/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fdebuginfo.rs?ref=bf36193ef6f8bc31cc2ae3ffe8ec9bfe0d3d29a8", "patch": "@@ -352,6 +352,9 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                         bx.set_var_name(a, &(name.clone() + \".0\"));\n                         bx.set_var_name(b, &(name.clone() + \".1\"));\n                     }\n+                    OperandValue::ZeroSized => {\n+                        // These never have a value to talk about\n+                    }\n                 },\n                 LocalRef::PendingOperand => {}\n             }"}, {"sha": "2809ec2deb550c1926265bc6557aa7290a8f8c59", "filename": "compiler/rustc_codegen_ssa/src/mir/mod.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/bf36193ef6f8bc31cc2ae3ffe8ec9bfe0d3d29a8/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf36193ef6f8bc31cc2ae3ffe8ec9bfe0d3d29a8/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs?ref=bf36193ef6f8bc31cc2ae3ffe8ec9bfe0d3d29a8", "patch": "@@ -129,16 +129,13 @@ enum LocalRef<'tcx, V> {\n     PendingOperand,\n }\n \n-impl<'a, 'tcx, V: CodegenObject> LocalRef<'tcx, V> {\n-    fn new_operand<Bx: BuilderMethods<'a, 'tcx, Value = V>>(\n-        bx: &mut Bx,\n-        layout: TyAndLayout<'tcx>,\n-    ) -> LocalRef<'tcx, V> {\n+impl<'tcx, V: CodegenObject> LocalRef<'tcx, V> {\n+    fn new_operand(layout: TyAndLayout<'tcx>) -> LocalRef<'tcx, V> {\n         if layout.is_zst() {\n             // Zero-size temporaries aren't always initialized, which\n             // doesn't matter because they don't contain data, but\n             // we need something in the operand.\n-            LocalRef::Operand(OperandRef::new_zst(bx, layout))\n+            LocalRef::Operand(OperandRef::zero_sized(layout))\n         } else {\n             LocalRef::PendingOperand\n         }\n@@ -249,7 +246,7 @@ pub fn codegen_mir<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n                 }\n             } else {\n                 debug!(\"alloc: {:?} -> operand\", local);\n-                LocalRef::new_operand(&mut start_bx, layout)\n+                LocalRef::new_operand(layout)\n             }\n         };\n \n@@ -355,7 +352,7 @@ fn arg_local_refs<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n                 let local = |op| LocalRef::Operand(op);\n                 match arg.mode {\n                     PassMode::Ignore => {\n-                        return local(OperandRef::new_zst(bx, arg.layout));\n+                        return local(OperandRef::zero_sized(arg.layout));\n                     }\n                     PassMode::Direct(_) => {\n                         let llarg = bx.get_param(llarg_idx);"}, {"sha": "31c293d7c298ec555eb18e044bc58bb12326fbcc", "filename": "compiler/rustc_codegen_ssa/src/mir/operand.rs", "status": "modified", "additions": 26, "deletions": 23, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/bf36193ef6f8bc31cc2ae3ffe8ec9bfe0d3d29a8/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf36193ef6f8bc31cc2ae3ffe8ec9bfe0d3d29a8/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Foperand.rs?ref=bf36193ef6f8bc31cc2ae3ffe8ec9bfe0d3d29a8", "patch": "@@ -45,6 +45,14 @@ pub enum OperandValue<V> {\n     /// as returned by [`LayoutTypeMethods::scalar_pair_element_backend_type`]\n     /// with `immediate: true`.\n     Pair(V, V),\n+    /// A value taking no bytes, and which therefore needs no LLVM value at all.\n+    ///\n+    /// If you ever need a `V` to pass to something, get a fresh poison value\n+    /// from [`ConstMethods::const_poison`].\n+    ///\n+    /// An `OperandValue` *must* be this variant for any type for which\n+    /// `is_zst` on its `Layout` returns `true`.\n+    ZeroSized,\n }\n \n /// An `OperandRef` is an \"SSA\" reference to a Rust value, along with\n@@ -71,15 +79,9 @@ impl<V: CodegenObject> fmt::Debug for OperandRef<'_, V> {\n }\n \n impl<'a, 'tcx, V: CodegenObject> OperandRef<'tcx, V> {\n-    pub fn new_zst<Bx: BuilderMethods<'a, 'tcx, Value = V>>(\n-        bx: &mut Bx,\n-        layout: TyAndLayout<'tcx>,\n-    ) -> OperandRef<'tcx, V> {\n+    pub fn zero_sized(layout: TyAndLayout<'tcx>) -> OperandRef<'tcx, V> {\n         assert!(layout.is_zst());\n-        OperandRef {\n-            val: OperandValue::Immediate(bx.const_poison(bx.immediate_backend_type(layout))),\n-            layout,\n-        }\n+        OperandRef { val: OperandValue::ZeroSized, layout }\n     }\n \n     pub fn from_const<Bx: BuilderMethods<'a, 'tcx, Value = V>>(\n@@ -97,7 +99,7 @@ impl<'a, 'tcx, V: CodegenObject> OperandRef<'tcx, V> {\n                 let llval = bx.scalar_to_backend(x, scalar, bx.immediate_backend_type(layout));\n                 OperandValue::Immediate(llval)\n             }\n-            ConstValue::ZeroSized => return OperandRef::new_zst(bx, layout),\n+            ConstValue::ZeroSized => return OperandRef::zero_sized(layout),\n             ConstValue::Slice { data, start, end } => {\n                 let Abi::ScalarPair(a_scalar, _) = layout.abi else {\n                     bug!(\"from_const: invalid ScalarPair layout: {:#?}\", layout);\n@@ -178,7 +180,7 @@ impl<'a, 'tcx, V: CodegenObject> OperandRef<'tcx, V> {\n                 );\n                 OperandRef { val: OperandValue::Pair(a_val, b_val), layout }\n             }\n-            _ if layout.is_zst() => OperandRef::new_zst(bx, layout),\n+            _ if layout.is_zst() => OperandRef::zero_sized(layout),\n             _ => {\n                 // Neither a scalar nor scalar pair. Load from a place\n                 let init = bx.const_data_from_alloc(alloc);\n@@ -216,6 +218,7 @@ impl<'a, 'tcx, V: CodegenObject> OperandRef<'tcx, V> {\n             OperandValue::Immediate(llptr) => (llptr, None),\n             OperandValue::Pair(llptr, llextra) => (llptr, Some(llextra)),\n             OperandValue::Ref(..) => bug!(\"Deref of by-Ref operand {:?}\", self),\n+            OperandValue::ZeroSized => bug!(\"Deref of ZST operand {:?}\", self),\n         };\n         let layout = cx.layout_of(projected_ty);\n         PlaceRef { llval: llptr, llextra, layout, align: layout.align.abi }\n@@ -273,9 +276,7 @@ impl<'a, 'tcx, V: CodegenObject> OperandRef<'tcx, V> {\n \n         let mut val = match (self.val, self.layout.abi) {\n             // If the field is ZST, it has no data.\n-            _ if field.is_zst() => {\n-                return OperandRef::new_zst(bx, field);\n-            }\n+            _ if field.is_zst() => OperandValue::ZeroSized,\n \n             // Newtype of a scalar, scalar pair or vector.\n             (OperandValue::Immediate(_) | OperandValue::Pair(..), _)\n@@ -306,6 +307,7 @@ impl<'a, 'tcx, V: CodegenObject> OperandRef<'tcx, V> {\n         };\n \n         match (&mut val, field.abi) {\n+            (OperandValue::ZeroSized, _) => {}\n             (\n                 OperandValue::Immediate(llval),\n                 Abi::Scalar(_) | Abi::ScalarPair(..) | Abi::Vector { .. },\n@@ -359,16 +361,18 @@ impl<'a, 'tcx, V: CodegenObject> OperandRef<'tcx, V> {\n impl<'a, 'tcx, V: CodegenObject> OperandValue<V> {\n     /// Returns an `OperandValue` that's generally UB to use in any way.\n     ///\n-    /// Depending on the `layout`, returns an `Immediate` or `Pair` containing\n-    /// poison value(s), or a `Ref` containing a poison pointer.\n+    /// Depending on the `layout`, returns `ZeroSized` for ZSTs, an `Immediate` or\n+    /// `Pair` containing poison value(s), or a `Ref` containing a poison pointer.\n     ///\n     /// Supports sized types only.\n     pub fn poison<Bx: BuilderMethods<'a, 'tcx, Value = V>>(\n         bx: &mut Bx,\n         layout: TyAndLayout<'tcx>,\n     ) -> OperandValue<V> {\n         assert!(layout.is_sized());\n-        if bx.cx().is_backend_immediate(layout) {\n+        if layout.is_zst() {\n+            OperandValue::ZeroSized\n+        } else if bx.cx().is_backend_immediate(layout) {\n             let ibty = bx.cx().immediate_backend_type(layout);\n             OperandValue::Immediate(bx.const_poison(ibty))\n         } else if bx.cx().is_backend_scalar_pair(layout) {\n@@ -421,12 +425,11 @@ impl<'a, 'tcx, V: CodegenObject> OperandValue<V> {\n         flags: MemFlags,\n     ) {\n         debug!(\"OperandRef::store: operand={:?}, dest={:?}\", self, dest);\n-        // Avoid generating stores of zero-sized values, because the only way to have a zero-sized\n-        // value is through `undef`, and store itself is useless.\n-        if dest.layout.is_zst() {\n-            return;\n-        }\n         match self {\n+            OperandValue::ZeroSized => {\n+                // Avoid generating stores of zero-sized values, because the only way to have a zero-sized\n+                // value is through `undef`/`poison`, and the store itself is useless.\n+            }\n             OperandValue::Ref(r, None, source_align) => {\n                 if flags.contains(MemFlags::NONTEMPORAL) {\n                     // HACK(nox): This is inefficient but there is no nontemporal memcpy.\n@@ -527,7 +530,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                             // checks in `codegen_consume` and `extract_field`.\n                             let elem = o.layout.field(bx.cx(), 0);\n                             if elem.is_zst() {\n-                                o = OperandRef::new_zst(bx, elem);\n+                                o = OperandRef::zero_sized(elem);\n                             } else {\n                                 return None;\n                             }\n@@ -561,7 +564,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n \n         // ZSTs don't require any actual memory access.\n         if layout.is_zst() {\n-            return OperandRef::new_zst(bx, layout);\n+            return OperandRef::zero_sized(layout);\n         }\n \n         if let Some(o) = self.maybe_codegen_consume_direct(bx, place_ref) {"}, {"sha": "5241a5aee008e4b09d9de6fca5da74051251668b", "filename": "compiler/rustc_codegen_ssa/src/mir/rvalue.rs", "status": "modified", "additions": 35, "deletions": 33, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/bf36193ef6f8bc31cc2ae3ffe8ec9bfe0d3d29a8/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf36193ef6f8bc31cc2ae3ffe8ec9bfe0d3d29a8/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs?ref=bf36193ef6f8bc31cc2ae3ffe8ec9bfe0d3d29a8", "patch": "@@ -70,6 +70,9 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     OperandValue::Ref(_, Some(_), _) => {\n                         bug!(\"unsized coercion on an unsized rvalue\");\n                     }\n+                    OperandValue::ZeroSized => {\n+                        bug!(\"unsized coercion on a ZST rvalue\");\n+                    }\n                 }\n             }\n \n@@ -165,11 +168,11 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         }\n \n         match src.val {\n-            OperandValue::Ref(..) => {\n+            OperandValue::Ref(..) | OperandValue::ZeroSized => {\n                 span_bug!(\n                     self.mir.span,\n                     \"Operand path should have handled transmute \\\n-                    from `Ref` {src:?} to place {dst:?}\"\n+                    from {src:?} to place {dst:?}\"\n                 );\n             }\n             OperandValue::Immediate(..) | OperandValue::Pair(..) => {\n@@ -220,17 +223,22 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 let fake_place = PlaceRef::new_sized_aligned(cast_ptr, cast, align);\n                 Some(bx.load_operand(fake_place).val)\n             }\n+            OperandValue::ZeroSized => {\n+                let OperandValueKind::ZeroSized = operand_kind else {\n+                    bug!(\"Found {operand_kind:?} for operand {operand:?}\");\n+                };\n+                if let OperandValueKind::ZeroSized = cast_kind {\n+                    Some(OperandValue::ZeroSized)\n+                } else {\n+                    None\n+                }\n+            }\n             OperandValue::Immediate(imm) => {\n                 let OperandValueKind::Immediate(in_scalar) = operand_kind else {\n                     bug!(\"Found {operand_kind:?} for operand {operand:?}\");\n                 };\n-                if let OperandValueKind::Immediate(out_scalar) = cast_kind {\n-                    match (in_scalar, out_scalar) {\n-                        (ScalarOrZst::Zst, ScalarOrZst::Zst) => {\n-                            Some(OperandRef::new_zst(bx, cast).val)\n-                        }\n-                        (ScalarOrZst::Scalar(in_scalar), ScalarOrZst::Scalar(out_scalar))\n-                            if in_scalar.size(self.cx) == out_scalar.size(self.cx) =>\n+                if let OperandValueKind::Immediate(out_scalar) = cast_kind\n+                    && in_scalar.size(self.cx) == out_scalar.size(self.cx)\n                         {\n                             let operand_bty = bx.backend_type(operand.layout);\n                             let cast_bty = bx.backend_type(cast);\n@@ -242,9 +250,6 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                                 out_scalar,\n                                 cast_bty,\n                             )))\n-                        }\n-                        _ => None,\n-                    }\n                 } else {\n                     None\n                 }\n@@ -457,6 +462,9 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                             OperandValue::Ref(..) => {\n                                 bug!(\"by-ref operand {:?} in `codegen_rvalue_operand`\", operand);\n                             }\n+                            OperandValue::ZeroSized => {\n+                                bug!(\"zero-sized operand {:?} in `codegen_rvalue_operand`\", operand);\n+                            }\n                         };\n                         let (lldata, llextra) =\n                             base::unsize_ptr(bx, lldata, operand.layout.ty, cast.ty, llextra);\n@@ -490,6 +498,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                             OperandValue::Ref(_, _, _) => todo!(),\n                             OperandValue::Immediate(v) => (v, None),\n                             OperandValue::Pair(v, l) => (v, Some(l)),\n+                            OperandValue::ZeroSized => bug!(\"ZST -- which is not PointerLike -- in DynStar\"),\n                         };\n                         let (lldata, llextra) =\n                             base::cast_to_dyn_star(bx, lldata, operand.layout, cast.ty, llextra);\n@@ -718,7 +727,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 // According to `rvalue_creates_operand`, only ZST\n                 // aggregate rvalues are allowed to be operands.\n                 let ty = rvalue.ty(self.mir, self.cx.tcx());\n-                OperandRef::new_zst(bx, self.cx.layout_of(self.monomorphize(ty)))\n+                OperandRef::zero_sized(self.cx.layout_of(self.monomorphize(ty)))\n             }\n             mir::Rvalue::ShallowInitBox(ref operand, content_ty) => {\n                 let operand = self.codegen_operand(bx, operand);\n@@ -936,6 +945,12 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     // Can always load from a pointer as needed\n                     (OperandValueKind::Ref, _) => true,\n \n+                    // ZST-to-ZST is the easiest thing ever\n+                    (OperandValueKind::ZeroSized, OperandValueKind::ZeroSized) => true,\n+\n+                    // But if only one of them is a ZST the sizes can't match\n+                    (OperandValueKind::ZeroSized, _) | (_, OperandValueKind::ZeroSized) => false,\n+\n                     // Need to generate an `alloc` to get a pointer from an immediate\n                     (OperandValueKind::Immediate(..) | OperandValueKind::Pair(..), OperandValueKind::Ref) => false,\n \n@@ -979,12 +994,13 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n \n     /// Gets which variant of [`OperandValue`] is expected for a particular type.\n     fn value_kind(&self, layout: TyAndLayout<'tcx>) -> OperandValueKind {\n-        if self.cx.is_backend_immediate(layout) {\n+        if layout.is_zst() {\n+            OperandValueKind::ZeroSized\n+        } else if self.cx.is_backend_immediate(layout) {\n             debug_assert!(!self.cx.is_backend_scalar_pair(layout));\n             OperandValueKind::Immediate(match layout.abi {\n-                abi::Abi::Scalar(s) => ScalarOrZst::Scalar(s),\n-                abi::Abi::Vector { element, .. } => ScalarOrZst::Scalar(element),\n-                _ if layout.is_zst() => ScalarOrZst::Zst,\n+                abi::Abi::Scalar(s) => s,\n+                abi::Abi::Vector { element, .. } => element,\n                 x => span_bug!(self.mir.span, \"Couldn't translate {x:?} as backend immediate\"),\n             })\n         } else if self.cx.is_backend_scalar_pair(layout) {\n@@ -1007,21 +1023,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n #[derive(Debug, Copy, Clone)]\n enum OperandValueKind {\n     Ref,\n-    Immediate(ScalarOrZst),\n+    Immediate(abi::Scalar),\n     Pair(abi::Scalar, abi::Scalar),\n-}\n-\n-#[derive(Debug, Copy, Clone)]\n-enum ScalarOrZst {\n-    Zst,\n-    Scalar(abi::Scalar),\n-}\n-\n-impl ScalarOrZst {\n-    pub fn size(self, cx: &impl abi::HasDataLayout) -> abi::Size {\n-        match self {\n-            ScalarOrZst::Zst => abi::Size::ZERO,\n-            ScalarOrZst::Scalar(s) => s.size(cx),\n-        }\n-    }\n+    ZeroSized,\n }"}, {"sha": "fe42494000e1704bd40c95d262195428e3cad26b", "filename": "tests/codegen/intrinsics/transmute.rs", "status": "modified", "additions": 71, "deletions": 4, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/bf36193ef6f8bc31cc2ae3ffe8ec9bfe0d3d29a8/tests%2Fcodegen%2Fintrinsics%2Ftransmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf36193ef6f8bc31cc2ae3ffe8ec9bfe0d3d29a8/tests%2Fcodegen%2Fintrinsics%2Ftransmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fintrinsics%2Ftransmute.rs?ref=bf36193ef6f8bc31cc2ae3ffe8ec9bfe0d3d29a8", "patch": "@@ -14,10 +14,10 @@ use std::intrinsics::{transmute, transmute_unchecked};\n // Some of these need custom MIR to not get removed by MIR optimizations.\n use std::intrinsics::mir::*;\n \n-enum Never {}\n+pub enum ZstNever {}\n \n #[repr(align(2))]\n-pub struct BigNever(Never, u16, Never);\n+pub struct BigNever(ZstNever, u16, ZstNever);\n \n #[repr(align(8))]\n pub struct Scalar64(i64);\n@@ -56,11 +56,13 @@ pub unsafe fn check_bigger_array(x: [u32; 3]) -> [u32; 7] {\n     transmute_unchecked(x)\n }\n \n-// CHECK-LABEL: @check_to_uninhabited(\n+// CHECK-LABEL: @check_to_empty_array(\n #[no_mangle]\n #[custom_mir(dialect = \"runtime\", phase = \"optimized\")]\n-pub unsafe fn check_to_uninhabited(x: u16) -> BigNever {\n+pub unsafe fn check_to_empty_array(x: [u32; 5]) -> [u32; 0] {\n+    // CHECK-NOT: trap\n     // CHECK: call void @llvm.trap\n+    // CHECK-NOT: trap\n     mir!{\n         {\n             RET = CastTransmute(x);\n@@ -69,6 +71,37 @@ pub unsafe fn check_to_uninhabited(x: u16) -> BigNever {\n     }\n }\n \n+// CHECK-LABEL: @check_from_empty_array(\n+#[no_mangle]\n+#[custom_mir(dialect = \"runtime\", phase = \"optimized\")]\n+pub unsafe fn check_from_empty_array(x: [u32; 0]) -> [u32; 5] {\n+    // CHECK-NOT: trap\n+    // CHECK: call void @llvm.trap\n+    // CHECK-NOT: trap\n+    mir!{\n+        {\n+            RET = CastTransmute(x);\n+            Return()\n+        }\n+    }\n+}\n+\n+// CHECK-LABEL: @check_to_uninhabited(\n+#[no_mangle]\n+#[custom_mir(dialect = \"runtime\", phase = \"optimized\")]\n+pub unsafe fn check_to_uninhabited(x: u16) {\n+    // CHECK-NOT: trap\n+    // CHECK: call void @llvm.trap\n+    // CHECK-NOT: trap\n+    mir!{\n+        let temp: BigNever;\n+        {\n+            temp = CastTransmute(x);\n+            Return()\n+        }\n+    }\n+}\n+\n // CHECK-LABEL: @check_from_uninhabited(\n #[no_mangle]\n #[custom_mir(dialect = \"runtime\", phase = \"optimized\")]\n@@ -366,6 +399,40 @@ pub unsafe fn check_issue_109992(x: ()) -> [(); 1] {\n     }\n }\n \n+// CHECK-LABEL: @check_unit_to_never(\n+#[no_mangle]\n+#[custom_mir(dialect = \"runtime\", phase = \"optimized\")]\n+pub unsafe fn check_unit_to_never(x: ()) {\n+    // This uses custom MIR to avoid MIR optimizations having removed ZST ops.\n+\n+    // CHECK-NOT: trap\n+    // CHECK: call void @llvm.trap\n+    // CHECK-NOT: trap\n+    mir!{\n+        let temp: ZstNever;\n+        {\n+            temp = CastTransmute(x);\n+            Return()\n+        }\n+    }\n+}\n+\n+// CHECK-LABEL: @check_unit_from_never(\n+#[no_mangle]\n+#[custom_mir(dialect = \"runtime\", phase = \"optimized\")]\n+pub unsafe fn check_unit_from_never(x: ZstNever) -> () {\n+    // This uses custom MIR to avoid MIR optimizations having removed ZST ops.\n+\n+    // CHECK: start\n+    // CHECK-NEXT: ret void\n+    mir!{\n+        {\n+            RET = CastTransmute(x);\n+            Return()\n+        }\n+    }\n+}\n+\n // CHECK-LABEL: @check_maybe_uninit_pair(i16 %x.0, i64 %x.1)\n #[no_mangle]\n pub unsafe fn check_maybe_uninit_pair("}]}