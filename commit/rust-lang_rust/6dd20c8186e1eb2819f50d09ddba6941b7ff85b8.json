{"sha": "6dd20c8186e1eb2819f50d09ddba6941b7ff85b8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZkZDIwYzgxODZlMWViMjgxOWY1MGQwOWRkYmE2OTQxYjdmZjg1Yjg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-03-30T22:42:43Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-03-30T22:42:43Z"}, "message": "auto merge of #5630 : erickt/rust/serial, r=erickt\n\n@nikomatsakis and I were talking about how the serializers were a bit too complicated. None of the users of With the `emit_option` and `read_option` functions, the serializers are now moving more high level. This patch series continues that trend. I've removed support for emitting specific string and vec types, and added support for emitting mapping types.", "tree": {"sha": "69979296882e63fc8386e60ae379b9361db579ca", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/69979296882e63fc8386e60ae379b9361db579ca"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6dd20c8186e1eb2819f50d09ddba6941b7ff85b8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6dd20c8186e1eb2819f50d09ddba6941b7ff85b8", "html_url": "https://github.com/rust-lang/rust/commit/6dd20c8186e1eb2819f50d09ddba6941b7ff85b8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6dd20c8186e1eb2819f50d09ddba6941b7ff85b8/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fbd8eae26de23cf00081229176fd7efd80943905", "url": "https://api.github.com/repos/rust-lang/rust/commits/fbd8eae26de23cf00081229176fd7efd80943905", "html_url": "https://github.com/rust-lang/rust/commit/fbd8eae26de23cf00081229176fd7efd80943905"}, {"sha": "810c4d8a1e0bdae3c2aba86a8b93e20faecba283", "url": "https://api.github.com/repos/rust-lang/rust/commits/810c4d8a1e0bdae3c2aba86a8b93e20faecba283", "html_url": "https://github.com/rust-lang/rust/commit/810c4d8a1e0bdae3c2aba86a8b93e20faecba283"}], "stats": {"total": 1596, "additions": 837, "deletions": 759}, "files": [{"sha": "9387ec4f43209e32e051c573e697419f831bc3eb", "filename": "src/libcore/hashmap.rs", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/6dd20c8186e1eb2819f50d09ddba6941b7ff85b8/src%2Flibcore%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dd20c8186e1eb2819f50d09ddba6941b7ff85b8/src%2Flibcore%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhashmap.rs?ref=6dd20c8186e1eb2819f50d09ddba6941b7ff85b8", "patch": "@@ -393,10 +393,16 @@ pub mod linear {\n         }\n     }\n \n-    pub impl<K:Hash + IterBytes + Eq,V> LinearMap<K, V> {\n+    pub impl<K: Hash + IterBytes + Eq, V> LinearMap<K, V> {\n         /// Create an empty LinearMap\n         fn new() -> LinearMap<K, V> {\n-            linear_map_with_capacity(INITIAL_CAPACITY)\n+            LinearMap::with_capacity(INITIAL_CAPACITY)\n+        }\n+\n+        /// Create an empty LinearMap with space for at least `n` elements in\n+        /// the hash table.\n+        fn with_capacity(capacity: uint) -> LinearMap<K, V> {\n+            linear_map_with_capacity(capacity)\n         }\n \n         /// Reserve space for at least `n` elements in the hash table.\n@@ -652,7 +658,15 @@ pub mod linear {\n \n     pub impl <T:Hash + IterBytes + Eq> LinearSet<T> {\n         /// Create an empty LinearSet\n-        fn new() -> LinearSet<T> { LinearSet{map: LinearMap::new()} }\n+        fn new() -> LinearSet<T> {\n+            LinearSet::with_capacity(INITIAL_CAPACITY)\n+        }\n+\n+        /// Create an empty LinearSet with space for at least `n` elements in\n+        /// the hash table.\n+        fn with_capacity(capacity: uint) -> LinearSet<T> {\n+            LinearSet { map: LinearMap::with_capacity(capacity) }\n+        }\n \n         /// Reserve space for at least `n` elements in the hash table.\n         fn reserve_at_least(&mut self, n: uint) {"}, {"sha": "0ac86ac280d069d93745f9cb1e95698696f8e7fc", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/6dd20c8186e1eb2819f50d09ddba6941b7ff85b8/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dd20c8186e1eb2819f50d09ddba6941b7ff85b8/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=6dd20c8186e1eb2819f50d09ddba6941b7ff85b8", "patch": "@@ -560,6 +560,28 @@ pub fn consume<T>(mut v: ~[T], f: &fn(uint, v: T)) {\n     }\n }\n \n+pub fn consume_reverse<T>(mut v: ~[T], f: &fn(uint, v: T)) {\n+    unsafe {\n+        do as_mut_buf(v) |p, ln| {\n+            let mut i = ln;\n+            while i > 0 {\n+                i -= 1;\n+\n+                // NB: This unsafe operation counts on init writing 0s to the\n+                // holes we create in the vector. That ensures that, if the\n+                // iterator fails then we won't try to clean up the consumed\n+                // elements during unwinding\n+                let mut x = intrinsics::init();\n+                let p = ptr::mut_offset(p, i);\n+                x <-> *p;\n+                f(i, x);\n+            }\n+        }\n+\n+        raw::set_len(&mut v, 0);\n+    }\n+}\n+\n /// Remove the last element from a vector and return it\n pub fn pop<T>(v: &mut ~[T]) -> T {\n     let ln = v.len();\n@@ -1985,6 +2007,7 @@ pub trait OwnedVector<T> {\n     fn truncate(&mut self, newlen: uint);\n     fn retain(&mut self, f: &fn(t: &T) -> bool);\n     fn consume(self, f: &fn(uint, v: T));\n+    fn consume_reverse(self, f: &fn(uint, v: T));\n     fn filter(self, f: &fn(t: &T) -> bool) -> ~[T];\n     fn partition(self, f: &fn(&T) -> bool) -> (~[T], ~[T]);\n     fn grow_fn(&mut self, n: uint, op: iter::InitOp<T>);\n@@ -2046,6 +2069,11 @@ impl<T> OwnedVector<T> for ~[T] {\n         consume(self, f)\n     }\n \n+    #[inline]\n+    fn consume_reverse(self, f: &fn(uint, v: T)) {\n+        consume_reverse(self, f)\n+    }\n+\n     #[inline]\n     fn filter(self, f: &fn(&T) -> bool) -> ~[T] {\n         filter(self, f)"}, {"sha": "b6b6730620e9ea1e7c7682877701570faa676a4c", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 5, "deletions": 16, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/6dd20c8186e1eb2819f50d09ddba6941b7ff85b8/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dd20c8186e1eb2819f50d09ddba6941b7ff85b8/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=6dd20c8186e1eb2819f50d09ddba6941b7ff85b8", "patch": "@@ -558,7 +558,7 @@ trait read_method_map_entry_helper {\n fn encode_method_map_entry(ecx: @e::EncodeContext,\n                               ebml_w: writer::Encoder,\n                               mme: method_map_entry) {\n-    do ebml_w.emit_rec {\n+    do ebml_w.emit_struct(\"method_map_entry\", 3) {\n         do ebml_w.emit_field(~\"self_arg\", 0u) {\n             ebml_w.emit_arg(ecx, mme.self_arg);\n         }\n@@ -574,7 +574,7 @@ fn encode_method_map_entry(ecx: @e::EncodeContext,\n impl read_method_map_entry_helper for reader::Decoder {\n     fn read_method_map_entry(&self, xcx: @ExtendedDecodeContext)\n         -> method_map_entry {\n-        do self.read_rec {\n+        do self.read_struct(\"method_map_entry\", 3) {\n             method_map_entry {\n                 self_arg: self.read_field(~\"self_arg\", 0u, || {\n                     self.read_arg(xcx)\n@@ -778,7 +778,7 @@ impl ebml_writer_helpers for writer::Encoder {\n \n     fn emit_tpbt(&self, ecx: @e::EncodeContext,\n                  tpbt: ty::ty_param_bounds_and_ty) {\n-        do self.emit_rec {\n+        do self.emit_struct(\"ty_param_bounds_and_ty\", 3) {\n             do self.emit_field(~\"bounds\", 0) {\n                 do self.emit_from_vec(*tpbt.bounds) |bs| {\n                     self.emit_bounds(ecx, *bs);\n@@ -1045,7 +1045,7 @@ impl ebml_decoder_decoder_helpers for reader::Decoder {\n     fn read_ty_param_bounds_and_ty(&self, xcx: @ExtendedDecodeContext)\n         -> ty::ty_param_bounds_and_ty\n     {\n-        do self.read_rec {\n+        do self.read_struct(\"ty_param_bounds_and_ty\", 3) {\n             ty::ty_param_bounds_and_ty {\n                 bounds: self.read_field(~\"bounds\", 0u, || {\n                     @self.read_to_vec(|| self.read_bounds(xcx) )\n@@ -1212,7 +1212,6 @@ fn mk_ctxt() -> @fake_ext_ctxt {\n #[cfg(test)]\n fn roundtrip(in_item: Option<@ast::item>) {\n     use core::io;\n-    use std::prettyprint;\n \n     let in_item = in_item.get();\n     let bytes = do io::with_bytes_writer |wr| {\n@@ -1222,17 +1221,7 @@ fn roundtrip(in_item: Option<@ast::item>) {\n     let ebml_doc = reader::Doc(@bytes);\n     let out_item = decode_item_ast(ebml_doc);\n \n-    let exp_str = do io::with_str_writer |w| {\n-        in_item.encode(&prettyprint::Serializer(w))\n-    };\n-    let out_str = do io::with_str_writer |w| {\n-        out_item.encode(&prettyprint::Serializer(w))\n-    };\n-\n-    debug!(\"expected string: %s\", exp_str);\n-    debug!(\"actual string  : %s\", out_str);\n-\n-    assert!(exp_str == out_str);\n+    assert_eq!(in_item, out_item);\n }\n \n #[test]"}, {"sha": "e7ec86963eeb5831635a5d68fd46b67df473ec9e", "filename": "src/libstd/deque.rs", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/6dd20c8186e1eb2819f50d09ddba6941b7ff85b8/src%2Flibstd%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dd20c8186e1eb2819f50d09ddba6941b7ff85b8/src%2Flibstd%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdeque.rs?ref=6dd20c8186e1eb2819f50d09ddba6941b7ff85b8", "patch": "@@ -66,6 +66,18 @@ pub impl<T> Deque<T> {\n         get(self.elts, idx)\n     }\n \n+    /// Iterate over the elements in the deque\n+    fn each(&self, f: &fn(&T) -> bool) {\n+        self.eachi(|_i, e| f(e))\n+    }\n+\n+    /// Iterate over the elements in the deque by index\n+    fn eachi(&self, f: &fn(uint, &T) -> bool) {\n+        for uint::range(0, self.nelts) |i| {\n+            if !f(i, self.get(i as int)) { return; }\n+        }\n+    }\n+\n     /// Remove and return the first element in the deque\n     ///\n     /// Fails if the deque is empty\n@@ -223,6 +235,7 @@ mod tests {\n         assert!(*deq.get(3) == d);\n     }\n \n+    #[test]\n     fn test_parameterized<T:Copy + Eq + Durable>(a: T, b: T, c: T, d: T) {\n         let mut deq = Deque::new();\n         assert!(deq.len() == 0);\n@@ -300,4 +313,23 @@ mod tests {\n         let reccy4 = RecCy { x: 19, y: 252, t: Two(17, 42) };\n         test_parameterized::<RecCy>(reccy1, reccy2, reccy3, reccy4);\n     }\n+\n+    #[test]\n+    fn test_eachi() {\n+        let mut deq = Deque::new();\n+        deq.add_back(1);\n+        deq.add_back(2);\n+        deq.add_back(3);\n+\n+        for deq.eachi |i, e| {\n+            assert_eq!(*e, i + 1);\n+        }\n+\n+        deq.pop_front();\n+\n+        for deq.eachi |i, e| {\n+            assert_eq!(*e, i + 2);\n+        }\n+\n+    }\n }"}, {"sha": "b117c8d9882ba301655a81cb4e0da4d2ef0791e1", "filename": "src/libstd/ebml.rs", "status": "modified", "additions": 35, "deletions": 69, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/6dd20c8186e1eb2819f50d09ddba6941b7ff85b8/src%2Flibstd%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dd20c8186e1eb2819f50d09ddba6941b7ff85b8/src%2Flibstd%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Febml.rs?ref=6dd20c8186e1eb2819f50d09ddba6941b7ff85b8", "patch": "@@ -311,23 +311,10 @@ pub mod reader {\n         fn read_f64(&self) -> f64 { fail!(~\"read_f64()\"); }\n         fn read_f32(&self) -> f32 { fail!(~\"read_f32()\"); }\n         fn read_float(&self) -> float { fail!(~\"read_float()\"); }\n-\n         fn read_char(&self) -> char { fail!(~\"read_char()\"); }\n-\n-        fn read_owned_str(&self) -> ~str { doc_as_str(self.next_doc(EsStr)) }\n-        fn read_managed_str(&self) -> @str { fail!(~\"read_managed_str()\"); }\n+        fn read_str(&self) -> ~str { doc_as_str(self.next_doc(EsStr)) }\n \n         // Compound types:\n-        fn read_owned<T>(&self, f: &fn() -> T) -> T {\n-            debug!(\"read_owned()\");\n-            f()\n-        }\n-\n-        fn read_managed<T>(&self, f: &fn() -> T) -> T {\n-            debug!(\"read_managed()\");\n-            f()\n-        }\n-\n         fn read_enum<T>(&self, name: &str, f: &fn() -> T) -> T {\n             debug!(\"read_enum(%s)\", name);\n             self._check_label(name);\n@@ -348,34 +335,20 @@ pub mod reader {\n             f()\n         }\n \n-        fn read_owned_vec<T>(&self, f: &fn(uint) -> T) -> T {\n-            debug!(\"read_owned_vec()\");\n+        fn read_seq<T>(&self, f: &fn(uint) -> T) -> T {\n+            debug!(\"read_seq()\");\n             do self.push_doc(self.next_doc(EsVec)) {\n                 let len = self._next_uint(EsVecLen);\n                 debug!(\"  len=%u\", len);\n                 f(len)\n             }\n         }\n \n-        fn read_managed_vec<T>(&self, f: &fn(uint) -> T) -> T {\n-            debug!(\"read_managed_vec()\");\n-            do self.push_doc(self.next_doc(EsVec)) {\n-                let len = self._next_uint(EsVecLen);\n-                debug!(\"  len=%u\", len);\n-                f(len)\n-            }\n-        }\n-\n-        fn read_vec_elt<T>(&self, idx: uint, f: &fn() -> T) -> T {\n-            debug!(\"read_vec_elt(idx=%u)\", idx);\n+        fn read_seq_elt<T>(&self, idx: uint, f: &fn() -> T) -> T {\n+            debug!(\"read_seq_elt(idx=%u)\", idx);\n             self.push_doc(self.next_doc(EsVecElt), f)\n         }\n \n-        fn read_rec<T>(&self, f: &fn() -> T) -> T {\n-            debug!(\"read_rec()\");\n-            f()\n-        }\n-\n         fn read_struct<T>(&self, name: &str, _len: uint, f: &fn() -> T) -> T {\n             debug!(\"read_struct(name=%s)\", name);\n             f()\n@@ -387,16 +360,6 @@ pub mod reader {\n             f()\n         }\n \n-        fn read_tup<T>(&self, len: uint, f: &fn() -> T) -> T {\n-            debug!(\"read_tup(len=%u)\", len);\n-            f()\n-        }\n-\n-        fn read_tup_elt<T>(&self, idx: uint, f: &fn() -> T) -> T {\n-            debug!(\"read_tup_elt(idx=%u)\", idx);\n-            f()\n-        }\n-\n         fn read_option<T>(&self, f: &fn(bool) -> T) -> T {\n             debug!(\"read_option()\");\n             do self.read_enum(\"Option\") || {\n@@ -409,6 +372,21 @@ pub mod reader {\n                 }\n             }\n         }\n+\n+        fn read_map<T>(&self, _f: &fn(uint) -> T) -> T {\n+            debug!(\"read_map()\");\n+            fail!(~\"read_map is unimplemented\");\n+        }\n+\n+        fn read_map_elt_key<T>(&self, idx: uint, _f: &fn() -> T) -> T {\n+            debug!(\"read_map_elt_key(idx=%u)\", idx);\n+            fail!(~\"read_map_elt_val is unimplemented\");\n+        }\n+\n+        fn read_map_elt_val<T>(&self, idx: uint, _f: &fn() -> T) -> T {\n+            debug!(\"read_map_elt_val(idx=%u)\", idx);\n+            fail!(~\"read_map_elt_val is unimplemented\");\n+        }\n     }\n }\n \n@@ -620,22 +598,10 @@ pub mod writer {\n             fail!(~\"Unimplemented: serializing a char\");\n         }\n \n-        fn emit_borrowed_str(&self, v: &str) {\n+        fn emit_str(&self, v: &str) {\n             self.wr_tagged_str(EsStr as uint, v)\n         }\n \n-        fn emit_owned_str(&self, v: &str) {\n-            self.emit_borrowed_str(v)\n-        }\n-\n-        fn emit_managed_str(&self, v: &str) {\n-            self.emit_borrowed_str(v)\n-        }\n-\n-        fn emit_borrowed(&self, f: &fn()) { f() }\n-        fn emit_owned(&self, f: &fn()) { f() }\n-        fn emit_managed(&self, f: &fn()) { f() }\n-\n         fn emit_enum(&self, name: &str, f: &fn()) {\n             self._emit_label(name);\n             self.wr_tag(EsEnum as uint, f)\n@@ -647,35 +613,23 @@ pub mod writer {\n         }\n         fn emit_enum_variant_arg(&self, _idx: uint, f: &fn()) { f() }\n \n-        fn emit_borrowed_vec(&self, len: uint, f: &fn()) {\n+        fn emit_seq(&self, len: uint, f: &fn()) {\n             do self.wr_tag(EsVec as uint) {\n                 self._emit_tagged_uint(EsVecLen, len);\n                 f()\n             }\n         }\n \n-        fn emit_owned_vec(&self, len: uint, f: &fn()) {\n-            self.emit_borrowed_vec(len, f)\n-        }\n-\n-        fn emit_managed_vec(&self, len: uint, f: &fn()) {\n-            self.emit_borrowed_vec(len, f)\n-        }\n-\n-        fn emit_vec_elt(&self, _idx: uint, f: &fn()) {\n+        fn emit_seq_elt(&self, _idx: uint, f: &fn()) {\n             self.wr_tag(EsVecElt as uint, f)\n         }\n \n-        fn emit_rec(&self, f: &fn()) { f() }\n         fn emit_struct(&self, _name: &str, _len: uint, f: &fn()) { f() }\n         fn emit_field(&self, name: &str, _idx: uint, f: &fn()) {\n             self._emit_label(name);\n             f()\n         }\n \n-        fn emit_tup(&self, _len: uint, f: &fn()) { f() }\n-        fn emit_tup_elt(&self, _idx: uint, f: &fn()) { f() }\n-\n         fn emit_option(&self, f: &fn()) {\n             self.emit_enum(\"Option\", f);\n         }\n@@ -685,6 +639,18 @@ pub mod writer {\n         fn emit_option_some(&self, f: &fn()) {\n             self.emit_enum_variant(\"Some\", 1, 1, f)\n         }\n+\n+        fn emit_map(&self, _len: uint, _f: &fn()) {\n+            fail!(~\"emit_map is unimplemented\");\n+        }\n+\n+        fn emit_map_elt_key(&self, _idx: uint, _f: &fn()) {\n+            fail!(~\"emit_map_elt_key is unimplemented\");\n+        }\n+\n+        fn emit_map_elt_val(&self, _idx: uint, _f: &fn()) {\n+            fail!(~\"emit_map_elt_val is unimplemented\");\n+        }\n     }\n }\n "}, {"sha": "56c67156d3d9be3a76ffc25e340357fd6040f94a", "filename": "src/libstd/flatpipes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6dd20c8186e1eb2819f50d09ddba6941b7ff85b8/src%2Flibstd%2Fflatpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dd20c8186e1eb2819f50d09ddba6941b7ff85b8/src%2Flibstd%2Fflatpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fflatpipes.rs?ref=6dd20c8186e1eb2819f50d09ddba6941b7ff85b8", "patch": "@@ -466,8 +466,8 @@ pub mod flatteners {\n         fn from_writer(w: @Writer) -> Self;\n     }\n \n-    impl<'self> FromReader for json::Decoder<'self> {\n-        fn from_reader(r: @Reader) -> json::Decoder<'self> {\n+    impl FromReader for json::Decoder {\n+        fn from_reader(r: @Reader) -> json::Decoder {\n             match json::from_reader(r) {\n                 Ok(json) => {\n                     json::Decoder(json)"}, {"sha": "e090d6bc036d8444fceed65435ad4eb6081671f6", "filename": "src/libstd/json.rs", "status": "modified", "additions": 354, "deletions": 313, "changes": 667, "blob_url": "https://github.com/rust-lang/rust/blob/6dd20c8186e1eb2819f50d09ddba6941b7ff85b8/src%2Flibstd%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dd20c8186e1eb2819f50d09ddba6941b7ff85b8/src%2Flibstd%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fjson.rs?ref=6dd20c8186e1eb2819f50d09ddba6941b7ff85b8", "patch": "@@ -105,20 +105,10 @@ impl serialize::Encoder for Encoder {\n         self.wr.write_str(float::to_str_digits(v, 6u));\n     }\n \n-    fn emit_char(&self, v: char) { self.emit_borrowed_str(str::from_char(v)) }\n-\n-    fn emit_borrowed_str(&self, v: &str) { self.wr.write_str(escape_str(v)) }\n-    fn emit_owned_str(&self, v: &str) { self.emit_borrowed_str(v) }\n-    fn emit_managed_str(&self, v: &str) { self.emit_borrowed_str(v) }\n-\n-    fn emit_borrowed(&self, f: &fn()) { f() }\n-    fn emit_owned(&self, f: &fn()) { f() }\n-    fn emit_managed(&self, f: &fn()) { f() }\n-\n-    fn emit_enum(&self, _name: &str, f: &fn()) {\n-        f()\n-    }\n+    fn emit_char(&self, v: char) { self.emit_str(str::from_char(v)) }\n+    fn emit_str(&self, v: &str) { self.wr.write_str(escape_str(v)) }\n \n+    fn emit_enum(&self, _name: &str, f: &fn()) { f() }\n     fn emit_enum_variant(&self, name: &str, _id: uint, cnt: uint, f: &fn()) {\n         // enums are encoded as strings or vectors:\n         // Bunny => \"Bunny\"\n@@ -140,28 +130,17 @@ impl serialize::Encoder for Encoder {\n         f();\n     }\n \n-    fn emit_borrowed_vec(&self, _len: uint, f: &fn()) {\n+    fn emit_seq(&self, _len: uint, f: &fn()) {\n         self.wr.write_char('[');\n         f();\n         self.wr.write_char(']');\n     }\n \n-    fn emit_owned_vec(&self, len: uint, f: &fn()) {\n-        self.emit_borrowed_vec(len, f)\n-    }\n-    fn emit_managed_vec(&self, len: uint, f: &fn()) {\n-        self.emit_borrowed_vec(len, f)\n-    }\n-    fn emit_vec_elt(&self, idx: uint, f: &fn()) {\n+    fn emit_seq_elt(&self, idx: uint, f: &fn()) {\n         if idx != 0 { self.wr.write_char(','); }\n         f()\n     }\n \n-    fn emit_rec(&self, f: &fn()) {\n-        self.wr.write_char('{');\n-        f();\n-        self.wr.write_char('}');\n-    }\n     fn emit_struct(&self, _name: &str, _len: uint, f: &fn()) {\n         self.wr.write_char('{');\n         f();\n@@ -174,16 +153,25 @@ impl serialize::Encoder for Encoder {\n         f();\n     }\n \n-    fn emit_tup(&self, len: uint, f: &fn()) {\n-        self.emit_borrowed_vec(len, f);\n-    }\n-    fn emit_tup_elt(&self, idx: uint, f: &fn()) {\n-        self.emit_vec_elt(idx, f)\n-    }\n-\n     fn emit_option(&self, f: &fn()) { f(); }\n     fn emit_option_none(&self) { self.emit_nil(); }\n     fn emit_option_some(&self, f: &fn()) { f(); }\n+\n+    fn emit_map(&self, _len: uint, f: &fn()) {\n+        self.wr.write_char('{');\n+        f();\n+        self.wr.write_char('}');\n+    }\n+\n+    fn emit_map_elt_key(&self, idx: uint, f: &fn()) {\n+        if idx != 0 { self.wr.write_char(','); }\n+        f()\n+    }\n+\n+    fn emit_map_elt_val(&self, _idx: uint, f: &fn()) {\n+        self.wr.write_char(':');\n+        f()\n+    }\n }\n \n pub struct PrettyEncoder {\n@@ -224,15 +212,8 @@ impl serialize::Encoder for PrettyEncoder {\n         self.wr.write_str(float::to_str_digits(v, 6u));\n     }\n \n-    fn emit_char(&self, v: char) { self.emit_borrowed_str(str::from_char(v)) }\n-\n-    fn emit_borrowed_str(&self, v: &str) { self.wr.write_str(escape_str(v)); }\n-    fn emit_owned_str(&self, v: &str) { self.emit_borrowed_str(v) }\n-    fn emit_managed_str(&self, v: &str) { self.emit_borrowed_str(v) }\n-\n-    fn emit_borrowed(&self, f: &fn()) { f() }\n-    fn emit_owned(&self, f: &fn()) { f() }\n-    fn emit_managed(&self, f: &fn()) { f() }\n+    fn emit_char(&self, v: char) { self.emit_str(str::from_char(v)) }\n+    fn emit_str(&self, v: &str) { self.wr.write_str(escape_str(v)); }\n \n     fn emit_enum(&self, _name: &str, f: &fn()) { f() }\n     fn emit_enum_variant(&self, name: &str, _id: uint, cnt: uint, f: &fn()) {\n@@ -260,7 +241,7 @@ impl serialize::Encoder for PrettyEncoder {\n         f()\n     }\n \n-    fn emit_borrowed_vec(&self, len: uint, f: &fn()) {\n+    fn emit_seq(&self, len: uint, f: &fn()) {\n         if len == 0 {\n             self.wr.write_str(\"[]\");\n         } else {\n@@ -273,13 +254,7 @@ impl serialize::Encoder for PrettyEncoder {\n             self.wr.write_char(']');\n         }\n     }\n-    fn emit_owned_vec(&self, len: uint, f: &fn()) {\n-        self.emit_borrowed_vec(len, f)\n-    }\n-    fn emit_managed_vec(&self, len: uint, f: &fn()) {\n-        self.emit_borrowed_vec(len, f)\n-    }\n-    fn emit_vec_elt(&self, idx: uint, f: &fn()) {\n+    fn emit_seq_elt(&self, idx: uint, f: &fn()) {\n         if idx == 0 {\n             self.wr.write_char('\\n');\n         } else {\n@@ -289,20 +264,17 @@ impl serialize::Encoder for PrettyEncoder {\n         f()\n     }\n \n-    fn emit_rec(&self, f: &fn()) {\n-        self.wr.write_char('{');\n-        self.indent += 2;\n-        f();\n-        self.wr.write_char('\\n');\n-        self.indent -= 2;\n-        self.wr.write_str(spaces(self.indent));\n-        self.wr.write_char('}');\n-    }\n     fn emit_struct(&self, _name: &str, len: uint, f: &fn()) {\n         if len == 0 {\n             self.wr.write_str(\"{}\");\n         } else {\n-            self.emit_rec(f)\n+            self.wr.write_char('{');\n+            self.indent += 2;\n+            f();\n+            self.wr.write_char('\\n');\n+            self.indent -= 2;\n+            self.wr.write_str(spaces(self.indent));\n+            self.wr.write_char('}');\n         }\n     }\n     fn emit_field(&self, name: &str, idx: uint, f: &fn()) {\n@@ -316,37 +288,49 @@ impl serialize::Encoder for PrettyEncoder {\n         self.wr.write_str(\": \");\n         f();\n     }\n-    fn emit_tup(&self, sz: uint, f: &fn()) {\n-        self.emit_borrowed_vec(sz, f);\n-    }\n-    fn emit_tup_elt(&self, idx: uint, f: &fn()) {\n-        self.emit_vec_elt(idx, f)\n-    }\n \n     fn emit_option(&self, f: &fn()) { f(); }\n     fn emit_option_none(&self) { self.emit_nil(); }\n     fn emit_option_some(&self, f: &fn()) { f(); }\n+\n+    fn emit_map(&self, len: uint, f: &fn()) {\n+        if len == 0 {\n+            self.wr.write_str(\"{}\");\n+        } else {\n+            self.wr.write_char('{');\n+            self.indent += 2;\n+            f();\n+            self.wr.write_char('\\n');\n+            self.indent -= 2;\n+            self.wr.write_str(spaces(self.indent));\n+            self.wr.write_char('}');\n+        }\n+    }\n+    fn emit_map_elt_key(&self, idx: uint, f: &fn()) {\n+        if idx == 0 {\n+            self.wr.write_char('\\n');\n+        } else {\n+            self.wr.write_str(\",\\n\");\n+        }\n+        self.wr.write_str(spaces(self.indent));\n+        f();\n+    }\n+\n+    fn emit_map_elt_val(&self, _idx: uint, f: &fn()) {\n+        self.wr.write_str(\": \");\n+        f();\n+    }\n }\n \n-impl<S:serialize::Encoder> serialize::Encodable<S> for Json {\n-    fn encode(&self, s: &S) {\n+impl<E: serialize::Encoder> serialize::Encodable<E> for Json {\n+    fn encode(&self, e: &E) {\n         match *self {\n-            Number(v) => v.encode(s),\n-            String(ref v) => v.encode(s),\n-            Boolean(v) => v.encode(s),\n-            List(ref v) => v.encode(s),\n-            Object(ref v) => {\n-                do s.emit_rec || {\n-                    let mut idx = 0;\n-                    for v.each |&(key, value)| {\n-                        do s.emit_field(*key, idx) {\n-                            value.encode(s);\n-                        }\n-                        idx += 1;\n-                    }\n-                }\n-            },\n-            Null => s.emit_nil(),\n+            Number(v) => v.encode(e),\n+            String(ref v) => v.encode(e),\n+            Boolean(v) => v.encode(e),\n+            List(ref v) => v.encode(e),\n+            Object(ref v) => v.encode(e),\n+            Null => e.emit_nil(),\n         }\n     }\n }\n@@ -752,37 +736,20 @@ pub fn from_str(s: &str) -> Result<Json, Error> {\n     }\n }\n \n-pub struct Decoder<'self> {\n-    priv json: Json,\n-    priv mut stack: ~[&'self Json],\n+pub struct Decoder {\n+    priv mut stack: ~[Json],\n }\n \n pub fn Decoder(json: Json) -> Decoder {\n-    Decoder { json: json, stack: ~[] }\n-}\n-\n-priv impl<'self> Decoder<'self> {\n-    fn peek(&self) -> &'self Json {\n-        if vec::uniq_len(&const self.stack) == 0 {\n-            self.stack.push(&self.json);\n-        }\n-        self.stack[vec::uniq_len(&const self.stack) - 1]\n-    }\n-\n-    fn pop(&self) -> &'self Json {\n-        if vec::uniq_len(&const self.stack) == 0 {\n-            self.stack.push(&self.json);\n-        }\n-        self.stack.pop()\n-    }\n+    Decoder { stack: ~[json] }\n }\n \n-impl<'self> serialize::Decoder for Decoder<'self> {\n+impl serialize::Decoder for Decoder {\n     fn read_nil(&self) -> () {\n         debug!(\"read_nil\");\n-        match *self.pop() {\n+        match self.stack.pop() {\n             Null => (),\n-            _ => fail!(~\"not a null\")\n+            value => fail!(fmt!(\"not a null: %?\", value))\n         }\n     }\n \n@@ -800,68 +767,58 @@ impl<'self> serialize::Decoder for Decoder<'self> {\n \n     fn read_bool(&self) -> bool {\n         debug!(\"read_bool\");\n-        match *self.pop() {\n+        match self.stack.pop() {\n             Boolean(b) => b,\n-            _ => fail!(~\"not a boolean\")\n+            value => fail!(fmt!(\"not a boolean: %?\", value))\n         }\n     }\n \n     fn read_f64(&self) -> f64 { self.read_float() as f64 }\n     fn read_f32(&self) -> f32 { self.read_float() as f32 }\n     fn read_float(&self) -> float {\n         debug!(\"read_float\");\n-        match *self.pop() {\n+        match self.stack.pop() {\n             Number(f) => f,\n-            _ => fail!(~\"not a number\")\n+            value => fail!(fmt!(\"not a number: %?\", value))\n         }\n     }\n \n     fn read_char(&self) -> char {\n         let mut v = ~[];\n-        for str::each_char(self.read_owned_str()) |c| { v.push(c) }\n+        for str::each_char(self.read_str()) |c| { v.push(c) }\n         if v.len() != 1 { fail!(~\"string must have one character\") }\n         v[0]\n     }\n \n-    fn read_owned_str(&self) -> ~str {\n-        debug!(\"read_owned_str\");\n-        match *self.pop() {\n-            String(ref s) => copy *s,\n-            ref json => fail!(fmt!(\"not a string: %?\", *json))\n+    fn read_str(&self) -> ~str {\n+        debug!(\"read_str\");\n+        match self.stack.pop() {\n+            String(s) => s,\n+            json => fail!(fmt!(\"not a string: %?\", json))\n         }\n     }\n \n-    fn read_managed_str(&self) -> @str {\n-        debug!(\"read_managed_str\");\n-        match *self.pop() {\n-            String(ref s) => s.to_managed(),\n-            ref json => fail!(fmt!(\"not a string: %?\", *json))\n-        }\n-    }\n-\n-    fn read_owned<T>(&self, f: &fn() -> T) -> T {\n-        debug!(\"read_owned()\");\n-        f()\n-    }\n-\n-    fn read_managed<T>(&self, f: &fn() -> T) -> T {\n-        debug!(\"read_managed()\");\n-        f()\n-    }\n-\n     fn read_enum<T>(&self, name: &str, f: &fn() -> T) -> T {\n         debug!(\"read_enum(%s)\", name);\n         f()\n     }\n \n     fn read_enum_variant<T>(&self, names: &[&str], f: &fn(uint) -> T) -> T {\n         debug!(\"read_enum_variant(names=%?)\", names);\n-        let name = match *self.peek() {\n-            String(ref s) => s,\n-            List([String(ref s), .. _]) => s,\n+        let name = match self.stack.pop() {\n+            String(s) => s,\n+            List(list) => {\n+                do vec::consume_reverse(list) |_i, v| {\n+                    self.stack.push(v);\n+                }\n+                match self.stack.pop() {\n+                    String(s) => s,\n+                    value => fail!(fmt!(\"invalid variant name: %?\", value)),\n+                }\n+            }\n             ref json => fail!(fmt!(\"invalid variant: %?\", *json)),\n         };\n-        let idx = match vec::position(names, |n| str::eq_slice(*n, *name)) {\n+        let idx = match vec::position(names, |n| str::eq_slice(*n, name)) {\n             Some(idx) => idx,\n             None => fail!(fmt!(\"Unknown variant name: %?\", name)),\n         };\n@@ -870,108 +827,87 @@ impl<'self> serialize::Decoder for Decoder<'self> {\n \n     fn read_enum_variant_arg<T>(&self, idx: uint, f: &fn() -> T) -> T {\n         debug!(\"read_enum_variant_arg(idx=%u)\", idx);\n-        match *self.peek() {\n-            List(ref list) => {\n-                self.stack.push(&list[idx + 1]);\n-                f()\n-            }\n-            ref json => fail!(fmt!(\"not a list: %?\", json)),\n-        }\n-    }\n-\n-    fn read_owned_vec<T>(&self, f: &fn(uint) -> T) -> T {\n-        debug!(\"read_owned_vec()\");\n-        let len = match *self.peek() {\n-            List(ref list) => list.len(),\n-            _ => fail!(~\"not a list\"),\n-        };\n-        let res = f(len);\n-        self.pop();\n-        res\n-    }\n-\n-    fn read_managed_vec<T>(&self, f: &fn(uint) -> T) -> T {\n-        debug!(\"read_owned_vec()\");\n-        let len = match *self.peek() {\n-            List(ref list) => list.len(),\n-            _ => fail!(~\"not a list\"),\n-        };\n-        let res = f(len);\n-        self.pop();\n-        res\n+        f()\n     }\n \n-    fn read_vec_elt<T>(&self, idx: uint, f: &fn() -> T) -> T {\n-        debug!(\"read_vec_elt(idx=%u)\", idx);\n-        match *self.peek() {\n-            List(ref list) => {\n-                self.stack.push(&list[idx]);\n-                f()\n+    fn read_seq<T>(&self, f: &fn(uint) -> T) -> T {\n+        debug!(\"read_seq()\");\n+        let len = match self.stack.pop() {\n+            List(list) => {\n+                let len = list.len();\n+                do vec::consume_reverse(list) |_i, v| {\n+                    self.stack.push(v);\n+                }\n+                len\n             }\n             _ => fail!(~\"not a list\"),\n-        }\n+        };\n+        f(len)\n     }\n \n-    fn read_rec<T>(&self, f: &fn() -> T) -> T {\n-        debug!(\"read_rec()\");\n-        let value = f();\n-        self.pop();\n-        value\n+    fn read_seq_elt<T>(&self, idx: uint, f: &fn() -> T) -> T {\n+        debug!(\"read_seq_elt(idx=%u)\", idx);\n+        f()\n     }\n \n-    fn read_struct<T>(&self, _name: &str, _len: uint, f: &fn() -> T) -> T {\n-        debug!(\"read_struct()\");\n+    fn read_struct<T>(&self, name: &str, len: uint, f: &fn() -> T) -> T {\n+        debug!(\"read_struct(name=%s, len=%u)\", name, len);\n         let value = f();\n-        self.pop();\n+        self.stack.pop();\n         value\n     }\n \n     fn read_field<T>(&self, name: &str, idx: uint, f: &fn() -> T) -> T {\n-        debug!(\"read_rec_field(%s, idx=%u)\", name, idx);\n-        let top = self.peek();\n-        match *top {\n-            Object(ref obj) => {\n-                match obj.find(&name.to_owned()) {\n+        debug!(\"read_field(%s, idx=%u)\", name, idx);\n+        match self.stack.pop() {\n+            Object(obj) => {\n+                let mut obj = obj;\n+                let value = match obj.pop(&name.to_owned()) {\n                     None => fail!(fmt!(\"no such field: %s\", name)),\n                     Some(json) => {\n                         self.stack.push(json);\n                         f()\n                     }\n-                }\n+                };\n+                self.stack.push(Object(obj));\n+                value\n             }\n-            Number(_) => fail!(~\"num\"),\n-            String(_) => fail!(~\"str\"),\n-            Boolean(_) => fail!(~\"bool\"),\n-            List(_) => fail!(fmt!(\"list: %?\", top)),\n-            Null => fail!(~\"null\"),\n-\n-            //_ => fail!(fmt!(\"not an object: %?\", *top))\n+            value => fail!(fmt!(\"not an object: %?\", value))\n         }\n     }\n \n-    fn read_tup<T>(&self, len: uint, f: &fn() -> T) -> T {\n-        debug!(\"read_tup(len=%u)\", len);\n-        let value = f();\n-        self.pop();\n-        value\n+    fn read_option<T>(&self, f: &fn(bool) -> T) -> T {\n+        match self.stack.pop() {\n+            Null => f(false),\n+            value => { self.stack.push(value); f(true) }\n+        }\n     }\n \n-    fn read_tup_elt<T>(&self, idx: uint, f: &fn() -> T) -> T {\n-        debug!(\"read_tup_elt(idx=%u)\", idx);\n-        match *self.peek() {\n-            List(ref list) => {\n-                self.stack.push(&list[idx]);\n-                f()\n+    fn read_map<T>(&self, f: &fn(uint) -> T) -> T {\n+        debug!(\"read_map()\");\n+        let len = match self.stack.pop() {\n+            Object(obj) => {\n+                let mut obj = obj;\n+                let len = obj.len();\n+                do obj.consume |key, value| {\n+                    self.stack.push(value);\n+                    self.stack.push(String(key));\n+                }\n+                len\n             }\n-            _ => fail!(~\"not a list\")\n-        }\n+            json => fail!(fmt!(\"not an object: %?\", json)),\n+        };\n+        f(len)\n     }\n \n-    fn read_option<T>(&self, f: &fn(bool) -> T) -> T {\n-        match *self.peek() {\n-            Null => { self.pop(); f(false) }\n-            _ => f(true),\n-        }\n+    fn read_map_elt_key<T>(&self, idx: uint, f: &fn() -> T) -> T {\n+        debug!(\"read_map_elt_key(idx=%u)\", idx);\n+        f()\n+    }\n+\n+    fn read_map_elt_val<T>(&self, idx: uint, f: &fn() -> T) -> T {\n+        debug!(\"read_map_elt_val(idx=%u)\", idx);\n+        f()\n     }\n }\n \n@@ -1229,6 +1165,30 @@ mod tests {\n \n     use std::serialize::Decodable;\n \n+    #[auto_encode]\n+    #[auto_decode]\n+    #[deriving(Eq)]\n+    enum Animal {\n+        Dog,\n+        Frog(~str, int)\n+    }\n+\n+    #[auto_encode]\n+    #[auto_decode]\n+    #[deriving(Eq)]\n+    struct Inner {\n+        a: (),\n+        b: uint,\n+        c: ~[~str],\n+    }\n+\n+    #[auto_encode]\n+    #[auto_decode]\n+    #[deriving(Eq)]\n+    struct Outer {\n+        inner: ~[Inner],\n+    }\n+\n     fn mk_object(items: &[(~str, Json)]) -> Json {\n         let mut d = ~LinearMap::new();\n \n@@ -1244,49 +1204,62 @@ mod tests {\n     #[test]\n     fn test_write_null() {\n         assert_eq!(to_str(&Null), ~\"null\");\n+        assert_eq!(to_pretty_str(&Null), ~\"null\");\n     }\n \n+\n     #[test]\n     fn test_write_number() {\n         assert_eq!(to_str(&Number(3f)), ~\"3\");\n+        assert_eq!(to_pretty_str(&Number(3f)), ~\"3\");\n+\n         assert_eq!(to_str(&Number(3.1f)), ~\"3.1\");\n+        assert_eq!(to_pretty_str(&Number(3.1f)), ~\"3.1\");\n+\n         assert_eq!(to_str(&Number(-1.5f)), ~\"-1.5\");\n+        assert_eq!(to_pretty_str(&Number(-1.5f)), ~\"-1.5\");\n+\n         assert_eq!(to_str(&Number(0.5f)), ~\"0.5\");\n+        assert_eq!(to_pretty_str(&Number(0.5f)), ~\"0.5\");\n     }\n \n     #[test]\n     fn test_write_str() {\n         assert_eq!(to_str(&String(~\"\")), ~\"\\\"\\\"\");\n+        assert_eq!(to_pretty_str(&String(~\"\")), ~\"\\\"\\\"\");\n+\n         assert_eq!(to_str(&String(~\"foo\")), ~\"\\\"foo\\\"\");\n+        assert_eq!(to_pretty_str(&String(~\"foo\")), ~\"\\\"foo\\\"\");\n     }\n \n     #[test]\n     fn test_write_bool() {\n         assert_eq!(to_str(&Boolean(true)), ~\"true\");\n+        assert_eq!(to_pretty_str(&Boolean(true)), ~\"true\");\n+\n         assert_eq!(to_str(&Boolean(false)), ~\"false\");\n+        assert_eq!(to_pretty_str(&Boolean(false)), ~\"false\");\n     }\n \n     #[test]\n     fn test_write_list() {\n         assert_eq!(to_str(&List(~[])), ~\"[]\");\n-        assert_eq!(to_str(&List(~[Boolean(true)])), ~\"[true]\");\n-        assert_eq!(to_str(&List(~[\n-            Boolean(false),\n-            Null,\n-            List(~[String(~\"foo\\nbar\"), Number(3.5f)])\n-        ])), ~\"[false,null,[\\\"foo\\\\nbar\\\",3.5]]\");\n-    }\n-\n-    #[test]\n-    fn test_write_list_pretty() {\n         assert_eq!(to_pretty_str(&List(~[])), ~\"[]\");\n+\n+        assert_eq!(to_str(&List(~[Boolean(true)])), ~\"[true]\");\n         assert_eq!(\n             to_pretty_str(&List(~[Boolean(true)])),\n             ~\"\\\n             [\\n  \\\n                 true\\n\\\n             ]\"\n         );\n+\n+        assert_eq!(to_str(&List(~[\n+            Boolean(false),\n+            Null,\n+            List(~[String(~\"foo\\nbar\"), Number(3.5f)])\n+        ])), ~\"[false,null,[\\\"foo\\\\nbar\\\",3.5]]\");\n         assert_eq!(\n             to_pretty_str(&List(~[\n                 Boolean(false),\n@@ -1308,10 +1281,20 @@ mod tests {\n     #[test]\n     fn test_write_object() {\n         assert_eq!(to_str(&mk_object(~[])), ~\"{}\");\n+        assert_eq!(to_pretty_str(&mk_object(~[])), ~\"{}\");\n+\n         assert_eq!(\n             to_str(&mk_object(~[(~\"a\", Boolean(true))])),\n             ~\"{\\\"a\\\":true}\"\n         );\n+        assert_eq!(\n+            to_pretty_str(&mk_object(~[(~\"a\", Boolean(true))])),\n+            ~\"\\\n+            {\\n  \\\n+                \\\"a\\\": true\\n\\\n+            }\"\n+        );\n+\n         assert_eq!(\n             to_str(&mk_object(~[\n                 (~\"b\", List(~[\n@@ -1326,29 +1309,6 @@ mod tests {\n                 ]\\\n             }\"\n         );\n-        let a = mk_object(~[\n-            (~\"a\", Boolean(true)),\n-            (~\"b\", List(~[\n-                mk_object(~[(~\"c\", String(~\"\\x0c\\r\"))]),\n-                mk_object(~[(~\"d\", String(~\"\"))])\n-            ]))\n-        ]);\n-        // We can't compare the strings directly because the object fields be\n-        // printed in a different order.\n-        let b = from_str(to_str(&a)).unwrap();\n-        assert_eq!(a, b);\n-    }\n-\n-    #[test]\n-    fn test_write_object_pretty() {\n-        assert_eq!(to_pretty_str(&mk_object(~[])), ~\"{\\n}\");\n-        assert_eq!(\n-            to_pretty_str(&mk_object(~[(~\"a\", Boolean(true))])),\n-            ~\"\\\n-            {\\n  \\\n-                \\\"a\\\": true\\n\\\n-            }\"\n-        );\n         assert_eq!(\n             to_pretty_str(&mk_object(~[\n                 (~\"b\", List(~[\n@@ -1368,70 +1328,52 @@ mod tests {\n                 ]\\n\\\n             }\"\n         );\n+\n         let a = mk_object(~[\n             (~\"a\", Boolean(true)),\n             (~\"b\", List(~[\n                 mk_object(~[(~\"c\", String(~\"\\x0c\\r\"))]),\n                 mk_object(~[(~\"d\", String(~\"\"))])\n             ]))\n         ]);\n+\n         // We can't compare the strings directly because the object fields be\n         // printed in a different order.\n-        let b = from_str(to_str(&a)).unwrap();\n-        assert_eq!(a, b);\n-    }\n-\n-    #[auto_encode]\n-    #[auto_decode]\n-    #[deriving(Eq)]\n-    enum Animal {\n-        Dog,\n-        Frog(~str, int)\n+        assert_eq!(copy a, from_str(to_str(&a)).unwrap());\n+        assert_eq!(copy a, from_str(to_pretty_str(&a)).unwrap());\n     }\n \n     #[test]\n-    fn test_write_enum_no_args() {\n+    fn test_write_enum() {\n         let animal = Dog;\n+        assert_eq!(\n+            do io::with_str_writer |wr| {\n+                let encoder = Encoder(wr);\n+                animal.encode(&encoder);\n+            },\n+            ~\"\\\"Dog\\\"\"\n+        );\n+        assert_eq!(\n+            do io::with_str_writer |wr| {\n+                let encoder = PrettyEncoder(wr);\n+                animal.encode(&encoder);\n+            },\n+            ~\"\\\"Dog\\\"\"\n+        );\n \n-        let s = do io::with_str_writer |wr| {\n-            let encoder = Encoder(wr);\n-            animal.encode(&encoder);\n-        };\n-        assert_eq!(s, ~\"\\\"Dog\\\"\");\n-    }\n-\n-    #[test]\n-    fn test_write_enum_no_args_pretty() {\n-        let animal = Dog;\n-\n-        let s = do io::with_str_writer |wr| {\n-            let encoder = PrettyEncoder(wr);\n-            animal.encode(&encoder);\n-        };\n-        assert_eq!(s, ~\"\\\"Dog\\\"\");\n-    }\n-\n-    #[test]\n-    fn test_write_enum_multiple_args() {\n-        let animal = Frog(~\"Henry\", 349);\n-\n-        let s = do io::with_str_writer |wr| {\n-            let encoder = Encoder(wr);\n-            animal.encode(&encoder);\n-        };\n-        assert_eq!(s, ~\"[\\\"Frog\\\",\\\"Henry\\\",349]\");\n-    }\n-\n-    #[test]\n-    fn test_write_enum_multiple_args_pretty() {\n         let animal = Frog(~\"Henry\", 349);\n-\n-        let s = do io::with_str_writer |wr| {\n-            let encoder = PrettyEncoder(wr);\n-            animal.encode(&encoder);\n-        };\n         assert_eq!(\n-            s,\n+            do io::with_str_writer |wr| {\n+                let encoder = Encoder(wr);\n+                animal.encode(&encoder);\n+            },\n+            ~\"[\\\"Frog\\\",\\\"Henry\\\",349]\"\n+        );\n+        assert_eq!(\n+            do io::with_str_writer |wr| {\n+                let encoder = PrettyEncoder(wr);\n+                animal.encode(&encoder);\n+            },\n             ~\"\\\n             [\\n  \\\n                 \\\"Frog\\\",\\n  \\\n@@ -1449,10 +1391,7 @@ mod tests {\n             value.encode(&encoder);\n         };\n         assert_eq!(s, ~\"\\\"jodhpurs\\\"\");\n-    }\n \n-    #[test]\n-    fn test_write_some_pretty() {\n         let value = Some(~\"jodhpurs\");\n         let s = do io::with_str_writer |wr| {\n             let encoder = PrettyEncoder(wr);\n@@ -1469,11 +1408,7 @@ mod tests {\n             value.encode(&encoder);\n         };\n         assert_eq!(s, ~\"null\");\n-    }\n \n-    #[test]\n-    fn test_write_none_pretty() {\n-        let value: Option<~str> = None;\n         let s = do io::with_str_writer |wr| {\n             let encoder = Encoder(wr);\n             value.encode(&encoder);\n@@ -1522,6 +1457,18 @@ mod tests {\n         assert_eq!(from_str(~\" false \"), Ok(Boolean(false)));\n     }\n \n+    #[test]\n+    fn test_decode_identifiers() {\n+        let v: () = Decodable::decode(&Decoder(from_str(~\"null\").unwrap()));\n+        assert_eq!(v, ());\n+\n+        let v: bool = Decodable::decode(&Decoder(from_str(~\"true\").unwrap()));\n+        assert_eq!(v, true);\n+\n+        let v: bool = Decodable::decode(&Decoder(from_str(~\"false\").unwrap()));\n+        assert_eq!(v, false);\n+    }\n+\n     #[test]\n     fn test_read_number() {\n         assert_eq!(from_str(~\"+\"),\n@@ -1550,6 +1497,30 @@ mod tests {\n         assert_eq!(from_str(~\" 3 \"), Ok(Number(3f)));\n     }\n \n+    #[test]\n+    fn test_decode_numbers() {\n+        let v: float = Decodable::decode(&Decoder(from_str(~\"3\").unwrap()));\n+        assert_eq!(v, 3f);\n+\n+        let v: float = Decodable::decode(&Decoder(from_str(~\"3.1\").unwrap()));\n+        assert_eq!(v, 3.1f);\n+\n+        let v: float = Decodable::decode(&Decoder(from_str(~\"-1.2\").unwrap()));\n+        assert_eq!(v, -1.2f);\n+\n+        let v: float = Decodable::decode(&Decoder(from_str(~\"0.4\").unwrap()));\n+        assert_eq!(v, 0.4f);\n+\n+        let v: float = Decodable::decode(&Decoder(from_str(~\"0.4e5\").unwrap()));\n+        assert_eq!(v, 0.4e5f);\n+\n+        let v: float = Decodable::decode(&Decoder(from_str(~\"0.4e15\").unwrap()));\n+        assert_eq!(v, 0.4e15f);\n+\n+        let v: float = Decodable::decode(&Decoder(from_str(~\"0.4e-01\").unwrap()));\n+        assert_eq!(v, 0.4e-01f);\n+    }\n+\n     #[test]\n     fn test_read_str() {\n         assert_eq!(from_str(~\"\\\"\"),\n@@ -1567,12 +1538,38 @@ mod tests {\n         assert_eq!(from_str(~\"\\\"\\\\r\\\"\"), Ok(String(~\"\\r\")));\n         assert_eq!(from_str(~\"\\\"\\\\t\\\"\"), Ok(String(~\"\\t\")));\n         assert_eq!(from_str(~\" \\\"foo\\\" \"), Ok(String(~\"foo\")));\n+        assert_eq!(from_str(~\"\\\"\\\\u12ab\\\"\"), Ok(String(~\"\\u12ab\")));\n+        assert_eq!(from_str(~\"\\\"\\\\uAB12\\\"\"), Ok(String(~\"\\uAB12\")));\n     }\n \n     #[test]\n-    fn test_unicode_hex_escapes_in_str() {\n-        assert_eq!(from_str(~\"\\\"\\\\u12ab\\\"\"), Ok(String(~\"\\u12ab\")));\n-        assert_eq!(from_str(~\"\\\"\\\\uAB12\\\"\"), Ok(String(~\"\\uAB12\")));\n+    fn test_decode_str() {\n+        let v: ~str = Decodable::decode(&Decoder(from_str(~\"\\\"\\\"\").unwrap()));\n+        assert_eq!(v, ~\"\");\n+\n+        let v: ~str = Decodable::decode(&Decoder(from_str(~\"\\\"foo\\\"\").unwrap()));\n+        assert_eq!(v, ~\"foo\");\n+\n+        let v: ~str = Decodable::decode(&Decoder(from_str(~\"\\\"\\\\\\\"\\\"\").unwrap()));\n+        assert_eq!(v, ~\"\\\"\");\n+\n+        let v: ~str = Decodable::decode(&Decoder(from_str(~\"\\\"\\\\b\\\"\").unwrap()));\n+        assert_eq!(v, ~\"\\x08\");\n+\n+        let v: ~str = Decodable::decode(&Decoder(from_str(~\"\\\"\\\\n\\\"\").unwrap()));\n+        assert_eq!(v, ~\"\\n\");\n+\n+        let v: ~str = Decodable::decode(&Decoder(from_str(~\"\\\"\\\\r\\\"\").unwrap()));\n+        assert_eq!(v, ~\"\\r\");\n+\n+        let v: ~str = Decodable::decode(&Decoder(from_str(~\"\\\"\\\\t\\\"\").unwrap()));\n+        assert_eq!(v, ~\"\\t\");\n+\n+        let v: ~str = Decodable::decode(&Decoder(from_str(~\"\\\"\\\\u12ab\\\"\").unwrap()));\n+        assert_eq!(v, ~\"\\u12ab\");\n+\n+        let v: ~str = Decodable::decode(&Decoder(from_str(~\"\\\"\\\\uAB12\\\"\").unwrap()));\n+        assert_eq!(v, ~\"\\uAB12\");\n     }\n \n     #[test]\n@@ -1601,6 +1598,28 @@ mod tests {\n                Ok(List(~[Number(2f), List(~[Number(4f), Number(1f)])])));\n     }\n \n+    #[test]\n+    fn test_decode_list() {\n+        let v: ~[()] = Decodable::decode(&Decoder(from_str(~\"[]\").unwrap()));\n+        assert_eq!(v, ~[]);\n+\n+        let v: ~[()] = Decodable::decode(&Decoder(from_str(~\"[null]\").unwrap()));\n+        assert_eq!(v, ~[()]);\n+\n+\n+        let v: ~[bool] = Decodable::decode(&Decoder(from_str(~\"[true]\").unwrap()));\n+        assert_eq!(v, ~[true]);\n+\n+        let v: ~[bool] = Decodable::decode(&Decoder(from_str(~\"[true]\").unwrap()));\n+        assert_eq!(v, ~[true]);\n+\n+        let v: ~[int] = Decodable::decode(&Decoder(from_str(~\"[3, 1]\").unwrap()));\n+        assert_eq!(v, ~[3, 1]);\n+\n+        let v: ~[~[uint]] = Decodable::decode(&Decoder(from_str(~\"[[3], [1, 2]]\").unwrap()));\n+        assert_eq!(v, ~[~[3], ~[1, 2]]);\n+    }\n+\n     #[test]\n     fn test_read_object() {\n         assert_eq!(from_str(~\"{\"),\n@@ -1693,33 +1712,55 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_read_none() {\n+    fn test_decode_struct() {\n+        let s = ~\"{\n+            \\\"inner\\\": [\n+                { \\\"a\\\": null, \\\"b\\\": 2, \\\"c\\\": [\\\"abc\\\", \\\"xyz\\\"] }\n+            ]\n+        }\";\n+        let v: Outer = Decodable::decode(&Decoder(from_str(s).unwrap()));\n+        assert_eq!(\n+            v,\n+            Outer {\n+                inner: ~[\n+                    Inner { a: (), b: 2, c: ~[~\"abc\", ~\"xyz\"] }\n+                ]\n+            }\n+        );\n+    }\n+\n+    #[test]\n+    fn test_decode_option() {\n         let decoder = Decoder(from_str(~\"null\").unwrap());\n         let value: Option<~str> = Decodable::decode(&decoder);\n         assert_eq!(value, None);\n-    }\n \n-    #[test]\n-    fn test_read_some() {\n         let decoder = Decoder(from_str(~\"\\\"jodhpurs\\\"\").unwrap());\n         let value: Option<~str> = Decodable::decode(&decoder);\n         assert_eq!(value, Some(~\"jodhpurs\"));\n     }\n \n     #[test]\n-    fn test_read_enum_no_args() {\n+    fn test_decode_enum() {\n         let decoder = Decoder(from_str(~\"\\\"Dog\\\"\").unwrap());\n         let value: Animal = Decodable::decode(&decoder);\n         assert_eq!(value, Dog);\n-    }\n \n-    #[test]\n-    fn test_read_enum_multiple_args() {\n         let decoder = Decoder(from_str(~\"[\\\"Frog\\\",\\\"Henry\\\",349]\").unwrap());\n         let value: Animal = Decodable::decode(&decoder);\n         assert_eq!(value, Frog(~\"Henry\", 349));\n     }\n \n+    #[test]\n+    fn test_decode_map() {\n+        let s = ~\"{\\\"a\\\": \\\"Dog\\\", \\\"b\\\": [\\\"Frog\\\", \\\"Henry\\\", 349]}\";\n+        let decoder = Decoder(from_str(s).unwrap());\n+        let mut map: LinearMap<~str, Animal> = Decodable::decode(&decoder);\n+\n+        assert_eq!(map.pop(&~\"a\"), Some(Dog));\n+        assert_eq!(map.pop(&~\"b\"), Some(Frog(~\"Henry\", 349)));\n+    }\n+\n     #[test]\n     fn test_multiline_errors() {\n         assert_eq!(from_str(~\"{\\n  \\\"foo\\\":\\n \\\"bar\\\"\"),"}, {"sha": "ed4f3e957c02af8258f6762569a0039730ec3420", "filename": "src/libstd/prettyprint.rs", "status": "removed", "additions": 0, "deletions": 199, "changes": 199, "blob_url": "https://github.com/rust-lang/rust/blob/fbd8eae26de23cf00081229176fd7efd80943905/src%2Flibstd%2Fprettyprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd8eae26de23cf00081229176fd7efd80943905/src%2Flibstd%2Fprettyprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprettyprint.rs?ref=fbd8eae26de23cf00081229176fd7efd80943905", "patch": "@@ -1,199 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use serialize;\n-\n-use core::io::WriterUtil;\n-use core::io;\n-\n-pub struct Serializer {\n-    wr: @io::Writer,\n-}\n-\n-pub fn Serializer(wr: @io::Writer) -> Serializer {\n-    Serializer { wr: wr }\n-}\n-\n-impl serialize::Encoder for Serializer {\n-    fn emit_nil(&self) {\n-        self.wr.write_str(~\"()\")\n-    }\n-\n-    fn emit_uint(&self, v: uint) {\n-        self.wr.write_str(fmt!(\"%?u\", v));\n-    }\n-\n-    fn emit_u64(&self, v: u64) {\n-        self.wr.write_str(fmt!(\"%?_u64\", v));\n-    }\n-\n-    fn emit_u32(&self, v: u32) {\n-        self.wr.write_str(fmt!(\"%?_u32\", v));\n-    }\n-\n-    fn emit_u16(&self, v: u16) {\n-        self.wr.write_str(fmt!(\"%?_u16\", v));\n-    }\n-\n-    fn emit_u8(&self, v: u8) {\n-        self.wr.write_str(fmt!(\"%?_u8\", v));\n-    }\n-\n-    fn emit_int(&self, v: int) {\n-        self.wr.write_str(fmt!(\"%?\", v));\n-    }\n-\n-    fn emit_i64(&self, v: i64) {\n-        self.wr.write_str(fmt!(\"%?_i64\", v));\n-    }\n-\n-    fn emit_i32(&self, v: i32) {\n-        self.wr.write_str(fmt!(\"%?_i32\", v));\n-    }\n-\n-    fn emit_i16(&self, v: i16) {\n-        self.wr.write_str(fmt!(\"%?_i16\", v));\n-    }\n-\n-    fn emit_i8(&self, v: i8) {\n-        self.wr.write_str(fmt!(\"%?_i8\", v));\n-    }\n-\n-    fn emit_bool(&self, v: bool) {\n-        self.wr.write_str(fmt!(\"%b\", v));\n-    }\n-\n-    fn emit_float(&self, v: float) {\n-        self.wr.write_str(fmt!(\"%?_f\", v));\n-    }\n-\n-    fn emit_f64(&self, v: f64) {\n-        self.wr.write_str(fmt!(\"%?_f64\", v));\n-    }\n-\n-    fn emit_f32(&self, v: f32) {\n-        self.wr.write_str(fmt!(\"%?_f32\", v));\n-    }\n-\n-    fn emit_char(&self, v: char) {\n-        self.wr.write_str(fmt!(\"%?\", v));\n-    }\n-\n-    fn emit_borrowed_str(&self, v: &str) {\n-        self.wr.write_str(fmt!(\"&%?\", v));\n-    }\n-\n-    fn emit_owned_str(&self, v: &str) {\n-        self.wr.write_str(fmt!(\"~%?\", v));\n-    }\n-\n-    fn emit_managed_str(&self, v: &str) {\n-        self.wr.write_str(fmt!(\"@%?\", v));\n-    }\n-\n-    fn emit_borrowed(&self, f: &fn()) {\n-        self.wr.write_str(~\"&\");\n-        f();\n-    }\n-\n-    fn emit_owned(&self, f: &fn()) {\n-        self.wr.write_str(~\"~\");\n-        f();\n-    }\n-\n-    fn emit_managed(&self, f: &fn()) {\n-        self.wr.write_str(~\"@\");\n-        f();\n-    }\n-\n-    fn emit_enum(&self, _name: &str, f: &fn()) {\n-        f();\n-    }\n-\n-    fn emit_enum_variant(&self, v_name: &str, _v_id: uint, sz: uint,\n-                         f: &fn()) {\n-        self.wr.write_str(v_name);\n-        if sz > 0u { self.wr.write_str(~\"(\"); }\n-        f();\n-        if sz > 0u { self.wr.write_str(~\")\"); }\n-    }\n-\n-    fn emit_enum_variant_arg(&self, idx: uint, f: &fn()) {\n-        if idx > 0u { self.wr.write_str(~\", \"); }\n-        f();\n-    }\n-\n-    fn emit_borrowed_vec(&self, _len: uint, f: &fn()) {\n-        self.wr.write_str(~\"&[\");\n-        f();\n-        self.wr.write_str(~\"]\");\n-    }\n-\n-    fn emit_owned_vec(&self, _len: uint, f: &fn()) {\n-        self.wr.write_str(~\"~[\");\n-        f();\n-        self.wr.write_str(~\"]\");\n-    }\n-\n-    fn emit_managed_vec(&self, _len: uint, f: &fn()) {\n-        self.wr.write_str(~\"@[\");\n-        f();\n-        self.wr.write_str(~\"]\");\n-    }\n-\n-    fn emit_vec_elt(&self, idx: uint, f: &fn()) {\n-        if idx > 0u { self.wr.write_str(~\", \"); }\n-        f();\n-    }\n-\n-    fn emit_rec(&self, f: &fn()) {\n-        self.wr.write_str(~\"{\");\n-        f();\n-        self.wr.write_str(~\"}\");\n-    }\n-\n-    fn emit_struct(&self, name: &str, _len: uint, f: &fn()) {\n-        self.wr.write_str(fmt!(\"%s {\", name));\n-        f();\n-        self.wr.write_str(~\"}\");\n-    }\n-\n-    fn emit_field(&self, name: &str, idx: uint, f: &fn()) {\n-        if idx > 0u { self.wr.write_str(~\", \"); }\n-        self.wr.write_str(name);\n-        self.wr.write_str(~\": \");\n-        f();\n-    }\n-\n-    fn emit_tup(&self, _len: uint, f: &fn()) {\n-        self.wr.write_str(~\"(\");\n-        f();\n-        self.wr.write_str(~\")\");\n-    }\n-\n-    fn emit_tup_elt(&self, idx: uint, f: &fn()) {\n-        if idx > 0u { self.wr.write_str(~\", \"); }\n-        f();\n-    }\n-\n-    fn emit_option(&self, f: &fn()) {\n-        f();\n-    }\n-\n-    fn emit_option_none(&self) {\n-        self.wr.write_str(\"None\");\n-    }\n-\n-    fn emit_option_some(&self, f: &fn()) {\n-        self.wr.write_str(\"Some(\");\n-        f();\n-        self.wr.write_char(')');\n-    }\n-}"}, {"sha": "72c81d6d6b40cc18169584e93225f3db90bd585f", "filename": "src/libstd/serialize.rs", "status": "modified", "additions": 322, "deletions": 92, "changes": 414, "blob_url": "https://github.com/rust-lang/rust/blob/6dd20c8186e1eb2819f50d09ddba6941b7ff85b8/src%2Flibstd%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dd20c8186e1eb2819f50d09ddba6941b7ff85b8/src%2Flibstd%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fserialize.rs?ref=6dd20c8186e1eb2819f50d09ddba6941b7ff85b8", "patch": "@@ -16,9 +16,12 @@ Core encoding and decoding interfaces.\n \n #[forbid(non_camel_case_types)];\n \n-use core::at_vec;\n use core::prelude::*;\n-use core::vec;\n+use core::dlist::DList;\n+use core::hashmap::linear::{LinearMap, LinearSet};\n+use core::trie::{TrieMap, TrieSet};\n+use deque::Deque;\n+use treemap::{TreeMap, TreeSet};\n \n pub trait Encoder {\n     // Primitive types:\n@@ -38,35 +41,28 @@ pub trait Encoder {\n     fn emit_f64(&self, v: f64);\n     fn emit_f32(&self, v: f32);\n     fn emit_char(&self, v: char);\n-    fn emit_borrowed_str(&self, v: &str);\n-    fn emit_owned_str(&self, v: &str);\n-    fn emit_managed_str(&self, v: &str);\n+    fn emit_str(&self, v: &str);\n \n     // Compound types:\n-    fn emit_borrowed(&self, f: &fn());\n-    fn emit_owned(&self, f: &fn());\n-    fn emit_managed(&self, f: &fn());\n \n     fn emit_enum(&self, name: &str, f: &fn());\n     fn emit_enum_variant(&self, v_name: &str, v_id: uint, sz: uint, f: &fn());\n     fn emit_enum_variant_arg(&self, idx: uint, f: &fn());\n \n-    fn emit_borrowed_vec(&self, len: uint, f: &fn());\n-    fn emit_owned_vec(&self, len: uint, f: &fn());\n-    fn emit_managed_vec(&self, len: uint, f: &fn());\n-    fn emit_vec_elt(&self, idx: uint, f: &fn());\n+    fn emit_seq(&self, len: uint, f: &fn());\n+    fn emit_seq_elt(&self, idx: uint, f: &fn());\n \n-    fn emit_rec(&self, f: &fn());\n     fn emit_struct(&self, name: &str, _len: uint, f: &fn());\n     fn emit_field(&self, f_name: &str, f_idx: uint, f: &fn());\n \n-    fn emit_tup(&self, len: uint, f: &fn());\n-    fn emit_tup_elt(&self, idx: uint, f: &fn());\n-\n     // Specialized types:\n     fn emit_option(&self, f: &fn());\n     fn emit_option_none(&self);\n     fn emit_option_some(&self, f: &fn());\n+\n+    fn emit_map(&self, len: uint, f: &fn());\n+    fn emit_map_elt_key(&self, idx: uint, f: &fn());\n+    fn emit_map_elt_val(&self, idx: uint, f: &fn());\n }\n \n pub trait Decoder {\n@@ -87,32 +83,25 @@ pub trait Decoder {\n     fn read_f32(&self) -> f32;\n     fn read_float(&self) -> float;\n     fn read_char(&self) -> char;\n-    fn read_owned_str(&self) -> ~str;\n-    fn read_managed_str(&self) -> @str;\n+    fn read_str(&self) -> ~str;\n \n     // Compound types:\n     fn read_enum<T>(&self, name: &str, f: &fn() -> T) -> T;\n-\n     fn read_enum_variant<T>(&self, names: &[&str], f: &fn(uint) -> T) -> T;\n-\n     fn read_enum_variant_arg<T>(&self, idx: uint, f: &fn() -> T) -> T;\n \n-    fn read_owned<T>(&self, f: &fn() -> T) -> T;\n-    fn read_managed<T>(&self, f: &fn() -> T) -> T;\n+    fn read_seq<T>(&self, f: &fn(uint) -> T) -> T;\n+    fn read_seq_elt<T>(&self, idx: uint, f: &fn() -> T) -> T;\n \n-    fn read_owned_vec<T>(&self, f: &fn(uint) -> T) -> T;\n-    fn read_managed_vec<T>(&self, f: &fn(uint) -> T) -> T;\n-    fn read_vec_elt<T>(&self, idx: uint, f: &fn() -> T) -> T;\n-\n-    fn read_rec<T>(&self, f: &fn() -> T) -> T;\n     fn read_struct<T>(&self, name: &str, _len: uint, f: &fn() -> T) -> T;\n     fn read_field<T>(&self, name: &str, idx: uint, f: &fn() -> T) -> T;\n \n-    fn read_tup<T>(&self, sz: uint, f: &fn() -> T) -> T;\n-    fn read_tup_elt<T>(&self, idx: uint, f: &fn() -> T) -> T;\n-\n     // Specialized types:\n     fn read_option<T>(&self, f: &fn(bool) -> T) -> T;\n+\n+    fn read_map<T>(&self, f: &fn(uint) -> T) -> T;\n+    fn read_map_elt_key<T>(&self, idx: uint, f: &fn() -> T) -> T;\n+    fn read_map_elt_val<T>(&self, idx: uint, f: &fn() -> T) -> T;\n }\n \n pub trait Encodable<S:Encoder> {\n@@ -224,27 +213,25 @@ impl<D:Decoder> Decodable<D> for i64 {\n }\n \n impl<'self, S:Encoder> Encodable<S> for &'self str {\n-    fn encode(&self, s: &S) { s.emit_borrowed_str(*self) }\n+    fn encode(&self, s: &S) { s.emit_str(*self) }\n }\n \n impl<S:Encoder> Encodable<S> for ~str {\n-    fn encode(&self, s: &S) { s.emit_owned_str(*self) }\n+    fn encode(&self, s: &S) { s.emit_str(*self) }\n }\n \n impl<D:Decoder> Decodable<D> for ~str {\n     fn decode(d: &D) -> ~str {\n-        d.read_owned_str()\n+        d.read_str()\n     }\n }\n \n impl<S:Encoder> Encodable<S> for @str {\n-    fn encode(&self, s: &S) { s.emit_managed_str(*self) }\n+    fn encode(&self, s: &S) { s.emit_str(*self) }\n }\n \n impl<D:Decoder> Decodable<D> for @str {\n-    fn decode(d: &D) -> @str {\n-        d.read_managed_str()\n-    }\n+    fn decode(d: &D) -> @str { d.read_str().to_managed() }\n }\n \n impl<S:Encoder> Encodable<S> for float {\n@@ -298,79 +285,79 @@ impl<D:Decoder> Decodable<D> for () {\n \n impl<'self, S:Encoder,T:Encodable<S>> Encodable<S> for &'self T {\n     fn encode(&self, s: &S) {\n-        s.emit_borrowed(|| (**self).encode(s))\n+        (**self).encode(s)\n     }\n }\n \n impl<S:Encoder,T:Encodable<S>> Encodable<S> for ~T {\n     fn encode(&self, s: &S) {\n-        s.emit_owned(|| (**self).encode(s))\n+        (**self).encode(s)\n     }\n }\n \n impl<D:Decoder,T:Decodable<D>> Decodable<D> for ~T {\n     fn decode(d: &D) -> ~T {\n-        d.read_owned(|| ~Decodable::decode(d))\n+        ~Decodable::decode(d)\n     }\n }\n \n impl<S:Encoder,T:Encodable<S>> Encodable<S> for @T {\n     fn encode(&self, s: &S) {\n-        s.emit_managed(|| (**self).encode(s))\n+        (**self).encode(s)\n     }\n }\n \n impl<D:Decoder,T:Decodable<D>> Decodable<D> for @T {\n     fn decode(d: &D) -> @T {\n-        d.read_managed(|| @Decodable::decode(d))\n+        @Decodable::decode(d)\n     }\n }\n \n impl<'self, S:Encoder,T:Encodable<S>> Encodable<S> for &'self [T] {\n     fn encode(&self, s: &S) {\n-        do s.emit_borrowed_vec(self.len()) {\n+        do s.emit_seq(self.len()) {\n             for self.eachi |i, e| {\n-                s.emit_vec_elt(i, || e.encode(s))\n+                s.emit_seq_elt(i, || e.encode(s))\n             }\n         }\n     }\n }\n \n impl<S:Encoder,T:Encodable<S>> Encodable<S> for ~[T] {\n     fn encode(&self, s: &S) {\n-        do s.emit_owned_vec(self.len()) {\n+        do s.emit_seq(self.len()) {\n             for self.eachi |i, e| {\n-                s.emit_vec_elt(i, || e.encode(s))\n+                s.emit_seq_elt(i, || e.encode(s))\n             }\n         }\n     }\n }\n \n impl<D:Decoder,T:Decodable<D>> Decodable<D> for ~[T] {\n     fn decode(d: &D) -> ~[T] {\n-        do d.read_owned_vec |len| {\n+        do d.read_seq |len| {\n             do vec::from_fn(len) |i| {\n-                d.read_vec_elt(i, || Decodable::decode(d))\n+                d.read_seq_elt(i, || Decodable::decode(d))\n             }\n         }\n     }\n }\n \n impl<S:Encoder,T:Encodable<S>> Encodable<S> for @[T] {\n     fn encode(&self, s: &S) {\n-        do s.emit_managed_vec(self.len()) {\n+        do s.emit_seq(self.len()) {\n             for self.eachi |i, e| {\n-                s.emit_vec_elt(i, || e.encode(s))\n+                s.emit_seq_elt(i, || e.encode(s))\n             }\n         }\n     }\n }\n \n impl<D:Decoder,T:Decodable<D>> Decodable<D> for @[T] {\n     fn decode(d: &D) -> @[T] {\n-        do d.read_managed_vec |len| {\n+        do d.read_seq |len| {\n             do at_vec::from_fn(len) |i| {\n-                d.read_vec_elt(i, || Decodable::decode(d))\n+                d.read_seq_elt(i, || Decodable::decode(d))\n             }\n         }\n     }\n@@ -403,9 +390,9 @@ impl<S:Encoder,T0:Encodable<S>,T1:Encodable<S>> Encodable<S> for (T0, T1) {\n     fn encode(&self, s: &S) {\n         match *self {\n             (ref t0, ref t1) => {\n-                do s.emit_tup(2) {\n-                    s.emit_tup_elt(0, || t0.encode(s));\n-                    s.emit_tup_elt(1, || t1.encode(s));\n+                do s.emit_seq(2) {\n+                    s.emit_seq_elt(0, || t0.encode(s));\n+                    s.emit_seq_elt(1, || t1.encode(s));\n                 }\n             }\n         }\n@@ -414,10 +401,11 @@ impl<S:Encoder,T0:Encodable<S>,T1:Encodable<S>> Encodable<S> for (T0, T1) {\n \n impl<D:Decoder,T0:Decodable<D>,T1:Decodable<D>> Decodable<D> for (T0, T1) {\n     fn decode(d: &D) -> (T0, T1) {\n-        do d.read_tup(2) {\n+        do d.read_seq |len| {\n+            assert!(len == 2);\n             (\n-                d.read_tup_elt(0, || Decodable::decode(d)),\n-                d.read_tup_elt(1, || Decodable::decode(d))\n+                d.read_seq_elt(0, || Decodable::decode(d)),\n+                d.read_seq_elt(1, || Decodable::decode(d))\n             )\n         }\n     }\n@@ -432,10 +420,10 @@ impl<\n     fn encode(&self, s: &S) {\n         match *self {\n             (ref t0, ref t1, ref t2) => {\n-                do s.emit_tup(3) {\n-                    s.emit_tup_elt(0, || t0.encode(s));\n-                    s.emit_tup_elt(1, || t1.encode(s));\n-                    s.emit_tup_elt(2, || t2.encode(s));\n+                do s.emit_seq(3) {\n+                    s.emit_seq_elt(0, || t0.encode(s));\n+                    s.emit_seq_elt(1, || t1.encode(s));\n+                    s.emit_seq_elt(2, || t2.encode(s));\n                 }\n             }\n         }\n@@ -449,11 +437,12 @@ impl<\n     T2: Decodable<D>\n > Decodable<D> for (T0, T1, T2) {\n     fn decode(d: &D) -> (T0, T1, T2) {\n-        do d.read_tup(3) {\n+        do d.read_seq |len| {\n+            assert!(len == 3);\n             (\n-                d.read_tup_elt(0, || Decodable::decode(d)),\n-                d.read_tup_elt(1, || Decodable::decode(d)),\n-                d.read_tup_elt(2, || Decodable::decode(d))\n+                d.read_seq_elt(0, || Decodable::decode(d)),\n+                d.read_seq_elt(1, || Decodable::decode(d)),\n+                d.read_seq_elt(2, || Decodable::decode(d))\n             )\n         }\n     }\n@@ -469,11 +458,11 @@ impl<\n     fn encode(&self, s: &S) {\n         match *self {\n             (ref t0, ref t1, ref t2, ref t3) => {\n-                do s.emit_tup(4) {\n-                    s.emit_tup_elt(0, || t0.encode(s));\n-                    s.emit_tup_elt(1, || t1.encode(s));\n-                    s.emit_tup_elt(2, || t2.encode(s));\n-                    s.emit_tup_elt(3, || t3.encode(s));\n+                do s.emit_seq(4) {\n+                    s.emit_seq_elt(0, || t0.encode(s));\n+                    s.emit_seq_elt(1, || t1.encode(s));\n+                    s.emit_seq_elt(2, || t2.encode(s));\n+                    s.emit_seq_elt(3, || t3.encode(s));\n                 }\n             }\n         }\n@@ -488,12 +477,13 @@ impl<\n     T3: Decodable<D>\n > Decodable<D> for (T0, T1, T2, T3) {\n     fn decode(d: &D) -> (T0, T1, T2, T3) {\n-        do d.read_tup(4) {\n+        do d.read_seq |len| {\n+            assert!(len == 4);\n             (\n-                d.read_tup_elt(0, || Decodable::decode(d)),\n-                d.read_tup_elt(1, || Decodable::decode(d)),\n-                d.read_tup_elt(2, || Decodable::decode(d)),\n-                d.read_tup_elt(3, || Decodable::decode(d))\n+                d.read_seq_elt(0, || Decodable::decode(d)),\n+                d.read_seq_elt(1, || Decodable::decode(d)),\n+                d.read_seq_elt(2, || Decodable::decode(d)),\n+                d.read_seq_elt(3, || Decodable::decode(d))\n             )\n         }\n     }\n@@ -510,12 +500,12 @@ impl<\n     fn encode(&self, s: &S) {\n         match *self {\n             (ref t0, ref t1, ref t2, ref t3, ref t4) => {\n-                do s.emit_tup(5) {\n-                    s.emit_tup_elt(0, || t0.encode(s));\n-                    s.emit_tup_elt(1, || t1.encode(s));\n-                    s.emit_tup_elt(2, || t2.encode(s));\n-                    s.emit_tup_elt(3, || t3.encode(s));\n-                    s.emit_tup_elt(4, || t4.encode(s));\n+                do s.emit_seq(5) {\n+                    s.emit_seq_elt(0, || t0.encode(s));\n+                    s.emit_seq_elt(1, || t1.encode(s));\n+                    s.emit_seq_elt(2, || t2.encode(s));\n+                    s.emit_seq_elt(3, || t3.encode(s));\n+                    s.emit_seq_elt(4, || t4.encode(s));\n                 }\n             }\n         }\n@@ -532,18 +522,258 @@ impl<\n > Decodable<D> for (T0, T1, T2, T3, T4) {\n     fn decode(d: &D)\n       -> (T0, T1, T2, T3, T4) {\n-        do d.read_tup(5) {\n+        do d.read_seq |len| {\n+            assert!(len == 5);\n             (\n-                d.read_tup_elt(0, || Decodable::decode(d)),\n-                d.read_tup_elt(1, || Decodable::decode(d)),\n-                d.read_tup_elt(2, || Decodable::decode(d)),\n-                d.read_tup_elt(3, || Decodable::decode(d)),\n-                d.read_tup_elt(4, || Decodable::decode(d))\n+                d.read_seq_elt(0, || Decodable::decode(d)),\n+                d.read_seq_elt(1, || Decodable::decode(d)),\n+                d.read_seq_elt(2, || Decodable::decode(d)),\n+                d.read_seq_elt(3, || Decodable::decode(d)),\n+                d.read_seq_elt(4, || Decodable::decode(d))\n             )\n         }\n     }\n }\n \n+impl<\n+    S: Encoder,\n+    T: Encodable<S> + Copy\n+> Encodable<S> for @mut DList<T> {\n+    fn encode(&self, s: &S) {\n+        do s.emit_seq(self.size) {\n+            let mut i = 0;\n+            for self.each |e| {\n+                s.emit_seq_elt(i, || e.encode(s));\n+                i += 1;\n+            }\n+        }\n+    }\n+}\n+\n+impl<D:Decoder,T:Decodable<D>> Decodable<D> for @mut DList<T> {\n+    fn decode(d: &D) -> @mut DList<T> {\n+        let list = DList();\n+        do d.read_seq |len| {\n+            for uint::range(0, len) |i| {\n+                list.push(d.read_seq_elt(i, || Decodable::decode(d)));\n+            }\n+        }\n+        list\n+    }\n+}\n+\n+impl<\n+    S: Encoder,\n+    T: Encodable<S>\n+> Encodable<S> for Deque<T> {\n+    fn encode(&self, s: &S) {\n+        do s.emit_seq(self.len()) {\n+            for self.eachi |i, e| {\n+                s.emit_seq_elt(i, || e.encode(s));\n+            }\n+        }\n+    }\n+}\n+\n+impl<D:Decoder,T:Decodable<D>> Decodable<D> for Deque<T> {\n+    fn decode(d: &D) -> Deque<T> {\n+        let mut deque = Deque::new();\n+        do d.read_seq |len| {\n+            for uint::range(0, len) |i| {\n+                deque.add_back(d.read_seq_elt(i, || Decodable::decode(d)));\n+            }\n+        }\n+        deque\n+    }\n+}\n+\n+impl<\n+    E: Encoder,\n+    K: Encodable<E> + Hash + IterBytes + Eq,\n+    V: Encodable<E>\n+> Encodable<E> for LinearMap<K, V> {\n+    fn encode(&self, e: &E) {\n+        do e.emit_map(self.len()) {\n+            let mut i = 0;\n+            for self.each |&(key, val)| {\n+                e.emit_map_elt_key(i, || key.encode(e));\n+                e.emit_map_elt_val(i, || val.encode(e));\n+                i += 1;\n+            }\n+        }\n+    }\n+}\n+\n+impl<\n+    D: Decoder,\n+    K: Decodable<D> + Hash + IterBytes + Eq,\n+    V: Decodable<D>\n+> Decodable<D> for LinearMap<K, V> {\n+    fn decode(d: &D) -> LinearMap<K, V> {\n+        do d.read_map |len| {\n+            let mut map = LinearMap::with_capacity(len);\n+            for uint::range(0, len) |i| {\n+                let key = d.read_map_elt_key(i, || Decodable::decode(d));\n+                let val = d.read_map_elt_val(i, || Decodable::decode(d));\n+                map.insert(key, val);\n+            }\n+            map\n+        }\n+    }\n+}\n+\n+impl<\n+    S: Encoder,\n+    T: Encodable<S> + Hash + IterBytes + Eq\n+> Encodable<S> for LinearSet<T> {\n+    fn encode(&self, s: &S) {\n+        do s.emit_seq(self.len()) {\n+            let mut i = 0;\n+            for self.each |e| {\n+                s.emit_seq_elt(i, || e.encode(s));\n+                i += 1;\n+            }\n+        }\n+    }\n+}\n+\n+impl<\n+    D: Decoder,\n+    T: Decodable<D> + Hash + IterBytes + Eq\n+> Decodable<D> for LinearSet<T> {\n+    fn decode(d: &D) -> LinearSet<T> {\n+        do d.read_seq |len| {\n+            let mut set = LinearSet::with_capacity(len);\n+            for uint::range(0, len) |i| {\n+                set.insert(d.read_seq_elt(i, || Decodable::decode(d)));\n+            }\n+            set\n+        }\n+    }\n+}\n+\n+impl<\n+    E: Encoder,\n+    V: Encodable<E>\n+> Encodable<E> for TrieMap<V> {\n+    fn encode(&self, e: &E) {\n+        do e.emit_map(self.len()) {\n+            let mut i = 0;\n+            for self.each |&(key, val)| {\n+                e.emit_map_elt_key(i, || key.encode(e));\n+                e.emit_map_elt_val(i, || val.encode(e));\n+                i += 1;\n+            }\n+        }\n+    }\n+}\n+\n+impl<\n+    D: Decoder,\n+    V: Decodable<D>\n+> Decodable<D> for TrieMap<V> {\n+    fn decode(d: &D) -> TrieMap<V> {\n+        do d.read_map |len| {\n+            let mut map = TrieMap::new();\n+            for uint::range(0, len) |i| {\n+                let key = d.read_map_elt_key(i, || Decodable::decode(d));\n+                let val = d.read_map_elt_val(i, || Decodable::decode(d));\n+                map.insert(key, val);\n+            }\n+            map\n+        }\n+    }\n+}\n+\n+impl<S: Encoder> Encodable<S> for TrieSet {\n+    fn encode(&self, s: &S) {\n+        do s.emit_seq(self.len()) {\n+            let mut i = 0;\n+            for self.each |e| {\n+                s.emit_seq_elt(i, || e.encode(s));\n+                i += 1;\n+            }\n+        }\n+    }\n+}\n+\n+impl<D: Decoder> Decodable<D> for TrieSet {\n+    fn decode(d: &D) -> TrieSet {\n+        do d.read_seq |len| {\n+            let mut set = TrieSet::new();\n+            for uint::range(0, len) |i| {\n+                set.insert(d.read_seq_elt(i, || Decodable::decode(d)));\n+            }\n+            set\n+        }\n+    }\n+}\n+\n+impl<\n+    E: Encoder,\n+    K: Encodable<E> + Eq + TotalOrd,\n+    V: Encodable<E> + Eq\n+> Encodable<E> for TreeMap<K, V> {\n+    fn encode(&self, e: &E) {\n+        do e.emit_map(self.len()) {\n+            let mut i = 0;\n+            for self.each |&(key, val)| {\n+                e.emit_map_elt_key(i, || key.encode(e));\n+                e.emit_map_elt_val(i, || val.encode(e));\n+                i += 1;\n+            }\n+        }\n+    }\n+}\n+\n+impl<\n+    D: Decoder,\n+    K: Decodable<D> + Eq + TotalOrd,\n+    V: Decodable<D> + Eq\n+> Decodable<D> for TreeMap<K, V> {\n+    fn decode(d: &D) -> TreeMap<K, V> {\n+        do d.read_map |len| {\n+            let mut map = TreeMap::new();\n+            for uint::range(0, len) |i| {\n+                let key = d.read_map_elt_key(i, || Decodable::decode(d));\n+                let val = d.read_map_elt_val(i, || Decodable::decode(d));\n+                map.insert(key, val);\n+            }\n+            map\n+        }\n+    }\n+}\n+\n+impl<\n+    S: Encoder,\n+    T: Encodable<S> + Eq + TotalOrd\n+> Encodable<S> for TreeSet<T> {\n+    fn encode(&self, s: &S) {\n+        do s.emit_seq(self.len()) {\n+            let mut i = 0;\n+            for self.each |e| {\n+                s.emit_seq_elt(i, || e.encode(s));\n+                i += 1;\n+            }\n+        }\n+    }\n+}\n+\n+impl<\n+    D: Decoder,\n+    T: Decodable<D> + Eq + TotalOrd\n+> Decodable<D> for TreeSet<T> {\n+    fn decode(d: &D) -> TreeSet<T> {\n+        do d.read_seq |len| {\n+            let mut set = TreeSet::new();\n+            for uint::range(0, len) |i| {\n+                set.insert(d.read_seq_elt(i, || Decodable::decode(d)));\n+            }\n+            set\n+        }\n+    }\n+}\n+\n // ___________________________________________________________________________\n // Helper routines\n //\n@@ -555,9 +785,9 @@ pub trait EncoderHelpers {\n \n impl<S:Encoder> EncoderHelpers for S {\n     fn emit_from_vec<T>(&self, v: &[T], f: &fn(v: &T)) {\n-        do self.emit_owned_vec(v.len()) {\n+        do self.emit_seq(v.len()) {\n             for v.eachi |i, e| {\n-                do self.emit_vec_elt(i) {\n+                do self.emit_seq_elt(i) {\n                     f(e)\n                 }\n             }\n@@ -571,9 +801,9 @@ pub trait DecoderHelpers {\n \n impl<D:Decoder> DecoderHelpers for D {\n     fn read_to_vec<T>(&self, f: &fn() -> T) -> ~[T] {\n-        do self.read_owned_vec |len| {\n+        do self.read_seq |len| {\n             do vec::from_fn(len) |i| {\n-                self.read_vec_elt(i, || f())\n+                self.read_seq_elt(i, || f())\n             }\n         }\n     }"}, {"sha": "b28e2f0ab6df18c6098d02df7bfbf24dede7b4a1", "filename": "src/libstd/std.rc", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6dd20c8186e1eb2819f50d09ddba6941b7ff85b8/src%2Flibstd%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/6dd20c8186e1eb2819f50d09ddba6941b7ff85b8/src%2Flibstd%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstd.rc?ref=6dd20c8186e1eb2819f50d09ddba6941b7ff85b8", "patch": "@@ -88,7 +88,6 @@ pub mod md4;\n pub mod tempfile;\n pub mod term;\n pub mod time;\n-pub mod prettyprint;\n pub mod arena;\n pub mod par;\n pub mod cmp;"}, {"sha": "90f10ea50541dd8631dbfe26e2398284c00e77e4", "filename": "src/libstd/workcache.rs", "status": "modified", "additions": 27, "deletions": 14, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/6dd20c8186e1eb2819f50d09ddba6941b7ff85b8/src%2Flibstd%2Fworkcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dd20c8186e1eb2819f50d09ddba6941b7ff85b8/src%2Flibstd%2Fworkcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fworkcache.rs?ref=6dd20c8186e1eb2819f50d09ddba6941b7ff85b8", "patch": "@@ -137,7 +137,11 @@ pub impl WorkKey {\n     }\n }\n \n-type WorkMap = LinearMap<WorkKey, ~str>;\n+struct WorkMap(LinearMap<WorkKey, ~str>);\n+\n+impl WorkMap {\n+    fn new() -> WorkMap { WorkMap(LinearMap::new()) }\n+}\n \n impl<S:Encoder> Encodable<S> for WorkMap {\n     fn encode(&self, s: &S) {\n@@ -153,7 +157,7 @@ impl<S:Encoder> Encodable<S> for WorkMap {\n impl<D:Decoder> Decodable<D> for WorkMap {\n     fn decode(d: &D) -> WorkMap {\n         let v : ~[(WorkKey,~str)] = Decodable::decode(d);\n-        let mut w = LinearMap::new();\n+        let mut w = WorkMap::new();\n         for v.each |&(k, v)| {\n             w.insert(copy k, copy v);\n         }\n@@ -235,7 +239,7 @@ fn json_encode<T:Encodable<json::Encoder>>(t: &T) -> ~str {\n }\n \n // FIXME(#5121)\n-fn json_decode<T:Decodable<json::Decoder<'static>>>(s: &str) -> T {\n+fn json_decode<T:Decodable<json::Decoder>>(s: &str) -> T {\n     do io::with_str_reader(s) |rdr| {\n         let j = result::unwrap(json::from_reader(rdr));\n         Decodable::decode(&json::Decoder(j))\n@@ -260,18 +264,25 @@ pub impl Context {\n     fn new(db: @Mut<Database>,\n                   lg: @Mut<Logger>,\n                   cfg: @json::Object) -> Context {\n-        Context{db: db, logger: lg, cfg: cfg, freshness: LinearMap::new()}\n+        Context {\n+            db: db,\n+            logger: lg,\n+            cfg: cfg,\n+            freshness: LinearMap::new()\n+        }\n     }\n \n     fn prep<T:Owned +\n               Encodable<json::Encoder> +\n-              Decodable<json::Decoder<'static>>>( // FIXME(#5121)\n+              Decodable<json::Decoder>>( // FIXME(#5121)\n                   @self,\n                   fn_name:&str,\n                   blk: &fn(@Mut<Prep>)->Work<T>) -> Work<T> {\n-        let p = @Mut(Prep {ctxt: self,\n-                           fn_name: fn_name.to_owned(),\n-                           declared_inputs: LinearMap::new()});\n+        let p = @Mut(Prep {\n+            ctxt: self,\n+            fn_name: fn_name.to_owned(),\n+            declared_inputs: WorkMap::new()\n+        });\n         blk(p)\n     }\n }\n@@ -283,7 +294,7 @@ trait TPrep {\n     fn all_fresh(&self, cat:&str, map:&WorkMap) -> bool;\n     fn exec<T:Owned +\n               Encodable<json::Encoder> +\n-              Decodable<json::Decoder<'static>>>( // FIXME(#5121)\n+              Decodable<json::Decoder>>( // FIXME(#5121)\n         &self, blk: ~fn(&Exec) -> T) -> Work<T>;\n }\n \n@@ -324,7 +335,7 @@ impl TPrep for @Mut<Prep> {\n \n     fn exec<T:Owned +\n               Encodable<json::Encoder> +\n-              Decodable<json::Decoder<'static>>>( // FIXME(#5121)\n+              Decodable<json::Decoder>>( // FIXME(#5121)\n             &self, blk: ~fn(&Exec) -> T) -> Work<T> {\n         let mut bo = Some(blk);\n \n@@ -349,8 +360,10 @@ impl TPrep for @Mut<Prep> {\n                     let blk = blk.unwrap();\n                     let chan = Cell(chan);\n                     do task::spawn || {\n-                        let exe = Exec{discovered_inputs: LinearMap::new(),\n-                                       discovered_outputs: LinearMap::new()};\n+                        let exe = Exec {\n+                            discovered_inputs: WorkMap::new(),\n+                            discovered_outputs: WorkMap::new(),\n+                        };\n                         let chan = chan.take();\n                         let v = blk(&exe);\n                         send_one(chan, (exe, v));\n@@ -365,7 +378,7 @@ impl TPrep for @Mut<Prep> {\n \n pub impl<T:Owned +\n          Encodable<json::Encoder> +\n-         Decodable<json::Decoder<'static>>> Work<T> { // FIXME(#5121)\n+         Decodable<json::Decoder>> Work<T> { // FIXME(#5121)\n     fn new(p: @Mut<Prep>, e: Either<T,PortOne<(Exec,T)>>) -> Work<T> {\n         Work { prep: p, res: Some(e) }\n     }\n@@ -374,7 +387,7 @@ pub impl<T:Owned +\n // FIXME (#3724): movable self. This should be in impl Work.\n fn unwrap<T:Owned +\n             Encodable<json::Encoder> +\n-            Decodable<json::Decoder<'static>>>( // FIXME(#5121)\n+            Decodable<json::Decoder>>( // FIXME(#5121)\n         w: Work<T>) -> T {\n     let mut ww = w;\n     let mut s = None;"}, {"sha": "16399674b5599305610dba3bc6d76e2602b7afc7", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6dd20c8186e1eb2819f50d09ddba6941b7ff85b8/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dd20c8186e1eb2819f50d09ddba6941b7ff85b8/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=6dd20c8186e1eb2819f50d09ddba6941b7ff85b8", "patch": "@@ -71,7 +71,7 @@ impl<S:Encoder> Encodable<S> for ident {\n             Some(intr) => intr\n         };\n \n-        s.emit_owned_str(*(*intr).get(*self));\n+        s.emit_str(*(*intr).get(*self));\n     }\n }\n \n@@ -84,7 +84,7 @@ impl<D:Decoder> Decodable<D> for ident {\n             Some(intr) => intr\n         };\n \n-        (*intr).intern(@d.read_owned_str())\n+        (*intr).intern(@d.read_str())\n     }\n }\n "}, {"sha": "d25792355a718279d4896b5c1a44c41e9efbc788", "filename": "src/libsyntax/ext/auto_encode.rs", "status": "modified", "additions": 13, "deletions": 27, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/6dd20c8186e1eb2819f50d09ddba6941b7ff85b8/src%2Flibsyntax%2Fext%2Fauto_encode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dd20c8186e1eb2819f50d09ddba6941b7ff85b8/src%2Flibsyntax%2Fext%2Fauto_encode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fauto_encode.rs?ref=6dd20c8186e1eb2819f50d09ddba6941b7ff85b8", "patch": "@@ -1240,14 +1240,7 @@ mod test {\n         fn emit_float(&self, +_v: float) { self.add_unknown_to_log(); }\n \n         fn emit_char(&self, +_v: char) { self.add_unknown_to_log(); }\n-\n-        fn emit_borrowed_str(&self, +_v: &str) { self.add_unknown_to_log(); }\n-        fn emit_owned_str(&self, +_v: &str) { self.add_unknown_to_log(); }\n-        fn emit_managed_str(&self, +_v: &str) { self.add_unknown_to_log(); }\n-\n-        fn emit_borrowed(&self, f: &fn()) { self.add_unknown_to_log(); f() }\n-        fn emit_owned(&self, f: &fn()) { self.add_unknown_to_log(); f() }\n-        fn emit_managed(&self, f: &fn()) { self.add_unknown_to_log(); f() }\n+        fn emit_str(&self, +_v: &str) { self.add_unknown_to_log(); }\n \n         fn emit_enum(&self, name: &str, f: &fn()) {\n             self.add_to_log(CallToEmitEnum(name.to_str())); f(); }\n@@ -1262,37 +1255,20 @@ mod test {\n             self.add_to_log(CallToEmitEnumVariantArg (idx)); f();\n         }\n \n-        fn emit_borrowed_vec(&self, +_len: uint, f: &fn()) {\n-            self.add_unknown_to_log(); f();\n-        }\n-\n-        fn emit_owned_vec(&self, +_len: uint, f: &fn()) {\n+        fn emit_seq(&self, +_len: uint, f: &fn()) {\n             self.add_unknown_to_log(); f();\n         }\n-        fn emit_managed_vec(&self, +_len: uint, f: &fn()) {\n-            self.add_unknown_to_log(); f();\n-        }\n-        fn emit_vec_elt(&self, +_idx: uint, f: &fn()) {\n+        fn emit_seq_elt(&self, +_idx: uint, f: &fn()) {\n             self.add_unknown_to_log(); f();\n         }\n \n-        fn emit_rec(&self, f: &fn()) {\n-            self.add_unknown_to_log(); f();\n-        }\n         fn emit_struct(&self, name: &str, +len: uint, f: &fn()) {\n             self.add_to_log(CallToEmitStruct (name.to_str(),len)); f();\n         }\n         fn emit_field(&self, name: &str, +idx: uint, f: &fn()) {\n             self.add_to_log(CallToEmitField (name.to_str(),idx)); f();\n         }\n \n-        fn emit_tup(&self, +_len: uint, f: &fn()) {\n-            self.add_unknown_to_log(); f();\n-        }\n-        fn emit_tup_elt(&self, +_idx: uint, f: &fn()) {\n-            self.add_unknown_to_log(); f();\n-        }\n-\n         fn emit_option(&self, f: &fn()) {\n             self.add_to_log(CallToEmitOption);\n             f();\n@@ -1304,6 +1280,16 @@ mod test {\n             self.add_to_log(CallToEmitOptionSome);\n             f();\n         }\n+\n+        fn emit_map(&self, _len: uint, f: &fn()) {\n+            self.add_unknown_to_log(); f();\n+        }\n+        fn emit_map_elt_key(&self, _idx: uint, f: &fn()) {\n+            self.add_unknown_to_log(); f();\n+        }\n+        fn emit_map_elt_val(&self, _idx: uint, f: &fn()) {\n+            self.add_unknown_to_log(); f();\n+        }\n     }\n \n "}, {"sha": "e0720876900ff103932e19c8bc51fe42be6c5a48", "filename": "src/test/run-pass/auto-encode.rs", "status": "modified", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/6dd20c8186e1eb2819f50d09ddba6941b7ff85b8/src%2Ftest%2Frun-pass%2Fauto-encode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dd20c8186e1eb2819f50d09ddba6941b7ff85b8/src%2Ftest%2Frun-pass%2Fauto-encode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauto-encode.rs?ref=6dd20c8186e1eb2819f50d09ddba6941b7ff85b8", "patch": "@@ -22,21 +22,9 @@ use EBWriter = std::ebml::writer;\n use core::cmp::Eq;\n use core::io::Writer;\n use std::ebml;\n-use std::prettyprint;\n use std::serialize::{Encodable, Decodable};\n use std::time;\n \n-fn test_prettyprint<A:Encodable<prettyprint::Serializer>>(\n-    a: &A,\n-    expected: &~str\n-) {\n-    let s = do io::with_str_writer |w| {\n-        a.encode(&prettyprint::Serializer(w))\n-    };\n-    debug!(\"s == %?\", s);\n-    assert!(s == *expected);\n-}\n-\n fn test_ebml<A:\n     Eq +\n     Encodable<EBWriter::Encoder> +\n@@ -149,36 +137,27 @@ enum CLike { A, B, C }\n \n pub fn main() {\n     let a = &Plus(@Minus(@Val(3u), @Val(10u)), @Plus(@Val(22u), @Val(5u)));\n-    test_prettyprint(a, &~\"Plus(@Minus(@Val(3u), @Val(10u)), \\\n-                           @Plus(@Val(22u), @Val(5u)))\");\n     test_ebml(a);\n \n     let a = &Spanned {lo: 0u, hi: 5u, node: 22u};\n-    test_prettyprint(a, &~\"Spanned {lo: 0u, hi: 5u, node: 22u}\");\n     test_ebml(a);\n \n     let a = &Point {x: 3u, y: 5u};\n-    test_prettyprint(a, &~\"Point {x: 3u, y: 5u}\");\n     test_ebml(a);\n \n     let a = &@[1u, 2u, 3u];\n-    test_prettyprint(a, &~\"@[1u, 2u, 3u]\");\n     test_ebml(a);\n \n     let a = &Top(22u);\n-    test_prettyprint(a, &~\"Top(22u)\");\n     test_ebml(a);\n \n     let a = &Bottom(222u);\n-    test_prettyprint(a, &~\"Bottom(222u)\");\n     test_ebml(a);\n \n     let a = &A;\n-    test_prettyprint(a, &~\"A\");\n     test_ebml(a);\n \n     let a = &B;\n-    test_prettyprint(a, &~\"B\");\n     test_ebml(a);\n \n     let a = &time::now();"}]}