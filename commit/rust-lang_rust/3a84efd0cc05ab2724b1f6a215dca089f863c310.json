{"sha": "3a84efd0cc05ab2724b1f6a215dca089f863c310", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNhODRlZmQwY2MwNWFiMjcyNGIxZjZhMjE1ZGNhMDg5Zjg2M2MzMTA=", "commit": {"author": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2019-11-06T19:44:56Z"}, "committer": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2019-11-13T18:44:13Z"}, "message": "Add HIR pass to check for `if`s and `loop`s in a `const`\n\nThese high-level constructs get mapped to control-flow primitives by the\ntime the MIR const-checker runs, making it hard to get the span for the\nerroneous expression.", "tree": {"sha": "fdabc93fa4ce273accc763ba3344d3d2c77c3198", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fdabc93fa4ce273accc763ba3344d3d2c77c3198"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3a84efd0cc05ab2724b1f6a215dca089f863c310", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3a84efd0cc05ab2724b1f6a215dca089f863c310", "html_url": "https://github.com/rust-lang/rust/commit/3a84efd0cc05ab2724b1f6a215dca089f863c310", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3a84efd0cc05ab2724b1f6a215dca089f863c310/comments", "author": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "33b62be8626b28f3c6fa0e6186ad114c452bc966", "url": "https://api.github.com/repos/rust-lang/rust/commits/33b62be8626b28f3c6fa0e6186ad114c452bc966", "html_url": "https://github.com/rust-lang/rust/commit/33b62be8626b28f3c6fa0e6186ad114c452bc966"}], "stats": {"total": 164, "additions": 164, "deletions": 0}, "files": [{"sha": "9bd2a933c1c694095ac12f276f3ba67c59707761", "filename": "src/librustc/query/mod.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3a84efd0cc05ab2724b1f6a215dca089f863c310/src%2Flibrustc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a84efd0cc05ab2724b1f6a215dca089f863c310/src%2Flibrustc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fquery%2Fmod.rs?ref=3a84efd0cc05ab2724b1f6a215dca089f863c310", "patch": "@@ -329,6 +329,11 @@ rustc_queries! {\n             desc { |tcx| \"checking for unstable API usage in {}\", key.describe_as_module(tcx) }\n         }\n \n+        /// Checks the const bodies in the module for illegal operations (e.g. `if` or `loop`).\n+        query check_mod_const_bodies(key: DefId) -> () {\n+            desc { |tcx| \"checking consts in {}\", key.describe_as_module(tcx) }\n+        }\n+\n         /// Checks the loops in the module.\n         query check_mod_loops(key: DefId) -> () {\n             desc { |tcx| \"checking loops in {}\", key.describe_as_module(tcx) }"}, {"sha": "70e4a19e96fa1b2045b9d87840bc8b536eafb68d", "filename": "src/librustc_passes/check_const.rs", "status": "added", "additions": 157, "deletions": 0, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/3a84efd0cc05ab2724b1f6a215dca089f863c310/src%2Flibrustc_passes%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a84efd0cc05ab2724b1f6a215dca089f863c310/src%2Flibrustc_passes%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fcheck_const.rs?ref=3a84efd0cc05ab2724b1f6a215dca089f863c310", "patch": "@@ -0,0 +1,157 @@\n+//! This pass checks the HIR bodies in a const context (e.g., `const`, `static`, `const fn`) for\n+//! structured control flow (e.g. `if`, `while`), which is forbidden in a const context.\n+//!\n+//! By the time the MIR const-checker runs, these high-level constructs have been lowered to\n+//! control-flow primitives (e.g., `Goto`, `SwitchInt`), making it tough to properly attribute\n+//! errors. We still look for those primitives in the MIR const-checker to ensure nothing slips\n+//! through, but errors for structured control flow in a `const` should be emitted here.\n+\n+use rustc::hir::def_id::DefId;\n+use rustc::hir::intravisit::{Visitor, NestedVisitorMap};\n+use rustc::hir::map::Map;\n+use rustc::hir;\n+use rustc::session::Session;\n+use rustc::ty::TyCtxt;\n+use rustc::ty::query::Providers;\n+use syntax::span_err;\n+use syntax_pos::Span;\n+\n+use std::fmt;\n+\n+#[derive(Copy, Clone)]\n+enum ConstKind {\n+    Static,\n+    StaticMut,\n+    ConstFn,\n+    Const,\n+    AnonConst,\n+}\n+\n+impl ConstKind {\n+    fn for_body(body: &hir::Body, hir_map: &Map<'_>) -> Option<Self> {\n+        let is_const_fn = |id| hir_map.fn_sig_by_hir_id(id).unwrap().header.is_const();\n+\n+        let owner = hir_map.body_owner(body.id());\n+        let const_kind = match hir_map.body_owner_kind(owner) {\n+            hir::BodyOwnerKind::Const => Self::Const,\n+            hir::BodyOwnerKind::Static(hir::Mutability::MutMutable) => Self::StaticMut,\n+            hir::BodyOwnerKind::Static(hir::Mutability::MutImmutable) => Self::Static,\n+\n+            hir::BodyOwnerKind::Fn if is_const_fn(owner) => Self::ConstFn,\n+            hir::BodyOwnerKind::Fn | hir::BodyOwnerKind::Closure => return None,\n+        };\n+\n+        Some(const_kind)\n+    }\n+}\n+\n+impl fmt::Display for ConstKind {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        let s = match self {\n+            Self::Static => \"static\",\n+            Self::StaticMut => \"static mut\",\n+            Self::Const | Self::AnonConst => \"const\",\n+            Self::ConstFn => \"const fn\",\n+        };\n+\n+        write!(f, \"{}\", s)\n+    }\n+}\n+\n+fn check_mod_const_bodies(tcx: TyCtxt<'_>, module_def_id: DefId) {\n+    if tcx.sess.opts.debugging_opts.unleash_the_miri_inside_of_you {\n+        return;\n+    }\n+\n+    let mut vis = CheckConstVisitor::new(tcx);\n+    tcx.hir().visit_item_likes_in_module(module_def_id, &mut vis.as_deep_visitor());\n+}\n+\n+pub(crate) fn provide(providers: &mut Providers<'_>) {\n+    *providers = Providers {\n+        check_mod_const_bodies,\n+        ..*providers\n+    };\n+}\n+\n+#[derive(Copy, Clone)]\n+struct CheckConstVisitor<'tcx> {\n+    sess: &'tcx Session,\n+    hir_map: &'tcx Map<'tcx>,\n+    const_kind: Option<ConstKind>,\n+}\n+\n+impl<'tcx> CheckConstVisitor<'tcx> {\n+    fn new(tcx: TyCtxt<'tcx>) -> Self {\n+        CheckConstVisitor {\n+            sess: &tcx.sess,\n+            hir_map: tcx.hir(),\n+            const_kind: None,\n+        }\n+    }\n+\n+    /// Emits an error when an unsupported expression is found in a const context.\n+    fn const_check_violated(&self, bad_op: &str, span: Span) {\n+        let const_kind = self.const_kind\n+            .expect(\"`const_check_violated` may only be called inside a const context\");\n+\n+        span_err!(self.sess, span, E0744, \"`{}` is not allowed in a `{}`\", bad_op, const_kind);\n+    }\n+\n+    /// Saves the parent `const_kind` before visiting a nested `Body` and restores it afterwards.\n+    fn recurse_into(&mut self, kind: Option<ConstKind>, f: impl FnOnce(&mut Self)) {\n+        let parent_kind = self.const_kind;\n+        self.const_kind = kind;\n+        f(self);\n+        self.const_kind = parent_kind;\n+    }\n+}\n+\n+impl<'tcx> Visitor<'tcx> for CheckConstVisitor<'tcx> {\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::OnlyBodies(&self.hir_map)\n+    }\n+\n+    fn visit_anon_const(&mut self, anon: &'tcx hir::AnonConst) {\n+        let kind = Some(ConstKind::AnonConst);\n+        self.recurse_into(kind, |this| hir::intravisit::walk_anon_const(this, anon));\n+    }\n+\n+    fn visit_body(&mut self, body: &'tcx hir::Body) {\n+        let kind = ConstKind::for_body(body, self.hir_map);\n+        self.recurse_into(kind, |this| hir::intravisit::walk_body(this, body));\n+    }\n+\n+    fn visit_expr(&mut self, e: &'tcx hir::Expr) {\n+        match &e.kind {\n+            // Skip these checks if the current item is not const.\n+            _ if self.const_kind.is_none() => {}\n+\n+            hir::ExprKind::Loop(_, _, source) => {\n+                self.const_check_violated(source.name(), e.span);\n+            }\n+\n+            hir::ExprKind::Match(_, _, source) => {\n+                use hir::MatchSource::*;\n+\n+                let op = match source {\n+                    Normal => Some(\"match\"),\n+                    IfDesugar { .. } | IfLetDesugar { .. } => Some(\"if\"),\n+                    TryDesugar => Some(\"?\"),\n+                    AwaitDesugar => Some(\".await\"),\n+\n+                    // These are handled by `ExprKind::Loop` above.\n+                    WhileDesugar | WhileLetDesugar | ForLoopDesugar => None,\n+                };\n+\n+                if let Some(op) = op {\n+                    self.const_check_violated(op, e.span);\n+                }\n+            }\n+\n+            _ => {},\n+        }\n+\n+        hir::intravisit::walk_expr(self, e);\n+    }\n+}"}, {"sha": "1cbe6a652af968abddf787195b41e581928b7ff6", "filename": "src/librustc_passes/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3a84efd0cc05ab2724b1f6a215dca089f863c310/src%2Flibrustc_passes%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a84efd0cc05ab2724b1f6a215dca089f863c310/src%2Flibrustc_passes%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Flib.rs?ref=3a84efd0cc05ab2724b1f6a215dca089f863c310", "patch": "@@ -23,6 +23,7 @@ use rustc::ty::query::Providers;\n pub mod error_codes;\n \n pub mod ast_validation;\n+mod check_const;\n pub mod hir_stats;\n pub mod layout_test;\n pub mod loops;\n@@ -32,6 +33,7 @@ mod liveness;\n mod intrinsicck;\n \n pub fn provide(providers: &mut Providers<'_>) {\n+    check_const::provide(providers);\n     entry::provide(providers);\n     loops::provide(providers);\n     liveness::provide(providers);"}]}