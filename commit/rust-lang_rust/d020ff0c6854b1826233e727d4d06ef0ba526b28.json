{"sha": "d020ff0c6854b1826233e727d4d06ef0ba526b28", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQwMjBmZjBjNjg1NGIxODI2MjMzZTcyN2Q0ZDA2ZWYwYmE1MjZiMjg=", "commit": {"author": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2017-08-12T05:11:19Z"}, "committer": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2017-08-12T05:11:19Z"}, "message": "Merge branch 'master' of https://github.com/rust-lang/rust into gen\n\n# Conflicts:\n#\tsrc/librustc_mir/build/scope.rs", "tree": {"sha": "e43519fbbaf20512cbb0281b63eae7be04fd6c35", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e43519fbbaf20512cbb0281b63eae7be04fd6c35"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d020ff0c6854b1826233e727d4d06ef0ba526b28", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d020ff0c6854b1826233e727d4d06ef0ba526b28", "html_url": "https://github.com/rust-lang/rust/commit/d020ff0c6854b1826233e727d4d06ef0ba526b28", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d020ff0c6854b1826233e727d4d06ef0ba526b28/comments", "author": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fa18aa35206b52b3081d5200c21700f3a109ba65", "url": "https://api.github.com/repos/rust-lang/rust/commits/fa18aa35206b52b3081d5200c21700f3a109ba65", "html_url": "https://github.com/rust-lang/rust/commit/fa18aa35206b52b3081d5200c21700f3a109ba65"}, {"sha": "b8266a90b9ffee04c1e4a33ec02a47b1299f1180", "url": "https://api.github.com/repos/rust-lang/rust/commits/b8266a90b9ffee04c1e4a33ec02a47b1299f1180", "html_url": "https://github.com/rust-lang/rust/commit/b8266a90b9ffee04c1e4a33ec02a47b1299f1180"}], "stats": {"total": 848, "additions": 528, "deletions": 320}, "files": [{"sha": "c175198c227a54adc24d0fc04abd27072402d0ab", "filename": "src/Cargo.lock", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/d020ff0c6854b1826233e727d4d06ef0ba526b28/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/d020ff0c6854b1826233e727d4d06ef0ba526b28/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=d020ff0c6854b1826233e727d4d06ef0ba526b28", "patch": "@@ -65,6 +65,11 @@ name = \"ansi_term\"\n version = \"0.9.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n+[[package]]\n+name = \"ar\"\n+version = \"0.3.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n [[package]]\n name = \"arena\"\n version = \"0.0.0\"\n@@ -1333,10 +1338,12 @@ dependencies = [\n name = \"rustc_driver\"\n version = \"0.0.0\"\n dependencies = [\n+ \"ar 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"arena 0.0.0\",\n  \"env_logger 0.4.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"graphviz 0.0.0\",\n  \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"owning_ref 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc 0.0.0\",\n  \"rustc_allocator 0.0.0\",\n  \"rustc_back 0.0.0\",\n@@ -1354,6 +1361,7 @@ dependencies = [\n  \"rustc_resolve 0.0.0\",\n  \"rustc_save_analysis 0.0.0\",\n  \"rustc_trans 0.0.0\",\n+ \"rustc_trans_utils 0.0.0\",\n  \"rustc_typeck 0.0.0\",\n  \"serialize 0.0.0\",\n  \"syntax 0.0.0\",\n@@ -1545,11 +1553,21 @@ dependencies = [\n  \"rustc_incremental 0.0.0\",\n  \"rustc_llvm 0.0.0\",\n  \"rustc_platform_intrinsics 0.0.0\",\n+ \"rustc_trans_utils 0.0.0\",\n  \"serialize 0.0.0\",\n  \"syntax 0.0.0\",\n  \"syntax_pos 0.0.0\",\n ]\n \n+[[package]]\n+name = \"rustc_trans_utils\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"rustc 0.0.0\",\n+ \"syntax 0.0.0\",\n+ \"syntax_pos 0.0.0\",\n+]\n+\n [[package]]\n name = \"rustc_tsan\"\n version = \"0.0.0\"\n@@ -2141,6 +2159,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum aho-corasick 0.5.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ca972c2ea5f742bfce5687b9aef75506a764f61d37f8f649047846a9686ddb66\"\n \"checksum aho-corasick 0.6.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"500909c4f87a9e52355b26626d890833e9e1d53ac566db76c36faa984b889699\"\n \"checksum ansi_term 0.9.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"23ac7c30002a5accbf7e8987d0632fa6de155b7c3d39d0067317a391e00a2ef6\"\n+\"checksum ar 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"b24e4eef8e3fa7e2ca75b157e6039cdf8d9d3a68213ddc19d0fd9d576b9717c9\"\n \"checksum atty 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d912da0db7fa85514874458ca3651fe2cddace8d0b0505571dbdcd41ab490159\"\n \"checksum backtrace 0.3.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"72f9b4182546f4b04ebc4ab7f84948953a118bd6021a1b6a6c909e3e94f6be76\"\n \"checksum backtrace-sys 0.1.12 (registry+https://github.com/rust-lang/crates.io-index)\" = \"afccc5772ba333abccdf60d55200fa3406f8c59dcf54d5f7998c9107d3799c7c\""}, {"sha": "ec57bb069e0a4812719f88be8640239e3cf857e6", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d020ff0c6854b1826233e727d4d06ef0ba526b28/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d020ff0c6854b1826233e727d4d06ef0ba526b28/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=d020ff0c6854b1826233e727d4d06ef0ba526b28", "patch": "@@ -53,6 +53,7 @@ pub struct Config {\n     pub profiler: bool,\n \n     // llvm codegen options\n+    pub llvm_enabled: bool,\n     pub llvm_assertions: bool,\n     pub llvm_optimize: bool,\n     pub llvm_release_debuginfo: bool,\n@@ -192,6 +193,7 @@ struct Install {\n #[derive(Deserialize, Default)]\n #[serde(deny_unknown_fields, rename_all = \"kebab-case\")]\n struct Llvm {\n+    enabled: Option<bool>,\n     ccache: Option<StringOrBool>,\n     ninja: Option<bool>,\n     assertions: Option<bool>,\n@@ -265,6 +267,7 @@ struct TomlTarget {\n impl Config {\n     pub fn parse(build: &str, file: Option<PathBuf>) -> Config {\n         let mut config = Config::default();\n+        config.llvm_enabled = true;\n         config.llvm_optimize = true;\n         config.use_jemalloc = true;\n         config.backtrace = true;\n@@ -345,6 +348,7 @@ impl Config {\n                 Some(StringOrBool::Bool(false)) | None => {}\n             }\n             set(&mut config.ninja, llvm.ninja);\n+            set(&mut config.llvm_enabled, llvm.enabled);\n             set(&mut config.llvm_assertions, llvm.assertions);\n             set(&mut config.llvm_optimize, llvm.optimize);\n             set(&mut config.llvm_release_debuginfo, llvm.release_debuginfo);"}, {"sha": "19678dc77937568216a7fafa88302834669bca10", "filename": "src/bootstrap/config.toml.example", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d020ff0c6854b1826233e727d4d06ef0ba526b28/src%2Fbootstrap%2Fconfig.toml.example", "raw_url": "https://github.com/rust-lang/rust/raw/d020ff0c6854b1826233e727d4d06ef0ba526b28/src%2Fbootstrap%2Fconfig.toml.example", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.toml.example?ref=d020ff0c6854b1826233e727d4d06ef0ba526b28", "patch": "@@ -14,6 +14,10 @@\n # =============================================================================\n [llvm]\n \n+# Indicates whether rustc will support compilation with LLVM\n+# note: rustc does not compile without LLVM at the moment\n+#enabled = true\n+\n # Indicates whether the LLVM build is a Release or Debug build\n #optimize = true\n "}, {"sha": "a8485d1d152d18703837f735a7e778e8c62dd2f8", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d020ff0c6854b1826233e727d4d06ef0ba526b28/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d020ff0c6854b1826233e727d4d06ef0ba526b28/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=d020ff0c6854b1826233e727d4d06ef0ba526b28", "patch": "@@ -429,6 +429,9 @@ impl Build {\n         if self.config.use_jemalloc {\n             features.push_str(\" jemalloc\");\n         }\n+        if self.config.llvm_enabled {\n+            features.push_str(\" llvm\");\n+        }\n         features\n     }\n "}, {"sha": "59efbd5c4d20d8d9ce7f96d355cf746e20e13fec", "filename": "src/bootstrap/native.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d020ff0c6854b1826233e727d4d06ef0ba526b28/src%2Fbootstrap%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d020ff0c6854b1826233e727d4d06ef0ba526b28/src%2Fbootstrap%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fnative.rs?ref=d020ff0c6854b1826233e727d4d06ef0ba526b28", "patch": "@@ -56,6 +56,12 @@ impl Step for Llvm {\n     fn run(self, builder: &Builder) {\n         let build = builder.build;\n         let target = self.target;\n+\n+        // If we're not compiling for LLVM bail out here.\n+        if !build.config.llvm_enabled {\n+            return;\n+        }\n+\n         // If we're using a custom LLVM bail out here, but we can only use a\n         // custom LLVM for the build triple.\n         if let Some(config) = build.config.target_config.get(&target) {"}, {"sha": "fdca8d00d7a75f1fc0a693765a576b7d536d893d", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d020ff0c6854b1826233e727d4d06ef0ba526b28/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d020ff0c6854b1826233e727d4d06ef0ba526b28/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=d020ff0c6854b1826233e727d4d06ef0ba526b28", "patch": "@@ -629,10 +629,12 @@ extern \"rust-intrinsic\" {\n     /// Aborts the execution of the process.\n     pub fn abort() -> !;\n \n-    /// Tells LLVM that this point in the code is not reachable,\n-    /// enabling further optimizations.\n+    /// Tells LLVM that this point in the code is not reachable, enabling\n+    /// further optimizations.\n     ///\n-    /// NB: This is very different from the `unreachable!()` macro!\n+    /// NB: This is very different from the `unreachable!()` macro: Unlike the\n+    /// macro, which panics when it is executed, it is *undefined behavior* to\n+    /// reach code marked with this function.\n     pub fn unreachable() -> !;\n \n     /// Informs the optimizer that a condition is always true."}, {"sha": "6f7adbe1e7a0e9e67754ae9731582c4e209b4668", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d020ff0c6854b1826233e727d4d06ef0ba526b28/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d020ff0c6854b1826233e727d4d06ef0ba526b28/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=d020ff0c6854b1826233e727d4d06ef0ba526b28", "patch": "@@ -942,3 +942,15 @@ impl<T: ::fmt::Debug> ::fmt::Debug for ManuallyDrop<T> {\n         }\n     }\n }\n+\n+/// Tells LLVM that this point in the code is not reachable, enabling further\n+/// optimizations.\n+///\n+/// NB: This is very different from the `unreachable!()` macro: Unlike the\n+/// macro, which panics when it is executed, it is *undefined behavior* to\n+/// reach code marked with this function.\n+#[inline]\n+#[unstable(feature = \"unreachable\", issue = \"43751\")]\n+pub unsafe fn unreachable() -> ! {\n+    intrinsics::unreachable()\n+}"}, {"sha": "eb403442f46399de4b82d559a70e7562afb4b4f4", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d020ff0c6854b1826233e727d4d06ef0ba526b28/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d020ff0c6854b1826233e727d4d06ef0ba526b28/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=d020ff0c6854b1826233e727d4d06ef0ba526b28", "patch": "@@ -135,6 +135,11 @@ impl<'tcx> Lvalue<'tcx> {\n     }\n }\n \n+pub enum RvalueInitializationState {\n+    Shallow,\n+    Deep\n+}\n+\n impl<'tcx> Rvalue<'tcx> {\n     pub fn ty<'a, 'gcx, D>(&self, local_decls: &D, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Ty<'tcx>\n         where D: HasLocalDecls<'tcx>\n@@ -209,6 +214,16 @@ impl<'tcx> Rvalue<'tcx> {\n             }\n         }\n     }\n+\n+    #[inline]\n+    /// Returns whether this rvalue is deeply initialized (most rvalues) or\n+    /// whether its only shallowly initialized (`Rvalue::Box`).\n+    pub fn initialization_state(&self) -> RvalueInitializationState {\n+        match *self {\n+            Rvalue::NullaryOp(NullOp::Box, _) => RvalueInitializationState::Shallow,\n+            _ => RvalueInitializationState::Deep\n+        }\n+    }\n }\n \n impl<'tcx> Operand<'tcx> {"}, {"sha": "d6155f53485e3a8caca6b161bb38ac83e55ce1e8", "filename": "src/librustc_driver/Cargo.toml", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d020ff0c6854b1826233e727d4d06ef0ba526b28/src%2Flibrustc_driver%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/d020ff0c6854b1826233e727d4d06ef0ba526b28/src%2Flibrustc_driver%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2FCargo.toml?ref=d020ff0c6854b1826233e727d4d06ef0ba526b28", "patch": "@@ -12,6 +12,7 @@ crate-type = [\"dylib\"]\n arena = { path = \"../libarena\" }\n graphviz = { path = \"../libgraphviz\" }\n log = { version = \"0.3\", features = [\"release_max_level_info\"] }\n+owning_ref = \"0.3.3\"\n env_logger = { version = \"0.4\", default-features = false }\n rustc = { path = \"../librustc\" }\n rustc_allocator = { path = \"../librustc_allocator\" }\n@@ -29,9 +30,15 @@ rustc_plugin = { path = \"../librustc_plugin\" }\n rustc_privacy = { path = \"../librustc_privacy\" }\n rustc_resolve = { path = \"../librustc_resolve\" }\n rustc_save_analysis = { path = \"../librustc_save_analysis\" }\n-rustc_trans = { path = \"../librustc_trans\" }\n+rustc_trans = { path = \"../librustc_trans\", optional = true }\n+rustc_trans_utils = { path = \"../librustc_trans_utils\" }\n rustc_typeck = { path = \"../librustc_typeck\" }\n serialize = { path = \"../libserialize\" }\n syntax = { path = \"../libsyntax\" }\n syntax_ext = { path = \"../libsyntax_ext\" }\n syntax_pos = { path = \"../libsyntax_pos\" }\n+\n+ar = \"0.3.0\"\n+\n+[features]\n+llvm = [\"rustc_trans\"]"}, {"sha": "7efa2846cd6f3dd6deb8af749f3bbb46eab26506", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 73, "deletions": 27, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/d020ff0c6854b1826233e727d4d06ef0ba526b28/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d020ff0c6854b1826233e727d4d06ef0ba526b28/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=d020ff0c6854b1826233e727d4d06ef0ba526b28", "patch": "@@ -18,7 +18,9 @@ use rustc::session::CompileIncomplete;\n use rustc::session::config::{self, Input, OutputFilenames, OutputType};\n use rustc::session::search_paths::PathKind;\n use rustc::lint;\n-use rustc::middle::{self, dependency_format, stability, reachable};\n+use rustc::middle::{self, stability, reachable};\n+#[cfg(feature=\"llvm\")]\n+use rustc::middle::dependency_format;\n use rustc::middle::privacy::AccessLevels;\n use rustc::mir::transform::{MIR_CONST, MIR_VALIDATED, MIR_OPTIMIZED, Passes};\n use rustc::ty::{self, TyCtxt, Resolutions, GlobalArenas};\n@@ -31,7 +33,9 @@ use rustc_incremental::{self, IncrementalHashesMap};\n use rustc_resolve::{MakeGlobMap, Resolver};\n use rustc_metadata::creader::CrateLoader;\n use rustc_metadata::cstore::{self, CStore};\n+#[cfg(feature=\"llvm\")]\n use rustc_trans::back::{link, write};\n+#[cfg(feature=\"llvm\")]\n use rustc_trans as trans;\n use rustc_typeck as typeck;\n use rustc_privacy;\n@@ -69,6 +73,11 @@ pub fn compile_input(sess: &Session,\n                      output: &Option<PathBuf>,\n                      addl_plugins: Option<Vec<String>>,\n                      control: &CompileController) -> CompileResult {\n+    #[cfg(feature=\"llvm\")]\n+    use rustc_trans::back::write::OngoingCrateTranslation;\n+    #[cfg(not(feature=\"llvm\"))]\n+    type OngoingCrateTranslation = ();\n+\n     macro_rules! controller_entry_point {\n         ($point: ident, $tsess: expr, $make_state: expr, $phase_result: expr) => {{\n             let state = &mut $make_state;\n@@ -88,7 +97,7 @@ pub fn compile_input(sess: &Session,\n     // We need nested scopes here, because the intermediate results can keep\n     // large chunks of memory alive and we want to free them as soon as\n     // possible to keep the peak memory usage low\n-    let (outputs, trans) = {\n+    let (outputs, trans): (OutputFilenames, OngoingCrateTranslation) = {\n         let krate = match phase_1_parse_input(control, sess, input) {\n             Ok(krate) => krate,\n             Err(mut parse_error) => {\n@@ -113,7 +122,8 @@ pub fn compile_input(sess: &Session,\n         };\n \n         let outputs = build_output_filenames(input, outdir, output, &krate.attrs, sess);\n-        let crate_name = link::find_crate_name(Some(sess), &krate.attrs, input);\n+        let crate_name =\n+            ::rustc_trans_utils::link::find_crate_name(Some(sess), &krate.attrs, input);\n         let ExpansionResult { expanded_crate, defs, analysis, resolutions, mut hir_forest } = {\n             phase_2_configure_and_expand(\n                 sess, &cstore, krate, registry, &crate_name, addl_plugins, control.make_glob_map,\n@@ -206,6 +216,8 @@ pub fn compile_input(sess: &Session,\n                 println!(\"Pre-trans\");\n                 tcx.print_debug_stats();\n             }\n+\n+            #[cfg(feature=\"llvm\")]\n             let trans = phase_4_translate_to_llvm(tcx, analysis, incremental_hashes_map,\n                                                   &outputs);\n \n@@ -221,38 +233,59 @@ pub fn compile_input(sess: &Session,\n                 }\n             }\n \n+            #[cfg(not(feature=\"llvm\"))]\n+            {\n+                let _ = incremental_hashes_map;\n+                sess.err(&format!(\"LLVM is not supported by this rustc\"));\n+                sess.abort_if_errors();\n+                unreachable!();\n+            }\n+\n+            #[cfg(feature=\"llvm\")]\n             Ok((outputs, trans))\n         })??\n     };\n \n-    if sess.opts.debugging_opts.print_type_sizes {\n-        sess.code_stats.borrow().print_type_sizes();\n+    #[cfg(not(feature=\"llvm\"))]\n+    {\n+        let _ = outputs;\n+        let _ = trans;\n+        unreachable!();\n     }\n \n-    let (phase5_result, trans) = phase_5_run_llvm_passes(sess, trans);\n+    #[cfg(feature=\"llvm\")]\n+    {\n+        if sess.opts.debugging_opts.print_type_sizes {\n+            sess.code_stats.borrow().print_type_sizes();\n+        }\n \n-    controller_entry_point!(after_llvm,\n-                            sess,\n-                            CompileState::state_after_llvm(input, sess, outdir, output, &trans),\n-                            phase5_result);\n-    phase5_result?;\n+        let (phase5_result, trans) = phase_5_run_llvm_passes(sess, trans);\n \n-    phase_6_link_output(sess, &trans, &outputs);\n+        controller_entry_point!(after_llvm,\n+                                sess,\n+                                CompileState::state_after_llvm(input, sess, outdir, output, &trans),\n+                                phase5_result);\n+        phase5_result?;\n \n-    // Now that we won't touch anything in the incremental compilation directory\n-    // any more, we can finalize it (which involves renaming it)\n-    rustc_incremental::finalize_session_directory(sess, trans.link.crate_hash);\n+        phase_6_link_output(sess, &trans, &outputs);\n \n-    if sess.opts.debugging_opts.perf_stats {\n-        sess.print_perf_stats();\n-    }\n+        // Now that we won't touch anything in the incremental compilation directory\n+        // any more, we can finalize it (which involves renaming it)\n+        rustc_incremental::finalize_session_directory(sess, trans.link.crate_hash);\n \n-    controller_entry_point!(compilation_done,\n-                            sess,\n-                            CompileState::state_when_compilation_done(input, sess, outdir, output),\n-                            Ok(()));\n+        if sess.opts.debugging_opts.perf_stats {\n+            sess.print_perf_stats();\n+        }\n+\n+        controller_entry_point!(\n+            compilation_done,\n+            sess,\n+            CompileState::state_when_compilation_done(input, sess, outdir, output),\n+            Ok(())\n+        );\n \n-    Ok(())\n+        Ok(())\n+    }\n }\n \n fn keep_hygiene_data(sess: &Session) -> bool {\n@@ -360,6 +393,7 @@ pub struct CompileState<'a, 'tcx: 'a> {\n     pub resolutions: Option<&'a Resolutions>,\n     pub analysis: Option<&'a ty::CrateAnalysis>,\n     pub tcx: Option<TyCtxt<'a, 'tcx, 'tcx>>,\n+    #[cfg(feature=\"llvm\")]\n     pub trans: Option<&'a trans::CrateTranslation>,\n }\n \n@@ -386,6 +420,7 @@ impl<'a, 'tcx> CompileState<'a, 'tcx> {\n             resolutions: None,\n             analysis: None,\n             tcx: None,\n+            #[cfg(feature=\"llvm\")]\n             trans: None,\n         }\n     }\n@@ -474,7 +509,7 @@ impl<'a, 'tcx> CompileState<'a, 'tcx> {\n         }\n     }\n \n-\n+    #[cfg(feature=\"llvm\")]\n     fn state_after_llvm(input: &'a Input,\n                         session: &'tcx Session,\n                         out_dir: &'a Option<PathBuf>,\n@@ -488,6 +523,7 @@ impl<'a, 'tcx> CompileState<'a, 'tcx> {\n         }\n     }\n \n+    #[cfg(feature=\"llvm\")]\n     fn state_when_compilation_done(input: &'a Input,\n                                    session: &'tcx Session,\n                                    out_dir: &'a Option<PathBuf>,\n@@ -906,6 +942,7 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n     mir::provide(&mut local_providers);\n     reachable::provide(&mut local_providers);\n     rustc_privacy::provide(&mut local_providers);\n+    #[cfg(feature=\"llvm\")]\n     trans::provide(&mut local_providers);\n     typeck::provide(&mut local_providers);\n     ty::provide(&mut local_providers);\n@@ -918,6 +955,7 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n \n     let mut extern_providers = ty::maps::Providers::default();\n     cstore::provide(&mut extern_providers);\n+    #[cfg(feature=\"llvm\")]\n     trans::provide(&mut extern_providers);\n     ty::provide_extern(&mut extern_providers);\n     traits::provide_extern(&mut extern_providers);\n@@ -1066,6 +1104,7 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n \n /// Run the translation phase to LLVM, after which the AST and analysis can\n /// be discarded.\n+#[cfg(feature=\"llvm\")]\n pub fn phase_4_translate_to_llvm<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                            analysis: ty::CrateAnalysis,\n                                            incremental_hashes_map: IncrementalHashesMap,\n@@ -1087,6 +1126,7 @@ pub fn phase_4_translate_to_llvm<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n /// Run LLVM itself, producing a bitcode file, assembly file or object file\n /// as a side effect.\n+#[cfg(feature=\"llvm\")]\n pub fn phase_5_run_llvm_passes(sess: &Session,\n                                trans: write::OngoingCrateTranslation)\n                                -> (CompileResult, trans::CrateTranslation) {\n@@ -1105,6 +1145,7 @@ pub fn phase_5_run_llvm_passes(sess: &Session,\n \n /// Run the linker on any artifacts that resulted from the LLVM run.\n /// This should produce either a finished executable or library.\n+#[cfg(feature=\"llvm\")]\n pub fn phase_6_link_output(sess: &Session,\n                            trans: &trans::CrateTranslation,\n                            outputs: &OutputFilenames) {\n@@ -1126,7 +1167,12 @@ fn write_out_deps(sess: &Session, outputs: &OutputFilenames, crate_name: &str) {\n         match *output_type {\n             OutputType::Exe => {\n                 for output in sess.crate_types.borrow().iter() {\n-                    let p = link::filename_for_input(sess, *output, crate_name, outputs);\n+                    let p = ::rustc_trans_utils::link::filename_for_input(\n+                        sess,\n+                        *output,\n+                        crate_name,\n+                        outputs\n+                    );\n                     out_filenames.push(p);\n                 }\n             }\n@@ -1236,15 +1282,15 @@ pub fn collect_crate_types(session: &Session, attrs: &[ast::Attribute]) -> Vec<c\n     if base.is_empty() {\n         base.extend(attr_types);\n         if base.is_empty() {\n-            base.push(link::default_output_for_target(session));\n+            base.push(::rustc_trans_utils::link::default_output_for_target(session));\n         }\n         base.sort();\n         base.dedup();\n     }\n \n     base.into_iter()\n         .filter(|crate_type| {\n-            let res = !link::invalid_output_for_target(session, *crate_type);\n+            let res = !::rustc_trans_utils::link::invalid_output_for_target(session, *crate_type);\n \n             if !res {\n                 session.warn(&format!(\"dropping unsupported crate type `{}` for target `{}`\","}, {"sha": "91ba7ed1958e7c85299cf4795b54fc30ddcc486b", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 81, "deletions": 5, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/d020ff0c6854b1826233e727d4d06ef0ba526b28/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d020ff0c6854b1826233e727d4d06ef0ba526b28/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=d020ff0c6854b1826233e727d4d06ef0ba526b28", "patch": "@@ -28,10 +28,15 @@\n #![feature(rustc_diagnostic_macros)]\n #![feature(set_stdio)]\n \n+#[cfg(not(feature=\"llvm\"))]\n+extern crate ar;\n+\n extern crate arena;\n extern crate getopts;\n extern crate graphviz;\n extern crate env_logger;\n+#[cfg(not(feature=\"llvm\"))]\n+extern crate owning_ref;\n extern crate libc;\n extern crate rustc;\n extern crate rustc_allocator;\n@@ -49,7 +54,9 @@ extern crate rustc_metadata;\n extern crate rustc_mir;\n extern crate rustc_resolve;\n extern crate rustc_save_analysis;\n+#[cfg(feature=\"llvm\")]\n extern crate rustc_trans;\n+extern crate rustc_trans_utils;\n extern crate rustc_typeck;\n extern crate serialize;\n #[macro_use]\n@@ -64,7 +71,7 @@ use pretty::{PpMode, UserIdentifiedItem};\n use rustc_resolve as resolve;\n use rustc_save_analysis as save;\n use rustc_save_analysis::DumpHandler;\n-use rustc_trans::back::link;\n+#[cfg(feature=\"llvm\")]\n use rustc_trans::back::write::{RELOC_MODEL_ARGS, CODE_GEN_MODEL_ARGS};\n use rustc::dep_graph::DepGraph;\n use rustc::session::{self, config, Session, build_session, CompileResult};\n@@ -74,9 +81,13 @@ use rustc::session::config::nightly_options;\n use rustc::session::{early_error, early_warn};\n use rustc::lint::Lint;\n use rustc::lint;\n+#[cfg(not(feature=\"llvm\"))]\n+use rustc::middle::cstore::MetadataLoader as MetadataLoaderTrait;\n use rustc_metadata::locator;\n use rustc_metadata::cstore::CStore;\n use rustc::util::common::{time, ErrorReported};\n+#[cfg(not(feature=\"llvm\"))]\n+use rustc_back::target::Target;\n \n use serialize::json::ToJson;\n \n@@ -89,6 +100,8 @@ use std::ffi::OsString;\n use std::io::{self, Read, Write};\n use std::iter::repeat;\n use std::path::PathBuf;\n+#[cfg(not(feature=\"llvm\"))]\n+use std::path::Path;\n use std::process::{self, Command, Stdio};\n use std::rc::Rc;\n use std::str;\n@@ -101,11 +114,15 @@ use syntax::feature_gate::{GatedCfg, UnstableFeatures};\n use syntax::parse::{self, PResult};\n use syntax_pos::{DUMMY_SP, MultiSpan};\n \n+#[cfg(not(feature=\"llvm\"))]\n+use owning_ref::{OwningRef, ErasedBoxRef};\n+\n #[cfg(test)]\n pub mod test;\n \n pub mod driver;\n pub mod pretty;\n+#[cfg(feature=\"llvm\")]\n pub mod target_features;\n mod derive_registrar;\n \n@@ -151,9 +168,49 @@ pub fn run<F>(run_compiler: F) -> isize\n     0\n }\n \n+#[cfg(not(feature=\"llvm\"))]\n+pub struct NoLLvmMetadataLoader;\n+\n+#[cfg(not(feature=\"llvm\"))]\n+pub use NoLLvmMetadataLoader as MetadataLoader;\n+#[cfg(feature=\"llvm\")]\n+pub use rustc_trans::LlvmMetadataLoader as MetadataLoader;\n+\n+#[cfg(not(feature=\"llvm\"))]\n+impl MetadataLoaderTrait for NoLLvmMetadataLoader {\n+    fn get_rlib_metadata(&self, _: &Target, filename: &Path) -> Result<ErasedBoxRef<[u8]>, String> {\n+        use std::fs::File;\n+        use std::io;\n+        use self::ar::Archive;\n+\n+        let file = File::open(filename).map_err(|e|format!(\"metadata file open err: {:?}\", e))?;\n+        let mut archive = Archive::new(file);\n+\n+        while let Some(entry_result) = archive.next_entry() {\n+            let mut entry = entry_result.map_err(|e|format!(\"metadata section read err: {:?}\", e))?;\n+            if entry.header().identifier() == \"rust.metadata.bin\" {\n+                let mut buf = Vec::new();\n+                io::copy(&mut entry, &mut buf).unwrap();\n+                let buf: OwningRef<Vec<u8>, [u8]> = OwningRef::new(buf).into();\n+                return Ok(buf.map_owner_box().erase_owner());\n+            }\n+        }\n+\n+        Err(\"Couldnt find metadata section\".to_string())\n+    }\n+\n+    fn get_dylib_metadata(&self,\n+                          _target: &Target,\n+                          _filename: &Path)\n+                          -> Result<ErasedBoxRef<[u8]>, String> {\n+        panic!(\"Dylib metadata loading not supported without LLVM\")\n+    }\n+}\n+\n // Parse args and run the compiler. This is the primary entry point for rustc.\n // See comments on CompilerCalls below for details about the callbacks argument.\n // The FileLoader provides a way to load files from sources other than the file system.\n+#[cfg_attr(not(feature=\"llvm\"), allow(unused_mut))]\n pub fn run_compiler<'a>(args: &[String],\n                         callbacks: &mut CompilerCalls<'a>,\n                         file_loader: Option<Box<FileLoader + 'static>>,\n@@ -175,6 +232,7 @@ pub fn run_compiler<'a>(args: &[String],\n     let (sopts, cfg) = config::build_session_options_and_crate_config(&matches);\n \n     if sopts.debugging_opts.debug_llvm {\n+        #[cfg(feature=\"llvm\")]\n         rustc_trans::enable_llvm_debug();\n     }\n \n@@ -197,17 +255,19 @@ pub fn run_compiler<'a>(args: &[String],\n     };\n \n     let dep_graph = DepGraph::new(sopts.build_dep_graph());\n-    let cstore = Rc::new(CStore::new(&dep_graph, box rustc_trans::LlvmMetadataLoader));\n+    let cstore = Rc::new(CStore::new(&dep_graph, box ::MetadataLoader));\n \n     let loader = file_loader.unwrap_or(box RealFileLoader);\n     let codemap = Rc::new(CodeMap::with_file_loader(loader, sopts.file_path_mapping()));\n     let mut sess = session::build_session_with_codemap(\n         sopts, &dep_graph, input_file_path, descriptions, cstore.clone(), codemap, emitter_dest,\n     );\n+    #[cfg(feature=\"llvm\")]\n     rustc_trans::init(&sess);\n     rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n \n     let mut cfg = config::build_configuration(&sess, cfg);\n+    #[cfg(feature=\"llvm\")]\n     target_features::add_configuration(&mut cfg, &sess);\n     sess.parse_sess.config = cfg;\n \n@@ -460,6 +520,7 @@ impl<'a> CompilerCalls<'a> for RustcDefaultCalls {\n         Compilation::Continue\n     }\n \n+    #[cfg_attr(not(feature=\"llvm\"), allow(unused_mut))]\n     fn no_input(&mut self,\n                 matches: &getopts::Matches,\n                 sopts: &config::Options,\n@@ -477,15 +538,17 @@ impl<'a> CompilerCalls<'a> for RustcDefaultCalls {\n                     return None;\n                 }\n                 let dep_graph = DepGraph::new(sopts.build_dep_graph());\n-                let cstore = Rc::new(CStore::new(&dep_graph, box rustc_trans::LlvmMetadataLoader));\n+                let cstore = Rc::new(CStore::new(&dep_graph, box ::MetadataLoader));\n                 let mut sess = build_session(sopts.clone(),\n                     &dep_graph,\n                     None,\n                     descriptions.clone(),\n                     cstore.clone());\n+                #[cfg(feature=\"llvm\")]\n                 rustc_trans::init(&sess);\n                 rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n                 let mut cfg = config::build_configuration(&sess, cfg.clone());\n+                #[cfg(feature=\"llvm\")]\n                 target_features::add_configuration(&mut cfg, &sess);\n                 sess.parse_sess.config = cfg;\n                 let should_stop =\n@@ -678,14 +741,19 @@ impl RustcDefaultCalls {\n                     };\n                     let attrs = attrs.as_ref().unwrap();\n                     let t_outputs = driver::build_output_filenames(input, odir, ofile, attrs, sess);\n-                    let id = link::find_crate_name(Some(sess), attrs, input);\n+                    let id = rustc_trans_utils::link::find_crate_name(Some(sess), attrs, input);\n                     if *req == PrintRequest::CrateName {\n                         println!(\"{}\", id);\n                         continue;\n                     }\n                     let crate_types = driver::collect_crate_types(sess, attrs);\n                     for &style in &crate_types {\n-                        let fname = link::filename_for_input(sess, style, &id, &t_outputs);\n+                        let fname = rustc_trans_utils::link::filename_for_input(\n+                            sess,\n+                            style,\n+                            &id,\n+                            &t_outputs\n+                        );\n                         println!(\"{}\",\n                                  fname.file_name()\n                                       .unwrap()\n@@ -734,20 +802,25 @@ impl RustcDefaultCalls {\n                 }\n                 PrintRequest::RelocationModels => {\n                     println!(\"Available relocation models:\");\n+                    #[cfg(feature=\"llvm\")]\n                     for &(name, _) in RELOC_MODEL_ARGS.iter() {\n                         println!(\"    {}\", name);\n                     }\n                     println!(\"\");\n                 }\n                 PrintRequest::CodeModels => {\n                     println!(\"Available code models:\");\n+                    #[cfg(feature=\"llvm\")]\n                     for &(name, _) in CODE_GEN_MODEL_ARGS.iter(){\n                         println!(\"    {}\", name);\n                     }\n                     println!(\"\");\n                 }\n                 PrintRequest::TargetCPUs | PrintRequest::TargetFeatures => {\n+                    #[cfg(feature=\"llvm\")]\n                     rustc_trans::print(*req, sess);\n+                    #[cfg(not(feature=\"llvm\"))]\n+                    panic!(\"LLVM not supported by this rustc\")\n                 }\n             }\n         }\n@@ -786,6 +859,7 @@ pub fn version(binary: &str, matches: &getopts::Matches) {\n         println!(\"commit-date: {}\", unw(commit_date_str()));\n         println!(\"host: {}\", config::host_triple());\n         println!(\"release: {}\", unw(release_str()));\n+        #[cfg(feature=\"llvm\")]\n         rustc_trans::print_version();\n     }\n }\n@@ -1083,6 +1157,7 @@ pub fn handle_options(args: &[String]) -> Option<getopts::Matches> {\n     }\n \n     if cg_flags.contains(&\"passes=list\".to_string()) {\n+        #[cfg(feature=\"llvm\")]\n         rustc_trans::print_passes();\n         return None;\n     }\n@@ -1210,6 +1285,7 @@ pub fn diagnostics_registry() -> errors::registry::Registry {\n     all_errors.extend_from_slice(&rustc_borrowck::DIAGNOSTICS);\n     all_errors.extend_from_slice(&rustc_resolve::DIAGNOSTICS);\n     all_errors.extend_from_slice(&rustc_privacy::DIAGNOSTICS);\n+    #[cfg(feature=\"llvm\")]\n     all_errors.extend_from_slice(&rustc_trans::DIAGNOSTICS);\n     all_errors.extend_from_slice(&rustc_const_eval::DIAGNOSTICS);\n     all_errors.extend_from_slice(&rustc_metadata::DIAGNOSTICS);"}, {"sha": "7f65a8b97cd669b76297f14ea01d9681151982bd", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d020ff0c6854b1826233e727d4d06ef0ba526b28/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d020ff0c6854b1826233e727d4d06ef0ba526b28/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=d020ff0c6854b1826233e727d4d06ef0ba526b28", "patch": "@@ -14,6 +14,7 @@ use driver;\n use rustc::dep_graph::DepGraph;\n use rustc_lint;\n use rustc_resolve::MakeGlobMap;\n+#[cfg(feature=\"llvm\")]\n use rustc_trans;\n use rustc::middle::lang_items;\n use rustc::middle::free_region::FreeRegionMap;\n@@ -106,13 +107,14 @@ fn test_env<F>(source_string: &str,\n \n     let dep_graph = DepGraph::new(false);\n     let _ignore = dep_graph.in_ignore();\n-    let cstore = Rc::new(CStore::new(&dep_graph, box rustc_trans::LlvmMetadataLoader));\n+    let cstore = Rc::new(CStore::new(&dep_graph, box ::MetadataLoader));\n     let sess = session::build_session_(options,\n                                        &dep_graph,\n                                        None,\n                                        diagnostic_handler,\n                                        Rc::new(CodeMap::new(FilePathMapping::empty())),\n                                        cstore.clone());\n+    #[cfg(feature=\"llvm\")]\n     rustc_trans::init(&sess);\n     rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n     let input = config::Input::Str {"}, {"sha": "c870e200645400d83d089d65a6b4ed2b2461e1ed", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d020ff0c6854b1826233e727d4d06ef0ba526b28/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d020ff0c6854b1826233e727d4d06ef0ba526b28/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=d020ff0c6854b1826233e727d4d06ef0ba526b28", "patch": "@@ -94,19 +94,19 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 }\n                 block.and(Rvalue::UnaryOp(op, arg))\n             }\n-            ExprKind::Box { value, value_extents } => {\n+            ExprKind::Box { value } => {\n                 let value = this.hir.mirror(value);\n                 let result = this.temp(expr.ty, expr_span);\n                 // to start, malloc some memory of suitable type (thus far, uninitialized):\n                 let box_ = Rvalue::NullaryOp(NullOp::Box, value.ty);\n                 this.cfg.push_assign(block, source_info, &result, box_);\n-                this.in_scope((value_extents, source_info), block, |this| {\n+                if let Some(scope) = scope {\n                     // schedule a shallow free of that memory, lest we unwind:\n-                    this.schedule_box_free(expr_span, value_extents, &result, value.ty);\n-                    // initialize the box contents:\n-                    unpack!(block = this.into(&result.clone().deref(), block, value));\n-                    block.and(Rvalue::Use(Operand::Consume(result)))\n-                })\n+                    this.schedule_drop(expr_span, scope, &result, value.ty);\n+                }\n+                // initialize the box contents:\n+                unpack!(block = this.into(&result.clone().deref(), block, value));\n+                block.and(Rvalue::Use(Operand::Consume(result)))\n             }\n             ExprKind::Cast { source } => {\n                 let source = this.hir.mirror(source);"}, {"sha": "c35f709a528a2f468c09d3ab85a333381df66d20", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 3, "deletions": 122, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/d020ff0c6854b1826233e727d4d06ef0ba526b28/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d020ff0c6854b1826233e727d4d06ef0ba526b28/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=d020ff0c6854b1826233e727d4d06ef0ba526b28", "patch": "@@ -89,9 +89,6 @@ should go to.\n \n use build::{BlockAnd, BlockAndExtension, Builder, CFG};\n use rustc::middle::region::CodeExtent;\n-use rustc::middle::lang_items;\n-use rustc::middle::const_val::ConstVal;\n-use rustc::ty::subst::{Kind, Subst};\n use rustc::ty::{Ty, TyCtxt};\n use rustc::mir::*;\n use rustc::mir::transform::MirSource;\n@@ -127,21 +124,6 @@ pub struct Scope<'tcx> {\n     /// end of the vector (top of the stack) first.\n     drops: Vec<DropData<'tcx>>,\n \n-    /// A scope may only have one associated free, because:\n-    ///\n-    /// 1. We require a `free` to only be scheduled in the scope of\n-    ///    `EXPR` in `box EXPR`;\n-    /// 2. It only makes sense to have it translated into the diverge-path.\n-    ///\n-    /// This kind of drop will be run *after* all the regular drops\n-    /// scheduled onto this scope, because drops may have dependencies\n-    /// on the allocated memory.\n-    ///\n-    /// This is expected to go away once `box EXPR` becomes a sugar\n-    /// for placement protocol and gets desugared in some earlier\n-    /// stage.\n-    free: Option<FreeData<'tcx>>,\n-\n     /// The cache for drop chain on \u201cnormal\u201d exit into a particular BasicBlock.\n     cached_exits: FxHashMap<(BasicBlock, CodeExtent), BasicBlock>,\n \n@@ -181,22 +163,6 @@ enum DropKind {\n     Storage\n }\n \n-#[derive(Debug)]\n-struct FreeData<'tcx> {\n-    /// span where free obligation was incurred\n-    span: Span,\n-\n-    /// Lvalue containing the allocated box.\n-    value: Lvalue<'tcx>,\n-\n-    /// type of item for which the box was allocated for (i.e. the T in Box<T>).\n-    item_ty: Ty<'tcx>,\n-\n-    /// The cached block containing code to run the free. The block will also execute all the drops\n-    /// in the scope.\n-    cached_block: CachedBlock,\n-}\n-\n #[derive(Clone, Debug)]\n pub struct BreakableScope<'tcx> {\n     /// Extent of the loop\n@@ -258,9 +224,6 @@ impl<'tcx> Scope<'tcx> {\n                 cached_block.invalidate();\n             }\n         }\n-        if let Some(ref mut freedata) = self.free {\n-            freedata.cached_block.invalidate();\n-        }\n     }\n \n     /// Returns the cached entrypoint for diverging exit from this scope.\n@@ -278,8 +241,6 @@ impl<'tcx> Scope<'tcx> {\n         });\n         if let Some(cached_block) = drops.next() {\n             Some(cached_block.expect(\"drop cache is not filled\"))\n-        } else if let Some(ref data) = self.free {\n-            Some(data.cached_block.get(generator_drop).expect(\"free cache is not filled\"))\n         } else {\n             None\n         }\n@@ -369,7 +330,6 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             extent_span: extent.1.span,\n             needs_cleanup: false,\n             drops: vec![],\n-            free: None,\n             cached_generator_drop: None,\n             cached_exits: FxHashMap()\n         });\n@@ -420,7 +380,6 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         });\n         let len = self.scopes.len();\n         assert!(scope_count < len, \"should not use `exit_scope` to pop ALL scopes\");\n-        let tmp = self.get_unit_temp();\n \n         // If we are emitting a `drop` statement, we need to have the cached\n         // diverge cleanup pads ready in case that drop panics.\n@@ -454,13 +413,6 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n             // End all regions for scopes out of which we are breaking.\n             self.cfg.push_end_region(block, extent.1, scope.extent);\n-\n-            if let Some(ref free_data) = scope.free {\n-                let next = self.cfg.start_new_block();\n-                let free = build_free(self.hir.tcx(), &tmp, free_data, next);\n-                self.cfg.terminate(block, scope.source_info(free_data.span), free);\n-                block = next;\n-            }\n         }\n         }\n         let scope = &self.scopes[len - scope_count];\n@@ -704,36 +656,6 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         span_bug!(span, \"extent {:?} not in scope to drop {:?}\", extent, lvalue);\n     }\n \n-    /// Schedule dropping of a not-yet-fully-initialised box.\n-    ///\n-    /// This cleanup will only be translated into unwind branch.\n-    /// The extent should be for the `EXPR` inside `box EXPR`.\n-    /// There may only be one \u201cfree\u201d scheduled in any given scope.\n-    pub fn schedule_box_free(&mut self,\n-                             span: Span,\n-                             extent: CodeExtent,\n-                             value: &Lvalue<'tcx>,\n-                             item_ty: Ty<'tcx>) {\n-        for scope in self.scopes.iter_mut().rev() {\n-            // See the comment in schedule_drop above. The primary difference is that we invalidate\n-            // the unwind blocks unconditionally. That\u2019s because the box free may be considered\n-            // outer-most cleanup within the scope.\n-            scope.invalidate_cache(true);\n-            if scope.extent == extent {\n-                assert!(scope.free.is_none(), \"scope already has a scheduled free!\");\n-                scope.needs_cleanup = true;\n-                scope.free = Some(FreeData {\n-                    span: span,\n-                    value: value.clone(),\n-                    item_ty: item_ty,\n-                    cached_block: CachedBlock::default(),\n-                });\n-                return;\n-            }\n-        }\n-        span_bug!(span, \"extent {:?} not in scope to free {:?}\", extent, value);\n-    }\n-\n     // Other\n     // =====\n     /// Creates a path that performs all required cleanup for unwinding.\n@@ -751,7 +673,6 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         }\n         assert!(!self.scopes.is_empty()); // or `any` above would be false\n \n-        let unit_temp = self.get_unit_temp();\n         let Builder { ref mut hir, ref mut cfg, ref mut scopes,\n                       ref mut cached_resume_block, .. } = *self;\n \n@@ -779,13 +700,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         };\n \n         for scope in scopes.iter_mut() {\n-            target = build_diverge_scope(hir.tcx(),\n-                                         cfg,\n-                                         &unit_temp,\n-                                         scope.extent_span,\n-                                         scope,\n-                                         target,\n-                                         generator_drop);\n+            target = build_diverge_scope(\n+                hir.tcx(), cfg, scope.extent_span, scope, target, generator_drop);\n         }\n         Some(target)\n     }\n@@ -921,9 +837,8 @@ fn build_scope_drops<'tcx>(cfg: &mut CFG<'tcx>,\n     block.unit()\n }\n \n-fn build_diverge_scope<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+fn build_diverge_scope<'a, 'gcx, 'tcx>(_tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                                        cfg: &mut CFG<'tcx>,\n-                                       unit_temp: &Lvalue<'tcx>,\n                                        span: Span,\n                                        scope: &mut Scope<'tcx>,\n                                        mut target: BasicBlock,\n@@ -949,19 +864,6 @@ fn build_diverge_scope<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n         scope: visibility_scope\n     };\n \n-    // Next, build up any free.\n-    if let Some(ref mut free_data) = scope.free {\n-        target = if let Some(cached_block) = free_data.cached_block.get(generator_drop) {\n-            cached_block\n-        } else {\n-            let into = cfg.start_new_cleanup_block();\n-            cfg.terminate(into, source_info(free_data.span),\n-                          build_free(tcx, unit_temp, free_data, target));\n-            *free_data.cached_block.ref_mut(generator_drop) = Some(into);\n-            into\n-        };\n-    }\n-\n     // Next, build up the drops. Here we iterate the vector in\n     // *forward* order, so that we generate drops[0] first (right to\n     // left in diagram above).\n@@ -1005,24 +907,3 @@ fn build_diverge_scope<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n \n     target\n }\n-\n-fn build_free<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                              unit_temp: &Lvalue<'tcx>,\n-                              data: &FreeData<'tcx>,\n-                              target: BasicBlock)\n-                              -> TerminatorKind<'tcx> {\n-    let free_func = tcx.require_lang_item(lang_items::BoxFreeFnLangItem);\n-    let substs = tcx.intern_substs(&[Kind::from(data.item_ty)]);\n-    TerminatorKind::Call {\n-        func: Operand::Constant(box Constant {\n-            span: data.span,\n-            ty: tcx.type_of(free_func).subst(tcx, substs),\n-            literal: Literal::Value {\n-                value: ConstVal::Function(free_func, substs),\n-            }\n-        }),\n-        args: vec![Operand::Consume(data.value.clone())],\n-        destination: Some((unit_temp.clone(), target)),\n-        cleanup: None\n-    }\n-}"}, {"sha": "890fe3c091ab2f166a62c835b8897d1a6d39c272", "filename": "src/librustc_mir/dataflow/drop_flag_effects.rs", "status": "modified", "additions": 18, "deletions": 8, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/d020ff0c6854b1826233e727d4d06ef0ba526b28/src%2Flibrustc_mir%2Fdataflow%2Fdrop_flag_effects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d020ff0c6854b1826233e727d4d06ef0ba526b28/src%2Flibrustc_mir%2Fdataflow%2Fdrop_flag_effects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fdrop_flag_effects.rs?ref=d020ff0c6854b1826233e727d4d06ef0ba526b28", "patch": "@@ -240,7 +240,7 @@ pub(crate) fn drop_flag_effects_for_function_entry<'a, 'tcx, F>(\n         let lookup_result = move_data.rev_lookup.find(&lvalue);\n         on_lookup_result_bits(tcx, mir, move_data,\n                               lookup_result,\n-                              |moi| callback(moi, DropFlagState::Present));\n+                              |mpi| callback(mpi, DropFlagState::Present));\n     }\n }\n \n@@ -270,7 +270,7 @@ pub(crate) fn drop_flag_effects_for_location<'a, 'tcx, F>(\n \n         on_all_children_bits(tcx, mir, move_data,\n                              path,\n-                             |moi| callback(moi, DropFlagState::Absent))\n+                             |mpi| callback(mpi, DropFlagState::Absent))\n     }\n \n     let block = &mir[loc.block];\n@@ -279,11 +279,21 @@ pub(crate) fn drop_flag_effects_for_location<'a, 'tcx, F>(\n             mir::StatementKind::SetDiscriminant{ .. } => {\n                 span_bug!(stmt.source_info.span, \"SetDiscrimant should not exist during borrowck\");\n             }\n-            mir::StatementKind::Assign(ref lvalue, _) => {\n-                debug!(\"drop_flag_effects: assignment {:?}\", stmt);\n-                 on_lookup_result_bits(tcx, mir, move_data,\n-                                       move_data.rev_lookup.find(lvalue),\n-                                       |moi| callback(moi, DropFlagState::Present))\n+            mir::StatementKind::Assign(ref lvalue, ref rvalue) => {\n+                match rvalue.initialization_state() {\n+                    mir::tcx::RvalueInitializationState::Shallow => {\n+                        debug!(\"drop_flag_effects: box assignment {:?}\", stmt);\n+                        if let LookupResult::Exact(mpi) = move_data.rev_lookup.find(lvalue) {\n+                            callback(mpi, DropFlagState::Present);\n+                        }\n+                    }\n+                    mir::tcx::RvalueInitializationState::Deep => {\n+                        debug!(\"drop_flag_effects: assignment {:?}\", stmt);\n+                        on_lookup_result_bits(tcx, mir, move_data,\n+                                              move_data.rev_lookup.find(lvalue),\n+                                              |mpi| callback(mpi, DropFlagState::Present))\n+                    }\n+                }\n             }\n             mir::StatementKind::StorageLive(_) |\n             mir::StatementKind::StorageDead(_) |\n@@ -298,7 +308,7 @@ pub(crate) fn drop_flag_effects_for_location<'a, 'tcx, F>(\n                 mir::TerminatorKind::DropAndReplace { ref location, .. } => {\n                     on_lookup_result_bits(tcx, mir, move_data,\n                                           move_data.rev_lookup.find(location),\n-                                          |moi| callback(moi, DropFlagState::Present))\n+                                          |mpi| callback(mpi, DropFlagState::Present))\n                 }\n                 _ => {\n                     // other terminators do not contain move-ins"}, {"sha": "d68e64abe4f2ddf0f1ca4693f18d7bce2ff8ef2e", "filename": "src/librustc_mir/dataflow/impls/mod.rs", "status": "modified", "additions": 22, "deletions": 9, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/d020ff0c6854b1826233e727d4d06ef0ba526b28/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d020ff0c6854b1826233e727d4d06ef0ba526b28/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs?ref=d020ff0c6854b1826233e727d4d06ef0ba526b28", "patch": "@@ -23,6 +23,7 @@ use super::MoveDataParamEnv;\n use util::elaborate_drops::DropFlagState;\n \n use super::move_paths::{HasMoveData, MoveData, MoveOutIndex, MovePathIndex};\n+use super::move_paths::LookupResult;\n use super::{BitDenotation, BlockSets, DataflowOperator};\n \n use super::drop_flag_effects_for_function_entry;\n@@ -469,18 +470,30 @@ impl<'a, 'tcx> BitDenotation for MovingOutStatements<'a, 'tcx> {\n             mir::StatementKind::SetDiscriminant { .. } => {\n                 span_bug!(stmt.source_info.span, \"SetDiscriminant should not exist in borrowck\");\n             }\n-            mir::StatementKind::Assign(ref lvalue, _) => {\n+            mir::StatementKind::Assign(ref lvalue, ref rvalue) => {\n                 // assigning into this `lvalue` kills all\n                 // MoveOuts from it, and *also* all MoveOuts\n                 // for children and associated fragment sets.\n-                on_lookup_result_bits(tcx,\n-                                     mir,\n-                                     move_data,\n-                                     rev_lookup.find(lvalue),\n-                                     |mpi| for moi in &path_map[mpi] {\n-                                         assert!(moi.index() < bits_per_block);\n-                                         sets.kill_set.add(&moi);\n-                                     });\n+                match rvalue.initialization_state() {\n+                    mir::tcx::RvalueInitializationState::Shallow => {\n+                        if let LookupResult::Exact(mpi) = rev_lookup.find(lvalue) {\n+                             for moi in &path_map[mpi] {\n+                                 assert!(moi.index() < bits_per_block);\n+                                 sets.kill_set.add(&moi);\n+                             }\n+                        }\n+                    }\n+                    mir::tcx::RvalueInitializationState::Deep => {\n+                        on_lookup_result_bits(tcx,\n+                                              mir,\n+                                              move_data,\n+                                              rev_lookup.find(lvalue),\n+                                              |mpi| for moi in &path_map[mpi] {\n+                                                  assert!(moi.index() < bits_per_block);\n+                                                  sets.kill_set.add(&moi);\n+                                              });\n+                    }\n+                }\n             }\n             mir::StatementKind::StorageLive(_) |\n             mir::StatementKind::StorageDead(_) |"}, {"sha": "01ce77bce13c11dec77b5af490a1dc4ac31784d9", "filename": "src/librustc_mir/dataflow/move_paths/mod.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d020ff0c6854b1826233e727d4d06ef0ba526b28/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d020ff0c6854b1826233e727d4d06ef0ba526b28/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs?ref=d020ff0c6854b1826233e727d4d06ef0ba526b28", "patch": "@@ -11,6 +11,7 @@\n \n use rustc::ty::{self, TyCtxt};\n use rustc::mir::*;\n+use rustc::mir::tcx::RvalueInitializationState;\n use rustc::util::nodemap::FxHashMap;\n use rustc_data_structures::indexed_vec::{IndexVec};\n \n@@ -406,6 +407,12 @@ impl<'a, 'tcx> MoveDataBuilder<'a, 'tcx> {\n         match stmt.kind {\n             StatementKind::Assign(ref lval, ref rval) => {\n                 self.create_move_path(lval);\n+                if let RvalueInitializationState::Shallow = rval.initialization_state() {\n+                    // Box starts out uninitialized - need to create a separate\n+                    // move-path for the interior so it will be separate from\n+                    // the exterior.\n+                    self.create_move_path(&lval.clone().deref());\n+                }\n                 self.gather_rvalue(loc, rval);\n             }\n             StatementKind::StorageLive(_) |"}, {"sha": "231e2fb68e65ca175234389f56f42a59cf9c1348", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d020ff0c6854b1826233e727d4d06ef0ba526b28/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d020ff0c6854b1826233e727d4d06ef0ba526b28/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=d020ff0c6854b1826233e727d4d06ef0ba526b28", "patch": "@@ -561,7 +561,6 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         hir::ExprBox(ref value) => {\n             ExprKind::Box {\n                 value: value.to_ref(),\n-                value_extents: CodeExtent::Misc(value.id),\n             }\n         }\n         hir::ExprArray(ref fields) => ExprKind::Array { fields: fields.to_ref() },"}, {"sha": "073b32ae7fa321a7b7d3963bf52084fe810664aa", "filename": "src/librustc_mir/hair/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d020ff0c6854b1826233e727d4d06ef0ba526b28/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d020ff0c6854b1826233e727d4d06ef0ba526b28/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fmod.rs?ref=d020ff0c6854b1826233e727d4d06ef0ba526b28", "patch": "@@ -116,7 +116,6 @@ pub enum ExprKind<'tcx> {\n     },\n     Box {\n         value: ExprRef<'tcx>,\n-        value_extents: CodeExtent,\n     },\n     Call {\n         ty: ty::Ty<'tcx>,"}, {"sha": "4a92a5798604af01b25330400c3873acc0b0a3ea", "filename": "src/librustc_trans/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d020ff0c6854b1826233e727d4d06ef0ba526b28/src%2Flibrustc_trans%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/d020ff0c6854b1826233e727d4d06ef0ba526b28/src%2Flibrustc_trans%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2FCargo.toml?ref=d020ff0c6854b1826233e727d4d06ef0ba526b28", "patch": "@@ -26,6 +26,7 @@ rustc_errors = { path = \"../librustc_errors\" }\n rustc_incremental = { path = \"../librustc_incremental\" }\n rustc_llvm = { path = \"../librustc_llvm\" }\n rustc_platform_intrinsics = { path = \"../librustc_platform_intrinsics\" }\n+rustc_trans_utils = { path = \"../librustc_trans_utils\" }\n serialize = { path = \"../libserialize\" }\n syntax = { path = \"../libsyntax\" }\n syntax_pos = { path = \"../libsyntax_pos\" }"}, {"sha": "a9bd8ea90109e24316c7b4a150802d389c36a95b", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 6, "deletions": 120, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/d020ff0c6854b1826233e727d4d06ef0ba526b28/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d020ff0c6854b1826233e727d4d06ef0ba526b28/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=d020ff0c6854b1826233e727d4d06ef0ba526b28", "patch": "@@ -8,16 +8,18 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+extern crate rustc_trans_utils;\n+\n use super::archive::{ArchiveBuilder, ArchiveConfig};\n use super::linker::Linker;\n use super::rpath::RPathConfig;\n use super::rpath;\n use metadata::METADATA_FILENAME;\n-use rustc::session::config::{self, NoDebugInfo, OutputFilenames, Input, OutputType};\n+use rustc::session::config::{self, NoDebugInfo, OutputFilenames, OutputType};\n use rustc::session::filesearch;\n use rustc::session::search_paths::PathKind;\n use rustc::session::Session;\n-use rustc::middle::cstore::{self, LinkMeta, NativeLibrary, LibSource, LinkagePreference,\n+use rustc::middle::cstore::{LinkMeta, NativeLibrary, LibSource, LinkagePreference,\n                             NativeLibraryKind};\n use rustc::middle::dependency_format::Linkage;\n use CrateTranslation;\n@@ -44,9 +46,7 @@ use std::process::Command;\n use std::str;\n use flate2::Compression;\n use flate2::write::DeflateEncoder;\n-use syntax::ast;\n use syntax::attr;\n-use syntax_pos::Span;\n \n /// The LLVM module name containing crate-metadata. This includes a `.` on\n /// purpose, so it cannot clash with the name of a user-defined module.\n@@ -88,55 +88,8 @@ pub const RLIB_BYTECODE_OBJECT_V1_DATASIZE_OFFSET: usize =\n pub const RLIB_BYTECODE_OBJECT_V1_DATA_OFFSET: usize =\n     RLIB_BYTECODE_OBJECT_V1_DATASIZE_OFFSET + 8;\n \n-\n-pub fn find_crate_name(sess: Option<&Session>,\n-                       attrs: &[ast::Attribute],\n-                       input: &Input) -> String {\n-    let validate = |s: String, span: Option<Span>| {\n-        cstore::validate_crate_name(sess, &s, span);\n-        s\n-    };\n-\n-    // Look in attributes 100% of the time to make sure the attribute is marked\n-    // as used. After doing this, however, we still prioritize a crate name from\n-    // the command line over one found in the #[crate_name] attribute. If we\n-    // find both we ensure that they're the same later on as well.\n-    let attr_crate_name = attrs.iter().find(|at| at.check_name(\"crate_name\"))\n-                               .and_then(|at| at.value_str().map(|s| (at, s)));\n-\n-    if let Some(sess) = sess {\n-        if let Some(ref s) = sess.opts.crate_name {\n-            if let Some((attr, name)) = attr_crate_name {\n-                if name != &**s {\n-                    let msg = format!(\"--crate-name and #[crate_name] are \\\n-                                       required to match, but `{}` != `{}`\",\n-                                      s, name);\n-                    sess.span_err(attr.span, &msg);\n-                }\n-            }\n-            return validate(s.clone(), None);\n-        }\n-    }\n-\n-    if let Some((attr, s)) = attr_crate_name {\n-        return validate(s.to_string(), Some(attr.span));\n-    }\n-    if let Input::File(ref path) = *input {\n-        if let Some(s) = path.file_stem().and_then(|s| s.to_str()) {\n-            if s.starts_with(\"-\") {\n-                let msg = format!(\"crate names cannot start with a `-`, but \\\n-                                   `{}` has a leading hyphen\", s);\n-                if let Some(sess) = sess {\n-                    sess.err(&msg);\n-                }\n-            } else {\n-                return validate(s.replace(\"-\", \"_\"), None);\n-            }\n-        }\n-    }\n-\n-    \"rust_out\".to_string()\n-}\n+pub use self::rustc_trans_utils::link::{find_crate_name, filename_for_input,\n+                                        default_output_for_target, invalid_output_for_target};\n \n pub fn build_link_meta(incremental_hashes_map: &IncrementalHashesMap) -> LinkMeta {\n     let krate_dep_node = &DepNode::new_no_params(DepKind::Krate);\n@@ -252,37 +205,6 @@ pub fn link_binary(sess: &Session,\n     out_filenames\n }\n \n-\n-/// Returns default crate type for target\n-///\n-/// Default crate type is used when crate type isn't provided neither\n-/// through cmd line arguments nor through crate attributes\n-///\n-/// It is CrateTypeExecutable for all platforms but iOS as there is no\n-/// way to run iOS binaries anyway without jailbreaking and\n-/// interaction with Rust code through static library is the only\n-/// option for now\n-pub fn default_output_for_target(sess: &Session) -> config::CrateType {\n-    if !sess.target.target.options.executables {\n-        config::CrateTypeStaticlib\n-    } else {\n-        config::CrateTypeExecutable\n-    }\n-}\n-\n-/// Checks if target supports crate_type as output\n-pub fn invalid_output_for_target(sess: &Session,\n-                                 crate_type: config::CrateType) -> bool {\n-    match (sess.target.target.options.dynamic_linking,\n-           sess.target.target.options.executables, crate_type) {\n-        (false, _, config::CrateTypeCdylib) |\n-        (false, _, config::CrateTypeProcMacro) |\n-        (false, _, config::CrateTypeDylib) => true,\n-        (_, false, config::CrateTypeExecutable) => true,\n-        _ => false\n-    }\n-}\n-\n fn is_writeable(p: &Path) -> bool {\n     match p.metadata() {\n         Err(..) => true,\n@@ -299,42 +221,6 @@ fn filename_for_metadata(sess: &Session, crate_name: &str, outputs: &OutputFilen\n     out_filename\n }\n \n-pub fn filename_for_input(sess: &Session,\n-                          crate_type: config::CrateType,\n-                          crate_name: &str,\n-                          outputs: &OutputFilenames) -> PathBuf {\n-    let libname = format!(\"{}{}\", crate_name, sess.opts.cg.extra_filename);\n-\n-    match crate_type {\n-        config::CrateTypeRlib => {\n-            outputs.out_directory.join(&format!(\"lib{}.rlib\", libname))\n-        }\n-        config::CrateTypeCdylib |\n-        config::CrateTypeProcMacro |\n-        config::CrateTypeDylib => {\n-            let (prefix, suffix) = (&sess.target.target.options.dll_prefix,\n-                                    &sess.target.target.options.dll_suffix);\n-            outputs.out_directory.join(&format!(\"{}{}{}\", prefix, libname,\n-                                                suffix))\n-        }\n-        config::CrateTypeStaticlib => {\n-            let (prefix, suffix) = (&sess.target.target.options.staticlib_prefix,\n-                                    &sess.target.target.options.staticlib_suffix);\n-            outputs.out_directory.join(&format!(\"{}{}{}\", prefix, libname,\n-                                                suffix))\n-        }\n-        config::CrateTypeExecutable => {\n-            let suffix = &sess.target.target.options.exe_suffix;\n-            let out_filename = outputs.path(OutputType::Exe);\n-            if suffix.is_empty() {\n-                out_filename.to_path_buf()\n-            } else {\n-                out_filename.with_extension(&suffix[1..])\n-            }\n-        }\n-    }\n-}\n-\n pub fn each_linked_rlib(sess: &Session,\n                         f: &mut FnMut(CrateNum, &Path)) -> Result<(), String> {\n     let crates = sess.cstore.used_crates(LinkagePreference::RequireStatic).into_iter();"}, {"sha": "94cae37761fe2bf36cd54e6246eedb10392f2c78", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d020ff0c6854b1826233e727d4d06ef0ba526b28/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d020ff0c6854b1826233e727d4d06ef0ba526b28/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=d020ff0c6854b1826233e727d4d06ef0ba526b28", "patch": "@@ -1356,6 +1356,16 @@ fn start_executing_work(sess: &Session,\n                             maybe_start_llvm_timer(&item, &mut llvm_start_time);\n                             main_thread_worker_state = MainThreadWorkerState::LLVMing;\n                             spawn_work(cgcx, item);\n+                        } else {\n+                            // There is no unstarted work, so let the main thread\n+                            // take over for a running worker. Otherwise the\n+                            // implicit token would just go to waste.\n+                            // We reduce the `running` counter by one. The\n+                            // `tokens.truncate()` below will take care of\n+                            // giving the Token back.\n+                            debug_assert!(running > 0);\n+                            running -= 1;\n+                            main_thread_worker_state = MainThreadWorkerState::LLVMing;\n                         }\n                     }\n                     MainThreadWorkerState::Translating => {"}, {"sha": "f026d4fcbc2806fbc43e5a7dc43958e6171818bb", "filename": "src/librustc_trans_utils/Cargo.toml", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d020ff0c6854b1826233e727d4d06ef0ba526b28/src%2Flibrustc_trans_utils%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/d020ff0c6854b1826233e727d4d06ef0ba526b28/src%2Flibrustc_trans_utils%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans_utils%2FCargo.toml?ref=d020ff0c6854b1826233e727d4d06ef0ba526b28", "patch": "@@ -0,0 +1,15 @@\n+[package]\n+authors = [\"The Rust Project Developers\"]\n+name = \"rustc_trans_utils\"\n+version = \"0.0.0\"\n+\n+[lib]\n+name = \"rustc_trans_utils\"\n+path = \"lib.rs\"\n+crate-type = [\"dylib\"]\n+test = false\n+\n+[dependencies]\n+rustc = { path = \"../librustc\" }\n+syntax = { path = \"../libsyntax\" }\n+syntax_pos = { path = \"../libsyntax_pos\" }"}, {"sha": "81e83076f8c0c9812f0059455aa36e08648811d5", "filename": "src/librustc_trans_utils/lib.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/d020ff0c6854b1826233e727d4d06ef0ba526b28/src%2Flibrustc_trans_utils%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d020ff0c6854b1826233e727d4d06ef0ba526b28/src%2Flibrustc_trans_utils%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans_utils%2Flib.rs?ref=d020ff0c6854b1826233e727d4d06ef0ba526b28", "patch": "@@ -0,0 +1,38 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! # Note\n+//!\n+//! This API is completely unstable and subject to change.\n+\n+#![crate_name = \"rustc_trans_utils\"]\n+#![crate_type = \"dylib\"]\n+#![crate_type = \"rlib\"]\n+#![doc(html_logo_url = \"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n+      html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n+      html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n+#![deny(warnings)]\n+\n+#![feature(box_patterns)]\n+#![feature(box_syntax)]\n+#![feature(const_fn)]\n+#![feature(custom_attribute)]\n+#![allow(unused_attributes)]\n+#![feature(i128_type)]\n+#![feature(quote)]\n+#![feature(rustc_diagnostic_macros)]\n+#![feature(slice_patterns)]\n+#![feature(conservative_impl_trait)]\n+\n+extern crate rustc;\n+extern crate syntax;\n+extern crate syntax_pos;\n+\n+pub mod link;"}, {"sha": "29bb062d34cf6212833d8f8c66a79a3fdee53193", "filename": "src/librustc_trans_utils/link.rs", "status": "added", "additions": 154, "deletions": 0, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/d020ff0c6854b1826233e727d4d06ef0ba526b28/src%2Flibrustc_trans_utils%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d020ff0c6854b1826233e727d4d06ef0ba526b28/src%2Flibrustc_trans_utils%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans_utils%2Flink.rs?ref=d020ff0c6854b1826233e727d4d06ef0ba526b28", "patch": "@@ -0,0 +1,154 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use rustc::session::config::{self, /*NoDebugInfo,*/ OutputFilenames, Input, OutputType};\n+/*use rustc::session::filesearch;\n+use rustc::session::search_paths::PathKind;\n+*/use rustc::session::Session;\n+use rustc::middle::cstore;/*::{self, LinkMeta, NativeLibrary, LibSource, LinkagePreference,\n+                            NativeLibraryKind};*/\n+/*use rustc::middle::dependency_format::Linkage;\n+use rustc::util::common::time;\n+use rustc::util::fs::fix_windows_verbatim_for_gcc;\n+use rustc::dep_graph::{DepKind, DepNode};\n+use rustc::hir::def_id::CrateNum;\n+use rustc::hir::svh::Svh;\n+use rustc_back::tempdir::TempDir;\n+use rustc_back::{PanicStrategy, RelroLevel};\n+use rustc_incremental::IncrementalHashesMap;*/\n+\n+/*use std::ascii;\n+use std::char;\n+use std::env;\n+use std::ffi::OsString;\n+use std::fs;\n+use std::io::{self, Read, Write};\n+use std::mem;\n+*/use std::path::PathBuf;/*{Path, PathBuf};\n+use std::process::Command;\n+use std::str;*/\n+use syntax::ast;\n+//use syntax::attr;\n+use syntax_pos::Span;\n+\n+pub fn find_crate_name(sess: Option<&Session>,\n+                       attrs: &[ast::Attribute],\n+                       input: &Input) -> String {\n+    let validate = |s: String, span: Option<Span>| {\n+        cstore::validate_crate_name(sess, &s, span);\n+        s\n+    };\n+\n+    // Look in attributes 100% of the time to make sure the attribute is marked\n+    // as used. After doing this, however, we still prioritize a crate name from\n+    // the command line over one found in the #[crate_name] attribute. If we\n+    // find both we ensure that they're the same later on as well.\n+    let attr_crate_name = attrs.iter().find(|at| at.check_name(\"crate_name\"))\n+                               .and_then(|at| at.value_str().map(|s| (at, s)));\n+\n+    if let Some(sess) = sess {\n+        if let Some(ref s) = sess.opts.crate_name {\n+            if let Some((attr, name)) = attr_crate_name {\n+                if name != &**s {\n+                    let msg = format!(\"--crate-name and #[crate_name] are \\\n+                                       required to match, but `{}` != `{}`\",\n+                                      s, name);\n+                    sess.span_err(attr.span, &msg);\n+                }\n+            }\n+            return validate(s.clone(), None);\n+        }\n+    }\n+\n+    if let Some((attr, s)) = attr_crate_name {\n+        return validate(s.to_string(), Some(attr.span));\n+    }\n+    if let Input::File(ref path) = *input {\n+        if let Some(s) = path.file_stem().and_then(|s| s.to_str()) {\n+            if s.starts_with(\"-\") {\n+                let msg = format!(\"crate names cannot start with a `-`, but \\\n+                                   `{}` has a leading hyphen\", s);\n+                if let Some(sess) = sess {\n+                    sess.err(&msg);\n+                }\n+            } else {\n+                return validate(s.replace(\"-\", \"_\"), None);\n+            }\n+        }\n+    }\n+\n+    \"rust_out\".to_string()\n+}\n+\n+pub fn filename_for_input(sess: &Session,\n+                          crate_type: config::CrateType,\n+                          crate_name: &str,\n+                          outputs: &OutputFilenames) -> PathBuf {\n+    let libname = format!(\"{}{}\", crate_name, sess.opts.cg.extra_filename);\n+\n+    match crate_type {\n+        config::CrateTypeRlib => {\n+            outputs.out_directory.join(&format!(\"lib{}.rlib\", libname))\n+        }\n+        config::CrateTypeCdylib |\n+        config::CrateTypeProcMacro |\n+        config::CrateTypeDylib => {\n+            let (prefix, suffix) = (&sess.target.target.options.dll_prefix,\n+                                    &sess.target.target.options.dll_suffix);\n+            outputs.out_directory.join(&format!(\"{}{}{}\", prefix, libname,\n+                                                suffix))\n+        }\n+        config::CrateTypeStaticlib => {\n+            let (prefix, suffix) = (&sess.target.target.options.staticlib_prefix,\n+                                    &sess.target.target.options.staticlib_suffix);\n+            outputs.out_directory.join(&format!(\"{}{}{}\", prefix, libname,\n+                                                suffix))\n+        }\n+        config::CrateTypeExecutable => {\n+            let suffix = &sess.target.target.options.exe_suffix;\n+            let out_filename = outputs.path(OutputType::Exe);\n+            if suffix.is_empty() {\n+                out_filename.to_path_buf()\n+            } else {\n+                out_filename.with_extension(&suffix[1..])\n+            }\n+        }\n+    }\n+}\n+\n+/// Returns default crate type for target\n+///\n+/// Default crate type is used when crate type isn't provided neither\n+/// through cmd line arguments nor through crate attributes\n+///\n+/// It is CrateTypeExecutable for all platforms but iOS as there is no\n+/// way to run iOS binaries anyway without jailbreaking and\n+/// interaction with Rust code through static library is the only\n+/// option for now\n+pub fn default_output_for_target(sess: &Session) -> config::CrateType {\n+    if !sess.target.target.options.executables {\n+        config::CrateTypeStaticlib\n+    } else {\n+        config::CrateTypeExecutable\n+    }\n+}\n+\n+/// Checks if target supports crate_type as output\n+pub fn invalid_output_for_target(sess: &Session,\n+                                 crate_type: config::CrateType) -> bool {\n+    match (sess.target.target.options.dynamic_linking,\n+           sess.target.target.options.executables, crate_type) {\n+        (false, _, config::CrateTypeCdylib) |\n+        (false, _, config::CrateTypeProcMacro) |\n+        (false, _, config::CrateTypeDylib) => true,\n+        (_, false, config::CrateTypeExecutable) => true,\n+        _ => false\n+    }\n+}"}, {"sha": "d185c061d5bd9fb6656b7240de820824447d2137", "filename": "src/rustc/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d020ff0c6854b1826233e727d4d06ef0ba526b28/src%2Frustc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/d020ff0c6854b1826233e727d4d06ef0ba526b28/src%2Frustc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2FCargo.toml?ref=d020ff0c6854b1826233e727d4d06ef0ba526b28", "patch": "@@ -15,3 +15,4 @@ rustc_driver = { path = \"../librustc_driver\" }\n \n [features]\n jemalloc = [\"rustc_back/jemalloc\"]\n+llvm = [\"rustc_driver/llvm\"]"}, {"sha": "0b34231b4eec6b0fc84ce5752619e1466f1a3427", "filename": "src/test/mir-opt/end_region_4.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d020ff0c6854b1826233e727d4d06ef0ba526b28/src%2Ftest%2Fmir-opt%2Fend_region_4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d020ff0c6854b1826233e727d4d06ef0ba526b28/src%2Ftest%2Fmir-opt%2Fend_region_4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fend_region_4.rs?ref=d020ff0c6854b1826233e727d4d06ef0ba526b28", "patch": "@@ -34,10 +34,9 @@ fn foo(i: i32) {\n //     let _1: D;\n //     let _2: i32;\n //     let _3: &'6_2rce i32;\n-//     let _7: &'6_4rce i32;\n+//     let _6: &'6_4rce i32;\n //     let mut _4: ();\n //     let mut _5: i32;\n-//     let mut _6: ();\n //     bb0: {\n //         StorageLive(_1);\n //         _1 = D::{{constructor}}(const 0i32,);\n@@ -51,10 +50,10 @@ fn foo(i: i32) {\n //     }\n //     bb1: {\n //         StorageDead(_5);\n-//         StorageLive(_7);\n-//         _7 = &'6_4rce _2;\n+//         StorageLive(_6);\n+//         _6 = &'6_4rce _2;\n //         _0 = ();\n-//         StorageDead(_7);\n+//         StorageDead(_6);\n //         EndRegion('6_4rce);\n //         StorageDead(_3);\n //         EndRegion('6_2rce);"}, {"sha": "e51bb9350db60520aa52886a4f811606c84ffec5", "filename": "src/test/mir-opt/end_region_5.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d020ff0c6854b1826233e727d4d06ef0ba526b28/src%2Ftest%2Fmir-opt%2Fend_region_5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d020ff0c6854b1826233e727d4d06ef0ba526b28/src%2Ftest%2Fmir-opt%2Fend_region_5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fend_region_5.rs?ref=d020ff0c6854b1826233e727d4d06ef0ba526b28", "patch": "@@ -33,7 +33,6 @@ fn foo<F>(f: F) where F: FnOnce() -> i32 {\n //     let mut _2: ();\n //     let mut _3: [closure@NodeId(18) d:&'19mce D];\n //     let mut _4: &'19mce D;\n-//     let mut _5: ();\n //     bb0: {\n //         StorageLive(_1);\n //         _1 = D::{{constructor}}(const 0i32,);"}, {"sha": "c55e6d105cbdc3fe9c8d4c5ba83ca1568f172731", "filename": "src/test/mir-opt/end_region_6.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d020ff0c6854b1826233e727d4d06ef0ba526b28/src%2Ftest%2Fmir-opt%2Fend_region_6.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d020ff0c6854b1826233e727d4d06ef0ba526b28/src%2Ftest%2Fmir-opt%2Fend_region_6.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fend_region_6.rs?ref=d020ff0c6854b1826233e727d4d06ef0ba526b28", "patch": "@@ -33,7 +33,6 @@ fn foo<F>(f: F) where F: FnOnce() -> i32 {\n //     let mut _2: ();\n //     let mut _3: [closure@NodeId(22) d:&'23mce D];\n //     let mut _4: &'23mce D;\n-//     let mut _5: ();\n //     bb0: {\n //         StorageLive(_1);\n //         _1 = D::{{constructor}}(const 0i32,);"}, {"sha": "9c8e3ec08d498956b271f04d2e54ef62e85f3011", "filename": "src/test/mir-opt/end_region_7.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d020ff0c6854b1826233e727d4d06ef0ba526b28/src%2Ftest%2Fmir-opt%2Fend_region_7.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d020ff0c6854b1826233e727d4d06ef0ba526b28/src%2Ftest%2Fmir-opt%2Fend_region_7.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fend_region_7.rs?ref=d020ff0c6854b1826233e727d4d06ef0ba526b28", "patch": "@@ -33,7 +33,6 @@ fn foo<F>(f: F) where F: FnOnce() -> i32 {\n //     let mut _2: ();\n //     let mut _3: [closure@NodeId(22) d:D];\n //     let mut _4: D;\n-//     let mut _5: ();\n //\n //     bb0: {\n //         StorageLive(_1);\n@@ -77,7 +76,6 @@ fn foo<F>(f: F) where F: FnOnce() -> i32 {\n //     let mut _0: i32;\n //     let _2: &'14_0rce D;\n //     let mut _3: i32;\n-//     let mut _4: ();\n //\n //     bb0: {\n //         StorageLive(_2);"}, {"sha": "b4dbec5cd2dd7ec5e159feb418640a8459f54303", "filename": "src/test/mir-opt/end_region_8.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d020ff0c6854b1826233e727d4d06ef0ba526b28/src%2Ftest%2Fmir-opt%2Fend_region_8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d020ff0c6854b1826233e727d4d06ef0ba526b28/src%2Ftest%2Fmir-opt%2Fend_region_8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fend_region_8.rs?ref=d020ff0c6854b1826233e727d4d06ef0ba526b28", "patch": "@@ -35,7 +35,6 @@ fn foo<F>(f: F) where F: FnOnce() -> i32 {\n //    let mut _3: ();\n //    let mut _4: [closure@NodeId(22) r:&'6_1rce D];\n //    let mut _5: &'6_1rce D;\n-//    let mut _6: ();\n //    bb0: {\n //        StorageLive(_1);\n //        _1 = D::{{constructor}}(const 0i32,);"}, {"sha": "3a8b5c449c22ad7fe94d8c633be20a6fa24aa10d", "filename": "src/test/mir-opt/issue-41110.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d020ff0c6854b1826233e727d4d06ef0ba526b28/src%2Ftest%2Fmir-opt%2Fissue-41110.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d020ff0c6854b1826233e727d4d06ef0ba526b28/src%2Ftest%2Fmir-opt%2Fissue-41110.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fissue-41110.rs?ref=d020ff0c6854b1826233e727d4d06ef0ba526b28", "patch": "@@ -39,8 +39,7 @@ impl S {\n //    let mut _2: S;\n //    let mut _3: S;\n //    let mut _4: S;\n-//    let mut _5: ();\n-//    let mut _6: bool;\n+//    let mut _5: bool;\n //\n //    bb0: {\n // END rustc.node4.ElaborateDrops.after.mir\n@@ -50,9 +49,8 @@ impl S {\n //    let mut _2: S;\n //    let mut _3: ();\n //    let mut _4: S;\n-//    let mut _5: ();\n-//    let mut _6: S;\n-//    let mut _7: bool;\n+//    let mut _5: S;\n+//    let mut _6: bool;\n //\n //    bb0: {\n // END rustc.node13.ElaborateDrops.after.mir"}, {"sha": "1aba47af1e9dca30f48f8f877da20e840bff37b0", "filename": "src/test/run-pass/dynamic-drop.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d020ff0c6854b1826233e727d4d06ef0ba526b28/src%2Ftest%2Frun-pass%2Fdynamic-drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d020ff0c6854b1826233e727d4d06ef0ba526b28/src%2Ftest%2Frun-pass%2Fdynamic-drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdynamic-drop.rs?ref=d020ff0c6854b1826233e727d4d06ef0ba526b28", "patch": "@@ -161,6 +161,11 @@ fn vec_simple(a: &Allocator) {\n     let _x = vec![a.alloc(), a.alloc(), a.alloc(), a.alloc()];\n }\n \n+#[allow(unreachable_code)]\n+fn vec_unreachable(a: &Allocator) {\n+    let _x = vec![a.alloc(), a.alloc(), a.alloc(), return];\n+}\n+\n fn run_test<F>(mut f: F)\n     where F: FnMut(&Allocator)\n {\n@@ -209,6 +214,7 @@ fn main() {\n \n     run_test(|a| array_simple(a));\n     run_test(|a| vec_simple(a));\n+    run_test(|a| vec_unreachable(a));\n \n     run_test(|a| struct_dynamic_drop(a, false, false, false));\n     run_test(|a| struct_dynamic_drop(a, false, false, true));"}]}