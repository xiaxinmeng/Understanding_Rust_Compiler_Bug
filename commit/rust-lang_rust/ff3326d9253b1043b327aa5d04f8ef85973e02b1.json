{"sha": "ff3326d9253b1043b327aa5d04f8ef85973e02b1", "node_id": "C_kwDOAAsO6NoAKGZmMzMyNmQ5MjUzYjEwNDNiMzI3YWE1ZDA0ZjhlZjg1OTczZTAyYjE", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-12-31T05:26:33Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-12-31T05:26:33Z"}, "message": "Rollup merge of #105903 - joboet:unify_parking, r=m-ou-se\n\nUnify id-based thread parking implementations\n\nMultiple platforms currently use thread-id-based parking implementations (NetBSD and SGX[^1]). Even though the strategy does not differ, these are duplicated for each platform, as the id is encoded into an atomic thread variable in different ways for each platform.\n\nSince `park` is only called by one thread, it is possible to move the thread id into a separate field. By ensuring that the field is only written to once, before any other threads access it, these accesses can be unsynchronized, removing any restrictions on the size and niches of the thread id.\n\nThis PR also renames the internal `thread_parker` modules to `thread_parking`, as that name now better reflects their contents. I hope this does not add too much reviewing noise.\n\nr? `@m-ou-se`\n\n`@rustbot` label +T-libs\n\n[^1]: SOLID supports this as well, I will switch it over in a follow-up PR.", "tree": {"sha": "8422c5f8d3013b2b87a4d0b8c6e143f6547db849", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8422c5f8d3013b2b87a4d0b8c6e143f6547db849"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ff3326d9253b1043b327aa5d04f8ef85973e02b1", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjr8gJCRBK7hj4Ov3rIwAA4/MIAFJyzUVn/CoN6V6onBYBmEjW\nH1O9Kt6YiG8phA1iVQADunXGC9jUOW+KOH9Exlkbot4TIvGkjM7tk+VxyUeHaZV6\niY8bzwfHf81E4bJfY4QagbquWE510ZaiyXyoZ5w3T8ufararsrMAXTPSeInD1a3i\nvYSmYu81PWsbSn4wVs4r6UnUj8THodHteX/qBEF+vBYcGaXIzt0FJAMawvGbY7p0\nXmkb7wedLVV+vbgLJApkjpQDYO6n1VfzgHPiWOx5/m6OKZgIV6Z9HNb0oINadHmA\nxtXLxR5BD1ipdDeXUZVCt6UpelFJ2Is2Y4EA+IvQHCk/RfyRITW60MlVDKSfW+Y=\n=koq6\n-----END PGP SIGNATURE-----\n", "payload": "tree 8422c5f8d3013b2b87a4d0b8c6e143f6547db849\nparent 5570cda1870a399532c34b36c89fe0b03d59c72c\nparent 898302e685210baec6c0047108ed192b0d59071f\nauthor Michael Goulet <michael@errs.io> 1672464393 -0800\ncommitter GitHub <noreply@github.com> 1672464393 -0800\n\nRollup merge of #105903 - joboet:unify_parking, r=m-ou-se\n\nUnify id-based thread parking implementations\n\nMultiple platforms currently use thread-id-based parking implementations (NetBSD and SGX[^1]). Even though the strategy does not differ, these are duplicated for each platform, as the id is encoded into an atomic thread variable in different ways for each platform.\n\nSince `park` is only called by one thread, it is possible to move the thread id into a separate field. By ensuring that the field is only written to once, before any other threads access it, these accesses can be unsynchronized, removing any restrictions on the size and niches of the thread id.\n\nThis PR also renames the internal `thread_parker` modules to `thread_parking`, as that name now better reflects their contents. I hope this does not add too much reviewing noise.\n\nr? `@m-ou-se`\n\n`@rustbot` label +T-libs\n\n[^1]: SOLID supports this as well, I will switch it over in a follow-up PR.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ff3326d9253b1043b327aa5d04f8ef85973e02b1", "html_url": "https://github.com/rust-lang/rust/commit/ff3326d9253b1043b327aa5d04f8ef85973e02b1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ff3326d9253b1043b327aa5d04f8ef85973e02b1/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5570cda1870a399532c34b36c89fe0b03d59c72c", "url": "https://api.github.com/repos/rust-lang/rust/commits/5570cda1870a399532c34b36c89fe0b03d59c72c", "html_url": "https://github.com/rust-lang/rust/commit/5570cda1870a399532c34b36c89fe0b03d59c72c"}, {"sha": "898302e685210baec6c0047108ed192b0d59071f", "url": "https://api.github.com/repos/rust-lang/rust/commits/898302e685210baec6c0047108ed192b0d59071f", "html_url": "https://github.com/rust-lang/rust/commit/898302e685210baec6c0047108ed192b0d59071f"}], "stats": {"total": 447, "additions": 207, "deletions": 240}, "files": [{"sha": "9865a945bad1d17389586da7633767f04eba3991", "filename": "library/std/src/sys/sgx/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff3326d9253b1043b327aa5d04f8ef85973e02b1/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff3326d9253b1043b327aa5d04f8ef85973e02b1/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fmod.rs?ref=ff3326d9253b1043b327aa5d04f8ef85973e02b1", "patch": "@@ -34,7 +34,7 @@ pub mod process;\n pub mod stdio;\n pub mod thread;\n pub mod thread_local_key;\n-pub mod thread_parker;\n+pub mod thread_parking;\n pub mod time;\n \n mod condvar;"}, {"sha": "1608b8cb642dc858ba13482b2d1f5c72a0ba6bfa", "filename": "library/std/src/sys/sgx/thread.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ff3326d9253b1043b327aa5d04f8ef85973e02b1/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff3326d9253b1043b327aa5d04f8ef85973e02b1/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fthread.rs?ref=ff3326d9253b1043b327aa5d04f8ef85973e02b1", "patch": "@@ -65,9 +65,9 @@ mod task_queue {\n /// execution. The signal is sent once all TLS destructors have finished at\n /// which point no new thread locals should be created.\n pub mod wait_notify {\n-    use super::super::thread_parker::Parker;\n     use crate::pin::Pin;\n     use crate::sync::Arc;\n+    use crate::sys_common::thread_parking::Parker;\n \n     pub struct Notifier(Arc<Parker>);\n \n@@ -87,14 +87,14 @@ pub mod wait_notify {\n         /// called, this will return immediately, otherwise the current thread\n         /// is blocked until notified.\n         pub fn wait(self) {\n-            // This is not actually `unsafe`, but it uses the `Parker` API,\n-            // which needs `unsafe` on some platforms.\n+            // SAFETY:\n+            // This is only ever called on one thread.\n             unsafe { Pin::new(&*self.0).park() }\n         }\n     }\n \n     pub fn new() -> (Notifier, Waiter) {\n-        let inner = Arc::new(Parker::new_internal());\n+        let inner = Arc::new(Parker::new());\n         (Notifier(inner.clone()), Waiter(inner))\n     }\n }"}, {"sha": "1c55bcffb1e8c2dc3650e918177026d9b7cc2250", "filename": "library/std/src/sys/sgx/thread_parker.rs", "status": "removed", "additions": 0, "deletions": 107, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/5570cda1870a399532c34b36c89fe0b03d59c72c/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fthread_parker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5570cda1870a399532c34b36c89fe0b03d59c72c/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fthread_parker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fthread_parker.rs?ref=5570cda1870a399532c34b36c89fe0b03d59c72c", "patch": "@@ -1,107 +0,0 @@\n-//! Thread parking based on SGX events.\n-\n-use super::abi::{thread, usercalls};\n-use crate::io::ErrorKind;\n-use crate::pin::Pin;\n-use crate::ptr::{self, NonNull};\n-use crate::sync::atomic::AtomicPtr;\n-use crate::sync::atomic::Ordering::{Acquire, Relaxed, Release};\n-use crate::time::Duration;\n-use fortanix_sgx_abi::{EV_UNPARK, WAIT_INDEFINITE};\n-\n-// The TCS structure must be page-aligned (this is checked by EENTER), so these cannot\n-// be valid pointers\n-const EMPTY: *mut u8 = ptr::invalid_mut(1);\n-const NOTIFIED: *mut u8 = ptr::invalid_mut(2);\n-\n-pub struct Parker {\n-    /// The park state. One of EMPTY, NOTIFIED or a TCS address.\n-    /// A state change to NOTIFIED must be done with release ordering\n-    /// and be observed with acquire ordering so that operations after\n-    /// `thread::park` returns will not occur before the unpark message\n-    /// was sent.\n-    state: AtomicPtr<u8>,\n-}\n-\n-impl Parker {\n-    /// Construct the thread parker. The UNIX parker implementation\n-    /// requires this to happen in-place.\n-    pub unsafe fn new(parker: *mut Parker) {\n-        unsafe { parker.write(Parker::new_internal()) }\n-    }\n-\n-    pub(super) fn new_internal() -> Parker {\n-        Parker { state: AtomicPtr::new(EMPTY) }\n-    }\n-\n-    // This implementation doesn't require `unsafe` and `Pin`, but other implementations do.\n-    pub unsafe fn park(self: Pin<&Self>) {\n-        if self.state.load(Acquire) != NOTIFIED {\n-            let mut prev = EMPTY;\n-            loop {\n-                // Guard against changing TCS addresses by always setting the state to\n-                // the current value.\n-                let tcs = thread::current().as_ptr();\n-                if self.state.compare_exchange(prev, tcs, Relaxed, Acquire).is_ok() {\n-                    let event = usercalls::wait(EV_UNPARK, WAIT_INDEFINITE).unwrap();\n-                    assert!(event & EV_UNPARK == EV_UNPARK);\n-                    prev = tcs;\n-                } else {\n-                    // The state was definitely changed by another thread at this point.\n-                    // The only time this occurs is when the state is changed to NOTIFIED.\n-                    // We observed this change with acquire ordering, so we can simply\n-                    // change the state to EMPTY with a relaxed store.\n-                    break;\n-                }\n-            }\n-        }\n-\n-        // At this point, the token was definately read with acquire ordering,\n-        // so this can be a relaxed store.\n-        self.state.store(EMPTY, Relaxed);\n-    }\n-\n-    // This implementation doesn't require `unsafe` and `Pin`, but other implementations do.\n-    pub unsafe fn park_timeout(self: Pin<&Self>, dur: Duration) {\n-        let timeout = u128::min(dur.as_nanos(), WAIT_INDEFINITE as u128 - 1) as u64;\n-        let tcs = thread::current().as_ptr();\n-\n-        if self.state.load(Acquire) != NOTIFIED {\n-            if self.state.compare_exchange(EMPTY, tcs, Relaxed, Acquire).is_ok() {\n-                match usercalls::wait(EV_UNPARK, timeout) {\n-                    Ok(event) => assert!(event & EV_UNPARK == EV_UNPARK),\n-                    Err(e) => {\n-                        assert!(matches!(e.kind(), ErrorKind::TimedOut | ErrorKind::WouldBlock))\n-                    }\n-                }\n-\n-                // Swap to provide acquire ordering even if the timeout occurred\n-                // before the token was set. This situation can result in spurious\n-                // wakeups on the next call to `park_timeout`, but it is better to let\n-                // those be handled by the user than do some perhaps unnecessary, but\n-                // always expensive guarding.\n-                self.state.swap(EMPTY, Acquire);\n-                return;\n-            }\n-        }\n-\n-        // The token was already read with `acquire` ordering, this can be a store.\n-        self.state.store(EMPTY, Relaxed);\n-    }\n-\n-    // This implementation doesn't require `Pin`, but other implementations do.\n-    pub fn unpark(self: Pin<&Self>) {\n-        let state = self.state.swap(NOTIFIED, Release);\n-\n-        if !matches!(state, EMPTY | NOTIFIED) {\n-            // There is a thread waiting, wake it up.\n-            let tcs = NonNull::new(state).unwrap();\n-            // This will fail if the thread has already terminated or its TCS is destroyed\n-            // by the time the signal is sent, but that is fine. If another thread receives\n-            // the same TCS, it will receive this notification as a spurious wakeup, but\n-            // all users of `wait` should and (internally) do guard against those where\n-            // necessary.\n-            let _ = usercalls::send(EV_UNPARK, Some(tcs));\n-        }\n-    }\n-}"}, {"sha": "0006cd4f1be2502a1bdc182be8fb37d3981effde", "filename": "library/std/src/sys/sgx/thread_parking.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/ff3326d9253b1043b327aa5d04f8ef85973e02b1/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fthread_parking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff3326d9253b1043b327aa5d04f8ef85973e02b1/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fthread_parking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fthread_parking.rs?ref=ff3326d9253b1043b327aa5d04f8ef85973e02b1", "patch": "@@ -0,0 +1,23 @@\n+use super::abi::usercalls;\n+use crate::io::ErrorKind;\n+use crate::time::Duration;\n+use fortanix_sgx_abi::{EV_UNPARK, WAIT_INDEFINITE};\n+\n+pub type ThreadId = fortanix_sgx_abi::Tcs;\n+\n+pub use super::abi::thread::current;\n+\n+pub fn park(_hint: usize) {\n+    usercalls::wait(EV_UNPARK, WAIT_INDEFINITE).unwrap();\n+}\n+\n+pub fn park_timeout(dur: Duration, _hint: usize) {\n+    let timeout = u128::min(dur.as_nanos(), WAIT_INDEFINITE as u128 - 1) as u64;\n+    if let Err(e) = usercalls::wait(EV_UNPARK, timeout) {\n+        assert!(matches!(e.kind(), ErrorKind::TimedOut | ErrorKind::WouldBlock))\n+    }\n+}\n+\n+pub fn unpark(tid: ThreadId, _hint: usize) {\n+    let _ = usercalls::send(EV_UNPARK, Some(tid));\n+}"}, {"sha": "30a96be14300a8f8c07fb2f81cf52af12e640ef6", "filename": "library/std/src/sys/unix/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff3326d9253b1043b327aa5d04f8ef85973e02b1/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff3326d9253b1043b327aa5d04f8ef85973e02b1/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fmod.rs?ref=ff3326d9253b1043b327aa5d04f8ef85973e02b1", "patch": "@@ -40,7 +40,7 @@ pub mod stdio;\n pub mod thread;\n pub mod thread_local_dtor;\n pub mod thread_local_key;\n-pub mod thread_parker;\n+pub mod thread_parking;\n pub mod time;\n \n #[cfg(target_os = \"espidf\")]"}, {"sha": "7657605b52f0d99d70db8599d5cb5d5b32d86be2", "filename": "library/std/src/sys/unix/thread_parker/netbsd.rs", "status": "removed", "additions": 0, "deletions": 113, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/5570cda1870a399532c34b36c89fe0b03d59c72c/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_parker%2Fnetbsd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5570cda1870a399532c34b36c89fe0b03d59c72c/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_parker%2Fnetbsd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_parker%2Fnetbsd.rs?ref=5570cda1870a399532c34b36c89fe0b03d59c72c", "patch": "@@ -1,113 +0,0 @@\n-use crate::ffi::{c_int, c_void};\n-use crate::pin::Pin;\n-use crate::ptr::{null, null_mut};\n-use crate::sync::atomic::{\n-    AtomicU64,\n-    Ordering::{Acquire, Relaxed, Release},\n-};\n-use crate::time::Duration;\n-use libc::{_lwp_self, clockid_t, lwpid_t, time_t, timespec, CLOCK_MONOTONIC};\n-\n-extern \"C\" {\n-    fn ___lwp_park60(\n-        clock_id: clockid_t,\n-        flags: c_int,\n-        ts: *mut timespec,\n-        unpark: lwpid_t,\n-        hint: *const c_void,\n-        unparkhint: *const c_void,\n-    ) -> c_int;\n-    fn _lwp_unpark(lwp: lwpid_t, hint: *const c_void) -> c_int;\n-}\n-\n-/// The thread is not parked and the token is not available.\n-///\n-/// Zero cannot be a valid LWP id, since it is used as empty value for the unpark\n-/// argument in _lwp_park.\n-const EMPTY: u64 = 0;\n-/// The token is available. Do not park anymore.\n-const NOTIFIED: u64 = u64::MAX;\n-\n-pub struct Parker {\n-    /// The parker state. Contains either one of the two state values above or the LWP\n-    /// id of the parked thread.\n-    state: AtomicU64,\n-}\n-\n-impl Parker {\n-    pub unsafe fn new(parker: *mut Parker) {\n-        parker.write(Parker { state: AtomicU64::new(EMPTY) })\n-    }\n-\n-    // Does not actually need `unsafe` or `Pin`, but the pthread implementation does.\n-    pub unsafe fn park(self: Pin<&Self>) {\n-        // If the token has already been made available, we can skip\n-        // a bit of work, so check for it here.\n-        if self.state.load(Acquire) != NOTIFIED {\n-            let parked = _lwp_self() as u64;\n-            let hint = self.state.as_mut_ptr().cast();\n-            if self.state.compare_exchange(EMPTY, parked, Relaxed, Acquire).is_ok() {\n-                // Loop to guard against spurious wakeups.\n-                loop {\n-                    ___lwp_park60(0, 0, null_mut(), 0, hint, null());\n-                    if self.state.load(Acquire) == NOTIFIED {\n-                        break;\n-                    }\n-                }\n-            }\n-        }\n-\n-        // At this point, the change to NOTIFIED has always been observed with acquire\n-        // ordering, so we can just use a relaxed store here (instead of a swap).\n-        self.state.store(EMPTY, Relaxed);\n-    }\n-\n-    // Does not actually need `unsafe` or `Pin`, but the pthread implementation does.\n-    pub unsafe fn park_timeout(self: Pin<&Self>, dur: Duration) {\n-        if self.state.load(Acquire) != NOTIFIED {\n-            let parked = _lwp_self() as u64;\n-            let hint = self.state.as_mut_ptr().cast();\n-            let mut timeout = timespec {\n-                // Saturate so that the operation will definitely time out\n-                // (even if it is after the heat death of the universe).\n-                tv_sec: dur.as_secs().try_into().ok().unwrap_or(time_t::MAX),\n-                tv_nsec: dur.subsec_nanos().into(),\n-            };\n-\n-            if self.state.compare_exchange(EMPTY, parked, Relaxed, Acquire).is_ok() {\n-                // Timeout needs to be mutable since it is modified on NetBSD 9.0 and\n-                // above.\n-                ___lwp_park60(CLOCK_MONOTONIC, 0, &mut timeout, 0, hint, null());\n-                // Use a swap to get acquire ordering even if the token was set after\n-                // the timeout occurred.\n-                self.state.swap(EMPTY, Acquire);\n-                return;\n-            }\n-        }\n-\n-        self.state.store(EMPTY, Relaxed);\n-    }\n-\n-    // Does not actually need `Pin`, but the pthread implementation does.\n-    pub fn unpark(self: Pin<&Self>) {\n-        let state = self.state.swap(NOTIFIED, Release);\n-        if !matches!(state, EMPTY | NOTIFIED) {\n-            let lwp = state as lwpid_t;\n-            let hint = self.state.as_mut_ptr().cast();\n-\n-            // If the parking thread terminated and did not actually park, this will\n-            // probably return an error, which is OK. In the worst case, another\n-            // thread has received the same LWP id. It will then receive a spurious\n-            // wakeup, but those are allowable per the API contract. The same reasoning\n-            // applies if a timeout occurred before this call, but the state was not\n-            // yet reset.\n-\n-            // SAFETY:\n-            // The syscall has no invariants to hold. Only unsafe because it is an\n-            // extern function.\n-            unsafe {\n-                _lwp_unpark(lwp, hint);\n-            }\n-        }\n-    }\n-}"}, {"sha": "b709fada3b4a805f1421f7c408f9ac266caf9115", "filename": "library/std/src/sys/unix/thread_parking/darwin.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff3326d9253b1043b327aa5d04f8ef85973e02b1/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_parking%2Fdarwin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff3326d9253b1043b327aa5d04f8ef85973e02b1/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_parking%2Fdarwin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_parking%2Fdarwin.rs?ref=ff3326d9253b1043b327aa5d04f8ef85973e02b1", "patch": "@@ -46,7 +46,7 @@ unsafe impl Sync for Parker {}\n unsafe impl Send for Parker {}\n \n impl Parker {\n-    pub unsafe fn new(parker: *mut Parker) {\n+    pub unsafe fn new_in_place(parker: *mut Parker) {\n         let semaphore = dispatch_semaphore_create(0);\n         assert!(\n             !semaphore.is_null(),", "previous_filename": "library/std/src/sys/unix/thread_parker/darwin.rs"}, {"sha": "185333c072f49246d1315347e1040da660f1ad59", "filename": "library/std/src/sys/unix/thread_parking/mod.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff3326d9253b1043b327aa5d04f8ef85973e02b1/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_parking%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff3326d9253b1043b327aa5d04f8ef85973e02b1/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_parking%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_parking%2Fmod.rs?ref=ff3326d9253b1043b327aa5d04f8ef85973e02b1", "patch": "@@ -24,7 +24,7 @@ cfg_if::cfg_if! {\n         pub use darwin::Parker;\n     } else if #[cfg(target_os = \"netbsd\")] {\n         mod netbsd;\n-        pub use netbsd::Parker;\n+        pub use netbsd::{current, park, park_timeout, unpark, ThreadId};\n     } else {\n         mod pthread;\n         pub use pthread::Parker;", "previous_filename": "library/std/src/sys/unix/thread_parker/mod.rs"}, {"sha": "3be08122138ab249790f19cf3c21566ee254fcf8", "filename": "library/std/src/sys/unix/thread_parking/netbsd.rs", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/ff3326d9253b1043b327aa5d04f8ef85973e02b1/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_parking%2Fnetbsd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff3326d9253b1043b327aa5d04f8ef85973e02b1/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_parking%2Fnetbsd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_parking%2Fnetbsd.rs?ref=ff3326d9253b1043b327aa5d04f8ef85973e02b1", "patch": "@@ -0,0 +1,52 @@\n+use crate::ffi::{c_int, c_void};\n+use crate::ptr;\n+use crate::time::Duration;\n+use libc::{_lwp_self, clockid_t, lwpid_t, time_t, timespec, CLOCK_MONOTONIC};\n+\n+extern \"C\" {\n+    fn ___lwp_park60(\n+        clock_id: clockid_t,\n+        flags: c_int,\n+        ts: *mut timespec,\n+        unpark: lwpid_t,\n+        hint: *const c_void,\n+        unparkhint: *const c_void,\n+    ) -> c_int;\n+    fn _lwp_unpark(lwp: lwpid_t, hint: *const c_void) -> c_int;\n+}\n+\n+pub type ThreadId = lwpid_t;\n+\n+#[inline]\n+pub fn current() -> ThreadId {\n+    unsafe { _lwp_self() }\n+}\n+\n+#[inline]\n+pub fn park(hint: usize) {\n+    unsafe {\n+        ___lwp_park60(0, 0, ptr::null_mut(), 0, ptr::invalid(hint), ptr::null());\n+    }\n+}\n+\n+pub fn park_timeout(dur: Duration, hint: usize) {\n+    let mut timeout = timespec {\n+        // Saturate so that the operation will definitely time out\n+        // (even if it is after the heat death of the universe).\n+        tv_sec: dur.as_secs().try_into().ok().unwrap_or(time_t::MAX),\n+        tv_nsec: dur.subsec_nanos().into(),\n+    };\n+\n+    // Timeout needs to be mutable since it is modified on NetBSD 9.0 and\n+    // above.\n+    unsafe {\n+        ___lwp_park60(CLOCK_MONOTONIC, 0, &mut timeout, 0, ptr::invalid(hint), ptr::null());\n+    }\n+}\n+\n+#[inline]\n+pub fn unpark(tid: ThreadId, hint: usize) {\n+    unsafe {\n+        _lwp_unpark(tid, ptr::invalid(hint));\n+    }\n+}"}, {"sha": "082d25e68f587ad9a424b076b348a2814b011894", "filename": "library/std/src/sys/unix/thread_parking/pthread.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff3326d9253b1043b327aa5d04f8ef85973e02b1/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_parking%2Fpthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff3326d9253b1043b327aa5d04f8ef85973e02b1/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_parking%2Fpthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_parking%2Fpthread.rs?ref=ff3326d9253b1043b327aa5d04f8ef85973e02b1", "patch": "@@ -99,7 +99,7 @@ impl Parker {\n     ///\n     /// # Safety\n     /// The constructed parker must never be moved.\n-    pub unsafe fn new(parker: *mut Parker) {\n+    pub unsafe fn new_in_place(parker: *mut Parker) {\n         // Use the default mutex implementation to allow for simpler initialization.\n         // This could lead to undefined behaviour when deadlocking. This is avoided\n         // by not deadlocking. Note in particular the unlocking operation before any", "previous_filename": "library/std/src/sys/unix/thread_parker/pthread.rs"}, {"sha": "77359abe429950869a9c82bbb5477e1a2f3cd6af", "filename": "library/std/src/sys/windows/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff3326d9253b1043b327aa5d04f8ef85973e02b1/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff3326d9253b1043b327aa5d04f8ef85973e02b1/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fmod.rs?ref=ff3326d9253b1043b327aa5d04f8ef85973e02b1", "patch": "@@ -33,7 +33,7 @@ pub mod stdio;\n pub mod thread;\n pub mod thread_local_dtor;\n pub mod thread_local_key;\n-pub mod thread_parker;\n+pub mod thread_parking;\n pub mod time;\n cfg_if::cfg_if! {\n     if #[cfg(not(target_vendor = \"uwp\"))] {"}, {"sha": "5d43676adbb11f0428d99c796fe58eaa3b3b2c45", "filename": "library/std/src/sys/windows/thread_parking.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff3326d9253b1043b327aa5d04f8ef85973e02b1/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fthread_parking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff3326d9253b1043b327aa5d04f8ef85973e02b1/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fthread_parking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fthread_parking.rs?ref=ff3326d9253b1043b327aa5d04f8ef85973e02b1", "patch": "@@ -97,7 +97,7 @@ const NOTIFIED: i8 = 1;\n impl Parker {\n     /// Construct the Windows parker. The UNIX parker implementation\n     /// requires this to happen in-place.\n-    pub unsafe fn new(parker: *mut Parker) {\n+    pub unsafe fn new_in_place(parker: *mut Parker) {\n         parker.write(Self { state: AtomicI8::new(EMPTY) });\n     }\n ", "previous_filename": "library/std/src/sys/windows/thread_parker.rs"}, {"sha": "6b24b0e9aa8be85129f6a62bfb074db63d39e7ec", "filename": "library/std/src/sys_common/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff3326d9253b1043b327aa5d04f8ef85973e02b1/library%2Fstd%2Fsrc%2Fsys_common%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff3326d9253b1043b327aa5d04f8ef85973e02b1/library%2Fstd%2Fsrc%2Fsys_common%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fmod.rs?ref=ff3326d9253b1043b327aa5d04f8ef85973e02b1", "patch": "@@ -30,7 +30,7 @@ pub mod process;\n pub mod thread;\n pub mod thread_info;\n pub mod thread_local_dtor;\n-pub mod thread_parker;\n+pub mod thread_parking;\n pub mod wstr;\n pub mod wtf8;\n "}, {"sha": "588e7b27826f6633ed6ba4c6b8f8f95192c52aac", "filename": "library/std/src/sys_common/thread_parking/futex.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff3326d9253b1043b327aa5d04f8ef85973e02b1/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parking%2Ffutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff3326d9253b1043b327aa5d04f8ef85973e02b1/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parking%2Ffutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parking%2Ffutex.rs?ref=ff3326d9253b1043b327aa5d04f8ef85973e02b1", "patch": "@@ -35,7 +35,7 @@ pub struct Parker {\n impl Parker {\n     /// Construct the futex parker. The UNIX parker implementation\n     /// requires this to happen in-place.\n-    pub unsafe fn new(parker: *mut Parker) {\n+    pub unsafe fn new_in_place(parker: *mut Parker) {\n         parker.write(Self { state: AtomicU32::new(EMPTY) });\n     }\n ", "previous_filename": "library/std/src/sys_common/thread_parker/futex.rs"}, {"sha": "3209bffe353ed81b775a8b7869789824d1a052b1", "filename": "library/std/src/sys_common/thread_parking/generic.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff3326d9253b1043b327aa5d04f8ef85973e02b1/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parking%2Fgeneric.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff3326d9253b1043b327aa5d04f8ef85973e02b1/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parking%2Fgeneric.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parking%2Fgeneric.rs?ref=ff3326d9253b1043b327aa5d04f8ef85973e02b1", "patch": "@@ -19,7 +19,7 @@ pub struct Parker {\n impl Parker {\n     /// Construct the generic parker. The UNIX parker implementation\n     /// requires this to happen in-place.\n-    pub unsafe fn new(parker: *mut Parker) {\n+    pub unsafe fn new_in_place(parker: *mut Parker) {\n         parker.write(Parker {\n             state: AtomicUsize::new(EMPTY),\n             lock: Mutex::new(()),", "previous_filename": "library/std/src/sys_common/thread_parker/generic.rs"}, {"sha": "e98169597c378011d3e044251d69e813fbd119f6", "filename": "library/std/src/sys_common/thread_parking/id.rs", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/ff3326d9253b1043b327aa5d04f8ef85973e02b1/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parking%2Fid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff3326d9253b1043b327aa5d04f8ef85973e02b1/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parking%2Fid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parking%2Fid.rs?ref=ff3326d9253b1043b327aa5d04f8ef85973e02b1", "patch": "@@ -0,0 +1,108 @@\n+//! Thread parking using thread ids.\n+//!\n+//! Some platforms (notably NetBSD) have thread parking primitives whose semantics\n+//! match those offered by `thread::park`, with the difference that the thread to\n+//! be unparked is referenced by a platform-specific thread id. Since the thread\n+//! parker is constructed before that id is known, an atomic state variable is used\n+//! to manage the park state and propagate the thread id. This also avoids platform\n+//! calls in the case where `unpark` is called before `park`.\n+\n+use crate::cell::UnsafeCell;\n+use crate::pin::Pin;\n+use crate::sync::atomic::{\n+    fence, AtomicI8,\n+    Ordering::{Acquire, Relaxed, Release},\n+};\n+use crate::sys::thread_parking::{current, park, park_timeout, unpark, ThreadId};\n+use crate::time::Duration;\n+\n+pub struct Parker {\n+    state: AtomicI8,\n+    tid: UnsafeCell<Option<ThreadId>>,\n+}\n+\n+const PARKED: i8 = -1;\n+const EMPTY: i8 = 0;\n+const NOTIFIED: i8 = 1;\n+\n+impl Parker {\n+    pub fn new() -> Parker {\n+        Parker { state: AtomicI8::new(EMPTY), tid: UnsafeCell::new(None) }\n+    }\n+\n+    /// Create a new thread parker. UNIX requires this to happen in-place.\n+    pub unsafe fn new_in_place(parker: *mut Parker) {\n+        parker.write(Parker::new())\n+    }\n+\n+    /// # Safety\n+    /// * must always be called from the same thread\n+    /// * must be called before the state is set to PARKED\n+    unsafe fn init_tid(&self) {\n+        // The field is only ever written to from this thread, so we don't need\n+        // synchronization to read it here.\n+        if self.tid.get().read().is_none() {\n+            // Because this point is only reached once, before the state is set\n+            // to PARKED for the first time, the non-atomic write here can not\n+            // conflict with reads by other threads.\n+            self.tid.get().write(Some(current()));\n+            // Ensure that the write can be observed by all threads reading the\n+            // state. Synchronizes with the acquire barrier in `unpark`.\n+            fence(Release);\n+        }\n+    }\n+\n+    pub unsafe fn park(self: Pin<&Self>) {\n+        self.init_tid();\n+\n+        // Changes NOTIFIED to EMPTY and EMPTY to PARKED.\n+        let mut state = self.state.fetch_sub(1, Acquire).wrapping_sub(1);\n+        if state == PARKED {\n+            // Loop to guard against spurious wakeups.\n+            while state == PARKED {\n+                park(self.state.as_mut_ptr().addr());\n+                state = self.state.load(Acquire);\n+            }\n+\n+            // Since the state change has already been observed with acquire\n+            // ordering, the state can be reset with a relaxed store instead\n+            // of a swap.\n+            self.state.store(EMPTY, Relaxed);\n+        }\n+    }\n+\n+    pub unsafe fn park_timeout(self: Pin<&Self>, dur: Duration) {\n+        self.init_tid();\n+\n+        let state = self.state.fetch_sub(1, Acquire).wrapping_sub(1);\n+        if state == PARKED {\n+            park_timeout(dur, self.state.as_mut_ptr().addr());\n+            // Swap to ensure that we observe all state changes with acquire\n+            // ordering, even if the state has been changed after the timeout\n+            // occured.\n+            self.state.swap(EMPTY, Acquire);\n+        }\n+    }\n+\n+    pub fn unpark(self: Pin<&Self>) {\n+        let state = self.state.swap(NOTIFIED, Release);\n+        if state == PARKED {\n+            // Synchronize with the release fence in `init_tid` to observe the\n+            // write to `tid`.\n+            fence(Acquire);\n+            // # Safety\n+            // The thread id is initialized before the state is set to `PARKED`\n+            // for the first time and is not written to from that point on\n+            // (negating the need for an atomic read).\n+            let tid = unsafe { self.tid.get().read().unwrap_unchecked() };\n+            // It is possible that the waiting thread woke up because of a timeout\n+            // and terminated before this call is made. This call then returns an\n+            // error or wakes up an unrelated thread. The platform API and\n+            // environment does allow this, however.\n+            unpark(tid, self.state.as_mut_ptr().addr());\n+        }\n+    }\n+}\n+\n+unsafe impl Send for Parker {}\n+unsafe impl Sync for Parker {}"}, {"sha": "0ead6633c3501bd5302a4f11c3865267cd6b5d8d", "filename": "library/std/src/sys_common/thread_parking/mod.rs", "status": "renamed", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ff3326d9253b1043b327aa5d04f8ef85973e02b1/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parking%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff3326d9253b1043b327aa5d04f8ef85973e02b1/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parking%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parking%2Fmod.rs?ref=ff3326d9253b1043b327aa5d04f8ef85973e02b1", "patch": "@@ -11,13 +11,17 @@ cfg_if::cfg_if! {\n     ))] {\n         mod futex;\n         pub use futex::Parker;\n+    } else if #[cfg(any(\n+        target_os = \"netbsd\",\n+        all(target_vendor = \"fortanix\", target_env = \"sgx\"),\n+    ))] {\n+        mod id;\n+        pub use id::Parker;\n     } else if #[cfg(target_os = \"solid_asp3\")] {\n         mod wait_flag;\n         pub use wait_flag::Parker;\n     } else if #[cfg(any(windows, target_family = \"unix\"))] {\n-        pub use crate::sys::thread_parker::Parker;\n-    } else if #[cfg(all(target_vendor = \"fortanix\", target_env = \"sgx\"))] {\n-        pub use crate::sys::thread_parker::Parker;\n+        pub use crate::sys::thread_parking::Parker;\n     } else {\n         mod generic;\n         pub use generic::Parker;", "previous_filename": "library/std/src/sys_common/thread_parker/mod.rs"}, {"sha": "d0f8899a94eb8507ff233f5d8321bf576fc8827e", "filename": "library/std/src/sys_common/thread_parking/wait_flag.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff3326d9253b1043b327aa5d04f8ef85973e02b1/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parking%2Fwait_flag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff3326d9253b1043b327aa5d04f8ef85973e02b1/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parking%2Fwait_flag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parking%2Fwait_flag.rs?ref=ff3326d9253b1043b327aa5d04f8ef85973e02b1", "patch": "@@ -41,7 +41,7 @@ pub struct Parker {\n impl Parker {\n     /// Construct a parker for the current thread. The UNIX parker\n     /// implementation requires this to happen in-place.\n-    pub unsafe fn new(parker: *mut Parker) {\n+    pub unsafe fn new_in_place(parker: *mut Parker) {\n         parker.write(Parker { state: AtomicI8::new(EMPTY), wait_flag: WaitFlag::new() })\n     }\n ", "previous_filename": "library/std/src/sys_common/thread_parker/wait_flag.rs"}, {"sha": "7acda8e98f18fcf75bf3b8f97334832b949bb0f6", "filename": "library/std/src/thread/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ff3326d9253b1043b327aa5d04f8ef85973e02b1/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff3326d9253b1043b327aa5d04f8ef85973e02b1/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs?ref=ff3326d9253b1043b327aa5d04f8ef85973e02b1", "patch": "@@ -173,7 +173,7 @@ use crate::sync::Arc;\n use crate::sys::thread as imp;\n use crate::sys_common::thread;\n use crate::sys_common::thread_info;\n-use crate::sys_common::thread_parker::Parker;\n+use crate::sys_common::thread_parking::Parker;\n use crate::sys_common::{AsInner, IntoInner};\n use crate::time::Duration;\n \n@@ -1216,7 +1216,7 @@ impl Thread {\n             let ptr = Arc::get_mut_unchecked(&mut arc).as_mut_ptr();\n             addr_of_mut!((*ptr).name).write(name);\n             addr_of_mut!((*ptr).id).write(ThreadId::new());\n-            Parker::new(addr_of_mut!((*ptr).parker));\n+            Parker::new_in_place(addr_of_mut!((*ptr).parker));\n             Pin::new_unchecked(arc.assume_init())\n         };\n "}]}