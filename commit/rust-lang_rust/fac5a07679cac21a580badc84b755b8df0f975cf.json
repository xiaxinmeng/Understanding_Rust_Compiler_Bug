{"sha": "fac5a07679cac21a580badc84b755b8df0f975cf", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZhYzVhMDc2NzljYWMyMWE1ODBiYWRjODRiNzU1YjhkZjBmOTc1Y2Y=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-11-26T22:37:06Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-11-26T22:37:06Z"}, "message": "auto merge of #19115 : jakub-/rust/issue-19100, r=alexcrichton\n\n...of the type being matched.\r\n\r\nThis change will result in a better diagnostic for code like the following:\r\n\r\n```rust\r\nenum Enum {\r\n    Foo,\r\n    Bar\r\n}\r\n\r\nfn f(x: Enum) {\r\n    match x {\r\n        Foo => (),\r\n        Bar => ()\r\n    }\r\n}\r\n```\r\n\r\nwhich would currently simply fail with an unreachable pattern error\r\non the 2nd arm.\r\n\r\nThe user is advised to either use a qualified path in the patterns\r\nor import the variants explicitly into the scope.", "tree": {"sha": "ae15b481ed531e4fae600c41ca41107f6ad3e279", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ae15b481ed531e4fae600c41ca41107f6ad3e279"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fac5a07679cac21a580badc84b755b8df0f975cf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fac5a07679cac21a580badc84b755b8df0f975cf", "html_url": "https://github.com/rust-lang/rust/commit/fac5a07679cac21a580badc84b755b8df0f975cf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fac5a07679cac21a580badc84b755b8df0f975cf/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6faff24ec85744de092a7d7c2378370f65d623bb", "url": "https://api.github.com/repos/rust-lang/rust/commits/6faff24ec85744de092a7d7c2378370f65d623bb", "html_url": "https://github.com/rust-lang/rust/commit/6faff24ec85744de092a7d7c2378370f65d623bb"}, {"sha": "9d01db1966a3ab073691eb8e5203e36624b9f992", "url": "https://api.github.com/repos/rust-lang/rust/commits/9d01db1966a3ab073691eb8e5203e36624b9f992", "html_url": "https://github.com/rust-lang/rust/commit/9d01db1966a3ab073691eb8e5203e36624b9f992"}], "stats": {"total": 185, "additions": 153, "deletions": 32}, "files": [{"sha": "28504210a3f39cdf067b49e076c28ff8a826748f", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fac5a07679cac21a580badc84b755b8df0f975cf/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fac5a07679cac21a580badc84b755b8df0f975cf/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=fac5a07679cac21a580badc84b755b8df0f975cf", "patch": "@@ -145,5 +145,6 @@ register_diagnostics!(\n     E0166,\n     E0167,\n     E0168,\n-    E0169\n+    E0169,\n+    E0170\n )"}, {"sha": "ed119081f78c7913a3a840d368c37b5e6c415d73", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 58, "deletions": 26, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/fac5a07679cac21a580badc84b755b8df0f975cf/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fac5a07679cac21a580badc84b755b8df0f975cf/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=fac5a07679cac21a580badc84b755b8df0f975cf", "patch": "@@ -153,19 +153,14 @@ fn check_expr(cx: &mut MatchCheckCtxt, ex: &ast::Expr) {\n     visit::walk_expr(cx, ex);\n     match ex.node {\n         ast::ExprMatch(ref scrut, ref arms, source) => {\n-            // First, check legality of move bindings.\n             for arm in arms.iter() {\n+                // First, check legality of move bindings.\n                 check_legality_of_move_bindings(cx,\n                                                 arm.guard.is_some(),\n                                                 arm.pats.as_slice());\n-                for pat in arm.pats.iter() {\n-                    check_legality_of_bindings_in_at_patterns(cx, &**pat);\n-                }\n-            }\n \n-            // Second, if there is a guard on each arm, make sure it isn't\n-            // assigning or borrowing anything mutably.\n-            for arm in arms.iter() {\n+                // Second, if there is a guard on each arm, make sure it isn't\n+                // assigning or borrowing anything mutably.\n                 match arm.guard {\n                     Some(ref guard) => check_for_mutation_in_guard(cx, &**guard),\n                     None => {}\n@@ -179,13 +174,23 @@ fn check_expr(cx: &mut MatchCheckCtxt, ex: &ast::Expr) {\n                 }).collect(), arm.guard.as_ref().map(|e| &**e))\n             }).collect::<Vec<(Vec<P<Pat>>, Option<&ast::Expr>)>>();\n \n+            // Bail out early if inlining failed.\n             if static_inliner.failed {\n                 return;\n             }\n \n-            // Third, check if there are any references to NaN that we should warn about.\n-            for &(ref pats, _) in inlined_arms.iter() {\n-                check_for_static_nan(cx, pats.as_slice());\n+            for pat in inlined_arms\n+                .iter()\n+                .flat_map(|&(ref pats, _)| pats.iter()) {\n+                // Third, check legality of move bindings.\n+                check_legality_of_bindings_in_at_patterns(cx, &**pat);\n+\n+                // Fourth, check if there are any references to NaN that we should warn about.\n+                check_for_static_nan(cx, &**pat);\n+\n+                // Fifth, check if for any of the patterns that match an enumerated type\n+                // are bindings with the same name as one of the variants of said type.\n+                check_for_bindings_named_the_same_as_variants(cx, &**pat);\n             }\n \n             // Fourth, check for unreachable arms.\n@@ -239,21 +244,49 @@ fn is_expr_const_nan(tcx: &ty::ctxt, expr: &ast::Expr) -> bool {\n     }\n }\n \n-// Check that we do not match against a static NaN (#6804)\n-fn check_for_static_nan(cx: &MatchCheckCtxt, pats: &[P<Pat>]) {\n-    for pat in pats.iter() {\n-        walk_pat(&**pat, |p| {\n-            match p.node {\n-                ast::PatLit(ref expr) if is_expr_const_nan(cx.tcx, &**expr) => {\n-                    span_warn!(cx.tcx.sess, p.span, E0003,\n-                        \"unmatchable NaN in pattern, \\\n-                            use the is_nan method in a guard instead\");\n+fn check_for_bindings_named_the_same_as_variants(cx: &MatchCheckCtxt, pat: &Pat) {\n+    walk_pat(pat, |p| {\n+        match p.node {\n+            ast::PatIdent(ast::BindByValue(ast::MutImmutable), ident, None) => {\n+                let pat_ty = ty::pat_ty(cx.tcx, p);\n+                if let ty::ty_enum(def_id, _) = pat_ty.sty {\n+                    let def = cx.tcx.def_map.borrow().get(&p.id).cloned();\n+                    if let Some(DefLocal(_)) = def {\n+                        if ty::enum_variants(cx.tcx, def_id).iter().any(|variant|\n+                            token::get_name(variant.name) == token::get_name(ident.node.name)\n+                                && variant.args.len() == 0\n+                        ) {\n+                            span_warn!(cx.tcx.sess, p.span, E0170,\n+                                \"pattern binding `{}` is named the same as one \\\n+                                 of the variants of the type `{}`\",\n+                                token::get_ident(ident.node).get(), ty_to_string(cx.tcx, pat_ty));\n+                            span_help!(cx.tcx.sess, p.span,\n+                                \"if you meant to match on a variant, \\\n+                                 consider making the path in the pattern qualified: `{}::{}`\",\n+                                ty_to_string(cx.tcx, pat_ty), token::get_ident(ident.node).get());\n+                        }\n+                    }\n                 }\n-                _ => ()\n             }\n-            true\n-        });\n-    }\n+            _ => ()\n+        }\n+        true\n+    });\n+}\n+\n+// Check that we do not match against a static NaN (#6804)\n+fn check_for_static_nan(cx: &MatchCheckCtxt, pat: &Pat) {\n+    walk_pat(pat, |p| {\n+        match p.node {\n+            ast::PatLit(ref expr) if is_expr_const_nan(cx.tcx, &**expr) => {\n+                span_warn!(cx.tcx.sess, p.span, E0003,\n+                    \"unmatchable NaN in pattern, \\\n+                        use the is_nan method in a guard instead\");\n+            }\n+            _ => ()\n+        }\n+        true\n+    });\n }\n \n // Check for unreachable patterns\n@@ -414,8 +447,7 @@ fn construct_witness(cx: &MatchCheckCtxt, ctor: &Constructor,\n                 &Variant(vid) =>\n                     (vid, ty::enum_variant_with_id(cx.tcx, cid, vid).arg_names.is_some()),\n                 _ =>\n-                    (cid, ty::lookup_struct_fields(cx.tcx, cid).iter()\n-                        .any(|field| field.name != token::special_idents::unnamed_field.name))\n+                    (cid, !ty::is_tuple_struct(cx.tcx, cid))\n             };\n             if is_structure {\n                 let fields = ty::lookup_struct_fields(cx.tcx, vid);"}, {"sha": "3c2dbae665fa98d9b2cde79ae35025da841210ef", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/fac5a07679cac21a580badc84b755b8df0f975cf/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fac5a07679cac21a580badc84b755b8df0f975cf/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=fac5a07679cac21a580badc84b755b8df0f975cf", "patch": "@@ -948,4 +948,38 @@ mod test {\n         assert!(test_items.next().is_some());\n         assert!(test_items.next().is_none());\n     }\n+\n+    #[test]\n+    fn test_can_print_warnings() {\n+        {\n+            let matches = getopts(&[\n+                \"-Awarnings\".to_string()\n+            ], optgroups().as_slice()).unwrap();\n+            let registry = diagnostics::registry::Registry::new(&[]);\n+            let sessopts = build_session_options(&matches);\n+            let sess = build_session(sessopts, None, registry);\n+            assert!(!sess.can_print_warnings);\n+        }\n+\n+        {\n+            let matches = getopts(&[\n+                \"-Awarnings\".to_string(),\n+                \"-Dwarnings\".to_string()\n+            ], optgroups().as_slice()).unwrap();\n+            let registry = diagnostics::registry::Registry::new(&[]);\n+            let sessopts = build_session_options(&matches);\n+            let sess = build_session(sessopts, None, registry);\n+            assert!(sess.can_print_warnings);\n+        }\n+\n+        {\n+            let matches = getopts(&[\n+                \"-Adead_code\".to_string()\n+            ], optgroups().as_slice()).unwrap();\n+            let registry = diagnostics::registry::Registry::new(&[]);\n+            let sessopts = build_session_options(&matches);\n+            let sess = build_session(sessopts, None, registry);\n+            assert!(sess.can_print_warnings);\n+        }\n+    }\n }"}, {"sha": "047e5985569ae41f0f2f4cb0f56194151da5112c", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/fac5a07679cac21a580badc84b755b8df0f975cf/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fac5a07679cac21a580badc84b755b8df0f975cf/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=fac5a07679cac21a580badc84b755b8df0f975cf", "patch": "@@ -54,6 +54,8 @@ pub struct Session {\n     /// The maximum recursion limit for potentially infinitely recursive\n     /// operations such as auto-dereference and monomorphization.\n     pub recursion_limit: Cell<uint>,\n+\n+    pub can_print_warnings: bool\n }\n \n impl Session {\n@@ -82,13 +84,19 @@ impl Session {\n         self.diagnostic().handler().abort_if_errors()\n     }\n     pub fn span_warn(&self, sp: Span, msg: &str) {\n-        self.diagnostic().span_warn(sp, msg)\n+        if self.can_print_warnings {\n+            self.diagnostic().span_warn(sp, msg)\n+        }\n     }\n     pub fn span_warn_with_code(&self, sp: Span, msg: &str, code: &str) {\n-        self.diagnostic().span_warn_with_code(sp, msg, code)\n+        if self.can_print_warnings {\n+            self.diagnostic().span_warn_with_code(sp, msg, code)\n+        }\n     }\n     pub fn warn(&self, msg: &str) {\n-        self.diagnostic().handler().warn(msg)\n+        if self.can_print_warnings {\n+            self.diagnostic().handler().warn(msg)\n+        }\n     }\n     pub fn opt_span_warn(&self, opt_sp: Option<Span>, msg: &str) {\n         match opt_sp {\n@@ -247,6 +255,13 @@ pub fn build_session_(sopts: config::Options,\n         }\n     );\n \n+    let can_print_warnings = sopts.lint_opts\n+        .iter()\n+        .filter(|&&(ref key, _)| key.as_slice() == \"warnings\")\n+        .map(|&(_, ref level)| *level != lint::Allow)\n+        .last()\n+        .unwrap_or(true);\n+\n     let sess = Session {\n         target: target_cfg,\n         opts: sopts,\n@@ -265,6 +280,7 @@ pub fn build_session_(sopts: config::Options,\n         crate_metadata: RefCell::new(Vec::new()),\n         features: RefCell::new(feature_gate::Features::new()),\n         recursion_limit: Cell::new(64),\n+        can_print_warnings: can_print_warnings\n     };\n \n     sess.lint_store.borrow_mut().register_builtin(Some(&sess));"}, {"sha": "47907ac2be9b8e4f778eb14a779ead0716a3391e", "filename": "src/test/compile-fail/issue-12116.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fac5a07679cac21a580badc84b755b8df0f975cf/src%2Ftest%2Fcompile-fail%2Fissue-12116.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fac5a07679cac21a580badc84b755b8df0f975cf/src%2Ftest%2Fcompile-fail%2Fissue-12116.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-12116.rs?ref=fac5a07679cac21a580badc84b755b8df0f975cf", "patch": "@@ -17,7 +17,8 @@ fn tail(source_list: &IntList) -> IntList {\n     match source_list {\n         &IntList::Cons(val, box ref next_list) => tail(next_list),\n         &IntList::Cons(val, box Nil)           => IntList::Cons(val, box Nil),\n-        //~^ ERROR: unreachable pattern\n+//~^ ERROR unreachable pattern\n+//~^^ WARN pattern binding `Nil` is named the same as one of the variants of the type `IntList`\n         _                          => panic!()\n     }\n }"}, {"sha": "e79be99a346fa8692251b9c0508ba47bee897653", "filename": "src/test/compile-fail/issue-14221.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fac5a07679cac21a580badc84b755b8df0f975cf/src%2Ftest%2Fcompile-fail%2Fissue-14221.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fac5a07679cac21a580badc84b755b8df0f975cf/src%2Ftest%2Fcompile-fail%2Fissue-14221.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-14221.rs?ref=fac5a07679cac21a580badc84b755b8df0f975cf", "patch": "@@ -17,7 +17,9 @@ pub mod b {\n     pub fn key(e: ::E) -> &'static str {\n         match e {\n             A => \"A\",\n+//~^ WARN pattern binding `A` is named the same as one of the variants of the type `E`\n             B => \"B\", //~ ERROR: unreachable pattern\n+//~^ WARN pattern binding `B` is named the same as one of the variants of the type `E`\n         }\n     }\n }"}, {"sha": "eb5c475e7ef4fdca3aff442ad5b272be419d0a99", "filename": "src/test/compile-fail/lint-uppercase-variables.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fac5a07679cac21a580badc84b755b8df0f975cf/src%2Ftest%2Fcompile-fail%2Flint-uppercase-variables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fac5a07679cac21a580badc84b755b8df0f975cf/src%2Ftest%2Fcompile-fail%2Flint-uppercase-variables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-uppercase-variables.rs?ref=fac5a07679cac21a580badc84b755b8df0f975cf", "patch": "@@ -33,7 +33,8 @@ fn main() {\n     match f.read(&mut buff) {\n         Ok(cnt) => println!(\"read this many bytes: {}\", cnt),\n         Err(IoError{ kind: EndOfFile, .. }) => println!(\"Got end of file: {}\", EndOfFile.to_string()),\n-        //~^ ERROR variable `EndOfFile` should have a snake case name such as `end_of_file`\n+//~^ ERROR variable `EndOfFile` should have a snake case name such as `end_of_file`\n+//~^^ WARN `EndOfFile` is named the same as one of the variants of the type `std::io::IoErrorKind`\n     }\n \n     test(1);"}, {"sha": "cee5c808f9982c9f2abffb676db472df666c8f89", "filename": "src/test/run-pass/issue-19100.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/fac5a07679cac21a580badc84b755b8df0f975cf/src%2Ftest%2Frun-pass%2Fissue-19100.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fac5a07679cac21a580badc84b755b8df0f975cf/src%2Ftest%2Frun-pass%2Fissue-19100.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-19100.rs?ref=fac5a07679cac21a580badc84b755b8df0f975cf", "patch": "@@ -0,0 +1,34 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+enum Foo {\n+    Bar,\n+    Baz\n+}\n+\n+impl Foo {\n+    fn foo(&self) {\n+        match self {\n+            &\n+Bar if true\n+//~^ WARN pattern binding `Bar` is named the same as one of the variants of the type `Foo`\n+//~^^ HELP to match on a variant, consider making the path in the pattern qualified: `Foo::Bar`\n+=> println!(\"bar\"),\n+            &\n+Baz if false\n+//~^ WARN pattern binding `Baz` is named the same as one of the variants of the type `Foo`\n+//~^^ HELP to match on a variant, consider making the path in the pattern qualified: `Foo::Baz`\n+=> println!(\"baz\"),\n+_ => ()\n+        }\n+    }\n+}\n+\n+fn main() {}"}]}