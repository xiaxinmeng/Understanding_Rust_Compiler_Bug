{"sha": "353c8eb828ec7a68621334b91bf0f01eaf3ed769", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM1M2M4ZWI4MjhlYzdhNjg2MjEzMzRiOTFiZjBmMDFlYWYzZWQ3Njk=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-06-19T07:36:20Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-06-20T07:28:12Z"}, "message": "shared_from_iter/Rc: Use specialization to elide allocation.", "tree": {"sha": "fdd1b88cd05e296b704a78577c5e0cbe930e6cc7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fdd1b88cd05e296b704a78577c5e0cbe930e6cc7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/353c8eb828ec7a68621334b91bf0f01eaf3ed769", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/353c8eb828ec7a68621334b91bf0f01eaf3ed769", "html_url": "https://github.com/rust-lang/rust/commit/353c8eb828ec7a68621334b91bf0f01eaf3ed769", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/353c8eb828ec7a68621334b91bf0f01eaf3ed769/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bf8f6c399b886480a2f2710531cf76de46b1c0cd", "url": "https://api.github.com/repos/rust-lang/rust/commits/bf8f6c399b886480a2f2710531cf76de46b1c0cd", "html_url": "https://github.com/rust-lang/rust/commit/bf8f6c399b886480a2f2710531cf76de46b1c0cd"}], "stats": {"total": 207, "additions": 168, "deletions": 39}, "files": [{"sha": "b679abacdc8d12caac43fc037d58d34256a03c31", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/353c8eb828ec7a68621334b91bf0f01eaf3ed769/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/353c8eb828ec7a68621334b91bf0f01eaf3ed769/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=353c8eb828ec7a68621334b91bf0f01eaf3ed769", "patch": "@@ -102,6 +102,7 @@\n #![feature(try_reserve)]\n #![feature(unboxed_closures)]\n #![feature(unicode_internals)]\n+#![feature(untagged_unions)]\n #![feature(unsize)]\n #![feature(unsized_locals)]\n #![feature(allocator_internals)]"}, {"sha": "43b6b3cea15d693679dadd3a2dceceafedaec07e", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 167, "deletions": 39, "changes": 206, "blob_url": "https://github.com/rust-lang/rust/blob/353c8eb828ec7a68621334b91bf0f01eaf3ed769/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/353c8eb828ec7a68621334b91bf0f01eaf3ed769/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=353c8eb828ec7a68621334b91bf0f01eaf3ed769", "patch": "@@ -238,12 +238,13 @@ use core::cmp::Ordering;\n use core::fmt;\n use core::hash::{Hash, Hasher};\n use core::intrinsics::abort;\n+use core::iter;\n use core::marker::{self, Unpin, Unsize, PhantomData};\n use core::mem::{self, align_of, align_of_val, forget, size_of_val};\n use core::ops::{Deref, Receiver, CoerceUnsized, DispatchFromDyn};\n use core::pin::Pin;\n use core::ptr::{self, NonNull};\n-use core::slice::from_raw_parts_mut;\n+use core::slice::{self, from_raw_parts_mut};\n use core::convert::From;\n use core::usize;\n \n@@ -698,21 +699,29 @@ impl Rc<dyn Any> {\n }\n \n impl<T: ?Sized> Rc<T> {\n-    // Allocates an `RcBox<T>` with sufficient space for an unsized value\n-    unsafe fn allocate_for_ptr(ptr: *const T) -> *mut RcBox<T> {\n-        // Calculate layout using the given value.\n+    // Allocates an `RcBox<T>` with sufficient space for\n+    // an unsized value where the value has the layout provided.\n+    //\n+    // The function `mem_to_rcbox` is called with the data pointer\n+    // and must return back a (potentially fat)-pointer for the `RcBox<T>`.\n+    unsafe fn allocate_for_unsized(\n+        value_layout: Layout,\n+        mem_to_rcbox: impl FnOnce(*mut u8) -> *mut RcBox<T>\n+    ) -> *mut RcBox<T> {\n+        // Calculate layout using the given value layout.\n         // Previously, layout was calculated on the expression\n         // `&*(ptr as *const RcBox<T>)`, but this created a misaligned\n         // reference (see #54908).\n         let layout = Layout::new::<RcBox<()>>()\n-            .extend(Layout::for_value(&*ptr)).unwrap().0\n+            .extend(value_layout).unwrap().0\n             .pad_to_align().unwrap();\n \n+        // Allocate for the layout.\n         let mem = Global.alloc(layout)\n             .unwrap_or_else(|_| handle_alloc_error(layout));\n \n         // Initialize the RcBox\n-        let inner = set_data_ptr(ptr as *mut T, mem.as_ptr() as *mut u8) as *mut RcBox<T>;\n+        let inner = mem_to_rcbox(mem.as_ptr());\n         debug_assert_eq!(Layout::for_value(&*inner), layout);\n \n         ptr::write(&mut (*inner).strong, Cell::new(1));\n@@ -721,6 +730,15 @@ impl<T: ?Sized> Rc<T> {\n         inner\n     }\n \n+    // Allocates an `RcBox<T>` with sufficient space for an unsized value\n+    unsafe fn allocate_for_ptr(ptr: *const T) -> *mut RcBox<T> {\n+        // Allocate for the `RcBox<T>` using the given value.\n+        Self::allocate_for_unsized(\n+            Layout::for_value(&*ptr),\n+            |mem| set_data_ptr(ptr as *mut T, mem) as *mut RcBox<T>,\n+        )\n+    }\n+\n     fn from_box(v: Box<T>) -> Rc<T> {\n         unsafe {\n             let box_unique = Box::into_unique(v);\n@@ -743,6 +761,32 @@ impl<T: ?Sized> Rc<T> {\n     }\n }\n \n+impl<T> Rc<[T]> {\n+    // Allocates an `RcBox<[T]>` with the given length.\n+    unsafe fn allocate_for_slice(len: usize) -> *mut RcBox<[T]> {\n+        // FIXME(#60667): Deduplicate.\n+        fn slice_from_raw_parts_mut<T>(data: *mut T, len: usize) -> *mut [T] {\n+            #[repr(C)]\n+            union Repr<T> {\n+                rust_mut: *mut [T],\n+                raw: FatPtr<T>,\n+            }\n+\n+            #[repr(C)]\n+            struct FatPtr<T> {\n+                data: *const T,\n+                len: usize,\n+            }\n+            unsafe { Repr { raw: FatPtr { data, len } }.rust_mut }\n+        }\n+\n+        Self::allocate_for_unsized(\n+            Layout::array::<T>(len).unwrap(),\n+            |mem| slice_from_raw_parts_mut(mem as *mut T, len) as *mut RcBox<[T]>,\n+        )\n+    }\n+}\n+\n // Sets the data pointer of a `?Sized` raw pointer.\n //\n // For a slice/trait object, this sets the `data` field and leaves the rest\n@@ -757,8 +801,7 @@ impl<T> Rc<[T]> {\n     //\n     // Unsafe because the caller must either take ownership or bind `T: Copy`\n     unsafe fn copy_from_slice(v: &[T]) -> Rc<[T]> {\n-        let v_ptr = v as *const [T];\n-        let ptr = Self::allocate_for_ptr(v_ptr);\n+        let ptr = Self::allocate_for_slice(v.len());\n \n         ptr::copy_nonoverlapping(\n             v.as_ptr(),\n@@ -767,15 +810,11 @@ impl<T> Rc<[T]> {\n \n         Self::from_ptr(ptr)\n     }\n-}\n \n-trait RcFromSlice<T> {\n-    fn from_slice(slice: &[T]) -> Self;\n-}\n-\n-impl<T: Clone> RcFromSlice<T> for Rc<[T]> {\n-    #[inline]\n-    default fn from_slice(v: &[T]) -> Self {\n+    /// Constructs an `Rc<[T]>` from an iterator known to be of a certain size.\n+    ///\n+    /// Behavior is undefined should the size be wrong.\n+    unsafe fn from_iter_exact(iter: impl iter::Iterator<Item = T>, len: usize) -> Rc<[T]> {\n         // Panic guard while cloning T elements.\n         // In the event of a panic, elements that have been written\n         // into the new RcBox will be dropped, then the memory freed.\n@@ -797,32 +836,42 @@ impl<T: Clone> RcFromSlice<T> for Rc<[T]> {\n             }\n         }\n \n-        unsafe {\n-            let v_ptr = v as *const [T];\n-            let ptr = Self::allocate_for_ptr(v_ptr);\n+        let ptr = Self::allocate_for_slice(len);\n \n-            let mem = ptr as *mut _ as *mut u8;\n-            let layout = Layout::for_value(&*ptr);\n+        let mem = ptr as *mut _ as *mut u8;\n+        let layout = Layout::for_value(&*ptr);\n \n-            // Pointer to first element\n-            let elems = &mut (*ptr).value as *mut [T] as *mut T;\n+        // Pointer to first element\n+        let elems = &mut (*ptr).value as *mut [T] as *mut T;\n \n-            let mut guard = Guard {\n-                mem: NonNull::new_unchecked(mem),\n-                elems: elems,\n-                layout: layout,\n-                n_elems: 0,\n-            };\n+        let mut guard = Guard {\n+            mem: NonNull::new_unchecked(mem),\n+            elems,\n+            layout,\n+            n_elems: 0,\n+        };\n \n-            for (i, item) in v.iter().enumerate() {\n-                ptr::write(elems.add(i), item.clone());\n-                guard.n_elems += 1;\n-            }\n+        for (i, item) in iter.enumerate() {\n+            ptr::write(elems.add(i), item);\n+            guard.n_elems += 1;\n+        }\n \n-            // All clear. Forget the guard so it doesn't free the new RcBox.\n-            forget(guard);\n+        // All clear. Forget the guard so it doesn't free the new RcBox.\n+        forget(guard);\n \n-            Self::from_ptr(ptr)\n+        Self::from_ptr(ptr)\n+    }\n+}\n+\n+trait RcFromSlice<T> {\n+    fn from_slice(slice: &[T]) -> Self;\n+}\n+\n+impl<T: Clone> RcFromSlice<T> for Rc<[T]> {\n+    #[inline]\n+    default fn from_slice(v: &[T]) -> Self {\n+        unsafe {\n+            Self::from_iter_exact(v.iter().cloned(), v.len())\n         }\n     }\n }\n@@ -1221,9 +1270,88 @@ impl<T> From<Vec<T>> for Rc<[T]> {\n }\n \n #[stable(feature = \"shared_from_iter\", since = \"1.37.0\")]\n-impl<T> core::iter::FromIterator<T> for Rc<[T]> {\n-    fn from_iter<I: IntoIterator<Item = T>>(iter: I) -> Self {\n-        iter.into_iter().collect::<Vec<T>>().into()\n+impl<T> iter::FromIterator<T> for Rc<[T]> {\n+    /// Takes each element in the `Iterator` and collects it into an `Rc<[T]>`.\n+    ///\n+    /// # Performance characteristics\n+    ///\n+    /// ## The general case\n+    ///\n+    /// In the general case, collecting into `Rc<[T]>` is done by first\n+    /// collecting into a `Vec<T>`. That is, when writing the following:\n+    ///\n+    /// ```rust\n+    /// # use std::rc::Rc;\n+    /// let evens: Rc<[u8]> = (0..10).filter(|&x| x % 2 == 0).collect();\n+    /// # assert_eq!(&*evens, &[0, 2, 4, 6, 8]);\n+    /// ```\n+    ///\n+    /// this behaves as if we wrote:\n+    ///\n+    /// ```rust\n+    /// # use std::rc::Rc;\n+    /// let evens: Rc<[u8]> = (0..10).filter(|&x| x % 2 == 0)\n+    ///     .collect::<Vec<_>>() // The first set of allocations happens here.\n+    ///     .into(); // A second allocation for `Rc<[T]>` happens here.\n+    /// # assert_eq!(&*evens, &[0, 2, 4, 6, 8]);\n+    /// ```\n+    ///\n+    /// This will allocate as many times as needed for constructing the `Vec<T>`\n+    /// and then it will allocate once for turning the `Vec<T>` into the `Rc<[T]>`.\n+    ///\n+    /// ## Iterators of known length\n+    ///\n+    /// When your `Iterator` implements `TrustedLen` and is of an exact size,\n+    /// a single allocation will be made for the `Rc<[T]>`. For example:\n+    ///\n+    /// ```rust\n+    /// # use std::rc::Rc;\n+    /// let evens: Rc<[u8]> = (0..10).collect(); // Just a single allocation happens here.\n+    /// # assert_eq!(&*evens, &*(0..10).collect::<Vec<_>>());\n+    /// ```\n+    fn from_iter<I: iter::IntoIterator<Item = T>>(iter: I) -> Self {\n+        RcFromIter::from_iter(iter.into_iter())\n+    }\n+}\n+\n+/// Specialization trait used for collecting into `Rc<[T]>`.\n+trait RcFromIter<T, I> {\n+    fn from_iter(iter: I) -> Self;\n+}\n+\n+impl<T, I: Iterator<Item = T>> RcFromIter<T, I> for Rc<[T]> {\n+    default fn from_iter(iter: I) -> Self {\n+        iter.collect::<Vec<T>>().into()\n+    }\n+}\n+\n+impl<T, I: iter::TrustedLen<Item = T>> RcFromIter<T, I> for Rc<[T]>  {\n+    default fn from_iter(iter: I) -> Self {\n+        // This is the case for a `TrustedLen` iterator.\n+        let (low, high) = iter.size_hint();\n+        if let Some(high) = high {\n+            debug_assert_eq!(\n+                low, high,\n+                \"TrustedLen iterator's size hint is not exact: {:?}\",\n+                (low, high)\n+            );\n+\n+            unsafe {\n+                // SAFETY: We need to ensure that the iterator has an exact length and we have.\n+                Rc::from_iter_exact(iter, low)\n+            }\n+        } else {\n+            // Fall back to normal implementation.\n+            iter.collect::<Vec<T>>().into()\n+        }\n+    }\n+}\n+\n+impl<'a, T: 'a + Clone> RcFromIter<&'a T, slice::Iter<'a, T>> for Rc<[T]> {\n+    fn from_iter(iter: slice::Iter<'a, T>) -> Self {\n+        // Delegate to `impl<T: Clone> From<&[T]> for Rc<[T]>`\n+        // which will use `ptr::copy_nonoverlapping`.\n+        iter.as_slice().into()\n     }\n }\n "}]}