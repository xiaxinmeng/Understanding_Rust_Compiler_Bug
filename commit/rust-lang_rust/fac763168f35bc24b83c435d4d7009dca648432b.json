{"sha": "fac763168f35bc24b83c435d4d7009dca648432b", "node_id": "C_kwDOAAsO6NoAKGZhYzc2MzE2OGYzNWJjMjRiODNjNDM1ZDRkNzAwOWRjYTY0ODQzMmI", "commit": {"author": {"name": "Santiago Pastorino", "email": "spastorino@gmail.com", "date": "2022-07-26T14:56:26Z"}, "committer": {"name": "Santiago Pastorino", "email": "spastorino@gmail.com", "date": "2022-08-04T14:26:52Z"}, "message": "Remove NEW_COLLECT_LIFETIMES env var", "tree": {"sha": "9fa8c8a71483b05622f5d5f574e1af32ac46d734", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9fa8c8a71483b05622f5d5f574e1af32ac46d734"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fac763168f35bc24b83c435d4d7009dca648432b", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEF0ntrgrd9qf9uuThgTGiTgx5768FAmLr1ywACgkQgTGiTgx5\n768MrxAAlM/iRtV8Exg15Gwzm5nYKfExHd0Z9m1hlmgjWDKUsxDOe1pjo2JU0OZK\nDFqgDIHVHcqLV53qLe2u/QKQy7p3eEPzsRp4aAL8qq+BwJVuXRELqS5RB/jPfHtt\n5LnCQPeOc6A/UlHkQKQmA+cPeHgYOT0WeahXAaobMcq+ZeG43VjLF6MNjGD8QzjZ\nY15qKO3Nb+ieYpEXDhrD7csq6gJtd+z0Iy06SnFgWoGnJcHwP5FAotvSV+cinbWH\nO6zyXpy37JaIE7ieu5/+tc9Rq1PQeW4z75uGdH1HbzVTaGk/EkQxhXVcgHhsuXX9\nFuscqIxZOO94mQtJajux4zJaZvF2ii1amxVjPAfU4AGj20JJJHp1tFXgykCOw+T8\n2VF4esYNdVq7t6bDr4Zl8293NxXik7VWrsXHeW4DT69PDvLA9YLLraZiZP+5np/M\nB6Llp+TTriZSI72omMk5z2KTqX1RmnJrrBqXDN2YzafOp4OdFjt/fgw3CFQLXNMH\n+kWAboyr5FqACy9gb12e1V6Xu5Fo94Q7LBd059zml5OGD77nGb2Nbce04AVWkCkm\nwfYu/LhrY2GN5caayy6BimBt36QMzB1lLeNNGKYJAtxsyHza2zeL4wEK5WkCXQR0\nI0dAB4rtbYn0CJ7kosJXVOT0ZF6RSu03ue0+U16/DhhCHF46dAY=\n=04cw\n-----END PGP SIGNATURE-----", "payload": "tree 9fa8c8a71483b05622f5d5f574e1af32ac46d734\nparent 399609e841f36f32d22d53df4c1633ff038f2ff7\nauthor Santiago Pastorino <spastorino@gmail.com> 1658847386 -0300\ncommitter Santiago Pastorino <spastorino@gmail.com> 1659623212 -0300\n\nRemove NEW_COLLECT_LIFETIMES env var\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fac763168f35bc24b83c435d4d7009dca648432b", "html_url": "https://github.com/rust-lang/rust/commit/fac763168f35bc24b83c435d4d7009dca648432b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fac763168f35bc24b83c435d4d7009dca648432b/comments", "author": {"login": "spastorino", "id": 52642, "node_id": "MDQ6VXNlcjUyNjQy", "avatar_url": "https://avatars.githubusercontent.com/u/52642?v=4", "gravatar_id": "", "url": "https://api.github.com/users/spastorino", "html_url": "https://github.com/spastorino", "followers_url": "https://api.github.com/users/spastorino/followers", "following_url": "https://api.github.com/users/spastorino/following{/other_user}", "gists_url": "https://api.github.com/users/spastorino/gists{/gist_id}", "starred_url": "https://api.github.com/users/spastorino/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/spastorino/subscriptions", "organizations_url": "https://api.github.com/users/spastorino/orgs", "repos_url": "https://api.github.com/users/spastorino/repos", "events_url": "https://api.github.com/users/spastorino/events{/privacy}", "received_events_url": "https://api.github.com/users/spastorino/received_events", "type": "User", "site_admin": false}, "committer": {"login": "spastorino", "id": 52642, "node_id": "MDQ6VXNlcjUyNjQy", "avatar_url": "https://avatars.githubusercontent.com/u/52642?v=4", "gravatar_id": "", "url": "https://api.github.com/users/spastorino", "html_url": "https://github.com/spastorino", "followers_url": "https://api.github.com/users/spastorino/followers", "following_url": "https://api.github.com/users/spastorino/following{/other_user}", "gists_url": "https://api.github.com/users/spastorino/gists{/gist_id}", "starred_url": "https://api.github.com/users/spastorino/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/spastorino/subscriptions", "organizations_url": "https://api.github.com/users/spastorino/orgs", "repos_url": "https://api.github.com/users/spastorino/repos", "events_url": "https://api.github.com/users/spastorino/events{/privacy}", "received_events_url": "https://api.github.com/users/spastorino/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "399609e841f36f32d22d53df4c1633ff038f2ff7", "url": "https://api.github.com/repos/rust-lang/rust/commits/399609e841f36f32d22d53df4c1633ff038f2ff7", "html_url": "https://github.com/rust-lang/rust/commit/399609e841f36f32d22d53df4c1633ff038f2ff7"}], "stats": {"total": 186, "additions": 82, "deletions": 104}, "files": [{"sha": "aa84373b6cf8826482b8b7c85e6406b01b4c523c", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 82, "deletions": 104, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/fac763168f35bc24b83c435d4d7009dca648432b/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fac763168f35bc24b83c435d4d7009dca648432b/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=fac763168f35bc24b83c435d4d7009dca648432b", "patch": "@@ -1377,125 +1377,103 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             let hir_bounds = if origin == hir::OpaqueTyOrigin::TyAlias {\n                 lctx.lower_param_bounds(bounds, itctx, true)\n             } else {\n-                if std::env::var(\"NEW_COLLECT_LIFETIMES\").is_ok() {\n-                    debug!(?lctx.captured_lifetimes);\n-\n-                    let lifetime_stash = std::mem::replace(\n-                        &mut lctx.captured_lifetimes,\n-                        Some(LifetimeCaptureContext {\n-                            parent_def_id: opaque_ty_def_id,\n-                            captures: std::mem::take(&mut collected_lifetimes),\n-                            binders_to_ignore: Default::default(),\n-                        }),\n-                    );\n-\n-                    let (lifetimes_in_bounds, binders_to_ignore) = ast::lifetimes_in_bounds(bounds);\n-                    debug!(?lifetimes_in_bounds);\n-                    debug!(?binders_to_ignore);\n-\n-                    for lifetime in &lifetimes_in_bounds {\n-                        let ident = lifetime.ident;\n-                        let span = ident.span;\n-\n-                        let res = lctx\n-                            .resolver\n-                            .get_lifetime_res(lifetime.id)\n-                            .unwrap_or(LifetimeRes::Error);\n-                        debug!(?res);\n-\n-                        if let Some(mut captured_lifetimes) = lctx.captured_lifetimes.take() {\n-                            match res {\n-                                LifetimeRes::Param { param, binder } => {\n-                                    if !captured_lifetimes.binders_to_ignore.contains(&binder)\n-                                        && !binders_to_ignore\n-                                            .get(&lifetime.id)\n-                                            .unwrap_or(&Vec::new())\n-                                            .contains(&binder)\n-                                    {\n-                                        match captured_lifetimes.captures.entry(param) {\n-                                            Entry::Occupied(_) => {}\n-                                            Entry::Vacant(v) => {\n-                                                let node_id = lctx.next_node_id();\n-                                                let name = ParamName::Plain(ident);\n-\n-                                                lctx.create_def(\n-                                                    captured_lifetimes.parent_def_id,\n-                                                    node_id,\n-                                                    DefPathData::LifetimeNs(name.ident().name),\n-                                                );\n-\n-                                                v.insert((span, node_id, name, res));\n-                                            }\n+                debug!(?lctx.captured_lifetimes);\n+\n+                let lifetime_stash = std::mem::replace(\n+                    &mut lctx.captured_lifetimes,\n+                    Some(LifetimeCaptureContext {\n+                        parent_def_id: opaque_ty_def_id,\n+                        captures: std::mem::take(&mut collected_lifetimes),\n+                        binders_to_ignore: Default::default(),\n+                    }),\n+                );\n+\n+                let (lifetimes_in_bounds, binders_to_ignore) = ast::lifetimes_in_bounds(bounds);\n+                debug!(?lifetimes_in_bounds);\n+                debug!(?binders_to_ignore);\n+\n+                for lifetime in &lifetimes_in_bounds {\n+                    let ident = lifetime.ident;\n+                    let span = ident.span;\n+\n+                    let res =\n+                        lctx.resolver.get_lifetime_res(lifetime.id).unwrap_or(LifetimeRes::Error);\n+                    debug!(?res);\n+\n+                    if let Some(mut captured_lifetimes) = lctx.captured_lifetimes.take() {\n+                        match res {\n+                            LifetimeRes::Param { param, binder } => {\n+                                if !captured_lifetimes.binders_to_ignore.contains(&binder)\n+                                    && !binders_to_ignore\n+                                        .get(&lifetime.id)\n+                                        .unwrap_or(&Vec::new())\n+                                        .contains(&binder)\n+                                {\n+                                    match captured_lifetimes.captures.entry(param) {\n+                                        Entry::Occupied(_) => {}\n+                                        Entry::Vacant(v) => {\n+                                            let node_id = lctx.next_node_id();\n+                                            let name = ParamName::Plain(ident);\n+\n+                                            lctx.create_def(\n+                                                captured_lifetimes.parent_def_id,\n+                                                node_id,\n+                                                DefPathData::LifetimeNs(name.ident().name),\n+                                            );\n+\n+                                            v.insert((span, node_id, name, res));\n                                         }\n                                     }\n                                 }\n+                            }\n \n-                                LifetimeRes::Fresh { param, binder } => {\n-                                    debug_assert_eq!(ident.name, kw::UnderscoreLifetime);\n-                                    if !captured_lifetimes.binders_to_ignore.contains(&binder)\n-                                        && !binders_to_ignore\n-                                            .get(&lifetime.id)\n-                                            .unwrap_or(&Vec::new())\n-                                            .contains(&binder)\n-                                    {\n-                                        let param = lctx.local_def_id(param);\n-                                        match captured_lifetimes.captures.entry(param) {\n-                                            Entry::Occupied(_) => {}\n-                                            Entry::Vacant(v) => {\n-                                                let node_id = lctx.next_node_id();\n-\n-                                                let name = ParamName::Fresh;\n-\n-                                                lctx.create_def(\n-                                                    captured_lifetimes.parent_def_id,\n-                                                    node_id,\n-                                                    DefPathData::LifetimeNs(kw::UnderscoreLifetime),\n-                                                );\n-\n-                                                v.insert((span, node_id, name, res));\n-                                            }\n+                            LifetimeRes::Fresh { param, binder } => {\n+                                debug_assert_eq!(ident.name, kw::UnderscoreLifetime);\n+                                if !captured_lifetimes.binders_to_ignore.contains(&binder)\n+                                    && !binders_to_ignore\n+                                        .get(&lifetime.id)\n+                                        .unwrap_or(&Vec::new())\n+                                        .contains(&binder)\n+                                {\n+                                    let param = lctx.local_def_id(param);\n+                                    match captured_lifetimes.captures.entry(param) {\n+                                        Entry::Occupied(_) => {}\n+                                        Entry::Vacant(v) => {\n+                                            let node_id = lctx.next_node_id();\n+\n+                                            let name = ParamName::Fresh;\n+\n+                                            lctx.create_def(\n+                                                captured_lifetimes.parent_def_id,\n+                                                node_id,\n+                                                DefPathData::LifetimeNs(kw::UnderscoreLifetime),\n+                                            );\n+\n+                                            v.insert((span, node_id, name, res));\n                                         }\n                                     }\n                                 }\n-\n-                                LifetimeRes::Infer | LifetimeRes::Static | LifetimeRes::Error => {}\n-\n-                                res => panic!(\n-                                    \"Unexpected lifetime resolution {:?} for {:?} at {:?}\",\n-                                    res, lifetime.ident, lifetime.ident.span\n-                                ),\n                             }\n \n-                            lctx.captured_lifetimes = Some(captured_lifetimes);\n-                        }\n-                    }\n-\n-                    let ret = lctx.lower_param_bounds(bounds, itctx, false);\n+                            LifetimeRes::Infer | LifetimeRes::Static | LifetimeRes::Error => {}\n \n-                    let ctxt =\n-                        std::mem::replace(&mut lctx.captured_lifetimes, lifetime_stash).unwrap();\n+                            res => panic!(\n+                                \"Unexpected lifetime resolution {:?} for {:?} at {:?}\",\n+                                res, lifetime.ident, lifetime.ident.span\n+                            ),\n+                        }\n \n-                    collected_lifetimes = ctxt.captures;\n+                        lctx.captured_lifetimes = Some(captured_lifetimes);\n+                    }\n+                }\n \n-                    ret\n-                } else {\n-                    let lifetime_stash = std::mem::replace(\n-                        &mut lctx.captured_lifetimes,\n-                        Some(LifetimeCaptureContext {\n-                            parent_def_id: opaque_ty_def_id,\n-                            captures: std::mem::take(&mut collected_lifetimes),\n-                            binders_to_ignore: Default::default(),\n-                        }),\n-                    );\n+                let ret = lctx.lower_param_bounds(bounds, itctx, false);\n \n-                    let ret = lctx.lower_param_bounds(bounds, itctx, true);\n+                let ctxt = std::mem::replace(&mut lctx.captured_lifetimes, lifetime_stash).unwrap();\n \n-                    let ctxt =\n-                        std::mem::replace(&mut lctx.captured_lifetimes, lifetime_stash).unwrap();\n-                    collected_lifetimes = ctxt.captures;\n+                collected_lifetimes = ctxt.captures;\n \n-                    ret\n-                }\n+                ret\n             };\n             debug!(?collected_lifetimes);\n "}]}