{"sha": "df04d28163cc42e2c5b1072abe68460f904e42be", "node_id": "C_kwDOAAsO6NoAKGRmMDRkMjgxNjNjYzQyZTJjNWIxMDcyYWJlNjg0NjBmOTA0ZTQyYmU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-27T10:35:00Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-27T10:35:00Z"}, "message": "Auto merge of #103917 - oli-obk:layout_math, r=RalfJung,lcnr\n\nVarious cleanups around scalar layout restrictions\n\nPulled out of https://github.com/rust-lang/rust/pull/103724", "tree": {"sha": "332ecf0df1e53bf06a2b9fe766dfa952f88fb828", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/332ecf0df1e53bf06a2b9fe766dfa952f88fb828"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/df04d28163cc42e2c5b1072abe68460f904e42be", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/df04d28163cc42e2c5b1072abe68460f904e42be", "html_url": "https://github.com/rust-lang/rust/commit/df04d28163cc42e2c5b1072abe68460f904e42be", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/df04d28163cc42e2c5b1072abe68460f904e42be/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5ac7e08aaf10d2882c6addcf220872c9390ed91e", "url": "https://api.github.com/repos/rust-lang/rust/commits/5ac7e08aaf10d2882c6addcf220872c9390ed91e", "html_url": "https://github.com/rust-lang/rust/commit/5ac7e08aaf10d2882c6addcf220872c9390ed91e"}, {"sha": "208bb933e7a6d8820646e3e367e2bf188d85e485", "url": "https://api.github.com/repos/rust-lang/rust/commits/208bb933e7a6d8820646e3e367e2bf188d85e485", "html_url": "https://github.com/rust-lang/rust/commit/208bb933e7a6d8820646e3e367e2bf188d85e485"}], "stats": {"total": 390, "additions": 261, "deletions": 129}, "files": [{"sha": "11e7b80f85efd1a7a49c68c4220105de4589d41e", "filename": "compiler/rustc_abi/src/layout.rs", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/df04d28163cc42e2c5b1072abe68460f904e42be/compiler%2Frustc_abi%2Fsrc%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df04d28163cc42e2c5b1072abe68460f904e42be/compiler%2Frustc_abi%2Fsrc%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_abi%2Fsrc%2Flayout.rs?ref=df04d28163cc42e2c5b1072abe68460f904e42be", "patch": "@@ -382,28 +382,26 @@ pub trait LayoutCalculator {\n             let (start, end) = scalar_valid_range;\n             match st.abi {\n                 Abi::Scalar(ref mut scalar) | Abi::ScalarPair(ref mut scalar, _) => {\n-                    // the asserts ensure that we are not using the\n-                    // `#[rustc_layout_scalar_valid_range(n)]`\n-                    // attribute to widen the range of anything as that would probably\n-                    // result in UB somewhere\n-                    // FIXME(eddyb) the asserts are probably not needed,\n-                    // as larger validity ranges would result in missed\n+                    // Enlarging validity ranges would result in missed\n                     // optimizations, *not* wrongly assuming the inner\n-                    // value is valid. e.g. unions enlarge validity ranges,\n+                    // value is valid. e.g. unions already enlarge validity ranges,\n                     // because the values may be uninitialized.\n+                    //\n+                    // Because of that we only check that the start and end\n+                    // of the range is representable with this scalar type.\n+\n+                    let max_value = scalar.size(dl).unsigned_int_max();\n                     if let Bound::Included(start) = start {\n                         // FIXME(eddyb) this might be incorrect - it doesn't\n                         // account for wrap-around (end < start) ranges.\n-                        let valid_range = scalar.valid_range_mut();\n-                        assert!(valid_range.start <= start);\n-                        valid_range.start = start;\n+                        assert!(start <= max_value, \"{start} > {max_value}\");\n+                        scalar.valid_range_mut().start = start;\n                     }\n                     if let Bound::Included(end) = end {\n                         // FIXME(eddyb) this might be incorrect - it doesn't\n                         // account for wrap-around (end < start) ranges.\n-                        let valid_range = scalar.valid_range_mut();\n-                        assert!(valid_range.end >= end);\n-                        valid_range.end = end;\n+                        assert!(end <= max_value, \"{end} > {max_value}\");\n+                        scalar.valid_range_mut().end = end;\n                     }\n \n                     // Update `largest_niche` if we have introduced a larger niche."}, {"sha": "0e85c7d11bce560b3af9d507a25f23b2e0aa0eaf", "filename": "compiler/rustc_const_eval/src/interpret/validity.rs", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/df04d28163cc42e2c5b1072abe68460f904e42be/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df04d28163cc42e2c5b1072abe68460f904e42be/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs?ref=df04d28163cc42e2c5b1072abe68460f904e42be", "patch": "@@ -785,18 +785,10 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                 }\n             }\n             Abi::ScalarPair(a_layout, b_layout) => {\n-                // There is no `rustc_layout_scalar_valid_range_start` for pairs, so\n-                // we would validate these things as we descend into the fields,\n-                // but that can miss bugs in layout computation. Layout computation\n-                // is subtle due to enums having ScalarPair layout, where one field\n-                // is the discriminant.\n-                if cfg!(debug_assertions)\n-                    && !a_layout.is_uninit_valid()\n-                    && !b_layout.is_uninit_valid()\n-                {\n-                    // We can only proceed if *both* scalars need to be initialized.\n-                    // FIXME: find a way to also check ScalarPair when one side can be uninit but\n-                    // the other must be init.\n+                // We can only proceed if *both* scalars need to be initialized.\n+                // FIXME: find a way to also check ScalarPair when one side can be uninit but\n+                // the other must be init.\n+                if !a_layout.is_uninit_valid() && !b_layout.is_uninit_valid() {\n                     let (a, b) =\n                         self.read_immediate(op, \"initiailized scalar value\")?.to_scalar_pair();\n                     self.visit_scalar(a, a_layout)?;"}, {"sha": "bf700d3122465c584b1d15efc54a71ffe1ab88e1", "filename": "compiler/rustc_const_eval/src/transform/validate.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/df04d28163cc42e2c5b1072abe68460f904e42be/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df04d28163cc42e2c5b1072abe68460f904e42be/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs?ref=df04d28163cc42e2c5b1072abe68460f904e42be", "patch": "@@ -81,6 +81,7 @@ struct TypeChecker<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n+    #[track_caller]\n     fn fail(&self, location: Location, msg: impl AsRef<str>) {\n         let span = self.body.source_info(location).span;\n         // We use `delay_span_bug` as we might see broken MIR when other errors have already\n@@ -226,12 +227,12 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n                 let check_equal = |this: &Self, location, f_ty| {\n                     if !this.mir_assign_valid_types(ty, f_ty) {\n                         this.fail(\n-                        location,\n-                        format!(\n-                            \"Field projection `{:?}.{:?}` specified type `{:?}`, but actual type is `{:?}`\",\n-                            parent, f, ty, f_ty\n+                            location,\n+                            format!(\n+                                \"Field projection `{:?}.{:?}` specified type `{:?}`, but actual type is `{:?}`\",\n+                                parent, f, ty, f_ty\n+                            )\n                         )\n-                    )\n                     }\n                 };\n "}, {"sha": "93d81125f48855e6d88be848941aa17b9e4877d0", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 97, "deletions": 63, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/df04d28163cc42e2c5b1072abe68460f904e42be/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df04d28163cc42e2c5b1072abe68460f904e42be/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=df04d28163cc42e2c5b1072abe68460f904e42be", "patch": "@@ -52,7 +52,7 @@ use rustc_span::edition::Edition;\n use rustc_span::source_map::Spanned;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{BytePos, InnerSpan, Span};\n-use rustc_target::abi::VariantIdx;\n+use rustc_target::abi::{Abi, VariantIdx};\n use rustc_trait_selection::traits::{self, misc::can_type_implement_copy};\n \n use crate::nonstandard_style::{method_context, MethodLateContext};\n@@ -2413,8 +2413,34 @@ impl<'tcx> LateLintPass<'tcx> for InvalidValue {\n         }\n \n         /// Information about why a type cannot be initialized this way.\n-        /// Contains an error message and optionally a span to point at.\n-        type InitError = (String, Option<Span>);\n+        struct InitError {\n+            message: String,\n+            /// Spans from struct fields and similar that can be obtained from just the type.\n+            span: Option<Span>,\n+            /// Used to report a trace through adts.\n+            nested: Option<Box<InitError>>,\n+        }\n+        impl InitError {\n+            fn spanned(self, span: Span) -> InitError {\n+                Self { span: Some(span), ..self }\n+            }\n+\n+            fn nested(self, nested: impl Into<Option<InitError>>) -> InitError {\n+                assert!(self.nested.is_none());\n+                Self { nested: nested.into().map(Box::new), ..self }\n+            }\n+        }\n+\n+        impl<'a> From<&'a str> for InitError {\n+            fn from(s: &'a str) -> Self {\n+                s.to_owned().into()\n+            }\n+        }\n+        impl From<String> for InitError {\n+            fn from(message: String) -> Self {\n+                Self { message, span: None, nested: None }\n+            }\n+        }\n \n         /// Test if this constant is all-0.\n         fn is_zero(expr: &hir::Expr<'_>) -> bool {\n@@ -2470,25 +2496,54 @@ impl<'tcx> LateLintPass<'tcx> for InvalidValue {\n \n         fn variant_find_init_error<'tcx>(\n             cx: &LateContext<'tcx>,\n+            ty: Ty<'tcx>,\n             variant: &VariantDef,\n             substs: ty::SubstsRef<'tcx>,\n             descr: &str,\n             init: InitKind,\n         ) -> Option<InitError> {\n-            variant.fields.iter().find_map(|field| {\n-                ty_find_init_error(cx, field.ty(cx.tcx, substs), init).map(|(mut msg, span)| {\n-                    if span.is_none() {\n-                        // Point to this field, should be helpful for figuring\n-                        // out where the source of the error is.\n-                        let span = cx.tcx.def_span(field.did);\n-                        write!(&mut msg, \" (in this {descr})\").unwrap();\n-                        (msg, Some(span))\n+            let mut field_err = variant.fields.iter().find_map(|field| {\n+                ty_find_init_error(cx, field.ty(cx.tcx, substs), init).map(|mut err| {\n+                    if !field.did.is_local() {\n+                        err\n+                    } else if err.span.is_none() {\n+                        err.span = Some(cx.tcx.def_span(field.did));\n+                        write!(&mut err.message, \" (in this {descr})\").unwrap();\n+                        err\n                     } else {\n-                        // Just forward.\n-                        (msg, span)\n+                        InitError::from(format!(\"in this {descr}\"))\n+                            .spanned(cx.tcx.def_span(field.did))\n+                            .nested(err)\n                     }\n                 })\n-            })\n+            });\n+\n+            // Check if this ADT has a constrained layout (like `NonNull` and friends).\n+            if let Ok(layout) = cx.tcx.layout_of(cx.param_env.and(ty)) {\n+                if let Abi::Scalar(scalar) | Abi::ScalarPair(scalar, _) = &layout.abi {\n+                    let range = scalar.valid_range(cx);\n+                    let msg = if !range.contains(0) {\n+                        \"must be non-null\"\n+                    } else if init == InitKind::Uninit && !scalar.is_always_valid(cx) {\n+                        // Prefer reporting on the fields over the entire struct for uninit,\n+                        // as the information bubbles out and it may be unclear why the type can't\n+                        // be null from just its outside signature.\n+\n+                        \"must be initialized inside its custom valid range\"\n+                    } else {\n+                        return field_err;\n+                    };\n+                    if let Some(field_err) = &mut field_err {\n+                        // Most of the time, if the field error is the same as the struct error,\n+                        // the struct error only happens because of the field error.\n+                        if field_err.message.contains(msg) {\n+                            field_err.message = format!(\"because {}\", field_err.message);\n+                        }\n+                    }\n+                    return Some(InitError::from(format!(\"`{ty}` {msg}\")).nested(field_err));\n+                }\n+            }\n+            field_err\n         }\n \n         /// Return `Some` only if we are sure this type does *not*\n@@ -2501,63 +2556,36 @@ impl<'tcx> LateLintPass<'tcx> for InvalidValue {\n             use rustc_type_ir::sty::TyKind::*;\n             match ty.kind() {\n                 // Primitive types that don't like 0 as a value.\n-                Ref(..) => Some((\"references must be non-null\".to_string(), None)),\n-                Adt(..) if ty.is_box() => Some((\"`Box` must be non-null\".to_string(), None)),\n-                FnPtr(..) => Some((\"function pointers must be non-null\".to_string(), None)),\n-                Never => Some((\"the `!` type has no valid value\".to_string(), None)),\n+                Ref(..) => Some(\"references must be non-null\".into()),\n+                Adt(..) if ty.is_box() => Some(\"`Box` must be non-null\".into()),\n+                FnPtr(..) => Some(\"function pointers must be non-null\".into()),\n+                Never => Some(\"the `!` type has no valid value\".into()),\n                 RawPtr(tm) if matches!(tm.ty.kind(), Dynamic(..)) =>\n                 // raw ptr to dyn Trait\n                 {\n-                    Some((\"the vtable of a wide raw pointer must be non-null\".to_string(), None))\n+                    Some(\"the vtable of a wide raw pointer must be non-null\".into())\n                 }\n                 // Primitive types with other constraints.\n                 Bool if init == InitKind::Uninit => {\n-                    Some((\"booleans must be either `true` or `false`\".to_string(), None))\n+                    Some(\"booleans must be either `true` or `false`\".into())\n                 }\n                 Char if init == InitKind::Uninit => {\n-                    Some((\"characters must be a valid Unicode codepoint\".to_string(), None))\n+                    Some(\"characters must be a valid Unicode codepoint\".into())\n                 }\n                 Int(_) | Uint(_) if init == InitKind::Uninit => {\n-                    Some((\"integers must not be uninitialized\".to_string(), None))\n-                }\n-                Float(_) if init == InitKind::Uninit => {\n-                    Some((\"floats must not be uninitialized\".to_string(), None))\n+                    Some(\"integers must be initialized\".into())\n                 }\n+                Float(_) if init == InitKind::Uninit => Some(\"floats must be initialized\".into()),\n                 RawPtr(_) if init == InitKind::Uninit => {\n-                    Some((\"raw pointers must not be uninitialized\".to_string(), None))\n+                    Some(\"raw pointers must be initialized\".into())\n                 }\n                 // Recurse and checks for some compound types. (but not unions)\n                 Adt(adt_def, substs) if !adt_def.is_union() => {\n-                    // First check if this ADT has a layout attribute (like `NonNull` and friends).\n-                    use std::ops::Bound;\n-                    match cx.tcx.layout_scalar_valid_range(adt_def.did()) {\n-                        // We exploit here that `layout_scalar_valid_range` will never\n-                        // return `Bound::Excluded`.  (And we have tests checking that we\n-                        // handle the attribute correctly.)\n-                        // We don't add a span since users cannot declare such types anyway.\n-                        (Bound::Included(lo), Bound::Included(hi)) if 0 < lo && lo < hi => {\n-                            return Some((format!(\"`{}` must be non-null\", ty), None));\n-                        }\n-                        (Bound::Included(lo), Bound::Unbounded) if 0 < lo => {\n-                            return Some((format!(\"`{}` must be non-null\", ty), None));\n-                        }\n-                        (Bound::Included(_), _) | (_, Bound::Included(_))\n-                            if init == InitKind::Uninit =>\n-                        {\n-                            return Some((\n-                                format!(\n-                                    \"`{}` must be initialized inside its custom valid range\",\n-                                    ty,\n-                                ),\n-                                None,\n-                            ));\n-                        }\n-                        _ => {}\n-                    }\n                     // Handle structs.\n                     if adt_def.is_struct() {\n                         return variant_find_init_error(\n                             cx,\n+                            ty,\n                             adt_def.non_enum_variant(),\n                             substs,\n                             \"struct field\",\n@@ -2581,13 +2609,14 @@ impl<'tcx> LateLintPass<'tcx> for InvalidValue {\n                         Some((variant, definitely_inhabited))\n                     });\n                     let Some(first_variant) = potential_variants.next() else {\n-                        return Some((\"enums with no inhabited variants have no valid value\".to_string(), Some(span)));\n+                        return Some(InitError::from(\"enums with no inhabited variants have no valid value\").spanned(span));\n                     };\n                     // So we have at least one potentially inhabited variant. Might we have two?\n                     let Some(second_variant) = potential_variants.next() else {\n                         // There is only one potentially inhabited variant. So we can recursively check that variant!\n                         return variant_find_init_error(\n                             cx,\n+                            ty,\n                             &first_variant.0,\n                             substs,\n                             \"field of the only potentially inhabited enum variant\",\n@@ -2605,10 +2634,9 @@ impl<'tcx> LateLintPass<'tcx> for InvalidValue {\n                                 .filter(|(_variant, definitely_inhabited)| *definitely_inhabited)\n                                 .count();\n                         if definitely_inhabited > 1 {\n-                            return Some((\n-                                \"enums with multiple inhabited variants have to be initialized to a variant\".to_string(),\n-                                Some(span),\n-                            ));\n+                            return Some(InitError::from(\n+                                \"enums with multiple inhabited variants have to be initialized to a variant\",\n+                            ).spanned(span));\n                         }\n                     }\n                     // We couldn't find anything wrong here.\n@@ -2637,8 +2665,7 @@ impl<'tcx> LateLintPass<'tcx> for InvalidValue {\n             // using zeroed or uninitialized memory.\n             // We are extremely conservative with what we warn about.\n             let conjured_ty = cx.typeck_results().expr_ty(expr);\n-            if let Some((msg, span)) =\n-                with_no_trimmed_paths!(ty_find_init_error(cx, conjured_ty, init))\n+            if let Some(mut err) = with_no_trimmed_paths!(ty_find_init_error(cx, conjured_ty, init))\n             {\n                 // FIXME(davidtwco): make translatable\n                 cx.struct_span_lint(\n@@ -2664,10 +2691,17 @@ impl<'tcx> LateLintPass<'tcx> for InvalidValue {\n                             \"help: use `MaybeUninit<T>` instead, \\\n                             and only call `assume_init` after initialization is done\",\n                         );\n-                        if let Some(span) = span {\n-                            lint.span_note(span, &msg);\n-                        } else {\n-                            lint.note(&msg);\n+                        loop {\n+                            if let Some(span) = err.span {\n+                                lint.span_note(span, &err.message);\n+                            } else {\n+                                lint.note(&err.message);\n+                            }\n+                            if let Some(e) = err.nested {\n+                                err = *e;\n+                            } else {\n+                                break;\n+                            }\n                         }\n                         lint\n                     },"}, {"sha": "f3186e1c30c3dc4b4229f8501ac5e91d33131edd", "filename": "compiler/rustc_middle/src/ty/consts/int.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/df04d28163cc42e2c5b1072abe68460f904e42be/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df04d28163cc42e2c5b1072abe68460f904e42be/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fint.rs?ref=df04d28163cc42e2c5b1072abe68460f904e42be", "patch": "@@ -245,6 +245,18 @@ impl ScalarInt {\n         self.to_bits(size)\n     }\n \n+    // Tries to convert the `ScalarInt` to `bool`. Fails if the `size` of the `ScalarInt`\n+    // in not equal to `Size { raw: 1 }` or if the value is not 0 or 1 and returns the `size`\n+    // value of the `ScalarInt` in that case.\n+    #[inline]\n+    pub fn try_to_bool(self) -> Result<bool, Size> {\n+        match self.try_to_u8()? {\n+            0 => Ok(false),\n+            1 => Ok(true),\n+            _ => Err(self.size()),\n+        }\n+    }\n+\n     // Tries to convert the `ScalarInt` to `u8`. Fails if the `size` of the `ScalarInt`\n     // in not equal to `Size { raw: 1 }` and returns the `size` value of the `ScalarInt` in\n     // that case."}, {"sha": "f5555846d20a7e522691df81d4f0844328b817c2", "filename": "compiler/rustc_span/src/def_id.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/df04d28163cc42e2c5b1072abe68460f904e42be/compiler%2Frustc_span%2Fsrc%2Fdef_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df04d28163cc42e2c5b1072abe68460f904e42be/compiler%2Frustc_span%2Fsrc%2Fdef_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fdef_id.rs?ref=df04d28163cc42e2c5b1072abe68460f904e42be", "patch": "@@ -34,7 +34,7 @@ impl CrateNum {\n \n impl fmt::Display for CrateNum {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        fmt::Display::fmt(&self.private, f)\n+        fmt::Display::fmt(&self.as_u32(), f)\n     }\n }\n "}, {"sha": "99a8b03fa39ad27d769aea707c3c77532037c265", "filename": "compiler/rustc_span/src/hygiene.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/df04d28163cc42e2c5b1072abe68460f904e42be/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df04d28163cc42e2c5b1072abe68460f904e42be/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs?ref=df04d28163cc42e2c5b1072abe68460f904e42be", "patch": "@@ -76,7 +76,7 @@ pub struct ExpnId {\n impl fmt::Debug for ExpnId {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         // Generate crate_::{{expn_}}.\n-        write!(f, \"{:?}::{{{{expn{}}}}}\", self.krate, self.local_id.private)\n+        write!(f, \"{:?}::{{{{expn{}}}}}\", self.krate, self.local_id.as_u32())\n     }\n }\n "}, {"sha": "fbc055b5d238f8690555df090b99c3e267f4b126", "filename": "compiler/rustc_ty_utils/src/layout.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/df04d28163cc42e2c5b1072abe68460f904e42be/compiler%2Frustc_ty_utils%2Fsrc%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df04d28163cc42e2c5b1072abe68460f904e42be/compiler%2Frustc_ty_utils%2Fsrc%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Flayout.rs?ref=df04d28163cc42e2c5b1072abe68460f904e42be", "patch": "@@ -325,8 +325,8 @@ fn layout_of_uncached<'tcx>(\n \n                 // Extract the number of elements from the layout of the array field:\n                 let FieldsShape::Array { count, .. } = cx.layout_of(f0_ty)?.layout.fields() else {\n-                        return Err(LayoutError::Unknown(ty));\n-                    };\n+                    return Err(LayoutError::Unknown(ty));\n+                };\n \n                 (*e_ty, *count, true)\n             } else {\n@@ -351,14 +351,14 @@ fn layout_of_uncached<'tcx>(\n             // Compute the ABI of the element type:\n             let e_ly = cx.layout_of(e_ty)?;\n             let Abi::Scalar(e_abi) = e_ly.abi else {\n-                    // This error isn't caught in typeck, e.g., if\n-                    // the element type of the vector is generic.\n-                    tcx.sess.fatal(&format!(\n-                        \"monomorphising SIMD type `{}` with a non-primitive-scalar \\\n-                        (integer/float/pointer) element type `{}`\",\n-                        ty, e_ty\n-                    ))\n-                };\n+                // This error isn't caught in typeck, e.g., if\n+                // the element type of the vector is generic.\n+                tcx.sess.fatal(&format!(\n+                    \"monomorphising SIMD type `{}` with a non-primitive-scalar \\\n+                    (integer/float/pointer) element type `{}`\",\n+                    ty, e_ty\n+                ))\n+            };\n \n             // Compute the size and alignment of the vector:\n             let size = e_ly.size.checked_mul(e_len, dl).ok_or(LayoutError::SizeOverflow(ty))?;\n@@ -597,8 +597,8 @@ fn generator_layout<'tcx>(\n     let subst_field = |ty: Ty<'tcx>| EarlyBinder(ty).subst(tcx, substs);\n \n     let Some(info) = tcx.generator_layout(def_id) else {\n-            return Err(LayoutError::Unknown(ty));\n-        };\n+        return Err(LayoutError::Unknown(ty));\n+    };\n     let (ineligible_locals, assignments) = generator_saved_local_eligibility(&info);\n \n     // Build a prefix layout, including \"promoting\" all ineligible\n@@ -701,8 +701,8 @@ fn generator_layout<'tcx>(\n             variant.variants = Variants::Single { index };\n \n             let FieldsShape::Arbitrary { offsets, memory_index } = variant.fields else {\n-                    bug!();\n-                };\n+                bug!();\n+            };\n \n             // Now, stitch the promoted and variant-only fields back together in\n             // the order they are mentioned by our GeneratorLayout."}, {"sha": "b24e0cc37aa65ec8f7f5db4b266e817efbe412a9", "filename": "src/test/ui/consts/const-eval/ub-nonnull.32bit.stderr", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/df04d28163cc42e2c5b1072abe68460f904e42be/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.32bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/df04d28163cc42e2c5b1072abe68460f904e42be/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.32bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.32bit.stderr?ref=df04d28163cc42e2c5b1072abe68460f904e42be", "patch": "@@ -65,6 +65,17 @@ LL | const BAD_RANGE2: RestrictedRange2 = unsafe { RestrictedRange2(20) };\n                14 00 00 00                                     \u2502 ....\n            }\n \n-error: aborting due to 7 previous errors\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/ub-nonnull.rs:50:1\n+   |\n+LL | const NULL_FAT_PTR: NonNull<dyn Send> = unsafe {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered 0, but expected something greater or equal to 1\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 8, align: 4) {\n+               00 00 00 00 \u257e\u2500alloc26\u2500\u257c                         \u2502 ....\u257e\u2500\u2500\u257c\n+           }\n+\n+error: aborting due to 8 previous errors\n \n For more information about this error, try `rustc --explain E0080`."}, {"sha": "92b8d017c0b77e404b5a63a4f5166e6d1a3f1686", "filename": "src/test/ui/consts/const-eval/ub-nonnull.64bit.stderr", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/df04d28163cc42e2c5b1072abe68460f904e42be/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.64bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/df04d28163cc42e2c5b1072abe68460f904e42be/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.64bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.64bit.stderr?ref=df04d28163cc42e2c5b1072abe68460f904e42be", "patch": "@@ -65,6 +65,17 @@ LL | const BAD_RANGE2: RestrictedRange2 = unsafe { RestrictedRange2(20) };\n                14 00 00 00                                     \u2502 ....\n            }\n \n-error: aborting due to 7 previous errors\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/ub-nonnull.rs:50:1\n+   |\n+LL | const NULL_FAT_PTR: NonNull<dyn Send> = unsafe {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered 0, but expected something greater or equal to 1\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 16, align: 8) {\n+               00 00 00 00 00 00 00 00 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc26\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 ........\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+           }\n+\n+error: aborting due to 8 previous errors\n \n For more information about this error, try `rustc --explain E0080`."}, {"sha": "49092582267c8c9e4cd233044b7ade02c47a06e6", "filename": "src/test/ui/consts/const-eval/ub-nonnull.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/df04d28163cc42e2c5b1072abe68460f904e42be/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df04d28163cc42e2c5b1072abe68460f904e42be/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.rs?ref=df04d28163cc42e2c5b1072abe68460f904e42be", "patch": "@@ -1,5 +1,5 @@\n // stderr-per-bitwidth\n-#![feature(rustc_attrs)]\n+#![feature(rustc_attrs, ptr_metadata)]\n #![allow(invalid_value)] // make sure we cannot allow away the errors tested here\n \n use std::mem;\n@@ -47,4 +47,11 @@ struct RestrictedRange2(u32);\n const BAD_RANGE2: RestrictedRange2 = unsafe { RestrictedRange2(20) };\n //~^ ERROR it is undefined behavior to use this value\n \n+const NULL_FAT_PTR: NonNull<dyn Send> = unsafe {\n+//~^ ERROR it is undefined behavior to use this value\n+    let x: &dyn Send = &42;\n+    let meta = std::ptr::metadata(x);\n+    mem::transmute((0_usize, meta))\n+};\n+\n fn main() {}"}, {"sha": "8b4d845b30eaa0ee857d6614645a4e6bee00cf8f", "filename": "src/test/ui/consts/const-eval/validate_uninhabited_zsts.32bit.stderr", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/df04d28163cc42e2c5b1072abe68460f904e42be/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fvalidate_uninhabited_zsts.32bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/df04d28163cc42e2c5b1072abe68460f904e42be/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fvalidate_uninhabited_zsts.32bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fvalidate_uninhabited_zsts.32bit.stderr?ref=df04d28163cc42e2c5b1072abe68460f904e42be", "patch": "@@ -40,6 +40,11 @@ LL | const BAR: [empty::Empty; 3] = [unsafe { std::mem::transmute(()) }; 3];\n    |                                          this code causes undefined behavior when executed\n    |                                          help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n+note: in this struct field\n+  --> $DIR/validate_uninhabited_zsts.rs:16:22\n+   |\n+LL |     pub struct Empty(Void);\n+   |                      ^^^^\n note: enums with no inhabited variants have no valid value\n   --> $DIR/validate_uninhabited_zsts.rs:13:5\n    |"}, {"sha": "8b4d845b30eaa0ee857d6614645a4e6bee00cf8f", "filename": "src/test/ui/consts/const-eval/validate_uninhabited_zsts.64bit.stderr", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/df04d28163cc42e2c5b1072abe68460f904e42be/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fvalidate_uninhabited_zsts.64bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/df04d28163cc42e2c5b1072abe68460f904e42be/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fvalidate_uninhabited_zsts.64bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fvalidate_uninhabited_zsts.64bit.stderr?ref=df04d28163cc42e2c5b1072abe68460f904e42be", "patch": "@@ -40,6 +40,11 @@ LL | const BAR: [empty::Empty; 3] = [unsafe { std::mem::transmute(()) }; 3];\n    |                                          this code causes undefined behavior when executed\n    |                                          help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n+note: in this struct field\n+  --> $DIR/validate_uninhabited_zsts.rs:16:22\n+   |\n+LL |     pub struct Empty(Void);\n+   |                      ^^^^\n note: enums with no inhabited variants have no valid value\n   --> $DIR/validate_uninhabited_zsts.rs:13:5\n    |"}, {"sha": "74aa47fe40549f91e54c57a0eb7ec067233bd294", "filename": "src/test/ui/layout/valid_range_oob.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/df04d28163cc42e2c5b1072abe68460f904e42be/src%2Ftest%2Fui%2Flayout%2Fvalid_range_oob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df04d28163cc42e2c5b1072abe68460f904e42be/src%2Ftest%2Fui%2Flayout%2Fvalid_range_oob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flayout%2Fvalid_range_oob.rs?ref=df04d28163cc42e2c5b1072abe68460f904e42be", "patch": "@@ -0,0 +1,15 @@\n+// failure-status: 101\n+// normalize-stderr-test \"note: .*\\n\\n\" -> \"\"\n+// normalize-stderr-test \"thread 'rustc' panicked.*\\n\" -> \"\"\n+// rustc-env:RUST_BACKTRACE=0\n+\n+#![feature(rustc_attrs)]\n+\n+#[rustc_layout_scalar_valid_range_end(257)]\n+struct Foo(i8);\n+\n+// Need to do in a constant, as runtime codegen\n+// does not compute the layout of `Foo` in check builds.\n+const FOO: Foo = unsafe { Foo(1) };\n+\n+fn main() {}"}, {"sha": "7398f01643f6eb9f35957c0fb07c9968ac0f54af", "filename": "src/test/ui/layout/valid_range_oob.stderr", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/df04d28163cc42e2c5b1072abe68460f904e42be/src%2Ftest%2Fui%2Flayout%2Fvalid_range_oob.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/df04d28163cc42e2c5b1072abe68460f904e42be/src%2Ftest%2Fui%2Flayout%2Fvalid_range_oob.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flayout%2Fvalid_range_oob.stderr?ref=df04d28163cc42e2c5b1072abe68460f904e42be", "patch": "@@ -0,0 +1,6 @@\n+error: internal compiler error: unexpected panic\n+\n+query stack during panic:\n+#0 [layout_of] computing layout of `Foo`\n+#1 [eval_to_allocation_raw] const-evaluating + checking `FOO`\n+end of query stack"}, {"sha": "5370660d6c185ecc51db76349bce46394cd410a4", "filename": "src/test/ui/lint/invalid_value.stderr", "status": "modified", "additions": 52, "deletions": 17, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/df04d28163cc42e2c5b1072abe68460f904e42be/src%2Ftest%2Fui%2Flint%2Finvalid_value.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/df04d28163cc42e2c5b1072abe68460f904e42be/src%2Ftest%2Fui%2Flint%2Finvalid_value.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Finvalid_value.stderr?ref=df04d28163cc42e2c5b1072abe68460f904e42be", "patch": "@@ -34,7 +34,8 @@ LL |         let _val: Wrap<&'static T> = mem::zeroed();\n    |                                      this code causes undefined behavior when executed\n    |                                      help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n-note: references must be non-null (in this struct field)\n+   = note: `Wrap<&T>` must be non-null\n+note: because references must be non-null (in this struct field)\n   --> $DIR/invalid_value.rs:17:18\n    |\n LL | struct Wrap<T> { wrapped: T }\n@@ -49,7 +50,8 @@ LL |         let _val: Wrap<&'static T> = mem::uninitialized();\n    |                                      this code causes undefined behavior when executed\n    |                                      help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n-note: references must be non-null (in this struct field)\n+   = note: `Wrap<&T>` must be non-null\n+note: because references must be non-null (in this struct field)\n   --> $DIR/invalid_value.rs:17:18\n    |\n LL | struct Wrap<T> { wrapped: T }\n@@ -97,7 +99,7 @@ LL |         let _val: (i32, !) = mem::uninitialized();\n    |                              this code causes undefined behavior when executed\n    |                              help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n-   = note: integers must not be uninitialized\n+   = note: integers must be initialized\n \n error: the type `Void` does not permit zero-initialization\n   --> $DIR/invalid_value.rs:71:26\n@@ -160,7 +162,8 @@ LL |         let _val: Ref = mem::zeroed();\n    |                         this code causes undefined behavior when executed\n    |                         help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n-note: references must be non-null (in this struct field)\n+   = note: `Ref` must be non-null\n+note: because references must be non-null (in this struct field)\n   --> $DIR/invalid_value.rs:14:12\n    |\n LL | struct Ref(&'static i32);\n@@ -175,7 +178,8 @@ LL |         let _val: Ref = mem::uninitialized();\n    |                         this code causes undefined behavior when executed\n    |                         help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n-note: references must be non-null (in this struct field)\n+   = note: `Ref` must be non-null\n+note: because references must be non-null (in this struct field)\n   --> $DIR/invalid_value.rs:14:12\n    |\n LL | struct Ref(&'static i32);\n@@ -212,7 +216,8 @@ LL |         let _val: Wrap<fn()> = mem::zeroed();\n    |                                this code causes undefined behavior when executed\n    |                                help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n-note: function pointers must be non-null (in this struct field)\n+   = note: `Wrap<fn()>` must be non-null\n+note: because function pointers must be non-null (in this struct field)\n   --> $DIR/invalid_value.rs:17:18\n    |\n LL | struct Wrap<T> { wrapped: T }\n@@ -227,7 +232,8 @@ LL |         let _val: Wrap<fn()> = mem::uninitialized();\n    |                                this code causes undefined behavior when executed\n    |                                help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n-note: function pointers must be non-null (in this struct field)\n+   = note: `Wrap<fn()>` must be non-null\n+note: because function pointers must be non-null (in this struct field)\n   --> $DIR/invalid_value.rs:17:18\n    |\n LL | struct Wrap<T> { wrapped: T }\n@@ -242,7 +248,8 @@ LL |         let _val: WrapEnum<fn()> = mem::zeroed();\n    |                                    this code causes undefined behavior when executed\n    |                                    help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n-note: function pointers must be non-null (in this field of the only potentially inhabited enum variant)\n+   = note: `WrapEnum<fn()>` must be non-null\n+note: because function pointers must be non-null (in this field of the only potentially inhabited enum variant)\n   --> $DIR/invalid_value.rs:18:28\n    |\n LL | enum WrapEnum<T> { Wrapped(T) }\n@@ -257,7 +264,8 @@ LL |         let _val: WrapEnum<fn()> = mem::uninitialized();\n    |                                    this code causes undefined behavior when executed\n    |                                    help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n-note: function pointers must be non-null (in this field of the only potentially inhabited enum variant)\n+   = note: `WrapEnum<fn()>` must be non-null\n+note: because function pointers must be non-null (in this field of the only potentially inhabited enum variant)\n   --> $DIR/invalid_value.rs:18:28\n    |\n LL | enum WrapEnum<T> { Wrapped(T) }\n@@ -272,7 +280,12 @@ LL |         let _val: Wrap<(RefPair, i32)> = mem::zeroed();\n    |                                          this code causes undefined behavior when executed\n    |                                          help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n-note: references must be non-null (in this struct field)\n+note: `RefPair` must be non-null (in this struct field)\n+  --> $DIR/invalid_value.rs:17:18\n+   |\n+LL | struct Wrap<T> { wrapped: T }\n+   |                  ^^^^^^^^^^\n+note: because references must be non-null (in this struct field)\n   --> $DIR/invalid_value.rs:15:16\n    |\n LL | struct RefPair((&'static i32, i32));\n@@ -287,7 +300,12 @@ LL |         let _val: Wrap<(RefPair, i32)> = mem::uninitialized();\n    |                                          this code causes undefined behavior when executed\n    |                                          help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n-note: references must be non-null (in this struct field)\n+note: `RefPair` must be non-null (in this struct field)\n+  --> $DIR/invalid_value.rs:17:18\n+   |\n+LL | struct Wrap<T> { wrapped: T }\n+   |                  ^^^^^^^^^^\n+note: because references must be non-null (in this struct field)\n   --> $DIR/invalid_value.rs:15:16\n    |\n LL | struct RefPair((&'static i32, i32));\n@@ -314,6 +332,7 @@ LL |         let _val: NonNull<i32> = mem::uninitialized();\n    |                                  help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n    = note: `std::ptr::NonNull<i32>` must be non-null\n+   = note: raw pointers must be initialized\n \n error: the type `(NonZeroU32, i32)` does not permit zero-initialization\n   --> $DIR/invalid_value.rs:95:39\n@@ -336,6 +355,7 @@ LL |         let _val: (NonZeroU32, i32) = mem::uninitialized();\n    |                                       help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n    = note: `std::num::NonZeroU32` must be non-null\n+   = note: integers must be initialized\n \n error: the type `*const dyn Send` does not permit zero-initialization\n   --> $DIR/invalid_value.rs:98:37\n@@ -420,7 +440,8 @@ LL |         let _val: OneFruitNonZero = mem::zeroed();\n    |                                     this code causes undefined behavior when executed\n    |                                     help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n-note: `std::num::NonZeroU32` must be non-null (in this field of the only potentially inhabited enum variant)\n+   = note: `OneFruitNonZero` must be non-null\n+note: because `std::num::NonZeroU32` must be non-null (in this field of the only potentially inhabited enum variant)\n   --> $DIR/invalid_value.rs:39:12\n    |\n LL |     Banana(NonZeroU32),\n@@ -435,11 +456,13 @@ LL |         let _val: OneFruitNonZero = mem::uninitialized();\n    |                                     this code causes undefined behavior when executed\n    |                                     help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n-note: `std::num::NonZeroU32` must be non-null (in this field of the only potentially inhabited enum variant)\n+   = note: `OneFruitNonZero` must be non-null\n+note: because `std::num::NonZeroU32` must be non-null (in this field of the only potentially inhabited enum variant)\n   --> $DIR/invalid_value.rs:39:12\n    |\n LL |     Banana(NonZeroU32),\n    |            ^^^^^^^^^^\n+   = note: integers must be initialized\n \n error: the type `bool` does not permit being left uninitialized\n   --> $DIR/invalid_value.rs:112:26\n@@ -461,6 +484,7 @@ LL |         let _val: Wrap<char> = mem::uninitialized();\n    |                                this code causes undefined behavior when executed\n    |                                help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n+   = note: `Wrap<char>` must be initialized inside its custom valid range\n note: characters must be a valid Unicode codepoint (in this struct field)\n   --> $DIR/invalid_value.rs:17:18\n    |\n@@ -477,6 +501,11 @@ LL |         let _val: NonBig = mem::uninitialized();\n    |                            help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n    = note: `NonBig` must be initialized inside its custom valid range\n+note: integers must be initialized (in this struct field)\n+  --> $DIR/invalid_value.rs:23:26\n+   |\n+LL | pub(crate) struct NonBig(u64);\n+   |                          ^^^\n \n error: the type `Fruit` does not permit being left uninitialized\n   --> $DIR/invalid_value.rs:121:27\n@@ -513,7 +542,7 @@ LL |         let _val: i32 = mem::uninitialized();\n    |                         this code causes undefined behavior when executed\n    |                         help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n-   = note: integers must not be uninitialized\n+   = note: integers must be initialized\n \n error: the type `f32` does not permit being left uninitialized\n   --> $DIR/invalid_value.rs:130:25\n@@ -524,7 +553,7 @@ LL |         let _val: f32 = mem::uninitialized();\n    |                         this code causes undefined behavior when executed\n    |                         help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n-   = note: floats must not be uninitialized\n+   = note: floats must be initialized\n \n error: the type `*const ()` does not permit being left uninitialized\n   --> $DIR/invalid_value.rs:133:31\n@@ -535,7 +564,7 @@ LL |         let _val: *const () = mem::uninitialized();\n    |                               this code causes undefined behavior when executed\n    |                               help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n-   = note: raw pointers must not be uninitialized\n+   = note: raw pointers must be initialized\n \n error: the type `*const [()]` does not permit being left uninitialized\n   --> $DIR/invalid_value.rs:136:33\n@@ -546,7 +575,7 @@ LL |         let _val: *const [()] = mem::uninitialized();\n    |                                 this code causes undefined behavior when executed\n    |                                 help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n-   = note: raw pointers must not be uninitialized\n+   = note: raw pointers must be initialized\n \n error: the type `WrapAroundRange` does not permit being left uninitialized\n   --> $DIR/invalid_value.rs:139:37\n@@ -558,6 +587,11 @@ LL |         let _val: WrapAroundRange = mem::uninitialized();\n    |                                     help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n    = note: `WrapAroundRange` must be initialized inside its custom valid range\n+note: integers must be initialized (in this struct field)\n+  --> $DIR/invalid_value.rs:49:35\n+   |\n+LL | pub(crate) struct WrapAroundRange(u8);\n+   |                                   ^^\n \n error: the type `Result<i32, i32>` does not permit being left uninitialized\n   --> $DIR/invalid_value.rs:144:38\n@@ -628,6 +662,7 @@ LL |         let _val: NonNull<i32> = MaybeUninit::uninit().assume_init();\n    |                                  help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n    = note: `std::ptr::NonNull<i32>` must be non-null\n+   = note: raw pointers must be initialized\n \n error: the type `bool` does not permit being left uninitialized\n   --> $DIR/invalid_value.rs:159:26"}]}