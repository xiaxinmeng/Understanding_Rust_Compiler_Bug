{"sha": "b7f030e114186890612872c89498cbc914c0220f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI3ZjAzMGUxMTQxODY4OTA2MTI4NzJjODk0OThjYmM5MTRjMDIyMGY=", "commit": {"author": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2019-01-19T23:25:06Z"}, "committer": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2019-01-26T15:02:08Z"}, "message": "Bump bootstrap compiler to 1.33 beta", "tree": {"sha": "0caddc882edfebfe8b9340d564452367351f6ea6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0caddc882edfebfe8b9340d564452367351f6ea6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b7f030e114186890612872c89498cbc914c0220f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b7f030e114186890612872c89498cbc914c0220f", "html_url": "https://github.com/rust-lang/rust/commit/b7f030e114186890612872c89498cbc914c0220f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b7f030e114186890612872c89498cbc914c0220f/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f95834b2a92aa1571d6339d50a34616515773f1c", "url": "https://api.github.com/repos/rust-lang/rust/commits/f95834b2a92aa1571d6339d50a34616515773f1c", "html_url": "https://github.com/rust-lang/rust/commit/f95834b2a92aa1571d6339d50a34616515773f1c"}], "stats": {"total": 184, "additions": 16, "deletions": 168}, "files": [{"sha": "0b2f62485c9ee18094047e27b3c2b9e205d007bc", "filename": "src/bootstrap/channel.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7f030e114186890612872c89498cbc914c0220f/src%2Fbootstrap%2Fchannel.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7f030e114186890612872c89498cbc914c0220f/src%2Fbootstrap%2Fchannel.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fchannel.rs?ref=b7f030e114186890612872c89498cbc914c0220f", "patch": "@@ -14,7 +14,7 @@ use crate::Build;\n use crate::config::Config;\n \n // The version number\n-pub const CFG_RELEASE_NUM: &str = \"1.33.0\";\n+pub const CFG_RELEASE_NUM: &str = \"1.34.0\";\n \n pub struct GitInfo {\n     inner: Option<Info>,"}, {"sha": "116b2720f39a47a46e6f90d760cba5664f156307", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7f030e114186890612872c89498cbc914c0220f/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7f030e114186890612872c89498cbc914c0220f/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=b7f030e114186890612872c89498cbc914c0220f", "patch": "@@ -226,7 +226,7 @@ fn make_win_dist(\n         let trim_chars: &[_] = &[' ', '='];\n         let value =\n             line[(idx + 1)..]\n-                .trim_left_matches(trim_chars)\n+                .trim_start_matches(trim_chars)\n                 .split(';')\n                 .map(PathBuf::from);\n "}, {"sha": "7491385af79295d721688d3dc358389881558e5f", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7f030e114186890612872c89498cbc914c0220f/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7f030e114186890612872c89498cbc914c0220f/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=b7f030e114186890612872c89498cbc914c0220f", "patch": "@@ -423,7 +423,7 @@ impl Build {\n             Command::new(&build.initial_rustc).arg(\"--version\").arg(\"--verbose\"));\n         let local_release = local_version_verbose\n             .lines().filter(|x| x.starts_with(\"release:\"))\n-            .next().unwrap().trim_left_matches(\"release:\").trim();\n+            .next().unwrap().trim_start_matches(\"release:\").trim();\n         let my_version = channel::CFG_RELEASE_NUM;\n         if local_release.split('.').take(2).eq(my_version.split('.').take(2)) {\n             build.verbose(&format!(\"auto-detected local-rebuild {}\", local_release));"}, {"sha": "78ec91d9e3e9b90e84d9150360bb3d9e681634b5", "filename": "src/liballoc/benches/vec_deque_append.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b7f030e114186890612872c89498cbc914c0220f/src%2Fliballoc%2Fbenches%2Fvec_deque_append.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7f030e114186890612872c89498cbc914c0220f/src%2Fliballoc%2Fbenches%2Fvec_deque_append.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbenches%2Fvec_deque_append.rs?ref=b7f030e114186890612872c89498cbc914c0220f", "patch": "@@ -1,4 +1,3 @@\n-#![cfg_attr(stage0, feature(duration_as_u128))]\n use std::{collections::VecDeque, time::Instant};\n \n const VECDEQUE_LEN: i32 = 100000;"}, {"sha": "e66a8465370433386ec71b7fa228623d63b1d558", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b7f030e114186890612872c89498cbc914c0220f/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7f030e114186890612872c89498cbc914c0220f/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=b7f030e114186890612872c89498cbc914c0220f", "patch": "@@ -692,7 +692,6 @@ extern \"rust-intrinsic\" {\n \n     /// A guard for unsafe functions that cannot ever be executed if `T` is uninhabited:\n     /// This will statically either panic, or do nothing.\n-    #[cfg(not(stage0))]\n     pub fn panic_if_uninhabited<T>();\n \n     /// Creates a value initialized to zero."}, {"sha": "45ef7fe70a0e7fef38f7e3608cd537d340da8b1d", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b7f030e114186890612872c89498cbc914c0220f/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7f030e114186890612872c89498cbc914c0220f/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=b7f030e114186890612872c89498cbc914c0220f", "patch": "@@ -71,7 +71,6 @@\n #![feature(cfg_target_has_atomic)]\n #![feature(concat_idents)]\n #![feature(const_fn)]\n-#![cfg_attr(stage0, feature(const_int_ops))]\n #![feature(const_fn_union)]\n #![feature(custom_attribute)]\n #![feature(doc_cfg)]\n@@ -112,19 +111,17 @@\n #![feature(aarch64_target_feature)]\n #![feature(wasm_target_feature)]\n #![feature(avx512_target_feature)]\n-#![cfg_attr(not(stage0), feature(cmpxchg16b_target_feature))]\n+#![feature(cmpxchg16b_target_feature)]\n #![feature(const_slice_len)]\n #![feature(const_str_as_bytes)]\n #![feature(const_str_len)]\n-#![cfg_attr(stage0, feature(const_let))]\n-#![cfg_attr(stage0, feature(const_int_rotate))]\n #![feature(const_int_conversion)]\n #![feature(const_transmute)]\n #![feature(reverse_bits)]\n #![feature(non_exhaustive)]\n #![feature(structural_match)]\n #![feature(abi_unadjusted)]\n-#![cfg_attr(not(stage0), feature(adx_target_feature))]\n+#![feature(adx_target_feature)]\n \n #[prelude_import]\n #[allow(unused)]"}, {"sha": "e661ea3f5037cae345d9ce228736fc332a66ffd9", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b7f030e114186890612872c89498cbc914c0220f/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7f030e114186890612872c89498cbc914c0220f/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=b7f030e114186890612872c89498cbc914c0220f", "patch": "@@ -492,7 +492,6 @@ pub const fn needs_drop<T>() -> bool {\n #[rustc_deprecated(since = \"2.0.0\", reason = \"use `mem::MaybeUninit::zeroed` instead\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub unsafe fn zeroed<T>() -> T {\n-    #[cfg(not(stage0))]\n     intrinsics::panic_if_uninhabited::<T>();\n     intrinsics::init()\n }\n@@ -626,7 +625,6 @@ pub unsafe fn zeroed<T>() -> T {\n #[rustc_deprecated(since = \"2.0.0\", reason = \"use `mem::MaybeUninit::uninitialized` instead\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub unsafe fn uninitialized<T>() -> T {\n-    #[cfg(not(stage0))]\n     intrinsics::panic_if_uninhabited::<T>();\n     intrinsics::uninit()\n }\n@@ -1132,7 +1130,6 @@ impl<T> MaybeUninit<T> {\n     #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n     #[inline(always)]\n     pub unsafe fn into_inner(self) -> T {\n-        #[cfg(not(stage0))]\n         intrinsics::panic_if_uninhabited::<T>();\n         ManuallyDrop::into_inner(self.value)\n     }"}, {"sha": "c3a42a0fc04948c6db5d80e50939504789075a26", "filename": "src/libcore/num/bignum.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b7f030e114186890612872c89498cbc914c0220f/src%2Flibcore%2Fnum%2Fbignum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7f030e114186890612872c89498cbc914c0220f/src%2Flibcore%2Fnum%2Fbignum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fbignum.rs?ref=b7f030e114186890612872c89498cbc914c0220f", "patch": "@@ -46,17 +46,6 @@ macro_rules! impl_full_ops {\n     ($($ty:ty: add($addfn:path), mul/div($bigty:ident);)*) => (\n         $(\n             impl FullOps for $ty {\n-                #[cfg(stage0)]\n-                fn full_add(self, other: $ty, carry: bool) -> (bool, $ty) {\n-                    // This cannot overflow; the output is between `0` and `2 * 2^nbits - 1`.\n-                    // FIXME: will LLVM optimize this into ADC or similar?\n-                    let (v, carry1) = unsafe { intrinsics::add_with_overflow(self, other) };\n-                    let (v, carry2) = unsafe {\n-                        intrinsics::add_with_overflow(v, if carry {1} else {0})\n-                    };\n-                    (carry1 || carry2, v)\n-                }\n-                #[cfg(not(stage0))]\n                 fn full_add(self, other: $ty, carry: bool) -> (bool, $ty) {\n                     // This cannot overflow; the output is between `0` and `2 * 2^nbits - 1`.\n                     // FIXME: will LLVM optimize this into ADC or similar?"}, {"sha": "7cf2317f4b37f45b6fb164cb88dc90fa5cb4e9df", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 5, "deletions": 129, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/b7f030e114186890612872c89498cbc914c0220f/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7f030e114186890612872c89498cbc914c0220f/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=b7f030e114186890612872c89498cbc914c0220f", "patch": "@@ -281,7 +281,6 @@ $EndFeature, \"\n ```\n \"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            #[cfg_attr(stage0, rustc_const_unstable(feature = \"const_int_ops\"))]\n             #[inline]\n             pub const fn count_ones(self) -> u32 { (self as $UnsignedT).count_ones() }\n         }\n@@ -297,7 +296,6 @@ Basic usage:\n \", $Feature, \"assert_eq!(\", stringify!($SelfT), \"::max_value().count_zeros(), 1);\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            #[cfg_attr(stage0, rustc_const_unstable(feature = \"const_int_ops\"))]\n             #[inline]\n             pub const fn count_zeros(self) -> u32 {\n                 (!self).count_ones()\n@@ -318,7 +316,6 @@ assert_eq!(n.leading_zeros(), 0);\",\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            #[cfg_attr(stage0, rustc_const_unstable(feature = \"const_int_ops\"))]\n             #[inline]\n             pub const fn leading_zeros(self) -> u32 {\n                 (self as $UnsignedT).leading_zeros()\n@@ -339,7 +336,6 @@ assert_eq!(n.trailing_zeros(), 2);\",\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            #[cfg_attr(stage0, rustc_const_unstable(feature = \"const_int_ops\"))]\n             #[inline]\n             pub const fn trailing_zeros(self) -> u32 {\n                 (self as $UnsignedT).trailing_zeros()\n@@ -363,7 +359,6 @@ let m = \", $rot_result, \";\n assert_eq!(n.rotate_left(\", $rot, \"), m);\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            #[cfg_attr(stage0, rustc_const_unstable(feature = \"const_int_rotate\"))]\n             #[inline]\n             pub const fn rotate_left(self, n: u32) -> Self {\n                 (self as $UnsignedT).rotate_left(n) as Self\n@@ -388,7 +383,6 @@ let m = \", $rot_op, \";\n assert_eq!(n.rotate_right(\", $rot, \"), m);\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            #[cfg_attr(stage0, rustc_const_unstable(feature = \"const_int_rotate\"))]\n             #[inline]\n             pub const fn rotate_right(self, n: u32) -> Self {\n                 (self as $UnsignedT).rotate_right(n) as Self\n@@ -410,7 +404,6 @@ let m = n.swap_bytes();\n assert_eq!(m, \", $swapped, \");\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            #[cfg_attr(stage0, rustc_const_unstable(feature = \"const_int_ops\"))]\n             #[inline]\n             pub const fn swap_bytes(self) -> Self {\n                 (self as $UnsignedT).swap_bytes() as Self\n@@ -460,7 +453,6 @@ if cfg!(target_endian = \\\"big\\\") {\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            #[cfg_attr(stage0, rustc_const_unstable(feature = \"const_int_ops\"))]\n             #[inline]\n             pub const fn from_be(x: Self) -> Self {\n                 #[cfg(target_endian = \"big\")]\n@@ -494,7 +486,6 @@ if cfg!(target_endian = \\\"little\\\") {\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            #[cfg_attr(stage0, rustc_const_unstable(feature = \"const_int_ops\"))]\n             #[inline]\n             pub const fn from_le(x: Self) -> Self {\n                 #[cfg(target_endian = \"little\")]\n@@ -528,7 +519,6 @@ if cfg!(target_endian = \\\"big\\\") {\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            #[cfg_attr(stage0, rustc_const_unstable(feature = \"const_int_ops\"))]\n             #[inline]\n             pub const fn to_be(self) -> Self { // or not to be?\n                 #[cfg(target_endian = \"big\")]\n@@ -562,7 +552,6 @@ if cfg!(target_endian = \\\"little\\\") {\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            #[cfg_attr(stage0, rustc_const_unstable(feature = \"const_int_ops\"))]\n             #[inline]\n             pub const fn to_le(self) -> Self {\n                 #[cfg(target_endian = \"little\")]\n@@ -998,14 +987,8 @@ assert_eq!(\", stringify!($SelfT), \"::max_value().wrapping_add(2), \", stringify!(\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            #[cfg_attr(stage0, rustc_const_unstable(feature = \"const_int_wrapping\"))]\n             #[inline]\n             pub const fn wrapping_add(self, rhs: Self) -> Self {\n-                #[cfg(stage0)]\n-                unsafe {\n-                    intrinsics::overflowing_add(self, rhs)\n-                }\n-                #[cfg(not(stage0))]\n                 intrinsics::overflowing_add(self, rhs)\n             }\n         }\n@@ -1025,14 +1008,8 @@ stringify!($SelfT), \"::max_value());\",\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            #[cfg_attr(stage0, rustc_const_unstable(feature = \"const_int_wrapping\"))]\n             #[inline]\n             pub const fn wrapping_sub(self, rhs: Self) -> Self {\n-                #[cfg(stage0)]\n-                unsafe {\n-                    intrinsics::overflowing_sub(self, rhs)\n-                }\n-                #[cfg(not(stage0))]\n                 intrinsics::overflowing_sub(self, rhs)\n             }\n         }\n@@ -1051,14 +1028,8 @@ assert_eq!(11i8.wrapping_mul(12), -124);\",\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            #[cfg_attr(stage0, rustc_const_unstable(feature = \"const_int_wrapping\"))]\n             #[inline]\n             pub const fn wrapping_mul(self, rhs: Self) -> Self {\n-                #[cfg(stage0)]\n-                unsafe {\n-                    intrinsics::overflowing_mul(self, rhs)\n-                }\n-                #[cfg(not(stage0))]\n                 intrinsics::overflowing_mul(self, rhs)\n             }\n         }\n@@ -1218,7 +1189,6 @@ assert_eq!((-1\", stringify!($SelfT), \").wrapping_shl(128), -1);\",\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n-            #[cfg_attr(stage0, rustc_const_unstable(feature = \"const_int_wrapping\"))]\n             #[inline]\n             pub const fn wrapping_shl(self, rhs: u32) -> Self {\n                 unsafe {\n@@ -1246,7 +1216,6 @@ assert_eq!((-128i16).wrapping_shr(64), -128);\",\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n-            #[cfg_attr(stage0, rustc_const_unstable(feature = \"const_int_wrapping\"))]\n             #[inline]\n             pub const fn wrapping_shr(self, rhs: u32) -> Self {\n                 unsafe {\n@@ -1343,14 +1312,8 @@ assert_eq!(\", stringify!($SelfT), \"::MAX.overflowing_add(1), (\", stringify!($Sel\n \"::MIN, true));\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n-            #[cfg_attr(stage0, rustc_const_unstable(feature = \"const_int_overflowing\"))]\n             #[inline]\n             pub const fn overflowing_add(self, rhs: Self) -> (Self, bool) {\n-                #[cfg(stage0)]\n-                let (a, b) = unsafe {\n-                    intrinsics::add_with_overflow(self as $ActualT, rhs as $ActualT)\n-                };\n-                #[cfg(not(stage0))]\n                 let (a, b) = intrinsics::add_with_overflow(self as $ActualT, rhs as $ActualT);\n                 (a as Self, b)\n             }\n@@ -1374,14 +1337,8 @@ assert_eq!(\", stringify!($SelfT), \"::MIN.overflowing_sub(1), (\", stringify!($Sel\n \"::MAX, true));\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n-            #[cfg_attr(stage0, rustc_const_unstable(feature = \"const_int_overflowing\"))]\n             #[inline]\n             pub const fn overflowing_sub(self, rhs: Self) -> (Self, bool) {\n-                #[cfg(stage0)]\n-                let (a, b) = unsafe {\n-                    intrinsics::sub_with_overflow(self as $ActualT, rhs as $ActualT)\n-                };\n-                #[cfg(not(stage0))]\n                 let (a, b) = intrinsics::sub_with_overflow(self as $ActualT, rhs as $ActualT);\n                 (a as Self, b)\n             }\n@@ -1403,14 +1360,8 @@ assert_eq!(1_000_000_000i32.overflowing_mul(10), (1410065408, true));\",\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n-            #[cfg_attr(stage0, rustc_const_unstable(feature = \"const_int_overflowing\"))]\n             #[inline]\n             pub const fn overflowing_mul(self, rhs: Self) -> (Self, bool) {\n-                #[cfg(stage0)]\n-                let (a, b) = unsafe {\n-                    intrinsics::mul_with_overflow(self as $ActualT, rhs as $ActualT)\n-                };\n-                #[cfg(not(stage0))]\n                 let (a, b) = intrinsics::mul_with_overflow(self as $ActualT, rhs as $ActualT);\n                 (a as Self, b)\n             }\n@@ -1594,7 +1545,6 @@ assert_eq!(0x1i32.overflowing_shl(36), (0x10, true));\",\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n-            #[cfg_attr(stage0, rustc_const_unstable(feature = \"const_int_overflowing\"))]\n             #[inline]\n             pub const fn overflowing_shl(self, rhs: u32) -> (Self, bool) {\n                 (self.wrapping_shl(rhs), (rhs > ($BITS - 1)))\n@@ -1618,7 +1568,6 @@ assert_eq!(0x10i32.overflowing_shr(36), (0x1, true));\",\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n-            #[cfg_attr(stage0, rustc_const_unstable(feature = \"const_int_overflowing\"))]\n             #[inline]\n             pub const fn overflowing_shr(self, rhs: u32) -> (Self, bool) {\n                 (self.wrapping_shr(rhs), (rhs > ($BITS - 1)))\n@@ -2242,13 +2191,9 @@ Basic usage:\n assert_eq!(n.count_ones(), 3);\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            #[cfg_attr(stage0, rustc_const_unstable(feature = \"const_int_ops\"))]\n             #[inline]\n             pub const fn count_ones(self) -> u32 {\n-                #[cfg(stage0)]\n-                unsafe { intrinsics::ctpop(self as $ActualT) as u32 }\n-                #[cfg(not(stage0))]\n-                { intrinsics::ctpop(self as $ActualT) as u32 }\n+                intrinsics::ctpop(self as $ActualT) as u32\n             }\n         }\n \n@@ -2263,7 +2208,6 @@ Basic usage:\n \", $Feature, \"assert_eq!(\", stringify!($SelfT), \"::max_value().count_zeros(), 0);\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            #[cfg_attr(stage0, rustc_const_unstable(feature = \"const_int_ops\"))]\n             #[inline]\n             pub const fn count_zeros(self) -> u32 {\n                 (!self).count_ones()\n@@ -2283,13 +2227,9 @@ Basic usage:\n assert_eq!(n.leading_zeros(), 2);\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            #[cfg_attr(stage0, rustc_const_unstable(feature = \"const_int_ops\"))]\n             #[inline]\n             pub const fn leading_zeros(self) -> u32 {\n-                #[cfg(stage0)]\n-                unsafe { intrinsics::ctlz(self as $ActualT) as u32 }\n-                #[cfg(not(stage0))]\n-                { intrinsics::ctlz(self as $ActualT) as u32 }\n+                intrinsics::ctlz(self as $ActualT) as u32\n             }\n         }\n \n@@ -2307,13 +2247,9 @@ Basic usage:\n assert_eq!(n.trailing_zeros(), 3);\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            #[cfg_attr(stage0, rustc_const_unstable(feature = \"const_int_ops\"))]\n             #[inline]\n             pub const fn trailing_zeros(self) -> u32 {\n-                #[cfg(stage0)]\n-                unsafe { intrinsics::cttz(self) as u32 }\n-                #[cfg(not(stage0))]\n-                { intrinsics::cttz(self) as u32 }\n+                intrinsics::cttz(self) as u32\n             }\n         }\n \n@@ -2334,12 +2270,8 @@ let m = \", $rot_result, \";\n assert_eq!(n.rotate_left(\", $rot, \"), m);\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            #[cfg_attr(stage0, rustc_const_unstable(feature = \"const_int_rotate\"))]\n             #[inline]\n             pub const fn rotate_left(self, n: u32) -> Self {\n-                #[cfg(stage0)]\n-                unsafe { intrinsics::rotate_left(self, n as $SelfT) }\n-                #[cfg(not(stage0))]\n                 intrinsics::rotate_left(self, n as $SelfT)\n             }\n         }\n@@ -2362,12 +2294,8 @@ let m = \", $rot_op, \";\n assert_eq!(n.rotate_right(\", $rot, \"), m);\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            #[cfg_attr(stage0, rustc_const_unstable(feature = \"const_int_rotate\"))]\n             #[inline]\n             pub const fn rotate_right(self, n: u32) -> Self {\n-                #[cfg(stage0)]\n-                unsafe { intrinsics::rotate_right(self, n as $SelfT) }\n-                #[cfg(not(stage0))]\n                 intrinsics::rotate_right(self, n as $SelfT)\n             }\n         }\n@@ -2387,13 +2315,9 @@ let m = n.swap_bytes();\n assert_eq!(m, \", $swapped, \");\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            #[cfg_attr(stage0, rustc_const_unstable(feature = \"const_int_ops\"))]\n             #[inline]\n             pub const fn swap_bytes(self) -> Self {\n-                #[cfg(stage0)]\n-                unsafe { intrinsics::bswap(self as $ActualT) as Self }\n-                #[cfg(not(stage0))]\n-                { intrinsics::bswap(self as $ActualT) as Self }\n+                intrinsics::bswap(self as $ActualT) as Self\n             }\n         }\n \n@@ -2413,13 +2337,9 @@ let m = n.reverse_bits();\n assert_eq!(m, \", $reversed, \");\n ```\"),\n             #[unstable(feature = \"reverse_bits\", issue = \"48763\")]\n-            #[cfg_attr(stage0, rustc_const_unstable(feature = \"const_int_conversion\"))]\n             #[inline]\n             pub const fn reverse_bits(self) -> Self {\n-                #[cfg(stage0)]\n-                unsafe { intrinsics::bitreverse(self as $ActualT) as Self }\n-                #[cfg(not(stage0))]\n-                { intrinsics::bitreverse(self as $ActualT) as Self }\n+                intrinsics::bitreverse(self as $ActualT) as Self\n             }\n         }\n \n@@ -2443,7 +2363,6 @@ if cfg!(target_endian = \\\"big\\\") {\n }\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            #[cfg_attr(stage0, rustc_const_unstable(feature = \"const_int_ops\"))]\n             #[inline]\n             pub const fn from_be(x: Self) -> Self {\n                 #[cfg(target_endian = \"big\")]\n@@ -2477,7 +2396,6 @@ if cfg!(target_endian = \\\"little\\\") {\n }\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            #[cfg_attr(stage0, rustc_const_unstable(feature = \"const_int_ops\"))]\n             #[inline]\n             pub const fn from_le(x: Self) -> Self {\n                 #[cfg(target_endian = \"little\")]\n@@ -2511,7 +2429,6 @@ if cfg!(target_endian = \\\"big\\\") {\n }\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            #[cfg_attr(stage0, rustc_const_unstable(feature = \"const_int_ops\"))]\n             #[inline]\n             pub const fn to_be(self) -> Self { // or not to be?\n                 #[cfg(target_endian = \"big\")]\n@@ -2545,7 +2462,6 @@ if cfg!(target_endian = \\\"little\\\") {\n }\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            #[cfg_attr(stage0, rustc_const_unstable(feature = \"const_int_ops\"))]\n             #[inline]\n             pub const fn to_le(self) -> Self {\n                 #[cfg(target_endian = \"little\")]\n@@ -2918,14 +2834,8 @@ assert_eq!(200\", stringify!($SelfT), \".wrapping_add(\", stringify!($SelfT), \"::ma\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            #[cfg_attr(stage0, rustc_const_unstable(feature = \"const_int_wrapping\"))]\n             #[inline]\n             pub const fn wrapping_add(self, rhs: Self) -> Self {\n-                #[cfg(stage0)]\n-                unsafe {\n-                    intrinsics::overflowing_add(self, rhs)\n-                }\n-                #[cfg(not(stage0))]\n                 intrinsics::overflowing_add(self, rhs)\n             }\n         }\n@@ -2944,14 +2854,8 @@ assert_eq!(100\", stringify!($SelfT), \".wrapping_sub(\", stringify!($SelfT), \"::ma\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            #[cfg_attr(stage0, rustc_const_unstable(feature = \"const_int_wrapping\"))]\n             #[inline]\n             pub const fn wrapping_sub(self, rhs: Self) -> Self {\n-                #[cfg(stage0)]\n-                unsafe {\n-                    intrinsics::overflowing_sub(self, rhs)\n-                }\n-                #[cfg(not(stage0))]\n                 intrinsics::overflowing_sub(self, rhs)\n             }\n         }\n@@ -2971,14 +2875,8 @@ $EndFeature, \"\n         /// assert_eq!(25u8.wrapping_mul(12), 44);\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        #[cfg_attr(stage0, rustc_const_unstable(feature = \"const_int_wrapping\"))]\n         #[inline]\n         pub const fn wrapping_mul(self, rhs: Self) -> Self {\n-            #[cfg(stage0)]\n-            unsafe {\n-                intrinsics::overflowing_mul(self, rhs)\n-            }\n-            #[cfg(not(stage0))]\n             intrinsics::overflowing_mul(self, rhs)\n         }\n \n@@ -3124,7 +3022,6 @@ Basic usage:\n assert_eq!(1\", stringify!($SelfT), \".wrapping_shl(128), 1);\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n-            #[cfg_attr(stage0, rustc_const_unstable(feature = \"const_int_wrapping\"))]\n             #[inline]\n             pub const fn wrapping_shl(self, rhs: u32) -> Self {\n                 unsafe {\n@@ -3154,7 +3051,6 @@ Basic usage:\n assert_eq!(128\", stringify!($SelfT), \".wrapping_shr(128), 128);\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n-            #[cfg_attr(stage0, rustc_const_unstable(feature = \"const_int_wrapping\"))]\n             #[inline]\n             pub const fn wrapping_shr(self, rhs: u32) -> Self {\n                 unsafe {\n@@ -3218,14 +3114,8 @@ assert_eq!(5\", stringify!($SelfT), \".overflowing_add(2), (7, false));\n assert_eq!(\", stringify!($SelfT), \"::MAX.overflowing_add(1), (0, true));\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n-            #[cfg_attr(stage0, rustc_const_unstable(feature = \"const_int_overflowing\"))]\n             #[inline]\n             pub const fn overflowing_add(self, rhs: Self) -> (Self, bool) {\n-                #[cfg(stage0)]\n-                let (a, b) = unsafe {\n-                    intrinsics::add_with_overflow(self as $ActualT, rhs as $ActualT)\n-                };\n-                #[cfg(not(stage0))]\n                 let (a, b) = intrinsics::add_with_overflow(self as $ActualT, rhs as $ActualT);\n                 (a as Self, b)\n             }\n@@ -3250,14 +3140,8 @@ assert_eq!(0\", stringify!($SelfT), \".overflowing_sub(1), (\", stringify!($SelfT),\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n-            #[cfg_attr(stage0, rustc_const_unstable(feature = \"const_int_overflowing\"))]\n             #[inline]\n             pub const fn overflowing_sub(self, rhs: Self) -> (Self, bool) {\n-                #[cfg(stage0)]\n-                let (a, b) = unsafe {\n-                    intrinsics::sub_with_overflow(self as $ActualT, rhs as $ActualT)\n-                };\n-                #[cfg(not(stage0))]\n                 let (a, b) = intrinsics::sub_with_overflow(self as $ActualT, rhs as $ActualT);\n                 (a as Self, b)\n             }\n@@ -3281,14 +3165,8 @@ $EndFeature, \"\n         /// assert_eq!(1_000_000_000u32.overflowing_mul(10), (1410065408, true));\n         /// ```\n         #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n-        #[cfg_attr(stage0, rustc_const_unstable(feature = \"const_int_overflowing\"))]\n         #[inline]\n         pub const fn overflowing_mul(self, rhs: Self) -> (Self, bool) {\n-            #[cfg(stage0)]\n-            let (a, b) = unsafe {\n-                intrinsics::mul_with_overflow(self as $ActualT, rhs as $ActualT)\n-            };\n-            #[cfg(not(stage0))]\n             let (a, b) = intrinsics::mul_with_overflow(self as $ActualT, rhs as $ActualT);\n             (a as Self, b)\n         }\n@@ -3447,7 +3325,6 @@ Basic usage\n assert_eq!(0x1\", stringify!($SelfT), \".overflowing_shl(132), (0x10, true));\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n-            #[cfg_attr(stage0, rustc_const_unstable(feature = \"const_int_overflowing\"))]\n             #[inline]\n             pub const fn overflowing_shl(self, rhs: u32) -> (Self, bool) {\n                 (self.wrapping_shl(rhs), (rhs > ($BITS - 1)))\n@@ -3472,7 +3349,6 @@ Basic usage\n assert_eq!(0x10\", stringify!($SelfT), \".overflowing_shr(132), (0x1, true));\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n-            #[cfg_attr(stage0, rustc_const_unstable(feature = \"const_int_overflowing\"))]\n             #[inline]\n             pub const fn overflowing_shr(self, rhs: u32) -> (Self, bool) {\n                 (self.wrapping_shr(rhs), (rhs > ($BITS - 1)))"}, {"sha": "42bb5cabb48cdb9920623f294d8ab1b6eaae4059", "filename": "src/libcore/ops/deref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7f030e114186890612872c89498cbc914c0220f/src%2Flibcore%2Fops%2Fderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7f030e114186890612872c89498cbc914c0220f/src%2Flibcore%2Fops%2Fderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Fderef.rs?ref=b7f030e114186890612872c89498cbc914c0220f", "patch": "@@ -171,7 +171,7 @@ impl<T: ?Sized> DerefMut for &mut T {\n /// Indicates that a struct can be used as a method receiver, without the\n /// `arbitrary_self_types` feature. This is implemented by stdlib pointer types like `Box<T>`,\n /// `Rc<T>`, `&T`, and `Pin<P>`.\n-#[cfg_attr(not(stage0), lang = \"receiver\")]\n+#[lang = \"receiver\"]\n #[unstable(feature = \"receiver_trait\", issue = \"0\")]\n #[doc(hidden)]\n pub trait Receiver {"}, {"sha": "f6306d23c30c0f1a9d4ee5c52e967366121dba44", "filename": "src/libpanic_abort/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b7f030e114186890612872c89498cbc914c0220f/src%2Flibpanic_abort%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7f030e114186890612872c89498cbc914c0220f/src%2Flibpanic_abort%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_abort%2Flib.rs?ref=b7f030e114186890612872c89498cbc914c0220f", "patch": "@@ -12,7 +12,6 @@\n #![panic_runtime]\n #![allow(unused_features)]\n \n-#![cfg_attr(stage0, feature(cfg_target_vendor))]\n #![feature(core_intrinsics)]\n #![feature(libc)]\n #![feature(nll)]"}, {"sha": "ccfc15bac042ce26bd66c6a2b592964ca947a1a0", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7f030e114186890612872c89498cbc914c0220f/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7f030e114186890612872c89498cbc914c0220f/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=b7f030e114186890612872c89498cbc914c0220f", "patch": "@@ -24,10 +24,8 @@ Rust MIR: a lowered representation of Rust. Also: an experiment!\n #![feature(unicode_internals)]\n #![feature(step_trait)]\n #![feature(slice_concat_ext)]\n-#![cfg_attr(stage0, feature(if_while_or_patterns))]\n #![feature(try_from)]\n #![feature(reverse_bits)]\n-#![cfg_attr(stage0, feature(underscore_imports))]\n \n #![recursion_limit=\"256\"]\n "}, {"sha": "c94a33da0379078b7331cb7024134b2fe27dbd29", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b7f030e114186890612872c89498cbc914c0220f/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7f030e114186890612872c89498cbc914c0220f/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=b7f030e114186890612872c89498cbc914c0220f", "patch": "@@ -234,12 +234,9 @@\n #![feature(c_variadic)]\n #![feature(cfg_target_has_atomic)]\n #![feature(cfg_target_thread_local)]\n-#![cfg_attr(stage0, feature(cfg_target_vendor))]\n #![feature(char_error_internals)]\n #![feature(compiler_builtins_lib)]\n #![feature(concat_idents)]\n-#![cfg_attr(stage0, feature(const_int_ops))]\n-#![cfg_attr(stage0, feature(const_ip))]\n #![feature(const_raw_ptr_deref)]\n #![feature(const_cstr_unchecked)]\n #![feature(core_intrinsics)]"}, {"sha": "f45cd8b8c101acec1b3abfafe4a21ac61890010f", "filename": "src/libstd/net/ip.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b7f030e114186890612872c89498cbc914c0220f/src%2Flibstd%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7f030e114186890612872c89498cbc914c0220f/src%2Flibstd%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fip.rs?ref=b7f030e114186890612872c89498cbc914c0220f", "patch": "@@ -328,7 +328,6 @@ impl Ipv4Addr {\n     /// let addr = Ipv4Addr::new(127, 0, 0, 1);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[cfg_attr(stage0, rustc_const_unstable(feature = \"const_ip\"))]\n     pub const fn new(a: u8, b: u8, c: u8, d: u8) -> Ipv4Addr {\n         Ipv4Addr {\n             inner: c::in_addr {"}, {"sha": "7547814129d6c84cb1a39a0d82a240c43e89a610", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b7f030e114186890612872c89498cbc914c0220f/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7f030e114186890612872c89498cbc914c0220f/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=b7f030e114186890612872c89498cbc914c0220f", "patch": "@@ -23,7 +23,6 @@\n        html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n        html_root_url = \"https://doc.rust-lang.org/nightly/\", test(attr(deny(warnings))))]\n #![feature(asm)]\n-#![cfg_attr(stage0, feature(cfg_target_vendor))]\n #![feature(fnbox)]\n #![cfg_attr(any(unix, target_os = \"cloudabi\"), feature(libc))]\n #![feature(nll)]"}, {"sha": "5f9c82431b7867278054b5f8d7a9aa7fed0e167f", "filename": "src/libunwind/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b7f030e114186890612872c89498cbc914c0220f/src%2Flibunwind%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7f030e114186890612872c89498cbc914c0220f/src%2Flibunwind%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunwind%2Flib.rs?ref=b7f030e114186890612872c89498cbc914c0220f", "patch": "@@ -1,7 +1,6 @@\n #![no_std]\n #![unstable(feature = \"panic_unwind\", issue = \"32837\")]\n \n-#![cfg_attr(stage0, feature(cfg_target_vendor))]\n #![feature(link_cfg)]\n #![feature(nll)]\n #![feature(staged_api)]"}, {"sha": "36d30b7d27342642d2e703ef8074a2ddbf4303ce", "filename": "src/stage0.txt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7f030e114186890612872c89498cbc914c0220f/src%2Fstage0.txt", "raw_url": "https://github.com/rust-lang/rust/raw/b7f030e114186890612872c89498cbc914c0220f/src%2Fstage0.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstage0.txt?ref=b7f030e114186890612872c89498cbc914c0220f", "patch": "@@ -12,7 +12,7 @@\n # source tarball for a stable release you'll likely see `1.x.0` for rustc and\n # `0.x.0` for Cargo where they were released on `date`.\n \n-date: 2019-01-04\n+date: 2019-01-18\n rustc: beta\n cargo: beta\n "}, {"sha": "2cf0fcfd34cd6b19f48d797d6549747fe61188bf", "filename": "src/tools/linkchecker/main.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b7f030e114186890612872c89498cbc914c0220f/src%2Ftools%2Flinkchecker%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7f030e114186890612872c89498cbc914c0220f/src%2Ftools%2Flinkchecker%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Flinkchecker%2Fmain.rs?ref=b7f030e114186890612872c89498cbc914c0220f", "patch": "@@ -78,7 +78,7 @@ impl FileEntry {\n     fn parse_ids(&mut self, file: &Path, contents: &str, errors: &mut bool) {\n         if self.ids.is_empty() {\n             with_attrs_in_source(contents, \" id\", |fragment, i, _| {\n-                let frag = fragment.trim_left_matches(\"#\").to_owned();\n+                let frag = fragment.trim_start_matches(\"#\").to_owned();\n                 let encoded = small_url_encode(&frag);\n                 if !self.ids.insert(frag) {\n                     *errors = true;\n@@ -343,7 +343,7 @@ fn with_attrs_in_source<F: FnMut(&str, usize, &str)>(contents: &str, attr: &str,\n                 Some(i) => i,\n                 None => continue,\n             };\n-            if rest[..pos_equals].trim_left_matches(\" \") != \"\" {\n+            if rest[..pos_equals].trim_start_matches(\" \") != \"\" {\n                 continue;\n             }\n \n@@ -355,7 +355,7 @@ fn with_attrs_in_source<F: FnMut(&str, usize, &str)>(contents: &str, attr: &str,\n             };\n             let quote_delim = rest.as_bytes()[pos_quote] as char;\n \n-            if rest[..pos_quote].trim_left_matches(\" \") != \"\" {\n+            if rest[..pos_quote].trim_start_matches(\" \") != \"\" {\n                 continue;\n             }\n             let rest = &rest[pos_quote + 1..];"}, {"sha": "7126c0c2f6ecf1639e8c9d4e04be3addbdfe1f5f", "filename": "src/tools/tidy/src/features.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7f030e114186890612872c89498cbc914c0220f/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7f030e114186890612872c89498cbc914c0220f/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures.rs?ref=b7f030e114186890612872c89498cbc914c0220f", "patch": "@@ -188,7 +188,7 @@ pub fn collect_lang_features(base_src_path: &Path, bad: &mut bool) -> Features {\n             }\n \n             let mut parts = line.split(',');\n-            let level = match parts.next().map(|l| l.trim().trim_left_matches('(')) {\n+            let level = match parts.next().map(|l| l.trim().trim_start_matches('(')) {\n                 Some(\"active\") => Status::Unstable,\n                 Some(\"removed\") => Status::Removed,\n                 Some(\"accepted\") => Status::Stable,"}]}