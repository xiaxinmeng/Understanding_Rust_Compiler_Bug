{"sha": "a2af9cf1cf6ccb195eae40cdd793939bc77e7e73", "node_id": "C_kwDOAAsO6NoAKGEyYWY5Y2YxY2Y2Y2NiMTk1ZWFlNDBjZGQ3OTM5MzliYzc3ZTdlNzM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-03-16T04:05:35Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-03-16T04:05:35Z"}, "message": "Auto merge of #94987 - Dylan-DPC:rollup-5tssuhi, r=Dylan-DPC\n\nRollup of 5 pull requests\n\nSuccessful merges:\n\n - #94868 (Format core and std macro rules, removing needless surrounding blocks)\n - #94951 (Extend the irrefutable_let_patterns lint to let chains)\n - #94955 (Refactor: Use `format_args_capture` in some parts of `rustc_parse`)\n - #94957 (Improve the explanation about the behaviour of read_line)\n - #94974 (Ensure that `let_else` does not interact with `let_chains`)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "85776d35bca2bd513ce46e8c0ad1c7c7d17f5588", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/85776d35bca2bd513ce46e8c0ad1c7c7d17f5588"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a2af9cf1cf6ccb195eae40cdd793939bc77e7e73", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a2af9cf1cf6ccb195eae40cdd793939bc77e7e73", "html_url": "https://github.com/rust-lang/rust/commit/a2af9cf1cf6ccb195eae40cdd793939bc77e7e73", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a2af9cf1cf6ccb195eae40cdd793939bc77e7e73/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "af446e1d7086d4aeed495f6b03e70009e9424ce4", "url": "https://api.github.com/repos/rust-lang/rust/commits/af446e1d7086d4aeed495f6b03e70009e9424ce4", "html_url": "https://github.com/rust-lang/rust/commit/af446e1d7086d4aeed495f6b03e70009e9424ce4"}, {"sha": "aaf2255379c22f93e53c5fad14453ac7a791ae9e", "url": "https://api.github.com/repos/rust-lang/rust/commits/aaf2255379c22f93e53c5fad14453ac7a791ae9e", "html_url": "https://github.com/rust-lang/rust/commit/aaf2255379c22f93e53c5fad14453ac7a791ae9e"}], "stats": {"total": 801, "additions": 650, "deletions": 151}, "files": [{"sha": "8a3a46c11903aac8eff0e07b06aee3339a032374", "filename": "compiler/rustc_mir_build/src/thir/pattern/check_match.rs", "status": "modified", "additions": 180, "deletions": 35, "changes": 215, "blob_url": "https://github.com/rust-lang/rust/blob/a2af9cf1cf6ccb195eae40cdd793939bc77e7e73/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2af9cf1cf6ccb195eae40cdd793939bc77e7e73/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs?ref=a2af9cf1cf6ccb195eae40cdd793939bc77e7e73", "patch": "@@ -158,7 +158,7 @@ impl<'p, 'tcx> MatchVisitor<'_, 'p, 'tcx> {\n         self.check_patterns(pat, Refutable);\n         let mut cx = self.new_cx(scrutinee.hir_id);\n         let tpat = self.lower_pattern(&mut cx, pat, &mut false);\n-        check_let_reachability(&mut cx, pat.hir_id, tpat, span);\n+        self.check_let_reachability(&mut cx, pat.hir_id, tpat, span);\n     }\n \n     fn check_match(\n@@ -176,7 +176,7 @@ impl<'p, 'tcx> MatchVisitor<'_, 'p, 'tcx> {\n             if let Some(hir::Guard::IfLet(ref pat, _)) = arm.guard {\n                 self.check_patterns(pat, Refutable);\n                 let tpat = self.lower_pattern(&mut cx, pat, &mut false);\n-                check_let_reachability(&mut cx, pat.hir_id, tpat, tpat.span());\n+                self.check_let_reachability(&mut cx, pat.hir_id, tpat, tpat.span());\n             }\n         }\n \n@@ -224,6 +224,157 @@ impl<'p, 'tcx> MatchVisitor<'_, 'p, 'tcx> {\n         }\n     }\n \n+    fn check_let_reachability(\n+        &mut self,\n+        cx: &mut MatchCheckCtxt<'p, 'tcx>,\n+        pat_id: HirId,\n+        pat: &'p DeconstructedPat<'p, 'tcx>,\n+        span: Span,\n+    ) {\n+        if self.check_let_chain(cx, pat_id) {\n+            return;\n+        }\n+\n+        if is_let_irrefutable(cx, pat_id, pat) {\n+            irrefutable_let_pattern(cx.tcx, pat_id, span);\n+        }\n+    }\n+\n+    fn check_let_chain(&mut self, cx: &mut MatchCheckCtxt<'p, 'tcx>, pat_id: HirId) -> bool {\n+        let hir = self.tcx.hir();\n+        let parent = hir.get_parent_node(pat_id);\n+\n+        // First, figure out if the given pattern is part of a let chain,\n+        // and if so, obtain the top node of the chain.\n+        let mut top = parent;\n+        let mut part_of_chain = false;\n+        loop {\n+            let new_top = hir.get_parent_node(top);\n+            if let hir::Node::Expr(\n+                hir::Expr {\n+                    kind: hir::ExprKind::Binary(Spanned { node: hir::BinOpKind::And, .. }, lhs, rhs),\n+                    ..\n+                },\n+                ..,\n+            ) = hir.get(new_top)\n+            {\n+                // If this isn't the first iteration, we need to check\n+                // if there is a let expr before us in the chain, so\n+                // that we avoid doubly checking the let chain.\n+\n+                // The way a chain of &&s is encoded is ((let ... && let ...) && let ...) && let ...\n+                // as && is left-to-right associative. Thus, we need to check rhs.\n+                if part_of_chain && matches!(rhs.kind, hir::ExprKind::Let(..)) {\n+                    return true;\n+                }\n+                // If there is a let at the lhs, and we provide the rhs, we don't do any checking either.\n+                if !part_of_chain && matches!(lhs.kind, hir::ExprKind::Let(..)) && rhs.hir_id == top\n+                {\n+                    return true;\n+                }\n+            } else {\n+                // We've reached the top.\n+                break;\n+            }\n+\n+            // Since this function is called within a let context, it is reasonable to assume that any parent\n+            // `&&` infers a let chain\n+            part_of_chain = true;\n+            top = new_top;\n+        }\n+        if !part_of_chain {\n+            return false;\n+        }\n+\n+        // Second, obtain the refutabilities of all exprs in the chain,\n+        // and record chain members that aren't let exprs.\n+        let mut chain_refutabilities = Vec::new();\n+        let hir::Node::Expr(top_expr) = hir.get(top) else {\n+            // We ensure right above that it's an Expr\n+            unreachable!()\n+        };\n+        let mut cur_expr = top_expr;\n+        loop {\n+            let mut add = |expr: &hir::Expr<'tcx>| {\n+                let refutability = match expr.kind {\n+                    hir::ExprKind::Let(hir::Let { pat, init, span, .. }) => {\n+                        let mut ncx = self.new_cx(init.hir_id);\n+                        let tpat = self.lower_pattern(&mut ncx, pat, &mut false);\n+\n+                        let refutable = !is_let_irrefutable(&mut ncx, pat.hir_id, tpat);\n+                        Some((*span, refutable))\n+                    }\n+                    _ => None,\n+                };\n+                chain_refutabilities.push(refutability);\n+            };\n+            if let hir::Expr {\n+                kind: hir::ExprKind::Binary(Spanned { node: hir::BinOpKind::And, .. }, lhs, rhs),\n+                ..\n+            } = cur_expr\n+            {\n+                add(rhs);\n+                cur_expr = lhs;\n+            } else {\n+                add(cur_expr);\n+                break;\n+            }\n+        }\n+        chain_refutabilities.reverse();\n+\n+        // Third, emit the actual warnings.\n+\n+        if chain_refutabilities.iter().all(|r| matches!(*r, Some((_, false)))) {\n+            // The entire chain is made up of irrefutable `let` statements\n+            let let_source = let_source_parent(self.tcx, top, None);\n+            irrefutable_let_patterns(\n+                cx.tcx,\n+                top,\n+                let_source,\n+                chain_refutabilities.len(),\n+                top_expr.span,\n+            );\n+            return true;\n+        }\n+        let lint_affix = |affix: &[Option<(Span, bool)>], kind, suggestion| {\n+            let span_start = affix[0].unwrap().0;\n+            let span_end = affix.last().unwrap().unwrap().0;\n+            let span = span_start.to(span_end);\n+            let cnt = affix.len();\n+            cx.tcx.struct_span_lint_hir(IRREFUTABLE_LET_PATTERNS, top, span, |lint| {\n+                let s = pluralize!(cnt);\n+                let mut diag = lint.build(&format!(\"{kind} irrefutable pattern{s} in let chain\"));\n+                diag.note(&format!(\n+                    \"{these} pattern{s} will always match\",\n+                    these = pluralize!(\"this\", cnt),\n+                ));\n+                diag.help(&format!(\n+                    \"consider moving {} {suggestion}\",\n+                    if cnt > 1 { \"them\" } else { \"it\" }\n+                ));\n+                diag.emit()\n+            });\n+        };\n+        if let Some(until) = chain_refutabilities.iter().position(|r| !matches!(*r, Some((_, false)))) && until > 0 {\n+            // The chain has a non-zero prefix of irrefutable `let` statements.\n+\n+            // Check if the let source is while, for there is no alternative place to put a prefix,\n+            // and we shouldn't lint.\n+            let let_source = let_source_parent(self.tcx, top, None);\n+            if !matches!(let_source, LetSource::WhileLet) {\n+                // Emit the lint\n+                let prefix = &chain_refutabilities[..until];\n+                lint_affix(prefix, \"leading\", \"outside of the construct\");\n+            }\n+        }\n+        if let Some(from) = chain_refutabilities.iter().rposition(|r| !matches!(*r, Some((_, false)))) && from != (chain_refutabilities.len() - 1) {\n+            // The chain has a non-empty suffix of irrefutable `let` statements\n+            let suffix = &chain_refutabilities[from + 1..];\n+            lint_affix(suffix, \"trailing\", \"into the body\");\n+        }\n+        true\n+    }\n+\n     fn check_irrefutable(&self, pat: &'tcx Pat<'tcx>, origin: &str, sp: Option<Span>) {\n         let mut cx = self.new_cx(pat.hir_id);\n \n@@ -453,21 +604,33 @@ fn unreachable_pattern(tcx: TyCtxt<'_>, span: Span, id: HirId, catchall: Option<\n }\n \n fn irrefutable_let_pattern(tcx: TyCtxt<'_>, id: HirId, span: Span) {\n+    let source = let_source(tcx, id);\n+    irrefutable_let_patterns(tcx, id, source, 1, span);\n+}\n+\n+fn irrefutable_let_patterns(\n+    tcx: TyCtxt<'_>,\n+    id: HirId,\n+    source: LetSource,\n+    count: usize,\n+    span: Span,\n+) {\n     macro_rules! emit_diag {\n         (\n             $lint:expr,\n             $source_name:expr,\n             $note_sufix:expr,\n             $help_sufix:expr\n         ) => {{\n-            let mut diag = $lint.build(concat!(\"irrefutable \", $source_name, \" pattern\"));\n-            diag.note(concat!(\"this pattern will always match, so the \", $note_sufix));\n+            let s = pluralize!(count);\n+            let these = pluralize!(\"this\", count);\n+            let mut diag = $lint.build(&format!(\"irrefutable {} pattern{s}\", $source_name));\n+            diag.note(&format!(\"{these} pattern{s} will always match, so the {}\", $note_sufix));\n             diag.help(concat!(\"consider \", $help_sufix));\n             diag.emit()\n         }};\n     }\n \n-    let source = let_source(tcx, id);\n     let span = match source {\n         LetSource::LetElse(span) => span,\n         _ => span,\n@@ -511,16 +674,11 @@ fn irrefutable_let_pattern(tcx: TyCtxt<'_>, id: HirId, span: Span) {\n     });\n }\n \n-fn check_let_reachability<'p, 'tcx>(\n+fn is_let_irrefutable<'p, 'tcx>(\n     cx: &mut MatchCheckCtxt<'p, 'tcx>,\n     pat_id: HirId,\n     pat: &'p DeconstructedPat<'p, 'tcx>,\n-    span: Span,\n-) {\n-    if is_let_chain(cx.tcx, pat_id) {\n-        return;\n-    }\n-\n+) -> bool {\n     let arms = [MatchArm { pat, hir_id: pat_id, has_guard: false }];\n     let report = compute_match_usefulness(&cx, &arms, pat_id, pat.ty());\n \n@@ -529,10 +687,9 @@ fn check_let_reachability<'p, 'tcx>(\n     // `is_uninhabited` check.\n     report_arm_reachability(&cx, &report);\n \n-    if report.non_exhaustiveness_witnesses.is_empty() {\n-        // The match is exhaustive, i.e. the `if let` pattern is irrefutable.\n-        irrefutable_let_pattern(cx.tcx, pat_id, span);\n-    }\n+    // If the list of witnesses is empty, the match is exhaustive,\n+    // i.e. the `if let` pattern is irrefutable.\n+    report.non_exhaustiveness_witnesses.is_empty()\n }\n \n /// Report unreachable arms, if any.\n@@ -941,13 +1098,19 @@ fn let_source(tcx: TyCtxt<'_>, pat_id: HirId) -> LetSource {\n     let hir = tcx.hir();\n \n     let parent = hir.get_parent_node(pat_id);\n+    let_source_parent(tcx, parent, Some(pat_id))\n+}\n+\n+fn let_source_parent(tcx: TyCtxt<'_>, parent: HirId, pat_id: Option<HirId>) -> LetSource {\n+    let hir = tcx.hir();\n+\n     let parent_node = hir.get(parent);\n \n     match parent_node {\n         hir::Node::Arm(hir::Arm {\n             guard: Some(hir::Guard::IfLet(&hir::Pat { hir_id, .. }, _)),\n             ..\n-        }) if hir_id == pat_id => {\n+        }) if Some(hir_id) == pat_id => {\n             return LetSource::IfLetGuard;\n         }\n         hir::Node::Expr(hir::Expr { kind: hir::ExprKind::Let(..), span, .. }) => {\n@@ -980,21 +1143,3 @@ fn let_source(tcx: TyCtxt<'_>, pat_id: HirId) -> LetSource {\n \n     LetSource::GenericLet\n }\n-\n-// Since this function is called within a let context, it is reasonable to assume that any parent\n-// `&&` infers a let chain\n-fn is_let_chain(tcx: TyCtxt<'_>, pat_id: HirId) -> bool {\n-    let hir = tcx.hir();\n-    let parent = hir.get_parent_node(pat_id);\n-    let parent_parent = hir.get_parent_node(parent);\n-    matches!(\n-        hir.get(parent_parent),\n-        hir::Node::Expr(\n-            hir::Expr {\n-                kind: hir::ExprKind::Binary(Spanned { node: hir::BinOpKind::And, .. }, ..),\n-                ..\n-            },\n-            ..\n-        )\n-    )\n-}"}, {"sha": "8f759ae84fa69ea457f8e11c2b3fb0d5718e8842", "filename": "compiler/rustc_parse/src/parser/attr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a2af9cf1cf6ccb195eae40cdd793939bc77e7e73/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2af9cf1cf6ccb195eae40cdd793939bc77e7e73/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr.rs?ref=a2af9cf1cf6ccb195eae40cdd793939bc77e7e73", "patch": "@@ -139,7 +139,7 @@ impl<'a> Parser<'a> {\n                 Ok(attr::mk_attr_from_item(item, None, style, attr_sp))\n             } else {\n                 let token_str = pprust::token_to_string(&this.token);\n-                let msg = &format!(\"expected `#`, found `{}`\", token_str);\n+                let msg = &format!(\"expected `#`, found `{token_str}`\");\n                 Err(this.struct_span_err(this.token.span, msg))\n             }\n         })\n@@ -421,7 +421,7 @@ impl<'a> Parser<'a> {\n         }\n \n         let found = pprust::token_to_string(&self.token);\n-        let msg = format!(\"expected unsuffixed literal or identifier, found `{}`\", found);\n+        let msg = format!(\"expected unsuffixed literal or identifier, found `{found}`\");\n         Err(self.struct_span_err(self.token.span, &msg))\n     }\n }"}, {"sha": "1909e9ee749490acdcdfc642943ee2ab73d8fbe5", "filename": "compiler/rustc_parse/src/parser/diagnostics.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/a2af9cf1cf6ccb195eae40cdd793939bc77e7e73/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2af9cf1cf6ccb195eae40cdd793939bc77e7e73/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs?ref=a2af9cf1cf6ccb195eae40cdd793939bc77e7e73", "patch": "@@ -327,8 +327,8 @@ impl<'a> Parser<'a> {\n                 expect.clone()\n             };\n             (\n-                format!(\"expected one of {}, found {}\", expect, actual),\n-                (self.prev_token.span.shrink_to_hi(), format!(\"expected one of {}\", short_expect)),\n+                format!(\"expected one of {expect}, found {actual}\"),\n+                (self.prev_token.span.shrink_to_hi(), format!(\"expected one of {short_expect}\")),\n             )\n         } else if expected.is_empty() {\n             (\n@@ -337,8 +337,8 @@ impl<'a> Parser<'a> {\n             )\n         } else {\n             (\n-                format!(\"expected {}, found {}\", expect, actual),\n-                (self.prev_token.span.shrink_to_hi(), format!(\"expected {}\", expect)),\n+                format!(\"expected {expect}, found {actual}\"),\n+                (self.prev_token.span.shrink_to_hi(), format!(\"expected {expect}\")),\n             )\n         };\n         self.last_unexpected_token_span = Some(self.token.span);\n@@ -421,7 +421,7 @@ impl<'a> Parser<'a> {\n                     String::new(),\n                     Applicability::MachineApplicable,\n                 );\n-                err.note(&format!(\"the raw string started with {} `#`s\", n_hashes));\n+                err.note(&format!(\"the raw string started with {n_hashes} `#`s\"));\n                 true\n             }\n             _ => false,\n@@ -1191,7 +1191,7 @@ impl<'a> Parser<'a> {\n                     _ => None,\n                 };\n                 if let Some(name) = previous_item_kind_name {\n-                    err.help(&format!(\"{} declarations are not followed by a semicolon\", name));\n+                    err.help(&format!(\"{name} declarations are not followed by a semicolon\"));\n                 }\n             }\n             err.emit();\n@@ -1226,12 +1226,12 @@ impl<'a> Parser<'a> {\n             \"expected `{}`, found {}\",\n             token_str,\n             match (&self.token.kind, self.subparser_name) {\n-                (token::Eof, Some(origin)) => format!(\"end of {}\", origin),\n+                (token::Eof, Some(origin)) => format!(\"end of {origin}\"),\n                 _ => this_token_str,\n             },\n         );\n         let mut err = self.struct_span_err(sp, &msg);\n-        let label_exp = format!(\"expected `{}`\", token_str);\n+        let label_exp = format!(\"expected `{token_str}`\");\n         match self.recover_closing_delimiter(&[t.clone()], err) {\n             Err(e) => err = e,\n             Ok(recovered) => {\n@@ -1368,7 +1368,7 @@ impl<'a> Parser<'a> {\n                     Applicability::MachineApplicable,\n                 );\n             }\n-            err.span_suggestion(lo.shrink_to_lo(), &format!(\"{}you can still access the deprecated `try!()` macro using the \\\"raw identifier\\\" syntax\", prefix), \"r#\".to_string(), Applicability::MachineApplicable);\n+            err.span_suggestion(lo.shrink_to_lo(), &format!(\"{prefix}you can still access the deprecated `try!()` macro using the \\\"raw identifier\\\" syntax\"), \"r#\".to_string(), Applicability::MachineApplicable);\n             err.emit();\n             Ok(self.mk_expr_err(lo.to(hi)))\n         } else {\n@@ -1504,7 +1504,7 @@ impl<'a> Parser<'a> {\n                 delim.retain(|c| c != '`');\n                 err.span_suggestion_short(\n                     self.prev_token.span.shrink_to_hi(),\n-                    &format!(\"`{}` may belong here\", delim),\n+                    &format!(\"`{delim}` may belong here\"),\n                     delim,\n                     Applicability::MaybeIncorrect,\n                 );\n@@ -1698,7 +1698,7 @@ impl<'a> Parser<'a> {\n                                 (\n                                     ident,\n                                     \"self: \".to_string(),\n-                                    format!(\"{}: &{}TypeName\", ident, mutab),\n+                                    format!(\"{ident}: &{mutab}TypeName\"),\n                                     \"_: \".to_string(),\n                                     pat.span.shrink_to_lo(),\n                                     pat.span,\n@@ -1826,7 +1826,7 @@ impl<'a> Parser<'a> {\n         let (span, msg) = match (&self.token.kind, self.subparser_name) {\n             (&token::Eof, Some(origin)) => {\n                 let sp = self.sess.source_map().next_point(self.prev_token.span);\n-                (sp, format!(\"expected expression, found end of {}\", origin))\n+                (sp, format!(\"expected expression, found end of {origin}\"))\n             }\n             _ => (\n                 self.token.span,\n@@ -1975,8 +1975,8 @@ impl<'a> Parser<'a> {\n             (ty_generics, self.sess.source_map().span_to_snippet(param.span()))\n         {\n             let (span, sugg) = match &generics.params[..] {\n-                [] => (generics.span, format!(\"<{}>\", snippet)),\n-                [.., generic] => (generic.span().shrink_to_hi(), format!(\", {}\", snippet)),\n+                [] => (generics.span, format!(\"<{snippet}>\")),\n+                [.., generic] => (generic.span().shrink_to_hi(), format!(\", {snippet}\")),\n             };\n             err.multipart_suggestion(\n                 \"`const` parameters must be declared for the `impl`\","}, {"sha": "550d79a898c11ca94dd0fa000dfe8c52b45f1a5d", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/a2af9cf1cf6ccb195eae40cdd793939bc77e7e73/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2af9cf1cf6ccb195eae40cdd793939bc77e7e73/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=a2af9cf1cf6ccb195eae40cdd793939bc77e7e73", "patch": "@@ -223,7 +223,7 @@ impl<'a> Parser<'a> {\n                     AssocOp::NotEqual => \"!=\",\n                     _ => unreachable!(),\n                 };\n-                self.struct_span_err(sp, &format!(\"invalid comparison operator `{}=`\", sugg))\n+                self.struct_span_err(sp, &format!(\"invalid comparison operator `{sugg}=`\"))\n                     .span_suggestion_short(\n                         sp,\n                         &format!(\"`{s}=` is not a valid comparison operator, use `{s}`\", s = sugg),\n@@ -441,10 +441,10 @@ impl<'a> Parser<'a> {\n \n     /// Error on `and` and `or` suggesting `&&` and `||` respectively.\n     fn error_bad_logical_op(&self, bad: &str, good: &str, english: &str) {\n-        self.struct_span_err(self.token.span, &format!(\"`{}` is not a logical operator\", bad))\n+        self.struct_span_err(self.token.span, &format!(\"`{bad}` is not a logical operator\"))\n             .span_suggestion_short(\n                 self.token.span,\n-                &format!(\"use `{}` to perform logical {}\", good, english),\n+                &format!(\"use `{good}` to perform logical {english}\"),\n                 good.to_string(),\n                 Applicability::MachineApplicable,\n             )\n@@ -766,9 +766,9 @@ impl<'a> Parser<'a> {\n                                 self.look_ahead(1, |t| t.span).to(span_after_type),\n                                 \"interpreted as generic arguments\",\n                             )\n-                            .span_label(self.token.span, format!(\"not interpreted as {}\", op_noun))\n+                            .span_label(self.token.span, format!(\"not interpreted as {op_noun}\"))\n                             .multipart_suggestion(\n-                                &format!(\"try {} the cast value\", op_verb),\n+                                &format!(\"try {op_verb} the cast value\"),\n                                 vec![\n                                     (expr.span.shrink_to_lo(), \"(\".to_string()),\n                                     (expr.span.shrink_to_hi(), \")\".to_string()),\n@@ -970,7 +970,7 @@ impl<'a> Parser<'a> {\n     fn error_unexpected_after_dot(&self) {\n         // FIXME Could factor this out into non_fatal_unexpected or something.\n         let actual = pprust::token_to_string(&self.token);\n-        self.struct_span_err(self.token.span, &format!(\"unexpected token: `{}`\", actual)).emit();\n+        self.struct_span_err(self.token.span, &format!(\"unexpected token: `{actual}`\")).emit();\n     }\n \n     // We need an identifier or integer, but the next token is a float.\n@@ -1151,15 +1151,15 @@ impl<'a> Parser<'a> {\n                             mem::replace(err, replacement_err).cancel();\n \n                             err.multipart_suggestion(\n-                                &format!(\"if `{}` is a struct, use braces as delimiters\", name),\n+                                &format!(\"if `{name}` is a struct, use braces as delimiters\"),\n                                 vec![\n                                     (open_paren, \" { \".to_string()),\n                                     (close_paren, \" }\".to_string()),\n                                 ],\n                                 Applicability::MaybeIncorrect,\n                             );\n                             err.multipart_suggestion(\n-                                &format!(\"if `{}` is a function, use the arguments directly\", name),\n+                                &format!(\"if `{name}` is a function, use the arguments directly\"),\n                                 fields\n                                     .into_iter()\n                                     .map(|field| (field.span.until(field.expr.span), String::new()))\n@@ -1776,9 +1776,9 @@ impl<'a> Parser<'a> {\n                         )\n                         .emit();\n                 } else {\n-                    let msg = format!(\"invalid suffix `{}` for number literal\", suf);\n+                    let msg = format!(\"invalid suffix `{suf}` for number literal\");\n                     self.struct_span_err(span, &msg)\n-                        .span_label(span, format!(\"invalid suffix `{}`\", suf))\n+                        .span_label(span, format!(\"invalid suffix `{suf}`\"))\n                         .help(\"the suffix must be one of the numeric types (`u32`, `isize`, `f32`, etc.)\")\n                         .emit();\n                 }\n@@ -1791,9 +1791,9 @@ impl<'a> Parser<'a> {\n                     let msg = format!(\"invalid width `{}` for float literal\", &suf[1..]);\n                     self.struct_span_err(span, &msg).help(\"valid widths are 32 and 64\").emit();\n                 } else {\n-                    let msg = format!(\"invalid suffix `{}` for float literal\", suf);\n+                    let msg = format!(\"invalid suffix `{suf}` for float literal\");\n                     self.struct_span_err(span, &msg)\n-                        .span_label(span, format!(\"invalid suffix `{}`\", suf))\n+                        .span_label(span, format!(\"invalid suffix `{suf}`\"))\n                         .help(\"valid suffixes are `f32` and `f64`\")\n                         .emit();\n                 }\n@@ -1805,7 +1805,7 @@ impl<'a> Parser<'a> {\n                     2 => \"binary\",\n                     _ => unreachable!(),\n                 };\n-                self.struct_span_err(span, &format!(\"{} float literal is not supported\", descr))\n+                self.struct_span_err(span, &format!(\"{descr} float literal is not supported\"))\n                     .span_label(span, \"not supported\")\n                     .emit();\n             }\n@@ -1825,7 +1825,7 @@ impl<'a> Parser<'a> {\n                 let mut err = self\n                     .sess\n                     .span_diagnostic\n-                    .struct_span_warn(sp, &format!(\"suffixes on {} are invalid\", kind));\n+                    .struct_span_warn(sp, &format!(\"suffixes on {kind} are invalid\"));\n                 err.note(&format!(\n                     \"`{}` is *temporarily* accepted on tuple index fields as it was \\\n                         incorrectly accepted on stable for a few releases\",\n@@ -1842,10 +1842,10 @@ impl<'a> Parser<'a> {\n                 );\n                 err\n             } else {\n-                self.struct_span_err(sp, &format!(\"suffixes on {} are invalid\", kind))\n+                self.struct_span_err(sp, &format!(\"suffixes on {kind} are invalid\"))\n                     .forget_guarantee()\n             };\n-            err.span_label(sp, format!(\"invalid suffix `{}`\", suf));\n+            err.span_label(sp, format!(\"invalid suffix `{suf}`\"));\n             err.emit();\n         }\n     }\n@@ -2211,7 +2211,7 @@ impl<'a> Parser<'a> {\n         let ctx = if is_ctx_else { \"else\" } else { \"if\" };\n         self.struct_span_err(last, \"outer attributes are not allowed on `if` and `else` branches\")\n             .span_label(branch_span, \"the attributes are attached to this branch\")\n-            .span_label(ctx_span, format!(\"the branch belongs to this `{}`\", ctx))\n+            .span_label(ctx_span, format!(\"the branch belongs to this `{ctx}`\"))\n             .span_suggestion(\n                 span,\n                 \"remove the attributes\",\n@@ -2391,7 +2391,7 @@ impl<'a> Parser<'a> {\n             err.span_label(arrow_span, \"while parsing the `match` arm starting here\");\n             if stmts.len() > 1 {\n                 err.multipart_suggestion(\n-                    &format!(\"surround the statement{} with a body\", s),\n+                    &format!(\"surround the statement{s} with a body\"),\n                     vec![\n                         (span.shrink_to_lo(), \"{ \".to_string()),\n                         (span.shrink_to_hi(), \" }\".to_string()),"}, {"sha": "b582f060395c38c9c9994ca9cf5daadebaef46d6", "filename": "compiler/rustc_parse/src/parser/item.rs", "status": "modified", "additions": 26, "deletions": 27, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/a2af9cf1cf6ccb195eae40cdd793939bc77e7e73/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2af9cf1cf6ccb195eae40cdd793939bc77e7e73/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs?ref=a2af9cf1cf6ccb195eae40cdd793939bc77e7e73", "patch": "@@ -66,7 +66,7 @@ impl<'a> Parser<'a> {\n         if !self.eat(term) {\n             let token_str = super::token_descr(&self.token);\n             if !self.maybe_consume_incorrect_semicolon(&items) {\n-                let msg = &format!(\"expected item, found {}\", token_str);\n+                let msg = &format!(\"expected item, found {token_str}\");\n                 let mut err = self.struct_span_err(self.token.span, msg);\n                 err.span_label(self.token.span, \"expected item\");\n                 return Err(err);\n@@ -163,9 +163,9 @@ impl<'a> Parser<'a> {\n         }\n         let vs = pprust::vis_to_string(&vis);\n         let vs = vs.trim_end();\n-        self.struct_span_err(vis.span, &format!(\"visibility `{}` is not followed by an item\", vs))\n+        self.struct_span_err(vis.span, &format!(\"visibility `{vs}` is not followed by an item\"))\n             .span_label(vis.span, \"the visibility\")\n-            .help(&format!(\"you likely meant to define an item, e.g., `{} fn foo() {{}}`\", vs))\n+            .help(&format!(\"you likely meant to define an item, e.g., `{vs} fn foo() {{}}`\"))\n             .emit();\n     }\n \n@@ -327,7 +327,7 @@ impl<'a> Parser<'a> {\n         if self.look_ahead(1, |t| *t == token::OpenDelim(token::Brace)) {\n             // possible public struct definition where `struct` was forgotten\n             let ident = self.parse_ident().unwrap();\n-            let msg = format!(\"add `struct` here to parse `{}` as a public struct\", ident);\n+            let msg = format!(\"add `struct` here to parse `{ident}` as a public struct\");\n             let mut err = self.struct_span_err(sp, \"missing `struct` for struct definition\");\n             err.span_suggestion_short(\n                 sp,\n@@ -355,16 +355,16 @@ impl<'a> Parser<'a> {\n                 (\"fn` or `struct\", \"function or struct\", true)\n             };\n \n-            let msg = format!(\"missing `{}` for {} definition\", kw, kw_name);\n+            let msg = format!(\"missing `{kw}` for {kw_name} definition\");\n             let mut err = self.struct_span_err(sp, &msg);\n             if !ambiguous {\n                 self.consume_block(token::Brace, ConsumeClosingDelim::Yes);\n                 let suggestion =\n-                    format!(\"add `{}` here to parse `{}` as a public {}\", kw, ident, kw_name);\n+                    format!(\"add `{kw}` here to parse `{ident}` as a public {kw_name}\");\n                 err.span_suggestion_short(\n                     sp,\n                     &suggestion,\n-                    format!(\" {} \", kw),\n+                    format!(\" {kw} \"),\n                     Applicability::MachineApplicable,\n                 );\n             } else if let Ok(snippet) = self.span_to_snippet(ident_sp) {\n@@ -393,12 +393,12 @@ impl<'a> Parser<'a> {\n             } else {\n                 (\"fn` or `struct\", \"function or struct\", true)\n             };\n-            let msg = format!(\"missing `{}` for {} definition\", kw, kw_name);\n+            let msg = format!(\"missing `{kw}` for {kw_name} definition\");\n             let mut err = self.struct_span_err(sp, &msg);\n             if !ambiguous {\n                 err.span_suggestion_short(\n                     sp,\n-                    &format!(\"add `{}` here to parse `{}` as a public {}\", kw, ident, kw_name),\n+                    &format!(\"add `{kw}` here to parse `{ident}` as a public {kw_name}\"),\n                     format!(\" {} \", kw),\n                     Applicability::MachineApplicable,\n                 );\n@@ -1031,8 +1031,8 @@ impl<'a> Parser<'a> {\n     fn error_bad_item_kind<T>(&self, span: Span, kind: &ItemKind, ctx: &str) -> Option<T> {\n         let span = self.sess.source_map().guess_head_span(span);\n         let descr = kind.descr();\n-        self.struct_span_err(span, &format!(\"{} is not supported in {}\", descr, ctx))\n-            .help(&format!(\"consider moving the {} out to a nearby module scope\", descr))\n+        self.struct_span_err(span, &format!(\"{descr} is not supported in {ctx}\"))\n+            .help(&format!(\"consider moving the {descr} out to a nearby module scope\"))\n             .emit();\n         None\n     }\n@@ -1161,11 +1161,11 @@ impl<'a> Parser<'a> {\n             Some(Mutability::Not) => \"static\",\n             None => \"const\",\n         };\n-        let mut err = self.struct_span_err(id.span, &format!(\"missing type for `{}` item\", kind));\n+        let mut err = self.struct_span_err(id.span, &format!(\"missing type for `{kind}` item\"));\n         err.span_suggestion(\n             id.span,\n             \"provide a type for the item\",\n-            format!(\"{}: <type>\", id),\n+            format!(\"{id}: <type>\"),\n             Applicability::HasPlaceholders,\n         );\n         err.stash(id.span, StashKey::ItemNoType);\n@@ -1282,8 +1282,7 @@ impl<'a> Parser<'a> {\n         } else {\n             let token_str = super::token_descr(&self.token);\n             let msg = &format!(\n-                \"expected `where`, `{{`, `(`, or `;` after struct name, found {}\",\n-                token_str\n+                \"expected `where`, `{{`, `(`, or `;` after struct name, found {token_str}\"\n             );\n             let mut err = self.struct_span_err(self.token.span, msg);\n             err.span_label(self.token.span, \"expected `where`, `{`, `(`, or `;` after struct name\");\n@@ -1310,7 +1309,7 @@ impl<'a> Parser<'a> {\n             VariantData::Struct(fields, recovered)\n         } else {\n             let token_str = super::token_descr(&self.token);\n-            let msg = &format!(\"expected `where` or `{{` after union name, found {}\", token_str);\n+            let msg = &format!(\"expected `where` or `{{` after union name, found {token_str}\");\n             let mut err = self.struct_span_err(self.token.span, msg);\n             err.span_label(self.token.span, \"expected `where` or `{` after union name\");\n             return Err(err);\n@@ -1591,7 +1590,7 @@ impl<'a> Parser<'a> {\n                 }\n                 let mut err = self.struct_span_err(\n                     lo.to(self.prev_token.span),\n-                    &format!(\"functions are not allowed in {} definitions\", adt_ty),\n+                    &format!(\"functions are not allowed in {adt_ty} definitions\"),\n                 );\n                 err.help(\"unlike in C++, Java, and C#, functions are declared in `impl` blocks\");\n                 err.help(\"see https://doc.rust-lang.org/book/ch05-03-method-syntax.html for more information\");\n@@ -1706,7 +1705,7 @@ impl<'a> Parser<'a> {\n         let vstr = pprust::vis_to_string(vis);\n         let vstr = vstr.trim_end();\n         if macro_rules {\n-            let msg = format!(\"can't qualify macro_rules invocation with `{}`\", vstr);\n+            let msg = format!(\"can't qualify macro_rules invocation with `{vstr}`\");\n             self.struct_span_err(vis.span, &msg)\n                 .span_suggestion(\n                     vis.span,\n@@ -1723,7 +1722,7 @@ impl<'a> Parser<'a> {\n                     String::new(),\n                     Applicability::MachineApplicable,\n                 )\n-                .help(&format!(\"try adjusting the macro to put `{}` inside the invocation\", vstr))\n+                .help(&format!(\"try adjusting the macro to put `{vstr}` inside the invocation\"))\n                 .emit();\n         }\n     }\n@@ -1781,11 +1780,11 @@ impl<'a> Parser<'a> {\n \n             self.struct_span_err(\n                 kw_token.span,\n-                &format!(\"`{}` definition cannot be nested inside `{}`\", kw_str, keyword),\n+                &format!(\"`{kw_str}` definition cannot be nested inside `{keyword}`\"),\n             )\n             .span_suggestion(\n                 item.unwrap().span,\n-                &format!(\"consider creating a new `{}` definition instead of nesting\", kw_str),\n+                &format!(\"consider creating a new `{kw_str}` definition instead of nesting\"),\n                 String::new(),\n                 Applicability::MaybeIncorrect,\n             )\n@@ -2045,11 +2044,11 @@ impl<'a> Parser<'a> {\n \n                         err.span_suggestion(\n                             self.token.uninterpolated_span(),\n-                            &format!(\"`{}` already used earlier, remove this one\", original_kw),\n+                            &format!(\"`{original_kw}` already used earlier, remove this one\"),\n                             \"\".to_string(),\n                             Applicability::MachineApplicable,\n                         )\n-                        .span_note(original_sp, &format!(\"`{}` first seen here\", original_kw));\n+                        .span_note(original_sp, &format!(\"`{original_kw}` first seen here\"));\n                     }\n                     // The keyword has not been seen yet, suggest correct placement in the function front matter\n                     else if let Some(WrongKw::Misplaced(correct_pos_sp)) = wrong_kw {\n@@ -2060,8 +2059,8 @@ impl<'a> Parser<'a> {\n \n                             err.span_suggestion(\n                                     correct_pos_sp.to(misplaced_qual_sp),\n-                                    &format!(\"`{}` must come before `{}`\", misplaced_qual, current_qual),\n-                                    format!(\"{} {}\", misplaced_qual, current_qual),\n+                                    &format!(\"`{misplaced_qual}` must come before `{current_qual}`\"),\n+                                    format!(\"{misplaced_qual} {current_qual}\"),\n                                     Applicability::MachineApplicable,\n                                 ).note(\"keyword order for functions declaration is `default`, `pub`, `const`, `async`, `unsafe`, `extern`\");\n                         }\n@@ -2084,8 +2083,8 @@ impl<'a> Parser<'a> {\n                             if matches!(orig_vis.kind, VisibilityKind::Inherited) {\n                                 err.span_suggestion(\n                                     sp_start.to(self.prev_token.span),\n-                                    &format!(\"visibility `{}` must come before `{}`\", vs, snippet),\n-                                    format!(\"{} {}\", vs, snippet),\n+                                    &format!(\"visibility `{vs}` must come before `{snippet}`\"),\n+                                    format!(\"{vs} {snippet}\"),\n                                     Applicability::MachineApplicable,\n                                 );\n                             }"}, {"sha": "74c94680e47e54c82dd903b522a2e2cfed75d56e", "filename": "library/core/src/macros/mod.rs", "status": "modified", "additions": 50, "deletions": 26, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/a2af9cf1cf6ccb195eae40cdd793939bc77e7e73/library%2Fcore%2Fsrc%2Fmacros%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2af9cf1cf6ccb195eae40cdd793939bc77e7e73/library%2Fcore%2Fsrc%2Fmacros%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmacros%2Fmod.rs?ref=a2af9cf1cf6ccb195eae40cdd793939bc77e7e73", "patch": "@@ -34,7 +34,7 @@ macro_rules! panic {\n #[cfg_attr(not(test), rustc_diagnostic_item = \"assert_eq_macro\")]\n #[allow_internal_unstable(core_panic)]\n macro_rules! assert_eq {\n-    ($left:expr, $right:expr $(,)?) => ({\n+    ($left:expr, $right:expr $(,)?) => {\n         match (&$left, &$right) {\n             (left_val, right_val) => {\n                 if !(*left_val == *right_val) {\n@@ -46,8 +46,8 @@ macro_rules! assert_eq {\n                 }\n             }\n         }\n-    });\n-    ($left:expr, $right:expr, $($arg:tt)+) => ({\n+    };\n+    ($left:expr, $right:expr, $($arg:tt)+) => {\n         match (&$left, &$right) {\n             (left_val, right_val) => {\n                 if !(*left_val == *right_val) {\n@@ -59,7 +59,7 @@ macro_rules! assert_eq {\n                 }\n             }\n         }\n-    });\n+    };\n }\n \n /// Asserts that two expressions are not equal to each other (using [`PartialEq`]).\n@@ -84,7 +84,7 @@ macro_rules! assert_eq {\n #[cfg_attr(not(test), rustc_diagnostic_item = \"assert_ne_macro\")]\n #[allow_internal_unstable(core_panic)]\n macro_rules! assert_ne {\n-    ($left:expr, $right:expr $(,)?) => ({\n+    ($left:expr, $right:expr $(,)?) => {\n         match (&$left, &$right) {\n             (left_val, right_val) => {\n                 if *left_val == *right_val {\n@@ -96,8 +96,8 @@ macro_rules! assert_ne {\n                 }\n             }\n         }\n-    });\n-    ($left:expr, $right:expr, $($arg:tt)+) => ({\n+    };\n+    ($left:expr, $right:expr, $($arg:tt)+) => {\n         match (&($left), &($right)) {\n             (left_val, right_val) => {\n                 if *left_val == *right_val {\n@@ -109,7 +109,7 @@ macro_rules! assert_ne {\n                 }\n             }\n         }\n-    });\n+    };\n }\n \n /// Asserts that an expression matches any of the given patterns.\n@@ -142,7 +142,7 @@ macro_rules! assert_ne {\n #[allow_internal_unstable(core_panic)]\n #[rustc_macro_transparency = \"semitransparent\"]\n pub macro assert_matches {\n-    ($left:expr, $(|)? $( $pattern:pat_param )|+ $( if $guard: expr )? $(,)?) => ({\n+    ($left:expr, $(|)? $( $pattern:pat_param )|+ $( if $guard: expr )? $(,)?) => {\n         match $left {\n             $( $pattern )|+ $( if $guard )? => {}\n             ref left_val => {\n@@ -153,8 +153,8 @@ pub macro assert_matches {\n                 );\n             }\n         }\n-    }),\n-    ($left:expr, $(|)? $( $pattern:pat_param )|+ $( if $guard: expr )?, $($arg:tt)+) => ({\n+    },\n+    ($left:expr, $(|)? $( $pattern:pat_param )|+ $( if $guard: expr )?, $($arg:tt)+) => {\n         match $left {\n             $( $pattern )|+ $( if $guard )? => {}\n             ref left_val => {\n@@ -165,7 +165,7 @@ pub macro assert_matches {\n                 );\n             }\n         }\n-    }),\n+    },\n }\n \n /// Asserts that a boolean expression is `true` at runtime.\n@@ -214,7 +214,11 @@ pub macro assert_matches {\n #[rustc_diagnostic_item = \"debug_assert_macro\"]\n #[allow_internal_unstable(edition_panic)]\n macro_rules! debug_assert {\n-    ($($arg:tt)*) => (if $crate::cfg!(debug_assertions) { $crate::assert!($($arg)*); })\n+    ($($arg:tt)*) => {\n+        if $crate::cfg!(debug_assertions) {\n+            $crate::assert!($($arg)*);\n+        }\n+    };\n }\n \n /// Asserts that two expressions are equal to each other.\n@@ -240,7 +244,11 @@ macro_rules! debug_assert {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[cfg_attr(not(test), rustc_diagnostic_item = \"debug_assert_eq_macro\")]\n macro_rules! debug_assert_eq {\n-    ($($arg:tt)*) => (if $crate::cfg!(debug_assertions) { $crate::assert_eq!($($arg)*); })\n+    ($($arg:tt)*) => {\n+        if $crate::cfg!(debug_assertions) {\n+            $crate::assert_eq!($($arg)*);\n+        }\n+    };\n }\n \n /// Asserts that two expressions are not equal to each other.\n@@ -266,7 +274,11 @@ macro_rules! debug_assert_eq {\n #[stable(feature = \"assert_ne\", since = \"1.13.0\")]\n #[cfg_attr(not(test), rustc_diagnostic_item = \"debug_assert_ne_macro\")]\n macro_rules! debug_assert_ne {\n-    ($($arg:tt)*) => (if $crate::cfg!(debug_assertions) { $crate::assert_ne!($($arg)*); })\n+    ($($arg:tt)*) => {\n+        if $crate::cfg!(debug_assertions) {\n+            $crate::assert_ne!($($arg)*);\n+        }\n+    };\n }\n \n /// Asserts that an expression matches any of the given patterns.\n@@ -305,7 +317,9 @@ macro_rules! debug_assert_ne {\n #[allow_internal_unstable(assert_matches)]\n #[rustc_macro_transparency = \"semitransparent\"]\n pub macro debug_assert_matches($($arg:tt)*) {\n-    if $crate::cfg!(debug_assertions) { $crate::assert_matches::assert_matches!($($arg)*); }\n+    if $crate::cfg!(debug_assertions) {\n+        $crate::assert_matches::assert_matches!($($arg)*);\n+    }\n }\n \n /// Returns whether the given expression matches any of the given patterns.\n@@ -331,7 +345,7 @@ macro_rules! matches {\n             $( $pattern )|+ $( if $guard )? => true,\n             _ => false\n         }\n-    }\n+    };\n }\n \n /// Unwraps a result or propagates its error.\n@@ -482,7 +496,9 @@ macro_rules! r#try {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[cfg_attr(not(test), rustc_diagnostic_item = \"write_macro\")]\n macro_rules! write {\n-    ($dst:expr, $($arg:tt)*) => ($dst.write_fmt($crate::format_args!($($arg)*)))\n+    ($dst:expr, $($arg:tt)*) => {\n+        $dst.write_fmt($crate::format_args!($($arg)*))\n+    };\n }\n \n /// Write formatted data into a buffer, with a newline appended.\n@@ -534,12 +550,12 @@ macro_rules! write {\n #[cfg_attr(not(test), rustc_diagnostic_item = \"writeln_macro\")]\n #[allow_internal_unstable(format_args_nl)]\n macro_rules! writeln {\n-    ($dst:expr $(,)?) => (\n+    ($dst:expr $(,)?) => {\n         $crate::write!($dst, \"\\n\")\n-    );\n-    ($dst:expr, $($arg:tt)*) => (\n+    };\n+    ($dst:expr, $($arg:tt)*) => {\n         $dst.write_fmt($crate::format_args_nl!($($arg)*))\n-    );\n+    };\n }\n \n /// Indicates unreachable code.\n@@ -683,8 +699,12 @@ macro_rules! unreachable {\n #[cfg_attr(not(test), rustc_diagnostic_item = \"unimplemented_macro\")]\n #[allow_internal_unstable(core_panic)]\n macro_rules! unimplemented {\n-    () => ($crate::panicking::panic(\"not implemented\"));\n-    ($($arg:tt)+) => ($crate::panic!(\"not implemented: {}\", $crate::format_args!($($arg)+)));\n+    () => {\n+        $crate::panicking::panic(\"not implemented\")\n+    };\n+    ($($arg:tt)+) => {\n+        $crate::panic!(\"not implemented: {}\", $crate::format_args!($($arg)+))\n+    };\n }\n \n /// Indicates unfinished code.\n@@ -746,8 +766,12 @@ macro_rules! unimplemented {\n #[cfg_attr(not(test), rustc_diagnostic_item = \"todo_macro\")]\n #[allow_internal_unstable(core_panic)]\n macro_rules! todo {\n-    () => ($crate::panicking::panic(\"not yet implemented\"));\n-    ($($arg:tt)+) => ($crate::panic!(\"not yet implemented: {}\", $crate::format_args!($($arg)+)));\n+    () => {\n+        $crate::panicking::panic(\"not yet implemented\")\n+    };\n+    ($($arg:tt)+) => {\n+        $crate::panic!(\"not yet implemented: {}\", $crate::format_args!($($arg)+))\n+    };\n }\n \n /// Definitions of built-in macros."}, {"sha": "cd2197fca350e73e8d8d7a3462487ba724828220", "filename": "library/std/src/io/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a2af9cf1cf6ccb195eae40cdd793939bc77e7e73/library%2Fstd%2Fsrc%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2af9cf1cf6ccb195eae40cdd793939bc77e7e73/library%2Fstd%2Fsrc%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fmod.rs?ref=a2af9cf1cf6ccb195eae40cdd793939bc77e7e73", "patch": "@@ -2110,7 +2110,8 @@ pub trait BufRead: Read {\n     }\n \n     /// Read all bytes until a newline (the `0xA` byte) is reached, and append\n-    /// them to the provided buffer.\n+    /// them to the provided buffer. You do not need to clear the buffer before\n+    /// appending.\n     ///\n     /// This function will read bytes from the underlying stream until the\n     /// newline delimiter (the `0xA` byte) or EOF is found. Once found, all bytes"}, {"sha": "c597fb5df45d28fd49af6d3a20a95b0a49997d16", "filename": "library/std/src/macros.rs", "status": "modified", "additions": 18, "deletions": 10, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/a2af9cf1cf6ccb195eae40cdd793939bc77e7e73/library%2Fstd%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2af9cf1cf6ccb195eae40cdd793939bc77e7e73/library%2Fstd%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fmacros.rs?ref=a2af9cf1cf6ccb195eae40cdd793939bc77e7e73", "patch": "@@ -60,7 +60,9 @@ macro_rules! panic {\n #[cfg_attr(not(test), rustc_diagnostic_item = \"print_macro\")]\n #[allow_internal_unstable(print_internals)]\n macro_rules! print {\n-    ($($arg:tt)*) => ($crate::io::_print($crate::format_args!($($arg)*)));\n+    ($($arg:tt)*) => {\n+        $crate::io::_print($crate::format_args!($($arg)*))\n+    };\n }\n \n /// Prints to the standard output, with a newline.\n@@ -94,10 +96,12 @@ macro_rules! print {\n #[cfg_attr(not(test), rustc_diagnostic_item = \"println_macro\")]\n #[allow_internal_unstable(print_internals, format_args_nl)]\n macro_rules! println {\n-    () => ($crate::print!(\"\\n\"));\n-    ($($arg:tt)*) => ({\n-        $crate::io::_print($crate::format_args_nl!($($arg)*));\n-    })\n+    () => {\n+        $crate::print!(\"\\n\")\n+    };\n+    ($($arg:tt)*) => {\n+        $crate::io::_print($crate::format_args_nl!($($arg)*))\n+    };\n }\n \n /// Prints to the standard error.\n@@ -126,7 +130,9 @@ macro_rules! println {\n #[cfg_attr(not(test), rustc_diagnostic_item = \"eprint_macro\")]\n #[allow_internal_unstable(print_internals)]\n macro_rules! eprint {\n-    ($($arg:tt)*) => ($crate::io::_eprint($crate::format_args!($($arg)*)));\n+    ($($arg:tt)*) => {\n+        $crate::io::_eprint($crate::format_args!($($arg)*))\n+    };\n }\n \n /// Prints to the standard error, with a newline.\n@@ -155,10 +161,12 @@ macro_rules! eprint {\n #[cfg_attr(not(test), rustc_diagnostic_item = \"eprintln_macro\")]\n #[allow_internal_unstable(print_internals, format_args_nl)]\n macro_rules! eprintln {\n-    () => ($crate::eprint!(\"\\n\"));\n-    ($($arg:tt)*) => ({\n-        $crate::io::_eprint($crate::format_args_nl!($($arg)*));\n-    })\n+    () => {\n+        $crate::eprint!(\"\\n\")\n+    };\n+    ($($arg:tt)*) => {\n+        $crate::io::_eprint($crate::format_args_nl!($($arg)*))\n+    };\n }\n \n /// Prints and returns the value of a given expression for quick and dirty"}, {"sha": "0c96fb593e659311008e39f56ca578e136808795", "filename": "src/test/pretty/dollar-crate.pp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a2af9cf1cf6ccb195eae40cdd793939bc77e7e73/src%2Ftest%2Fpretty%2Fdollar-crate.pp", "raw_url": "https://github.com/rust-lang/rust/raw/a2af9cf1cf6ccb195eae40cdd793939bc77e7e73/src%2Ftest%2Fpretty%2Fdollar-crate.pp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fdollar-crate.pp?ref=a2af9cf1cf6ccb195eae40cdd793939bc77e7e73", "patch": "@@ -9,5 +9,5 @@\n // pp-exact:dollar-crate.pp\n \n fn main() {\n-    { ::std::io::_print(::core::fmt::Arguments::new_v1(&[\"rust\\n\"], &[])); };\n+    ::std::io::_print(::core::fmt::Arguments::new_v1(&[\"rust\\n\"], &[]));\n }"}, {"sha": "8bf9c97fddad4679ad7cec5436641d19e8001daf", "filename": "src/test/run-make-fulldeps/coverage-reports/expected_show_coverage.closure.txt", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a2af9cf1cf6ccb195eae40cdd793939bc77e7e73/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.closure.txt", "raw_url": "https://github.com/rust-lang/rust/raw/a2af9cf1cf6ccb195eae40cdd793939bc77e7e73/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.closure.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.closure.txt?ref=a2af9cf1cf6ccb195eae40cdd793939bc77e7e73", "patch": "@@ -116,8 +116,8 @@\n   116|      1|\n   117|      1|    let\n   118|      1|        _unused_closure\n-  119|       |    =\n-  120|       |        |\n+  119|      1|    =\n+  120|      1|        |\n   121|       |            mut countdown\n   122|       |        |\n   123|      0|    {\n@@ -173,7 +173,7 @@\n   169|       |    ;\n   170|       |\n   171|      1|    let short_used_not_covered_closure_line_break_no_block_embedded_branch =\n-  172|       |        | _unused_arg: u8 |\n+  172|      1|        | _unused_arg: u8 |\n   173|      0|            println!(\n   174|      0|                \"not called: {}\",\n   175|      0|                if is_true { \"check\" } else { \"me\" }\n@@ -191,7 +191,7 @@\n   187|       |    ;\n   188|       |\n   189|      1|    let short_used_covered_closure_line_break_no_block_embedded_branch =\n-  190|      1|        | _unused_arg: u8 |\n+  190|       |        | _unused_arg: u8 |\n   191|      1|            println!(\n   192|      1|                \"not called: {}\",\n   193|      1|                if is_true { \"check\" } else { \"me\" }"}, {"sha": "c8a0fd684304e4bc18f6f43b26e143faee419ead", "filename": "src/test/ui/macros/trace-macro.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a2af9cf1cf6ccb195eae40cdd793939bc77e7e73/src%2Ftest%2Fui%2Fmacros%2Ftrace-macro.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a2af9cf1cf6ccb195eae40cdd793939bc77e7e73/src%2Ftest%2Fui%2Fmacros%2Ftrace-macro.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Ftrace-macro.stderr?ref=a2af9cf1cf6ccb195eae40cdd793939bc77e7e73", "patch": "@@ -5,5 +5,5 @@ LL |     println!(\"Hello, World!\");\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: expanding `println! { \"Hello, World!\" }`\n-   = note: to `{ $crate :: io :: _print($crate :: format_args_nl! (\"Hello, World!\")) ; }`\n+   = note: to `$crate :: io :: _print($crate :: format_args_nl! (\"Hello, World!\"))`\n "}, {"sha": "6498a5195719493dea0b0b46241c39d744f7c4ab", "filename": "src/test/ui/mir/mir_let_chains_drop_order.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a2af9cf1cf6ccb195eae40cdd793939bc77e7e73/src%2Ftest%2Fui%2Fmir%2Fmir_let_chains_drop_order.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2af9cf1cf6ccb195eae40cdd793939bc77e7e73/src%2Ftest%2Fui%2Fmir%2Fmir_let_chains_drop_order.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmir%2Fmir_let_chains_drop_order.rs?ref=a2af9cf1cf6ccb195eae40cdd793939bc77e7e73", "patch": "@@ -5,6 +5,7 @@\n // See `mir_drop_order.rs` for more information\n \n #![feature(let_chains)]\n+#![allow(irrefutable_let_patterns)]\n \n use std::cell::RefCell;\n use std::panic;"}, {"sha": "ed5e863bd9def1067059b00462a06fed76a8ec73", "filename": "src/test/ui/parser/issues/issue-62894.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a2af9cf1cf6ccb195eae40cdd793939bc77e7e73/src%2Ftest%2Fui%2Fparser%2Fissues%2Fissue-62894.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a2af9cf1cf6ccb195eae40cdd793939bc77e7e73/src%2Ftest%2Fui%2Fparser%2Fissues%2Fissue-62894.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissues%2Fissue-62894.stderr?ref=a2af9cf1cf6ccb195eae40cdd793939bc77e7e73", "patch": "@@ -45,7 +45,7 @@ LL | fn main() {}\n    |\n   ::: $SRC_DIR/core/src/macros/mod.rs:LL:COL\n    |\n-LL |     ($left:expr, $right:expr $(,)?) => ({\n+LL |     ($left:expr, $right:expr $(,)?) => {\n    |      ---------- while parsing argument for this `expr` macro fragment\n \n error: aborting due to 4 previous errors"}, {"sha": "e2a65ff8524040062aefcaad59b284c07e11921a", "filename": "src/test/ui/pattern/usefulness/tuple-struct-nonexhaustive.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a2af9cf1cf6ccb195eae40cdd793939bc77e7e73/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Ftuple-struct-nonexhaustive.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a2af9cf1cf6ccb195eae40cdd793939bc77e7e73/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Ftuple-struct-nonexhaustive.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Ftuple-struct-nonexhaustive.stderr?ref=a2af9cf1cf6ccb195eae40cdd793939bc77e7e73", "patch": "@@ -12,7 +12,7 @@ LL | struct Foo(isize, isize);\n    = note: the matched value is of type `Foo`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL ~         Foo(2, b) => println!(\"{}\", b)\n+LL ~         Foo(2, b) => println!(\"{}\", b),\n LL +         Foo(_, _) => todo!()\n    |\n "}, {"sha": "d851fac8e644fdac9dc70743538ff83ffc1322e1", "filename": "src/test/ui/rfc-2497-if-let-chains/ast-lowering-does-not-wrap-let-chains.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a2af9cf1cf6ccb195eae40cdd793939bc77e7e73/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fast-lowering-does-not-wrap-let-chains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2af9cf1cf6ccb195eae40cdd793939bc77e7e73/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fast-lowering-does-not-wrap-let-chains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fast-lowering-does-not-wrap-let-chains.rs?ref=a2af9cf1cf6ccb195eae40cdd793939bc77e7e73", "patch": "@@ -1,6 +1,7 @@\n // run-pass\n \n #![feature(let_chains)]\n+#![allow(irrefutable_let_patterns)]\n \n fn main() {\n     let first = Some(1);"}, {"sha": "e24649ea044f549b70d6be1fa6baced6679010ba", "filename": "src/test/ui/rfc-2497-if-let-chains/ensure-that-let-else-does-not-interact-with-let-chains.rs", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/a2af9cf1cf6ccb195eae40cdd793939bc77e7e73/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fensure-that-let-else-does-not-interact-with-let-chains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2af9cf1cf6ccb195eae40cdd793939bc77e7e73/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fensure-that-let-else-does-not-interact-with-let-chains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fensure-that-let-else-does-not-interact-with-let-chains.rs?ref=a2af9cf1cf6ccb195eae40cdd793939bc77e7e73", "patch": "@@ -0,0 +1,54 @@\n+#![feature(let_chains, let_else)]\n+\n+fn main() {\n+    let opt = Some(1i32);\n+\n+    let Some(n) = opt else {\n+        return;\n+    };\n+    let Some(n) = opt && n == 1 else {\n+    //~^ ERROR a `&&` expression cannot be directly assigned in `let...else`\n+    //~| ERROR mismatched types\n+    //~| ERROR mismatched types\n+        return;\n+    };\n+    let Some(n) = opt && let another = n else {\n+    //~^ ERROR a `&&` expression cannot be directly assigned in `let...else`\n+    //~| ERROR `let` expressions are not supported here\n+    //~| ERROR mismatched types\n+    //~| ERROR mismatched types\n+        return;\n+    };\n+\n+    if let Some(n) = opt else {\n+    //~^ ERROR missing condition for `if` expression\n+        return;\n+    };\n+    if let Some(n) = opt && n == 1 else {\n+    //~^ ERROR missing condition for `if` expression\n+        return;\n+    };\n+    if let Some(n) = opt && let another = n else {\n+    //~^ ERROR missing condition for `if` expression\n+        return;\n+    };\n+\n+    {\n+        while let Some(n) = opt else {\n+        //~^ ERROR expected `{`, found keyword `else`\n+            return;\n+        };\n+    }\n+    {\n+        while let Some(n) = opt && n == 1 else {\n+        //~^ ERROR expected `{`, found keyword `else`\n+            return;\n+        };\n+    }\n+    {\n+        while let Some(n) = opt && let another = n else {\n+        //~^ ERROR expected `{`, found keyword `else`\n+            return;\n+        };\n+    }\n+}"}, {"sha": "992c34eb402d8e9742f843715edc140a0b4d0c86", "filename": "src/test/ui/rfc-2497-if-let-chains/ensure-that-let-else-does-not-interact-with-let-chains.stderr", "status": "added", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/a2af9cf1cf6ccb195eae40cdd793939bc77e7e73/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fensure-that-let-else-does-not-interact-with-let-chains.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a2af9cf1cf6ccb195eae40cdd793939bc77e7e73/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fensure-that-let-else-does-not-interact-with-let-chains.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fensure-that-let-else-does-not-interact-with-let-chains.stderr?ref=a2af9cf1cf6ccb195eae40cdd793939bc77e7e73", "patch": "@@ -0,0 +1,119 @@\n+error: a `&&` expression cannot be directly assigned in `let...else`\n+  --> $DIR/ensure-that-let-else-does-not-interact-with-let-chains.rs:9:19\n+   |\n+LL |     let Some(n) = opt && n == 1 else {\n+   |                   ^^^^^^^^^^^^^\n+   |\n+help: wrap the expression in parentheses\n+   |\n+LL |     let Some(n) = (opt && n == 1) else {\n+   |                   +             +\n+\n+error: a `&&` expression cannot be directly assigned in `let...else`\n+  --> $DIR/ensure-that-let-else-does-not-interact-with-let-chains.rs:15:19\n+   |\n+LL |     let Some(n) = opt && let another = n else {\n+   |                   ^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: wrap the expression in parentheses\n+   |\n+LL |     let Some(n) = (opt && let another = n) else {\n+   |                   +                      +\n+\n+error: missing condition for `if` expression\n+  --> $DIR/ensure-that-let-else-does-not-interact-with-let-chains.rs:23:7\n+   |\n+LL |     if let Some(n) = opt else {\n+   |       ^ expected if condition here\n+\n+error: missing condition for `if` expression\n+  --> $DIR/ensure-that-let-else-does-not-interact-with-let-chains.rs:27:7\n+   |\n+LL |     if let Some(n) = opt && n == 1 else {\n+   |       ^ expected if condition here\n+\n+error: missing condition for `if` expression\n+  --> $DIR/ensure-that-let-else-does-not-interact-with-let-chains.rs:31:7\n+   |\n+LL |     if let Some(n) = opt && let another = n else {\n+   |       ^ expected if condition here\n+\n+error: expected `{`, found keyword `else`\n+  --> $DIR/ensure-that-let-else-does-not-interact-with-let-chains.rs:37:33\n+   |\n+LL |         while let Some(n) = opt else {\n+   |         ----- ----------------- ^^^^ expected `{`\n+   |         |     |\n+   |         |     this `while` condition successfully parsed\n+   |         while parsing the body of this `while` expression\n+\n+error: expected `{`, found keyword `else`\n+  --> $DIR/ensure-that-let-else-does-not-interact-with-let-chains.rs:43:43\n+   |\n+LL |         while let Some(n) = opt && n == 1 else {\n+   |         ----- --------------------------- ^^^^ expected `{`\n+   |         |     |\n+   |         |     this `while` condition successfully parsed\n+   |         while parsing the body of this `while` expression\n+\n+error: expected `{`, found keyword `else`\n+  --> $DIR/ensure-that-let-else-does-not-interact-with-let-chains.rs:49:52\n+   |\n+LL |         while let Some(n) = opt && let another = n else {\n+   |         ----- ------------------------------------ ^^^^ expected `{`\n+   |         |     |\n+   |         |     this `while` condition successfully parsed\n+   |         while parsing the body of this `while` expression\n+\n+error: `let` expressions are not supported here\n+  --> $DIR/ensure-that-let-else-does-not-interact-with-let-chains.rs:15:26\n+   |\n+LL |     let Some(n) = opt && let another = n else {\n+   |                          ^^^^^^^^^^^^^^^\n+   |\n+   = note: only supported directly in conditions of `if` and `while` expressions\n+   = note: as well as when nested within `&&` and parentheses in those conditions\n+\n+error[E0308]: mismatched types\n+  --> $DIR/ensure-that-let-else-does-not-interact-with-let-chains.rs:9:19\n+   |\n+LL |     let Some(n) = opt && n == 1 else {\n+   |                   ^^^ expected `bool`, found enum `Option`\n+   |\n+   = note: expected type `bool`\n+              found enum `Option<i32>`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/ensure-that-let-else-does-not-interact-with-let-chains.rs:9:9\n+   |\n+LL |     let Some(n) = opt && n == 1 else {\n+   |         ^^^^^^^   ------------- this expression has type `bool`\n+   |         |\n+   |         expected `bool`, found enum `Option`\n+   |\n+   = note: expected type `bool`\n+              found enum `Option<_>`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/ensure-that-let-else-does-not-interact-with-let-chains.rs:15:19\n+   |\n+LL |     let Some(n) = opt && let another = n else {\n+   |                   ^^^ expected `bool`, found enum `Option`\n+   |\n+   = note: expected type `bool`\n+              found enum `Option<i32>`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/ensure-that-let-else-does-not-interact-with-let-chains.rs:15:9\n+   |\n+LL |     let Some(n) = opt && let another = n else {\n+   |         ^^^^^^^   ---------------------- this expression has type `bool`\n+   |         |\n+   |         expected `bool`, found enum `Option`\n+   |\n+   = note: expected type `bool`\n+              found enum `Option<_>`\n+\n+error: aborting due to 13 previous errors\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "d1d5288aea31c25a1a649a321c87ce719b893777", "filename": "src/test/ui/rfc-2497-if-let-chains/irrefutable-lets.disallowed.stderr", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/a2af9cf1cf6ccb195eae40cdd793939bc77e7e73/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Firrefutable-lets.disallowed.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a2af9cf1cf6ccb195eae40cdd793939bc77e7e73/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Firrefutable-lets.disallowed.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Firrefutable-lets.disallowed.stderr?ref=a2af9cf1cf6ccb195eae40cdd793939bc77e7e73", "patch": "@@ -0,0 +1,115 @@\n+error: leading irrefutable pattern in let chain\n+  --> $DIR/irrefutable-lets.rs:13:8\n+   |\n+LL |     if let first = &opt && let Some(ref second) = first && let None = second.start {}\n+   |        ^^^^^^^^^^^^^^^^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/irrefutable-lets.rs:6:30\n+   |\n+LL | #![cfg_attr(disallowed, deny(irrefutable_let_patterns))]\n+   |                              ^^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: this pattern will always match\n+   = help: consider moving it outside of the construct\n+\n+error: irrefutable `if let` patterns\n+  --> $DIR/irrefutable-lets.rs:19:8\n+   |\n+LL |     if let first = &opt && let (a, b) = (1, 2) {}\n+   |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: these patterns will always match, so the `if let` is useless\n+   = help: consider replacing the `if let` with a `let`\n+\n+error: leading irrefutable pattern in let chain\n+  --> $DIR/irrefutable-lets.rs:22:8\n+   |\n+LL |     if let first = &opt && let Some(ref second) = first && let None = second.start && let v = 0 {}\n+   |        ^^^^^^^^^^^^^^^^\n+   |\n+   = note: this pattern will always match\n+   = help: consider moving it outside of the construct\n+\n+error: trailing irrefutable pattern in let chain\n+  --> $DIR/irrefutable-lets.rs:22:87\n+   |\n+LL |     if let first = &opt && let Some(ref second) = first && let None = second.start && let v = 0 {}\n+   |                                                                                       ^^^^^^^^^\n+   |\n+   = note: this pattern will always match\n+   = help: consider moving it into the body\n+\n+error: trailing irrefutable patterns in let chain\n+  --> $DIR/irrefutable-lets.rs:26:37\n+   |\n+LL |     if let Some(ref first) = opt && let second = first && let _third = second {}\n+   |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: these patterns will always match\n+   = help: consider moving them into the body\n+\n+error: leading irrefutable pattern in let chain\n+  --> $DIR/irrefutable-lets.rs:29:8\n+   |\n+LL |     if let Range { start: local_start, end: _ } = (None..Some(1)) && let None = local_start {}\n+   |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: this pattern will always match\n+   = help: consider moving it outside of the construct\n+\n+error: leading irrefutable pattern in let chain\n+  --> $DIR/irrefutable-lets.rs:32:8\n+   |\n+LL |     if let (a, b, c) = (Some(1), Some(1), Some(1)) && let None = Some(1) {}\n+   |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: this pattern will always match\n+   = help: consider moving it outside of the construct\n+\n+error: leading irrefutable pattern in let chain\n+  --> $DIR/irrefutable-lets.rs:35:8\n+   |\n+LL |     if let first = &opt && let None = Some(1) {}\n+   |        ^^^^^^^^^^^^^^^^\n+   |\n+   = note: this pattern will always match\n+   = help: consider moving it outside of the construct\n+\n+error: irrefutable `let` patterns\n+  --> $DIR/irrefutable-lets.rs:44:28\n+   |\n+LL |         Some(ref first) if let second = first && let _third = second && let v = 4 + 4 => {},\n+   |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: these patterns will always match, so the `let` is useless\n+   = help: consider removing `let`\n+\n+error: leading irrefutable pattern in let chain\n+  --> $DIR/irrefutable-lets.rs:50:28\n+   |\n+LL |         Some(ref first) if let Range { start: local_start, end: _ } = first\n+   |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: this pattern will always match\n+   = help: consider moving it outside of the construct\n+\n+error: irrefutable `while let` patterns\n+  --> $DIR/irrefutable-lets.rs:59:11\n+   |\n+LL |     while let first = &opt && let (a, b) = (1, 2) {}\n+   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: these patterns will always match, so the loop will never exit\n+   = help: consider instead using a `loop { ... }` with a `let` inside it\n+\n+error: trailing irrefutable patterns in let chain\n+  --> $DIR/irrefutable-lets.rs:62:40\n+   |\n+LL |     while let Some(ref first) = opt && let second = first && let _third = second {}\n+   |                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: these patterns will always match\n+   = help: consider moving them into the body\n+\n+error: aborting due to 12 previous errors\n+"}, {"sha": "3d1626e8ffb9adb95afc00a8db2aa8e40279be6e", "filename": "src/test/ui/rfc-2497-if-let-chains/irrefutable-lets.rs", "status": "modified", "additions": 42, "deletions": 10, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/a2af9cf1cf6ccb195eae40cdd793939bc77e7e73/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Firrefutable-lets.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2af9cf1cf6ccb195eae40cdd793939bc77e7e73/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Firrefutable-lets.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Firrefutable-lets.rs?ref=a2af9cf1cf6ccb195eae40cdd793939bc77e7e73", "patch": "@@ -1,35 +1,67 @@\n-// check-pass\n+// revisions: allowed disallowed\n+//[allowed] check-pass\n \n #![feature(if_let_guard, let_chains)]\n+#![cfg_attr(allowed, allow(irrefutable_let_patterns))]\n+#![cfg_attr(disallowed, deny(irrefutable_let_patterns))]\n \n use std::ops::Range;\n \n fn main() {\n     let opt = Some(None..Some(1));\n \n-    if let first = &opt && let Some(ref second) = first && let None = second.start {\n-    }\n-    if let Some(ref first) = opt && let second = first && let _third = second {\n-    }\n+    if let first = &opt && let Some(ref second) = first && let None = second.start {}\n+    //[disallowed]~^ ERROR leading irrefutable pattern in let chain\n+\n+    // No lint as the irrefutable pattern is surrounded by other stuff\n+    if 4 * 2 == 0 && let first = &opt && let Some(ref second) = first && let None = second.start {}\n+\n+    if let first = &opt && let (a, b) = (1, 2) {}\n+    //[disallowed]~^ ERROR irrefutable `if let` patterns\n+\n+    if let first = &opt && let Some(ref second) = first && let None = second.start && let v = 0 {}\n+    //[disallowed]~^ ERROR leading irrefutable pattern in let chain\n+    //[disallowed]~^^ ERROR trailing irrefutable pattern in let chain\n+\n+    if let Some(ref first) = opt && let second = first && let _third = second {}\n+    //[disallowed]~^ ERROR trailing irrefutable patterns in let chain\n+\n+    if let Range { start: local_start, end: _ } = (None..Some(1)) && let None = local_start {}\n+    //[disallowed]~^ ERROR leading irrefutable pattern in let chain\n+\n+    if let (a, b, c) = (Some(1), Some(1), Some(1)) && let None = Some(1) {}\n+    //[disallowed]~^ ERROR leading irrefutable pattern in let chain\n+\n+    if let first = &opt && let None = Some(1) {}\n+    //[disallowed]~^ ERROR leading irrefutable pattern in let chain\n+\n     if let Some(ref first) = opt\n         && let Range { start: local_start, end: _ } = first\n         && let None = local_start {\n     }\n \n     match opt {\n-        Some(ref first) if let second = first && let _third = second => {},\n+        Some(ref first) if let second = first && let _third = second && let v = 4 + 4 => {},\n+        //[disallowed]~^ ERROR irrefutable `let` patterns\n         _ => {}\n     }\n+\n     match opt {\n         Some(ref first) if let Range { start: local_start, end: _ } = first\n+        //[disallowed]~^ ERROR leading irrefutable pattern in let chain\n             && let None = local_start => {},\n         _ => {}\n     }\n \n-    while let first = &opt && let Some(ref second) = first && let None = second.start {\n-    }\n-    while let Some(ref first) = opt && let second = first && let _third = second {\n-    }\n+    // No error, despite the prefix being irrefutable\n+    while let first = &opt && let Some(ref second) = first && let None = second.start {}\n+\n+    while let first = &opt && let (a, b) = (1, 2) {}\n+    //[disallowed]~^ ERROR irrefutable `while let` patterns\n+\n+    while let Some(ref first) = opt && let second = first && let _third = second {}\n+    //[disallowed]~^ ERROR trailing irrefutable patterns in let chain\n+\n     while let Some(ref first) = opt\n         && let Range { start: local_start, end: _ } = first\n         && let None = local_start {"}]}