{"sha": "2805553dd8dcb2bd7388cf8a53bed82e876ab5d1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI4MDU1NTNkZDhkY2IyYmQ3Mzg4Y2Y4YTUzYmVkODJlODc2YWI1ZDE=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-10-06T19:25:57Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-10-14T15:05:45Z"}, "message": "rustc_metadata: Improve documentation of `CrateMetadata`", "tree": {"sha": "17f501a5065ba893cf2607c826447234cdcabd4e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/17f501a5065ba893cf2607c826447234cdcabd4e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2805553dd8dcb2bd7388cf8a53bed82e876ab5d1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2805553dd8dcb2bd7388cf8a53bed82e876ab5d1", "html_url": "https://github.com/rust-lang/rust/commit/2805553dd8dcb2bd7388cf8a53bed82e876ab5d1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2805553dd8dcb2bd7388cf8a53bed82e876ab5d1/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b476f2fa4e97cc5050469f199582f2a32da4a589", "url": "https://api.github.com/repos/rust-lang/rust/commits/b476f2fa4e97cc5050469f199582f2a32da4a589", "html_url": "https://github.com/rust-lang/rust/commit/b476f2fa4e97cc5050469f199582f2a32da4a589"}], "stats": {"total": 61, "additions": 36, "deletions": 25}, "files": [{"sha": "08e824d45761870ea99cc07e2277db82f311ff52", "filename": "src/librustc_metadata/cstore.rs", "status": "modified", "additions": 36, "deletions": 25, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/2805553dd8dcb2bd7388cf8a53bed82e876ab5d1/src%2Flibrustc_metadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2805553dd8dcb2bd7388cf8a53bed82e876ab5d1/src%2Flibrustc_metadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore.rs?ref=2805553dd8dcb2bd7388cf8a53bed82e876ab5d1", "patch": "@@ -37,50 +37,61 @@ crate struct ImportedSourceFile {\n }\n \n pub struct CrateMetadata {\n-    /// Information about the extern crate that caused this crate to\n-    /// be loaded. If this is `None`, then the crate was injected\n-    /// (e.g., by the allocator)\n-    crate extern_crate: Lock<Option<ExternCrate>>,\n-\n+    /// The primary crate data - binary metadata blob.\n     crate blob: MetadataBlob,\n-    crate cnum_map: CrateNumMap,\n-    crate cnum: CrateNum,\n-    crate dependencies: Lock<Vec<CrateNum>>,\n-    crate source_map_import_info: RwLock<Vec<ImportedSourceFile>>,\n \n-    /// Used for decoding interpret::AllocIds in a cached & thread-safe manner.\n-    crate alloc_decoding_state: AllocDecodingState,\n+    // --- Some data pre-decoded from the metadata blob, usually for performance ---\n \n-    // NOTE(eddyb) we pass `'static` to a `'tcx` parameter because this\n-    // lifetime is only used behind `Lazy`, and therefore acts like an\n-    // universal (`for<'tcx>`), that is paired up with whichever `TyCtxt`\n-    // is being used to decode those values.\n+    /// Properties of the whole crate.\n+    /// NOTE(eddyb) we pass `'static` to a `'tcx` parameter because this\n+    /// lifetime is only used behind `Lazy`, and therefore acts like an\n+    /// universal (`for<'tcx>`), that is paired up with whichever `TyCtxt`\n+    /// is being used to decode those values.\n     crate root: schema::CrateRoot<'static>,\n-\n     /// For each definition in this crate, we encode a key. When the\n     /// crate is loaded, we read all the keys and put them in this\n     /// hashmap, which gives the reverse mapping. This allows us to\n     /// quickly retrace a `DefPath`, which is needed for incremental\n     /// compilation support.\n     crate def_path_table: Lrc<DefPathTable>,\n-\n+    /// Trait impl data.\n+    /// FIXME: Used only from queries and can use query cache,\n+    /// so pre-decoding can probably be avoided.\n     crate trait_impls: FxHashMap<(u32, DefIndex), schema::Lazy<[DefIndex]>>,\n+    /// Proc macro descriptions for this crate, if it's a proc macro crate.\n+    crate raw_proc_macros: Option<&'static [ProcMacro]>,\n+    /// Source maps for code from the crate.\n+    crate source_map_import_info: RwLock<Vec<ImportedSourceFile>>,\n+    /// Used for decoding interpret::AllocIds in a cached & thread-safe manner.\n+    crate alloc_decoding_state: AllocDecodingState,\n+    /// The `DepNodeIndex` of the `DepNode` representing this upstream crate.\n+    /// It is initialized on the first access in `get_crate_dep_node_index()`.\n+    /// Do not access the value directly, as it might not have been initialized yet.\n+    /// The field must always be initialized to `DepNodeIndex::INVALID`.\n+    crate dep_node_index: AtomicCell<DepNodeIndex>,\n+\n+    // --- Other significant crate properties ---\n \n+    /// ID of this crate, from the current compilation session's point of view.\n+    crate cnum: CrateNum,\n+    /// Maps crate IDs as they are were seen from this crate's compilation sessions into\n+    /// IDs as they are seen from the current compilation session.\n+    crate cnum_map: CrateNumMap,\n+    /// Same ID set as `cnum_map` plus maybe some injected crates like panic runtime.\n+    crate dependencies: Lock<Vec<CrateNum>>,\n+    /// How to link (or not link) this crate to the currently compiled crate.\n     crate dep_kind: Lock<DepKind>,\n+    /// Filesystem location of this crate.\n     crate source: CrateSource,\n-\n     /// Whether or not this crate should be consider a private dependency\n     /// for purposes of the 'exported_private_dependencies' lint\n     crate private_dep: bool,\n \n-    crate raw_proc_macros: Option<&'static [ProcMacro]>,\n+    // --- Data used only for improving diagnostics ---\n \n-    /// The `DepNodeIndex` of the `DepNode` representing this upstream crate.\n-    /// It is initialized on the first access in `get_crate_dep_node_index()`.\n-    /// Do not access the value directly, as it might not have been initialized\n-    /// yet.\n-    /// The field must always be initialized to `DepNodeIndex::INVALID`.\n-    crate dep_node_index: AtomicCell<DepNodeIndex>,\n+    /// Information about the `extern crate` item or path that caused this crate to be loaded.\n+    /// If this is `None`, then the crate was injected (e.g., by the allocator).\n+    crate extern_crate: Lock<Option<ExternCrate>>,\n }\n \n pub struct CStore {"}]}