{"sha": "1d494198bbb9701b6336febcf9d0ceb39e4b7975", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFkNDk0MTk4YmJiOTcwMWI2MzM2ZmViY2Y5ZDBjZWIzOWU0Yjc5NzU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-02-01T12:11:21Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-02-01T12:11:21Z"}, "message": "auto merge of #11930 : bjz/rust/next_power_of_two, r=huonw", "tree": {"sha": "648f27b2e0b1f8d09b3a207b5d0ed2451ef01b4b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/648f27b2e0b1f8d09b3a207b5d0ed2451ef01b4b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1d494198bbb9701b6336febcf9d0ceb39e4b7975", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1d494198bbb9701b6336febcf9d0ceb39e4b7975", "html_url": "https://github.com/rust-lang/rust/commit/1d494198bbb9701b6336febcf9d0ceb39e4b7975", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1d494198bbb9701b6336febcf9d0ceb39e4b7975/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c80d28c8e322b6da49b7725d2b5e5b5cc86da822", "url": "https://api.github.com/repos/rust-lang/rust/commits/c80d28c8e322b6da49b7725d2b5e5b5cc86da822", "html_url": "https://github.com/rust-lang/rust/commit/c80d28c8e322b6da49b7725d2b5e5b5cc86da822"}, {"sha": "1f15d24243078903410176a0924bd5d09fe1c2b8", "url": "https://api.github.com/repos/rust-lang/rust/commits/1f15d24243078903410176a0924bd5d09fe1c2b8", "html_url": "https://github.com/rust-lang/rust/commit/1f15d24243078903410176a0924bd5d09fe1c2b8"}], "stats": {"total": 257, "additions": 101, "deletions": 156}, "files": [{"sha": "ac290de0d72188ff8d7db6e7054275e35df95837", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1d494198bbb9701b6336febcf9d0ceb39e4b7975/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d494198bbb9701b6336febcf9d0ceb39e4b7975/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=1d494198bbb9701b6336febcf9d0ceb39e4b7975", "patch": "@@ -36,7 +36,6 @@ use std::ptr;\n use std::kinds::marker;\n use std::mem;\n use std::rt::global_heap;\n-use std::uint;\n use std::unstable::intrinsics::{TyDesc, get_tydesc};\n use std::unstable::intrinsics;\n use std::util;\n@@ -180,7 +179,7 @@ impl Arena {\n         let new_min_chunk_size = num::max(n_bytes, chunk_size);\n         self.chunks.set(@Cons(self.pod_head.clone(), self.chunks.get()));\n         self.pod_head =\n-            chunk(uint::next_power_of_two(new_min_chunk_size + 1u), true);\n+            chunk(num::next_power_of_two(new_min_chunk_size + 1u), true);\n \n         return self.alloc_pod_inner(n_bytes, align);\n     }\n@@ -222,7 +221,7 @@ impl Arena {\n         let new_min_chunk_size = num::max(n_bytes, chunk_size);\n         self.chunks.set(@Cons(self.head.clone(), self.chunks.get()));\n         self.head =\n-            chunk(uint::next_power_of_two(new_min_chunk_size + 1u), false);\n+            chunk(num::next_power_of_two(new_min_chunk_size + 1u), false);\n \n         return self.alloc_nonpod_inner(n_bytes, align);\n     }"}, {"sha": "55e90248e1c3b608149c72e16c6b72ae3ee9fa5e", "filename": "src/libstd/at_vec.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1d494198bbb9701b6336febcf9d0ceb39e4b7975/src%2Flibstd%2Fat_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d494198bbb9701b6336febcf9d0ceb39e4b7975/src%2Flibstd%2Fat_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fat_vec.rs?ref=1d494198bbb9701b6336febcf9d0ceb39e4b7975", "patch": "@@ -177,9 +177,9 @@ pub mod raw {\n     use cast::{transmute, transmute_copy};\n     use container::Container;\n     use option::None;\n-    use ptr;\n     use mem;\n-    use uint;\n+    use num::next_power_of_two;\n+    use ptr;\n     use unstable::intrinsics::{move_val_init, TyDesc};\n     use unstable::intrinsics;\n     use unstable::raw::{Box, Vec};\n@@ -293,7 +293,7 @@ pub mod raw {\n      */\n     #[inline]\n     pub unsafe fn reserve_at_least<T>(v: &mut @[T], n: uint) {\n-        reserve(v, uint::next_power_of_two(n));\n+        reserve(v, next_power_of_two(n));\n     }\n }\n "}, {"sha": "a97feea786d19682fb2d92d0ab01effdfd7fb28d", "filename": "src/libstd/hashmap.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1d494198bbb9701b6336febcf9d0ceb39e4b7975/src%2Flibstd%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d494198bbb9701b6336febcf9d0ceb39e4b7975/src%2Flibstd%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fhashmap.rs?ref=1d494198bbb9701b6336febcf9d0ceb39e4b7975", "patch": "@@ -64,7 +64,6 @@ use num;\n use option::{None, Option, Some};\n use rand::Rng;\n use rand;\n-use uint;\n use util::replace;\n use vec::{ImmutableVector, MutableVector, OwnedVector, Items, MutItems};\n use vec_ng;\n@@ -388,7 +387,7 @@ impl<K: Hash + Eq, V> HashMap<K, V> {\n     pub fn reserve_at_least(&mut self, n: uint) {\n         if n > self.buckets.len() {\n             let buckets = n * 4 / 3 + 1;\n-            self.resize(uint::next_power_of_two(buckets));\n+            self.resize(num::next_power_of_two(buckets));\n         }\n     }\n "}, {"sha": "f336afe12f40072a2e8a1525269dbfbc966ae0bb", "filename": "src/libstd/num/int.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1d494198bbb9701b6336febcf9d0ceb39e4b7975/src%2Flibstd%2Fnum%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d494198bbb9701b6336febcf9d0ceb39e4b7975/src%2Flibstd%2Fnum%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fint.rs?ref=1d494198bbb9701b6336febcf9d0ceb39e4b7975", "patch": "@@ -120,10 +120,3 @@ impl CheckedMul for int {\n         }\n     }\n }\n-\n-#[test]\n-fn test_overflows() {\n-    assert!((::int::MAX > 0));\n-    assert!((::int::MIN <= 0));\n-    assert!((::int::MIN + ::int::MAX + 1 == 0));\n-}"}, {"sha": "c8d5dc1249959fb216a293c571a01170433d94ea", "filename": "src/libstd/num/int_macros.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1d494198bbb9701b6336febcf9d0ceb39e4b7975/src%2Flibstd%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d494198bbb9701b6336febcf9d0ceb39e4b7975/src%2Flibstd%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fint_macros.rs?ref=1d494198bbb9701b6336febcf9d0ceb39e4b7975", "patch": "@@ -445,6 +445,13 @@ mod tests {\n     use num::CheckedDiv;\n     use num::Bitwise;\n \n+    #[test]\n+    fn test_overflows() {\n+        assert!(MAX > 0);\n+        assert!(MIN <= 0);\n+        assert_eq!(MIN + MAX + 1, 0);\n+    }\n+\n     #[test]\n     fn test_num() {\n         num::test_num(10 as $T, 2 as $T);"}, {"sha": "976761b512053309e698a261e96fd717bd907f67", "filename": "src/libstd/num/mod.rs", "status": "modified", "additions": 75, "deletions": 1, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/1d494198bbb9701b6336febcf9d0ceb39e4b7975/src%2Flibstd%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d494198bbb9701b6336febcf9d0ceb39e4b7975/src%2Flibstd%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fmod.rs?ref=1d494198bbb9701b6336febcf9d0ceb39e4b7975", "patch": "@@ -440,7 +440,39 @@ pub trait Primitive: Clone\n /// A collection of traits relevant to primitive signed and unsigned integers\n pub trait Int: Integer\n              + Primitive\n-             + Bitwise {}\n+             + Bitwise\n+             + CheckedAdd\n+             + CheckedSub\n+             // + CheckedMul // FIXME #8849: currently not impled on 32-bit\n+             + CheckedDiv {}\n+\n+/// Returns the smallest power of 2 greater than or equal to `n`.\n+#[inline]\n+pub fn next_power_of_two<T: Unsigned + Int>(n: T) -> T {\n+    let halfbits: T = cast(size_of::<T>() * 4).unwrap();\n+    let mut tmp: T = n - one();\n+    let mut shift: T = one();\n+    while shift <= halfbits {\n+        tmp = tmp | (tmp >> shift);\n+        shift = shift << one();\n+    }\n+    tmp + one()\n+}\n+\n+/// Returns the smallest power of 2 greater than or equal to `n`. If the next\n+/// power of two is greater than the type's maximum value, `None` is returned,\n+/// otherwise the power of 2 is wrapped in `Some`.\n+#[inline]\n+pub fn checked_next_power_of_two<T: Unsigned + Int>(n: T) -> Option<T> {\n+    let halfbits: T = cast(size_of::<T>() * 4).unwrap();\n+    let mut tmp: T = n - one();\n+    let mut shift: T = one();\n+    while shift <= halfbits {\n+        tmp = tmp | (tmp >> shift);\n+        shift = shift << one();\n+    }\n+    tmp.checked_add(&one())\n+}\n \n /// Used for representing the classification of floating point numbers\n #[deriving(Eq)]\n@@ -1589,6 +1621,48 @@ mod tests {\n         assert_eq!(third.checked_mul(&4), None);\n     }\n \n+    macro_rules! test_next_power_of_two(\n+        ($test_name:ident, $T:ident) => (\n+            fn $test_name() {\n+                #[test];\n+                assert_eq!(next_power_of_two::<$T>(0), 0);\n+                let mut next_power = 1;\n+                for i in range::<$T>(1, 40) {\n+                     assert_eq!(next_power_of_two(i), next_power);\n+                     if i == next_power { next_power *= 2 }\n+                }\n+            }\n+        )\n+    )\n+\n+    test_next_power_of_two!(test_next_power_of_two_u8, u8)\n+    test_next_power_of_two!(test_next_power_of_two_u16, u16)\n+    test_next_power_of_two!(test_next_power_of_two_u32, u32)\n+    test_next_power_of_two!(test_next_power_of_two_u64, u64)\n+    test_next_power_of_two!(test_next_power_of_two_uint, uint)\n+\n+    macro_rules! test_checked_next_power_of_two(\n+        ($test_name:ident, $T:ident) => (\n+            fn $test_name() {\n+                #[test];\n+                assert_eq!(checked_next_power_of_two::<$T>(0), None);\n+                let mut next_power = 1;\n+                for i in range::<$T>(1, 40) {\n+                     assert_eq!(checked_next_power_of_two(i), Some(next_power));\n+                     if i == next_power { next_power *= 2 }\n+                }\n+                assert!(checked_next_power_of_two::<$T>($T::MAX / 2).is_some());\n+                assert_eq!(checked_next_power_of_two::<$T>($T::MAX - 1), None);\n+                assert_eq!(checked_next_power_of_two::<$T>($T::MAX), None);\n+            }\n+        )\n+    )\n+\n+    test_checked_next_power_of_two!(test_checked_next_power_of_two_u8, u8)\n+    test_checked_next_power_of_two!(test_checked_next_power_of_two_u16, u16)\n+    test_checked_next_power_of_two!(test_checked_next_power_of_two_u32, u32)\n+    test_checked_next_power_of_two!(test_checked_next_power_of_two_u64, u64)\n+    test_checked_next_power_of_two!(test_checked_next_power_of_two_uint, uint)\n \n     #[deriving(Eq)]\n     struct Value { x: int }"}, {"sha": "1811ebc7acc041424e30d7f272c1edcdc4b46b69", "filename": "src/libstd/num/uint.rs", "status": "modified", "additions": 0, "deletions": 133, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/1d494198bbb9701b6336febcf9d0ceb39e4b7975/src%2Flibstd%2Fnum%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d494198bbb9701b6336febcf9d0ceb39e4b7975/src%2Flibstd%2Fnum%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fuint.rs?ref=1d494198bbb9701b6336febcf9d0ceb39e4b7975", "patch": "@@ -15,7 +15,6 @@\n use prelude::*;\n \n use default::Default;\n-use mem;\n use num::{Bitwise, Bounded};\n use num::{CheckedAdd, CheckedSub, CheckedMul};\n use num::{CheckedDiv, Zero, One, strconv};\n@@ -26,79 +25,6 @@ use unstable::intrinsics;\n \n uint_module!(uint, int, ::int::BITS)\n \n-///\n-/// Divide two numbers, return the result, rounded up.\n-///\n-/// # Arguments\n-///\n-/// * x - an integer\n-/// * y - an integer distinct from 0u\n-///\n-/// # Return value\n-///\n-/// The smallest integer `q` such that `x/y <= q`.\n-///\n-pub fn div_ceil(x: uint, y: uint) -> uint {\n-    let div = x / y;\n-    if x % y == 0u { div }\n-    else { div + 1u }\n-}\n-\n-///\n-/// Divide two numbers, return the result, rounded to the closest integer.\n-///\n-/// # Arguments\n-///\n-/// * x - an integer\n-/// * y - an integer distinct from 0u\n-///\n-/// # Return value\n-///\n-/// The integer `q` closest to `x/y`.\n-///\n-pub fn div_round(x: uint, y: uint) -> uint {\n-    let div = x / y;\n-    if x % y * 2u  < y { div }\n-    else { div + 1u }\n-}\n-\n-///\n-/// Divide two numbers, return the result, rounded down.\n-///\n-/// Note: This is the same function as `div`.\n-///\n-/// # Arguments\n-///\n-/// * x - an integer\n-/// * y - an integer distinct from 0u\n-///\n-/// # Return value\n-///\n-/// The smallest integer `q` such that `x/y <= q`. This\n-/// is either `x/y` or `x/y + 1`.\n-///\n-pub fn div_floor(x: uint, y: uint) -> uint { return x / y; }\n-\n-/// Returns the smallest power of 2 greater than or equal to `n`\n-#[inline]\n-pub fn next_power_of_two(n: uint) -> uint {\n-    let halfbits: uint = mem::size_of::<uint>() * 4u;\n-    let mut tmp: uint = n - 1u;\n-    let mut shift: uint = 1u;\n-    while shift <= halfbits { tmp |= tmp >> shift; shift <<= 1u; }\n-    tmp + 1u\n-}\n-\n-/// Returns the smallest power of 2 greater than or equal to `n`\n-#[inline]\n-pub fn next_power_of_two_opt(n: uint) -> Option<uint> {\n-    let halfbits: uint = mem::size_of::<uint>() * 4u;\n-    let mut tmp: uint = n - 1u;\n-    let mut shift: uint = 1u;\n-    while shift <= halfbits { tmp |= tmp >> shift; shift <<= 1u; }\n-    tmp.checked_add(&1)\n-}\n-\n #[cfg(target_word_size = \"32\")]\n impl CheckedAdd for uint {\n     #[inline]\n@@ -164,62 +90,3 @@ impl CheckedMul for uint {\n         }\n     }\n }\n-\n-#[test]\n-fn test_next_power_of_two() {\n-    assert!((next_power_of_two(0u) == 0u));\n-    assert!((next_power_of_two(1u) == 1u));\n-    assert!((next_power_of_two(2u) == 2u));\n-    assert!((next_power_of_two(3u) == 4u));\n-    assert!((next_power_of_two(4u) == 4u));\n-    assert!((next_power_of_two(5u) == 8u));\n-    assert!((next_power_of_two(6u) == 8u));\n-    assert!((next_power_of_two(7u) == 8u));\n-    assert!((next_power_of_two(8u) == 8u));\n-    assert!((next_power_of_two(9u) == 16u));\n-    assert!((next_power_of_two(10u) == 16u));\n-    assert!((next_power_of_two(11u) == 16u));\n-    assert!((next_power_of_two(12u) == 16u));\n-    assert!((next_power_of_two(13u) == 16u));\n-    assert!((next_power_of_two(14u) == 16u));\n-    assert!((next_power_of_two(15u) == 16u));\n-    assert!((next_power_of_two(16u) == 16u));\n-    assert!((next_power_of_two(17u) == 32u));\n-    assert!((next_power_of_two(18u) == 32u));\n-    assert!((next_power_of_two(19u) == 32u));\n-    assert!((next_power_of_two(20u) == 32u));\n-    assert!((next_power_of_two(21u) == 32u));\n-    assert!((next_power_of_two(22u) == 32u));\n-    assert!((next_power_of_two(23u) == 32u));\n-    assert!((next_power_of_two(24u) == 32u));\n-    assert!((next_power_of_two(25u) == 32u));\n-    assert!((next_power_of_two(26u) == 32u));\n-    assert!((next_power_of_two(27u) == 32u));\n-    assert!((next_power_of_two(28u) == 32u));\n-    assert!((next_power_of_two(29u) == 32u));\n-    assert!((next_power_of_two(30u) == 32u));\n-    assert!((next_power_of_two(31u) == 32u));\n-    assert!((next_power_of_two(32u) == 32u));\n-    assert!((next_power_of_two(33u) == 64u));\n-    assert!((next_power_of_two(34u) == 64u));\n-    assert!((next_power_of_two(35u) == 64u));\n-    assert!((next_power_of_two(36u) == 64u));\n-    assert!((next_power_of_two(37u) == 64u));\n-    assert!((next_power_of_two(38u) == 64u));\n-    assert!((next_power_of_two(39u) == 64u));\n-}\n-\n-#[test]\n-fn test_overflows() {\n-    use uint;\n-    assert!((uint::MAX > 0u));\n-    assert!((uint::MIN <= 0u));\n-    assert!((uint::MIN + uint::MAX + 1u == 0u));\n-}\n-\n-#[test]\n-fn test_div() {\n-    assert!((div_floor(3u, 4u) == 0u));\n-    assert!((div_ceil(3u, 4u)  == 1u));\n-    assert!((div_round(3u, 4u) == 1u));\n-}"}, {"sha": "eb483843b5dc28adf77c7fc5357505835553f51a", "filename": "src/libstd/num/uint_macros.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1d494198bbb9701b6336febcf9d0ceb39e4b7975/src%2Flibstd%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d494198bbb9701b6336febcf9d0ceb39e4b7975/src%2Flibstd%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fuint_macros.rs?ref=1d494198bbb9701b6336febcf9d0ceb39e4b7975", "patch": "@@ -317,6 +317,13 @@ mod tests {\n     use num::Bitwise;\n     use u16;\n \n+    #[test]\n+    fn test_overflows() {\n+        assert!(MAX > 0);\n+        assert!(MIN <= 0);\n+        assert_eq!(MIN + MAX + 1, 0);\n+    }\n+\n     #[test]\n     fn test_num() {\n         num::test_num(10 as $T, 2 as $T);"}, {"sha": "3cc199ce1957139c564cf94d0b1049a2e0dc3d48", "filename": "src/libstd/str.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1d494198bbb9701b6336febcf9d0ceb39e4b7975/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d494198bbb9701b6336febcf9d0ceb39e4b7975/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=1d494198bbb9701b6336febcf9d0ceb39e4b7975", "patch": "@@ -104,13 +104,12 @@ use iter::{Iterator, FromIterator, Extendable, range};\n use iter::{Filter, AdditiveIterator, Map};\n use iter::{Rev, DoubleEndedIterator, ExactSize};\n use libc;\n-use num::{Saturating};\n+use num::{Saturating, checked_next_power_of_two};\n use option::{None, Option, Some};\n use ptr;\n use ptr::RawPtr;\n use to_str::ToStr;\n use from_str::FromStr;\n-use uint;\n use vec;\n use vec::{OwnedVector, OwnedCloneableVector, ImmutableVector, MutableVector};\n use default::Default;\n@@ -2640,7 +2639,7 @@ impl OwnedStr for ~str {\n \n     #[inline]\n     fn reserve_at_least(&mut self, n: uint) {\n-        self.reserve(uint::next_power_of_two_opt(n).unwrap_or(n))\n+        self.reserve(checked_next_power_of_two(n).unwrap_or(n))\n     }\n \n     #[inline]"}, {"sha": "74f3a6f6918da8b44a7978d3e878790b623a43db", "filename": "src/libstd/sync/mpmc_bounded_queue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1d494198bbb9701b6336febcf9d0ceb39e4b7975/src%2Flibstd%2Fsync%2Fmpmc_bounded_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d494198bbb9701b6336febcf9d0ceb39e4b7975/src%2Flibstd%2Fsync%2Fmpmc_bounded_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpmc_bounded_queue.rs?ref=1d494198bbb9701b6336febcf9d0ceb39e4b7975", "patch": "@@ -31,10 +31,10 @@\n \n use clone::Clone;\n use kinds::Send;\n+use num::next_power_of_two;\n use option::{Option, Some, None};\n use sync::arc::UnsafeArc;\n use sync::atomics::{AtomicUint,Relaxed,Release,Acquire};\n-use uint;\n use vec;\n \n struct Node<T> {\n@@ -64,7 +64,7 @@ impl<T: Send> State<T> {\n                 2u\n             } else {\n                 // use next power of 2 as capacity\n-                uint::next_power_of_two(capacity)\n+                next_power_of_two(capacity)\n             }\n         } else {\n             capacity"}, {"sha": "15cd5ce334323e1f15bd07a25cec1339d8f86252", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1d494198bbb9701b6336febcf9d0ceb39e4b7975/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d494198bbb9701b6336febcf9d0ceb39e4b7975/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=1d494198bbb9701b6336febcf9d0ceb39e4b7975", "patch": "@@ -109,7 +109,7 @@ use cmp::{Eq, TotalOrd, Ordering, Less, Equal, Greater};\n use cmp;\n use default::Default;\n use iter::*;\n-use num::{Integer, CheckedAdd, Saturating};\n+use num::{Integer, CheckedAdd, Saturating, checked_next_power_of_two};\n use option::{None, Option, Some};\n use ptr::to_unsafe_ptr;\n use ptr;\n@@ -1487,7 +1487,7 @@ impl<T> OwnedVector<T> for ~[T] {\n \n     #[inline]\n     fn reserve_at_least(&mut self, n: uint) {\n-        self.reserve(uint::next_power_of_two_opt(n).unwrap_or(n));\n+        self.reserve(checked_next_power_of_two(n).unwrap_or(n));\n     }\n \n     #[inline]"}]}