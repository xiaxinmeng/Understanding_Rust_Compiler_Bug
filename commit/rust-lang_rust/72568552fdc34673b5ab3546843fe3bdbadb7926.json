{"sha": "72568552fdc34673b5ab3546843fe3bdbadb7926", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcyNTY4NTUyZmRjMzQ2NzNiNWFiMzU0Njg0M2ZlM2JkYmFkYjc5MjY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-07-11T16:09:17Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-07-11T16:09:17Z"}, "message": "Auto merge of #85941 - cjgillot:qresolve, r=Aaron1011\n\nReduce the amount of untracked state in TyCtxt -- Take 2\n\nMain part of #85153\n\nThe offending line (https://github.com/rust-lang/rust/pull/85153#discussion_r642866298) is replaced by a FIXME until the possible bug and the perf concern are both resolved.\n\nr? `@Aaron1011`", "tree": {"sha": "e8b4ca78ff8b1c6afd109b1424e82321b1ba3c97", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e8b4ca78ff8b1c6afd109b1424e82321b1ba3c97"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/72568552fdc34673b5ab3546843fe3bdbadb7926", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/72568552fdc34673b5ab3546843fe3bdbadb7926", "html_url": "https://github.com/rust-lang/rust/commit/72568552fdc34673b5ab3546843fe3bdbadb7926", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/72568552fdc34673b5ab3546843fe3bdbadb7926/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e9a387d6cf5961a7f2dcb671da3147bd413355c4", "url": "https://api.github.com/repos/rust-lang/rust/commits/e9a387d6cf5961a7f2dcb671da3147bd413355c4", "html_url": "https://github.com/rust-lang/rust/commit/e9a387d6cf5961a7f2dcb671da3147bd413355c4"}, {"sha": "9f6d7e7dad3b59fb8939a077c577019852aad33f", "url": "https://api.github.com/repos/rust-lang/rust/commits/9f6d7e7dad3b59fb8939a077c577019852aad33f", "html_url": "https://github.com/rust-lang/rust/commit/9f6d7e7dad3b59fb8939a077c577019852aad33f"}], "stats": {"total": 261, "additions": 139, "deletions": 122}, "files": [{"sha": "30a367052cba58411702cd20b1e0f50cbd478b9f", "filename": "compiler/rustc_hir/src/definitions.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/72568552fdc34673b5ab3546843fe3bdbadb7926/compiler%2Frustc_hir%2Fsrc%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72568552fdc34673b5ab3546843fe3bdbadb7926/compiler%2Frustc_hir%2Fsrc%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fdefinitions.rs?ref=72568552fdc34673b5ab3546843fe3bdbadb7926", "patch": "@@ -23,7 +23,7 @@ use tracing::debug;\n /// Internally the `DefPathTable` holds a tree of `DefKey`s, where each `DefKey`\n /// stores the `DefIndex` of its parent.\n /// There is one `DefPathTable` for each crate.\n-#[derive(Clone, Default)]\n+#[derive(Clone, Default, Debug)]\n pub struct DefPathTable {\n     index_to_key: IndexVec<DefIndex, DefKey>,\n     def_path_hashes: IndexVec<DefIndex, DefPathHash>,\n@@ -96,7 +96,7 @@ impl DefPathTable {\n /// The definition table containing node definitions.\n /// It holds the `DefPathTable` for `LocalDefId`s/`DefPath`s.\n /// It also stores mappings to convert `LocalDefId`s to/from `HirId`s.\n-#[derive(Clone)]\n+#[derive(Clone, Debug)]\n pub struct Definitions {\n     table: DefPathTable,\n "}, {"sha": "250af3c6e89cb723d3ec12c07eb90890dac4dce8", "filename": "compiler/rustc_metadata/src/creader.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/72568552fdc34673b5ab3546843fe3bdbadb7926/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72568552fdc34673b5ab3546843fe3bdbadb7926/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs?ref=72568552fdc34673b5ab3546843fe3bdbadb7926", "patch": "@@ -51,6 +51,12 @@ pub struct CStore {\n     unused_externs: Vec<Symbol>,\n }\n \n+impl std::fmt::Debug for CStore {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        f.debug_struct(\"CStore\").finish_non_exhaustive()\n+    }\n+}\n+\n pub struct CrateLoader<'a> {\n     // Immutable configuration.\n     sess: &'a Session,"}, {"sha": "0e924d644353ce22b9a9c930a9956a2599e86d3f", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/72568552fdc34673b5ab3546843fe3bdbadb7926/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72568552fdc34673b5ab3546843fe3bdbadb7926/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=72568552fdc34673b5ab3546843fe3bdbadb7926", "patch": "@@ -445,7 +445,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n     }\n \n     fn encode_def_path_table(&mut self) {\n-        let table = self.tcx.hir().definitions().def_path_table();\n+        let table = self.tcx.resolutions(()).definitions.def_path_table();\n         if self.is_proc_macro {\n             for def_index in std::iter::once(CRATE_DEF_INDEX)\n                 .chain(self.tcx.hir().krate().proc_macros.iter().map(|p| p.owner.local_def_index))\n@@ -1062,7 +1062,7 @@ impl EncodeContext<'a, 'tcx> {\n \n         let data = ModData {\n             reexports,\n-            expansion: tcx.hir().definitions().expansion_that_defined(local_def_id),\n+            expansion: tcx.resolutions(()).definitions.expansion_that_defined(local_def_id),\n         };\n \n         record!(self.tables.kind[def_id] <- EntryKind::Mod(self.lazy(data)));\n@@ -1759,7 +1759,7 @@ impl EncodeContext<'a, 'tcx> {\n             .map(|(trait_def_id, mut impls)| {\n                 // Bring everything into deterministic order for hashing\n                 impls.sort_by_cached_key(|&(index, _)| {\n-                    tcx.hir().definitions().def_path_hash(LocalDefId { local_def_index: index })\n+                    tcx.hir().def_path_hash(LocalDefId { local_def_index: index })\n                 });\n \n                 TraitImpls {"}, {"sha": "6f799ea940b05c04bbc9c76a5a90c7b0550610ba", "filename": "compiler/rustc_middle/src/hir/map/mod.rs", "status": "modified", "additions": 30, "deletions": 15, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/72568552fdc34673b5ab3546843fe3bdbadb7926/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72568552fdc34673b5ab3546843fe3bdbadb7926/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs?ref=72568552fdc34673b5ab3546843fe3bdbadb7926", "patch": "@@ -9,7 +9,7 @@ use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::svh::Svh;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::{CrateNum, DefId, LocalDefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n-use rustc_hir::definitions::{DefKey, DefPath, Definitions};\n+use rustc_hir::definitions::{DefKey, DefPath, DefPathHash};\n use rustc_hir::intravisit;\n use rustc_hir::intravisit::Visitor;\n use rustc_hir::itemlikevisit::ItemLikeVisitor;\n@@ -154,21 +154,24 @@ impl<'hir> Map<'hir> {\n         self.tcx.hir_crate(())\n     }\n \n-    #[inline]\n-    pub fn definitions(&self) -> &'hir Definitions {\n-        &self.tcx.definitions\n-    }\n-\n     pub fn def_key(&self, def_id: LocalDefId) -> DefKey {\n-        self.tcx.definitions.def_key(def_id)\n+        // Accessing the DefKey is ok, since it is part of DefPathHash.\n+        self.tcx.untracked_resolutions.definitions.def_key(def_id)\n     }\n \n     pub fn def_path_from_hir_id(&self, id: HirId) -> Option<DefPath> {\n         self.opt_local_def_id(id).map(|def_id| self.def_path(def_id))\n     }\n \n     pub fn def_path(&self, def_id: LocalDefId) -> DefPath {\n-        self.tcx.definitions.def_path(def_id)\n+        // Accessing the DefPath is ok, since it is part of DefPathHash.\n+        self.tcx.untracked_resolutions.definitions.def_path(def_id)\n+    }\n+\n+    #[inline]\n+    pub fn def_path_hash(self, def_id: LocalDefId) -> DefPathHash {\n+        // Accessing the DefPathHash is ok, it is incr. comp. stable.\n+        self.tcx.untracked_resolutions.definitions.def_path_hash(def_id)\n     }\n \n     #[inline]\n@@ -184,16 +187,21 @@ impl<'hir> Map<'hir> {\n \n     #[inline]\n     pub fn opt_local_def_id(&self, hir_id: HirId) -> Option<LocalDefId> {\n-        self.tcx.definitions.opt_hir_id_to_local_def_id(hir_id)\n+        // FIXME(#85914) is this access safe for incr. comp.?\n+        self.tcx.untracked_resolutions.definitions.opt_hir_id_to_local_def_id(hir_id)\n     }\n \n     #[inline]\n     pub fn local_def_id_to_hir_id(&self, def_id: LocalDefId) -> HirId {\n-        self.tcx.definitions.local_def_id_to_hir_id(def_id)\n+        // FIXME(#85914) is this access safe for incr. comp.?\n+        self.tcx.untracked_resolutions.definitions.local_def_id_to_hir_id(def_id)\n     }\n \n     pub fn iter_local_def_id(&self) -> impl Iterator<Item = LocalDefId> + '_ {\n-        self.tcx.definitions.iter_local_def_id()\n+        // Create a dependency to the crate to be sure we reexcute this when the amount of\n+        // definitions change.\n+        self.tcx.ensure().hir_crate(());\n+        self.tcx.untracked_resolutions.definitions.iter_local_def_id()\n     }\n \n     pub fn opt_def_kind(&self, local_def_id: LocalDefId) -> Option<DefKind> {\n@@ -932,9 +940,15 @@ impl<'hir> intravisit::Map<'hir> for Map<'hir> {\n pub(super) fn index_hir<'tcx>(tcx: TyCtxt<'tcx>, (): ()) -> &'tcx IndexedHir<'tcx> {\n     let _prof_timer = tcx.sess.prof.generic_activity(\"build_hir_map\");\n \n+    // We can access untracked state since we are an eval_always query.\n     let hcx = tcx.create_stable_hashing_context();\n-    let mut collector =\n-        NodeCollector::root(tcx.sess, &**tcx.arena, tcx.untracked_crate, &tcx.definitions, hcx);\n+    let mut collector = NodeCollector::root(\n+        tcx.sess,\n+        &**tcx.arena,\n+        tcx.untracked_crate,\n+        &tcx.untracked_resolutions.definitions,\n+        hcx,\n+    );\n     intravisit::walk_crate(&mut collector, tcx.untracked_crate);\n \n     let map = collector.finalize_and_compute_crate_hash();\n@@ -944,14 +958,15 @@ pub(super) fn index_hir<'tcx>(tcx: TyCtxt<'tcx>, (): ()) -> &'tcx IndexedHir<'tc\n pub(super) fn crate_hash(tcx: TyCtxt<'_>, crate_num: CrateNum) -> Svh {\n     assert_eq!(crate_num, LOCAL_CRATE);\n \n+    // We can access untracked state since we are an eval_always query.\n     let mut hcx = tcx.create_stable_hashing_context();\n \n     let mut hir_body_nodes: Vec<_> = tcx\n         .index_hir(())\n         .map\n         .iter_enumerated()\n         .filter_map(|(def_id, hod)| {\n-            let def_path_hash = tcx.definitions.def_path_hash(def_id);\n+            let def_path_hash = tcx.untracked_resolutions.definitions.def_path_hash(def_id);\n             let mut hasher = StableHasher::new();\n             hod.as_ref()?.hash_stable(&mut hcx, &mut hasher);\n             AttributeMap { map: &tcx.untracked_crate.attrs, prefix: def_id }\n@@ -968,7 +983,7 @@ pub(super) fn crate_hash(tcx: TyCtxt<'_>, crate_num: CrateNum) -> Svh {\n         },\n     );\n \n-    let upstream_crates = upstream_crates(&*tcx.cstore);\n+    let upstream_crates = upstream_crates(&*tcx.untracked_resolutions.cstore);\n \n     // We hash the final, remapped names of all local source files so we\n     // don't have to include the path prefix remapping commandline args."}, {"sha": "3026bf8274d2e2eb60717de5f7b146b4fdd2e4da", "filename": "compiler/rustc_middle/src/hir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/72568552fdc34673b5ab3546843fe3bdbadb7926/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72568552fdc34673b5ab3546843fe3bdbadb7926/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs?ref=72568552fdc34673b5ab3546843fe3bdbadb7926", "patch": "@@ -169,6 +169,6 @@ pub fn provide(providers: &mut Providers) {\n     providers.all_local_trait_impls = |tcx, ()| &tcx.hir_crate(()).trait_impls;\n     providers.expn_that_defined = |tcx, id| {\n         let id = id.expect_local();\n-        tcx.definitions.expansion_that_defined(id)\n+        tcx.resolutions(()).definitions.expansion_that_defined(id)\n     };\n }"}, {"sha": "fcd4988635b079a3beb6dc139586ec0a4ed42fa7", "filename": "compiler/rustc_middle/src/middle/cstore.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/72568552fdc34673b5ab3546843fe3bdbadb7926/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72568552fdc34673b5ab3546843fe3bdbadb7926/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fcstore.rs?ref=72568552fdc34673b5ab3546843fe3bdbadb7926", "patch": "@@ -187,7 +187,7 @@ pub type MetadataLoaderDyn = dyn MetadataLoader + Sync;\n /// that it's *not* tracked for dependency information throughout compilation\n /// (it'd break incremental compilation) and should only be called pre-HIR (e.g.\n /// during resolve)\n-pub trait CrateStore {\n+pub trait CrateStore: std::fmt::Debug {\n     fn as_any(&self) -> &dyn Any;\n \n     // resolve"}, {"sha": "79a4e94948e5e9a9107d91c55a42caf0445b7be2", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/72568552fdc34673b5ab3546843fe3bdbadb7926/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72568552fdc34673b5ab3546843fe3bdbadb7926/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=72568552fdc34673b5ab3546843fe3bdbadb7926", "patch": "@@ -14,6 +14,12 @@ rustc_queries! {\n         desc { \"trigger a delay span bug\" }\n     }\n \n+    query resolutions(_: ()) -> &'tcx ty::ResolverOutputs {\n+        eval_always\n+        no_hash\n+        desc { \"get the resolver outputs\" }\n+    }\n+\n     /// Represents crate as a whole (as distinct from the top-level crate module).\n     /// If you call `hir_crate` (e.g., indirectly by calling `tcx.hir().krate()`),\n     /// we will have to assume that any change means that you need to be recompiled.\n@@ -207,7 +213,6 @@ rustc_queries! {\n     }\n \n     query expn_that_defined(key: DefId) -> rustc_span::ExpnId {\n-        eval_always\n         desc { |tcx| \"expansion that defined `{}`\", tcx.def_path_str(key) }\n     }\n \n@@ -1133,7 +1138,6 @@ rustc_queries! {\n \n     query module_exports(def_id: LocalDefId) -> Option<&'tcx [Export<LocalDefId>]> {\n         desc { |tcx| \"looking up items exported by `{}`\", tcx.def_path_str(def_id.to_def_id()) }\n-        eval_always\n     }\n \n     query impl_defaultness(def_id: DefId) -> hir::Defaultness {\n@@ -1323,7 +1327,6 @@ rustc_queries! {\n     }\n \n     query visibility(def_id: DefId) -> ty::Visibility {\n-        eval_always\n         desc { |tcx| \"computing visibility of `{}`\", tcx.def_path_str(def_id) }\n     }\n \n@@ -1348,8 +1351,6 @@ rustc_queries! {\n         desc { |tcx| \"collecting child items of `{}`\", tcx.def_path_str(def_id) }\n     }\n     query extern_mod_stmt_cnum(def_id: LocalDefId) -> Option<CrateNum> {\n-        // This depends on untracked global state (`tcx.extern_crate_map`)\n-        eval_always\n         desc { |tcx| \"computing crate imported by `{}`\", tcx.def_path_str(def_id.to_def_id()) }\n     }\n \n@@ -1426,16 +1427,12 @@ rustc_queries! {\n         eval_always\n     }\n     query maybe_unused_trait_import(def_id: LocalDefId) -> bool {\n-        eval_always\n         desc { |tcx| \"maybe_unused_trait_import for `{}`\", tcx.def_path_str(def_id.to_def_id()) }\n     }\n     query maybe_unused_extern_crates(_: ()) -> &'tcx [(LocalDefId, Span)] {\n-        eval_always\n         desc { \"looking up all possibly unused extern crates\" }\n     }\n-    query names_imported_by_glob_use(def_id: LocalDefId)\n-        -> &'tcx FxHashSet<Symbol> {\n-        eval_always\n+    query names_imported_by_glob_use(def_id: LocalDefId) -> &'tcx FxHashSet<Symbol> {\n         desc { |tcx| \"names_imported_by_glob_use for `{}`\", tcx.def_path_str(def_id.to_def_id()) }\n     }\n \n@@ -1445,7 +1442,6 @@ rustc_queries! {\n         desc { \"calculating the stability index for the local crate\" }\n     }\n     query crates(_: ()) -> &'tcx [CrateNum] {\n-        eval_always\n         desc { \"fetching all foreign CrateNum instances\" }\n     }\n "}, {"sha": "1afeb4a138f9da1334d428a90bf007684ad4186f", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 47, "deletions": 59, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/72568552fdc34673b5ab3546843fe3bdbadb7926/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72568552fdc34673b5ab3546843fe3bdbadb7926/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=72568552fdc34673b5ab3546843fe3bdbadb7926", "patch": "@@ -2,13 +2,12 @@\n \n use crate::arena::Arena;\n use crate::dep_graph::DepGraph;\n-use crate::hir::exports::ExportMap;\n use crate::hir::place::Place as HirPlace;\n use crate::ich::{NodeIdHashingMode, StableHashingContext};\n use crate::infer::canonical::{Canonical, CanonicalVarInfo, CanonicalVarInfos};\n use crate::lint::{struct_lint_level, LintDiagnosticBuilder, LintLevelSource};\n use crate::middle;\n-use crate::middle::cstore::{CrateStoreDyn, EncodedMetadata};\n+use crate::middle::cstore::EncodedMetadata;\n use crate::middle::resolve_lifetime::{self, LifetimeScopeForPath, ObjectLifetimeDefault};\n use crate::middle::stability;\n use crate::mir::interpret::{self, AllocId, Allocation, ConstValue, Scalar};\n@@ -21,10 +20,9 @@ use crate::ty::TyKind::*;\n use crate::ty::{\n     self, AdtDef, AdtKind, Binder, BindingMode, BoundVar, CanonicalPolyFnSig,\n     ClosureSizeProfileData, Const, ConstVid, DefIdTree, ExistentialPredicate, FloatTy, FloatVar,\n-    FloatVid, GenericParamDefKind, InferConst, InferTy, IntTy, IntVar, IntVid, List,\n-    MainDefinition, ParamConst, ParamTy, PolyFnSig, Predicate, PredicateInner, PredicateKind,\n-    ProjectionTy, Region, RegionKind, ReprOptions, TraitObjectVisitor, Ty, TyKind, TyS, TyVar,\n-    TyVid, TypeAndMut, UintTy, Visibility,\n+    FloatVid, GenericParamDefKind, InferConst, InferTy, IntTy, IntVar, IntVid, List, ParamConst,\n+    ParamTy, PolyFnSig, Predicate, PredicateInner, PredicateKind, ProjectionTy, Region, RegionKind,\n+    ReprOptions, TraitObjectVisitor, Ty, TyKind, TyS, TyVar, TyVid, TypeAndMut, UintTy,\n };\n use rustc_ast as ast;\n use rustc_attr as attr;\n@@ -39,7 +37,6 @@ use rustc_errors::ErrorReported;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::{CrateNum, DefId, DefIdMap, LocalDefId, LOCAL_CRATE};\n-use rustc_hir::definitions::Definitions;\n use rustc_hir::intravisit::Visitor;\n use rustc_hir::lang_items::LangItem;\n use rustc_hir::{\n@@ -966,8 +963,6 @@ pub struct GlobalCtxt<'tcx> {\n \n     interners: CtxtInterners<'tcx>,\n \n-    pub(crate) cstore: Box<CrateStoreDyn>,\n-\n     pub sess: &'tcx Session,\n \n     /// This only ever stores a `LintStore` but we don't want a dependency on that type here.\n@@ -989,17 +984,10 @@ pub struct GlobalCtxt<'tcx> {\n     /// Common consts, pre-interned for your convenience.\n     pub consts: CommonConsts<'tcx>,\n \n-    /// Visibilities produced by resolver.\n-    pub visibilities: FxHashMap<LocalDefId, Visibility>,\n-\n-    /// Resolutions of `extern crate` items produced by resolver.\n-    extern_crate_map: FxHashMap<LocalDefId, CrateNum>,\n-\n-    /// Export map produced by name resolution.\n-    export_map: ExportMap<LocalDefId>,\n+    /// Output of the resolver.\n+    pub(crate) untracked_resolutions: ty::ResolverOutputs,\n \n     pub(crate) untracked_crate: &'tcx hir::Crate<'tcx>,\n-    pub(crate) definitions: Definitions,\n \n     /// This provides access to the incremental compilation on-disk cache for query results.\n     /// Do not access this directly. It is only meant to be used by\n@@ -1010,15 +998,6 @@ pub struct GlobalCtxt<'tcx> {\n     pub queries: &'tcx dyn query::QueryEngine<'tcx>,\n     pub query_caches: query::QueryCaches<'tcx>,\n \n-    maybe_unused_trait_imports: FxHashSet<LocalDefId>,\n-    maybe_unused_extern_crates: Vec<(LocalDefId, Span)>,\n-    /// A map of glob use to a set of names it actually imports. Currently only\n-    /// used in save-analysis.\n-    pub(crate) glob_map: FxHashMap<LocalDefId, FxHashSet<Symbol>>,\n-    /// Extern prelude entries. The value is `true` if the entry was introduced\n-    /// via `extern crate` item and not `--extern` option or compiler built-in.\n-    pub extern_prelude: FxHashMap<Symbol, bool>,\n-\n     // Internal caches for metadata decoding. No need to track deps on this.\n     pub ty_rcache: Lock<FxHashMap<ty::CReaderCacheKey, Ty<'tcx>>>,\n     pub pred_rcache: Lock<FxHashMap<ty::CReaderCacheKey, Predicate<'tcx>>>,\n@@ -1052,8 +1031,6 @@ pub struct GlobalCtxt<'tcx> {\n \n     output_filenames: Arc<OutputFilenames>,\n \n-    pub main_def: Option<MainDefinition>,\n-\n     pub(super) vtables_cache:\n         Lock<FxHashMap<(Ty<'tcx>, Option<ty::PolyExistentialTraitRef<'tcx>>), AllocId>>,\n }\n@@ -1176,28 +1153,19 @@ impl<'tcx> TyCtxt<'tcx> {\n         let common_types = CommonTypes::new(&interners);\n         let common_lifetimes = CommonLifetimes::new(&interners);\n         let common_consts = CommonConsts::new(&interners, &common_types);\n-        let cstore = resolutions.cstore;\n \n         GlobalCtxt {\n             sess: s,\n             lint_store,\n-            cstore,\n             arena,\n             interners,\n             dep_graph,\n+            untracked_resolutions: resolutions,\n             prof: s.prof.clone(),\n             types: common_types,\n             lifetimes: common_lifetimes,\n             consts: common_consts,\n-            visibilities: resolutions.visibilities,\n-            extern_crate_map: resolutions.extern_crate_map,\n-            export_map: resolutions.export_map,\n-            maybe_unused_trait_imports: resolutions.maybe_unused_trait_imports,\n-            maybe_unused_extern_crates: resolutions.maybe_unused_extern_crates,\n-            glob_map: resolutions.glob_map,\n-            extern_prelude: resolutions.extern_prelude,\n             untracked_crate: krate,\n-            definitions: resolutions.definitions,\n             on_disk_cache,\n             queries,\n             query_caches: query::QueryCaches::default(),\n@@ -1212,7 +1180,6 @@ impl<'tcx> TyCtxt<'tcx> {\n             const_stability_interner: Default::default(),\n             alloc_map: Lock::new(interpret::AllocMap::new()),\n             output_filenames: Arc::new(output_filenames),\n-            main_def: resolutions.main_def,\n             vtables_cache: Default::default(),\n         }\n     }\n@@ -1273,7 +1240,12 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n \n     pub fn def_key(self, id: DefId) -> rustc_hir::definitions::DefKey {\n-        if let Some(id) = id.as_local() { self.hir().def_key(id) } else { self.cstore.def_key(id) }\n+        // Accessing the DefKey is ok, since it is part of DefPathHash.\n+        if let Some(id) = id.as_local() {\n+            self.untracked_resolutions.definitions.def_key(id)\n+        } else {\n+            self.untracked_resolutions.cstore.def_key(id)\n+        }\n     }\n \n     /// Converts a `DefId` into its fully expanded `DefPath` (every\n@@ -1282,19 +1254,21 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// Note that if `id` is not local to this crate, the result will\n     ///  be a non-local `DefPath`.\n     pub fn def_path(self, id: DefId) -> rustc_hir::definitions::DefPath {\n+        // Accessing the DefPath is ok, since it is part of DefPathHash.\n         if let Some(id) = id.as_local() {\n-            self.hir().def_path(id)\n+            self.untracked_resolutions.definitions.def_path(id)\n         } else {\n-            self.cstore.def_path(id)\n+            self.untracked_resolutions.cstore.def_path(id)\n         }\n     }\n \n     #[inline]\n     pub fn def_path_hash(self, def_id: DefId) -> rustc_hir::definitions::DefPathHash {\n+        // Accessing the DefPathHash is ok, it is incr. comp. stable.\n         if let Some(def_id) = def_id.as_local() {\n-            self.definitions.def_path_hash(def_id)\n+            self.untracked_resolutions.definitions.def_path_hash(def_id)\n         } else {\n-            self.cstore.def_path_hash(def_id)\n+            self.untracked_resolutions.cstore.def_path_hash(def_id)\n         }\n     }\n \n@@ -1303,7 +1277,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         if crate_num == LOCAL_CRATE {\n             self.sess.local_stable_crate_id()\n         } else {\n-            self.cstore.stable_crate_id_untracked(crate_num)\n+            self.untracked_resolutions.cstore.stable_crate_id_untracked(crate_num)\n         }\n     }\n \n@@ -1315,9 +1289,10 @@ impl<'tcx> TyCtxt<'tcx> {\n         let (crate_name, stable_crate_id) = if def_id.is_local() {\n             (self.crate_name, self.sess.local_stable_crate_id())\n         } else {\n+            let cstore = &self.untracked_resolutions.cstore;\n             (\n-                self.cstore.crate_name_untracked(def_id.krate),\n-                self.def_path_hash(def_id.krate.as_def_id()).stable_crate_id(),\n+                cstore.crate_name_untracked(def_id.krate),\n+                cstore.stable_crate_id_untracked(def_id.krate),\n             )\n         };\n \n@@ -1333,27 +1308,34 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     pub fn encode_metadata(self) -> EncodedMetadata {\n         let _prof_timer = self.prof.verbose_generic_activity(\"generate_crate_metadata\");\n-        self.cstore.encode_metadata(self)\n+        self.untracked_resolutions.cstore.encode_metadata(self)\n     }\n \n     // Note that this is *untracked* and should only be used within the query\n     // system if the result is otherwise tracked through queries\n     pub fn cstore_as_any(self) -> &'tcx dyn Any {\n-        self.cstore.as_any()\n+        self.untracked_resolutions.cstore.as_any()\n     }\n \n     #[inline(always)]\n     pub fn create_stable_hashing_context(self) -> StableHashingContext<'tcx> {\n         let krate = self.gcx.untracked_crate;\n+        let resolutions = &self.gcx.untracked_resolutions;\n \n-        StableHashingContext::new(self.sess, krate, &self.definitions, &*self.cstore)\n+        StableHashingContext::new(self.sess, krate, &resolutions.definitions, &*resolutions.cstore)\n     }\n \n     #[inline(always)]\n     pub fn create_no_span_stable_hashing_context(self) -> StableHashingContext<'tcx> {\n         let krate = self.gcx.untracked_crate;\n+        let resolutions = &self.gcx.untracked_resolutions;\n \n-        StableHashingContext::ignore_spans(self.sess, krate, &self.definitions, &*self.cstore)\n+        StableHashingContext::ignore_spans(\n+            self.sess,\n+            krate,\n+            &resolutions.definitions,\n+            &*resolutions.cstore,\n+        )\n     }\n \n     pub fn serialize_query_result_cache(self, encoder: &mut FileEncoder) -> FileEncodeResult {\n@@ -2821,15 +2803,19 @@ fn ptr_eq<T, U>(t: *const T, u: *const U) -> bool {\n \n pub fn provide(providers: &mut ty::query::Providers) {\n     providers.in_scope_traits_map = |tcx, id| tcx.hir_crate(()).trait_map.get(&id);\n-    providers.module_exports = |tcx, id| tcx.gcx.export_map.get(&id).map(|v| &v[..]);\n+    providers.resolutions = |tcx, ()| &tcx.untracked_resolutions;\n+    providers.module_exports = |tcx, id| tcx.resolutions(()).export_map.get(&id).map(|v| &v[..]);\n     providers.crate_name = |tcx, id| {\n         assert_eq!(id, LOCAL_CRATE);\n         tcx.crate_name\n     };\n-    providers.maybe_unused_trait_import = |tcx, id| tcx.maybe_unused_trait_imports.contains(&id);\n-    providers.maybe_unused_extern_crates = |tcx, ()| &tcx.maybe_unused_extern_crates[..];\n-    providers.names_imported_by_glob_use =\n-        |tcx, id| tcx.arena.alloc(tcx.glob_map.get(&id).cloned().unwrap_or_default());\n+    providers.maybe_unused_trait_import =\n+        |tcx, id| tcx.resolutions(()).maybe_unused_trait_imports.contains(&id);\n+    providers.maybe_unused_extern_crates =\n+        |tcx, ()| &tcx.resolutions(()).maybe_unused_extern_crates[..];\n+    providers.names_imported_by_glob_use = |tcx, id| {\n+        tcx.arena.alloc(tcx.resolutions(()).glob_map.get(&id).cloned().unwrap_or_default())\n+    };\n \n     providers.lookup_stability = |tcx, id| {\n         let id = tcx.hir().local_def_id_to_hir_id(id.expect_local());\n@@ -2843,8 +2829,10 @@ pub fn provide(providers: &mut ty::query::Providers) {\n         let id = tcx.hir().local_def_id_to_hir_id(id.expect_local());\n         tcx.stability().local_deprecation_entry(id)\n     };\n-    providers.extern_mod_stmt_cnum = |tcx, id| tcx.extern_crate_map.get(&id).cloned();\n-    providers.crates = |tcx, ()| tcx.arena.alloc_slice(&tcx.cstore.crates_untracked());\n+    providers.extern_mod_stmt_cnum =\n+        |tcx, id| tcx.resolutions(()).extern_crate_map.get(&id).cloned();\n+    providers.crates =\n+        |tcx, ()| tcx.arena.alloc_slice(&tcx.resolutions(()).cstore.crates_untracked());\n     providers.output_filenames = |tcx, ()| tcx.output_filenames.clone();\n     providers.features_query = |tcx, ()| tcx.sess.features_untracked();\n     providers.is_panic_runtime = |tcx, cnum| {"}, {"sha": "42a8f1763f117b8f110278a8764a4e9f492a92e0", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/72568552fdc34673b5ab3546843fe3bdbadb7926/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72568552fdc34673b5ab3546843fe3bdbadb7926/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=72568552fdc34673b5ab3546843fe3bdbadb7926", "patch": "@@ -113,6 +113,7 @@ mod sty;\n \n // Data types\n \n+#[derive(Debug)]\n pub struct ResolverOutputs {\n     pub definitions: rustc_hir::definitions::Definitions,\n     pub cstore: Box<CrateStoreDyn>,"}, {"sha": "21d5baced7687de4df41f9abf89d8c93655909a6", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/72568552fdc34673b5ab3546843fe3bdbadb7926/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72568552fdc34673b5ab3546843fe3bdbadb7926/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=72568552fdc34673b5ab3546843fe3bdbadb7926", "patch": "@@ -2313,7 +2313,7 @@ fn trimmed_def_paths(tcx: TyCtxt<'_>, (): ()) -> FxHashMap<DefId, Symbol> {\n     let unique_symbols_rev: &mut FxHashMap<(Namespace, Symbol), Option<DefId>> =\n         &mut FxHashMap::default();\n \n-    for symbol_set in tcx.glob_map.values() {\n+    for symbol_set in tcx.resolutions(()).glob_map.values() {\n         for symbol in symbol_set {\n             unique_symbols_rev.insert((Namespace::TypeNS, *symbol), None);\n             unique_symbols_rev.insert((Namespace::ValueNS, *symbol), None);"}, {"sha": "15188643d66319c3388d7ce116dff37900bd765b", "filename": "compiler/rustc_middle/src/ty/query/on_disk_cache.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/72568552fdc34673b5ab3546843fe3bdbadb7926/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72568552fdc34673b5ab3546843fe3bdbadb7926/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fon_disk_cache.rs?ref=72568552fdc34673b5ab3546843fe3bdbadb7926", "patch": "@@ -584,7 +584,9 @@ impl<'sess> OnDiskCache<'sess> {\n                 debug!(\"def_path_hash_to_def_id({:?})\", hash);\n                 // Check if the `DefPathHash` corresponds to a definition in the current\n                 // crate\n-                if let Some(def_id) = tcx.definitions.local_def_path_hash_to_def_id(hash) {\n+                if let Some(def_id) =\n+                    tcx.untracked_resolutions.definitions.local_def_path_hash_to_def_id(hash)\n+                {\n                     let def_id = def_id.to_def_id();\n                     e.insert(Some(def_id));\n                     return Some(def_id);\n@@ -612,7 +614,11 @@ impl<'sess> OnDiskCache<'sess> {\n                 debug_assert_ne!(krate, LOCAL_CRATE);\n                 // Try to find a definition in the current session, using the previous `DefIndex`\n                 // as an initial guess.\n-                let opt_def_id = tcx.cstore.def_path_hash_to_def_id(krate, raw_def_id.index, hash);\n+                let opt_def_id = tcx.untracked_resolutions.cstore.def_path_hash_to_def_id(\n+                    krate,\n+                    raw_def_id.index,\n+                    hash,\n+                );\n                 debug!(\"def_path_to_def_id({:?}): opt_def_id = {:?}\", hash, opt_def_id);\n                 e.insert(opt_def_id);\n                 opt_def_id"}, {"sha": "550f4f148fd24abc74d07c4280a6e1ebb044a8a4", "filename": "compiler/rustc_passes/src/entry.rs", "status": "modified", "additions": 27, "deletions": 24, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/72568552fdc34673b5ab3546843fe3bdbadb7926/compiler%2Frustc_passes%2Fsrc%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72568552fdc34673b5ab3546843fe3bdbadb7926/compiler%2Frustc_passes%2Fsrc%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fentry.rs?ref=72568552fdc34673b5ab3546843fe3bdbadb7926", "patch": "@@ -147,33 +147,36 @@ fn configure_main(tcx: TyCtxt<'_>, visitor: &EntryContext<'_, '_>) -> Option<(De\n         Some((tcx.hir().local_def_id(hir_id).to_def_id(), EntryFnType::Start))\n     } else if let Some((hir_id, _)) = visitor.attr_main_fn {\n         Some((tcx.hir().local_def_id(hir_id).to_def_id(), EntryFnType::Main))\n-    } else if let Some(def_id) = tcx.main_def.and_then(|main_def| main_def.opt_fn_def_id()) {\n-        // non-local main imports are handled below\n-        if def_id.is_local() {\n-            let hir_id = tcx.hir().local_def_id_to_hir_id(def_id.expect_local());\n-            if matches!(tcx.hir().find(hir_id), Some(Node::ForeignItem(_))) {\n-                tcx.sess\n-                    .struct_span_err(\n-                        tcx.hir().span(hir_id),\n-                        \"the `main` function cannot be declared in an `extern` block\",\n+    } else {\n+        if let Some(main_def) = tcx.resolutions(()).main_def {\n+            if let Some(def_id) = main_def.opt_fn_def_id() {\n+                // non-local main imports are handled below\n+                if def_id.is_local() {\n+                    let hir_id = tcx.hir().local_def_id_to_hir_id(def_id.expect_local());\n+                    if matches!(tcx.hir().find(hir_id), Some(Node::ForeignItem(_))) {\n+                        tcx.sess\n+                            .struct_span_err(\n+                                tcx.hir().span(hir_id),\n+                                \"the `main` function cannot be declared in an `extern` block\",\n+                            )\n+                            .emit();\n+                        return None;\n+                    }\n+                }\n+\n+                if main_def.is_import && !tcx.features().imported_main {\n+                    let span = main_def.span;\n+                    feature_err(\n+                        &tcx.sess.parse_sess,\n+                        sym::imported_main,\n+                        span,\n+                        \"using an imported function as entry point `main` is experimental\",\n                     )\n                     .emit();\n-                return None;\n+                }\n+                return Some((def_id, EntryFnType::Main));\n             }\n         }\n-\n-        if tcx.main_def.unwrap().is_import && !tcx.features().imported_main {\n-            let span = tcx.main_def.unwrap().span;\n-            feature_err(\n-                &tcx.sess.parse_sess,\n-                sym::imported_main,\n-                span,\n-                \"using an imported function as entry point `main` is experimental\",\n-            )\n-            .emit();\n-        }\n-        Some((def_id, EntryFnType::Main))\n-    } else {\n         no_main_err(tcx, visitor);\n         None\n     }\n@@ -223,7 +226,7 @@ fn no_main_err(tcx: TyCtxt<'_>, visitor: &EntryContext<'_, '_>) {\n         err.note(&note);\n     }\n \n-    if let Some(main_def) = tcx.main_def {\n+    if let Some(main_def) = tcx.resolutions(()).main_def {\n         if main_def.opt_fn_def_id().is_none() {\n             // There is something at `crate::main`, but it is not a function definition.\n             err.span_label(main_def.span, &format!(\"non-function item at `crate::main` is found\"));"}, {"sha": "d969f50c1d9185b7f5eb7af1c06e7f3450b3660a", "filename": "compiler/rustc_privacy/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/72568552fdc34673b5ab3546843fe3bdbadb7926/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72568552fdc34673b5ab3546843fe3bdbadb7926/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fsrc%2Flib.rs?ref=72568552fdc34673b5ab3546843fe3bdbadb7926", "patch": "@@ -2031,7 +2031,7 @@ pub fn provide(providers: &mut Providers) {\n \n fn visibility(tcx: TyCtxt<'_>, def_id: DefId) -> ty::Visibility {\n     let def_id = def_id.expect_local();\n-    match tcx.visibilities.get(&def_id) {\n+    match tcx.resolutions(()).visibilities.get(&def_id) {\n         Some(vis) => *vis,\n         None => {\n             let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);"}, {"sha": "fa48df3ed45c63e2ba1fe338de8e8f2dae996155", "filename": "compiler/rustc_query_impl/src/stats.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/72568552fdc34673b5ab3546843fe3bdbadb7926/compiler%2Frustc_query_impl%2Fsrc%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72568552fdc34673b5ab3546843fe3bdbadb7926/compiler%2Frustc_query_impl%2Fsrc%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fstats.rs?ref=72568552fdc34673b5ab3546843fe3bdbadb7926", "patch": "@@ -108,7 +108,7 @@ pub fn print_stats(tcx: TyCtxt<'_>) {\n         queries.iter().filter(|q| q.local_def_id_keys.is_some()).collect();\n     def_id_density.sort_by_key(|q| q.local_def_id_keys.unwrap());\n     eprintln!(\"\\nLocal DefId density:\");\n-    let total = tcx.hir().definitions().def_index_count() as f64;\n+    let total = tcx.resolutions(()).definitions.def_index_count() as f64;\n     for q in def_id_density.iter().rev() {\n         let local = q.local_def_id_keys.unwrap();\n         eprintln!(\"   {} - {} = ({}%)\", q.name, local, (local as f64 * 100.0) / total);"}, {"sha": "7e5cc771b3199a20ee75774b7f6f53a2858f916d", "filename": "compiler/rustc_typeck/src/check_unused.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/72568552fdc34673b5ab3546843fe3bdbadb7926/compiler%2Frustc_typeck%2Fsrc%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72568552fdc34673b5ab3546843fe3bdbadb7926/compiler%2Frustc_typeck%2Fsrc%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck_unused.rs?ref=72568552fdc34673b5ab3546843fe3bdbadb7926", "patch": "@@ -116,6 +116,8 @@ fn unused_crates_lint(tcx: TyCtxt<'_>) {\n         crates_to_lint: &mut crates_to_lint,\n     });\n \n+    let extern_prelude = &tcx.resolutions(()).extern_prelude;\n+\n     for extern_crate in &crates_to_lint {\n         let def_id = extern_crate.def_id.expect_local();\n         let id = tcx.hir().local_def_id_to_hir_id(def_id);\n@@ -155,7 +157,7 @@ fn unused_crates_lint(tcx: TyCtxt<'_>) {\n         // If the extern crate isn't in the extern prelude,\n         // there is no way it can be written as an `use`.\n         let orig_name = extern_crate.orig_name.unwrap_or(item.ident.name);\n-        if !tcx.extern_prelude.get(&orig_name).map_or(false, |from_item| !from_item) {\n+        if !extern_prelude.get(&orig_name).map_or(false, |from_item| !from_item) {\n             continue;\n         }\n "}]}