{"sha": "a5138b16768d2ceefee3deba995cd45fc1f52fdb", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE1MTM4YjE2NzY4ZDJjZWVmZWUzZGViYTk5NWNkNDVmYzFmNTJmZGI=", "commit": {"author": {"name": "topecongiro", "email": "seuchida@gmail.com", "date": "2017-06-15T07:25:40Z"}, "committer": {"name": "topecongiro", "email": "seuchida@gmail.com", "date": "2017-06-15T07:25:40Z"}, "message": "Use block indent for tuple pattern when fn_call_style is Block", "tree": {"sha": "6c4f542520cdb5821ef57cc7dea92e8269d16eee", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6c4f542520cdb5821ef57cc7dea92e8269d16eee"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a5138b16768d2ceefee3deba995cd45fc1f52fdb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a5138b16768d2ceefee3deba995cd45fc1f52fdb", "html_url": "https://github.com/rust-lang/rust/commit/a5138b16768d2ceefee3deba995cd45fc1f52fdb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a5138b16768d2ceefee3deba995cd45fc1f52fdb/comments", "author": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "committer": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bd1eff55bb70112c7f0cbca9333d4864625484c1", "url": "https://api.github.com/repos/rust-lang/rust/commits/bd1eff55bb70112c7f0cbca9333d4864625484c1", "html_url": "https://github.com/rust-lang/rust/commit/bd1eff55bb70112c7f0cbca9333d4864625484c1"}], "stats": {"total": 293, "additions": 197, "deletions": 96}, "files": [{"sha": "6bba83b520cc3493311dd3d4ec9362b65e576815", "filename": "src/expr.rs", "status": "modified", "additions": 113, "deletions": 39, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/a5138b16768d2ceefee3deba995cd45fc1f52fdb/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5138b16768d2ceefee3deba995cd45fc1f52fdb/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=a5138b16768d2ceefee3deba995cd45fc1f52fdb", "patch": "@@ -25,10 +25,11 @@ use utils::{extra_offset, last_line_width, wrap_str, binary_search, first_line_w\n use visitor::FmtVisitor;\n use config::{Config, IndentStyle, MultilineStyle, ControlBraceStyle, Style};\n use comment::{FindUncommented, rewrite_comment, contains_comment, recover_comment_removed};\n-use types::{rewrite_path, PathContext};\n+use types::{rewrite_path, PathContext, can_be_overflowed_type};\n use items::{span_lo_for_arg, span_hi_for_arg};\n use chains::rewrite_chain;\n use macros::{rewrite_macro, MacroPosition};\n+use patterns::{TuplePatField, can_be_overflowed_pat};\n \n use syntax::{ast, ptr};\n use syntax::codemap::{CodeMap, Span, BytePos};\n@@ -110,7 +111,13 @@ fn format_expr(\n         }\n         ast::ExprKind::Call(ref callee, ref args) => {\n             let inner_span = mk_sp(callee.span.hi, expr.span.hi);\n-            rewrite_call_with_binary_search(context, &**callee, args, inner_span, shape)\n+            rewrite_call_with_binary_search(\n+                context,\n+                &**callee,\n+                &args.iter().map(|x| &**x).collect::<Vec<_>>()[..],\n+                inner_span,\n+                shape,\n+            )\n         }\n         ast::ExprKind::Paren(ref subexpr) => rewrite_paren(context, subexpr, shape),\n         ast::ExprKind::Binary(ref op, ref lhs, ref rhs) => {\n@@ -136,7 +143,14 @@ fn format_expr(\n                 shape,\n             )\n         }\n-        ast::ExprKind::Tup(ref items) => rewrite_tuple(context, items, expr.span, shape),\n+        ast::ExprKind::Tup(ref items) => {\n+            rewrite_tuple(\n+                context,\n+                &items.iter().map(|x| &**x).collect::<Vec<_>>()[..],\n+                expr.span,\n+                shape,\n+            )\n+        }\n         ast::ExprKind::While(ref cond, ref block, label) => {\n             ControlFlow::new_while(None, cond, block, label, expr.span).rewrite(context, shape)\n         }\n@@ -1800,7 +1814,7 @@ fn string_requires_rewrite(\n pub fn rewrite_call_with_binary_search<R>(\n     context: &RewriteContext,\n     callee: &R,\n-    args: &[ptr::P<ast::Expr>],\n+    args: &[&ast::Expr],\n     span: Span,\n     shape: Shape,\n ) -> Option<String>\n@@ -1818,7 +1832,15 @@ where\n             Ordering::Greater,\n         )?;\n \n-        rewrite_call_inner(context, &callee_str, args, span, shape, false)\n+        rewrite_call_inner(\n+            context,\n+            &callee_str,\n+            args,\n+            span,\n+            shape,\n+            context.config.fn_call_width(),\n+            false,\n+        )\n     };\n \n     binary_search(1, shape.width, closure)\n@@ -1831,15 +1853,24 @@ pub fn rewrite_call(\n     span: Span,\n     shape: Shape,\n ) -> Option<String> {\n-    rewrite_call_inner(context, &callee, args, span, shape, false).ok()\n+    rewrite_call_inner(\n+        context,\n+        &callee,\n+        &args.iter().map(|x| &**x).collect::<Vec<_>>(),\n+        span,\n+        shape,\n+        context.config.fn_call_width(),\n+        false,\n+    ).ok()\n }\n \n-fn rewrite_call_inner<'a, T>(\n+pub fn rewrite_call_inner<'a, T>(\n     context: &RewriteContext,\n     callee_str: &str,\n-    args: &[ptr::P<T>],\n+    args: &[&T],\n     span: Span,\n     shape: Shape,\n+    args_max_width: usize,\n     force_trailing_comma: bool,\n ) -> Result<String, Ordering>\n where\n@@ -1873,6 +1904,7 @@ where\n         args_span,\n         nested_shape,\n         one_line_width,\n+        args_max_width,\n         force_trailing_comma,\n     ).or_else(|| if context.use_block_indent() {\n         rewrite_call_args(\n@@ -1884,6 +1916,7 @@ where\n                 context.config,\n             ),\n             0,\n+            0,\n             force_trailing_comma,\n         )\n     } else {\n@@ -1900,6 +1933,7 @@ where\n             args,\n             span,\n             shape,\n+            args_max_width,\n             force_trailing_comma,\n         );\n     }\n@@ -1930,10 +1964,11 @@ fn need_block_indent(s: &str, shape: Shape) -> bool {\n \n fn rewrite_call_args<'a, T>(\n     context: &RewriteContext,\n-    args: &[ptr::P<T>],\n+    args: &[&T],\n     span: Span,\n     shape: Shape,\n     one_line_width: usize,\n+    args_max_width: usize,\n     force_trailing_comma: bool,\n ) -> Option<(bool, String)>\n where\n@@ -1956,13 +1991,13 @@ where\n     // Try letting the last argument overflow to the next line with block\n     // indentation. If its first line fits on one line with the other arguments,\n     // we format the function arguments horizontally.\n-    let args = args.iter().filter_map(|e| e.to_expr()).collect::<Vec<_>>();\n     let tactic = try_overflow_last_arg(\n         &item_context,\n         &mut item_vec,\n         &args[..],\n         shape,\n         one_line_width,\n+        args_max_width,\n     );\n \n     let fmt = ListFormatting {\n@@ -1985,38 +2020,45 @@ where\n     })\n }\n \n-fn try_overflow_last_arg(\n+fn try_overflow_last_arg<'a, T>(\n     context: &RewriteContext,\n     item_vec: &mut Vec<ListItem>,\n-    args: &[&ast::Expr],\n+    args: &[&T],\n     shape: Shape,\n     one_line_width: usize,\n-) -> DefinitiveListTactic {\n+    args_max_width: usize,\n+) -> DefinitiveListTactic\n+where\n+    T: Rewrite + Spanned + ToExpr + 'a,\n+{\n     let overflow_last = can_be_overflowed(&context, args);\n \n     // Replace the last item with its first line to see if it fits with\n     // first arguments.\n     let (orig_last, placeholder) = if overflow_last {\n         let mut context = context.clone();\n-        match args[args.len() - 1].node {\n-            ast::ExprKind::MethodCall(..) => context.force_one_line_chain = true,\n-            _ => (),\n-        }\n-        last_arg_shape(&context, &item_vec, shape).map_or((None, None), |arg_shape| {\n-            rewrite_last_arg_with_overflow(\n-                &context,\n-                args[args.len() - 1],\n-                &mut item_vec[args.len() - 1],\n-                arg_shape,\n-            )\n-        })\n+        if let Some(expr) = args[args.len() - 1].to_expr() {\n+            match expr.node {\n+                ast::ExprKind::MethodCall(..) => context.force_one_line_chain = true,\n+                _ => (),\n+            }\n+        }\n+        last_arg_shape(&context, &item_vec, shape, args_max_width)\n+            .map_or((None, None), |arg_shape| {\n+                rewrite_last_arg_with_overflow(\n+                    &context,\n+                    args[args.len() - 1],\n+                    &mut item_vec[args.len() - 1],\n+                    arg_shape,\n+                )\n+            })\n     } else {\n         (None, None)\n     };\n \n     let tactic = definitive_tactic(\n         &*item_vec,\n-        ListTactic::LimitedHorizontalVertical(context.config.fn_call_width()),\n+        ListTactic::LimitedHorizontalVertical(args_max_width),\n         one_line_width,\n     );\n \n@@ -2035,11 +2077,16 @@ fn try_overflow_last_arg(\n     tactic\n }\n \n-fn last_arg_shape(context: &RewriteContext, items: &Vec<ListItem>, shape: Shape) -> Option<Shape> {\n+fn last_arg_shape(\n+    context: &RewriteContext,\n+    items: &Vec<ListItem>,\n+    shape: Shape,\n+    args_max_width: usize,\n+) -> Option<Shape> {\n     let overhead = items.iter().rev().skip(1).fold(0, |acc, i| {\n         acc + i.item.as_ref().map_or(0, |s| first_line_width(&s))\n     });\n-    let max_width = min(context.config.fn_call_width(), shape.width);\n+    let max_width = min(args_max_width, shape.width);\n     let arg_indent = if context.use_block_indent() {\n         shape.block().indent.block_unindent(context.config)\n     } else {\n@@ -2052,12 +2099,15 @@ fn last_arg_shape(context: &RewriteContext, items: &Vec<ListItem>, shape: Shape)\n     })\n }\n \n-fn rewrite_last_arg_with_overflow(\n+fn rewrite_last_arg_with_overflow<'a, T>(\n     context: &RewriteContext,\n-    last_arg: &ast::Expr,\n+    last_arg: &T,\n     last_item: &mut ListItem,\n     shape: Shape,\n-) -> (Option<String>, Option<String>) {\n+) -> (Option<String>, Option<String>)\n+where\n+    T: Rewrite + Spanned + ToExpr + 'a,\n+{\n     let rewrite = last_arg.rewrite(context, shape);\n     let orig_last = last_item.item.clone();\n \n@@ -2070,13 +2120,17 @@ fn rewrite_last_arg_with_overflow(\n     }\n }\n \n-fn can_be_overflowed(context: &RewriteContext, args: &[&ast::Expr]) -> bool {\n-    args.last().map_or(false, |x| {\n-        can_be_overflowed_expr(context, &x, args.len())\n-    })\n+fn can_be_overflowed<'a, T>(context: &RewriteContext, args: &[&T]) -> bool\n+where\n+    T: Rewrite + Spanned + ToExpr + 'a,\n+{\n+    args.last().map_or(\n+        false,\n+        |x| x.can_be_overflowed(context, args.len()),\n+    )\n }\n \n-fn can_be_overflowed_expr(context: &RewriteContext, expr: &ast::Expr, args_len: usize) -> bool {\n+pub fn can_be_overflowed_expr(context: &RewriteContext, expr: &ast::Expr, args_len: usize) -> bool {\n     match expr.node {\n         ast::ExprKind::Match(..) => {\n             (context.use_block_indent() && args_len == 1) ||\n@@ -2117,7 +2171,7 @@ fn paren_overhead(context: &RewriteContext) -> usize {\n     }\n }\n \n-fn wrap_args_with_parens(\n+pub fn wrap_args_with_parens(\n     context: &RewriteContext,\n     args_str: &str,\n     is_extendable: bool,\n@@ -2370,7 +2424,7 @@ fn shape_from_fn_call_style(\n \n fn rewrite_tuple_in_visual_indent_style<'a, T>(\n     context: &RewriteContext,\n-    items: &[ptr::P<T>],\n+    items: &[&T],\n     span: Span,\n     shape: Shape,\n ) -> Option<String>\n@@ -2417,7 +2471,7 @@ where\n \n pub fn rewrite_tuple<'a, T>(\n     context: &RewriteContext,\n-    items: &[ptr::P<T>],\n+    items: &[&T],\n     span: Span,\n     shape: Shape,\n ) -> Option<String>\n@@ -2433,6 +2487,7 @@ where\n             items,\n             span,\n             shape,\n+            context.config.fn_call_width(),\n             items.len() == 1,\n         ).ok()\n     } else {\n@@ -2590,16 +2645,35 @@ fn rewrite_expr_addrof(\n \n pub trait ToExpr {\n     fn to_expr(&self) -> Option<&ast::Expr>;\n+    fn can_be_overflowed(&self, context: &RewriteContext, len: usize) -> bool;\n }\n \n impl ToExpr for ast::Expr {\n     fn to_expr(&self) -> Option<&ast::Expr> {\n         Some(self)\n     }\n+\n+    fn can_be_overflowed(&self, context: &RewriteContext, len: usize) -> bool {\n+        can_be_overflowed_expr(context, self, len)\n+    }\n }\n \n impl ToExpr for ast::Ty {\n     fn to_expr(&self) -> Option<&ast::Expr> {\n         None\n     }\n+\n+    fn can_be_overflowed(&self, context: &RewriteContext, len: usize) -> bool {\n+        can_be_overflowed_type(context, self, len)\n+    }\n+}\n+\n+impl<'a> ToExpr for TuplePatField<'a> {\n+    fn to_expr(&self) -> Option<&ast::Expr> {\n+        None\n+    }\n+\n+    fn can_be_overflowed(&self, context: &RewriteContext, len: usize) -> bool {\n+        can_be_overflowed_pat(context, self, len)\n+    }\n }"}, {"sha": "88d63af2298f5abdc41418e908a4ff71fb9560cb", "filename": "src/patterns.rs", "status": "modified", "additions": 69, "deletions": 56, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/a5138b16768d2ceefee3deba995cd45fc1f52fdb/src%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5138b16768d2ceefee3deba995cd45fc1f52fdb/src%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fpatterns.rs?ref=a5138b16768d2ceefee3deba995cd45fc1f52fdb", "patch": "@@ -13,10 +13,9 @@ use codemap::SpanUtils;\n use config::{IndentStyle, MultilineStyle};\n use rewrite::{Rewrite, RewriteContext};\n use utils::{wrap_str, format_mutability, mk_sp};\n-use lists::{DefinitiveListTactic, SeparatorTactic, format_item_list, itemize_list, ListItem,\n-            struct_lit_shape, struct_lit_tactic, shape_for_tactic, struct_lit_formatting,\n-            write_list};\n-use expr::{rewrite_unary_prefix, rewrite_pair};\n+use lists::{DefinitiveListTactic, SeparatorTactic, itemize_list, struct_lit_shape,\n+            struct_lit_tactic, shape_for_tactic, struct_lit_formatting, write_list};\n+use expr::{rewrite_call_inner, rewrite_unary_prefix, rewrite_pair, can_be_overflowed_expr};\n use types::{rewrite_path, PathContext};\n use super::Spanned;\n use comment::FindUncommented;\n@@ -239,7 +238,7 @@ impl Rewrite for FieldPat {\n     }\n }\n \n-enum TuplePatField<'a> {\n+pub enum TuplePatField<'a> {\n     Pat(&'a ptr::P<ast::Pat>),\n     Dotdot(Span),\n }\n@@ -262,6 +261,24 @@ impl<'a> Spanned for TuplePatField<'a> {\n     }\n }\n \n+pub fn can_be_overflowed_pat(context: &RewriteContext, pat: &TuplePatField, len: usize) -> bool {\n+    match pat {\n+        &TuplePatField::Pat(ref pat) => {\n+            match pat.node {\n+                ast::PatKind::Tuple(..) |\n+                ast::PatKind::Struct(..) => context.use_block_indent() && len == 1,\n+                ast::PatKind::Ref(ref p, _) |\n+                ast::PatKind::Box(ref p) => {\n+                    can_be_overflowed_pat(context, &TuplePatField::Pat(p), len)\n+                }\n+                ast::PatKind::Lit(ref expr) => can_be_overflowed_expr(context, expr, len),\n+                _ => false,\n+            }\n+        }\n+        &TuplePatField::Dotdot(..) => false,\n+    }\n+}\n+\n fn rewrite_tuple_pat(\n     pats: &[ptr::P<ast::Pat>],\n     dotdot_pos: Option<usize>,\n@@ -286,77 +303,73 @@ fn rewrite_tuple_pat(\n         let dot_span = mk_sp(prev, next);\n         let snippet = context.snippet(dot_span);\n         let lo = dot_span.lo + BytePos(snippet.find_uncommented(\"..\").unwrap() as u32);\n-        let span = Span {\n+        let dotdot = TuplePatField::Dotdot(Span {\n             lo: lo,\n             // 2 == \"..\".len()\n             hi: lo + BytePos(2),\n             ctxt: codemap::NO_EXPANSION,\n-        };\n-        let dotdot = TuplePatField::Dotdot(span);\n+        });\n         pat_vec.insert(pos, dotdot);\n     }\n \n     if pat_vec.is_empty() {\n         return Some(format!(\"{}()\", try_opt!(path_str)));\n     }\n+\n+    let wildcard_suffix_len = count_wildcard_suffix_len(context, &pat_vec, span, shape);\n+    let (pat_vec, span) =\n+        if context.config.condense_wildcard_suffixes() && wildcard_suffix_len >= 2 {\n+            let new_item_count = 1 + pat_vec.len() - wildcard_suffix_len;\n+            let sp = pat_vec[new_item_count - 1].span();\n+            let snippet = context.snippet(sp);\n+            let lo = sp.lo + BytePos(snippet.find_uncommented(\"_\").unwrap() as u32);\n+            pat_vec[new_item_count - 1] = TuplePatField::Dotdot(mk_sp(lo, lo + BytePos(1)));\n+            (&pat_vec[..new_item_count], mk_sp(span.lo, lo + BytePos(1)))\n+        } else {\n+            (&pat_vec[..], span)\n+        };\n+\n     // add comma if `(x,)`\n     let add_comma = path_str.is_none() && pat_vec.len() == 1 && dotdot_pos.is_none();\n+    let mut context = context.clone();\n+    if let Some(&TuplePatField::Dotdot(..)) = pat_vec.last() {\n+        context.inside_macro = true;\n+    }\n+    let path_str = path_str.unwrap_or(String::new());\n+    let mut pat_ref_vec = Vec::with_capacity(pat_vec.len());\n+    for pat in pat_vec {\n+        pat_ref_vec.push(pat);\n+    }\n+    return rewrite_call_inner(\n+        &context,\n+        &path_str,\n+        &pat_ref_vec[..],\n+        span,\n+        shape,\n+        shape.width,\n+        add_comma,\n+    ).ok();\n+}\n+\n+fn count_wildcard_suffix_len(\n+    context: &RewriteContext,\n+    patterns: &[TuplePatField],\n+    span: Span,\n+    shape: Shape,\n+) -> usize {\n+    let mut suffix_len = 0;\n \n-    let path_len = path_str.as_ref().map(|p| p.len()).unwrap_or(0);\n-    // 2 = \"()\".len(), 3 = \"(,)\".len()\n-    let nested_shape = try_opt!(shape.sub_width(path_len + if add_comma { 3 } else { 2 }));\n-    // 1 = \"(\".len()\n-    let nested_shape = nested_shape.visual_indent(path_len + 1);\n-    let mut items: Vec<_> = itemize_list(\n+    let items: Vec<_> = itemize_list(\n         context.codemap,\n-        pat_vec.iter(),\n-        if add_comma { \",)\" } else { \")\" },\n+        patterns.iter(),\n+        \")\",\n         |item| item.span().lo,\n         |item| item.span().hi,\n-        |item| item.rewrite(context, nested_shape),\n+        |item| item.rewrite(context, shape),\n         context.codemap.span_after(span, \"(\"),\n         span.hi - BytePos(1),\n     ).collect();\n \n-    // Condense wildcard string suffix into a single ..\n-    let wildcard_suffix_len = count_wildcard_suffix_len(&items);\n-\n-    let list = if context.config.condense_wildcard_suffixes() && wildcard_suffix_len >= 2 {\n-        let new_item_count = 1 + pats.len() - wildcard_suffix_len;\n-        items[new_item_count - 1].item = Some(\"..\".to_owned());\n-\n-        let da_iter = items.into_iter().take(new_item_count);\n-        try_opt!(format_item_list(da_iter, nested_shape, context.config))\n-    } else {\n-        try_opt!(format_item_list(\n-            items.into_iter(),\n-            nested_shape,\n-            context.config,\n-        ))\n-    };\n-\n-    match path_str {\n-        Some(path_str) => {\n-            Some(if context.config.spaces_within_parens() {\n-                format!(\"{}( {} )\", path_str, list)\n-            } else {\n-                format!(\"{}({})\", path_str, list)\n-            })\n-        }\n-        None => {\n-            let comma = if add_comma { \",\" } else { \"\" };\n-            Some(if context.config.spaces_within_parens() {\n-                format!(\"( {}{} )\", list, comma)\n-            } else {\n-                format!(\"({}{})\", list, comma)\n-            })\n-        }\n-    }\n-}\n-\n-fn count_wildcard_suffix_len(items: &[ListItem]) -> usize {\n-    let mut suffix_len = 0;\n-\n     for item in items.iter().rev().take_while(|i| match i.item {\n         Some(ref internal_string) if internal_string == \"_\" => true,\n         _ => false,"}, {"sha": "d725b0919831f1e442b7de799a743137d3d97f06", "filename": "src/types.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a5138b16768d2ceefee3deba995cd45fc1f52fdb/src%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5138b16768d2ceefee3deba995cd45fc1f52fdb/src%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftypes.rs?ref=a5138b16768d2ceefee3deba995cd45fc1f52fdb", "patch": "@@ -689,7 +689,14 @@ impl Rewrite for ast::Ty {\n                         format!(\"[{}]\", ty_str)\n                     })\n             }\n-            ast::TyKind::Tup(ref items) => rewrite_tuple(context, items, self.span, shape),\n+            ast::TyKind::Tup(ref items) => {\n+                rewrite_tuple(\n+                    context,\n+                    &items.iter().map(|x| &**x).collect::<Vec<_>>()[..],\n+                    self.span,\n+                    shape,\n+                )\n+            }\n             ast::TyKind::Path(ref q_self, ref path) => {\n                 rewrite_path(context, PathContext::Type, q_self.as_ref(), path, shape)\n             }\n@@ -792,3 +799,10 @@ pub fn join_bounds(context: &RewriteContext, shape: Shape, type_strs: &Vec<Strin\n         result\n     }\n }\n+\n+pub fn can_be_overflowed_type(context: &RewriteContext, ty: &ast::Ty, len: usize) -> bool {\n+    match ty.node {\n+        ast::TyKind::Tup(..) => context.use_block_indent() && len == 1,\n+        _ => false,\n+    }\n+}"}]}