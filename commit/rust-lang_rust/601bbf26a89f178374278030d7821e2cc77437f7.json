{"sha": "601bbf26a89f178374278030d7821e2cc77437f7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYwMWJiZjI2YTg5ZjE3ODM3NDI3ODAzMGQ3ODIxZTJjYzc3NDM3Zjc=", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2016-10-25T00:04:57Z"}, "committer": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2016-12-20T10:37:14Z"}, "message": "Start of implementation of proposal for E0308", "tree": {"sha": "e8fcaafb699f49d5c302f77dc119b314ee5552b7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e8fcaafb699f49d5c302f77dc119b314ee5552b7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/601bbf26a89f178374278030d7821e2cc77437f7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/601bbf26a89f178374278030d7821e2cc77437f7", "html_url": "https://github.com/rust-lang/rust/commit/601bbf26a89f178374278030d7821e2cc77437f7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/601bbf26a89f178374278030d7821e2cc77437f7/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "94ae2a2e6791e0c4ab6fba836b2b09a07f2d3c8a", "url": "https://api.github.com/repos/rust-lang/rust/commits/94ae2a2e6791e0c4ab6fba836b2b09a07f2d3c8a", "html_url": "https://github.com/rust-lang/rust/commit/94ae2a2e6791e0c4ab6fba836b2b09a07f2d3c8a"}], "stats": {"total": 80, "additions": 78, "deletions": 2}, "files": [{"sha": "d50853e3a0e74f86384354824c763c97e13c8c31", "filename": "src/librustc/infer/error_reporting.rs", "status": "modified", "additions": 77, "deletions": 2, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/601bbf26a89f178374278030d7821e2cc77437f7/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/601bbf26a89f178374278030d7821e2cc77437f7/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting.rs?ref=601bbf26a89f178374278030d7821e2cc77437f7", "patch": "@@ -83,7 +83,7 @@ use hir::def_id::DefId;\n use infer;\n use middle::region;\n use traits::{ObligationCause, ObligationCauseCode};\n-use ty::{self, TyCtxt, TypeFoldable};\n+use ty::{self, ImplOrTraitItem, Ty, TyCtxt, TypeFoldable};\n use ty::{Region, ReFree};\n use ty::error::TypeError;\n \n@@ -549,7 +549,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     {\n         let expected_found = match values {\n             None => None,\n-            Some(values) => match self.values_str(&values) {\n+            Some(ref values) => match self.values_str(&values) {\n                 Some((expected, found)) => Some((expected, found)),\n                 None => {\n                     // Derived error. Cancel the emitter.\n@@ -582,6 +582,27 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                     diag.note_expected_found(&\"type\", &expected, &found);\n                 }\n             }\n+\n+            if let Some((found, (expected_ty, _))) = self.get_ids(values) {\n+                // look for expected with found id\n+                self.tcx.populate_inherent_implementations_for_type_if_necessary(found);\n+                if let Some(impl_infos) = self.tcx.inherent_impls.borrow().get(&found) {\n+                    let mut methods = Vec::new();\n+                    for impl_ in impl_infos {\n+                        methods.append(&mut self.tcx\n+                                                .impl_or_trait_items(*impl_)\n+                                                .iter()\n+                                                .map(|&did| self.tcx.impl_or_trait_item(did))\n+                                                .filter(|x| {\n+                                                    self.matches_return_type(x, &expected_ty)\n+                                                })\n+                                                .collect());\n+                    }\n+                    for method in methods {\n+                        println!(\"==> {:?}\", method.name());\n+                    }\n+                }\n+            }\n         }\n \n         diag.span_label(span, &terr);\n@@ -622,6 +643,60 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n+    fn matches_return_type(&self, method: &ImplOrTraitItem<'tcx>, expected: &ty::Ty<'tcx>) -> bool {\n+        match *method {\n+            ImplOrTraitItem::MethodTraitItem(ref x) => {\n+                self.can_sub_types(x.fty.sig.skip_binder().output, expected).is_ok()\n+            }\n+            _ => false,\n+        }\n+    }\n+\n+    fn get_id(&self, ty: Ty<'tcx>) -> Option<DefId> {\n+        match ty.sty {\n+            ty::TyTrait(box ref data) => Some(data.principal.def_id()),\n+            ty::TyAdt(def, _) => Some(def.did),\n+            ty::TyBox(ref ty) => self.get_id(*ty), // since we don't want box's methods by type's\n+            ty::TyChar => self.tcx.lang_items.char_impl(),\n+            ty::TyStr => self.tcx.lang_items.str_impl(),\n+            ty::TySlice(_) => self.tcx.lang_items.slice_impl(),\n+            ty::TyRawPtr(ty::TypeAndMut { ty: _, mutbl: hir::MutImmutable }) => {\n+                self.tcx.lang_items.const_ptr_impl()\n+            }\n+            ty::TyRawPtr(ty::TypeAndMut { ty: _, mutbl: hir::MutMutable }) => {\n+                self.tcx.lang_items.mut_ptr_impl()\n+            }\n+            ty::TyInt(ast::IntTy::I8) => self.tcx.lang_items.i8_impl(),\n+            ty::TyInt(ast::IntTy::I16) => self.tcx.lang_items.i16_impl(),\n+            ty::TyInt(ast::IntTy::I32) => self.tcx.lang_items.i32_impl(),\n+            ty::TyInt(ast::IntTy::I64) => self.tcx.lang_items.i64_impl(),\n+            ty::TyInt(ast::IntTy::Is) => self.tcx.lang_items.isize_impl(),\n+            ty::TyUint(ast::UintTy::U8) => self.tcx.lang_items.u8_impl(),\n+            ty::TyUint(ast::UintTy::U16) => self.tcx.lang_items.u16_impl(),\n+            ty::TyUint(ast::UintTy::U32) => self.tcx.lang_items.u32_impl(),\n+            ty::TyUint(ast::UintTy::U64) => self.tcx.lang_items.u64_impl(),\n+            ty::TyUint(ast::UintTy::Us) => self.tcx.lang_items.usize_impl(),\n+            ty::TyFloat(ast::FloatTy::F32) => self.tcx.lang_items.f32_impl(),\n+            ty::TyFloat(ast::FloatTy::F64) => self.tcx.lang_items.f64_impl(),\n+            _ => None,\n+        }\n+    }\n+\n+    // Yep, returned value super ugly. it'll certainly become `Option<(DefId, ty::Ty<'tcx>)>`\n+    // in a close future. Or maybe a struct?\n+    fn get_ids(&self, values: Option<ValuePairs<'tcx>>) -> Option<(DefId, (ty::Ty<'tcx>, DefId))> {\n+        match values {\n+            // for now, only handling non trait types\n+            Some(infer::Types(ref exp_found)) => {\n+                match (self.get_id(exp_found.found), self.get_id(exp_found.expected)) {\n+                    (Some(found), Some(expected)) => Some((found, (exp_found.expected, expected))),\n+                    _ => None,\n+                }\n+            }\n+            _ => None,\n+        }\n+    }\n+\n     fn expected_found_str<T: fmt::Display + TypeFoldable<'tcx>>(\n         &self,\n         exp_found: &ty::error::ExpectedFound<T>)"}, {"sha": "638345608c2f5d9743595101ff8352a506d07d4d", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/601bbf26a89f178374278030d7821e2cc77437f7/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/601bbf26a89f178374278030d7821e2cc77437f7/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=601bbf26a89f178374278030d7821e2cc77437f7", "patch": "@@ -543,6 +543,7 @@ pub struct ProjectionTy<'tcx> {\n pub struct BareFnTy<'tcx> {\n     pub unsafety: hir::Unsafety,\n     pub abi: abi::Abi,\n+    /// Signature (inputs and output) of this function type.\n     pub sig: PolyFnSig<'tcx>,\n }\n "}]}