{"sha": "18bfe5d8a9ca0e226171e98f8f4ef071790f3352", "node_id": "C_kwDOAAsO6NoAKDE4YmZlNWQ4YTljYTBlMjI2MTcxZTk4ZjhmNGVmMDcxNzkwZjMzNTI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-14T19:33:02Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-14T19:33:02Z"}, "message": "Auto merge of #92048 - Urgau:num-midpoint, r=scottmcm\n\nAdd midpoint function for all integers and floating numbers\n\nThis pull-request adds the `midpoint` function to `{u,i}{8,16,32,64,128,size}`, `NonZeroU{8,16,32,64,size}` and `f{32,64}`.\n\nThis new function is analog to the [C++ midpoint](https://en.cppreference.com/w/cpp/numeric/midpoint) function, and basically compute `(a + b) / 2` with a rounding towards ~~`a`~~ negative infinity in the case of integers. Or simply said: `midpoint(a, b)` is `(a + b) >> 1` as if it were performed in a sufficiently-large signed integral type.\n\nNote that unlike the C++ function this pull-request does not implement this function on pointers (`*const T` or `*mut T`). This could be implemented in a future pull-request if desire.\n\n### Implementation\n\nFor `f32` and `f64` the implementation in based on the `libcxx` [one](https://github.com/llvm/llvm-project/blob/18ab892ff7e9032914ff7fdb07685d5945c84fef/libcxx/include/__numeric/midpoint.h#L65-L77). I originally tried many different approach but all of them failed or lead me with a poor version of the `libcxx`. Note that `libstdc++` has a very similar one; Microsoft STL implementation is also basically the same as `libcxx`. It unfortunately doesn't seems like a better way exist.\n\nFor unsigned integers I created the macro `midpoint_impl!`, this macro has two branches:\n - The first one take `$SelfT` and is used when there is no unsigned integer with at least the double of bits. The code simply use this formula `a + (b - a) / 2` with the arguments in the correct order and signs to have the good rounding.\n - The second branch is used when a `$WideT` (at least double of bits as `$SelfT`) is provided, using a wider number means that no overflow can occur, this greatly improve the codegen (no branch and less instructions).\n\nFor signed integers the code basically forwards the signed numbers to the unsigned version of midpoint by mapping the signed numbers to their unsigned numbers (`ex: i8 [-128; 127] to [0; 255]`) and vice versa.\nI originally created a version that worked directly on the signed numbers but the code was \"ugly\" and not understandable. Despite this mapping \"overhead\" the codegen is better than my most optimized version on signed integers.\n\n~~Note that in the case of unsigned numbers I tried to be smart and used `#[cfg(target_pointer_width = \"64\")]` to determine if using the wide version was better or not by looking at the assembly on godbolt. This was applied to `u32`, `u64` and `usize` and doesn't change the behavior only the assembly code generated.~~", "tree": {"sha": "64e7ea28a284c8d8ef8b18cbcc4e8d13d408d02a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/64e7ea28a284c8d8ef8b18cbcc4e8d13d408d02a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/18bfe5d8a9ca0e226171e98f8f4ef071790f3352", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/18bfe5d8a9ca0e226171e98f8f4ef071790f3352", "html_url": "https://github.com/rust-lang/rust/commit/18bfe5d8a9ca0e226171e98f8f4ef071790f3352", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/18bfe5d8a9ca0e226171e98f8f4ef071790f3352/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eda41addfcf8112e69531f56ca8c478509be0135", "url": "https://api.github.com/repos/rust-lang/rust/commits/eda41addfcf8112e69531f56ca8c478509be0135", "html_url": "https://github.com/rust-lang/rust/commit/eda41addfcf8112e69531f56ca8c478509be0135"}, {"sha": "95a383bebd6181b95271aa1ffa3c164f9eb92956", "url": "https://api.github.com/repos/rust-lang/rust/commits/95a383bebd6181b95271aa1ffa3c164f9eb92956", "html_url": "https://github.com/rust-lang/rust/commit/95a383bebd6181b95271aa1ffa3c164f9eb92956"}], "stats": {"total": 316, "additions": 313, "deletions": 3}, "files": [{"sha": "0af04fac90994648c000f31a482c34e2e1df14b3", "filename": "library/core/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/18bfe5d8a9ca0e226171e98f8f4ef071790f3352/library%2Fcore%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18bfe5d8a9ca0e226171e98f8f4ef071790f3352/library%2Fcore%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Flib.rs?ref=18bfe5d8a9ca0e226171e98f8f4ef071790f3352", "patch": "@@ -133,6 +133,7 @@\n #![feature(const_maybe_uninit_assume_init)]\n #![feature(const_maybe_uninit_uninit_array)]\n #![feature(const_nonnull_new)]\n+#![feature(const_num_midpoint)]\n #![feature(const_option)]\n #![feature(const_option_ext)]\n #![feature(const_pin)]"}, {"sha": "4a035ad61e107cabc0708494c036c5d2211e541e", "filename": "library/core/src/num/f32.rs", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/18bfe5d8a9ca0e226171e98f8f4ef071790f3352/library%2Fcore%2Fsrc%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18bfe5d8a9ca0e226171e98f8f4ef071790f3352/library%2Fcore%2Fsrc%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Ff32.rs?ref=18bfe5d8a9ca0e226171e98f8f4ef071790f3352", "patch": "@@ -940,6 +940,42 @@ impl f32 {\n         }\n     }\n \n+    /// Calculates the middle point of `self` and `rhs`.\n+    ///\n+    /// This returns NaN when *either* argument is NaN or if a combination of\n+    /// +inf and -inf is provided as arguments.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(num_midpoint)]\n+    /// assert_eq!(1f32.midpoint(4.0), 2.5);\n+    /// assert_eq!((-5.5f32).midpoint(8.0), 1.25);\n+    /// ```\n+    #[unstable(feature = \"num_midpoint\", issue = \"110840\")]\n+    pub fn midpoint(self, other: f32) -> f32 {\n+        const LO: f32 = f32::MIN_POSITIVE * 2.;\n+        const HI: f32 = f32::MAX / 2.;\n+\n+        let (a, b) = (self, other);\n+        let abs_a = a.abs_private();\n+        let abs_b = b.abs_private();\n+\n+        if abs_a <= HI && abs_b <= HI {\n+            // Overflow is impossible\n+            (a + b) / 2.\n+        } else if abs_a < LO {\n+            // Not safe to halve a\n+            a + (b / 2.)\n+        } else if abs_b < LO {\n+            // Not safe to halve b\n+            (a / 2.) + b\n+        } else {\n+            // Not safe to halve a and b\n+            (a / 2.) + (b / 2.)\n+        }\n+    }\n+\n     /// Rounds toward zero and converts to any primitive integer type,\n     /// assuming that the value is finite and fits in that type.\n     ///"}, {"sha": "3aafc435f1e17687cd62e1bd47afee93818daf2b", "filename": "library/core/src/num/f64.rs", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/18bfe5d8a9ca0e226171e98f8f4ef071790f3352/library%2Fcore%2Fsrc%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18bfe5d8a9ca0e226171e98f8f4ef071790f3352/library%2Fcore%2Fsrc%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Ff64.rs?ref=18bfe5d8a9ca0e226171e98f8f4ef071790f3352", "patch": "@@ -951,6 +951,42 @@ impl f64 {\n         }\n     }\n \n+    /// Calculates the middle point of `self` and `rhs`.\n+    ///\n+    /// This returns NaN when *either* argument is NaN or if a combination of\n+    /// +inf and -inf is provided as arguments.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(num_midpoint)]\n+    /// assert_eq!(1f64.midpoint(4.0), 2.5);\n+    /// assert_eq!((-5.5f64).midpoint(8.0), 1.25);\n+    /// ```\n+    #[unstable(feature = \"num_midpoint\", issue = \"110840\")]\n+    pub fn midpoint(self, other: f64) -> f64 {\n+        const LO: f64 = f64::MIN_POSITIVE * 2.;\n+        const HI: f64 = f64::MAX / 2.;\n+\n+        let (a, b) = (self, other);\n+        let abs_a = a.abs_private();\n+        let abs_b = b.abs_private();\n+\n+        if abs_a <= HI && abs_b <= HI {\n+            // Overflow is impossible\n+            (a + b) / 2.\n+        } else if abs_a < LO {\n+            // Not safe to halve a\n+            a + (b / 2.)\n+        } else if abs_b < LO {\n+            // Not safe to halve b\n+            (a / 2.) + b\n+        } else {\n+            // Not safe to halve a and b\n+            (a / 2.) + (b / 2.)\n+        }\n+    }\n+\n     /// Rounds toward zero and converts to any primitive integer type,\n     /// assuming that the value is finite and fits in that type.\n     ///"}, {"sha": "1199d09b563d659d1c5fa6cf85b746aa58b090d8", "filename": "library/core/src/num/int_macros.rs", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/18bfe5d8a9ca0e226171e98f8f4ef071790f3352/library%2Fcore%2Fsrc%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18bfe5d8a9ca0e226171e98f8f4ef071790f3352/library%2Fcore%2Fsrc%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fint_macros.rs?ref=18bfe5d8a9ca0e226171e98f8f4ef071790f3352", "patch": "@@ -2332,6 +2332,44 @@ macro_rules! int_impl {\n             }\n         }\n \n+        /// Calculates the middle point of `self` and `rhs`.\n+        ///\n+        /// `midpoint(a, b)` is `(a + b) >> 1` as if it were performed in a\n+        /// sufficiently-large signed integral type. This implies that the result is\n+        /// always rounded towards negative infinity and that no overflow will ever occur.\n+        ///\n+        /// # Examples\n+        ///\n+        /// ```\n+        /// #![feature(num_midpoint)]\n+        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".midpoint(4), 2);\")]\n+        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".midpoint(-1), -1);\")]\n+        #[doc = concat!(\"assert_eq!((-1\", stringify!($SelfT), \").midpoint(0), -1);\")]\n+        /// ```\n+        #[unstable(feature = \"num_midpoint\", issue = \"110840\")]\n+        #[rustc_const_unstable(feature = \"const_num_midpoint\", issue = \"110840\")]\n+        #[rustc_allow_const_fn_unstable(const_num_midpoint)]\n+        #[must_use = \"this returns the result of the operation, \\\n+                      without modifying the original\"]\n+        #[inline]\n+        pub const fn midpoint(self, rhs: Self) -> Self {\n+            const U: $UnsignedT = <$SelfT>::MIN.unsigned_abs();\n+\n+            // Map an $SelfT to an $UnsignedT\n+            // ex: i8 [-128; 127] to [0; 255]\n+            const fn map(a: $SelfT) -> $UnsignedT {\n+                (a as $UnsignedT) ^ U\n+            }\n+\n+            // Map an $UnsignedT to an $SelfT\n+            // ex: u8 [0; 255] to [-128; 127]\n+            const fn demap(a: $UnsignedT) -> $SelfT {\n+                (a ^ U) as $SelfT\n+            }\n+\n+            demap(<$UnsignedT>::midpoint(map(self), map(rhs)))\n+        }\n+\n         /// Returns the logarithm of the number with respect to an arbitrary base,\n         /// rounded down.\n         ///"}, {"sha": "c9baa09f4074a2b264fcbb50eb14cb0b3c7689a9", "filename": "library/core/src/num/mod.rs", "status": "modified", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/18bfe5d8a9ca0e226171e98f8f4ef071790f3352/library%2Fcore%2Fsrc%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18bfe5d8a9ca0e226171e98f8f4ef071790f3352/library%2Fcore%2Fsrc%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fmod.rs?ref=18bfe5d8a9ca0e226171e98f8f4ef071790f3352", "patch": "@@ -95,6 +95,57 @@ depending on the target pointer size.\n     };\n }\n \n+macro_rules! midpoint_impl {\n+    ($SelfT:ty, unsigned) => {\n+        /// Calculates the middle point of `self` and `rhs`.\n+        ///\n+        /// `midpoint(a, b)` is `(a + b) >> 1` as if it were performed in a\n+        /// sufficiently-large signed integral type. This implies that the result is\n+        /// always rounded towards negative infinity and that no overflow will ever occur.\n+        ///\n+        /// # Examples\n+        ///\n+        /// ```\n+        /// #![feature(num_midpoint)]\n+        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".midpoint(4), 2);\")]\n+        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".midpoint(4), 2);\")]\n+        /// ```\n+        #[unstable(feature = \"num_midpoint\", issue = \"110840\")]\n+        #[rustc_const_unstable(feature = \"const_num_midpoint\", issue = \"110840\")]\n+        #[must_use = \"this returns the result of the operation, \\\n+                      without modifying the original\"]\n+        #[inline]\n+        pub const fn midpoint(self, rhs: $SelfT) -> $SelfT {\n+            // Use the well known branchless algorthim from Hacker's Delight to compute\n+            // `(a + b) / 2` without overflowing: `((a ^ b) >> 1) + (a & b)`.\n+            ((self ^ rhs) >> 1) + (self & rhs)\n+        }\n+    };\n+    ($SelfT:ty, $WideT:ty, unsigned) => {\n+        /// Calculates the middle point of `self` and `rhs`.\n+        ///\n+        /// `midpoint(a, b)` is `(a + b) >> 1` as if it were performed in a\n+        /// sufficiently-large signed integral type. This implies that the result is\n+        /// always rounded towards negative infinity and that no overflow will ever occur.\n+        ///\n+        /// # Examples\n+        ///\n+        /// ```\n+        /// #![feature(num_midpoint)]\n+        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".midpoint(4), 2);\")]\n+        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".midpoint(4), 2);\")]\n+        /// ```\n+        #[unstable(feature = \"num_midpoint\", issue = \"110840\")]\n+        #[rustc_const_unstable(feature = \"const_num_midpoint\", issue = \"110840\")]\n+        #[must_use = \"this returns the result of the operation, \\\n+                      without modifying the original\"]\n+        #[inline]\n+        pub const fn midpoint(self, rhs: $SelfT) -> $SelfT {\n+            ((self as $WideT + rhs as $WideT) / 2) as $SelfT\n+        }\n+    };\n+}\n+\n macro_rules! widening_impl {\n     ($SelfT:ty, $WideT:ty, $BITS:literal, unsigned) => {\n         /// Calculates the complete product `self * rhs` without the possibility to overflow.\n@@ -455,6 +506,7 @@ impl u8 {\n         bound_condition = \"\",\n     }\n     widening_impl! { u8, u16, 8, unsigned }\n+    midpoint_impl! { u8, u16, unsigned }\n \n     /// Checks if the value is within the ASCII range.\n     ///\n@@ -1066,6 +1118,7 @@ impl u16 {\n         bound_condition = \"\",\n     }\n     widening_impl! { u16, u32, 16, unsigned }\n+    midpoint_impl! { u16, u32, unsigned }\n \n     /// Checks if the value is a Unicode surrogate code point, which are disallowed values for [`char`].\n     ///\n@@ -1114,6 +1167,7 @@ impl u32 {\n         bound_condition = \"\",\n     }\n     widening_impl! { u32, u64, 32, unsigned }\n+    midpoint_impl! { u32, u64, unsigned }\n }\n \n impl u64 {\n@@ -1137,6 +1191,7 @@ impl u64 {\n         bound_condition = \"\",\n     }\n     widening_impl! { u64, u128, 64, unsigned }\n+    midpoint_impl! { u64, u128, unsigned }\n }\n \n impl u128 {\n@@ -1161,6 +1216,7 @@ impl u128 {\n         from_xe_bytes_doc = \"\",\n         bound_condition = \"\",\n     }\n+    midpoint_impl! { u128, unsigned }\n }\n \n #[cfg(target_pointer_width = \"16\")]\n@@ -1185,6 +1241,7 @@ impl usize {\n         bound_condition = \" on 16-bit targets\",\n     }\n     widening_impl! { usize, u32, 16, unsigned }\n+    midpoint_impl! { usize, u32, unsigned }\n }\n \n #[cfg(target_pointer_width = \"32\")]\n@@ -1209,6 +1266,7 @@ impl usize {\n         bound_condition = \" on 32-bit targets\",\n     }\n     widening_impl! { usize, u64, 32, unsigned }\n+    midpoint_impl! { usize, u64, unsigned }\n }\n \n #[cfg(target_pointer_width = \"64\")]\n@@ -1233,6 +1291,7 @@ impl usize {\n         bound_condition = \" on 64-bit targets\",\n     }\n     widening_impl! { usize, u128, 64, unsigned }\n+    midpoint_impl! { usize, u128, unsigned }\n }\n \n impl usize {"}, {"sha": "6a3b9c5287ad5222011cff70a434b268a9ffe28e", "filename": "library/core/src/num/nonzero.rs", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/18bfe5d8a9ca0e226171e98f8f4ef071790f3352/library%2Fcore%2Fsrc%2Fnum%2Fnonzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18bfe5d8a9ca0e226171e98f8f4ef071790f3352/library%2Fcore%2Fsrc%2Fnum%2Fnonzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fnonzero.rs?ref=18bfe5d8a9ca0e226171e98f8f4ef071790f3352", "patch": "@@ -493,6 +493,43 @@ macro_rules! nonzero_unsigned_operations {\n                 pub const fn ilog10(self) -> u32 {\n                     super::int_log10::$Int(self.0)\n                 }\n+\n+                /// Calculates the middle point of `self` and `rhs`.\n+                ///\n+                /// `midpoint(a, b)` is `(a + b) >> 1` as if it were performed in a\n+                /// sufficiently-large signed integral type. This implies that the result is\n+                /// always rounded towards negative infinity and that no overflow will ever occur.\n+                ///\n+                /// # Examples\n+                ///\n+                /// ```\n+                /// #![feature(num_midpoint)]\n+                #[doc = concat!(\"# use std::num::\", stringify!($Ty), \";\")]\n+                ///\n+                /// # fn main() { test().unwrap(); }\n+                /// # fn test() -> Option<()> {\n+                #[doc = concat!(\"let one = \", stringify!($Ty), \"::new(1)?;\")]\n+                #[doc = concat!(\"let two = \", stringify!($Ty), \"::new(2)?;\")]\n+                #[doc = concat!(\"let four = \", stringify!($Ty), \"::new(4)?;\")]\n+                ///\n+                /// assert_eq!(one.midpoint(four), two);\n+                /// assert_eq!(four.midpoint(one), two);\n+                /// # Some(())\n+                /// # }\n+                /// ```\n+                #[unstable(feature = \"num_midpoint\", issue = \"110840\")]\n+                #[rustc_const_unstable(feature = \"const_num_midpoint\", issue = \"110840\")]\n+                #[rustc_allow_const_fn_unstable(const_num_midpoint)]\n+                #[must_use = \"this returns the result of the operation, \\\n+                              without modifying the original\"]\n+                #[inline]\n+                pub const fn midpoint(self, rhs: Self) -> Self {\n+                    // SAFETY: The only way to get `0` with midpoint is to have two opposite or\n+                    // near opposite numbers: (-5, 5), (0, 1), (0, 0) which is impossible because\n+                    // of the unsignedness of this number and also because $Ty is guaranteed to\n+                    // never being 0.\n+                    unsafe { $Ty::new_unchecked(self.get().midpoint(rhs.get())) }\n+                }\n             }\n         )+\n     }"}, {"sha": "3933e3289514cc048044b65d9372bc814f7b1168", "filename": "library/core/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/18bfe5d8a9ca0e226171e98f8f4ef071790f3352/library%2Fcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18bfe5d8a9ca0e226171e98f8f4ef071790f3352/library%2Fcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Flib.rs?ref=18bfe5d8a9ca0e226171e98f8f4ef071790f3352", "patch": "@@ -53,6 +53,7 @@\n #![feature(maybe_uninit_uninit_array_transpose)]\n #![feature(min_specialization)]\n #![feature(numfmt)]\n+#![feature(num_midpoint)]\n #![feature(step_trait)]\n #![feature(str_internals)]\n #![feature(std_internals)]"}, {"sha": "439bbe669978121224a2cae041a8036ba6239898", "filename": "library/core/tests/num/int_macros.rs", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/18bfe5d8a9ca0e226171e98f8f4ef071790f3352/library%2Fcore%2Ftests%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18bfe5d8a9ca0e226171e98f8f4ef071790f3352/library%2Fcore%2Ftests%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fnum%2Fint_macros.rs?ref=18bfe5d8a9ca0e226171e98f8f4ef071790f3352", "patch": "@@ -364,6 +364,32 @@ macro_rules! int_module {\n                 assert_eq!((0 as $T).borrowing_sub($T::MIN, false), ($T::MIN, true));\n                 assert_eq!((0 as $T).borrowing_sub($T::MIN, true), ($T::MAX, false));\n             }\n+\n+            #[test]\n+            fn test_midpoint() {\n+                assert_eq!(<$T>::midpoint(1, 3), 2);\n+                assert_eq!(<$T>::midpoint(3, 1), 2);\n+\n+                assert_eq!(<$T>::midpoint(0, 0), 0);\n+                assert_eq!(<$T>::midpoint(0, 2), 1);\n+                assert_eq!(<$T>::midpoint(2, 0), 1);\n+                assert_eq!(<$T>::midpoint(2, 2), 2);\n+\n+                assert_eq!(<$T>::midpoint(1, 4), 2);\n+                assert_eq!(<$T>::midpoint(4, 1), 2);\n+                assert_eq!(<$T>::midpoint(3, 4), 3);\n+                assert_eq!(<$T>::midpoint(4, 3), 3);\n+\n+                assert_eq!(<$T>::midpoint(<$T>::MIN, <$T>::MAX), -1);\n+                assert_eq!(<$T>::midpoint(<$T>::MAX, <$T>::MIN), -1);\n+                assert_eq!(<$T>::midpoint(<$T>::MIN, <$T>::MIN), <$T>::MIN);\n+                assert_eq!(<$T>::midpoint(<$T>::MAX, <$T>::MAX), <$T>::MAX);\n+\n+                assert_eq!(<$T>::midpoint(<$T>::MIN, 6), <$T>::MIN / 2 + 3);\n+                assert_eq!(<$T>::midpoint(6, <$T>::MIN), <$T>::MIN / 2 + 3);\n+                assert_eq!(<$T>::midpoint(<$T>::MAX, 6), <$T>::MAX / 2 + 3);\n+                assert_eq!(<$T>::midpoint(6, <$T>::MAX), <$T>::MAX / 2 + 3);\n+            }\n         }\n     };\n }"}, {"sha": "3f3659ba837d5ca468cb5f7fe37121d8818068de", "filename": "library/core/tests/num/mod.rs", "status": "modified", "additions": 53, "deletions": 3, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/18bfe5d8a9ca0e226171e98f8f4ef071790f3352/library%2Fcore%2Ftests%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18bfe5d8a9ca0e226171e98f8f4ef071790f3352/library%2Fcore%2Ftests%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fnum%2Fmod.rs?ref=18bfe5d8a9ca0e226171e98f8f4ef071790f3352", "patch": "@@ -724,7 +724,7 @@ assume_usize_width! {\n }\n \n macro_rules! test_float {\n-    ($modname: ident, $fty: ty, $inf: expr, $neginf: expr, $nan: expr) => {\n+    ($modname: ident, $fty: ty, $inf: expr, $neginf: expr, $nan: expr, $min: expr, $max: expr, $min_pos: expr) => {\n         mod $modname {\n             #[test]\n             fn min() {\n@@ -845,6 +845,38 @@ macro_rules! test_float {\n                 assert!(($nan as $fty).maximum($nan).is_nan());\n             }\n             #[test]\n+            fn midpoint() {\n+                assert_eq!((0.5 as $fty).midpoint(0.5), 0.5);\n+                assert_eq!((0.5 as $fty).midpoint(2.5), 1.5);\n+                assert_eq!((3.0 as $fty).midpoint(4.0), 3.5);\n+                assert_eq!((-3.0 as $fty).midpoint(4.0), 0.5);\n+                assert_eq!((3.0 as $fty).midpoint(-4.0), -0.5);\n+                assert_eq!((-3.0 as $fty).midpoint(-4.0), -3.5);\n+                assert_eq!((0.0 as $fty).midpoint(0.0), 0.0);\n+                assert_eq!((-0.0 as $fty).midpoint(-0.0), -0.0);\n+                assert_eq!((-5.0 as $fty).midpoint(5.0), 0.0);\n+                assert_eq!(($max as $fty).midpoint($min), 0.0);\n+                assert_eq!(($min as $fty).midpoint($max), -0.0);\n+                assert_eq!(($max as $fty).midpoint($min_pos), $max / 2.);\n+                assert_eq!((-$max as $fty).midpoint($min_pos), -$max / 2.);\n+                assert_eq!(($max as $fty).midpoint(-$min_pos), $max / 2.);\n+                assert_eq!((-$max as $fty).midpoint(-$min_pos), -$max / 2.);\n+                assert_eq!(($min_pos as $fty).midpoint($max), $max / 2.);\n+                assert_eq!(($min_pos as $fty).midpoint(-$max), -$max / 2.);\n+                assert_eq!((-$min_pos as $fty).midpoint($max), $max / 2.);\n+                assert_eq!((-$min_pos as $fty).midpoint(-$max), -$max / 2.);\n+                assert_eq!(($max as $fty).midpoint($max), $max);\n+                assert_eq!(($min_pos as $fty).midpoint($min_pos), $min_pos);\n+                assert_eq!((-$min_pos as $fty).midpoint(-$min_pos), -$min_pos);\n+                assert_eq!(($max as $fty).midpoint(5.0), $max / 2.0 + 2.5);\n+                assert_eq!(($max as $fty).midpoint(-5.0), $max / 2.0 - 2.5);\n+                assert_eq!(($inf as $fty).midpoint($inf), $inf);\n+                assert_eq!(($neginf as $fty).midpoint($neginf), $neginf);\n+                assert!(($nan as $fty).midpoint(1.0).is_nan());\n+                assert!((1.0 as $fty).midpoint($nan).is_nan());\n+                assert!(($nan as $fty).midpoint($nan).is_nan());\n+            }\n+            #[test]\n             fn rem_euclid() {\n                 let a: $fty = 42.0;\n                 assert!($inf.rem_euclid(a).is_nan());\n@@ -867,5 +899,23 @@ macro_rules! test_float {\n     };\n }\n \n-test_float!(f32, f32, f32::INFINITY, f32::NEG_INFINITY, f32::NAN);\n-test_float!(f64, f64, f64::INFINITY, f64::NEG_INFINITY, f64::NAN);\n+test_float!(\n+    f32,\n+    f32,\n+    f32::INFINITY,\n+    f32::NEG_INFINITY,\n+    f32::NAN,\n+    f32::MIN,\n+    f32::MAX,\n+    f32::MIN_POSITIVE\n+);\n+test_float!(\n+    f64,\n+    f64,\n+    f64::INFINITY,\n+    f64::NEG_INFINITY,\n+    f64::NAN,\n+    f64::MIN,\n+    f64::MAX,\n+    f64::MIN_POSITIVE\n+);"}, {"sha": "7d6203db0b940ec196efcd3ff73a5f1873bb2191", "filename": "library/core/tests/num/uint_macros.rs", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/18bfe5d8a9ca0e226171e98f8f4ef071790f3352/library%2Fcore%2Ftests%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18bfe5d8a9ca0e226171e98f8f4ef071790f3352/library%2Fcore%2Ftests%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fnum%2Fuint_macros.rs?ref=18bfe5d8a9ca0e226171e98f8f4ef071790f3352", "patch": "@@ -252,6 +252,32 @@ macro_rules! uint_module {\n                 assert_eq!($T::MAX.borrowing_sub(0, true), ($T::MAX - 1, false));\n                 assert_eq!($T::MAX.borrowing_sub($T::MAX, true), ($T::MAX, true));\n             }\n+\n+            #[test]\n+            fn test_midpoint() {\n+                assert_eq!(<$T>::midpoint(1, 3), 2);\n+                assert_eq!(<$T>::midpoint(3, 1), 2);\n+\n+                assert_eq!(<$T>::midpoint(0, 0), 0);\n+                assert_eq!(<$T>::midpoint(0, 2), 1);\n+                assert_eq!(<$T>::midpoint(2, 0), 1);\n+                assert_eq!(<$T>::midpoint(2, 2), 2);\n+\n+                assert_eq!(<$T>::midpoint(1, 4), 2);\n+                assert_eq!(<$T>::midpoint(4, 1), 2);\n+                assert_eq!(<$T>::midpoint(3, 4), 3);\n+                assert_eq!(<$T>::midpoint(4, 3), 3);\n+\n+                assert_eq!(<$T>::midpoint(<$T>::MIN, <$T>::MAX), (<$T>::MAX - <$T>::MIN) / 2);\n+                assert_eq!(<$T>::midpoint(<$T>::MAX, <$T>::MIN), (<$T>::MAX - <$T>::MIN) / 2);\n+                assert_eq!(<$T>::midpoint(<$T>::MIN, <$T>::MIN), <$T>::MIN);\n+                assert_eq!(<$T>::midpoint(<$T>::MAX, <$T>::MAX), <$T>::MAX);\n+\n+                assert_eq!(<$T>::midpoint(<$T>::MIN, 6), <$T>::MIN / 2 + 3);\n+                assert_eq!(<$T>::midpoint(6, <$T>::MIN), <$T>::MIN / 2 + 3);\n+                assert_eq!(<$T>::midpoint(<$T>::MAX, 6), (<$T>::MAX - <$T>::MIN) / 2 + 3);\n+                assert_eq!(<$T>::midpoint(6, <$T>::MAX), (<$T>::MAX - <$T>::MIN) / 2 + 3);\n+            }\n         }\n     };\n }"}]}