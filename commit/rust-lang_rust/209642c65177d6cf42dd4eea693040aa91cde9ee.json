{"sha": "209642c65177d6cf42dd4eea693040aa91cde9ee", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIwOTY0MmM2NTE3N2Q2Y2Y0MmRkNGVlYTY5MzA0MGFhOTFjZGU5ZWU=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-01-30T22:10:53Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-02-03T17:32:34Z"}, "message": "std: Fix tests with io_error usage", "tree": {"sha": "b9c7c1c2382c978a53b6dd3f1c6c6fccb116cf0a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b9c7c1c2382c978a53b6dd3f1c6c6fccb116cf0a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/209642c65177d6cf42dd4eea693040aa91cde9ee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/209642c65177d6cf42dd4eea693040aa91cde9ee", "html_url": "https://github.com/rust-lang/rust/commit/209642c65177d6cf42dd4eea693040aa91cde9ee", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/209642c65177d6cf42dd4eea693040aa91cde9ee/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "29e7247fd8be5a9879ebcd1a3ddc47e2fa743abd", "url": "https://api.github.com/repos/rust-lang/rust/commits/29e7247fd8be5a9879ebcd1a3ddc47e2fa743abd", "html_url": "https://github.com/rust-lang/rust/commit/29e7247fd8be5a9879ebcd1a3ddc47e2fa743abd"}], "stats": {"total": 1268, "additions": 568, "deletions": 700}, "files": [{"sha": "bccebeaa79f6b9fb12f2d01f2096b50159b7960e", "filename": "src/libstd/comm/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/209642c65177d6cf42dd4eea693040aa91cde9ee/src%2Flibstd%2Fcomm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/209642c65177d6cf42dd4eea693040aa91cde9ee/src%2Flibstd%2Fcomm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fmod.rs?ref=209642c65177d6cf42dd4eea693040aa91cde9ee", "patch": "@@ -1252,7 +1252,7 @@ mod test {\n             spawn(proc() {\n                 let _p = port;\n             });\n-            task::try(proc() {\n+            let _ = task::try(proc() {\n                 chan.send(1);\n             });\n         }"}, {"sha": "e3bc97b6f28f0137f95aa094c0f8d3cf66700231", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 55, "deletions": 50, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/209642c65177d6cf42dd4eea693040aa91cde9ee/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/209642c65177d6cf42dd4eea693040aa91cde9ee/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=209642c65177d6cf42dd4eea693040aa91cde9ee", "patch": "@@ -88,7 +88,7 @@ impl<R: Reader> BufferedReader<R> {\n \n impl<R: Reader> Buffer for BufferedReader<R> {\n     fn fill<'a>(&'a mut self) -> IoResult<&'a [u8]> {\n-        while self.pos == self.cap {\n+        if self.pos == self.cap {\n             self.cap = if_ok!(self.inner.read(self.buf));\n             self.pos = 0;\n         }\n@@ -360,13 +360,13 @@ mod test {\n     pub struct NullStream;\n \n     impl Reader for NullStream {\n-        fn read(&mut self, _: &mut [u8]) -> Option<uint> {\n-            None\n+        fn read(&mut self, _: &mut [u8]) -> io::IoResult<uint> {\n+            Err(io::standard_error(io::EndOfFile))\n         }\n     }\n \n     impl Writer for NullStream {\n-        fn write(&mut self, _: &[u8]) { }\n+        fn write(&mut self, _: &[u8]) -> io::IoResult<()> { Ok(()) }\n     }\n \n     /// A dummy reader intended at testing short-reads propagation.\n@@ -375,8 +375,11 @@ mod test {\n     }\n \n     impl Reader for ShortReader {\n-        fn read(&mut self, _: &mut [u8]) -> Option<uint> {\n-            self.lengths.shift()\n+        fn read(&mut self, _: &mut [u8]) -> io::IoResult<uint> {\n+            match self.lengths.shift() {\n+                Some(i) => Ok(i),\n+                None => Err(io::standard_error(io::EndOfFile))\n+            }\n         }\n     }\n \n@@ -387,68 +390,68 @@ mod test {\n \n         let mut buf = [0, 0, 0];\n         let nread = reader.read(buf);\n-        assert_eq!(Some(2), nread);\n+        assert_eq!(Ok(2), nread);\n         assert_eq!([0, 1, 0], buf);\n \n         let mut buf = [0];\n         let nread = reader.read(buf);\n-        assert_eq!(Some(1), nread);\n+        assert_eq!(Ok(1), nread);\n         assert_eq!([2], buf);\n \n         let mut buf = [0, 0, 0];\n         let nread = reader.read(buf);\n-        assert_eq!(Some(1), nread);\n+        assert_eq!(Ok(1), nread);\n         assert_eq!([3, 0, 0], buf);\n \n         let nread = reader.read(buf);\n-        assert_eq!(Some(1), nread);\n+        assert_eq!(Ok(1), nread);\n         assert_eq!([4, 0, 0], buf);\n \n-        assert_eq!(None, reader.read(buf));\n+        assert!(reader.read(buf).is_err());\n     }\n \n     #[test]\n     fn test_buffered_writer() {\n         let inner = MemWriter::new();\n         let mut writer = BufferedWriter::with_capacity(2, inner);\n \n-        writer.write([0, 1]);\n+        writer.write([0, 1]).unwrap();\n         assert_eq!([], writer.get_ref().get_ref());\n \n-        writer.write([2]);\n+        writer.write([2]).unwrap();\n         assert_eq!([0, 1], writer.get_ref().get_ref());\n \n-        writer.write([3]);\n+        writer.write([3]).unwrap();\n         assert_eq!([0, 1], writer.get_ref().get_ref());\n \n-        writer.flush();\n+        writer.flush().unwrap();\n         assert_eq!([0, 1, 2, 3], writer.get_ref().get_ref());\n \n-        writer.write([4]);\n-        writer.write([5]);\n+        writer.write([4]).unwrap();\n+        writer.write([5]).unwrap();\n         assert_eq!([0, 1, 2, 3], writer.get_ref().get_ref());\n \n-        writer.write([6]);\n+        writer.write([6]).unwrap();\n         assert_eq!([0, 1, 2, 3, 4, 5],\n                    writer.get_ref().get_ref());\n \n-        writer.write([7, 8]);\n+        writer.write([7, 8]).unwrap();\n         assert_eq!([0, 1, 2, 3, 4, 5, 6],\n                    writer.get_ref().get_ref());\n \n-        writer.write([9, 10, 11]);\n+        writer.write([9, 10, 11]).unwrap();\n         assert_eq!([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11],\n                    writer.get_ref().get_ref());\n \n-        writer.flush();\n+        writer.flush().unwrap();\n         assert_eq!([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11],\n                    writer.get_ref().get_ref());\n     }\n \n     #[test]\n     fn test_buffered_writer_inner_flushes() {\n         let mut w = BufferedWriter::with_capacity(3, MemWriter::new());\n-        w.write([0, 1]);\n+        w.write([0, 1]).unwrap();\n         assert_eq!([], w.get_ref().get_ref());\n         let w = w.unwrap();\n         assert_eq!([0, 1], w.get_ref());\n@@ -461,47 +464,49 @@ mod test {\n         struct S;\n \n         impl io::Writer for S {\n-            fn write(&mut self, _: &[u8]) {}\n+            fn write(&mut self, _: &[u8]) -> io::IoResult<()> { Ok(()) }\n         }\n \n         impl io::Reader for S {\n-            fn read(&mut self, _: &mut [u8]) -> Option<uint> { None }\n+            fn read(&mut self, _: &mut [u8]) -> io::IoResult<uint> {\n+                Err(io::standard_error(io::EndOfFile))\n+            }\n         }\n \n         let mut stream = BufferedStream::new(S);\n         let mut buf = [];\n-        stream.read(buf);\n-        stream.write(buf);\n-        stream.flush();\n+        assert!(stream.read(buf).is_err());\n+        stream.write(buf).unwrap();\n+        stream.flush().unwrap();\n     }\n \n     #[test]\n     fn test_read_until() {\n         let inner = MemReader::new(~[0, 1, 2, 1, 0]);\n         let mut reader = BufferedReader::with_capacity(2, inner);\n-        assert_eq!(reader.read_until(0), Some(~[0]));\n-        assert_eq!(reader.read_until(2), Some(~[1, 2]));\n-        assert_eq!(reader.read_until(1), Some(~[1]));\n-        assert_eq!(reader.read_until(8), Some(~[0]));\n-        assert_eq!(reader.read_until(9), None);\n+        assert_eq!(reader.read_until(0), Ok(~[0]));\n+        assert_eq!(reader.read_until(2), Ok(~[1, 2]));\n+        assert_eq!(reader.read_until(1), Ok(~[1]));\n+        assert_eq!(reader.read_until(8), Ok(~[0]));\n+        assert!(reader.read_until(9).is_err());\n     }\n \n     #[test]\n     fn test_line_buffer() {\n         let mut writer = LineBufferedWriter::new(MemWriter::new());\n-        writer.write([0]);\n+        writer.write([0]).unwrap();\n         assert_eq!(writer.get_ref().get_ref(), []);\n-        writer.write([1]);\n+        writer.write([1]).unwrap();\n         assert_eq!(writer.get_ref().get_ref(), []);\n-        writer.flush();\n+        writer.flush().unwrap();\n         assert_eq!(writer.get_ref().get_ref(), [0, 1]);\n-        writer.write([0, '\\n' as u8, 1, '\\n' as u8, 2]);\n+        writer.write([0, '\\n' as u8, 1, '\\n' as u8, 2]).unwrap();\n         assert_eq!(writer.get_ref().get_ref(),\n             [0, 1, 0, '\\n' as u8, 1, '\\n' as u8]);\n-        writer.flush();\n+        writer.flush().unwrap();\n         assert_eq!(writer.get_ref().get_ref(),\n             [0, 1, 0, '\\n' as u8, 1, '\\n' as u8, 2]);\n-        writer.write([3, '\\n' as u8]);\n+        writer.write([3, '\\n' as u8]).unwrap();\n         assert_eq!(writer.get_ref().get_ref(),\n             [0, 1, 0, '\\n' as u8, 1, '\\n' as u8, 2, 3, '\\n' as u8]);\n     }\n@@ -510,10 +515,10 @@ mod test {\n     fn test_read_line() {\n         let in_buf = MemReader::new(bytes!(\"a\\nb\\nc\").to_owned());\n         let mut reader = BufferedReader::with_capacity(2, in_buf);\n-        assert_eq!(reader.read_line(), Some(~\"a\\n\"));\n-        assert_eq!(reader.read_line(), Some(~\"b\\n\"));\n-        assert_eq!(reader.read_line(), Some(~\"c\"));\n-        assert_eq!(reader.read_line(), None);\n+        assert_eq!(reader.read_line(), Ok(~\"a\\n\"));\n+        assert_eq!(reader.read_line(), Ok(~\"b\\n\"));\n+        assert_eq!(reader.read_line(), Ok(~\"c\"));\n+        assert!(reader.read_line().is_err());\n     }\n \n     #[test]\n@@ -532,20 +537,20 @@ mod test {\n         let inner = ShortReader{lengths: ~[0, 1, 2, 0, 1, 0]};\n         let mut reader = BufferedReader::new(inner);\n         let mut buf = [0, 0];\n-        assert_eq!(reader.read(buf), Some(0));\n-        assert_eq!(reader.read(buf), Some(1));\n-        assert_eq!(reader.read(buf), Some(2));\n-        assert_eq!(reader.read(buf), Some(0));\n-        assert_eq!(reader.read(buf), Some(1));\n-        assert_eq!(reader.read(buf), Some(0));\n-        assert_eq!(reader.read(buf), None);\n+        assert_eq!(reader.read(buf), Ok(0));\n+        assert_eq!(reader.read(buf), Ok(1));\n+        assert_eq!(reader.read(buf), Ok(2));\n+        assert_eq!(reader.read(buf), Ok(0));\n+        assert_eq!(reader.read(buf), Ok(1));\n+        assert_eq!(reader.read(buf), Ok(0));\n+        assert!(reader.read(buf).is_err());\n     }\n \n     #[test]\n     fn read_char_buffered() {\n         let buf = [195u8, 159u8];\n         let mut reader = BufferedReader::with_capacity(1, BufReader::new(buf));\n-        assert_eq!(reader.read_char(), Some('\u00df'));\n+        assert_eq!(reader.read_char(), Ok('\u00df'));\n     }\n \n     #[bench]"}, {"sha": "6ed588ac69fd42266c02ea72a1dd69d229e4f9be", "filename": "src/libstd/io/comm_adapters.rs", "status": "modified", "additions": 17, "deletions": 28, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/209642c65177d6cf42dd4eea693040aa91cde9ee/src%2Flibstd%2Fio%2Fcomm_adapters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/209642c65177d6cf42dd4eea693040aa91cde9ee/src%2Flibstd%2Fio%2Fcomm_adapters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fcomm_adapters.rs?ref=209642c65177d6cf42dd4eea693040aa91cde9ee", "patch": "@@ -133,55 +133,44 @@ mod test {\n         let mut buf = ~[0u8, ..3];\n \n \n-        assert_eq!(Some(0), reader.read([]));\n+        assert_eq!(Ok(0), reader.read([]));\n \n-        assert_eq!(Some(3), reader.read(buf));\n+        assert_eq!(Ok(3), reader.read(buf));\n         assert_eq!(~[1,2,3], buf);\n \n-        assert_eq!(Some(3), reader.read(buf));\n+        assert_eq!(Ok(3), reader.read(buf));\n         assert_eq!(~[4,5,6], buf);\n \n-        assert_eq!(Some(2), reader.read(buf));\n+        assert_eq!(Ok(2), reader.read(buf));\n         assert_eq!(~[7,8,6], buf);\n \n-        let mut err = None;\n-        let result = io::io_error::cond.trap(|io::standard_error(k, _, _)| {\n-            err = Some(k)\n-        }).inside(|| {\n-            reader.read(buf)\n-        });\n-        assert_eq!(Some(io::EndOfFile), err);\n-        assert_eq!(None, result);\n+        match reader.read(buf) {\n+            Ok(..) => fail!(),\n+            Err(e) => assert_eq!(e.kind, io::EndOfFile),\n+        }\n         assert_eq!(~[7,8,6], buf);\n \n         // Ensure it continues to fail in the same way.\n-        err = None;\n-        let result = io::io_error::cond.trap(|io::standard_error(k, _, _)| {\n-            err = Some(k)\n-        }).inside(|| {\n-            reader.read(buf)\n-        });\n-        assert_eq!(Some(io::EndOfFile), err);\n-        assert_eq!(None, result);\n+        match reader.read(buf) {\n+            Ok(..) => fail!(),\n+            Err(e) => assert_eq!(e.kind, io::EndOfFile),\n+        }\n         assert_eq!(~[7,8,6], buf);\n     }\n \n     #[test]\n     fn test_chan_writer() {\n         let (port, chan) = Chan::new();\n         let mut writer = ChanWriter::new(chan);\n-        writer.write_be_u32(42);\n+        writer.write_be_u32(42).unwrap();\n \n         let wanted = ~[0u8, 0u8, 0u8, 42u8];\n         let got = task::try(proc() { port.recv() }).unwrap();\n         assert_eq!(wanted, got);\n \n-        let mut err = None;\n-        io::io_error::cond.trap(|io::IoError { kind, .. } | {\n-            err = Some(kind)\n-        }).inside(|| {\n-            writer.write_u8(1)\n-        });\n-        assert_eq!(Some(io::BrokenPipe), err);\n+        match writer.write_u8(1) {\n+            Ok(..) => fail!(),\n+            Err(e) => assert_eq!(e.kind, io::BrokenPipe),\n+        }\n     }\n }"}, {"sha": "49d51cbb26fc87f5ba9b35db090f49eafae2bccb", "filename": "src/libstd/io/extensions.rs", "status": "modified", "additions": 48, "deletions": 84, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/209642c65177d6cf42dd4eea693040aa91cde9ee/src%2Flibstd%2Fio%2Fextensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/209642c65177d6cf42dd4eea693040aa91cde9ee/src%2Flibstd%2Fio%2Fextensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fextensions.rs?ref=209642c65177d6cf42dd4eea693040aa91cde9ee", "patch": "@@ -125,41 +125,39 @@ pub fn u64_from_be_bytes(data: &[u8],\n \n #[cfg(test)]\n mod test {\n-    use unstable::finally::Finally;\n     use prelude::*;\n+    use io;\n     use io::{MemReader, MemWriter};\n-    use io::{io_error, placeholder_error};\n \n     struct InitialZeroByteReader {\n         count: int,\n     }\n \n     impl Reader for InitialZeroByteReader {\n-        fn read(&mut self, buf: &mut [u8]) -> Option<uint> {\n+        fn read(&mut self, buf: &mut [u8]) -> io::IoResult<uint> {\n             if self.count == 0 {\n                 self.count = 1;\n-                Some(0)\n+                Ok(0)\n             } else {\n                 buf[0] = 10;\n-                Some(1)\n+                Ok(1)\n             }\n         }\n     }\n \n     struct EofReader;\n \n     impl Reader for EofReader {\n-        fn read(&mut self, _: &mut [u8]) -> Option<uint> {\n-            None\n+        fn read(&mut self, _: &mut [u8]) -> io::IoResult<uint> {\n+            Err(io::standard_error(io::EndOfFile))\n         }\n     }\n \n     struct ErroringReader;\n \n     impl Reader for ErroringReader {\n-        fn read(&mut self, _: &mut [u8]) -> Option<uint> {\n-            io_error::cond.raise(placeholder_error());\n-            None\n+        fn read(&mut self, _: &mut [u8]) -> io::IoResult<uint> {\n+            Err(io::standard_error(io::InvalidInput))\n         }\n     }\n \n@@ -168,16 +166,16 @@ mod test {\n     }\n \n     impl Reader for PartialReader {\n-        fn read(&mut self, buf: &mut [u8]) -> Option<uint> {\n+        fn read(&mut self, buf: &mut [u8]) -> io::IoResult<uint> {\n             if self.count == 0 {\n                 self.count = 1;\n                 buf[0] = 10;\n                 buf[1] = 11;\n-                Some(2)\n+                Ok(2)\n             } else {\n                 buf[0] = 12;\n                 buf[1] = 13;\n-                Some(2)\n+                Ok(2)\n             }\n         }\n     }\n@@ -187,14 +185,13 @@ mod test {\n     }\n \n     impl Reader for ErroringLaterReader {\n-        fn read(&mut self, buf: &mut [u8]) -> Option<uint> {\n+        fn read(&mut self, buf: &mut [u8]) -> io::IoResult<uint> {\n             if self.count == 0 {\n                 self.count = 1;\n                 buf[0] = 10;\n-                Some(1)\n+                Ok(1)\n             } else {\n-                io_error::cond.raise(placeholder_error());\n-                None\n+                Err(io::standard_error(io::InvalidInput))\n             }\n         }\n     }\n@@ -204,19 +201,19 @@ mod test {\n     }\n \n     impl Reader for ThreeChunkReader {\n-        fn read(&mut self, buf: &mut [u8]) -> Option<uint> {\n+        fn read(&mut self, buf: &mut [u8]) -> io::IoResult<uint> {\n             if self.count == 0 {\n                 self.count = 1;\n                 buf[0] = 10;\n                 buf[1] = 11;\n-                Some(2)\n+                Ok(2)\n             } else if self.count == 1 {\n                 self.count = 2;\n                 buf[0] = 12;\n                 buf[1] = 13;\n-                Some(2)\n+                Ok(2)\n             } else {\n-                None\n+                Err(io::standard_error(io::EndOfFile))\n             }\n         }\n     }\n@@ -225,7 +222,7 @@ mod test {\n     fn read_byte() {\n         let mut reader = MemReader::new(~[10]);\n         let byte = reader.read_byte();\n-        assert!(byte == Some(10));\n+        assert!(byte == Ok(10));\n     }\n \n     #[test]\n@@ -234,24 +231,21 @@ mod test {\n             count: 0,\n         };\n         let byte = reader.read_byte();\n-        assert!(byte == Some(10));\n+        assert!(byte == Ok(10));\n     }\n \n     #[test]\n     fn read_byte_eof() {\n         let mut reader = EofReader;\n         let byte = reader.read_byte();\n-        assert!(byte == None);\n+        assert!(byte.is_err());\n     }\n \n     #[test]\n     fn read_byte_error() {\n         let mut reader = ErroringReader;\n-        io_error::cond.trap(|_| {\n-        }).inside(|| {\n-            let byte = reader.read_byte();\n-            assert!(byte == None);\n-        });\n+        let byte = reader.read_byte();\n+        assert!(byte.is_err());\n     }\n \n     #[test]\n@@ -267,23 +261,21 @@ mod test {\n     fn bytes_eof() {\n         let mut reader = EofReader;\n         let byte = reader.bytes().next();\n-        assert!(byte == None);\n+        assert!(byte.is_none());\n     }\n \n     #[test]\n     fn bytes_error() {\n         let mut reader = ErroringReader;\n         let mut it = reader.bytes();\n-        io_error::cond.trap(|_| ()).inside(|| {\n-            let byte = it.next();\n-            assert!(byte == None);\n-        })\n+        let byte = it.next();\n+        assert!(byte.is_none());\n     }\n \n     #[test]\n     fn read_bytes() {\n         let mut reader = MemReader::new(~[10, 11, 12, 13]);\n-        let bytes = reader.read_bytes(4);\n+        let bytes = reader.read_bytes(4).unwrap();\n         assert!(bytes == ~[10, 11, 12, 13]);\n     }\n \n@@ -292,24 +284,21 @@ mod test {\n         let mut reader = PartialReader {\n             count: 0,\n         };\n-        let bytes = reader.read_bytes(4);\n+        let bytes = reader.read_bytes(4).unwrap();\n         assert!(bytes == ~[10, 11, 12, 13]);\n     }\n \n     #[test]\n     fn read_bytes_eof() {\n         let mut reader = MemReader::new(~[10, 11]);\n-        io_error::cond.trap(|_| {\n-        }).inside(|| {\n-            assert!(reader.read_bytes(4) == ~[10, 11]);\n-        })\n+        assert!(reader.read_bytes(4).is_err());\n     }\n \n     #[test]\n     fn push_bytes() {\n         let mut reader = MemReader::new(~[10, 11, 12, 13]);\n         let mut buf = ~[8, 9];\n-        reader.push_bytes(&mut buf, 4);\n+        reader.push_bytes(&mut buf, 4).unwrap();\n         assert!(buf == ~[8, 9, 10, 11, 12, 13]);\n     }\n \n@@ -319,19 +308,16 @@ mod test {\n             count: 0,\n         };\n         let mut buf = ~[8, 9];\n-        reader.push_bytes(&mut buf, 4);\n+        reader.push_bytes(&mut buf, 4).unwrap();\n         assert!(buf == ~[8, 9, 10, 11, 12, 13]);\n     }\n \n     #[test]\n     fn push_bytes_eof() {\n         let mut reader = MemReader::new(~[10, 11]);\n         let mut buf = ~[8, 9];\n-        io_error::cond.trap(|_| {\n-        }).inside(|| {\n-            reader.push_bytes(&mut buf, 4);\n-            assert!(buf == ~[8, 9, 10, 11]);\n-        })\n+        assert!(reader.push_bytes(&mut buf, 4).is_err());\n+        assert!(buf == ~[8, 9, 10, 11]);\n     }\n \n     #[test]\n@@ -340,38 +326,16 @@ mod test {\n             count: 0,\n         };\n         let mut buf = ~[8, 9];\n-        io_error::cond.trap(|_| { } ).inside(|| {\n-            reader.push_bytes(&mut buf, 4);\n-        });\n+        assert!(reader.push_bytes(&mut buf, 4).is_err());\n         assert!(buf == ~[8, 9, 10]);\n     }\n \n-    #[test]\n-    #[should_fail]\n-    #[ignore] // borrow issues with RefCell\n-    fn push_bytes_fail_reset_len() {\n-        // push_bytes unsafely sets the vector length. This is testing that\n-        // upon failure the length is reset correctly.\n-        let _reader = ErroringLaterReader {\n-            count: 0,\n-        };\n-        // FIXME (#7049): Figure out some other way to do this.\n-        //let buf = RefCell::new(~[8, 9]);\n-        (|| {\n-            //reader.push_bytes(buf.borrow_mut().get(), 4);\n-        }).finally(|| {\n-            // NB: Using rtassert here to trigger abort on failure since this is a should_fail test\n-            // FIXME: #7049 This fails because buf is still borrowed\n-            //rtassert!(buf.borrow().get() == ~[8, 9, 10]);\n-        })\n-    }\n-\n     #[test]\n     fn read_to_end() {\n         let mut reader = ThreeChunkReader {\n             count: 0,\n         };\n-        let buf = reader.read_to_end();\n+        let buf = reader.read_to_end().unwrap();\n         assert!(buf == ~[10, 11, 12, 13]);\n     }\n \n@@ -381,7 +345,7 @@ mod test {\n         let mut reader = ThreeChunkReader {\n             count: 0,\n         };\n-        let buf = reader.read_to_end();\n+        let buf = reader.read_to_end().unwrap();\n         assert!(buf == ~[10, 11]);\n     }\n \n@@ -391,12 +355,12 @@ mod test {\n \n         let mut writer = MemWriter::new();\n         for i in uints.iter() {\n-            writer.write_le_u64(*i);\n+            writer.write_le_u64(*i).unwrap();\n         }\n \n         let mut reader = MemReader::new(writer.unwrap());\n         for i in uints.iter() {\n-            assert!(reader.read_le_u64() == *i);\n+            assert!(reader.read_le_u64().unwrap() == *i);\n         }\n     }\n \n@@ -407,12 +371,12 @@ mod test {\n \n         let mut writer = MemWriter::new();\n         for i in uints.iter() {\n-            writer.write_be_u64(*i);\n+            writer.write_be_u64(*i).unwrap();\n         }\n \n         let mut reader = MemReader::new(writer.unwrap());\n         for i in uints.iter() {\n-            assert!(reader.read_be_u64() == *i);\n+            assert!(reader.read_be_u64().unwrap() == *i);\n         }\n     }\n \n@@ -422,14 +386,14 @@ mod test {\n \n         let mut writer = MemWriter::new();\n         for i in ints.iter() {\n-            writer.write_be_i32(*i);\n+            writer.write_be_i32(*i).unwrap();\n         }\n \n         let mut reader = MemReader::new(writer.unwrap());\n         for i in ints.iter() {\n             // this tests that the sign extension is working\n             // (comparing the values as i32 would not test this)\n-            assert!(reader.read_be_int_n(4) == *i as i64);\n+            assert!(reader.read_be_int_n(4).unwrap() == *i as i64);\n         }\n     }\n \n@@ -439,10 +403,10 @@ mod test {\n         let buf = ~[0x41, 0x02, 0x00, 0x00];\n \n         let mut writer = MemWriter::new();\n-        writer.write(buf);\n+        writer.write(buf).unwrap();\n \n         let mut reader = MemReader::new(writer.unwrap());\n-        let f = reader.read_be_f32();\n+        let f = reader.read_be_f32().unwrap();\n         assert!(f == 8.1250);\n     }\n \n@@ -451,12 +415,12 @@ mod test {\n         let f:f32 = 8.1250;\n \n         let mut writer = MemWriter::new();\n-        writer.write_be_f32(f);\n-        writer.write_le_f32(f);\n+        writer.write_be_f32(f).unwrap();\n+        writer.write_le_f32(f).unwrap();\n \n         let mut reader = MemReader::new(writer.unwrap());\n-        assert!(reader.read_be_f32() == 8.1250);\n-        assert!(reader.read_le_f32() == 8.1250);\n+        assert!(reader.read_be_f32().unwrap() == 8.1250);\n+        assert!(reader.read_le_f32().unwrap() == 8.1250);\n     }\n \n     #[test]"}, {"sha": "1b669539288dabdf6210a4df90c4385836ada978", "filename": "src/libstd/io/fs.rs", "status": "modified", "additions": 128, "deletions": 138, "changes": 266, "blob_url": "https://github.com/rust-lang/rust/blob/209642c65177d6cf42dd4eea693040aa91cde9ee/src%2Flibstd%2Fio%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/209642c65177d6cf42dd4eea693040aa91cde9ee/src%2Flibstd%2Fio%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ffs.rs?ref=209642c65177d6cf42dd4eea693040aa91cde9ee", "patch": "@@ -681,8 +681,7 @@ impl path::Path {\n #[allow(unused_imports)]\n mod test {\n     use prelude::*;\n-    use io::{SeekSet, SeekCur, SeekEnd, io_error, Read, Open,\n-             ReadWrite};\n+    use io::{SeekSet, SeekCur, SeekEnd, Read, Open, ReadWrite};\n     use io;\n     use str;\n     use io::fs::{File, rmdir, mkdir, readdir, rmdir_recursive,\n@@ -712,15 +711,15 @@ mod test {\n             // Gee, seeing how we're testing the fs module I sure hope that we\n             // at least implement this correctly!\n             let TempDir(ref p) = *self;\n-            io::fs::rmdir_recursive(p);\n+            io::fs::rmdir_recursive(p).unwrap();\n         }\n     }\n \n     pub fn tmpdir() -> TempDir {\n         use os;\n         use rand;\n         let ret = os::tmpdir().join(format!(\"rust-{}\", rand::random::<u32>()));\n-        io::fs::mkdir(&ret, io::UserRWX);\n+        io::fs::mkdir(&ret, io::UserRWX).unwrap();\n         TempDir(ret)\n     }\n \n@@ -730,7 +729,7 @@ mod test {\n         let filename = &tmpdir.join(\"file_rt_io_file_test.txt\");\n         {\n             let mut write_stream = File::open_mode(filename, Open, ReadWrite);\n-            write_stream.write(message.as_bytes());\n+            write_stream.write(message.as_bytes()).unwrap();\n         }\n         {\n             let mut read_stream = File::open_mode(filename, Open, Read);\n@@ -741,30 +740,20 @@ mod test {\n             };\n             assert_eq!(read_str, message.to_owned());\n         }\n-        unlink(filename);\n+        unlink(filename).unwrap();\n     })\n \n     iotest!(fn invalid_path_raises() {\n         let tmpdir = tmpdir();\n         let filename = &tmpdir.join(\"file_that_does_not_exist.txt\");\n-        let mut called = false;\n-        io_error::cond.trap(|_| {\n-            called = true;\n-        }).inside(|| {\n-            let result = File::open_mode(filename, Open, Read);\n-            assert!(result.is_none());\n-        });\n-        assert!(called);\n+        let result = File::open_mode(filename, Open, Read);\n+        assert!(result.is_err());\n     })\n \n     iotest!(fn file_test_iounlinking_invalid_path_should_raise_condition() {\n         let tmpdir = tmpdir();\n         let filename = &tmpdir.join(\"file_another_file_that_does_not_exist.txt\");\n-        let mut called = false;\n-        io_error::cond.trap(|_| {\n-            called = true;\n-        }).inside(|| unlink(filename));\n-        assert!(called);\n+        assert!(unlink(filename).is_err());\n     })\n \n     iotest!(fn file_test_io_non_positional_read() {\n@@ -774,20 +763,20 @@ mod test {\n         let filename = &tmpdir.join(\"file_rt_io_file_test_positional.txt\");\n         {\n             let mut rw_stream = File::open_mode(filename, Open, ReadWrite);\n-            rw_stream.write(message.as_bytes());\n+            rw_stream.write(message.as_bytes()).unwrap();\n         }\n         {\n             let mut read_stream = File::open_mode(filename, Open, Read);\n             {\n                 let read_buf = read_mem.mut_slice(0, 4);\n-                read_stream.read(read_buf);\n+                read_stream.read(read_buf).unwrap();\n             }\n             {\n                 let read_buf = read_mem.mut_slice(4, 8);\n-                read_stream.read(read_buf);\n+                read_stream.read(read_buf).unwrap();\n             }\n         }\n-        unlink(filename);\n+        unlink(filename).unwrap();\n         let read_str = str::from_utf8(read_mem).unwrap();\n         assert_eq!(read_str, message);\n     })\n@@ -802,16 +791,16 @@ mod test {\n         let filename = &tmpdir.join(\"file_rt_io_file_test_seeking.txt\");\n         {\n             let mut rw_stream = File::open_mode(filename, Open, ReadWrite);\n-            rw_stream.write(message.as_bytes());\n+            rw_stream.write(message.as_bytes()).unwrap();\n         }\n         {\n             let mut read_stream = File::open_mode(filename, Open, Read);\n-            read_stream.seek(set_cursor as i64, SeekSet);\n-            tell_pos_pre_read = read_stream.tell();\n-            read_stream.read(read_mem);\n-            tell_pos_post_read = read_stream.tell();\n+            read_stream.seek(set_cursor as i64, SeekSet).unwrap();\n+            tell_pos_pre_read = read_stream.tell().unwrap();\n+            read_stream.read(read_mem).unwrap();\n+            tell_pos_post_read = read_stream.tell().unwrap();\n         }\n-        unlink(filename);\n+        unlink(filename).unwrap();\n         let read_str = str::from_utf8(read_mem).unwrap();\n         assert_eq!(read_str, message.slice(4, 8));\n         assert_eq!(tell_pos_pre_read, set_cursor);\n@@ -828,15 +817,15 @@ mod test {\n         let filename = &tmpdir.join(\"file_rt_io_file_test_seek_and_write.txt\");\n         {\n             let mut rw_stream = File::open_mode(filename, Open, ReadWrite);\n-            rw_stream.write(initial_msg.as_bytes());\n-            rw_stream.seek(seek_idx as i64, SeekSet);\n-            rw_stream.write(overwrite_msg.as_bytes());\n+            rw_stream.write(initial_msg.as_bytes()).unwrap();\n+            rw_stream.seek(seek_idx as i64, SeekSet).unwrap();\n+            rw_stream.write(overwrite_msg.as_bytes()).unwrap();\n         }\n         {\n             let mut read_stream = File::open_mode(filename, Open, Read);\n-            read_stream.read(read_mem);\n+            read_stream.read(read_mem).unwrap();\n         }\n-        unlink(filename);\n+        unlink(filename).unwrap();\n         let read_str = str::from_utf8(read_mem).unwrap();\n         assert!(read_str == final_msg.to_owned());\n     })\n@@ -852,24 +841,24 @@ mod test {\n         let filename = &tmpdir.join(\"file_rt_io_file_test_seek_shakedown.txt\");\n         {\n             let mut rw_stream = File::open_mode(filename, Open, ReadWrite);\n-            rw_stream.write(initial_msg.as_bytes());\n+            rw_stream.write(initial_msg.as_bytes()).unwrap();\n         }\n         {\n             let mut read_stream = File::open_mode(filename, Open, Read);\n \n-            read_stream.seek(-4, SeekEnd);\n-            read_stream.read(read_mem);\n+            read_stream.seek(-4, SeekEnd).unwrap();\n+            read_stream.read(read_mem).unwrap();\n             assert_eq!(str::from_utf8(read_mem).unwrap(), chunk_three);\n \n-            read_stream.seek(-9, SeekCur);\n-            read_stream.read(read_mem);\n+            read_stream.seek(-9, SeekCur).unwrap();\n+            read_stream.read(read_mem).unwrap();\n             assert_eq!(str::from_utf8(read_mem).unwrap(), chunk_two);\n \n-            read_stream.seek(0, SeekSet);\n-            read_stream.read(read_mem);\n+            read_stream.seek(0, SeekSet).unwrap();\n+            read_stream.read(read_mem).unwrap();\n             assert_eq!(str::from_utf8(read_mem).unwrap(), chunk_one);\n         }\n-        unlink(filename);\n+        unlink(filename).unwrap();\n     })\n \n     iotest!(fn file_test_stat_is_correct_on_is_file() {\n@@ -878,83 +867,83 @@ mod test {\n         {\n             let mut fs = File::open_mode(filename, Open, ReadWrite);\n             let msg = \"hw\";\n-            fs.write(msg.as_bytes());\n+            fs.write(msg.as_bytes()).unwrap();\n         }\n-        let stat_res = stat(filename);\n+        let stat_res = stat(filename).unwrap();\n         assert_eq!(stat_res.kind, io::TypeFile);\n-        unlink(filename);\n+        unlink(filename).unwrap();\n     })\n \n     iotest!(fn file_test_stat_is_correct_on_is_dir() {\n         let tmpdir = tmpdir();\n         let filename = &tmpdir.join(\"file_stat_correct_on_is_dir\");\n-        mkdir(filename, io::UserRWX);\n-        let stat_res = filename.stat();\n+        mkdir(filename, io::UserRWX).unwrap();\n+        let stat_res = filename.stat().unwrap();\n         assert!(stat_res.kind == io::TypeDirectory);\n-        rmdir(filename);\n+        rmdir(filename).unwrap();\n     })\n \n     iotest!(fn file_test_fileinfo_false_when_checking_is_file_on_a_directory() {\n         let tmpdir = tmpdir();\n         let dir = &tmpdir.join(\"fileinfo_false_on_dir\");\n-        mkdir(dir, io::UserRWX);\n+        mkdir(dir, io::UserRWX).unwrap();\n         assert!(dir.is_file() == false);\n-        rmdir(dir);\n+        rmdir(dir).unwrap();\n     })\n \n     iotest!(fn file_test_fileinfo_check_exists_before_and_after_file_creation() {\n         let tmpdir = tmpdir();\n         let file = &tmpdir.join(\"fileinfo_check_exists_b_and_a.txt\");\n-        File::create(file).write(bytes!(\"foo\"));\n+        File::create(file).write(bytes!(\"foo\")).unwrap();\n         assert!(file.exists());\n-        unlink(file);\n+        unlink(file).unwrap();\n         assert!(!file.exists());\n     })\n \n     iotest!(fn file_test_directoryinfo_check_exists_before_and_after_mkdir() {\n         let tmpdir = tmpdir();\n         let dir = &tmpdir.join(\"before_and_after_dir\");\n         assert!(!dir.exists());\n-        mkdir(dir, io::UserRWX);\n+        mkdir(dir, io::UserRWX).unwrap();\n         assert!(dir.exists());\n         assert!(dir.is_dir());\n-        rmdir(dir);\n+        rmdir(dir).unwrap();\n         assert!(!dir.exists());\n     })\n \n     iotest!(fn file_test_directoryinfo_readdir() {\n         use std::str;\n         let tmpdir = tmpdir();\n         let dir = &tmpdir.join(\"di_readdir\");\n-        mkdir(dir, io::UserRWX);\n+        mkdir(dir, io::UserRWX).unwrap();\n         let prefix = \"foo\";\n         for n in range(0,3) {\n             let f = dir.join(format!(\"{}.txt\", n));\n-            let mut w = File::create(&f);\n+            let mut w = File::create(&f).unwrap();\n             let msg_str = (prefix + n.to_str().to_owned()).to_owned();\n             let msg = msg_str.as_bytes();\n-            w.write(msg);\n+            w.write(msg).unwrap();\n         }\n-        let files = readdir(dir);\n+        let files = readdir(dir).unwrap();\n         let mut mem = [0u8, .. 4];\n         for f in files.iter() {\n             {\n                 let n = f.filestem_str();\n-                File::open(f).read(mem);\n+                File::open(f).read(mem).unwrap();\n                 let read_str = str::from_utf8(mem).unwrap();\n                 let expected = match n {\n                     None|Some(\"\") => fail!(\"really shouldn't happen..\"),\n                     Some(n) => prefix+n\n                 };\n                 assert_eq!(expected.as_slice(), read_str);\n             }\n-            unlink(f);\n+            unlink(f).unwrap();\n         }\n-        rmdir(dir);\n+        rmdir(dir).unwrap();\n     })\n \n     iotest!(fn recursive_mkdir_slash() {\n-        mkdir_recursive(&Path::new(\"/\"), io::UserRWX);\n+        mkdir_recursive(&Path::new(\"/\"), io::UserRWX).unwrap();\n     })\n \n     iotest!(fn unicode_path_is_dir() {\n@@ -965,12 +954,12 @@ mod test {\n \n         let mut dirpath = tmpdir.path().clone();\n         dirpath.push(format!(\"test-\uac00\u4e00\u30fc\u4f60\u597d\"));\n-        mkdir(&dirpath, io::UserRWX);\n+        mkdir(&dirpath, io::UserRWX).unwrap();\n         assert!(dirpath.is_dir());\n \n         let mut filepath = dirpath;\n         filepath.push(\"unicode-file-\\uac00\\u4e00\\u30fc\\u4f60\\u597d.rs\");\n-        File::create(&filepath); // ignore return; touch only\n+        File::create(&filepath).unwrap(); // ignore return; touch only\n         assert!(!filepath.is_dir());\n         assert!(filepath.exists());\n     })\n@@ -982,15 +971,15 @@ mod test {\n         let tmpdir = tmpdir();\n         let unicode = tmpdir.path();\n         let unicode = unicode.join(format!(\"test-\uac01\u4e01\u30fc\u518d\u89c1\"));\n-        mkdir(&unicode, io::UserRWX);\n+        mkdir(&unicode, io::UserRWX).unwrap();\n         assert!(unicode.exists());\n         assert!(!Path::new(\"test/unicode-bogus-path-\uac01\u4e01\u30fc\u518d\u89c1\").exists());\n     })\n \n     iotest!(fn copy_file_does_not_exist() {\n         let from = Path::new(\"test/nonexistent-bogus-path\");\n         let to = Path::new(\"test/other-bogus-path\");\n-        match io::result(|| copy(&from, &to)) {\n+        match copy(&from, &to) {\n             Ok(..) => fail!(),\n             Err(..) => {\n                 assert!(!from.exists());\n@@ -1004,20 +993,20 @@ mod test {\n         let input = tmpdir.join(\"in.txt\");\n         let out = tmpdir.join(\"out.txt\");\n \n-        File::create(&input).write(bytes!(\"hello\"));\n-        copy(&input, &out);\n-        let contents = File::open(&out).read_to_end();\n+        File::create(&input).write(bytes!(\"hello\")).unwrap();\n+        copy(&input, &out).unwrap();\n+        let contents = File::open(&out).read_to_end().unwrap();\n         assert_eq!(contents.as_slice(), bytes!(\"hello\"));\n \n-        assert_eq!(input.stat().perm, out.stat().perm);\n+        assert_eq!(input.stat().unwrap().perm, out.stat().unwrap().perm);\n     })\n \n     iotest!(fn copy_file_dst_dir() {\n         let tmpdir = tmpdir();\n         let out = tmpdir.join(\"out\");\n \n-        File::create(&out);\n-        match io::result(|| copy(&out, tmpdir.path())) {\n+        File::create(&out).unwrap();\n+        match copy(&out, tmpdir.path()) {\n             Ok(..) => fail!(), Err(..) => {}\n         }\n     })\n@@ -1027,19 +1016,19 @@ mod test {\n         let input = tmpdir.join(\"in\");\n         let output = tmpdir.join(\"out\");\n \n-        File::create(&input).write(\"foo\".as_bytes());\n-        File::create(&output).write(\"bar\".as_bytes());\n-        copy(&input, &output);\n+        File::create(&input).write(\"foo\".as_bytes()).unwrap();\n+        File::create(&output).write(\"bar\".as_bytes()).unwrap();\n+        copy(&input, &output).unwrap();\n \n-        assert_eq!(File::open(&output).read_to_end(),\n+        assert_eq!(File::open(&output).read_to_end().unwrap(),\n                    (bytes!(\"foo\")).to_owned());\n     })\n \n     iotest!(fn copy_file_src_dir() {\n         let tmpdir = tmpdir();\n         let out = tmpdir.join(\"out\");\n \n-        match io::result(|| copy(tmpdir.path(), &out)) {\n+        match copy(tmpdir.path(), &out) {\n             Ok(..) => fail!(), Err(..) => {}\n         }\n         assert!(!out.exists());\n@@ -1050,13 +1039,13 @@ mod test {\n         let input = tmpdir.join(\"in.txt\");\n         let out = tmpdir.join(\"out.txt\");\n \n-        File::create(&input);\n-        chmod(&input, io::UserRead);\n-        copy(&input, &out);\n-        assert!(out.stat().perm & io::UserWrite == 0);\n+        File::create(&input).unwrap();\n+        chmod(&input, io::UserRead).unwrap();\n+        copy(&input, &out).unwrap();\n+        assert!(out.stat().unwrap().perm & io::UserWrite == 0);\n \n-        chmod(&input, io::UserFile);\n-        chmod(&out, io::UserFile);\n+        chmod(&input, io::UserFile).unwrap();\n+        chmod(&out, io::UserFile).unwrap();\n     })\n \n     #[cfg(not(windows))] // FIXME(#10264) operation not permitted?\n@@ -1065,26 +1054,27 @@ mod test {\n         let input = tmpdir.join(\"in.txt\");\n         let out = tmpdir.join(\"out.txt\");\n \n-        File::create(&input).write(\"foobar\".as_bytes());\n-        symlink(&input, &out);\n+        File::create(&input).write(\"foobar\".as_bytes()).unwrap();\n+        symlink(&input, &out).unwrap();\n         if cfg!(not(windows)) {\n-            assert_eq!(lstat(&out).kind, io::TypeSymlink);\n+            assert_eq!(lstat(&out).unwrap().kind, io::TypeSymlink);\n         }\n-        assert_eq!(stat(&out).size, stat(&input).size);\n-        assert_eq!(File::open(&out).read_to_end(), (bytes!(\"foobar\")).to_owned());\n+        assert_eq!(stat(&out).unwrap().size, stat(&input).unwrap().size);\n+        assert_eq!(File::open(&out).read_to_end().unwrap(),\n+                   (bytes!(\"foobar\")).to_owned());\n     })\n \n     #[cfg(not(windows))] // apparently windows doesn't like symlinks\n     iotest!(fn symlink_noexist() {\n         let tmpdir = tmpdir();\n         // symlinks can point to things that don't exist\n-        symlink(&tmpdir.join(\"foo\"), &tmpdir.join(\"bar\"));\n+        symlink(&tmpdir.join(\"foo\"), &tmpdir.join(\"bar\")).unwrap();\n         assert!(readlink(&tmpdir.join(\"bar\")).unwrap() == tmpdir.join(\"foo\"));\n     })\n \n     iotest!(fn readlink_not_symlink() {\n         let tmpdir = tmpdir();\n-        match io::result(|| readlink(tmpdir.path())) {\n+        match readlink(tmpdir.path()) {\n             Ok(..) => fail!(\"wanted a failure\"),\n             Err(..) => {}\n         }\n@@ -1095,22 +1085,23 @@ mod test {\n         let input = tmpdir.join(\"in.txt\");\n         let out = tmpdir.join(\"out.txt\");\n \n-        File::create(&input).write(\"foobar\".as_bytes());\n-        link(&input, &out);\n+        File::create(&input).write(\"foobar\".as_bytes()).unwrap();\n+        link(&input, &out).unwrap();\n         if cfg!(not(windows)) {\n-            assert_eq!(lstat(&out).kind, io::TypeFile);\n-            assert_eq!(stat(&out).unstable.nlink, 2);\n+            assert_eq!(lstat(&out).unwrap().kind, io::TypeFile);\n+            assert_eq!(stat(&out).unwrap().unstable.nlink, 2);\n         }\n-        assert_eq!(stat(&out).size, stat(&input).size);\n-        assert_eq!(File::open(&out).read_to_end(), (bytes!(\"foobar\")).to_owned());\n+        assert_eq!(stat(&out).unwrap().size, stat(&input).unwrap().size);\n+        assert_eq!(File::open(&out).read_to_end().unwrap(),\n+                   (bytes!(\"foobar\")).to_owned());\n \n         // can't link to yourself\n-        match io::result(|| link(&input, &input)) {\n+        match link(&input, &input) {\n             Ok(..) => fail!(\"wanted a failure\"),\n             Err(..) => {}\n         }\n         // can't link to something that doesn't exist\n-        match io::result(|| link(&tmpdir.join(\"foo\"), &tmpdir.join(\"bar\"))) {\n+        match link(&tmpdir.join(\"foo\"), &tmpdir.join(\"bar\")) {\n             Ok(..) => fail!(\"wanted a failure\"),\n             Err(..) => {}\n         }\n@@ -1120,29 +1111,29 @@ mod test {\n         let tmpdir = tmpdir();\n         let file = tmpdir.join(\"in.txt\");\n \n-        File::create(&file);\n-        assert!(stat(&file).perm & io::UserWrite == io::UserWrite);\n-        chmod(&file, io::UserRead);\n-        assert!(stat(&file).perm & io::UserWrite == 0);\n+        File::create(&file).unwrap();\n+        assert!(stat(&file).unwrap().perm & io::UserWrite == io::UserWrite);\n+        chmod(&file, io::UserRead).unwrap();\n+        assert!(stat(&file).unwrap().perm & io::UserWrite == 0);\n \n-        match io::result(|| chmod(&tmpdir.join(\"foo\"), io::UserRWX)) {\n+        match chmod(&tmpdir.join(\"foo\"), io::UserRWX) {\n             Ok(..) => fail!(\"wanted a failure\"),\n             Err(..) => {}\n         }\n \n-        chmod(&file, io::UserFile);\n+        chmod(&file, io::UserFile).unwrap();\n     })\n \n     iotest!(fn sync_doesnt_kill_anything() {\n         let tmpdir = tmpdir();\n         let path = tmpdir.join(\"in.txt\");\n \n         let mut file = File::open_mode(&path, io::Open, io::ReadWrite).unwrap();\n-        file.fsync();\n-        file.datasync();\n-        file.write(bytes!(\"foo\"));\n-        file.fsync();\n-        file.datasync();\n+        file.fsync().unwrap();\n+        file.datasync().unwrap();\n+        file.write(bytes!(\"foo\")).unwrap();\n+        file.fsync().unwrap();\n+        file.datasync().unwrap();\n         drop(file);\n     })\n \n@@ -1151,37 +1142,36 @@ mod test {\n         let path = tmpdir.join(\"in.txt\");\n \n         let mut file = File::open_mode(&path, io::Open, io::ReadWrite).unwrap();\n-        file.write(bytes!(\"foo\"));\n-        file.fsync();\n+        file.write(bytes!(\"foo\")).unwrap();\n+        file.fsync().unwrap();\n \n         // Do some simple things with truncation\n-        assert_eq!(stat(&path).size, 3);\n-        file.truncate(10);\n-        assert_eq!(stat(&path).size, 10);\n-        file.write(bytes!(\"bar\"));\n-        file.fsync();\n-        assert_eq!(stat(&path).size, 10);\n-        assert_eq!(File::open(&path).read_to_end(),\n+        assert_eq!(stat(&path).unwrap().size, 3);\n+        file.truncate(10).unwrap();\n+        assert_eq!(stat(&path).unwrap().size, 10);\n+        file.write(bytes!(\"bar\")).unwrap();\n+        file.fsync().unwrap();\n+        assert_eq!(stat(&path).unwrap().size, 10);\n+        assert_eq!(File::open(&path).read_to_end().unwrap(),\n                    (bytes!(\"foobar\", 0, 0, 0, 0)).to_owned());\n \n         // Truncate to a smaller length, don't seek, and then write something.\n         // Ensure that the intermediate zeroes are all filled in (we're seeked\n         // past the end of the file).\n-        file.truncate(2);\n-        assert_eq!(stat(&path).size, 2);\n-        file.write(bytes!(\"wut\"));\n-        file.fsync();\n-        assert_eq!(stat(&path).size, 9);\n-        assert_eq!(File::open(&path).read_to_end(),\n+        file.truncate(2).unwrap();\n+        assert_eq!(stat(&path).unwrap().size, 2);\n+        file.write(bytes!(\"wut\")).unwrap();\n+        file.fsync().unwrap();\n+        assert_eq!(stat(&path).unwrap().size, 9);\n+        assert_eq!(File::open(&path).read_to_end().unwrap(),\n                    (bytes!(\"fo\", 0, 0, 0, 0, \"wut\")).to_owned());\n         drop(file);\n     })\n \n     iotest!(fn open_flavors() {\n         let tmpdir = tmpdir();\n \n-        match io::result(|| File::open_mode(&tmpdir.join(\"a\"), io::Open,\n-                                            io::Read)) {\n+        match File::open_mode(&tmpdir.join(\"a\"), io::Open, io::Read) {\n             Ok(..) => fail!(), Err(..) => {}\n         }\n         File::open_mode(&tmpdir.join(\"b\"), io::Open, io::Write).unwrap();\n@@ -1191,46 +1181,46 @@ mod test {\n         File::open_mode(&tmpdir.join(\"f\"), io::Truncate, io::Write).unwrap();\n         File::open_mode(&tmpdir.join(\"g\"), io::Truncate, io::ReadWrite).unwrap();\n \n-        File::create(&tmpdir.join(\"h\")).write(\"foo\".as_bytes());\n+        File::create(&tmpdir.join(\"h\")).write(\"foo\".as_bytes()).unwrap();\n         File::open_mode(&tmpdir.join(\"h\"), io::Open, io::Read).unwrap();\n         {\n             let mut f = File::open_mode(&tmpdir.join(\"h\"), io::Open,\n                                         io::Read).unwrap();\n-            match io::result(|| f.write(\"wut\".as_bytes())) {\n+            match f.write(\"wut\".as_bytes()) {\n                 Ok(..) => fail!(), Err(..) => {}\n             }\n         }\n-        assert_eq!(stat(&tmpdir.join(\"h\")).size, 3);\n+        assert_eq!(stat(&tmpdir.join(\"h\")).unwrap().size, 3);\n         {\n             let mut f = File::open_mode(&tmpdir.join(\"h\"), io::Append,\n                                         io::Write).unwrap();\n-            f.write(\"bar\".as_bytes());\n+            f.write(\"bar\".as_bytes()).unwrap();\n         }\n-        assert_eq!(stat(&tmpdir.join(\"h\")).size, 6);\n+        assert_eq!(stat(&tmpdir.join(\"h\")).unwrap().size, 6);\n         {\n             let mut f = File::open_mode(&tmpdir.join(\"h\"), io::Truncate,\n                                         io::Write).unwrap();\n-            f.write(\"bar\".as_bytes());\n+            f.write(\"bar\".as_bytes()).unwrap();\n         }\n-        assert_eq!(stat(&tmpdir.join(\"h\")).size, 3);\n+        assert_eq!(stat(&tmpdir.join(\"h\")).unwrap().size, 3);\n     })\n \n     #[test]\n     fn utime() {\n         let tmpdir = tmpdir();\n         let path = tmpdir.join(\"a\");\n-        File::create(&path);\n+        File::create(&path).unwrap();\n \n-        change_file_times(&path, 1000, 2000);\n-        assert_eq!(path.stat().accessed, 1000);\n-        assert_eq!(path.stat().modified, 2000);\n+        change_file_times(&path, 1000, 2000).unwrap();\n+        assert_eq!(path.stat().unwrap().accessed, 1000);\n+        assert_eq!(path.stat().unwrap().modified, 2000);\n     }\n \n     #[test]\n     fn utime_noexist() {\n         let tmpdir = tmpdir();\n \n-        match io::result(|| change_file_times(&tmpdir.join(\"a\"), 100, 200)) {\n+        match change_file_times(&tmpdir.join(\"a\"), 100, 200) {\n             Ok(..) => fail!(),\n             Err(..) => {}\n         }"}, {"sha": "3a6aa1939a41119add053e7d347c61367ad6a7db", "filename": "src/libstd/io/mem.rs", "status": "modified", "additions": 74, "deletions": 77, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/209642c65177d6cf42dd4eea693040aa91cde9ee/src%2Flibstd%2Fio%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/209642c65177d6cf42dd4eea693040aa91cde9ee/src%2Flibstd%2Fio%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmem.rs?ref=209642c65177d6cf42dd4eea693040aa91cde9ee", "patch": "@@ -314,33 +314,34 @@ mod test {\n     use prelude::*;\n     use super::*;\n     use io::*;\n+    use io;\n \n     #[test]\n     fn test_mem_writer() {\n         let mut writer = MemWriter::new();\n-        assert_eq!(writer.tell(), 0);\n-        writer.write([0]);\n-        assert_eq!(writer.tell(), 1);\n-        writer.write([1, 2, 3]);\n-        writer.write([4, 5, 6, 7]);\n-        assert_eq!(writer.tell(), 8);\n+        assert_eq!(writer.tell(), Ok(0));\n+        writer.write([0]).unwrap();\n+        assert_eq!(writer.tell(), Ok(1));\n+        writer.write([1, 2, 3]).unwrap();\n+        writer.write([4, 5, 6, 7]).unwrap();\n+        assert_eq!(writer.tell(), Ok(8));\n         assert_eq!(writer.get_ref(), [0, 1, 2, 3, 4, 5, 6, 7]);\n \n-        writer.seek(0, SeekSet);\n-        assert_eq!(writer.tell(), 0);\n-        writer.write([3, 4]);\n+        writer.seek(0, SeekSet).unwrap();\n+        assert_eq!(writer.tell(), Ok(0));\n+        writer.write([3, 4]).unwrap();\n         assert_eq!(writer.get_ref(), [3, 4, 2, 3, 4, 5, 6, 7]);\n \n-        writer.seek(1, SeekCur);\n-        writer.write([0, 1]);\n+        writer.seek(1, SeekCur).unwrap();\n+        writer.write([0, 1]).unwrap();\n         assert_eq!(writer.get_ref(), [3, 4, 2, 0, 1, 5, 6, 7]);\n \n-        writer.seek(-1, SeekEnd);\n-        writer.write([1, 2]);\n+        writer.seek(-1, SeekEnd).unwrap();\n+        writer.write([1, 2]).unwrap();\n         assert_eq!(writer.get_ref(), [3, 4, 2, 0, 1, 5, 6, 1, 2]);\n \n-        writer.seek(1, SeekEnd);\n-        writer.write([1]);\n+        writer.seek(1, SeekEnd).unwrap();\n+        writer.write([1]).unwrap();\n         assert_eq!(writer.get_ref(), [3, 4, 2, 0, 1, 5, 6, 1, 2, 0, 1]);\n     }\n \n@@ -349,12 +350,12 @@ mod test {\n         let mut buf = [0 as u8, ..8];\n         {\n             let mut writer = BufWriter::new(buf);\n-            assert_eq!(writer.tell(), 0);\n-            writer.write([0]);\n-            assert_eq!(writer.tell(), 1);\n-            writer.write([1, 2, 3]);\n-            writer.write([4, 5, 6, 7]);\n-            assert_eq!(writer.tell(), 8);\n+            assert_eq!(writer.tell(), Ok(0));\n+            writer.write([0]).unwrap();\n+            assert_eq!(writer.tell(), Ok(1));\n+            writer.write([1, 2, 3]).unwrap();\n+            writer.write([4, 5, 6, 7]).unwrap();\n+            assert_eq!(writer.tell(), Ok(8));\n         }\n         assert_eq!(buf, [0, 1, 2, 3, 4, 5, 6, 7]);\n     }\n@@ -364,24 +365,24 @@ mod test {\n         let mut buf = [0 as u8, ..8];\n         {\n             let mut writer = BufWriter::new(buf);\n-            assert_eq!(writer.tell(), 0);\n-            writer.write([1]);\n-            assert_eq!(writer.tell(), 1);\n+            assert_eq!(writer.tell(), Ok(0));\n+            writer.write([1]).unwrap();\n+            assert_eq!(writer.tell(), Ok(1));\n \n-            writer.seek(2, SeekSet);\n-            assert_eq!(writer.tell(), 2);\n-            writer.write([2]);\n-            assert_eq!(writer.tell(), 3);\n+            writer.seek(2, SeekSet).unwrap();\n+            assert_eq!(writer.tell(), Ok(2));\n+            writer.write([2]).unwrap();\n+            assert_eq!(writer.tell(), Ok(3));\n \n-            writer.seek(-2, SeekCur);\n-            assert_eq!(writer.tell(), 1);\n-            writer.write([3]);\n-            assert_eq!(writer.tell(), 2);\n+            writer.seek(-2, SeekCur).unwrap();\n+            assert_eq!(writer.tell(), Ok(1));\n+            writer.write([3]).unwrap();\n+            assert_eq!(writer.tell(), Ok(2));\n \n-            writer.seek(-1, SeekEnd);\n-            assert_eq!(writer.tell(), 7);\n-            writer.write([4]);\n-            assert_eq!(writer.tell(), 8);\n+            writer.seek(-1, SeekEnd).unwrap();\n+            assert_eq!(writer.tell(), Ok(7));\n+            writer.write([4]).unwrap();\n+            assert_eq!(writer.tell(), Ok(8));\n \n         }\n         assert_eq!(buf, [1, 3, 2, 0, 0, 0, 0, 4]);\n@@ -391,100 +392,96 @@ mod test {\n     fn test_buf_writer_error() {\n         let mut buf = [0 as u8, ..2];\n         let mut writer = BufWriter::new(buf);\n-        writer.write([0]);\n-\n-        let mut called = false;\n-        io_error::cond.trap(|err| {\n-            assert_eq!(err.kind, io::OtherIoError);\n-            called = true;\n-        }).inside(|| {\n-            writer.write([0, 0]);\n-        });\n-        assert!(called);\n+        writer.write([0]).unwrap();\n+\n+        match writer.write([0, 0]) {\n+            Ok(..) => fail!(),\n+            Err(e) => assert_eq!(e.kind, io::OtherIoError),\n+        }\n     }\n \n     #[test]\n     fn test_mem_reader() {\n         let mut reader = MemReader::new(~[0, 1, 2, 3, 4, 5, 6, 7]);\n         let mut buf = [];\n-        assert_eq!(reader.read(buf), Some(0));\n-        assert_eq!(reader.tell(), 0);\n+        assert_eq!(reader.read(buf), Ok(0));\n+        assert_eq!(reader.tell(), Ok(0));\n         let mut buf = [0];\n-        assert_eq!(reader.read(buf), Some(1));\n-        assert_eq!(reader.tell(), 1);\n+        assert_eq!(reader.read(buf), Ok(1));\n+        assert_eq!(reader.tell(), Ok(1));\n         assert_eq!(buf, [0]);\n         let mut buf = [0, ..4];\n-        assert_eq!(reader.read(buf), Some(4));\n-        assert_eq!(reader.tell(), 5);\n+        assert_eq!(reader.read(buf), Ok(4));\n+        assert_eq!(reader.tell(), Ok(5));\n         assert_eq!(buf, [1, 2, 3, 4]);\n-        assert_eq!(reader.read(buf), Some(3));\n+        assert_eq!(reader.read(buf), Ok(3));\n         assert_eq!(buf.slice(0, 3), [5, 6, 7]);\n-        assert_eq!(reader.read(buf), None);\n+        assert!(reader.read(buf).is_err());\n     }\n \n     #[test]\n     fn test_buf_reader() {\n         let in_buf = ~[0, 1, 2, 3, 4, 5, 6, 7];\n         let mut reader = BufReader::new(in_buf);\n         let mut buf = [];\n-        assert_eq!(reader.read(buf), Some(0));\n-        assert_eq!(reader.tell(), 0);\n+        assert_eq!(reader.read(buf), Ok(0));\n+        assert_eq!(reader.tell(), Ok(0));\n         let mut buf = [0];\n-        assert_eq!(reader.read(buf), Some(1));\n-        assert_eq!(reader.tell(), 1);\n+        assert_eq!(reader.read(buf), Ok(1));\n+        assert_eq!(reader.tell(), Ok(1));\n         assert_eq!(buf, [0]);\n         let mut buf = [0, ..4];\n-        assert_eq!(reader.read(buf), Some(4));\n-        assert_eq!(reader.tell(), 5);\n+        assert_eq!(reader.read(buf), Ok(4));\n+        assert_eq!(reader.tell(), Ok(5));\n         assert_eq!(buf, [1, 2, 3, 4]);\n-        assert_eq!(reader.read(buf), Some(3));\n+        assert_eq!(reader.read(buf), Ok(3));\n         assert_eq!(buf.slice(0, 3), [5, 6, 7]);\n-        assert_eq!(reader.read(buf), None);\n+        assert!(reader.read(buf).is_err());\n     }\n \n     #[test]\n     fn test_read_char() {\n         let b = bytes!(\"Vi\u1ec7t\");\n         let mut r = BufReader::new(b);\n-        assert_eq!(r.read_char(), Some('V'));\n-        assert_eq!(r.read_char(), Some('i'));\n-        assert_eq!(r.read_char(), Some('\u1ec7'));\n-        assert_eq!(r.read_char(), Some('t'));\n-        assert_eq!(r.read_char(), None);\n+        assert_eq!(r.read_char(), Ok('V'));\n+        assert_eq!(r.read_char(), Ok('i'));\n+        assert_eq!(r.read_char(), Ok('\u1ec7'));\n+        assert_eq!(r.read_char(), Ok('t'));\n+        assert!(r.read_char().is_err());\n     }\n \n     #[test]\n     fn test_read_bad_char() {\n         let b = bytes!(0x80);\n         let mut r = BufReader::new(b);\n-        assert_eq!(r.read_char(), None);\n+        assert!(r.read_char().is_err());\n     }\n \n     #[test]\n     fn test_write_strings() {\n         let mut writer = MemWriter::new();\n-        writer.write_str(\"testing\");\n-        writer.write_line(\"testing\");\n-        writer.write_str(\"testing\");\n+        writer.write_str(\"testing\").unwrap();\n+        writer.write_line(\"testing\").unwrap();\n+        writer.write_str(\"testing\").unwrap();\n         let mut r = BufReader::new(writer.get_ref());\n-        assert_eq!(r.read_to_str(), ~\"testingtesting\\ntesting\");\n+        assert_eq!(r.read_to_str().unwrap(), ~\"testingtesting\\ntesting\");\n     }\n \n     #[test]\n     fn test_write_char() {\n         let mut writer = MemWriter::new();\n-        writer.write_char('a');\n-        writer.write_char('\\n');\n-        writer.write_char('\u1ec7');\n+        writer.write_char('a').unwrap();\n+        writer.write_char('\\n').unwrap();\n+        writer.write_char('\u1ec7').unwrap();\n         let mut r = BufReader::new(writer.get_ref());\n-        assert_eq!(r.read_to_str(), ~\"a\\n\u1ec7\");\n+        assert_eq!(r.read_to_str().unwrap(), ~\"a\\n\u1ec7\");\n     }\n \n     #[test]\n     fn test_read_whole_string_bad() {\n         let buf = [0xff];\n         let mut r = BufReader::new(buf);\n-        match result(|| r.read_to_str()) {\n+        match r.read_to_str() {\n             Ok(..) => fail!(),\n             Err(..) => {}\n         }"}, {"sha": "bd7a349a2aaac650dabb4ec0b0cc7bdff11efec5", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/209642c65177d6cf42dd4eea693040aa91cde9ee/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/209642c65177d6cf42dd4eea693040aa91cde9ee/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=209642c65177d6cf42dd4eea693040aa91cde9ee", "patch": "@@ -287,6 +287,7 @@ Out of scope\n */\n \n #[allow(missing_doc)];\n+#[deny(unused_must_use)];\n \n use cast;\n use char::Char;\n@@ -1122,9 +1123,6 @@ pub trait Buffer: Reader {\n                     }\n                 }\n             }\n-            if used == 0 {\n-                break\n-            }\n             self.consume(used);\n         }\n         self.consume(used);\n@@ -1141,15 +1139,14 @@ pub trait Buffer: Reader {\n     /// This function will raise on the `io_error` condition if a read error is\n     /// encountered.\n     fn read_char(&mut self) -> IoResult<char> {\n-        let width = {\n-            let available = if_ok!(self.fill());\n-            str::utf8_char_width(available[0])\n-        };\n-        if width == 0 { return Err(standard_error(InvalidInput)) } // not uf8\n-        let mut buf = [0, ..4];\n+        let first_byte = if_ok!(self.read_byte());\n+        let width = str::utf8_char_width(first_byte);\n+        if width == 1 { return Ok(first_byte as char) }\n+        if width == 0 { return Err(standard_error(InvalidInput)) } // not utf8\n+        let mut buf = [first_byte, 0, 0, 0];\n         {\n-            let mut start = 0;\n-            loop {\n+            let mut start = 1;\n+            while start < width {\n                 match if_ok!(self.read(buf.mut_slice(start, width))) {\n                     n if n == width - start => break,\n                     n if n < width - start => { start += n; }"}, {"sha": "f72c6aecd642583a1c3d33e728f5140525f681c6", "filename": "src/libstd/io/net/addrinfo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/209642c65177d6cf42dd4eea693040aa91cde9ee/src%2Flibstd%2Fio%2Fnet%2Faddrinfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/209642c65177d6cf42dd4eea693040aa91cde9ee/src%2Flibstd%2Fio%2Fnet%2Faddrinfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Faddrinfo.rs?ref=209642c65177d6cf42dd4eea693040aa91cde9ee", "patch": "@@ -116,6 +116,6 @@ mod test {\n     iotest!(fn issue_10663() {\n         // Something should happen here, but this certainly shouldn't cause\n         // everything to die. The actual outcome we don't care too much about.\n-        get_host_addresses(\"example.com\");\n+        get_host_addresses(\"example.com\").unwrap();\n     } #[ignore])\n }"}, {"sha": "f3db964b88251a8f1cd40502771ba14c0b2f7032", "filename": "src/libstd/io/net/tcp.rs", "status": "modified", "additions": 84, "deletions": 110, "changes": 194, "blob_url": "https://github.com/rust-lang/rust/blob/209642c65177d6cf42dd4eea693040aa91cde9ee/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/209642c65177d6cf42dd4eea693040aa91cde9ee/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs?ref=209642c65177d6cf42dd4eea693040aa91cde9ee", "patch": "@@ -86,29 +86,19 @@ mod test {\n \n     // FIXME #11530 this fails on android because tests are run as root\n     iotest!(fn bind_error() {\n-        let mut called = false;\n-        io_error::cond.trap(|e| {\n-            assert!(e.kind == PermissionDenied);\n-            called = true;\n-        }).inside(|| {\n-            let addr = SocketAddr { ip: Ipv4Addr(0, 0, 0, 0), port: 1 };\n-            let listener = TcpListener::bind(addr);\n-            assert!(listener.is_none());\n-        });\n-        assert!(called);\n+        let addr = SocketAddr { ip: Ipv4Addr(0, 0, 0, 0), port: 1 };\n+        match TcpListener::bind(addr) {\n+            Ok(..) => fail!(),\n+            Err(e) => assert_eq!(e.kind, PermissionDenied),\n+        }\n     } #[ignore(cfg(windows))] #[ignore(cfg(target_os = \"android\"))])\n \n     iotest!(fn connect_error() {\n-        let mut called = false;\n-        io_error::cond.trap(|e| {\n-            assert_eq!(e.kind, ConnectionRefused);\n-            called = true;\n-        }).inside(|| {\n-            let addr = SocketAddr { ip: Ipv4Addr(0, 0, 0, 0), port: 1 };\n-            let stream = TcpStream::connect(addr);\n-            assert!(stream.is_none());\n-        });\n-        assert!(called);\n+        let addr = SocketAddr { ip: Ipv4Addr(0, 0, 0, 0), port: 1 };\n+        match TcpStream::connect(addr) {\n+            Ok(..) => fail!(),\n+            Err(e) => assert_eq!(e.kind, ConnectionRefused),\n+        }\n     })\n \n     iotest!(fn smoke_test_ip4() {\n@@ -118,14 +108,14 @@ mod test {\n         spawn(proc() {\n             port.recv();\n             let mut stream = TcpStream::connect(addr);\n-            stream.write([99]);\n+            stream.write([99]).unwrap();\n         });\n \n         let mut acceptor = TcpListener::bind(addr).listen();\n         chan.send(());\n         let mut stream = acceptor.accept();\n         let mut buf = [0];\n-        stream.read(buf);\n+        stream.read(buf).unwrap();\n         assert!(buf[0] == 99);\n     })\n \n@@ -136,14 +126,14 @@ mod test {\n         spawn(proc() {\n             port.recv();\n             let mut stream = TcpStream::connect(addr);\n-            stream.write([99]);\n+            stream.write([99]).unwrap();\n         });\n \n         let mut acceptor = TcpListener::bind(addr).listen();\n         chan.send(());\n         let mut stream = acceptor.accept();\n         let mut buf = [0];\n-        stream.read(buf);\n+        stream.read(buf).unwrap();\n         assert!(buf[0] == 99);\n     })\n \n@@ -162,7 +152,7 @@ mod test {\n         let mut stream = acceptor.accept();\n         let mut buf = [0];\n         let nread = stream.read(buf);\n-        assert!(nread.is_none());\n+        assert!(nread.is_err());\n     })\n \n     iotest!(fn read_eof_ip6() {\n@@ -180,7 +170,7 @@ mod test {\n         let mut stream = acceptor.accept();\n         let mut buf = [0];\n         let nread = stream.read(buf);\n-        assert!(nread.is_none());\n+        assert!(nread.is_err());\n     })\n \n     iotest!(fn read_eof_twice_ip4() {\n@@ -198,17 +188,14 @@ mod test {\n         let mut stream = acceptor.accept();\n         let mut buf = [0];\n         let nread = stream.read(buf);\n-        assert!(nread.is_none());\n-        io_error::cond.trap(|e| {\n-            if cfg!(windows) {\n-                assert_eq!(e.kind, NotConnected);\n-            } else {\n-                fail!();\n-            }\n-        }).inside(|| {\n-            let nread = stream.read(buf);\n-            assert!(nread.is_none());\n-        })\n+        assert!(nread.is_err());\n+\n+        match stream.read(buf) {\n+            Ok(..) => fail!(),\n+            Err(ref e) if cfg!(windows) => assert_eq!(e.kind, NotConnected),\n+            Err(ref e) if cfg!(unix) => assert_eq!(e.kind, EndOfFile),\n+            Err(..) => fail!(),\n+        }\n     })\n \n     iotest!(fn read_eof_twice_ip6() {\n@@ -226,17 +213,14 @@ mod test {\n         let mut stream = acceptor.accept();\n         let mut buf = [0];\n         let nread = stream.read(buf);\n-        assert!(nread.is_none());\n-        io_error::cond.trap(|e| {\n-            if cfg!(windows) {\n-                assert_eq!(e.kind, NotConnected);\n-            } else {\n-                fail!();\n-            }\n-        }).inside(|| {\n-            let nread = stream.read(buf);\n-            assert!(nread.is_none());\n-        })\n+        assert!(nread.is_err());\n+\n+        match stream.read(buf) {\n+            Ok(..) => fail!(),\n+            Err(ref e) if cfg!(windows) => assert_eq!(e.kind, NotConnected),\n+            Err(ref e) if cfg!(unix) => assert_eq!(e.kind, EndOfFile),\n+            Err(..) => fail!(),\n+        }\n     })\n \n     iotest!(fn write_close_ip4() {\n@@ -254,19 +238,16 @@ mod test {\n         let mut stream = acceptor.accept();\n         let buf = [0];\n         loop {\n-            let mut stop = false;\n-            io_error::cond.trap(|e| {\n-                // NB: ECONNRESET on linux, EPIPE on mac, ECONNABORTED\n-                //     on windows\n-                assert!(e.kind == ConnectionReset ||\n-                        e.kind == BrokenPipe ||\n-                        e.kind == ConnectionAborted,\n-                        \"unknown error: {:?}\", e);\n-                stop = true;\n-            }).inside(|| {\n-                stream.write(buf);\n-            });\n-            if stop { break }\n+            match stream.write(buf) {\n+                Ok(..) => {}\n+                Err(e) => {\n+                    assert!(e.kind == ConnectionReset ||\n+                            e.kind == BrokenPipe ||\n+                            e.kind == ConnectionAborted,\n+                            \"unknown error: {:?}\", e);\n+                    break;\n+                }\n+            }\n         }\n     })\n \n@@ -285,19 +266,16 @@ mod test {\n         let mut stream = acceptor.accept();\n         let buf = [0];\n         loop {\n-            let mut stop = false;\n-            io_error::cond.trap(|e| {\n-                // NB: ECONNRESET on linux, EPIPE on mac, ECONNABORTED\n-                //     on windows\n-                assert!(e.kind == ConnectionReset ||\n-                        e.kind == BrokenPipe ||\n-                        e.kind == ConnectionAborted,\n-                        \"unknown error: {:?}\", e);\n-                stop = true;\n-            }).inside(|| {\n-                stream.write(buf);\n-            });\n-            if stop { break }\n+            match stream.write(buf) {\n+                Ok(..) => {}\n+                Err(e) => {\n+                    assert!(e.kind == ConnectionReset ||\n+                            e.kind == BrokenPipe ||\n+                            e.kind == ConnectionAborted,\n+                            \"unknown error: {:?}\", e);\n+                    break;\n+                }\n+            }\n         }\n     })\n \n@@ -310,15 +288,15 @@ mod test {\n             port.recv();\n             for _ in range(0, max) {\n                 let mut stream = TcpStream::connect(addr);\n-                stream.write([99]);\n+                stream.write([99]).unwrap();\n             }\n         });\n \n         let mut acceptor = TcpListener::bind(addr).listen();\n         chan.send(());\n         for ref mut stream in acceptor.incoming().take(max) {\n             let mut buf = [0];\n-            stream.read(buf);\n+            stream.read(buf).unwrap();\n             assert_eq!(buf[0], 99);\n         }\n     })\n@@ -332,15 +310,15 @@ mod test {\n             port.recv();\n             for _ in range(0, max) {\n                 let mut stream = TcpStream::connect(addr);\n-                stream.write([99]);\n+                stream.write([99]).unwrap();\n             }\n         });\n \n         let mut acceptor = TcpListener::bind(addr).listen();\n         chan.send(());\n         for ref mut stream in acceptor.incoming().take(max) {\n             let mut buf = [0];\n-            stream.read(buf);\n+            stream.read(buf).unwrap();\n             assert_eq!(buf[0], 99);\n         }\n     })\n@@ -358,7 +336,7 @@ mod test {\n                 spawn(proc() {\n                     let mut stream = stream;\n                     let mut buf = [0];\n-                    stream.read(buf);\n+                    stream.read(buf).unwrap();\n                     assert!(buf[0] == i as u8);\n                     debug!(\"read\");\n                 });\n@@ -377,7 +355,7 @@ mod test {\n                 // Connect again before writing\n                 connect(i + 1, addr);\n                 debug!(\"writing\");\n-                stream.write([i as u8]);\n+                stream.write([i as u8]).unwrap();\n             });\n         }\n     })\n@@ -395,7 +373,7 @@ mod test {\n                 spawn(proc() {\n                     let mut stream = stream;\n                     let mut buf = [0];\n-                    stream.read(buf);\n+                    stream.read(buf).unwrap();\n                     assert!(buf[0] == i as u8);\n                     debug!(\"read\");\n                 });\n@@ -414,7 +392,7 @@ mod test {\n                 // Connect again before writing\n                 connect(i + 1, addr);\n                 debug!(\"writing\");\n-                stream.write([i as u8]);\n+                stream.write([i as u8]).unwrap();\n             });\n         }\n     })\n@@ -432,7 +410,7 @@ mod test {\n                 spawn(proc() {\n                     let mut stream = stream;\n                     let mut buf = [0];\n-                    stream.read(buf);\n+                    stream.read(buf).unwrap();\n                     assert!(buf[0] == 99);\n                     debug!(\"read\");\n                 });\n@@ -451,7 +429,7 @@ mod test {\n                 // Connect again before writing\n                 connect(i + 1, addr);\n                 debug!(\"writing\");\n-                stream.write([99]);\n+                stream.write([99]).unwrap();\n             });\n         }\n     })\n@@ -469,7 +447,7 @@ mod test {\n                 spawn(proc() {\n                     let mut stream = stream;\n                     let mut buf = [0];\n-                    stream.read(buf);\n+                    stream.read(buf).unwrap();\n                     assert!(buf[0] == 99);\n                     debug!(\"read\");\n                 });\n@@ -488,7 +466,7 @@ mod test {\n                 // Connect again before writing\n                 connect(i + 1, addr);\n                 debug!(\"writing\");\n-                stream.write([99]);\n+                stream.write([99]).unwrap();\n             });\n         }\n     })\n@@ -499,7 +477,7 @@ mod test {\n         // Make sure socket_name gives\n         // us the socket we binded to.\n         let so_name = listener.socket_name();\n-        assert!(so_name.is_some());\n+        assert!(so_name.is_ok());\n         assert_eq!(addr, so_name.unwrap());\n     }\n \n@@ -509,20 +487,20 @@ mod test {\n         spawn(proc() {\n             let mut acceptor = TcpListener::bind(addr).listen();\n             chan.send(());\n-            acceptor.accept();\n+            acceptor.accept().unwrap();\n         });\n \n         port.recv();\n         let stream = TcpStream::connect(addr);\n \n-        assert!(stream.is_some());\n+        assert!(stream.is_ok());\n         let mut stream = stream.unwrap();\n \n         // Make sure peer_name gives us the\n         // address/port of the peer we've\n         // connected to.\n         let peer_name = stream.peer_name();\n-        assert!(peer_name.is_some());\n+        assert!(peer_name.is_ok());\n         assert_eq!(addr, peer_name.unwrap());\n     }\n \n@@ -541,37 +519,33 @@ mod test {\n         let addr = next_test_ip4();\n         let (p, c) = Chan::new();\n         spawn(proc() {\n-            let mut srv = TcpListener::bind(addr).listen();\n+            let mut srv = TcpListener::bind(addr).listen().unwrap();\n             c.send(());\n             let mut cl = srv.accept().unwrap();\n-            cl.write([10]);\n+            cl.write([10]).unwrap();\n             let mut b = [0];\n-            cl.read(b);\n+            cl.read(b).unwrap();\n             c.send(());\n         });\n \n         p.recv();\n         let mut c = TcpStream::connect(addr).unwrap();\n         let mut b = [0, ..10];\n-        assert_eq!(c.read(b), Some(1));\n-        c.write([1]);\n+        assert_eq!(c.read(b), Ok(1));\n+        c.write([1]).unwrap();\n         p.recv();\n     })\n \n     iotest!(fn double_bind() {\n-        let mut called = false;\n-        io_error::cond.trap(|e| {\n-            assert!(e.kind == ConnectionRefused || e.kind == OtherIoError);\n-            called = true;\n-        }).inside(|| {\n-            let addr = next_test_ip4();\n-            let listener = TcpListener::bind(addr).unwrap().listen();\n-            assert!(listener.is_some());\n-            let listener2 = TcpListener::bind(addr).and_then(|l|\n-                                                    l.listen());\n-            assert!(listener2.is_none());\n-        });\n-        assert!(called);\n+        let addr = next_test_ip4();\n+        let listener = TcpListener::bind(addr).unwrap().listen();\n+        assert!(listener.is_ok());\n+        match TcpListener::bind(addr).listen() {\n+            Ok(..) => fail!(),\n+            Err(e) => {\n+                assert!(e.kind == ConnectionRefused || e.kind == OtherIoError);\n+            }\n+        }\n     })\n \n     iotest!(fn fast_rebind() {\n@@ -580,7 +554,7 @@ mod test {\n \n         spawn(proc() {\n             port.recv();\n-            let _stream = TcpStream::connect(addr);\n+            let _stream = TcpStream::connect(addr).unwrap();\n             // Close\n             port.recv();\n         });\n@@ -589,7 +563,7 @@ mod test {\n             let mut acceptor = TcpListener::bind(addr).listen();\n             chan.send(());\n             {\n-                let _stream = acceptor.accept();\n+                let _stream = acceptor.accept().unwrap();\n                 // Close client\n                 chan.send(());\n             }"}, {"sha": "0ef62648afcb7934e2d1f29cd46db97168704be9", "filename": "src/libstd/io/net/udp.rs", "status": "modified", "additions": 35, "deletions": 40, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/209642c65177d6cf42dd4eea693040aa91cde9ee/src%2Flibstd%2Fio%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/209642c65177d6cf42dd4eea693040aa91cde9ee/src%2Flibstd%2Fio%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fudp.rs?ref=209642c65177d6cf42dd4eea693040aa91cde9ee", "patch": "@@ -80,16 +80,11 @@ mod test {\n \n     // FIXME #11530 this fails on android because tests are run as root\n     iotest!(fn bind_error() {\n-        let mut called = false;\n-        io_error::cond.trap(|e| {\n-            assert_eq!(e.kind, PermissionDenied);\n-            called = true;\n-        }).inside(|| {\n-            let addr = SocketAddr { ip: Ipv4Addr(0, 0, 0, 0), port: 1 };\n-            let socket = UdpSocket::bind(addr);\n-            assert!(socket.is_none());\n-        });\n-        assert!(called);\n+        let addr = SocketAddr { ip: Ipv4Addr(0, 0, 0, 0), port: 1 };\n+        match UdpSocket::bind(addr) {\n+            Ok(..) => fail!(),\n+            Err(e) => assert_eq!(e.kind, PermissionDenied),\n+        }\n     } #[ignore(cfg(windows))] #[ignore(cfg(target_os = \"android\"))])\n \n     iotest!(fn socket_smoke_test_ip4() {\n@@ -100,29 +95,29 @@ mod test {\n \n         spawn(proc() {\n             match UdpSocket::bind(client_ip) {\n-                Some(ref mut client) => {\n+                Ok(ref mut client) => {\n                     port.recv();\n-                    client.sendto([99], server_ip)\n+                    client.sendto([99], server_ip).unwrap()\n                 }\n-                None => fail!()\n+                Err(..) => fail!()\n             }\n             chan2.send(());\n         });\n \n         match UdpSocket::bind(server_ip) {\n-            Some(ref mut server) => {\n+            Ok(ref mut server) => {\n                 chan.send(());\n                 let mut buf = [0];\n                 match server.recvfrom(buf) {\n-                    Some((nread, src)) => {\n+                    Ok((nread, src)) => {\n                         assert_eq!(nread, 1);\n                         assert_eq!(buf[0], 99);\n                         assert_eq!(src, client_ip);\n                     }\n-                    None => fail!()\n+                    Err(..) => fail!()\n                 }\n             }\n-            None => fail!()\n+            Err(..) => fail!()\n         }\n         port2.recv();\n     })\n@@ -134,28 +129,28 @@ mod test {\n \n         spawn(proc() {\n             match UdpSocket::bind(client_ip) {\n-                Some(ref mut client) => {\n+                Ok(ref mut client) => {\n                     port.recv();\n-                    client.sendto([99], server_ip)\n+                    client.sendto([99], server_ip).unwrap()\n                 }\n-                None => fail!()\n+                Err(..) => fail!()\n             }\n         });\n \n         match UdpSocket::bind(server_ip) {\n-            Some(ref mut server) => {\n+            Ok(ref mut server) => {\n                 chan.send(());\n                 let mut buf = [0];\n                 match server.recvfrom(buf) {\n-                    Some((nread, src)) => {\n+                    Ok((nread, src)) => {\n                         assert_eq!(nread, 1);\n                         assert_eq!(buf[0], 99);\n                         assert_eq!(src, client_ip);\n                     }\n-                    None => fail!()\n+                    Err(..) => fail!()\n                 }\n             }\n-            None => fail!()\n+            Err(..) => fail!()\n         }\n     })\n \n@@ -167,32 +162,32 @@ mod test {\n \n         spawn(proc() {\n             match UdpSocket::bind(client_ip) {\n-                Some(client) => {\n+                Ok(client) => {\n                     let client = ~client;\n                     let mut stream = client.connect(server_ip);\n                     port.recv();\n-                    stream.write([99]);\n+                    stream.write([99]).unwrap();\n                 }\n-                None => fail!()\n+                Err(..) => fail!()\n             }\n             chan2.send(());\n         });\n \n         match UdpSocket::bind(server_ip) {\n-            Some(server) => {\n+            Ok(server) => {\n                 let server = ~server;\n                 let mut stream = server.connect(client_ip);\n                 chan.send(());\n                 let mut buf = [0];\n                 match stream.read(buf) {\n-                    Some(nread) => {\n+                    Ok(nread) => {\n                         assert_eq!(nread, 1);\n                         assert_eq!(buf[0], 99);\n                     }\n-                    None => fail!()\n+                    Err(..) => fail!()\n                 }\n             }\n-            None => fail!()\n+            Err(..) => fail!()\n         }\n         port2.recv();\n     })\n@@ -205,46 +200,46 @@ mod test {\n \n         spawn(proc() {\n             match UdpSocket::bind(client_ip) {\n-                Some(client) => {\n+                Ok(client) => {\n                     let client = ~client;\n                     let mut stream = client.connect(server_ip);\n                     port.recv();\n-                    stream.write([99]);\n+                    stream.write([99]).unwrap();\n                 }\n-                None => fail!()\n+                Err(..) => fail!()\n             }\n             chan2.send(());\n         });\n \n         match UdpSocket::bind(server_ip) {\n-            Some(server) => {\n+            Ok(server) => {\n                 let server = ~server;\n                 let mut stream = server.connect(client_ip);\n                 chan.send(());\n                 let mut buf = [0];\n                 match stream.read(buf) {\n-                    Some(nread) => {\n+                    Ok(nread) => {\n                         assert_eq!(nread, 1);\n                         assert_eq!(buf[0], 99);\n                     }\n-                    None => fail!()\n+                    Err(..) => fail!()\n                 }\n             }\n-            None => fail!()\n+            Err(..) => fail!()\n         }\n         port2.recv();\n     })\n \n     pub fn socket_name(addr: SocketAddr) {\n         let server = UdpSocket::bind(addr);\n \n-        assert!(server.is_some());\n+        assert!(server.is_ok());\n         let mut server = server.unwrap();\n \n         // Make sure socket_name gives\n         // us the socket we binded to.\n         let so_name = server.socket_name();\n-        assert!(so_name.is_some());\n+        assert!(so_name.is_ok());\n         assert_eq!(addr, so_name.unwrap());\n     }\n "}, {"sha": "63a2ba3d0951a3a8dc0ae0b6fdafe55b0097a34a", "filename": "src/libstd/io/net/unix.rs", "status": "modified", "additions": 24, "deletions": 34, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/209642c65177d6cf42dd4eea693040aa91cde9ee/src%2Flibstd%2Fio%2Fnet%2Funix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/209642c65177d6cf42dd4eea693040aa91cde9ee/src%2Flibstd%2Fio%2Fnet%2Funix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Funix.rs?ref=209642c65177d6cf42dd4eea693040aa91cde9ee", "patch": "@@ -151,48 +151,38 @@ mod tests {\n \n     #[test]\n     fn bind_error() {\n-        let mut called = false;\n-        io_error::cond.trap(|e| {\n-            assert!(e.kind == PermissionDenied);\n-            called = true;\n-        }).inside(|| {\n-            let listener = UnixListener::bind(&(\"path/to/nowhere\"));\n-            assert!(listener.is_none());\n-        });\n-        assert!(called);\n+        match UnixListener::bind(&(\"path/to/nowhere\")) {\n+            Ok(..) => fail!(),\n+            Err(e) => assert_eq!(e.kind, PermissionDenied),\n+        }\n     }\n \n     #[test]\n     fn connect_error() {\n-        let mut called = false;\n-        io_error::cond.trap(|e| {\n-            assert_eq!(e.kind,\n-                       if cfg!(windows) {OtherIoError} else {FileNotFound});\n-            called = true;\n-        }).inside(|| {\n-            let stream = UnixStream::connect(&(\"path/to/nowhere\"));\n-            assert!(stream.is_none());\n-        });\n-        assert!(called);\n+        match UnixStream::connect(&(\"path/to/nowhere\")) {\n+            Ok(..) => fail!(),\n+            Err(e) => assert_eq!(e.kind,\n+                        if cfg!(windows) {OtherIoError} else {FileNotFound})\n+        }\n     }\n \n     #[test]\n     fn smoke() {\n         smalltest(proc(mut server) {\n             let mut buf = [0];\n-            server.read(buf);\n+            server.read(buf).unwrap();\n             assert!(buf[0] == 99);\n         }, proc(mut client) {\n-            client.write([99]);\n+            client.write([99]).unwrap();\n         })\n     }\n \n     #[test]\n     fn read_eof() {\n         smalltest(proc(mut server) {\n             let mut buf = [0];\n-            assert!(server.read(buf).is_none());\n-            assert!(server.read(buf).is_none());\n+            assert!(server.read(buf).is_err());\n+            assert!(server.read(buf).is_err());\n         }, proc(_client) {\n             // drop the client\n         })\n@@ -202,15 +192,15 @@ mod tests {\n     fn write_begone() {\n         smalltest(proc(mut server) {\n             let buf = [0];\n-            let mut stop = false;\n-            while !stop{\n-                io_error::cond.trap(|e| {\n-                    assert!(e.kind == BrokenPipe || e.kind == NotConnected,\n-                            \"unknown error {:?}\", e);\n-                    stop = true;\n-                }).inside(|| {\n-                    server.write(buf);\n-                })\n+            loop {\n+                match server.write(buf) {\n+                    Ok(..) => {}\n+                    Err(e) => {\n+                        assert!(e.kind == BrokenPipe || e.kind == NotConnected,\n+                                \"unknown error {:?}\", e);\n+                        break;\n+                    }\n+                }\n             }\n         }, proc(_client) {\n             // drop the client\n@@ -228,7 +218,7 @@ mod tests {\n             port.recv();\n             for _ in range(0, times) {\n                 let mut stream = UnixStream::connect(&path2);\n-                stream.write([100]);\n+                stream.write([100]).unwrap();\n             }\n         });\n \n@@ -237,7 +227,7 @@ mod tests {\n         for _ in range(0, times) {\n             let mut client = acceptor.accept();\n             let mut buf = [0];\n-            client.read(buf);\n+            client.read(buf).unwrap();\n             assert_eq!(buf[0], 100);\n         }\n     }"}, {"sha": "75791164b891992a65ed5ad1db82251a3e46d296", "filename": "src/libstd/io/pipe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/209642c65177d6cf42dd4eea693040aa91cde9ee/src%2Flibstd%2Fio%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/209642c65177d6cf42dd4eea693040aa91cde9ee/src%2Flibstd%2Fio%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fpipe.rs?ref=209642c65177d6cf42dd4eea693040aa91cde9ee", "patch": "@@ -73,12 +73,12 @@ mod test {\n         let (p, c) = Chan::new();\n         spawn(proc() {\n             let mut out = out;\n-            out.write([10]);\n+            out.write([10]).unwrap();\n             p.recv(); // don't close the pipe until the other read has finished\n         });\n \n         let mut buf = [0, ..10];\n-        input.read(buf);\n+        input.read(buf).unwrap();\n         c.send(());\n     })\n }"}, {"sha": "87d47868d0af18a524e57883b4ba308285a7e815", "filename": "src/libstd/io/process.rs", "status": "modified", "additions": 8, "deletions": 17, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/209642c65177d6cf42dd4eea693040aa91cde9ee/src%2Flibstd%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/209642c65177d6cf42dd4eea693040aa91cde9ee/src%2Flibstd%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fprocess.rs?ref=209642c65177d6cf42dd4eea693040aa91cde9ee", "patch": "@@ -171,7 +171,6 @@ impl Drop for Process {\n mod tests {\n     use io::process::{ProcessConfig, Process};\n     use prelude::*;\n-    use str;\n \n     // FIXME(#10380)\n     #[cfg(unix, not(target_os=\"android\"))]\n@@ -185,7 +184,7 @@ mod tests {\n             io: io,\n         };\n         let p = Process::new(args);\n-        assert!(p.is_some());\n+        assert!(p.is_ok());\n         let mut p = p.unwrap();\n         assert!(p.wait().success());\n     })\n@@ -201,7 +200,7 @@ mod tests {\n             cwd: None,\n             io: io,\n         };\n-        match io::result(|| Process::new(args)) {\n+        match Process::new(args) {\n             Ok(..) => fail!(),\n             Err(..) => {}\n         }\n@@ -219,7 +218,7 @@ mod tests {\n             io: io,\n         };\n         let p = Process::new(args);\n-        assert!(p.is_some());\n+        assert!(p.is_ok());\n         let mut p = p.unwrap();\n         assert!(p.wait().matches_exit_status(1));\n     })\n@@ -235,7 +234,7 @@ mod tests {\n             io: io,\n         };\n         let p = Process::new(args);\n-        assert!(p.is_some());\n+        assert!(p.is_ok());\n         let mut p = p.unwrap();\n         match p.wait() {\n             process::ExitSignal(1) => {},\n@@ -244,20 +243,12 @@ mod tests {\n     })\n \n     pub fn read_all(input: &mut Reader) -> ~str {\n-        let mut ret = ~\"\";\n-        let mut buf = [0, ..1024];\n-        loop {\n-            match input.read(buf) {\n-                None => { break }\n-                Some(n) => { ret.push_str(str::from_utf8(buf.slice_to(n)).unwrap()); }\n-            }\n-        }\n-        return ret;\n+        input.read_to_str().unwrap()\n     }\n \n     pub fn run_output(args: ProcessConfig) -> ~str {\n         let p = Process::new(args);\n-        assert!(p.is_some());\n+        assert!(p.is_ok());\n         let mut p = p.unwrap();\n         assert!(p.io[0].is_none());\n         assert!(p.io[1].is_some());\n@@ -307,8 +298,8 @@ mod tests {\n             cwd: None,\n             io: io,\n         };\n-        let mut p = Process::new(args).expect(\"didn't create a proces?!\");\n-        p.io[0].get_mut_ref().write(\"foobar\".as_bytes());\n+        let mut p = Process::new(args).unwrap();\n+        p.io[0].get_mut_ref().write(\"foobar\".as_bytes()).unwrap();\n         p.io[0] = None; // close stdin;\n         let out = read_all(p.io[1].get_mut_ref() as &mut Reader);\n         assert!(p.wait().success());"}, {"sha": "aa33ecb19e556aec825e8cb6f83f57f3d3d3cc2d", "filename": "src/libstd/io/result.rs", "status": "modified", "additions": 23, "deletions": 33, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/209642c65177d6cf42dd4eea693040aa91cde9ee/src%2Flibstd%2Fio%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/209642c65177d6cf42dd4eea693040aa91cde9ee/src%2Flibstd%2Fio%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fresult.rs?ref=209642c65177d6cf42dd4eea693040aa91cde9ee", "patch": "@@ -80,59 +80,49 @@ impl<T, A: Acceptor<T>> Acceptor<T> for IoResult<A> {\n mod test {\n     use prelude::*;\n     use super::super::mem::*;\n-    use super::super::{PreviousIoError, io_error};\n+    use io;\n \n     #[test]\n     fn test_option_writer() {\n-        let mut writer: Option<MemWriter> = Some(MemWriter::new());\n-        writer.write([0, 1, 2]);\n-        writer.flush();\n+        let mut writer: io::IoResult<MemWriter> = Ok(MemWriter::new());\n+        writer.write([0, 1, 2]).unwrap();\n+        writer.flush().unwrap();\n         assert_eq!(writer.unwrap().unwrap(), ~[0, 1, 2]);\n     }\n \n     #[test]\n     fn test_option_writer_error() {\n-        let mut writer: Option<MemWriter> = None;\n+        let mut writer: io::IoResult<MemWriter> =\n+            Err(io::standard_error(io::EndOfFile));\n \n-        let mut called = false;\n-        io_error::cond.trap(|err| {\n-            assert_eq!(err.kind, PreviousIoError);\n-            called = true;\n-        }).inside(|| {\n-            writer.write([0, 0, 0]);\n-        });\n-        assert!(called);\n-\n-        let mut called = false;\n-        io_error::cond.trap(|err| {\n-            assert_eq!(err.kind, PreviousIoError);\n-            called = true;\n-        }).inside(|| {\n-            writer.flush();\n-        });\n-        assert!(called);\n+        match writer.write([0, 0, 0]) {\n+            Ok(..) => fail!(),\n+            Err(e) => assert_eq!(e.kind, io::EndOfFile),\n+        }\n+        match writer.flush() {\n+            Ok(..) => fail!(),\n+            Err(e) => assert_eq!(e.kind, io::EndOfFile),\n+        }\n     }\n \n     #[test]\n     fn test_option_reader() {\n-        let mut reader: Option<MemReader> = Some(MemReader::new(~[0, 1, 2, 3]));\n+        let mut reader: io::IoResult<MemReader> =\n+            Ok(MemReader::new(~[0, 1, 2, 3]));\n         let mut buf = [0, 0];\n-        reader.read(buf);\n+        reader.read(buf).unwrap();\n         assert_eq!(buf, [0, 1]);\n     }\n \n     #[test]\n     fn test_option_reader_error() {\n-        let mut reader: Option<MemReader> = None;\n+        let mut reader: io::IoResult<MemReader> =\n+            Err(io::standard_error(io::EndOfFile));\n         let mut buf = [];\n \n-        let mut called = false;\n-        io_error::cond.trap(|err| {\n-            assert_eq!(err.kind, PreviousIoError);\n-            called = true;\n-        }).inside(|| {\n-            reader.read(buf);\n-        });\n-        assert!(called);\n+        match reader.read(buf) {\n+            Ok(..) => fail!(),\n+            Err(e) => assert_eq!(e.kind, io::EndOfFile),\n+        }\n     }\n }"}, {"sha": "8096bfeddfd407699eeaac47c140252a96b16037", "filename": "src/libstd/io/signal.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/209642c65177d6cf42dd4eea693040aa91cde9ee/src%2Flibstd%2Fio%2Fsignal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/209642c65177d6cf42dd4eea693040aa91cde9ee/src%2Flibstd%2Fio%2Fsignal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fsignal.rs?ref=209642c65177d6cf42dd4eea693040aa91cde9ee", "patch": "@@ -160,7 +160,7 @@ mod test {\n     #[test] #[cfg(unix, not(target_os=\"android\"))] // FIXME(#10378)\n     fn test_io_signal_smoketest() {\n         let mut signal = Listener::new();\n-        signal.register(Interrupt);\n+        signal.register(Interrupt).unwrap();\n         sigint();\n         timer::sleep(10);\n         match signal.port.recv() {\n@@ -173,8 +173,8 @@ mod test {\n     fn test_io_signal_two_signal_one_signum() {\n         let mut s1 = Listener::new();\n         let mut s2 = Listener::new();\n-        s1.register(Interrupt);\n-        s2.register(Interrupt);\n+        s1.register(Interrupt).unwrap();\n+        s2.register(Interrupt).unwrap();\n         sigint();\n         timer::sleep(10);\n         match s1.port.recv() {\n@@ -191,8 +191,8 @@ mod test {\n     fn test_io_signal_unregister() {\n         let mut s1 = Listener::new();\n         let mut s2 = Listener::new();\n-        s1.register(Interrupt);\n-        s2.register(Interrupt);\n+        s1.register(Interrupt).unwrap();\n+        s2.register(Interrupt).unwrap();\n         s2.unregister(Interrupt);\n         sigint();\n         timer::sleep(10);"}, {"sha": "702ecfb603151cb1731f262dce445fb306e348d9", "filename": "src/libstd/io/stdio.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/209642c65177d6cf42dd4eea693040aa91cde9ee/src%2Flibstd%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/209642c65177d6cf42dd4eea693040aa91cde9ee/src%2Flibstd%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fstdio.rs?ref=209642c65177d6cf42dd4eea693040aa91cde9ee", "patch": "@@ -358,7 +358,7 @@ mod tests {\n             set_stdout(~w as ~Writer);\n             println!(\"hello!\");\n         });\n-        assert_eq!(r.read_to_str(), ~\"hello!\\n\");\n+        assert_eq!(r.read_to_str().unwrap(), ~\"hello!\\n\");\n     })\n \n     iotest!(fn capture_stderr() {\n@@ -370,7 +370,7 @@ mod tests {\n             set_stderr(~w as ~Writer);\n             fail!(\"my special message\");\n         });\n-        let s = r.read_to_str();\n+        let s = r.read_to_str().unwrap();\n         assert!(s.contains(\"my special message\"));\n     })\n }"}, {"sha": "c4d92b36ecfa60fca8b76463aeb55f4af0c6070f", "filename": "src/libstd/io/util.rs", "status": "modified", "additions": 17, "deletions": 14, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/209642c65177d6cf42dd4eea693040aa91cde9ee/src%2Flibstd%2Fio%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/209642c65177d6cf42dd4eea693040aa91cde9ee/src%2Flibstd%2Fio%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Futil.rs?ref=209642c65177d6cf42dd4eea693040aa91cde9ee", "patch": "@@ -183,6 +183,7 @@ pub fn copy<R: Reader, W: Writer>(r: &mut R, w: &mut W) -> io::IoResult<()> {\n \n #[cfg(test)]\n mod test {\n+    use io;\n     use io::{MemReader, MemWriter};\n     use super::*;\n     use prelude::*;\n@@ -192,7 +193,7 @@ mod test {\n         let mut r = MemReader::new(~[0, 1, 2]);\n         {\n             let mut r = LimitReader::new(&mut r, 4);\n-            assert_eq!(~[0, 1, 2], r.read_to_end());\n+            assert_eq!(~[0, 1, 2], r.read_to_end().unwrap());\n         }\n     }\n \n@@ -201,32 +202,32 @@ mod test {\n         let mut r = MemReader::new(~[0, 1, 2]);\n         {\n             let mut r = LimitReader::new(&mut r, 2);\n-            assert_eq!(~[0, 1], r.read_to_end());\n+            assert_eq!(~[0, 1], r.read_to_end().unwrap());\n         }\n-        assert_eq!(~[2], r.read_to_end());\n+        assert_eq!(~[2], r.read_to_end().unwrap());\n     }\n \n     #[test]\n     fn test_null_writer() {\n         let mut s = NullWriter;\n         let buf = ~[0, 0, 0];\n-        s.write(buf);\n-        s.flush();\n+        s.write(buf).unwrap();\n+        s.flush().unwrap();\n     }\n \n     #[test]\n     fn test_zero_reader() {\n         let mut s = ZeroReader;\n         let mut buf = ~[1, 2, 3];\n-        assert_eq!(s.read(buf), Some(3));\n+        assert_eq!(s.read(buf), Ok(3));\n         assert_eq!(~[0, 0, 0], buf);\n     }\n \n     #[test]\n     fn test_null_reader() {\n         let mut r = NullReader;\n         let mut buf = ~[0];\n-        assert_eq!(r.read(buf), None);\n+        assert!(r.read(buf).is_err());\n     }\n \n     #[test]\n@@ -236,21 +237,23 @@ mod test {\n \n         struct TestWriter;\n         impl Writer for TestWriter {\n-            fn write(&mut self, _buf: &[u8]) {\n+            fn write(&mut self, _buf: &[u8]) -> io::IoResult<()> {\n                 unsafe { writes += 1 }\n+                Ok(())\n             }\n \n-            fn flush(&mut self) {\n+            fn flush(&mut self) -> io::IoResult<()> {\n                 unsafe { flushes += 1 }\n+                Ok(())\n             }\n         }\n \n         let mut multi = MultiWriter::new(~[~TestWriter as ~Writer,\n                                            ~TestWriter as ~Writer]);\n-        multi.write([1, 2, 3]);\n+        multi.write([1, 2, 3]).unwrap();\n         assert_eq!(2, unsafe { writes });\n         assert_eq!(0, unsafe { flushes });\n-        multi.flush();\n+        multi.flush().unwrap();\n         assert_eq!(2, unsafe { writes });\n         assert_eq!(2, unsafe { flushes });\n     }\n@@ -260,14 +263,14 @@ mod test {\n         let rs = ~[MemReader::new(~[0, 1]), MemReader::new(~[]),\n                    MemReader::new(~[2, 3])];\n         let mut r = ChainedReader::new(rs.move_iter());\n-        assert_eq!(~[0, 1, 2, 3], r.read_to_end());\n+        assert_eq!(~[0, 1, 2, 3], r.read_to_end().unwrap());\n     }\n \n     #[test]\n     fn test_tee_reader() {\n         let mut r = TeeReader::new(MemReader::new(~[0, 1, 2]),\n                                    MemWriter::new());\n-        assert_eq!(~[0, 1, 2], r.read_to_end());\n+        assert_eq!(~[0, 1, 2], r.read_to_end().unwrap());\n         let (_, w) = r.unwrap();\n         assert_eq!(~[0, 1, 2], w.unwrap());\n     }\n@@ -276,7 +279,7 @@ mod test {\n     fn test_copy() {\n         let mut r = MemReader::new(~[0, 1, 2, 3, 4]);\n         let mut w = MemWriter::new();\n-        copy(&mut r, &mut w);\n+        copy(&mut r, &mut w).unwrap();\n         assert_eq!(~[0, 1, 2, 3, 4], w.unwrap());\n     }\n }"}, {"sha": "2457917d2e4d18f24fcafc7cc788fcf93e09b180", "filename": "src/libstd/os.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/209642c65177d6cf42dd4eea693040aa91cde9ee/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/209642c65177d6cf42dd4eea693040aa91cde9ee/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=209642c65177d6cf42dd4eea693040aa91cde9ee", "patch": "@@ -1492,7 +1492,6 @@ mod tests {\n         use result::{Ok, Err};\n         use os::*;\n         use libc::*;\n-        use io;\n         use io::fs;\n \n         #[cfg(unix)]\n@@ -1537,8 +1536,7 @@ mod tests {\n             close(fd);\n         }\n \n-        let _guard = io::ignore_io_error();\n-        fs::unlink(&path);\n+        fs::unlink(&path).unwrap();\n     }\n \n     // More recursive_mkdir tests are in extra::tempfile"}, {"sha": "04e42b3eedfc5d5020cbb1a430b4dca7c9c990ff", "filename": "src/libstd/run.rs", "status": "modified", "additions": 33, "deletions": 48, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/209642c65177d6cf42dd4eea693040aa91cde9ee/src%2Flibstd%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/209642c65177d6cf42dd4eea693040aa91cde9ee/src%2Flibstd%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frun.rs?ref=209642c65177d6cf42dd4eea693040aa91cde9ee", "patch": "@@ -11,6 +11,7 @@\n //! Utilities for spawning and managing processes\n \n #[allow(missing_doc)];\n+#[deny(unused_must_use)];\n \n use comm::SharedChan;\n use io::Reader;\n@@ -258,10 +259,10 @@ impl Process {\n      * On Posix OSs SIGTERM will be sent to the process. On Win32\n      * TerminateProcess(..) will be called.\n      */\n-    pub fn destroy(&mut self) {\n-        // This should never fail because we own the process\n-        self.inner.signal(io::process::PleaseExitSignal).unwrap();\n+    pub fn destroy(&mut self) -> io::IoResult<()> {\n+        let ret = self.inner.signal(io::process::PleaseExitSignal);\n         self.finish();\n+        return ret;\n     }\n \n     /**\n@@ -271,10 +272,11 @@ impl Process {\n      * On Posix OSs SIGKILL will be sent to the process. On Win32\n      * TerminateProcess(..) will be called.\n      */\n-    pub fn force_destroy(&mut self) {\n+    pub fn force_destroy(&mut self) -> io::IoResult<()> {\n         // This should never fail because we own the process\n-        self.inner.signal(io::process::MustDieSignal).unwrap();\n+        let ret = self.inner.signal(io::process::MustDieSignal);\n         self.finish();\n+        return ret;\n \n     }\n }\n@@ -330,41 +332,33 @@ mod tests {\n     use task::spawn;\n     use unstable::running_on_valgrind;\n     use io::pipe::PipeStream;\n-    use io::{io_error, FileNotFound};\n+    use io::{FileNotFound};\n     use libc::c_int;\n \n     #[test]\n     #[cfg(not(target_os=\"android\"))] // FIXME(#10380)\n     fn test_process_status() {\n-        let mut status = run::process_status(\"false\", []).expect(\"failed to exec `false`\");\n+        let mut status = run::process_status(\"false\", []).unwrap();\n         assert!(status.matches_exit_status(1));\n \n-        status = run::process_status(\"true\", []).expect(\"failed to exec `true`\");\n+        status = run::process_status(\"true\", []).unwrap();\n         assert!(status.success());\n     }\n \n     #[test]\n     fn test_process_output_fail_to_start() {\n-        // If the executable does not exist, then the io_error condition should be raised with\n-        // IoErrorKind FileNotFound.\n-\n-        let mut trapped_io_error = false;\n-        let opt_outp = io_error::cond.trap(|e| {\n-            trapped_io_error = true;\n-            assert_eq!(e.kind, FileNotFound);\n-        }).inside(|| -> Option<run::ProcessOutput> {\n-            run::process_output(\"/no-binary-by-this-name-should-exist\", [])\n-        });\n-        assert!(trapped_io_error);\n-        assert!(opt_outp.is_none());\n+        match run::process_output(\"/no-binary-by-this-name-should-exist\", []) {\n+            Err(e) => assert_eq!(e.kind, FileNotFound),\n+            Ok(..) => fail!()\n+        }\n     }\n \n     #[test]\n     #[cfg(not(target_os=\"android\"))] // FIXME(#10380)\n     fn test_process_output_output() {\n \n         let run::ProcessOutput {status, output, error}\n-             = run::process_output(\"echo\", [~\"hello\"]).expect(\"failed to exec `echo`\");\n+             = run::process_output(\"echo\", [~\"hello\"]).unwrap();\n         let output_str = str::from_utf8_owned(output).unwrap();\n \n         assert!(status.success());\n@@ -380,7 +374,7 @@ mod tests {\n     fn test_process_output_error() {\n \n         let run::ProcessOutput {status, output, error}\n-             = run::process_output(\"mkdir\", [~\".\"]).expect(\"failed to exec `mkdir`\");\n+             = run::process_output(\"mkdir\", [~\".\"]).unwrap();\n \n         assert!(status.matches_exit_status(1));\n         assert_eq!(output, ~[]);\n@@ -401,7 +395,7 @@ mod tests {\n             in_fd: Some(pipe_in.input),\n             out_fd: Some(pipe_out.out),\n             err_fd: Some(pipe_err.out)\n-        }).expect(\"failed to exec `cat`\");\n+        }).unwrap();\n \n         os::close(pipe_in.input as int);\n         os::close(pipe_out.out as int);\n@@ -419,35 +413,26 @@ mod tests {\n \n     fn writeclose(fd: c_int, s: &str) {\n         let mut writer = PipeStream::open(fd);\n-        writer.write(s.as_bytes());\n+        writer.write(s.as_bytes()).unwrap();\n     }\n \n     fn readclose(fd: c_int) -> ~str {\n-        let mut res = ~[];\n-        let mut reader = PipeStream::open(fd);\n-        let mut buf = [0, ..1024];\n-        loop {\n-            match reader.read(buf) {\n-                Some(n) => { res.push_all(buf.slice_to(n)); }\n-                None => break\n-            }\n-        }\n-        str::from_utf8_owned(res).unwrap()\n+        PipeStream::open(fd).read_to_str().unwrap()\n     }\n \n     #[test]\n     #[cfg(not(target_os=\"android\"))] // FIXME(#10380)\n     fn test_finish_once() {\n         let mut prog = run::Process::new(\"false\", [], run::ProcessOptions::new())\n-            .expect(\"failed to exec `false`\");\n+            .unwrap();\n         assert!(prog.finish().matches_exit_status(1));\n     }\n \n     #[test]\n     #[cfg(not(target_os=\"android\"))] // FIXME(#10380)\n     fn test_finish_twice() {\n         let mut prog = run::Process::new(\"false\", [], run::ProcessOptions::new())\n-            .expect(\"failed to exec `false`\");\n+            .unwrap();\n         assert!(prog.finish().matches_exit_status(1));\n         assert!(prog.finish().matches_exit_status(1));\n     }\n@@ -457,7 +442,7 @@ mod tests {\n     fn test_finish_with_output_once() {\n \n         let mut prog = run::Process::new(\"echo\", [~\"hello\"], run::ProcessOptions::new())\n-            .expect(\"failed to exec `echo`\");\n+            .unwrap();\n         let run::ProcessOutput {status, output, error}\n             = prog.finish_with_output();\n         let output_str = str::from_utf8_owned(output).unwrap();\n@@ -475,7 +460,7 @@ mod tests {\n     fn test_finish_with_output_twice() {\n \n         let mut prog = run::Process::new(\"echo\", [~\"hello\"], run::ProcessOptions::new())\n-            .expect(\"failed to exec `echo`\");\n+            .unwrap();\n         let run::ProcessOutput {status, output, error}\n             = prog.finish_with_output();\n \n@@ -504,22 +489,22 @@ mod tests {\n         run::Process::new(\"pwd\", [], run::ProcessOptions {\n             dir: dir,\n             .. run::ProcessOptions::new()\n-        }).expect(\"failed to exec `pwd`\")\n+        }).unwrap()\n     }\n     #[cfg(unix,target_os=\"android\")]\n     fn run_pwd(dir: Option<&Path>) -> run::Process {\n         run::Process::new(\"/system/bin/sh\", [~\"-c\",~\"pwd\"], run::ProcessOptions {\n             dir: dir,\n             .. run::ProcessOptions::new()\n-        }).expect(\"failed to exec `/system/bin/sh`\")\n+        }).unwrap()\n     }\n \n     #[cfg(windows)]\n     fn run_pwd(dir: Option<&Path>) -> run::Process {\n         run::Process::new(\"cmd\", [~\"/c\", ~\"cd\"], run::ProcessOptions {\n             dir: dir,\n             .. run::ProcessOptions::new()\n-        }).expect(\"failed to run `cmd`\")\n+        }).unwrap()\n     }\n \n     #[test]\n@@ -530,8 +515,8 @@ mod tests {\n         let parent_dir = os::getcwd();\n         let child_dir = Path::new(output.trim());\n \n-        let parent_stat = parent_dir.stat();\n-        let child_stat = child_dir.stat();\n+        let parent_stat = parent_dir.stat().unwrap();\n+        let child_stat = child_dir.stat().unwrap();\n \n         assert_eq!(parent_stat.unstable.device, child_stat.unstable.device);\n         assert_eq!(parent_stat.unstable.inode, child_stat.unstable.inode);\n@@ -547,8 +532,8 @@ mod tests {\n         let output = str::from_utf8_owned(prog.finish_with_output().output).unwrap();\n         let child_dir = Path::new(output.trim());\n \n-        let parent_stat = parent_dir.stat();\n-        let child_stat = child_dir.stat();\n+        let parent_stat = parent_dir.stat().unwrap();\n+        let child_stat = child_dir.stat().unwrap();\n \n         assert_eq!(parent_stat.unstable.device, child_stat.unstable.device);\n         assert_eq!(parent_stat.unstable.inode, child_stat.unstable.inode);\n@@ -559,22 +544,22 @@ mod tests {\n         run::Process::new(\"env\", [], run::ProcessOptions {\n             env: env,\n             .. run::ProcessOptions::new()\n-        }).expect(\"failed to exec `env`\")\n+        }).unwrap()\n     }\n     #[cfg(unix,target_os=\"android\")]\n     fn run_env(env: Option<~[(~str, ~str)]>) -> run::Process {\n         run::Process::new(\"/system/bin/sh\", [~\"-c\",~\"set\"], run::ProcessOptions {\n             env: env,\n             .. run::ProcessOptions::new()\n-        }).expect(\"failed to exec `/system/bin/sh`\")\n+        }).unwrap()\n     }\n \n     #[cfg(windows)]\n     fn run_env(env: Option<~[(~str, ~str)]>) -> run::Process {\n         run::Process::new(\"cmd\", [~\"/c\", ~\"set\"], run::ProcessOptions {\n             env: env,\n             .. run::ProcessOptions::new()\n-        }).expect(\"failed to run `cmd`\")\n+        }).unwrap()\n     }\n \n     #[test]"}, {"sha": "5fa0c6431ab5caa5c7e31f55fd904368a5809660", "filename": "src/libstd/task.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/209642c65177d6cf42dd4eea693040aa91cde9ee/src%2Flibstd%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/209642c65177d6cf42dd4eea693040aa91cde9ee/src%2Flibstd%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask.rs?ref=209642c65177d6cf42dd4eea693040aa91cde9ee", "patch": "@@ -541,7 +541,7 @@ fn test_avoid_copying_the_body_task_spawn() {\n #[test]\n fn test_avoid_copying_the_body_try() {\n     avoid_copying_the_body(|f| {\n-        try(proc() {\n+        let _ = try(proc() {\n             f()\n         });\n     })"}, {"sha": "c2fa168a47825bad0857474df67ffbea25a2448e", "filename": "src/libstd/unstable/sync.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/209642c65177d6cf42dd4eea693040aa91cde9ee/src%2Flibstd%2Funstable%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/209642c65177d6cf42dd4eea693040aa91cde9ee/src%2Flibstd%2Funstable%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fsync.rs?ref=209642c65177d6cf42dd4eea693040aa91cde9ee", "patch": "@@ -200,7 +200,7 @@ mod tests {\n             // accesses will also fail.\n             let x = Exclusive::new(1);\n             let x2 = x.clone();\n-            task::try(proc() {\n+            let _ = task::try(proc() {\n                 x2.with(|one| assert_eq!(*one, 2))\n             });\n             x.with(|one| assert_eq!(*one, 1));"}]}