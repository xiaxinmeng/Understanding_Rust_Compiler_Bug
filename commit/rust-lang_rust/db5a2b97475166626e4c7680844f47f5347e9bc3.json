{"sha": "db5a2b97475166626e4c7680844f47f5347e9bc3", "node_id": "C_kwDOAAsO6NoAKGRiNWEyYjk3NDc1MTY2NjI2ZTRjNzY4MDg0NGY0N2Y1MzQ3ZTliYzM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-13T01:44:01Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-13T01:44:01Z"}, "message": "Auto merge of #2315 - saethlin:shrink-item, r=saethlin\n\nOptimizing Stacked Borrows (part 2): Shrink Item\n\nThis moves protectors out of `Item`, storing them both in a global `HashSet` which contains all currently-protected tags as well as a `Vec<SbTag>` on each `Frame` so that when we return from a function we know which tags to remove from the protected set.\n\nThis also bit-packs the 64-bit tag and the 2-bit permission together when they are stored in memory. This means we theoretically run out of tags sooner, but I doubt that limit will ever be hit.\n\nTogether these optimizations reduce the memory footprint of Miri when executing programs which stress Stacked Borrows by ~66%. For example, running a test with isolation off which only panics currently peaks at ~19 GB, with this PR it peaks at ~6.2 GB.\n\nTo-do\n- [x] Enforce the 62-bit limit\n- [x] Decide if there is a better order to pack the tag and permission in\n- [x] Wait for `UnsafeCell` to become infectious, or express offsets + tags in the global protector set\n\nBenchmarks before:\n```\nBenchmark 1: cargo +miri miri run --manifest-path bench-cargo-miri/backtraces/Cargo.toml\n  Time (mean \u00b1 \u03c3):      8.948 s \u00b1  0.253 s    [User: 8.752 s, System: 0.158 s]\n  Range (min \u2026 max):    8.619 s \u2026  9.279 s    5 runs\n\nBenchmark 1: cargo +miri miri run --manifest-path bench-cargo-miri/mse/Cargo.toml\n  Time (mean \u00b1 \u03c3):      2.129 s \u00b1  0.037 s    [User: 1.849 s, System: 0.248 s]\n  Range (min \u2026 max):    2.086 s \u2026  2.176 s    5 runs\n\nBenchmark 1: cargo +miri miri run --manifest-path bench-cargo-miri/serde1/Cargo.toml\n  Time (mean \u00b1 \u03c3):      3.334 s \u00b1  0.017 s    [User: 3.211 s, System: 0.103 s]\n  Range (min \u2026 max):    3.315 s \u2026  3.352 s    5 runs\n\nBenchmark 1: cargo +miri miri run --manifest-path bench-cargo-miri/serde2/Cargo.toml\n  Time (mean \u00b1 \u03c3):      3.316 s \u00b1  0.038 s    [User: 3.207 s, System: 0.095 s]\n  Range (min \u2026 max):    3.282 s \u2026  3.375 s    5 runs\n\nBenchmark 1: cargo +miri miri run --manifest-path bench-cargo-miri/unicode/Cargo.toml\n  Time (mean \u00b1 \u03c3):      6.391 s \u00b1  0.323 s    [User: 5.928 s, System: 0.412 s]\n  Range (min \u2026 max):    6.090 s \u2026  6.917 s    5 runs\n ```\n After:\n ```\nBenchmark 1: cargo +miri miri run --manifest-path bench-cargo-miri/backtraces/Cargo.toml\n  Time (mean \u00b1 \u03c3):      6.955 s \u00b1  0.051 s    [User: 6.807 s, System: 0.132 s]\n  Range (min \u2026 max):    6.900 s \u2026  7.038 s    5 runs\n\nBenchmark 1: cargo +miri miri run --manifest-path bench-cargo-miri/mse/Cargo.toml\n  Time (mean \u00b1 \u03c3):      1.784 s \u00b1  0.012 s    [User: 1.627 s, System: 0.156 s]\n  Range (min \u2026 max):    1.772 s \u2026  1.797 s    5 runs\n\nBenchmark 1: cargo +miri miri run --manifest-path bench-cargo-miri/serde1/Cargo.toml\n  Time (mean \u00b1 \u03c3):      2.505 s \u00b1  0.095 s    [User: 2.311 s, System: 0.096 s]\n  Range (min \u2026 max):    2.405 s \u2026  2.603 s    5 runs\n\nBenchmark 1: cargo +miri miri run --manifest-path bench-cargo-miri/serde2/Cargo.toml\n  Time (mean \u00b1 \u03c3):      2.449 s \u00b1  0.031 s    [User: 2.306 s, System: 0.100 s]\n  Range (min \u2026 max):    2.395 s \u2026  2.467 s    5 runs\n\nBenchmark 1: cargo +miri miri run --manifest-path bench-cargo-miri/unicode/Cargo.toml\n  Time (mean \u00b1 \u03c3):      3.667 s \u00b1  0.110 s    [User: 3.498 s, System: 0.140 s]\n  Range (min \u2026 max):    3.564 s \u2026  3.814 s    5 runs\n ```\n The decrease in system time is probably due to spending less time in the page fault handler.", "tree": {"sha": "5c2ce79583d37af07f10c244c1d13533a8076947", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5c2ce79583d37af07f10c244c1d13533a8076947"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/db5a2b97475166626e4c7680844f47f5347e9bc3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/db5a2b97475166626e4c7680844f47f5347e9bc3", "html_url": "https://github.com/rust-lang/rust/commit/db5a2b97475166626e4c7680844f47f5347e9bc3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/db5a2b97475166626e4c7680844f47f5347e9bc3/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f223a5fe7045b649fcffc5880f6aff68e6fb9eb4", "url": "https://api.github.com/repos/rust-lang/rust/commits/f223a5fe7045b649fcffc5880f6aff68e6fb9eb4", "html_url": "https://github.com/rust-lang/rust/commit/f223a5fe7045b649fcffc5880f6aff68e6fb9eb4"}, {"sha": "4eff60ad6e37cd8f37e994d42c8c1ce271670bd4", "url": "https://api.github.com/repos/rust-lang/rust/commits/4eff60ad6e37cd8f37e994d42c8c1ce271670bd4", "html_url": "https://github.com/rust-lang/rust/commit/4eff60ad6e37cd8f37e994d42c8c1ce271670bd4"}], "stats": {"total": 470, "additions": 317, "deletions": 153}, "files": [{"sha": "b3d408a6dc07244945073a84014a923dd2d350e4", "filename": "src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/db5a2b97475166626e4c7680844f47f5347e9bc3/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db5a2b97475166626e4c7680844f47f5347e9bc3/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=db5a2b97475166626e4c7680844f47f5347e9bc3", "patch": "@@ -90,8 +90,8 @@ pub use crate::mono_hash_map::MonoHashMap;\n pub use crate::operator::EvalContextExt as OperatorEvalContextExt;\n pub use crate::range_map::RangeMap;\n pub use crate::stacked_borrows::{\n-    stack::Stack, CallId, EvalContextExt as StackedBorEvalContextExt, Item, Permission, SbTag,\n-    SbTagExtra, Stacks,\n+    CallId, EvalContextExt as StackedBorEvalContextExt, Item, Permission, SbTag, SbTagExtra, Stack,\n+    Stacks,\n };\n pub use crate::sync::{CondvarId, EvalContextExt as SyncEvalContextExt, MutexId, RwLockId};\n pub use crate::thread::{"}, {"sha": "e31d7ba0105d611e5ff38d599a06d8cd8a5dfa86", "filename": "src/machine.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/db5a2b97475166626e4c7680844f47f5347e9bc3/src%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db5a2b97475166626e4c7680844f47f5347e9bc3/src%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmachine.rs?ref=db5a2b97475166626e4c7680844f47f5347e9bc3", "patch": "@@ -5,7 +5,6 @@ use std::borrow::Cow;\n use std::cell::RefCell;\n use std::collections::HashSet;\n use std::fmt;\n-use std::num::NonZeroU64;\n use std::time::Instant;\n \n use rand::rngs::StdRng;\n@@ -43,7 +42,7 @@ pub const NUM_CPUS: u64 = 1;\n /// Extra data stored with each stack frame\n pub struct FrameData<'tcx> {\n     /// Extra data for Stacked Borrows.\n-    pub call_id: stacked_borrows::CallId,\n+    pub stacked_borrows: Option<stacked_borrows::FrameExtra>,\n \n     /// If this is Some(), then this is a special \"catch unwind\" frame (the frame of `try_fn`\n     /// called by `try`). When this frame is popped during unwinding a panic,\n@@ -59,9 +58,9 @@ pub struct FrameData<'tcx> {\n impl<'tcx> std::fmt::Debug for FrameData<'tcx> {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         // Omitting `timing`, it does not support `Debug`.\n-        let FrameData { call_id, catch_unwind, timing: _ } = self;\n+        let FrameData { stacked_borrows, catch_unwind, timing: _ } = self;\n         f.debug_struct(\"FrameData\")\n-            .field(\"call_id\", call_id)\n+            .field(\"stacked_borrows\", stacked_borrows)\n             .field(\"catch_unwind\", catch_unwind)\n             .finish()\n     }\n@@ -788,6 +787,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n                 range,\n                 machine.stacked_borrows.as_ref().unwrap(),\n                 machine.current_span(),\n+                &machine.threads,\n             )?;\n         }\n         if let Some(weak_memory) = &alloc_extra.weak_memory {\n@@ -819,6 +819,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n                 range,\n                 machine.stacked_borrows.as_ref().unwrap(),\n                 machine.current_span(),\n+                &machine.threads,\n             )?;\n         }\n         if let Some(weak_memory) = &alloc_extra.weak_memory {\n@@ -852,6 +853,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n                 tag,\n                 range,\n                 machine.stacked_borrows.as_ref().unwrap(),\n+                &machine.threads,\n             )\n         } else {\n             Ok(())\n@@ -888,11 +890,12 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n         };\n \n         let stacked_borrows = ecx.machine.stacked_borrows.as_ref();\n-        let call_id = stacked_borrows.map_or(NonZeroU64::new(1).unwrap(), |stacked_borrows| {\n-            stacked_borrows.borrow_mut().new_call()\n-        });\n \n-        let extra = FrameData { call_id, catch_unwind: None, timing };\n+        let extra = FrameData {\n+            stacked_borrows: stacked_borrows.map(|sb| sb.borrow_mut().new_frame()),\n+            catch_unwind: None,\n+            timing,\n+        };\n         Ok(frame.with_extra(extra))\n     }\n \n@@ -936,7 +939,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n     ) -> InterpResult<'tcx, StackPopJump> {\n         let timing = frame.extra.timing.take();\n         if let Some(stacked_borrows) = &ecx.machine.stacked_borrows {\n-            stacked_borrows.borrow_mut().end_call(frame.extra.call_id);\n+            stacked_borrows.borrow_mut().end_call(&frame.extra);\n         }\n         let res = ecx.handle_stack_pop_unwind(frame.extra, unwinding);\n         if let Some(profiler) = ecx.machine.profiler.as_ref() {"}, {"sha": "4cae27ecd2192a67ba85e9fd8459865c5714f96e", "filename": "src/stacked_borrows.rs", "status": "modified", "additions": 134, "deletions": 89, "changes": 223, "blob_url": "https://github.com/rust-lang/rust/blob/db5a2b97475166626e4c7680844f47f5347e9bc3/src%2Fstacked_borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db5a2b97475166626e4c7680844f47f5347e9bc3/src%2Fstacked_borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows.rs?ref=db5a2b97475166626e4c7680844f47f5347e9bc3", "patch": "@@ -16,15 +16,18 @@ use rustc_middle::ty::{\n };\n use rustc_span::DUMMY_SP;\n use rustc_target::abi::Size;\n+use smallvec::SmallVec;\n use std::collections::HashSet;\n \n use crate::*;\n \n pub mod diagnostics;\n use diagnostics::{AllocHistory, TagHistory};\n \n-pub mod stack;\n-use stack::Stack;\n+mod item;\n+pub use item::{Item, Permission};\n+mod stack;\n+pub use stack::Stack;\n \n pub type CallId = NonZeroU64;\n \n@@ -78,40 +81,20 @@ impl SbTagExtra {\n     }\n }\n \n-/// Indicates which permission is granted (by this item to some pointers)\n-#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n-pub enum Permission {\n-    /// Grants unique mutable access.\n-    Unique,\n-    /// Grants shared mutable access.\n-    SharedReadWrite,\n-    /// Grants shared read-only access.\n-    SharedReadOnly,\n-    /// Grants no access, but separates two groups of SharedReadWrite so they are not\n-    /// all considered mutually compatible.\n-    Disabled,\n-}\n-\n-/// An item in the per-location borrow stack.\n-#[derive(Copy, Clone, Hash, PartialEq, Eq)]\n-pub struct Item {\n-    /// The permission this item grants.\n-    perm: Permission,\n-    /// The pointers the permission is granted to.\n-    tag: SbTag,\n-    /// An optional protector, ensuring the item cannot get popped until `CallId` is over.\n-    protector: Option<CallId>,\n-}\n-\n-impl fmt::Debug for Item {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"[{:?} for {:?}\", self.perm, self.tag)?;\n-        if let Some(call) = self.protector {\n-            write!(f, \" (call {})\", call)?;\n-        }\n-        write!(f, \"]\")?;\n-        Ok(())\n-    }\n+#[derive(Debug)]\n+pub struct FrameExtra {\n+    /// The ID of the call this frame corresponds to.\n+    call_id: CallId,\n+\n+    /// If this frame is protecting any tags, they are listed here. We use this list to do\n+    /// incremental updates of the global list of protected tags stored in the\n+    /// `stacked_borrows::GlobalState` upon function return, and if we attempt to pop a protected\n+    /// tag, to identify which call is responsible for protecting the tag.\n+    /// See `Stack::item_popped` for more explanation.\n+    ///\n+    /// This will contain one tag per reference passed to the function, so\n+    /// a size of 2 is enough for the vast majority of functions.\n+    protected_tags: SmallVec<[SbTag; 2]>,\n }\n \n /// Extra per-allocation state.\n@@ -136,8 +119,12 @@ pub struct GlobalStateInner {\n     base_ptr_tags: FxHashMap<AllocId, SbTag>,\n     /// Next unused call ID (for protectors).\n     next_call_id: CallId,\n-    /// Those call IDs corresponding to functions that are still running.\n-    active_calls: FxHashSet<CallId>,\n+    /// All currently protected tags.\n+    /// An item is protected if its tag is in this set, *and* it has the \"protected\" bit set.\n+    /// We add tags to this when they are created with a protector in `reborrow`, and\n+    /// we remove tags from this when the call which is protecting them returns, in\n+    /// `GlobalStateInner::end_call`. See `Stack::item_popped` for more details.\n+    protected_tags: FxHashSet<SbTag>,\n     /// The pointer ids to trace\n     tracked_pointer_tags: HashSet<SbTag>,\n     /// The call ids to trace\n@@ -201,7 +188,7 @@ impl GlobalStateInner {\n             next_ptr_tag: SbTag(NonZeroU64::new(1).unwrap()),\n             base_ptr_tags: FxHashMap::default(),\n             next_call_id: NonZeroU64::new(1).unwrap(),\n-            active_calls: FxHashSet::default(),\n+            protected_tags: FxHashSet::default(),\n             tracked_pointer_tags,\n             tracked_call_ids,\n             retag_fields,\n@@ -215,23 +202,25 @@ impl GlobalStateInner {\n         id\n     }\n \n-    pub fn new_call(&mut self) -> CallId {\n-        let id = self.next_call_id;\n-        trace!(\"new_call: Assigning ID {}\", id);\n-        if self.tracked_call_ids.contains(&id) {\n-            register_diagnostic(NonHaltingDiagnostic::CreatedCallId(id));\n+    pub fn new_frame(&mut self) -> FrameExtra {\n+        let call_id = self.next_call_id;\n+        trace!(\"new_frame: Assigning call ID {}\", call_id);\n+        if self.tracked_call_ids.contains(&call_id) {\n+            register_diagnostic(NonHaltingDiagnostic::CreatedCallId(call_id));\n         }\n-        assert!(self.active_calls.insert(id));\n-        self.next_call_id = NonZeroU64::new(id.get() + 1).unwrap();\n-        id\n-    }\n-\n-    pub fn end_call(&mut self, id: CallId) {\n-        assert!(self.active_calls.remove(&id));\n+        self.next_call_id = NonZeroU64::new(call_id.get() + 1).unwrap();\n+        FrameExtra { call_id, protected_tags: SmallVec::new() }\n     }\n \n-    fn is_active(&self, id: CallId) -> bool {\n-        self.active_calls.contains(&id)\n+    pub fn end_call(&mut self, frame: &machine::FrameData<'_>) {\n+        for tag in &frame\n+            .stacked_borrows\n+            .as_ref()\n+            .expect(\"we should have Stacked Borrows data\")\n+            .protected_tags\n+        {\n+            self.protected_tags.remove(tag);\n+        }\n     }\n \n     pub fn base_ptr_tag(&mut self, id: AllocId) -> SbTag {\n@@ -287,7 +276,7 @@ impl<'tcx> Stack {\n     /// Find the first write-incompatible item above the given one --\n     /// i.e, find the height to which the stack will be truncated when writing to `granting`.\n     fn find_first_write_incompatible(&self, granting: usize) -> usize {\n-        let perm = self.get(granting).unwrap().perm;\n+        let perm = self.get(granting).unwrap().perm();\n         match perm {\n             Permission::SharedReadOnly => bug!(\"Cannot use SharedReadOnly for writing\"),\n             Permission::Disabled => bug!(\"Cannot use Disabled for anything\"),\n@@ -299,7 +288,7 @@ impl<'tcx> Stack {\n                 // The SharedReadWrite *just* above us are compatible, to skip those.\n                 let mut idx = granting + 1;\n                 while let Some(item) = self.get(idx) {\n-                    if item.perm == Permission::SharedReadWrite {\n+                    if item.perm() == Permission::SharedReadWrite {\n                         // Go on.\n                         idx += 1;\n                     } else {\n@@ -325,32 +314,67 @@ impl<'tcx> Stack {\n         provoking_access: Option<(SbTagExtra, AllocRange, Size, AccessKind)>, // just for debug printing and error messages\n         global: &GlobalStateInner,\n         alloc_history: &mut AllocHistory,\n+        threads: &ThreadManager<'_, 'tcx>,\n     ) -> InterpResult<'tcx> {\n-        if global.tracked_pointer_tags.contains(&item.tag) {\n+        if global.tracked_pointer_tags.contains(&item.tag()) {\n             register_diagnostic(NonHaltingDiagnostic::PoppedPointerTag(\n                 *item,\n                 provoking_access.map(|(tag, _alloc_range, _size, access)| (tag, access)),\n             ));\n         }\n \n-        if let Some(call) = item.protector {\n-            if global.is_active(call) {\n-                if let Some((tag, _alloc_range, _offset, _access)) = provoking_access {\n-                    Err(err_sb_ub(\n-                        format!(\n-                            \"not granting access to tag {:?} because incompatible item is protected: {:?}\",\n-                            tag, item\n-                        ),\n-                        None,\n-                        tag.and_then(|tag| alloc_history.get_logs_relevant_to(tag, Some(item.tag))),\n-                    ))?\n-                } else {\n-                    Err(err_sb_ub(\n-                        format!(\"deallocating while item is protected: {:?}\", item),\n-                        None,\n-                        None,\n-                    ))?\n-                }\n+        if !item.protected() {\n+            return Ok(());\n+        }\n+\n+        // We store tags twice, once in global.protected_tags and once in each call frame.\n+        // We do this because consulting a single global set in this function is faster\n+        // than attempting to search all call frames in the program for the `FrameExtra`\n+        // (if any) which is protecting the popped tag.\n+        //\n+        // This duplication trades off making `end_call` slower to make this function faster. This\n+        // trade-off is profitable in practice for a combination of two reasons.\n+        // 1. A single protected tag can (and does in some programs) protect thousands of `Item`s.\n+        //    Therefore, adding overhead to in function call/return is profitable even if it only\n+        //    saves a little work in this function.\n+        // 2. Most frames protect only one or two tags. So this duplicative global turns a search\n+        //    which ends up about linear in the number of protected tags in the program into a\n+        //    constant time check (and a slow linear, because the tags in the frames aren't contiguous).\n+        if global.protected_tags.contains(&item.tag()) {\n+            // This path is cold because it is fatal to the program. So here it is fine to do the\n+            // more expensive search to figure out which call is responsible for protecting this\n+            // tag.\n+            let call_id = threads\n+                .all_stacks()\n+                .flatten()\n+                .map(|frame| {\n+                    frame\n+                        .extra\n+                        .stacked_borrows\n+                        .as_ref()\n+                        .expect(\"we should have Stacked Borrows data\")\n+                })\n+                .find(|frame| frame.protected_tags.contains(&item.tag()))\n+                .map(|frame| frame.call_id)\n+                .unwrap(); // FIXME: Surely we should find something, but a panic seems wrong here?\n+            if let Some((tag, _alloc_range, _offset, _access)) = provoking_access {\n+                Err(err_sb_ub(\n+                    format!(\n+                        \"not granting access to tag {:?} because incompatible item {:?} is protected by call {:?}\",\n+                        tag, item, call_id\n+                    ),\n+                    None,\n+                    tag.and_then(|tag| alloc_history.get_logs_relevant_to(tag, Some(item.tag()))),\n+                ))?\n+            } else {\n+                Err(err_sb_ub(\n+                    format!(\n+                        \"deallocating while item {:?} is protected by call {:?}\",\n+                        item, call_id\n+                    ),\n+                    None,\n+                    None,\n+                ))?\n             }\n         }\n         Ok(())\n@@ -369,6 +393,7 @@ impl<'tcx> Stack {\n         current_span: &mut CurrentSpan<'_, '_, 'tcx>,\n         alloc_history: &mut AllocHistory,\n         exposed_tags: &FxHashSet<SbTag>,\n+        threads: &ThreadManager<'_, 'tcx>,\n     ) -> InterpResult<'tcx> {\n         // Two main steps: Find granting item, remove incompatible items above.\n \n@@ -399,8 +424,9 @@ impl<'tcx> Stack {\n                     Some((tag, alloc_range, offset, access)),\n                     global,\n                     alloc_history,\n+                    threads,\n                 )?;\n-                alloc_history.log_invalidation(item.tag, alloc_range, current_span);\n+                alloc_history.log_invalidation(item.tag(), alloc_range, current_span);\n                 Ok(())\n             })?;\n         } else {\n@@ -425,8 +451,9 @@ impl<'tcx> Stack {\n                     Some((tag, alloc_range, offset, access)),\n                     global,\n                     alloc_history,\n+                    threads,\n                 )?;\n-                alloc_history.log_invalidation(item.tag, alloc_range, current_span);\n+                alloc_history.log_invalidation(item.tag(), alloc_range, current_span);\n                 Ok(())\n             })?;\n         }\n@@ -439,9 +466,9 @@ impl<'tcx> Stack {\n             for i in 0..self.len() {\n                 let item = self.get(i).unwrap();\n                 // Skip disabled items, they cannot be matched anyway.\n-                if !matches!(item.perm, Permission::Disabled) {\n+                if !matches!(item.perm(), Permission::Disabled) {\n                     // We are looking for a strict upper bound, so add 1 to this tag.\n-                    max = cmp::max(item.tag.0.checked_add(1).unwrap(), max);\n+                    max = cmp::max(item.tag().0.checked_add(1).unwrap(), max);\n                 }\n             }\n             if let Some(unk) = self.unknown_bottom() {\n@@ -467,6 +494,7 @@ impl<'tcx> Stack {\n         global: &GlobalStateInner,\n         alloc_history: &mut AllocHistory,\n         exposed_tags: &FxHashSet<SbTag>,\n+        threads: &ThreadManager<'_, 'tcx>,\n     ) -> InterpResult<'tcx> {\n         // Step 1: Make sure there is a granting item.\n         self.find_granting(AccessKind::Write, tag, exposed_tags).map_err(|_| {\n@@ -482,7 +510,7 @@ impl<'tcx> Stack {\n         // Step 2: Consider all items removed. This checks for protectors.\n         for idx in (0..self.len()).rev() {\n             let item = self.get(idx).unwrap();\n-            Stack::item_popped(&item, None, global, alloc_history)?;\n+            Stack::item_popped(&item, None, global, alloc_history, threads)?;\n         }\n         Ok(())\n     }\n@@ -502,10 +530,11 @@ impl<'tcx> Stack {\n         current_span: &mut CurrentSpan<'_, '_, 'tcx>,\n         alloc_history: &mut AllocHistory,\n         exposed_tags: &FxHashSet<SbTag>,\n+        threads: &ThreadManager<'_, 'tcx>,\n     ) -> InterpResult<'tcx> {\n         // Figure out which access `perm` corresponds to.\n         let access =\n-            if new.perm.grants(AccessKind::Write) { AccessKind::Write } else { AccessKind::Read };\n+            if new.perm().grants(AccessKind::Write) { AccessKind::Write } else { AccessKind::Read };\n \n         // Now we figure out which item grants our parent (`derived_from`) this kind of access.\n         // We use that to determine where to put the new item.\n@@ -517,7 +546,7 @@ impl<'tcx> Stack {\n         // Compute where to put the new item.\n         // Either way, we ensure that we insert the new item in a way such that between\n         // `derived_from` and the new one, there are only items *compatible with* `derived_from`.\n-        let new_idx = if new.perm == Permission::SharedReadWrite {\n+        let new_idx = if new.perm() == Permission::SharedReadWrite {\n             assert!(\n                 access == AccessKind::Write,\n                 \"this case only makes sense for stack-like accesses\"\n@@ -550,6 +579,7 @@ impl<'tcx> Stack {\n                 current_span,\n                 alloc_history,\n                 exposed_tags,\n+                threads,\n             )?;\n \n             // We insert \"as far up as possible\": We know only compatible items are remaining\n@@ -571,7 +601,7 @@ impl<'tcx> Stack {\n impl<'tcx> Stacks {\n     /// Creates new stack with initial tag.\n     fn new(size: Size, perm: Permission, tag: SbTag) -> Self {\n-        let item = Item { perm, tag, protector: None };\n+        let item = Item::new(tag, perm, false);\n         let stack = Stack::new(item);\n \n         Stacks {\n@@ -637,6 +667,7 @@ impl Stacks {\n         range: AllocRange,\n         state: &GlobalState,\n         mut current_span: CurrentSpan<'_, '_, 'tcx>,\n+        threads: &ThreadManager<'_, 'tcx>,\n     ) -> InterpResult<'tcx> {\n         trace!(\n             \"read access with tag {:?}: {:?}, size {}\",\n@@ -654,6 +685,7 @@ impl Stacks {\n                 &mut current_span,\n                 history,\n                 exposed_tags,\n+                threads,\n             )\n         })\n     }\n@@ -666,6 +698,7 @@ impl Stacks {\n         range: AllocRange,\n         state: &GlobalState,\n         mut current_span: CurrentSpan<'_, '_, 'tcx>,\n+        threads: &ThreadManager<'_, 'tcx>,\n     ) -> InterpResult<'tcx> {\n         trace!(\n             \"write access with tag {:?}: {:?}, size {}\",\n@@ -683,6 +716,7 @@ impl Stacks {\n                 &mut current_span,\n                 history,\n                 exposed_tags,\n+                threads,\n             )\n         })\n     }\n@@ -694,11 +728,12 @@ impl Stacks {\n         tag: SbTagExtra,\n         range: AllocRange,\n         state: &GlobalState,\n+        threads: &ThreadManager<'_, 'tcx>,\n     ) -> InterpResult<'tcx> {\n         trace!(\"deallocation with tag {:?}: {:?}, size {}\", tag, alloc_id, range.size.bytes());\n         let state = state.borrow();\n         self.for_each(range, |offset, stack, history, exposed_tags| {\n-            stack.dealloc(tag, (alloc_id, range, offset), &state, history, exposed_tags)\n+            stack.dealloc(tag, (alloc_id, range, offset), &state, history, exposed_tags, threads)\n         })?;\n         Ok(())\n     }\n@@ -801,7 +836,6 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             });\n         }\n \n-        let protector = if protect { Some(this.frame().extra.call_id) } else { None };\n         trace!(\n             \"reborrow: {} reference {:?} derived from {:?} (pointee {}): {:?}, size {}\",\n             kind,\n@@ -812,6 +846,13 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             size.bytes()\n         );\n \n+        if protect {\n+            this.frame_mut().extra.stacked_borrows.as_mut().unwrap().protected_tags.push(new_tag);\n+            this.machine.stacked_borrows.as_mut().unwrap().get_mut().protected_tags.insert(new_tag);\n+        }\n+        // FIXME: can't hold the current span handle across the borrows of self above\n+        let current_span = &mut this.machine.current_span();\n+\n         // Update the stacks.\n         // Make sure that raw pointers and mutable shared references are reborrowed \"weak\":\n         // There could be existing unique pointers reborrowed from them that should remain valid!\n@@ -848,15 +889,16 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                     } else {\n                         Permission::SharedReadWrite\n                     };\n-                    let protector = if frozen {\n-                        protector\n+                    let protected = if frozen {\n+                        protect\n                     } else {\n                         // We do not protect inside UnsafeCell.\n                         // This fixes https://github.com/rust-lang/rust/issues/55005.\n-                        None\n+                        false\n                     };\n-                    let item = Item { perm, tag: new_tag, protector };\n+                    let item = Item::new(new_tag, perm, protected);\n                     let mut global = this.machine.stacked_borrows.as_ref().unwrap().borrow_mut();\n+                    let threads = &this.machine.threads;\n                     stacked_borrows.for_each(range, |offset, stack, history, exposed_tags| {\n                         stack.grant(\n                             orig_tag,\n@@ -866,6 +908,7 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                             current_span,\n                             history,\n                             exposed_tags,\n+                            threads,\n                         )\n                     })\n                 })?;\n@@ -881,9 +924,10 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             .as_mut()\n             .expect(\"we should have Stacked Borrows data\")\n             .borrow_mut();\n-        let item = Item { perm, tag: new_tag, protector };\n+        let item = Item::new(new_tag, perm, protect);\n         let range = alloc_range(base_offset, size);\n         let mut global = machine.stacked_borrows.as_ref().unwrap().borrow_mut();\n+        let threads = &machine.threads;\n         let current_span = &mut machine.current_span(); // `get_alloc_extra_mut` invalidated our old `current_span`\n         stacked_borrows.for_each(range, |offset, stack, history, exposed_tags| {\n             stack.grant(\n@@ -894,6 +938,7 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 current_span,\n                 history,\n                 exposed_tags,\n+                threads,\n             )\n         })?;\n "}, {"sha": "1fa619a3ae4d48f819dcfa0eeacb5be0fce3a33a", "filename": "src/stacked_borrows/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/db5a2b97475166626e4c7680844f47f5347e9bc3/src%2Fstacked_borrows%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db5a2b97475166626e4c7680844f47f5347e9bc3/src%2Fstacked_borrows%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows%2Fdiagnostics.rs?ref=db5a2b97475166626e4c7680844f47f5347e9bc3", "patch": "@@ -141,7 +141,7 @@ impl AllocHistory {\n     ) -> InterpError<'tcx> {\n         let action = format!(\n             \"trying to reborrow {derived_from:?} for {new_perm:?} permission at {alloc_id:?}[{offset:#x}]\",\n-            new_perm = new.perm,\n+            new_perm = new.perm(),\n             offset = error_offset.bytes(),\n         );\n         err_sb_ub(\n@@ -185,7 +185,7 @@ fn error_cause(stack: &Stack, tag: SbTagExtra) -> &'static str {\n     if let SbTagExtra::Concrete(tag) = tag {\n         if (0..stack.len())\n             .map(|i| stack.get(i).unwrap())\n-            .any(|item| item.tag == tag && item.perm != Permission::Disabled)\n+            .any(|item| item.tag() == tag && item.perm() != Permission::Disabled)\n         {\n             \", but that tag only grants SharedReadOnly permission for this location\"\n         } else {"}, {"sha": "ad1b9b075b40fce12dd96baaa0e0eeec8c26afb0", "filename": "src/stacked_borrows/item.rs", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/db5a2b97475166626e4c7680844f47f5347e9bc3/src%2Fstacked_borrows%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db5a2b97475166626e4c7680844f47f5347e9bc3/src%2Fstacked_borrows%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows%2Fitem.rs?ref=db5a2b97475166626e4c7680844f47f5347e9bc3", "patch": "@@ -0,0 +1,104 @@\n+use crate::stacked_borrows::SbTag;\n+use std::fmt;\n+use std::num::NonZeroU64;\n+\n+/// An item in the per-location borrow stack.\n+#[derive(Copy, Clone, Hash, PartialEq, Eq)]\n+pub struct Item(u64);\n+\n+// An Item contains 3 bitfields:\n+// * Bits 0-61 store an SbTag\n+// * Bits 61-63 store a Permission\n+// * Bit 64 stores a flag which indicates if we have a protector\n+const TAG_MASK: u64 = u64::MAX >> 3;\n+const PERM_MASK: u64 = 0x3 << 61;\n+const PROTECTED_MASK: u64 = 0x1 << 63;\n+\n+const PERM_SHIFT: u64 = 61;\n+const PROTECTED_SHIFT: u64 = 63;\n+\n+impl Item {\n+    pub fn new(tag: SbTag, perm: Permission, protected: bool) -> Self {\n+        assert!(tag.0.get() <= TAG_MASK);\n+        let packed_tag = tag.0.get();\n+        let packed_perm = perm.to_bits() << PERM_SHIFT;\n+        let packed_protected = (protected as u64) << PROTECTED_SHIFT;\n+\n+        let new = Self(packed_tag | packed_perm | packed_protected);\n+\n+        debug_assert!(new.tag() == tag);\n+        debug_assert!(new.perm() == perm);\n+        debug_assert!(new.protected() == protected);\n+\n+        new\n+    }\n+\n+    /// The pointers the permission is granted to.\n+    pub fn tag(self) -> SbTag {\n+        SbTag(NonZeroU64::new(self.0 & TAG_MASK).unwrap())\n+    }\n+\n+    /// The permission this item grants.\n+    pub fn perm(self) -> Permission {\n+        Permission::from_bits((self.0 & PERM_MASK) >> PERM_SHIFT)\n+    }\n+\n+    /// Whether or not there is a protector for this tag\n+    pub fn protected(self) -> bool {\n+        self.0 & PROTECTED_MASK > 0\n+    }\n+\n+    /// Set the Permission stored in this Item\n+    pub fn set_permission(&mut self, perm: Permission) {\n+        // Clear the current set permission\n+        self.0 &= !PERM_MASK;\n+        // Write Permission::Disabled to the Permission bits\n+        self.0 |= perm.to_bits() << PERM_SHIFT;\n+    }\n+}\n+\n+impl fmt::Debug for Item {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"[{:?} for {:?}]\", self.perm(), self.tag())\n+    }\n+}\n+\n+/// Indicates which permission is granted (by this item to some pointers)\n+#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n+pub enum Permission {\n+    /// Grants unique mutable access.\n+    Unique,\n+    /// Grants shared mutable access.\n+    SharedReadWrite,\n+    /// Grants shared read-only access.\n+    SharedReadOnly,\n+    /// Grants no access, but separates two groups of SharedReadWrite so they are not\n+    /// all considered mutually compatible.\n+    Disabled,\n+}\n+\n+impl Permission {\n+    const UNIQUE: u64 = 0;\n+    const SHARED_READ_WRITE: u64 = 1;\n+    const SHARED_READ_ONLY: u64 = 2;\n+    const DISABLED: u64 = 3;\n+\n+    fn to_bits(self) -> u64 {\n+        match self {\n+            Permission::Unique => Self::UNIQUE,\n+            Permission::SharedReadWrite => Self::SHARED_READ_WRITE,\n+            Permission::SharedReadOnly => Self::SHARED_READ_ONLY,\n+            Permission::Disabled => Self::DISABLED,\n+        }\n+    }\n+\n+    fn from_bits(perm: u64) -> Self {\n+        match perm {\n+            Self::UNIQUE => Permission::Unique,\n+            Self::SHARED_READ_WRITE => Permission::SharedReadWrite,\n+            Self::SHARED_READ_ONLY => Permission::SharedReadOnly,\n+            Self::DISABLED => Permission::Disabled,\n+            _ => unreachable!(),\n+        }\n+    }\n+}"}, {"sha": "1b05471618a52bc4f2507ee9c0f40e88b513a696", "filename": "src/stacked_borrows/stack.rs", "status": "modified", "additions": 37, "deletions": 29, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/db5a2b97475166626e4c7680844f47f5347e9bc3/src%2Fstacked_borrows%2Fstack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db5a2b97475166626e4c7680844f47f5347e9bc3/src%2Fstacked_borrows%2Fstack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows%2Fstack.rs?ref=db5a2b97475166626e4c7680844f47f5347e9bc3", "patch": "@@ -37,7 +37,7 @@ pub struct Stack {\n }\n \n /// A very small cache of searches of the borrow stack\n-/// This maps tags to locations in the borrow stack. Any use of this still needs to do a\n+/// This maps items to locations in the borrow stack. Any use of this still needs to do a\n /// probably-cold random access into the borrow stack to figure out what `Permission` an\n /// `SbTag` grants. We could avoid this by also storing the `Permission` in the cache, but\n /// most lookups into the cache are immediately followed by access of the full borrow stack anyway.\n@@ -48,7 +48,7 @@ pub struct Stack {\n #[cfg(feature = \"stack-cache\")]\n #[derive(Clone, Debug)]\n struct StackCache {\n-    tags: [SbTag; CACHE_LEN], // Hot in find_granting\n+    items: [Item; CACHE_LEN], // Hot in find_granting\n     idx: [usize; CACHE_LEN],  // Hot in grant\n }\n \n@@ -59,11 +59,11 @@ impl StackCache {\n     /// We use the position in the cache to represent how recently a tag was used; the first position\n     /// is the most recently used tag. So an add shifts every element towards the end, and inserts\n     /// the new element at the start. We lose the last element.\n-    /// This strategy is effective at keeping the most-accessed tags in the cache, but it costs a\n+    /// This strategy is effective at keeping the most-accessed items in the cache, but it costs a\n     /// linear shift across the entire cache when we add a new tag.\n-    fn add(&mut self, idx: usize, tag: SbTag) {\n-        self.tags.copy_within(0..CACHE_LEN - 1, 1);\n-        self.tags[0] = tag;\n+    fn add(&mut self, idx: usize, item: Item) {\n+        self.items.copy_within(0..CACHE_LEN - 1, 1);\n+        self.items[0] = item;\n         self.idx.copy_within(0..CACHE_LEN - 1, 1);\n         self.idx[0] = idx;\n     }\n@@ -80,20 +80,20 @@ impl Eq for Stack {}\n \n impl<'tcx> Stack {\n     /// Panics if any of the caching mechanisms have broken,\n-    /// - The StackCache indices don't refer to the parallel tags,\n-    /// - There are no Unique tags outside of first_unique..last_unique\n+    /// - The StackCache indices don't refer to the parallel items,\n+    /// - There are no Unique items outside of first_unique..last_unique\n     #[cfg(feature = \"expensive-debug-assertions\")]\n     fn verify_cache_consistency(&self) {\n         // Only a full cache needs to be valid. Also see the comments in find_granting_cache\n         // and set_unknown_bottom.\n         if self.borrows.len() >= CACHE_LEN {\n-            for (tag, stack_idx) in self.cache.tags.iter().zip(self.cache.idx.iter()) {\n-                assert_eq!(self.borrows[*stack_idx].tag, *tag);\n+            for (tag, stack_idx) in self.cache.items.iter().zip(self.cache.idx.iter()) {\n+                assert_eq!(self.borrows[*stack_idx], *tag);\n             }\n         }\n \n         for (idx, item) in self.borrows.iter().enumerate() {\n-            if item.perm == Permission::Unique {\n+            if item.perm() == Permission::Unique {\n                 assert!(\n                     self.unique_range.contains(&idx),\n                     \"{:?} {:?}\",\n@@ -128,7 +128,7 @@ impl<'tcx> Stack {\n                     .rev() // search top-to-bottom\n                     .find_map(|(idx, item)| {\n                         // If the item fits and *might* be this wildcard, use it.\n-                        if item.perm.grants(access) && exposed_tags.contains(&item.tag) {\n+                        if item.perm().grants(access) && exposed_tags.contains(&item.tag()) {\n                             Some(idx)\n                         } else {\n                             None\n@@ -161,9 +161,9 @@ impl<'tcx> Stack {\n         // If we didn't find the tag in the cache, fall back to a linear search of the\n         // whole stack, and add the tag to the cache.\n         for (stack_idx, item) in self.borrows.iter().enumerate().rev() {\n-            if tag == item.tag && item.perm.grants(access) {\n+            if tag == item.tag() && item.perm().grants(access) {\n                 #[cfg(feature = \"stack-cache\")]\n-                self.cache.add(stack_idx, tag);\n+                self.cache.add(stack_idx, *item);\n                 return Some(stack_idx);\n             }\n         }\n@@ -175,7 +175,7 @@ impl<'tcx> Stack {\n         // This looks like a common-sense optimization; we're going to do a linear search of the\n         // cache or the borrow stack to scan the shorter of the two. This optimization is miniscule\n         // and this check actually ensures we do not access an invalid cache.\n-        // When a stack is created and when tags are removed from the top of the borrow stack, we\n+        // When a stack is created and when items are removed from the top of the borrow stack, we\n         // need some valid value to populate the cache. In both cases, we try to use the bottom\n         // item. But when the stack is cleared in `set_unknown_bottom` there is nothing we could\n         // place in the cache that is correct. But due to the way we populate the cache in\n@@ -185,21 +185,23 @@ impl<'tcx> Stack {\n             return None;\n         }\n         // Search the cache for the tag we're looking up\n-        let cache_idx = self.cache.tags.iter().position(|t| *t == tag)?;\n+        let cache_idx = self.cache.items.iter().position(|t| t.tag() == tag)?;\n         let stack_idx = self.cache.idx[cache_idx];\n         // If we found the tag, look up its position in the stack to see if it grants\n         // the required permission\n-        if self.borrows[stack_idx].perm.grants(access) {\n+        if self.cache.items[cache_idx].perm().grants(access) {\n             // If it does, and it's not already in the most-recently-used position, re-insert it at\n             // the most-recently-used position. This technically reduces the efficiency of the\n             // cache by duplicating elements, but current benchmarks do not seem to benefit from\n             // avoiding this duplication.\n             // But if the tag is in position 1, avoiding the duplicating add is trivial.\n+            // If it does, and it's not already in the most-recently-used position, move it there.\n+            // Except if the tag is in position 1, this is equivalent to just a swap, so do that.\n             if cache_idx == 1 {\n-                self.cache.tags.swap(0, 1);\n+                self.cache.items.swap(0, 1);\n                 self.cache.idx.swap(0, 1);\n             } else if cache_idx > 1 {\n-                self.cache.add(stack_idx, tag);\n+                self.cache.add(stack_idx, self.cache.items[cache_idx]);\n             }\n             Some(stack_idx)\n         } else {\n@@ -224,7 +226,7 @@ impl<'tcx> Stack {\n         if self.unique_range.end >= new_idx {\n             self.unique_range.end += 1;\n         }\n-        if new.perm == Permission::Unique {\n+        if new.perm() == Permission::Unique {\n             // Make sure the possibly-unique range contains the new borrow\n             self.unique_range.start = self.unique_range.start.min(new_idx);\n             self.unique_range.end = self.unique_range.end.max(new_idx + 1);\n@@ -233,7 +235,7 @@ impl<'tcx> Stack {\n         // The above insert changes the meaning of every index in the cache >= new_idx, so now\n         // we need to find every one of those indexes and increment it.\n         // But if the insert is at the end (equivalent to a push), we can skip this step because\n-        // it didn't change the position of any other tags.\n+        // it didn't change the position of any other items.\n         if new_idx != self.borrows.len() - 1 {\n             for idx in &mut self.cache.idx {\n                 if *idx >= new_idx {\n@@ -243,7 +245,7 @@ impl<'tcx> Stack {\n         }\n \n         // This primes the cache for the next access, which is almost always the just-added tag.\n-        self.cache.add(new_idx, new.tag);\n+        self.cache.add(new_idx, new);\n \n         #[cfg(feature = \"expensive-debug-assertions\")]\n         self.verify_cache_consistency();\n@@ -255,9 +257,9 @@ impl<'tcx> Stack {\n             borrows: vec![item],\n             unknown_bottom: None,\n             #[cfg(feature = \"stack-cache\")]\n-            cache: StackCache { idx: [0; CACHE_LEN], tags: [item.tag; CACHE_LEN] },\n+            cache: StackCache { idx: [0; CACHE_LEN], items: [item; CACHE_LEN] },\n             #[cfg(feature = \"stack-cache\")]\n-            unique_range: if item.perm == Permission::Unique { 0..1 } else { 0..0 },\n+            unique_range: if item.perm() == Permission::Unique { 0..1 } else { 0..0 },\n         }\n     }\n \n@@ -298,10 +300,16 @@ impl<'tcx> Stack {\n             let lower = unique_range.start.max(disable_start);\n             let upper = (unique_range.end + 1).min(self.borrows.len());\n             for item in &mut self.borrows[lower..upper] {\n-                if item.perm == Permission::Unique {\n+                if item.perm() == Permission::Unique {\n                     log::trace!(\"access: disabling item {:?}\", item);\n                     visitor(*item)?;\n-                    item.perm = Permission::Disabled;\n+                    item.set_permission(Permission::Disabled);\n+                    // Also update all copies of this item in the cache.\n+                    for it in &mut self.cache.items {\n+                        if it.tag() == item.tag() {\n+                            it.set_permission(Permission::Disabled);\n+                        }\n+                    }\n                 }\n             }\n         }\n@@ -341,7 +349,7 @@ impl<'tcx> Stack {\n             // also possible that the whole cache is still valid. So we call this method to repair what\n             // aspects of the cache are now invalid, instead of resetting the whole thing to a trivially\n             // valid default state.\n-            let base_tag = self.borrows[0].tag;\n+            let base_tag = self.borrows[0];\n             let mut removed = 0;\n             let mut cursor = 0;\n             // Remove invalid entries from the cache by rotating them to the end of the cache, then\n@@ -350,15 +358,15 @@ impl<'tcx> Stack {\n             for _ in 0..CACHE_LEN - 1 {\n                 if self.cache.idx[cursor] >= start {\n                     self.cache.idx[cursor..CACHE_LEN - removed].rotate_left(1);\n-                    self.cache.tags[cursor..CACHE_LEN - removed].rotate_left(1);\n+                    self.cache.items[cursor..CACHE_LEN - removed].rotate_left(1);\n                     removed += 1;\n                 } else {\n                     cursor += 1;\n                 }\n             }\n             for i in CACHE_LEN - removed - 1..CACHE_LEN {\n                 self.cache.idx[i] = 0;\n-                self.cache.tags[i] = base_tag;\n+                self.cache.items[i] = base_tag;\n             }\n \n             if start < self.unique_range.start.saturating_sub(1) {"}, {"sha": "96135d093d96792d700c7cd7c9078e04d4654d22", "filename": "src/thread.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/db5a2b97475166626e4c7680844f47f5347e9bc3/src%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db5a2b97475166626e4c7680844f47f5347e9bc3/src%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fthread.rs?ref=db5a2b97475166626e4c7680844f47f5347e9bc3", "patch": "@@ -281,6 +281,10 @@ impl<'mir, 'tcx: 'mir> ThreadManager<'mir, 'tcx> {\n         &mut self.threads[self.active_thread].stack\n     }\n \n+    pub fn all_stacks(&self) -> impl Iterator<Item = &[Frame<'mir, 'tcx, Tag, FrameData<'tcx>>]> {\n+        self.threads.iter().map(|t| &t.stack[..])\n+    }\n+\n     /// Create a new thread and returns its id.\n     fn create_thread(&mut self) -> ThreadId {\n         let new_thread_id = ThreadId::new(self.threads.len());"}, {"sha": "c568d1c50434c30fdb97c01ac4db1e35ca006aa4", "filename": "tests/compiletest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/db5a2b97475166626e4c7680844f47f5347e9bc3/tests%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db5a2b97475166626e4c7680844f47f5347e9bc3/tests%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompiletest.rs?ref=db5a2b97475166626e4c7680844f47f5347e9bc3", "patch": "@@ -97,7 +97,7 @@ regexes! {\n     // erase specific alignments\n     \"alignment [0-9]+\"               => \"alignment ALIGN\",\n     // erase thread caller ids\n-    r\"\\(call [0-9]+\\)\"              => \"(call ID)\",\n+    r\"call [0-9]+\"                  => \"call ID\",\n     // erase platform module paths\n     \"sys::[a-z]+::\"                  => \"sys::PLATFORM::\",\n     // Windows file paths"}, {"sha": "b821d1e6edb42ef5177a3167c28919dd5b680c1c", "filename": "tests/fail/stacked_borrows/aliasing_mut1.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/db5a2b97475166626e4c7680844f47f5347e9bc3/tests%2Ffail%2Fstacked_borrows%2Faliasing_mut1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/db5a2b97475166626e4c7680844f47f5347e9bc3/tests%2Ffail%2Fstacked_borrows%2Faliasing_mut1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Faliasing_mut1.stderr?ref=db5a2b97475166626e4c7680844f47f5347e9bc3", "patch": "@@ -1,8 +1,8 @@\n-error: Undefined Behavior: not granting access to tag <TAG> because incompatible item is protected: [Unique for <TAG> (call ID)]\n+error: Undefined Behavior: not granting access to tag <TAG> because incompatible item [Unique for <TAG>] is protected by call ID\n   --> $DIR/aliasing_mut1.rs:LL:CC\n    |\n LL | pub fn safe(_x: &mut i32, _y: &mut i32) {}\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not granting access to tag <TAG> because incompatible item is protected: [Unique for <TAG> (call ID)]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not granting access to tag <TAG> because incompatible item [Unique for <TAG>] is protected by call ID\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information"}, {"sha": "594b578fc09a7235c737be067bee54f51711bc0e", "filename": "tests/fail/stacked_borrows/aliasing_mut2.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/db5a2b97475166626e4c7680844f47f5347e9bc3/tests%2Ffail%2Fstacked_borrows%2Faliasing_mut2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/db5a2b97475166626e4c7680844f47f5347e9bc3/tests%2Ffail%2Fstacked_borrows%2Faliasing_mut2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Faliasing_mut2.stderr?ref=db5a2b97475166626e4c7680844f47f5347e9bc3", "patch": "@@ -1,8 +1,8 @@\n-error: Undefined Behavior: not granting access to tag <TAG> because incompatible item is protected: [SharedReadOnly for <TAG> (call ID)]\n+error: Undefined Behavior: not granting access to tag <TAG> because incompatible item [SharedReadOnly for <TAG>] is protected by call ID\n   --> $DIR/aliasing_mut2.rs:LL:CC\n    |\n LL | pub fn safe(_x: &i32, _y: &mut i32) {}\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not granting access to tag <TAG> because incompatible item is protected: [SharedReadOnly for <TAG> (call ID)]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not granting access to tag <TAG> because incompatible item [SharedReadOnly for <TAG>] is protected by call ID\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information"}, {"sha": "0c7d85ae5756c1c63fde4b042fec3db640080404", "filename": "tests/fail/stacked_borrows/aliasing_mut4.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/db5a2b97475166626e4c7680844f47f5347e9bc3/tests%2Ffail%2Fstacked_borrows%2Faliasing_mut4.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/db5a2b97475166626e4c7680844f47f5347e9bc3/tests%2Ffail%2Fstacked_borrows%2Faliasing_mut4.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Faliasing_mut4.stderr?ref=db5a2b97475166626e4c7680844f47f5347e9bc3", "patch": "@@ -1,8 +1,8 @@\n-error: Undefined Behavior: not granting access to tag <TAG> because incompatible item is protected: [SharedReadOnly for <TAG> (call ID)]\n+error: Undefined Behavior: not granting access to tag <TAG> because incompatible item [SharedReadOnly for <TAG>] is protected by call ID\n   --> $DIR/aliasing_mut4.rs:LL:CC\n    |\n LL | pub fn safe(_x: &i32, _y: &mut Cell<i32>) {}\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not granting access to tag <TAG> because incompatible item is protected: [SharedReadOnly for <TAG> (call ID)]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not granting access to tag <TAG> because incompatible item [SharedReadOnly for <TAG>] is protected by call ID\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information"}, {"sha": "20e026df7b9b226146698319ebf4c79b944b0ff7", "filename": "tests/fail/stacked_borrows/deallocate_against_barrier1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/db5a2b97475166626e4c7680844f47f5347e9bc3/tests%2Ffail%2Fstacked_borrows%2Fdeallocate_against_barrier1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db5a2b97475166626e4c7680844f47f5347e9bc3/tests%2Ffail%2Fstacked_borrows%2Fdeallocate_against_barrier1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Fdeallocate_against_barrier1.rs?ref=db5a2b97475166626e4c7680844f47f5347e9bc3", "patch": "@@ -1,4 +1,4 @@\n-//@error-pattern: deallocating while item is protected\n+//@error-pattern: deallocating while item\n \n fn inner(x: &mut i32, f: fn(&mut i32)) {\n     // `f` may mutate, but it may not deallocate!"}, {"sha": "689c0a5deae68c9755fc0d5204e80d5ee37f977e", "filename": "tests/fail/stacked_borrows/deallocate_against_barrier1.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/db5a2b97475166626e4c7680844f47f5347e9bc3/tests%2Ffail%2Fstacked_borrows%2Fdeallocate_against_barrier1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/db5a2b97475166626e4c7680844f47f5347e9bc3/tests%2Ffail%2Fstacked_borrows%2Fdeallocate_against_barrier1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Fdeallocate_against_barrier1.stderr?ref=db5a2b97475166626e4c7680844f47f5347e9bc3", "patch": "@@ -1,8 +1,8 @@\n-error: Undefined Behavior: deallocating while item is protected: [Unique for <TAG> (call ID)]\n+error: Undefined Behavior: deallocating while item [Unique for <TAG>] is protected by call ID\n   --> RUSTLIB/alloc/src/alloc.rs:LL:CC\n    |\n LL |     unsafe { __rust_dealloc(ptr, layout.size(), layout.align()) }\n-   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ deallocating while item is protected: [Unique for <TAG> (call ID)]\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ deallocating while item [Unique for <TAG>] is protected by call ID\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information"}, {"sha": "9cb2d52bf2e9af989f526599a1043b3c311fd8c6", "filename": "tests/fail/stacked_borrows/deallocate_against_barrier2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/db5a2b97475166626e4c7680844f47f5347e9bc3/tests%2Ffail%2Fstacked_borrows%2Fdeallocate_against_barrier2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db5a2b97475166626e4c7680844f47f5347e9bc3/tests%2Ffail%2Fstacked_borrows%2Fdeallocate_against_barrier2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Fdeallocate_against_barrier2.rs?ref=db5a2b97475166626e4c7680844f47f5347e9bc3", "patch": "@@ -1,4 +1,4 @@\n-//@error-pattern: deallocating while item is protected\n+//@error-pattern: deallocating while item\n use std::marker::PhantomPinned;\n \n pub struct NotUnpin(i32, PhantomPinned);"}, {"sha": "a1a7ce0c6bb681a662c3de52f73ea76c1a53899c", "filename": "tests/fail/stacked_borrows/deallocate_against_barrier2.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/db5a2b97475166626e4c7680844f47f5347e9bc3/tests%2Ffail%2Fstacked_borrows%2Fdeallocate_against_barrier2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/db5a2b97475166626e4c7680844f47f5347e9bc3/tests%2Ffail%2Fstacked_borrows%2Fdeallocate_against_barrier2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Fdeallocate_against_barrier2.stderr?ref=db5a2b97475166626e4c7680844f47f5347e9bc3", "patch": "@@ -1,8 +1,8 @@\n-error: Undefined Behavior: deallocating while item is protected: [SharedReadWrite for <TAG> (call ID)]\n+error: Undefined Behavior: deallocating while item [SharedReadWrite for <TAG>] is protected by call ID\n   --> RUSTLIB/alloc/src/alloc.rs:LL:CC\n    |\n LL |     unsafe { __rust_dealloc(ptr, layout.size(), layout.align()) }\n-   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ deallocating while item is protected: [SharedReadWrite for <TAG> (call ID)]\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ deallocating while item [SharedReadWrite for <TAG>] is protected by call ID\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information"}, {"sha": "42f7b3f8b54bfbb9b192695eb66e9e87d144b1f5", "filename": "tests/fail/stacked_borrows/illegal_write6.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/db5a2b97475166626e4c7680844f47f5347e9bc3/tests%2Ffail%2Fstacked_borrows%2Fillegal_write6.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/db5a2b97475166626e4c7680844f47f5347e9bc3/tests%2Ffail%2Fstacked_borrows%2Fillegal_write6.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Fillegal_write6.stderr?ref=db5a2b97475166626e4c7680844f47f5347e9bc3", "patch": "@@ -1,8 +1,8 @@\n-error: Undefined Behavior: not granting access to tag <TAG> because incompatible item is protected: [Unique for <TAG> (call ID)]\n+error: Undefined Behavior: not granting access to tag <TAG> because incompatible item [Unique for <TAG>] is protected by call ID\n   --> $DIR/illegal_write6.rs:LL:CC\n    |\n LL |     unsafe { *y = 2 };\n-   |              ^^^^^^ not granting access to tag <TAG> because incompatible item is protected: [Unique for <TAG> (call ID)]\n+   |              ^^^^^^ not granting access to tag <TAG> because incompatible item [Unique for <TAG>] is protected by call ID\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information"}, {"sha": "4a1b14e460941dccd2414dc8aaf6efd5519a3d7a", "filename": "tests/fail/stacked_borrows/invalidate_against_barrier1.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/db5a2b97475166626e4c7680844f47f5347e9bc3/tests%2Ffail%2Fstacked_borrows%2Finvalidate_against_barrier1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/db5a2b97475166626e4c7680844f47f5347e9bc3/tests%2Ffail%2Fstacked_borrows%2Finvalidate_against_barrier1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Finvalidate_against_barrier1.stderr?ref=db5a2b97475166626e4c7680844f47f5347e9bc3", "patch": "@@ -1,8 +1,8 @@\n-error: Undefined Behavior: not granting access to tag <TAG> because incompatible item is protected: [Unique for <TAG> (call ID)]\n+error: Undefined Behavior: not granting access to tag <TAG> because incompatible item [Unique for <TAG>] is protected by call ID\n   --> $DIR/invalidate_against_barrier1.rs:LL:CC\n    |\n LL |     let _val = unsafe { *x };\n-   |                         ^^ not granting access to tag <TAG> because incompatible item is protected: [Unique for <TAG> (call ID)]\n+   |                         ^^ not granting access to tag <TAG> because incompatible item [Unique for <TAG>] is protected by call ID\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information"}, {"sha": "c6f158316f51294cee00729f48ff85a0f938b198", "filename": "tests/fail/stacked_borrows/invalidate_against_barrier2.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/db5a2b97475166626e4c7680844f47f5347e9bc3/tests%2Ffail%2Fstacked_borrows%2Finvalidate_against_barrier2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/db5a2b97475166626e4c7680844f47f5347e9bc3/tests%2Ffail%2Fstacked_borrows%2Finvalidate_against_barrier2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Finvalidate_against_barrier2.stderr?ref=db5a2b97475166626e4c7680844f47f5347e9bc3", "patch": "@@ -1,8 +1,8 @@\n-error: Undefined Behavior: not granting access to tag <TAG> because incompatible item is protected: [SharedReadOnly for <TAG> (call ID)]\n+error: Undefined Behavior: not granting access to tag <TAG> because incompatible item [SharedReadOnly for <TAG>] is protected by call ID\n   --> $DIR/invalidate_against_barrier2.rs:LL:CC\n    |\n LL |     unsafe { *x = 0 };\n-   |              ^^^^^^ not granting access to tag <TAG> because incompatible item is protected: [SharedReadOnly for <TAG> (call ID)]\n+   |              ^^^^^^ not granting access to tag <TAG> because incompatible item [SharedReadOnly for <TAG>] is protected by call ID\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information"}, {"sha": "f9cceb761af3e6f2fcee46b164b028f32222bf3b", "filename": "tests/fail/stacked_borrows/newtype_retagging.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/db5a2b97475166626e4c7680844f47f5347e9bc3/tests%2Ffail%2Fstacked_borrows%2Fnewtype_retagging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db5a2b97475166626e4c7680844f47f5347e9bc3/tests%2Ffail%2Fstacked_borrows%2Fnewtype_retagging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Fnewtype_retagging.rs?ref=db5a2b97475166626e4c7680844f47f5347e9bc3", "patch": "@@ -1,5 +1,5 @@\n //@compile-flags: -Zmiri-retag-fields\n-//@error-pattern: incompatible item is protected\n+//@error-pattern: is protected by call\n struct Newtype<'a>(&'a mut i32);\n \n fn dealloc_while_running(_n: Newtype<'_>, dealloc: impl FnOnce()) {"}, {"sha": "d9aebecfda731bbaf883e0be56f47bb58ac7debf", "filename": "tests/fail/stacked_borrows/newtype_retagging.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/db5a2b97475166626e4c7680844f47f5347e9bc3/tests%2Ffail%2Fstacked_borrows%2Fnewtype_retagging.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/db5a2b97475166626e4c7680844f47f5347e9bc3/tests%2Ffail%2Fstacked_borrows%2Fnewtype_retagging.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Fnewtype_retagging.stderr?ref=db5a2b97475166626e4c7680844f47f5347e9bc3", "patch": "@@ -1,8 +1,8 @@\n-error: Undefined Behavior: not granting access to tag <TAG> because incompatible item is protected: [Unique for <TAG> (call ID)]\n+error: Undefined Behavior: not granting access to tag <TAG> because incompatible item [Unique for <TAG>] is protected by call ID\n   --> RUSTLIB/alloc/src/boxed.rs:LL:CC\n    |\n LL |         Box(unsafe { Unique::new_unchecked(raw) }, alloc)\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not granting access to tag <TAG> because incompatible item is protected: [Unique for <TAG> (call ID)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not granting access to tag <TAG> because incompatible item [Unique for <TAG>] is protected by call ID\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information"}]}