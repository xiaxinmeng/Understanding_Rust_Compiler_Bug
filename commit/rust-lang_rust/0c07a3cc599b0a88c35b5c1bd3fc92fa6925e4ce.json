{"sha": "0c07a3cc599b0a88c35b5c1bd3fc92fa6925e4ce", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBjMDdhM2NjNTk5YjBhODhjMzViNWMxYmQzZmM5MmZhNjkyNWU0Y2U=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-03-29T15:05:20Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-03-29T15:05:20Z"}, "message": "Auto merge of #32567 - soltanmm:clean-up, r=nikomatsakis\n\nRefactor s.t. TypeRelation implementors in `infer` don't escape InferCtxt\n\nSome clean-up so that we can go back to the future of #31867 as opposed to #32542.\n\nr? @nikomatsakis", "tree": {"sha": "bc33904a6d5f7386d94085d2ebff20f6ccb62da8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bc33904a6d5f7386d94085d2ebff20f6ccb62da8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0c07a3cc599b0a88c35b5c1bd3fc92fa6925e4ce", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0c07a3cc599b0a88c35b5c1bd3fc92fa6925e4ce", "html_url": "https://github.com/rust-lang/rust/commit/0c07a3cc599b0a88c35b5c1bd3fc92fa6925e4ce", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0c07a3cc599b0a88c35b5c1bd3fc92fa6925e4ce/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "641204a408ecda8494adce213e1d5c65f4220756", "url": "https://api.github.com/repos/rust-lang/rust/commits/641204a408ecda8494adce213e1d5c65f4220756", "html_url": "https://github.com/rust-lang/rust/commit/641204a408ecda8494adce213e1d5c65f4220756"}, {"sha": "8cd0f0cc3a7a6c0f15a9b214cfa5f0744713c178", "url": "https://api.github.com/repos/rust-lang/rust/commits/8cd0f0cc3a7a6c0f15a9b214cfa5f0744713c178", "html_url": "https://github.com/rust-lang/rust/commit/8cd0f0cc3a7a6c0f15a9b214cfa5f0744713c178"}], "stats": {"total": 128, "additions": 56, "deletions": 72}, "files": [{"sha": "725c6d9593cdda9c5cc9055fe99a6301a28af591", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 22, "deletions": 49, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/0c07a3cc599b0a88c35b5c1bd3fc92fa6925e4ce/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c07a3cc599b0a88c35b5c1bd3fc92fa6925e4ce/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=0c07a3cc599b0a88c35b5c1bd3fc92fa6925e4ce", "patch": "@@ -386,33 +386,6 @@ pub fn normalizing_infer_ctxt<'a, 'tcx>(tcx: &'a TyCtxt<'tcx>,\n     infcx\n }\n \n-/// Computes the least upper-bound of `a` and `b`. If this is not possible, reports an error and\n-/// returns ty::err.\n-pub fn common_supertype<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n-                                  origin: TypeOrigin,\n-                                  a_is_expected: bool,\n-                                  a: Ty<'tcx>,\n-                                  b: Ty<'tcx>)\n-                                  -> Ty<'tcx>\n-{\n-    debug!(\"common_supertype({:?}, {:?})\",\n-           a, b);\n-\n-    let trace = TypeTrace {\n-        origin: origin,\n-        values: Types(expected_found(a_is_expected, a, b))\n-    };\n-\n-    let result = cx.commit_if_ok(|_| cx.lub(a_is_expected, trace.clone()).relate(&a, &b));\n-    match result {\n-        Ok(t) => t,\n-        Err(ref err) => {\n-            cx.report_and_explain_type_error(trace, err).emit();\n-            cx.tcx.types.err\n-        }\n-    }\n-}\n-\n pub fn mk_subty<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n                           a_is_expected: bool,\n                           origin: TypeOrigin,\n@@ -434,7 +407,7 @@ pub fn can_mk_subty<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n             origin: TypeOrigin::Misc(codemap::DUMMY_SP),\n             values: Types(expected_found(true, a, b))\n         };\n-        cx.sub(true, trace).relate(&a, &b).map(|_| ())\n+        cx.sub(true, trace, &a, &b).map(|_| ())\n     })\n }\n \n@@ -695,32 +668,32 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                        cause: None}\n     }\n \n-    // public so that it can be used from the rustc_driver unit tests\n-    pub fn equate(&'a self, a_is_expected: bool, trace: TypeTrace<'tcx>)\n-              -> equate::Equate<'a, 'tcx>\n+    pub fn equate<T>(&'a self, a_is_expected: bool, trace: TypeTrace<'tcx>, a: &T, b: &T)\n+        -> RelateResult<'tcx, T>\n+        where T: Relate<'a, 'tcx>\n     {\n-        self.combine_fields(a_is_expected, trace).equate()\n+        self.combine_fields(a_is_expected, trace).equate().relate(a, b)\n     }\n \n-    // public so that it can be used from the rustc_driver unit tests\n-    pub fn sub(&'a self, a_is_expected: bool, trace: TypeTrace<'tcx>)\n-               -> sub::Sub<'a, 'tcx>\n+    pub fn sub<T>(&'a self, a_is_expected: bool, trace: TypeTrace<'tcx>, a: &T, b: &T)\n+        -> RelateResult<'tcx, T>\n+        where T: Relate<'a, 'tcx>\n     {\n-        self.combine_fields(a_is_expected, trace).sub()\n+        self.combine_fields(a_is_expected, trace).sub().relate(a, b)\n     }\n \n-    // public so that it can be used from the rustc_driver unit tests\n-    pub fn lub(&'a self, a_is_expected: bool, trace: TypeTrace<'tcx>)\n-               -> lub::Lub<'a, 'tcx>\n+    pub fn lub<T>(&'a self, a_is_expected: bool, trace: TypeTrace<'tcx>, a: &T, b: &T)\n+        -> RelateResult<'tcx, T>\n+        where T: Relate<'a, 'tcx>\n     {\n-        self.combine_fields(a_is_expected, trace).lub()\n+        self.combine_fields(a_is_expected, trace).lub().relate(a, b)\n     }\n \n-    // public so that it can be used from the rustc_driver unit tests\n-    pub fn glb(&'a self, a_is_expected: bool, trace: TypeTrace<'tcx>)\n-               -> glb::Glb<'a, 'tcx>\n+    pub fn glb<T>(&'a self, a_is_expected: bool, trace: TypeTrace<'tcx>, a: &T, b: &T)\n+        -> RelateResult<'tcx, T>\n+        where T: Relate<'a, 'tcx>\n     {\n-        self.combine_fields(a_is_expected, trace).glb()\n+        self.combine_fields(a_is_expected, trace).glb().relate(a, b)\n     }\n \n     fn start_snapshot(&self) -> CombinedSnapshot {\n@@ -861,7 +834,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         debug!(\"sub_types({:?} <: {:?})\", a, b);\n         self.commit_if_ok(|_| {\n             let trace = TypeTrace::types(origin, a_is_expected, a, b);\n-            self.sub(a_is_expected, trace).relate(&a, &b).map(|_| ())\n+            self.sub(a_is_expected, trace, &a, &b).map(|_| ())\n         })\n     }\n \n@@ -874,7 +847,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     {\n         self.commit_if_ok(|_| {\n             let trace = TypeTrace::types(origin, a_is_expected, a, b);\n-            self.equate(a_is_expected, trace).relate(&a, &b).map(|_| ())\n+            self.equate(a_is_expected, trace, &a, &b).map(|_| ())\n         })\n     }\n \n@@ -893,7 +866,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 origin: origin,\n                 values: TraitRefs(expected_found(a_is_expected, a.clone(), b.clone()))\n             };\n-            self.equate(a_is_expected, trace).relate(&a, &b).map(|_| ())\n+            self.equate(a_is_expected, trace, &a, &b).map(|_| ())\n         })\n     }\n \n@@ -912,7 +885,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 origin: origin,\n                 values: PolyTraitRefs(expected_found(a_is_expected, a.clone(), b.clone()))\n             };\n-            self.sub(a_is_expected, trace).relate(&a, &b).map(|_| ())\n+            self.sub(a_is_expected, trace, &a, &b).map(|_| ())\n         })\n     }\n \n@@ -1461,7 +1434,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 origin: TypeOrigin::Misc(codemap::DUMMY_SP),\n                 values: Types(expected_found(true, e, e))\n             };\n-            self.equate(true, trace).relate(a, b)\n+            self.equate(true, trace, a, b)\n         }).map(|_| ())\n     }\n "}, {"sha": "635af0a98e246c50a7f3bc451dec055093545f47", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0c07a3cc599b0a88c35b5c1bd3fc92fa6925e4ce/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c07a3cc599b0a88c35b5c1bd3fc92fa6925e4ce/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=0c07a3cc599b0a88c35b5c1bd3fc92fa6925e4ce", "patch": "@@ -602,6 +602,17 @@ impl<'a,'tcx:'a> Relate<'a,'tcx> for ty::ClosureSubsts<'tcx> {\n     }\n }\n \n+impl<'a,'tcx:'a> Relate<'a,'tcx> for Substs<'tcx> {\n+    fn relate<R>(relation: &mut R,\n+                 a: &Substs<'tcx>,\n+                 b: &Substs<'tcx>)\n+                 -> RelateResult<'tcx, Substs<'tcx>>\n+        where R: TypeRelation<'a,'tcx>\n+    {\n+        relate_substs(relation, None, a, b)\n+    }\n+}\n+\n impl<'a,'tcx:'a> Relate<'a,'tcx> for ty::Region {\n     fn relate<R>(relation: &mut R,\n                  a: &ty::Region,"}, {"sha": "6ce623a3b28926c70774ff9c4d703239e9ca7899", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 11, "deletions": 14, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/0c07a3cc599b0a88c35b5c1bd3fc92fa6925e4ce/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c07a3cc599b0a88c35b5c1bd3fc92fa6925e4ce/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=0c07a3cc599b0a88c35b5c1bd3fc92fa6925e4ce", "patch": "@@ -24,11 +24,8 @@ use rustc::ty::subst;\n use rustc::ty::subst::Subst;\n use rustc::traits::ProjectionMode;\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n-use rustc::ty::relate::TypeRelation;\n+use rustc::ty::relate::{TypeRelation, RelateResult};\n use rustc::infer::{self, TypeOrigin};\n-use rustc::infer::lub::Lub;\n-use rustc::infer::glb::Glb;\n-use rustc::infer::sub::Sub;\n use rustc_metadata::cstore::CStore;\n use rustc::front::map as hir_map;\n use rustc::session::{self, config};\n@@ -358,25 +355,25 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n         infer::TypeTrace::dummy(self.tcx())\n     }\n \n-    pub fn sub(&self) -> Sub<'a, 'tcx> {\n+    pub fn sub(&self, t1: &Ty<'tcx>, t2: &Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n         let trace = self.dummy_type_trace();\n-        self.infcx.sub(true, trace)\n+        self.infcx.sub(true, trace, t1, t2)\n     }\n \n-    pub fn lub(&self) -> Lub<'a, 'tcx> {\n+    pub fn lub(&self, t1: &Ty<'tcx>, t2: &Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n         let trace = self.dummy_type_trace();\n-        self.infcx.lub(true, trace)\n+        self.infcx.lub(true, trace, t1, t2)\n     }\n \n-    pub fn glb(&self) -> Glb<'a, 'tcx> {\n+    pub fn glb(&self, t1: &Ty<'tcx>, t2: &Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n         let trace = self.dummy_type_trace();\n-        self.infcx.glb(true, trace)\n+        self.infcx.glb(true, trace, t1, t2)\n     }\n \n     /// Checks that `t1 <: t2` is true (this may register additional\n     /// region checks).\n     pub fn check_sub(&self, t1: Ty<'tcx>, t2: Ty<'tcx>) {\n-        match self.sub().relate(&t1, &t2) {\n+        match self.sub(&t1, &t2) {\n             Ok(_) => {}\n             Err(ref e) => {\n                 panic!(\"unexpected error computing sub({:?},{:?}): {}\", t1, t2, e);\n@@ -387,7 +384,7 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n     /// Checks that `t1 <: t2` is false (this may register additional\n     /// region checks).\n     pub fn check_not_sub(&self, t1: Ty<'tcx>, t2: Ty<'tcx>) {\n-        match self.sub().relate(&t1, &t2) {\n+        match self.sub(&t1, &t2) {\n             Err(_) => {}\n             Ok(_) => {\n                 panic!(\"unexpected success computing sub({:?},{:?})\", t1, t2);\n@@ -397,7 +394,7 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n \n     /// Checks that `LUB(t1,t2) == t_lub`\n     pub fn check_lub(&self, t1: Ty<'tcx>, t2: Ty<'tcx>, t_lub: Ty<'tcx>) {\n-        match self.lub().relate(&t1, &t2) {\n+        match self.lub(&t1, &t2) {\n             Ok(t) => {\n                 self.assert_eq(t, t_lub);\n             }\n@@ -410,7 +407,7 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n     /// Checks that `GLB(t1,t2) == t_glb`\n     pub fn check_glb(&self, t1: Ty<'tcx>, t2: Ty<'tcx>, t_glb: Ty<'tcx>) {\n         debug!(\"check_glb(t1={}, t2={}, t_glb={})\", t1, t2, t_glb);\n-        match self.glb().relate(&t1, &t2) {\n+        match self.glb(&t1, &t2) {\n             Err(e) => {\n                 panic!(\"unexpected error computing LUB: {:?}\", e)\n             }"}, {"sha": "e36da1a568a7d2300427bb58d01d6dba81b6ce64", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/0c07a3cc599b0a88c35b5c1bd3fc92fa6925e4ce/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c07a3cc599b0a88c35b5c1bd3fc92fa6925e4ce/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=0c07a3cc599b0a88c35b5c1bd3fc92fa6925e4ce", "patch": "@@ -71,7 +71,7 @@ use rustc::ty::adjustment::{AdjustUnsafeFnPointer, AdjustMutToConstPointer};\n use rustc::ty::{self, LvaluePreference, TypeAndMut, Ty, TyCtxt};\n use rustc::ty::fold::TypeFoldable;\n use rustc::ty::error::TypeError;\n-use rustc::ty::relate::{relate_substs, Relate, RelateResult, TypeRelation};\n+use rustc::ty::relate::{RelateResult, TypeRelation};\n use util::common::indent;\n \n use std::cell::RefCell;\n@@ -117,9 +117,9 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         infcx.commit_if_ok(|_| {\n             let trace = TypeTrace::types(self.origin, false, a, b);\n             if self.use_lub {\n-                infcx.lub(false, trace).relate(&a, &b)\n+                infcx.lub(false, trace, &a, &b)\n             } else {\n-                infcx.sub(false, trace).relate(&a, &b)\n+                infcx.sub(false, trace, &a, &b)\n             }\n         })\n     }\n@@ -649,20 +649,19 @@ pub fn try_find_lub<'a, 'b, 'tcx, E, I>(fcx: &FnCtxt<'a, 'tcx>,\n     debug!(\"coercion::try_find_lub({:?}, {:?})\", prev_ty, new_ty);\n \n     let trace = TypeTrace::types(origin, true, prev_ty, new_ty);\n-    let mut lub = fcx.infcx().lub(true, trace);\n \n     // Special-case that coercion alone cannot handle:\n     // Two function item types of differing IDs or Substs.\n     match (&prev_ty.sty, &new_ty.sty) {\n         (&ty::TyFnDef(a_def_id, a_substs, a_fty),\n          &ty::TyFnDef(b_def_id, b_substs, b_fty)) => {\n             // The signature must always match.\n-            let fty = lub.relate(a_fty, b_fty)?;\n+            let fty = fcx.infcx().lub(true, trace.clone(), a_fty, b_fty)?;\n \n             if a_def_id == b_def_id {\n                 // Same function, maybe the parameters match.\n                 let substs = fcx.infcx().commit_if_ok(|_| {\n-                    relate_substs(&mut lub, None, a_substs, b_substs)\n+                    fcx.infcx().lub(true, trace.clone(), a_substs, b_substs)\n                 }).map(|s| fcx.tcx().mk_substs(s));\n \n                 if let Ok(substs) = substs {\n@@ -724,7 +723,9 @@ pub fn try_find_lub<'a, 'b, 'tcx, E, I>(fcx: &FnCtxt<'a, 'tcx>,\n         };\n \n         if !noop {\n-            return fcx.infcx().commit_if_ok(|_| lub.relate(&prev_ty, &new_ty));\n+            return fcx.infcx().commit_if_ok(|_| {\n+                fcx.infcx().lub(true, trace.clone(), &prev_ty, &new_ty)\n+            });\n         }\n     }\n \n@@ -734,7 +735,9 @@ pub fn try_find_lub<'a, 'b, 'tcx, E, I>(fcx: &FnCtxt<'a, 'tcx>,\n             if let Some(e) = first_error {\n                 Err(e)\n             } else {\n-                fcx.infcx().commit_if_ok(|_| lub.relate(&prev_ty, &new_ty))\n+                fcx.infcx().commit_if_ok(|_| {\n+                    fcx.infcx().lub(true, trace, &prev_ty, &new_ty)\n+                })\n             }\n         }\n         Ok((ty, adjustment)) => {"}, {"sha": "107497a2aa3673735e91e27277501dee6b74cf10", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c07a3cc599b0a88c35b5c1bd3fc92fa6925e4ce/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c07a3cc599b0a88c35b5c1bd3fc92fa6925e4ce/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=0c07a3cc599b0a88c35b5c1bd3fc92fa6925e4ce", "patch": "@@ -2904,7 +2904,7 @@ fn check_expr_with_expectation_and_lvalue_pref<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             } else {\n                 fcx.infcx().commit_if_ok(|_| {\n                     let trace = TypeTrace::types(origin, true, then_ty, else_ty);\n-                    fcx.infcx().lub(true, trace).relate(&then_ty, &else_ty)\n+                    fcx.infcx().lub(true, trace, &then_ty, &else_ty)\n                 })\n             };\n             (origin, then_ty, else_ty, result)"}]}