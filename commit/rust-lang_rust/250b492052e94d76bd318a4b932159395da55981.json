{"sha": "250b492052e94d76bd318a4b932159395da55981", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI1MGI0OTIwNTJlOTRkNzZiZDMxOGE0YjkzMjE1OTM5NWRhNTU5ODE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-12-21T20:12:13Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-12-21T20:12:13Z"}, "message": "Auto merge of #45930 - jplatte:generics_refactoring, r=eddyb\n\nGenerics refactoring (groundwork for const generics)\n\nThese changes were suggested by @eddyb.\n\nAfter this change, the `Generics` contain one `Vec` of an enum for the generic parameters, rather than two separate `Vec`s for lifetime and type parameters. Type params and const params will need to be in a shared `Vec` to preserve their ordering, and moving lifetimes into the same `Vec` should simplify the code that processes `Generics`.", "tree": {"sha": "aadee204c60a58ef29eb6ea544c84281727567d4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aadee204c60a58ef29eb6ea544c84281727567d4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/250b492052e94d76bd318a4b932159395da55981", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/250b492052e94d76bd318a4b932159395da55981", "html_url": "https://github.com/rust-lang/rust/commit/250b492052e94d76bd318a4b932159395da55981", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/250b492052e94d76bd318a4b932159395da55981/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b7b52cc8bf2bcc4cbd223a4b61fe3e35e798f6e2", "url": "https://api.github.com/repos/rust-lang/rust/commits/b7b52cc8bf2bcc4cbd223a4b61fe3e35e798f6e2", "html_url": "https://github.com/rust-lang/rust/commit/b7b52cc8bf2bcc4cbd223a4b61fe3e35e798f6e2"}, {"sha": "78493ed21aaeb20a8d5f7bd08f26c0c9fd496ed4", "url": "https://api.github.com/repos/rust-lang/rust/commits/78493ed21aaeb20a8d5f7bd08f26c0c9fd496ed4", "html_url": "https://github.com/rust-lang/rust/commit/78493ed21aaeb20a8d5f7bd08f26c0c9fd496ed4"}], "stats": {"total": 1860, "additions": 1024, "deletions": 836}, "files": [{"sha": "74714edfc86461b8b8a08a8cafe05a3d5f819ca7", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 23, "deletions": 19, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/250b492052e94d76bd318a4b932159395da55981/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/250b492052e94d76bd318a4b932159395da55981/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=250b492052e94d76bd318a4b932159395da55981", "patch": "@@ -279,6 +279,9 @@ pub trait Visitor<'v> : Sized {\n     fn visit_ty(&mut self, t: &'v Ty) {\n         walk_ty(self, t)\n     }\n+    fn visit_generic_param(&mut self, p: &'v GenericParam) {\n+        walk_generic_param(self, p)\n+    }\n     fn visit_generics(&mut self, g: &'v Generics) {\n         walk_generics(self, g)\n     }\n@@ -336,9 +339,6 @@ pub trait Visitor<'v> : Sized {\n     fn visit_lifetime(&mut self, lifetime: &'v Lifetime) {\n         walk_lifetime(self, lifetime)\n     }\n-    fn visit_lifetime_def(&mut self, lifetime: &'v LifetimeDef) {\n-        walk_lifetime_def(self, lifetime)\n-    }\n     fn visit_qpath(&mut self, qpath: &'v QPath, id: NodeId, span: Span) {\n         walk_qpath(self, qpath, id, span)\n     }\n@@ -430,17 +430,12 @@ pub fn walk_lifetime<'v, V: Visitor<'v>>(visitor: &mut V, lifetime: &'v Lifetime\n     }\n }\n \n-pub fn walk_lifetime_def<'v, V: Visitor<'v>>(visitor: &mut V, lifetime_def: &'v LifetimeDef) {\n-    visitor.visit_lifetime(&lifetime_def.lifetime);\n-    walk_list!(visitor, visit_lifetime, &lifetime_def.bounds);\n-}\n-\n pub fn walk_poly_trait_ref<'v, V>(visitor: &mut V,\n                                   trait_ref: &'v PolyTraitRef,\n                                   _modifier: TraitBoundModifier)\n     where V: Visitor<'v>\n {\n-    walk_list!(visitor, visit_lifetime_def, &trait_ref.bound_lifetimes);\n+    walk_list!(visitor, visit_generic_param, &trait_ref.bound_generic_params);\n     visitor.visit_trait_ref(&trait_ref.trait_ref);\n }\n \n@@ -581,7 +576,7 @@ pub fn walk_ty<'v, V: Visitor<'v>>(visitor: &mut V, typ: &'v Ty) {\n         }\n         TyBareFn(ref function_declaration) => {\n             visitor.visit_fn_decl(&function_declaration.decl);\n-            walk_list!(visitor, visit_lifetime_def, &function_declaration.lifetimes);\n+            walk_list!(visitor, visit_generic_param, &function_declaration.generic_params);\n         }\n         TyPath(ref qpath) => {\n             visitor.visit_qpath(qpath, typ.id, typ.span);\n@@ -729,14 +724,23 @@ pub fn walk_ty_param_bound<'v, V: Visitor<'v>>(visitor: &mut V, bound: &'v TyPar\n     }\n }\n \n-pub fn walk_generics<'v, V: Visitor<'v>>(visitor: &mut V, generics: &'v Generics) {\n-    for param in &generics.ty_params {\n-        visitor.visit_id(param.id);\n-        visitor.visit_name(param.span, param.name);\n-        walk_list!(visitor, visit_ty_param_bound, &param.bounds);\n-        walk_list!(visitor, visit_ty, &param.default);\n+pub fn walk_generic_param<'v, V: Visitor<'v>>(visitor: &mut V, param: &'v GenericParam) {\n+    match *param {\n+        GenericParam::Lifetime(ref ld) => {\n+            visitor.visit_lifetime(&ld.lifetime);\n+            walk_list!(visitor, visit_lifetime, &ld.bounds);\n+        }\n+        GenericParam::Type(ref ty_param) => {\n+            visitor.visit_id(ty_param.id);\n+            visitor.visit_name(ty_param.span, ty_param.name);\n+            walk_list!(visitor, visit_ty_param_bound, &ty_param.bounds);\n+            walk_list!(visitor, visit_ty, &ty_param.default);\n+        }\n     }\n-    walk_list!(visitor, visit_lifetime_def, &generics.lifetimes);\n+}\n+\n+pub fn walk_generics<'v, V: Visitor<'v>>(visitor: &mut V, generics: &'v Generics) {\n+    walk_list!(visitor, visit_generic_param, &generics.params);\n     visitor.visit_id(generics.where_clause.id);\n     walk_list!(visitor, visit_where_predicate, &generics.where_clause.predicates);\n }\n@@ -748,11 +752,11 @@ pub fn walk_where_predicate<'v, V: Visitor<'v>>(\n     match predicate {\n         &WherePredicate::BoundPredicate(WhereBoundPredicate{ref bounded_ty,\n                                                             ref bounds,\n-                                                            ref bound_lifetimes,\n+                                                            ref bound_generic_params,\n                                                             ..}) => {\n             visitor.visit_ty(bounded_ty);\n             walk_list!(visitor, visit_ty_param_bound, bounds);\n-            walk_list!(visitor, visit_lifetime_def, bound_lifetimes);\n+            walk_list!(visitor, visit_generic_param, bound_generic_params);\n         }\n         &WherePredicate::RegionPredicate(WhereRegionPredicate{ref lifetime,\n                                                               ref bounds,"}, {"sha": "22e661a876ec2101fc449e9d5d956e307915b27a", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 139, "deletions": 90, "changes": 229, "blob_url": "https://github.com/rust-lang/rust/blob/250b492052e94d76bd318a4b932159395da55981/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/250b492052e94d76bd318a4b932159395da55981/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=250b492052e94d76bd318a4b932159395da55981", "patch": "@@ -253,7 +253,9 @@ impl<'a> LoweringContext<'a> {\n                     ItemKind::Ty(_, ref generics) |\n                     ItemKind::Trait(_, _, ref generics, ..) => {\n                         let def_id = self.lctx.resolver.definitions().local_def_id(item.id);\n-                        let count = generics.lifetimes.len();\n+                        let count = generics.params.iter()\n+                            .filter(|param| param.is_lifetime_param())\n+                            .count();\n                         self.lctx.type_def_lifetime_params.insert(def_id, count);\n                     }\n                     _ => {}\n@@ -306,8 +308,8 @@ impl<'a> LoweringContext<'a> {\n                     let item_lifetimes = match self.lctx.items.get(&item.id).unwrap().node {\n                         hir::Item_::ItemImpl(_,_,_,ref generics,..) |\n                         hir::Item_::ItemTrait(_,_,ref generics,..) =>\n-                            generics.lifetimes.clone(),\n-                        _ => Vec::new().into(),\n+                            generics.lifetimes().cloned().collect::<Vec<_>>(),\n+                        _ => Vec::new(),\n                     };\n \n                     self.lctx.with_parent_impl_lifetime_defs(&item_lifetimes, |this| {\n@@ -532,14 +534,14 @@ impl<'a> LoweringContext<'a> {\n         span.with_ctxt(SyntaxContext::empty().apply_mark(mark))\n     }\n \n-    // Creates a new hir::LifetimeDef for every new lifetime encountered\n-    // while evaluating `f`. Definitions are created with the parent provided.\n-    // If no `parent_id` is provided, no definitions will be returned.\n+    // Creates a new hir::GenericParam for every new lifetime and type parameter\n+    // encountered while evaluating `f`. Definitions are created with the parent\n+    // provided. If no `parent_id` is provided, no definitions will be returned.\n     fn collect_in_band_defs<T, F>(\n         &mut self,\n         parent_id: Option<DefId>,\n         f: F\n-    ) -> (Vec<hir::TyParam>, Vec<hir::LifetimeDef>, T) where F: FnOnce(&mut LoweringContext) -> T\n+    ) -> (Vec<hir::GenericParam>, T) where F: FnOnce(&mut LoweringContext) -> T\n     {\n         assert!(!self.is_collecting_in_band_lifetimes);\n         assert!(self.lifetimes_to_define.is_empty());\n@@ -554,7 +556,7 @@ impl<'a> LoweringContext<'a> {\n         let in_band_ty_params = self.in_band_ty_params.split_off(0);\n         let lifetimes_to_define = self.lifetimes_to_define.split_off(0);\n \n-        let lifetime_defs = match parent_id {\n+        let mut params = match parent_id {\n             Some(parent_id) => lifetimes_to_define.into_iter().map(|(span, name)| {\n                     let def_node_id = self.next_id().node_id;\n \n@@ -567,7 +569,7 @@ impl<'a> LoweringContext<'a> {\n                         Mark::root()\n                     );\n \n-                    hir::LifetimeDef {\n+                    hir::GenericParam::Lifetime(hir::LifetimeDef {\n                         lifetime: hir::Lifetime {\n                             id: def_node_id,\n                             span,\n@@ -576,12 +578,14 @@ impl<'a> LoweringContext<'a> {\n                         bounds: Vec::new().into(),\n                         pure_wrt_drop: false,\n                         in_band: true,\n-                    }\n+                    })\n                 }).collect(),\n             None => Vec::new(),\n         };\n \n-        (in_band_ty_params, lifetime_defs, res)\n+        params.extend(in_band_ty_params.into_iter().map(|tp| hir::GenericParam::Type(tp)));\n+\n+        (params, res)\n     }\n \n     // Evaluates `f` with the lifetimes in `lt_defs` in-scope.\n@@ -635,24 +639,24 @@ impl<'a> LoweringContext<'a> {\n     ) -> (hir::Generics, T)\n         where F: FnOnce(&mut LoweringContext) -> T\n     {\n-        let (in_band_ty_defs, in_band_lifetime_defs, (mut lowered_generics, res)) =\n-            self.with_in_scope_lifetime_defs(&generics.lifetimes, |this| {\n-                this.collect_in_band_defs(parent_id, |this| {\n-                    (this.lower_generics(generics), f(this))\n-                })\n-            });\n-\n-        lowered_generics.ty_params =\n-            lowered_generics.ty_params\n-                .iter().cloned()\n-                .chain(in_band_ty_defs.into_iter())\n-                .collect();\n+        let (in_band_defs, (mut lowered_generics, res)) =\n+            self.with_in_scope_lifetime_defs(\n+                &generics.params\n+                    .iter()\n+                    .filter_map(|p| match *p {\n+                        GenericParam::Lifetime(ref ld) => Some(ld.clone()),\n+                        _ => None,\n+                    })\n+                    .collect::<Vec<_>>(),\n+                |this| {\n+                    this.collect_in_band_defs(parent_id, |this| {\n+                        (this.lower_generics(generics), f(this))\n+                    })\n+                }\n+            );\n \n-        lowered_generics.lifetimes =\n-            lowered_generics.lifetimes\n-                .iter().cloned()\n-               .chain(in_band_lifetime_defs.into_iter())\n-               .collect();\n+        lowered_generics.params =\n+            lowered_generics.params.iter().cloned().chain(in_band_defs).collect();\n \n         (lowered_generics, res)\n     }\n@@ -877,9 +881,16 @@ impl<'a> LoweringContext<'a> {\n                 hir::TyRptr(lifetime, self.lower_mt(mt, itctx))\n             }\n             TyKind::BareFn(ref f) => {\n-                self.with_in_scope_lifetime_defs(&f.lifetimes, |this|\n-                    hir::TyBareFn(P(hir::BareFnTy {\n-                        lifetimes: this.lower_lifetime_defs(&f.lifetimes),\n+                self.with_in_scope_lifetime_defs(\n+                    &f.generic_params\n+                        .iter()\n+                        .filter_map(|p| match *p {\n+                            GenericParam::Lifetime(ref ld) => Some(ld.clone()),\n+                            _ => None,\n+                        })\n+                        .collect::<Vec<_>>(),\n+                    |this| hir::TyBareFn(P(hir::BareFnTy {\n+                        generic_params: this.lower_generic_params(&f.generic_params, &NodeMap()),\n                         unsafety: this.lower_unsafety(f.unsafety),\n                         abi: f.abi,\n                         decl: this.lower_fn_decl(&f.decl, None, false),\n@@ -954,9 +965,7 @@ impl<'a> LoweringContext<'a> {\n \n                         hir::TyImplTraitExistential(hir::ExistTy {\n                             generics: hir::Generics {\n-                                lifetimes: lifetime_defs,\n-                                // Type parameters are taken from environment:\n-                                ty_params: Vec::new().into(),\n+                                params: lifetime_defs,\n                                 where_clause: hir::WhereClause {\n                                     id: self.next_id().node_id,\n                                     predicates: Vec::new().into(),\n@@ -1027,7 +1036,7 @@ impl<'a> LoweringContext<'a> {\n         &mut self,\n         parent_index: DefIndex,\n         bounds: &hir::TyParamBounds\n-    ) -> (HirVec<hir::Lifetime>, HirVec<hir::LifetimeDef>) {\n+    ) -> (HirVec<hir::Lifetime>, HirVec<hir::GenericParam>) {\n \n         // This visitor walks over impl trait bounds and creates defs for all lifetimes which\n         // appear in the bounds, excluding lifetimes that are created within the bounds.\n@@ -1039,7 +1048,7 @@ impl<'a> LoweringContext<'a> {\n             currently_bound_lifetimes: Vec<hir::LifetimeName>,\n             already_defined_lifetimes: HashSet<hir::LifetimeName>,\n             output_lifetimes: Vec<hir::Lifetime>,\n-            output_lifetime_defs: Vec<hir::LifetimeDef>,\n+            output_lifetime_params: Vec<hir::GenericParam>,\n         }\n \n         impl<'r, 'a: 'r, 'v> hir::intravisit::Visitor<'v> for ImplTraitLifetimeCollector<'r, 'a> {\n@@ -1078,14 +1087,16 @@ impl<'a> LoweringContext<'a> {\n                 let old_len = self.currently_bound_lifetimes.len();\n \n                 // Record the introduction of 'a in `for<'a> ...`\n-                for lt_def in &polytr.bound_lifetimes {\n-                    // Introduce lifetimes one at a time so that we can handle\n-                    // cases like `fn foo<'d>() -> impl for<'a, 'b: 'a, 'c: 'b + 'd>`\n-                    self.currently_bound_lifetimes.push(lt_def.lifetime.name);\n-\n-                    // Visit the lifetime bounds\n-                    for lt_bound in &lt_def.bounds {\n-                        self.visit_lifetime(&lt_bound);\n+                for param in &polytr.bound_generic_params {\n+                    if let hir::GenericParam::Lifetime(ref lt_def) = *param {\n+                        // Introduce lifetimes one at a time so that we can handle\n+                        // cases like `fn foo<'d>() -> impl for<'a, 'b: 'a, 'c: 'b + 'd>`\n+                        self.currently_bound_lifetimes.push(lt_def.lifetime.name);\n+\n+                        // Visit the lifetime bounds\n+                        for lt_bound in &lt_def.bounds {\n+                            self.visit_lifetime(&lt_bound);\n+                        }\n                     }\n                 }\n \n@@ -1133,12 +1144,12 @@ impl<'a> LoweringContext<'a> {\n                         span: lifetime.span,\n                         name: name,\n                     };\n-                    self.output_lifetime_defs.push(hir::LifetimeDef {\n+                    self.output_lifetime_params.push(hir::GenericParam::Lifetime(hir::LifetimeDef {\n                         lifetime: def_lifetime,\n                         bounds: Vec::new().into(),\n                         pure_wrt_drop: false,\n                         in_band: false,\n-                    });\n+                    }));\n                 }\n             }\n         }\n@@ -1150,7 +1161,7 @@ impl<'a> LoweringContext<'a> {\n             currently_bound_lifetimes: Vec::new(),\n             already_defined_lifetimes: HashSet::new(),\n             output_lifetimes: Vec::new(),\n-            output_lifetime_defs: Vec::new(),\n+            output_lifetime_params: Vec::new(),\n         };\n \n         for bound in bounds {\n@@ -1159,7 +1170,7 @@ impl<'a> LoweringContext<'a> {\n \n         (\n             lifetime_collector.output_lifetimes.into(),\n-            lifetime_collector.output_lifetime_defs.into()\n+            lifetime_collector.output_lifetime_params.into()\n         )\n     }\n \n@@ -1568,13 +1579,6 @@ impl<'a> LoweringContext<'a> {\n         }\n     }\n \n-    fn lower_ty_params(&mut self, tps: &Vec<TyParam>, add_bounds: &NodeMap<Vec<TyParamBound>>)\n-                       -> hir::HirVec<hir::TyParam> {\n-        tps.iter().map(|tp| {\n-            self.lower_ty_param(tp, add_bounds.get(&tp.id).map_or(&[][..], |x| &x))\n-        }).collect()\n-    }\n-\n     fn lower_lifetime(&mut self, l: &Lifetime) -> hir::Lifetime {\n         let name = match self.lower_ident(l.ident) {\n             x if x == \"'_\" => hir::LifetimeName::Underscore,\n@@ -1620,12 +1624,31 @@ impl<'a> LoweringContext<'a> {\n         lts.iter().map(|l| self.lower_lifetime(l)).collect()\n     }\n \n-    fn lower_lifetime_defs(&mut self, lts: &Vec<LifetimeDef>) -> hir::HirVec<hir::LifetimeDef> {\n-        lts.iter().map(|l| self.lower_lifetime_def(l)).collect()\n+    fn lower_generic_params(\n+        &mut self,\n+        params: &Vec<GenericParam>,\n+        add_bounds: &NodeMap<Vec<TyParamBound>>,\n+    ) -> hir::HirVec<hir::GenericParam> {\n+        params.iter()\n+            .map(|param| match *param {\n+                GenericParam::Lifetime(ref lifetime_def) => {\n+                    hir::GenericParam::Lifetime(self.lower_lifetime_def(lifetime_def))\n+                }\n+                GenericParam::Type(ref ty_param) => {\n+                    hir::GenericParam::Type(self.lower_ty_param(\n+                        ty_param,\n+                        add_bounds.get(&ty_param.id).map_or(&[][..], |x| &x)\n+                    ))\n+                }\n+            })\n+            .collect()\n     }\n \n     fn lower_generics(&mut self, g: &Generics) -> hir::Generics {\n         // Collect `?Trait` bounds in where clause and move them to parameter definitions.\n+        // FIXME: This could probably be done with less rightward drift. Also looks like two control\n+        //        paths where report_error is called are also the only paths that advance to after\n+        //        the match statement, so the error reporting could probably just be moved there.\n         let mut add_bounds = NodeMap();\n         for pred in &g.where_clause.predicates {\n             if let WherePredicate::BoundPredicate(ref bound_pred) = *pred {\n@@ -1640,17 +1663,20 @@ impl<'a> LoweringContext<'a> {\n                         match bound_pred.bounded_ty.node {\n                             TyKind::Path(None, ref path)\n                                     if path.segments.len() == 1 &&\n-                                       bound_pred.bound_lifetimes.is_empty() => {\n+                                       bound_pred.bound_generic_params.is_empty() => {\n                                 if let Some(Def::TyParam(def_id)) =\n                                         self.resolver.get_resolution(bound_pred.bounded_ty.id)\n                                                      .map(|d| d.base_def()) {\n                                     if let Some(node_id) =\n                                             self.resolver.definitions().as_local_node_id(def_id) {\n-                                        for ty_param in &g.ty_params {\n-                                            if node_id == ty_param.id {\n-                                                add_bounds.entry(ty_param.id).or_insert(Vec::new())\n-                                                                            .push(bound.clone());\n-                                                continue 'next_bound;\n+                                        for param in &g.params {\n+                                            if let GenericParam::Type(ref ty_param) = *param {\n+                                                if node_id == ty_param.id {\n+                                                    add_bounds.entry(ty_param.id)\n+                                                        .or_insert(Vec::new())\n+                                                        .push(bound.clone());\n+                                                    continue 'next_bound;\n+                                                }\n                                             }\n                                         }\n                                     }\n@@ -1665,8 +1691,7 @@ impl<'a> LoweringContext<'a> {\n         }\n \n         hir::Generics {\n-            ty_params: self.lower_ty_params(&g.ty_params, &add_bounds),\n-            lifetimes: self.lower_lifetime_defs(&g.lifetimes),\n+            params: self.lower_generic_params(&g.params, &add_bounds),\n             where_clause: self.lower_where_clause(&g.where_clause),\n             span: g.span,\n         }\n@@ -1684,24 +1709,33 @@ impl<'a> LoweringContext<'a> {\n \n     fn lower_where_predicate(&mut self, pred: &WherePredicate) -> hir::WherePredicate {\n         match *pred {\n-            WherePredicate::BoundPredicate(WhereBoundPredicate{ ref bound_lifetimes,\n+            WherePredicate::BoundPredicate(WhereBoundPredicate{ ref bound_generic_params,\n                                                                 ref bounded_ty,\n                                                                 ref bounds,\n                                                                 span}) => {\n-                self.with_in_scope_lifetime_defs(bound_lifetimes, |this| {\n-                    hir::WherePredicate::BoundPredicate(hir::WhereBoundPredicate {\n-                        bound_lifetimes: this.lower_lifetime_defs(bound_lifetimes),\n-                        bounded_ty: this.lower_ty(bounded_ty, ImplTraitContext::Disallowed),\n-                        bounds: bounds.iter().filter_map(|bound| match *bound {\n-                            // Ignore `?Trait` bounds.\n-                            // Tthey were copied into type parameters already.\n-                            TraitTyParamBound(_, TraitBoundModifier::Maybe) => None,\n-                            _ => Some(this.lower_ty_param_bound(\n-                                    bound, ImplTraitContext::Disallowed))\n-                        }).collect(),\n-                        span,\n-                    })\n-                })\n+                self.with_in_scope_lifetime_defs(\n+                    &bound_generic_params.iter()\n+                        .filter_map(|p| match *p {\n+                            GenericParam::Lifetime(ref ld) => Some(ld.clone()),\n+                            _ => None,\n+                        })\n+                        .collect::<Vec<_>>(),\n+                    |this| {\n+                        hir::WherePredicate::BoundPredicate(hir::WhereBoundPredicate {\n+                            bound_generic_params:\n+                                this.lower_generic_params(bound_generic_params, &NodeMap()),\n+                            bounded_ty: this.lower_ty(bounded_ty, ImplTraitContext::Disallowed),\n+                            bounds: bounds.iter().filter_map(|bound| match *bound {\n+                                // Ignore `?Trait` bounds.\n+                                // Tthey were copied into type parameters already.\n+                                TraitTyParamBound(_, TraitBoundModifier::Maybe) => None,\n+                                _ => Some(this.lower_ty_param_bound(\n+                                        bound, ImplTraitContext::Disallowed))\n+                            }).collect(),\n+                            span,\n+                        })\n+                    }\n+                )\n             }\n             WherePredicate::RegionPredicate(WhereRegionPredicate{ ref lifetime,\n                                                                   ref bounds,\n@@ -1761,12 +1795,19 @@ impl<'a> LoweringContext<'a> {\n                             p: &PolyTraitRef,\n                             itctx: ImplTraitContext)\n                             -> hir::PolyTraitRef {\n-        let bound_lifetimes = self.lower_lifetime_defs(&p.bound_lifetimes);\n-        let trait_ref = self.with_parent_impl_lifetime_defs(&bound_lifetimes,\n-                                |this| this.lower_trait_ref(&p.trait_ref, itctx));\n+        let bound_generic_params = self.lower_generic_params(&p.bound_generic_params, &NodeMap());\n+        let trait_ref = self.with_parent_impl_lifetime_defs(\n+            &bound_generic_params.iter()\n+                .filter_map(|p| match *p {\n+                    hir::GenericParam::Lifetime(ref ld) => Some(ld.clone()),\n+                    _ => None,\n+                })\n+                .collect::<Vec<_>>(),\n+            |this| this.lower_trait_ref(&p.trait_ref, itctx),\n+        );\n \n         hir::PolyTraitRef {\n-            bound_lifetimes,\n+            bound_generic_params,\n             trait_ref,\n             span: p.span,\n         }\n@@ -1945,11 +1986,19 @@ impl<'a> LoweringContext<'a> {\n                     });\n \n                 let new_impl_items = self.with_in_scope_lifetime_defs(\n-                                            &ast_generics.lifetimes, |this| {\n-                    impl_items.iter()\n-                              .map(|item| this.lower_impl_item_ref(item))\n-                              .collect()\n-                });\n+                    &ast_generics.params\n+                        .iter()\n+                        .filter_map(|p| match *p {\n+                            GenericParam::Lifetime(ref ld) => Some(ld.clone()),\n+                            _ => None,\n+                        })\n+                        .collect::<Vec<_>>(),\n+                    |this| {\n+                        impl_items.iter()\n+                            .map(|item| this.lower_impl_item_ref(item))\n+                            .collect()\n+                    }\n+                );\n \n \n                 hir::ItemImpl(self.lower_unsafety(unsafety),\n@@ -3621,7 +3670,7 @@ impl<'a> LoweringContext<'a> {\n                 // Turn trait object paths into `TyTraitObject` instead.\n                 if let Def::Trait(_) = path.def {\n                     let principal = hir::PolyTraitRef {\n-                        bound_lifetimes: hir_vec![],\n+                        bound_generic_params: hir::HirVec::new(),\n                         trait_ref: hir::TraitRef {\n                             path: path.and_then(|path| path),\n                             ref_id: id.node_id,"}, {"sha": "e3ca6f1591e72b23f5f542d5e0091533714d5f13", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/250b492052e94d76bd318a4b932159395da55981/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/250b492052e94d76bd318a4b932159395da55981/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=250b492052e94d76bd318a4b932159395da55981", "patch": "@@ -326,7 +326,7 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n     }\n \n     fn visit_generics(&mut self, generics: &'hir Generics) {\n-        for ty_param in generics.ty_params.iter() {\n+        for ty_param in generics.ty_params() {\n             self.insert(ty_param.id, NodeTyParam(ty_param));\n         }\n "}, {"sha": "002849c0399c30e1a644d948d0ee5e2492ae7285", "filename": "src/librustc/hir/map/def_collector.rs", "status": "modified", "additions": 17, "deletions": 12, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/250b492052e94d76bd318a4b932159395da55981/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/250b492052e94d76bd318a4b932159395da55981/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs?ref=250b492052e94d76bd318a4b932159395da55981", "patch": "@@ -183,14 +183,25 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n         });\n     }\n \n-    fn visit_generics(&mut self, generics: &'a Generics) {\n-        for ty_param in generics.ty_params.iter() {\n-            self.create_def(ty_param.id,\n-                            DefPathData::TypeParam(ty_param.ident.name.as_str()),\n-                            REGULAR_SPACE);\n+    fn visit_generic_param(&mut self, param: &'a GenericParam) {\n+        match *param {\n+            GenericParam::Lifetime(ref lifetime_def) => {\n+                self.create_def(\n+                    lifetime_def.lifetime.id,\n+                    DefPathData::LifetimeDef(lifetime_def.lifetime.ident.name.as_str()),\n+                    REGULAR_SPACE\n+                );\n+            }\n+            GenericParam::Type(ref ty_param) => {\n+                self.create_def(\n+                    ty_param.id,\n+                    DefPathData::TypeParam(ty_param.ident.name.as_str()),\n+                    REGULAR_SPACE\n+                );\n+            }\n         }\n \n-        visit::walk_generics(self, generics);\n+        visit::walk_generic_param(self, param);\n     }\n \n     fn visit_trait_item(&mut self, ti: &'a TraitItem) {\n@@ -268,12 +279,6 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n         visit::walk_ty(self, ty);\n     }\n \n-    fn visit_lifetime_def(&mut self, def: &'a LifetimeDef) {\n-        self.create_def(def.lifetime.id,\n-                        DefPathData::LifetimeDef(def.lifetime.ident.name.as_str()),\n-                        REGULAR_SPACE);\n-    }\n-\n     fn visit_stmt(&mut self, stmt: &'a Stmt) {\n         match stmt.node {\n             StmtKind::Mac(..) => self.visit_macro_invoc(stmt.id, false),"}, {"sha": "ca2f3475fdb39e1d5a43c1492ef347636ad43006", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 86, "deletions": 21, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/250b492052e94d76bd318a4b932159395da55981/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/250b492052e94d76bd318a4b932159395da55981/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=250b492052e94d76bd318a4b932159395da55981", "patch": "@@ -48,6 +48,8 @@ use rustc_data_structures::indexed_vec;\n use serialize::{self, Encoder, Encodable, Decoder, Decodable};\n use std::collections::BTreeMap;\n use std::fmt;\n+use std::iter;\n+use std::slice;\n \n /// HIR doesn't commit to a concrete storage type and has its own alias for a vector.\n /// It can be `Vec`, `P<[T]>` or potentially `Box<[T]>`, or some other container with similar\n@@ -398,21 +400,75 @@ pub struct TyParam {\n     pub synthetic: Option<SyntheticTyParamKind>,\n }\n \n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+pub enum GenericParam {\n+    Lifetime(LifetimeDef),\n+    Type(TyParam),\n+}\n+\n+impl GenericParam {\n+    pub fn is_lifetime_param(&self) -> bool {\n+        match *self {\n+            GenericParam::Lifetime(_) => true,\n+            _ => false,\n+        }\n+    }\n+\n+    pub fn is_type_param(&self) -> bool {\n+        match *self {\n+            GenericParam::Type(_) => true,\n+            _ => false,\n+        }\n+    }\n+}\n+\n+pub trait GenericParamsExt {\n+    fn lifetimes<'a>(&'a self) -> iter::FilterMap<\n+        slice::Iter<GenericParam>,\n+        fn(&GenericParam) -> Option<&LifetimeDef>,\n+    >;\n+\n+    fn ty_params<'a>(&'a self) -> iter::FilterMap<\n+        slice::Iter<GenericParam>,\n+        fn(&GenericParam) -> Option<&TyParam>,\n+    >;\n+}\n+\n+impl GenericParamsExt for [GenericParam] {\n+    fn lifetimes<'a>(&'a self) -> iter::FilterMap<\n+        slice::Iter<GenericParam>,\n+        fn(&GenericParam) -> Option<&LifetimeDef>,\n+    > {\n+        self.iter().filter_map(|param| match *param {\n+            GenericParam::Lifetime(ref l) => Some(l),\n+            _ => None,\n+        })\n+    }\n+\n+    fn ty_params<'a>(&'a self) -> iter::FilterMap<\n+        slice::Iter<GenericParam>,\n+        fn(&GenericParam) -> Option<&TyParam>,\n+    > {\n+        self.iter().filter_map(|param| match *param {\n+            GenericParam::Type(ref t) => Some(t),\n+            _ => None,\n+        })\n+    }\n+}\n+\n /// Represents lifetimes and type parameters attached to a declaration\n /// of a function, enum, trait, etc.\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct Generics {\n-    pub lifetimes: HirVec<LifetimeDef>,\n-    pub ty_params: HirVec<TyParam>,\n+    pub params: HirVec<GenericParam>,\n     pub where_clause: WhereClause,\n     pub span: Span,\n }\n \n impl Generics {\n     pub fn empty() -> Generics {\n         Generics {\n-            lifetimes: HirVec::new(),\n-            ty_params: HirVec::new(),\n+            params: HirVec::new(),\n             where_clause: WhereClause {\n                 id: DUMMY_NODE_ID,\n                 predicates: HirVec::new(),\n@@ -422,15 +478,19 @@ impl Generics {\n     }\n \n     pub fn is_lt_parameterized(&self) -> bool {\n-        !self.lifetimes.is_empty()\n+        self.params.iter().any(|param| param.is_lifetime_param())\n     }\n \n     pub fn is_type_parameterized(&self) -> bool {\n-        !self.ty_params.is_empty()\n+        self.params.iter().any(|param| param.is_type_param())\n+    }\n+\n+    pub fn lifetimes<'a>(&'a self) -> impl Iterator<Item = &'a LifetimeDef> {\n+        self.params.lifetimes()\n     }\n \n-    pub fn is_parameterized(&self) -> bool {\n-        self.is_lt_parameterized() || self.is_type_parameterized()\n+    pub fn ty_params<'a>(&'a self) -> impl Iterator<Item = &'a TyParam> {\n+        self.params.ty_params()\n     }\n }\n \n@@ -450,17 +510,22 @@ impl UnsafeGeneric {\n \n impl Generics {\n     pub fn carries_unsafe_attr(&self) -> Option<UnsafeGeneric> {\n-        for r in &self.lifetimes {\n-            if r.pure_wrt_drop {\n-                return Some(UnsafeGeneric::Region(r.clone(), \"may_dangle\"));\n-            }\n-        }\n-        for t in &self.ty_params {\n-            if t.pure_wrt_drop {\n-                return Some(UnsafeGeneric::Type(t.clone(), \"may_dangle\"));\n+        for param in &self.params {\n+            match *param {\n+                GenericParam::Lifetime(ref l) => {\n+                    if l.pure_wrt_drop {\n+                        return Some(UnsafeGeneric::Region(l.clone(), \"may_dangle\"));\n+                    }\n+                }\n+                GenericParam::Type(ref t) => {\n+                    if t.pure_wrt_drop {\n+                        return Some(UnsafeGeneric::Type(t.clone(), \"may_dangle\"));\n+                    }\n+                }\n             }\n         }\n-        return None;\n+\n+        None\n     }\n }\n \n@@ -493,8 +558,8 @@ pub enum WherePredicate {\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct WhereBoundPredicate {\n     pub span: Span,\n-    /// Any lifetimes from a `for` binding\n-    pub bound_lifetimes: HirVec<LifetimeDef>,\n+    /// Any generics from a `for` binding\n+    pub bound_generic_params: HirVec<GenericParam>,\n     /// The type being bounded\n     pub bounded_ty: P<Ty>,\n     /// Trait and lifetime bounds (`Clone+Send+'static`)\n@@ -1475,7 +1540,7 @@ pub enum PrimTy {\n pub struct BareFnTy {\n     pub unsafety: Unsafety,\n     pub abi: Abi,\n-    pub lifetimes: HirVec<LifetimeDef>,\n+    pub generic_params: HirVec<GenericParam>,\n     pub decl: P<FnDecl>,\n     pub arg_names: HirVec<Spanned<Name>>,\n }\n@@ -1733,7 +1798,7 @@ pub struct TraitRef {\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct PolyTraitRef {\n     /// The `'a` in `<'a> Foo<&'a T>`\n-    pub bound_lifetimes: HirVec<LifetimeDef>,\n+    pub bound_generic_params: HirVec<GenericParam>,\n \n     /// The `Foo<&'a T>` in `<'a> Foo<&'a T>`\n     pub trait_ref: TraitRef,"}, {"sha": "2f9fc70252f8da43b1ccef387875ee1a362ae1d2", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 40, "deletions": 65, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/250b492052e94d76bd318a4b932159395da55981/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/250b492052e94d76bd318a4b932159395da55981/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=250b492052e94d76bd318a4b932159395da55981", "patch": "@@ -390,16 +390,7 @@ impl<'a> State<'a> {\n                 self.pclose()?;\n             }\n             hir::TyBareFn(ref f) => {\n-                let generics = hir::Generics {\n-                    lifetimes: f.lifetimes.clone(),\n-                    ty_params: hir::HirVec::new(),\n-                    where_clause: hir::WhereClause {\n-                        id: ast::DUMMY_NODE_ID,\n-                        predicates: hir::HirVec::new(),\n-                    },\n-                    span: syntax_pos::DUMMY_SP,\n-                };\n-                self.print_ty_fn(f.abi, f.unsafety, &f.decl, None, &generics,\n+                self.print_ty_fn(f.abi, f.unsafety, &f.decl, None, &f.generic_params,\n                                  &f.arg_names[..])?;\n             }\n             hir::TyPath(ref qpath) => {\n@@ -635,15 +626,15 @@ impl<'a> State<'a> {\n                 self.s.word(&ga.asm.as_str())?;\n                 self.end()?\n             }\n-            hir::ItemTy(ref ty, ref params) => {\n+            hir::ItemTy(ref ty, ref generics) => {\n                 self.ibox(indent_unit)?;\n                 self.ibox(0)?;\n                 self.word_nbsp(&visibility_qualified(&item.vis, \"type\"))?;\n                 self.print_name(item.name)?;\n-                self.print_generics(params)?;\n+                self.print_generic_params(&generics.params)?;\n                 self.end()?; // end the inner ibox\n \n-                self.print_where_clause(&params.where_clause)?;\n+                self.print_where_clause(&generics.where_clause)?;\n                 self.s.space()?;\n                 self.word_space(\"=\")?;\n                 self.print_type(&ty)?;\n@@ -686,8 +677,8 @@ impl<'a> State<'a> {\n                 self.print_unsafety(unsafety)?;\n                 self.word_nbsp(\"impl\")?;\n \n-                if generics.is_parameterized() {\n-                    self.print_generics(generics)?;\n+                if !generics.params.is_empty() {\n+                    self.print_generic_params(&generics.params)?;\n                     self.s.space()?;\n                 }\n \n@@ -725,7 +716,7 @@ impl<'a> State<'a> {\n                 self.print_unsafety(unsafety)?;\n                 self.word_nbsp(\"trait\")?;\n                 self.print_name(item.name)?;\n-                self.print_generics(generics)?;\n+                self.print_generic_params(&generics.params)?;\n                 let mut real_bounds = Vec::with_capacity(bounds.len());\n                 for b in bounds.iter() {\n                     if let TraitTyParamBound(ref ptr, hir::TraitBoundModifier::Maybe) = *b {\n@@ -750,7 +741,7 @@ impl<'a> State<'a> {\n                 self.print_visibility(&item.vis)?;\n                 self.word_nbsp(\"trait\")?;\n                 self.print_name(item.name)?;\n-                self.print_generics(generics)?;\n+                self.print_generic_params(&generics.params)?;\n                 let mut real_bounds = Vec::with_capacity(bounds.len());\n                 // FIXME(durka) this seems to be some quite outdated syntax\n                 for b in bounds.iter() {\n@@ -775,25 +766,20 @@ impl<'a> State<'a> {\n         self.print_path(&t.path, false)\n     }\n \n-    fn print_formal_lifetime_list(&mut self, lifetimes: &[hir::LifetimeDef]) -> io::Result<()> {\n-        if !lifetimes.is_empty() {\n-            self.s.word(\"for<\")?;\n-            let mut comma = false;\n-            for lifetime_def in lifetimes {\n-                if comma {\n-                    self.word_space(\",\")?\n-                }\n-                self.print_lifetime_def(lifetime_def)?;\n-                comma = true;\n-            }\n-            self.s.word(\">\")?;\n+    fn print_formal_generic_params(\n+        &mut self,\n+        generic_params: &[hir::GenericParam]\n+    ) -> io::Result<()> {\n+        if !generic_params.is_empty() {\n+            self.s.word(\"for\")?;\n+            self.print_generic_params(generic_params)?;\n             self.nbsp()?;\n         }\n         Ok(())\n     }\n \n     fn print_poly_trait_ref(&mut self, t: &hir::PolyTraitRef) -> io::Result<()> {\n-        self.print_formal_lifetime_list(&t.bound_lifetimes)?;\n+        self.print_formal_generic_params(&t.bound_generic_params)?;\n         self.print_trait_ref(&t.trait_ref)\n     }\n \n@@ -806,7 +792,7 @@ impl<'a> State<'a> {\n                           -> io::Result<()> {\n         self.head(&visibility_qualified(visibility, \"enum\"))?;\n         self.print_name(name)?;\n-        self.print_generics(generics)?;\n+        self.print_generic_params(&generics.params)?;\n         self.print_where_clause(&generics.where_clause)?;\n         self.s.space()?;\n         self.print_variants(&enum_definition.variants, span)\n@@ -859,7 +845,7 @@ impl<'a> State<'a> {\n                         print_finalizer: bool)\n                         -> io::Result<()> {\n         self.print_name(name)?;\n-        self.print_generics(generics)?;\n+        self.print_generic_params(&generics.params)?;\n         if !struct_def.is_struct() {\n             if struct_def.is_tuple() {\n                 self.popen()?;\n@@ -1941,7 +1927,7 @@ impl<'a> State<'a> {\n             self.nbsp()?;\n             self.print_name(name)?;\n         }\n-        self.print_generics(generics)?;\n+        self.print_generic_params(&generics.params)?;\n \n         self.popen()?;\n         let mut i = 0;\n@@ -2056,31 +2042,19 @@ impl<'a> State<'a> {\n         Ok(())\n     }\n \n-    pub fn print_generics(&mut self, generics: &hir::Generics) -> io::Result<()> {\n-        let total = generics.lifetimes.len() + generics.ty_params.len();\n-        if total == 0 {\n-            return Ok(());\n-        }\n+    pub fn print_generic_params(&mut self, generic_params: &[hir::GenericParam]) -> io::Result<()> {\n+        if !generic_params.is_empty() {\n+            self.s.word(\"<\")?;\n \n-        self.s.word(\"<\")?;\n+            self.commasep(Inconsistent, generic_params, |s, param| {\n+                match *param {\n+                    hir::GenericParam::Lifetime(ref ld) => s.print_lifetime_def(ld),\n+                    hir::GenericParam::Type(ref tp) => s.print_ty_param(tp),\n+                }\n+            })?;\n \n-        let mut ints = Vec::new();\n-        for i in 0..total {\n-            ints.push(i);\n+            self.s.word(\">\")?;\n         }\n-\n-        self.commasep(Inconsistent, &ints[..], |s, &idx| {\n-            if idx < generics.lifetimes.len() {\n-                let lifetime = &generics.lifetimes[idx];\n-                s.print_lifetime_def(lifetime)\n-            } else {\n-                let idx = idx - generics.lifetimes.len();\n-                let param = &generics.ty_params[idx];\n-                s.print_ty_param(param)\n-            }\n-        })?;\n-\n-        self.s.word(\">\")?;\n         Ok(())\n     }\n \n@@ -2111,11 +2085,13 @@ impl<'a> State<'a> {\n             }\n \n             match predicate {\n-                &hir::WherePredicate::BoundPredicate(hir::WhereBoundPredicate{ref bound_lifetimes,\n-                                                                              ref bounded_ty,\n-                                                                              ref bounds,\n-                                                                              ..}) => {\n-                    self.print_formal_lifetime_list(bound_lifetimes)?;\n+                &hir::WherePredicate::BoundPredicate(hir::WhereBoundPredicate {\n+                    ref bound_generic_params,\n+                    ref bounded_ty,\n+                    ref bounds,\n+                    ..\n+                }) => {\n+                    self.print_formal_generic_params(bound_generic_params)?;\n                     self.print_type(&bounded_ty)?;\n                     self.print_bounds(\":\", bounds)?;\n                 }\n@@ -2184,17 +2160,16 @@ impl<'a> State<'a> {\n                        unsafety: hir::Unsafety,\n                        decl: &hir::FnDecl,\n                        name: Option<ast::Name>,\n-                       generics: &hir::Generics,\n+                       generic_params: &[hir::GenericParam],\n                        arg_names: &[Spanned<ast::Name>])\n                        -> io::Result<()> {\n         self.ibox(indent_unit)?;\n-        if !generics.lifetimes.is_empty() || !generics.ty_params.is_empty() {\n+        if !generic_params.is_empty() {\n             self.s.word(\"for\")?;\n-            self.print_generics(generics)?;\n+            self.print_generic_params(generic_params)?;\n         }\n         let generics = hir::Generics {\n-            lifetimes: hir::HirVec::new(),\n-            ty_params: hir::HirVec::new(),\n+            params: hir::HirVec::new(),\n             where_clause: hir::WhereClause {\n                 id: ast::DUMMY_NODE_ID,\n                 predicates: hir::HirVec::new(),"}, {"sha": "bddbdec2c34acb358f00292d4976e8b35688e4e0", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/250b492052e94d76bd318a4b932159395da55981/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/250b492052e94d76bd318a4b932159395da55981/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=250b492052e94d76bd318a4b932159395da55981", "patch": "@@ -200,9 +200,13 @@ impl_stable_hash_for!(struct hir::TyParam {\n     synthetic\n });\n \n+impl_stable_hash_for!(enum hir::GenericParam {\n+    Lifetime(lifetime_def),\n+    Type(ty_param)\n+});\n+\n impl_stable_hash_for!(struct hir::Generics {\n-    lifetimes,\n-    ty_params,\n+    params,\n     where_clause,\n     span\n });\n@@ -224,7 +228,7 @@ impl_stable_hash_for!(enum hir::WherePredicate {\n \n impl_stable_hash_for!(struct hir::WhereBoundPredicate {\n     span,\n-    bound_lifetimes,\n+    bound_generic_params,\n     bounded_ty,\n     bounds\n });\n@@ -291,7 +295,7 @@ impl_stable_hash_for!(enum hir::PrimTy {\n impl_stable_hash_for!(struct hir::BareFnTy {\n     unsafety,\n     abi,\n-    lifetimes,\n+    generic_params,\n     decl,\n     arg_names\n });\n@@ -345,7 +349,7 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::TraitRef {\n \n \n impl_stable_hash_for!(struct hir::PolyTraitRef {\n-    bound_lifetimes,\n+    bound_generic_params,\n     trait_ref,\n     span\n });"}, {"sha": "32ab458cb91de4a849f389a9507acc301a331d77", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/250b492052e94d76bd318a4b932159395da55981/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/250b492052e94d76bd318a4b932159395da55981/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=250b492052e94d76bd318a4b932159395da55981", "patch": "@@ -783,6 +783,11 @@ impl<'a, 'tcx> hir_visit::Visitor<'tcx> for LateContext<'a, 'tcx> {\n         hir_visit::walk_decl(self, d);\n     }\n \n+    fn visit_generic_param(&mut self, p: &'tcx hir::GenericParam) {\n+        run_lints!(self, check_generic_param, late_passes, p);\n+        hir_visit::walk_generic_param(self, p);\n+    }\n+\n     fn visit_generics(&mut self, g: &'tcx hir::Generics) {\n         run_lints!(self, check_generics, late_passes, g);\n         hir_visit::walk_generics(self, g);\n@@ -819,11 +824,6 @@ impl<'a, 'tcx> hir_visit::Visitor<'tcx> for LateContext<'a, 'tcx> {\n         hir_visit::walk_lifetime(self, lt);\n     }\n \n-    fn visit_lifetime_def(&mut self, lt: &'tcx hir::LifetimeDef) {\n-        run_lints!(self, check_lifetime_def, late_passes, lt);\n-        hir_visit::walk_lifetime_def(self, lt);\n-    }\n-\n     fn visit_path(&mut self, p: &'tcx hir::Path, id: ast::NodeId) {\n         run_lints!(self, check_path, late_passes, p, id);\n         hir_visit::walk_path(self, p);\n@@ -945,6 +945,11 @@ impl<'a> ast_visit::Visitor<'a> for EarlyContext<'a> {\n         run_lints!(self, check_expr_post, early_passes, e);\n     }\n \n+    fn visit_generic_param(&mut self, param: &'a ast::GenericParam) {\n+        run_lints!(self, check_generic_param, early_passes, param);\n+        ast_visit::walk_generic_param(self, param);\n+    }\n+\n     fn visit_generics(&mut self, g: &'a ast::Generics) {\n         run_lints!(self, check_generics, early_passes, g);\n         ast_visit::walk_generics(self, g);\n@@ -971,10 +976,6 @@ impl<'a> ast_visit::Visitor<'a> for EarlyContext<'a> {\n         self.check_id(lt.id);\n     }\n \n-    fn visit_lifetime_def(&mut self, lt: &'a ast::LifetimeDef) {\n-        run_lints!(self, check_lifetime_def, early_passes, lt);\n-    }\n-\n     fn visit_path(&mut self, p: &'a ast::Path, id: ast::NodeId) {\n         run_lints!(self, check_path, early_passes, p, id);\n         self.check_id(id);"}, {"sha": "f4abc54ad2e4ec53ebbccb6106e750ae4d459b4b", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/250b492052e94d76bd318a4b932159395da55981/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/250b492052e94d76bd318a4b932159395da55981/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=250b492052e94d76bd318a4b932159395da55981", "patch": "@@ -155,6 +155,7 @@ pub trait LateLintPass<'a, 'tcx>: LintPass {\n     fn check_expr(&mut self, _: &LateContext<'a, 'tcx>, _: &'tcx hir::Expr) { }\n     fn check_expr_post(&mut self, _: &LateContext<'a, 'tcx>, _: &'tcx hir::Expr) { }\n     fn check_ty(&mut self, _: &LateContext<'a, 'tcx>, _: &'tcx hir::Ty) { }\n+    fn check_generic_param(&mut self, _: &LateContext<'a, 'tcx>, _: &'tcx hir::GenericParam) { }\n     fn check_generics(&mut self, _: &LateContext<'a, 'tcx>, _: &'tcx hir::Generics) { }\n     fn check_fn(&mut self,\n                 _: &LateContext<'a, 'tcx>,\n@@ -196,7 +197,6 @@ pub trait LateLintPass<'a, 'tcx>: LintPass {\n                           _: &'tcx hir::Variant,\n                           _: &'tcx hir::Generics) { }\n     fn check_lifetime(&mut self, _: &LateContext<'a, 'tcx>, _: &'tcx hir::Lifetime) { }\n-    fn check_lifetime_def(&mut self, _: &LateContext<'a, 'tcx>, _: &'tcx hir::LifetimeDef) { }\n     fn check_path(&mut self, _: &LateContext<'a, 'tcx>, _: &'tcx hir::Path, _: ast::NodeId) { }\n     fn check_attribute(&mut self, _: &LateContext<'a, 'tcx>, _: &'tcx ast::Attribute) { }\n \n@@ -227,6 +227,7 @@ pub trait EarlyLintPass: LintPass {\n     fn check_expr(&mut self, _: &EarlyContext, _: &ast::Expr) { }\n     fn check_expr_post(&mut self, _: &EarlyContext, _: &ast::Expr) { }\n     fn check_ty(&mut self, _: &EarlyContext, _: &ast::Ty) { }\n+    fn check_generic_param(&mut self, _: &EarlyContext, _: &ast::GenericParam) { }\n     fn check_generics(&mut self, _: &EarlyContext, _: &ast::Generics) { }\n     fn check_fn(&mut self, _: &EarlyContext,\n         _: ast_visit::FnKind, _: &ast::FnDecl, _: Span, _: ast::NodeId) { }\n@@ -244,7 +245,6 @@ pub trait EarlyLintPass: LintPass {\n     fn check_variant(&mut self, _: &EarlyContext, _: &ast::Variant, _: &ast::Generics) { }\n     fn check_variant_post(&mut self, _: &EarlyContext, _: &ast::Variant, _: &ast::Generics) { }\n     fn check_lifetime(&mut self, _: &EarlyContext, _: &ast::Lifetime) { }\n-    fn check_lifetime_def(&mut self, _: &EarlyContext, _: &ast::LifetimeDef) { }\n     fn check_path(&mut self, _: &EarlyContext, _: &ast::Path, _: ast::NodeId) { }\n     fn check_attribute(&mut self, _: &EarlyContext, _: &ast::Attribute) { }\n "}, {"sha": "6f457c9d1e1b2960a1dc782f8fe7743c9a901ee3", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/250b492052e94d76bd318a4b932159395da55981/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/250b492052e94d76bd318a4b932159395da55981/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=250b492052e94d76bd318a4b932159395da55981", "patch": "@@ -37,7 +37,7 @@ use hir::intravisit;\n // Returns true if the given set of generics implies that the item it's\n // associated with must be inlined.\n fn generics_require_inlining(generics: &hir::Generics) -> bool {\n-    !generics.ty_params.is_empty()\n+    generics.params.iter().any(|param| param.is_type_param())\n }\n \n // Returns true if the given item must be inlined because it may be"}, {"sha": "8b302dbe67a42ab0cecee0b57915b65e86670b98", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 74, "deletions": 72, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/250b492052e94d76bd318a4b932159395da55981/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/250b492052e94d76bd318a4b932159395da55981/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=250b492052e94d76bd318a4b932159395da55981", "patch": "@@ -33,7 +33,7 @@ use util::nodemap::{DefIdMap, FxHashMap, FxHashSet, NodeMap, NodeSet};\n use std::slice;\n use rustc::lint;\n \n-use hir;\n+use hir::{self, GenericParamsExt};\n use hir::intravisit::{self, NestedVisitorMap, Visitor};\n \n /// The origin of a named lifetime definition.\n@@ -491,19 +491,17 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 } else {\n                     0\n                 };\n-                let lifetimes = generics\n-                    .lifetimes\n-                    .iter()\n+                let lifetimes = generics.lifetimes()\n                     .map(|def| Region::early(&self.tcx.hir, &mut index, def))\n                     .collect();\n-                let next_early_index = index + generics.ty_params.len() as u32;\n+                let next_early_index = index + generics.ty_params().count() as u32;\n                 let scope = Scope::Binder {\n                     lifetimes,\n                     next_early_index,\n                     s: ROOT_SCOPE,\n                 };\n                 self.with(scope, |old_scope, this| {\n-                    this.check_lifetime_defs(old_scope, &generics.lifetimes);\n+                    this.check_lifetime_params(old_scope, &generics.params);\n                     intravisit::walk_item(this, item);\n                 });\n             }\n@@ -537,8 +535,8 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 let was_in_fn_syntax = self.is_in_fn_syntax;\n                 self.is_in_fn_syntax = true;\n                 let scope = Scope::Binder {\n-                    lifetimes: c.lifetimes\n-                        .iter()\n+                    lifetimes: c.generic_params\n+                        .lifetimes()\n                         .map(|def| Region::late(&self.tcx.hir, def))\n                         .collect(),\n                     s: self.scope,\n@@ -547,7 +545,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 self.with(scope, |old_scope, this| {\n                     // a bare fn has no bounds, so everything\n                     // contained within is scoped within its binder.\n-                    this.check_lifetime_defs(old_scope, &c.lifetimes);\n+                    this.check_lifetime_params(old_scope, &c.generic_params);\n                     intravisit::walk_ty(this, ty);\n                 });\n                 self.is_in_fn_syntax = was_in_fn_syntax;\n@@ -621,7 +619,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n \n                 let mut elision = None;\n                 let mut lifetimes = FxHashMap();\n-                for lt_def in &generics.lifetimes {\n+                for lt_def in generics.lifetimes() {\n                     let (lt_name, region) = Region::early(&self.tcx.hir, &mut index, &lt_def);\n                     if let hir::LifetimeName::Underscore = lt_name {\n                         // Pick the elided lifetime \"definition\" if one exists and use it to make an\n@@ -632,7 +630,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     }\n                 }\n \n-                let next_early_index = index + generics.ty_params.len() as u32;\n+                let next_early_index = index + generics.ty_params().count() as u32;\n \n                 if let Some(elision_region) = elision {\n                     let scope = Scope::Elision {\n@@ -678,11 +676,11 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 let generics = &trait_item.generics;\n                 let mut index = self.next_early_index();\n                 debug!(\"visit_ty: index = {}\", index);\n-                let lifetimes = generics.lifetimes.iter()\n+                let lifetimes = generics.lifetimes()\n                     .map(|lt_def| Region::early(&self.tcx.hir, &mut index, lt_def))\n                     .collect();\n \n-                let next_early_index = index + generics.ty_params.len() as u32;\n+                let next_early_index = index + generics.ty_params().count() as u32;\n                 let scope = Scope::Binder { lifetimes, next_early_index, s: self.scope };\n                 self.with(scope, |_old_scope, this| {\n                     this.visit_generics(generics);\n@@ -696,7 +694,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n             },\n             Const(_, _) => {\n                 // Only methods and types support generics.\n-                assert!(!trait_item.generics.is_parameterized());\n+                assert!(trait_item.generics.params.is_empty());\n                 intravisit::walk_trait_item(self, trait_item);\n             },\n         }\n@@ -718,11 +716,11 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 let generics = &impl_item.generics;\n                 let mut index = self.next_early_index();\n                 debug!(\"visit_ty: index = {}\", index);\n-                let lifetimes = generics.lifetimes.iter()\n+                let lifetimes = generics.lifetimes()\n                     .map(|lt_def| Region::early(&self.tcx.hir, &mut index, lt_def))\n                     .collect();\n \n-                let next_early_index = index + generics.ty_params.len() as u32;\n+                let next_early_index = index + generics.ty_params().count() as u32;\n                 let scope = Scope::Binder { lifetimes, next_early_index, s: self.scope };\n                 self.with(scope, |_old_scope, this| {\n                     this.visit_generics(generics);\n@@ -731,7 +729,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n             },\n             Const(_, _) => {\n                 // Only methods and types support generics.\n-                assert!(!impl_item.generics.is_parameterized());\n+                assert!(impl_item.generics.params.is_empty());\n                 intravisit::walk_impl_item(self, impl_item);\n             },\n         }\n@@ -767,8 +765,11 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n     }\n \n     fn visit_generics(&mut self, generics: &'tcx hir::Generics) {\n-        check_mixed_explicit_and_in_band_defs(self.tcx, &generics.lifetimes);\n-        for ty_param in generics.ty_params.iter() {\n+        check_mixed_explicit_and_in_band_defs(\n+            self.tcx,\n+            &generics.lifetimes().cloned().collect::<Vec<_>>()\n+        );\n+        for ty_param in generics.ty_params() {\n             walk_list!(self, visit_ty_param_bound, &ty_param.bounds);\n             if let Some(ref ty) = ty_param.default {\n                 self.visit_ty(&ty);\n@@ -779,22 +780,21 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 &hir::WherePredicate::BoundPredicate(hir::WhereBoundPredicate {\n                     ref bounded_ty,\n                     ref bounds,\n-                    ref bound_lifetimes,\n+                    ref bound_generic_params,\n                     ..\n                 }) => {\n-                    if !bound_lifetimes.is_empty() {\n+                    if bound_generic_params.iter().any(|p| p.is_lifetime_param()) {\n                         self.trait_ref_hack = true;\n                         let next_early_index = self.next_early_index();\n                         let scope = Scope::Binder {\n-                            lifetimes: bound_lifetimes\n-                                .iter()\n+                            lifetimes: bound_generic_params.lifetimes()\n                                 .map(|def| Region::late(&self.tcx.hir, def))\n                                 .collect(),\n                             s: self.scope,\n                             next_early_index,\n                         };\n                         let result = self.with(scope, |old_scope, this| {\n-                            this.check_lifetime_defs(old_scope, bound_lifetimes);\n+                            this.check_lifetime_params(old_scope, &bound_generic_params);\n                             this.visit_ty(&bounded_ty);\n                             walk_list!(this, visit_ty_param_bound, bounds);\n                         });\n@@ -834,7 +834,9 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n     ) {\n         debug!(\"visit_poly_trait_ref trait_ref={:?}\", trait_ref);\n \n-        if !self.trait_ref_hack || !trait_ref.bound_lifetimes.is_empty() {\n+        if !self.trait_ref_hack ||\n+            trait_ref.bound_generic_params.iter().any(|p| p.is_lifetime_param())\n+        {\n             if self.trait_ref_hack {\n                 span_err!(\n                     self.tcx.sess,\n@@ -845,19 +847,16 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n             }\n             let next_early_index = self.next_early_index();\n             let scope = Scope::Binder {\n-                lifetimes: trait_ref\n-                    .bound_lifetimes\n-                    .iter()\n+                lifetimes: trait_ref.bound_generic_params\n+                    .lifetimes()\n                     .map(|def| Region::late(&self.tcx.hir, def))\n                     .collect(),\n                 s: self.scope,\n                 next_early_index,\n             };\n             self.with(scope, |old_scope, this| {\n-                this.check_lifetime_defs(old_scope, &trait_ref.bound_lifetimes);\n-                for lifetime in &trait_ref.bound_lifetimes {\n-                    this.visit_lifetime_def(lifetime);\n-                }\n+                this.check_lifetime_params(old_scope, &trait_ref.bound_generic_params);\n+                walk_list!(this, visit_generic_param, &trait_ref.bound_generic_params);\n                 this.visit_trait_ref(&trait_ref.trait_ref)\n             })\n         } else {\n@@ -1087,8 +1086,9 @@ fn compute_object_lifetime_defaults(\n                         .map(|set| match *set {\n                             Set1::Empty => \"BaseDefault\".to_string(),\n                             Set1::One(Region::Static) => \"'static\".to_string(),\n-                            Set1::One(Region::EarlyBound(i, _, _)) => generics.lifetimes\n-                                [i as usize]\n+                            Set1::One(Region::EarlyBound(i, _, _)) => generics.lifetimes()\n+                                .nth(i as usize)\n+                                .unwrap()\n                                 .lifetime\n                                 .name\n                                 .name()\n@@ -1124,9 +1124,7 @@ fn object_lifetime_defaults_for_item(\n         }\n     }\n \n-    generics\n-        .ty_params\n-        .iter()\n+    generics.ty_params()\n         .map(|param| {\n             let mut set = Set1::Empty;\n \n@@ -1142,7 +1140,7 @@ fn object_lifetime_defaults_for_item(\n \n                 // Ignore `for<'a> type: ...` as they can change what\n                 // lifetimes mean (although we could \"just\" handle it).\n-                if !data.bound_lifetimes.is_empty() {\n+                if !data.bound_generic_params.is_empty() {\n                     continue;\n                 }\n \n@@ -1163,8 +1161,7 @@ fn object_lifetime_defaults_for_item(\n                         Set1::One(Region::Static)\n                     } else {\n                         generics\n-                            .lifetimes\n-                            .iter()\n+                            .lifetimes()\n                             .enumerate()\n                             .find(|&(_, def)| def.lifetime.name == name)\n                             .map_or(Set1::Many, |(i, def)| {\n@@ -1283,15 +1280,14 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             match parent.node {\n                 hir::ItemTrait(_, _, ref generics, ..)\n                 | hir::ItemImpl(_, _, _, ref generics, ..) => {\n-                    index += (generics.lifetimes.len() + generics.ty_params.len()) as u32;\n+                    index += generics.params.len() as u32;\n                 }\n                 _ => {}\n             }\n         }\n \n         let lifetimes = generics\n-            .lifetimes\n-            .iter()\n+            .lifetimes()\n             .map(|def| {\n                 if self.map.late_bound.contains(&def.lifetime.id) {\n                     Region::late(&self.tcx.hir, def)\n@@ -1301,15 +1297,15 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             })\n             .collect();\n \n-        let next_early_index = index + generics.ty_params.len() as u32;\n+        let next_early_index = index + generics.ty_params().count() as u32;\n \n         let scope = Scope::Binder {\n             lifetimes,\n             next_early_index,\n             s: self.scope,\n         };\n         self.with(scope, move |old_scope, this| {\n-            this.check_lifetime_defs(old_scope, &generics.lifetimes);\n+            this.check_lifetime_params(old_scope, &generics.params);\n             this.hack(walk); // FIXME(#37666) workaround in place of `walk(this)`\n         });\n     }\n@@ -1769,6 +1765,16 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 }\n             }\n \n+            fn visit_generic_param(&mut self, param: &hir::GenericParam) {\n+                if let hir::GenericParam::Lifetime(ref lifetime_def) = *param {\n+                    for l in &lifetime_def.bounds {\n+                        self.visit_lifetime(l);\n+                    }\n+                }\n+\n+                intravisit::walk_generic_param(self, param);\n+            }\n+\n             fn visit_poly_trait_ref(\n                 &mut self,\n                 trait_ref: &hir::PolyTraitRef,\n@@ -1779,12 +1785,6 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 self.binder_depth -= 1;\n             }\n \n-            fn visit_lifetime_def(&mut self, lifetime_def: &hir::LifetimeDef) {\n-                for l in &lifetime_def.bounds {\n-                    self.visit_lifetime(l);\n-                }\n-            }\n-\n             fn visit_lifetime(&mut self, lifetime_ref: &hir::Lifetime) {\n                 if let Some(&lifetime) = self.map.defs.get(&lifetime_ref.id) {\n                     match lifetime {\n@@ -1980,11 +1980,9 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         self.insert_lifetime(lifetime_ref, lifetime.shifted(late_depth));\n     }\n \n-    fn check_lifetime_defs(&mut self, old_scope: ScopeRef, lifetimes: &'tcx [hir::LifetimeDef]) {\n-        for i in 0..lifetimes.len() {\n-            let lifetime_i = &lifetimes[i];\n-\n-            for lifetime in lifetimes {\n+    fn check_lifetime_params(&mut self, old_scope: ScopeRef, params: &'tcx [hir::GenericParam]) {\n+        for (i, lifetime_i) in params.lifetimes().enumerate() {\n+            for lifetime in params.lifetimes() {\n                 match lifetime.lifetime.name {\n                     hir::LifetimeName::Static | hir::LifetimeName::Underscore => {\n                         let lifetime = lifetime.lifetime;\n@@ -2007,9 +2005,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             }\n \n             // It is a hard error to shadow a lifetime within the same scope.\n-            for j in i + 1..lifetimes.len() {\n-                let lifetime_j = &lifetimes[j];\n-\n+            for lifetime_j in params.lifetimes().skip(i + 1) {\n                 if lifetime_i.lifetime.name == lifetime_j.lifetime.name {\n                     struct_span_err!(\n                         self.tcx.sess,\n@@ -2200,24 +2196,30 @@ fn insert_late_bound_lifetimes(\n     let mut appears_in_where_clause = AllCollector {\n         regions: FxHashSet(),\n     };\n-    for ty_param in generics.ty_params.iter() {\n-        walk_list!(\n-            &mut appears_in_where_clause,\n-            visit_ty_param_bound,\n-            &ty_param.bounds\n-        );\n+\n+    for param in &generics.params {\n+        match *param {\n+            hir::GenericParam::Lifetime(ref lifetime_def) => {\n+                if !lifetime_def.bounds.is_empty() {\n+                    // `'a: 'b` means both `'a` and `'b` are referenced\n+                    appears_in_where_clause.visit_generic_param(param);\n+                }\n+            }\n+            hir::GenericParam::Type(ref ty_param) => {\n+                walk_list!(\n+                    &mut appears_in_where_clause,\n+                    visit_ty_param_bound,\n+                    &ty_param.bounds\n+                );\n+            }\n+        }\n     }\n+\n     walk_list!(\n         &mut appears_in_where_clause,\n         visit_where_predicate,\n         &generics.where_clause.predicates\n     );\n-    for lifetime_def in &generics.lifetimes {\n-        if !lifetime_def.bounds.is_empty() {\n-            // `'a: 'b` means both `'a` and `'b` are referenced\n-            appears_in_where_clause.visit_lifetime_def(lifetime_def);\n-        }\n-    }\n \n     debug!(\n         \"insert_late_bound_lifetimes: appears_in_where_clause={:?}\",\n@@ -2228,7 +2230,7 @@ fn insert_late_bound_lifetimes(\n     // - appear in the inputs\n     // - do not appear in the where-clauses\n     // - are not implicitly captured by `impl Trait`\n-    for lifetime in &generics.lifetimes {\n+    for lifetime in generics.lifetimes() {\n         let name = lifetime.lifetime.name;\n \n         // appears in the where clauses? early-bound."}, {"sha": "49f14e8484f3a1c2572313b4e8d0422622bcde77", "filename": "src/librustc_lint/bad_style.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/250b492052e94d76bd318a4b932159395da55981/src%2Flibrustc_lint%2Fbad_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/250b492052e94d76bd318a4b932159395da55981/src%2Flibrustc_lint%2Fbad_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbad_style.rs?ref=250b492052e94d76bd318a4b932159395da55981", "patch": "@@ -126,8 +126,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonCamelCaseTypes {\n         self.check_case(cx, \"variant\", v.node.name, v.span);\n     }\n \n-    fn check_generics(&mut self, cx: &LateContext, it: &hir::Generics) {\n-        for gen in it.ty_params.iter() {\n+    fn check_generic_param(&mut self, cx: &LateContext, param: &hir::GenericParam) {\n+        if let hir::GenericParam::Type(ref gen) = *param {\n             self.check_case(cx, \"type parameter\", gen.name, gen.span);\n         }\n     }\n@@ -232,6 +232,17 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonSnakeCase {\n         }\n     }\n \n+    fn check_generic_param(&mut self, cx: &LateContext, param: &hir::GenericParam) {\n+        if let hir::GenericParam::Lifetime(ref ld) = *param {\n+            self.check_snake_case(\n+                cx,\n+                \"lifetime\",\n+                &ld.lifetime.name.name().as_str(),\n+                Some(ld.lifetime.span)\n+            );\n+        }\n+    }\n+\n     fn check_fn(&mut self,\n                 cx: &LateContext,\n                 fk: FnKind,\n@@ -280,13 +291,6 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonSnakeCase {\n         }\n     }\n \n-    fn check_lifetime_def(&mut self, cx: &LateContext, t: &hir::LifetimeDef) {\n-        self.check_snake_case(cx,\n-                              \"lifetime\",\n-                              &t.lifetime.name.name().as_str(),\n-                              Some(t.lifetime.span));\n-    }\n-\n     fn check_pat(&mut self, cx: &LateContext, p: &hir::Pat) {\n         if let &PatKind::Binding(_, _, ref path1, _) = &p.node {\n             self.check_snake_case(cx, \"variable\", &path1.node.as_str(), Some(p.span));"}, {"sha": "81db44b0553114ea4b80ac15086c44d71c00e52d", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/250b492052e94d76bd318a4b932159395da55981/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/250b492052e94d76bd318a4b932159395da55981/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=250b492052e94d76bd318a4b932159395da55981", "patch": "@@ -507,21 +507,21 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingCopyImplementations {\n         }\n         let (def, ty) = match item.node {\n             hir::ItemStruct(_, ref ast_generics) => {\n-                if ast_generics.is_parameterized() {\n+                if !ast_generics.params.is_empty() {\n                     return;\n                 }\n                 let def = cx.tcx.adt_def(cx.tcx.hir.local_def_id(item.id));\n                 (def, cx.tcx.mk_adt(def, cx.tcx.intern_substs(&[])))\n             }\n             hir::ItemUnion(_, ref ast_generics) => {\n-                if ast_generics.is_parameterized() {\n+                if !ast_generics.params.is_empty() {\n                     return;\n                 }\n                 let def = cx.tcx.adt_def(cx.tcx.hir.local_def_id(item.id));\n                 (def, cx.tcx.mk_adt(def, cx.tcx.intern_substs(&[])))\n             }\n             hir::ItemEnum(_, ref ast_generics) => {\n-                if ast_generics.is_parameterized() {\n+                if !ast_generics.params.is_empty() {\n                     return;\n                 }\n                 let def = cx.tcx.adt_def(cx.tcx.hir.local_def_id(item.id));"}, {"sha": "c109a47f79867ea1ddf0d4a6c35ec7ae03958d17", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/250b492052e94d76bd318a4b932159395da55981/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/250b492052e94d76bd318a4b932159395da55981/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=250b492052e94d76bd318a4b932159395da55981", "patch": "@@ -744,7 +744,7 @@ impl LintPass for VariantSizeDifferences {\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for VariantSizeDifferences {\n     fn check_item(&mut self, cx: &LateContext, it: &hir::Item) {\n         if let hir::ItemEnum(ref enum_definition, ref gens) = it.node {\n-            if gens.ty_params.is_empty() {\n+            if gens.params.iter().all(|param| param.is_lifetime_param()) {\n                 // sizes only make sense for non-generic types\n                 let item_def_id = cx.tcx.hir.local_def_id(it.id);\n                 let t = cx.tcx.type_of(item_def_id);"}, {"sha": "29369f9f8bb410e1a7755ef24f31df4e366b9ce7", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/250b492052e94d76bd318a4b932159395da55981/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/250b492052e94d76bd318a4b932159395da55981/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=250b492052e94d76bd318a4b932159395da55981", "patch": "@@ -1078,8 +1078,8 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n                 }\n                 hir::ItemConst(..) => self.encode_optimized_mir(def_id),\n                 hir::ItemFn(_, _, constness, _, ref generics, _) => {\n-                    let tps_len = generics.ty_params.len();\n-                    let needs_inline = tps_len > 0 || attr::requests_inline(&item.attrs);\n+                    let has_tps = generics.ty_params().next().is_some();\n+                    let needs_inline = has_tps || attr::requests_inline(&item.attrs);\n                     let always_encode_mir = self.tcx.sess.opts.debugging_opts.always_encode_mir;\n                     if needs_inline || constness == hir::Constness::Const || always_encode_mir {\n                         self.encode_optimized_mir(def_id)\n@@ -1480,7 +1480,7 @@ impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n     }\n \n     fn encode_info_for_generics(&mut self, generics: &hir::Generics) {\n-        for ty_param in &generics.ty_params {\n+        for ty_param in generics.ty_params() {\n             let def_id = self.tcx.hir.local_def_id(ty_param.id);\n             let has_default = Untracked(ty_param.default.is_some());\n             self.record(def_id, IsolatedEncoder::encode_info_for_ty_param, (def_id, has_default));"}, {"sha": "0d9976afb9e3d508186049a8032667291a2527bc", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/250b492052e94d76bd318a4b932159395da55981/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/250b492052e94d76bd318a4b932159395da55981/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=250b492052e94d76bd318a4b932159395da55981", "patch": "@@ -922,7 +922,7 @@ impl<'b, 'a, 'v> ItemLikeVisitor<'v> for RootCollector<'b, 'a, 'v> {\n             hir::ItemEnum(_, ref generics) |\n             hir::ItemStruct(_, ref generics) |\n             hir::ItemUnion(_, ref generics) => {\n-                if !generics.is_parameterized() {\n+                if generics.params.is_empty() {\n                     if self.mode == MonoItemCollectionMode::Eager {\n                         let def_id = self.tcx.hir.local_def_id(item.id);\n                         debug!(\"RootCollector: ADT drop-glue for {}\","}, {"sha": "d74a8af921beab6864f4b1b55e31a5af4027c4e6", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 34, "deletions": 14, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/250b492052e94d76bd318a4b932159395da55981/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/250b492052e94d76bd318a4b932159395da55981/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=250b492052e94d76bd318a4b932159395da55981", "patch": "@@ -250,7 +250,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n             ItemKind::Trait(is_auto, _, ref generics, ref bounds, ref trait_items) => {\n                 if is_auto == IsAuto::Yes {\n                     // Auto traits cannot have generics, super traits nor contain items.\n-                    if !generics.ty_params.is_empty() {\n+                    if generics.is_parameterized() {\n                         self.err_handler().span_err(item.span,\n                                                     \"auto traits cannot have generics\");\n                     }\n@@ -283,17 +283,25 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                     }\n                 }\n             }\n-            ItemKind::TraitAlias(Generics { ref ty_params, .. }, ..) => {\n-                for &TyParam { ref bounds, ref default, span, .. } in ty_params {\n-                    if !bounds.is_empty() {\n-                        self.err_handler().span_err(span,\n-                                                    \"type parameters on the left side of a \\\n-                                                     trait alias cannot be bounded\");\n-                    }\n-                    if !default.is_none() {\n-                        self.err_handler().span_err(span,\n-                                                    \"type parameters on the left side of a \\\n-                                                     trait alias cannot have defaults\");\n+            ItemKind::TraitAlias(Generics { ref params, .. }, ..) => {\n+                for param in params {\n+                    if let GenericParam::Type(TyParam {\n+                        ref bounds,\n+                        ref default,\n+                        span,\n+                        ..\n+                    }) = *param\n+                    {\n+                        if !bounds.is_empty() {\n+                            self.err_handler().span_err(span,\n+                                                        \"type parameters on the left side of a \\\n+                                                         trait alias cannot be bounded\");\n+                        }\n+                        if !default.is_none() {\n+                            self.err_handler().span_err(span,\n+                                                        \"type parameters on the left side of a \\\n+                                                         trait alias cannot have defaults\");\n+                        }\n                     }\n                 }\n             }\n@@ -352,9 +360,21 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n     }\n \n     fn visit_generics(&mut self, g: &'a Generics) {\n+        let mut seen_non_lifetime_param = false;\n         let mut seen_default = None;\n-        for ty_param in &g.ty_params {\n-            if ty_param.default.is_some() {\n+        for param in &g.params {\n+            match (param, seen_non_lifetime_param) {\n+                (&GenericParam::Lifetime(ref ld), true) => {\n+                    self.err_handler()\n+                        .span_err(ld.lifetime.span, \"lifetime parameters must be leading\");\n+                },\n+                (&GenericParam::Lifetime(_), false) => {}\n+                _ => {\n+                    seen_non_lifetime_param = true;\n+                }\n+            }\n+\n+            if let GenericParam::Type(ref ty_param @ TyParam { default: Some(_), .. }) = *param {\n                 seen_default = Some(ty_param.span);\n             } else if let Some(span) = seen_default {\n                 self.err_handler()"}, {"sha": "ba0be974b2771997292c2df43b29614aeaac7ef0", "filename": "src/librustc_passes/hir_stats.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/250b492052e94d76bd318a4b932159395da55981/src%2Flibrustc_passes%2Fhir_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/250b492052e94d76bd318a4b932159395da55981/src%2Flibrustc_passes%2Fhir_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fhir_stats.rs?ref=250b492052e94d76bd318a4b932159395da55981", "patch": "@@ -224,10 +224,6 @@ impl<'v> hir_visit::Visitor<'v> for StatCollector<'v> {\n         self.record(\"Lifetime\", Id::Node(lifetime.id), lifetime);\n         hir_visit::walk_lifetime(self, lifetime)\n     }\n-    fn visit_lifetime_def(&mut self, lifetime: &'v hir::LifetimeDef) {\n-        self.record(\"LifetimeDef\", Id::None, lifetime);\n-        hir_visit::walk_lifetime_def(self, lifetime)\n-    }\n     fn visit_qpath(&mut self, qpath: &'v hir::QPath, id: NodeId, span: Span) {\n         self.record(\"QPath\", Id::None, qpath);\n         hir_visit::walk_qpath(self, qpath, id, span)\n@@ -349,11 +345,6 @@ impl<'v> ast_visit::Visitor<'v> for StatCollector<'v> {\n         ast_visit::walk_lifetime(self, lifetime)\n     }\n \n-    fn visit_lifetime_def(&mut self, lifetime: &'v ast::LifetimeDef) {\n-        self.record(\"LifetimeDef\", Id::None, lifetime);\n-        ast_visit::walk_lifetime_def(self, lifetime)\n-    }\n-\n     fn visit_mac(&mut self, mac: &'v ast::Mac) {\n         self.record(\"Mac\", Id::None, mac);\n     }"}, {"sha": "bb0a4be49c2a8d005b654572be20760b25c09121", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/250b492052e94d76bd318a4b932159395da55981/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/250b492052e94d76bd318a4b932159395da55981/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=250b492052e94d76bd318a4b932159395da55981", "patch": "@@ -1236,7 +1236,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n     }\n \n     fn visit_generics(&mut self, generics: &'tcx hir::Generics) {\n-        for ty_param in generics.ty_params.iter() {\n+        for ty_param in generics.ty_params() {\n             for bound in ty_param.bounds.iter() {\n                 self.check_ty_param_bound(bound)\n             }"}, {"sha": "b57a8bc7e77f1e5fb1c45c56f17e00e38200a53f", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 39, "deletions": 30, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/250b492052e94d76bd318a4b932159395da55981/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/250b492052e94d76bd318a4b932159395da55981/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=250b492052e94d76bd318a4b932159395da55981", "patch": "@@ -53,7 +53,7 @@ use syntax::util::lev_distance::find_best_match_for_name;\n use syntax::visit::{self, FnKind, Visitor};\n use syntax::attr;\n use syntax::ast::{Arm, BindingMode, Block, Crate, Expr, ExprKind};\n-use syntax::ast::{FnDecl, ForeignItem, ForeignItemKind, Generics};\n+use syntax::ast::{FnDecl, ForeignItem, ForeignItemKind, GenericParam, Generics};\n use syntax::ast::{Item, ItemKind, ImplItem, ImplItemKind};\n use syntax::ast::{Local, Mutability, Pat, PatKind, Path};\n use syntax::ast::{QSelf, TraitItemKind, TraitRef, Ty, TyKind};\n@@ -790,25 +790,30 @@ impl<'a, 'tcx> Visitor<'tcx> for Resolver<'a> {\n         // to following type parameters, as the Substs can only\n         // provide previous type parameters as they're built.\n         let mut default_ban_rib = Rib::new(ForwardTyParamBanRibKind);\n-        default_ban_rib.bindings.extend(generics.ty_params.iter()\n+        default_ban_rib.bindings.extend(generics.params.iter()\n+            .filter_map(|p| if let GenericParam::Type(ref tp) = *p { Some(tp) } else { None })\n             .skip_while(|p| p.default.is_none())\n             .map(|p| (Ident::with_empty_ctxt(p.ident.name), Def::Err)));\n \n-        for param in &generics.ty_params {\n-            for bound in &param.bounds {\n-                self.visit_ty_param_bound(bound);\n-            }\n+        for param in &generics.params {\n+            match *param {\n+                GenericParam::Lifetime(_) => self.visit_generic_param(param),\n+                GenericParam::Type(ref ty_param) => {\n+                    for bound in &ty_param.bounds {\n+                        self.visit_ty_param_bound(bound);\n+                    }\n \n-            if let Some(ref ty) = param.default {\n-                self.ribs[TypeNS].push(default_ban_rib);\n-                self.visit_ty(ty);\n-                default_ban_rib = self.ribs[TypeNS].pop().unwrap();\n-            }\n+                    if let Some(ref ty) = ty_param.default {\n+                        self.ribs[TypeNS].push(default_ban_rib);\n+                        self.visit_ty(ty);\n+                        default_ban_rib = self.ribs[TypeNS].pop().unwrap();\n+                    }\n \n-            // Allow all following defaults to refer to this type parameter.\n-            default_ban_rib.bindings.remove(&Ident::with_empty_ctxt(param.ident.name));\n+                    // Allow all following defaults to refer to this type parameter.\n+                    default_ban_rib.bindings.remove(&Ident::with_empty_ctxt(ty_param.ident.name));\n+                }\n+            }\n         }\n-        for lt in &generics.lifetimes { self.visit_lifetime_def(lt); }\n         for p in &generics.where_clause.predicates { self.visit_where_predicate(p); }\n     }\n }\n@@ -2022,23 +2027,27 @@ impl<'a> Resolver<'a> {\n             HasTypeParameters(generics, rib_kind) => {\n                 let mut function_type_rib = Rib::new(rib_kind);\n                 let mut seen_bindings = FxHashMap();\n-                for type_parameter in &generics.ty_params {\n-                    let ident = type_parameter.ident.modern();\n-                    debug!(\"with_type_parameter_rib: {}\", type_parameter.id);\n-\n-                    if seen_bindings.contains_key(&ident) {\n-                        let span = seen_bindings.get(&ident).unwrap();\n-                        let err =\n-                            ResolutionError::NameAlreadyUsedInTypeParameterList(ident.name, span);\n-                        resolve_error(self, type_parameter.span, err);\n-                    }\n-                    seen_bindings.entry(ident).or_insert(type_parameter.span);\n+                for param in &generics.params {\n+                    if let GenericParam::Type(ref type_parameter) = *param {\n+                        let ident = type_parameter.ident.modern();\n+                        debug!(\"with_type_parameter_rib: {}\", type_parameter.id);\n+\n+                        if seen_bindings.contains_key(&ident) {\n+                            let span = seen_bindings.get(&ident).unwrap();\n+                            let err = ResolutionError::NameAlreadyUsedInTypeParameterList(\n+                                ident.name,\n+                                span,\n+                            );\n+                            resolve_error(self, type_parameter.span, err);\n+                        }\n+                        seen_bindings.entry(ident).or_insert(type_parameter.span);\n \n-                    // plain insert (no renaming)\n-                    let def_id = self.definitions.local_def_id(type_parameter.id);\n-                    let def = Def::TyParam(def_id);\n-                    function_type_rib.bindings.insert(ident, def);\n-                    self.record_def(type_parameter.id, PathResolution::new(def));\n+                        // plain insert (no renaming)\n+                        let def_id = self.definitions.local_def_id(type_parameter.id);\n+                        let def = Def::TyParam(def_id);\n+                        function_type_rib.bindings.insert(ident, def);\n+                        self.record_def(type_parameter.id, PathResolution::new(def));\n+                    }\n                 }\n                 self.ribs[TypeNS].push(function_type_rib);\n             }"}, {"sha": "ed3b8eadad74c6c4b4d6abb7b33f7fa98bb016d9", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 47, "deletions": 38, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/250b492052e94d76bd318a4b932159395da55981/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/250b492052e94d76bd318a4b932159395da55981/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=250b492052e94d76bd318a4b932159395da55981", "patch": "@@ -36,7 +36,12 @@ use syntax::ast::{self, Attribute, NodeId, PatKind, CRATE_NODE_ID};\n use syntax::parse::token;\n use syntax::symbol::keywords;\n use syntax::visit::{self, Visitor};\n-use syntax::print::pprust::{bounds_to_string, generics_to_string, path_to_string, ty_to_string};\n+use syntax::print::pprust::{\n+    bounds_to_string,\n+    generic_params_to_string,\n+    path_to_string,\n+    ty_to_string\n+};\n use syntax::ptr::P;\n use syntax::codemap::{Spanned, DUMMY_SP};\n use syntax_pos::*;\n@@ -438,35 +443,37 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n         prefix: &str,\n         id: NodeId,\n     ) {\n-        for param in &generics.ty_params {\n-            let param_ss = param.span;\n-            let name = escape(self.span.snippet(param_ss));\n-            // Append $id to name to make sure each one is unique\n-            let qualname = format!(\"{}::{}${}\", prefix, name, id);\n-            if !self.span.filter_generated(Some(param_ss), full_span) {\n-                let id = ::id_from_node_id(param.id, &self.save_ctxt);\n-                let span = self.span_from_span(param_ss);\n+        for param in &generics.params {\n+            if let ast::GenericParam::Type(ref ty_param) = *param {\n+                let param_ss = ty_param.span;\n+                let name = escape(self.span.snippet(param_ss));\n+                // Append $id to name to make sure each one is unique\n+                let qualname = format!(\"{}::{}${}\", prefix, name, id);\n+                if !self.span.filter_generated(Some(param_ss), full_span) {\n+                    let id = ::id_from_node_id(ty_param.id, &self.save_ctxt);\n+                    let span = self.span_from_span(param_ss);\n \n-                self.dumper.dump_def(\n-                    &Access {\n-                        public: false,\n-                        reachable: false,\n-                    },\n-                    Def {\n-                        kind: DefKind::Type,\n-                        id,\n-                        span,\n-                        name,\n-                        qualname,\n-                        value: String::new(),\n-                        parent: None,\n-                        children: vec![],\n-                        decl_id: None,\n-                        docs: String::new(),\n-                        sig: None,\n-                        attributes: vec![],\n-                    },\n-                );\n+                    self.dumper.dump_def(\n+                        &Access {\n+                            public: false,\n+                            reachable: false,\n+                        },\n+                        Def {\n+                            kind: DefKind::Type,\n+                            id,\n+                            span,\n+                            name,\n+                            qualname,\n+                            value: String::new(),\n+                            parent: None,\n+                            children: vec![],\n+                            decl_id: None,\n+                            docs: String::new(),\n+                            sig: None,\n+                            attributes: vec![],\n+                        },\n+                    );\n+                }\n             }\n         }\n         self.visit_generics(generics);\n@@ -787,8 +794,8 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n         let name = item.ident.to_string();\n         let qualname = format!(\"::{}\", self.tcx.node_path_str(item.id));\n         let mut val = name.clone();\n-        if !generics.lifetimes.is_empty() || !generics.ty_params.is_empty() {\n-            val.push_str(&generics_to_string(generics));\n+        if !generics.params.is_empty() {\n+            val.push_str(&generic_params_to_string(&generics.params));\n         }\n         if !trait_refs.is_empty() {\n             val.push_str(\": \");\n@@ -1478,14 +1485,16 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> Visitor<'l> for DumpVisitor<'l, 'tc\n     }\n \n     fn visit_generics(&mut self, generics: &'l ast::Generics) {\n-        for param in generics.ty_params.iter() {\n-            for bound in param.bounds.iter() {\n-                if let ast::TraitTyParamBound(ref trait_ref, _) = *bound {\n-                    self.process_path(trait_ref.trait_ref.ref_id, &trait_ref.trait_ref.path)\n+        for param in &generics.params {\n+            if let ast::GenericParam::Type(ref ty_param) = *param {\n+                for bound in ty_param.bounds.iter() {\n+                    if let ast::TraitTyParamBound(ref trait_ref, _) = *bound {\n+                        self.process_path(trait_ref.trait_ref.ref_id, &trait_ref.trait_ref.path)\n+                    }\n+                }\n+                if let Some(ref ty) = ty_param.default {\n+                    self.visit_ty(&ty);\n                 }\n-            }\n-            if let Some(ref ty) = param.default {\n-                self.visit_ty(&ty);\n             }\n         }\n     }"}, {"sha": "93fb22a2dc0c9c26f8e1613d72646df2d86ce902", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/250b492052e94d76bd318a4b932159395da55981/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/250b492052e94d76bd318a4b932159395da55981/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=250b492052e94d76bd318a4b932159395da55981", "patch": "@@ -886,21 +886,15 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n \n fn make_signature(decl: &ast::FnDecl, generics: &ast::Generics) -> String {\n     let mut sig = \"fn \".to_owned();\n-    if !generics.lifetimes.is_empty() || !generics.ty_params.is_empty() {\n+    if !generics.params.is_empty() {\n         sig.push('<');\n         sig.push_str(&generics\n-            .lifetimes\n+            .params\n             .iter()\n-            .map(|l| l.lifetime.ident.name.to_string())\n-            .collect::<Vec<_>>()\n-            .join(\", \"));\n-        if !generics.lifetimes.is_empty() {\n-            sig.push_str(\", \");\n-        }\n-        sig.push_str(&generics\n-            .ty_params\n-            .iter()\n-            .map(|l| l.ident.to_string())\n+            .map(|param| match *param {\n+                ast::GenericParam::Lifetime(ref l) => l.lifetime.ident.name.to_string(),\n+                ast::GenericParam::Type(ref t) => t.ident.to_string(),\n+            })\n             .collect::<Vec<_>>()\n             .join(\", \"));\n         sig.push_str(\"> \");"}, {"sha": "9211ddfab671edf292caedbaecdc0dfc848852f9", "filename": "src/librustc_save_analysis/sig.rs", "status": "modified", "additions": 47, "deletions": 39, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/250b492052e94d76bd318a4b932159395da55981/src%2Flibrustc_save_analysis%2Fsig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/250b492052e94d76bd318a4b932159395da55981/src%2Flibrustc_save_analysis%2Fsig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fsig.rs?ref=250b492052e94d76bd318a4b932159395da55981", "patch": "@@ -218,12 +218,17 @@ impl Sig for ast::Ty {\n             }\n             ast::TyKind::BareFn(ref f) => {\n                 let mut text = String::new();\n-                if !f.lifetimes.is_empty() {\n+                if !f.generic_params.is_empty() {\n                     // FIXME defs, bounds on lifetimes\n                     text.push_str(\"for<\");\n-                    text.push_str(&f.lifetimes\n+                    text.push_str(&f.generic_params\n                         .iter()\n-                        .map(|l| l.lifetime.ident.to_string())\n+                        .filter_map(|p| match *p {\n+                            ast::GenericParam::Lifetime(ref l) => {\n+                                Some(l.lifetime.ident.to_string())\n+                            }\n+                            _ => None,\n+                        })\n                         .collect::<Vec<_>>()\n                         .join(\", \"));\n                     text.push('>');\n@@ -615,50 +620,53 @@ impl Sig for ast::Path {\n // This does not cover the where clause, which must be processed separately.\n impl Sig for ast::Generics {\n     fn make(&self, offset: usize, _parent_id: Option<NodeId>, scx: &SaveContext) -> Result {\n-        let total = self.lifetimes.len() + self.ty_params.len();\n-        if total == 0 {\n+        if self.params.is_empty() {\n             return Ok(text_sig(String::new()));\n         }\n \n         let mut text = \"<\".to_owned();\n \n         let mut defs = vec![];\n-        for l in &self.lifetimes {\n-            let mut l_text = l.lifetime.ident.to_string();\n-            defs.push(SigElement {\n-                id: id_from_node_id(l.lifetime.id, scx),\n-                start: offset + text.len(),\n-                end: offset + text.len() + l_text.len(),\n-            });\n-\n-            if !l.bounds.is_empty() {\n-                l_text.push_str(\": \");\n-                let bounds = l.bounds\n-                    .iter()\n-                    .map(|l| l.ident.to_string())\n-                    .collect::<Vec<_>>()\n-                    .join(\" + \");\n-                l_text.push_str(&bounds);\n-                // FIXME add lifetime bounds refs.\n-            }\n-            text.push_str(&l_text);\n-            text.push(',');\n-        }\n-        for t in &self.ty_params {\n-            let mut t_text = t.ident.to_string();\n-            defs.push(SigElement {\n-                id: id_from_node_id(t.id, scx),\n-                start: offset + text.len(),\n-                end: offset + text.len() + t_text.len(),\n-            });\n+        for param in &self.params {\n+            match *param {\n+                ast::GenericParam::Lifetime(ref l) => {\n+                    let mut l_text = l.lifetime.ident.to_string();\n+                    defs.push(SigElement {\n+                        id: id_from_node_id(l.lifetime.id, scx),\n+                        start: offset + text.len(),\n+                        end: offset + text.len() + l_text.len(),\n+                    });\n+\n+                    if !l.bounds.is_empty() {\n+                        l_text.push_str(\": \");\n+                        let bounds = l.bounds\n+                            .iter()\n+                            .map(|l| l.ident.to_string())\n+                            .collect::<Vec<_>>()\n+                            .join(\" + \");\n+                        l_text.push_str(&bounds);\n+                        // FIXME add lifetime bounds refs.\n+                    }\n+                    text.push_str(&l_text);\n+                    text.push(',');\n+                }\n+                ast::GenericParam::Type(ref t) => {\n+                    let mut t_text = t.ident.to_string();\n+                    defs.push(SigElement {\n+                        id: id_from_node_id(t.id, scx),\n+                        start: offset + text.len(),\n+                        end: offset + text.len() + t_text.len(),\n+                    });\n \n-            if !t.bounds.is_empty() {\n-                t_text.push_str(\": \");\n-                t_text.push_str(&pprust::bounds_to_string(&t.bounds));\n-                // FIXME descend properly into bounds.\n+                    if !t.bounds.is_empty() {\n+                        t_text.push_str(\": \");\n+                        t_text.push_str(&pprust::bounds_to_string(&t.bounds));\n+                        // FIXME descend properly into bounds.\n+                    }\n+                    text.push_str(&t_text);\n+                    text.push(',');\n+                }\n             }\n-            text.push_str(&t_text);\n-            text.push(',');\n         }\n \n         text.push('>');"}, {"sha": "734287f5f7d2992d89afe8b15406e96e0be89af8", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/250b492052e94d76bd318a4b932159395da55981/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/250b492052e94d76bd318a4b932159395da55981/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=250b492052e94d76bd318a4b932159395da55981", "patch": "@@ -562,10 +562,10 @@ fn compare_number_of_generics<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     if num_impl_m_type_params != num_trait_m_type_params {\n         let impl_m_node_id = tcx.hir.as_local_node_id(impl_m.def_id).unwrap();\n         let impl_m_item = tcx.hir.expect_impl_item(impl_m_node_id);\n-        let span = if impl_m_item.generics.is_parameterized() {\n-            impl_m_item.generics.span\n-        } else {\n+        let span = if impl_m_item.generics.params.is_empty() {\n             impl_m_span\n+        } else {\n+            impl_m_item.generics.span\n         };\n \n         let mut err = struct_span_err!(tcx.sess,"}, {"sha": "77272b18f13b4fb331cd35dc6040c99140c076af", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/250b492052e94d76bd318a4b932159395da55981/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/250b492052e94d76bd318a4b932159395da55981/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=250b492052e94d76bd318a4b932159395da55981", "patch": "@@ -4949,24 +4949,26 @@ pub fn check_bounds_are_used<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                        generics: &hir::Generics,\n                                        ty: Ty<'tcx>) {\n     debug!(\"check_bounds_are_used(n_tps={}, ty={:?})\",\n-           generics.ty_params.len(),  ty);\n+           generics.ty_params().count(),  ty);\n \n     // make a vector of booleans initially false, set to true when used\n-    if generics.ty_params.is_empty() { return; }\n-    let mut tps_used = vec![false; generics.ty_params.len()];\n+    if generics.ty_params().next().is_none() { return; }\n+    let mut tps_used = vec![false; generics.ty_params().count()];\n+\n+    let lifetime_count = generics.lifetimes().count();\n \n     for leaf_ty in ty.walk() {\n         if let ty::TyParam(ParamTy {idx, ..}) = leaf_ty.sty {\n             debug!(\"Found use of ty param num {}\", idx);\n-            tps_used[idx as usize - generics.lifetimes.len()] = true;\n+            tps_used[idx as usize - lifetime_count] = true;\n         } else if let ty::TyError = leaf_ty.sty {\n             // If there already another error, do not emit an error for not using a type Parameter\n             assert!(tcx.sess.err_count() > 0);\n             return;\n         }\n     }\n \n-    for (&used, param) in tps_used.iter().zip(&generics.ty_params) {\n+    for (&used, param) in tps_used.iter().zip(generics.ty_params()) {\n         if !used {\n             struct_span_err!(tcx.sess, param.span, E0091,\n                 \"type parameter `{}` is unused\","}, {"sha": "385b9321db71ab10c50c8ac94a8e0a869cc4d719", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/250b492052e94d76bd318a4b932159395da55981/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/250b492052e94d76bd318a4b932159395da55981/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=250b492052e94d76bd318a4b932159395da55981", "patch": "@@ -592,13 +592,9 @@ impl<'a, 'gcx> CheckTypeWellFormedVisitor<'a, 'gcx> {\n                 continue;\n             }\n \n-            let (span, name) = if index < ast_generics.lifetimes.len() {\n-                (ast_generics.lifetimes[index].lifetime.span,\n-                 ast_generics.lifetimes[index].lifetime.name.name())\n-            } else {\n-                let index = index - ast_generics.lifetimes.len();\n-                (ast_generics.ty_params[index].span,\n-                 ast_generics.ty_params[index].name)\n+            let (span, name) = match ast_generics.params[index] {\n+                hir::GenericParam::Lifetime(ref ld) => (ld.lifetime.span, ld.lifetime.name.name()),\n+                hir::GenericParam::Type(ref tp) => (tp.span, tp.name),\n             };\n             self.report_bivariance(span, name);\n         }"}, {"sha": "0a6d87e5a60b74e4e4b0701e29dac7c3a76afc6c", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/250b492052e94d76bd318a4b932159395da55981/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/250b492052e94d76bd318a4b932159395da55981/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=250b492052e94d76bd318a4b932159395da55981", "patch": "@@ -111,7 +111,7 @@ impl<'a, 'tcx> Visitor<'tcx> for CollectItemTypesVisitor<'a, 'tcx> {\n     }\n \n     fn visit_generics(&mut self, generics: &'tcx hir::Generics) {\n-        for param in &generics.ty_params {\n+        for param in generics.ty_params() {\n             if param.default.is_some() {\n                 let def_id = self.tcx.hir.local_def_id(param.id);\n                 self.tcx.type_of(def_id);\n@@ -315,8 +315,7 @@ impl<'a, 'tcx> ItemCtxt<'a, 'tcx> {\n                                          -> Vec<ty::Predicate<'tcx>>\n     {\n         let from_ty_params =\n-            ast_generics.ty_params\n-                .iter()\n+            ast_generics.ty_params()\n                 .filter(|p| p.id == param_id)\n                 .flat_map(|p| p.bounds.iter())\n                 .flat_map(|b| predicates_from_bound(self, ty, b));\n@@ -365,7 +364,7 @@ fn ensure_no_ty_param_bounds(tcx: TyCtxt,\n                              thing: &'static str) {\n     let mut warn = false;\n \n-    for ty_param in generics.ty_params.iter() {\n+    for ty_param in generics.ty_params() {\n         for bound in ty_param.bounds.iter() {\n             match *bound {\n                 hir::TraitTyParamBound(..) => {\n@@ -804,7 +803,7 @@ fn has_late_bound_regions<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         let mut visitor = LateBoundRegionsDetector {\n             tcx, binder_depth: 1, has_late_bound_regions: None\n         };\n-        for lifetime in &generics.lifetimes {\n+        for lifetime in generics.lifetimes() {\n             let hir_id = tcx.hir.node_to_hir_id(lifetime.lifetime.id);\n             if tcx.is_late_bound(hir_id) {\n                 return Some(lifetime.lifetime.span);\n@@ -964,7 +963,7 @@ fn generics_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     // Now create the real type parameters.\n     let type_start = own_start + regions.len() as u32;\n-    let types = ast_generics.ty_params.iter().enumerate().map(|(i, p)| {\n+    let types = ast_generics.ty_params().enumerate().map(|(i, p)| {\n         if p.name == keywords::SelfType.name() {\n             span_bug!(p.span, \"`Self` should not be the name of a regular parameter\");\n         }\n@@ -1359,8 +1358,7 @@ fn early_bound_lifetimes_from_generics<'a, 'tcx>(\n     -> impl Iterator<Item=&'a hir::LifetimeDef>\n {\n     ast_generics\n-        .lifetimes\n-        .iter()\n+        .lifetimes()\n         .filter(move |l| {\n             let hir_id = tcx.hir.node_to_hir_id(l.lifetime.id);\n             !tcx.is_late_bound(hir_id)\n@@ -1492,7 +1490,7 @@ fn explicit_predicates_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     // Collect the predicates that were written inline by the user on each\n     // type parameter (e.g., `<T:Foo>`).\n-    for param in &ast_generics.ty_params {\n+    for param in ast_generics.ty_params() {\n         let param_ty = ty::ParamTy::new(index, param.name).to_ty(tcx);\n         index += 1;\n "}, {"sha": "1eed1bf4b71fb58e19496d11e9a15ea555210eba", "filename": "src/librustc_typeck/impl_wf_check.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/250b492052e94d76bd318a4b932159395da55981/src%2Flibrustc_typeck%2Fimpl_wf_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/250b492052e94d76bd318a4b932159395da55981/src%2Flibrustc_typeck%2Fimpl_wf_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fimpl_wf_check.rs?ref=250b492052e94d76bd318a4b932159395da55981", "patch": "@@ -105,7 +105,7 @@ fn enforce_impl_params_are_constrained<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         tcx, &impl_predicates.predicates.as_slice(), impl_trait_ref, &mut input_parameters);\n \n     // Disallow ANY unconstrained type parameters.\n-    for (ty_param, param) in impl_generics.types.iter().zip(&impl_hir_generics.ty_params) {\n+    for (ty_param, param) in impl_generics.types.iter().zip(impl_hir_generics.ty_params()) {\n         let param_ty = ty::ParamTy::for_def(ty_param);\n         if !input_parameters.contains(&ctp::Parameter::from(param_ty)) {\n             report_unused_parameter(tcx, param.span, \"type\", &param_ty.to_string());\n@@ -123,7 +123,7 @@ fn enforce_impl_params_are_constrained<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             ctp::parameters_for(&tcx.type_of(def_id), true)\n         }).collect();\n     for (ty_lifetime, lifetime) in impl_generics.regions.iter()\n-        .zip(&impl_hir_generics.lifetimes)\n+        .zip(impl_hir_generics.lifetimes())\n     {\n         let param = ctp::Parameter::from(ty_lifetime.to_early_bound_region_data());\n "}, {"sha": "129511ee64c62b59407ac23e16585639c36594b8", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/250b492052e94d76bd318a4b932159395da55981/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/250b492052e94d76bd318a4b932159395da55981/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=250b492052e94d76bd318a4b932159395da55981", "patch": "@@ -186,7 +186,7 @@ fn check_main_fn_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 Some(hir_map::NodeItem(it)) => {\n                     match it.node {\n                         hir::ItemFn(.., ref generics, _) => {\n-                            if generics.is_parameterized() {\n+                            if !generics.params.is_empty() {\n                                 struct_span_err!(tcx.sess, generics.span, E0131,\n                                          \"main function is not allowed to have type parameters\")\n                                     .span_label(generics.span,\n@@ -235,7 +235,7 @@ fn check_start_fn_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 Some(hir_map::NodeItem(it)) => {\n                     match it.node {\n                         hir::ItemFn(..,ref ps,_)\n-                        if ps.is_parameterized() => {\n+                        if !ps.params.is_empty() => {\n                             struct_span_err!(tcx.sess, ps.span, E0132,\n                                 \"start function is not allowed to have type parameters\")\n                                 .span_label(ps.span,"}, {"sha": "dc157f682fcea839ac1149d263bc52802df99cfa", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 49, "deletions": 38, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/250b492052e94d76bd318a4b932159395da55981/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/250b492052e94d76bd318a4b932159395da55981/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=250b492052e94d76bd318a4b932159395da55981", "patch": "@@ -43,6 +43,7 @@ use rustc_typeck::hir_ty_to_ty;\n use rustc::hir;\n \n use rustc_const_math::ConstInt;\n+use std::default::Default;\n use std::{mem, slice, vec};\n use std::iter::FromIterator;\n use std::rc::Rc;\n@@ -856,7 +857,7 @@ impl TyParamBound {\n                 did,\n                 is_generic: false,\n             },\n-            lifetimes: vec![]\n+            generic_params: Vec::new(),\n         }, hir::TraitBoundModifier::Maybe)\n     }\n \n@@ -951,7 +952,7 @@ impl<'tcx> Clean<TyParamBound> for ty::TraitRef<'tcx> {\n                         if let &ty::RegionKind::ReLateBound(..) = *reg {\n                             debug!(\"  hit an ReLateBound {:?}\", reg);\n                             if let Some(lt) = reg.clean(cx) {\n-                                late_bounds.push(lt);\n+                                late_bounds.push(GenericParam::Lifetime(lt));\n                             }\n                         }\n                     }\n@@ -967,7 +968,7 @@ impl<'tcx> Clean<TyParamBound> for ty::TraitRef<'tcx> {\n                     did: self.def_id,\n                     is_generic: false,\n                 },\n-                lifetimes: late_bounds,\n+                generic_params: late_bounds,\n             },\n             hir::TraitBoundModifier::None\n         )\n@@ -981,7 +982,7 @@ impl<'tcx> Clean<Option<Vec<TyParamBound>>> for Substs<'tcx> {\n                      .map(RegionBound));\n         v.extend(self.types().map(|t| TraitBound(PolyTrait {\n             trait_: t.clean(cx),\n-            lifetimes: vec![]\n+            generic_params: Vec::new(),\n         }, hir::TraitBoundModifier::None)));\n         if !v.is_empty() {Some(v)} else {None}\n     }\n@@ -1186,19 +1187,31 @@ impl<'tcx> Clean<Type> for ty::ProjectionTy<'tcx> {\n     }\n }\n \n-// maybe use a Generic enum and use Vec<Generic>?\n #[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Debug)]\n+pub enum GenericParam {\n+    Lifetime(Lifetime),\n+    Type(TyParam),\n+}\n+\n+impl Clean<GenericParam> for hir::GenericParam {\n+    fn clean(&self, cx: &DocContext) -> GenericParam {\n+        match *self {\n+            hir::GenericParam::Lifetime(ref l) => GenericParam::Lifetime(l.clean(cx)),\n+            hir::GenericParam::Type(ref t) => GenericParam::Type(t.clean(cx)),\n+        }\n+    }\n+}\n+\n+#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Debug, Default)]\n pub struct Generics {\n-    pub lifetimes: Vec<Lifetime>,\n-    pub type_params: Vec<TyParam>,\n+    pub params: Vec<GenericParam>,\n     pub where_predicates: Vec<WherePredicate>,\n }\n \n impl Clean<Generics> for hir::Generics {\n     fn clean(&self, cx: &DocContext) -> Generics {\n         let mut g = Generics {\n-            lifetimes: self.lifetimes.clean(cx),\n-            type_params: self.ty_params.clean(cx),\n+            params: self.params.clean(cx),\n             where_predicates: self.where_clause.predicates.clean(cx)\n         };\n \n@@ -1209,10 +1222,12 @@ impl Clean<Generics> for hir::Generics {\n             match *where_pred {\n                 WherePredicate::BoundPredicate { ty: Generic(ref name), ref mut bounds } => {\n                     if bounds.is_empty() {\n-                        for type_params in &mut g.type_params {\n-                            if &type_params.name == name {\n-                                mem::swap(bounds, &mut type_params.bounds);\n-                                break\n+                        for param in &mut g.params {\n+                            if let GenericParam::Type(ref mut type_param) = *param {\n+                                if &type_param.name == name {\n+                                    mem::swap(bounds, &mut type_param.bounds);\n+                                    break\n+                                }\n                             }\n                         }\n                     }\n@@ -1283,8 +1298,16 @@ impl<'a, 'tcx> Clean<Generics> for (&'a ty::Generics,\n         // and instead see `where T: Foo + Bar + Sized + 'a`\n \n         Generics {\n-            type_params: simplify::ty_params(stripped_typarams),\n-            lifetimes: gens.regions.clean(cx),\n+            params: gens.regions\n+                .clean(cx)\n+                .into_iter()\n+                .map(|lp| GenericParam::Lifetime(lp))\n+                .chain(\n+                    simplify::ty_params(stripped_typarams)\n+                        .into_iter()\n+                        .map(|tp| GenericParam::Type(tp))\n+                )\n+                .collect(),\n             where_predicates: simplify::where_clauses(cx, where_predicates),\n         }\n     }\n@@ -1538,7 +1561,7 @@ impl Clean<PolyTrait> for hir::PolyTraitRef {\n     fn clean(&self, cx: &DocContext) -> PolyTrait {\n         PolyTrait {\n             trait_: self.trait_ref.clean(cx),\n-            lifetimes: self.bound_lifetimes.clean(cx)\n+            generic_params: self.bound_generic_params.clean(cx)\n         }\n     }\n }\n@@ -1590,11 +1613,7 @@ impl Clean<Item> for hir::ImplItem {\n             }\n             hir::ImplItemKind::Type(ref ty) => TypedefItem(Typedef {\n                 type_: ty.clean(cx),\n-                generics: Generics {\n-                    lifetimes: Vec::new(),\n-                    type_params: Vec::new(),\n-                    where_predicates: Vec::new()\n-                },\n+                generics: Generics::default(),\n             }, true),\n         };\n         Item {\n@@ -1726,8 +1745,7 @@ impl<'tcx> Clean<Item> for ty::AssociatedItem {\n                     TypedefItem(Typedef {\n                         type_: cx.tcx.type_of(self.def_id).clean(cx),\n                         generics: Generics {\n-                            lifetimes: Vec::new(),\n-                            type_params: Vec::new(),\n+                            params: Vec::new(),\n                             where_predicates: Vec::new(),\n                         },\n                     }, true)\n@@ -1757,7 +1775,7 @@ impl<'tcx> Clean<Item> for ty::AssociatedItem {\n #[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Debug)]\n pub struct PolyTrait {\n     pub trait_: Type,\n-    pub lifetimes: Vec<Lifetime>\n+    pub generic_params: Vec<GenericParam>,\n }\n \n /// A representation of a Type suitable for hyperlinking purposes. Ideally one can get the original\n@@ -2081,15 +2099,16 @@ impl Clean<Type> for hir::Ty {\n                     let mut ty_substs = FxHashMap();\n                     let mut lt_substs = FxHashMap();\n                     provided_params.with_parameters(|provided_params| {\n-                        for (i, ty_param) in generics.ty_params.iter().enumerate() {\n+                        for (i, ty_param) in generics.ty_params().enumerate() {\n                             let ty_param_def = Def::TyParam(cx.tcx.hir.local_def_id(ty_param.id));\n                             if let Some(ty) = provided_params.types.get(i).cloned() {\n                                 ty_substs.insert(ty_param_def, ty.into_inner().clean(cx));\n                             } else if let Some(default) = ty_param.default.clone() {\n                                 ty_substs.insert(ty_param_def, default.into_inner().clean(cx));\n                             }\n                         }\n-                        for (i, lt_param) in generics.lifetimes.iter().enumerate() {\n+\n+                        for (i, lt_param) in generics.lifetimes().enumerate() {\n                             if let Some(lt) = provided_params.lifetimes.get(i).cloned() {\n                                 if !lt.is_elided() {\n                                     let lt_def_id = cx.tcx.hir.local_def_id(lt_param.lifetime.id);\n@@ -2197,11 +2216,7 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n                 let sig = ty.fn_sig(cx.tcx);\n                 BareFunction(box BareFunctionDecl {\n                     unsafety: sig.unsafety(),\n-                    generics: Generics {\n-                        lifetimes: Vec::new(),\n-                        type_params: Vec::new(),\n-                        where_predicates: Vec::new()\n-                    },\n+                    generic_params: Vec::new(),\n                     decl: (cx.tcx.hir.local_def_id(ast::CRATE_NODE_ID), sig).clean(cx),\n                     abi: sig.abi(),\n                 })\n@@ -2253,7 +2268,7 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n                                 did,\n                                 is_generic: false,\n                             },\n-                            lifetimes: vec![]\n+                            generic_params: Vec::new(),\n                         }, hir::TraitBoundModifier::None);\n                         typarams.push(bound);\n                     }\n@@ -2713,7 +2728,7 @@ impl Clean<Item> for doctree::Typedef {\n #[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Debug)]\n pub struct BareFunctionDecl {\n     pub unsafety: hir::Unsafety,\n-    pub generics: Generics,\n+    pub generic_params: Vec<GenericParam>,\n     pub decl: FnDecl,\n     pub abi: Abi,\n }\n@@ -2722,11 +2737,7 @@ impl Clean<BareFunctionDecl> for hir::BareFnTy {\n     fn clean(&self, cx: &DocContext) -> BareFunctionDecl {\n         BareFunctionDecl {\n             unsafety: self.unsafety,\n-            generics: Generics {\n-                lifetimes: self.lifetimes.clean(cx),\n-                type_params: Vec::new(),\n-                where_predicates: Vec::new()\n-            },\n+            generic_params: self.generic_params.clean(cx),\n             decl: (&*self.decl, &self.arg_names[..]).clean(cx),\n             abi: self.abi,\n         }"}, {"sha": "7300721c3840659a56fca25fcf8e14dae2a90976", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 20, "deletions": 43, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/250b492052e94d76bd318a4b932159395da55981/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/250b492052e94d76bd318a4b932159395da55981/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=250b492052e94d76bd318a4b932159395da55981", "patch": "@@ -118,30 +118,11 @@ impl<'a> fmt::Display for TyParamBounds<'a> {\n     }\n }\n \n-impl fmt::Display for clean::Generics {\n+impl fmt::Display for clean::GenericParam {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        if self.lifetimes.is_empty() && self.type_params.is_empty() { return Ok(()) }\n-        if f.alternate() {\n-            f.write_str(\"<\")?;\n-        } else {\n-            f.write_str(\"&lt;\")?;\n-        }\n-\n-        for (i, life) in self.lifetimes.iter().enumerate() {\n-            if i > 0 {\n-                f.write_str(\", \")?;\n-            }\n-            write!(f, \"{}\", *life)?;\n-        }\n-\n-        if !self.type_params.is_empty() {\n-            if !self.lifetimes.is_empty() {\n-                f.write_str(\", \")?;\n-            }\n-            for (i, tp) in self.type_params.iter().enumerate() {\n-                if i > 0 {\n-                    f.write_str(\", \")?\n-                }\n+        match *self {\n+            clean::GenericParam::Lifetime(ref lp) => write!(f, \"{}\", lp),\n+            clean::GenericParam::Type(ref tp) => {\n                 f.write_str(&tp.name)?;\n \n                 if !tp.bounds.is_empty() {\n@@ -158,15 +139,22 @@ impl fmt::Display for clean::Generics {\n                     } else {\n                         write!(f, \"&nbsp;=&nbsp;{}\", ty)?;\n                     }\n-                };\n+                }\n+\n+                Ok(())\n             }\n         }\n+    }\n+}\n+\n+impl fmt::Display for clean::Generics {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        if self.params.is_empty() { return Ok(()) }\n         if f.alternate() {\n-            f.write_str(\">\")?;\n+            write!(f, \"<{:#}>\", CommaSep(&self.params))\n         } else {\n-            f.write_str(\"&gt;\")?;\n+            write!(f, \"&lt;{}&gt;\", CommaSep(&self.params))\n         }\n-        Ok(())\n     }\n }\n \n@@ -259,22 +247,11 @@ impl fmt::Display for clean::Lifetime {\n \n impl fmt::Display for clean::PolyTrait {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        if !self.lifetimes.is_empty() {\n-            if f.alternate() {\n-                f.write_str(\"for<\")?;\n-            } else {\n-                f.write_str(\"for&lt;\")?;\n-            }\n-            for (i, lt) in self.lifetimes.iter().enumerate() {\n-                if i > 0 {\n-                    f.write_str(\", \")?;\n-                }\n-                write!(f, \"{}\", lt)?;\n-            }\n+        if !self.generic_params.is_empty() {\n             if f.alternate() {\n-                f.write_str(\"> \")?;\n+                write!(f, \"for<{:#}> \", CommaSep(&self.generic_params))?;\n             } else {\n-                f.write_str(\"&gt; \")?;\n+                write!(f, \"for&lt;{}&gt; \", CommaSep(&self.generic_params))?;\n             }\n         }\n         if f.alternate() {\n@@ -602,12 +579,12 @@ fn fmt_type(t: &clean::Type, f: &mut fmt::Formatter, use_absolute: bool) -> fmt:\n                 write!(f, \"{}{:#}fn{:#}{:#}\",\n                        UnsafetySpace(decl.unsafety),\n                        AbiSpace(decl.abi),\n-                       decl.generics,\n+                       CommaSep(&decl.generic_params),\n                        decl.decl)\n             } else {\n                 write!(f, \"{}{}\", UnsafetySpace(decl.unsafety), AbiSpace(decl.abi))?;\n                 primitive_link(f, PrimitiveType::Fn, \"fn\")?;\n-                write!(f, \"{}{}\", decl.generics, decl.decl)\n+                write!(f, \"{}{}\", CommaSep(&decl.generic_params), decl.decl)\n             }\n         }\n         clean::Tuple(ref typs) => {"}, {"sha": "515baa2c6698f7a306069d3ef025f9ffb40d7ded", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/250b492052e94d76bd318a4b932159395da55981/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/250b492052e94d76bd318a4b932159395da55981/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=250b492052e94d76bd318a4b932159395da55981", "patch": "@@ -1424,8 +1424,10 @@ impl DocFolder for Cache {\n \n impl<'a> Cache {\n     fn generics(&mut self, generics: &clean::Generics) {\n-        for typ in &generics.type_params {\n-            self.typarams.insert(typ.did, typ.name.clone());\n+        for param in &generics.params {\n+            if let clean::GenericParam::Type(ref typ) = *param {\n+                self.typarams.insert(typ.did, typ.name.clone());\n+            }\n         }\n     }\n }"}, {"sha": "77ce6b7c3ca0baadb9c038e317f3cab93dd1f6cf", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 43, "deletions": 18, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/250b492052e94d76bd318a4b932159395da55981/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/250b492052e94d76bd318a4b932159395da55981/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=250b492052e94d76bd318a4b932159395da55981", "patch": "@@ -301,30 +301,56 @@ pub struct TyParam {\n     pub span: Span,\n }\n \n-/// Represents lifetimes and type parameters attached to a declaration\n-/// of a function, enum, trait, etc.\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+pub enum GenericParam {\n+    Lifetime(LifetimeDef),\n+    Type(TyParam),\n+}\n+\n+impl GenericParam {\n+    pub fn is_lifetime_param(&self) -> bool {\n+        match *self {\n+            GenericParam::Lifetime(_) => true,\n+            _ => false,\n+        }\n+    }\n+\n+    pub fn is_type_param(&self) -> bool {\n+        match *self {\n+            GenericParam::Type(_) => true,\n+            _ => false,\n+        }\n+    }\n+}\n+\n+/// Represents lifetime, type and const parameters attached to a declaration of\n+/// a function, enum, trait, etc.\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct Generics {\n-    pub lifetimes: Vec<LifetimeDef>,\n-    pub ty_params: Vec<TyParam>,\n+    pub params: Vec<GenericParam>,\n     pub where_clause: WhereClause,\n     pub span: Span,\n }\n \n impl Generics {\n     pub fn is_lt_parameterized(&self) -> bool {\n-        !self.lifetimes.is_empty()\n+        self.params.iter().any(|param| param.is_lifetime_param())\n     }\n+\n     pub fn is_type_parameterized(&self) -> bool {\n-        !self.ty_params.is_empty()\n+        self.params.iter().any(|param| param.is_type_param())\n     }\n+\n     pub fn is_parameterized(&self) -> bool {\n-        self.is_lt_parameterized() || self.is_type_parameterized()\n+        !self.params.is_empty()\n     }\n+\n     pub fn span_for_name(&self, name: &str) -> Option<Span> {\n-        for t in &self.ty_params {\n-            if t.ident.name == name {\n-                return Some(t.span);\n+        for param in &self.params {\n+            if let GenericParam::Type(ref t) = *param {\n+                if t.ident.name == name {\n+                    return Some(t.span);\n+                }\n             }\n         }\n         None\n@@ -335,8 +361,7 @@ impl Default for Generics {\n     /// Creates an instance of `Generics`.\n     fn default() ->  Generics {\n         Generics {\n-            lifetimes: Vec::new(),\n-            ty_params: Vec::new(),\n+            params: Vec::new(),\n             where_clause: WhereClause {\n                 id: DUMMY_NODE_ID,\n                 predicates: Vec::new(),\n@@ -372,8 +397,8 @@ pub enum WherePredicate {\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct WhereBoundPredicate {\n     pub span: Span,\n-    /// Any lifetimes from a `for` binding\n-    pub bound_lifetimes: Vec<LifetimeDef>,\n+    /// Any generics from a `for` binding\n+    pub bound_generic_params: Vec<GenericParam>,\n     /// The type being bounded\n     pub bounded_ty: P<Ty>,\n     /// Trait and lifetime bounds (`Clone+Send+'static`)\n@@ -1461,7 +1486,7 @@ impl fmt::Debug for Ty {\n pub struct BareFnTy {\n     pub unsafety: Unsafety,\n     pub abi: Abi,\n-    pub lifetimes: Vec<LifetimeDef>,\n+    pub generic_params: Vec<GenericParam>,\n     pub decl: P<FnDecl>\n }\n \n@@ -1820,7 +1845,7 @@ pub struct TraitRef {\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct PolyTraitRef {\n     /// The `'a` in `<'a> Foo<&'a T>`\n-    pub bound_lifetimes: Vec<LifetimeDef>,\n+    pub bound_generic_params: Vec<GenericParam>,\n \n     /// The `Foo<&'a T>` in `<'a> Foo<&'a T>`\n     pub trait_ref: TraitRef,\n@@ -1829,9 +1854,9 @@ pub struct PolyTraitRef {\n }\n \n impl PolyTraitRef {\n-    pub fn new(lifetimes: Vec<LifetimeDef>, path: Path, span: Span) -> Self {\n+    pub fn new(generic_params: Vec<GenericParam>, path: Path, span: Span) -> Self {\n         PolyTraitRef {\n-            bound_lifetimes: lifetimes,\n+            bound_generic_params: generic_params,\n             trait_ref: TraitRef { path: path, ref_id: DUMMY_NODE_ID },\n             span,\n         }"}, {"sha": "0b3272fc1db24fb1a282f8a9de1cb49ff8fc21ec", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/250b492052e94d76bd318a4b932159395da55981/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/250b492052e94d76bd318a4b932159395da55981/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=250b492052e94d76bd318a4b932159395da55981", "patch": "@@ -462,7 +462,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n \n     fn poly_trait_ref(&self, span: Span, path: ast::Path) -> ast::PolyTraitRef {\n         ast::PolyTraitRef {\n-            bound_lifetimes: Vec::new(),\n+            bound_generic_params: Vec::new(),\n             trait_ref: self.trait_ref(path),\n             span,\n         }"}, {"sha": "2d47382ac0fae35843afd7c98cbc3f295716bff6", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 11, "deletions": 14, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/250b492052e94d76bd318a4b932159395da55981/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/250b492052e94d76bd318a4b932159395da55981/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=250b492052e94d76bd318a4b932159395da55981", "patch": "@@ -1748,22 +1748,19 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n         visit::walk_vis(self, vis);\n     }\n \n-    fn visit_generics(&mut self, g: &'a ast::Generics) {\n-        for t in &g.ty_params {\n-            if !t.attrs.is_empty() {\n-                gate_feature_post!(&self, generic_param_attrs, t.attrs[0].span,\n-                                   \"attributes on type parameter bindings are experimental\");\n-            }\n+    fn visit_generic_param(&mut self, param: &'a ast::GenericParam) {\n+        let (attrs, explain) = match *param {\n+            ast::GenericParam::Lifetime(ref ld) =>\n+                (&ld.attrs, \"attributes on lifetime bindings are experimental\"),\n+            ast::GenericParam::Type(ref t) =>\n+                (&t.attrs, \"attributes on type parameter bindings are experimental\"),\n+        };\n+\n+        if !attrs.is_empty() {\n+            gate_feature_post!(&self, generic_param_attrs, attrs[0].span, explain);\n         }\n-        visit::walk_generics(self, g)\n-    }\n \n-    fn visit_lifetime_def(&mut self, lifetime_def: &'a ast::LifetimeDef) {\n-        if !lifetime_def.attrs.is_empty() {\n-            gate_feature_post!(&self, generic_param_attrs, lifetime_def.attrs[0].span,\n-                               \"attributes on lifetime bindings are experimental\");\n-        }\n-        visit::walk_lifetime_def(self, lifetime_def)\n+        visit::walk_generic_param(self, param)\n     }\n \n     fn visit_lifetime(&mut self, lt: &'a ast::Lifetime) {"}, {"sha": "d1aef0c5042e8c5bebac9bc41b8103bfc2f9c633", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 25, "deletions": 12, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/250b492052e94d76bd318a4b932159395da55981/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/250b492052e94d76bd318a4b932159395da55981/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=250b492052e94d76bd318a4b932159395da55981", "patch": "@@ -237,8 +237,12 @@ pub trait Folder : Sized {\n         noop_fold_ty_param(tp, self)\n     }\n \n-    fn fold_ty_params(&mut self, tps: Vec<TyParam>) -> Vec<TyParam> {\n-        noop_fold_ty_params(tps, self)\n+    fn fold_generic_param(&mut self, param: GenericParam) -> GenericParam {\n+        noop_fold_generic_param(param, self)\n+    }\n+\n+    fn fold_generic_params(&mut self, params: Vec<GenericParam>) -> Vec<GenericParam> {\n+        noop_fold_generic_params(params, self)\n     }\n \n     fn fold_tt(&mut self, tt: TokenTree) -> TokenTree {\n@@ -363,8 +367,8 @@ pub fn noop_fold_ty<T: Folder>(t: P<Ty>, fld: &mut T) -> P<Ty> {\n                 TyKind::Rptr(fld.fold_opt_lifetime(region), fld.fold_mt(mt))\n             }\n             TyKind::BareFn(f) => {\n-                TyKind::BareFn(f.map(|BareFnTy {lifetimes, unsafety, abi, decl}| BareFnTy {\n-                    lifetimes: fld.fold_lifetime_defs(lifetimes),\n+                TyKind::BareFn(f.map(|BareFnTy {generic_params, unsafety, abi, decl}| BareFnTy {\n+                    generic_params: fld.fold_generic_params(generic_params),\n                     unsafety,\n                     abi,\n                     decl: fld.fold_fn_decl(decl)\n@@ -677,8 +681,18 @@ pub fn noop_fold_ty_param<T: Folder>(tp: TyParam, fld: &mut T) -> TyParam {\n     }\n }\n \n-pub fn noop_fold_ty_params<T: Folder>(tps: Vec<TyParam>, fld: &mut T) -> Vec<TyParam> {\n-    tps.move_map(|tp| fld.fold_ty_param(tp))\n+pub fn noop_fold_generic_param<T: Folder>(param: GenericParam, fld: &mut T) -> GenericParam {\n+    match param {\n+        GenericParam::Lifetime(l) => GenericParam::Lifetime(fld.fold_lifetime_def(l)),\n+        GenericParam::Type(t) => GenericParam::Type(fld.fold_ty_param(t)),\n+    }\n+}\n+\n+pub fn noop_fold_generic_params<T: Folder>(\n+    params: Vec<GenericParam>,\n+    fld: &mut T\n+) -> Vec<GenericParam> {\n+    params.move_map(|p| fld.fold_generic_param(p))\n }\n \n pub fn noop_fold_lifetime<T: Folder>(l: Lifetime, fld: &mut T) -> Lifetime {\n@@ -716,11 +730,10 @@ pub fn noop_fold_opt_lifetime<T: Folder>(o_lt: Option<Lifetime>, fld: &mut T)\n     o_lt.map(|lt| fld.fold_lifetime(lt))\n }\n \n-pub fn noop_fold_generics<T: Folder>(Generics {ty_params, lifetimes, where_clause, span}: Generics,\n+pub fn noop_fold_generics<T: Folder>(Generics { params, where_clause, span }: Generics,\n                                      fld: &mut T) -> Generics {\n     Generics {\n-        ty_params: fld.fold_ty_params(ty_params),\n-        lifetimes: fld.fold_lifetime_defs(lifetimes),\n+        params: fld.fold_generic_params(params),\n         where_clause: fld.fold_where_clause(where_clause),\n         span: fld.new_span(span),\n     }\n@@ -744,12 +757,12 @@ pub fn noop_fold_where_predicate<T: Folder>(\n                                  fld: &mut T)\n                                  -> WherePredicate {\n     match pred {\n-        ast::WherePredicate::BoundPredicate(ast::WhereBoundPredicate{bound_lifetimes,\n+        ast::WherePredicate::BoundPredicate(ast::WhereBoundPredicate{bound_generic_params,\n                                                                      bounded_ty,\n                                                                      bounds,\n                                                                      span}) => {\n             ast::WherePredicate::BoundPredicate(ast::WhereBoundPredicate {\n-                bound_lifetimes: fld.fold_lifetime_defs(bound_lifetimes),\n+                bound_generic_params: fld.fold_generic_params(bound_generic_params),\n                 bounded_ty: fld.fold_ty(bounded_ty),\n                 bounds: bounds.move_map(|x| fld.fold_ty_param_bound(x)),\n                 span: fld.new_span(span)\n@@ -806,7 +819,7 @@ pub fn noop_fold_trait_ref<T: Folder>(p: TraitRef, fld: &mut T) -> TraitRef {\n \n pub fn noop_fold_poly_trait_ref<T: Folder>(p: PolyTraitRef, fld: &mut T) -> PolyTraitRef {\n     ast::PolyTraitRef {\n-        bound_lifetimes: fld.fold_lifetime_defs(p.bound_lifetimes),\n+        bound_generic_params: fld.fold_generic_params(p.bound_generic_params),\n         trait_ref: fld.fold_trait_ref(p.trait_ref),\n         span: fld.new_span(p.span),\n     }"}, {"sha": "17bccfc2d0f3599c7b89121f064c2ee912d221fb", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/250b492052e94d76bd318a4b932159395da55981/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/250b492052e94d76bd318a4b932159395da55981/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=250b492052e94d76bd318a4b932159395da55981", "patch": "@@ -905,9 +905,8 @@ mod tests {\n                                         node: ast::Constness::NotConst,\n                                     },\n                                     Abi::Rust,\n-                                    ast::Generics{ // no idea on either of these:\n-                                        lifetimes: Vec::new(),\n-                                        ty_params: Vec::new(),\n+                                    ast::Generics{\n+                                        params: Vec::new(),\n                                         where_clause: ast::WhereClause {\n                                             id: ast::DUMMY_NODE_ID,\n                                             predicates: Vec::new(),"}, {"sha": "f81421460c7abec16597a11a48589802dbd1eb00", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 28, "deletions": 21, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/250b492052e94d76bd318a4b932159395da55981/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/250b492052e94d76bd318a4b932159395da55981/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=250b492052e94d76bd318a4b932159395da55981", "patch": "@@ -21,6 +21,7 @@ use ast::EnumDef;\n use ast::{Expr, ExprKind, RangeLimits};\n use ast::{Field, FnDecl};\n use ast::{ForeignItem, ForeignItemKind, FunctionRetTy};\n+use ast::GenericParam;\n use ast::{Ident, ImplItem, IsAuto, Item, ItemKind};\n use ast::{Lifetime, LifetimeDef, Lit, LitKind, UintTy};\n use ast::Local;\n@@ -1299,7 +1300,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// parse a TyKind::BareFn type:\n-    pub fn parse_ty_bare_fn(&mut self, lifetime_defs: Vec<LifetimeDef>)\n+    pub fn parse_ty_bare_fn(&mut self, generic_params: Vec<GenericParam>)\n                             -> PResult<'a, TyKind> {\n         /*\n \n@@ -1331,7 +1332,7 @@ impl<'a> Parser<'a> {\n         Ok(TyKind::BareFn(P(BareFnTy {\n             abi,\n             unsafety,\n-            lifetimes: lifetime_defs,\n+            generic_params,\n             decl,\n         })))\n     }\n@@ -1621,9 +1622,9 @@ impl<'a> Parser<'a> {\n         Ok(P(ty))\n     }\n \n-    fn parse_remaining_bounds(&mut self, lifetime_defs: Vec<LifetimeDef>, path: ast::Path,\n+    fn parse_remaining_bounds(&mut self, generic_params: Vec<GenericParam>, path: ast::Path,\n                               lo: Span, parse_plus: bool) -> PResult<'a, TyKind> {\n-        let poly_trait_ref = PolyTraitRef::new(lifetime_defs, path, lo.to(self.prev_span));\n+        let poly_trait_ref = PolyTraitRef::new(generic_params, path, lo.to(self.prev_span));\n         let mut bounds = vec![TraitTyParamBound(poly_trait_ref, TraitBoundModifier::None)];\n         if parse_plus {\n             self.bump(); // `+`\n@@ -4590,9 +4591,8 @@ impl<'a> Parser<'a> {\n \n     /// Parses (possibly empty) list of lifetime and type parameters, possibly including\n     /// trailing comma and erroneous trailing attributes.\n-    pub fn parse_generic_params(&mut self) -> PResult<'a, (Vec<LifetimeDef>, Vec<TyParam>)> {\n-        let mut lifetime_defs = Vec::new();\n-        let mut ty_params = Vec::new();\n+    pub fn parse_generic_params(&mut self) -> PResult<'a, Vec<ast::GenericParam>> {\n+        let mut params = Vec::new();\n         let mut seen_ty_param = false;\n         loop {\n             let attrs = self.parse_outer_attributes()?;\n@@ -4604,18 +4604,18 @@ impl<'a> Parser<'a> {\n                 } else {\n                     Vec::new()\n                 };\n-                lifetime_defs.push(LifetimeDef {\n+                params.push(ast::GenericParam::Lifetime(LifetimeDef {\n                     attrs: attrs.into(),\n                     lifetime,\n                     bounds,\n-                });\n+                }));\n                 if seen_ty_param {\n                     self.span_err(self.prev_span,\n                         \"lifetime parameters must be declared prior to type parameters\");\n                 }\n             } else if self.check_ident() {\n                 // Parse type parameter.\n-                ty_params.push(self.parse_ty_param(attrs)?);\n+                params.push(ast::GenericParam::Type(self.parse_ty_param(attrs)?));\n                 seen_ty_param = true;\n             } else {\n                 // Check for trailing attributes and stop parsing.\n@@ -4631,7 +4631,7 @@ impl<'a> Parser<'a> {\n                 break\n             }\n         }\n-        Ok((lifetime_defs, ty_params))\n+        Ok(params)\n     }\n \n     /// Parse a set of optional generic type parameter declarations. Where\n@@ -4646,11 +4646,10 @@ impl<'a> Parser<'a> {\n \n         let span_lo = self.span;\n         if self.eat_lt() {\n-            let (lifetime_defs, ty_params) = self.parse_generic_params()?;\n+            let params = self.parse_generic_params()?;\n             self.expect_gt()?;\n             Ok(ast::Generics {\n-                lifetimes: lifetime_defs,\n-                ty_params,\n+                params,\n                 where_clause: WhereClause {\n                     id: ast::DUMMY_NODE_ID,\n                     predicates: Vec::new(),\n@@ -4778,7 +4777,7 @@ impl<'a> Parser<'a> {\n                     where_clause.predicates.push(ast::WherePredicate::BoundPredicate(\n                         ast::WhereBoundPredicate {\n                             span: lo.to(self.prev_span),\n-                            bound_lifetimes: lifetime_defs,\n+                            bound_generic_params: lifetime_defs,\n                             bounded_ty: ty,\n                             bounds,\n                         }\n@@ -5403,16 +5402,24 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    fn parse_late_bound_lifetime_defs(&mut self) -> PResult<'a, Vec<LifetimeDef>> {\n+    fn parse_late_bound_lifetime_defs(&mut self) -> PResult<'a, Vec<GenericParam>> {\n         if self.eat_keyword(keywords::For) {\n             self.expect_lt()?;\n-            let (lifetime_defs, ty_params) = self.parse_generic_params()?;\n+            let params = self.parse_generic_params()?;\n             self.expect_gt()?;\n-            if !ty_params.is_empty() {\n-                self.span_err(ty_params[0].span,\n-                              \"only lifetime parameters can be used in this context\");\n+\n+            let first_non_lifetime_param_span = params.iter()\n+                .filter_map(|param| match *param {\n+                    ast::GenericParam::Lifetime(_) => None,\n+                    ast::GenericParam::Type(ref t) => Some(t.span),\n+                })\n+                .next();\n+\n+            if let Some(span) = first_non_lifetime_param_span {\n+                self.span_err(span, \"only lifetime parameters can be used in this context\");\n             }\n-            Ok(lifetime_defs)\n+\n+            Ok(params)\n         } else {\n             Ok(Vec::new())\n         }"}, {"sha": "8f619e8af765a7a92f515480fe3be7fa2705d83b", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 44, "deletions": 67, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/250b492052e94d76bd318a4b932159395da55981/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/250b492052e94d76bd318a4b932159395da55981/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=250b492052e94d76bd318a4b932159395da55981", "patch": "@@ -275,7 +275,7 @@ pub fn token_to_string(tok: &Token) -> String {\n             token::NtArm(ref e)         => arm_to_string(e),\n             token::NtImplItem(ref e)    => impl_item_to_string(e),\n             token::NtTraitItem(ref e)   => trait_item_to_string(e),\n-            token::NtGenerics(ref e)    => generics_to_string(e),\n+            token::NtGenerics(ref e)    => generic_params_to_string(&e.params),\n             token::NtWhereClause(ref e) => where_clause_to_string(e),\n             token::NtArg(ref e)         => arg_to_string(e),\n             token::NtVis(ref e)         => vis_to_string(e),\n@@ -339,8 +339,8 @@ pub fn trait_item_to_string(i: &ast::TraitItem) -> String {\n     to_string(|s| s.print_trait_item(i))\n }\n \n-pub fn generics_to_string(generics: &ast::Generics) -> String {\n-    to_string(|s| s.print_generics(generics))\n+pub fn generic_params_to_string(generic_params: &[ast::GenericParam]) -> String {\n+    to_string(|s| s.print_generic_params(generic_params))\n }\n \n pub fn where_clause_to_string(i: &ast::WhereClause) -> String {\n@@ -1043,21 +1043,11 @@ impl<'a> State<'a> {\n                 self.pclose()?;\n             }\n             ast::TyKind::BareFn(ref f) => {\n-                let generics = ast::Generics {\n-                    lifetimes: f.lifetimes.clone(),\n-                    ty_params: Vec::new(),\n-                    where_clause: ast::WhereClause {\n-                        id: ast::DUMMY_NODE_ID,\n-                        predicates: Vec::new(),\n-                        span: syntax_pos::DUMMY_SP,\n-                    },\n-                    span: syntax_pos::DUMMY_SP,\n-                };\n                 self.print_ty_fn(f.abi,\n                                  f.unsafety,\n                                  &f.decl,\n                                  None,\n-                                 &generics)?;\n+                                 &f.generic_params)?;\n             }\n             ast::TyKind::Path(None, ref path) => {\n                 self.print_path(path, false, 0, false)?;\n@@ -1271,15 +1261,15 @@ impl<'a> State<'a> {\n                 self.s.word(&ga.asm.as_str())?;\n                 self.end()?;\n             }\n-            ast::ItemKind::Ty(ref ty, ref params) => {\n+            ast::ItemKind::Ty(ref ty, ref generics) => {\n                 self.ibox(INDENT_UNIT)?;\n                 self.ibox(0)?;\n                 self.word_nbsp(&visibility_qualified(&item.vis, \"type\"))?;\n                 self.print_ident(item.ident)?;\n-                self.print_generics(params)?;\n+                self.print_generic_params(&generics.params)?;\n                 self.end()?; // end the inner ibox\n \n-                self.print_where_clause(&params.where_clause)?;\n+                self.print_where_clause(&generics.where_clause)?;\n                 self.s.space()?;\n                 self.word_space(\"=\")?;\n                 self.print_type(ty)?;\n@@ -1329,7 +1319,7 @@ impl<'a> State<'a> {\n                 self.word_nbsp(\"impl\")?;\n \n                 if generics.is_parameterized() {\n-                    self.print_generics(generics)?;\n+                    self.print_generic_params(&generics.params)?;\n                     self.s.space()?;\n                 }\n \n@@ -1361,7 +1351,7 @@ impl<'a> State<'a> {\n                 self.print_is_auto(is_auto)?;\n                 self.word_nbsp(\"trait\")?;\n                 self.print_ident(item.ident)?;\n-                self.print_generics(generics)?;\n+                self.print_generic_params(&generics.params)?;\n                 let mut real_bounds = Vec::with_capacity(bounds.len());\n                 for b in bounds.iter() {\n                     if let TraitTyParamBound(ref ptr, ast::TraitBoundModifier::Maybe) = *b {\n@@ -1386,7 +1376,7 @@ impl<'a> State<'a> {\n                 self.print_visibility(&item.vis)?;\n                 self.word_nbsp(\"trait\")?;\n                 self.print_ident(item.ident)?;\n-                self.print_generics(generics)?;\n+                self.print_generic_params(&generics.params)?;\n                 let mut real_bounds = Vec::with_capacity(bounds.len());\n                 // FIXME(durka) this seems to be some quite outdated syntax\n                 for b in bounds.iter() {\n@@ -1432,26 +1422,20 @@ impl<'a> State<'a> {\n         self.print_path(&t.path, false, 0, false)\n     }\n \n-    fn print_formal_lifetime_list(&mut self, lifetimes: &[ast::LifetimeDef]) -> io::Result<()> {\n-        if !lifetimes.is_empty() {\n-            self.s.word(\"for<\")?;\n-            let mut comma = false;\n-            for lifetime_def in lifetimes {\n-                if comma {\n-                    self.word_space(\",\")?\n-                }\n-                self.print_outer_attributes_inline(&lifetime_def.attrs)?;\n-                self.print_lifetime_bounds(&lifetime_def.lifetime, &lifetime_def.bounds)?;\n-                comma = true;\n-            }\n-            self.s.word(\">\")?;\n+    fn print_formal_generic_params(\n+        &mut self,\n+        generic_params: &[ast::GenericParam]\n+    ) -> io::Result<()> {\n+        if !generic_params.is_empty() {\n+            self.s.word(\"for\")?;\n+            self.print_generic_params(generic_params)?;\n             self.nbsp()?;\n         }\n         Ok(())\n     }\n \n     fn print_poly_trait_ref(&mut self, t: &ast::PolyTraitRef) -> io::Result<()> {\n-        self.print_formal_lifetime_list(&t.bound_lifetimes)?;\n+        self.print_formal_generic_params(&t.bound_generic_params)?;\n         self.print_trait_ref(&t.trait_ref)\n     }\n \n@@ -1461,7 +1445,7 @@ impl<'a> State<'a> {\n                           visibility: &ast::Visibility) -> io::Result<()> {\n         self.head(&visibility_qualified(visibility, \"enum\"))?;\n         self.print_ident(ident)?;\n-        self.print_generics(generics)?;\n+        self.print_generic_params(&generics.params)?;\n         self.print_where_clause(&generics.where_clause)?;\n         self.s.space()?;\n         self.print_variants(&enum_definition.variants, span)\n@@ -1517,7 +1501,7 @@ impl<'a> State<'a> {\n                         span: syntax_pos::Span,\n                         print_finalizer: bool) -> io::Result<()> {\n         self.print_ident(ident)?;\n-        self.print_generics(generics)?;\n+        self.print_generic_params(&generics.params)?;\n         if !struct_def.is_struct() {\n             if struct_def.is_tuple() {\n                 self.popen()?;\n@@ -2764,7 +2748,7 @@ impl<'a> State<'a> {\n             self.nbsp()?;\n             self.print_ident(name)?;\n         }\n-        self.print_generics(generics)?;\n+        self.print_generic_params(&generics.params)?;\n         self.print_fn_args_and_ret(decl)?;\n         self.print_where_clause(&generics.where_clause)\n     }\n@@ -2870,31 +2854,23 @@ impl<'a> State<'a> {\n         Ok(())\n     }\n \n-    pub fn print_generics(&mut self,\n-                          generics: &ast::Generics)\n-                          -> io::Result<()>\n-    {\n-        let total = generics.lifetimes.len() + generics.ty_params.len();\n-        if total == 0 {\n+    pub fn print_generic_params(\n+        &mut self,\n+        generic_params: &[ast::GenericParam]\n+    ) -> io::Result<()> {\n+        if generic_params.is_empty() {\n             return Ok(());\n         }\n \n         self.s.word(\"<\")?;\n \n-        let mut ints = Vec::new();\n-        for i in 0..total {\n-            ints.push(i);\n-        }\n-\n-        self.commasep(Inconsistent, &ints[..], |s, &idx| {\n-            if idx < generics.lifetimes.len() {\n-                let lifetime_def = &generics.lifetimes[idx];\n-                s.print_outer_attributes_inline(&lifetime_def.attrs)?;\n-                s.print_lifetime_bounds(&lifetime_def.lifetime, &lifetime_def.bounds)\n-            } else {\n-                let idx = idx - generics.lifetimes.len();\n-                let param = &generics.ty_params[idx];\n-                s.print_ty_param(param)\n+        self.commasep(Inconsistent, &generic_params, |s, param| {\n+            match *param {\n+                ast::GenericParam::Lifetime(ref lifetime_def) => {\n+                    s.print_outer_attributes_inline(&lifetime_def.attrs)?;\n+                    s.print_lifetime_bounds(&lifetime_def.lifetime, &lifetime_def.bounds)\n+                },\n+                ast::GenericParam::Type(ref ty_param) => s.print_ty_param(ty_param),\n             }\n         })?;\n \n@@ -2931,11 +2907,13 @@ impl<'a> State<'a> {\n             }\n \n             match *predicate {\n-                ast::WherePredicate::BoundPredicate(ast::WhereBoundPredicate{ref bound_lifetimes,\n-                                                                             ref bounded_ty,\n-                                                                             ref bounds,\n-                                                                             ..}) => {\n-                    self.print_formal_lifetime_list(bound_lifetimes)?;\n+                ast::WherePredicate::BoundPredicate(ast::WhereBoundPredicate {\n+                    ref bound_generic_params,\n+                    ref bounded_ty,\n+                    ref bounds,\n+                    ..\n+                }) => {\n+                    self.print_formal_generic_params(bound_generic_params)?;\n                     self.print_type(bounded_ty)?;\n                     self.print_bounds(\":\", bounds)?;\n                 }\n@@ -3057,16 +3035,15 @@ impl<'a> State<'a> {\n                        unsafety: ast::Unsafety,\n                        decl: &ast::FnDecl,\n                        name: Option<ast::Ident>,\n-                       generics: &ast::Generics)\n+                       generic_params: &Vec<ast::GenericParam>)\n                        -> io::Result<()> {\n         self.ibox(INDENT_UNIT)?;\n-        if !generics.lifetimes.is_empty() || !generics.ty_params.is_empty() {\n+        if !generic_params.is_empty() {\n             self.s.word(\"for\")?;\n-            self.print_generics(generics)?;\n+            self.print_generic_params(generic_params)?;\n         }\n         let generics = ast::Generics {\n-            lifetimes: Vec::new(),\n-            ty_params: Vec::new(),\n+            params: Vec::new(),\n             where_clause: ast::WhereClause {\n                 id: ast::DUMMY_NODE_ID,\n                 predicates: Vec::new(),"}, {"sha": "1a0f4e9278da6f60ee2201ae6dea5730197f064b", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/250b492052e94d76bd318a4b932159395da55981/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/250b492052e94d76bd318a4b932159395da55981/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=250b492052e94d76bd318a4b932159395da55981", "patch": "@@ -363,7 +363,10 @@ fn is_bench_fn(cx: &TestCtxt, i: &ast::Item) -> bool {\n                     ast::FunctionRetTy::Ty(ref t) if t.node == ast::TyKind::Tup(vec![]) => true,\n                     _ => false\n                 };\n-                let tparm_cnt = generics.ty_params.len();\n+                let tparm_cnt = generics.params.iter()\n+                    .filter(|param| param.is_type_param())\n+                    .count();\n+\n                 // NB: inadequate check, but we're running\n                 // well before resolve, can't get too deep.\n                 input_cnt == 1"}, {"sha": "da238be85e0e2dee751e34a4c6f30bc89835c189", "filename": "src/libsyntax/util/node_count.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/250b492052e94d76bd318a4b932159395da55981/src%2Flibsyntax%2Futil%2Fnode_count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/250b492052e94d76bd318a4b932159395da55981/src%2Flibsyntax%2Futil%2Fnode_count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fnode_count.rs?ref=250b492052e94d76bd318a4b932159395da55981", "patch": "@@ -71,6 +71,10 @@ impl<'ast> Visitor<'ast> for NodeCounter {\n         self.count += 1;\n         walk_ty(self, t)\n     }\n+    fn visit_generic_param(&mut self, param: &GenericParam) {\n+        self.count += 1;\n+        walk_generic_param(self, param)\n+    }\n     fn visit_generics(&mut self, g: &Generics) {\n         self.count += 1;\n         walk_generics(self, g)\n@@ -121,10 +125,6 @@ impl<'ast> Visitor<'ast> for NodeCounter {\n         self.count += 1;\n         walk_lifetime(self, lifetime)\n     }\n-    fn visit_lifetime_def(&mut self, lifetime: &LifetimeDef) {\n-        self.count += 1;\n-        walk_lifetime_def(self, lifetime)\n-    }\n     fn visit_mac(&mut self, _mac: &Mac) {\n         self.count += 1;\n         walk_mac(self, _mac)"}, {"sha": "bd68d7cf8f5d88c94eaf0eab12eb508969ff4efa", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 22, "deletions": 20, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/250b492052e94d76bd318a4b932159395da55981/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/250b492052e94d76bd318a4b932159395da55981/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=250b492052e94d76bd318a4b932159395da55981", "patch": "@@ -72,6 +72,7 @@ pub trait Visitor<'ast>: Sized {\n     fn visit_expr(&mut self, ex: &'ast Expr) { walk_expr(self, ex) }\n     fn visit_expr_post(&mut self, _ex: &'ast Expr) { }\n     fn visit_ty(&mut self, t: &'ast Ty) { walk_ty(self, t) }\n+    fn visit_generic_param(&mut self, param: &'ast GenericParam) { walk_generic_param(self, param) }\n     fn visit_generics(&mut self, g: &'ast Generics) { walk_generics(self, g) }\n     fn visit_where_predicate(&mut self, p: &'ast WherePredicate) {\n         walk_where_predicate(self, p)\n@@ -103,9 +104,6 @@ pub trait Visitor<'ast>: Sized {\n     fn visit_lifetime(&mut self, lifetime: &'ast Lifetime) {\n         walk_lifetime(self, lifetime)\n     }\n-    fn visit_lifetime_def(&mut self, lifetime: &'ast LifetimeDef) {\n-        walk_lifetime_def(self, lifetime)\n-    }\n     fn visit_mac(&mut self, _mac: &'ast Mac) {\n         panic!(\"visit_mac disabled by default\");\n         // NB: see note about macros above.\n@@ -210,18 +208,12 @@ pub fn walk_lifetime<'a, V: Visitor<'a>>(visitor: &mut V, lifetime: &'a Lifetime\n     visitor.visit_ident(lifetime.span, lifetime.ident);\n }\n \n-pub fn walk_lifetime_def<'a, V: Visitor<'a>>(visitor: &mut V, lifetime_def: &'a LifetimeDef) {\n-    visitor.visit_lifetime(&lifetime_def.lifetime);\n-    walk_list!(visitor, visit_lifetime, &lifetime_def.bounds);\n-    walk_list!(visitor, visit_attribute, &*lifetime_def.attrs);\n-}\n-\n pub fn walk_poly_trait_ref<'a, V>(visitor: &mut V,\n                                   trait_ref: &'a PolyTraitRef,\n                                   _: &TraitBoundModifier)\n     where V: Visitor<'a>,\n {\n-    walk_list!(visitor, visit_lifetime_def, &trait_ref.bound_lifetimes);\n+    walk_list!(visitor, visit_generic_param, &trait_ref.bound_generic_params);\n     visitor.visit_trait_ref(&trait_ref.trait_ref);\n }\n \n@@ -339,7 +331,7 @@ pub fn walk_ty<'a, V: Visitor<'a>>(visitor: &mut V, typ: &'a Ty) {\n         }\n         TyKind::BareFn(ref function_declaration) => {\n             walk_fn_decl(visitor, &function_declaration.decl);\n-            walk_list!(visitor, visit_lifetime_def, &function_declaration.lifetimes);\n+            walk_list!(visitor, visit_generic_param, &function_declaration.generic_params);\n         }\n         TyKind::Path(ref maybe_qself, ref path) => {\n             if let Some(ref qself) = *maybe_qself {\n@@ -499,26 +491,36 @@ pub fn walk_ty_param_bound<'a, V: Visitor<'a>>(visitor: &mut V, bound: &'a TyPar\n     }\n }\n \n-pub fn walk_generics<'a, V: Visitor<'a>>(visitor: &mut V, generics: &'a Generics) {\n-    for param in &generics.ty_params {\n-        visitor.visit_ident(param.span, param.ident);\n-        walk_list!(visitor, visit_ty_param_bound, &param.bounds);\n-        walk_list!(visitor, visit_ty, &param.default);\n-        walk_list!(visitor, visit_attribute, &*param.attrs);\n+pub fn walk_generic_param<'a, V: Visitor<'a>>(visitor: &mut V, param: &'a GenericParam) {\n+    match *param {\n+        GenericParam::Lifetime(ref l) => {\n+            visitor.visit_lifetime(&l.lifetime);\n+            walk_list!(visitor, visit_lifetime, &l.bounds);\n+            walk_list!(visitor, visit_attribute, &*l.attrs);\n+        }\n+        GenericParam::Type(ref t) => {\n+            visitor.visit_ident(t.span, t.ident);\n+            walk_list!(visitor, visit_ty_param_bound, &t.bounds);\n+            walk_list!(visitor, visit_ty, &t.default);\n+            walk_list!(visitor, visit_attribute, &*t.attrs);\n+        }\n     }\n-    walk_list!(visitor, visit_lifetime_def, &generics.lifetimes);\n+}\n+\n+pub fn walk_generics<'a, V: Visitor<'a>>(visitor: &mut V, generics: &'a Generics) {\n+    walk_list!(visitor, visit_generic_param, &generics.params);\n     walk_list!(visitor, visit_where_predicate, &generics.where_clause.predicates);\n }\n \n pub fn walk_where_predicate<'a, V: Visitor<'a>>(visitor: &mut V, predicate: &'a WherePredicate) {\n     match *predicate {\n         WherePredicate::BoundPredicate(WhereBoundPredicate{ref bounded_ty,\n                                                            ref bounds,\n-                                                           ref bound_lifetimes,\n+                                                           ref bound_generic_params,\n                                                            ..}) => {\n             visitor.visit_ty(bounded_ty);\n             walk_list!(visitor, visit_ty_param_bound, bounds);\n-            walk_list!(visitor, visit_lifetime_def, bound_lifetimes);\n+            walk_list!(visitor, visit_generic_param, bound_generic_params);\n         }\n         WherePredicate::RegionPredicate(WhereRegionPredicate{ref lifetime,\n                                                              ref bounds,"}, {"sha": "f23d22b0c365f4b82b9b2b17f46be4511137d204", "filename": "src/libsyntax_ext/deriving/clone.rs", "status": "modified", "additions": 17, "deletions": 9, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/250b492052e94d76bd318a4b932159395da55981/src%2Flibsyntax_ext%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/250b492052e94d76bd318a4b932159395da55981/src%2Flibsyntax_ext%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fclone.rs?ref=250b492052e94d76bd318a4b932159395da55981", "patch": "@@ -45,15 +45,23 @@ pub fn expand_deriving_clone(cx: &mut ExtCtxt,\n     match *item {\n         Annotatable::Item(ref annitem) => {\n             match annitem.node {\n-                ItemKind::Struct(_, Generics { ref ty_params, .. }) |\n-                ItemKind::Enum(_, Generics { ref ty_params, .. })\n-                        if attr::contains_name(&annitem.attrs, \"rustc_copy_clone_marker\") &&\n-                           ty_params.is_empty() => {\n-                    bounds = vec![];\n-                    is_shallow = true;\n-                    substructure = combine_substructure(Box::new(|c, s, sub| {\n-                        cs_clone_shallow(\"Clone\", c, s, sub, false)\n-                    }));\n+                ItemKind::Struct(_, Generics { ref params, .. }) |\n+                ItemKind::Enum(_, Generics { ref params, .. }) => {\n+                    if attr::contains_name(&annitem.attrs, \"rustc_copy_clone_marker\") &&\n+                        !params.iter().any(|param| param.is_type_param())\n+                    {\n+                        bounds = vec![];\n+                        is_shallow = true;\n+                        substructure = combine_substructure(Box::new(|c, s, sub| {\n+                            cs_clone_shallow(\"Clone\", c, s, sub, false)\n+                        }));\n+                    } else {\n+                        bounds = vec![];\n+                        is_shallow = false;\n+                        substructure = combine_substructure(Box::new(|c, s, sub| {\n+                            cs_clone(\"Clone\", c, s, sub)\n+                        }));\n+                    }\n                 }\n                 ItemKind::Union(..) => {\n                     bounds = vec![Literal(path_std!(cx, marker::Copy))];"}, {"sha": "29f5196c9bd6f904ef8eb2e3932048a1f4613a27", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 88, "deletions": 64, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/250b492052e94d76bd318a4b932159395da55981/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/250b492052e94d76bd318a4b932159395da55981/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=250b492052e94d76bd318a4b932159395da55981", "patch": "@@ -192,7 +192,9 @@ use std::collections::HashSet;\n use std::vec;\n \n use syntax::abi::Abi;\n-use syntax::ast::{self, BinOpKind, EnumDef, Expr, Generics, Ident, PatKind, VariantData};\n+use syntax::ast::{\n+    self, BinOpKind, EnumDef, Expr, GenericParam, Generics, Ident, PatKind, VariantData\n+};\n use syntax::attr;\n use syntax::ext::base::{Annotatable, ExtCtxt};\n use syntax::ext::build::AstBuilder;\n@@ -417,7 +419,7 @@ impl<'a> TraitDef<'a> {\n                     ast::ItemKind::Struct(_, ref generics) |\n                     ast::ItemKind::Enum(_, ref generics) |\n                     ast::ItemKind::Union(_, ref generics) => {\n-                        generics.ty_params.is_empty()\n+                        !generics.params.iter().any(|p| p.is_type_param())\n                     }\n                     _ => {\n                         // Non-ADT derive is an error, but it should have been\n@@ -537,32 +539,35 @@ impl<'a> TraitDef<'a> {\n             }\n         });\n \n-        let Generics { mut lifetimes, mut ty_params, mut where_clause, span } = self.generics\n+        let Generics { mut params, mut where_clause, span } = self.generics\n             .to_generics(cx, self.span, type_ident, generics);\n \n-        // Copy the lifetimes\n-        lifetimes.extend(generics.lifetimes.iter().cloned());\n-\n-        // Create the type parameters.\n-        ty_params.extend(generics.ty_params.iter().map(|ty_param| {\n-            // I don't think this can be moved out of the loop, since\n-            // a TyParamBound requires an ast id\n-            let mut bounds: Vec<_> =\n-                // extra restrictions on the generics parameters to the type being derived upon\n-                self.additional_bounds.iter().map(|p| {\n-                    cx.typarambound(p.to_path(cx, self.span,\n-                                                  type_ident, generics))\n-                }).collect();\n-\n-            // require the current trait\n-            bounds.push(cx.typarambound(trait_path.clone()));\n-\n-            // also add in any bounds from the declaration\n-            for declared_bound in ty_param.bounds.iter() {\n-                bounds.push((*declared_bound).clone());\n-            }\n+        // Create the generic parameters\n+        params.extend(generics.params.iter().map(|param| {\n+            match *param {\n+                ref l @ GenericParam::Lifetime(_) => l.clone(),\n+                GenericParam::Type(ref ty_param) => {\n+                    // I don't think this can be moved out of the loop, since\n+                    // a TyParamBound requires an ast id\n+                    let mut bounds: Vec<_> =\n+                        // extra restrictions on the generics parameters to the\n+                        // type being derived upon\n+                        self.additional_bounds.iter().map(|p| {\n+                            cx.typarambound(p.to_path(cx, self.span,\n+                                                        type_ident, generics))\n+                        }).collect();\n+\n+                    // require the current trait\n+                    bounds.push(cx.typarambound(trait_path.clone()));\n+\n+                    // also add in any bounds from the declaration\n+                    for declared_bound in ty_param.bounds.iter() {\n+                        bounds.push((*declared_bound).clone());\n+                    }\n \n-            cx.typaram(self.span, ty_param.ident, vec![], bounds, None)\n+                    GenericParam::Type(cx.typaram(self.span, ty_param.ident, vec![], bounds, None))\n+                }\n+            }\n         }));\n \n         // and similarly for where clauses\n@@ -571,7 +576,7 @@ impl<'a> TraitDef<'a> {\n                 ast::WherePredicate::BoundPredicate(ref wb) => {\n                     ast::WherePredicate::BoundPredicate(ast::WhereBoundPredicate {\n                         span: self.span,\n-                        bound_lifetimes: wb.bound_lifetimes.clone(),\n+                        bound_generic_params: wb.bound_generic_params.clone(),\n                         bounded_ty: wb.bounded_ty.clone(),\n                         bounds: wb.bounds.iter().cloned().collect(),\n                     })\n@@ -594,49 +599,61 @@ impl<'a> TraitDef<'a> {\n             }\n         }));\n \n-        if !ty_params.is_empty() {\n-            let ty_param_names: Vec<ast::Name> = ty_params.iter()\n-                .map(|ty_param| ty_param.ident.name)\n-                .collect();\n+        {\n+            // Extra scope required here so ty_params goes out of scope before params is moved\n \n-            let mut processed_field_types = HashSet::new();\n-            for field_ty in field_tys {\n-                let tys = find_type_parameters(&field_ty, &ty_param_names, self.span, cx);\n-\n-                for ty in tys {\n-                    // if we have already handled this type, skip it\n-                    if let ast::TyKind::Path(_, ref p) = ty.node {\n-                        if p.segments.len() == 1 &&\n-                           ty_param_names.contains(&p.segments[0].identifier.name) ||\n-                           processed_field_types.contains(&p.segments) {\n-                            continue;\n-                        };\n-                        processed_field_types.insert(p.segments.clone());\n-                    }\n-                    let mut bounds: Vec<_> = self.additional_bounds\n-                        .iter()\n-                        .map(|p| cx.typarambound(p.to_path(cx, self.span, type_ident, generics)))\n-                        .collect();\n+            let mut ty_params = params.iter()\n+                .filter_map(|param| match *param {\n+                    ast::GenericParam::Type(ref t) => Some(t),\n+                    _ => None,\n+                })\n+                .peekable();\n \n-                    // require the current trait\n-                    bounds.push(cx.typarambound(trait_path.clone()));\n+            if ty_params.peek().is_some() {\n+                let ty_param_names: Vec<ast::Name> = ty_params\n+                    .map(|ty_param| ty_param.ident.name)\n+                    .collect();\n \n-                    let predicate = ast::WhereBoundPredicate {\n-                        span: self.span,\n-                        bound_lifetimes: vec![],\n-                        bounded_ty: ty,\n-                        bounds,\n-                    };\n+                let mut processed_field_types = HashSet::new();\n+                for field_ty in field_tys {\n+                    let tys = find_type_parameters(&field_ty, &ty_param_names, self.span, cx);\n+\n+                    for ty in tys {\n+                        // if we have already handled this type, skip it\n+                        if let ast::TyKind::Path(_, ref p) = ty.node {\n+                            if p.segments.len() == 1 &&\n+                            ty_param_names.contains(&p.segments[0].identifier.name) ||\n+                            processed_field_types.contains(&p.segments) {\n+                                continue;\n+                            };\n+                            processed_field_types.insert(p.segments.clone());\n+                        }\n+                        let mut bounds: Vec<_> = self.additional_bounds\n+                            .iter()\n+                            .map(|p| {\n+                                cx.typarambound(p.to_path(cx, self.span, type_ident, generics))\n+                            })\n+                            .collect();\n \n-                    let predicate = ast::WherePredicate::BoundPredicate(predicate);\n-                    where_clause.predicates.push(predicate);\n+                        // require the current trait\n+                        bounds.push(cx.typarambound(trait_path.clone()));\n+\n+                        let predicate = ast::WhereBoundPredicate {\n+                            span: self.span,\n+                            bound_generic_params: Vec::new(),\n+                            bounded_ty: ty,\n+                            bounds,\n+                        };\n+\n+                        let predicate = ast::WherePredicate::BoundPredicate(predicate);\n+                        where_clause.predicates.push(predicate);\n+                    }\n                 }\n             }\n         }\n \n         let trait_generics = Generics {\n-            lifetimes,\n-            ty_params,\n+            params,\n             where_clause,\n             span,\n         };\n@@ -645,14 +662,21 @@ impl<'a> TraitDef<'a> {\n         let trait_ref = cx.trait_ref(trait_path);\n \n         // Create the type parameters on the `self` path.\n-        let self_ty_params = generics.ty_params\n+        let self_ty_params = generics.params\n             .iter()\n-            .map(|ty_param| cx.ty_ident(self.span, ty_param.ident))\n+            .filter_map(|param| match *param {\n+                GenericParam::Type(ref ty_param)\n+                    => Some(cx.ty_ident(self.span, ty_param.ident)),\n+                _ => None,\n+            })\n             .collect();\n \n-        let self_lifetimes: Vec<ast::Lifetime> = generics.lifetimes\n+        let self_lifetimes: Vec<ast::Lifetime> = generics.params\n             .iter()\n-            .map(|ld| ld.lifetime)\n+            .filter_map(|param| match *param {\n+                GenericParam::Lifetime(ref ld) => Some(ld.lifetime),\n+                _ => None,\n+            })\n             .collect();\n \n         // Create the type of `self`."}, {"sha": "cc3e8b6e6b7c09276d0e723c8ab6453d49e4f2d6", "filename": "src/libsyntax_ext/deriving/generic/ty.rs", "status": "modified", "additions": 27, "deletions": 22, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/250b492052e94d76bd318a4b932159395da55981/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/250b492052e94d76bd318a4b932159395da55981/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs?ref=250b492052e94d76bd318a4b932159395da55981", "patch": "@@ -15,7 +15,7 @@ pub use self::PtrTy::*;\n pub use self::Ty::*;\n \n use syntax::ast;\n-use syntax::ast::{Expr, Generics, Ident, SelfKind};\n+use syntax::ast::{Expr, GenericParam, Generics, Ident, SelfKind};\n use syntax::ext::base::ExtCtxt;\n use syntax::ext::build::AstBuilder;\n use syntax::codemap::respan;\n@@ -185,13 +185,20 @@ impl<'a> Ty<'a> {\n                    -> ast::Path {\n         match *self {\n             Self_ => {\n-                let self_params = self_generics.ty_params\n+                let self_params = self_generics.params\n                     .iter()\n-                    .map(|ty_param| cx.ty_ident(span, ty_param.ident))\n+                    .filter_map(|param| match *param {\n+                        GenericParam::Type(ref ty_param) => Some(cx.ty_ident(span, ty_param.ident)),\n+                        _ => None,\n+                    })\n                     .collect();\n-                let lifetimes = self_generics.lifetimes\n+\n+                let lifetimes: Vec<ast::Lifetime> = self_generics.params\n                     .iter()\n-                    .map(|d| d.lifetime)\n+                    .filter_map(|param| match *param {\n+                        GenericParam::Lifetime(ref ld) => Some(ld.lifetime),\n+                        _ => None,\n+                    })\n                     .collect();\n \n                 cx.path_all(span,\n@@ -226,11 +233,9 @@ fn mk_ty_param(cx: &ExtCtxt,\n     cx.typaram(span, cx.ident_of(name), attrs.to_owned(), bounds, None)\n }\n \n-fn mk_generics(lifetimes: Vec<ast::LifetimeDef>, ty_params: Vec<ast::TyParam>, span: Span)\n-               -> Generics {\n+fn mk_generics(params: Vec<GenericParam>, span: Span) -> Generics {\n     Generics {\n-        lifetimes,\n-        ty_params,\n+        params,\n         where_clause: ast::WhereClause {\n             id: ast::DUMMY_NODE_ID,\n             predicates: Vec::new(),\n@@ -260,26 +265,26 @@ impl<'a> LifetimeBounds<'a> {\n                        self_ty: Ident,\n                        self_generics: &Generics)\n                        -> Generics {\n-        let lifetimes = self.lifetimes\n+        let generic_params = self.lifetimes\n             .iter()\n             .map(|&(lt, ref bounds)| {\n                 let bounds = bounds.iter()\n                     .map(|b| cx.lifetime(span, Ident::from_str(b)))\n                     .collect();\n-                cx.lifetime_def(span, Ident::from_str(lt), vec![], bounds)\n+                GenericParam::Lifetime(cx.lifetime_def(span, Ident::from_str(lt), vec![], bounds))\n             })\n+            .chain(self.bounds\n+                .iter()\n+                .map(|t| {\n+                    let (name, ref bounds) = *t;\n+                    GenericParam::Type(mk_ty_param(\n+                        cx, span, name, &[], &bounds, self_ty, self_generics\n+                    ))\n+                })\n+            )\n             .collect();\n-        let ty_params = self.bounds\n-            .iter()\n-            .map(|t| {\n-                match *t {\n-                    (ref name, ref bounds) => {\n-                        mk_ty_param(cx, span, *name, &[], bounds, self_ty, self_generics)\n-                    }\n-                }\n-            })\n-            .collect();\n-        mk_generics(lifetimes, ty_params, span)\n+\n+        mk_generics(generic_params, span)\n     }\n }\n "}, {"sha": "d769732381ccf5cec5e348dcfd2fc7f4d417d957", "filename": "src/libsyntax_ext/deriving/mod.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/250b492052e94d76bd318a4b932159395da55981/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/250b492052e94d76bd318a4b932159395da55981/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs?ref=250b492052e94d76bd318a4b932159395da55981", "patch": "@@ -121,10 +121,12 @@ fn hygienic_type_parameter(item: &Annotatable, base: &str) -> String {\n     let mut typaram = String::from(base);\n     if let Annotatable::Item(ref item) = *item {\n         match item.node {\n-            ast::ItemKind::Struct(_, ast::Generics { ref ty_params, .. }) |\n-            ast::ItemKind::Enum(_, ast::Generics { ref ty_params, .. }) => {\n-                for ty in ty_params.iter() {\n-                    typaram.push_str(&ty.ident.name.as_str());\n+            ast::ItemKind::Struct(_, ast::Generics { ref params, .. }) |\n+            ast::ItemKind::Enum(_, ast::Generics { ref params, .. }) => {\n+                for param in params.iter() {\n+                    if let ast::GenericParam::Type(ref ty) = *param{\n+                        typaram.push_str(&ty.ident.name.as_str());\n+                    }\n                 }\n             }\n "}, {"sha": "bfe408342a868d73b5b5b8a770e5cd4c221c7f68", "filename": "src/test/ui/nll/ty-outlives/projection-one-region-closure.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/250b492052e94d76bd318a4b932159395da55981/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/250b492052e94d76bd318a4b932159395da55981/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-closure.stderr?ref=250b492052e94d76bd318a4b932159395da55981", "patch": "@@ -89,9 +89,9 @@ error[E0309]: the parameter type `T` may not live long enough\n 56 |     with_signature(cell, t, |cell, t| require(cell, t));\n    |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = help: consider adding an explicit lifetime bound `T: ReFree(DefId(0/0:8 ~ projection_one_region_closure[317d]::no_relationships_late[0]), BrNamed(crate0:DefIndex(1:17), 'a))`...\n+   = help: consider adding an explicit lifetime bound `T: ReFree(DefId(0/0:8 ~ projection_one_region_closure[317d]::no_relationships_late[0]), BrNamed(crate0:DefIndex(1:16), 'a))`...\n \n-error: free region `ReEarlyBound(0, 'b)` does not outlive free region `ReFree(DefId(0/0:8 ~ projection_one_region_closure[317d]::no_relationships_late[0]), BrNamed(crate0:DefIndex(1:17), 'a))`\n+error: free region `ReEarlyBound(0, 'b)` does not outlive free region `ReFree(DefId(0/0:8 ~ projection_one_region_closure[317d]::no_relationships_late[0]), BrNamed(crate0:DefIndex(1:16), 'a))`\n   --> $DIR/projection-one-region-closure.rs:56:20\n    |\n 56 |     with_signature(cell, t, |cell, t| require(cell, t));"}, {"sha": "6cb54170d7a90170ab888599405188536e42f08e", "filename": "src/test/ui/nll/ty-outlives/projection-one-region-trait-bound-closure.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/250b492052e94d76bd318a4b932159395da55981/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-trait-bound-closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/250b492052e94d76bd318a4b932159395da55981/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-trait-bound-closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-trait-bound-closure.stderr?ref=250b492052e94d76bd318a4b932159395da55981", "patch": "@@ -94,7 +94,7 @@ note: External requirements\n     = note: number of external vids: 3\n     = note: where '_#1r: '_#2r\n \n-error: free region `ReEarlyBound(0, 'b)` does not outlive free region `ReFree(DefId(0/0:8 ~ projection_one_region_trait_bound_closure[317d]::no_relationships_late[0]), BrNamed(crate0:DefIndex(1:17), 'a))`\n+error: free region `ReEarlyBound(0, 'b)` does not outlive free region `ReFree(DefId(0/0:8 ~ projection_one_region_trait_bound_closure[317d]::no_relationships_late[0]), BrNamed(crate0:DefIndex(1:16), 'a))`\n   --> $DIR/projection-one-region-trait-bound-closure.rs:48:20\n    |\n 48 |     with_signature(cell, t, |cell, t| require(cell, t));"}, {"sha": "21487899d3ba6c44683526dd059758073ca0e3ab", "filename": "src/test/ui/nll/ty-outlives/projection-two-region-trait-bound-closure.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/250b492052e94d76bd318a4b932159395da55981/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-two-region-trait-bound-closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/250b492052e94d76bd318a4b932159395da55981/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-two-region-trait-bound-closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-two-region-trait-bound-closure.stderr?ref=250b492052e94d76bd318a4b932159395da55981", "patch": "@@ -158,7 +158,7 @@ error[E0309]: the associated type `<T as Anything<'_#5r, '_#6r>>::AssocType` may\n 49 |     with_signature(cell, t, |cell, t| require(cell, t));\n    |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = help: consider adding an explicit lifetime bound `<T as Anything<'_#5r, '_#6r>>::AssocType: ReFree(DefId(0/0:8 ~ projection_two_region_trait_bound_closure[317d]::no_relationships_late[0]), BrNamed(crate0:DefIndex(1:19), 'a))`...\n+   = help: consider adding an explicit lifetime bound `<T as Anything<'_#5r, '_#6r>>::AssocType: ReFree(DefId(0/0:8 ~ projection_two_region_trait_bound_closure[317d]::no_relationships_late[0]), BrNamed(crate0:DefIndex(1:18), 'a))`...\n \n note: No external requirements\n   --> $DIR/projection-two-region-trait-bound-closure.rs:45:1\n@@ -270,7 +270,7 @@ note: No external requirements\n                 T\n             ]\n \n-error: free region `ReEarlyBound(0, 'b)` does not outlive free region `ReFree(DefId(0/0:13 ~ projection_two_region_trait_bound_closure[317d]::two_regions[0]), BrNamed(crate0:DefIndex(1:44), 'a))`\n+error: free region `ReEarlyBound(0, 'b)` does not outlive free region `ReFree(DefId(0/0:13 ~ projection_two_region_trait_bound_closure[317d]::two_regions[0]), BrNamed(crate0:DefIndex(1:43), 'a))`\n    --> $DIR/projection-two-region-trait-bound-closure.rs:109:20\n     |\n 109 |     with_signature(cell, t, |cell, t| require(cell, t));"}, {"sha": "023b58c927d865b49fd9767fda9f94f0e55ded10", "filename": "src/test/ui/nll/ty-outlives/ty-param-closure-approximate-lower-bound.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/250b492052e94d76bd318a4b932159395da55981/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-closure-approximate-lower-bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/250b492052e94d76bd318a4b932159395da55981/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-closure-approximate-lower-bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-closure-approximate-lower-bound.stderr?ref=250b492052e94d76bd318a4b932159395da55981", "patch": "@@ -66,7 +66,7 @@ error[E0309]: the parameter type `T` may not live long enough\n 43 |     twice(cell, value, |a, b| invoke(a, b));\n    |                        ^^^^^^^^^^^^^^^^^^^\n    |\n-   = help: consider adding an explicit lifetime bound `T: ReFree(DefId(0/0:6 ~ ty_param_closure_approximate_lower_bound[317d]::generic_fail[0]), BrNamed(crate0:DefIndex(1:16), 'a))`...\n+   = help: consider adding an explicit lifetime bound `T: ReFree(DefId(0/0:6 ~ ty_param_closure_approximate_lower_bound[317d]::generic_fail[0]), BrNamed(crate0:DefIndex(1:15), 'a))`...\n \n note: No external requirements\n   --> $DIR/ty-param-closure-approximate-lower-bound.rs:42:1"}, {"sha": "2dd13810ae48a09092380d90591bbd9cdbb0d3c3", "filename": "src/test/ui/nll/ty-outlives/ty-param-closure-outlives-from-where-clause.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/250b492052e94d76bd318a4b932159395da55981/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-closure-outlives-from-where-clause.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/250b492052e94d76bd318a4b932159395da55981/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-closure-outlives-from-where-clause.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-closure-outlives-from-where-clause.stderr?ref=250b492052e94d76bd318a4b932159395da55981", "patch": "@@ -107,7 +107,7 @@ error[E0309]: the parameter type `T` may not live long enough\n 47 | |     })\n    | |_____^\n    |\n-   = help: consider adding an explicit lifetime bound `T: ReFree(DefId(0/0:6 ~ ty_param_closure_outlives_from_where_clause[317d]::no_region[0]), BrNamed(crate0:DefIndex(1:15), 'a))`...\n+   = help: consider adding an explicit lifetime bound `T: ReFree(DefId(0/0:6 ~ ty_param_closure_outlives_from_where_clause[317d]::no_region[0]), BrNamed(crate0:DefIndex(1:14), 'a))`...\n \n note: No external requirements\n   --> $DIR/ty-param-closure-outlives-from-where-clause.rs:37:1\n@@ -154,7 +154,7 @@ error[E0309]: the parameter type `T` may not live long enough\n 81 | |     })\n    | |_____^\n    |\n-   = help: consider adding an explicit lifetime bound `T: ReFree(DefId(0/0:8 ~ ty_param_closure_outlives_from_where_clause[317d]::wrong_region[0]), BrNamed(crate0:DefIndex(1:21), 'a))`...\n+   = help: consider adding an explicit lifetime bound `T: ReFree(DefId(0/0:8 ~ ty_param_closure_outlives_from_where_clause[317d]::wrong_region[0]), BrNamed(crate0:DefIndex(1:20), 'a))`...\n \n note: No external requirements\n   --> $DIR/ty-param-closure-outlives-from-where-clause.rs:72:1"}]}