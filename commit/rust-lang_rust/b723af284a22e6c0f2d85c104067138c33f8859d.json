{"sha": "b723af284a22e6c0f2d85c104067138c33f8859d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI3MjNhZjI4NGEyMmU2YzBmMmQ4NWMxMDQwNjcxMzhjMzNmODg1OWQ=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-09-21T17:40:50Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-11-19T00:14:32Z"}, "message": "rustc_trans: go through layouts uniformly for fat pointers and variants.", "tree": {"sha": "4153341b1f9782376b1d472ef2e83ba473acfe81", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4153341b1f9782376b1d472ef2e83ba473acfe81"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b723af284a22e6c0f2d85c104067138c33f8859d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b723af284a22e6c0f2d85c104067138c33f8859d", "html_url": "https://github.com/rust-lang/rust/commit/b723af284a22e6c0f2d85c104067138c33f8859d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b723af284a22e6c0f2d85c104067138c33f8859d/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "026214c85830719900133eb92a31a1e4dce8dd20", "url": "https://api.github.com/repos/rust-lang/rust/commits/026214c85830719900133eb92a31a1e4dce8dd20", "html_url": "https://github.com/rust-lang/rust/commit/026214c85830719900133eb92a31a1e4dce8dd20"}], "stats": {"total": 810, "additions": 363, "deletions": 447}, "files": [{"sha": "4496e07b13814857461296395116754e3899c8b0", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b723af284a22e6c0f2d85c104067138c33f8859d/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b723af284a22e6c0f2d85c104067138c33f8859d/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=b723af284a22e6c0f2d85c104067138c33f8859d", "patch": "@@ -35,7 +35,7 @@ use rustc_serialize::{Decoder, Decodable, Encoder, Encodable};\n use session::{config, early_error, Session};\n use traits::Reveal;\n use ty::{self, TyCtxt, Ty};\n-use ty::layout::{FullLayout, LayoutError, LayoutOf};\n+use ty::layout::{LayoutError, LayoutOf, TyLayout};\n use util::nodemap::FxHashMap;\n \n use std::default::Default as StdDefault;\n@@ -628,9 +628,9 @@ impl<'a, 'tcx> LateContext<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> LayoutOf<Ty<'tcx>> for &'a LateContext<'a, 'tcx> {\n-    type FullLayout = Result<FullLayout<'tcx>, LayoutError<'tcx>>;\n+    type TyLayout = Result<TyLayout<'tcx>, LayoutError<'tcx>>;\n \n-    fn layout_of(self, ty: Ty<'tcx>) -> Self::FullLayout {\n+    fn layout_of(self, ty: Ty<'tcx>) -> Self::TyLayout {\n         (self.tcx, self.param_env.reveal_all()).layout_of(ty)\n     }\n }"}, {"sha": "7bf7d81037d9e7c92431e2a452844ddde341040b", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 118, "deletions": 115, "changes": 233, "blob_url": "https://github.com/rust-lang/rust/blob/b723af284a22e6c0f2d85c104067138c33f8859d/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b723af284a22e6c0f2d85c104067138c33f8859d/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=b723af284a22e6c0f2d85c104067138c33f8859d", "patch": "@@ -23,7 +23,7 @@ use std::fmt;\n use std::i64;\n use std::iter;\n use std::mem;\n-use std::ops::{Add, Sub, Mul, AddAssign, RangeInclusive};\n+use std::ops::{Add, Sub, Mul, AddAssign, Deref, RangeInclusive};\n \n use ich::StableHashingContext;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n@@ -907,6 +907,7 @@ impl<'tcx> fmt::Display for LayoutError<'tcx> {\n \n #[derive(PartialEq, Eq, Hash, Debug)]\n pub struct CachedLayout {\n+    pub variant_index: Option<usize>,\n     pub layout: Layout,\n     pub fields: FieldPlacement,\n     pub abi: Abi,\n@@ -948,6 +949,7 @@ impl<'a, 'tcx> Layout {\n         let dl = cx.data_layout();\n         let scalar = |value| {\n             tcx.intern_layout(CachedLayout {\n+                variant_index: None,\n                 layout: Layout::Scalar,\n                 fields: FieldPlacement::Union(0),\n                 abi: Abi::Scalar(value)\n@@ -962,7 +964,7 @@ impl<'a, 'tcx> Layout {\n             /// A univariant, but part of an enum.\n             EnumVariant(Integer),\n         }\n-        let univariant_uninterned = |fields: &[FullLayout], repr: &ReprOptions, kind| {\n+        let univariant_uninterned = |fields: &[TyLayout], repr: &ReprOptions, kind| {\n             let packed = repr.packed();\n             if packed && repr.align > 0 {\n                 bug!(\"struct cannot be packed and aligned\");\n@@ -1085,6 +1087,7 @@ impl<'a, 'tcx> Layout {\n             }\n \n             Ok(CachedLayout {\n+                variant_index: None,\n                 layout: Layout::Univariant,\n                 fields: FieldPlacement::Arbitrary {\n                     offsets,\n@@ -1099,7 +1102,7 @@ impl<'a, 'tcx> Layout {\n                 }\n             })\n         };\n-        let univariant = |fields: &[FullLayout], repr: &ReprOptions, kind| {\n+        let univariant = |fields: &[TyLayout], repr: &ReprOptions, kind| {\n             Ok(tcx.intern_layout(univariant_uninterned(fields, repr, kind)?))\n         };\n         assert!(!ty.has_infer_types());\n@@ -1129,6 +1132,7 @@ impl<'a, 'tcx> Layout {\n                 memory_index: vec![0, 1]\n             };\n             Ok(tcx.intern_layout(CachedLayout {\n+                variant_index: None,\n                 layout: Layout::Univariant,\n                 fields,\n                 abi: Abi::Aggregate {\n@@ -1185,6 +1189,7 @@ impl<'a, 'tcx> Layout {\n                     .ok_or(LayoutError::SizeOverflow(ty))?;\n \n                 tcx.intern_layout(CachedLayout {\n+                    variant_index: None,\n                     layout: Layout::Array,\n                     fields: FieldPlacement::Array {\n                         stride: element_size,\n@@ -1202,6 +1207,7 @@ impl<'a, 'tcx> Layout {\n             ty::TySlice(element) => {\n                 let element = cx.layout_of(element)?;\n                 tcx.intern_layout(CachedLayout {\n+                    variant_index: None,\n                     layout: Layout::Array,\n                     fields: FieldPlacement::Array {\n                         stride: element.size(dl),\n@@ -1218,6 +1224,7 @@ impl<'a, 'tcx> Layout {\n             }\n             ty::TyStr => {\n                 tcx.intern_layout(CachedLayout {\n+                    variant_index: None,\n                     layout: Layout::Array,\n                     fields: FieldPlacement::Array {\n                         stride: Size::from_bytes(1),\n@@ -1286,6 +1293,7 @@ impl<'a, 'tcx> Layout {\n                     }\n                 };\n                 tcx.intern_layout(CachedLayout {\n+                    variant_index: None,\n                     layout: Layout::Vector,\n                     fields: FieldPlacement::Array {\n                         stride: element.size(tcx),\n@@ -1343,6 +1351,7 @@ impl<'a, 'tcx> Layout {\n                     }\n \n                     return Ok(tcx.intern_layout(CachedLayout {\n+                        variant_index: None,\n                         layout: Layout::UntaggedUnion,\n                         fields: FieldPlacement::Union(variants[0].len()),\n                         abi: Abi::Aggregate {\n@@ -1372,7 +1381,11 @@ impl<'a, 'tcx> Layout {\n                         else { StructKind::AlwaysSized }\n                     };\n \n-                    return univariant(&variants[0], &def.repr, kind);\n+                    let mut cached = univariant_uninterned(&variants[0], &def.repr, kind)?;\n+                    if def.is_enum() {\n+                        cached.variant_index = Some(0);\n+                    }\n+                    return Ok(tcx.intern_layout(cached));\n                 }\n \n                 let no_explicit_discriminants = def.variants.iter().enumerate()\n@@ -1389,12 +1402,14 @@ impl<'a, 'tcx> Layout {\n \n                         for (field_index, field) in variants[i].iter().enumerate() {\n                             if let Some((offset, discr)) = field.non_zero_field(cx)? {\n-                                let st = vec![\n+                                let mut st = vec![\n                                     univariant_uninterned(&variants[0],\n                                         &def.repr, StructKind::AlwaysSized)?,\n                                     univariant_uninterned(&variants[1],\n                                         &def.repr, StructKind::AlwaysSized)?\n                                 ];\n+                                st[0].variant_index = Some(0);\n+                                st[1].variant_index = Some(1);\n                                 let offset = st[i].fields.offset(field_index) + offset;\n                                 let mut abi = st[i].abi;\n                                 if offset.bytes() == 0 && discr.size(dl) == abi.size(dl) {\n@@ -1418,6 +1433,7 @@ impl<'a, 'tcx> Layout {\n                                     _ => {}\n                                 }\n                                 return Ok(tcx.intern_layout(CachedLayout {\n+                                    variant_index: None,\n                                     layout: Layout::NullablePointer {\n                                         nndiscr: i as u64,\n \n@@ -1454,13 +1470,13 @@ impl<'a, 'tcx> Layout {\n                 assert_eq!(Integer::for_abi_align(dl, start_align), None);\n \n                 // Create the set of structs that represent each variant.\n-                let mut variants = variants.into_iter().map(|field_layouts| {\n-                    let st = univariant_uninterned(&field_layouts,\n+                let mut variants = variants.into_iter().enumerate().map(|(i, field_layouts)| {\n+                    let mut st = univariant_uninterned(&field_layouts,\n                         &def.repr, StructKind::EnumVariant(min_ity))?;\n+                    st.variant_index = Some(i);\n                     // Find the first field we can't move later\n                     // to make room for a larger discriminant.\n-                    for i in st.fields.index_by_increasing_offset() {\n-                        let field = field_layouts[i];\n+                    for field in st.fields.index_by_increasing_offset().map(|j| field_layouts[j]) {\n                         let field_align = field.align(dl);\n                         if !field.is_zst() || field_align.abi() != 1 {\n                             start_align = start_align.min(field_align);\n@@ -1539,6 +1555,7 @@ impl<'a, 'tcx> Layout {\n \n                 let discr = Int(ity, signed);\n                 tcx.intern_layout(CachedLayout {\n+                    variant_index: None,\n                     layout: Layout::General {\n                         discr,\n \n@@ -1587,7 +1604,7 @@ impl<'a, 'tcx> Layout {\n     fn record_layout_for_printing(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                   ty: Ty<'tcx>,\n                                   param_env: ty::ParamEnv<'tcx>,\n-                                  layout: FullLayout<'tcx>) {\n+                                  layout: TyLayout<'tcx>) {\n         // If we are running with `-Zprint-type-sizes`, record layouts for\n         // dumping later. Ignore layouts that are done with non-empty\n         // environments or non-monomorphic layouts, as the user only wants\n@@ -1607,7 +1624,7 @@ impl<'a, 'tcx> Layout {\n     fn record_layout_for_printing_outlined(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                            ty: Ty<'tcx>,\n                                            param_env: ty::ParamEnv<'tcx>,\n-                                           layout: FullLayout<'tcx>) {\n+                                           layout: TyLayout<'tcx>) {\n         let cx = (tcx, param_env);\n         // (delay format until we actually need it)\n         let record = |kind, opt_discr_size, variants| {\n@@ -1644,7 +1661,7 @@ impl<'a, 'tcx> Layout {\n \n         let build_variant_info = |n: Option<ast::Name>,\n                                   flds: &[ast::Name],\n-                                  layout: FullLayout<'tcx>| {\n+                                  layout: TyLayout<'tcx>| {\n             let mut min_size = Size::from_bytes(0);\n             let field_info: Vec<_> = flds.iter().enumerate().map(|(i, &name)| {\n                 match layout.field(cx, i) {\n@@ -1685,7 +1702,7 @@ impl<'a, 'tcx> Layout {\n             }\n         };\n \n-        match *layout.layout {\n+        match layout.layout {\n             Layout::Univariant => {\n                 let variant_names = || {\n                     adt_def.variants.iter().map(|v|format!(\"{}\", v.name)).collect::<Vec<_>>()\n@@ -1723,7 +1740,7 @@ impl<'a, 'tcx> Layout {\n                                             layout.for_variant(i))\n                     })\n                     .collect();\n-                record(adt_kind.into(), match *layout.layout {\n+                record(adt_kind.into(), match layout.layout {\n                     Layout::General { discr, .. } => Some(discr.size(tcx)),\n                     _ => None\n                 }, variant_infos);\n@@ -1901,12 +1918,16 @@ impl<'a, 'tcx> SizeSkeleton<'tcx> {\n /// layouts for which Rust types do not exist, such as enum variants\n /// or synthetic fields of enums (i.e. discriminants) and fat pointers.\n #[derive(Copy, Clone, Debug)]\n-pub struct FullLayout<'tcx> {\n+pub struct TyLayout<'tcx> {\n     pub ty: Ty<'tcx>,\n-    pub variant_index: Option<usize>,\n-    pub layout: &'tcx Layout,\n-    pub fields: &'tcx FieldPlacement,\n-    pub abi: Abi,\n+    cached: &'tcx CachedLayout\n+}\n+\n+impl<'tcx> Deref for TyLayout<'tcx> {\n+    type Target = &'tcx CachedLayout;\n+    fn deref(&self) -> &&'tcx CachedLayout {\n+        &self.cached\n+    }\n }\n \n pub trait HasTyCtxt<'tcx>: HasDataLayout {\n@@ -1937,29 +1958,42 @@ impl<'a, 'gcx, 'tcx, T: Copy> HasTyCtxt<'gcx> for (TyCtxt<'a, 'gcx, 'tcx>, T) {\n     }\n }\n \n+pub trait MaybeResult<T> {\n+    fn map_same<F: FnOnce(T) -> T>(self, f: F) -> Self;\n+}\n+\n+impl<T> MaybeResult<T> for T {\n+    fn map_same<F: FnOnce(T) -> T>(self, f: F) -> Self {\n+        f(self)\n+    }\n+}\n+\n+impl<T, E> MaybeResult<T> for Result<T, E> {\n+    fn map_same<F: FnOnce(T) -> T>(self, f: F) -> Self {\n+        self.map(f)\n+    }\n+}\n+\n pub trait LayoutOf<T> {\n-    type FullLayout;\n+    type TyLayout;\n \n-    fn layout_of(self, ty: T) -> Self::FullLayout;\n+    fn layout_of(self, ty: T) -> Self::TyLayout;\n }\n \n impl<'a, 'tcx> LayoutOf<Ty<'tcx>> for (TyCtxt<'a, 'tcx, 'tcx>, ty::ParamEnv<'tcx>) {\n-    type FullLayout = Result<FullLayout<'tcx>, LayoutError<'tcx>>;\n+    type TyLayout = Result<TyLayout<'tcx>, LayoutError<'tcx>>;\n \n     /// Computes the layout of a type. Note that this implicitly\n     /// executes in \"reveal all\" mode.\n     #[inline]\n-    fn layout_of(self, ty: Ty<'tcx>) -> Self::FullLayout {\n+    fn layout_of(self, ty: Ty<'tcx>) -> Self::TyLayout {\n         let (tcx, param_env) = self;\n \n         let ty = tcx.normalize_associated_type_in_env(&ty, param_env.reveal_all());\n         let cached = tcx.layout_raw(param_env.reveal_all().and(ty))?;\n-        let layout = FullLayout {\n+        let layout = TyLayout {\n             ty,\n-            variant_index: None,\n-            layout: &cached.layout,\n-            fields: &cached.fields,\n-            abi: cached.abi\n+            cached\n         };\n \n         // NB: This recording is normally disabled; when enabled, it\n@@ -1976,22 +2010,19 @@ impl<'a, 'tcx> LayoutOf<Ty<'tcx>> for (TyCtxt<'a, 'tcx, 'tcx>, ty::ParamEnv<'tcx\n \n impl<'a, 'tcx> LayoutOf<Ty<'tcx>> for (ty::maps::TyCtxtAt<'a, 'tcx, 'tcx>,\n                                        ty::ParamEnv<'tcx>) {\n-    type FullLayout = Result<FullLayout<'tcx>, LayoutError<'tcx>>;\n+    type TyLayout = Result<TyLayout<'tcx>, LayoutError<'tcx>>;\n \n     /// Computes the layout of a type. Note that this implicitly\n     /// executes in \"reveal all\" mode.\n     #[inline]\n-    fn layout_of(self, ty: Ty<'tcx>) -> Self::FullLayout {\n+    fn layout_of(self, ty: Ty<'tcx>) -> Self::TyLayout {\n         let (tcx_at, param_env) = self;\n \n         let ty = tcx_at.tcx.normalize_associated_type_in_env(&ty, param_env.reveal_all());\n         let cached = tcx_at.layout_raw(param_env.reveal_all().and(ty))?;\n-        let layout = FullLayout {\n+        let layout = TyLayout {\n             ty,\n-            variant_index: None,\n-            layout: &cached.layout,\n-            fields: &cached.fields,\n-            abi: cached.abi\n+            cached\n         };\n \n         // NB: This recording is normally disabled; when enabled, it\n@@ -2006,79 +2037,57 @@ impl<'a, 'tcx> LayoutOf<Ty<'tcx>> for (ty::maps::TyCtxtAt<'a, 'tcx, 'tcx>,\n     }\n }\n \n-impl<'a, 'tcx> FullLayout<'tcx> {\n+impl<'a, 'tcx> TyLayout<'tcx> {\n     pub fn for_variant(&self, variant_index: usize) -> Self {\n-        let variants = match self.ty.sty {\n-            ty::TyAdt(def, _) if def.is_enum() => &def.variants[..],\n-            _ => &[]\n-        };\n-        let count = if variants.is_empty() {\n-            0\n-        } else {\n-            variants[variant_index].fields.len()\n-        };\n-\n-        let (layout, fields, abi) = match *self.layout {\n-            Layout::Univariant => (self.layout, self.fields, self.abi),\n-\n+        let cached = match self.layout {\n             Layout::NullablePointer { ref variants, .. } |\n             Layout::General { ref variants, .. } => {\n-                let variant = &variants[variant_index];\n-                (&variant.layout, &variant.fields, variant.abi)\n+                &variants[variant_index]\n             }\n \n-            _ => bug!()\n+            _ => self.cached\n         };\n-        assert_eq!(fields.count(), count);\n-\n-        FullLayout {\n-            variant_index: Some(variant_index),\n-            layout,\n-            fields,\n-            abi,\n-            ..*self\n+        assert_eq!(cached.variant_index, Some(variant_index));\n+\n+        TyLayout {\n+            ty: self.ty,\n+            cached\n         }\n     }\n \n-    fn field_type_unnormalized(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, i: usize) -> Ty<'tcx> {\n-        let ptr_field_type = |pointee: Ty<'tcx>| {\n+    pub fn field<C>(&self, cx: C, i: usize) -> C::TyLayout\n+        where C: LayoutOf<Ty<'tcx>> + HasTyCtxt<'tcx>,\n+              C::TyLayout: MaybeResult<TyLayout<'tcx>>\n+    {\n+        let tcx = cx.tcx();\n+        let ptr_field_layout = |pointee: Ty<'tcx>| {\n             assert!(i < 2);\n-            let mk_ptr = |ty: Ty<'tcx>| {\n-                match self.ty.sty {\n-                    ty::TyRef(r, ty::TypeAndMut { mutbl, .. }) => {\n-                        tcx.mk_ref(r, ty::TypeAndMut { ty, mutbl })\n-                    }\n-                    ty::TyRawPtr(ty::TypeAndMut { mutbl, .. }) => {\n-                        tcx.mk_ptr(ty::TypeAndMut { ty, mutbl })\n-                    }\n-                    ty::TyAdt(def, _) if def.is_box() => {\n-                        tcx.mk_box(ty)\n-                    }\n-                    _ => bug!()\n-                }\n-            };\n-            let slice = |element: Ty<'tcx>| {\n-                if i == 0 {\n-                    mk_ptr(element)\n-                } else {\n-                    tcx.types.usize\n-                }\n-            };\n-            match tcx.struct_tail(pointee).sty {\n-                ty::TySlice(element) => slice(element),\n-                ty::TyStr => slice(tcx.types.u8),\n+\n+            // Reuse the fat *T type as its own thin pointer data field.\n+            // This provides information about e.g. DST struct pointees\n+            // (which may have no non-DST form), and will work as long\n+            // as the `Abi` or `FieldPlacement` is checked by users.\n+            if i == 0 {\n+                return cx.layout_of(Pointer.to_ty(tcx)).map_same(|mut ptr_layout| {\n+                    ptr_layout.ty = self.ty;\n+                    ptr_layout\n+                });\n+            }\n+\n+            let meta_ty = match tcx.struct_tail(pointee).sty {\n+                ty::TySlice(_) |\n+                ty::TyStr => tcx.types.usize,\n                 ty::TyDynamic(..) => {\n-                    if i == 0 {\n-                        mk_ptr(tcx.mk_nil())\n-                    } else {\n-                        Pointer.to_ty(tcx)\n-                    }\n+                    // FIXME(eddyb) use an usize/fn() array with\n+                    // the correct number of vtables slots.\n+                    tcx.mk_imm_ref(tcx.types.re_static, tcx.mk_nil())\n                 }\n-                _ => bug!(\"FullLayout::field_type({:?}): not applicable\", self)\n-            }\n+                _ => bug!(\"TyLayout::field_type({:?}): not applicable\", self)\n+            };\n+            cx.layout_of(meta_ty)\n         };\n \n-        match self.ty.sty {\n+        cx.layout_of(match self.ty.sty {\n             ty::TyBool |\n             ty::TyChar |\n             ty::TyInt(_) |\n@@ -2089,16 +2098,16 @@ impl<'a, 'tcx> FullLayout<'tcx> {\n             ty::TyFnDef(..) |\n             ty::TyDynamic(..) |\n             ty::TyForeign(..) => {\n-                bug!(\"FullLayout::field_type({:?}): not applicable\", self)\n+                bug!(\"TyLayout::field_type({:?}): not applicable\", self)\n             }\n \n             // Potentially-fat pointers.\n             ty::TyRef(_, ty::TypeAndMut { ty: pointee, .. }) |\n             ty::TyRawPtr(ty::TypeAndMut { ty: pointee, .. }) => {\n-                ptr_field_type(pointee)\n+                return ptr_field_layout(pointee);\n             }\n             ty::TyAdt(def, _) if def.is_box() => {\n-                ptr_field_type(self.ty.boxed_ty())\n+                return ptr_field_layout(self.ty.boxed_ty());\n             }\n \n             // Arrays and slices.\n@@ -2126,16 +2135,16 @@ impl<'a, 'tcx> FullLayout<'tcx> {\n             ty::TyAdt(def, substs) => {\n                 let v = if def.is_enum() {\n                     match self.variant_index {\n-                        None => match *self.layout {\n+                        None => match self.layout {\n                             // Discriminant field for enums (where applicable).\n                             Layout::General { discr, .. } |\n                             Layout::NullablePointer { discr, .. } => {\n-                                return [discr.to_ty(tcx)][i];\n+                                return cx.layout_of([discr.to_ty(tcx)][i]);\n+                            }\n+                            _ => {\n+                                bug!(\"TyLayout::field_type: enum `{}` has no discriminant\",\n+                                     self.ty)\n                             }\n-                            _ if def.variants.len() > 1 => return [][i],\n-\n-                            // Enums with one variant behave like structs.\n-                            _ => 0\n                         },\n                         Some(v) => v\n                     }\n@@ -2148,16 +2157,9 @@ impl<'a, 'tcx> FullLayout<'tcx> {\n \n             ty::TyProjection(_) | ty::TyAnon(..) | ty::TyParam(_) |\n             ty::TyInfer(_) | ty::TyError => {\n-                bug!(\"FullLayout::field_type: unexpected type `{}`\", self.ty)\n+                bug!(\"TyLayout::field_type: unexpected type `{}`\", self.ty)\n             }\n-        }\n-    }\n-\n-    pub fn field<C: LayoutOf<Ty<'tcx>> + HasTyCtxt<'tcx>>(&self,\n-                                                          cx: C,\n-                                                          i: usize)\n-                                                          -> C::FullLayout {\n-        cx.layout_of(self.field_type_unnormalized(cx.tcx(), i))\n+        })\n     }\n \n     /// Returns true if the layout corresponds to an unsized type.\n@@ -2198,11 +2200,11 @@ impl<'a, 'tcx> FullLayout<'tcx> {\n     // FIXME(eddyb) track value ranges and traverse already optimized enums.\n     fn non_zero_field<C>(&self, cx: C)\n         -> Result<Option<(Size, Primitive)>, LayoutError<'tcx>>\n-        where C: LayoutOf<Ty<'tcx>, FullLayout = Result<Self, LayoutError<'tcx>>> +\n+        where C: LayoutOf<Ty<'tcx>, TyLayout = Result<Self, LayoutError<'tcx>>> +\n                  HasTyCtxt<'tcx>\n     {\n         let tcx = cx.tcx();\n-        match (self.layout, self.abi, &self.ty.sty) {\n+        match (&self.layout, self.abi, &self.ty.sty) {\n             // FIXME(eddyb) check this via value ranges on scalars.\n             (&Layout::Scalar, Abi::Scalar(Pointer), &ty::TyRef(..)) |\n             (&Layout::Scalar, Abi::Scalar(Pointer), &ty::TyFnPtr(..)) => {\n@@ -2238,7 +2240,7 @@ impl<'a, 'tcx> FullLayout<'tcx> {\n \n             // Perhaps one of the fields is non-zero, let's recurse and find out.\n             _ => {\n-                if let FieldPlacement::Array { count, .. } = *self.fields {\n+                if let FieldPlacement::Array { count, .. } = self.fields {\n                     if count > 0 {\n                         return self.field(cx, 0)?.non_zero_field(cx);\n                     }\n@@ -2341,6 +2343,7 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for Abi {\n }\n \n impl_stable_hash_for!(struct ::ty::layout::CachedLayout {\n+    variant_index,\n     layout,\n     fields,\n     abi"}, {"sha": "e0c7bc66876eaa36408c6ec80b3bb4141281d599", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b723af284a22e6c0f2d85c104067138c33f8859d/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b723af284a22e6c0f2d85c104067138c33f8859d/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=b723af284a22e6c0f2d85c104067138c33f8859d", "patch": "@@ -753,7 +753,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for VariantSizeDifferences {\n                     bug!(\"failed to get layout for `{}`: {}\", t, e)\n                 });\n \n-                if let Layout::General { ref variants, discr, .. } = *layout.layout {\n+                if let Layout::General { ref variants, discr, .. } = layout.layout {\n                     let discr_size = discr.size(cx.tcx).bytes();\n \n                     debug!(\"enum `{}` is {} bytes large with layout:\\n{:#?}\","}, {"sha": "fdc27d4e041cca184f3162ad178ce4daf90156f4", "filename": "src/librustc_llvm/ffi.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b723af284a22e6c0f2d85c104067138c33f8859d/src%2Flibrustc_llvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b723af284a22e6c0f2d85c104067138c33f8859d/src%2Flibrustc_llvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Fffi.rs?ref=b723af284a22e6c0f2d85c104067138c33f8859d", "patch": "@@ -1316,11 +1316,6 @@ extern \"C\" {\n                              ElementCount: c_uint,\n                              Packed: Bool);\n \n-    pub fn LLVMConstNamedStruct(S: TypeRef,\n-                                ConstantVals: *const ValueRef,\n-                                Count: c_uint)\n-                                -> ValueRef;\n-\n     /// Enables LLVM debug output.\n     pub fn LLVMRustSetDebug(Enabled: c_int);\n "}, {"sha": "8fa55b6ef7481110bfa4a6e5c1331853e4a2b9b4", "filename": "src/librustc_trans/abi.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b723af284a22e6c0f2d85c104067138c33f8859d/src%2Flibrustc_trans%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b723af284a22e6c0f2d85c104067138c33f8859d/src%2Flibrustc_trans%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fabi.rs?ref=b723af284a22e6c0f2d85c104067138c33f8859d", "patch": "@@ -36,7 +36,7 @@ use type_of::LayoutLlvmExt;\n \n use rustc::hir;\n use rustc::ty::{self, Ty};\n-use rustc::ty::layout::{self, Align, Size, FullLayout};\n+use rustc::ty::layout::{self, Align, Size, TyLayout};\n use rustc::ty::layout::{HasDataLayout, LayoutOf};\n use rustc_back::PanicStrategy;\n \n@@ -275,7 +275,7 @@ pub trait LayoutExt<'tcx> {\n     fn homogeneous_aggregate<'a>(&self, ccx: &CrateContext<'a, 'tcx>) -> Option<Reg>;\n }\n \n-impl<'tcx> LayoutExt<'tcx> for FullLayout<'tcx> {\n+impl<'tcx> LayoutExt<'tcx> for TyLayout<'tcx> {\n     fn is_aggregate(&self) -> bool {\n         match self.abi {\n             layout::Abi::Scalar(_) |\n@@ -311,7 +311,7 @@ impl<'tcx> LayoutExt<'tcx> for FullLayout<'tcx> {\n                 let mut total = Size::from_bytes(0);\n                 let mut result = None;\n \n-                let is_union = match *self.fields {\n+                let is_union = match self.fields {\n                     layout::FieldPlacement::Array { count, .. } => {\n                         if count > 0 {\n                             return self.field(ccx, 0).homogeneous_aggregate(ccx);\n@@ -424,7 +424,7 @@ impl CastTarget {\n #[derive(Debug)]\n pub struct ArgType<'tcx> {\n     kind: ArgKind,\n-    pub layout: FullLayout<'tcx>,\n+    pub layout: TyLayout<'tcx>,\n     /// Cast target, either a single uniform or a pair of registers.\n     pub cast: Option<CastTarget>,\n     /// Dummy argument, which is emitted before the real argument.\n@@ -435,7 +435,7 @@ pub struct ArgType<'tcx> {\n }\n \n impl<'a, 'tcx> ArgType<'tcx> {\n-    fn new(layout: FullLayout<'tcx>) -> ArgType<'tcx> {\n+    fn new(layout: TyLayout<'tcx>) -> ArgType<'tcx> {\n         ArgType {\n             kind: ArgKind::Direct,\n             layout,\n@@ -610,7 +610,7 @@ impl<'a, 'tcx> FnType<'tcx> {\n         let fn_ty = instance_ty(ccx.tcx(), &instance);\n         let sig = ty_fn_sig(ccx, fn_ty);\n         let sig = ccx.tcx().erase_late_bound_regions_and_normalize(&sig);\n-        Self::new(ccx, sig, &[])\n+        FnType::new(ccx, sig, &[])\n     }\n \n     pub fn new(ccx: &CrateContext<'a, 'tcx>,"}, {"sha": "2f252c5e55e0bdbc82d511c55ba35c6819ef7115", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b723af284a22e6c0f2d85c104067138c33f8859d/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b723af284a22e6c0f2d85c104067138c33f8859d/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=b723af284a22e6c0f2d85c104067138c33f8859d", "patch": "@@ -28,6 +28,7 @@ use super::ModuleSource;\n use super::ModuleTranslation;\n use super::ModuleKind;\n \n+use abi;\n use assert_module_sources;\n use back::link;\n use back::symbol_export;\n@@ -40,7 +41,7 @@ use rustc::middle::lang_items::StartFnLangItem;\n use rustc::middle::trans::{Linkage, Visibility, Stats};\n use rustc::middle::cstore::{EncodedMetadata, EncodedMetadataHashes};\n use rustc::ty::{self, Ty, TyCtxt};\n-use rustc::ty::layout::{self, Align, FullLayout, LayoutOf};\n+use rustc::ty::layout::{self, Align, TyLayout, LayoutOf};\n use rustc::ty::maps::Providers;\n use rustc::dep_graph::{DepNode, DepKind, DepConstructor};\n use rustc::middle::cstore::{self, LinkMeta, LinkagePreference};\n@@ -68,7 +69,7 @@ use symbol_names_test;\n use time_graph;\n use trans_item::{TransItem, BaseTransItemExt, TransItemExt, DefPathBasedNames};\n use type_::Type;\n-use type_of::{self, LayoutLlvmExt};\n+use type_of::LayoutLlvmExt;\n use rustc::util::nodemap::{NodeSet, FxHashMap, FxHashSet, DefIdSet};\n use CrateInfo;\n \n@@ -203,8 +204,10 @@ pub fn unsized_info<'ccx, 'tcx>(ccx: &CrateContext<'ccx, 'tcx>,\n             old_info.expect(\"unsized_info: missing old info for trait upcast\")\n         }\n         (_, &ty::TyDynamic(ref data, ..)) => {\n+            let vtable_ptr = ccx.layout_of(ccx.tcx().mk_mut_ptr(target))\n+                .field(ccx, abi::FAT_PTR_EXTRA);\n             consts::ptrcast(meth::get_vtable(ccx, source, data.principal()),\n-                            Type::vtable_ptr(ccx))\n+                            vtable_ptr.llvm_type(ccx))\n         }\n         _ => bug!(\"unsized_info: invalid unsizing {:?} -> {:?}\",\n                                      source,\n@@ -255,8 +258,8 @@ pub fn coerce_unsized_into<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                 // i.e. &'a fmt::Debug+Send => &'a fmt::Debug\n                 // So we need to pointercast the base to ensure\n                 // the types match up.\n-                let llcast_ty = type_of::fat_ptr_base_ty(bcx.ccx, dst_ty);\n-                (bcx.pointercast(base, llcast_ty), info)\n+                let thin_ptr = dst.layout.field(bcx.ccx, abi::FAT_PTR_ADDR);\n+                (bcx.pointercast(base, thin_ptr.llvm_type(bcx.ccx)), info)\n             }\n             OperandValue::Immediate(base) => {\n                 unsize_thin_ptr(bcx, base, src_ty, dst_ty)\n@@ -371,7 +374,7 @@ pub fn from_immediate(bcx: &Builder, val: ValueRef) -> ValueRef {\n     }\n }\n \n-pub fn to_immediate(bcx: &Builder, val: ValueRef, layout: layout::FullLayout) -> ValueRef {\n+pub fn to_immediate(bcx: &Builder, val: ValueRef, layout: layout::TyLayout) -> ValueRef {\n     if let layout::Abi::Scalar(layout::Int(layout::I1, _)) = layout.abi {\n         bcx.trunc(val, Type::i1(bcx.ccx))\n     } else {\n@@ -400,7 +403,7 @@ pub fn memcpy_ty<'a, 'tcx>(\n     bcx: &Builder<'a, 'tcx>,\n     dst: ValueRef,\n     src: ValueRef,\n-    layout: FullLayout<'tcx>,\n+    layout: TyLayout<'tcx>,\n     align: Option<Align>,\n ) {\n     let ccx = bcx.ccx;"}, {"sha": "ed598e0a86b68950d45df62c763f85c79305ec18", "filename": "src/librustc_trans/cabi_s390x.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b723af284a22e6c0f2d85c104067138c33f8859d/src%2Flibrustc_trans%2Fcabi_s390x.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b723af284a22e6c0f2d85c104067138c33f8859d/src%2Flibrustc_trans%2Fcabi_s390x.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_s390x.rs?ref=b723af284a22e6c0f2d85c104067138c33f8859d", "patch": "@@ -14,7 +14,7 @@\n use abi::{FnType, ArgType, LayoutExt, Reg};\n use context::CrateContext;\n \n-use rustc::ty::layout::{self, FullLayout};\n+use rustc::ty::layout::{self, TyLayout};\n \n fn classify_ret_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ret: &mut ArgType<'tcx>) {\n     if !ret.layout.is_aggregate() && ret.layout.size(ccx).bits() <= 64 {\n@@ -25,7 +25,7 @@ fn classify_ret_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ret: &mut ArgType<'tc\n }\n \n fn is_single_fp_element<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                  layout: FullLayout<'tcx>) -> bool {\n+                                  layout: TyLayout<'tcx>) -> bool {\n     match layout.abi {\n         layout::Abi::Scalar(layout::F32) |\n         layout::Abi::Scalar(layout::F64) => true,"}, {"sha": "26f130ec75542982c3546f41eafe7928f9f913e0", "filename": "src/librustc_trans/cabi_x86.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b723af284a22e6c0f2d85c104067138c33f8859d/src%2Flibrustc_trans%2Fcabi_x86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b723af284a22e6c0f2d85c104067138c33f8859d/src%2Flibrustc_trans%2Fcabi_x86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_x86.rs?ref=b723af284a22e6c0f2d85c104067138c33f8859d", "patch": "@@ -11,7 +11,7 @@\n use abi::{ArgAttribute, FnType, LayoutExt, Reg, RegKind};\n use common::CrateContext;\n \n-use rustc::ty::layout::{self, FullLayout};\n+use rustc::ty::layout::{self, TyLayout};\n \n #[derive(PartialEq)]\n pub enum Flavor {\n@@ -20,7 +20,7 @@ pub enum Flavor {\n }\n \n fn is_single_fp_element<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                  layout: FullLayout<'tcx>) -> bool {\n+                                  layout: TyLayout<'tcx>) -> bool {\n     match layout.abi {\n         layout::Abi::Scalar(layout::F32) |\n         layout::Abi::Scalar(layout::F64) => true,"}, {"sha": "45f2b39b982d098c4896d5af7044ecd1017d7be6", "filename": "src/librustc_trans/cabi_x86_64.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b723af284a22e6c0f2d85c104067138c33f8859d/src%2Flibrustc_trans%2Fcabi_x86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b723af284a22e6c0f2d85c104067138c33f8859d/src%2Flibrustc_trans%2Fcabi_x86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_x86_64.rs?ref=b723af284a22e6c0f2d85c104067138c33f8859d", "patch": "@@ -14,7 +14,7 @@\n use abi::{ArgType, ArgAttribute, CastTarget, FnType, LayoutExt, Reg, RegKind};\n use context::CrateContext;\n \n-use rustc::ty::layout::{self, Layout, FullLayout, Size};\n+use rustc::ty::layout::{self, Layout, TyLayout, Size};\n \n #[derive(Clone, Copy, PartialEq, Debug)]\n enum Class {\n@@ -53,7 +53,7 @@ fn classify_arg<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &ArgType<'tcx>)\n     }\n \n     fn classify<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                          layout: FullLayout<'tcx>,\n+                          layout: TyLayout<'tcx>,\n                           cls: &mut [Class],\n                           off: Size)\n                           -> Result<(), Memory> {\n@@ -90,7 +90,7 @@ fn classify_arg<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &ArgType<'tcx>)\n                 // FIXME(eddyb) have to work around Rust enums for now.\n                 // Fix is either guarantee no data where there is no field,\n                 // by putting variants in fields, or be more clever.\n-                match *layout.layout {\n+                match layout.layout {\n                     Layout::General { .. } |\n                     Layout::NullablePointer { .. } => return Err(Memory),\n                     _ => {}"}, {"sha": "7ccac6069233f834fe44fbf07d92c537ec40296a", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 4, "deletions": 28, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/b723af284a22e6c0f2d85c104067138c33f8859d/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b723af284a22e6c0f2d85c104067138c33f8859d/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=b723af284a22e6c0f2d85c104067138c33f8859d", "patch": "@@ -54,29 +54,20 @@ pub fn type_is_fat_ptr<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) ->\n     }\n }\n \n-pub fn type_is_immediate<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) -> bool {\n-    let layout = ccx.layout_of(ty);\n-    match layout.abi {\n-        layout::Abi::Scalar(_) | layout::Abi::Vector { .. } => true,\n-\n-        layout::Abi::Aggregate { .. } => layout.is_zst()\n-    }\n-}\n-\n /// Returns true if the type is represented as a pair of immediates.\n pub fn type_is_imm_pair<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>)\n                                   -> bool {\n     let layout = ccx.layout_of(ty);\n-    match *layout.fields {\n+    match layout.fields {\n         layout::FieldPlacement::Arbitrary { .. } => {\n             // There must be only 2 fields.\n             if layout.fields.count() != 2 {\n                 return false;\n             }\n \n             // The two fields must be both immediates.\n-            type_is_immediate(ccx, layout.field(ccx, 0).ty) &&\n-            type_is_immediate(ccx, layout.field(ccx, 1).ty)\n+            layout.field(ccx, 0).is_llvm_immediate() &&\n+            layout.field(ccx, 1).is_llvm_immediate()\n         }\n         _ => false\n     }\n@@ -256,16 +247,7 @@ pub fn C_str_slice(cx: &CrateContext, s: InternedString) -> ValueRef {\n     let len = s.len();\n     let cs = consts::ptrcast(C_cstr(cx, s, false),\n         cx.layout_of(cx.tcx().mk_str()).llvm_type(cx).ptr_to());\n-    let empty = C_array(Type::i8(cx), &[]);\n-    assert_eq!(abi::FAT_PTR_ADDR, 0);\n-    assert_eq!(abi::FAT_PTR_EXTRA, 1);\n-    C_named_struct(cx.str_slice_type(), &[\n-        empty,\n-        cs,\n-        empty,\n-        C_usize(cx, len as u64),\n-        empty\n-    ])\n+    C_fat_ptr(cx, cs, C_usize(cx, len as u64))\n }\n \n pub fn C_fat_ptr(cx: &CrateContext, ptr: ValueRef, meta: ValueRef) -> ValueRef {\n@@ -293,12 +275,6 @@ pub fn C_struct_in_context(llcx: ContextRef, elts: &[ValueRef], packed: bool) ->\n     }\n }\n \n-pub fn C_named_struct(t: Type, elts: &[ValueRef]) -> ValueRef {\n-    unsafe {\n-        llvm::LLVMConstNamedStruct(t.to_ref(), elts.as_ptr(), elts.len() as c_uint)\n-    }\n-}\n-\n pub fn C_array(ty: Type, elts: &[ValueRef]) -> ValueRef {\n     unsafe {\n         return llvm::LLVMConstArray(ty.to_ref(), elts.as_ptr(), elts.len() as c_uint);"}, {"sha": "83efe6b795872be8287d30d42e3a6fd1ade137da", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 17, "deletions": 27, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/b723af284a22e6c0f2d85c104067138c33f8859d/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b723af284a22e6c0f2d85c104067138c33f8859d/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=b723af284a22e6c0f2d85c104067138c33f8859d", "patch": "@@ -24,14 +24,13 @@ use monomorphize::Instance;\n \n use partitioning::CodegenUnit;\n use type_::Type;\n-use type_of::LayoutLlvmExt;\n \n use rustc_data_structures::base_n;\n use rustc::middle::trans::Stats;\n use rustc_data_structures::stable_hasher::StableHashingContextProvider;\n use rustc::session::config::{self, NoDebugInfo};\n use rustc::session::Session;\n-use rustc::ty::layout::{LayoutError, LayoutOf, FullLayout};\n+use rustc::ty::layout::{LayoutError, LayoutOf, TyLayout};\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::util::nodemap::FxHashMap;\n use rustc_trans_utils;\n@@ -101,9 +100,9 @@ pub struct LocalCrateContext<'a, 'tcx: 'a> {\n     /// See http://llvm.org/docs/LangRef.html#the-llvm-used-global-variable for details\n     used_statics: RefCell<Vec<ValueRef>>,\n \n-    lltypes: RefCell<FxHashMap<Ty<'tcx>, Type>>,\n+    lltypes: RefCell<FxHashMap<(Ty<'tcx>, Option<usize>), Type>>,\n+    scalar_lltypes: RefCell<FxHashMap<Ty<'tcx>, Type>>,\n     isize_ty: Type,\n-    str_slice_type: Type,\n \n     dbg_cx: Option<debuginfo::CrateDebugContext<'tcx>>,\n \n@@ -378,8 +377,8 @@ impl<'a, 'tcx> LocalCrateContext<'a, 'tcx> {\n                 statics_to_rauw: RefCell::new(Vec::new()),\n                 used_statics: RefCell::new(Vec::new()),\n                 lltypes: RefCell::new(FxHashMap()),\n+                scalar_lltypes: RefCell::new(FxHashMap()),\n                 isize_ty: Type::from_ref(ptr::null_mut()),\n-                str_slice_type: Type::from_ref(ptr::null_mut()),\n                 dbg_cx,\n                 eh_personality: Cell::new(None),\n                 eh_unwind_resume: Cell::new(None),\n@@ -389,28 +388,19 @@ impl<'a, 'tcx> LocalCrateContext<'a, 'tcx> {\n                 placeholder: PhantomData,\n             };\n \n-            let (isize_ty, str_slice_ty, mut local_ccx) = {\n+            let (isize_ty, mut local_ccx) = {\n                 // Do a little dance to create a dummy CrateContext, so we can\n                 // create some things in the LLVM module of this codegen unit\n                 let mut local_ccxs = vec![local_ccx];\n-                let (isize_ty, str_slice_ty) = {\n+                let isize_ty = {\n                     let dummy_ccx = LocalCrateContext::dummy_ccx(shared,\n                                                                  local_ccxs.as_mut_slice());\n-                    let mut str_slice_ty = Type::named_struct(&dummy_ccx, \"str_slice\");\n-                    str_slice_ty.set_struct_body(&[\n-                        Type::array(&Type::i8(&dummy_ccx), 0),\n-                        dummy_ccx.layout_of(shared.tcx.mk_str()).llvm_type(&dummy_ccx).ptr_to(),\n-                        Type::array(&Type::i8(&dummy_ccx), 0),\n-                        Type::isize(&dummy_ccx),\n-                        Type::array(&Type::i8(&dummy_ccx), 0)\n-                    ], false);\n-                    (Type::isize(&dummy_ccx), str_slice_ty)\n+                    Type::isize(&dummy_ccx)\n                 };\n-                (isize_ty, str_slice_ty, local_ccxs.pop().unwrap())\n+                (isize_ty, local_ccxs.pop().unwrap())\n             };\n \n             local_ccx.isize_ty = isize_ty;\n-            local_ccx.str_slice_type = str_slice_ty;\n \n             local_ccx\n         }\n@@ -515,10 +505,14 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         &self.local().used_statics\n     }\n \n-    pub fn lltypes<'a>(&'a self) -> &'a RefCell<FxHashMap<Ty<'tcx>, Type>> {\n+    pub fn lltypes<'a>(&'a self) -> &'a RefCell<FxHashMap<(Ty<'tcx>, Option<usize>), Type>> {\n         &self.local().lltypes\n     }\n \n+    pub fn scalar_lltypes<'a>(&'a self) -> &'a RefCell<FxHashMap<Ty<'tcx>, Type>> {\n+        &self.local().scalar_lltypes\n+    }\n+\n     pub fn stats<'a>(&'a self) -> &'a RefCell<Stats> {\n         &self.local().stats\n     }\n@@ -527,10 +521,6 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         self.local().isize_ty\n     }\n \n-    pub fn str_slice_type(&self) -> Type {\n-        self.local().str_slice_type\n-    }\n-\n     pub fn dbg_cx<'a>(&'a self) -> &'a Option<debuginfo::CrateDebugContext<'tcx>> {\n         &self.local().dbg_cx\n     }\n@@ -669,9 +659,9 @@ impl<'a, 'tcx> ty::layout::HasTyCtxt<'tcx> for &'a CrateContext<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> LayoutOf<Ty<'tcx>> for &'a SharedCrateContext<'a, 'tcx> {\n-    type FullLayout = FullLayout<'tcx>;\n+    type TyLayout = TyLayout<'tcx>;\n \n-    fn layout_of(self, ty: Ty<'tcx>) -> Self::FullLayout {\n+    fn layout_of(self, ty: Ty<'tcx>) -> Self::TyLayout {\n         (self.tcx, ty::ParamEnv::empty(traits::Reveal::All))\n             .layout_of(ty)\n             .unwrap_or_else(|e| match e {\n@@ -682,10 +672,10 @@ impl<'a, 'tcx> LayoutOf<Ty<'tcx>> for &'a SharedCrateContext<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> LayoutOf<Ty<'tcx>> for &'a CrateContext<'a, 'tcx> {\n-    type FullLayout = FullLayout<'tcx>;\n+    type TyLayout = TyLayout<'tcx>;\n \n \n-    fn layout_of(self, ty: Ty<'tcx>) -> Self::FullLayout {\n+    fn layout_of(self, ty: Ty<'tcx>) -> Self::TyLayout {\n         self.shared.layout_of(ty)\n     }\n }"}, {"sha": "1bb8aec92e57f38bb09885ac135a7913b9acb576", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b723af284a22e6c0f2d85c104067138c33f8859d/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b723af284a22e6c0f2d85c104067138c33f8859d/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=b723af284a22e6c0f2d85c104067138c33f8859d", "patch": "@@ -32,7 +32,7 @@ use rustc::ty::util::TypeIdHasher;\n use rustc::ich::Fingerprint;\n use common::{self, CrateContext};\n use rustc::ty::{self, AdtKind, Ty};\n-use rustc::ty::layout::{self, Align, LayoutOf, Size, FullLayout};\n+use rustc::ty::layout::{self, Align, LayoutOf, Size, TyLayout};\n use rustc::session::{Session, config};\n use rustc::util::nodemap::FxHashMap;\n use rustc::util::common::path2cstr;\n@@ -1052,7 +1052,7 @@ fn prepare_tuple_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n //=-----------------------------------------------------------------------------\n \n struct UnionMemberDescriptionFactory<'tcx> {\n-    layout: FullLayout<'tcx>,\n+    layout: TyLayout<'tcx>,\n     variant: &'tcx ty::VariantDef,\n     span: Span,\n }\n@@ -1119,7 +1119,7 @@ fn prepare_union_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n // offset of zero bytes).\n struct EnumMemberDescriptionFactory<'tcx> {\n     enum_type: Ty<'tcx>,\n-    type_rep: FullLayout<'tcx>,\n+    type_rep: TyLayout<'tcx>,\n     discriminant_type_metadata: Option<DIType>,\n     containing_scope: DIScope,\n     span: Span,\n@@ -1129,7 +1129,7 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n     fn create_member_descriptions<'a>(&self, cx: &CrateContext<'a, 'tcx>)\n                                       -> Vec<MemberDescription> {\n         let adt = &self.enum_type.ty_adt_def().unwrap();\n-        match *self.type_rep.layout {\n+        match self.type_rep.layout {\n             layout::Layout::General { ref variants, .. } => {\n                 let discriminant_info = RegularDiscriminant(self.discriminant_type_metadata\n                     .expect(\"\"));\n@@ -1220,7 +1220,7 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n                 // of discriminant instead of us having to recover its path.\n                 fn compute_field_path<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                                 name: &mut String,\n-                                                layout: FullLayout<'tcx>,\n+                                                layout: TyLayout<'tcx>,\n                                                 offset: Size,\n                                                 size: Size) {\n                     for i in 0..layout.fields.count() {\n@@ -1300,7 +1300,7 @@ enum EnumDiscriminantInfo {\n // descriptions of the fields of the variant. This is a rudimentary version of a\n // full RecursiveTypeDescription.\n fn describe_enum_variant<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n-                                   layout: layout::FullLayout<'tcx>,\n+                                   layout: layout::TyLayout<'tcx>,\n                                    variant: &'tcx ty::VariantDef,\n                                    discriminant_info: EnumDiscriminantInfo,\n                                    containing_scope: DIScope,\n@@ -1431,7 +1431,7 @@ fn prepare_enum_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n     let type_rep = cx.layout_of(enum_type);\n \n-    let discriminant_type_metadata = match *type_rep.layout {\n+    let discriminant_type_metadata = match type_rep.layout {\n         layout::Layout::NullablePointer { .. } |\n         layout::Layout::Univariant { .. } => None,\n         layout::Layout::General { discr, .. } => Some(discriminant_type_metadata(discr)),"}, {"sha": "697f4ecd2bee38170f73e1083df3ab9386b816fa", "filename": "src/librustc_trans/meth.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b723af284a22e6c0f2d85c104067138c33f8859d/src%2Flibrustc_trans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b723af284a22e6c0f2d85c104067138c33f8859d/src%2Flibrustc_trans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmeth.rs?ref=b723af284a22e6c0f2d85c104067138c33f8859d", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n use llvm::ValueRef;\n+use abi::FnType;\n use callee;\n use common::*;\n use builder::Builder;\n@@ -32,10 +33,13 @@ impl<'a, 'tcx> VirtualIndex {\n         VirtualIndex(index as u64 + 3)\n     }\n \n-    pub fn get_fn(self, bcx: &Builder<'a, 'tcx>, llvtable: ValueRef) -> ValueRef {\n+    pub fn get_fn(self, bcx: &Builder<'a, 'tcx>,\n+                  llvtable: ValueRef,\n+                  fn_ty: &FnType<'tcx>) -> ValueRef {\n         // Load the data pointer from the object.\n         debug!(\"get_fn({:?}, {:?})\", Value(llvtable), self);\n \n+        let llvtable = bcx.pointercast(llvtable, fn_ty.llvm_type(bcx.ccx).ptr_to().ptr_to());\n         let ptr = bcx.load_nonnull(bcx.inbounds_gep(llvtable, &[C_usize(bcx.ccx, self.0)]), None);\n         // Vtable loads are invariant\n         bcx.set_invariant_load(ptr);"}, {"sha": "93780aefe4ddb1180d35e555c0c849d82bb04040", "filename": "src/librustc_trans/mir/analyze.rs", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b723af284a22e6c0f2d85c104067138c33f8859d/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b723af284a22e6c0f2d85c104067138c33f8859d/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs?ref=b723af284a22e6c0f2d85c104067138c33f8859d", "patch": "@@ -20,6 +20,7 @@ use rustc::mir::traversal;\n use rustc::ty;\n use rustc::ty::layout::LayoutOf;\n use common;\n+use type_of::LayoutLlvmExt;\n use super::MirContext;\n \n pub fn lvalue_locals<'a, 'tcx>(mircx: &MirContext<'a, 'tcx>) -> BitVector {\n@@ -31,21 +32,14 @@ pub fn lvalue_locals<'a, 'tcx>(mircx: &MirContext<'a, 'tcx>) -> BitVector {\n     for (index, ty) in mir.local_decls.iter().map(|l| l.ty).enumerate() {\n         let ty = mircx.monomorphize(&ty);\n         debug!(\"local {} has type {:?}\", index, ty);\n-        if ty.is_scalar() ||\n-            ty.is_box() ||\n-            ty.is_region_ptr() ||\n-            ty.is_simd() ||\n-            mircx.ccx.layout_of(ty).is_zst()\n-        {\n+        if mircx.ccx.layout_of(ty).is_llvm_immediate() {\n             // These sorts of types are immediates that we can store\n             // in an ValueRef without an alloca.\n-            assert!(common::type_is_immediate(mircx.ccx, ty) ||\n-                    common::type_is_fat_ptr(mircx.ccx, ty));\n         } else if common::type_is_imm_pair(mircx.ccx, ty) {\n             // We allow pairs and uses of any of their 2 fields.\n         } else {\n             // These sorts of types require an alloca. Note that\n-            // type_is_immediate() may *still* be true, particularly\n+            // is_llvm_immediate() may *still* be true, particularly\n             // for newtypes, but we currently force some types\n             // (e.g. structs) into an alloca unconditionally, just so\n             // that we don't have to deal with having two pathways\n@@ -179,9 +173,9 @@ impl<'mir, 'a, 'tcx> Visitor<'tcx> for LocalAnalyzer<'mir, 'a, 'tcx> {\n             LvalueContext::StorageLive |\n             LvalueContext::StorageDead |\n             LvalueContext::Validate |\n-            LvalueContext::Inspect |\n             LvalueContext::Consume => {}\n \n+            LvalueContext::Inspect |\n             LvalueContext::Store |\n             LvalueContext::Borrow { .. } |\n             LvalueContext::Projection(..) => {"}, {"sha": "0528bf972de0c2258327d9c6a0dc78d63317fc7c", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 20, "deletions": 13, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/b723af284a22e6c0f2d85c104067138c33f8859d/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b723af284a22e6c0f2d85c104067138c33f8859d/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=b723af284a22e6c0f2d85c104067138c33f8859d", "patch": "@@ -274,13 +274,22 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 }\n \n                 let lvalue = self.trans_lvalue(&bcx, location);\n-                let fn_ty = FnType::of_instance(bcx.ccx, &drop_fn);\n-                let (drop_fn, need_extra) = match ty.sty {\n-                    ty::TyDynamic(..) => (meth::DESTRUCTOR.get_fn(&bcx, lvalue.llextra),\n-                                          false),\n-                    _ => (callee::get_fn(bcx.ccx, drop_fn), lvalue.has_extra())\n+                let mut args: &[_] = &[lvalue.llval, lvalue.llextra];\n+                args = &args[..1 + lvalue.has_extra() as usize];\n+                let (drop_fn, fn_ty) = match ty.sty {\n+                    ty::TyDynamic(..) => {\n+                        let fn_ty = common::instance_ty(bcx.ccx.tcx(), &drop_fn);\n+                        let sig = common::ty_fn_sig(bcx.ccx, fn_ty);\n+                        let sig = bcx.tcx().erase_late_bound_regions_and_normalize(&sig);\n+                        let fn_ty = FnType::new_vtable(bcx.ccx, sig, &[]);\n+                        args = &args[..1];\n+                        (meth::DESTRUCTOR.get_fn(&bcx, lvalue.llextra, &fn_ty), fn_ty)\n+                    }\n+                    _ => {\n+                        (callee::get_fn(bcx.ccx, drop_fn),\n+                         FnType::of_instance(bcx.ccx, &drop_fn))\n+                    }\n                 };\n-                let args = &[lvalue.llval, lvalue.llextra][..1 + need_extra as usize];\n                 do_call(self, bcx, fn_ty, drop_fn, args,\n                         Some((ReturnDest::Nothing, target)),\n                         unwind);\n@@ -561,15 +570,13 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     (&args[..], None)\n                 };\n \n-                for (idx, arg) in first_args.iter().enumerate() {\n+                for (i, arg) in first_args.iter().enumerate() {\n                     let mut op = self.trans_operand(&bcx, arg);\n-                    if idx == 0 {\n+                    if i == 0 {\n                         if let Pair(_, meta) = op.val {\n                             if let Some(ty::InstanceDef::Virtual(_, idx)) = def {\n-                                let llmeth = meth::VirtualIndex::from_index(idx)\n-                                    .get_fn(&bcx, meta);\n-                                let llty = fn_ty.llvm_type(bcx.ccx).ptr_to();\n-                                llfn = Some(bcx.pointercast(llmeth, llty));\n+                                llfn = Some(meth::VirtualIndex::from_index(idx)\n+                                    .get_fn(&bcx, meta, &fn_ty));\n                             }\n                         }\n                     }\n@@ -582,7 +589,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                         op.val = Ref(tmp.llval, tmp.alignment);\n                     }\n \n-                    self.trans_argument(&bcx, op, &mut llargs, &fn_ty.args[idx]);\n+                    self.trans_argument(&bcx, op, &mut llargs, &fn_ty.args[i]);\n                 }\n                 if let Some(tup) = untuple {\n                     self.trans_arguments_untupled(&bcx, tup, &mut llargs,"}, {"sha": "cc6b84a671527ec9c42de8c65a36bfccfc1b09fd", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/b723af284a22e6c0f2d85c104067138c33f8859d/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b723af284a22e6c0f2d85c104067138c33f8859d/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=b723af284a22e6c0f2d85c104067138c33f8859d", "patch": "@@ -32,7 +32,7 @@ use common::{C_array, C_bool, C_bytes, C_int, C_uint, C_big_integral, C_u32, C_u\n use common::{C_null, C_struct, C_str_slice, C_undef, C_usize, C_vector, C_fat_ptr};\n use common::const_to_opt_u128;\n use consts;\n-use type_of::{self, LayoutLlvmExt};\n+use type_of::LayoutLlvmExt;\n use type_::Type;\n use value::Value;\n \n@@ -145,7 +145,7 @@ impl<'a, 'tcx> Const<'tcx> {\n         let val = if llty == llvalty && common::type_is_imm_pair(ccx, self.ty) {\n             let (a, b) = self.get_pair(ccx);\n             OperandValue::Pair(a, b)\n-        } else if llty == llvalty && common::type_is_immediate(ccx, self.ty) {\n+        } else if llty == llvalty && ccx.layout_of(self.ty).is_llvm_immediate() {\n             // If the types match, we can use the value directly.\n             OperandValue::Immediate(self.llval)\n         } else {\n@@ -677,11 +677,12 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                         }\n                         C_fat_ptr(self.ccx, base, info)\n                     }\n-                    mir::CastKind::Misc if common::type_is_immediate(self.ccx, operand.ty) => {\n-                        debug_assert!(common::type_is_immediate(self.ccx, cast_ty));\n+                    mir::CastKind::Misc if self.ccx.layout_of(operand.ty).is_llvm_immediate() => {\n                         let r_t_in = CastTy::from_ty(operand.ty).expect(\"bad input type for cast\");\n                         let r_t_out = CastTy::from_ty(cast_ty).expect(\"bad output type for cast\");\n-                        let ll_t_out = self.ccx.layout_of(cast_ty).immediate_llvm_type(self.ccx);\n+                        let cast_layout = self.ccx.layout_of(cast_ty);\n+                        assert!(cast_layout.is_llvm_immediate());\n+                        let ll_t_out = cast_layout.immediate_llvm_type(self.ccx);\n                         let llval = operand.llval;\n                         let signed = match self.ccx.layout_of(operand.ty).abi {\n                             layout::Abi::Scalar(layout::Int(_, signed)) => signed,\n@@ -728,8 +729,10 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                         if common::type_is_fat_ptr(self.ccx, operand.ty) {\n                             let (data_ptr, meta) = operand.get_fat_ptr(self.ccx);\n                             if common::type_is_fat_ptr(self.ccx, cast_ty) {\n-                                let llcast_ty = type_of::fat_ptr_base_ty(self.ccx, cast_ty);\n-                                let data_cast = consts::ptrcast(data_ptr, llcast_ty);\n+                                let thin_ptr = self.ccx.layout_of(cast_ty)\n+                                    .field(self.ccx, abi::FAT_PTR_ADDR);\n+                                let data_cast = consts::ptrcast(data_ptr,\n+                                    thin_ptr.llvm_type(self.ccx));\n                                 C_fat_ptr(self.ccx, data_cast, meta)\n                             } else { // cast to thin-ptr\n                                 // Cast of fat-ptr to thin-ptr is an extraction of data-ptr and\n@@ -1091,7 +1094,7 @@ fn trans_const_adt<'a, 'tcx>(\n         mir::AggregateKind::Adt(_, index, _, _) => index,\n         _ => 0,\n     };\n-    match *l.layout {\n+    match l.layout {\n         layout::Layout::General { .. } => {\n             let discr = match *kind {\n                 mir::AggregateKind::Adt(adt_def, _, _, _) => {\n@@ -1147,7 +1150,7 @@ fn trans_const_adt<'a, 'tcx>(\n /// a two-element struct will locate it at offset 4, and accesses to it\n /// will read the wrong memory.\n fn build_const_struct<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                layout: layout::FullLayout<'tcx>,\n+                                layout: layout::TyLayout<'tcx>,\n                                 vals: &[Const<'tcx>],\n                                 discr: Option<Const<'tcx>>)\n                                 -> Const<'tcx> {"}, {"sha": "7c0b2748a7feb909c17ab609009511377869325b", "filename": "src/librustc_trans/mir/lvalue.rs", "status": "modified", "additions": 20, "deletions": 41, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/b723af284a22e6c0f2d85c104067138c33f8859d/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b723af284a22e6c0f2d85c104067138c33f8859d/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Flvalue.rs?ref=b723af284a22e6c0f2d85c104067138c33f8859d", "patch": "@@ -10,7 +10,7 @@\n \n use llvm::{self, ValueRef};\n use rustc::ty::{self, Ty};\n-use rustc::ty::layout::{self, Align, FullLayout, LayoutOf};\n+use rustc::ty::layout::{self, Align, TyLayout, LayoutOf};\n use rustc::mir;\n use rustc::mir::tcx::LvalueTy;\n use rustc_data_structures::indexed_vec::Idx;\n@@ -19,7 +19,7 @@ use base;\n use builder::Builder;\n use common::{self, CrateContext, C_usize, C_u8, C_u32, C_uint, C_int, C_null, val_ty};\n use consts;\n-use type_of::{self, LayoutLlvmExt};\n+use type_of::LayoutLlvmExt;\n use type_::Type;\n use value::Value;\n use glue;\n@@ -54,8 +54,8 @@ impl ops::BitOr for Alignment {\n     }\n }\n \n-impl<'a> From<FullLayout<'a>> for Alignment {\n-    fn from(layout: FullLayout) -> Self {\n+impl<'a> From<TyLayout<'a>> for Alignment {\n+    fn from(layout: TyLayout) -> Self {\n         if let layout::Abi::Aggregate { packed: true, align, .. } = layout.abi {\n             Alignment::Packed(align)\n         } else {\n@@ -86,15 +86,15 @@ pub struct LvalueRef<'tcx> {\n     pub llextra: ValueRef,\n \n     /// Monomorphized type of this lvalue, including variant information\n-    pub layout: FullLayout<'tcx>,\n+    pub layout: TyLayout<'tcx>,\n \n     /// Whether this lvalue is known to be aligned according to its layout\n     pub alignment: Alignment,\n }\n \n impl<'a, 'tcx> LvalueRef<'tcx> {\n     pub fn new_sized(llval: ValueRef,\n-                     layout: FullLayout<'tcx>,\n+                     layout: TyLayout<'tcx>,\n                      alignment: Alignment)\n                      -> LvalueRef<'tcx> {\n         LvalueRef {\n@@ -105,7 +105,7 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n         }\n     }\n \n-    pub fn alloca(bcx: &Builder<'a, 'tcx>, layout: FullLayout<'tcx>, name: &str)\n+    pub fn alloca(bcx: &Builder<'a, 'tcx>, layout: TyLayout<'tcx>, name: &str)\n                   -> LvalueRef<'tcx> {\n         debug!(\"alloca({:?}: {:?})\", name, layout);\n         let tmp = bcx.alloca(\n@@ -114,7 +114,7 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n     }\n \n     pub fn len(&self, ccx: &CrateContext<'a, 'tcx>) -> ValueRef {\n-        if let layout::FieldPlacement::Array { count, .. } = *self.layout.fields {\n+        if let layout::FieldPlacement::Array { count, .. } = self.layout.fields {\n             if self.layout.is_unsized() {\n                 assert!(self.has_extra());\n                 assert_eq!(count, 0);\n@@ -163,7 +163,7 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n             OperandValue::Pair(\n                 self.project_field(bcx, 0).load(bcx).pack_if_pair(bcx).immediate(),\n                 self.project_field(bcx, 1).load(bcx).pack_if_pair(bcx).immediate())\n-        } else if common::type_is_immediate(bcx.ccx, self.layout.ty) {\n+        } else if self.layout.is_llvm_immediate() {\n             let mut const_llval = ptr::null_mut();\n             unsafe {\n                 let global = llvm::LLVMIsAGlobalVariable(self.llval);\n@@ -202,28 +202,15 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n         let ccx = bcx.ccx;\n         let field = self.layout.field(ccx, ix);\n         let offset = self.layout.fields.offset(ix).bytes();\n-\n         let alignment = self.alignment | Alignment::from(self.layout);\n \n-        // Unions and newtypes only use an offset of 0.\n-        let has_llvm_fields = match *self.layout.fields {\n-            layout::FieldPlacement::Union(_) => false,\n-            layout::FieldPlacement::Array { .. } => true,\n-            layout::FieldPlacement::Arbitrary { .. } => {\n-                match self.layout.abi {\n-                    layout::Abi::Scalar(_) | layout::Abi::Vector { .. } => false,\n-                    layout::Abi::Aggregate { .. } => true\n-                }\n-            }\n-        };\n-\n         let simple = || {\n             LvalueRef {\n-                llval: if has_llvm_fields {\n-                    bcx.struct_gep(self.llval, self.layout.llvm_field_index(ix))\n-                } else {\n-                    assert_eq!(offset, 0);\n+                // Unions and newtypes only use an offset of 0.\n+                llval: if offset == 0 {\n                     bcx.pointercast(self.llval, field.llvm_type(ccx).ptr_to())\n+                } else {\n+                    bcx.struct_gep(self.llval, self.layout.llvm_field_index(ix))\n                 },\n                 llextra: if ccx.shared().type_has_metadata(field.ty) {\n                     self.llextra\n@@ -309,7 +296,7 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n     /// Obtain the actual discriminant of a value.\n     pub fn trans_get_discr(self, bcx: &Builder<'a, 'tcx>, cast_to: Ty<'tcx>) -> ValueRef {\n         let cast_to = bcx.ccx.layout_of(cast_to).immediate_llvm_type(bcx.ccx);\n-        match *self.layout.layout {\n+        match self.layout.layout {\n             layout::Layout::Univariant { .. } |\n             layout::Layout::UntaggedUnion { .. } => return C_uint(cast_to, 0),\n             _ => {}\n@@ -320,7 +307,7 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n             layout::Abi::Scalar(discr) => discr,\n             _ => bug!(\"discriminant not scalar: {:#?}\", discr.layout)\n         };\n-        let (min, max) = match *self.layout.layout {\n+        let (min, max) = match self.layout.layout {\n             layout::Layout::General { ref discr_range, .. } => (discr_range.start, discr_range.end),\n             _ => (0, u64::max_value()),\n         };\n@@ -346,7 +333,7 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n                 bcx.load(discr.llval, discr.alignment.non_abi())\n             }\n         };\n-        match *self.layout.layout {\n+        match self.layout.layout {\n             layout::Layout::General { .. } => {\n                 let signed = match discr_scalar {\n                     layout::Int(_, signed) => signed,\n@@ -369,7 +356,7 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n         let to = self.layout.ty.ty_adt_def().unwrap()\n             .discriminant_for_variant(bcx.tcx(), variant_index)\n             .to_u128_unchecked() as u64;\n-        match *self.layout.layout {\n+        match self.layout.layout {\n             layout::Layout::General { .. } => {\n                 let ptr = self.project_field(bcx, 0);\n                 bcx.store(C_int(ptr.layout.llvm_type(bcx.ccx), to as i64),\n@@ -419,17 +406,9 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n         let mut downcast = *self;\n         downcast.layout = self.layout.for_variant(variant_index);\n \n-        // If this is an enum, cast to the appropriate variant struct type.\n-        match *self.layout.layout {\n-            layout::Layout::NullablePointer { .. } |\n-            layout::Layout::General { .. } => {\n-                let variant_ty = Type::struct_(bcx.ccx,\n-                    &type_of::struct_llfields(bcx.ccx, downcast.layout),\n-                    downcast.layout.is_packed());\n-                downcast.llval = bcx.pointercast(downcast.llval, variant_ty.ptr_to());\n-            }\n-            _ => {}\n-        }\n+        // Cast to the appropriate variant struct type.\n+        let variant_ty = downcast.layout.llvm_type(bcx.ccx);\n+        downcast.llval = bcx.pointercast(downcast.llval, variant_ty.ptr_to());\n \n         downcast\n     }"}, {"sha": "38719fedede5b543f506b1298df43803cc5cc5cd", "filename": "src/librustc_trans/mir/mod.rs", "status": "modified", "additions": 8, "deletions": 27, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/b723af284a22e6c0f2d85c104067138c33f8859d/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b723af284a22e6c0f2d85c104067138c33f8859d/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fmod.rs?ref=b723af284a22e6c0f2d85c104067138c33f8859d", "patch": "@@ -12,18 +12,17 @@ use libc::c_uint;\n use llvm::{self, ValueRef, BasicBlockRef};\n use llvm::debuginfo::DIScope;\n use rustc::ty::{self, TypeFoldable};\n-use rustc::ty::layout::{LayoutOf, FullLayout};\n+use rustc::ty::layout::{LayoutOf, TyLayout};\n use rustc::mir::{self, Mir};\n use rustc::ty::subst::Substs;\n use rustc::infer::TransNormalize;\n use rustc::session::config::FullDebugInfo;\n use base;\n use builder::Builder;\n-use common::{self, CrateContext, Funclet};\n+use common::{CrateContext, Funclet};\n use debuginfo::{self, declare_local, VariableAccess, VariableKind, FunctionDebugContext};\n use monomorphize::Instance;\n use abi::{ArgAttribute, FnType};\n-use type_of::{self, LayoutLlvmExt};\n \n use syntax_pos::{DUMMY_SP, NO_EXPANSION, BytePos, Span};\n use syntax::symbol::keywords;\n@@ -85,7 +84,7 @@ pub struct MirContext<'a, 'tcx:'a> {\n     /// directly using an `OperandRef`, which makes for tighter LLVM\n     /// IR. The conditions for using an `OperandRef` are as follows:\n     ///\n-    /// - the type of the local must be judged \"immediate\" by `type_is_immediate`\n+    /// - the type of the local must be judged \"immediate\" by `is_llvm_immediate`\n     /// - the operand must never be referenced indirectly\n     ///     - we should not take its address using the `&` operator\n     ///     - nor should it appear in an lvalue path like `tmp.a`\n@@ -177,7 +176,7 @@ enum LocalRef<'tcx> {\n }\n \n impl<'a, 'tcx> LocalRef<'tcx> {\n-    fn new_operand(ccx: &CrateContext<'a, 'tcx>, layout: FullLayout<'tcx>) -> LocalRef<'tcx> {\n+    fn new_operand(ccx: &CrateContext<'a, 'tcx>, layout: TyLayout<'tcx>) -> LocalRef<'tcx> {\n         if layout.is_zst() {\n             // Zero-size temporaries aren't always initialized, which\n             // doesn't matter because they don't contain data, but\n@@ -448,32 +447,14 @@ fn arg_local_refs<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n             assert!(!a.is_ignore() && a.cast.is_none() && a.pad.is_none());\n             assert!(!b.is_ignore() && b.cast.is_none() && b.pad.is_none());\n \n-            let mut a = llvm::get_param(bcx.llfn(), llarg_idx as c_uint);\n+            let a = llvm::get_param(bcx.llfn(), llarg_idx as c_uint);\n+            bcx.set_value_name(a, &(name.clone() + \".0\"));\n             llarg_idx += 1;\n \n-            let mut b = llvm::get_param(bcx.llfn(), llarg_idx as c_uint);\n+            let b = llvm::get_param(bcx.llfn(), llarg_idx as c_uint);\n+            bcx.set_value_name(b, &(name + \".1\"));\n             llarg_idx += 1;\n \n-            if common::type_is_fat_ptr(bcx.ccx, arg.layout.ty) {\n-                // FIXME(eddyb) As we can't perfectly represent the data and/or\n-                // vtable pointer in a fat pointers in Rust's typesystem, and\n-                // because we split fat pointers into two ArgType's, they're\n-                // not the right type so we have to cast them for now.\n-                let pointee = match arg.layout.ty.sty {\n-                    ty::TyRef(_, ty::TypeAndMut{ty, ..}) |\n-                    ty::TyRawPtr(ty::TypeAndMut{ty, ..}) => ty,\n-                    ty::TyAdt(def, _) if def.is_box() => arg.layout.ty.boxed_ty(),\n-                    _ => bug!()\n-                };\n-                let data_llty = bcx.ccx.layout_of(pointee).llvm_type(bcx.ccx);\n-                let meta_llty = type_of::unsized_info_ty(bcx.ccx, pointee);\n-\n-                a = bcx.pointercast(a, data_llty.ptr_to());\n-                bcx.set_value_name(a, &(name.clone() + \".ptr\"));\n-                b = bcx.pointercast(b, meta_llty);\n-                bcx.set_value_name(b, &(name + \".meta\"));\n-            }\n-\n             return LocalRef::Operand(Some(OperandRef {\n                 val: OperandValue::Pair(a, b),\n                 layout: arg.layout"}, {"sha": "5659072fa932c264e4a8df7f4afe5e59ca4e9763", "filename": "src/librustc_trans/mir/operand.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b723af284a22e6c0f2d85c104067138c33f8859d/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b723af284a22e6c0f2d85c104067138c33f8859d/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Foperand.rs?ref=b723af284a22e6c0f2d85c104067138c33f8859d", "patch": "@@ -10,7 +10,7 @@\n \n use llvm::ValueRef;\n use rustc::ty;\n-use rustc::ty::layout::{LayoutOf, FullLayout};\n+use rustc::ty::layout::{LayoutOf, TyLayout};\n use rustc::mir;\n use rustc_data_structures::indexed_vec::Idx;\n \n@@ -71,7 +71,7 @@ pub struct OperandRef<'tcx> {\n     pub val: OperandValue,\n \n     // The layout of value, based on its Rust type.\n-    pub layout: FullLayout<'tcx>,\n+    pub layout: TyLayout<'tcx>,\n }\n \n impl<'tcx> fmt::Debug for OperandRef<'tcx> {\n@@ -82,7 +82,7 @@ impl<'tcx> fmt::Debug for OperandRef<'tcx> {\n \n impl<'a, 'tcx> OperandRef<'tcx> {\n     pub fn new_zst(ccx: &CrateContext<'a, 'tcx>,\n-                   layout: FullLayout<'tcx>) -> OperandRef<'tcx> {\n+                   layout: TyLayout<'tcx>) -> OperandRef<'tcx> {\n         assert!(layout.is_zst());\n         let llty = layout.llvm_type(ccx);\n         // FIXME(eddyb) ZSTs should always be immediate, not pairs."}, {"sha": "b68cd3a6ae5d123c51c98b032dcbf164c205c06a", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b723af284a22e6c0f2d85c104067138c33f8859d/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b723af284a22e6c0f2d85c104067138c33f8859d/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=b723af284a22e6c0f2d85c104067138c33f8859d", "patch": "@@ -18,6 +18,7 @@ use rustc_apfloat::{ieee, Float, Status, Round};\n use rustc_const_math::MAX_F32_PLUS_HALF_ULP;\n use std::{u128, i128};\n \n+use abi;\n use base;\n use builder::Builder;\n use callee;\n@@ -26,7 +27,7 @@ use common::{C_bool, C_u8, C_i32, C_u32, C_u64, C_null, C_usize, C_uint, C_big_i\n use consts;\n use monomorphize;\n use type_::Type;\n-use type_of::{self, LayoutLlvmExt};\n+use type_of::LayoutLlvmExt;\n use value::Value;\n \n use super::{MirContext, LocalRef};\n@@ -234,8 +235,8 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                                 //   &'a fmt::Debug+Send => &'a fmt::Debug,\n                                 // So we need to pointercast the base to ensure\n                                 // the types match up.\n-                                let llcast_ty = type_of::fat_ptr_base_ty(bcx.ccx, cast.ty);\n-                                let lldata = bcx.pointercast(lldata, llcast_ty);\n+                                let thin_ptr = cast.field(bcx.ccx, abi::FAT_PTR_ADDR);\n+                                let lldata = bcx.pointercast(lldata, thin_ptr.llvm_type(bcx.ccx));\n                                 OperandValue::Pair(lldata, llextra)\n                             }\n                             OperandValue::Immediate(lldata) => {\n@@ -253,8 +254,9 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     mir::CastKind::Misc if common::type_is_fat_ptr(bcx.ccx, operand.layout.ty) => {\n                         if let OperandValue::Pair(data_ptr, meta) = operand.val {\n                             if common::type_is_fat_ptr(bcx.ccx, cast.ty) {\n-                                let llcast_ty = type_of::fat_ptr_base_ty(bcx.ccx, cast.ty);\n-                                let data_cast = bcx.pointercast(data_ptr, llcast_ty);\n+                                let thin_ptr = cast.field(bcx.ccx, abi::FAT_PTR_ADDR);\n+                                let data_cast = bcx.pointercast(data_ptr,\n+                                    thin_ptr.llvm_type(bcx.ccx));\n                                 OperandValue::Pair(data_cast, meta)\n                             } else { // cast to thin-ptr\n                                 // Cast of fat-ptr to thin-ptr is an extraction of data-ptr and\n@@ -268,15 +270,15 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                         }\n                     }\n                     mir::CastKind::Misc => {\n-                        debug_assert!(common::type_is_immediate(bcx.ccx, cast.ty));\n+                        assert!(cast.is_llvm_immediate());\n                         let r_t_in = CastTy::from_ty(operand.layout.ty)\n                             .expect(\"bad input type for cast\");\n                         let r_t_out = CastTy::from_ty(cast.ty).expect(\"bad output type for cast\");\n                         let ll_t_in = operand.layout.immediate_llvm_type(bcx.ccx);\n                         let ll_t_out = cast.immediate_llvm_type(bcx.ccx);\n                         let llval = operand.immediate();\n \n-                        if let Layout::General { ref discr_range, .. } = *operand.layout.layout {\n+                        if let Layout::General { ref discr_range, .. } = operand.layout.layout {\n                             if discr_range.end > discr_range.start {\n                                 // We want `table[e as usize]` to not\n                                 // have bound checks, and this is the most"}, {"sha": "53aaed15783224b871034da035df2a31bb23c6ca", "filename": "src/librustc_trans/type_.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b723af284a22e6c0f2d85c104067138c33f8859d/src%2Flibrustc_trans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b723af284a22e6c0f2d85c104067138c33f8859d/src%2Flibrustc_trans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftype_.rs?ref=b723af284a22e6c0f2d85c104067138c33f8859d", "patch": "@@ -207,10 +207,6 @@ impl Type {\n         ty!(llvm::LLVMVectorType(ty.to_ref(), len as c_uint))\n     }\n \n-    pub fn vtable_ptr(ccx: &CrateContext) -> Type {\n-        Type::func(&[Type::i8p(ccx)], &Type::void(ccx)).ptr_to().ptr_to()\n-    }\n-\n     pub fn kind(&self) -> TypeKind {\n         unsafe {\n             llvm::LLVMRustGetTypeKind(self.to_ref())"}, {"sha": "77cc3897c9be8bb9904d7c5795d21932accab6d9", "filename": "src/librustc_trans/type_of.rs", "status": "modified", "additions": 96, "deletions": 112, "changes": 208, "blob_url": "https://github.com/rust-lang/rust/blob/b723af284a22e6c0f2d85c104067138c33f8859d/src%2Flibrustc_trans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b723af284a22e6c0f2d85c104067138c33f8859d/src%2Flibrustc_trans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftype_of.rs?ref=b723af284a22e6c0f2d85c104067138c33f8859d", "patch": "@@ -11,131 +11,68 @@\n use abi::FnType;\n use common::*;\n use rustc::ty::{self, Ty, TypeFoldable};\n-use rustc::ty::layout::{self, HasDataLayout, Align, LayoutOf, Size, FullLayout};\n+use rustc::ty::layout::{self, HasDataLayout, Align, LayoutOf, Size, TyLayout};\n use trans_item::DefPathBasedNames;\n use type_::Type;\n \n-use syntax::ast;\n+use std::fmt::Write;\n \n-pub fn fat_ptr_base_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) -> Type {\n-    match ty.sty {\n-        ty::TyRef(_, ty::TypeAndMut { ty: t, .. }) |\n-        ty::TyRawPtr(ty::TypeAndMut { ty: t, .. }) if ccx.shared().type_has_metadata(t) => {\n-            ccx.layout_of(t).llvm_type(ccx).ptr_to()\n-        }\n-        ty::TyAdt(def, _) if def.is_box() => {\n-            ccx.layout_of(ty.boxed_ty()).llvm_type(ccx).ptr_to()\n-        }\n-        _ => bug!(\"expected fat ptr ty but got {:?}\", ty)\n-    }\n-}\n-\n-pub fn unsized_info_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) -> Type {\n-    let unsized_part = ccx.tcx().struct_tail(ty);\n-    match unsized_part.sty {\n-        ty::TyStr | ty::TyArray(..) | ty::TySlice(_) => {\n-            Type::uint_from_ty(ccx, ast::UintTy::Us)\n-        }\n-        ty::TyDynamic(..) => Type::vtable_ptr(ccx),\n-        _ => bug!(\"Unexpected tail in unsized_info_ty: {:?} for ty={:?}\",\n-                          unsized_part, ty)\n-    }\n-}\n-\n-fn uncached_llvm_type<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n-                                ty: Ty<'tcx>,\n-                                defer: &mut Option<(Type, FullLayout<'tcx>)>)\n+fn uncached_llvm_type<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                                layout: TyLayout<'tcx>,\n+                                defer: &mut Option<(Type, TyLayout<'tcx>)>)\n                                 -> Type {\n-    let ptr_ty = |ty: Ty<'tcx>| {\n-        if cx.shared().type_has_metadata(ty) {\n-            if let ty::TyStr = ty.sty {\n-                // This means we get a nicer name in the output (str is always\n-                // unsized).\n-                cx.str_slice_type()\n-            } else {\n-                let ptr_ty = cx.layout_of(ty).llvm_type(cx).ptr_to();\n-                let info_ty = unsized_info_ty(cx, ty);\n-                Type::struct_(cx, &[\n-                    Type::array(&Type::i8(cx), 0),\n-                    ptr_ty,\n-                    Type::array(&Type::i8(cx), 0),\n-                    info_ty,\n-                    Type::array(&Type::i8(cx), 0)\n-                ], false)\n-            }\n-        } else {\n-            cx.layout_of(ty).llvm_type(cx).ptr_to()\n-        }\n-    };\n-    match ty.sty {\n-        ty::TyRef(_, ty::TypeAndMut{ty, ..}) |\n-        ty::TyRawPtr(ty::TypeAndMut{ty, ..}) => {\n-            return ptr_ty(ty);\n+    match layout.abi {\n+        layout::Abi::Scalar(_) => bug!(\"handled elsewhere\"),\n+        layout::Abi::Vector { .. } => {\n+            return Type::vector(&layout.field(ccx, 0).llvm_type(ccx),\n+                                layout.fields.count() as u64);\n         }\n-        ty::TyAdt(def, _) if def.is_box() => {\n-            return ptr_ty(ty.boxed_ty());\n-        }\n-        ty::TyFnPtr(sig) => {\n-            let sig = cx.tcx().erase_late_bound_regions_and_normalize(&sig);\n-            return FnType::new(cx, sig, &[]).llvm_type(cx).ptr_to();\n-        }\n-        _ => {}\n+        layout::Abi::Aggregate { .. } => {}\n     }\n \n-    let layout = cx.layout_of(ty);\n-    if let layout::Abi::Scalar(value) = layout.abi {\n-        let llty = match value {\n-            layout::Int(layout::I1, _) => Type::i8(cx),\n-            layout::Int(i, _) => Type::from_integer(cx, i),\n-            layout::F32 => Type::f32(cx),\n-            layout::F64 => Type::f64(cx),\n-            layout::Pointer => {\n-                cx.layout_of(layout::Pointer.to_ty(cx.tcx())).llvm_type(cx)\n-            }\n-        };\n-        return llty;\n-    }\n-\n-    if let layout::Abi::Vector { .. } = layout.abi {\n-        return Type::vector(&layout.field(cx, 0).llvm_type(cx),\n-                            layout.fields.count() as u64);\n-    }\n-\n-    let name = match ty.sty {\n-        ty::TyClosure(..) | ty::TyGenerator(..) | ty::TyAdt(..) => {\n+    let name = match layout.ty.sty {\n+        ty::TyClosure(..) |\n+        ty::TyGenerator(..) |\n+        ty::TyAdt(..) |\n+        ty::TyDynamic(..) |\n+        ty::TyForeign(..) |\n+        ty::TyStr => {\n             let mut name = String::with_capacity(32);\n-            let printer = DefPathBasedNames::new(cx.tcx(), true, true);\n-            printer.push_type_name(ty, &mut name);\n+            let printer = DefPathBasedNames::new(ccx.tcx(), true, true);\n+            printer.push_type_name(layout.ty, &mut name);\n+            if let (&ty::TyAdt(def, _), Some(v)) = (&layout.ty.sty, layout.variant_index) {\n+                write!(&mut name, \"::{}\", def.variants[v].name).unwrap();\n+            }\n             Some(name)\n         }\n         _ => None\n     };\n \n-    match *layout.fields {\n+    match layout.fields {\n         layout::FieldPlacement::Union(_) => {\n-            let size = layout.size(cx).bytes();\n-            let fill = Type::array(&Type::i8(cx), size);\n+            let size = layout.size(ccx).bytes();\n+            let fill = Type::array(&Type::i8(ccx), size);\n             match name {\n                 None => {\n-                    Type::struct_(cx, &[fill], layout.is_packed())\n+                    Type::struct_(ccx, &[fill], layout.is_packed())\n                 }\n                 Some(ref name) => {\n-                    let mut llty = Type::named_struct(cx, name);\n+                    let mut llty = Type::named_struct(ccx, name);\n                     llty.set_struct_body(&[fill], layout.is_packed());\n                     llty\n                 }\n             }\n         }\n         layout::FieldPlacement::Array { count, .. } => {\n-            Type::array(&layout.field(cx, 0).llvm_type(cx), count)\n+            Type::array(&layout.field(ccx, 0).llvm_type(ccx), count)\n         }\n         layout::FieldPlacement::Arbitrary { .. } => {\n             match name {\n                 None => {\n-                    Type::struct_(cx, &struct_llfields(cx, layout), layout.is_packed())\n+                    Type::struct_(ccx, &struct_llfields(ccx, layout), layout.is_packed())\n                 }\n                 Some(ref name) => {\n-                    let llty = Type::named_struct(cx, name);\n+                    let llty = Type::named_struct(ccx, name);\n                     *defer = Some((llty, layout));\n                     llty\n                 }\n@@ -144,37 +81,37 @@ fn uncached_llvm_type<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     }\n }\n \n-pub fn struct_llfields<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n-                                 layout: FullLayout<'tcx>) -> Vec<Type> {\n+fn struct_llfields<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                             layout: TyLayout<'tcx>) -> Vec<Type> {\n     debug!(\"struct_llfields: {:#?}\", layout);\n-    let align = layout.align(cx);\n-    let size = layout.size(cx);\n+    let align = layout.align(ccx);\n+    let size = layout.size(ccx);\n     let field_count = layout.fields.count();\n \n     let mut offset = Size::from_bytes(0);\n     let mut result: Vec<Type> = Vec::with_capacity(1 + field_count * 2);\n     for i in layout.fields.index_by_increasing_offset() {\n-        let field = layout.field(cx, i);\n+        let field = layout.field(ccx, i);\n         let target_offset = layout.fields.offset(i as usize);\n         debug!(\"struct_llfields: {}: {:?} offset: {:?} target_offset: {:?}\",\n             i, field, offset, target_offset);\n         assert!(target_offset >= offset);\n         let padding = target_offset - offset;\n-        result.push(Type::array(&Type::i8(cx), padding.bytes()));\n+        result.push(Type::array(&Type::i8(ccx), padding.bytes()));\n         debug!(\"    padding before: {:?}\", padding);\n \n-        result.push(field.llvm_type(cx));\n+        result.push(field.llvm_type(ccx));\n \n         if layout.is_packed() {\n             assert_eq!(padding.bytes(), 0);\n         } else {\n-            let field_align = field.align(cx);\n+            let field_align = field.align(ccx);\n             assert!(field_align.abi() <= align.abi(),\n                     \"non-packed type has field with larger align ({}): {:#?}\",\n                     field_align.abi(), layout);\n         }\n \n-        offset = target_offset + field.size(cx);\n+        offset = target_offset + field.size(ccx);\n     }\n     if !layout.is_unsized() && field_count > 0 {\n         if offset > size {\n@@ -184,7 +121,7 @@ pub fn struct_llfields<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         let padding = size - offset;\n         debug!(\"struct_llfields: pad_bytes: {:?} offset: {:?} stride: {:?}\",\n                padding, offset, size);\n-        result.push(Type::array(&Type::i8(cx), padding.bytes()));\n+        result.push(Type::array(&Type::i8(ccx), padding.bytes()));\n         assert!(result.len() == 1 + field_count * 2);\n     } else {\n         debug!(\"struct_llfields: offset: {:?} stride: {:?}\",\n@@ -210,13 +147,22 @@ impl<'a, 'tcx> CrateContext<'a, 'tcx> {\n }\n \n pub trait LayoutLlvmExt<'tcx> {\n+    fn is_llvm_immediate(&self) -> bool;\n     fn llvm_type<'a>(&self, ccx: &CrateContext<'a, 'tcx>) -> Type;\n     fn immediate_llvm_type<'a>(&self, ccx: &CrateContext<'a, 'tcx>) -> Type;\n     fn over_align(&self, ccx: &CrateContext) -> Option<Align>;\n     fn llvm_field_index(&self, index: usize) -> u64;\n }\n \n-impl<'tcx> LayoutLlvmExt<'tcx> for FullLayout<'tcx> {\n+impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n+    fn is_llvm_immediate(&self) -> bool {\n+        match self.abi {\n+            layout::Abi::Scalar(_) | layout::Abi::Vector { .. } => true,\n+\n+            layout::Abi::Aggregate { .. } => self.is_zst()\n+        }\n+    }\n+\n     /// Get the LLVM type corresponding to a Rust type, i.e. `rustc::ty::Ty`.\n     /// The pointee type of the pointer in `LvalueRef` is always this type.\n     /// For sized types, it is also the right LLVM type for an `alloca`\n@@ -229,8 +175,42 @@ impl<'tcx> LayoutLlvmExt<'tcx> for FullLayout<'tcx> {\n     /// of that field's type - this is useful for taking the address of\n     /// that field and ensuring the struct has the right alignment.\n     fn llvm_type<'a>(&self, ccx: &CrateContext<'a, 'tcx>) -> Type {\n+        if let layout::Abi::Scalar(value) = self.abi {\n+            // Use a different cache for scalars because pointers to DSTs\n+            // can be either fat or thin (data pointers of fat pointers).\n+            if let Some(&llty) = ccx.scalar_lltypes().borrow().get(&self.ty) {\n+                return llty;\n+            }\n+            let llty = match value {\n+                layout::Int(layout::I1, _) => Type::i8(ccx),\n+                layout::Int(i, _) => Type::from_integer(ccx, i),\n+                layout::F32 => Type::f32(ccx),\n+                layout::F64 => Type::f64(ccx),\n+                layout::Pointer => {\n+                    let pointee = match self.ty.sty {\n+                        ty::TyRef(_, ty::TypeAndMut { ty, .. }) |\n+                        ty::TyRawPtr(ty::TypeAndMut { ty, .. }) => {\n+                            ccx.layout_of(ty).llvm_type(ccx)\n+                        }\n+                        ty::TyAdt(def, _) if def.is_box() => {\n+                            ccx.layout_of(self.ty.boxed_ty()).llvm_type(ccx)\n+                        }\n+                        ty::TyFnPtr(sig) => {\n+                            let sig = ccx.tcx().erase_late_bound_regions_and_normalize(&sig);\n+                            FnType::new(ccx, sig, &[]).llvm_type(ccx)\n+                        }\n+                        _ => Type::i8(ccx)\n+                    };\n+                    pointee.ptr_to()\n+                }\n+            };\n+            ccx.scalar_lltypes().borrow_mut().insert(self.ty, llty);\n+            return llty;\n+        }\n+\n+\n         // Check the cache.\n-        if let Some(&llty) = ccx.lltypes().borrow().get(&self.ty) {\n+        if let Some(&llty) = ccx.lltypes().borrow().get(&(self.ty, self.variant_index)) {\n             return llty;\n         }\n \n@@ -244,13 +224,17 @@ impl<'tcx> LayoutLlvmExt<'tcx> for FullLayout<'tcx> {\n \n         let mut defer = None;\n         let llty = if self.ty != normal_ty {\n-            ccx.layout_of(normal_ty).llvm_type(ccx)\n+            let mut layout = ccx.layout_of(normal_ty);\n+            if let Some(v) = self.variant_index {\n+                layout = layout.for_variant(v);\n+            }\n+            layout.llvm_type(ccx)\n         } else {\n-            uncached_llvm_type(ccx, self.ty, &mut defer)\n+            uncached_llvm_type(ccx, *self, &mut defer)\n         };\n         debug!(\"--> mapped {:#?} to llty={:?}\", self, llty);\n \n-        ccx.lltypes().borrow_mut().insert(self.ty, llty);\n+        ccx.lltypes().borrow_mut().insert((self.ty, self.variant_index), llty);\n \n         if let Some((mut llty, layout)) = defer {\n             llty.set_struct_body(&struct_llfields(ccx, layout), layout.is_packed())\n@@ -279,11 +263,11 @@ impl<'tcx> LayoutLlvmExt<'tcx> for FullLayout<'tcx> {\n \n     fn llvm_field_index(&self, index: usize) -> u64 {\n         if let layout::Abi::Scalar(_) = self.abi {\n-            bug!(\"FullLayout::llvm_field_index({:?}): not applicable\", self);\n+            bug!(\"TyLayout::llvm_field_index({:?}): not applicable\", self);\n         }\n-        match *self.fields {\n+        match self.fields {\n             layout::FieldPlacement::Union(_) => {\n-                bug!(\"FullLayout::llvm_field_index({:?}): not applicable\", self)\n+                bug!(\"TyLayout::llvm_field_index({:?}): not applicable\", self)\n             }\n \n             layout::FieldPlacement::Array { .. } => {"}, {"sha": "525a1f5310c9a978130a7e78f264ec7f8d1361c2", "filename": "src/test/codegen/adjustments.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b723af284a22e6c0f2d85c104067138c33f8859d/src%2Ftest%2Fcodegen%2Fadjustments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b723af284a22e6c0f2d85c104067138c33f8859d/src%2Ftest%2Fcodegen%2Fadjustments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fadjustments.rs?ref=b723af284a22e6c0f2d85c104067138c33f8859d", "patch": "@@ -24,10 +24,9 @@ pub fn helper(_: usize) {\n pub fn no_op_slice_adjustment(x: &[u8]) -> &[u8] {\n     // We used to generate an extra alloca and memcpy for the block's trailing expression value, so\n     // check that we copy directly to the return value slot\n-// CHECK: %x.ptr = bitcast i8* %0 to [0 x i8]*\n-// CHECK: %1 = insertvalue { [0 x i8], [0 x i8]*, [0 x i8], [[USIZE]], [0 x i8] } undef, [0 x i8]* %x.ptr, 1\n-// CHECK: %2 = insertvalue { [0 x i8], [0 x i8]*, [0 x i8], [[USIZE]], [0 x i8] } %1, [[USIZE]] %x.meta, 3\n-// CHECK: ret { [0 x i8], [0 x i8]*, [0 x i8], [[USIZE]], [0 x i8] } %2\n+// CHECK: %0 = insertvalue { [0 x i8], [0 x i8]*, [0 x i8], [[USIZE]], [0 x i8] } undef, [0 x i8]* %x.0, 1\n+// CHECK: %1 = insertvalue { [0 x i8], [0 x i8]*, [0 x i8], [[USIZE]], [0 x i8] } %0, [[USIZE]] %x.1, 3\n+// CHECK: ret { [0 x i8], [0 x i8]*, [0 x i8], [[USIZE]], [0 x i8] } %1\n     { x }\n }\n "}, {"sha": "05682a8efaecc1637092f98dee2197b643b951c8", "filename": "src/test/codegen/function-arguments.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b723af284a22e6c0f2d85c104067138c33f8859d/src%2Ftest%2Fcodegen%2Ffunction-arguments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b723af284a22e6c0f2d85c104067138c33f8859d/src%2Ftest%2Fcodegen%2Ffunction-arguments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Ffunction-arguments.rs?ref=b723af284a22e6c0f2d85c104067138c33f8859d", "patch": "@@ -97,43 +97,43 @@ pub fn struct_return() -> S {\n pub fn helper(_: usize) {\n }\n \n-// CHECK: @slice(i8* noalias nonnull readonly %arg0.ptr, [[USIZE]] %arg0.meta)\n+// CHECK: @slice([0 x i8]* noalias nonnull readonly %arg0.0, [[USIZE]] %arg0.1)\n // FIXME #25759 This should also have `nocapture`\n #[no_mangle]\n pub fn slice(_: &[u8]) {\n }\n \n-// CHECK: @mutable_slice(i8* nonnull %arg0.ptr, [[USIZE]] %arg0.meta)\n+// CHECK: @mutable_slice([0 x i8]* nonnull %arg0.0, [[USIZE]] %arg0.1)\n // FIXME #25759 This should also have `nocapture`\n // ... there's this LLVM bug that forces us to not use noalias, see #29485\n #[no_mangle]\n pub fn mutable_slice(_: &mut [u8]) {\n }\n \n-// CHECK: @unsafe_slice(%UnsafeInner* nonnull %arg0.ptr, [[USIZE]] %arg0.meta)\n+// CHECK: @unsafe_slice([0 x %UnsafeInner]* nonnull %arg0.0, [[USIZE]] %arg0.1)\n // unsafe interior means this isn't actually readonly and there may be aliases ...\n #[no_mangle]\n pub fn unsafe_slice(_: &[UnsafeInner]) {\n }\n \n-// CHECK: @str(i8* noalias nonnull readonly %arg0.ptr, [[USIZE]] %arg0.meta)\n+// CHECK: @str([0 x i8]* noalias nonnull readonly %arg0.0, [[USIZE]] %arg0.1)\n // FIXME #25759 This should also have `nocapture`\n #[no_mangle]\n pub fn str(_: &[u8]) {\n }\n \n-// CHECK: @trait_borrow({}* nonnull, {}* noalias nonnull readonly)\n+// CHECK: @trait_borrow(%\"core::ops::drop::Drop\"* nonnull %arg0.0, {}* noalias nonnull readonly %arg0.1)\n // FIXME #25759 This should also have `nocapture`\n #[no_mangle]\n pub fn trait_borrow(_: &Drop) {\n }\n \n-// CHECK: @trait_box({}* noalias nonnull, {}* noalias nonnull readonly)\n+// CHECK: @trait_box(%\"core::ops::drop::Drop\"* noalias nonnull, {}* noalias nonnull readonly)\n #[no_mangle]\n pub fn trait_box(_: Box<Drop>) {\n }\n \n-// CHECK: { [0 x i8], [0 x i16]*, [0 x i8], [[USIZE]], [0 x i8] } @return_slice(i16* noalias nonnull readonly %x.ptr, [[USIZE]] %x.meta)\n+// CHECK: { [0 x i8], [0 x i16]*, [0 x i8], [[USIZE]], [0 x i8] } @return_slice([0 x i16]* noalias nonnull readonly %x.0, [[USIZE]] %x.1)\n #[no_mangle]\n pub fn return_slice(x: &[u16]) -> &[u16] {\n   x"}, {"sha": "2ab64fffa3b34070275c2dd8ea7c7613249221a9", "filename": "src/test/codegen/refs.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b723af284a22e6c0f2d85c104067138c33f8859d/src%2Ftest%2Fcodegen%2Frefs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b723af284a22e6c0f2d85c104067138c33f8859d/src%2Ftest%2Fcodegen%2Frefs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Frefs.rs?ref=b723af284a22e6c0f2d85c104067138c33f8859d", "patch": "@@ -24,10 +24,10 @@ pub fn helper(_: usize) {\n pub fn ref_dst(s: &[u8]) {\n     // We used to generate an extra alloca and memcpy to ref the dst, so check that we copy\n     // directly to the alloca for \"x\"\n-// CHECK: [[X0:%[0-9]+]] = getelementptr {{.*}} { [0 x i8], [0 x i8]*, [0 x i8], [[USIZE]], [0 x i8] }* %x, i32 0, i32 1\n-// CHECK: store [0 x i8]* %s.ptr, [0 x i8]** [[X0]]\n+// CHECK: [[X0:%[0-9]+]] = bitcast { [0 x i8], [0 x i8]*, [0 x i8], [[USIZE]], [0 x i8] }* %x to [0 x i8]**\n+// CHECK: store [0 x i8]* %s.0, [0 x i8]** [[X0]]\n // CHECK: [[X1:%[0-9]+]] = getelementptr {{.*}} { [0 x i8], [0 x i8]*, [0 x i8], [[USIZE]], [0 x i8] }* %x, i32 0, i32 3\n-// CHECK: store [[USIZE]] %s.meta, [[USIZE]]* [[X1]]\n+// CHECK: store [[USIZE]] %s.1, [[USIZE]]* [[X1]]\n \n     let x = &*s;\n     &x; // keep variable in an alloca"}]}