{"sha": "9c282b44c2252c81ee638cea5b5b51763921f3e7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjljMjgyYjQ0YzIyNTJjODFlZTYzOGNlYTViNWI1MTc2MzkyMWYzZTc=", "commit": {"author": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2018-11-13T14:50:10Z"}, "committer": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2018-11-29T09:16:04Z"}, "message": "Support arbitrary slice constants for pattern deaggregation", "tree": {"sha": "4186762dbbe8ecadb967ed0402413a8eb4d09645", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4186762dbbe8ecadb967ed0402413a8eb4d09645"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9c282b44c2252c81ee638cea5b5b51763921f3e7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9c282b44c2252c81ee638cea5b5b51763921f3e7", "html_url": "https://github.com/rust-lang/rust/commit/9c282b44c2252c81ee638cea5b5b51763921f3e7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9c282b44c2252c81ee638cea5b5b51763921f3e7/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7df1d9f6564cafca3758e5d629920c02df526989", "url": "https://api.github.com/repos/rust-lang/rust/commits/7df1d9f6564cafca3758e5d629920c02df526989", "html_url": "https://github.com/rust-lang/rust/commit/7df1d9f6564cafca3758e5d629920c02df526989"}], "stats": {"total": 77, "additions": 50, "deletions": 27}, "files": [{"sha": "3c44ba0ad230b5d8fe6df610875f2bb2ea2730d7", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 24, "deletions": 23, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/9c282b44c2252c81ee638cea5b5b51763921f3e7/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c282b44c2252c81ee638cea5b5b51763921f3e7/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=9c282b44c2252c81ee638cea5b5b51763921f3e7", "patch": "@@ -309,13 +309,15 @@ pub struct MatchCheckCtxt<'a, 'tcx: 'a> {\n     /// outside it's module and should not be matchable with an empty match\n     /// statement.\n     pub module: DefId,\n+    param_env: ty::ParamEnv<'tcx>,\n     pub pattern_arena: &'a TypedArena<Pattern<'tcx>>,\n     pub byte_array_map: FxHashMap<*const Pattern<'tcx>, Vec<&'a Pattern<'tcx>>>,\n }\n \n impl<'a, 'tcx> MatchCheckCtxt<'a, 'tcx> {\n     pub fn create_and_enter<F, R>(\n         tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n         module: DefId,\n         f: F) -> R\n         where F: for<'b> FnOnce(MatchCheckCtxt<'b, 'tcx>) -> R\n@@ -324,6 +326,7 @@ impl<'a, 'tcx> MatchCheckCtxt<'a, 'tcx> {\n \n         f(MatchCheckCtxt {\n             tcx,\n+            param_env,\n             module,\n             pattern_arena: &pattern_arena,\n             byte_array_map: FxHashMap::default(),\n@@ -1668,17 +1671,14 @@ fn specialize<'p, 'a: 'p, 'tcx: 'a>(\n                     // necessarily point to memory, they are usually just integers. The only time\n                     // they should be pointing to memory is when they are subslices of nonzero\n                     // slices\n-                    let (opt_ptr, data_len) = match value.ty.builtin_deref(false).unwrap().ty.sty {\n-                        ty::TyKind::Array(t, n) => {\n-                            assert!(t == cx.tcx.types.u8);\n-                            (value.to_ptr(), n.unwrap_usize(cx.tcx))\n-                        },\n+                    let (opt_ptr, n, ty) = match value.ty.builtin_deref(false).unwrap().ty.sty {\n+                        ty::TyKind::Array(t, n) => (value.to_ptr(), n.unwrap_usize(cx.tcx), t),\n                         ty::TyKind::Slice(t) => {\n-                            assert!(t == cx.tcx.types.u8);\n                             match value.val {\n                                 ConstValue::ScalarPair(ptr, n) => (\n                                     ptr.to_ptr().ok(),\n-                                    n.to_bits(cx.tcx.data_layout.pointer_size).unwrap() as u64\n+                                    n.to_bits(cx.tcx.data_layout.pointer_size).unwrap() as u64,\n+                                    t,\n                                 ),\n                                 _ => span_bug!(\n                                     pat.span,\n@@ -1694,26 +1694,27 @@ fn specialize<'p, 'a: 'p, 'tcx: 'a>(\n                             constructor,\n                         ),\n                     };\n-                    if wild_patterns.len() as u64 == data_len {\n-                        // convert a byte-string pattern to a list of u8 patterns.\n-                        match (data_len, opt_ptr) {\n+                    if wild_patterns.len() as u64 == n {\n+                        // convert a constant slice/array pattern to a list of patterns.\n+                        match (n, opt_ptr) {\n                             (0, _) => Some(Vec::new()),\n                             (_, Some(ptr)) => {\n                                 let alloc = cx.tcx.alloc_map.lock().unwrap_memory(ptr.alloc_id);\n-                                // FIXME: use `Allocation::read_bytes` once available\n-                                assert_eq!(ptr.offset.bytes(), 0);\n-                                Some(alloc.bytes.iter().map(|b| {\n-                                    &*cx.pattern_arena.alloc(Pattern {\n-                                        ty: cx.tcx.types.u8,\n+                                let layout = cx.tcx.layout_of(cx.param_env.and(ty)).ok()?;\n+                                (0..n).map(|i| {\n+                                    let ptr = ptr.offset(layout.size * i, &cx.tcx).ok()?;\n+                                    let scalar = alloc.read_scalar(\n+                                        &cx.tcx, ptr, layout.size,\n+                                    ).ok()?;\n+                                    let scalar = scalar.not_undef().ok()?;\n+                                    let value = ty::Const::from_scalar(cx.tcx, scalar, ty);\n+                                    let pattern = Pattern {\n+                                        ty,\n                                         span: pat.span,\n-                                        kind: box PatternKind::Constant {\n-                                            value: ty::Const::from_bits(\n-                                                cx.tcx,\n-                                                *b as u128,\n-                                                ty::ParamEnv::empty().and(cx.tcx.types.u8))\n-                                        },\n-                                    })\n-                                }).collect())\n+                                        kind: box PatternKind::Constant { value },\n+                                    };\n+                                    Some(&*cx.pattern_arena.alloc(pattern))\n+                                }).collect()\n                             },\n                             (_, None) => span_bug!(\n                                 pat.span,"}, {"sha": "800f644f7f5957bb878003495c67c899476dbdbc", "filename": "src/librustc_mir/hair/pattern/check_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9c282b44c2252c81ee638cea5b5b51763921f3e7/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c282b44c2252c81ee638cea5b5b51763921f3e7/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs?ref=9c282b44c2252c81ee638cea5b5b51763921f3e7", "patch": "@@ -193,7 +193,7 @@ impl<'a, 'tcx> MatchVisitor<'a, 'tcx> {\n         }\n \n         let module = self.tcx.hir.get_module_parent(scrut.id);\n-        MatchCheckCtxt::create_and_enter(self.tcx, module, |ref mut cx| {\n+        MatchCheckCtxt::create_and_enter(self.tcx, self.param_env, module, |ref mut cx| {\n             let mut have_errors = false;\n \n             let inlined_arms : Vec<(Vec<_>, _)> = arms.iter().map(|arm| (\n@@ -268,7 +268,7 @@ impl<'a, 'tcx> MatchVisitor<'a, 'tcx> {\n \n     fn check_irrefutable(&self, pat: &'tcx Pat, origin: &str) {\n         let module = self.tcx.hir.get_module_parent(pat.id);\n-        MatchCheckCtxt::create_and_enter(self.tcx, module, |ref mut cx| {\n+        MatchCheckCtxt::create_and_enter(self.tcx, self.param_env, module, |ref mut cx| {\n             let mut patcx = PatternContext::new(self.tcx,\n                                                 self.param_env.and(self.identity_substs),\n                                                 self.tables);"}, {"sha": "328ba3d1137ec1ab1d9e91a832f6e6cf68c220b4", "filename": "src/test/ui/pattern/slice-pattern-const-2.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9c282b44c2252c81ee638cea5b5b51763921f3e7/src%2Ftest%2Fui%2Fpattern%2Fslice-pattern-const-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c282b44c2252c81ee638cea5b5b51763921f3e7/src%2Ftest%2Fui%2Fpattern%2Fslice-pattern-const-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fslice-pattern-const-2.rs?ref=9c282b44c2252c81ee638cea5b5b51763921f3e7", "patch": "@@ -0,0 +1,11 @@\n+// compile-pass\n+\n+fn main() {\n+\tlet s = &[0x00; 4][..]; //Slice of any value\n+\tconst MAGIC_TEST: &[u32] = &[4, 5, 6, 7]; //Const slice to pattern match with\n+\tmatch s {\n+\t\tMAGIC_TEST => (),\n+\t\t[0x00, 0x00, 0x00, 0x00] => (),\n+\t\t_ => (),\n+\t}\n+}"}, {"sha": "aedd9825001c1afc5231ddc2432dcbdb17f23065", "filename": "src/test/ui/pattern/slice-pattern-const-3.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9c282b44c2252c81ee638cea5b5b51763921f3e7/src%2Ftest%2Fui%2Fpattern%2Fslice-pattern-const-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c282b44c2252c81ee638cea5b5b51763921f3e7/src%2Ftest%2Fui%2Fpattern%2Fslice-pattern-const-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fslice-pattern-const-3.rs?ref=9c282b44c2252c81ee638cea5b5b51763921f3e7", "patch": "@@ -0,0 +1,11 @@\n+// compile-pass\n+\n+fn main() {\n+\tlet s = &[\"0x00\"; 4][..]; //Slice of any value\n+\tconst MAGIC_TEST: &[&str] = &[\"4\", \"5\", \"6\", \"7\"]; //Const slice to pattern match with\n+\tmatch s {\n+\t\tMAGIC_TEST => (),\n+\t\t[\"0x00\", \"0x00\", \"0x00\", \"0x00\"] => (),\n+\t\t_ => (),\n+\t}\n+}"}, {"sha": "c3b11111f8e58aa64d5fe79bd4960fe0f8c6cbc0", "filename": "src/test/ui/pattern/slice-pattern-const.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9c282b44c2252c81ee638cea5b5b51763921f3e7/src%2Ftest%2Fui%2Fpattern%2Fslice-pattern-const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c282b44c2252c81ee638cea5b5b51763921f3e7/src%2Ftest%2Fui%2Fpattern%2Fslice-pattern-const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fslice-pattern-const.rs?ref=9c282b44c2252c81ee638cea5b5b51763921f3e7", "patch": "@@ -6,6 +6,6 @@ fn main() {\n \tmatch s {\n \t\tMAGIC_TEST => (),\n \t\t[0x00, 0x00, 0x00, 0x00] => (),\n-\t\t_ => ()\n+\t\t_ => (),\n \t}\n-}\n\\ No newline at end of file\n+}"}]}