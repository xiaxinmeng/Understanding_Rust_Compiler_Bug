{"sha": "e8121b3d163f90a8f1cefca07352d3780eed933d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU4MTIxYjNkMTYzZjkwYThmMWNlZmNhMDczNTJkMzc4MGVlZDkzM2Q=", "commit": {"author": {"name": "John Colanduoni", "email": "john@colanduoni.com", "date": "2017-07-23T06:05:47Z"}, "committer": {"name": "kennytm", "email": "kennytm@gmail.com", "date": "2017-09-01T19:24:15Z"}, "message": "Add libbacktrace support for Apple platforms", "tree": {"sha": "5d3cef5f0030de9f4f04619d081facbbad6c3290", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5d3cef5f0030de9f4f04619d081facbbad6c3290"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e8121b3d163f90a8f1cefca07352d3780eed933d", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIcBAABCAAGBQJZqbPgAAoJEP72yAUdDgE8pEMP/1bIVm79rNjNTzMydUajyYtd\nfbUKL9aOzGNb6yM+ZO5xWDt9+PoKbuamXwfg3kbQAP7oAYDlZWx7E6NgGWpCYUzs\ntKX6SeM4VENuzXluNNkJ46ClEI+cGdKRj/RWayyZSO0VBlcuORG4hRDE9PGcVHrc\nhPduBjRVWXS2MdHlRt0LTjMkg6LNggb+519gjCkvMxF1BclITlNng2xY3oMDe0dS\nNCZRsE5fJ2BdSNWfaBDKsPwrzp3CggQn/4MXypAMJM0WQWWB4oZD4DFbH9c5SWYU\nxbAZcG/Wgrt1uUBqD5w6HPtJVVZx5xIw+jQl42Bj+4E+85klxDxK7xHyR5V4DL7J\nADDdpjzevUu8rCBEbgb3RHoDmQUDUdPNfvYeLtZ2z/vxB++q8Uhhy1w27JBX862f\nekjk/ZWPpQ2upJizCcf8K5Zxpj9Tm1ev351LCF3FJHdcRjwQRcl9x/8l1bF0m10a\nX9Y3t/MDtblPU1D1bT24kqxeZP/bY4ye1IcQT6+Z3Ot2W58l9l0vb0oHQIe/Dw47\nv1mn32g1ybs+3mdpv1sFOIIty5ZdoSHSVV6wGDfQEe5xVksDyhoAs2v4dYP+tsR+\nACbYllB3KL70uOlOgiD0dcJHXwTSE71sDrKNorgFgMCQrZ+LoAai+0Ho4q203ASr\nSJ9wBTw+zAZfWtmm+ZF9\n=tlqG\n-----END PGP SIGNATURE-----", "payload": "tree 5d3cef5f0030de9f4f04619d081facbbad6c3290\nparent f861b6ee46465097eec266c160ac53e230df7cf0\nauthor John Colanduoni <john@colanduoni.com> 1500789947 -0700\ncommitter kennytm <kennytm@gmail.com> 1504293855 +0800\n\nAdd libbacktrace support for Apple platforms\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e8121b3d163f90a8f1cefca07352d3780eed933d", "html_url": "https://github.com/rust-lang/rust/commit/e8121b3d163f90a8f1cefca07352d3780eed933d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e8121b3d163f90a8f1cefca07352d3780eed933d/comments", "author": {"login": "JohnColanduoni", "id": 54400, "node_id": "MDQ6VXNlcjU0NDAw", "avatar_url": "https://avatars.githubusercontent.com/u/54400?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JohnColanduoni", "html_url": "https://github.com/JohnColanduoni", "followers_url": "https://api.github.com/users/JohnColanduoni/followers", "following_url": "https://api.github.com/users/JohnColanduoni/following{/other_user}", "gists_url": "https://api.github.com/users/JohnColanduoni/gists{/gist_id}", "starred_url": "https://api.github.com/users/JohnColanduoni/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JohnColanduoni/subscriptions", "organizations_url": "https://api.github.com/users/JohnColanduoni/orgs", "repos_url": "https://api.github.com/users/JohnColanduoni/repos", "events_url": "https://api.github.com/users/JohnColanduoni/events{/privacy}", "received_events_url": "https://api.github.com/users/JohnColanduoni/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kennytm", "id": 103023, "node_id": "MDQ6VXNlcjEwMzAyMw==", "avatar_url": "https://avatars.githubusercontent.com/u/103023?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kennytm", "html_url": "https://github.com/kennytm", "followers_url": "https://api.github.com/users/kennytm/followers", "following_url": "https://api.github.com/users/kennytm/following{/other_user}", "gists_url": "https://api.github.com/users/kennytm/gists{/gist_id}", "starred_url": "https://api.github.com/users/kennytm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kennytm/subscriptions", "organizations_url": "https://api.github.com/users/kennytm/orgs", "repos_url": "https://api.github.com/users/kennytm/repos", "events_url": "https://api.github.com/users/kennytm/events{/privacy}", "received_events_url": "https://api.github.com/users/kennytm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f861b6ee46465097eec266c160ac53e230df7cf0", "url": "https://api.github.com/repos/rust-lang/rust/commits/f861b6ee46465097eec266c160ac53e230df7cf0", "html_url": "https://github.com/rust-lang/rust/commit/f861b6ee46465097eec266c160ac53e230df7cf0"}], "stats": {"total": 1465, "additions": 1458, "deletions": 7}, "files": [{"sha": "ed47ba3c2fa0822f621a5db62db529c1b5dd0a13", "filename": "src/libbacktrace/configure", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e8121b3d163f90a8f1cefca07352d3780eed933d/src%2Flibbacktrace%2Fconfigure", "raw_url": "https://github.com/rust-lang/rust/raw/e8121b3d163f90a8f1cefca07352d3780eed933d/src%2Flibbacktrace%2Fconfigure", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fconfigure?ref=e8121b3d163f90a8f1cefca07352d3780eed933d", "patch": "@@ -11844,6 +11844,9 @@ elf*) FORMAT_FILE=\"elf.lo\" ;;\n pecoff) FORMAT_FILE=\"pecoff.lo\"\n         backtrace_supports_data=no\n \t;;\n+macho*) FORMAT_FILE=\"macho.lo\"\n+        backtrace_supports_data=no\n+        ;;\n *) { $as_echo \"$as_me:${as_lineno-$LINENO}: WARNING: could not determine output file type\" >&5\n $as_echo \"$as_me: WARNING: could not determine output file type\" >&2;}\n    FORMAT_FILE=\"unknown.lo\""}, {"sha": "7ae21b8d1a68c78bb67af749d939d525c01ed0b0", "filename": "src/libbacktrace/configure.ac", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e8121b3d163f90a8f1cefca07352d3780eed933d/src%2Flibbacktrace%2Fconfigure.ac", "raw_url": "https://github.com/rust-lang/rust/raw/e8121b3d163f90a8f1cefca07352d3780eed933d/src%2Flibbacktrace%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fconfigure.ac?ref=e8121b3d163f90a8f1cefca07352d3780eed933d", "patch": "@@ -231,6 +231,9 @@ elf*) FORMAT_FILE=\"elf.lo\" ;;\n pecoff) FORMAT_FILE=\"pecoff.lo\"\n         backtrace_supports_data=no\n \t;;\n+macho*) FORMAT_FILE=\"macho.lo\"\n+        backtrace_supports_data=no\n+        ;;\n *) AC_MSG_WARN([could not determine output file type])\n    FORMAT_FILE=\"unknown.lo\"\n    backtrace_supported=no"}, {"sha": "a5f6c8cc1800f0cb24d415cade2b0905f54a730f", "filename": "src/libbacktrace/filetype.awk", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e8121b3d163f90a8f1cefca07352d3780eed933d/src%2Flibbacktrace%2Ffiletype.awk", "raw_url": "https://github.com/rust-lang/rust/raw/e8121b3d163f90a8f1cefca07352d3780eed933d/src%2Flibbacktrace%2Ffiletype.awk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Ffiletype.awk?ref=e8121b3d163f90a8f1cefca07352d3780eed933d", "patch": "@@ -3,3 +3,9 @@\n /\\177ELF\\002/ { if (NR == 1) { print \"elf64\"; exit } }\n /\\114\\001/    { if (NR == 1) { print \"pecoff\"; exit } }\n /\\144\\206/    { if (NR == 1) { print \"pecoff\"; exit } }\n+/\\xFE\\xED\\xFA\\xCE/ { if (NR == 1) { print \"macho32\"; exit } }\n+/\\xCE\\xFA\\xED\\xFE/ { if (NR == 1) { print \"macho32\"; exit } }\n+/\\xFE\\xED\\xFA\\xCF/ { if (NR == 1) { print \"macho64\"; exit } }\n+/\\xCF\\xFA\\xED\\xFE/ { if (NR == 1) { print \"macho64\"; exit } }\n+/\\xCA\\xFE\\xBA\\xBE/ { if (NR == 1) { print \"macho-fat\"; exit } }\n+/\\xBE\\xBA\\xFE\\xCA/ { if (NR == 1) { print \"macho-fat\"; exit } }"}, {"sha": "2f9655a12508af48c24343aae086afa8cc6fcaaa", "filename": "src/libbacktrace/macho.c", "status": "added", "additions": 1414, "deletions": 0, "changes": 1414, "blob_url": "https://github.com/rust-lang/rust/blob/e8121b3d163f90a8f1cefca07352d3780eed933d/src%2Flibbacktrace%2Fmacho.c", "raw_url": "https://github.com/rust-lang/rust/raw/e8121b3d163f90a8f1cefca07352d3780eed933d/src%2Flibbacktrace%2Fmacho.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fmacho.c?ref=e8121b3d163f90a8f1cefca07352d3780eed933d", "patch": "@@ -0,0 +1,1414 @@\n+/* macho.c -- Get debug data from an Mach-O file for backtraces.\n+   Copyright (C) 2012-2016 Free Software Foundation, Inc.\n+   Written by John Colanduoni.\n+\n+Redistribution and use in source and binary forms, with or without\n+modification, are permitted provided that the following conditions are\n+met:\n+\n+    (1) Redistributions of source code must retain the above copyright\n+    notice, this list of conditions and the following disclaimer.\n+\n+    (2) Redistributions in binary form must reproduce the above copyright\n+    notice, this list of conditions and the following disclaimer in\n+    the documentation and/or other materials provided with the\n+    distribution.\n+\n+    (3) The name of the author may not be used to\n+    endorse or promote products derived from this software without\n+    specific prior written permission.\n+\n+THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n+IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,\n+INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n+SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n+STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n+IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+POSSIBILITY OF SUCH DAMAGE.  */\n+\n+#include \"config.h\"\n+\n+/* We can't use autotools to detect the pointer width of our program because\n+   we may be building a fat Mach-O file containing both 32-bit and 64-bit\n+   variants. However Mach-O runs a limited set of platforms so detection\n+   via preprocessor is not difficult.  */\n+\n+#if defined(__MACH__)\n+#if defined(__LP64__)\n+#define BACKTRACE_BITS 64\n+#else\n+#define BACKTRACE_BITS 32\n+#endif\n+#else\n+#error Attempting to build Mach-O support on incorrect platform\n+#endif\n+\n+#if defined(__x86_64__)\n+#define NATIVE_CPU_TYPE CPU_TYPE_X86_64\n+#elif defined(__i386__)\n+#define NATIVE_CPU_TYPE CPU_TYPE_X86\n+#elif defined(__aarch64__)\n+#define NATIVE_CPU_TYPE CPU_TYPE_ARM64\n+#elif defined(__arm__)\n+#define NATIVE_CPU_TYPE CPU_TYPE_ARM\n+#else\n+#error Could not detect native Mach-O cpu_type_t\n+#endif\n+\n+#include <sys/types.h>\n+#include <sys/syslimits.h>\n+#include <string.h>\n+#include <mach-o/loader.h>\n+#include <mach-o/nlist.h>\n+#include <mach-o/fat.h>\n+#include <mach-o/dyld.h>\n+#include <uuid/uuid.h>\n+#include <dirent.h>\n+#include <stdlib.h>\n+\n+#include \"backtrace.h\"\n+#include \"internal.h\"\n+\n+struct macho_commands_view\n+{\n+    struct backtrace_view view;\n+    uint32_t commands_count;\n+    uint32_t commands_total_size;\n+    int bytes_swapped;\n+    size_t base_offset;\n+};\n+\n+enum debug_section\n+{\n+    DEBUG_INFO,\n+    DEBUG_LINE,\n+    DEBUG_ABBREV,\n+    DEBUG_RANGES,\n+    DEBUG_STR,\n+    DEBUG_MAX\n+};\n+\n+static const char *const debug_section_names[DEBUG_MAX] =\n+    {\n+        \"__debug_info\",\n+        \"__debug_line\",\n+        \"__debug_abbrev\",\n+        \"__debug_ranges\",\n+        \"__debug_str\"\n+    };\n+\n+struct found_dwarf_section\n+{\n+    uint32_t file_offset;\n+    uintptr_t file_size;\n+    const unsigned char *data;\n+};\n+\n+/* Mach-O symbols don't have a length. As a result we have to infer it\n+   by sorting the symbol addresses for each image and recording the\n+   memory range attributed to each image.  */\n+struct macho_symbol\n+{\n+    uintptr_t addr;\n+    size_t size;\n+    const char *name;\n+};\n+\n+struct macho_syminfo_data\n+{\n+    struct macho_syminfo_data *next;\n+    struct macho_symbol *symbols;\n+    size_t symbol_count;\n+    uintptr_t min_addr;\n+    uintptr_t max_addr;\n+};\n+\n+uint16_t\n+macho_file_to_host_u16 (int file_bytes_swapped, uint16_t input)\n+{\n+  if (file_bytes_swapped)\n+    return (input >> 8) | (input << 8);\n+  else\n+    return input;\n+}\n+\n+uint32_t\n+macho_file_to_host_u32 (int file_bytes_swapped, uint32_t input)\n+{\n+  if (file_bytes_swapped)\n+    {\n+      return ((input >> 24) & 0x000000FF)\n+             | ((input >> 8) & 0x0000FF00)\n+             | ((input << 8) & 0x00FF0000)\n+             | ((input << 24) & 0xFF000000);\n+    }\n+  else\n+    {\n+      return input;\n+    }\n+}\n+\n+uint64_t\n+macho_file_to_host_u64 (int file_bytes_swapped, uint64_t input)\n+{\n+  if (file_bytes_swapped)\n+    {\n+      return macho_file_to_host_u32 (file_bytes_swapped,\n+                                     (uint32_t) (input >> 32))\n+             | (((uint64_t) macho_file_to_host_u32 (file_bytes_swapped,\n+                                                    (uint32_t) input)) << 32);\n+    }\n+  else\n+    {\n+      return input;\n+    }\n+}\n+\n+#if BACKTRACE_BITS == 64\n+#define macho_file_to_host_usize macho_file_to_host_u64\n+typedef struct mach_header_64 mach_header_native_t;\n+#define LC_SEGMENT_NATIVE LC_SEGMENT_64\n+typedef struct segment_command_64 segment_command_native_t;\n+typedef struct nlist_64 nlist_native_t;\n+typedef struct section_64 section_native_t;\n+#else /* BACKTRACE_BITS == 32 */\n+#define macho_file_to_host_usize macho_file_to_host_u32\n+typedef struct mach_header mach_header_native_t;\n+#define LC_SEGMENT_NATIVE LC_SEGMENT\n+typedef struct segment_command segment_command_native_t;\n+typedef struct nlist nlist_native_t;\n+typedef struct section section_native_t;\n+#endif\n+\n+// Gets a view into a Mach-O image, taking any slice offset into account\n+int\n+macho_get_view (struct backtrace_state *state, int descriptor,\n+                off_t offset, size_t size,\n+                backtrace_error_callback error_callback,\n+                void *data, struct macho_commands_view *commands_view,\n+                struct backtrace_view *view)\n+{\n+  return backtrace_get_view (state, descriptor,\n+                             commands_view->base_offset + offset, size,\n+                             error_callback, data, view);\n+}\n+\n+int\n+macho_get_commands (struct backtrace_state *state, int descriptor,\n+                    backtrace_error_callback error_callback,\n+                    void *data, struct macho_commands_view *commands_view,\n+                    int *incompatible)\n+{\n+  int ret = 0;\n+  int is_fat = 0;\n+  struct backtrace_view file_header_view;\n+  int file_header_view_valid = 0;\n+  struct backtrace_view fat_archs_view;\n+  int fat_archs_view_valid = 0;\n+  const mach_header_native_t *file_header;\n+  uint64_t commands_offset;\n+\n+  *incompatible = 0;\n+\n+  if (!backtrace_get_view (state, descriptor, 0, sizeof (mach_header_native_t),\n+                           error_callback, data, &file_header_view))\n+    goto end;\n+  file_header_view_valid = 1;\n+\n+  switch (*(uint32_t *) file_header_view.data)\n+    {\n+      case MH_MAGIC:\n+        if (BACKTRACE_BITS == 32)\n+          commands_view->bytes_swapped = 0;\n+        else\n+          {\n+            *incompatible = 1;\n+            goto end;\n+          }\n+      break;\n+      case MH_CIGAM:\n+        if (BACKTRACE_BITS == 32)\n+          commands_view->bytes_swapped = 1;\n+        else\n+          {\n+            *incompatible = 1;\n+            goto end;\n+          }\n+      break;\n+      case MH_MAGIC_64:\n+        if (BACKTRACE_BITS == 64)\n+          commands_view->bytes_swapped = 0;\n+        else\n+          {\n+            *incompatible = 1;\n+            goto end;\n+          }\n+      break;\n+      case MH_CIGAM_64:\n+        if (BACKTRACE_BITS == 64)\n+          commands_view->bytes_swapped = 1;\n+        else\n+          {\n+            *incompatible = 1;\n+            goto end;\n+          }\n+      break;\n+      case FAT_MAGIC:\n+        is_fat = 1;\n+        commands_view->bytes_swapped = 0;\n+      break;\n+      case FAT_CIGAM:\n+        is_fat = 1;\n+        commands_view->bytes_swapped = 1;\n+      break;\n+      default:\n+        goto end;\n+    }\n+\n+  if (is_fat)\n+    {\n+      uint32_t native_slice_offset;\n+      size_t archs_total_size;\n+      uint32_t arch_count;\n+      const struct fat_header *fat_header;\n+      const struct fat_arch *archs;\n+      uint32_t i;\n+\n+      fat_header = file_header_view.data;\n+      arch_count =\n+          macho_file_to_host_u32 (commands_view->bytes_swapped,\n+                                  fat_header->nfat_arch);\n+\n+      archs_total_size = arch_count * sizeof (struct fat_arch);\n+\n+      if (!backtrace_get_view (state, descriptor, sizeof (fat_header),\n+                               archs_total_size, error_callback,\n+                               data, &fat_archs_view))\n+        goto end;\n+      fat_archs_view_valid = 1;\n+\n+      native_slice_offset = 0;\n+      archs = fat_archs_view.data;\n+      for (i = 0; i < arch_count; i++)\n+        {\n+          const struct fat_arch *raw_arch = archs + i;\n+          int cpu_type =\n+              (int) macho_file_to_host_u32 (commands_view->bytes_swapped,\n+                                            (uint32_t) raw_arch->cputype);\n+\n+          if (cpu_type == NATIVE_CPU_TYPE)\n+            {\n+              native_slice_offset =\n+                  macho_file_to_host_u32 (commands_view->bytes_swapped,\n+                                          raw_arch->offset);\n+\n+              break;\n+            }\n+        }\n+\n+      if (native_slice_offset == 0)\n+        {\n+          *incompatible = 1;\n+          goto end;\n+        }\n+\n+      backtrace_release_view (state, &file_header_view, error_callback, data);\n+      file_header_view_valid = 0;\n+      if (!backtrace_get_view (state, descriptor, native_slice_offset,\n+                               sizeof (mach_header_native_t), error_callback,\n+                               data, &file_header_view))\n+        goto end;\n+      file_header_view_valid = 1;\n+\n+      // The endianess of the slice may be different than the fat image\n+      switch (*(uint32_t *) file_header_view.data)\n+        {\n+          case MH_MAGIC:\n+            if (BACKTRACE_BITS == 32)\n+              commands_view->bytes_swapped = 0;\n+            else\n+              goto end;\n+          break;\n+          case MH_CIGAM:\n+            if (BACKTRACE_BITS == 32)\n+              commands_view->bytes_swapped = 1;\n+            else\n+              goto end;\n+          break;\n+          case MH_MAGIC_64:\n+            if (BACKTRACE_BITS == 64)\n+              commands_view->bytes_swapped = 0;\n+            else\n+              goto end;\n+          break;\n+          case MH_CIGAM_64:\n+            if (BACKTRACE_BITS == 64)\n+              commands_view->bytes_swapped = 1;\n+            else\n+              goto end;\n+          break;\n+          default:\n+            goto end;\n+        }\n+\n+      commands_view->base_offset = native_slice_offset;\n+    }\n+  else\n+    commands_view->base_offset = 0;\n+\n+  file_header = file_header_view.data;\n+  commands_view->commands_count =\n+      macho_file_to_host_u32 (commands_view->bytes_swapped,\n+                              file_header->ncmds);\n+  commands_view->commands_total_size =\n+      macho_file_to_host_u32 (commands_view->bytes_swapped,\n+                              file_header->sizeofcmds);\n+  commands_offset =\n+      commands_view->base_offset + sizeof (mach_header_native_t);\n+\n+  if (!backtrace_get_view (state, descriptor, commands_offset,\n+                           commands_view->commands_total_size, error_callback,\n+                           data, &commands_view->view))\n+    goto end;\n+\n+  ret = 1;\n+\n+end:\n+  if (file_header_view_valid)\n+    backtrace_release_view (state, &file_header_view, error_callback, data);\n+  if (fat_archs_view_valid)\n+    backtrace_release_view (state, &fat_archs_view, error_callback, data);\n+  return ret;\n+}\n+\n+int\n+macho_get_uuid (struct backtrace_state *state ATTRIBUTE_UNUSED,\n+                int descriptor ATTRIBUTE_UNUSED,\n+                backtrace_error_callback error_callback,\n+                void *data, struct macho_commands_view *commands_view,\n+                uuid_t *uuid)\n+{\n+  size_t offset = 0;\n+  uint32_t i = 0;\n+\n+  for (i = 0; i < commands_view->commands_count; i++)\n+    {\n+      const struct load_command *raw_command;\n+      struct load_command command;\n+\n+      if (offset + sizeof (struct load_command)\n+          > commands_view->commands_total_size)\n+        {\n+          error_callback (data,\n+                          \"executable file contains out of range command offset\",\n+                          0);\n+          return 0;\n+        }\n+\n+      raw_command =\n+          commands_view->view.data + offset;\n+      command.cmd = macho_file_to_host_u32 (commands_view->bytes_swapped,\n+                                            raw_command->cmd);\n+      command.cmdsize = macho_file_to_host_u32 (commands_view->bytes_swapped,\n+                                                raw_command->cmdsize);\n+\n+      if (command.cmd == LC_UUID)\n+        {\n+          const struct uuid_command *uuid_command;\n+\n+          if (offset + sizeof (struct uuid_command)\n+              > commands_view->commands_total_size)\n+            {\n+              error_callback (data,\n+                              \"executable file contains out of range command offset\",\n+                              0);\n+              return 0;\n+            }\n+\n+          uuid_command =\n+              (struct uuid_command *) raw_command;\n+          memcpy (uuid, uuid_command->uuid, sizeof (uuid_t));\n+          return 1;\n+        }\n+\n+      offset += command.cmdsize;\n+    }\n+\n+  error_callback (data, \"executable file is missing an identifying UUID\", 0);\n+  return 0;\n+}\n+\n+/* Returns the base address of a Mach-O image, as encoded in the file header.\n+ * WARNING: This does not take ASLR into account, which is ubiquitous on recent\n+ * Darwin platforms.\n+ */\n+int\n+macho_get_addr_range (struct backtrace_state *state ATTRIBUTE_UNUSED,\n+                      int descriptor ATTRIBUTE_UNUSED,\n+                      backtrace_error_callback error_callback,\n+                      void *data, struct macho_commands_view *commands_view,\n+                      uintptr_t *base_address, uintptr_t *max_address)\n+{\n+  size_t offset = 0;\n+  int found_text = 0;\n+  uint32_t i = 0;\n+\n+  *max_address = 0;\n+\n+  for (i = 0; i < commands_view->commands_count; i++)\n+    {\n+      const struct load_command *raw_command;\n+      struct load_command command;\n+\n+      if (offset + sizeof (struct load_command)\n+          > commands_view->commands_total_size)\n+        {\n+          error_callback (data,\n+                          \"executable file contains out of range command offset\",\n+                          0);\n+          return 0;\n+        }\n+\n+      raw_command = commands_view->view.data + offset;\n+      command.cmd = macho_file_to_host_u32 (commands_view->bytes_swapped,\n+                                            raw_command->cmd);\n+      command.cmdsize = macho_file_to_host_u32 (commands_view->bytes_swapped,\n+                                                raw_command->cmdsize);\n+\n+      if (command.cmd == LC_SEGMENT_NATIVE)\n+        {\n+          const segment_command_native_t *raw_segment;\n+          uintptr_t segment_vmaddr;\n+          uintptr_t segment_vmsize;\n+          uintptr_t segment_maxaddr;\n+          uintptr_t text_fileoff;\n+\n+          if (offset + sizeof (segment_command_native_t)\n+              > commands_view->commands_total_size)\n+            {\n+              error_callback (data,\n+                              \"executable file contains out of range command offset\",\n+                              0);\n+              return 0;\n+            }\n+\n+          raw_segment = (segment_command_native_t *) raw_command;\n+\n+          segment_vmaddr = macho_file_to_host_usize (\n+              commands_view->bytes_swapped, raw_segment->vmaddr);\n+          segment_vmsize = macho_file_to_host_usize (\n+              commands_view->bytes_swapped, raw_segment->vmsize);\n+          segment_maxaddr = segment_vmaddr + segment_vmsize;\n+\n+          if (strncmp (raw_segment->segname, \"__TEXT\",\n+                       sizeof (raw_segment->segname)) == 0)\n+            {\n+              text_fileoff = macho_file_to_host_usize (\n+                  commands_view->bytes_swapped, raw_segment->fileoff);\n+              *base_address = segment_vmaddr - text_fileoff;\n+\n+              found_text = 1;\n+            }\n+\n+          if (segment_maxaddr > *max_address)\n+            *max_address = segment_maxaddr;\n+        }\n+\n+      offset += command.cmdsize;\n+    }\n+\n+  if (found_text)\n+    return 1;\n+  else\n+    {\n+      error_callback (data, \"executable is missing __TEXT segment\", 0);\n+      return 0;\n+    }\n+}\n+\n+static int\n+macho_symbol_compare_addr (const void *left_raw, const void *right_raw)\n+{\n+  const struct macho_symbol *left = left_raw;\n+  const struct macho_symbol *right = right_raw;\n+\n+  if (left->addr > right->addr)\n+    return 1;\n+  else if (left->addr < right->addr)\n+    return -1;\n+  else\n+    return 0;\n+}\n+\n+int\n+macho_symbol_type_relevant (uint8_t type)\n+{\n+  uint8_t type_field = (uint8_t) (type & N_TYPE);\n+\n+  return !(type & N_EXT) &&\n+         (type_field == N_ABS || type_field == N_SECT);\n+}\n+\n+int\n+macho_add_symtab (struct backtrace_state *state,\n+                  backtrace_error_callback error_callback,\n+                  void *data, int descriptor,\n+                  struct macho_commands_view *commands_view,\n+                  uintptr_t base_address, uintptr_t max_image_address,\n+                  intptr_t vmslide, int *found_sym)\n+{\n+  struct macho_syminfo_data *syminfo_data;\n+\n+  int ret = 0;\n+  size_t offset = 0;\n+  struct backtrace_view symtab_view;\n+  int symtab_view_valid = 0;\n+  struct backtrace_view strtab_view;\n+  int strtab_view_valid = 0;\n+  size_t syminfo_index = 0;\n+  size_t function_count = 0;\n+  uint32_t i = 0;\n+  uint32_t j = 0;\n+  uint32_t symtab_index = 0;\n+\n+  *found_sym = 0;\n+\n+  for (i = 0; i < commands_view->commands_count; i++)\n+    {\n+      const struct load_command *raw_command;\n+      struct load_command command;\n+\n+      if (offset + sizeof (struct load_command)\n+          > commands_view->commands_total_size)\n+        {\n+          error_callback (data,\n+                          \"executable file contains out of range command offset\",\n+                          0);\n+          return 0;\n+        }\n+\n+      raw_command = commands_view->view.data + offset;\n+      command.cmd = macho_file_to_host_u32 (commands_view->bytes_swapped,\n+                                            raw_command->cmd);\n+      command.cmdsize = macho_file_to_host_u32 (commands_view->bytes_swapped,\n+                                                raw_command->cmdsize);\n+\n+      if (command.cmd == LC_SYMTAB)\n+        {\n+          const struct symtab_command *symtab_command;\n+          uint32_t symbol_table_offset;\n+          uint32_t symbol_count;\n+          uint32_t string_table_offset;\n+          uint32_t string_table_size;\n+\n+          if (offset + sizeof (struct symtab_command)\n+              > commands_view->commands_total_size)\n+            {\n+              error_callback (data,\n+                              \"executable file contains out of range command offset\",\n+                              0);\n+              return 0;\n+            }\n+\n+          symtab_command = (struct symtab_command *) raw_command;\n+\n+          symbol_table_offset = macho_file_to_host_u32 (\n+              commands_view->bytes_swapped, symtab_command->symoff);\n+          symbol_count = macho_file_to_host_u32 (\n+              commands_view->bytes_swapped, symtab_command->nsyms);\n+          string_table_offset = macho_file_to_host_u32 (\n+              commands_view->bytes_swapped, symtab_command->stroff);\n+          string_table_size = macho_file_to_host_u32 (\n+              commands_view->bytes_swapped, symtab_command->strsize);\n+\n+\n+          if (!macho_get_view (state, descriptor, symbol_table_offset,\n+                               symbol_count * sizeof (nlist_native_t),\n+                               error_callback, data, commands_view,\n+                               &symtab_view))\n+            goto end;\n+          symtab_view_valid = 1;\n+\n+          if (!macho_get_view (state, descriptor, string_table_offset,\n+                               string_table_size, error_callback, data,\n+                               commands_view, &strtab_view))\n+            goto end;\n+          strtab_view_valid = 1;\n+\n+          // Count functions first\n+          for (j = 0; j < symbol_count; j++)\n+            {\n+              const nlist_native_t *raw_sym =\n+                  ((const nlist_native_t *) symtab_view.data) + j;\n+\n+              if (macho_symbol_type_relevant (raw_sym->n_type))\n+                {\n+                  function_count += 1;\n+                }\n+            }\n+\n+          // Allocate space for the:\n+          //  (a) macho_syminfo_data for this image\n+          //  (b) macho_symbol entries\n+          syminfo_data =\n+              backtrace_alloc (state,\n+                               sizeof (struct macho_syminfo_data),\n+                               error_callback, data);\n+          if (syminfo_data == NULL)\n+            goto end;\n+\n+          syminfo_data->symbols = backtrace_alloc (\n+              state, function_count * sizeof (struct macho_symbol),\n+              error_callback, data);\n+          if (syminfo_data->symbols == NULL)\n+            goto end;\n+\n+          syminfo_data->symbol_count = function_count;\n+          syminfo_data->next = NULL;\n+          syminfo_data->min_addr = base_address;\n+          syminfo_data->max_addr = max_image_address;\n+\n+          for (symtab_index = 0;\n+               symtab_index < symbol_count; symtab_index++)\n+            {\n+              const nlist_native_t *raw_sym =\n+                  ((const nlist_native_t *) symtab_view.data) +\n+                  symtab_index;\n+\n+              if (macho_symbol_type_relevant (raw_sym->n_type))\n+                {\n+                  size_t strtab_index;\n+                  const char *name;\n+                  size_t max_len_plus_one;\n+\n+                  syminfo_data->symbols[syminfo_index].addr =\n+                      macho_file_to_host_usize (commands_view->bytes_swapped,\n+                                                raw_sym->n_value) + vmslide;\n+\n+                  strtab_index = macho_file_to_host_u32 (\n+                      commands_view->bytes_swapped,\n+                      raw_sym->n_un.n_strx);\n+\n+                  // Check the range of the supposed \"string\" we've been\n+                  // given\n+                  if (strtab_index >= string_table_size)\n+                    {\n+                      error_callback (\n+                          data,\n+                          \"dSYM file contains out of range string table index\",\n+                          0);\n+                      goto end;\n+                    }\n+\n+                  name = strtab_view.data + strtab_index;\n+                  max_len_plus_one = string_table_size - strtab_index;\n+\n+                  if (strnlen (name, max_len_plus_one) >= max_len_plus_one)\n+                    {\n+                      error_callback (\n+                          data,\n+                          \"dSYM file contains unterminated string\",\n+                          0);\n+                      goto end;\n+                    }\n+\n+                  // Remove underscore prefixes\n+                  if (name[0] == '_')\n+                    {\n+                      name = name + 1;\n+                    }\n+\n+                  syminfo_data->symbols[syminfo_index].name = name;\n+\n+                  syminfo_index += 1;\n+                }\n+            }\n+\n+          backtrace_qsort (syminfo_data->symbols,\n+                           syminfo_data->symbol_count,\n+                           sizeof (struct macho_symbol),\n+                           macho_symbol_compare_addr);\n+\n+          // Calculate symbol sizes\n+          for (syminfo_index = 0;\n+               syminfo_index < syminfo_data->symbol_count; syminfo_index++)\n+            {\n+              if (syminfo_index + 1 < syminfo_data->symbol_count)\n+                {\n+                  syminfo_data->symbols[syminfo_index].size =\n+                      syminfo_data->symbols[syminfo_index + 1].addr -\n+                      syminfo_data->symbols[syminfo_index].addr;\n+                }\n+              else\n+                {\n+                  syminfo_data->symbols[syminfo_index].size =\n+                      max_image_address -\n+                      syminfo_data->symbols[syminfo_index].addr;\n+                }\n+            }\n+\n+          if (!state->threaded)\n+            {\n+              struct macho_syminfo_data **pp;\n+\n+              for (pp = (struct macho_syminfo_data **) (void *) &state->syminfo_data;\n+                   *pp != NULL;\n+                   pp = &(*pp)->next);\n+              *pp = syminfo_data;\n+            }\n+          else\n+            {\n+              while (1)\n+                {\n+                  struct macho_syminfo_data **pp;\n+\n+                  pp = (struct macho_syminfo_data **) (void *) &state->syminfo_data;\n+\n+                  while (1)\n+                    {\n+                      struct macho_syminfo_data *p;\n+\n+                      p = backtrace_atomic_load_pointer (pp);\n+\n+                      if (p == NULL)\n+                        break;\n+\n+                      pp = &p->next;\n+                    }\n+\n+                  if (__sync_bool_compare_and_swap (pp, NULL, syminfo_data))\n+                    break;\n+                }\n+            }\n+\n+          strtab_view_valid = 0; // We need to keep string table around\n+          *found_sym = 1;\n+          ret = 1;\n+          goto end;\n+        }\n+\n+      offset += command.cmdsize;\n+    }\n+\n+  // No symbol table here\n+  ret = 1;\n+  goto end;\n+\n+end:\n+  if (symtab_view_valid)\n+    backtrace_release_view (state, &symtab_view, error_callback, data);\n+  if (strtab_view_valid)\n+    backtrace_release_view (state, &strtab_view, error_callback, data);\n+  return ret;\n+}\n+\n+int\n+macho_try_dwarf (struct backtrace_state *state,\n+                 backtrace_error_callback error_callback,\n+                 void *data, fileline *fileline_fn, uuid_t *executable_uuid,\n+                 uintptr_t base_address, uintptr_t max_image_address,\n+                 intptr_t vmslide, char *dwarf_filename, int *matched,\n+                 int *found_sym, int *found_dwarf)\n+{\n+  uuid_t dwarf_uuid;\n+\n+  int ret = 0;\n+  int dwarf_descriptor;\n+  int dwarf_descriptor_valid = 0;\n+  struct macho_commands_view commands_view;\n+  int commands_view_valid = 0;\n+  struct backtrace_view dwarf_view;\n+  int dwarf_view_valid = 0;\n+  size_t offset = 0;\n+  struct found_dwarf_section dwarf_sections[DEBUG_MAX];\n+  uintptr_t min_dwarf_offset = 0;\n+  uintptr_t max_dwarf_offset = 0;\n+  uint32_t i = 0;\n+  uint32_t j = 0;\n+  int k = 0;\n+\n+  *matched = 0;\n+  *found_sym = 0;\n+  *found_dwarf = 0;\n+\n+  if ((dwarf_descriptor = backtrace_open (dwarf_filename, error_callback,\n+                                          data, NULL)) == 0)\n+    goto end;\n+  dwarf_descriptor_valid = 1;\n+\n+  int incompatible;\n+  if (!macho_get_commands (state, dwarf_descriptor, error_callback, data,\n+                           &commands_view, &incompatible))\n+    {\n+      // Failing to read the header here is fine, because this dSYM may be\n+      // for a different architecture\n+      if (incompatible)\n+        {\n+          ret = 1;\n+        }\n+      goto end;\n+    }\n+  commands_view_valid = 1;\n+\n+  // Get dSYM UUID and compare\n+  if (!macho_get_uuid (state, dwarf_descriptor, error_callback, data,\n+                       &commands_view, &dwarf_uuid))\n+    {\n+      error_callback (data, \"dSYM file is missing an identifying uuid\", 0);\n+      goto end;\n+    }\n+  if (memcmp (executable_uuid, &dwarf_uuid, sizeof (uuid_t)) != 0)\n+    {\n+      // DWARF doesn't belong to desired executable\n+      ret = 1;\n+      goto end;\n+    }\n+\n+  *matched = 1;\n+\n+  // Read symbol table\n+  if (!macho_add_symtab (state, error_callback, data, dwarf_descriptor,\n+                         &commands_view, base_address, max_image_address,\n+                         vmslide, found_sym))\n+    goto end;\n+\n+  // Get DWARF sections\n+\n+  memset (dwarf_sections, 0, sizeof (dwarf_sections));\n+  offset = 0;\n+  for (i = 0; i < commands_view.commands_count; i++)\n+    {\n+      const struct load_command *raw_command;\n+      struct load_command command;\n+\n+      if (offset + sizeof (struct load_command)\n+          > commands_view.commands_total_size)\n+        {\n+          error_callback (data,\n+                          \"dSYM file contains out of range command offset\", 0);\n+          goto end;\n+        }\n+\n+      raw_command = commands_view.view.data + offset;\n+      command.cmd = macho_file_to_host_u32 (commands_view.bytes_swapped,\n+                                            raw_command->cmd);\n+      command.cmdsize = macho_file_to_host_u32 (commands_view.bytes_swapped,\n+                                                raw_command->cmdsize);\n+\n+      if (command.cmd == LC_SEGMENT_NATIVE)\n+        {\n+          uint32_t section_count;\n+          size_t section_offset;\n+          const segment_command_native_t *raw_segment;\n+\n+          if (offset + sizeof (segment_command_native_t)\n+              > commands_view.commands_total_size)\n+            {\n+              error_callback (data,\n+                              \"dSYM file contains out of range command offset\",\n+                              0);\n+              goto end;\n+            }\n+\n+          raw_segment = (const segment_command_native_t *) raw_command;\n+\n+          if (strncmp (raw_segment->segname, \"__DWARF\",\n+                       sizeof (raw_segment->segname)) == 0)\n+            {\n+              section_count = macho_file_to_host_u32 (\n+                  commands_view.bytes_swapped,\n+                  raw_segment->nsects);\n+\n+              section_offset = offset + sizeof (segment_command_native_t);\n+\n+              // Search sections for relevant DWARF section names\n+              for (j = 0; j < section_count; j++)\n+                {\n+                  const section_native_t *raw_section;\n+\n+                  if (section_offset + sizeof (section_native_t) >\n+                      commands_view.commands_total_size)\n+                    {\n+                      error_callback (data,\n+                                      \"dSYM file contains out of range command offset\",\n+                                      0);\n+                      goto end;\n+                    }\n+\n+                  raw_section = commands_view.view.data + section_offset;\n+\n+                  for (k = 0; k < DEBUG_MAX; k++)\n+                    {\n+                      uintptr_t dwarf_section_end;\n+\n+                      if (strncmp (raw_section->sectname,\n+                                   debug_section_names[k],\n+                                   sizeof (raw_section->sectname)) == 0)\n+                        {\n+                          *found_dwarf = 1;\n+\n+                          dwarf_sections[k].file_offset =\n+                              macho_file_to_host_u32 (\n+                                  commands_view.bytes_swapped,\n+                                  raw_section->offset);\n+                          dwarf_sections[k].file_size =\n+                              macho_file_to_host_usize (\n+                                  commands_view.bytes_swapped,\n+                                  raw_section->size);\n+\n+                          if (min_dwarf_offset == 0 ||\n+                              dwarf_sections[k].file_offset <\n+                              min_dwarf_offset)\n+                            min_dwarf_offset = dwarf_sections[k].file_offset;\n+\n+                          dwarf_section_end =\n+                              dwarf_sections[k].file_offset +\n+                              dwarf_sections[k].file_size;\n+                          if (dwarf_section_end > max_dwarf_offset)\n+                            max_dwarf_offset = dwarf_section_end;\n+\n+                          break;\n+                        }\n+                    }\n+\n+                  section_offset += sizeof (section_native_t);\n+                }\n+\n+              break;\n+            }\n+        }\n+\n+      offset += command.cmdsize;\n+    }\n+\n+  if (!*found_dwarf)\n+    {\n+      // No DWARF in this file\n+      ret = 1;\n+      goto end;\n+    }\n+\n+  if (!macho_get_view (state, dwarf_descriptor, (off_t) min_dwarf_offset,\n+                       max_dwarf_offset - min_dwarf_offset, error_callback,\n+                       data, &commands_view, &dwarf_view))\n+    goto end;\n+  dwarf_view_valid = 1;\n+\n+  for (i = 0; i < DEBUG_MAX; i++)\n+    {\n+      if (dwarf_sections[i].file_offset == 0)\n+        dwarf_sections[i].data = NULL;\n+      else\n+        dwarf_sections[i].data =\n+            dwarf_view.data + dwarf_sections[i].file_offset - min_dwarf_offset;\n+    }\n+\n+  if (!backtrace_dwarf_add (state, vmslide,\n+                            dwarf_sections[DEBUG_INFO].data,\n+                            dwarf_sections[DEBUG_INFO].file_size,\n+                            dwarf_sections[DEBUG_LINE].data,\n+                            dwarf_sections[DEBUG_LINE].file_size,\n+                            dwarf_sections[DEBUG_ABBREV].data,\n+                            dwarf_sections[DEBUG_ABBREV].file_size,\n+                            dwarf_sections[DEBUG_RANGES].data,\n+                            dwarf_sections[DEBUG_RANGES].file_size,\n+                            dwarf_sections[DEBUG_STR].data,\n+                            dwarf_sections[DEBUG_STR].file_size,\n+                            ((__DARWIN_BYTE_ORDER == __DARWIN_BIG_ENDIAN)\n+                            ^ commands_view.bytes_swapped),\n+                            error_callback, data, fileline_fn))\n+    goto end;\n+\n+  // Don't release the DWARF view because it is still in use\n+  dwarf_descriptor_valid = 0;\n+  dwarf_view_valid = 0;\n+  ret = 1;\n+\n+end:\n+  if (dwarf_descriptor_valid)\n+    backtrace_close (dwarf_descriptor, error_callback, data);\n+  if (commands_view_valid)\n+    backtrace_release_view (state, &commands_view.view, error_callback, data);\n+  if (dwarf_view_valid)\n+    backtrace_release_view (state, &dwarf_view, error_callback, data);\n+  return ret;\n+}\n+\n+int\n+macho_try_dsym (struct backtrace_state *state,\n+                backtrace_error_callback error_callback,\n+                void *data, fileline *fileline_fn, uuid_t *executable_uuid,\n+                uintptr_t base_address, uintptr_t max_image_address,\n+                intptr_t vmslide, char *dsym_filename, int *matched,\n+                int *found_sym, int *found_dwarf)\n+{\n+  int ret = 0;\n+  char dwarf_image_dir_path[PATH_MAX];\n+  DIR *dwarf_image_dir;\n+  int dwarf_image_dir_valid = 0;\n+  struct dirent *directory_entry;\n+  char dwarf_filename[PATH_MAX];\n+  int dwarf_matched;\n+  int dwarf_had_sym;\n+  int dwarf_had_dwarf;\n+\n+  *matched = 0;\n+  *found_sym = 0;\n+  *found_dwarf = 0;\n+\n+  strncpy (dwarf_image_dir_path, dsym_filename, PATH_MAX);\n+  strncat (dwarf_image_dir_path, \"/Contents/Resources/DWARF\", PATH_MAX);\n+\n+  if (!(dwarf_image_dir = opendir (dwarf_image_dir_path)))\n+    {\n+      error_callback (data, \"could not open DWARF directory in dSYM\",\n+                      0);\n+      goto end;\n+    }\n+  dwarf_image_dir_valid = 1;\n+\n+  while ((directory_entry = readdir (dwarf_image_dir)))\n+    {\n+      if (directory_entry->d_type != DT_REG)\n+        continue;\n+\n+      strncpy (dwarf_filename, dwarf_image_dir_path, PATH_MAX);\n+      strncat (dwarf_filename, \"/\", PATH_MAX);\n+      strncat (dwarf_filename, directory_entry->d_name, PATH_MAX);\n+\n+      if (!macho_try_dwarf (state, error_callback, data, fileline_fn,\n+                            executable_uuid, base_address, max_image_address,\n+                            vmslide, dwarf_filename,\n+                            &dwarf_matched, &dwarf_had_sym, &dwarf_had_dwarf))\n+        goto end;\n+\n+      if (dwarf_matched)\n+        {\n+          *matched = 1;\n+          *found_sym = dwarf_had_sym;\n+          *found_dwarf = dwarf_had_dwarf;\n+          ret = 1;\n+          goto end;\n+        }\n+    }\n+\n+  // No matching DWARF in this dSYM\n+  ret = 1;\n+  goto end;\n+\n+end:\n+  if (dwarf_image_dir_valid)\n+    closedir (dwarf_image_dir);\n+  return ret;\n+}\n+\n+int\n+macho_add (struct backtrace_state *state,\n+           backtrace_error_callback error_callback, void *data, int descriptor,\n+           const char *filename, fileline *fileline_fn, intptr_t vmslide,\n+           int *found_sym, int *found_dwarf)\n+{\n+  uuid_t image_uuid;\n+  uintptr_t image_file_base_address;\n+  uintptr_t image_file_max_address;\n+  uintptr_t image_actual_base_address = 0;\n+  uintptr_t image_actual_max_address = 0;\n+\n+  int ret = 0;\n+  struct macho_commands_view commands_view;\n+  int commands_view_valid = 0;\n+  char executable_dirname[PATH_MAX];\n+  size_t filename_len;\n+  DIR *executable_dir = NULL;\n+  int executable_dir_valid = 0;\n+  struct dirent *directory_entry;\n+  char dsym_full_path[PATH_MAX];\n+  static const char *extension;\n+  size_t extension_len;\n+  ssize_t i;\n+\n+  *found_sym = 0;\n+  *found_dwarf = 0;\n+\n+  // Find Mach-O commands list\n+  int incompatible;\n+  if (!macho_get_commands (state, descriptor, error_callback, data,\n+                           &commands_view, &incompatible))\n+    goto end;\n+  commands_view_valid = 1;\n+\n+  // First we need to get the uuid of our file so we can hunt down the correct\n+  // dSYM\n+  if (!macho_get_uuid (state, descriptor, error_callback, data, &commands_view,\n+                       &image_uuid))\n+    goto end;\n+\n+  // Now we need to find the in memory base address. Step one is to find out\n+  // what the executable thinks the base address is\n+  if (!macho_get_addr_range (state, descriptor, error_callback, data,\n+                             &commands_view,\n+                             &image_file_base_address,\n+                             &image_file_max_address))\n+    goto end;\n+\n+  image_actual_base_address =\n+      image_file_base_address + vmslide;\n+  image_actual_max_address =\n+      image_file_max_address + vmslide;\n+\n+  if (image_actual_base_address == 0)\n+    {\n+      error_callback (data, \"executable file is not loaded\", 0);\n+      goto end;\n+    }\n+\n+  // Look for dSYM in our executable's directory\n+  strncpy (executable_dirname, filename, PATH_MAX);\n+  filename_len = strlen (executable_dirname);\n+  for (i = filename_len - 1; i >= 0; i--)\n+    {\n+      if (executable_dirname[i] == '/')\n+        {\n+          executable_dirname[i] = '\\0';\n+          break;\n+        }\n+      else if (i == 0)\n+        {\n+          executable_dirname[0] = '.';\n+          executable_dirname[1] = '\\0';\n+          break;\n+        }\n+    }\n+\n+  if (!(executable_dir = opendir (executable_dirname)))\n+    {\n+      error_callback (data, \"could not open directory containing executable\",\n+                      0);\n+      goto end;\n+    }\n+  executable_dir_valid = 1;\n+\n+  extension = \".dSYM\";\n+  extension_len = strlen (extension);\n+  while ((directory_entry = readdir (executable_dir)))\n+    {\n+      if (directory_entry->d_namlen < extension_len)\n+        continue;\n+      if (strncasecmp (directory_entry->d_name + directory_entry->d_namlen\n+                       - extension_len, extension, extension_len) == 0)\n+        {\n+          int matched;\n+          int dsym_had_sym;\n+          int dsym_had_dwarf;\n+\n+          // Found a dSYM\n+          strncpy (dsym_full_path, executable_dirname, PATH_MAX);\n+          strncat (dsym_full_path, \"/\", PATH_MAX);\n+          strncat (dsym_full_path, directory_entry->d_name, PATH_MAX);\n+\n+          if (!macho_try_dsym (state, error_callback, data,\n+                               fileline_fn, &image_uuid,\n+                               image_actual_base_address,\n+                               image_actual_max_address, vmslide,\n+                               dsym_full_path,\n+                               &matched, &dsym_had_sym, &dsym_had_dwarf))\n+            goto end;\n+\n+          if (matched)\n+            {\n+              *found_sym = dsym_had_sym;\n+              *found_dwarf = dsym_had_dwarf;\n+              ret = 1;\n+              goto end;\n+            }\n+        }\n+    }\n+\n+  // No matching dSYM\n+  ret = 1;\n+  goto end;\n+\n+end:\n+  if (commands_view_valid)\n+    backtrace_release_view (state, &commands_view.view, error_callback,\n+                            data);\n+  if (executable_dir_valid)\n+    closedir (executable_dir);\n+  return ret;\n+}\n+\n+static int\n+macho_symbol_search (const void *vkey, const void *ventry)\n+{\n+  const uintptr_t *key = (const uintptr_t *) vkey;\n+  const struct macho_symbol *entry = (const struct macho_symbol *) ventry;\n+  uintptr_t addr;\n+\n+  addr = *key;\n+  if (addr < entry->addr)\n+    return -1;\n+  else if (addr >= entry->addr + entry->size)\n+    return 1;\n+  else\n+    return 0;\n+}\n+\n+static void\n+macho_syminfo (struct backtrace_state *state,\n+               uintptr_t addr,\n+               backtrace_syminfo_callback callback,\n+               backtrace_error_callback error_callback ATTRIBUTE_UNUSED,\n+               void *data)\n+{\n+  struct macho_syminfo_data *edata;\n+  struct macho_symbol *sym = NULL;\n+\n+  if (!state->threaded)\n+    {\n+      for (edata = (struct macho_syminfo_data *) state->syminfo_data;\n+           edata != NULL;\n+           edata = edata->next)\n+        {\n+          if (addr >= edata->min_addr && addr <= edata->max_addr)\n+            {\n+              sym = ((struct macho_symbol *)\n+                  bsearch (&addr, edata->symbols, edata->symbol_count,\n+                           sizeof (struct macho_symbol), macho_symbol_search));\n+              if (sym != NULL)\n+                break;\n+            }\n+        }\n+    }\n+  else\n+    {\n+      struct macho_syminfo_data **pp;\n+\n+      pp = (struct macho_syminfo_data **) (void *) &state->syminfo_data;\n+      while (1)\n+        {\n+          edata = backtrace_atomic_load_pointer (pp);\n+          if (edata == NULL)\n+            break;\n+\n+          if (addr >= edata->min_addr && addr <= edata->max_addr)\n+            {\n+              sym = ((struct macho_symbol *)\n+                  bsearch (&addr, edata->symbols, edata->symbol_count,\n+                           sizeof (struct macho_symbol), macho_symbol_search));\n+              if (sym != NULL)\n+                break;\n+            }\n+\n+          pp = &edata->next;\n+        }\n+    }\n+\n+  if (sym == NULL)\n+    callback (data, addr, NULL, 0, 0);\n+  else\n+    callback (data, addr, sym->name, sym->addr, sym->size);\n+}\n+\n+\n+static int\n+macho_nodebug (struct backtrace_state *state ATTRIBUTE_UNUSED,\n+               uintptr_t pc ATTRIBUTE_UNUSED,\n+               backtrace_full_callback callback ATTRIBUTE_UNUSED,\n+               backtrace_error_callback error_callback, void *data)\n+{\n+  error_callback (data, \"no debug info in Mach-O executable\", -1);\n+  return 0;\n+}\n+\n+static void\n+macho_nosyms (struct backtrace_state *state ATTRIBUTE_UNUSED,\n+              uintptr_t addr ATTRIBUTE_UNUSED,\n+              backtrace_syminfo_callback callback ATTRIBUTE_UNUSED,\n+              backtrace_error_callback error_callback, void *data)\n+{\n+  error_callback (data, \"no symbol table in Mach-O executable\", -1);\n+}\n+\n+int\n+backtrace_initialize (struct backtrace_state *state, int descriptor,\n+                      backtrace_error_callback error_callback,\n+                      void *data, fileline *fileline_fn)\n+{\n+  int ret;\n+  fileline macho_fileline_fn = macho_nodebug;\n+  int found_sym = 0;\n+  int found_dwarf = 0;\n+  uint32_t i = 0;\n+  uint32_t loaded_image_count;\n+\n+  // Add all loaded images\n+  loaded_image_count = _dyld_image_count ();\n+  for (i = 0; i < loaded_image_count; i++)\n+    {\n+      int current_found_sym;\n+      int current_found_dwarf;\n+      int current_descriptor;\n+      intptr_t current_vmslide;\n+      const char *current_name;\n+\n+      current_vmslide = _dyld_get_image_vmaddr_slide (i);\n+      current_name = _dyld_get_image_name (i);\n+\n+      if (current_name == NULL)\n+        continue;\n+\n+      if (!(current_descriptor =\n+                backtrace_open (current_name, error_callback, data, NULL)))\n+        {\n+          continue;\n+        }\n+\n+      if (!macho_add (state, error_callback, data, current_descriptor,\n+                      current_name, &macho_fileline_fn, current_vmslide,\n+                      &current_found_sym, &current_found_dwarf))\n+        {\n+          return 0;\n+        }\n+\n+      backtrace_close (current_descriptor, error_callback, data);\n+      found_sym = found_sym || current_found_sym;\n+      found_dwarf = found_dwarf || current_found_dwarf;\n+    }\n+\n+  if (!state->threaded)\n+    {\n+      if (found_sym)\n+        state->syminfo_fn = macho_syminfo;\n+      else if (state->syminfo_fn == NULL)\n+        state->syminfo_fn = macho_nosyms;\n+    }\n+  else\n+    {\n+      if (found_sym)\n+        backtrace_atomic_store_pointer (&state->syminfo_fn, macho_syminfo);\n+      else\n+        (void) __sync_bool_compare_and_swap (&state->syminfo_fn, NULL,\n+                                             macho_nosyms);\n+    }\n+\n+  if (!state->threaded)\n+    {\n+      if (state->fileline_fn == NULL || state->fileline_fn == macho_nodebug)\n+        *fileline_fn = macho_fileline_fn;\n+    }\n+  else\n+    {\n+      fileline current_fn;\n+\n+      current_fn = backtrace_atomic_load_pointer (&state->fileline_fn);\n+      if (current_fn == NULL || current_fn == macho_nodebug)\n+        *fileline_fn = macho_fileline_fn;\n+    }\n+\n+  return 1;\n+}\n+"}, {"sha": "ebd0db2edd00c35e7012e89786fc51b2a3c95082", "filename": "src/libstd/build.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e8121b3d163f90a8f1cefca07352d3780eed933d/src%2Flibstd%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8121b3d163f90a8f1cefca07352d3780eed933d/src%2Flibstd%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbuild.rs?ref=e8121b3d163f90a8f1cefca07352d3780eed933d", "patch": "@@ -20,7 +20,7 @@ use build_helper::{run, native_lib_boilerplate};\n fn main() {\n     let target = env::var(\"TARGET\").expect(\"TARGET was not set\");\n     let host = env::var(\"HOST\").expect(\"HOST was not set\");\n-    if cfg!(feature = \"backtrace\") && !target.contains(\"apple\") && !target.contains(\"msvc\") &&\n+    if cfg!(feature = \"backtrace\") && !target.contains(\"msvc\") &&\n         !target.contains(\"emscripten\") && !target.contains(\"fuchsia\") {\n         let _ = build_libbacktrace(&host, &target);\n     }"}, {"sha": "5bb34fe60cc9a192250ee3f678becf01ad25038e", "filename": "src/libstd/sys/unix/backtrace/mod.rs", "status": "modified", "additions": 28, "deletions": 1, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/e8121b3d163f90a8f1cefca07352d3780eed933d/src%2Flibstd%2Fsys%2Funix%2Fbacktrace%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8121b3d163f90a8f1cefca07352d3780eed933d/src%2Flibstd%2Fsys%2Funix%2Fbacktrace%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fbacktrace%2Fmod.rs?ref=e8121b3d163f90a8f1cefca07352d3780eed933d", "patch": "@@ -91,15 +91,42 @@ mod tracing;\n // symbol resolvers:\n mod printing;\n \n-#[cfg(not(any(target_os = \"macos\", target_os = \"ios\", target_os = \"emscripten\")))]\n+#[cfg(not(target_os = \"emscripten\"))]\n pub mod gnu {\n     use io;\n     use fs;\n     use libc::c_char;\n \n+    #[cfg(not(any(target_os = \"macos\", target_os = \"ios\")))]\n     pub fn get_executable_filename() -> io::Result<(Vec<c_char>, fs::File)> {\n         Err(io::Error::new(io::ErrorKind::Other, \"Not implemented\"))\n     }\n+\n+    #[cfg(any(target_os = \"macos\", target_os = \"ios\"))]\n+    pub fn get_executable_filename() -> io::Result<(Vec<c_char>, fs::File)> {\n+        use ptr;\n+        use slice;\n+        use ffi::OsStr;\n+        use os::unix::ffi::OsStrExt;\n+        use libc::c_int;\n+\n+        extern {\n+            fn _NSGetExecutablePath(buf: *mut c_char,\n+                                    bufsize: *mut u32) -> c_int;\n+        }\n+        unsafe {\n+            let mut bufsize: u32 = 0;\n+            _NSGetExecutablePath(ptr::null_mut(), &mut bufsize);\n+            if bufsize == 0 { return Err(io::Error::last_os_error()); }\n+            let mut buffer: Vec<c_char> = Vec::with_capacity(bufsize as usize);\n+            let ret = _NSGetExecutablePath(buffer.as_mut_ptr(), &mut bufsize);\n+            if ret != 0 { return Err(io::Error::last_os_error()); }\n+            buffer.set_len(bufsize as usize);\n+            let file = fs::File::open(OsStr::from_bytes(\n+                    slice::from_raw_parts(buffer.as_ptr() as *const u8, buffer.len()-1)))?;\n+            Ok((buffer, file))\n+        }\n+    }\n }\n \n pub struct BacktraceContext;"}, {"sha": "857900e1e554d05264fb78eadbda01d7b90e0801", "filename": "src/libstd/sys/unix/backtrace/printing/mod.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e8121b3d163f90a8f1cefca07352d3780eed933d/src%2Flibstd%2Fsys%2Funix%2Fbacktrace%2Fprinting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8121b3d163f90a8f1cefca07352d3780eed933d/src%2Flibstd%2Fsys%2Funix%2Fbacktrace%2Fprinting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fbacktrace%2Fprinting%2Fmod.rs?ref=e8121b3d163f90a8f1cefca07352d3780eed933d", "patch": "@@ -10,13 +10,11 @@\n \n pub use self::imp::{foreach_symbol_fileline, resolve_symname};\n \n-#[cfg(any(target_os = \"macos\", target_os = \"ios\",\n-          target_os = \"emscripten\"))]\n+#[cfg(target_os = \"emscripten\")]\n #[path = \"dladdr.rs\"]\n mod imp;\n \n-#[cfg(not(any(target_os = \"macos\", target_os = \"ios\",\n-              target_os = \"emscripten\")))]\n+#[cfg(not(target_os = \"emscripten\"))]\n mod imp {\n     pub use sys_common::gnu::libbacktrace::{foreach_symbol_fileline, resolve_symname};\n }"}, {"sha": "30241819bd51201e0c71fbefda327a979705bcf2", "filename": "src/libstd/sys_common/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e8121b3d163f90a8f1cefca07352d3780eed933d/src%2Flibstd%2Fsys_common%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8121b3d163f90a8f1cefca07352d3780eed933d/src%2Flibstd%2Fsys_common%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fmod.rs?ref=e8121b3d163f90a8f1cefca07352d3780eed933d", "patch": "@@ -51,7 +51,7 @@ pub use sys::net;\n pub mod net;\n \n #[cfg(feature = \"backtrace\")]\n-#[cfg(any(all(unix, not(any(target_os = \"macos\", target_os = \"ios\", target_os = \"emscripten\"))),\n+#[cfg(any(all(unix, not(target_os = \"emscripten\")),\n           all(windows, target_env = \"gnu\"),\n           target_os = \"redox\"))]\n pub mod gnu;"}]}