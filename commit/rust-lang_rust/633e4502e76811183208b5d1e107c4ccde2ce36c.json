{"sha": "633e4502e76811183208b5d1e107c4ccde2ce36c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYzM2U0NTAyZTc2ODExMTgzMjA4YjVkMWUxMDdjNGNjZGUyY2UzNmM=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-02-03T12:37:55Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-02-03T13:09:16Z"}, "message": "Clean up and update trans::ty_ctxt type definition\n\nIt had been messed up by the pretty-printer at some point, and was\npartially out of date.", "tree": {"sha": "dbc9cf25dd34745b3705eb3db49fc6c41df7ba97", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dbc9cf25dd34745b3705eb3db49fc6c41df7ba97"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/633e4502e76811183208b5d1e107c4ccde2ce36c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/633e4502e76811183208b5d1e107c4ccde2ce36c", "html_url": "https://github.com/rust-lang/rust/commit/633e4502e76811183208b5d1e107c4ccde2ce36c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/633e4502e76811183208b5d1e107c4ccde2ce36c/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3bcd4fe6fa137287df34bed19eed5851f44aa703", "url": "https://api.github.com/repos/rust-lang/rust/commits/3bcd4fe6fa137287df34bed19eed5851f44aa703", "html_url": "https://github.com/rust-lang/rust/commit/3bcd4fe6fa137287df34bed19eed5851f44aa703"}], "stats": {"total": 103, "additions": 37, "deletions": 66}, "files": [{"sha": "2fb83e0d77ee2e50986290be132e71b46967789b", "filename": "src/comp/middle/trans/common.rs", "status": "modified", "additions": 37, "deletions": 66, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/633e4502e76811183208b5d1e107c4ccde2ce36c/src%2Fcomp%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/633e4502e76811183208b5d1e107c4ccde2ce36c/src%2Fcomp%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fcommon.rs?ref=633e4502e76811183208b5d1e107c4ccde2ce36c", "patch": "@@ -135,72 +135,54 @@ type fn_ty_param = {desc: ValueRef, dicts: option<[ValueRef]>};\n \n // Function context.  Every LLVM function we create will have one of\n // these.\n-type fn_ctxt =\n+type fn_ctxt = {\n     // The ValueRef returned from a call to llvm::LLVMAddFunction; the\n     // address of the first instruction in the sequence of\n     // instructions for this function that will go in the .text\n     // section of the executable we're generating.\n+    llfn: ValueRef,\n \n-    // The three implicit arguments that arrive in the function we're\n-    // creating.  For instance, foo(int, int) is really foo(ret*,\n-    // task*, env*, int, int).  These are also available via\n-    // llvm::LLVMGetParam(llfn, uint) where uint = 1, 2, 0\n-    // respectively, but we unpack them into these fields for\n-    // convenience.\n+    // The two implicit arguments that arrive in the function we're creating.\n+    // For instance, foo(int, int) is really foo(ret*, env*, int, int).\n+    llenv: ValueRef,\n+    llretptr: ValueRef,\n \n-    // Points to the current task.\n-\n-    // Points to the current environment (bindings of variables to\n-    // values), if this is a regular function\n-\n-    // Points to where the return value of this function should end\n-    // up.\n-\n-    // The next three elements: \"hoisted basic blocks\" containing\n+    // These elements: \"hoisted basic blocks\" containing\n     // administrative activities that have to happen in only one place in\n     // the function, due to LLVM's quirks.\n-\n     // A block for all the function's static allocas, so that LLVM\n     // will coalesce them into a single alloca call.\n-\n+    mutable llstaticallocas: BasicBlockRef,\n     // A block containing code that copies incoming arguments to space\n     // already allocated by code in one of the llallocas blocks.\n     // (LLVM requires that arguments be copied to local allocas before\n     // allowing most any operation to be performed on them.)\n-\n-    // The first block containing derived tydescs received from the\n-    // runtime.  See description of derived_tydescs, below.\n-\n-    // The last block of the llderivedtydescs group.\n-\n+    mutable llloadenv: BasicBlockRef,\n+    // The first and last block containing derived tydescs received from the\n+    // runtime. See description of derived_tydescs, below.\n+    mutable llderivedtydescs_first: BasicBlockRef,\n+    mutable llderivedtydescs: BasicBlockRef,\n     // A block for all of the dynamically sized allocas.  This must be\n     // after llderivedtydescs, because these sometimes depend on\n     // information computed from derived tydescs.\n-\n+    mutable lldynamicallocas: BasicBlockRef,\n+    mutable llreturn: BasicBlockRef,\n     // The token used to clear the dynamic allocas at the end of this frame.\n-\n+    mutable llobstacktoken: option<ValueRef>,\n     // The 'self' value currently in use in this function, if there\n     // is one.\n-\n-    // If this function is actually a iter, a block containing the\n-    // code called whenever the iter calls 'put'.\n-\n-    // The next four items: hash tables mapping from AST def_ids to\n-    // LLVM-stuff-in-the-frame.\n+    mutable llself: option<val_self_pair>,\n \n     // Maps arguments to allocas created for them in llallocas.\n-\n+    llargs: hashmap<ast::node_id, local_val>,\n     // Maps the def_ids for local variables to the allocas created for\n     // them in llallocas.\n+    lllocals: hashmap<ast::node_id, local_val>,\n+    // Same as above, but for closure upvars\n+    llupvars: hashmap<ast::node_id, ValueRef>,\n \n-    // The same as above, but for variables accessed via the frame\n-    // pointer we pass into an iter, for access to the static\n-    // environment of the iter-calling frame.\n-\n-    // For convenience, a vector of the incoming tydescs for each of\n-    // this functions type parameters, fetched via llvm::LLVMGetParam.\n-    // For example, for a function foo::<A, B, C>(), lltydescs contains\n-    // the ValueRefs for the tydescs for A, B, and C.\n+    // A vector of incoming type descriptors and their associated iface dicts.\n+    mutable lltyparams: [fn_ty_param],\n \n     // Derived tydescs are tydescs created at runtime, for types that\n     // involve type parameters inside type constructors.  For example,\n@@ -211,35 +193,24 @@ type fn_ctxt =\n     // when information about both \"[T]\" and \"T\" are available.  When\n     // such a tydesc is created, we cache it in the derived_tydescs\n     // table for the next time that such a tydesc is needed.\n+    derived_tydescs: hashmap<ty::t, derived_tydesc_info>,\n \n     // The node_id of the function, or -1 if it doesn't correspond to\n     // a user-defined function.\n+    id: ast::node_id,\n+\n+    // If this function is being monomorphized, this contains the type\n+    // substitutions used.\n+    param_substs: option<[ty::t]>,\n+\n+    // The source span and nesting context where this function comes from, for\n+    // error reporting and symbol generation.\n+    span: option<span>,\n+    path: path,\n \n-    // The source span where this function comes from, for error\n-    // reporting.\n-\n-    // This function's enclosing local context.\n-    {llfn: ValueRef,\n-     llenv: ValueRef,\n-     llretptr: ValueRef,\n-     mutable llstaticallocas: BasicBlockRef,\n-     mutable llloadenv: BasicBlockRef,\n-     mutable llderivedtydescs_first: BasicBlockRef,\n-     mutable llderivedtydescs: BasicBlockRef,\n-     mutable lldynamicallocas: BasicBlockRef,\n-     mutable llreturn: BasicBlockRef,\n-     mutable llobstacktoken: option<ValueRef>,\n-     mutable llself: option<val_self_pair>,\n-     llargs: hashmap<ast::node_id, local_val>,\n-     lllocals: hashmap<ast::node_id, local_val>,\n-     llupvars: hashmap<ast::node_id, ValueRef>,\n-     mutable lltyparams: [fn_ty_param],\n-     derived_tydescs: hashmap<ty::t, derived_tydesc_info>,\n-     id: ast::node_id,\n-     param_substs: option<[ty::t]>,\n-     span: option<span>,\n-     path: path,\n-     ccx: @crate_ctxt};\n+    // This function's enclosing crate context.\n+    ccx: @crate_ctxt\n+};\n \n fn warn_not_to_commit(ccx: @crate_ctxt, msg: str) {\n     if !ccx.do_not_commit_warning_issued {"}]}