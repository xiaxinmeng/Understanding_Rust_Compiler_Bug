{"sha": "126dbdc9c78446ad4cf41f5f8510a7cee59ff966", "node_id": "C_kwDOAAsO6NoAKDEyNmRiZGM5Yzc4NDQ2YWQ0Y2Y0MWY1Zjg1MTBhN2NlZTU5ZmY5NjY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-27T21:36:07Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-27T21:36:07Z"}, "message": "Auto merge of #103629 - matthiaskrgr:rollup-r94tqfa, r=matthiaskrgr\n\nRollup of 8 pull requests\n\nSuccessful merges:\n\n - #103110 (remove redundant Send impl for references)\n - #103255 (Clean up hidden type registration)\n - #103394 (Clarify documentation about the memory layout of `UnsafeCell`)\n - #103408 (Clean return-position `impl Trait` in traits correctly in rustdoc)\n - #103505 (rustdoc: parse self-closing tags and attributes in `invalid_html_tags`)\n - #103524 (rustc_metadata: Add struct and variant constructors to module children at encoding time)\n - #103544 (Add flag to forbid recovery in the parser)\n - #103616 (rustdoc: remove CSS workaround for Firefox 29)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "f4b91936c399e3f916fc8962813b6c87285617a9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f4b91936c399e3f916fc8962813b6c87285617a9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/126dbdc9c78446ad4cf41f5f8510a7cee59ff966", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/126dbdc9c78446ad4cf41f5f8510a7cee59ff966", "html_url": "https://github.com/rust-lang/rust/commit/126dbdc9c78446ad4cf41f5f8510a7cee59ff966", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/126dbdc9c78446ad4cf41f5f8510a7cee59ff966/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0da281b6068a7d889ae89a9bd8991284cc9b7535", "url": "https://api.github.com/repos/rust-lang/rust/commits/0da281b6068a7d889ae89a9bd8991284cc9b7535", "html_url": "https://github.com/rust-lang/rust/commit/0da281b6068a7d889ae89a9bd8991284cc9b7535"}, {"sha": "ae4dc125196a62447ab07ba6b130d936f56a66d0", "url": "https://api.github.com/repos/rust-lang/rust/commits/ae4dc125196a62447ab07ba6b130d936f56a66d0", "html_url": "https://github.com/rust-lang/rust/commit/ae4dc125196a62447ab07ba6b130d936f56a66d0"}], "stats": {"total": 684, "additions": 467, "deletions": 217}, "files": [{"sha": "465f353aaa37f426bdc770213eadb5ea807abbba", "filename": "compiler/rustc_borrowck/src/region_infer/opaque_types.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/126dbdc9c78446ad4cf41f5f8510a7cee59ff966/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/126dbdc9c78446ad4cf41f5f8510a7cee59ff966/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs?ref=126dbdc9c78446ad4cf41f5f8510a7cee59ff966", "patch": "@@ -263,13 +263,11 @@ impl<'tcx> InferCtxtExt<'tcx> for InferCtxt<'tcx> {\n \n         // Require that the hidden type actually fulfills all the bounds of the opaque type, even without\n         // the bounds that the function supplies.\n-        match infcx.register_hidden_type(\n-            OpaqueTypeKey { def_id, substs: id_substs },\n-            ObligationCause::misc(instantiated_ty.span, body_id),\n-            param_env,\n-            definition_ty,\n-            origin,\n-        ) {\n+        let opaque_ty = self.tcx.mk_opaque(def_id.to_def_id(), id_substs);\n+        match infcx\n+            .at(&ObligationCause::misc(instantiated_ty.span, body_id), param_env)\n+            .eq(opaque_ty, definition_ty)\n+        {\n             Ok(infer_ok) => {\n                 for obligation in infer_ok.obligations {\n                     fulfillment_cx.register_predicate_obligation(&infcx, obligation);\n@@ -280,7 +278,7 @@ impl<'tcx> InferCtxtExt<'tcx> for InferCtxt<'tcx> {\n                     .err_ctxt()\n                     .report_mismatched_types(\n                         &ObligationCause::misc(instantiated_ty.span, body_id),\n-                        self.tcx.mk_opaque(def_id.to_def_id(), id_substs),\n+                        opaque_ty,\n                         definition_ty,\n                         err,\n                     )"}, {"sha": "ca249938d04051b7567b77434d4f24f2a1fc33fe", "filename": "compiler/rustc_borrowck/src/type_check/relate_tys.rs", "status": "modified", "additions": 4, "deletions": 15, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/126dbdc9c78446ad4cf41f5f8510a7cee59ff966/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Frelate_tys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/126dbdc9c78446ad4cf41f5f8510a7cee59ff966/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Frelate_tys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Frelate_tys.rs?ref=126dbdc9c78446ad4cf41f5f8510a7cee59ff966", "patch": "@@ -1,6 +1,6 @@\n use rustc_infer::infer::nll_relate::{NormalizationStrategy, TypeRelating, TypeRelatingDelegate};\n use rustc_infer::infer::NllRegionVariableOrigin;\n-use rustc_infer::traits::ObligationCause;\n+use rustc_infer::traits::PredicateObligations;\n use rustc_middle::mir::ConstraintCategory;\n use rustc_middle::ty::error::TypeError;\n use rustc_middle::ty::relate::TypeRelation;\n@@ -155,27 +155,16 @@ impl<'tcx> TypeRelatingDelegate<'tcx> for NllTypeRelatingDelegate<'_, '_, 'tcx>\n         true\n     }\n \n-    fn register_opaque_type(\n+    fn register_opaque_type_obligations(\n         &mut self,\n-        a: Ty<'tcx>,\n-        b: Ty<'tcx>,\n-        a_is_expected: bool,\n+        obligations: PredicateObligations<'tcx>,\n     ) -> Result<(), TypeError<'tcx>> {\n-        let param_env = self.param_env();\n-        let span = self.span();\n-        let def_id = self.type_checker.body.source.def_id().expect_local();\n-        let body_id = self.type_checker.tcx().hir().local_def_id_to_hir_id(def_id);\n-        let cause = ObligationCause::misc(span, body_id);\n         self.type_checker\n             .fully_perform_op(\n                 self.locations,\n                 self.category,\n                 InstantiateOpaqueType {\n-                    obligations: self\n-                        .type_checker\n-                        .infcx\n-                        .handle_opaque_type(a, b, a_is_expected, &cause, param_env)?\n-                        .obligations,\n+                    obligations,\n                     // These fields are filled in during execution of the operation\n                     base_universe: None,\n                     region_constraints: None,"}, {"sha": "f6fe38174f7c5566f380e7a2c587c8e3b98aa272", "filename": "compiler/rustc_expand/src/mbe/macro_rules.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/126dbdc9c78446ad4cf41f5f8510a7cee59ff966/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/126dbdc9c78446ad4cf41f5f8510a7cee59ff966/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs?ref=126dbdc9c78446ad4cf41f5f8510a7cee59ff966", "patch": "@@ -250,6 +250,7 @@ fn expand_macro<'cx>(\n     // hacky, but speeds up the `html5ever` benchmark significantly. (Issue\n     // 68836 suggests a more comprehensive but more complex change to deal with\n     // this situation.)\n+    // FIXME(Nilstrieb): Stop recovery from happening on this parser and retry later with recovery if the macro failed to match.\n     let parser = parser_from_cx(sess, arg.clone());\n \n     // Try each arm's matchers."}, {"sha": "4d287988e33604a10d1ff6ff5f0d7c109bf71130", "filename": "compiler/rustc_infer/src/infer/canonical/query_response.rs", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/126dbdc9c78446ad4cf41f5f8510a7cee59ff966/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/126dbdc9c78446ad4cf41f5f8510a7cee59ff966/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs?ref=126dbdc9c78446ad4cf41f5f8510a7cee59ff966", "patch": "@@ -16,8 +16,8 @@ use crate::infer::nll_relate::{NormalizationStrategy, TypeRelating, TypeRelating\n use crate::infer::region_constraints::{Constraint, RegionConstraintData};\n use crate::infer::{InferCtxt, InferOk, InferResult, NllRegionVariableOrigin};\n use crate::traits::query::{Fallible, NoSolution};\n-use crate::traits::TraitEngine;\n use crate::traits::{Obligation, ObligationCause, PredicateObligation};\n+use crate::traits::{PredicateObligations, TraitEngine};\n use rustc_data_structures::captures::Captures;\n use rustc_index::vec::Idx;\n use rustc_index::vec::IndexVec;\n@@ -509,7 +509,7 @@ impl<'tcx> InferCtxt<'tcx> {\n         for &(a, b) in &query_response.value.opaque_types {\n             let a = substitute_value(self.tcx, &result_subst, a);\n             let b = substitute_value(self.tcx, &result_subst, b);\n-            obligations.extend(self.handle_opaque_type(a, b, true, cause, param_env)?.obligations);\n+            obligations.extend(self.at(cause, param_env).eq(a, b)?.obligations);\n         }\n \n         Ok(InferOk { value: result_subst, obligations })\n@@ -741,17 +741,11 @@ impl<'tcx> TypeRelatingDelegate<'tcx> for QueryTypeRelatingDelegate<'_, 'tcx> {\n         true\n     }\n \n-    fn register_opaque_type(\n+    fn register_opaque_type_obligations(\n         &mut self,\n-        a: Ty<'tcx>,\n-        b: Ty<'tcx>,\n-        a_is_expected: bool,\n+        obligations: PredicateObligations<'tcx>,\n     ) -> Result<(), TypeError<'tcx>> {\n-        self.obligations.extend(\n-            self.infcx\n-                .handle_opaque_type(a, b, a_is_expected, &self.cause, self.param_env)?\n-                .obligations,\n-        );\n+        self.obligations.extend(obligations);\n         Ok(())\n     }\n }"}, {"sha": "600f94f095eace0056fc0af4292245a197946f0f", "filename": "compiler/rustc_infer/src/infer/nll_relate/mod.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/126dbdc9c78446ad4cf41f5f8510a7cee59ff966/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/126dbdc9c78446ad4cf41f5f8510a7cee59ff966/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs?ref=126dbdc9c78446ad4cf41f5f8510a7cee59ff966", "patch": "@@ -25,7 +25,9 @@ use crate::infer::combine::ConstEquateRelation;\n use crate::infer::InferCtxt;\n use crate::infer::{ConstVarValue, ConstVariableValue};\n use crate::infer::{TypeVariableOrigin, TypeVariableOriginKind};\n+use crate::traits::PredicateObligation;\n use rustc_data_structures::fx::FxHashMap;\n+use rustc_middle::traits::ObligationCause;\n use rustc_middle::ty::error::TypeError;\n use rustc_middle::ty::relate::{self, Relate, RelateResult, TypeRelation};\n use rustc_middle::ty::visit::{TypeSuperVisitable, TypeVisitable, TypeVisitor};\n@@ -91,11 +93,9 @@ pub trait TypeRelatingDelegate<'tcx> {\n     );\n \n     fn const_equate(&mut self, a: ty::Const<'tcx>, b: ty::Const<'tcx>);\n-    fn register_opaque_type(\n+    fn register_opaque_type_obligations(\n         &mut self,\n-        a: Ty<'tcx>,\n-        b: Ty<'tcx>,\n-        a_is_expected: bool,\n+        obligations: Vec<PredicateObligation<'tcx>>,\n     ) -> Result<(), TypeError<'tcx>>;\n \n     /// Creates a new universe index. Used when instantiating placeholders.\n@@ -414,7 +414,12 @@ where\n             (_, &ty::Opaque(..)) => (generalize(a, true)?, b),\n             _ => unreachable!(),\n         };\n-        self.delegate.register_opaque_type(a, b, true)?;\n+        let cause = ObligationCause::dummy_with_span(self.delegate.span());\n+        let obligations = self\n+            .infcx\n+            .handle_opaque_type(a, b, true, &cause, self.delegate.param_env())?\n+            .obligations;\n+        self.delegate.register_opaque_type_obligations(obligations)?;\n         trace!(a = ?a.kind(), b = ?b.kind(), \"opaque type instantiated\");\n         Ok(a)\n     }"}, {"sha": "a982f11f7187fa7703f46bf1eb5f81694479f272", "filename": "compiler/rustc_infer/src/infer/opaque_types.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/126dbdc9c78446ad4cf41f5f8510a7cee59ff966/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/126dbdc9c78446ad4cf41f5f8510a7cee59ff966/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs?ref=126dbdc9c78446ad4cf41f5f8510a7cee59ff966", "patch": "@@ -103,7 +103,7 @@ impl<'tcx> InferCtxt<'tcx> {\n             return Ok(InferOk { value: (), obligations: vec![] });\n         }\n         let (a, b) = if a_is_expected { (a, b) } else { (b, a) };\n-        let process = |a: Ty<'tcx>, b: Ty<'tcx>| match *a.kind() {\n+        let process = |a: Ty<'tcx>, b: Ty<'tcx>, a_is_expected| match *a.kind() {\n             ty::Opaque(def_id, substs) if def_id.is_local() => {\n                 let def_id = def_id.expect_local();\n                 let origin = match self.defining_use_anchor {\n@@ -169,13 +169,14 @@ impl<'tcx> InferCtxt<'tcx> {\n                     param_env,\n                     b,\n                     origin,\n+                    a_is_expected,\n                 ))\n             }\n             _ => None,\n         };\n-        if let Some(res) = process(a, b) {\n+        if let Some(res) = process(a, b, true) {\n             res\n-        } else if let Some(res) = process(b, a) {\n+        } else if let Some(res) = process(b, a, false) {\n             res\n         } else {\n             let (a, b) = self.resolve_vars_if_possible((a, b));\n@@ -514,13 +515,14 @@ impl UseKind {\n \n impl<'tcx> InferCtxt<'tcx> {\n     #[instrument(skip(self), level = \"debug\")]\n-    pub fn register_hidden_type(\n+    fn register_hidden_type(\n         &self,\n         opaque_type_key: OpaqueTypeKey<'tcx>,\n         cause: ObligationCause<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n         hidden_ty: Ty<'tcx>,\n         origin: hir::OpaqueTyOrigin,\n+        a_is_expected: bool,\n     ) -> InferResult<'tcx, ()> {\n         let tcx = self.tcx;\n         let OpaqueTypeKey { def_id, substs } = opaque_type_key;\n@@ -539,7 +541,8 @@ impl<'tcx> InferCtxt<'tcx> {\n             origin,\n         );\n         if let Some(prev) = prev {\n-            obligations = self.at(&cause, param_env).eq(prev, hidden_ty)?.obligations;\n+            obligations =\n+                self.at(&cause, param_env).eq_exp(a_is_expected, prev, hidden_ty)?.obligations;\n         }\n \n         let item_bounds = tcx.bound_explicit_item_bounds(def_id.to_def_id());"}, {"sha": "97354ba5d1bd1c2cf044988eaedf7cf536750423", "filename": "compiler/rustc_infer/src/infer/sub.rs", "status": "modified", "additions": 8, "deletions": 31, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/126dbdc9c78446ad4cf41f5f8510a7cee59ff966/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/126dbdc9c78446ad4cf41f5f8510a7cee59ff966/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs?ref=126dbdc9c78446ad4cf41f5f8510a7cee59ff966", "patch": "@@ -2,9 +2,7 @@ use super::combine::{CombineFields, RelationDir};\n use super::SubregionOrigin;\n \n use crate::infer::combine::ConstEquateRelation;\n-use crate::infer::{TypeVariableOrigin, TypeVariableOriginKind};\n use crate::traits::Obligation;\n-use rustc_middle::ty::error::{ExpectedFound, TypeError};\n use rustc_middle::ty::relate::{Cause, Relate, RelateResult, TypeRelation};\n use rustc_middle::ty::visit::TypeVisitable;\n use rustc_middle::ty::TyVar;\n@@ -130,39 +128,18 @@ impl<'tcx> TypeRelation<'tcx> for Sub<'_, '_, 'tcx> {\n             (&ty::Opaque(did, ..), _) | (_, &ty::Opaque(did, ..))\n                 if self.fields.define_opaque_types && did.is_local() =>\n             {\n-                let mut generalize = |ty, ty_is_expected| {\n-                    let var = infcx.next_ty_var_id_in_universe(\n-                        TypeVariableOrigin {\n-                            kind: TypeVariableOriginKind::MiscVariable,\n-                            span: self.fields.trace.cause.span,\n-                        },\n-                        ty::UniverseIndex::ROOT,\n-                    );\n-                    self.fields.instantiate(ty, RelationDir::SubtypeOf, var, ty_is_expected)?;\n-                    Ok(infcx.tcx.mk_ty_var(var))\n-                };\n-                let (a, b) = if self.a_is_expected { (a, b) } else { (b, a) };\n-                let (ga, gb) = match (a.kind(), b.kind()) {\n-                    (&ty::Opaque(..), _) => (a, generalize(b, true)?),\n-                    (_, &ty::Opaque(..)) => (generalize(a, false)?, b),\n-                    _ => unreachable!(),\n-                };\n                 self.fields.obligations.extend(\n                     infcx\n-                        .handle_opaque_type(ga, gb, true, &self.fields.trace.cause, self.param_env())\n-                        // Don't leak any generalized type variables out of this\n-                        // subtyping relation in the case of a type error.\n-                        .map_err(|err| {\n-                            let (ga, gb) = self.fields.infcx.resolve_vars_if_possible((ga, gb));\n-                            if let TypeError::Sorts(sorts) = err && sorts.expected == ga && sorts.found == gb {\n-                                TypeError::Sorts(ExpectedFound { expected: a, found: b })\n-                            } else {\n-                                err\n-                            }\n-                        })?\n+                        .handle_opaque_type(\n+                            a,\n+                            b,\n+                            self.a_is_expected,\n+                            &self.fields.trace.cause,\n+                            self.param_env(),\n+                        )?\n                         .obligations,\n                 );\n-                Ok(ga)\n+                Ok(a)\n             }\n             // Optimization of GeneratorWitness relation since we know that all\n             // free regions are replaced with bound regions during construction."}, {"sha": "691e3d0f8f9026aafc0b2fde5040962be4e7e1fe", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 35, "deletions": 44, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/126dbdc9c78446ad4cf41f5f8510a7cee59ff966/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/126dbdc9c78446ad4cf41f5f8510a7cee59ff966/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=126dbdc9c78446ad4cf41f5f8510a7cee59ff966", "patch": "@@ -773,7 +773,15 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n     }\n \n     fn opt_item_name(self, item_index: DefIndex) -> Option<Symbol> {\n-        self.def_key(item_index).disambiguated_data.data.get_opt_name()\n+        let def_key = self.def_key(item_index);\n+        def_key.disambiguated_data.data.get_opt_name().or_else(|| {\n+            if def_key.disambiguated_data.data == DefPathData::Ctor {\n+                let parent_index = def_key.parent.expect(\"no parent for a constructor\");\n+                self.def_key(parent_index).disambiguated_data.data.get_opt_name()\n+            } else {\n+                None\n+            }\n+        })\n     }\n \n     fn item_name(self, item_index: DefIndex) -> Symbol {\n@@ -905,7 +913,13 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n                 .get(self, item_id)\n                 .unwrap_or_else(LazyArray::empty)\n                 .decode(self)\n-                .map(|index| self.get_variant(&self.def_kind(index), index, did))\n+                .filter_map(|index| {\n+                    let kind = self.def_kind(index);\n+                    match kind {\n+                        DefKind::Ctor(..) => None,\n+                        _ => Some(self.get_variant(&kind, index, did)),\n+                    }\n+                })\n                 .collect()\n         } else {\n             std::iter::once(self.get_variant(&kind, item_id, did)).collect()\n@@ -1029,50 +1043,27 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n \n                 callback(ModChild { ident, res, vis, span, macro_rules });\n \n-                // For non-re-export structs and variants add their constructors to children.\n-                // Re-export lists automatically contain constructors when necessary.\n-                match kind {\n-                    DefKind::Struct => {\n-                        if let Some((ctor_def_id, ctor_kind)) =\n-                            self.get_ctor_def_id_and_kind(child_index)\n-                        {\n-                            let ctor_res =\n-                                Res::Def(DefKind::Ctor(CtorOf::Struct, ctor_kind), ctor_def_id);\n-                            let vis = self.get_visibility(ctor_def_id.index);\n-                            callback(ModChild {\n-                                ident,\n-                                res: ctor_res,\n-                                vis,\n-                                span,\n-                                macro_rules: false,\n-                            });\n-                        }\n-                    }\n-                    DefKind::Variant => {\n-                        // Braced variants, unlike structs, generate unusable names in\n-                        // value namespace, they are reserved for possible future use.\n-                        // It's ok to use the variant's id as a ctor id since an\n-                        // error will be reported on any use of such resolution anyway.\n-                        let (ctor_def_id, ctor_kind) = self\n-                            .get_ctor_def_id_and_kind(child_index)\n-                            .unwrap_or((def_id, CtorKind::Fictive));\n-                        let ctor_res =\n-                            Res::Def(DefKind::Ctor(CtorOf::Variant, ctor_kind), ctor_def_id);\n-                        let mut vis = self.get_visibility(ctor_def_id.index);\n-                        if ctor_def_id == def_id && vis.is_public() {\n-                            // For non-exhaustive variants lower the constructor visibility to\n-                            // within the crate. We only need this for fictive constructors,\n-                            // for other constructors correct visibilities\n-                            // were already encoded in metadata.\n-                            let mut attrs = self.get_item_attrs(def_id.index, sess);\n-                            if attrs.any(|item| item.has_name(sym::non_exhaustive)) {\n-                                let crate_def_id = self.local_def_id(CRATE_DEF_INDEX);\n-                                vis = ty::Visibility::Restricted(crate_def_id);\n-                            }\n+                // For non-reexport variants add their fictive constructors to children.\n+                // Braced variants, unlike structs, generate unusable names in value namespace,\n+                // they are reserved for possible future use. It's ok to use the variant's id as\n+                // a ctor id since an error will be reported on any use of such resolution anyway.\n+                // Reexport lists automatically contain such constructors when necessary.\n+                if kind == DefKind::Variant && self.get_ctor_def_id_and_kind(child_index).is_none()\n+                {\n+                    let ctor_res =\n+                        Res::Def(DefKind::Ctor(CtorOf::Variant, CtorKind::Fictive), def_id);\n+                    let mut vis = vis;\n+                    if vis.is_public() {\n+                        // For non-exhaustive variants lower the constructor visibility to\n+                        // within the crate. We only need this for fictive constructors,\n+                        // for other constructors correct visibilities\n+                        // were already encoded in metadata.\n+                        let mut attrs = self.get_item_attrs(def_id.index, sess);\n+                        if attrs.any(|item| item.has_name(sym::non_exhaustive)) {\n+                            vis = ty::Visibility::Restricted(self.local_def_id(CRATE_DEF_INDEX));\n                         }\n-                        callback(ModChild { ident, res: ctor_res, vis, span, macro_rules: false });\n                     }\n-                    _ => {}\n+                    callback(ModChild { ident, res: ctor_res, vis, span, macro_rules: false });\n                 }\n             }\n         }"}, {"sha": "1743bbd6a219d1c254a21125dde7055293e1bfd1", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/126dbdc9c78446ad4cf41f5f8510a7cee59ff966/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/126dbdc9c78446ad4cf41f5f8510a7cee59ff966/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=126dbdc9c78446ad4cf41f5f8510a7cee59ff966", "patch": "@@ -1297,6 +1297,13 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                         // Only encode named non-reexport children, reexports are encoded\n                         // separately and unnamed items are not used by name resolution.\n                         hir::ItemKind::ExternCrate(..) => continue,\n+                        hir::ItemKind::Struct(ref vdata, _) => {\n+                            yield item_id.def_id.def_id.local_def_index;\n+                            // Encode constructors which take a separate slot in value namespace.\n+                            if let Some(ctor_hir_id) = vdata.ctor_hir_id() {\n+                                yield tcx.hir().local_def_id(ctor_hir_id).local_def_index;\n+                            }\n+                        }\n                         _ if tcx.def_key(item_id.def_id.to_def_id()).get_opt_name().is_some() => {\n                             yield item_id.def_id.def_id.local_def_index;\n                         }\n@@ -1620,12 +1627,17 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         };\n         // FIXME(eddyb) there should be a nicer way to do this.\n         match item.kind {\n-            hir::ItemKind::Enum(..) => record_array!(self.tables.children[def_id] <-\n-                self.tcx.adt_def(def_id).variants().iter().map(|v| {\n-                    assert!(v.def_id.is_local());\n-                    v.def_id.index\n-                })\n-            ),\n+            hir::ItemKind::Enum(..) => {\n+                record_array!(self.tables.children[def_id] <- iter::from_generator(||\n+                    for variant in tcx.adt_def(def_id).variants() {\n+                        yield variant.def_id.index;\n+                        // Encode constructors which take a separate slot in value namespace.\n+                        if let Some(ctor_def_id) = variant.ctor_def_id {\n+                            yield ctor_def_id.index;\n+                        }\n+                    }\n+                ))\n+            }\n             hir::ItemKind::Struct(..) | hir::ItemKind::Union(..) => {\n                 record_array!(self.tables.children[def_id] <-\n                     self.tcx.adt_def(def_id).non_enum_variant().fields.iter().map(|f| {"}, {"sha": "a781748efc52af24aff8ed22f151cd16e7628a7e", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/126dbdc9c78446ad4cf41f5f8510a7cee59ff966/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/126dbdc9c78446ad4cf41f5f8510a7cee59ff966/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=126dbdc9c78446ad4cf41f5f8510a7cee59ff966", "patch": "@@ -2112,6 +2112,8 @@ impl<'a> Parser<'a> {\n             // HACK: This is needed so we can detect whether we're inside a macro,\n             // where regular assumptions about what tokens can follow other tokens\n             // don't necessarily apply.\n+            && self.may_recover()\n+            // FIXME(Nilstrieb): Remove this check once `may_recover` actually stops recovery\n             && self.subparser_name.is_none()\n         {\n             // It is likely that the closure body is a block but where the"}, {"sha": "5fe29062b85b90b7d1c88755283e812ed10dcff8", "filename": "compiler/rustc_parse/src/parser/mod.rs", "status": "modified", "additions": 28, "deletions": 2, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/126dbdc9c78446ad4cf41f5f8510a7cee59ff966/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/126dbdc9c78446ad4cf41f5f8510a7cee59ff966/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs?ref=126dbdc9c78446ad4cf41f5f8510a7cee59ff966", "patch": "@@ -115,6 +115,12 @@ macro_rules! maybe_recover_from_interpolated_ty_qpath {\n     };\n }\n \n+#[derive(Clone, Copy)]\n+pub enum Recovery {\n+    Allowed,\n+    Forbidden,\n+}\n+\n #[derive(Clone)]\n pub struct Parser<'a> {\n     pub sess: &'a ParseSess,\n@@ -152,12 +158,15 @@ pub struct Parser<'a> {\n     /// This allows us to recover when the user forget to add braces around\n     /// multiple statements in the closure body.\n     pub current_closure: Option<ClosureSpans>,\n+    /// Whether the parser is allowed to do recovery.\n+    /// This is disabled when parsing macro arguments, see #103534\n+    pub recovery: Recovery,\n }\n \n-// This type is used a lot, e.g. it's cloned when matching many declarative macro rules. Make sure\n+// This type is used a lot, e.g. it's cloned when matching many declarative macro rules with nonterminals. Make sure\n // it doesn't unintentionally get bigger.\n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n-rustc_data_structures::static_assert_size!(Parser<'_>, 328);\n+rustc_data_structures::static_assert_size!(Parser<'_>, 336);\n \n /// Stores span information about a closure.\n #[derive(Clone)]\n@@ -483,6 +492,7 @@ impl<'a> Parser<'a> {\n                 inner_attr_ranges: Default::default(),\n             },\n             current_closure: None,\n+            recovery: Recovery::Allowed,\n         };\n \n         // Make parser point to the first token.\n@@ -491,6 +501,22 @@ impl<'a> Parser<'a> {\n         parser\n     }\n \n+    pub fn forbid_recovery(mut self) -> Self {\n+        self.recovery = Recovery::Forbidden;\n+        self\n+    }\n+\n+    /// Whether the parser is allowed to recover from broken code.\n+    ///\n+    /// If this returns false, recovering broken code into valid code (especially if this recovery does lookahead)\n+    /// is not allowed. All recovery done by the parser must be gated behind this check.\n+    ///\n+    /// Technically, this only needs to restrict eager recovery by doing lookahead at more tokens.\n+    /// But making the distinction is very subtle, and simply forbidding all recovery is a lot simpler to uphold.\n+    fn may_recover(&self) -> bool {\n+        matches!(self.recovery, Recovery::Allowed)\n+    }\n+\n     pub fn unexpected<T>(&mut self) -> PResult<'a, T> {\n         match self.expect_one_of(&[], &[]) {\n             Err(e) => Err(e),"}, {"sha": "7bf32cb0d98f27b3bf4db76847f8725cea272d65", "filename": "library/core/src/cell.rs", "status": "modified", "additions": 36, "deletions": 25, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/126dbdc9c78446ad4cf41f5f8510a7cee59ff966/library%2Fcore%2Fsrc%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/126dbdc9c78446ad4cf41f5f8510a7cee59ff966/library%2Fcore%2Fsrc%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fcell.rs?ref=126dbdc9c78446ad4cf41f5f8510a7cee59ff966", "patch": "@@ -1816,6 +1816,8 @@ impl<T: ?Sized + fmt::Display> fmt::Display for RefMut<'_, T> {\n ///\n /// [`.get_mut()`]: `UnsafeCell::get_mut`\n ///\n+/// # Memory layout\n+///\n /// `UnsafeCell<T>` has the same in-memory representation as its inner type `T`. A consequence\n /// of this guarantee is that it is possible to convert between `T` and `UnsafeCell<T>`.\n /// Special care has to be taken when converting a nested `T` inside of an `Outer<T>` type\n@@ -1825,35 +1827,44 @@ impl<T: ?Sized + fmt::Display> fmt::Display for RefMut<'_, T> {\n /// Therefore this is not a valid conversion, despite `NonNull<u8>` and `UnsafeCell<NonNull<u8>>>`\n /// having the same memory layout. This is because `UnsafeCell` disables niche optimizations in\n /// order to avoid its interior mutability property from spreading from `T` into the `Outer` type,\n-/// thus this can cause distortions in the type size in these cases. Furthermore, it is only valid\n-/// to obtain a `*mut T` pointer to the contents of a _shared_ `UnsafeCell<T>` through [`.get()`]\n-/// or [`.raw_get()`]. A `&mut T` reference can be obtained by either dereferencing this pointer or\n-/// by calling [`.get_mut()`] on an _exclusive_ `UnsafeCell<T>`, e.g.:\n+/// thus this can cause distortions in the type size in these cases.\n+///\n+/// Note that the only valid way to obtain a `*mut T` pointer to the contents of a\n+/// _shared_ `UnsafeCell<T>` is through [`.get()`]  or [`.raw_get()`]. A `&mut T` reference\n+/// can be obtained by either dereferencing this pointer or by calling [`.get_mut()`]\n+/// on an _exclusive_ `UnsafeCell<T>`. Even though `T` and `UnsafeCell<T>` have the\n+/// same memory layout, the following is not allowed and undefined behavior:\n+///\n+/// ```rust,no_run\n+/// # use std::cell::UnsafeCell;\n+/// unsafe fn not_allowed<T>(ptr: &UnsafeCell<T>) -> &mut T {\n+///   let t = ptr as *const UnsafeCell<T> as *mut T;\n+///   // This is undefined behavior, because the `*mut T` pointer\n+///   // was not obtained through `.get()` nor `.raw_get()`:\n+///   unsafe { &mut *t }\n+/// }\n+/// ```\n+///\n+/// Instead, do this:\n ///\n /// ```rust\n-/// use std::cell::UnsafeCell;\n+/// # use std::cell::UnsafeCell;\n+/// // Safety: the caller must ensure that there are no references that\n+/// // point to the *contents* of the `UnsafeCell`.\n+/// unsafe fn get_mut<T>(ptr: &UnsafeCell<T>) -> &mut T {\n+///   unsafe { &mut *ptr.get() }\n+/// }\n+/// ```\n ///\n-/// let mut x: UnsafeCell<u32> = UnsafeCell::new(5);\n-/// let shared: &UnsafeCell<u32> = &x;\n-/// // using `.get()` is okay:\n-/// unsafe {\n-///     // SAFETY: there exist no other references to the contents of `x`\n-///     let exclusive: &mut u32 = &mut *shared.get();\n-/// };\n-/// // using `.raw_get()` is also okay:\n-/// unsafe {\n-///     // SAFETY: there exist no other references to the contents of `x` in this scope\n-///     let exclusive: &mut u32 = &mut *UnsafeCell::raw_get(shared as *const _);\n-/// };\n-/// // using `.get_mut()` is always safe:\n-/// let exclusive: &mut u32 = x.get_mut();\n+/// Coverting in the other direction from a `&mut T`\n+/// to an `&UnsafeCell<T>` is allowed:\n ///\n-/// // when we have exclusive access, we can convert it to a shared `&UnsafeCell`:\n-/// unsafe {\n-///     // SAFETY: `u32` has no niche, therefore it has the same layout as `UnsafeCell<u32>`\n-///     let shared: &UnsafeCell<u32> = &*(exclusive as *mut _ as *const UnsafeCell<u32>);\n-///     // SAFETY: there exist no other *active* references to the contents of `x` in this scope\n-///     let exclusive: &mut u32 = &mut *shared.get();\n+/// ```rust\n+/// # use std::cell::UnsafeCell;\n+/// fn get_shared<T>(ptr: &mut T) -> &UnsafeCell<T> {\n+///   let t = ptr as *mut T as *const UnsafeCell<T>;\n+///   // SAFETY: `T` and `UnsafeCell<T>` have the same memory layout\n+///   unsafe { &*t }\n /// }\n /// ```\n ///"}, {"sha": "ae4ebf444429545538b85c22ceef44087d7ea241", "filename": "library/core/src/marker.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/126dbdc9c78446ad4cf41f5f8510a7cee59ff966/library%2Fcore%2Fsrc%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/126dbdc9c78446ad4cf41f5f8510a7cee59ff966/library%2Fcore%2Fsrc%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmarker.rs?ref=126dbdc9c78446ad4cf41f5f8510a7cee59ff966", "patch": "@@ -44,6 +44,12 @@ impl<T: ?Sized> !Send for *const T {}\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized> !Send for *mut T {}\n \n+// Most instances arise automatically, but this instance is needed to link up `T: Sync` with\n+// `&T: Send` (and it also removes the unsound default instance `T Send` -> `&T: Send` that would\n+// otherwise exist).\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+unsafe impl<T: Sync + ?Sized> Send for &T {}\n+\n /// Types with a constant size known at compile time.\n ///\n /// All type parameters have an implicit bound of `Sized`. The special syntax\n@@ -674,13 +680,6 @@ impl<T: ?Sized> StructuralPartialEq for PhantomData<T> {}\n #[unstable(feature = \"structural_match\", issue = \"31434\")]\n impl<T: ?Sized> StructuralEq for PhantomData<T> {}\n \n-mod impls {\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    unsafe impl<T: Sync + ?Sized> Send for &T {}\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    unsafe impl<T: Send + ?Sized> Send for &mut T {}\n-}\n-\n /// Compiler-internal trait used to indicate the type of enum discriminants.\n ///\n /// This trait is automatically implemented for every type and does not add any"}, {"sha": "a3a1abc3cf0564b26fca363bd39863e1926e99ac", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 69, "deletions": 53, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/126dbdc9c78446ad4cf41f5f8510a7cee59ff966/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/126dbdc9c78446ad4cf41f5f8510a7cee59ff966/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=126dbdc9c78446ad4cf41f5f8510a7cee59ff966", "patch": "@@ -415,6 +415,16 @@ fn clean_projection<'tcx>(\n     cx: &mut DocContext<'tcx>,\n     def_id: Option<DefId>,\n ) -> Type {\n+    if cx.tcx.def_kind(ty.item_def_id) == DefKind::ImplTraitPlaceholder {\n+        let bounds = cx\n+            .tcx\n+            .explicit_item_bounds(ty.item_def_id)\n+            .iter()\n+            .map(|(bound, _)| EarlyBinder(*bound).subst(cx.tcx, ty.substs))\n+            .collect::<Vec<_>>();\n+        return clean_middle_opaque_bounds(cx, bounds);\n+    }\n+\n     let trait_ = clean_trait_ref_with_bindings(cx, ty.trait_ref(cx.tcx), ThinVec::new());\n     let self_type = clean_middle_ty(ty.self_ty(), cx, None);\n     let self_def_id = if let Some(def_id) = def_id {\n@@ -1720,59 +1730,7 @@ pub(crate) fn clean_middle_ty<'tcx>(\n                 .iter()\n                 .map(|(bound, _)| EarlyBinder(*bound).subst(cx.tcx, substs))\n                 .collect::<Vec<_>>();\n-            let mut regions = vec![];\n-            let mut has_sized = false;\n-            let mut bounds = bounds\n-                .iter()\n-                .filter_map(|bound| {\n-                    let bound_predicate = bound.kind();\n-                    let trait_ref = match bound_predicate.skip_binder() {\n-                        ty::PredicateKind::Trait(tr) => bound_predicate.rebind(tr.trait_ref),\n-                        ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(_ty, reg)) => {\n-                            if let Some(r) = clean_middle_region(reg) {\n-                                regions.push(GenericBound::Outlives(r));\n-                            }\n-                            return None;\n-                        }\n-                        _ => return None,\n-                    };\n-\n-                    if let Some(sized) = cx.tcx.lang_items().sized_trait() {\n-                        if trait_ref.def_id() == sized {\n-                            has_sized = true;\n-                            return None;\n-                        }\n-                    }\n-\n-                    let bindings: ThinVec<_> = bounds\n-                        .iter()\n-                        .filter_map(|bound| {\n-                            if let ty::PredicateKind::Projection(proj) = bound.kind().skip_binder()\n-                            {\n-                                if proj.projection_ty.trait_ref(cx.tcx) == trait_ref.skip_binder() {\n-                                    Some(TypeBinding {\n-                                        assoc: projection_to_path_segment(proj.projection_ty, cx),\n-                                        kind: TypeBindingKind::Equality {\n-                                            term: clean_middle_term(proj.term, cx),\n-                                        },\n-                                    })\n-                                } else {\n-                                    None\n-                                }\n-                            } else {\n-                                None\n-                            }\n-                        })\n-                        .collect();\n-\n-                    Some(clean_poly_trait_ref_with_bindings(cx, trait_ref, bindings))\n-                })\n-                .collect::<Vec<_>>();\n-            bounds.extend(regions);\n-            if !has_sized && !bounds.is_empty() {\n-                bounds.insert(0, GenericBound::maybe_sized(cx));\n-            }\n-            ImplTrait(bounds)\n+            clean_middle_opaque_bounds(cx, bounds)\n         }\n \n         ty::Closure(..) => panic!(\"Closure\"),\n@@ -1785,6 +1743,64 @@ pub(crate) fn clean_middle_ty<'tcx>(\n     }\n }\n \n+fn clean_middle_opaque_bounds<'tcx>(\n+    cx: &mut DocContext<'tcx>,\n+    bounds: Vec<ty::Predicate<'tcx>>,\n+) -> Type {\n+    let mut regions = vec![];\n+    let mut has_sized = false;\n+    let mut bounds = bounds\n+        .iter()\n+        .filter_map(|bound| {\n+            let bound_predicate = bound.kind();\n+            let trait_ref = match bound_predicate.skip_binder() {\n+                ty::PredicateKind::Trait(tr) => bound_predicate.rebind(tr.trait_ref),\n+                ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(_ty, reg)) => {\n+                    if let Some(r) = clean_middle_region(reg) {\n+                        regions.push(GenericBound::Outlives(r));\n+                    }\n+                    return None;\n+                }\n+                _ => return None,\n+            };\n+\n+            if let Some(sized) = cx.tcx.lang_items().sized_trait() {\n+                if trait_ref.def_id() == sized {\n+                    has_sized = true;\n+                    return None;\n+                }\n+            }\n+\n+            let bindings: ThinVec<_> = bounds\n+                .iter()\n+                .filter_map(|bound| {\n+                    if let ty::PredicateKind::Projection(proj) = bound.kind().skip_binder() {\n+                        if proj.projection_ty.trait_ref(cx.tcx) == trait_ref.skip_binder() {\n+                            Some(TypeBinding {\n+                                assoc: projection_to_path_segment(proj.projection_ty, cx),\n+                                kind: TypeBindingKind::Equality {\n+                                    term: clean_middle_term(proj.term, cx),\n+                                },\n+                            })\n+                        } else {\n+                            None\n+                        }\n+                    } else {\n+                        None\n+                    }\n+                })\n+                .collect();\n+\n+            Some(clean_poly_trait_ref_with_bindings(cx, trait_ref, bindings))\n+        })\n+        .collect::<Vec<_>>();\n+    bounds.extend(regions);\n+    if !has_sized && !bounds.is_empty() {\n+        bounds.insert(0, GenericBound::maybe_sized(cx));\n+    }\n+    ImplTrait(bounds)\n+}\n+\n pub(crate) fn clean_field<'tcx>(field: &hir::FieldDef<'tcx>, cx: &mut DocContext<'tcx>) -> Item {\n     let def_id = cx.tcx.hir().local_def_id(field.hir_id).to_def_id();\n     clean_field_with_def_id(def_id, field.ident.name, clean_ty(field.ty, cx), cx)"}, {"sha": "934334e0c88bdc2d054b713d74a8c4c8efc37d73", "filename": "src/librustdoc/html/static/css/rustdoc.css", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/126dbdc9c78446ad4cf41f5f8510a7cee59ff966/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/126dbdc9c78446ad4cf41f5f8510a7cee59ff966/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css?ref=126dbdc9c78446ad4cf41f5f8510a7cee59ff966", "patch": "@@ -857,9 +857,7 @@ so that we can apply CSS-filters to change the arrow color in themes */\n \t   causes rounded corners and no border on iOS Safari. */\n \t-webkit-appearance: none;\n \t/* Override Normalize.css: we have margins and do\n-\t not want to overflow - the `moz` attribute is necessary\n-\t until Firefox 29, too early to drop at this point */\n-\t-moz-box-sizing: border-box !important;\n+\t not want to overflow */\n \tbox-sizing: border-box !important;\n \toutline: none;\n \tborder: 1px solid var(--border-color);"}, {"sha": "a89ed7c7ed4546082e8d407d784efe92f41396bd", "filename": "src/librustdoc/passes/html_tags.rs", "status": "modified", "additions": 54, "deletions": 1, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/126dbdc9c78446ad4cf41f5f8510a7cee59ff966/src%2Flibrustdoc%2Fpasses%2Fhtml_tags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/126dbdc9c78446ad4cf41f5f8510a7cee59ff966/src%2Flibrustdoc%2Fpasses%2Fhtml_tags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fhtml_tags.rs?ref=126dbdc9c78446ad4cf41f5f8510a7cee59ff966", "patch": "@@ -184,7 +184,60 @@ fn extract_html_tag(\n                     }\n                     drop_tag(tags, tag_name, r, f);\n                 } else {\n-                    tags.push((tag_name, r));\n+                    let mut is_self_closing = false;\n+                    let mut quote_pos = None;\n+                    if c != '>' {\n+                        let mut quote = None;\n+                        let mut after_eq = false;\n+                        for (i, c) in text[pos..].char_indices() {\n+                            if !c.is_whitespace() {\n+                                if let Some(q) = quote {\n+                                    if c == q {\n+                                        quote = None;\n+                                        quote_pos = None;\n+                                        after_eq = false;\n+                                    }\n+                                } else if c == '>' {\n+                                    break;\n+                                } else if c == '/' && !after_eq {\n+                                    is_self_closing = true;\n+                                } else {\n+                                    if is_self_closing {\n+                                        is_self_closing = false;\n+                                    }\n+                                    if (c == '\"' || c == '\\'') && after_eq {\n+                                        quote = Some(c);\n+                                        quote_pos = Some(pos + i);\n+                                    } else if c == '=' {\n+                                        after_eq = true;\n+                                    }\n+                                }\n+                            } else if quote.is_none() {\n+                                after_eq = false;\n+                            }\n+                        }\n+                    }\n+                    if let Some(quote_pos) = quote_pos {\n+                        let qr = Range { start: quote_pos, end: quote_pos };\n+                        f(\n+                            &format!(\"unclosed quoted HTML attribute on tag `{}`\", tag_name),\n+                            &qr,\n+                            false,\n+                        );\n+                    }\n+                    if is_self_closing {\n+                        // https://html.spec.whatwg.org/#parse-error-non-void-html-element-start-tag-with-trailing-solidus\n+                        let valid = ALLOWED_UNCLOSED.contains(&&tag_name[..])\n+                            || tags.iter().take(pos + 1).any(|(at, _)| {\n+                                let at = at.to_lowercase();\n+                                at == \"svg\" || at == \"math\"\n+                            });\n+                        if !valid {\n+                            f(&format!(\"invalid self-closing HTML tag `{}`\", tag_name), &r, false);\n+                        }\n+                    } else {\n+                        tags.push((tag_name, r));\n+                    }\n                 }\n             }\n             break;"}, {"sha": "d973a53cbc7cea9d5cddfa83438d3f0bbf3435af", "filename": "src/test/rustdoc-ui/invalid-html-self-closing-tag.rs", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/126dbdc9c78446ad4cf41f5f8510a7cee59ff966/src%2Ftest%2Frustdoc-ui%2Finvalid-html-self-closing-tag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/126dbdc9c78446ad4cf41f5f8510a7cee59ff966/src%2Ftest%2Frustdoc-ui%2Finvalid-html-self-closing-tag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Finvalid-html-self-closing-tag.rs?ref=126dbdc9c78446ad4cf41f5f8510a7cee59ff966", "patch": "@@ -0,0 +1,70 @@\n+#![deny(rustdoc::invalid_html_tags)]\n+\n+/// <p/>\n+//~^ ERROR invalid self-closing HTML tag `p`\n+pub struct A;\n+\n+/// <p style/>\n+//~^ ERROR invalid self-closing HTML tag `p`\n+pub struct B;\n+\n+/// <p style=\"\"/>\n+//~^ ERROR invalid self-closing HTML tag `p`\n+pub struct C;\n+\n+/// <p style=\"x\"/>\n+//~^ ERROR invalid self-closing HTML tag `p`\n+pub struct D;\n+\n+/// <p style=\"x/></p>\n+//~^ ERROR unclosed quoted HTML attribute\n+pub struct E;\n+\n+/// <p style='x/></p>\n+//~^ ERROR unclosed quoted HTML attribute\n+pub struct F;\n+\n+/// <p style=\"x/\"></p>\n+pub struct G;\n+\n+/// <p style=\"x/\"/>\n+//~^ ERROR invalid self-closing HTML tag `p`\n+pub struct H;\n+\n+/// <p / >\n+//~^ ERROR invalid self-closing HTML tag `p`\n+pub struct I;\n+\n+/// <br/>\n+pub struct J;\n+\n+/// <a href=/></a>\n+pub struct K;\n+\n+/// <a href=//></a>\n+pub struct L;\n+\n+/// <a href=\"/\"/>\n+//~^ ERROR invalid self-closing HTML tag `a`\n+pub struct M;\n+\n+/// <a href=x />\n+//~^ ERROR invalid self-closing HTML tag `a`\n+pub struct N;\n+\n+/// <a href= />\n+//~^ ERROR invalid self-closing HTML tag `a`\n+pub struct O;\n+\n+/// <a href=x/></a>\n+pub struct P;\n+\n+/// <svg><rect width=1 height=1 /></svg>\n+pub struct Q;\n+\n+/// <svg><rect width=1 height=/></svg>\n+//~^ ERROR unclosed HTML tag `rect`\n+pub struct R;\n+\n+/// <svg / q>\n+pub struct S;"}, {"sha": "e45edfb43ff8e7f1c481014a85e5de3a0447a461", "filename": "src/test/rustdoc-ui/invalid-html-self-closing-tag.stderr", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/126dbdc9c78446ad4cf41f5f8510a7cee59ff966/src%2Ftest%2Frustdoc-ui%2Finvalid-html-self-closing-tag.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/126dbdc9c78446ad4cf41f5f8510a7cee59ff966/src%2Ftest%2Frustdoc-ui%2Finvalid-html-self-closing-tag.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Finvalid-html-self-closing-tag.stderr?ref=126dbdc9c78446ad4cf41f5f8510a7cee59ff966", "patch": "@@ -0,0 +1,80 @@\n+error: invalid self-closing HTML tag `p`\n+  --> $DIR/invalid-html-self-closing-tag.rs:3:5\n+   |\n+LL | /// <p/>\n+   |     ^^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/invalid-html-self-closing-tag.rs:1:9\n+   |\n+LL | #![deny(rustdoc::invalid_html_tags)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: invalid self-closing HTML tag `p`\n+  --> $DIR/invalid-html-self-closing-tag.rs:7:5\n+   |\n+LL | /// <p style/>\n+   |     ^^\n+\n+error: invalid self-closing HTML tag `p`\n+  --> $DIR/invalid-html-self-closing-tag.rs:11:5\n+   |\n+LL | /// <p style=\"\"/>\n+   |     ^^\n+\n+error: invalid self-closing HTML tag `p`\n+  --> $DIR/invalid-html-self-closing-tag.rs:15:5\n+   |\n+LL | /// <p style=\"x\"/>\n+   |     ^^\n+\n+error: unclosed quoted HTML attribute on tag `p`\n+  --> $DIR/invalid-html-self-closing-tag.rs:19:14\n+   |\n+LL | /// <p style=\"x/></p>\n+   |              ^\n+\n+error: unclosed quoted HTML attribute on tag `p`\n+  --> $DIR/invalid-html-self-closing-tag.rs:23:14\n+   |\n+LL | /// <p style='x/></p>\n+   |              ^\n+\n+error: invalid self-closing HTML tag `p`\n+  --> $DIR/invalid-html-self-closing-tag.rs:30:5\n+   |\n+LL | /// <p style=\"x/\"/>\n+   |     ^^\n+\n+error: invalid self-closing HTML tag `p`\n+  --> $DIR/invalid-html-self-closing-tag.rs:34:5\n+   |\n+LL | /// <p / >\n+   |     ^^\n+\n+error: invalid self-closing HTML tag `a`\n+  --> $DIR/invalid-html-self-closing-tag.rs:47:5\n+   |\n+LL | /// <a href=\"/\"/>\n+   |     ^^\n+\n+error: invalid self-closing HTML tag `a`\n+  --> $DIR/invalid-html-self-closing-tag.rs:51:5\n+   |\n+LL | /// <a href=x />\n+   |     ^^\n+\n+error: invalid self-closing HTML tag `a`\n+  --> $DIR/invalid-html-self-closing-tag.rs:55:5\n+   |\n+LL | /// <a href= />\n+   |     ^^\n+\n+error: unclosed HTML tag `rect`\n+  --> $DIR/invalid-html-self-closing-tag.rs:65:10\n+   |\n+LL | /// <svg><rect width=1 height=/></svg>\n+   |          ^^^^^\n+\n+error: aborting due to 12 previous errors\n+"}, {"sha": "a473e467473eb3fc4ea89f6661a4673b569b9d81", "filename": "src/test/rustdoc/async-trait.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/126dbdc9c78446ad4cf41f5f8510a7cee59ff966/src%2Ftest%2Frustdoc%2Fasync-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/126dbdc9c78446ad4cf41f5f8510a7cee59ff966/src%2Ftest%2Frustdoc%2Fasync-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fasync-trait.rs?ref=126dbdc9c78446ad4cf41f5f8510a7cee59ff966", "patch": "@@ -0,0 +1,16 @@\n+// aux-build:async-trait-dep.rs\n+// edition:2021\n+\n+#![feature(async_fn_in_trait)]\n+#![allow(incomplete_features)]\n+\n+extern crate async_trait_dep;\n+\n+pub struct Oink {}\n+\n+// @has 'async_trait/struct.Oink.html' '//h4[@class=\"code-header\"]' \"async fn woof()\"\n+impl async_trait_dep::Meow for Oink {\n+    async fn woof() {\n+        todo!()\n+    }\n+}"}, {"sha": "10a55dd0260efaf2fddf675c92ce12cd5e27b75b", "filename": "src/test/rustdoc/auxiliary/async-trait-dep.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/126dbdc9c78446ad4cf41f5f8510a7cee59ff966/src%2Ftest%2Frustdoc%2Fauxiliary%2Fasync-trait-dep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/126dbdc9c78446ad4cf41f5f8510a7cee59ff966/src%2Ftest%2Frustdoc%2Fauxiliary%2Fasync-trait-dep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fauxiliary%2Fasync-trait-dep.rs?ref=126dbdc9c78446ad4cf41f5f8510a7cee59ff966", "patch": "@@ -0,0 +1,9 @@\n+// edition:2021\n+\n+#![feature(async_fn_in_trait)]\n+#![allow(incomplete_features)]\n+\n+pub trait Meow {\n+    /// Who's a good dog?\n+    async fn woof();\n+}"}, {"sha": "a7b872fe4444aecd4317b3671d8c58125d1a7549", "filename": "src/test/ui/async-await/async-fn-nonsend.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/126dbdc9c78446ad4cf41f5f8510a7cee59ff966/src%2Ftest%2Fui%2Fasync-await%2Fasync-fn-nonsend.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/126dbdc9c78446ad4cf41f5f8510a7cee59ff966/src%2Ftest%2Fui%2Fasync-await%2Fasync-fn-nonsend.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fasync-fn-nonsend.stderr?ref=126dbdc9c78446ad4cf41f5f8510a7cee59ff966", "patch": "@@ -27,7 +27,7 @@ error: future cannot be sent between threads safely\n LL |     assert_send(non_sync_with_method_call());\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^ future returned by `non_sync_with_method_call` is not `Send`\n    |\n-   = help: the trait `Send` is not implemented for `dyn std::fmt::Write`\n+   = help: within `impl Future<Output = ()>`, the trait `Send` is not implemented for `dyn std::fmt::Write`\n note: future is not `Send` as this value is used across an await\n   --> $DIR/async-fn-nonsend.rs:46:14\n    |"}]}