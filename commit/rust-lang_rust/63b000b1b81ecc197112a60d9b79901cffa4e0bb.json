{"sha": "63b000b1b81ecc197112a60d9b79901cffa4e0bb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYzYjAwMGIxYjgxZWNjMTk3MTEyYTYwZDliNzk5MDFjZmZhNGUwYmI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-05-16T12:29:31Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-05-16T12:29:31Z"}, "message": "Auto merge of #25444 - nikomatsakis:macro-tt-fix, r=pnkfelix\n\nPermit token trees, identifiers, and blocks to be following by sequences.\r\n\r\nFixes #25436.\r\n\r\nr? @pnkfelix", "tree": {"sha": "219ad12a028f4aea837e397dc2730e27e531c763", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/219ad12a028f4aea837e397dc2730e27e531c763"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/63b000b1b81ecc197112a60d9b79901cffa4e0bb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/63b000b1b81ecc197112a60d9b79901cffa4e0bb", "html_url": "https://github.com/rust-lang/rust/commit/63b000b1b81ecc197112a60d9b79901cffa4e0bb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/63b000b1b81ecc197112a60d9b79901cffa4e0bb/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8fdb3a4ad902162f3f6809e007a79342c2ce19db", "url": "https://api.github.com/repos/rust-lang/rust/commits/8fdb3a4ad902162f3f6809e007a79342c2ce19db", "html_url": "https://github.com/rust-lang/rust/commit/8fdb3a4ad902162f3f6809e007a79342c2ce19db"}, {"sha": "7a5d74828bf6350c72f0330d7799e0cccd2e968f", "url": "https://api.github.com/repos/rust-lang/rust/commits/7a5d74828bf6350c72f0330d7799e0cccd2e968f", "html_url": "https://github.com/rust-lang/rust/commit/7a5d74828bf6350c72f0330d7799e0cccd2e968f"}], "stats": {"total": 207, "additions": 173, "deletions": 34}, "files": [{"sha": "febfc7a97fe3dc8c1f389febfbb5d8e4462c5488", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 78, "deletions": 34, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/63b000b1b81ecc197112a60d9b79901cffa4e0bb/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63b000b1b81ecc197112a60d9b79901cffa4e0bb/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=63b000b1b81ecc197112a60d9b79901cffa4e0bb", "patch": "@@ -325,42 +325,55 @@ fn check_matcher<'a, I>(cx: &mut ExtCtxt, matcher: I, follow: &Token)\n         last = match *token {\n             TtToken(sp, MatchNt(ref name, ref frag_spec, _, _)) => {\n                 // ii. If T is a simple NT, look ahead to the next token T' in\n-                // M.\n-                let next_token = match tokens.peek() {\n-                    // If T' closes a complex NT, replace T' with F\n-                    Some(&&TtToken(_, CloseDelim(_))) => follow.clone(),\n-                    Some(&&TtToken(_, ref tok)) => tok.clone(),\n-                    Some(&&TtSequence(sp, _)) => {\n-                        cx.span_err(sp,\n-                                    &format!(\"`${0}:{1}` is followed by a \\\n-                                              sequence repetition, which is not \\\n-                                              allowed for `{1}` fragments\",\n-                                             name.as_str(), frag_spec.as_str())\n+                // M. If T' is in the set FOLLOW(NT), continue. Else; reject.\n+                if can_be_followed_by_any(frag_spec.as_str()) {\n+                    continue\n+                } else {\n+                    let next_token = match tokens.peek() {\n+                        // If T' closes a complex NT, replace T' with F\n+                        Some(&&TtToken(_, CloseDelim(_))) => follow.clone(),\n+                        Some(&&TtToken(_, ref tok)) => tok.clone(),\n+                        Some(&&TtSequence(sp, _)) => {\n+                            // Be conservative around sequences: to be\n+                            // more specific, we would need to\n+                            // consider FIRST sets, but also the\n+                            // possibility that the sequence occurred\n+                            // zero times (in which case we need to\n+                            // look at the token that follows the\n+                            // sequence, which may itself a sequence,\n+                            // and so on).\n+                            cx.span_err(sp,\n+                                        &format!(\"`${0}:{1}` is followed by a \\\n+                                                  sequence repetition, which is not \\\n+                                                  allowed for `{1}` fragments\",\n+                                                 name.as_str(), frag_spec.as_str())\n                                         );\n-                        Eof\n-                    },\n-                    // die next iteration\n-                    Some(&&TtDelimited(_, ref delim)) => delim.close_token(),\n-                    // else, we're at the end of the macro or sequence\n-                    None => follow.clone()\n-                };\n-\n-                let tok = if let TtToken(_, ref tok) = *token { tok } else { unreachable!() };\n-                // If T' is in the set FOLLOW(NT), continue. Else, reject.\n-                match (&next_token, is_in_follow(cx, &next_token, frag_spec.as_str())) {\n-                    (_, Err(msg)) => {\n-                        cx.span_err(sp, &msg);\n-                        continue\n+                            Eof\n+                        },\n+                        // die next iteration\n+                        Some(&&TtDelimited(_, ref delim)) => delim.close_token(),\n+                        // else, we're at the end of the macro or sequence\n+                        None => follow.clone()\n+                    };\n+\n+                    let tok = if let TtToken(_, ref tok) = *token { tok } else { unreachable!() };\n+\n+                    // If T' is in the set FOLLOW(NT), continue. Else, reject.\n+                    match (&next_token, is_in_follow(cx, &next_token, frag_spec.as_str())) {\n+                        (_, Err(msg)) => {\n+                            cx.span_err(sp, &msg);\n+                            continue\n+                        }\n+                        (&Eof, _) => return Some((sp, tok.clone())),\n+                        (_, Ok(true)) => continue,\n+                        (next, Ok(false)) => {\n+                            cx.span_err(sp, &format!(\"`${0}:{1}` is followed by `{2}`, which \\\n+                                                      is not allowed for `{1}` fragments\",\n+                                                     name.as_str(), frag_spec.as_str(),\n+                                                     token_to_string(next)));\n+                            continue\n+                        },\n                     }\n-                    (&Eof, _) => return Some((sp, tok.clone())),\n-                    (_, Ok(true)) => continue,\n-                    (next, Ok(false)) => {\n-                        cx.span_err(sp, &format!(\"`${0}:{1}` is followed by `{2}`, which \\\n-                                                  is not allowed for `{1}` fragments\",\n-                                                 name.as_str(), frag_spec.as_str(),\n-                                                 token_to_string(next)));\n-                        continue\n-                    },\n                 }\n             },\n             TtSequence(sp, ref seq) => {\n@@ -427,8 +440,39 @@ fn check_matcher<'a, I>(cx: &mut ExtCtxt, matcher: I, follow: &Token)\n     last\n }\n \n+/// True if a fragment of type `frag` can be followed by any sort of\n+/// token.  We use this (among other things) as a useful approximation\n+/// for when `frag` can be followed by a repetition like `$(...)*` or\n+/// `$(...)+`. In general, these can be a bit tricky to reason about,\n+/// so we adopt a conservative position that says that any fragment\n+/// specifier which consumes at most one token tree can be followed by\n+/// a fragment specifier (indeed, these fragments can be followed by\n+/// ANYTHING without fear of future compatibility hazards).\n+fn can_be_followed_by_any(frag: &str) -> bool {\n+    match frag {\n+        \"item\" |  // always terminated by `}` or `;`\n+        \"block\" | // exactly one token tree\n+        \"ident\" | // exactly one token tree\n+        \"meta\" |  // exactly one token tree\n+        \"tt\" =>    // exactly one token tree\n+            true,\n+\n+        _ =>\n+            false,\n+    }\n+}\n+\n+/// True if `frag` can legally be followed by the token `tok`. For\n+/// fragments that can consume an unbounded numbe of tokens, `tok`\n+/// must be within a well-defined follow set. This is intended to\n+/// guarantee future compatibility: for example, without this rule, if\n+/// we expanded `expr` to include a new binary operator, we might\n+/// break macros that were relying on that binary operator as a\n+/// separator.\n fn is_in_follow(_: &ExtCtxt, tok: &Token, frag: &str) -> Result<bool, String> {\n     if let &CloseDelim(_) = tok {\n+        // closing a token tree can never be matched by any fragment;\n+        // iow, we always require that `(` and `)` match, etc.\n         Ok(true)\n     } else {\n         match frag {"}, {"sha": "0ee2221bbc14b9658c9f5010c94be25821b54f7b", "filename": "src/test/compile-fail/macro-followed-by-seq-bad.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/63b000b1b81ecc197112a60d9b79901cffa4e0bb/src%2Ftest%2Fcompile-fail%2Fmacro-followed-by-seq-bad.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63b000b1b81ecc197112a60d9b79901cffa4e0bb/src%2Ftest%2Fcompile-fail%2Fmacro-followed-by-seq-bad.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-followed-by-seq-bad.rs?ref=63b000b1b81ecc197112a60d9b79901cffa4e0bb", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Regression test for issue #25436: check that things which can be\n+// followed by any token also permit X* to come afterwards.\n+\n+macro_rules! foo {\n+  ( $a:expr $($b:tt)* ) => { }; //~ ERROR not allowed for `expr` fragments\n+  ( $a:ty $($b:tt)* ) => { };   //~ ERROR not allowed for `ty` fragments\n+}\n+\n+fn main() { }"}, {"sha": "b4f71343d546afba29b2aa1b4a680d29b3118a19", "filename": "src/test/compile-fail/macro-seq-followed-by-seq.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/63b000b1b81ecc197112a60d9b79901cffa4e0bb/src%2Ftest%2Fcompile-fail%2Fmacro-seq-followed-by-seq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63b000b1b81ecc197112a60d9b79901cffa4e0bb/src%2Ftest%2Fcompile-fail%2Fmacro-seq-followed-by-seq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-seq-followed-by-seq.rs?ref=63b000b1b81ecc197112a60d9b79901cffa4e0bb", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Check that we cannot have two sequence repetitions in a row.\n+\n+macro_rules! foo {\n+  ( $($a:expr)* $($b:tt)* ) => { }; //~ ERROR sequence repetition followed by another sequence\n+  ( $($a:tt)* $($b:tt)* ) => { }; //~ ERROR sequence repetition followed by another sequence\n+}\n+\n+fn main() { }"}, {"sha": "15224930b8465bf9662ad167c8719b65ebdf1555", "filename": "src/test/run-pass/macro-followed-by-seq.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/63b000b1b81ecc197112a60d9b79901cffa4e0bb/src%2Ftest%2Frun-pass%2Fmacro-followed-by-seq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63b000b1b81ecc197112a60d9b79901cffa4e0bb/src%2Ftest%2Frun-pass%2Fmacro-followed-by-seq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-followed-by-seq.rs?ref=63b000b1b81ecc197112a60d9b79901cffa4e0bb", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Regression test for issue #25436: check that things which can be\n+// followed by any token also permit X* to come afterwards.\n+\n+macro_rules! foo {\n+  ( $a:tt $($b:tt)* ) => { };\n+  ( $a:ident $($b:tt)* ) => { };\n+  ( $a:item $($b:tt)* ) => { };\n+  ( $a:block $($b:tt)* ) => { };\n+  ( $a:meta $($b:tt)* ) => { }\n+}\n+\n+fn main() { }"}, {"sha": "cdb1f86aea50b234d72199a47aecfa7e9b56cf2e", "filename": "src/test/run-pass/macro-tt-followed-by-seq.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/63b000b1b81ecc197112a60d9b79901cffa4e0bb/src%2Ftest%2Frun-pass%2Fmacro-tt-followed-by-seq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63b000b1b81ecc197112a60d9b79901cffa4e0bb/src%2Ftest%2Frun-pass%2Fmacro-tt-followed-by-seq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-tt-followed-by-seq.rs?ref=63b000b1b81ecc197112a60d9b79901cffa4e0bb", "patch": "@@ -0,0 +1,36 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Regression test for issue #25436: permit token-trees to be followed\n+// by sequences, enabling more general parsing.\n+\n+use self::Join::*;\n+\n+#[derive(Debug)]\n+enum Join<A,B> {\n+  Keep(A,B),\n+  Skip(A,B),\n+}\n+\n+macro_rules! parse_list {\n+  ( < $a:expr; > $($b:tt)* ) => { Keep(parse_item!($a),parse_list!($($b)*)) };\n+  ( $a:tt $($b:tt)* ) => { Skip(parse_item!($a), parse_list!($($b)*)) };\n+  ( ) => { () };\n+}\n+\n+macro_rules! parse_item {\n+  ( $x:expr ) => { $x }\n+}\n+\n+fn main() {\n+    let list = parse_list!(<1;> 2 <3;> 4);\n+    assert_eq!(\"Keep(1, Skip(2, Keep(3, Skip(4, ()))))\",\n+               format!(\"{:?}\", list));\n+}"}]}