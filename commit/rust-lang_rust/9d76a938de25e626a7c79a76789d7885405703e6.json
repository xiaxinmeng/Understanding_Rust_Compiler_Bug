{"sha": "9d76a938de25e626a7c79a76789d7885405703e6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlkNzZhOTM4ZGUyNWU2MjZhN2M3OWE3Njc4OWQ3ODg1NDA1NzAzZTY=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-08-10T13:27:31Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-08-10T13:27:31Z"}, "message": "Rollup merge of #63400 - petrochenkov:resplit, r=eddyb\n\nTry to break resolve into more isolated parts\n\nSome small step towards resolve librarification.\n\n\"Late resolution\" is the pass that resolves most of names in a crate beside imports and macros.\nIt runs when the crate is fully expanded and its module structure is fully built.\nSo we just walk through the crate and resolve all the expressions, types, etc.\n\nThis pass is pretty self-contained, but it was previously done by implementing `Visitor` on the whole `Resolver` (which is used for many other tasks), and fields specific to this pass were indiscernible from the global `Resolver` state.\n\nThis PR moves the late resolution pass into a separate visitor and a separate file, fields specific to this visitor are moved from `Resolver` as well.\n\nI'm especially happy about `current_module` being removed from `Resolver`.\nIt was used even for operations not related to visiting and changing the `current_module` position in process.\nIt was also used as an implicit argument for some functions used in this style\n```rust\nlet orig_current_module = mem::replace(&mut self.current_module, module);\nself.resolve_ident_somewhere();\nself.current_module = orig_current_module;\n```\nand having effects on e.g. privacy checking somewhere deeply inside `resolve_ident_somewhere`.\nNow we explicitly pass a `ParentScope` to those functions instead, which includes the module and some other data describing our position in the crate relatively to which we resolve names.\n\nRustdoc was one of the users of `current_module`, it set it for resolving intra-doc links.\nNow it passes it explicitly as an argument as well (I also supported resolving paths from rustdoc in unnamed blocks as a drive-by fix).\n\nVisibility resolution is also changed to use early resolution (which is correct because it's used during the work of `BuildReducedGraphVisitor`, i.e. integration of a new AST fragment into the existing partially built module structures.) instead of untimely late resolution (which worked only due to restrictions on paths in visibilities like inability to refer to anything except ancestor modules).\nThis slightly regresses its diagnostics because late resolution has a more systematic error detection and recovery currently.\nDue to changes in `current_module` and visibilities `BuildReducedGraphVisitor` ended up almost as heavily affected by this refactoring as late resolution.\n\nFixes https://github.com/rust-lang/rust/issues/63223 (due to visibility resolution changes).", "tree": {"sha": "196041ea3bd88ba5be92a406a53d3ba6a40a24bc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/196041ea3bd88ba5be92a406a53d3ba6a40a24bc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9d76a938de25e626a7c79a76789d7885405703e6", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdTsZECRBK7hj4Ov3rIwAAdHIIAAzgEc6yYaNs+ugRXCeJpzi7\n5HW6SgSNODX1w1Mag1NFveAMOw82FLDgqHC8tld/iesVCq+SWwYxejXTJnKfuNAX\nsd4RsKZcA2XrD3w4CUgAHJmFqzFM0ksvpeOUhqQ6lTC/hOnrFSjsc+4rAaDwGIWD\nZRdYmD8cJLgiRqtKgiZl88cPu/6LSCoowcRP79oRSISmCCD/dgFLR2HPvmhJRIy1\nQUbvLRVvTt0fIyY8yQqkSsI1WJSx9wzIImX/RPByQy6SXsKzaP4FrpY4e3O+5dmV\n1JFRCo5e7OEQmus4aDeFboCeKKpNG6d++pHxZLjPP5ziShuTYWoZ1MottIlUasI=\n=VsDd\n-----END PGP SIGNATURE-----\n", "payload": "tree 196041ea3bd88ba5be92a406a53d3ba6a40a24bc\nparent d19a359444295bab01de7ff44a9d72302e573bc9\nparent 319f0debd4c4bbd5f0dbd13ba87362c6cccd5e66\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1565443651 +0200\ncommitter GitHub <noreply@github.com> 1565443651 +0200\n\nRollup merge of #63400 - petrochenkov:resplit, r=eddyb\n\nTry to break resolve into more isolated parts\n\nSome small step towards resolve librarification.\n\n\"Late resolution\" is the pass that resolves most of names in a crate beside imports and macros.\nIt runs when the crate is fully expanded and its module structure is fully built.\nSo we just walk through the crate and resolve all the expressions, types, etc.\n\nThis pass is pretty self-contained, but it was previously done by implementing `Visitor` on the whole `Resolver` (which is used for many other tasks), and fields specific to this pass were indiscernible from the global `Resolver` state.\n\nThis PR moves the late resolution pass into a separate visitor and a separate file, fields specific to this visitor are moved from `Resolver` as well.\n\nI'm especially happy about `current_module` being removed from `Resolver`.\nIt was used even for operations not related to visiting and changing the `current_module` position in process.\nIt was also used as an implicit argument for some functions used in this style\n```rust\nlet orig_current_module = mem::replace(&mut self.current_module, module);\nself.resolve_ident_somewhere();\nself.current_module = orig_current_module;\n```\nand having effects on e.g. privacy checking somewhere deeply inside `resolve_ident_somewhere`.\nNow we explicitly pass a `ParentScope` to those functions instead, which includes the module and some other data describing our position in the crate relatively to which we resolve names.\n\nRustdoc was one of the users of `current_module`, it set it for resolving intra-doc links.\nNow it passes it explicitly as an argument as well (I also supported resolving paths from rustdoc in unnamed blocks as a drive-by fix).\n\nVisibility resolution is also changed to use early resolution (which is correct because it's used during the work of `BuildReducedGraphVisitor`, i.e. integration of a new AST fragment into the existing partially built module structures.) instead of untimely late resolution (which worked only due to restrictions on paths in visibilities like inability to refer to anything except ancestor modules).\nThis slightly regresses its diagnostics because late resolution has a more systematic error detection and recovery currently.\nDue to changes in `current_module` and visibilities `BuildReducedGraphVisitor` ended up almost as heavily affected by this refactoring as late resolution.\n\nFixes https://github.com/rust-lang/rust/issues/63223 (due to visibility resolution changes).\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9d76a938de25e626a7c79a76789d7885405703e6", "html_url": "https://github.com/rust-lang/rust/commit/9d76a938de25e626a7c79a76789d7885405703e6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9d76a938de25e626a7c79a76789d7885405703e6/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d19a359444295bab01de7ff44a9d72302e573bc9", "url": "https://api.github.com/repos/rust-lang/rust/commits/d19a359444295bab01de7ff44a9d72302e573bc9", "html_url": "https://github.com/rust-lang/rust/commit/d19a359444295bab01de7ff44a9d72302e573bc9"}, {"sha": "319f0debd4c4bbd5f0dbd13ba87362c6cccd5e66", "url": "https://api.github.com/repos/rust-lang/rust/commits/319f0debd4c4bbd5f0dbd13ba87362c6cccd5e66", "html_url": "https://github.com/rust-lang/rust/commit/319f0debd4c4bbd5f0dbd13ba87362c6cccd5e66"}], "stats": {"total": 7866, "additions": 3982, "deletions": 3884}, "files": [{"sha": "42acbd1106b6bb3daecdf6c9569b70f85d51193c", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9d76a938de25e626a7c79a76789d7885405703e6/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d76a938de25e626a7c79a76789d7885405703e6/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=9d76a938de25e626a7c79a76789d7885405703e6", "patch": "@@ -37,7 +37,7 @@ use crate::hir::{self, ParamName};\n use crate::hir::HirVec;\n use crate::hir::map::{DefKey, DefPathData, Definitions};\n use crate::hir::def_id::{DefId, DefIndex, CRATE_DEF_INDEX};\n-use crate::hir::def::{Res, DefKind, PartialRes, PerNS};\n+use crate::hir::def::{Namespace, Res, DefKind, PartialRes, PerNS};\n use crate::hir::{GenericArg, ConstArg};\n use crate::hir::ptr::P;\n use crate::lint::builtin::{self, PARENTHESIZED_PARAMS_IN_TYPES_AND_MODULES,\n@@ -148,13 +148,6 @@ pub struct LoweringContext<'a> {\n }\n \n pub trait Resolver {\n-    /// Resolve a path generated by the lowerer when expanding `for`, `if let`, etc.\n-    fn resolve_ast_path(\n-        &mut self,\n-        path: &ast::Path,\n-        is_value: bool,\n-    ) -> Res<NodeId>;\n-\n     /// Obtain resolution for a `NodeId` with a single resolution.\n     fn get_partial_res(&mut self, id: NodeId) -> Option<PartialRes>;\n \n@@ -175,7 +168,7 @@ pub trait Resolver {\n         span: Span,\n         crate_root: Option<Symbol>,\n         components: &[Symbol],\n-        is_value: bool,\n+        ns: Namespace,\n     ) -> (ast::Path, Res<NodeId>);\n \n     fn has_derives(&self, node_id: NodeId, derives: SpecialDerives) -> bool;\n@@ -5717,8 +5710,8 @@ impl<'a> LoweringContext<'a> {\n         params: Option<P<hir::GenericArgs>>,\n         is_value: bool,\n     ) -> hir::Path {\n-        let (path, res) = self.resolver\n-            .resolve_str_path(span, self.crate_root, components, is_value);\n+        let ns = if is_value { Namespace::ValueNS } else { Namespace::TypeNS };\n+        let (path, res) = self.resolver.resolve_str_path(span, self.crate_root, components, ns);\n \n         let mut segments: Vec<_> = path.segments.iter().map(|segment| {\n             let res = self.expect_full_res(segment.id);"}, {"sha": "6e5750e752e9409b81f5190913a38dc39a466e61", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 480, "deletions": 270, "changes": 750, "blob_url": "https://github.com/rust-lang/rust/blob/9d76a938de25e626a7c79a76789d7885405703e6/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d76a938de25e626a7c79a76789d7885405703e6/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=9d76a938de25e626a7c79a76789d7885405703e6", "patch": "@@ -3,13 +3,13 @@\n //! Here we build the \"reduced graph\": the graph of the module tree without\n //! any imports resolved.\n \n-use crate::macros::{InvocationData, LegacyScope};\n+use crate::macros::{InvocationData, LegacyBinding, LegacyScope};\n use crate::resolve_imports::ImportDirective;\n use crate::resolve_imports::ImportDirectiveSubclass::{self, GlobImport, SingleImport};\n use crate::{Module, ModuleData, ModuleKind, NameBinding, NameBindingKind, Segment, ToNameBinding};\n use crate::{ModuleOrUniformRoot, ParentScope, PerNS, Resolver, ResolverArenas, ExternPreludeEntry};\n use crate::Namespace::{self, TypeNS, ValueNS, MacroNS};\n-use crate::{resolve_error, resolve_struct_error, ResolutionError, Determinacy};\n+use crate::{ResolutionError, Determinacy, PathResult, CrateLint};\n \n use rustc::bug;\n use rustc::hir::def::{self, *};\n@@ -29,11 +29,11 @@ use syntax::attr;\n \n use syntax::ast::{self, Block, ForeignItem, ForeignItemKind, Item, ItemKind, NodeId};\n use syntax::ast::{MetaItemKind, StmtKind, TraitItem, TraitItemKind, Variant};\n-use syntax::ext::base::SyntaxExtension;\n+use syntax::ext::base::{MacroKind, SyntaxExtension};\n use syntax::ext::hygiene::ExpnId;\n use syntax::feature_gate::is_builtin_attr;\n use syntax::parse::token::{self, Token};\n-use syntax::span_err;\n+use syntax::{span_err, struct_span_err};\n use syntax::symbol::{kw, sym};\n use syntax::visit::{self, Visitor};\n \n@@ -93,6 +93,195 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n+    pub fn get_module(&mut self, def_id: DefId) -> Module<'a> {\n+        if def_id.krate == LOCAL_CRATE {\n+            return self.module_map[&def_id]\n+        }\n+\n+        let macros_only = self.cstore.dep_kind_untracked(def_id.krate).macros_only();\n+        if let Some(&module) = self.extern_module_map.get(&(def_id, macros_only)) {\n+            return module;\n+        }\n+\n+        let (name, parent) = if def_id.index == CRATE_DEF_INDEX {\n+            (self.cstore.crate_name_untracked(def_id.krate).as_interned_str(), None)\n+        } else {\n+            let def_key = self.cstore.def_key(def_id);\n+            (def_key.disambiguated_data.data.get_opt_name().unwrap(),\n+             Some(self.get_module(DefId { index: def_key.parent.unwrap(), ..def_id })))\n+        };\n+\n+        let kind = ModuleKind::Def(DefKind::Mod, def_id, name.as_symbol());\n+        let module = self.arenas.alloc_module(ModuleData::new(\n+            parent, kind, def_id, ExpnId::root(), DUMMY_SP\n+        ));\n+        self.extern_module_map.insert((def_id, macros_only), module);\n+        module\n+    }\n+\n+    pub fn macro_def_scope(&mut self, expn_id: ExpnId) -> Module<'a> {\n+        let def_id = match self.macro_defs.get(&expn_id) {\n+            Some(def_id) => *def_id,\n+            None => return self.graph_root,\n+        };\n+        if let Some(id) = self.definitions.as_local_node_id(def_id) {\n+            self.local_macro_def_scopes[&id]\n+        } else if self.is_builtin_macro(Some(def_id)) {\n+            self.injected_crate.unwrap_or(self.graph_root)\n+        } else {\n+            let module_def_id = ty::DefIdTree::parent(&*self, def_id).unwrap();\n+            self.get_module(module_def_id)\n+        }\n+    }\n+\n+    crate fn get_macro(&mut self, res: Res) -> Option<Lrc<SyntaxExtension>> {\n+        match res {\n+            Res::Def(DefKind::Macro(..), def_id) => self.get_macro_by_def_id(def_id),\n+            Res::NonMacroAttr(attr_kind) =>\n+                Some(self.non_macro_attr(attr_kind == NonMacroAttrKind::Tool)),\n+            _ => None,\n+        }\n+    }\n+\n+    crate fn get_macro_by_def_id(&mut self, def_id: DefId) -> Option<Lrc<SyntaxExtension>> {\n+        if let Some(ext) = self.macro_map.get(&def_id) {\n+            return Some(ext.clone());\n+        }\n+\n+        let macro_def = match self.cstore.load_macro_untracked(def_id, &self.session) {\n+            LoadedMacro::MacroDef(macro_def) => macro_def,\n+            LoadedMacro::ProcMacro(ext) => return Some(ext),\n+        };\n+\n+        let ext = self.compile_macro(&macro_def, self.cstore.crate_edition_untracked(def_id.krate));\n+        self.macro_map.insert(def_id, ext.clone());\n+        Some(ext)\n+    }\n+\n+    /// Ensures that the reduced graph rooted at the given external module\n+    /// is built, building it if it is not.\n+    pub fn populate_module_if_necessary(&mut self, module: Module<'a>) {\n+        if module.populated.get() { return }\n+        let def_id = module.def_id().unwrap();\n+        for child in self.cstore.item_children_untracked(def_id, self.session) {\n+            let child = child.map_id(|_| panic!(\"unexpected id\"));\n+            BuildReducedGraphVisitor { parent_scope: self.dummy_parent_scope(), r: self }\n+                .build_reduced_graph_for_external_crate_res(module, child);\n+        }\n+        module.populated.set(true)\n+    }\n+}\n+\n+pub struct BuildReducedGraphVisitor<'a, 'b> {\n+    pub r: &'b mut Resolver<'a>,\n+    pub parent_scope: ParentScope<'a>,\n+}\n+\n+impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n+    fn resolve_visibility(&mut self, vis: &ast::Visibility) -> ty::Visibility {\n+        let parent_scope = &self.parent_scope;\n+        match vis.node {\n+            ast::VisibilityKind::Public => ty::Visibility::Public,\n+            ast::VisibilityKind::Crate(..) => {\n+                ty::Visibility::Restricted(DefId::local(CRATE_DEF_INDEX))\n+            }\n+            ast::VisibilityKind::Inherited => {\n+                ty::Visibility::Restricted(parent_scope.module.normal_ancestor_id)\n+            }\n+            ast::VisibilityKind::Restricted { ref path, id, .. } => {\n+                // For visibilities we are not ready to provide correct implementation of \"uniform\n+                // paths\" right now, so on 2018 edition we only allow module-relative paths for now.\n+                // On 2015 edition visibilities are resolved as crate-relative by default,\n+                // so we are prepending a root segment if necessary.\n+                let ident = path.segments.get(0).expect(\"empty path in visibility\").ident;\n+                let crate_root = if ident.is_path_segment_keyword() {\n+                    None\n+                } else if ident.span.rust_2018() {\n+                    let msg = \"relative paths are not supported in visibilities on 2018 edition\";\n+                    self.r.session.struct_span_err(ident.span, msg)\n+                        .span_suggestion(\n+                            path.span,\n+                            \"try\",\n+                            format!(\"crate::{}\", path),\n+                            Applicability::MaybeIncorrect,\n+                        )\n+                        .emit();\n+                    return ty::Visibility::Public;\n+                } else {\n+                    let ctxt = ident.span.ctxt();\n+                    Some(Segment::from_ident(Ident::new(\n+                        kw::PathRoot, path.span.shrink_to_lo().with_ctxt(ctxt)\n+                    )))\n+                };\n+\n+                let segments = crate_root.into_iter()\n+                    .chain(path.segments.iter().map(|seg| seg.into())).collect::<Vec<_>>();\n+                let expected_found_error = |this: &Self, res: Res| {\n+                    let path_str = Segment::names_to_string(&segments);\n+                    struct_span_err!(this.r.session, path.span, E0577,\n+                                     \"expected module, found {} `{}`\", res.descr(), path_str)\n+                        .span_label(path.span, \"not a module\").emit();\n+                };\n+                match self.r.resolve_path(\n+                    &segments,\n+                    Some(TypeNS),\n+                    parent_scope,\n+                    true,\n+                    path.span,\n+                    CrateLint::SimplePath(id),\n+                ) {\n+                    PathResult::Module(ModuleOrUniformRoot::Module(module)) => {\n+                        let res = module.res().expect(\"visibility resolved to unnamed block\");\n+                        self.r.record_partial_res(id, PartialRes::new(res));\n+                        if module.is_normal() {\n+                            if res == Res::Err {\n+                                ty::Visibility::Public\n+                            } else {\n+                                let vis = ty::Visibility::Restricted(res.def_id());\n+                                if self.r.is_accessible_from(vis, parent_scope.module) {\n+                                    vis\n+                                } else {\n+                                    let msg =\n+                                        \"visibilities can only be restricted to ancestor modules\";\n+                                    self.r.session.span_err(path.span, msg);\n+                                    ty::Visibility::Public\n+                                }\n+                            }\n+                        } else {\n+                            expected_found_error(self, res);\n+                            ty::Visibility::Public\n+                        }\n+                    }\n+                    PathResult::Module(..) => {\n+                        self.r.session.span_err(path.span, \"visibility must resolve to a module\");\n+                        ty::Visibility::Public\n+                    }\n+                    PathResult::NonModule(partial_res) => {\n+                        expected_found_error(self, partial_res.base_res());\n+                        ty::Visibility::Public\n+                    }\n+                    PathResult::Failed { span, label, suggestion, .. } => {\n+                        self.r.report_error(\n+                            span, ResolutionError::FailedToResolve { label, suggestion }\n+                        );\n+                        ty::Visibility::Public\n+                    }\n+                    PathResult::Indeterminate => {\n+                        span_err!(self.r.session, path.span, E0578,\n+                                  \"cannot determine resolution for the visibility\");\n+                        ty::Visibility::Public\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    fn insert_field_names(&mut self, def_id: DefId, field_names: Vec<Name>) {\n+        if !field_names.is_empty() {\n+            self.r.field_names.insert(def_id, field_names);\n+        }\n+    }\n+\n     fn block_needs_anonymous_module(&mut self, block: &Block) -> bool {\n         // If any statements are items, we need to create an anonymous module\n         block.stmts.iter().any(|statement| match statement.node {\n@@ -101,9 +290,51 @@ impl<'a> Resolver<'a> {\n         })\n     }\n \n-    fn insert_field_names(&mut self, def_id: DefId, field_names: Vec<Name>) {\n-        if !field_names.is_empty() {\n-            self.field_names.insert(def_id, field_names);\n+    // Add an import directive to the current module.\n+    fn add_import_directive(\n+        &mut self,\n+        module_path: Vec<Segment>,\n+        subclass: ImportDirectiveSubclass<'a>,\n+        span: Span,\n+        id: NodeId,\n+        item: &ast::Item,\n+        root_span: Span,\n+        root_id: NodeId,\n+        vis: ty::Visibility,\n+    ) {\n+        let parent_scope = &self.parent_scope;\n+        let current_module = parent_scope.module;\n+        let directive = self.r.arenas.alloc_import_directive(ImportDirective {\n+            parent_scope: parent_scope.clone(),\n+            module_path,\n+            imported_module: Cell::new(None),\n+            subclass,\n+            span,\n+            id,\n+            use_span: item.span,\n+            use_span_with_attributes: item.span_with_attributes(),\n+            has_attributes: !item.attrs.is_empty(),\n+            root_span,\n+            root_id,\n+            vis: Cell::new(vis),\n+            used: Cell::new(false),\n+        });\n+\n+        debug!(\"add_import_directive({:?})\", directive);\n+\n+        self.r.indeterminate_imports.push(directive);\n+        match directive.subclass {\n+            SingleImport { target, type_ns_only, .. } => {\n+                self.r.per_ns(|this, ns| if !type_ns_only || ns == TypeNS {\n+                    let mut resolution = this.resolution(current_module, target, ns).borrow_mut();\n+                    resolution.add_single_import(directive);\n+                });\n+            }\n+            // We don't add prelude imports to the globs since they only affect lexical scopes,\n+            // which are not relevant to import resolution.\n+            GlobImport { is_prelude: true, .. } => {}\n+            GlobImport { .. } => current_module.globs.borrow_mut().push(directive),\n+            _ => unreachable!(),\n         }\n     }\n \n@@ -115,7 +346,6 @@ impl<'a> Resolver<'a> {\n         parent_prefix: &[Segment],\n         nested: bool,\n         // The whole `use` item\n-        parent_scope: ParentScope<'a>,\n         item: &Item,\n         vis: ty::Visibility,\n         root_span: Span,\n@@ -163,8 +393,7 @@ impl<'a> Resolver<'a> {\n                         type_ns_only = true;\n \n                         if empty_for_self(&module_path) {\n-                            resolve_error(\n-                                self,\n+                            self.r.report_error(\n                                 use_tree.span,\n                                 ResolutionError::\n                                 SelfImportOnlyInImportListWithNonEmptyPrefix\n@@ -181,14 +410,14 @@ impl<'a> Resolver<'a> {\n                 } else {\n                     // Disallow `self`\n                     if source.ident.name == kw::SelfLower {\n-                        resolve_error(self,\n-                                      use_tree.span,\n-                                      ResolutionError::SelfImportsOnlyAllowedWithin);\n+                        self.r.report_error(\n+                            use_tree.span, ResolutionError::SelfImportsOnlyAllowedWithin\n+                        );\n                     }\n \n                     // Disallow `use $crate;`\n                     if source.ident.name == kw::DollarCrate && module_path.is_empty() {\n-                        let crate_root = self.resolve_crate_root(source.ident);\n+                        let crate_root = self.r.resolve_crate_root(source.ident);\n                         let crate_name = match crate_root.kind {\n                             ModuleKind::Def(.., name) => name,\n                             ModuleKind::Block(..) => unreachable!(),\n@@ -203,23 +432,23 @@ impl<'a> Resolver<'a> {\n                                     name: kw::PathRoot,\n                                     span: source.ident.span,\n                                 },\n-                                id: Some(self.session.next_node_id()),\n+                                id: Some(self.r.session.next_node_id()),\n                             });\n                             source.ident.name = crate_name;\n                         }\n                         if rename.is_none() {\n                             ident.name = crate_name;\n                         }\n \n-                        self.session.struct_span_warn(item.span, \"`$crate` may not be imported\")\n+                        self.r.session.struct_span_warn(item.span, \"`$crate` may not be imported\")\n                             .note(\"`use $crate;` was erroneously allowed and \\\n                                    will become a hard error in a future release\")\n                             .emit();\n                     }\n                 }\n \n                 if ident.name == kw::Crate {\n-                    self.session.span_err(ident.span,\n+                    self.r.session.span_err(ident.span,\n                         \"crate root imports need to be explicitly named: \\\n                          `use crate as name;`\");\n                 }\n@@ -249,7 +478,6 @@ impl<'a> Resolver<'a> {\n                     root_span,\n                     item.id,\n                     vis,\n-                    parent_scope,\n                 );\n             }\n             ast::UseTreeKind::Glob => {\n@@ -266,7 +494,6 @@ impl<'a> Resolver<'a> {\n                     root_span,\n                     item.id,\n                     vis,\n-                    parent_scope,\n                 );\n             }\n             ast::UseTreeKind::Nested(ref items) => {\n@@ -281,7 +508,7 @@ impl<'a> Resolver<'a> {\n                     None\n                 }).collect::<Vec<_>>();\n                 if self_spans.len() > 1 {\n-                    let mut e = resolve_struct_error(self,\n+                    let mut e = self.r.into_struct_error(\n                         self_spans[0],\n                         ResolutionError::SelfImportCanOnlyAppearOnceInTheList);\n \n@@ -297,7 +524,7 @@ impl<'a> Resolver<'a> {\n                         // This particular use tree\n                         tree, id, &prefix, true,\n                         // The whole `use` item\n-                        parent_scope.clone(), item, vis, root_span,\n+                        item, vis, root_span,\n                     );\n                 }\n \n@@ -321,15 +548,16 @@ impl<'a> Resolver<'a> {\n                         // This particular use tree\n                         &tree, id, &prefix, true,\n                         // The whole `use` item\n-                        parent_scope, item, ty::Visibility::Invisible, root_span,\n+                        item, ty::Visibility::Invisible, root_span,\n                     );\n                 }\n             }\n         }\n     }\n \n     /// Constructs the reduced graph for one item.\n-    fn build_reduced_graph_for_item(&mut self, item: &Item, parent_scope: ParentScope<'a>) {\n+    fn build_reduced_graph_for_item(&mut self, item: &Item) {\n+        let parent_scope = &self.parent_scope;\n         let parent = parent_scope.module;\n         let expansion = parent_scope.expansion;\n         let ident = item.ident.gensym_if_underscore();\n@@ -342,13 +570,13 @@ impl<'a> Resolver<'a> {\n                     // This particular use tree\n                     use_tree, item.id, &[], false,\n                     // The whole `use` item\n-                    parent_scope, item, vis, use_tree.span,\n+                    item, vis, use_tree.span,\n                 );\n             }\n \n             ItemKind::ExternCrate(orig_name) => {\n                 let module = if orig_name.is_none() && ident.name == kw::SelfLower {\n-                    self.session\n+                    self.r.session\n                         .struct_span_err(item.span, \"`extern crate self;` requires renaming\")\n                         .span_suggestion(\n                             item.span,\n@@ -359,26 +587,28 @@ impl<'a> Resolver<'a> {\n                         .emit();\n                     return;\n                 } else if orig_name == Some(kw::SelfLower) {\n-                    self.graph_root\n+                    self.r.graph_root\n                 } else {\n-                    let crate_id = self.crate_loader.process_extern_crate(item, &self.definitions);\n-                    self.get_module(DefId { krate: crate_id, index: CRATE_DEF_INDEX })\n+                    let crate_id = self.r.crate_loader.process_extern_crate(\n+                        item, &self.r.definitions\n+                    );\n+                    self.r.get_module(DefId { krate: crate_id, index: CRATE_DEF_INDEX })\n                 };\n \n-                self.populate_module_if_necessary(module);\n-                if let Some(name) = self.session.parse_sess.injected_crate_name.try_get() {\n+                self.r.populate_module_if_necessary(module);\n+                if let Some(name) = self.r.session.parse_sess.injected_crate_name.try_get() {\n                     if name.as_str() == ident.name.as_str() {\n-                        self.injected_crate = Some(module);\n+                        self.r.injected_crate = Some(module);\n                     }\n                 }\n \n-                let used = self.process_legacy_macro_imports(item, module, &parent_scope);\n+                let used = self.process_legacy_macro_imports(item, module);\n                 let binding =\n-                    (module, ty::Visibility::Public, sp, expansion).to_name_binding(self.arenas);\n-                let directive = self.arenas.alloc_import_directive(ImportDirective {\n+                    (module, ty::Visibility::Public, sp, expansion).to_name_binding(self.r.arenas);\n+                let directive = self.r.arenas.alloc_import_directive(ImportDirective {\n                     root_id: item.id,\n                     id: item.id,\n-                    parent_scope,\n+                    parent_scope: self.parent_scope.clone(),\n                     imported_module: Cell::new(Some(ModuleOrUniformRoot::Module(module))),\n                     subclass: ImportDirectiveSubclass::ExternCrate {\n                         source: orig_name,\n@@ -393,18 +623,18 @@ impl<'a> Resolver<'a> {\n                     vis: Cell::new(vis),\n                     used: Cell::new(used),\n                 });\n-                self.potentially_unused_imports.push(directive);\n-                let imported_binding = self.import(binding, directive);\n-                if ptr::eq(self.current_module, self.graph_root) {\n-                    if let Some(entry) = self.extern_prelude.get(&ident.modern()) {\n+                self.r.potentially_unused_imports.push(directive);\n+                let imported_binding = self.r.import(binding, directive);\n+                if ptr::eq(parent, self.r.graph_root) {\n+                    if let Some(entry) = self.r.extern_prelude.get(&ident.modern()) {\n                         if expansion != ExpnId::root() && orig_name.is_some() &&\n                            entry.extern_crate_item.is_none() {\n-                            self.session.span_err(item.span, \"macro-expanded `extern crate` items \\\n-                                                              cannot shadow names passed with \\\n-                                                              `--extern`\");\n+                            let msg = \"macro-expanded `extern crate` items cannot \\\n+                                       shadow names passed with `--extern`\";\n+                            self.r.session.span_err(item.span, msg);\n                         }\n                     }\n-                    let entry = self.extern_prelude.entry(ident.modern())\n+                    let entry = self.r.extern_prelude.entry(ident.modern())\n                                                    .or_insert(ExternPreludeEntry {\n                         extern_crate_item: None,\n                         introduced_by_item: true,\n@@ -414,90 +644,90 @@ impl<'a> Resolver<'a> {\n                         entry.introduced_by_item = true;\n                     }\n                 }\n-                self.define(parent, ident, TypeNS, imported_binding);\n+                self.r.define(parent, ident, TypeNS, imported_binding);\n             }\n \n             ItemKind::GlobalAsm(..) => {}\n \n             ItemKind::Mod(..) if ident.name == kw::Invalid => {} // Crate root\n \n             ItemKind::Mod(..) => {\n-                let def_id = self.definitions.local_def_id(item.id);\n+                let def_id = self.r.definitions.local_def_id(item.id);\n                 let module_kind = ModuleKind::Def(DefKind::Mod, def_id, ident.name);\n-                let module = self.arenas.alloc_module(ModuleData {\n+                let module = self.r.arenas.alloc_module(ModuleData {\n                     no_implicit_prelude: parent.no_implicit_prelude || {\n                         attr::contains_name(&item.attrs, sym::no_implicit_prelude)\n                     },\n                     ..ModuleData::new(Some(parent), module_kind, def_id, expansion, item.span)\n                 });\n-                self.define(parent, ident, TypeNS, (module, vis, sp, expansion));\n-                self.module_map.insert(def_id, module);\n+                self.r.define(parent, ident, TypeNS, (module, vis, sp, expansion));\n+                self.r.module_map.insert(def_id, module);\n \n                 // Descend into the module.\n-                self.current_module = module;\n+                self.parent_scope.module = module;\n             }\n \n             // Handled in `rustc_metadata::{native_libs,link_args}`\n             ItemKind::ForeignMod(..) => {}\n \n             // These items live in the value namespace.\n             ItemKind::Static(..) => {\n-                let res = Res::Def(DefKind::Static, self.definitions.local_def_id(item.id));\n-                self.define(parent, ident, ValueNS, (res, vis, sp, expansion));\n+                let res = Res::Def(DefKind::Static, self.r.definitions.local_def_id(item.id));\n+                self.r.define(parent, ident, ValueNS, (res, vis, sp, expansion));\n             }\n             ItemKind::Const(..) => {\n-                let res = Res::Def(DefKind::Const, self.definitions.local_def_id(item.id));\n-                self.define(parent, ident, ValueNS, (res, vis, sp, expansion));\n+                let res = Res::Def(DefKind::Const, self.r.definitions.local_def_id(item.id));\n+                self.r.define(parent, ident, ValueNS, (res, vis, sp, expansion));\n             }\n             ItemKind::Fn(..) => {\n-                let res = Res::Def(DefKind::Fn, self.definitions.local_def_id(item.id));\n-                self.define(parent, ident, ValueNS, (res, vis, sp, expansion));\n+                let res = Res::Def(DefKind::Fn, self.r.definitions.local_def_id(item.id));\n+                self.r.define(parent, ident, ValueNS, (res, vis, sp, expansion));\n \n                 // Functions introducing procedural macros reserve a slot\n                 // in the macro namespace as well (see #52225).\n-                self.define_macro(item, expansion, &mut LegacyScope::Empty);\n+                self.define_macro(item);\n             }\n \n             // These items live in the type namespace.\n             ItemKind::TyAlias(..) => {\n-                let res = Res::Def(DefKind::TyAlias, self.definitions.local_def_id(item.id));\n-                self.define(parent, ident, TypeNS, (res, vis, sp, expansion));\n+                let res = Res::Def(DefKind::TyAlias, self.r.definitions.local_def_id(item.id));\n+                self.r.define(parent, ident, TypeNS, (res, vis, sp, expansion));\n             }\n \n             ItemKind::OpaqueTy(_, _) => {\n-                let res = Res::Def(DefKind::OpaqueTy, self.definitions.local_def_id(item.id));\n-                self.define(parent, ident, TypeNS, (res, vis, sp, expansion));\n+                let res = Res::Def(DefKind::OpaqueTy, self.r.definitions.local_def_id(item.id));\n+                self.r.define(parent, ident, TypeNS, (res, vis, sp, expansion));\n             }\n \n             ItemKind::Enum(ref enum_definition, _) => {\n                 let module_kind = ModuleKind::Def(\n                     DefKind::Enum,\n-                    self.definitions.local_def_id(item.id),\n+                    self.r.definitions.local_def_id(item.id),\n                     ident.name,\n                 );\n-                let module = self.new_module(parent,\n+                let module = self.r.new_module(parent,\n                                              module_kind,\n                                              parent.normal_ancestor_id,\n                                              expansion,\n                                              item.span);\n-                self.define(parent, ident, TypeNS, (module, vis, sp, expansion));\n+                self.r.define(parent, ident, TypeNS, (module, vis, sp, expansion));\n \n                 for variant in &(*enum_definition).variants {\n                     self.build_reduced_graph_for_variant(variant, module, vis, expansion);\n                 }\n             }\n \n             ItemKind::TraitAlias(..) => {\n-                let res = Res::Def(DefKind::TraitAlias, self.definitions.local_def_id(item.id));\n-                self.define(parent, ident, TypeNS, (res, vis, sp, expansion));\n+                let res = Res::Def(DefKind::TraitAlias, self.r.definitions.local_def_id(item.id));\n+                self.r.define(parent, ident, TypeNS, (res, vis, sp, expansion));\n             }\n \n             // These items live in both the type and value namespaces.\n             ItemKind::Struct(ref struct_def, _) => {\n                 // Define a name in the type namespace.\n-                let def_id = self.definitions.local_def_id(item.id);\n+                let def_id = self.r.definitions.local_def_id(item.id);\n                 let res = Res::Def(DefKind::Struct, def_id);\n-                self.define(parent, ident, TypeNS, (res, vis, sp, expansion));\n+                self.r.define(parent, ident, TypeNS, (res, vis, sp, expansion));\n \n                 let mut ctor_vis = vis;\n \n@@ -512,53 +742,57 @@ impl<'a> Resolver<'a> {\n                 // Record field names for error reporting.\n                 let field_names = struct_def.fields().iter().filter_map(|field| {\n                     let field_vis = self.resolve_visibility(&field.vis);\n-                    if ctor_vis.is_at_least(field_vis, &*self) {\n+                    if ctor_vis.is_at_least(field_vis, &*self.r) {\n                         ctor_vis = field_vis;\n                     }\n                     field.ident.map(|ident| ident.name)\n                 }).collect();\n-                let item_def_id = self.definitions.local_def_id(item.id);\n+                let item_def_id = self.r.definitions.local_def_id(item.id);\n                 self.insert_field_names(item_def_id, field_names);\n \n                 // If this is a tuple or unit struct, define a name\n                 // in the value namespace as well.\n                 if let Some(ctor_node_id) = struct_def.ctor_id() {\n                     let ctor_res = Res::Def(\n                         DefKind::Ctor(CtorOf::Struct, CtorKind::from_ast(struct_def)),\n-                        self.definitions.local_def_id(ctor_node_id),\n+                        self.r.definitions.local_def_id(ctor_node_id),\n                     );\n-                    self.define(parent, ident, ValueNS, (ctor_res, ctor_vis, sp, expansion));\n-                    self.struct_constructors.insert(res.def_id(), (ctor_res, ctor_vis));\n+                    self.r.define(parent, ident, ValueNS, (ctor_res, ctor_vis, sp, expansion));\n+                    self.r.struct_constructors.insert(res.def_id(), (ctor_res, ctor_vis));\n                 }\n             }\n \n             ItemKind::Union(ref vdata, _) => {\n-                let res = Res::Def(DefKind::Union, self.definitions.local_def_id(item.id));\n-                self.define(parent, ident, TypeNS, (res, vis, sp, expansion));\n+                let res = Res::Def(DefKind::Union, self.r.definitions.local_def_id(item.id));\n+                self.r.define(parent, ident, TypeNS, (res, vis, sp, expansion));\n \n                 // Record field names for error reporting.\n                 let field_names = vdata.fields().iter().filter_map(|field| {\n                     self.resolve_visibility(&field.vis);\n                     field.ident.map(|ident| ident.name)\n                 }).collect();\n-                let item_def_id = self.definitions.local_def_id(item.id);\n+                let item_def_id = self.r.definitions.local_def_id(item.id);\n                 self.insert_field_names(item_def_id, field_names);\n             }\n \n-            ItemKind::Impl(..) => {}\n+            ItemKind::Impl(.., ref impl_items) => {\n+                for impl_item in impl_items {\n+                    self.resolve_visibility(&impl_item.vis);\n+                }\n+            }\n \n             ItemKind::Trait(..) => {\n-                let def_id = self.definitions.local_def_id(item.id);\n+                let def_id = self.r.definitions.local_def_id(item.id);\n \n                 // Add all the items within to a new module.\n                 let module_kind = ModuleKind::Def(DefKind::Trait, def_id, ident.name);\n-                let module = self.new_module(parent,\n+                let module = self.r.new_module(parent,\n                                              module_kind,\n                                              parent.normal_ancestor_id,\n                                              expansion,\n                                              item.span);\n-                self.define(parent, ident, TypeNS, (module, vis, sp, expansion));\n-                self.current_module = module;\n+                self.r.define(parent, ident, TypeNS, (module, vis, sp, expansion));\n+                self.parent_scope.module = module;\n             }\n \n             ItemKind::MacroDef(..) | ItemKind::Mac(_) => unreachable!(),\n@@ -575,9 +809,9 @@ impl<'a> Resolver<'a> {\n         let ident = variant.node.ident;\n \n         // Define a name in the type namespace.\n-        let def_id = self.definitions.local_def_id(variant.node.id);\n+        let def_id = self.r.definitions.local_def_id(variant.node.id);\n         let res = Res::Def(DefKind::Variant, def_id);\n-        self.define(parent, ident, TypeNS, (res, vis, variant.span, expn_id));\n+        self.r.define(parent, ident, TypeNS, (res, vis, variant.span, expn_id));\n \n         // If the variant is marked as non_exhaustive then lower the visibility to within the\n         // crate.\n@@ -593,41 +827,43 @@ impl<'a> Resolver<'a> {\n         // It's ok to use the variant's id as a ctor id since an\n         // error will be reported on any use of such resolution anyway.\n         let ctor_node_id = variant.node.data.ctor_id().unwrap_or(variant.node.id);\n-        let ctor_def_id = self.definitions.local_def_id(ctor_node_id);\n+        let ctor_def_id = self.r.definitions.local_def_id(ctor_node_id);\n         let ctor_kind = CtorKind::from_ast(&variant.node.data);\n         let ctor_res = Res::Def(DefKind::Ctor(CtorOf::Variant, ctor_kind), ctor_def_id);\n-        self.define(parent, ident, ValueNS, (ctor_res, ctor_vis, variant.span, expn_id));\n+        self.r.define(parent, ident, ValueNS, (ctor_res, ctor_vis, variant.span, expn_id));\n     }\n \n     /// Constructs the reduced graph for one foreign item.\n-    fn build_reduced_graph_for_foreign_item(&mut self, item: &ForeignItem, expn_id: ExpnId) {\n+    fn build_reduced_graph_for_foreign_item(&mut self, item: &ForeignItem) {\n         let (res, ns) = match item.node {\n             ForeignItemKind::Fn(..) => {\n-                (Res::Def(DefKind::Fn, self.definitions.local_def_id(item.id)), ValueNS)\n+                (Res::Def(DefKind::Fn, self.r.definitions.local_def_id(item.id)), ValueNS)\n             }\n             ForeignItemKind::Static(..) => {\n-                (Res::Def(DefKind::Static, self.definitions.local_def_id(item.id)), ValueNS)\n+                (Res::Def(DefKind::Static, self.r.definitions.local_def_id(item.id)), ValueNS)\n             }\n             ForeignItemKind::Ty => {\n-                (Res::Def(DefKind::ForeignTy, self.definitions.local_def_id(item.id)), TypeNS)\n+                (Res::Def(DefKind::ForeignTy, self.r.definitions.local_def_id(item.id)), TypeNS)\n             }\n             ForeignItemKind::Macro(_) => unreachable!(),\n         };\n-        let parent = self.current_module;\n+        let parent = self.parent_scope.module;\n+        let expansion = self.parent_scope.expansion;\n         let vis = self.resolve_visibility(&item.vis);\n-        self.define(parent, item.ident, ns, (res, vis, item.span, expn_id));\n+        self.r.define(parent, item.ident, ns, (res, vis, item.span, expansion));\n     }\n \n-    fn build_reduced_graph_for_block(&mut self, block: &Block, expn_id: ExpnId) {\n-        let parent = self.current_module;\n+    fn build_reduced_graph_for_block(&mut self, block: &Block) {\n+        let parent = self.parent_scope.module;\n+        let expansion = self.parent_scope.expansion;\n         if self.block_needs_anonymous_module(block) {\n-            let module = self.new_module(parent,\n+            let module = self.r.new_module(parent,\n                                          ModuleKind::Block(block.id),\n                                          parent.normal_ancestor_id,\n-                                         expn_id,\n+                                         expansion,\n                                          block.span);\n-            self.block_map.insert(block.id, module);\n-            self.current_module = module; // Descend into the block.\n+            self.r.block_map.insert(block.id, module);\n+            self.parent_scope.module = module; // Descend into the block.\n         }\n     }\n \n@@ -646,12 +882,12 @@ impl<'a> Resolver<'a> {\n         match res {\n             Res::Def(kind @ DefKind::Mod, def_id)\n             | Res::Def(kind @ DefKind::Enum, def_id) => {\n-                let module = self.new_module(parent,\n+                let module = self.r.new_module(parent,\n                                              ModuleKind::Def(kind, def_id, ident.name),\n                                              def_id,\n                                              expansion,\n                                              span);\n-                self.define(parent, ident, TypeNS, (module, vis, DUMMY_SP, expansion));\n+                self.r.define(parent, ident, TypeNS, (module, vis, DUMMY_SP, expansion));\n             }\n             Res::Def(DefKind::Variant, _)\n             | Res::Def(DefKind::TyAlias, _)\n@@ -660,169 +896,91 @@ impl<'a> Resolver<'a> {\n             | Res::Def(DefKind::TraitAlias, _)\n             | Res::PrimTy(..)\n             | Res::ToolMod => {\n-                self.define(parent, ident, TypeNS, (res, vis, DUMMY_SP, expansion));\n+                self.r.define(parent, ident, TypeNS, (res, vis, DUMMY_SP, expansion));\n             }\n             Res::Def(DefKind::Fn, _)\n             | Res::Def(DefKind::Static, _)\n             | Res::Def(DefKind::Const, _)\n             | Res::Def(DefKind::Ctor(CtorOf::Variant, ..), _) => {\n-                self.define(parent, ident, ValueNS, (res, vis, DUMMY_SP, expansion));\n+                self.r.define(parent, ident, ValueNS, (res, vis, DUMMY_SP, expansion));\n             }\n             Res::Def(DefKind::Ctor(CtorOf::Struct, ..), def_id) => {\n-                self.define(parent, ident, ValueNS, (res, vis, DUMMY_SP, expansion));\n+                self.r.define(parent, ident, ValueNS, (res, vis, DUMMY_SP, expansion));\n \n                 if let Some(struct_def_id) =\n-                        self.cstore.def_key(def_id).parent\n+                        self.r.cstore.def_key(def_id).parent\n                             .map(|index| DefId { krate: def_id.krate, index: index }) {\n-                    self.struct_constructors.insert(struct_def_id, (res, vis));\n+                    self.r.struct_constructors.insert(struct_def_id, (res, vis));\n                 }\n             }\n             Res::Def(DefKind::Trait, def_id) => {\n                 let module_kind = ModuleKind::Def(DefKind::Trait, def_id, ident.name);\n-                let module = self.new_module(parent,\n+                let module = self.r.new_module(parent,\n                                              module_kind,\n                                              parent.normal_ancestor_id,\n                                              expansion,\n                                              span);\n-                self.define(parent, ident, TypeNS, (module, vis, DUMMY_SP, expansion));\n+                self.r.define(parent, ident, TypeNS, (module, vis, DUMMY_SP, expansion));\n \n-                for child in self.cstore.item_children_untracked(def_id, self.session) {\n+                for child in self.r.cstore.item_children_untracked(def_id, self.r.session) {\n                     let res = child.res.map_id(|_| panic!(\"unexpected id\"));\n                     let ns = if let Res::Def(DefKind::AssocTy, _) = res {\n                         TypeNS\n                     } else { ValueNS };\n-                    self.define(module, child.ident, ns,\n+                    self.r.define(module, child.ident, ns,\n                                 (res, ty::Visibility::Public, DUMMY_SP, expansion));\n \n-                    if self.cstore.associated_item_cloned_untracked(child.res.def_id())\n+                    if self.r.cstore.associated_item_cloned_untracked(child.res.def_id())\n                            .method_has_self_argument {\n-                        self.has_self.insert(res.def_id());\n+                        self.r.has_self.insert(res.def_id());\n                     }\n                 }\n                 module.populated.set(true);\n             }\n             Res::Def(DefKind::Struct, def_id) | Res::Def(DefKind::Union, def_id) => {\n-                self.define(parent, ident, TypeNS, (res, vis, DUMMY_SP, expansion));\n+                self.r.define(parent, ident, TypeNS, (res, vis, DUMMY_SP, expansion));\n \n                 // Record field names for error reporting.\n-                let field_names = self.cstore.struct_field_names_untracked(def_id);\n+                let field_names = self.r.cstore.struct_field_names_untracked(def_id);\n                 self.insert_field_names(def_id, field_names);\n             }\n             Res::Def(DefKind::Macro(..), _) | Res::NonMacroAttr(..) => {\n-                self.define(parent, ident, MacroNS, (res, vis, DUMMY_SP, expansion));\n+                self.r.define(parent, ident, MacroNS, (res, vis, DUMMY_SP, expansion));\n             }\n             _ => bug!(\"unexpected resolution: {:?}\", res)\n         }\n     }\n \n-    pub fn get_module(&mut self, def_id: DefId) -> Module<'a> {\n-        if def_id.krate == LOCAL_CRATE {\n-            return self.module_map[&def_id]\n-        }\n-\n-        let macros_only = self.cstore.dep_kind_untracked(def_id.krate).macros_only();\n-        if let Some(&module) = self.extern_module_map.get(&(def_id, macros_only)) {\n-            return module;\n-        }\n-\n-        let (name, parent) = if def_id.index == CRATE_DEF_INDEX {\n-            (self.cstore.crate_name_untracked(def_id.krate).as_interned_str(), None)\n-        } else {\n-            let def_key = self.cstore.def_key(def_id);\n-            (def_key.disambiguated_data.data.get_opt_name().unwrap(),\n-             Some(self.get_module(DefId { index: def_key.parent.unwrap(), ..def_id })))\n-        };\n-\n-        let kind = ModuleKind::Def(DefKind::Mod, def_id, name.as_symbol());\n-        let module = self.arenas.alloc_module(ModuleData::new(\n-            parent, kind, def_id, ExpnId::root(), DUMMY_SP\n-        ));\n-        self.extern_module_map.insert((def_id, macros_only), module);\n-        module\n-    }\n-\n-    pub fn macro_def_scope(&mut self, expn_id: ExpnId) -> Module<'a> {\n-        let def_id = match self.macro_defs.get(&expn_id) {\n-            Some(def_id) => *def_id,\n-            None => return self.graph_root,\n-        };\n-        if let Some(id) = self.definitions.as_local_node_id(def_id) {\n-            self.local_macro_def_scopes[&id]\n-        } else if self.is_builtin_macro(Some(def_id)) {\n-            self.injected_crate.unwrap_or(self.graph_root)\n-        } else {\n-            let module_def_id = ty::DefIdTree::parent(&*self, def_id).unwrap();\n-            self.get_module(module_def_id)\n-        }\n-    }\n-\n-    crate fn get_macro(&mut self, res: Res) -> Option<Lrc<SyntaxExtension>> {\n-        match res {\n-            Res::Def(DefKind::Macro(..), def_id) => self.get_macro_by_def_id(def_id),\n-            Res::NonMacroAttr(attr_kind) =>\n-                Some(self.non_macro_attr(attr_kind == NonMacroAttrKind::Tool)),\n-            _ => None,\n-        }\n-    }\n-\n-    crate fn get_macro_by_def_id(&mut self, def_id: DefId) -> Option<Lrc<SyntaxExtension>> {\n-        if let Some(ext) = self.macro_map.get(&def_id) {\n-            return Some(ext.clone());\n-        }\n-\n-        let macro_def = match self.cstore.load_macro_untracked(def_id, &self.session) {\n-            LoadedMacro::MacroDef(macro_def) => macro_def,\n-            LoadedMacro::ProcMacro(ext) => return Some(ext),\n-        };\n-\n-        let ext = self.compile_macro(&macro_def, self.cstore.crate_edition_untracked(def_id.krate));\n-        self.macro_map.insert(def_id, ext.clone());\n-        Some(ext)\n-    }\n-\n-    /// Ensures that the reduced graph rooted at the given external module\n-    /// is built, building it if it is not.\n-    pub fn populate_module_if_necessary(&mut self, module: Module<'a>) {\n-        if module.populated.get() { return }\n-        let def_id = module.def_id().unwrap();\n-        for child in self.cstore.item_children_untracked(def_id, self.session) {\n-            let child = child.map_id(|_| panic!(\"unexpected id\"));\n-            self.build_reduced_graph_for_external_crate_res(module, child);\n-        }\n-        module.populated.set(true)\n-    }\n-\n     fn legacy_import_macro(&mut self,\n                            name: Name,\n                            binding: &'a NameBinding<'a>,\n                            span: Span,\n                            allow_shadowing: bool) {\n-        if self.macro_use_prelude.insert(name, binding).is_some() && !allow_shadowing {\n+        if self.r.macro_use_prelude.insert(name, binding).is_some() && !allow_shadowing {\n             let msg = format!(\"`{}` is already in scope\", name);\n             let note =\n                 \"macro-expanded `#[macro_use]`s may not shadow existing macros (see RFC 1560)\";\n-            self.session.struct_span_err(span, &msg).note(note).emit();\n+            self.r.session.struct_span_err(span, &msg).note(note).emit();\n         }\n     }\n \n     /// Returns `true` if we should consider the underlying `extern crate` to be used.\n-    fn process_legacy_macro_imports(&mut self, item: &Item, module: Module<'a>,\n-                                    parent_scope: &ParentScope<'a>) -> bool {\n+    fn process_legacy_macro_imports(&mut self, item: &Item, module: Module<'a>) -> bool {\n         let mut import_all = None;\n         let mut single_imports = Vec::new();\n         for attr in &item.attrs {\n             if attr.check_name(sym::macro_use) {\n-                if self.current_module.parent.is_some() {\n-                    span_err!(self.session, item.span, E0468,\n+                if self.parent_scope.module.parent.is_some() {\n+                    span_err!(self.r.session, item.span, E0468,\n                         \"an `extern crate` loading macros must be at the crate root\");\n                 }\n                 if let ItemKind::ExternCrate(Some(orig_name)) = item.node {\n                     if orig_name == kw::SelfLower {\n-                        self.session.span_err(attr.span,\n+                        self.r.session.span_err(attr.span,\n                             \"`macro_use` is not supported on `extern crate self`\");\n                     }\n                 }\n-                let ill_formed = |span| span_err!(self.session, span, E0466, \"bad macro import\");\n+                let ill_formed = |span| span_err!(self.r.session, span, E0466, \"bad macro import\");\n                 match attr.meta() {\n                     Some(meta) => match meta.node {\n                         MetaItemKind::Word => {\n@@ -842,11 +1000,11 @@ impl<'a> Resolver<'a> {\n             }\n         }\n \n-        let arenas = self.arenas;\n-        let macro_use_directive = |span| arenas.alloc_import_directive(ImportDirective {\n+        let macro_use_directive =\n+                |this: &Self, span| this.r.arenas.alloc_import_directive(ImportDirective {\n             root_id: item.id,\n             id: item.id,\n-            parent_scope: parent_scope.clone(),\n+            parent_scope: this.parent_scope.clone(),\n             imported_module: Cell::new(Some(ModuleOrUniformRoot::Module(module))),\n             subclass: ImportDirectiveSubclass::MacroUse,\n             use_span_with_attributes: item.span_with_attributes(),\n@@ -859,32 +1017,32 @@ impl<'a> Resolver<'a> {\n             used: Cell::new(false),\n         });\n \n-        let allow_shadowing = parent_scope.expansion == ExpnId::root();\n+        let allow_shadowing = self.parent_scope.expansion == ExpnId::root();\n         if let Some(span) = import_all {\n-            let directive = macro_use_directive(span);\n-            self.potentially_unused_imports.push(directive);\n+            let directive = macro_use_directive(self, span);\n+            self.r.potentially_unused_imports.push(directive);\n             module.for_each_child(|ident, ns, binding| if ns == MacroNS {\n-                let imported_binding = self.import(binding, directive);\n+                let imported_binding = self.r.import(binding, directive);\n                 self.legacy_import_macro(ident.name, imported_binding, span, allow_shadowing);\n             });\n         } else {\n             for ident in single_imports.iter().cloned() {\n-                let result = self.resolve_ident_in_module(\n+                let result = self.r.resolve_ident_in_module(\n                     ModuleOrUniformRoot::Module(module),\n                     ident,\n                     MacroNS,\n-                    None,\n+                    &self.parent_scope,\n                     false,\n                     ident.span,\n                 );\n                 if let Ok(binding) = result {\n-                    let directive = macro_use_directive(ident.span);\n-                    self.potentially_unused_imports.push(directive);\n-                    let imported_binding = self.import(binding, directive);\n+                    let directive = macro_use_directive(self, ident.span);\n+                    self.r.potentially_unused_imports.push(directive);\n+                    let imported_binding = self.r.import(binding, directive);\n                     self.legacy_import_macro(ident.name, imported_binding,\n                                              ident.span, allow_shadowing);\n                 } else {\n-                    span_err!(self.session, ident.span, E0469, \"imported macro not found\");\n+                    span_err!(self.r.session, ident.span, E0469, \"imported macro not found\");\n                 }\n             }\n         }\n@@ -896,7 +1054,7 @@ impl<'a> Resolver<'a> {\n         for attr in attrs {\n             if attr.check_name(sym::macro_escape) {\n                 let msg = \"macro_escape is a deprecated synonym for macro_use\";\n-                let mut err = self.session.struct_span_warn(attr.span, msg);\n+                let mut err = self.r.session.struct_span_warn(attr.span, msg);\n                 if let ast::AttrStyle::Inner = attr.style {\n                     err.help(\"consider an outer attribute, `#[macro_use]` mod ...\").emit();\n                 } else {\n@@ -907,42 +1065,106 @@ impl<'a> Resolver<'a> {\n             }\n \n             if !attr.is_word() {\n-                self.session.span_err(attr.span, \"arguments to macro_use are not allowed here\");\n+                self.r.session.span_err(attr.span, \"arguments to macro_use are not allowed here\");\n             }\n             return true;\n         }\n \n         false\n     }\n-}\n-\n-pub struct BuildReducedGraphVisitor<'a, 'b> {\n-    pub resolver: &'a mut Resolver<'b>,\n-    pub current_legacy_scope: LegacyScope<'b>,\n-    pub expansion: ExpnId,\n-}\n \n-impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n-    fn visit_invoc(&mut self, id: ast::NodeId) -> &'b InvocationData<'b> {\n+    fn visit_invoc(&mut self, id: ast::NodeId) -> &'a InvocationData<'a> {\n         let invoc_id = id.placeholder_to_expn_id();\n \n-        self.resolver.current_module.unresolved_invocations.borrow_mut().insert(invoc_id);\n+        self.parent_scope.module.unresolved_invocations.borrow_mut().insert(invoc_id);\n \n-        let invocation_data = self.resolver.arenas.alloc_invocation_data(InvocationData {\n-            module: self.resolver.current_module,\n-            parent_legacy_scope: self.current_legacy_scope,\n+        let invocation_data = self.r.arenas.alloc_invocation_data(InvocationData {\n+            module: self.parent_scope.module,\n+            parent_legacy_scope: self.parent_scope.legacy,\n             output_legacy_scope: Cell::new(None),\n         });\n-        let old_invocation_data = self.resolver.invocations.insert(invoc_id, invocation_data);\n+        let old_invocation_data = self.r.invocations.insert(invoc_id, invocation_data);\n         assert!(old_invocation_data.is_none(), \"invocation data is reset for an invocation\");\n \n         invocation_data\n     }\n+\n+    fn proc_macro_stub(item: &ast::Item) -> Option<(MacroKind, Ident, Span)> {\n+        if attr::contains_name(&item.attrs, sym::proc_macro) {\n+            return Some((MacroKind::Bang, item.ident, item.span));\n+        } else if attr::contains_name(&item.attrs, sym::proc_macro_attribute) {\n+            return Some((MacroKind::Attr, item.ident, item.span));\n+        } else if let Some(attr) = attr::find_by_name(&item.attrs, sym::proc_macro_derive) {\n+            if let Some(nested_meta) = attr.meta_item_list().and_then(|list| list.get(0).cloned()) {\n+                if let Some(ident) = nested_meta.ident() {\n+                    return Some((MacroKind::Derive, ident, ident.span));\n+                }\n+            }\n+        }\n+        None\n+    }\n+\n+    fn define_macro(&mut self, item: &ast::Item) -> LegacyScope<'a> {\n+        let parent_scope = &self.parent_scope;\n+        let expansion = parent_scope.expansion;\n+        let (ext, ident, span, is_legacy) = match &item.node {\n+            ItemKind::MacroDef(def) => {\n+                let ext = self.r.compile_macro(item, self.r.session.edition());\n+                (ext, item.ident, item.span, def.legacy)\n+            }\n+            ItemKind::Fn(..) => match Self::proc_macro_stub(item) {\n+                Some((macro_kind, ident, span)) => {\n+                    self.r.proc_macro_stubs.insert(item.id);\n+                    (self.r.dummy_ext(macro_kind), ident, span, false)\n+                }\n+                None => return parent_scope.legacy,\n+            }\n+            _ => unreachable!(),\n+        };\n+\n+        let def_id = self.r.definitions.local_def_id(item.id);\n+        let res = Res::Def(DefKind::Macro(ext.macro_kind()), def_id);\n+        self.r.macro_map.insert(def_id, ext);\n+        self.r.local_macro_def_scopes.insert(item.id, parent_scope.module);\n+\n+        if is_legacy {\n+            let ident = ident.modern();\n+            self.r.macro_names.insert(ident);\n+            let is_macro_export = attr::contains_name(&item.attrs, sym::macro_export);\n+            let vis = if is_macro_export {\n+                ty::Visibility::Public\n+            } else {\n+                ty::Visibility::Restricted(DefId::local(CRATE_DEF_INDEX))\n+            };\n+            let binding = (res, vis, span, expansion).to_name_binding(self.r.arenas);\n+            self.r.set_binding_parent_module(binding, parent_scope.module);\n+            self.r.all_macros.insert(ident.name, res);\n+            if is_macro_export {\n+                let module = self.r.graph_root;\n+                self.r.define(module, ident, MacroNS,\n+                            (res, vis, span, expansion, IsMacroExport));\n+            } else {\n+                self.r.check_reserved_macro_name(ident, res);\n+                self.r.unused_macros.insert(item.id, span);\n+            }\n+            LegacyScope::Binding(self.r.arenas.alloc_legacy_binding(LegacyBinding {\n+                parent_legacy_scope: parent_scope.legacy, binding, ident\n+            }))\n+        } else {\n+            let module = parent_scope.module;\n+            let vis = self.resolve_visibility(&item.vis);\n+            if vis != ty::Visibility::Public {\n+                self.r.unused_macros.insert(item.id, span);\n+            }\n+            self.r.define(module, ident, MacroNS, (res, vis, span, expansion));\n+            self.parent_scope.legacy\n+        }\n+    }\n }\n \n macro_rules! method {\n     ($visit:ident: $ty:ty, $invoc:path, $walk:ident) => {\n-        fn $visit(&mut self, node: &'a $ty) {\n+        fn $visit(&mut self, node: &'b $ty) {\n             if let $invoc(..) = node.node {\n                 self.visit_invoc(node.id);\n             } else {\n@@ -952,84 +1174,78 @@ macro_rules! method {\n     }\n }\n \n-impl<'a, 'b> Visitor<'a> for BuildReducedGraphVisitor<'a, 'b> {\n+impl<'a, 'b> Visitor<'b> for BuildReducedGraphVisitor<'a, 'b> {\n     method!(visit_impl_item: ast::ImplItem, ast::ImplItemKind::Macro, walk_impl_item);\n     method!(visit_expr:      ast::Expr,     ast::ExprKind::Mac,       walk_expr);\n     method!(visit_pat:       ast::Pat,      ast::PatKind::Mac,        walk_pat);\n     method!(visit_ty:        ast::Ty,       ast::TyKind::Mac,         walk_ty);\n \n-    fn visit_item(&mut self, item: &'a Item) {\n+    fn visit_item(&mut self, item: &'b Item) {\n         let macro_use = match item.node {\n             ItemKind::MacroDef(..) => {\n-                self.resolver.define_macro(item, self.expansion, &mut self.current_legacy_scope);\n+                self.parent_scope.legacy = self.define_macro(item);\n                 return\n             }\n             ItemKind::Mac(..) => {\n-                self.current_legacy_scope = LegacyScope::Invocation(self.visit_invoc(item.id));\n+                self.parent_scope.legacy = LegacyScope::Invocation(self.visit_invoc(item.id));\n                 return\n             }\n-            ItemKind::Mod(..) => self.resolver.contains_macro_use(&item.attrs),\n+            ItemKind::Mod(..) => self.contains_macro_use(&item.attrs),\n             _ => false,\n         };\n \n-        let orig_current_module = self.resolver.current_module;\n-        let orig_current_legacy_scope = self.current_legacy_scope;\n-        let parent_scope = ParentScope {\n-            module: self.resolver.current_module,\n-            expansion: self.expansion,\n-            legacy: self.current_legacy_scope,\n-            derives: Vec::new(),\n-        };\n-        self.resolver.build_reduced_graph_for_item(item, parent_scope);\n+        let orig_current_module = self.parent_scope.module;\n+        let orig_current_legacy_scope = self.parent_scope.legacy;\n+        self.build_reduced_graph_for_item(item);\n         visit::walk_item(self, item);\n-        self.resolver.current_module = orig_current_module;\n+        self.parent_scope.module = orig_current_module;\n         if !macro_use {\n-            self.current_legacy_scope = orig_current_legacy_scope;\n+            self.parent_scope.legacy = orig_current_legacy_scope;\n         }\n     }\n \n-    fn visit_stmt(&mut self, stmt: &'a ast::Stmt) {\n+    fn visit_stmt(&mut self, stmt: &'b ast::Stmt) {\n         if let ast::StmtKind::Mac(..) = stmt.node {\n-            self.current_legacy_scope = LegacyScope::Invocation(self.visit_invoc(stmt.id));\n+            self.parent_scope.legacy = LegacyScope::Invocation(self.visit_invoc(stmt.id));\n         } else {\n             visit::walk_stmt(self, stmt);\n         }\n     }\n \n-    fn visit_foreign_item(&mut self, foreign_item: &'a ForeignItem) {\n+    fn visit_foreign_item(&mut self, foreign_item: &'b ForeignItem) {\n         if let ForeignItemKind::Macro(_) = foreign_item.node {\n             self.visit_invoc(foreign_item.id);\n             return;\n         }\n \n-        self.resolver.build_reduced_graph_for_foreign_item(foreign_item, self.expansion);\n+        self.build_reduced_graph_for_foreign_item(foreign_item);\n         visit::walk_foreign_item(self, foreign_item);\n     }\n \n-    fn visit_block(&mut self, block: &'a Block) {\n-        let orig_current_module = self.resolver.current_module;\n-        let orig_current_legacy_scope = self.current_legacy_scope;\n-        self.resolver.build_reduced_graph_for_block(block, self.expansion);\n+    fn visit_block(&mut self, block: &'b Block) {\n+        let orig_current_module = self.parent_scope.module;\n+        let orig_current_legacy_scope = self.parent_scope.legacy;\n+        self.build_reduced_graph_for_block(block);\n         visit::walk_block(self, block);\n-        self.resolver.current_module = orig_current_module;\n-        self.current_legacy_scope = orig_current_legacy_scope;\n+        self.parent_scope.module = orig_current_module;\n+        self.parent_scope.legacy = orig_current_legacy_scope;\n     }\n \n-    fn visit_trait_item(&mut self, item: &'a TraitItem) {\n-        let parent = self.resolver.current_module;\n+    fn visit_trait_item(&mut self, item: &'b TraitItem) {\n+        let parent = self.parent_scope.module;\n \n         if let TraitItemKind::Macro(_) = item.node {\n             self.visit_invoc(item.id);\n             return\n         }\n \n         // Add the item to the trait info.\n-        let item_def_id = self.resolver.definitions.local_def_id(item.id);\n+        let item_def_id = self.r.definitions.local_def_id(item.id);\n         let (res, ns) = match item.node {\n             TraitItemKind::Const(..) => (Res::Def(DefKind::AssocConst, item_def_id), ValueNS),\n             TraitItemKind::Method(ref sig, _) => {\n                 if sig.decl.has_self() {\n-                    self.resolver.has_self.insert(item_def_id);\n+                    self.r.has_self.insert(item_def_id);\n                 }\n                 (Res::Def(DefKind::Method, item_def_id), ValueNS)\n             }\n@@ -1038,11 +1254,12 @@ impl<'a, 'b> Visitor<'a> for BuildReducedGraphVisitor<'a, 'b> {\n         };\n \n         let vis = ty::Visibility::Public;\n-        self.resolver.define(parent, item.ident, ns, (res, vis, item.span, self.expansion));\n+        let expansion = self.parent_scope.expansion;\n+        self.r.define(parent, item.ident, ns, (res, vis, item.span, expansion));\n \n-        self.resolver.current_module = parent.parent.unwrap(); // nearest normal ancestor\n+        self.parent_scope.module = parent.parent.unwrap(); // nearest normal ancestor\n         visit::walk_trait_item(self, item);\n-        self.resolver.current_module = parent;\n+        self.parent_scope.module = parent;\n     }\n \n     fn visit_token(&mut self, t: Token) {\n@@ -1055,17 +1272,10 @@ impl<'a, 'b> Visitor<'a> for BuildReducedGraphVisitor<'a, 'b> {\n         }\n     }\n \n-    fn visit_attribute(&mut self, attr: &'a ast::Attribute) {\n+    fn visit_attribute(&mut self, attr: &'b ast::Attribute) {\n         if !attr.is_sugared_doc && is_builtin_attr(attr) {\n-            let parent_scope = ParentScope {\n-                module: self.resolver.current_module.nearest_item_scope(),\n-                expansion: self.expansion,\n-                legacy: self.current_legacy_scope,\n-                // Let's hope discerning built-in attributes from derive helpers is not necessary\n-                derives: Vec::new(),\n-            };\n-            parent_scope.module.builtin_attrs.borrow_mut().push((\n-                attr.path.segments[0].ident, parent_scope\n+            self.parent_scope.module.builtin_attrs.borrow_mut().push((\n+                attr.path.segments[0].ident, self.parent_scope.clone()\n             ));\n         }\n         visit::walk_attribute(self, attr);"}, {"sha": "96d44b4b4c0dcfa82a678e865d3b559b9b23d35e", "filename": "src/librustc_resolve/check_unused.rs", "status": "modified", "additions": 91, "deletions": 110, "changes": 201, "blob_url": "https://github.com/rust-lang/rust/blob/9d76a938de25e626a7c79a76789d7885405703e6/src%2Flibrustc_resolve%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d76a938de25e626a7c79a76789d7885405703e6/src%2Flibrustc_resolve%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fcheck_unused.rs?ref=9d76a938de25e626a7c79a76789d7885405703e6", "patch": "@@ -23,8 +23,6 @@\n //  - `check_crate` finally emits the diagnostics based on the data generated\n //    in the last step\n \n-use std::ops::{Deref, DerefMut};\n-\n use crate::Resolver;\n use crate::resolve_imports::ImportDirectiveSubclass;\n \n@@ -49,45 +47,30 @@ impl<'a> UnusedImport<'a> {\n }\n \n struct UnusedImportCheckVisitor<'a, 'b> {\n-    resolver: &'a mut Resolver<'b>,\n+    r: &'a mut Resolver<'b>,\n     /// All the (so far) unused imports, grouped path list\n     unused_imports: NodeMap<UnusedImport<'a>>,\n     base_use_tree: Option<&'a ast::UseTree>,\n     base_id: ast::NodeId,\n     item_span: Span,\n }\n \n-// Deref and DerefMut impls allow treating UnusedImportCheckVisitor as Resolver.\n-impl<'a, 'b> Deref for UnusedImportCheckVisitor<'a, 'b> {\n-    type Target = Resolver<'b>;\n-\n-    fn deref<'c>(&'c self) -> &'c Resolver<'b> {\n-        &*self.resolver\n-    }\n-}\n-\n-impl<'a, 'b> DerefMut for UnusedImportCheckVisitor<'a, 'b> {\n-    fn deref_mut<'c>(&'c mut self) -> &'c mut Resolver<'b> {\n-        &mut *self.resolver\n-    }\n-}\n-\n impl<'a, 'b> UnusedImportCheckVisitor<'a, 'b> {\n     // We have information about whether `use` (import) directives are actually\n     // used now. If an import is not used at all, we signal a lint error.\n     fn check_import(&mut self, id: ast::NodeId) {\n         let mut used = false;\n-        self.per_ns(|this, ns| used |= this.used_imports.contains(&(id, ns)));\n+        self.r.per_ns(|this, ns| used |= this.used_imports.contains(&(id, ns)));\n         if !used {\n-            if self.maybe_unused_trait_imports.contains(&id) {\n+            if self.r.maybe_unused_trait_imports.contains(&id) {\n                 // Check later.\n                 return;\n             }\n             self.unused_import(self.base_id).add(id);\n         } else {\n             // This trait import is definitely used, in a way other than\n             // method resolution.\n-            self.maybe_unused_trait_imports.remove(&id);\n+            self.r.maybe_unused_trait_imports.remove(&id);\n             if let Some(i) = self.unused_imports.get_mut(&self.base_id) {\n                 i.unused.remove(&id);\n             }\n@@ -238,104 +221,102 @@ fn calc_unused_spans(\n     }\n }\n \n-pub fn check_crate(resolver: &mut Resolver<'_>, krate: &ast::Crate) {\n-    for directive in resolver.potentially_unused_imports.iter() {\n-        match directive.subclass {\n-            _ if directive.used.get() ||\n-                 directive.vis.get() == ty::Visibility::Public ||\n-                 directive.span.is_dummy() => {\n-                if let ImportDirectiveSubclass::MacroUse = directive.subclass {\n-                    if !directive.span.is_dummy() {\n-                        resolver.session.buffer_lint(\n-                            lint::builtin::MACRO_USE_EXTERN_CRATE,\n-                            directive.id,\n-                            directive.span,\n-                            \"deprecated `#[macro_use]` directive used to \\\n-                             import macros should be replaced at use sites \\\n-                             with a `use` statement to import the macro \\\n-                             instead\",\n-                        );\n+impl Resolver<'_> {\n+    crate fn check_unused(&mut self, krate: &ast::Crate) {\n+        for directive in self.potentially_unused_imports.iter() {\n+            match directive.subclass {\n+                _ if directive.used.get() ||\n+                    directive.vis.get() == ty::Visibility::Public ||\n+                    directive.span.is_dummy() => {\n+                    if let ImportDirectiveSubclass::MacroUse = directive.subclass {\n+                        if !directive.span.is_dummy() {\n+                            self.session.buffer_lint(\n+                                lint::builtin::MACRO_USE_EXTERN_CRATE,\n+                                directive.id,\n+                                directive.span,\n+                                \"deprecated `#[macro_use]` directive used to \\\n+                                import macros should be replaced at use sites \\\n+                                with a `use` statement to import the macro \\\n+                                instead\",\n+                            );\n+                        }\n                     }\n                 }\n+                ImportDirectiveSubclass::ExternCrate { .. } => {\n+                    self.maybe_unused_extern_crates.push((directive.id, directive.span));\n+                }\n+                ImportDirectiveSubclass::MacroUse => {\n+                    let lint = lint::builtin::UNUSED_IMPORTS;\n+                    let msg = \"unused `#[macro_use]` import\";\n+                    self.session.buffer_lint(lint, directive.id, directive.span, msg);\n+                }\n+                _ => {}\n             }\n-            ImportDirectiveSubclass::ExternCrate { .. } => {\n-                resolver.maybe_unused_extern_crates.push((directive.id, directive.span));\n-            }\n-            ImportDirectiveSubclass::MacroUse => {\n-                let lint = lint::builtin::UNUSED_IMPORTS;\n-                let msg = \"unused `#[macro_use]` import\";\n-                resolver.session.buffer_lint(lint, directive.id, directive.span, msg);\n-            }\n-            _ => {}\n         }\n-    }\n-\n-    for (id, span) in resolver.unused_labels.iter() {\n-        resolver.session.buffer_lint(lint::builtin::UNUSED_LABELS, *id, *span, \"unused label\");\n-    }\n \n-    let mut visitor = UnusedImportCheckVisitor {\n-        resolver,\n-        unused_imports: Default::default(),\n-        base_use_tree: None,\n-        base_id: ast::DUMMY_NODE_ID,\n-        item_span: DUMMY_SP,\n-    };\n-    visit::walk_crate(&mut visitor, krate);\n-\n-    for unused in visitor.unused_imports.values() {\n-        let mut fixes = Vec::new();\n-        let mut spans = match calc_unused_spans(unused, unused.use_tree, unused.use_tree_id) {\n-            UnusedSpanResult::Used => continue,\n-            UnusedSpanResult::FlatUnused(span, remove) => {\n-                fixes.push((remove, String::new()));\n-                vec![span]\n-            }\n-            UnusedSpanResult::NestedFullUnused(spans, remove) => {\n-                fixes.push((remove, String::new()));\n-                spans\n-            }\n-            UnusedSpanResult::NestedPartialUnused(spans, remove) => {\n-                for fix in &remove {\n-                    fixes.push((*fix, String::new()));\n-                }\n-                spans\n-            }\n+        let mut visitor = UnusedImportCheckVisitor {\n+            r: self,\n+            unused_imports: Default::default(),\n+            base_use_tree: None,\n+            base_id: ast::DUMMY_NODE_ID,\n+            item_span: DUMMY_SP,\n         };\n+        visit::walk_crate(&mut visitor, krate);\n \n-        let len = spans.len();\n-        spans.sort();\n-        let ms = MultiSpan::from_spans(spans.clone());\n-        let mut span_snippets = spans.iter()\n-            .filter_map(|s| {\n-                match visitor.session.source_map().span_to_snippet(*s) {\n-                    Ok(s) => Some(format!(\"`{}`\", s)),\n-                    _ => None,\n+        for unused in visitor.unused_imports.values() {\n+            let mut fixes = Vec::new();\n+            let mut spans = match calc_unused_spans(unused, unused.use_tree, unused.use_tree_id) {\n+                UnusedSpanResult::Used => continue,\n+                UnusedSpanResult::FlatUnused(span, remove) => {\n+                    fixes.push((remove, String::new()));\n+                    vec![span]\n                 }\n-            }).collect::<Vec<String>>();\n-        span_snippets.sort();\n-        let msg = format!(\"unused import{}{}\",\n-                          if len > 1 { \"s\" } else { \"\" },\n-                          if !span_snippets.is_empty() {\n-                              format!(\": {}\", span_snippets.join(\", \"))\n-                          } else {\n-                              String::new()\n-                          });\n+                UnusedSpanResult::NestedFullUnused(spans, remove) => {\n+                    fixes.push((remove, String::new()));\n+                    spans\n+                }\n+                UnusedSpanResult::NestedPartialUnused(spans, remove) => {\n+                    for fix in &remove {\n+                        fixes.push((*fix, String::new()));\n+                    }\n+                    spans\n+                }\n+            };\n \n-        let fix_msg = if fixes.len() == 1 && fixes[0].0 == unused.item_span {\n-            \"remove the whole `use` item\"\n-        } else if spans.len() > 1 {\n-            \"remove the unused imports\"\n-        } else {\n-            \"remove the unused import\"\n-        };\n+            let len = spans.len();\n+            spans.sort();\n+            let ms = MultiSpan::from_spans(spans.clone());\n+            let mut span_snippets = spans.iter()\n+                .filter_map(|s| {\n+                    match visitor.r.session.source_map().span_to_snippet(*s) {\n+                        Ok(s) => Some(format!(\"`{}`\", s)),\n+                        _ => None,\n+                    }\n+                }).collect::<Vec<String>>();\n+            span_snippets.sort();\n+            let msg = format!(\"unused import{}{}\",\n+                            if len > 1 { \"s\" } else { \"\" },\n+                            if !span_snippets.is_empty() {\n+                                format!(\": {}\", span_snippets.join(\", \"))\n+                            } else {\n+                                String::new()\n+                            });\n \n-        visitor.session.buffer_lint_with_diagnostic(\n-            lint::builtin::UNUSED_IMPORTS,\n-            unused.use_tree_id,\n-            ms,\n-            &msg,\n-            lint::builtin::BuiltinLintDiagnostics::UnusedImports(fix_msg.into(), fixes),\n-        );\n+            let fix_msg = if fixes.len() == 1 && fixes[0].0 == unused.item_span {\n+                \"remove the whole `use` item\"\n+            } else if spans.len() > 1 {\n+                \"remove the unused imports\"\n+            } else {\n+                \"remove the unused import\"\n+            };\n+\n+            visitor.r.session.buffer_lint_with_diagnostic(\n+                lint::builtin::UNUSED_IMPORTS,\n+                unused.use_tree_id,\n+                ms,\n+                &msg,\n+                lint::builtin::BuiltinLintDiagnostics::UnusedImports(fix_msg.into(), fixes),\n+            );\n+        }\n     }\n }"}, {"sha": "01a4a3c4bb244fdbaa44f0c69680f1cf19419ab2", "filename": "src/librustc_resolve/diagnostics.rs", "status": "modified", "additions": 269, "deletions": 638, "changes": 907, "blob_url": "https://github.com/rust-lang/rust/blob/9d76a938de25e626a7c79a76789d7885405703e6/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d76a938de25e626a7c79a76789d7885405703e6/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=9d76a938de25e626a7c79a76789d7885405703e6", "patch": "@@ -2,55 +2,63 @@ use std::cmp::Reverse;\n \n use errors::{Applicability, DiagnosticBuilder, DiagnosticId};\n use log::debug;\n-use rustc::hir::def::{self, DefKind, CtorKind, NonMacroAttrKind};\n+use rustc::bug;\n+use rustc::hir::def::{self, DefKind, NonMacroAttrKind};\n use rustc::hir::def::Namespace::{self, *};\n use rustc::hir::def_id::{CRATE_DEF_INDEX, DefId};\n-use rustc::hir::PrimTy;\n-use rustc::session::{Session, config::nightly_options};\n+use rustc::session::Session;\n use rustc::ty::{self, DefIdTree};\n use rustc::util::nodemap::FxHashSet;\n-use syntax::ast::{self, Expr, ExprKind, Ident, NodeId, Path, Ty, TyKind};\n+use syntax::ast::{self, Ident, Path};\n use syntax::ext::base::MacroKind;\n use syntax::feature_gate::BUILTIN_ATTRIBUTES;\n+use syntax::source_map::SourceMap;\n+use syntax::struct_span_err;\n use syntax::symbol::{Symbol, kw};\n use syntax::util::lev_distance::find_best_match_for_name;\n-use syntax_pos::{BytePos, Span};\n+use syntax_pos::{BytePos, Span, MultiSpan};\n \n use crate::resolve_imports::{ImportDirective, ImportDirectiveSubclass, ImportResolver};\n-use crate::{is_self_type, is_self_value, path_names_to_string, KNOWN_TOOLS};\n-use crate::{CrateLint, LegacyScope, Module, ModuleKind, ModuleOrUniformRoot};\n-use crate::{PathResult, PathSource, ParentScope, Resolver, RibKind, Scope, ScopeSet, Segment};\n+use crate::{path_names_to_string, KNOWN_TOOLS};\n+use crate::{CrateLint, LegacyScope, Module, ModuleOrUniformRoot};\n+use crate::{PathResult, ParentScope, ResolutionError, Resolver, Scope, ScopeSet, Segment};\n \n type Res = def::Res<ast::NodeId>;\n \n /// A vector of spans and replacements, a message and applicability.\n crate type Suggestion = (Vec<(Span, String)>, String, Applicability);\n \n-/// A field or associated item from self type suggested in case of resolution failure.\n-enum AssocSuggestion {\n-    Field,\n-    MethodWithSelf,\n-    AssocItem,\n-}\n-\n-struct TypoSuggestion {\n-    candidate: Symbol,\n-    res: Res,\n+crate struct TypoSuggestion {\n+    pub candidate: Symbol,\n+    pub res: Res,\n }\n \n impl TypoSuggestion {\n-    fn from_res(candidate: Symbol, res: Res) -> TypoSuggestion {\n+    crate fn from_res(candidate: Symbol, res: Res) -> TypoSuggestion {\n         TypoSuggestion { candidate, res }\n     }\n }\n \n /// A free importable items suggested in case of resolution failure.\n crate struct ImportSuggestion {\n-    did: Option<DefId>,\n+    pub did: Option<DefId>,\n     pub path: Path,\n }\n \n-fn add_typo_suggestion(\n+/// Adjust the impl span so that just the `impl` keyword is taken by removing\n+/// everything after `<` (`\"impl<T> Iterator for A<T> {}\" -> \"impl\"`) and\n+/// everything after the first whitespace (`\"impl Iterator for A\" -> \"impl\"`).\n+///\n+/// *Attention*: the method used is very fragile since it essentially duplicates the work of the\n+/// parser. If you need to use this function or something similar, please consider updating the\n+/// `source_map` functions and this function to something more robust.\n+fn reduce_impl_span_to_impl_keyword(cm: &SourceMap, impl_span: Span) -> Span {\n+    let impl_span = cm.span_until_char(impl_span, '<');\n+    let impl_span = cm.span_until_whitespace(impl_span);\n+    impl_span\n+}\n+\n+crate fn add_typo_suggestion(\n     err: &mut DiagnosticBuilder<'_>, suggestion: Option<TypoSuggestion>, span: Span\n ) -> bool {\n     if let Some(suggestion) = suggestion {\n@@ -65,7 +73,7 @@ fn add_typo_suggestion(\n     false\n }\n \n-fn add_module_candidates(\n+crate fn add_module_candidates(\n     module: Module<'_>, names: &mut Vec<TypoSuggestion>, filter_fn: &impl Fn(Res) -> bool\n ) {\n     for (&(ident, _), resolution) in module.resolutions.borrow().iter() {\n@@ -79,479 +87,267 @@ fn add_module_candidates(\n }\n \n impl<'a> Resolver<'a> {\n-    /// Handles error reporting for `smart_resolve_path_fragment` function.\n-    /// Creates base error and amends it with one short label and possibly some longer helps/notes.\n-    pub(crate) fn smart_resolve_report_errors(\n-        &mut self,\n-        path: &[Segment],\n-        span: Span,\n-        source: PathSource<'_>,\n-        res: Option<Res>,\n-    ) -> (DiagnosticBuilder<'a>, Vec<ImportSuggestion>) {\n-        let ident_span = path.last().map_or(span, |ident| ident.ident.span);\n-        let ns = source.namespace();\n-        let is_expected = &|res| source.is_expected(res);\n-        let is_enum_variant = &|res| {\n-            if let Res::Def(DefKind::Variant, _) = res { true } else { false }\n-        };\n-\n-        // Make the base error.\n-        let expected = source.descr_expected();\n-        let path_str = Segment::names_to_string(path);\n-        let item_str = path.last().unwrap().ident;\n-        let code = source.error_code(res.is_some());\n-        let (base_msg, fallback_label, base_span) = if let Some(res) = res {\n-            (format!(\"expected {}, found {} `{}`\", expected, res.descr(), path_str),\n-                format!(\"not a {}\", expected),\n-                span)\n-        } else {\n-            let item_span = path.last().unwrap().ident.span;\n-            let (mod_prefix, mod_str) = if path.len() == 1 {\n-                (String::new(), \"this scope\".to_string())\n-            } else if path.len() == 2 && path[0].ident.name == kw::PathRoot {\n-                (String::new(), \"the crate root\".to_string())\n-            } else {\n-                let mod_path = &path[..path.len() - 1];\n-                let mod_prefix = match self.resolve_path_without_parent_scope(\n-                    mod_path, Some(TypeNS), false, span, CrateLint::No\n-                ) {\n-                    PathResult::Module(ModuleOrUniformRoot::Module(module)) =>\n-                        module.def_kind(),\n-                    _ => None,\n-                }.map_or(String::new(), |kind| format!(\"{} \", kind.descr()));\n-                (mod_prefix, format!(\"`{}`\", Segment::names_to_string(mod_path)))\n-            };\n-            (format!(\"cannot find {} `{}` in {}{}\", expected, item_str, mod_prefix, mod_str),\n-                format!(\"not found in {}\", mod_str),\n-                item_span)\n-        };\n-\n-        let code = DiagnosticId::Error(code.into());\n-        let mut err = self.session.struct_span_err_with_code(base_span, &base_msg, code);\n-\n-        // Emit help message for fake-self from other languages (e.g., `this` in Javascript).\n-        if [\"this\", \"my\"].contains(&&*item_str.as_str())\n-            && self.self_value_is_available(path[0].ident.span, span) {\n-            err.span_suggestion(\n-                span,\n-                \"did you mean\",\n-                \"self\".to_string(),\n-                Applicability::MaybeIncorrect,\n-            );\n-        }\n-\n-        // Emit special messages for unresolved `Self` and `self`.\n-        if is_self_type(path, ns) {\n-            __diagnostic_used!(E0411);\n-            err.code(DiagnosticId::Error(\"E0411\".into()));\n-            err.span_label(span, format!(\"`Self` is only available in impls, traits, \\\n-                                          and type definitions\"));\n-            return (err, Vec::new());\n-        }\n-        if is_self_value(path, ns) {\n-            debug!(\"smart_resolve_path_fragment: E0424, source={:?}\", source);\n-\n-            __diagnostic_used!(E0424);\n-            err.code(DiagnosticId::Error(\"E0424\".into()));\n-            err.span_label(span, match source {\n-                PathSource::Pat => {\n-                    format!(\"`self` value is a keyword \\\n-                             and may not be bound to \\\n-                             variables or shadowed\")\n-                }\n-                _ => {\n-                    format!(\"`self` value is a keyword \\\n-                             only available in methods \\\n-                             with `self` parameter\")\n-                }\n-            });\n-            return (err, Vec::new());\n-        }\n-\n-        // Try to lookup name in more relaxed fashion for better error reporting.\n-        let ident = path.last().unwrap().ident;\n-        let candidates = self.lookup_import_candidates(ident, ns, is_expected)\n-            .drain(..)\n-            .filter(|ImportSuggestion { did, .. }| {\n-                match (did, res.and_then(|res| res.opt_def_id())) {\n-                    (Some(suggestion_did), Some(actual_did)) => *suggestion_did != actual_did,\n-                    _ => true,\n-                }\n-            })\n-            .collect::<Vec<_>>();\n-        let crate_def_id = DefId::local(CRATE_DEF_INDEX);\n-        if candidates.is_empty() && is_expected(Res::Def(DefKind::Enum, crate_def_id)) {\n-            let enum_candidates =\n-                self.lookup_import_candidates(ident, ns, is_enum_variant);\n-            let mut enum_candidates = enum_candidates.iter()\n-                .map(|suggestion| {\n-                    import_candidate_to_enum_paths(&suggestion)\n-                }).collect::<Vec<_>>();\n-            enum_candidates.sort();\n-\n-            if !enum_candidates.is_empty() {\n-                // Contextualize for E0412 \"cannot find type\", but don't belabor the point\n-                // (that it's a variant) for E0573 \"expected type, found variant\".\n-                let preamble = if res.is_none() {\n-                    let others = match enum_candidates.len() {\n-                        1 => String::new(),\n-                        2 => \" and 1 other\".to_owned(),\n-                        n => format!(\" and {} others\", n)\n-                    };\n-                    format!(\"there is an enum variant `{}`{}; \",\n-                            enum_candidates[0].0, others)\n-                } else {\n-                    String::new()\n-                };\n-                let msg = format!(\"{}try using the variant's enum\", preamble);\n+    /// Combines an error with provided span and emits it.\n+    ///\n+    /// This takes the error provided, combines it with the span and any additional spans inside the\n+    /// error and emits it.\n+    crate fn report_error(&self, span: Span, resolution_error: ResolutionError<'_>) {\n+        self.into_struct_error(span, resolution_error).emit();\n+    }\n \n-                err.span_suggestions(\n+    crate fn into_struct_error(\n+        &self, span: Span, resolution_error: ResolutionError<'_>\n+    ) -> DiagnosticBuilder<'_> {\n+        match resolution_error {\n+            ResolutionError::GenericParamsFromOuterFunction(outer_res) => {\n+                let mut err = struct_span_err!(self.session,\n                     span,\n-                    &msg,\n-                    enum_candidates.into_iter()\n-                        .map(|(_variant_path, enum_ty_path)| enum_ty_path)\n-                        // Variants re-exported in prelude doesn't mean `prelude::v1` is the\n-                        // type name!\n-                        // FIXME: is there a more principled way to do this that\n-                        // would work for other re-exports?\n-                        .filter(|enum_ty_path| enum_ty_path != \"std::prelude::v1\")\n-                        // Also write `Option` rather than `std::prelude::v1::Option`.\n-                        .map(|enum_ty_path| {\n-                            // FIXME #56861: DRY-er prelude filtering.\n-                            enum_ty_path.trim_start_matches(\"std::prelude::v1::\").to_owned()\n-                        }),\n-                    Applicability::MachineApplicable,\n+                    E0401,\n+                    \"can't use generic parameters from outer function\",\n                 );\n-            }\n-        }\n-        if path.len() == 1 && self.self_type_is_available(span) {\n-            if let Some(candidate) = self.lookup_assoc_candidate(ident, ns, is_expected) {\n-                let self_is_available = self.self_value_is_available(path[0].ident.span, span);\n-                match candidate {\n-                    AssocSuggestion::Field => {\n-                        if self_is_available {\n-                            err.span_suggestion(\n-                                span,\n-                                \"you might have meant to use the available field\",\n-                                format!(\"self.{}\", path_str),\n-                                Applicability::MachineApplicable,\n-                            );\n-                        } else {\n+                err.span_label(span, format!(\"use of generic parameter from outer function\"));\n+\n+                let cm = self.session.source_map();\n+                match outer_res {\n+                    Res::SelfTy(maybe_trait_defid, maybe_impl_defid) => {\n+                        if let Some(impl_span) = maybe_impl_defid.and_then(|def_id| {\n+                            self.definitions.opt_span(def_id)\n+                        }) {\n                             err.span_label(\n-                                span,\n-                                \"a field by this name exists in `Self`\",\n+                                reduce_impl_span_to_impl_keyword(cm, impl_span),\n+                                \"`Self` type implicitly declared here, by this `impl`\",\n                             );\n                         }\n+                        match (maybe_trait_defid, maybe_impl_defid) {\n+                            (Some(_), None) => {\n+                                err.span_label(span, \"can't use `Self` here\");\n+                            }\n+                            (_, Some(_)) => {\n+                                err.span_label(span, \"use a type here instead\");\n+                            }\n+                            (None, None) => bug!(\"`impl` without trait nor type?\"),\n+                        }\n+                        return err;\n+                    },\n+                    Res::Def(DefKind::TyParam, def_id) => {\n+                        if let Some(span) = self.definitions.opt_span(def_id) {\n+                            err.span_label(span, \"type parameter from outer function\");\n+                        }\n                     }\n-                    AssocSuggestion::MethodWithSelf if self_is_available => {\n-                        err.span_suggestion(\n-                            span,\n-                            \"try\",\n-                            format!(\"self.{}\", path_str),\n-                            Applicability::MachineApplicable,\n-                        );\n+                    Res::Def(DefKind::ConstParam, def_id) => {\n+                        if let Some(span) = self.definitions.opt_span(def_id) {\n+                            err.span_label(span, \"const parameter from outer function\");\n+                        }\n                     }\n-                    AssocSuggestion::MethodWithSelf | AssocSuggestion::AssocItem => {\n-                        err.span_suggestion(\n-                            span,\n-                            \"try\",\n-                            format!(\"Self::{}\", path_str),\n-                            Applicability::MachineApplicable,\n-                        );\n+                    _ => {\n+                        bug!(\"GenericParamsFromOuterFunction should only be used with Res::SelfTy, \\\n+                            DefKind::TyParam\");\n                     }\n                 }\n-                return (err, candidates);\n-            }\n-        }\n \n-        // Try Levenshtein algorithm.\n-        let levenshtein_worked = add_typo_suggestion(\n-            &mut err, self.lookup_typo_candidate(path, ns, is_expected, span), ident_span\n-        );\n+                // Try to retrieve the span of the function signature and generate a new message\n+                // with a local type or const parameter.\n+                let sugg_msg = &format!(\"try using a local generic parameter instead\");\n+                if let Some((sugg_span, new_snippet)) = cm.generate_local_type_param_snippet(span) {\n+                    // Suggest the modification to the user\n+                    err.span_suggestion(\n+                        sugg_span,\n+                        sugg_msg,\n+                        new_snippet,\n+                        Applicability::MachineApplicable,\n+                    );\n+                } else if let Some(sp) = cm.generate_fn_name_span(span) {\n+                    err.span_label(sp,\n+                        format!(\"try adding a local generic parameter in this method instead\"));\n+                } else {\n+                    err.help(&format!(\"try using a local generic parameter instead\"));\n+                }\n \n-        // Try context-dependent help if relaxed lookup didn't work.\n-        if let Some(res) = res {\n-            if self.smart_resolve_context_dependent_help(&mut err,\n-                                                         span,\n-                                                         source,\n-                                                         res,\n-                                                         &path_str,\n-                                                         &fallback_label) {\n-                return (err, candidates);\n+                err\n             }\n-        }\n-\n-        // Fallback label.\n-        if !levenshtein_worked {\n-            err.span_label(base_span, fallback_label);\n-            self.type_ascription_suggestion(&mut err, base_span);\n-        }\n-        (err, candidates)\n-    }\n-\n-    fn followed_by_brace(&self, span: Span) -> (bool, Option<(Span, String)>) {\n-        // HACK(estebank): find a better way to figure out that this was a\n-        // parser issue where a struct literal is being used on an expression\n-        // where a brace being opened means a block is being started. Look\n-        // ahead for the next text to see if `span` is followed by a `{`.\n-        let sm = self.session.source_map();\n-        let mut sp = span;\n-        loop {\n-            sp = sm.next_point(sp);\n-            match sm.span_to_snippet(sp) {\n-                Ok(ref snippet) => {\n-                    if snippet.chars().any(|c| { !c.is_whitespace() }) {\n-                        break;\n-                    }\n-                }\n-                _ => break,\n+            ResolutionError::NameAlreadyUsedInParameterList(name, first_use_span) => {\n+                let mut err = struct_span_err!(self.session,\n+                                                span,\n+                                                E0403,\n+                                                \"the name `{}` is already used for a generic \\\n+                                                parameter in this list of generic parameters\",\n+                                                name);\n+                err.span_label(span, \"already used\");\n+                err.span_label(first_use_span, format!(\"first use of `{}`\", name));\n+                err\n             }\n-        }\n-        let followed_by_brace = match sm.span_to_snippet(sp) {\n-            Ok(ref snippet) if snippet == \"{\" => true,\n-            _ => false,\n-        };\n-        // In case this could be a struct literal that needs to be surrounded\n-        // by parenthesis, find the appropriate span.\n-        let mut i = 0;\n-        let mut closing_brace = None;\n-        loop {\n-            sp = sm.next_point(sp);\n-            match sm.span_to_snippet(sp) {\n-                Ok(ref snippet) => {\n-                    if snippet == \"}\" {\n-                        let sp = span.to(sp);\n-                        if let Ok(snippet) = sm.span_to_snippet(sp) {\n-                            closing_brace = Some((sp, snippet));\n-                        }\n-                        break;\n-                    }\n-                }\n-                _ => break,\n+            ResolutionError::MethodNotMemberOfTrait(method, trait_) => {\n+                let mut err = struct_span_err!(self.session,\n+                                            span,\n+                                            E0407,\n+                                            \"method `{}` is not a member of trait `{}`\",\n+                                            method,\n+                                            trait_);\n+                err.span_label(span, format!(\"not a member of trait `{}`\", trait_));\n+                err\n             }\n-            i += 1;\n-            // The bigger the span, the more likely we're incorrect --\n-            // bound it to 100 chars long.\n-            if i > 100 {\n-                break;\n+            ResolutionError::TypeNotMemberOfTrait(type_, trait_) => {\n+                let mut err = struct_span_err!(self.session,\n+                                span,\n+                                E0437,\n+                                \"type `{}` is not a member of trait `{}`\",\n+                                type_,\n+                                trait_);\n+                err.span_label(span, format!(\"not a member of trait `{}`\", trait_));\n+                err\n             }\n-        }\n-        return (followed_by_brace, closing_brace)\n-    }\n-\n-    /// Provides context-dependent help for errors reported by the `smart_resolve_path_fragment`\n-    /// function.\n-    /// Returns `true` if able to provide context-dependent help.\n-    fn smart_resolve_context_dependent_help(\n-        &mut self,\n-        err: &mut DiagnosticBuilder<'a>,\n-        span: Span,\n-        source: PathSource<'_>,\n-        res: Res,\n-        path_str: &str,\n-        fallback_label: &str,\n-    ) -> bool {\n-        let ns = source.namespace();\n-        let is_expected = &|res| source.is_expected(res);\n-\n-        let path_sep = |err: &mut DiagnosticBuilder<'_>, expr: &Expr| match expr.node {\n-            ExprKind::Field(_, ident) => {\n-                err.span_suggestion(\n-                    expr.span,\n-                    \"use the path separator to refer to an item\",\n-                    format!(\"{}::{}\", path_str, ident),\n-                    Applicability::MaybeIncorrect,\n-                );\n-                true\n+            ResolutionError::ConstNotMemberOfTrait(const_, trait_) => {\n+                let mut err = struct_span_err!(self.session,\n+                                span,\n+                                E0438,\n+                                \"const `{}` is not a member of trait `{}`\",\n+                                const_,\n+                                trait_);\n+                err.span_label(span, format!(\"not a member of trait `{}`\", trait_));\n+                err\n             }\n-            ExprKind::MethodCall(ref segment, ..) => {\n-                let span = expr.span.with_hi(segment.ident.span.hi());\n-                err.span_suggestion(\n-                    span,\n-                    \"use the path separator to refer to an item\",\n-                    format!(\"{}::{}\", path_str, segment.ident),\n-                    Applicability::MaybeIncorrect,\n+            ResolutionError::VariableNotBoundInPattern(binding_error) => {\n+                let target_sp = binding_error.target.iter().cloned().collect::<Vec<_>>();\n+                let msp = MultiSpan::from_spans(target_sp.clone());\n+                let msg = format!(\"variable `{}` is not bound in all patterns\", binding_error.name);\n+                let mut err = self.session.struct_span_err_with_code(\n+                    msp,\n+                    &msg,\n+                    DiagnosticId::Error(\"E0408\".into()),\n                 );\n-                true\n-            }\n-            _ => false,\n-        };\n-\n-        let mut bad_struct_syntax_suggestion = || {\n-            let (followed_by_brace, closing_brace) = self.followed_by_brace(span);\n-            let mut suggested = false;\n-            match source {\n-                PathSource::Expr(Some(parent)) => {\n-                    suggested = path_sep(err, &parent);\n+                for sp in target_sp {\n+                    err.span_label(sp, format!(\"pattern doesn't bind `{}`\", binding_error.name));\n                 }\n-                PathSource::Expr(None) if followed_by_brace == true => {\n-                    if let Some((sp, snippet)) = closing_brace {\n-                        err.span_suggestion(\n-                            sp,\n-                            \"surround the struct literal with parenthesis\",\n-                            format!(\"({})\", snippet),\n-                            Applicability::MaybeIncorrect,\n-                        );\n-                    } else {\n-                        err.span_label(\n-                            span,  // Note the parenthesis surrounding the suggestion below\n-                            format!(\"did you mean `({} {{ /* fields */ }})`?\", path_str),\n-                        );\n-                    }\n-                    suggested = true;\n-                },\n-                _ => {}\n-            }\n-            if !suggested {\n-                err.span_label(\n-                    span,\n-                    format!(\"did you mean `{} {{ /* fields */ }}`?\", path_str),\n-                );\n-            }\n-        };\n-\n-        match (res, source) {\n-            (Res::Def(DefKind::Macro(MacroKind::Bang), _), _) => {\n-                err.span_suggestion(\n-                    span,\n-                    \"use `!` to invoke the macro\",\n-                    format!(\"{}!\", path_str),\n-                    Applicability::MaybeIncorrect,\n-                );\n-                if path_str == \"try\" && span.rust_2015() {\n-                    err.note(\"if you want the `try` keyword, you need to be in the 2018 edition\");\n+                let origin_sp = binding_error.origin.iter().cloned();\n+                for sp in origin_sp {\n+                    err.span_label(sp, \"variable not in all patterns\");\n                 }\n+                err\n             }\n-            (Res::Def(DefKind::TyAlias, _), PathSource::Trait(_)) => {\n-                err.span_label(span, \"type aliases cannot be used as traits\");\n-                if nightly_options::is_nightly_build() {\n-                    err.note(\"did you mean to use a trait alias?\");\n-                }\n+            ResolutionError::VariableBoundWithDifferentMode(variable_name,\n+                                                            first_binding_span) => {\n+                let mut err = struct_span_err!(self.session,\n+                                span,\n+                                E0409,\n+                                \"variable `{}` is bound in inconsistent \\\n+                                ways within the same match arm\",\n+                                variable_name);\n+                err.span_label(span, \"bound in different ways\");\n+                err.span_label(first_binding_span, \"first binding\");\n+                err\n             }\n-            (Res::Def(DefKind::Mod, _), PathSource::Expr(Some(parent))) => {\n-                if !path_sep(err, &parent) {\n-                    return false;\n-                }\n+            ResolutionError::IdentifierBoundMoreThanOnceInParameterList(identifier) => {\n+                let mut err = struct_span_err!(self.session,\n+                                span,\n+                                E0415,\n+                                \"identifier `{}` is bound more than once in this parameter list\",\n+                                identifier);\n+                err.span_label(span, \"used as parameter more than once\");\n+                err\n             }\n-            (Res::Def(DefKind::Enum, def_id), PathSource::TupleStruct)\n-                | (Res::Def(DefKind::Enum, def_id), PathSource::Expr(..))  => {\n-                if let Some(variants) = self.collect_enum_variants(def_id) {\n-                    if !variants.is_empty() {\n-                        let msg = if variants.len() == 1 {\n-                            \"try using the enum's variant\"\n-                        } else {\n-                            \"try using one of the enum's variants\"\n-                        };\n-\n-                        err.span_suggestions(\n-                            span,\n-                            msg,\n-                            variants.iter().map(path_names_to_string),\n-                            Applicability::MaybeIncorrect,\n-                        );\n-                    }\n-                } else {\n-                    err.note(\"did you mean to use one of the enum's variants?\");\n-                }\n-            },\n-            (Res::Def(DefKind::Struct, def_id), _) if ns == ValueNS => {\n-                if let Some((ctor_def, ctor_vis))\n-                        = self.struct_constructors.get(&def_id).cloned() {\n-                    let accessible_ctor = self.is_accessible(ctor_vis);\n-                    if is_expected(ctor_def) && !accessible_ctor {\n-                        err.span_label(\n-                            span,\n-                            format!(\"constructor is not visible here due to private fields\"),\n-                        );\n-                    }\n+            ResolutionError::IdentifierBoundMoreThanOnceInSamePattern(identifier) => {\n+                let mut err = struct_span_err!(self.session,\n+                                span,\n+                                E0416,\n+                                \"identifier `{}` is bound more than once in the same pattern\",\n+                                identifier);\n+                err.span_label(span, \"used in a pattern more than once\");\n+                err\n+            }\n+            ResolutionError::UndeclaredLabel(name, lev_candidate) => {\n+                let mut err = struct_span_err!(self.session,\n+                                            span,\n+                                            E0426,\n+                                            \"use of undeclared label `{}`\",\n+                                            name);\n+                if let Some(lev_candidate) = lev_candidate {\n+                    err.span_suggestion(\n+                        span,\n+                        \"a label with a similar name exists in this scope\",\n+                        lev_candidate.to_string(),\n+                        Applicability::MaybeIncorrect,\n+                    );\n                 } else {\n-                    bad_struct_syntax_suggestion();\n+                    err.span_label(span, format!(\"undeclared label `{}`\", name));\n                 }\n+                err\n             }\n-            (Res::Def(DefKind::Union, _), _) |\n-            (Res::Def(DefKind::Variant, _), _) |\n-            (Res::Def(DefKind::Ctor(_, CtorKind::Fictive), _), _) if ns == ValueNS => {\n-                bad_struct_syntax_suggestion();\n+            ResolutionError::SelfImportsOnlyAllowedWithin => {\n+                struct_span_err!(self.session,\n+                                span,\n+                                E0429,\n+                                \"{}\",\n+                                \"`self` imports are only allowed within a { } list\")\n             }\n-            (Res::SelfTy(..), _) if ns == ValueNS => {\n-                err.span_label(span, fallback_label);\n-                err.note(\"can't use `Self` as a constructor, you must use the implemented struct\");\n+            ResolutionError::SelfImportCanOnlyAppearOnceInTheList => {\n+                let mut err = struct_span_err!(self.session, span, E0430,\n+                                            \"`self` import can only appear once in an import list\");\n+                err.span_label(span, \"can only appear once in an import list\");\n+                err\n             }\n-            (Res::Def(DefKind::TyAlias, _), _)\n-            | (Res::Def(DefKind::AssocTy, _), _) if ns == ValueNS => {\n-                err.note(\"can't use a type alias as a constructor\");\n+            ResolutionError::SelfImportOnlyInImportListWithNonEmptyPrefix => {\n+                let mut err = struct_span_err!(self.session, span, E0431,\n+                                            \"`self` import can only appear in an import list with \\\n+                                                a non-empty prefix\");\n+                err.span_label(span, \"can only appear in an import list with a non-empty prefix\");\n+                err\n             }\n-            _ => return false,\n-        }\n-        true\n-    }\n+            ResolutionError::FailedToResolve { label, suggestion } => {\n+                let mut err = struct_span_err!(self.session, span, E0433,\n+                                            \"failed to resolve: {}\", &label);\n+                err.span_label(span, label);\n \n-    fn lookup_assoc_candidate<FilterFn>(&mut self,\n-                                        ident: Ident,\n-                                        ns: Namespace,\n-                                        filter_fn: FilterFn)\n-                                        -> Option<AssocSuggestion>\n-        where FilterFn: Fn(Res) -> bool\n-    {\n-        fn extract_node_id(t: &Ty) -> Option<NodeId> {\n-            match t.node {\n-                TyKind::Path(None, _) => Some(t.id),\n-                TyKind::Rptr(_, ref mut_ty) => extract_node_id(&mut_ty.ty),\n-                // This doesn't handle the remaining `Ty` variants as they are not\n-                // that commonly the self_type, it might be interesting to provide\n-                // support for those in future.\n-                _ => None,\n-            }\n-        }\n-\n-        // Fields are generally expected in the same contexts as locals.\n-        if filter_fn(Res::Local(ast::DUMMY_NODE_ID)) {\n-            if let Some(node_id) = self.current_self_type.as_ref().and_then(extract_node_id) {\n-                // Look for a field with the same name in the current self_type.\n-                if let Some(resolution) = self.partial_res_map.get(&node_id) {\n-                    match resolution.base_res() {\n-                        Res::Def(DefKind::Struct, did) | Res::Def(DefKind::Union, did)\n-                                if resolution.unresolved_segments() == 0 => {\n-                            if let Some(field_names) = self.field_names.get(&did) {\n-                                if field_names.iter().any(|&field_name| ident.name == field_name) {\n-                                    return Some(AssocSuggestion::Field);\n-                                }\n-                            }\n-                        }\n-                        _ => {}\n-                    }\n+                if let Some((suggestions, msg, applicability)) = suggestion {\n+                    err.multipart_suggestion(&msg, suggestions, applicability);\n                 }\n-            }\n-        }\n \n-        for assoc_type_ident in &self.current_trait_assoc_types {\n-            if *assoc_type_ident == ident {\n-                return Some(AssocSuggestion::AssocItem);\n+                err\n             }\n-        }\n-\n-        // Look for associated items in the current trait.\n-        if let Some((module, _)) = self.current_trait_ref {\n-            if let Ok(binding) = self.resolve_ident_in_module(\n-                    ModuleOrUniformRoot::Module(module),\n-                    ident,\n-                    ns,\n-                    None,\n-                    false,\n-                    module.span,\n-                ) {\n-                let res = binding.res();\n-                if filter_fn(res) {\n-                    return Some(if self.has_self.contains(&res.def_id()) {\n-                        AssocSuggestion::MethodWithSelf\n-                    } else {\n-                        AssocSuggestion::AssocItem\n-                    });\n-                }\n+            ResolutionError::CannotCaptureDynamicEnvironmentInFnItem => {\n+                let mut err = struct_span_err!(self.session,\n+                                            span,\n+                                            E0434,\n+                                            \"{}\",\n+                                            \"can't capture dynamic environment in a fn item\");\n+                err.help(\"use the `|| { ... }` closure form instead\");\n+                err\n+            }\n+            ResolutionError::AttemptToUseNonConstantValueInConstant => {\n+                let mut err = struct_span_err!(self.session, span, E0435,\n+                                            \"attempt to use a non-constant value in a constant\");\n+                err.span_label(span, \"non-constant value\");\n+                err\n+            }\n+            ResolutionError::BindingShadowsSomethingUnacceptable(what_binding, name, binding) => {\n+                let shadows_what = binding.descr();\n+                let mut err = struct_span_err!(self.session, span, E0530, \"{}s cannot shadow {}s\",\n+                                            what_binding, shadows_what);\n+                err.span_label(span, format!(\"cannot be named the same as {} {}\",\n+                                            binding.article(), shadows_what));\n+                let participle = if binding.is_import() { \"imported\" } else { \"defined\" };\n+                let msg = format!(\"the {} `{}` is {} here\", shadows_what, name, participle);\n+                err.span_label(binding.span, msg);\n+                err\n+            }\n+            ResolutionError::ForwardDeclaredTyParam => {\n+                let mut err = struct_span_err!(self.session, span, E0128,\n+                                            \"type parameters with a default cannot use \\\n+                                                forward declared identifiers\");\n+                err.span_label(\n+                    span, \"defaulted type parameters cannot be forward declared\".to_string());\n+                err\n+            }\n+            ResolutionError::ConstParamDependentOnTypeParam => {\n+                let mut err = struct_span_err!(\n+                    self.session,\n+                    span,\n+                    E0671,\n+                    \"const parameters cannot depend on type parameters\"\n+                );\n+                err.span_label(span, format!(\"const parameter depends on type parameter\"));\n+                err\n             }\n         }\n-\n-        None\n     }\n \n     /// Lookup typo candidate in scope for a macro or import.\n@@ -569,9 +365,10 @@ impl<'a> Resolver<'a> {\n                     let res = Res::NonMacroAttr(NonMacroAttrKind::DeriveHelper);\n                     if filter_fn(res) {\n                         for derive in &parent_scope.derives {\n-                            let parent_scope = ParentScope { derives: Vec::new(), ..*parent_scope };\n+                            let parent_scope =\n+                                &ParentScope { derives: Vec::new(), ..*parent_scope };\n                             if let Ok((Some(ext), _)) = this.resolve_macro_path(\n-                                derive, Some(MacroKind::Derive), &parent_scope, false, false\n+                                derive, Some(MacroKind::Derive), parent_scope, false, false\n                             ) {\n                                 suggestions.extend(ext.helper_attrs.iter().map(|name| {\n                                     TypoSuggestion::from_res(*name, res)\n@@ -683,98 +480,6 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n-    fn lookup_typo_candidate(\n-        &mut self,\n-        path: &[Segment],\n-        ns: Namespace,\n-        filter_fn: &impl Fn(Res) -> bool,\n-        span: Span,\n-    ) -> Option<TypoSuggestion> {\n-        let mut names = Vec::new();\n-        if path.len() == 1 {\n-            // Search in lexical scope.\n-            // Walk backwards up the ribs in scope and collect candidates.\n-            for rib in self.ribs[ns].iter().rev() {\n-                // Locals and type parameters\n-                for (ident, &res) in &rib.bindings {\n-                    if filter_fn(res) {\n-                        names.push(TypoSuggestion::from_res(ident.name, res));\n-                    }\n-                }\n-                // Items in scope\n-                if let RibKind::ModuleRibKind(module) = rib.kind {\n-                    // Items from this module\n-                    add_module_candidates(module, &mut names, &filter_fn);\n-\n-                    if let ModuleKind::Block(..) = module.kind {\n-                        // We can see through blocks\n-                    } else {\n-                        // Items from the prelude\n-                        if !module.no_implicit_prelude {\n-                            names.extend(self.extern_prelude.clone().iter().flat_map(|(ident, _)| {\n-                                self.crate_loader\n-                                    .maybe_process_path_extern(ident.name, ident.span)\n-                                    .and_then(|crate_id| {\n-                                        let crate_mod = Res::Def(\n-                                            DefKind::Mod,\n-                                            DefId {\n-                                                krate: crate_id,\n-                                                index: CRATE_DEF_INDEX,\n-                                            },\n-                                        );\n-\n-                                        if filter_fn(crate_mod) {\n-                                            Some(TypoSuggestion::from_res(ident.name, crate_mod))\n-                                        } else {\n-                                            None\n-                                        }\n-                                    })\n-                            }));\n-\n-                            if let Some(prelude) = self.prelude {\n-                                add_module_candidates(prelude, &mut names, &filter_fn);\n-                            }\n-                        }\n-                        break;\n-                    }\n-                }\n-            }\n-            // Add primitive types to the mix\n-            if filter_fn(Res::PrimTy(PrimTy::Bool)) {\n-                names.extend(\n-                    self.primitive_type_table.primitive_types.iter().map(|(name, prim_ty)| {\n-                        TypoSuggestion::from_res(*name, Res::PrimTy(*prim_ty))\n-                    })\n-                )\n-            }\n-        } else {\n-            // Search in module.\n-            let mod_path = &path[..path.len() - 1];\n-            if let PathResult::Module(module) = self.resolve_path_without_parent_scope(\n-                mod_path, Some(TypeNS), false, span, CrateLint::No\n-            ) {\n-                if let ModuleOrUniformRoot::Module(module) = module {\n-                    add_module_candidates(module, &mut names, &filter_fn);\n-                }\n-            }\n-        }\n-\n-        let name = path[path.len() - 1].ident.name;\n-        // Make sure error reporting is deterministic.\n-        names.sort_by_cached_key(|suggestion| suggestion.candidate.as_str());\n-\n-        match find_best_match_for_name(\n-            names.iter().map(|suggestion| &suggestion.candidate),\n-            &name.as_str(),\n-            None,\n-        ) {\n-            Some(found) if found != name => names\n-                .into_iter()\n-                .find(|suggestion| suggestion.candidate == found),\n-            _ => None,\n-        }\n-    }\n-\n     fn lookup_import_candidates_from_module<FilterFn>(&mut self,\n                                           lookup_ident: Ident,\n                                           namespace: Namespace,\n@@ -901,65 +606,6 @@ impl<'a> Resolver<'a> {\n         suggestions\n     }\n \n-    fn find_module(&mut self, def_id: DefId) -> Option<(Module<'a>, ImportSuggestion)> {\n-        let mut result = None;\n-        let mut seen_modules = FxHashSet::default();\n-        let mut worklist = vec![(self.graph_root, Vec::new())];\n-\n-        while let Some((in_module, path_segments)) = worklist.pop() {\n-            // abort if the module is already found\n-            if result.is_some() { break; }\n-\n-            self.populate_module_if_necessary(in_module);\n-\n-            in_module.for_each_child_stable(|ident, _, name_binding| {\n-                // abort if the module is already found or if name_binding is private external\n-                if result.is_some() || !name_binding.vis.is_visible_locally() {\n-                    return\n-                }\n-                if let Some(module) = name_binding.module() {\n-                    // form the path\n-                    let mut path_segments = path_segments.clone();\n-                    path_segments.push(ast::PathSegment::from_ident(ident));\n-                    let module_def_id = module.def_id().unwrap();\n-                    if module_def_id == def_id {\n-                        let path = Path {\n-                            span: name_binding.span,\n-                            segments: path_segments,\n-                        };\n-                        result = Some((module, ImportSuggestion { did: Some(def_id), path }));\n-                    } else {\n-                        // add the module to the lookup\n-                        if seen_modules.insert(module_def_id) {\n-                            worklist.push((module, path_segments));\n-                        }\n-                    }\n-                }\n-            });\n-        }\n-\n-        result\n-    }\n-\n-    fn collect_enum_variants(&mut self, def_id: DefId) -> Option<Vec<Path>> {\n-        self.find_module(def_id).map(|(enum_module, enum_import_suggestion)| {\n-            self.populate_module_if_necessary(enum_module);\n-\n-            let mut variants = Vec::new();\n-            enum_module.for_each_child_stable(|ident, _, name_binding| {\n-                if let Res::Def(DefKind::Variant, _) = name_binding.res() {\n-                    let mut segms = enum_import_suggestion.path.segments.clone();\n-                    segms.push(ast::PathSegment::from_ident(ident));\n-                    variants.push(Path {\n-                        span: name_binding.span,\n-                        segments: segms,\n-                    });\n-                }\n-            });\n-            variants\n-        })\n-    }\n-\n     crate fn unresolved_macro_suggestions(\n         &mut self,\n         err: &mut DiagnosticBuilder<'a>,\n@@ -969,7 +615,7 @@ impl<'a> Resolver<'a> {\n     ) {\n         let is_expected = &|res: Res| res.macro_kind() == Some(macro_kind);\n         let suggestion = self.early_lookup_typo_candidate(\n-            ScopeSet::Macro(macro_kind), &parent_scope, ident, is_expected\n+            ScopeSet::Macro(macro_kind), parent_scope, ident, is_expected\n         );\n         add_typo_suggestion(err, suggestion, ident.span);\n \n@@ -1029,7 +675,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n     ) -> Option<(Vec<Segment>, Vec<String>)> {\n         // Replace first ident with `self` and check if that is valid.\n         path[0].ident.name = kw::SelfLower;\n-        let result = self.resolve_path(&path, None, parent_scope, false, span, CrateLint::No);\n+        let result = self.r.resolve_path(&path, None, parent_scope, false, span, CrateLint::No);\n         debug!(\"make_missing_self_suggestion: path={:?} result={:?}\", path, result);\n         if let PathResult::Module(..) = result {\n             Some((path, Vec::new()))\n@@ -1053,7 +699,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n     ) -> Option<(Vec<Segment>, Vec<String>)> {\n         // Replace first ident with `crate` and check if that is valid.\n         path[0].ident.name = kw::Crate;\n-        let result = self.resolve_path(&path, None, parent_scope, false, span, CrateLint::No);\n+        let result = self.r.resolve_path(&path, None, parent_scope, false, span, CrateLint::No);\n         debug!(\"make_missing_crate_suggestion:  path={:?} result={:?}\", path, result);\n         if let PathResult::Module(..) = result {\n             Some((\n@@ -1084,7 +730,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n     ) -> Option<(Vec<Segment>, Vec<String>)> {\n         // Replace first ident with `crate` and check if that is valid.\n         path[0].ident.name = kw::Super;\n-        let result = self.resolve_path(&path, None, parent_scope, false, span, CrateLint::No);\n+        let result = self.r.resolve_path(&path, None, parent_scope, false, span, CrateLint::No);\n         debug!(\"make_missing_super_suggestion:  path={:?} result={:?}\", path, result);\n         if let PathResult::Module(..) = result {\n             Some((path, Vec::new()))\n@@ -1117,13 +763,13 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n         // 1) some consistent ordering for emitted dignostics, and\n         // 2) `std` suggestions before `core` suggestions.\n         let mut extern_crate_names =\n-            self.resolver.extern_prelude.iter().map(|(ident, _)| ident.name).collect::<Vec<_>>();\n+            self.r.extern_prelude.iter().map(|(ident, _)| ident.name).collect::<Vec<_>>();\n         extern_crate_names.sort_by_key(|name| Reverse(name.as_str()));\n \n         for name in extern_crate_names.into_iter() {\n             // Replace first ident with a crate name and check if that is valid.\n             path[0].ident.name = name;\n-            let result = self.resolve_path(&path, None, parent_scope, false, span, CrateLint::No);\n+            let result = self.r.resolve_path(&path, None, parent_scope, false, span, CrateLint::No);\n             debug!(\"make_external_crate_suggestion: name={:?} path={:?} result={:?}\",\n                     name, path, result);\n             if let PathResult::Module(..) = result {\n@@ -1189,7 +835,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                 //   ie. `use a::b::{c, d, e};`\n                 //                      ^^^\n                 let (found_closing_brace, binding_span) = find_span_of_binding_until_next_binding(\n-                    self.resolver.session, directive.span, directive.use_span,\n+                    self.r.session, directive.span, directive.use_span,\n                 );\n                 debug!(\"check_for_module_export_macro: found_closing_brace={:?} binding_span={:?}\",\n                        found_closing_brace, binding_span);\n@@ -1204,7 +850,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                     //   ie. `use a::b::{c, d};`\n                     //                    ^^^\n                     if let Some(previous_span) = extend_span_to_previous_binding(\n-                        self.resolver.session, binding_span,\n+                        self.r.session, binding_span,\n                     ) {\n                         debug!(\"check_for_module_export_macro: previous_span={:?}\", previous_span);\n                         removal_span = removal_span.with_lo(previous_span.lo());\n@@ -1222,12 +868,12 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                 //   or  `use a::{b, c, d}};`\n                 //               ^^^^^^^^^^^\n                 let (has_nested, after_crate_name) = find_span_immediately_after_crate_name(\n-                    self.resolver.session, module_name, directive.use_span,\n+                    self.r.session, module_name, directive.use_span,\n                 );\n                 debug!(\"check_for_module_export_macro: has_nested={:?} after_crate_name={:?}\",\n                        has_nested, after_crate_name);\n \n-                let source_map = self.resolver.session.source_map();\n+                let source_map = self.r.session.source_map();\n \n                 // Add the import to the start, with a `{` if required.\n                 let start_point = source_map.start_point(after_crate_name);\n@@ -1415,21 +1061,6 @@ fn find_span_immediately_after_crate_name(\n     (next_left_bracket == after_second_colon, from_second_colon)\n }\n \n-/// Gets the stringified path for an enum from an `ImportSuggestion` for an enum variant.\n-fn import_candidate_to_enum_paths(suggestion: &ImportSuggestion) -> (String, String) {\n-    let variant_path = &suggestion.path;\n-    let variant_path_string = path_names_to_string(variant_path);\n-\n-    let path_len = suggestion.path.segments.len();\n-    let enum_path = ast::Path {\n-        span: suggestion.path.span,\n-        segments: suggestion.path.segments[0..path_len - 1].to_vec(),\n-    };\n-    let enum_path_string = path_names_to_string(&enum_path);\n-\n-    (variant_path_string, enum_path_string)\n-}\n-\n /// When an entity with a given name is not available in scope, we search for\n /// entities with that name in all crates. This method allows outputting the\n /// results of this search in a programmer-friendly way"}, {"sha": "7cb11195ee02ba0538dcf2ae06a8877c1969d5a7", "filename": "src/librustc_resolve/late.rs", "status": "added", "additions": 2004, "deletions": 0, "changes": 2004, "blob_url": "https://github.com/rust-lang/rust/blob/9d76a938de25e626a7c79a76789d7885405703e6/src%2Flibrustc_resolve%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d76a938de25e626a7c79a76789d7885405703e6/src%2Flibrustc_resolve%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate.rs?ref=9d76a938de25e626a7c79a76789d7885405703e6", "patch": "@@ -0,0 +1,2004 @@\n+use GenericParameters::*;\n+use RibKind::*;\n+\n+use crate::{path_names_to_string, BindingError, CrateLint, LexicalScopeBinding};\n+use crate::{Module, ModuleOrUniformRoot, NameBinding, NameBindingKind, ParentScope, PathResult};\n+use crate::{ResolutionError, Resolver, Segment, UseError};\n+\n+use log::debug;\n+use rustc::{bug, lint, span_bug};\n+use rustc::hir::def::{self, PartialRes, DefKind, CtorKind, PerNS};\n+use rustc::hir::def::Namespace::{self, *};\n+use rustc::hir::def_id::{DefId, CRATE_DEF_INDEX};\n+use rustc::hir::TraitCandidate;\n+use rustc::util::nodemap::FxHashMap;\n+use smallvec::{smallvec, SmallVec};\n+use syntax::{unwrap_or, walk_list};\n+use syntax::ast::*;\n+use syntax::ptr::P;\n+use syntax::symbol::{kw, sym};\n+use syntax::util::lev_distance::find_best_match_for_name;\n+use syntax::visit::{self, Visitor, FnKind};\n+use syntax_pos::Span;\n+\n+use std::collections::BTreeSet;\n+use std::mem::replace;\n+\n+mod diagnostics;\n+\n+type Res = def::Res<NodeId>;\n+\n+/// Map from the name in a pattern to its binding mode.\n+type BindingMap = FxHashMap<Ident, BindingInfo>;\n+\n+#[derive(Copy, Clone, Debug)]\n+struct BindingInfo {\n+    span: Span,\n+    binding_mode: BindingMode,\n+}\n+\n+#[derive(Copy, Clone)]\n+enum GenericParameters<'a, 'b> {\n+    NoGenericParams,\n+    HasGenericParams(// Type parameters.\n+                      &'b Generics,\n+\n+                      // The kind of the rib used for type parameters.\n+                      RibKind<'a>),\n+}\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+enum PatternSource {\n+    Match,\n+    Let,\n+    For,\n+    FnParam,\n+}\n+\n+impl PatternSource {\n+    fn descr(self) -> &'static str {\n+        match self {\n+            PatternSource::Match => \"match binding\",\n+            PatternSource::Let => \"let binding\",\n+            PatternSource::For => \"for binding\",\n+            PatternSource::FnParam => \"function parameter\",\n+        }\n+    }\n+}\n+\n+/// The rib kind restricts certain accesses,\n+/// e.g. to a `Res::Local` of an outer item.\n+#[derive(Copy, Clone, Debug)]\n+crate enum RibKind<'a> {\n+    /// No restriction needs to be applied.\n+    NormalRibKind,\n+\n+    /// We passed through an impl or trait and are now in one of its\n+    /// methods or associated types. Allow references to ty params that impl or trait\n+    /// binds. Disallow any other upvars (including other ty params that are\n+    /// upvars).\n+    AssocItemRibKind,\n+\n+    /// We passed through a function definition. Disallow upvars.\n+    /// Permit only those const parameters that are specified in the function's generics.\n+    FnItemRibKind,\n+\n+    /// We passed through an item scope. Disallow upvars.\n+    ItemRibKind,\n+\n+    /// We're in a constant item. Can't refer to dynamic stuff.\n+    ConstantItemRibKind,\n+\n+    /// We passed through a module.\n+    ModuleRibKind(Module<'a>),\n+\n+    /// We passed through a `macro_rules!` statement\n+    MacroDefinition(DefId),\n+\n+    /// All bindings in this rib are type parameters that can't be used\n+    /// from the default of a type parameter because they're not declared\n+    /// before said type parameter. Also see the `visit_generics` override.\n+    ForwardTyParamBanRibKind,\n+\n+    /// We forbid the use of type parameters as the types of const parameters.\n+    TyParamAsConstParamTy,\n+}\n+\n+/// A single local scope.\n+///\n+/// A rib represents a scope names can live in. Note that these appear in many places, not just\n+/// around braces. At any place where the list of accessible names (of the given namespace)\n+/// changes or a new restrictions on the name accessibility are introduced, a new rib is put onto a\n+/// stack. This may be, for example, a `let` statement (because it introduces variables), a macro,\n+/// etc.\n+///\n+/// Different [rib kinds](enum.RibKind) are transparent for different names.\n+///\n+/// The resolution keeps a separate stack of ribs as it traverses the AST for each namespace. When\n+/// resolving, the name is looked up from inside out.\n+#[derive(Debug)]\n+crate struct Rib<'a, R = Res> {\n+    pub bindings: FxHashMap<Ident, R>,\n+    pub kind: RibKind<'a>,\n+}\n+\n+impl<'a, R> Rib<'a, R> {\n+    fn new(kind: RibKind<'a>) -> Rib<'a, R> {\n+        Rib {\n+            bindings: Default::default(),\n+            kind,\n+        }\n+    }\n+}\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+crate enum AliasPossibility {\n+    No,\n+    Maybe,\n+}\n+\n+#[derive(Copy, Clone, Debug)]\n+crate enum PathSource<'a> {\n+    // Type paths `Path`.\n+    Type,\n+    // Trait paths in bounds or impls.\n+    Trait(AliasPossibility),\n+    // Expression paths `path`, with optional parent context.\n+    Expr(Option<&'a Expr>),\n+    // Paths in path patterns `Path`.\n+    Pat,\n+    // Paths in struct expressions and patterns `Path { .. }`.\n+    Struct,\n+    // Paths in tuple struct patterns `Path(..)`.\n+    TupleStruct,\n+    // `m::A::B` in `<T as m::A>::B::C`.\n+    TraitItem(Namespace),\n+}\n+\n+impl<'a> PathSource<'a> {\n+    fn namespace(self) -> Namespace {\n+        match self {\n+            PathSource::Type | PathSource::Trait(_) | PathSource::Struct => TypeNS,\n+            PathSource::Expr(..) | PathSource::Pat | PathSource::TupleStruct => ValueNS,\n+            PathSource::TraitItem(ns) => ns,\n+        }\n+    }\n+\n+    fn defer_to_typeck(self) -> bool {\n+        match self {\n+            PathSource::Type | PathSource::Expr(..) | PathSource::Pat |\n+            PathSource::Struct | PathSource::TupleStruct => true,\n+            PathSource::Trait(_) | PathSource::TraitItem(..) => false,\n+        }\n+    }\n+\n+    fn descr_expected(self) -> &'static str {\n+        match self {\n+            PathSource::Type => \"type\",\n+            PathSource::Trait(_) => \"trait\",\n+            PathSource::Pat => \"unit struct/variant or constant\",\n+            PathSource::Struct => \"struct, variant or union type\",\n+            PathSource::TupleStruct => \"tuple struct/variant\",\n+            PathSource::TraitItem(ns) => match ns {\n+                TypeNS => \"associated type\",\n+                ValueNS => \"method or associated constant\",\n+                MacroNS => bug!(\"associated macro\"),\n+            },\n+            PathSource::Expr(parent) => match parent.map(|p| &p.node) {\n+                // \"function\" here means \"anything callable\" rather than `DefKind::Fn`,\n+                // this is not precise but usually more helpful than just \"value\".\n+                Some(&ExprKind::Call(..)) => \"function\",\n+                _ => \"value\",\n+            },\n+        }\n+    }\n+\n+    crate fn is_expected(self, res: Res) -> bool {\n+        match self {\n+            PathSource::Type => match res {\n+                Res::Def(DefKind::Struct, _)\n+                | Res::Def(DefKind::Union, _)\n+                | Res::Def(DefKind::Enum, _)\n+                | Res::Def(DefKind::Trait, _)\n+                | Res::Def(DefKind::TraitAlias, _)\n+                | Res::Def(DefKind::TyAlias, _)\n+                | Res::Def(DefKind::AssocTy, _)\n+                | Res::PrimTy(..)\n+                | Res::Def(DefKind::TyParam, _)\n+                | Res::SelfTy(..)\n+                | Res::Def(DefKind::OpaqueTy, _)\n+                | Res::Def(DefKind::ForeignTy, _) => true,\n+                _ => false,\n+            },\n+            PathSource::Trait(AliasPossibility::No) => match res {\n+                Res::Def(DefKind::Trait, _) => true,\n+                _ => false,\n+            },\n+            PathSource::Trait(AliasPossibility::Maybe) => match res {\n+                Res::Def(DefKind::Trait, _) => true,\n+                Res::Def(DefKind::TraitAlias, _) => true,\n+                _ => false,\n+            },\n+            PathSource::Expr(..) => match res {\n+                Res::Def(DefKind::Ctor(_, CtorKind::Const), _)\n+                | Res::Def(DefKind::Ctor(_, CtorKind::Fn), _)\n+                | Res::Def(DefKind::Const, _)\n+                | Res::Def(DefKind::Static, _)\n+                | Res::Local(..)\n+                | Res::Def(DefKind::Fn, _)\n+                | Res::Def(DefKind::Method, _)\n+                | Res::Def(DefKind::AssocConst, _)\n+                | Res::SelfCtor(..)\n+                | Res::Def(DefKind::ConstParam, _) => true,\n+                _ => false,\n+            },\n+            PathSource::Pat => match res {\n+                Res::Def(DefKind::Ctor(_, CtorKind::Const), _) |\n+                Res::Def(DefKind::Const, _) | Res::Def(DefKind::AssocConst, _) |\n+                Res::SelfCtor(..) => true,\n+                _ => false,\n+            },\n+            PathSource::TupleStruct => match res {\n+                Res::Def(DefKind::Ctor(_, CtorKind::Fn), _) | Res::SelfCtor(..) => true,\n+                _ => false,\n+            },\n+            PathSource::Struct => match res {\n+                Res::Def(DefKind::Struct, _)\n+                | Res::Def(DefKind::Union, _)\n+                | Res::Def(DefKind::Variant, _)\n+                | Res::Def(DefKind::TyAlias, _)\n+                | Res::Def(DefKind::AssocTy, _)\n+                | Res::SelfTy(..) => true,\n+                _ => false,\n+            },\n+            PathSource::TraitItem(ns) => match res {\n+                Res::Def(DefKind::AssocConst, _)\n+                | Res::Def(DefKind::Method, _) if ns == ValueNS => true,\n+                Res::Def(DefKind::AssocTy, _) if ns == TypeNS => true,\n+                _ => false,\n+            },\n+        }\n+    }\n+\n+    fn error_code(self, has_unexpected_resolution: bool) -> &'static str {\n+        __diagnostic_used!(E0404);\n+        __diagnostic_used!(E0405);\n+        __diagnostic_used!(E0412);\n+        __diagnostic_used!(E0422);\n+        __diagnostic_used!(E0423);\n+        __diagnostic_used!(E0425);\n+        __diagnostic_used!(E0531);\n+        __diagnostic_used!(E0532);\n+        __diagnostic_used!(E0573);\n+        __diagnostic_used!(E0574);\n+        __diagnostic_used!(E0575);\n+        __diagnostic_used!(E0576);\n+        match (self, has_unexpected_resolution) {\n+            (PathSource::Trait(_), true) => \"E0404\",\n+            (PathSource::Trait(_), false) => \"E0405\",\n+            (PathSource::Type, true) => \"E0573\",\n+            (PathSource::Type, false) => \"E0412\",\n+            (PathSource::Struct, true) => \"E0574\",\n+            (PathSource::Struct, false) => \"E0422\",\n+            (PathSource::Expr(..), true) => \"E0423\",\n+            (PathSource::Expr(..), false) => \"E0425\",\n+            (PathSource::Pat, true) | (PathSource::TupleStruct, true) => \"E0532\",\n+            (PathSource::Pat, false) | (PathSource::TupleStruct, false) => \"E0531\",\n+            (PathSource::TraitItem(..), true) => \"E0575\",\n+            (PathSource::TraitItem(..), false) => \"E0576\",\n+        }\n+    }\n+}\n+\n+struct LateResolutionVisitor<'a, 'b> {\n+    r: &'b mut Resolver<'a>,\n+\n+    /// The module that represents the current item scope.\n+    parent_scope: ParentScope<'a>,\n+\n+    /// The current set of local scopes for types and values.\n+    /// FIXME #4948: Reuse ribs to avoid allocation.\n+    ribs: PerNS<Vec<Rib<'a>>>,\n+\n+    /// The current set of local scopes, for labels.\n+    label_ribs: Vec<Rib<'a, NodeId>>,\n+\n+    /// The trait that the current context can refer to.\n+    current_trait_ref: Option<(Module<'a>, TraitRef)>,\n+\n+    /// The current trait's associated types' ident, used for diagnostic suggestions.\n+    current_trait_assoc_types: Vec<Ident>,\n+\n+    /// The current self type if inside an impl (used for better errors).\n+    current_self_type: Option<Ty>,\n+\n+    /// The current self item if inside an ADT (used for better errors).\n+    current_self_item: Option<NodeId>,\n+\n+    /// A list of labels as of yet unused. Labels will be removed from this map when\n+    /// they are used (in a `break` or `continue` statement)\n+    unused_labels: FxHashMap<NodeId, Span>,\n+\n+    /// Only used for better errors on `fn(): fn()`.\n+    current_type_ascription: Vec<Span>,\n+}\n+\n+/// Walks the whole crate in DFS order, visiting each item, resolving names as it goes.\n+impl<'a, 'tcx> Visitor<'tcx> for LateResolutionVisitor<'a, '_> {\n+    fn visit_item(&mut self, item: &'tcx Item) {\n+        self.resolve_item(item);\n+    }\n+    fn visit_arm(&mut self, arm: &'tcx Arm) {\n+        self.resolve_arm(arm);\n+    }\n+    fn visit_block(&mut self, block: &'tcx Block) {\n+        self.resolve_block(block);\n+    }\n+    fn visit_anon_const(&mut self, constant: &'tcx AnonConst) {\n+        debug!(\"visit_anon_const {:?}\", constant);\n+        self.with_constant_rib(|this| {\n+            visit::walk_anon_const(this, constant);\n+        });\n+    }\n+    fn visit_expr(&mut self, expr: &'tcx Expr) {\n+        self.resolve_expr(expr, None);\n+    }\n+    fn visit_local(&mut self, local: &'tcx Local) {\n+        self.resolve_local(local);\n+    }\n+    fn visit_ty(&mut self, ty: &'tcx Ty) {\n+        match ty.node {\n+            TyKind::Path(ref qself, ref path) => {\n+                self.smart_resolve_path(ty.id, qself.as_ref(), path, PathSource::Type);\n+            }\n+            TyKind::ImplicitSelf => {\n+                let self_ty = Ident::with_empty_ctxt(kw::SelfUpper);\n+                let res = self.resolve_ident_in_lexical_scope(self_ty, TypeNS, Some(ty.id), ty.span)\n+                              .map_or(Res::Err, |d| d.res());\n+                self.r.record_partial_res(ty.id, PartialRes::new(res));\n+            }\n+            _ => (),\n+        }\n+        visit::walk_ty(self, ty);\n+    }\n+    fn visit_poly_trait_ref(&mut self,\n+                            tref: &'tcx PolyTraitRef,\n+                            m: &'tcx TraitBoundModifier) {\n+        self.smart_resolve_path(tref.trait_ref.ref_id, None,\n+                                &tref.trait_ref.path, PathSource::Trait(AliasPossibility::Maybe));\n+        visit::walk_poly_trait_ref(self, tref, m);\n+    }\n+    fn visit_foreign_item(&mut self, foreign_item: &'tcx ForeignItem) {\n+        let generic_params = match foreign_item.node {\n+            ForeignItemKind::Fn(_, ref generics) => {\n+                HasGenericParams(generics, ItemRibKind)\n+            }\n+            ForeignItemKind::Static(..) => NoGenericParams,\n+            ForeignItemKind::Ty => NoGenericParams,\n+            ForeignItemKind::Macro(..) => NoGenericParams,\n+        };\n+        self.with_generic_param_rib(generic_params, |this| {\n+            visit::walk_foreign_item(this, foreign_item);\n+        });\n+    }\n+    fn visit_fn(&mut self,\n+                function_kind: FnKind<'tcx>,\n+                declaration: &'tcx FnDecl,\n+                _: Span,\n+                _: NodeId)\n+    {\n+        debug!(\"(resolving function) entering function\");\n+        let rib_kind = match function_kind {\n+            FnKind::ItemFn(..) => FnItemRibKind,\n+            FnKind::Method(..) | FnKind::Closure(_) => NormalRibKind,\n+        };\n+\n+        // Create a value rib for the function.\n+        self.ribs[ValueNS].push(Rib::new(rib_kind));\n+\n+        // Create a label rib for the function.\n+        self.label_ribs.push(Rib::new(rib_kind));\n+\n+        // Add each argument to the rib.\n+        let mut bindings_list = FxHashMap::default();\n+        for argument in &declaration.inputs {\n+            self.resolve_pattern(&argument.pat, PatternSource::FnParam, &mut bindings_list);\n+\n+            self.visit_ty(&argument.ty);\n+\n+            debug!(\"(resolving function) recorded argument\");\n+        }\n+        visit::walk_fn_ret_ty(self, &declaration.output);\n+\n+        // Resolve the function body, potentially inside the body of an async closure\n+        match function_kind {\n+            FnKind::ItemFn(.., body) |\n+            FnKind::Method(.., body) => {\n+                self.visit_block(body);\n+            }\n+            FnKind::Closure(body) => {\n+                self.visit_expr(body);\n+            }\n+        };\n+\n+        debug!(\"(resolving function) leaving function\");\n+\n+        self.label_ribs.pop();\n+        self.ribs[ValueNS].pop();\n+    }\n+\n+    fn visit_generics(&mut self, generics: &'tcx Generics) {\n+        // For type parameter defaults, we have to ban access\n+        // to following type parameters, as the InternalSubsts can only\n+        // provide previous type parameters as they're built. We\n+        // put all the parameters on the ban list and then remove\n+        // them one by one as they are processed and become available.\n+        let mut default_ban_rib = Rib::new(ForwardTyParamBanRibKind);\n+        let mut found_default = false;\n+        default_ban_rib.bindings.extend(generics.params.iter()\n+            .filter_map(|param| match param.kind {\n+                GenericParamKind::Const { .. } |\n+                GenericParamKind::Lifetime { .. } => None,\n+                GenericParamKind::Type { ref default, .. } => {\n+                    found_default |= default.is_some();\n+                    if found_default {\n+                        Some((Ident::with_empty_ctxt(param.ident.name), Res::Err))\n+                    } else {\n+                        None\n+                    }\n+                }\n+            }));\n+\n+        // We also ban access to type parameters for use as the types of const parameters.\n+        let mut const_ty_param_ban_rib = Rib::new(TyParamAsConstParamTy);\n+        const_ty_param_ban_rib.bindings.extend(generics.params.iter()\n+            .filter(|param| {\n+                if let GenericParamKind::Type { .. } = param.kind {\n+                    true\n+                } else {\n+                    false\n+                }\n+            })\n+            .map(|param| (Ident::with_empty_ctxt(param.ident.name), Res::Err)));\n+\n+        for param in &generics.params {\n+            match param.kind {\n+                GenericParamKind::Lifetime { .. } => self.visit_generic_param(param),\n+                GenericParamKind::Type { ref default, .. } => {\n+                    for bound in &param.bounds {\n+                        self.visit_param_bound(bound);\n+                    }\n+\n+                    if let Some(ref ty) = default {\n+                        self.ribs[TypeNS].push(default_ban_rib);\n+                        self.visit_ty(ty);\n+                        default_ban_rib = self.ribs[TypeNS].pop().unwrap();\n+                    }\n+\n+                    // Allow all following defaults to refer to this type parameter.\n+                    default_ban_rib.bindings.remove(&Ident::with_empty_ctxt(param.ident.name));\n+                }\n+                GenericParamKind::Const { ref ty } => {\n+                    self.ribs[TypeNS].push(const_ty_param_ban_rib);\n+\n+                    for bound in &param.bounds {\n+                        self.visit_param_bound(bound);\n+                    }\n+\n+                    self.visit_ty(ty);\n+\n+                    const_ty_param_ban_rib = self.ribs[TypeNS].pop().unwrap();\n+                }\n+            }\n+        }\n+        for p in &generics.where_clause.predicates {\n+            self.visit_where_predicate(p);\n+        }\n+    }\n+}\n+\n+impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n+    fn new(resolver: &'b mut Resolver<'a>) -> LateResolutionVisitor<'a, 'b> {\n+        // During late resolution we only track the module component of the parent scope,\n+        // although it may be useful to track other components as well for diagnostics.\n+        let parent_scope = resolver.dummy_parent_scope();\n+        let graph_root = resolver.graph_root;\n+        LateResolutionVisitor {\n+            r: resolver,\n+            parent_scope,\n+            ribs: PerNS {\n+                value_ns: vec![Rib::new(ModuleRibKind(graph_root))],\n+                type_ns: vec![Rib::new(ModuleRibKind(graph_root))],\n+                macro_ns: vec![Rib::new(ModuleRibKind(graph_root))],\n+            },\n+            label_ribs: Vec::new(),\n+            current_trait_ref: None,\n+            current_trait_assoc_types: Vec::new(),\n+            current_self_type: None,\n+            current_self_item: None,\n+            unused_labels: Default::default(),\n+            current_type_ascription: Vec::new(),\n+        }\n+    }\n+\n+    fn resolve_ident_in_lexical_scope(&mut self,\n+                                      ident: Ident,\n+                                      ns: Namespace,\n+                                      record_used_id: Option<NodeId>,\n+                                      path_span: Span)\n+                                      -> Option<LexicalScopeBinding<'a>> {\n+        self.r.resolve_ident_in_lexical_scope(\n+            ident, ns, &self.parent_scope, record_used_id, path_span, &self.ribs[ns]\n+        )\n+    }\n+\n+    fn resolve_path(\n+        &mut self,\n+        path: &[Segment],\n+        opt_ns: Option<Namespace>, // `None` indicates a module path in import\n+        record_used: bool,\n+        path_span: Span,\n+        crate_lint: CrateLint,\n+    ) -> PathResult<'a> {\n+        self.r.resolve_path_with_ribs(\n+            path, opt_ns, &self.parent_scope, record_used, path_span, crate_lint, Some(&self.ribs)\n+        )\n+    }\n+\n+    // AST resolution\n+    //\n+    // We maintain a list of value ribs and type ribs.\n+    //\n+    // Simultaneously, we keep track of the current position in the module\n+    // graph in the `parent_scope.module` pointer. When we go to resolve a name in\n+    // the value or type namespaces, we first look through all the ribs and\n+    // then query the module graph. When we resolve a name in the module\n+    // namespace, we can skip all the ribs (since nested modules are not\n+    // allowed within blocks in Rust) and jump straight to the current module\n+    // graph node.\n+    //\n+    // Named implementations are handled separately. When we find a method\n+    // call, we consult the module node to find all of the implementations in\n+    // scope. This information is lazily cached in the module node. We then\n+    // generate a fake \"implementation scope\" containing all the\n+    // implementations thus found, for compatibility with old resolve pass.\n+\n+    fn with_scope<F, T>(&mut self, id: NodeId, f: F) -> T\n+        where F: FnOnce(&mut LateResolutionVisitor<'_, '_>) -> T\n+    {\n+        let id = self.r.definitions.local_def_id(id);\n+        let module = self.r.module_map.get(&id).cloned(); // clones a reference\n+        if let Some(module) = module {\n+            // Move down in the graph.\n+            let orig_module = replace(&mut self.parent_scope.module, module);\n+            self.ribs[ValueNS].push(Rib::new(ModuleRibKind(module)));\n+            self.ribs[TypeNS].push(Rib::new(ModuleRibKind(module)));\n+\n+            self.r.finalize_current_module_macro_resolutions(module);\n+            let ret = f(self);\n+\n+            self.parent_scope.module = orig_module;\n+            self.ribs[ValueNS].pop();\n+            self.ribs[TypeNS].pop();\n+            ret\n+        } else {\n+            f(self)\n+        }\n+    }\n+\n+    /// Searches the current set of local scopes for labels. Returns the first non-`None` label that\n+    /// is returned by the given predicate function\n+    ///\n+    /// Stops after meeting a closure.\n+    fn search_label<P, R>(&self, mut ident: Ident, pred: P) -> Option<R>\n+        where P: Fn(&Rib<'_, NodeId>, Ident) -> Option<R>\n+    {\n+        for rib in self.label_ribs.iter().rev() {\n+            match rib.kind {\n+                NormalRibKind => {}\n+                // If an invocation of this macro created `ident`, give up on `ident`\n+                // and switch to `ident`'s source from the macro definition.\n+                MacroDefinition(def) => {\n+                    if def == self.r.macro_def(ident.span.ctxt()) {\n+                        ident.span.remove_mark();\n+                    }\n+                }\n+                _ => {\n+                    // Do not resolve labels across function boundary\n+                    return None;\n+                }\n+            }\n+            let r = pred(rib, ident);\n+            if r.is_some() {\n+                return r;\n+            }\n+        }\n+        None\n+    }\n+\n+    fn resolve_adt(&mut self, item: &Item, generics: &Generics) {\n+        debug!(\"resolve_adt\");\n+        self.with_current_self_item(item, |this| {\n+            this.with_generic_param_rib(HasGenericParams(generics, ItemRibKind), |this| {\n+                let item_def_id = this.r.definitions.local_def_id(item.id);\n+                this.with_self_rib(Res::SelfTy(None, Some(item_def_id)), |this| {\n+                    visit::walk_item(this, item);\n+                });\n+            });\n+        });\n+    }\n+\n+    fn future_proof_import(&mut self, use_tree: &UseTree) {\n+        let segments = &use_tree.prefix.segments;\n+        if !segments.is_empty() {\n+            let ident = segments[0].ident;\n+            if ident.is_path_segment_keyword() || ident.span.rust_2015() {\n+                return;\n+            }\n+\n+            let nss = match use_tree.kind {\n+                UseTreeKind::Simple(..) if segments.len() == 1 => &[TypeNS, ValueNS][..],\n+                _ => &[TypeNS],\n+            };\n+            let report_error = |this: &Self, ns| {\n+                let what = if ns == TypeNS { \"type parameters\" } else { \"local variables\" };\n+                this.r.session.span_err(ident.span, &format!(\"imports cannot refer to {}\", what));\n+            };\n+\n+            for &ns in nss {\n+                match self.resolve_ident_in_lexical_scope(ident, ns, None, use_tree.prefix.span) {\n+                    Some(LexicalScopeBinding::Res(..)) => {\n+                        report_error(self, ns);\n+                    }\n+                    Some(LexicalScopeBinding::Item(binding)) => {\n+                        let orig_blacklisted_binding =\n+                            replace(&mut self.r.blacklisted_binding, Some(binding));\n+                        if let Some(LexicalScopeBinding::Res(..)) =\n+                                self.resolve_ident_in_lexical_scope(ident, ns, None,\n+                                                                    use_tree.prefix.span) {\n+                            report_error(self, ns);\n+                        }\n+                        self.r.blacklisted_binding = orig_blacklisted_binding;\n+                    }\n+                    None => {}\n+                }\n+            }\n+        } else if let UseTreeKind::Nested(use_trees) = &use_tree.kind {\n+            for (use_tree, _) in use_trees {\n+                self.future_proof_import(use_tree);\n+            }\n+        }\n+    }\n+\n+    fn resolve_item(&mut self, item: &Item) {\n+        let name = item.ident.name;\n+        debug!(\"(resolving item) resolving {} ({:?})\", name, item.node);\n+\n+        match item.node {\n+            ItemKind::TyAlias(_, ref generics) |\n+            ItemKind::OpaqueTy(_, ref generics) |\n+            ItemKind::Fn(_, _, ref generics, _) => {\n+                self.with_generic_param_rib(\n+                    HasGenericParams(generics, ItemRibKind),\n+                    |this| visit::walk_item(this, item)\n+                );\n+            }\n+\n+            ItemKind::Enum(_, ref generics) |\n+            ItemKind::Struct(_, ref generics) |\n+            ItemKind::Union(_, ref generics) => {\n+                self.resolve_adt(item, generics);\n+            }\n+\n+            ItemKind::Impl(.., ref generics, ref opt_trait_ref, ref self_type, ref impl_items) =>\n+                self.resolve_implementation(generics,\n+                                            opt_trait_ref,\n+                                            &self_type,\n+                                            item.id,\n+                                            impl_items),\n+\n+            ItemKind::Trait(.., ref generics, ref bounds, ref trait_items) => {\n+                // Create a new rib for the trait-wide type parameters.\n+                self.with_generic_param_rib(HasGenericParams(generics, ItemRibKind), |this| {\n+                    let local_def_id = this.r.definitions.local_def_id(item.id);\n+                    this.with_self_rib(Res::SelfTy(Some(local_def_id), None), |this| {\n+                        this.visit_generics(generics);\n+                        walk_list!(this, visit_param_bound, bounds);\n+\n+                        for trait_item in trait_items {\n+                            this.with_trait_items(trait_items, |this| {\n+                                let generic_params = HasGenericParams(\n+                                    &trait_item.generics,\n+                                    AssocItemRibKind,\n+                                );\n+                                this.with_generic_param_rib(generic_params, |this| {\n+                                    match trait_item.node {\n+                                        TraitItemKind::Const(ref ty, ref default) => {\n+                                            this.visit_ty(ty);\n+\n+                                            // Only impose the restrictions of\n+                                            // ConstRibKind for an actual constant\n+                                            // expression in a provided default.\n+                                            if let Some(ref expr) = *default{\n+                                                this.with_constant_rib(|this| {\n+                                                    this.visit_expr(expr);\n+                                                });\n+                                            }\n+                                        }\n+                                        TraitItemKind::Method(_, _) => {\n+                                            visit::walk_trait_item(this, trait_item)\n+                                        }\n+                                        TraitItemKind::Type(..) => {\n+                                            visit::walk_trait_item(this, trait_item)\n+                                        }\n+                                        TraitItemKind::Macro(_) => {\n+                                            panic!(\"unexpanded macro in resolve!\")\n+                                        }\n+                                    };\n+                                });\n+                            });\n+                        }\n+                    });\n+                });\n+            }\n+\n+            ItemKind::TraitAlias(ref generics, ref bounds) => {\n+                // Create a new rib for the trait-wide type parameters.\n+                self.with_generic_param_rib(HasGenericParams(generics, ItemRibKind), |this| {\n+                    let local_def_id = this.r.definitions.local_def_id(item.id);\n+                    this.with_self_rib(Res::SelfTy(Some(local_def_id), None), |this| {\n+                        this.visit_generics(generics);\n+                        walk_list!(this, visit_param_bound, bounds);\n+                    });\n+                });\n+            }\n+\n+            ItemKind::Mod(_) | ItemKind::ForeignMod(_) => {\n+                self.with_scope(item.id, |this| {\n+                    visit::walk_item(this, item);\n+                });\n+            }\n+\n+            ItemKind::Static(ref ty, _, ref expr) |\n+            ItemKind::Const(ref ty, ref expr) => {\n+                debug!(\"resolve_item ItemKind::Const\");\n+                self.with_item_rib(|this| {\n+                    this.visit_ty(ty);\n+                    this.with_constant_rib(|this| {\n+                        this.visit_expr(expr);\n+                    });\n+                });\n+            }\n+\n+            ItemKind::Use(ref use_tree) => {\n+                self.future_proof_import(use_tree);\n+            }\n+\n+            ItemKind::ExternCrate(..) |\n+            ItemKind::MacroDef(..) | ItemKind::GlobalAsm(..) => {\n+                // do nothing, these are just around to be encoded\n+            }\n+\n+            ItemKind::Mac(_) => panic!(\"unexpanded macro in resolve!\"),\n+        }\n+    }\n+\n+    fn with_generic_param_rib<'c, F>(&'c mut self, generic_params: GenericParameters<'a, 'c>, f: F)\n+        where F: FnOnce(&mut LateResolutionVisitor<'_, '_>)\n+    {\n+        debug!(\"with_generic_param_rib\");\n+        match generic_params {\n+            HasGenericParams(generics, rib_kind) => {\n+                let mut function_type_rib = Rib::new(rib_kind);\n+                let mut function_value_rib = Rib::new(rib_kind);\n+                let mut seen_bindings = FxHashMap::default();\n+                for param in &generics.params {\n+                    match param.kind {\n+                        GenericParamKind::Lifetime { .. } => {}\n+                        GenericParamKind::Type { .. } => {\n+                            let ident = param.ident.modern();\n+                            debug!(\"with_generic_param_rib: {}\", param.id);\n+\n+                            if seen_bindings.contains_key(&ident) {\n+                                let span = seen_bindings.get(&ident).unwrap();\n+                                let err = ResolutionError::NameAlreadyUsedInParameterList(\n+                                    ident.name,\n+                                    *span,\n+                                );\n+                                self.r.report_error(param.ident.span, err);\n+                            }\n+                            seen_bindings.entry(ident).or_insert(param.ident.span);\n+\n+                            // Plain insert (no renaming).\n+                            let res = Res::Def(\n+                                DefKind::TyParam,\n+                                self.r.definitions.local_def_id(param.id),\n+                            );\n+                            function_type_rib.bindings.insert(ident, res);\n+                            self.r.record_partial_res(param.id, PartialRes::new(res));\n+                        }\n+                        GenericParamKind::Const { .. } => {\n+                            let ident = param.ident.modern();\n+                            debug!(\"with_generic_param_rib: {}\", param.id);\n+\n+                            if seen_bindings.contains_key(&ident) {\n+                                let span = seen_bindings.get(&ident).unwrap();\n+                                let err = ResolutionError::NameAlreadyUsedInParameterList(\n+                                    ident.name,\n+                                    *span,\n+                                );\n+                                self.r.report_error(param.ident.span, err);\n+                            }\n+                            seen_bindings.entry(ident).or_insert(param.ident.span);\n+\n+                            let res = Res::Def(\n+                                DefKind::ConstParam,\n+                                self.r.definitions.local_def_id(param.id),\n+                            );\n+                            function_value_rib.bindings.insert(ident, res);\n+                            self.r.record_partial_res(param.id, PartialRes::new(res));\n+                        }\n+                    }\n+                }\n+                self.ribs[ValueNS].push(function_value_rib);\n+                self.ribs[TypeNS].push(function_type_rib);\n+            }\n+\n+            NoGenericParams => {\n+                // Nothing to do.\n+            }\n+        }\n+\n+        f(self);\n+\n+        if let HasGenericParams(..) = generic_params {\n+            self.ribs[TypeNS].pop();\n+            self.ribs[ValueNS].pop();\n+        }\n+    }\n+\n+    fn with_label_rib<F>(&mut self, f: F)\n+        where F: FnOnce(&mut LateResolutionVisitor<'_, '_>)\n+    {\n+        self.label_ribs.push(Rib::new(NormalRibKind));\n+        f(self);\n+        self.label_ribs.pop();\n+    }\n+\n+    fn with_item_rib<F>(&mut self, f: F)\n+        where F: FnOnce(&mut LateResolutionVisitor<'_, '_>)\n+    {\n+        self.ribs[ValueNS].push(Rib::new(ItemRibKind));\n+        self.ribs[TypeNS].push(Rib::new(ItemRibKind));\n+        f(self);\n+        self.ribs[TypeNS].pop();\n+        self.ribs[ValueNS].pop();\n+    }\n+\n+    fn with_constant_rib<F>(&mut self, f: F)\n+        where F: FnOnce(&mut LateResolutionVisitor<'_, '_>)\n+    {\n+        debug!(\"with_constant_rib\");\n+        self.ribs[ValueNS].push(Rib::new(ConstantItemRibKind));\n+        self.label_ribs.push(Rib::new(ConstantItemRibKind));\n+        f(self);\n+        self.label_ribs.pop();\n+        self.ribs[ValueNS].pop();\n+    }\n+\n+    fn with_current_self_type<T, F>(&mut self, self_type: &Ty, f: F) -> T\n+        where F: FnOnce(&mut LateResolutionVisitor<'_, '_>) -> T\n+    {\n+        // Handle nested impls (inside fn bodies)\n+        let previous_value = replace(&mut self.current_self_type, Some(self_type.clone()));\n+        let result = f(self);\n+        self.current_self_type = previous_value;\n+        result\n+    }\n+\n+    fn with_current_self_item<T, F>(&mut self, self_item: &Item, f: F) -> T\n+        where F: FnOnce(&mut LateResolutionVisitor<'_, '_>) -> T\n+    {\n+        let previous_value = replace(&mut self.current_self_item, Some(self_item.id));\n+        let result = f(self);\n+        self.current_self_item = previous_value;\n+        result\n+    }\n+\n+    /// When evaluating a `trait` use its associated types' idents for suggestionsa in E0412.\n+    fn with_trait_items<T, F>(&mut self, trait_items: &Vec<TraitItem>, f: F) -> T\n+        where F: FnOnce(&mut LateResolutionVisitor<'_, '_>) -> T\n+    {\n+        let trait_assoc_types = replace(\n+            &mut self.current_trait_assoc_types,\n+            trait_items.iter().filter_map(|item| match &item.node {\n+                TraitItemKind::Type(bounds, _) if bounds.len() == 0 => Some(item.ident),\n+                _ => None,\n+            }).collect(),\n+        );\n+        let result = f(self);\n+        self.current_trait_assoc_types = trait_assoc_types;\n+        result\n+    }\n+\n+    /// This is called to resolve a trait reference from an `impl` (i.e., `impl Trait for Foo`).\n+    fn with_optional_trait_ref<T, F>(&mut self, opt_trait_ref: Option<&TraitRef>, f: F) -> T\n+        where F: FnOnce(&mut LateResolutionVisitor<'_, '_>, Option<DefId>) -> T\n+    {\n+        let mut new_val = None;\n+        let mut new_id = None;\n+        if let Some(trait_ref) = opt_trait_ref {\n+            let path: Vec<_> = Segment::from_path(&trait_ref.path);\n+            let res = self.smart_resolve_path_fragment(\n+                trait_ref.ref_id,\n+                None,\n+                &path,\n+                trait_ref.path.span,\n+                PathSource::Trait(AliasPossibility::No),\n+                CrateLint::SimplePath(trait_ref.ref_id),\n+            ).base_res();\n+            if res != Res::Err {\n+                new_id = Some(res.def_id());\n+                let span = trait_ref.path.span;\n+                if let PathResult::Module(ModuleOrUniformRoot::Module(module)) =\n+                    self.resolve_path(\n+                        &path,\n+                        Some(TypeNS),\n+                        false,\n+                        span,\n+                        CrateLint::SimplePath(trait_ref.ref_id),\n+                    )\n+                {\n+                    new_val = Some((module, trait_ref.clone()));\n+                }\n+            }\n+        }\n+        let original_trait_ref = replace(&mut self.current_trait_ref, new_val);\n+        let result = f(self, new_id);\n+        self.current_trait_ref = original_trait_ref;\n+        result\n+    }\n+\n+    fn with_self_rib<F>(&mut self, self_res: Res, f: F)\n+        where F: FnOnce(&mut LateResolutionVisitor<'_, '_>)\n+    {\n+        let mut self_type_rib = Rib::new(NormalRibKind);\n+\n+        // Plain insert (no renaming, since types are not currently hygienic)\n+        self_type_rib.bindings.insert(Ident::with_empty_ctxt(kw::SelfUpper), self_res);\n+        self.ribs[TypeNS].push(self_type_rib);\n+        f(self);\n+        self.ribs[TypeNS].pop();\n+    }\n+\n+    fn with_self_struct_ctor_rib<F>(&mut self, impl_id: DefId, f: F)\n+        where F: FnOnce(&mut LateResolutionVisitor<'_, '_>)\n+    {\n+        let self_res = Res::SelfCtor(impl_id);\n+        let mut self_type_rib = Rib::new(NormalRibKind);\n+        self_type_rib.bindings.insert(Ident::with_empty_ctxt(kw::SelfUpper), self_res);\n+        self.ribs[ValueNS].push(self_type_rib);\n+        f(self);\n+        self.ribs[ValueNS].pop();\n+    }\n+\n+    fn resolve_implementation(&mut self,\n+                              generics: &Generics,\n+                              opt_trait_reference: &Option<TraitRef>,\n+                              self_type: &Ty,\n+                              item_id: NodeId,\n+                              impl_items: &[ImplItem]) {\n+        debug!(\"resolve_implementation\");\n+        // If applicable, create a rib for the type parameters.\n+        self.with_generic_param_rib(HasGenericParams(generics, ItemRibKind), |this| {\n+            // Dummy self type for better errors if `Self` is used in the trait path.\n+            this.with_self_rib(Res::SelfTy(None, None), |this| {\n+                // Resolve the trait reference, if necessary.\n+                this.with_optional_trait_ref(opt_trait_reference.as_ref(), |this, trait_id| {\n+                    let item_def_id = this.r.definitions.local_def_id(item_id);\n+                    this.with_self_rib(Res::SelfTy(trait_id, Some(item_def_id)), |this| {\n+                        if let Some(trait_ref) = opt_trait_reference.as_ref() {\n+                            // Resolve type arguments in the trait path.\n+                            visit::walk_trait_ref(this, trait_ref);\n+                        }\n+                        // Resolve the self type.\n+                        this.visit_ty(self_type);\n+                        // Resolve the generic parameters.\n+                        this.visit_generics(generics);\n+                        // Resolve the items within the impl.\n+                        this.with_current_self_type(self_type, |this| {\n+                            this.with_self_struct_ctor_rib(item_def_id, |this| {\n+                                debug!(\"resolve_implementation with_self_struct_ctor_rib\");\n+                                for impl_item in impl_items {\n+                                    // We also need a new scope for the impl item type parameters.\n+                                    let generic_params = HasGenericParams(&impl_item.generics,\n+                                                                          AssocItemRibKind);\n+                                    this.with_generic_param_rib(generic_params, |this| {\n+                                        use crate::ResolutionError::*;\n+                                        match impl_item.node {\n+                                            ImplItemKind::Const(..) => {\n+                                                debug!(\n+                                                    \"resolve_implementation ImplItemKind::Const\",\n+                                                );\n+                                                // If this is a trait impl, ensure the const\n+                                                // exists in trait\n+                                                this.check_trait_item(\n+                                                    impl_item.ident,\n+                                                    ValueNS,\n+                                                    impl_item.span,\n+                                                    |n, s| ConstNotMemberOfTrait(n, s),\n+                                                );\n+\n+                                                this.with_constant_rib(|this| {\n+                                                    visit::walk_impl_item(this, impl_item)\n+                                                });\n+                                            }\n+                                            ImplItemKind::Method(..) => {\n+                                                // If this is a trait impl, ensure the method\n+                                                // exists in trait\n+                                                this.check_trait_item(impl_item.ident,\n+                                                                      ValueNS,\n+                                                                      impl_item.span,\n+                                                    |n, s| MethodNotMemberOfTrait(n, s));\n+\n+                                                visit::walk_impl_item(this, impl_item);\n+                                            }\n+                                            ImplItemKind::TyAlias(ref ty) => {\n+                                                // If this is a trait impl, ensure the type\n+                                                // exists in trait\n+                                                this.check_trait_item(impl_item.ident,\n+                                                                      TypeNS,\n+                                                                      impl_item.span,\n+                                                    |n, s| TypeNotMemberOfTrait(n, s));\n+\n+                                                this.visit_ty(ty);\n+                                            }\n+                                            ImplItemKind::OpaqueTy(ref bounds) => {\n+                                                // If this is a trait impl, ensure the type\n+                                                // exists in trait\n+                                                this.check_trait_item(impl_item.ident,\n+                                                                      TypeNS,\n+                                                                      impl_item.span,\n+                                                    |n, s| TypeNotMemberOfTrait(n, s));\n+\n+                                                for bound in bounds {\n+                                                    this.visit_param_bound(bound);\n+                                                }\n+                                            }\n+                                            ImplItemKind::Macro(_) =>\n+                                                panic!(\"unexpanded macro in resolve!\"),\n+                                        }\n+                                    });\n+                                }\n+                            });\n+                        });\n+                    });\n+                });\n+            });\n+        });\n+    }\n+\n+    fn check_trait_item<F>(&mut self, ident: Ident, ns: Namespace, span: Span, err: F)\n+        where F: FnOnce(Name, &str) -> ResolutionError<'_>\n+    {\n+        // If there is a TraitRef in scope for an impl, then the method must be in the\n+        // trait.\n+        if let Some((module, _)) = self.current_trait_ref {\n+            if self.r.resolve_ident_in_module(\n+                ModuleOrUniformRoot::Module(module),\n+                ident,\n+                ns,\n+                &self.parent_scope,\n+                false,\n+                span,\n+            ).is_err() {\n+                let path = &self.current_trait_ref.as_ref().unwrap().1.path;\n+                self.r.report_error(span, err(ident.name, &path_names_to_string(path)));\n+            }\n+        }\n+    }\n+\n+    fn resolve_local(&mut self, local: &Local) {\n+        // Resolve the type.\n+        walk_list!(self, visit_ty, &local.ty);\n+\n+        // Resolve the initializer.\n+        walk_list!(self, visit_expr, &local.init);\n+\n+        // Resolve the pattern.\n+        self.resolve_pattern(&local.pat, PatternSource::Let, &mut FxHashMap::default());\n+    }\n+\n+    // build a map from pattern identifiers to binding-info's.\n+    // this is done hygienically. This could arise for a macro\n+    // that expands into an or-pattern where one 'x' was from the\n+    // user and one 'x' came from the macro.\n+    fn binding_mode_map(&mut self, pat: &Pat) -> BindingMap {\n+        let mut binding_map = FxHashMap::default();\n+\n+        pat.walk(&mut |pat| {\n+            if let PatKind::Ident(binding_mode, ident, ref sub_pat) = pat.node {\n+                if sub_pat.is_some() || match self.r.partial_res_map.get(&pat.id)\n+                                                                  .map(|res| res.base_res()) {\n+                    Some(Res::Local(..)) => true,\n+                    _ => false,\n+                } {\n+                    let binding_info = BindingInfo { span: ident.span, binding_mode: binding_mode };\n+                    binding_map.insert(ident, binding_info);\n+                }\n+            }\n+            true\n+        });\n+\n+        binding_map\n+    }\n+\n+    // Checks that all of the arms in an or-pattern have exactly the\n+    // same set of bindings, with the same binding modes for each.\n+    fn check_consistent_bindings(&mut self, pats: &[P<Pat>]) {\n+        if pats.is_empty() {\n+            return;\n+        }\n+\n+        let mut missing_vars = FxHashMap::default();\n+        let mut inconsistent_vars = FxHashMap::default();\n+        for (i, p) in pats.iter().enumerate() {\n+            let map_i = self.binding_mode_map(&p);\n+\n+            for (j, q) in pats.iter().enumerate() {\n+                if i == j {\n+                    continue;\n+                }\n+\n+                let map_j = self.binding_mode_map(&q);\n+                for (&key, &binding_i) in &map_i {\n+                    if map_j.is_empty() {                   // Account for missing bindings when\n+                        let binding_error = missing_vars    // `map_j` has none.\n+                            .entry(key.name)\n+                            .or_insert(BindingError {\n+                                name: key.name,\n+                                origin: BTreeSet::new(),\n+                                target: BTreeSet::new(),\n+                            });\n+                        binding_error.origin.insert(binding_i.span);\n+                        binding_error.target.insert(q.span);\n+                    }\n+                    for (&key_j, &binding_j) in &map_j {\n+                        match map_i.get(&key_j) {\n+                            None => {  // missing binding\n+                                let binding_error = missing_vars\n+                                    .entry(key_j.name)\n+                                    .or_insert(BindingError {\n+                                        name: key_j.name,\n+                                        origin: BTreeSet::new(),\n+                                        target: BTreeSet::new(),\n+                                    });\n+                                binding_error.origin.insert(binding_j.span);\n+                                binding_error.target.insert(p.span);\n+                            }\n+                            Some(binding_i) => {  // check consistent binding\n+                                if binding_i.binding_mode != binding_j.binding_mode {\n+                                    inconsistent_vars\n+                                        .entry(key.name)\n+                                        .or_insert((binding_j.span, binding_i.span));\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+        let mut missing_vars = missing_vars.iter().collect::<Vec<_>>();\n+        missing_vars.sort();\n+        for (_, v) in missing_vars {\n+            self.r.report_error(\n+                *v.origin.iter().next().unwrap(), ResolutionError::VariableNotBoundInPattern(v)\n+            );\n+        }\n+        let mut inconsistent_vars = inconsistent_vars.iter().collect::<Vec<_>>();\n+        inconsistent_vars.sort();\n+        for (name, v) in inconsistent_vars {\n+            self.r.report_error(v.0, ResolutionError::VariableBoundWithDifferentMode(*name, v.1));\n+        }\n+    }\n+\n+    fn resolve_arm(&mut self, arm: &Arm) {\n+        self.ribs[ValueNS].push(Rib::new(NormalRibKind));\n+\n+        self.resolve_pats(&arm.pats, PatternSource::Match);\n+\n+        if let Some(ref expr) = arm.guard {\n+            self.visit_expr(expr)\n+        }\n+        self.visit_expr(&arm.body);\n+\n+        self.ribs[ValueNS].pop();\n+    }\n+\n+    /// Arising from `source`, resolve a sequence of patterns (top level or-patterns).\n+    fn resolve_pats(&mut self, pats: &[P<Pat>], source: PatternSource) {\n+        let mut bindings_list = FxHashMap::default();\n+        for pat in pats {\n+            self.resolve_pattern(pat, source, &mut bindings_list);\n+        }\n+        // This has to happen *after* we determine which pat_idents are variants\n+        self.check_consistent_bindings(pats);\n+    }\n+\n+    fn resolve_block(&mut self, block: &Block) {\n+        debug!(\"(resolving block) entering block\");\n+        // Move down in the graph, if there's an anonymous module rooted here.\n+        let orig_module = self.parent_scope.module;\n+        let anonymous_module = self.r.block_map.get(&block.id).cloned(); // clones a reference\n+\n+        let mut num_macro_definition_ribs = 0;\n+        if let Some(anonymous_module) = anonymous_module {\n+            debug!(\"(resolving block) found anonymous module, moving down\");\n+            self.ribs[ValueNS].push(Rib::new(ModuleRibKind(anonymous_module)));\n+            self.ribs[TypeNS].push(Rib::new(ModuleRibKind(anonymous_module)));\n+            self.parent_scope.module = anonymous_module;\n+            self.r.finalize_current_module_macro_resolutions(anonymous_module);\n+        } else {\n+            self.ribs[ValueNS].push(Rib::new(NormalRibKind));\n+        }\n+\n+        // Descend into the block.\n+        for stmt in &block.stmts {\n+            if let StmtKind::Item(ref item) = stmt.node {\n+                if let ItemKind::MacroDef(..) = item.node {\n+                    num_macro_definition_ribs += 1;\n+                    let res = self.r.definitions.local_def_id(item.id);\n+                    self.ribs[ValueNS].push(Rib::new(MacroDefinition(res)));\n+                    self.label_ribs.push(Rib::new(MacroDefinition(res)));\n+                }\n+            }\n+\n+            self.visit_stmt(stmt);\n+        }\n+\n+        // Move back up.\n+        self.parent_scope.module = orig_module;\n+        for _ in 0 .. num_macro_definition_ribs {\n+            self.ribs[ValueNS].pop();\n+            self.label_ribs.pop();\n+        }\n+        self.ribs[ValueNS].pop();\n+        if anonymous_module.is_some() {\n+            self.ribs[TypeNS].pop();\n+        }\n+        debug!(\"(resolving block) leaving block\");\n+    }\n+\n+    fn fresh_binding(&mut self,\n+                     ident: Ident,\n+                     pat_id: NodeId,\n+                     outer_pat_id: NodeId,\n+                     pat_src: PatternSource,\n+                     bindings: &mut FxHashMap<Ident, NodeId>)\n+                     -> Res {\n+        // Add the binding to the local ribs, if it\n+        // doesn't already exist in the bindings map. (We\n+        // must not add it if it's in the bindings map\n+        // because that breaks the assumptions later\n+        // passes make about or-patterns.)\n+        let ident = ident.modern_and_legacy();\n+        let mut res = Res::Local(pat_id);\n+        match bindings.get(&ident).cloned() {\n+            Some(id) if id == outer_pat_id => {\n+                // `Variant(a, a)`, error\n+                self.r.report_error(\n+                    ident.span,\n+                    ResolutionError::IdentifierBoundMoreThanOnceInSamePattern(\n+                        &ident.as_str())\n+                );\n+            }\n+            Some(..) if pat_src == PatternSource::FnParam => {\n+                // `fn f(a: u8, a: u8)`, error\n+                self.r.report_error(\n+                    ident.span,\n+                    ResolutionError::IdentifierBoundMoreThanOnceInParameterList(\n+                        &ident.as_str())\n+                );\n+            }\n+            Some(..) if pat_src == PatternSource::Match ||\n+                        pat_src == PatternSource::Let => {\n+                // `Variant1(a) | Variant2(a)`, ok\n+                // Reuse definition from the first `a`.\n+                res = self.ribs[ValueNS].last_mut().unwrap().bindings[&ident];\n+            }\n+            Some(..) => {\n+                span_bug!(ident.span, \"two bindings with the same name from \\\n+                                       unexpected pattern source {:?}\", pat_src);\n+            }\n+            None => {\n+                // A completely fresh binding, add to the lists if it's valid.\n+                if ident.name != kw::Invalid {\n+                    bindings.insert(ident, outer_pat_id);\n+                    self.ribs[ValueNS].last_mut().unwrap().bindings.insert(ident, res);\n+                }\n+            }\n+        }\n+\n+        res\n+    }\n+\n+    fn resolve_pattern(&mut self,\n+                       pat: &Pat,\n+                       pat_src: PatternSource,\n+                       // Maps idents to the node ID for the\n+                       // outermost pattern that binds them.\n+                       bindings: &mut FxHashMap<Ident, NodeId>) {\n+        // Visit all direct subpatterns of this pattern.\n+        let outer_pat_id = pat.id;\n+        pat.walk(&mut |pat| {\n+            debug!(\"resolve_pattern pat={:?} node={:?}\", pat, pat.node);\n+            match pat.node {\n+                PatKind::Ident(bmode, ident, ref opt_pat) => {\n+                    // First try to resolve the identifier as some existing\n+                    // entity, then fall back to a fresh binding.\n+                    let binding = self.resolve_ident_in_lexical_scope(ident, ValueNS,\n+                                                                      None, pat.span)\n+                                      .and_then(LexicalScopeBinding::item);\n+                    let res = binding.map(NameBinding::res).and_then(|res| {\n+                        let is_syntactic_ambiguity = opt_pat.is_none() &&\n+                            bmode == BindingMode::ByValue(Mutability::Immutable);\n+                        match res {\n+                            Res::Def(DefKind::Ctor(_, CtorKind::Const), _) |\n+                            Res::Def(DefKind::Const, _) if is_syntactic_ambiguity => {\n+                                // Disambiguate in favor of a unit struct/variant\n+                                // or constant pattern.\n+                                self.r.record_use(ident, ValueNS, binding.unwrap(), false);\n+                                Some(res)\n+                            }\n+                            Res::Def(DefKind::Ctor(..), _)\n+                            | Res::Def(DefKind::Const, _)\n+                            | Res::Def(DefKind::Static, _) => {\n+                                // This is unambiguously a fresh binding, either syntactically\n+                                // (e.g., `IDENT @ PAT` or `ref IDENT`) or because `IDENT` resolves\n+                                // to something unusable as a pattern (e.g., constructor function),\n+                                // but we still conservatively report an error, see\n+                                // issues/33118#issuecomment-233962221 for one reason why.\n+                                self.r.report_error(\n+                                    ident.span,\n+                                    ResolutionError::BindingShadowsSomethingUnacceptable(\n+                                        pat_src.descr(), ident.name, binding.unwrap())\n+                                );\n+                                None\n+                            }\n+                            Res::Def(DefKind::Fn, _) | Res::Err => {\n+                                // These entities are explicitly allowed\n+                                // to be shadowed by fresh bindings.\n+                                None\n+                            }\n+                            res => {\n+                                span_bug!(ident.span, \"unexpected resolution for an \\\n+                                                       identifier in pattern: {:?}\", res);\n+                            }\n+                        }\n+                    }).unwrap_or_else(|| {\n+                        self.fresh_binding(ident, pat.id, outer_pat_id, pat_src, bindings)\n+                    });\n+\n+                    self.r.record_partial_res(pat.id, PartialRes::new(res));\n+                }\n+\n+                PatKind::TupleStruct(ref path, ..) => {\n+                    self.smart_resolve_path(pat.id, None, path, PathSource::TupleStruct);\n+                }\n+\n+                PatKind::Path(ref qself, ref path) => {\n+                    self.smart_resolve_path(pat.id, qself.as_ref(), path, PathSource::Pat);\n+                }\n+\n+                PatKind::Struct(ref path, ..) => {\n+                    self.smart_resolve_path(pat.id, None, path, PathSource::Struct);\n+                }\n+\n+                _ => {}\n+            }\n+            true\n+        });\n+\n+        visit::walk_pat(self, pat);\n+    }\n+\n+    // High-level and context dependent path resolution routine.\n+    // Resolves the path and records the resolution into definition map.\n+    // If resolution fails tries several techniques to find likely\n+    // resolution candidates, suggest imports or other help, and report\n+    // errors in user friendly way.\n+    fn smart_resolve_path(&mut self,\n+                          id: NodeId,\n+                          qself: Option<&QSelf>,\n+                          path: &Path,\n+                          source: PathSource<'_>) {\n+        self.smart_resolve_path_fragment(\n+            id,\n+            qself,\n+            &Segment::from_path(path),\n+            path.span,\n+            source,\n+            CrateLint::SimplePath(id),\n+        );\n+    }\n+\n+    fn smart_resolve_path_fragment(&mut self,\n+                                   id: NodeId,\n+                                   qself: Option<&QSelf>,\n+                                   path: &[Segment],\n+                                   span: Span,\n+                                   source: PathSource<'_>,\n+                                   crate_lint: CrateLint)\n+                                   -> PartialRes {\n+        let ns = source.namespace();\n+        let is_expected = &|res| source.is_expected(res);\n+\n+        let report_errors = |this: &mut Self, res: Option<Res>| {\n+            let (err, candidates) = this.smart_resolve_report_errors(path, span, source, res);\n+            let def_id = this.parent_scope.module.normal_ancestor_id;\n+            let node_id = this.r.definitions.as_local_node_id(def_id).unwrap();\n+            let better = res.is_some();\n+            this.r.use_injections.push(UseError { err, candidates, node_id, better });\n+            PartialRes::new(Res::Err)\n+        };\n+\n+        let partial_res = match self.resolve_qpath_anywhere(\n+            id,\n+            qself,\n+            path,\n+            ns,\n+            span,\n+            source.defer_to_typeck(),\n+            crate_lint,\n+        ) {\n+            Some(partial_res) if partial_res.unresolved_segments() == 0 => {\n+                if is_expected(partial_res.base_res()) || partial_res.base_res() == Res::Err {\n+                    partial_res\n+                } else {\n+                    // Add a temporary hack to smooth the transition to new struct ctor\n+                    // visibility rules. See #38932 for more details.\n+                    let mut res = None;\n+                    if let Res::Def(DefKind::Struct, def_id) = partial_res.base_res() {\n+                        if let Some((ctor_res, ctor_vis))\n+                                = self.r.struct_constructors.get(&def_id).cloned() {\n+                            if is_expected(ctor_res) &&\n+                               self.r.is_accessible_from(ctor_vis, self.parent_scope.module) {\n+                                let lint = lint::builtin::LEGACY_CONSTRUCTOR_VISIBILITY;\n+                                self.r.session.buffer_lint(lint, id, span,\n+                                    \"private struct constructors are not usable through \\\n+                                     re-exports in outer modules\",\n+                                );\n+                                res = Some(PartialRes::new(ctor_res));\n+                            }\n+                        }\n+                    }\n+\n+                    res.unwrap_or_else(|| report_errors(self, Some(partial_res.base_res())))\n+                }\n+            }\n+            Some(partial_res) if source.defer_to_typeck() => {\n+                // Not fully resolved associated item `T::A::B` or `<T as Tr>::A::B`\n+                // or `<T>::A::B`. If `B` should be resolved in value namespace then\n+                // it needs to be added to the trait map.\n+                if ns == ValueNS {\n+                    let item_name = path.last().unwrap().ident;\n+                    let traits = self.get_traits_containing_item(item_name, ns);\n+                    self.r.trait_map.insert(id, traits);\n+                }\n+\n+                let mut std_path = vec![Segment::from_ident(Ident::with_empty_ctxt(sym::std))];\n+                std_path.extend(path);\n+                if self.r.primitive_type_table.primitive_types.contains_key(&path[0].ident.name) {\n+                    let cl = CrateLint::No;\n+                    let ns = Some(ns);\n+                    if let PathResult::Module(_) | PathResult::NonModule(_) =\n+                            self.resolve_path(&std_path, ns, false, span, cl) {\n+                        // check if we wrote `str::from_utf8` instead of `std::str::from_utf8`\n+                        let item_span = path.iter().last().map(|segment| segment.ident.span)\n+                            .unwrap_or(span);\n+                        debug!(\"accessed item from `std` submodule as a bare type {:?}\", std_path);\n+                        let mut hm = self.r.session.confused_type_with_std_module.borrow_mut();\n+                        hm.insert(item_span, span);\n+                        // In some places (E0223) we only have access to the full path\n+                        hm.insert(span, span);\n+                    }\n+                }\n+                partial_res\n+            }\n+            _ => report_errors(self, None)\n+        };\n+\n+        if let PathSource::TraitItem(..) = source {} else {\n+            // Avoid recording definition of `A::B` in `<T as A>::B::C`.\n+            self.r.record_partial_res(id, partial_res);\n+        }\n+        partial_res\n+    }\n+\n+    fn self_type_is_available(&mut self, span: Span) -> bool {\n+        let binding = self.resolve_ident_in_lexical_scope(\n+            Ident::with_empty_ctxt(kw::SelfUpper),\n+            TypeNS,\n+            None,\n+            span,\n+        );\n+        if let Some(LexicalScopeBinding::Res(res)) = binding { res != Res::Err } else { false }\n+    }\n+\n+    fn self_value_is_available(&mut self, self_span: Span, path_span: Span) -> bool {\n+        let ident = Ident::new(kw::SelfLower, self_span);\n+        let binding = self.resolve_ident_in_lexical_scope(ident, ValueNS, None, path_span);\n+        if let Some(LexicalScopeBinding::Res(res)) = binding { res != Res::Err } else { false }\n+    }\n+\n+    // Resolve in alternative namespaces if resolution in the primary namespace fails.\n+    fn resolve_qpath_anywhere(\n+        &mut self,\n+        id: NodeId,\n+        qself: Option<&QSelf>,\n+        path: &[Segment],\n+        primary_ns: Namespace,\n+        span: Span,\n+        defer_to_typeck: bool,\n+        crate_lint: CrateLint,\n+    ) -> Option<PartialRes> {\n+        let mut fin_res = None;\n+        for (i, ns) in [primary_ns, TypeNS, ValueNS].iter().cloned().enumerate() {\n+            if i == 0 || ns != primary_ns {\n+                match self.resolve_qpath(id, qself, path, ns, span, crate_lint) {\n+                    // If defer_to_typeck, then resolution > no resolution,\n+                    // otherwise full resolution > partial resolution > no resolution.\n+                    Some(partial_res) if partial_res.unresolved_segments() == 0 ||\n+                                         defer_to_typeck =>\n+                        return Some(partial_res),\n+                    partial_res => if fin_res.is_none() { fin_res = partial_res },\n+                }\n+            }\n+        }\n+\n+        // `MacroNS`\n+        assert!(primary_ns != MacroNS);\n+        if qself.is_none() {\n+            let path_seg = |seg: &Segment| PathSegment::from_ident(seg.ident);\n+            let path = Path { segments: path.iter().map(path_seg).collect(), span };\n+            if let Ok((_, res)) = self.r.resolve_macro_path(\n+                &path, None, &self.parent_scope, false, false\n+            ) {\n+                return Some(PartialRes::new(res));\n+            }\n+        }\n+\n+        fin_res\n+    }\n+\n+    /// Handles paths that may refer to associated items.\n+    fn resolve_qpath(\n+        &mut self,\n+        id: NodeId,\n+        qself: Option<&QSelf>,\n+        path: &[Segment],\n+        ns: Namespace,\n+        span: Span,\n+        crate_lint: CrateLint,\n+    ) -> Option<PartialRes> {\n+        debug!(\n+            \"resolve_qpath(id={:?}, qself={:?}, path={:?}, ns={:?}, span={:?})\",\n+            id,\n+            qself,\n+            path,\n+            ns,\n+            span,\n+        );\n+\n+        if let Some(qself) = qself {\n+            if qself.position == 0 {\n+                // This is a case like `<T>::B`, where there is no\n+                // trait to resolve.  In that case, we leave the `B`\n+                // segment to be resolved by type-check.\n+                return Some(PartialRes::with_unresolved_segments(\n+                    Res::Def(DefKind::Mod, DefId::local(CRATE_DEF_INDEX)), path.len()\n+                ));\n+            }\n+\n+            // Make sure `A::B` in `<T as A::B>::C` is a trait item.\n+            //\n+            // Currently, `path` names the full item (`A::B::C`, in\n+            // our example).  so we extract the prefix of that that is\n+            // the trait (the slice upto and including\n+            // `qself.position`). And then we recursively resolve that,\n+            // but with `qself` set to `None`.\n+            //\n+            // However, setting `qself` to none (but not changing the\n+            // span) loses the information about where this path\n+            // *actually* appears, so for the purposes of the crate\n+            // lint we pass along information that this is the trait\n+            // name from a fully qualified path, and this also\n+            // contains the full span (the `CrateLint::QPathTrait`).\n+            let ns = if qself.position + 1 == path.len() { ns } else { TypeNS };\n+            let partial_res = self.smart_resolve_path_fragment(\n+                id,\n+                None,\n+                &path[..=qself.position],\n+                span,\n+                PathSource::TraitItem(ns),\n+                CrateLint::QPathTrait {\n+                    qpath_id: id,\n+                    qpath_span: qself.path_span,\n+                },\n+            );\n+\n+            // The remaining segments (the `C` in our example) will\n+            // have to be resolved by type-check, since that requires doing\n+            // trait resolution.\n+            return Some(PartialRes::with_unresolved_segments(\n+                partial_res.base_res(),\n+                partial_res.unresolved_segments() + path.len() - qself.position - 1,\n+            ));\n+        }\n+\n+        let result = match self.resolve_path(&path, Some(ns), true, span, crate_lint) {\n+            PathResult::NonModule(path_res) => path_res,\n+            PathResult::Module(ModuleOrUniformRoot::Module(module)) if !module.is_normal() => {\n+                PartialRes::new(module.res().unwrap())\n+            }\n+            // In `a(::assoc_item)*` `a` cannot be a module. If `a` does resolve to a module we\n+            // don't report an error right away, but try to fallback to a primitive type.\n+            // So, we are still able to successfully resolve something like\n+            //\n+            // use std::u8; // bring module u8 in scope\n+            // fn f() -> u8 { // OK, resolves to primitive u8, not to std::u8\n+            //     u8::max_value() // OK, resolves to associated function <u8>::max_value,\n+            //                     // not to non-existent std::u8::max_value\n+            // }\n+            //\n+            // Such behavior is required for backward compatibility.\n+            // The same fallback is used when `a` resolves to nothing.\n+            PathResult::Module(ModuleOrUniformRoot::Module(_)) |\n+            PathResult::Failed { .. }\n+                    if (ns == TypeNS || path.len() > 1) &&\n+                       self.r.primitive_type_table.primitive_types\n+                           .contains_key(&path[0].ident.name) => {\n+                let prim = self.r.primitive_type_table.primitive_types[&path[0].ident.name];\n+                PartialRes::with_unresolved_segments(Res::PrimTy(prim), path.len() - 1)\n+            }\n+            PathResult::Module(ModuleOrUniformRoot::Module(module)) =>\n+                PartialRes::new(module.res().unwrap()),\n+            PathResult::Failed { is_error_from_last_segment: false, span, label, suggestion } => {\n+                self.r.report_error(span, ResolutionError::FailedToResolve { label, suggestion });\n+                PartialRes::new(Res::Err)\n+            }\n+            PathResult::Module(..) | PathResult::Failed { .. } => return None,\n+            PathResult::Indeterminate => bug!(\"indetermined path result in resolve_qpath\"),\n+        };\n+\n+        if path.len() > 1 && result.base_res() != Res::Err &&\n+           path[0].ident.name != kw::PathRoot &&\n+           path[0].ident.name != kw::DollarCrate {\n+            let unqualified_result = {\n+                match self.resolve_path(\n+                    &[*path.last().unwrap()],\n+                    Some(ns),\n+                    false,\n+                    span,\n+                    CrateLint::No,\n+                ) {\n+                    PathResult::NonModule(path_res) => path_res.base_res(),\n+                    PathResult::Module(ModuleOrUniformRoot::Module(module)) =>\n+                        module.res().unwrap(),\n+                    _ => return Some(result),\n+                }\n+            };\n+            if result.base_res() == unqualified_result {\n+                let lint = lint::builtin::UNUSED_QUALIFICATIONS;\n+                self.r.session.buffer_lint(lint, id, span, \"unnecessary qualification\")\n+            }\n+        }\n+\n+        Some(result)\n+    }\n+\n+    fn with_resolved_label<F>(&mut self, label: Option<Label>, id: NodeId, f: F)\n+        where F: FnOnce(&mut LateResolutionVisitor<'_, '_>)\n+    {\n+        if let Some(label) = label {\n+            self.unused_labels.insert(id, label.ident.span);\n+            self.with_label_rib(|this| {\n+                let ident = label.ident.modern_and_legacy();\n+                this.label_ribs.last_mut().unwrap().bindings.insert(ident, id);\n+                f(this);\n+            });\n+        } else {\n+            f(self);\n+        }\n+    }\n+\n+    fn resolve_labeled_block(&mut self, label: Option<Label>, id: NodeId, block: &Block) {\n+        self.with_resolved_label(label, id, |this| this.visit_block(block));\n+    }\n+\n+    fn resolve_expr(&mut self, expr: &Expr, parent: Option<&Expr>) {\n+        // First, record candidate traits for this expression if it could\n+        // result in the invocation of a method call.\n+\n+        self.record_candidate_traits_for_expr_if_necessary(expr);\n+\n+        // Next, resolve the node.\n+        match expr.node {\n+            ExprKind::Path(ref qself, ref path) => {\n+                self.smart_resolve_path(expr.id, qself.as_ref(), path, PathSource::Expr(parent));\n+                visit::walk_expr(self, expr);\n+            }\n+\n+            ExprKind::Struct(ref path, ..) => {\n+                self.smart_resolve_path(expr.id, None, path, PathSource::Struct);\n+                visit::walk_expr(self, expr);\n+            }\n+\n+            ExprKind::Break(Some(label), _) | ExprKind::Continue(Some(label)) => {\n+                let node_id = self.search_label(label.ident, |rib, ident| {\n+                    rib.bindings.get(&ident.modern_and_legacy()).cloned()\n+                });\n+                match node_id {\n+                    None => {\n+                        // Search again for close matches...\n+                        // Picks the first label that is \"close enough\", which is not necessarily\n+                        // the closest match\n+                        let close_match = self.search_label(label.ident, |rib, ident| {\n+                            let names = rib.bindings.iter().filter_map(|(id, _)| {\n+                                if id.span.ctxt() == label.ident.span.ctxt() {\n+                                    Some(&id.name)\n+                                } else {\n+                                    None\n+                                }\n+                            });\n+                            find_best_match_for_name(names, &*ident.as_str(), None)\n+                        });\n+                        self.r.record_partial_res(expr.id, PartialRes::new(Res::Err));\n+                        self.r.report_error(\n+                            label.ident.span,\n+                            ResolutionError::UndeclaredLabel(&label.ident.as_str(), close_match),\n+                        );\n+                    }\n+                    Some(node_id) => {\n+                        // Since this res is a label, it is never read.\n+                        self.r.label_res_map.insert(expr.id, node_id);\n+                        self.unused_labels.remove(&node_id);\n+                    }\n+                }\n+\n+                // visit `break` argument if any\n+                visit::walk_expr(self, expr);\n+            }\n+\n+            ExprKind::Let(ref pats, ref scrutinee) => {\n+                self.visit_expr(scrutinee);\n+                self.resolve_pats(pats, PatternSource::Let);\n+            }\n+\n+            ExprKind::If(ref cond, ref then, ref opt_else) => {\n+                self.ribs[ValueNS].push(Rib::new(NormalRibKind));\n+                self.visit_expr(cond);\n+                self.visit_block(then);\n+                self.ribs[ValueNS].pop();\n+\n+                opt_else.as_ref().map(|expr| self.visit_expr(expr));\n+            }\n+\n+            ExprKind::Loop(ref block, label) => self.resolve_labeled_block(label, expr.id, &block),\n+\n+            ExprKind::While(ref subexpression, ref block, label) => {\n+                self.with_resolved_label(label, expr.id, |this| {\n+                    this.ribs[ValueNS].push(Rib::new(NormalRibKind));\n+                    this.visit_expr(subexpression);\n+                    this.visit_block(block);\n+                    this.ribs[ValueNS].pop();\n+                });\n+            }\n+\n+            ExprKind::ForLoop(ref pattern, ref subexpression, ref block, label) => {\n+                self.visit_expr(subexpression);\n+                self.ribs[ValueNS].push(Rib::new(NormalRibKind));\n+                self.resolve_pattern(pattern, PatternSource::For, &mut FxHashMap::default());\n+\n+                self.resolve_labeled_block(label, expr.id, block);\n+\n+                self.ribs[ValueNS].pop();\n+            }\n+\n+            ExprKind::Block(ref block, label) => self.resolve_labeled_block(label, block.id, block),\n+\n+            // Equivalent to `visit::walk_expr` + passing some context to children.\n+            ExprKind::Field(ref subexpression, _) => {\n+                self.resolve_expr(subexpression, Some(expr));\n+            }\n+            ExprKind::MethodCall(ref segment, ref arguments) => {\n+                let mut arguments = arguments.iter();\n+                self.resolve_expr(arguments.next().unwrap(), Some(expr));\n+                for argument in arguments {\n+                    self.resolve_expr(argument, None);\n+                }\n+                self.visit_path_segment(expr.span, segment);\n+            }\n+\n+            ExprKind::Call(ref callee, ref arguments) => {\n+                self.resolve_expr(callee, Some(expr));\n+                for argument in arguments {\n+                    self.resolve_expr(argument, None);\n+                }\n+            }\n+            ExprKind::Type(ref type_expr, _) => {\n+                self.current_type_ascription.push(type_expr.span);\n+                visit::walk_expr(self, expr);\n+                self.current_type_ascription.pop();\n+            }\n+            // `async |x| ...` gets desugared to `|x| future_from_generator(|| ...)`, so we need to\n+            // resolve the arguments within the proper scopes so that usages of them inside the\n+            // closure are detected as upvars rather than normal closure arg usages.\n+            ExprKind::Closure(\n+                _, IsAsync::Async { .. }, _,\n+                ref fn_decl, ref body, _span,\n+            ) => {\n+                let rib_kind = NormalRibKind;\n+                self.ribs[ValueNS].push(Rib::new(rib_kind));\n+                // Resolve arguments:\n+                let mut bindings_list = FxHashMap::default();\n+                for argument in &fn_decl.inputs {\n+                    self.resolve_pattern(&argument.pat, PatternSource::FnParam, &mut bindings_list);\n+                    self.visit_ty(&argument.ty);\n+                }\n+                // No need to resolve return type-- the outer closure return type is\n+                // FunctionRetTy::Default\n+\n+                // Now resolve the inner closure\n+                {\n+                    // No need to resolve arguments: the inner closure has none.\n+                    // Resolve the return type:\n+                    visit::walk_fn_ret_ty(self, &fn_decl.output);\n+                    // Resolve the body\n+                    self.visit_expr(body);\n+                }\n+                self.ribs[ValueNS].pop();\n+            }\n+            _ => {\n+                visit::walk_expr(self, expr);\n+            }\n+        }\n+    }\n+\n+    fn record_candidate_traits_for_expr_if_necessary(&mut self, expr: &Expr) {\n+        match expr.node {\n+            ExprKind::Field(_, ident) => {\n+                // FIXME(#6890): Even though you can't treat a method like a\n+                // field, we need to add any trait methods we find that match\n+                // the field name so that we can do some nice error reporting\n+                // later on in typeck.\n+                let traits = self.get_traits_containing_item(ident, ValueNS);\n+                self.r.trait_map.insert(expr.id, traits);\n+            }\n+            ExprKind::MethodCall(ref segment, ..) => {\n+                debug!(\"(recording candidate traits for expr) recording traits for {}\",\n+                       expr.id);\n+                let traits = self.get_traits_containing_item(segment.ident, ValueNS);\n+                self.r.trait_map.insert(expr.id, traits);\n+            }\n+            _ => {\n+                // Nothing to do.\n+            }\n+        }\n+    }\n+\n+    fn get_traits_containing_item(&mut self, mut ident: Ident, ns: Namespace)\n+                                  -> Vec<TraitCandidate> {\n+        debug!(\"(getting traits containing item) looking for '{}'\", ident.name);\n+\n+        let mut found_traits = Vec::new();\n+        // Look for the current trait.\n+        if let Some((module, _)) = self.current_trait_ref {\n+            if self.r.resolve_ident_in_module(\n+                ModuleOrUniformRoot::Module(module),\n+                ident,\n+                ns,\n+                &self.parent_scope,\n+                false,\n+                module.span,\n+            ).is_ok() {\n+                let def_id = module.def_id().unwrap();\n+                found_traits.push(TraitCandidate { def_id: def_id, import_ids: smallvec![] });\n+            }\n+        }\n+\n+        ident.span = ident.span.modern();\n+        let mut search_module = self.parent_scope.module;\n+        loop {\n+            self.get_traits_in_module_containing_item(ident, ns, search_module, &mut found_traits);\n+            search_module = unwrap_or!(\n+                self.r.hygienic_lexical_parent(search_module, &mut ident.span), break\n+            );\n+        }\n+\n+        if let Some(prelude) = self.r.prelude {\n+            if !search_module.no_implicit_prelude {\n+                self.get_traits_in_module_containing_item(ident, ns, prelude, &mut found_traits);\n+            }\n+        }\n+\n+        found_traits\n+    }\n+\n+    fn get_traits_in_module_containing_item(&mut self,\n+                                            ident: Ident,\n+                                            ns: Namespace,\n+                                            module: Module<'a>,\n+                                            found_traits: &mut Vec<TraitCandidate>) {\n+        assert!(ns == TypeNS || ns == ValueNS);\n+        let mut traits = module.traits.borrow_mut();\n+        if traits.is_none() {\n+            let mut collected_traits = Vec::new();\n+            module.for_each_child(|name, ns, binding| {\n+                if ns != TypeNS { return }\n+                match binding.res() {\n+                    Res::Def(DefKind::Trait, _) |\n+                    Res::Def(DefKind::TraitAlias, _) => collected_traits.push((name, binding)),\n+                    _ => (),\n+                }\n+            });\n+            *traits = Some(collected_traits.into_boxed_slice());\n+        }\n+\n+        for &(trait_name, binding) in traits.as_ref().unwrap().iter() {\n+            // Traits have pseudo-modules that can be used to search for the given ident.\n+            if let Some(module) = binding.module() {\n+                let mut ident = ident;\n+                if ident.span.glob_adjust(\n+                    module.expansion,\n+                    binding.span,\n+                ).is_none() {\n+                    continue\n+                }\n+                if self.r.resolve_ident_in_module_unadjusted(\n+                    ModuleOrUniformRoot::Module(module),\n+                    ident,\n+                    ns,\n+                    &self.parent_scope,\n+                    false,\n+                    module.span,\n+                ).is_ok() {\n+                    let import_ids = self.find_transitive_imports(&binding.kind, trait_name);\n+                    let trait_def_id = module.def_id().unwrap();\n+                    found_traits.push(TraitCandidate { def_id: trait_def_id, import_ids });\n+                }\n+            } else if let Res::Def(DefKind::TraitAlias, _) = binding.res() {\n+                // For now, just treat all trait aliases as possible candidates, since we don't\n+                // know if the ident is somewhere in the transitive bounds.\n+                let import_ids = self.find_transitive_imports(&binding.kind, trait_name);\n+                let trait_def_id = binding.res().def_id();\n+                found_traits.push(TraitCandidate { def_id: trait_def_id, import_ids });\n+            } else {\n+                bug!(\"candidate is not trait or trait alias?\")\n+            }\n+        }\n+    }\n+\n+    fn find_transitive_imports(&mut self, mut kind: &NameBindingKind<'_>,\n+                               trait_name: Ident) -> SmallVec<[NodeId; 1]> {\n+        let mut import_ids = smallvec![];\n+        while let NameBindingKind::Import { directive, binding, .. } = kind {\n+            self.r.maybe_unused_trait_imports.insert(directive.id);\n+            self.r.add_to_glob_map(&directive, trait_name);\n+            import_ids.push(directive.id);\n+            kind = &binding.kind;\n+        };\n+        import_ids\n+    }\n+}\n+\n+impl<'a> Resolver<'a> {\n+    pub(crate) fn late_resolve_crate(&mut self, krate: &Crate) {\n+        self.finalize_current_module_macro_resolutions(self.graph_root);\n+        let mut late_resolution_visitor = LateResolutionVisitor::new(self);\n+        visit::walk_crate(&mut late_resolution_visitor, krate);\n+        for (id, span) in late_resolution_visitor.unused_labels.iter() {\n+            self.session.buffer_lint(lint::builtin::UNUSED_LABELS, *id, *span, \"unused label\");\n+        }\n+    }\n+}"}, {"sha": "35cf720ad8742403f05742eccee07b5eed4b8c81", "filename": "src/librustc_resolve/late/diagnostics.rs", "status": "added", "additions": 770, "deletions": 0, "changes": 770, "blob_url": "https://github.com/rust-lang/rust/blob/9d76a938de25e626a7c79a76789d7885405703e6/src%2Flibrustc_resolve%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d76a938de25e626a7c79a76789d7885405703e6/src%2Flibrustc_resolve%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate%2Fdiagnostics.rs?ref=9d76a938de25e626a7c79a76789d7885405703e6", "patch": "@@ -0,0 +1,770 @@\n+use crate::{CrateLint, Module, ModuleKind, ModuleOrUniformRoot};\n+use crate::{PathResult, PathSource, Segment};\n+use crate::path_names_to_string;\n+use crate::diagnostics::{add_typo_suggestion, add_module_candidates};\n+use crate::diagnostics::{ImportSuggestion, TypoSuggestion};\n+use crate::late::{LateResolutionVisitor, RibKind};\n+\n+use errors::{Applicability, DiagnosticBuilder, DiagnosticId};\n+use log::debug;\n+use rustc::hir::def::{self, DefKind, CtorKind};\n+use rustc::hir::def::Namespace::{self, *};\n+use rustc::hir::def_id::{CRATE_DEF_INDEX, DefId};\n+use rustc::hir::PrimTy;\n+use rustc::session::config::nightly_options;\n+use rustc::util::nodemap::FxHashSet;\n+use syntax::ast::{self, Expr, ExprKind, Ident, NodeId, Path, Ty, TyKind};\n+use syntax::ext::base::MacroKind;\n+use syntax::symbol::kw;\n+use syntax::util::lev_distance::find_best_match_for_name;\n+use syntax_pos::Span;\n+\n+type Res = def::Res<ast::NodeId>;\n+\n+/// A field or associated item from self type suggested in case of resolution failure.\n+enum AssocSuggestion {\n+    Field,\n+    MethodWithSelf,\n+    AssocItem,\n+}\n+\n+fn is_self_type(path: &[Segment], namespace: Namespace) -> bool {\n+    namespace == TypeNS && path.len() == 1 && path[0].ident.name == kw::SelfUpper\n+}\n+\n+fn is_self_value(path: &[Segment], namespace: Namespace) -> bool {\n+    namespace == ValueNS && path.len() == 1 && path[0].ident.name == kw::SelfLower\n+}\n+\n+/// Gets the stringified path for an enum from an `ImportSuggestion` for an enum variant.\n+fn import_candidate_to_enum_paths(suggestion: &ImportSuggestion) -> (String, String) {\n+    let variant_path = &suggestion.path;\n+    let variant_path_string = path_names_to_string(variant_path);\n+\n+    let path_len = suggestion.path.segments.len();\n+    let enum_path = ast::Path {\n+        span: suggestion.path.span,\n+        segments: suggestion.path.segments[0..path_len - 1].to_vec(),\n+    };\n+    let enum_path_string = path_names_to_string(&enum_path);\n+\n+    (variant_path_string, enum_path_string)\n+}\n+\n+impl<'a> LateResolutionVisitor<'a, '_> {\n+    /// Handles error reporting for `smart_resolve_path_fragment` function.\n+    /// Creates base error and amends it with one short label and possibly some longer helps/notes.\n+    pub(crate) fn smart_resolve_report_errors(\n+        &mut self,\n+        path: &[Segment],\n+        span: Span,\n+        source: PathSource<'_>,\n+        res: Option<Res>,\n+    ) -> (DiagnosticBuilder<'a>, Vec<ImportSuggestion>) {\n+        let ident_span = path.last().map_or(span, |ident| ident.ident.span);\n+        let ns = source.namespace();\n+        let is_expected = &|res| source.is_expected(res);\n+        let is_enum_variant = &|res| {\n+            if let Res::Def(DefKind::Variant, _) = res { true } else { false }\n+        };\n+\n+        // Make the base error.\n+        let expected = source.descr_expected();\n+        let path_str = Segment::names_to_string(path);\n+        let item_str = path.last().unwrap().ident;\n+        let code = source.error_code(res.is_some());\n+        let (base_msg, fallback_label, base_span) = if let Some(res) = res {\n+            (format!(\"expected {}, found {} `{}`\", expected, res.descr(), path_str),\n+                format!(\"not a {}\", expected),\n+                span)\n+        } else {\n+            let item_span = path.last().unwrap().ident.span;\n+            let (mod_prefix, mod_str) = if path.len() == 1 {\n+                (String::new(), \"this scope\".to_string())\n+            } else if path.len() == 2 && path[0].ident.name == kw::PathRoot {\n+                (String::new(), \"the crate root\".to_string())\n+            } else {\n+                let mod_path = &path[..path.len() - 1];\n+                let mod_prefix = match self.resolve_path(\n+                    mod_path, Some(TypeNS), false, span, CrateLint::No\n+                ) {\n+                    PathResult::Module(ModuleOrUniformRoot::Module(module)) =>\n+                        module.def_kind(),\n+                    _ => None,\n+                }.map_or(String::new(), |kind| format!(\"{} \", kind.descr()));\n+                (mod_prefix, format!(\"`{}`\", Segment::names_to_string(mod_path)))\n+            };\n+            (format!(\"cannot find {} `{}` in {}{}\", expected, item_str, mod_prefix, mod_str),\n+                format!(\"not found in {}\", mod_str),\n+                item_span)\n+        };\n+\n+        let code = DiagnosticId::Error(code.into());\n+        let mut err = self.r.session.struct_span_err_with_code(base_span, &base_msg, code);\n+\n+        // Emit help message for fake-self from other languages (e.g., `this` in Javascript).\n+        if [\"this\", \"my\"].contains(&&*item_str.as_str())\n+            && self.self_value_is_available(path[0].ident.span, span) {\n+            err.span_suggestion(\n+                span,\n+                \"did you mean\",\n+                \"self\".to_string(),\n+                Applicability::MaybeIncorrect,\n+            );\n+        }\n+\n+        // Emit special messages for unresolved `Self` and `self`.\n+        if is_self_type(path, ns) {\n+            __diagnostic_used!(E0411);\n+            err.code(DiagnosticId::Error(\"E0411\".into()));\n+            err.span_label(span, format!(\"`Self` is only available in impls, traits, \\\n+                                          and type definitions\"));\n+            return (err, Vec::new());\n+        }\n+        if is_self_value(path, ns) {\n+            debug!(\"smart_resolve_path_fragment: E0424, source={:?}\", source);\n+\n+            __diagnostic_used!(E0424);\n+            err.code(DiagnosticId::Error(\"E0424\".into()));\n+            err.span_label(span, match source {\n+                PathSource::Pat => {\n+                    format!(\"`self` value is a keyword \\\n+                             and may not be bound to \\\n+                             variables or shadowed\")\n+                }\n+                _ => {\n+                    format!(\"`self` value is a keyword \\\n+                             only available in methods \\\n+                             with `self` parameter\")\n+                }\n+            });\n+            return (err, Vec::new());\n+        }\n+\n+        // Try to lookup name in more relaxed fashion for better error reporting.\n+        let ident = path.last().unwrap().ident;\n+        let candidates = self.r.lookup_import_candidates(ident, ns, is_expected)\n+            .drain(..)\n+            .filter(|ImportSuggestion { did, .. }| {\n+                match (did, res.and_then(|res| res.opt_def_id())) {\n+                    (Some(suggestion_did), Some(actual_did)) => *suggestion_did != actual_did,\n+                    _ => true,\n+                }\n+            })\n+            .collect::<Vec<_>>();\n+        let crate_def_id = DefId::local(CRATE_DEF_INDEX);\n+        if candidates.is_empty() && is_expected(Res::Def(DefKind::Enum, crate_def_id)) {\n+            let enum_candidates =\n+                self.r.lookup_import_candidates(ident, ns, is_enum_variant);\n+            let mut enum_candidates = enum_candidates.iter()\n+                .map(|suggestion| {\n+                    import_candidate_to_enum_paths(&suggestion)\n+                }).collect::<Vec<_>>();\n+            enum_candidates.sort();\n+\n+            if !enum_candidates.is_empty() {\n+                // Contextualize for E0412 \"cannot find type\", but don't belabor the point\n+                // (that it's a variant) for E0573 \"expected type, found variant\".\n+                let preamble = if res.is_none() {\n+                    let others = match enum_candidates.len() {\n+                        1 => String::new(),\n+                        2 => \" and 1 other\".to_owned(),\n+                        n => format!(\" and {} others\", n)\n+                    };\n+                    format!(\"there is an enum variant `{}`{}; \",\n+                            enum_candidates[0].0, others)\n+                } else {\n+                    String::new()\n+                };\n+                let msg = format!(\"{}try using the variant's enum\", preamble);\n+\n+                err.span_suggestions(\n+                    span,\n+                    &msg,\n+                    enum_candidates.into_iter()\n+                        .map(|(_variant_path, enum_ty_path)| enum_ty_path)\n+                        // Variants re-exported in prelude doesn't mean `prelude::v1` is the\n+                        // type name!\n+                        // FIXME: is there a more principled way to do this that\n+                        // would work for other re-exports?\n+                        .filter(|enum_ty_path| enum_ty_path != \"std::prelude::v1\")\n+                        // Also write `Option` rather than `std::prelude::v1::Option`.\n+                        .map(|enum_ty_path| {\n+                            // FIXME #56861: DRY-er prelude filtering.\n+                            enum_ty_path.trim_start_matches(\"std::prelude::v1::\").to_owned()\n+                        }),\n+                    Applicability::MachineApplicable,\n+                );\n+            }\n+        }\n+        if path.len() == 1 && self.self_type_is_available(span) {\n+            if let Some(candidate) = self.lookup_assoc_candidate(ident, ns, is_expected) {\n+                let self_is_available = self.self_value_is_available(path[0].ident.span, span);\n+                match candidate {\n+                    AssocSuggestion::Field => {\n+                        if self_is_available {\n+                            err.span_suggestion(\n+                                span,\n+                                \"you might have meant to use the available field\",\n+                                format!(\"self.{}\", path_str),\n+                                Applicability::MachineApplicable,\n+                            );\n+                        } else {\n+                            err.span_label(\n+                                span,\n+                                \"a field by this name exists in `Self`\",\n+                            );\n+                        }\n+                    }\n+                    AssocSuggestion::MethodWithSelf if self_is_available => {\n+                        err.span_suggestion(\n+                            span,\n+                            \"try\",\n+                            format!(\"self.{}\", path_str),\n+                            Applicability::MachineApplicable,\n+                        );\n+                    }\n+                    AssocSuggestion::MethodWithSelf | AssocSuggestion::AssocItem => {\n+                        err.span_suggestion(\n+                            span,\n+                            \"try\",\n+                            format!(\"Self::{}\", path_str),\n+                            Applicability::MachineApplicable,\n+                        );\n+                    }\n+                }\n+                return (err, candidates);\n+            }\n+        }\n+\n+        // Try Levenshtein algorithm.\n+        let levenshtein_worked = add_typo_suggestion(\n+            &mut err, self.lookup_typo_candidate(path, ns, is_expected, span), ident_span\n+        );\n+\n+        // Try context-dependent help if relaxed lookup didn't work.\n+        if let Some(res) = res {\n+            if self.smart_resolve_context_dependent_help(&mut err,\n+                                                         span,\n+                                                         source,\n+                                                         res,\n+                                                         &path_str,\n+                                                         &fallback_label) {\n+                return (err, candidates);\n+            }\n+        }\n+\n+        // Fallback label.\n+        if !levenshtein_worked {\n+            err.span_label(base_span, fallback_label);\n+            self.type_ascription_suggestion(&mut err, base_span);\n+        }\n+        (err, candidates)\n+    }\n+\n+    fn followed_by_brace(&self, span: Span) -> (bool, Option<(Span, String)>) {\n+        // HACK(estebank): find a better way to figure out that this was a\n+        // parser issue where a struct literal is being used on an expression\n+        // where a brace being opened means a block is being started. Look\n+        // ahead for the next text to see if `span` is followed by a `{`.\n+        let sm = self.r.session.source_map();\n+        let mut sp = span;\n+        loop {\n+            sp = sm.next_point(sp);\n+            match sm.span_to_snippet(sp) {\n+                Ok(ref snippet) => {\n+                    if snippet.chars().any(|c| { !c.is_whitespace() }) {\n+                        break;\n+                    }\n+                }\n+                _ => break,\n+            }\n+        }\n+        let followed_by_brace = match sm.span_to_snippet(sp) {\n+            Ok(ref snippet) if snippet == \"{\" => true,\n+            _ => false,\n+        };\n+        // In case this could be a struct literal that needs to be surrounded\n+        // by parenthesis, find the appropriate span.\n+        let mut i = 0;\n+        let mut closing_brace = None;\n+        loop {\n+            sp = sm.next_point(sp);\n+            match sm.span_to_snippet(sp) {\n+                Ok(ref snippet) => {\n+                    if snippet == \"}\" {\n+                        let sp = span.to(sp);\n+                        if let Ok(snippet) = sm.span_to_snippet(sp) {\n+                            closing_brace = Some((sp, snippet));\n+                        }\n+                        break;\n+                    }\n+                }\n+                _ => break,\n+            }\n+            i += 1;\n+            // The bigger the span, the more likely we're incorrect --\n+            // bound it to 100 chars long.\n+            if i > 100 {\n+                break;\n+            }\n+        }\n+        return (followed_by_brace, closing_brace)\n+    }\n+\n+    /// Provides context-dependent help for errors reported by the `smart_resolve_path_fragment`\n+    /// function.\n+    /// Returns `true` if able to provide context-dependent help.\n+    fn smart_resolve_context_dependent_help(\n+        &mut self,\n+        err: &mut DiagnosticBuilder<'a>,\n+        span: Span,\n+        source: PathSource<'_>,\n+        res: Res,\n+        path_str: &str,\n+        fallback_label: &str,\n+    ) -> bool {\n+        let ns = source.namespace();\n+        let is_expected = &|res| source.is_expected(res);\n+\n+        let path_sep = |err: &mut DiagnosticBuilder<'_>, expr: &Expr| match expr.node {\n+            ExprKind::Field(_, ident) => {\n+                err.span_suggestion(\n+                    expr.span,\n+                    \"use the path separator to refer to an item\",\n+                    format!(\"{}::{}\", path_str, ident),\n+                    Applicability::MaybeIncorrect,\n+                );\n+                true\n+            }\n+            ExprKind::MethodCall(ref segment, ..) => {\n+                let span = expr.span.with_hi(segment.ident.span.hi());\n+                err.span_suggestion(\n+                    span,\n+                    \"use the path separator to refer to an item\",\n+                    format!(\"{}::{}\", path_str, segment.ident),\n+                    Applicability::MaybeIncorrect,\n+                );\n+                true\n+            }\n+            _ => false,\n+        };\n+\n+        let mut bad_struct_syntax_suggestion = || {\n+            let (followed_by_brace, closing_brace) = self.followed_by_brace(span);\n+            let mut suggested = false;\n+            match source {\n+                PathSource::Expr(Some(parent)) => {\n+                    suggested = path_sep(err, &parent);\n+                }\n+                PathSource::Expr(None) if followed_by_brace == true => {\n+                    if let Some((sp, snippet)) = closing_brace {\n+                        err.span_suggestion(\n+                            sp,\n+                            \"surround the struct literal with parenthesis\",\n+                            format!(\"({})\", snippet),\n+                            Applicability::MaybeIncorrect,\n+                        );\n+                    } else {\n+                        err.span_label(\n+                            span,  // Note the parenthesis surrounding the suggestion below\n+                            format!(\"did you mean `({} {{ /* fields */ }})`?\", path_str),\n+                        );\n+                    }\n+                    suggested = true;\n+                },\n+                _ => {}\n+            }\n+            if !suggested {\n+                err.span_label(\n+                    span,\n+                    format!(\"did you mean `{} {{ /* fields */ }}`?\", path_str),\n+                );\n+            }\n+        };\n+\n+        match (res, source) {\n+            (Res::Def(DefKind::Macro(MacroKind::Bang), _), _) => {\n+                err.span_suggestion(\n+                    span,\n+                    \"use `!` to invoke the macro\",\n+                    format!(\"{}!\", path_str),\n+                    Applicability::MaybeIncorrect,\n+                );\n+                if path_str == \"try\" && span.rust_2015() {\n+                    err.note(\"if you want the `try` keyword, you need to be in the 2018 edition\");\n+                }\n+            }\n+            (Res::Def(DefKind::TyAlias, _), PathSource::Trait(_)) => {\n+                err.span_label(span, \"type aliases cannot be used as traits\");\n+                if nightly_options::is_nightly_build() {\n+                    err.note(\"did you mean to use a trait alias?\");\n+                }\n+            }\n+            (Res::Def(DefKind::Mod, _), PathSource::Expr(Some(parent))) => {\n+                if !path_sep(err, &parent) {\n+                    return false;\n+                }\n+            }\n+            (Res::Def(DefKind::Enum, def_id), PathSource::TupleStruct)\n+                | (Res::Def(DefKind::Enum, def_id), PathSource::Expr(..))  => {\n+                if let Some(variants) = self.collect_enum_variants(def_id) {\n+                    if !variants.is_empty() {\n+                        let msg = if variants.len() == 1 {\n+                            \"try using the enum's variant\"\n+                        } else {\n+                            \"try using one of the enum's variants\"\n+                        };\n+\n+                        err.span_suggestions(\n+                            span,\n+                            msg,\n+                            variants.iter().map(path_names_to_string),\n+                            Applicability::MaybeIncorrect,\n+                        );\n+                    }\n+                } else {\n+                    err.note(\"did you mean to use one of the enum's variants?\");\n+                }\n+            },\n+            (Res::Def(DefKind::Struct, def_id), _) if ns == ValueNS => {\n+                if let Some((ctor_def, ctor_vis))\n+                        = self.r.struct_constructors.get(&def_id).cloned() {\n+                    let accessible_ctor =\n+                        self.r.is_accessible_from(ctor_vis, self.parent_scope.module);\n+                    if is_expected(ctor_def) && !accessible_ctor {\n+                        err.span_label(\n+                            span,\n+                            format!(\"constructor is not visible here due to private fields\"),\n+                        );\n+                    }\n+                } else {\n+                    bad_struct_syntax_suggestion();\n+                }\n+            }\n+            (Res::Def(DefKind::Union, _), _) |\n+            (Res::Def(DefKind::Variant, _), _) |\n+            (Res::Def(DefKind::Ctor(_, CtorKind::Fictive), _), _) if ns == ValueNS => {\n+                bad_struct_syntax_suggestion();\n+            }\n+            (Res::SelfTy(..), _) if ns == ValueNS => {\n+                err.span_label(span, fallback_label);\n+                err.note(\"can't use `Self` as a constructor, you must use the implemented struct\");\n+            }\n+            (Res::Def(DefKind::TyAlias, _), _)\n+            | (Res::Def(DefKind::AssocTy, _), _) if ns == ValueNS => {\n+                err.note(\"can't use a type alias as a constructor\");\n+            }\n+            _ => return false,\n+        }\n+        true\n+    }\n+\n+    fn lookup_assoc_candidate<FilterFn>(&mut self,\n+                                        ident: Ident,\n+                                        ns: Namespace,\n+                                        filter_fn: FilterFn)\n+                                        -> Option<AssocSuggestion>\n+        where FilterFn: Fn(Res) -> bool\n+    {\n+        fn extract_node_id(t: &Ty) -> Option<NodeId> {\n+            match t.node {\n+                TyKind::Path(None, _) => Some(t.id),\n+                TyKind::Rptr(_, ref mut_ty) => extract_node_id(&mut_ty.ty),\n+                // This doesn't handle the remaining `Ty` variants as they are not\n+                // that commonly the self_type, it might be interesting to provide\n+                // support for those in future.\n+                _ => None,\n+            }\n+        }\n+\n+        // Fields are generally expected in the same contexts as locals.\n+        if filter_fn(Res::Local(ast::DUMMY_NODE_ID)) {\n+            if let Some(node_id) = self.current_self_type.as_ref().and_then(extract_node_id) {\n+                // Look for a field with the same name in the current self_type.\n+                if let Some(resolution) = self.r.partial_res_map.get(&node_id) {\n+                    match resolution.base_res() {\n+                        Res::Def(DefKind::Struct, did) | Res::Def(DefKind::Union, did)\n+                                if resolution.unresolved_segments() == 0 => {\n+                            if let Some(field_names) = self.r.field_names.get(&did) {\n+                                if field_names.iter().any(|&field_name| ident.name == field_name) {\n+                                    return Some(AssocSuggestion::Field);\n+                                }\n+                            }\n+                        }\n+                        _ => {}\n+                    }\n+                }\n+            }\n+        }\n+\n+        for assoc_type_ident in &self.current_trait_assoc_types {\n+            if *assoc_type_ident == ident {\n+                return Some(AssocSuggestion::AssocItem);\n+            }\n+        }\n+\n+        // Look for associated items in the current trait.\n+        if let Some((module, _)) = self.current_trait_ref {\n+            if let Ok(binding) = self.r.resolve_ident_in_module(\n+                    ModuleOrUniformRoot::Module(module),\n+                    ident,\n+                    ns,\n+                    &self.parent_scope,\n+                    false,\n+                    module.span,\n+                ) {\n+                let res = binding.res();\n+                if filter_fn(res) {\n+                    return Some(if self.r.has_self.contains(&res.def_id()) {\n+                        AssocSuggestion::MethodWithSelf\n+                    } else {\n+                        AssocSuggestion::AssocItem\n+                    });\n+                }\n+            }\n+        }\n+\n+        None\n+    }\n+\n+    fn lookup_typo_candidate(\n+        &mut self,\n+        path: &[Segment],\n+        ns: Namespace,\n+        filter_fn: &impl Fn(Res) -> bool,\n+        span: Span,\n+    ) -> Option<TypoSuggestion> {\n+        let mut names = Vec::new();\n+        if path.len() == 1 {\n+            // Search in lexical scope.\n+            // Walk backwards up the ribs in scope and collect candidates.\n+            for rib in self.ribs[ns].iter().rev() {\n+                // Locals and type parameters\n+                for (ident, &res) in &rib.bindings {\n+                    if filter_fn(res) {\n+                        names.push(TypoSuggestion::from_res(ident.name, res));\n+                    }\n+                }\n+                // Items in scope\n+                if let RibKind::ModuleRibKind(module) = rib.kind {\n+                    // Items from this module\n+                    add_module_candidates(module, &mut names, &filter_fn);\n+\n+                    if let ModuleKind::Block(..) = module.kind {\n+                        // We can see through blocks\n+                    } else {\n+                        // Items from the prelude\n+                        if !module.no_implicit_prelude {\n+                            let extern_prelude = self.r.extern_prelude.clone();\n+                            names.extend(extern_prelude.iter().flat_map(|(ident, _)| {\n+                                self.r.crate_loader\n+                                    .maybe_process_path_extern(ident.name, ident.span)\n+                                    .and_then(|crate_id| {\n+                                        let crate_mod = Res::Def(\n+                                            DefKind::Mod,\n+                                            DefId {\n+                                                krate: crate_id,\n+                                                index: CRATE_DEF_INDEX,\n+                                            },\n+                                        );\n+\n+                                        if filter_fn(crate_mod) {\n+                                            Some(TypoSuggestion::from_res(ident.name, crate_mod))\n+                                        } else {\n+                                            None\n+                                        }\n+                                    })\n+                            }));\n+\n+                            if let Some(prelude) = self.r.prelude {\n+                                add_module_candidates(prelude, &mut names, &filter_fn);\n+                            }\n+                        }\n+                        break;\n+                    }\n+                }\n+            }\n+            // Add primitive types to the mix\n+            if filter_fn(Res::PrimTy(PrimTy::Bool)) {\n+                names.extend(\n+                    self.r.primitive_type_table.primitive_types.iter().map(|(name, prim_ty)| {\n+                        TypoSuggestion::from_res(*name, Res::PrimTy(*prim_ty))\n+                    })\n+                )\n+            }\n+        } else {\n+            // Search in module.\n+            let mod_path = &path[..path.len() - 1];\n+            if let PathResult::Module(module) = self.resolve_path(\n+                mod_path, Some(TypeNS), false, span, CrateLint::No\n+            ) {\n+                if let ModuleOrUniformRoot::Module(module) = module {\n+                    add_module_candidates(module, &mut names, &filter_fn);\n+                }\n+            }\n+        }\n+\n+        let name = path[path.len() - 1].ident.name;\n+        // Make sure error reporting is deterministic.\n+        names.sort_by_cached_key(|suggestion| suggestion.candidate.as_str());\n+\n+        match find_best_match_for_name(\n+            names.iter().map(|suggestion| &suggestion.candidate),\n+            &name.as_str(),\n+            None,\n+        ) {\n+            Some(found) if found != name => names\n+                .into_iter()\n+                .find(|suggestion| suggestion.candidate == found),\n+            _ => None,\n+        }\n+    }\n+\n+    /// Only used in a specific case of type ascription suggestions\n+    fn get_colon_suggestion_span(&self, start: Span) -> Span {\n+        let cm = self.r.session.source_map();\n+        start.to(cm.next_point(start))\n+    }\n+\n+    fn type_ascription_suggestion(\n+        &self,\n+        err: &mut DiagnosticBuilder<'_>,\n+        base_span: Span,\n+    ) {\n+        debug!(\"type_ascription_suggetion {:?}\", base_span);\n+        let cm = self.r.session.source_map();\n+        let base_snippet = cm.span_to_snippet(base_span);\n+        debug!(\"self.current_type_ascription {:?}\", self.current_type_ascription);\n+        if let Some(sp) = self.current_type_ascription.last() {\n+            let mut sp = *sp;\n+            loop {\n+                // Try to find the `:`; bail on first non-':' / non-whitespace.\n+                sp = cm.next_point(sp);\n+                if let Ok(snippet) = cm.span_to_snippet(sp.to(cm.next_point(sp))) {\n+                    let line_sp = cm.lookup_char_pos(sp.hi()).line;\n+                    let line_base_sp = cm.lookup_char_pos(base_span.lo()).line;\n+                    if snippet == \":\" {\n+                        let mut show_label = true;\n+                        if line_sp != line_base_sp {\n+                            err.span_suggestion_short(\n+                                sp,\n+                                \"did you mean to use `;` here instead?\",\n+                                \";\".to_string(),\n+                                Applicability::MaybeIncorrect,\n+                            );\n+                        } else {\n+                            let colon_sp = self.get_colon_suggestion_span(sp);\n+                            let after_colon_sp = self.get_colon_suggestion_span(\n+                                colon_sp.shrink_to_hi(),\n+                            );\n+                            if !cm.span_to_snippet(after_colon_sp).map(|s| s == \" \")\n+                                .unwrap_or(false)\n+                            {\n+                                err.span_suggestion(\n+                                    colon_sp,\n+                                    \"maybe you meant to write a path separator here\",\n+                                    \"::\".to_string(),\n+                                    Applicability::MaybeIncorrect,\n+                                );\n+                                show_label = false;\n+                            }\n+                            if let Ok(base_snippet) = base_snippet {\n+                                let mut sp = after_colon_sp;\n+                                for _ in 0..100 {\n+                                    // Try to find an assignment\n+                                    sp = cm.next_point(sp);\n+                                    let snippet = cm.span_to_snippet(sp.to(cm.next_point(sp)));\n+                                    match snippet {\n+                                        Ok(ref x) if x.as_str() == \"=\" => {\n+                                            err.span_suggestion(\n+                                                base_span,\n+                                                \"maybe you meant to write an assignment here\",\n+                                                format!(\"let {}\", base_snippet),\n+                                                Applicability::MaybeIncorrect,\n+                                            );\n+                                            show_label = false;\n+                                            break;\n+                                        }\n+                                        Ok(ref x) if x.as_str() == \"\\n\" => break,\n+                                        Err(_) => break,\n+                                        Ok(_) => {}\n+                                    }\n+                                }\n+                            }\n+                        }\n+                        if show_label {\n+                            err.span_label(base_span,\n+                                           \"expecting a type here because of type ascription\");\n+                        }\n+                        break;\n+                    } else if !snippet.trim().is_empty() {\n+                        debug!(\"tried to find type ascription `:` token, couldn't find it\");\n+                        break;\n+                    }\n+                } else {\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+\n+    fn find_module(&mut self, def_id: DefId) -> Option<(Module<'a>, ImportSuggestion)> {\n+        let mut result = None;\n+        let mut seen_modules = FxHashSet::default();\n+        let mut worklist = vec![(self.r.graph_root, Vec::new())];\n+\n+        while let Some((in_module, path_segments)) = worklist.pop() {\n+            // abort if the module is already found\n+            if result.is_some() { break; }\n+\n+            self.r.populate_module_if_necessary(in_module);\n+\n+            in_module.for_each_child_stable(|ident, _, name_binding| {\n+                // abort if the module is already found or if name_binding is private external\n+                if result.is_some() || !name_binding.vis.is_visible_locally() {\n+                    return\n+                }\n+                if let Some(module) = name_binding.module() {\n+                    // form the path\n+                    let mut path_segments = path_segments.clone();\n+                    path_segments.push(ast::PathSegment::from_ident(ident));\n+                    let module_def_id = module.def_id().unwrap();\n+                    if module_def_id == def_id {\n+                        let path = Path {\n+                            span: name_binding.span,\n+                            segments: path_segments,\n+                        };\n+                        result = Some((module, ImportSuggestion { did: Some(def_id), path }));\n+                    } else {\n+                        // add the module to the lookup\n+                        if seen_modules.insert(module_def_id) {\n+                            worklist.push((module, path_segments));\n+                        }\n+                    }\n+                }\n+            });\n+        }\n+\n+        result\n+    }\n+\n+    fn collect_enum_variants(&mut self, def_id: DefId) -> Option<Vec<Path>> {\n+        self.find_module(def_id).map(|(enum_module, enum_import_suggestion)| {\n+            self.r.populate_module_if_necessary(enum_module);\n+\n+            let mut variants = Vec::new();\n+            enum_module.for_each_child_stable(|ident, _, name_binding| {\n+                if let Res::Def(DefKind::Variant, _) = name_binding.res() {\n+                    let mut segms = enum_import_suggestion.path.segments.clone();\n+                    segms.push(ast::PathSegment::from_ident(ident));\n+                    variants.push(Path {\n+                        span: name_binding.span,\n+                        segments: segms,\n+                    });\n+                }\n+            });\n+            variants\n+        })\n+    }\n+}"}, {"sha": "e786e1020026a151713eab5029f4543765642d56", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 153, "deletions": 2572, "changes": 2725, "blob_url": "https://github.com/rust-lang/rust/blob/9d76a938de25e626a7c79a76789d7885405703e6/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d76a938de25e626a7c79a76789d7885405703e6/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=9d76a938de25e626a7c79a76789d7885405703e6"}, {"sha": "5af71a0170a7bb7fcee36d41b33baa645418a655", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 32, "deletions": 107, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/9d76a938de25e626a7c79a76789d7885405703e6/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d76a938de25e626a7c79a76789d7885405703e6/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=9d76a938de25e626a7c79a76789d7885405703e6", "patch": "@@ -1,18 +1,16 @@\n use crate::{AmbiguityError, AmbiguityKind, AmbiguityErrorMisc, Determinacy};\n use crate::{CrateLint, Resolver, ResolutionError, Scope, ScopeSet, ParentScope, Weak};\n use crate::{Module, ModuleKind, NameBinding, PathResult, Segment, ToNameBinding};\n-use crate::{resolve_error, KNOWN_TOOLS};\n-use crate::ModuleOrUniformRoot;\n+use crate::{ModuleOrUniformRoot, KNOWN_TOOLS};\n use crate::Namespace::*;\n-use crate::build_reduced_graph::{BuildReducedGraphVisitor, IsMacroExport};\n+use crate::build_reduced_graph::BuildReducedGraphVisitor;\n use crate::resolve_imports::ImportResolver;\n-use rustc::hir::def_id::{DefId, CRATE_DEF_INDEX};\n use rustc::hir::def::{self, DefKind, NonMacroAttrKind};\n use rustc::hir::map::DefCollector;\n use rustc::middle::stability;\n use rustc::{ty, lint, span_bug};\n-use syntax::ast::{self, Ident, ItemKind};\n-use syntax::attr::{self, StabilityLevel};\n+use syntax::ast::{self, Ident};\n+use syntax::attr::StabilityLevel;\n use syntax::edition::Edition;\n use syntax::ext::base::{self, Indeterminate, SpecialDerives};\n use syntax::ext::base::{MacroKind, SyntaxExtension};\n@@ -116,21 +114,6 @@ fn fast_print_path(path: &ast::Path) -> Symbol {\n     }\n }\n \n-fn proc_macro_stub(item: &ast::Item) -> Option<(MacroKind, Ident, Span)> {\n-    if attr::contains_name(&item.attrs, sym::proc_macro) {\n-        return Some((MacroKind::Bang, item.ident, item.span));\n-    } else if attr::contains_name(&item.attrs, sym::proc_macro_attribute) {\n-        return Some((MacroKind::Attr, item.ident, item.span));\n-    } else if let Some(attr) = attr::find_by_name(&item.attrs, sym::proc_macro_derive) {\n-        if let Some(nested_meta) = attr.meta_item_list().and_then(|list| list.get(0).cloned()) {\n-            if let Some(ident) = nested_meta.ident() {\n-                return Some((MacroKind::Derive, ident, ident.span));\n-            }\n-        }\n-    }\n-    None\n-}\n-\n impl<'a> base::Resolver for Resolver<'a> {\n     fn next_node_id(&mut self) -> ast::NodeId {\n         self.session.next_node_id()\n@@ -166,21 +149,24 @@ impl<'a> base::Resolver for Resolver<'a> {\n         fragment.visit_with(&mut DefCollector::new(&mut self.definitions, expn_id));\n \n         let invocation = self.invocations[&expn_id];\n-        self.current_module = invocation.module;\n-        self.current_module.unresolved_invocations.borrow_mut().remove(&expn_id);\n-        self.current_module.unresolved_invocations.borrow_mut().extend(derives);\n+        invocation.module.unresolved_invocations.borrow_mut().remove(&expn_id);\n+        invocation.module.unresolved_invocations.borrow_mut().extend(derives);\n         let parent_def = self.definitions.invocation_parent(expn_id);\n         for &derive_invoc_id in derives {\n             self.definitions.set_invocation_parent(derive_invoc_id, parent_def);\n         }\n         self.invocations.extend(derives.iter().map(|&derive| (derive, invocation)));\n         let mut visitor = BuildReducedGraphVisitor {\n-            resolver: self,\n-            current_legacy_scope: invocation.parent_legacy_scope,\n-            expansion: expn_id,\n+            r: self,\n+            parent_scope: ParentScope {\n+                module: invocation.module,\n+                expansion: expn_id,\n+                legacy: invocation.parent_legacy_scope,\n+                derives: Vec::new(),\n+            },\n         };\n         fragment.visit_with(&mut visitor);\n-        invocation.output_legacy_scope.set(Some(visitor.current_legacy_scope));\n+        invocation.output_legacy_scope.set(Some(visitor.parent_scope.legacy));\n     }\n \n     fn register_builtin_macro(&mut self, ident: ast::Ident, ext: SyntaxExtension) {\n@@ -191,7 +177,7 @@ impl<'a> base::Resolver for Resolver<'a> {\n     }\n \n     fn resolve_imports(&mut self) {\n-        ImportResolver { resolver: self }.resolve_imports()\n+        ImportResolver { r: self }.resolve_imports()\n     }\n \n     fn resolve_macro_invocation(&mut self, invoc: &Invocation, invoc_id: ExpnId, force: bool)\n@@ -210,10 +196,10 @@ impl<'a> base::Resolver for Resolver<'a> {\n                 // will automatically knows about itself.\n                 let mut result = Ok(None);\n                 if derives.len() > 1 {\n-                    let parent_scope = self.invoc_parent_scope(invoc_id, Vec::new());\n+                    let parent_scope = &self.invoc_parent_scope(invoc_id, Vec::new());\n                     for path in derives {\n                         match self.resolve_macro_path(path, Some(MacroKind::Derive),\n-                                                      &parent_scope, true, force) {\n+                                                      parent_scope, true, force) {\n                             Ok((Some(ref ext), _)) if ext.is_derive_copy => {\n                                 self.add_derives(invoc.expansion_data.id, SpecialDerives::COPY);\n                                 return Ok(None);\n@@ -227,8 +213,8 @@ impl<'a> base::Resolver for Resolver<'a> {\n             }\n         };\n \n-        let parent_scope = self.invoc_parent_scope(invoc_id, derives_in_scope);\n-        let (ext, res) = self.smart_resolve_macro_path(path, kind, &parent_scope, force)?;\n+        let parent_scope = &self.invoc_parent_scope(invoc_id, derives_in_scope);\n+        let (ext, res) = self.smart_resolve_macro_path(path, kind, parent_scope, force)?;\n \n         let span = invoc.span();\n         invoc.expansion_data.id.set_expn_info(ext.expn_info(span, fast_print_path(path)));\n@@ -388,8 +374,7 @@ impl<'a> Resolver<'a> {\n             self.prohibit_imported_non_macro_attrs(None, res.ok(), path_span);\n             res\n         } else {\n-            // Macro without a specific kind restriction is equvalent to a macro import.\n-            let scope_set = kind.map_or(ScopeSet::Import(MacroNS), ScopeSet::Macro);\n+            let scope_set = kind.map_or(ScopeSet::All(MacroNS, false), ScopeSet::Macro);\n             let binding = self.early_resolve_ident_in_lexical_scope(\n                 path[0].ident, scope_set, parent_scope, false, force, path_span\n             );\n@@ -444,10 +429,9 @@ impl<'a> Resolver<'a> {\n         }\n \n         let (ns, macro_kind, is_import) = match scope_set {\n-            ScopeSet::Import(ns) => (ns, None, true),\n+            ScopeSet::All(ns, is_import) => (ns, None, is_import),\n             ScopeSet::AbsolutePath(ns) => (ns, None, false),\n             ScopeSet::Macro(macro_kind) => (MacroNS, Some(macro_kind), false),\n-            ScopeSet::Module => (TypeNS, None, false),\n         };\n \n         // This is *the* result, resolution from the scope closest to the resolved identifier.\n@@ -471,9 +455,9 @@ impl<'a> Resolver<'a> {\n                 Scope::DeriveHelpers => {\n                     let mut result = Err(Determinacy::Determined);\n                     for derive in &parent_scope.derives {\n-                        let parent_scope = ParentScope { derives: Vec::new(), ..*parent_scope };\n+                        let parent_scope = &ParentScope { derives: Vec::new(), ..*parent_scope };\n                         match this.resolve_macro_path(derive, Some(MacroKind::Derive),\n-                                                      &parent_scope, true, force) {\n+                                                      parent_scope, true, force) {\n                             Ok((Some(ext), _)) => if ext.helper_attrs.contains(&ident.name) {\n                                 let binding = (Res::NonMacroAttr(NonMacroAttrKind::DeriveHelper),\n                                                ty::Visibility::Public, derive.span, ExpnId::root())\n@@ -502,7 +486,7 @@ impl<'a> Resolver<'a> {\n                         ModuleOrUniformRoot::Module(root_module),\n                         ident,\n                         ns,\n-                        None,\n+                        parent_scope,\n                         record_used,\n                         path_span,\n                     );\n@@ -516,17 +500,16 @@ impl<'a> Resolver<'a> {\n                     }\n                 }\n                 Scope::Module(module) => {\n-                    let orig_current_module = mem::replace(&mut this.current_module, module);\n+                    let adjusted_parent_scope = &ParentScope { module, ..parent_scope.clone() };\n                     let binding = this.resolve_ident_in_module_unadjusted_ext(\n                         ModuleOrUniformRoot::Module(module),\n                         ident,\n                         ns,\n-                        None,\n+                        adjusted_parent_scope,\n                         true,\n                         record_used,\n                         path_span,\n                     );\n-                    this.current_module = orig_current_module;\n                     match binding {\n                         Ok(binding) => {\n                             let misc_flags = if ptr::eq(module, this.graph_root) {\n@@ -588,6 +571,7 @@ impl<'a> Resolver<'a> {\n                             ModuleOrUniformRoot::Module(prelude),\n                             ident,\n                             ns,\n+                            parent_scope,\n                             false,\n                             path_span,\n                         ) {\n@@ -710,9 +694,7 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n-    pub fn finalize_current_module_macro_resolutions(&mut self) {\n-        let module = self.current_module;\n-\n+    pub fn finalize_current_module_macro_resolutions(&mut self, module: Module<'a>) {\n         let check_consistency = |this: &mut Self, path: &[Segment], span, kind: MacroKind,\n                                  initial_res: Option<Res>, res: Res| {\n             if let Some(initial_res) = initial_res {\n@@ -753,8 +735,9 @@ impl<'a> Resolver<'a> {\n         for (mut path, path_span, kind, parent_scope, initial_res) in macro_resolutions {\n             // FIXME: Path resolution will ICE if segment IDs present.\n             for seg in &mut path { seg.id = None; }\n-            match self.resolve_path(&path, Some(MacroNS), &parent_scope,\n-                                    true, path_span, CrateLint::No) {\n+            match self.resolve_path(\n+                &path, Some(MacroNS), &parent_scope, true, path_span, CrateLint::No\n+            ) {\n                 PathResult::NonModule(path_res) if path_res.unresolved_segments() == 0 => {\n                     let res = path_res.base_res();\n                     check_consistency(self, &path, path_span, kind, initial_res, res);\n@@ -766,7 +749,7 @@ impl<'a> Resolver<'a> {\n                         (path_span, format!(\"partially resolved path in {} {}\",\n                                             kind.article(), kind.descr()))\n                     };\n-                    resolve_error(self, span, ResolutionError::FailedToResolve {\n+                    self.report_error(span, ResolutionError::FailedToResolve {\n                         label,\n                         suggestion: None\n                     });\n@@ -886,62 +869,4 @@ impl<'a> Resolver<'a> {\n \n         Lrc::new(result)\n     }\n-\n-    pub fn define_macro(&mut self,\n-                        item: &ast::Item,\n-                        expansion: ExpnId,\n-                        current_legacy_scope: &mut LegacyScope<'a>) {\n-        let (ext, ident, span, is_legacy) = match &item.node {\n-            ItemKind::MacroDef(def) => {\n-                let ext = self.compile_macro(item, self.session.edition());\n-                (ext, item.ident, item.span, def.legacy)\n-            }\n-            ItemKind::Fn(..) => match proc_macro_stub(item) {\n-                Some((macro_kind, ident, span)) => {\n-                    self.proc_macro_stubs.insert(item.id);\n-                    (self.dummy_ext(macro_kind), ident, span, false)\n-                }\n-                None => return,\n-            }\n-            _ => unreachable!(),\n-        };\n-\n-        let def_id = self.definitions.local_def_id(item.id);\n-        let res = Res::Def(DefKind::Macro(ext.macro_kind()), def_id);\n-        self.macro_map.insert(def_id, ext);\n-        self.local_macro_def_scopes.insert(item.id, self.current_module);\n-\n-        if is_legacy {\n-            let ident = ident.modern();\n-            self.macro_names.insert(ident);\n-            let is_macro_export = attr::contains_name(&item.attrs, sym::macro_export);\n-            let vis = if is_macro_export {\n-                ty::Visibility::Public\n-            } else {\n-                ty::Visibility::Restricted(DefId::local(CRATE_DEF_INDEX))\n-            };\n-            let binding = (res, vis, span, expansion).to_name_binding(self.arenas);\n-            self.set_binding_parent_module(binding, self.current_module);\n-            let legacy_binding = self.arenas.alloc_legacy_binding(LegacyBinding {\n-                parent_legacy_scope: *current_legacy_scope, binding, ident\n-            });\n-            *current_legacy_scope = LegacyScope::Binding(legacy_binding);\n-            self.all_macros.insert(ident.name, res);\n-            if is_macro_export {\n-                let module = self.graph_root;\n-                self.define(module, ident, MacroNS,\n-                            (res, vis, span, expansion, IsMacroExport));\n-            } else {\n-                self.check_reserved_macro_name(ident, res);\n-                self.unused_macros.insert(item.id, span);\n-            }\n-        } else {\n-            let module = self.current_module;\n-            let vis = self.resolve_visibility(&item.vis);\n-            if vis != ty::Visibility::Public {\n-                self.unused_macros.insert(item.id, span);\n-            }\n-            self.define(module, ident, MacroNS, (res, vis, span, expansion));\n-        }\n-    }\n }"}, {"sha": "00e89f0fdae0a7058a79d47425ff58c96d0dd9b9", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 89, "deletions": 142, "changes": 231, "blob_url": "https://github.com/rust-lang/rust/blob/9d76a938de25e626a7c79a76789d7885405703e6/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d76a938de25e626a7c79a76789d7885405703e6/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=9d76a938de25e626a7c79a76789d7885405703e6", "patch": "@@ -5,9 +5,8 @@ use crate::{CrateLint, Module, ModuleOrUniformRoot, PerNS, ScopeSet, ParentScope\n use crate::Determinacy::{self, *};\n use crate::Namespace::{self, TypeNS, MacroNS};\n use crate::{NameBinding, NameBindingKind, ToNameBinding, PathResult, PrivacyError};\n-use crate::{Resolver, Segment};\n+use crate::{Resolver, ResolutionError, Segment};\n use crate::{names_to_string, module_to_string};\n-use crate::{resolve_error, ResolutionError};\n use crate::ModuleKind;\n use crate::diagnostics::Suggestion;\n \n@@ -27,7 +26,7 @@ use rustc::session::DiagnosticMessageId;\n use rustc::util::nodemap::FxHashSet;\n use rustc::{bug, span_bug};\n \n-use syntax::ast::{self, Ident, Name, NodeId, CRATE_NODE_ID};\n+use syntax::ast::{Ident, Name, NodeId, CRATE_NODE_ID};\n use syntax::ext::hygiene::ExpnId;\n use syntax::symbol::kw;\n use syntax::util::lev_distance::find_best_match_for_name;\n@@ -153,10 +152,14 @@ impl<'a> NameResolution<'a> {\n                self.single_imports.is_empty() { Some(binding) } else { None }\n         })\n     }\n+\n+    crate fn add_single_import(&mut self, directive: &'a ImportDirective<'a>) {\n+        self.single_imports.insert(PtrKey(directive));\n+    }\n }\n \n impl<'a> Resolver<'a> {\n-    fn resolution(&self, module: Module<'a>, ident: Ident, ns: Namespace)\n+    crate fn resolution(&self, module: Module<'a>, ident: Ident, ns: Namespace)\n                   -> &'a RefCell<NameResolution<'a>> {\n         *module.resolutions.borrow_mut().entry((ident.modern(), ns))\n                .or_insert_with(|| self.arenas.alloc_name_resolution())\n@@ -167,11 +170,12 @@ impl<'a> Resolver<'a> {\n         module: ModuleOrUniformRoot<'a>,\n         ident: Ident,\n         ns: Namespace,\n+        parent_scope: &ParentScope<'a>,\n         record_used: bool,\n         path_span: Span,\n     ) -> Result<&'a NameBinding<'a>, Determinacy> {\n         self.resolve_ident_in_module_unadjusted_ext(\n-            module, ident, ns, None, false, record_used, path_span\n+            module, ident, ns, parent_scope, false, record_used, path_span\n         ).map_err(|(determinacy, _)| determinacy)\n     }\n \n@@ -182,7 +186,7 @@ impl<'a> Resolver<'a> {\n         module: ModuleOrUniformRoot<'a>,\n         ident: Ident,\n         ns: Namespace,\n-        parent_scope: Option<&ParentScope<'a>>,\n+        parent_scope: &ParentScope<'a>,\n         restricted_shadowing: bool,\n         record_used: bool,\n         path_span: Span,\n@@ -191,9 +195,8 @@ impl<'a> Resolver<'a> {\n             ModuleOrUniformRoot::Module(module) => module,\n             ModuleOrUniformRoot::CrateRootAndExternPrelude => {\n                 assert!(!restricted_shadowing);\n-                let parent_scope = self.dummy_parent_scope();\n                 let binding = self.early_resolve_ident_in_lexical_scope(\n-                    ident, ScopeSet::AbsolutePath(ns), &parent_scope,\n+                    ident, ScopeSet::AbsolutePath(ns), parent_scope,\n                     record_used, record_used, path_span,\n                 );\n                 return binding.map_err(|determinacy| (determinacy, Weak::No));\n@@ -213,9 +216,6 @@ impl<'a> Resolver<'a> {\n             }\n             ModuleOrUniformRoot::CurrentScope => {\n                 assert!(!restricted_shadowing);\n-                let parent_scope =\n-                    parent_scope.expect(\"no parent scope for a single-segment import\");\n-\n                 if ns == TypeNS {\n                     if ident.name == kw::Crate ||\n                         ident.name == kw::DollarCrate {\n@@ -232,8 +232,9 @@ impl<'a> Resolver<'a> {\n                     }\n                 }\n \n+                let scopes = ScopeSet::All(ns, true);\n                 let binding = self.early_resolve_ident_in_lexical_scope(\n-                    ident, ScopeSet::Import(ns), parent_scope, record_used, record_used, path_span\n+                    ident, scopes, parent_scope, record_used, record_used, path_span\n                 );\n                 return binding.map_err(|determinacy| (determinacy, Weak::No));\n             }\n@@ -261,7 +262,8 @@ impl<'a> Resolver<'a> {\n             }\n             // `extern crate` are always usable for backwards compatibility, see issue #37020,\n             // remove this together with `PUB_USE_OF_PRIVATE_EXTERN_CRATE`.\n-            let usable = this.is_accessible(binding.vis) || binding.is_extern_crate();\n+            let usable = this.is_accessible_from(binding.vis, parent_scope.module) ||\n+                         binding.is_extern_crate();\n             if usable { Ok(binding) } else { Err((Determined, Weak::No)) }\n         };\n \n@@ -299,7 +301,7 @@ impl<'a> Resolver<'a> {\n                         }\n                     }\n \n-                    if !self.is_accessible(binding.vis) &&\n+                    if !self.is_accessible_from(binding.vis, parent_scope.module) &&\n                        // Remove this together with `PUB_USE_OF_PRIVATE_EXTERN_CRATE`\n                        !(self.last_import_segment && binding.is_extern_crate()) {\n                         self.privacy_errors.push(PrivacyError(path_span, ident, binding));\n@@ -322,7 +324,7 @@ impl<'a> Resolver<'a> {\n         // Check if one of single imports can still define the name,\n         // if it can then our result is not determined and can be invalidated.\n         for single_import in &resolution.single_imports {\n-            if !self.is_accessible(single_import.vis.get()) {\n+            if !self.is_accessible_from(single_import.vis.get(), parent_scope.module) {\n                 continue;\n             }\n             let module = unwrap_or!(single_import.imported_module.get(),\n@@ -331,7 +333,7 @@ impl<'a> Resolver<'a> {\n                 SingleImport { source, .. } => source,\n                 _ => unreachable!(),\n             };\n-            match self.resolve_ident_in_module(module, ident, ns, Some(&single_import.parent_scope),\n+            match self.resolve_ident_in_module(module, ident, ns, &single_import.parent_scope,\n                                                false, path_span) {\n                 Err(Determined) => continue,\n                 Ok(binding) if !self.is_accessible_from(\n@@ -379,28 +381,33 @@ impl<'a> Resolver<'a> {\n         // Check if one of glob imports can still define the name,\n         // if it can then our \"no resolution\" result is not determined and can be invalidated.\n         for glob_import in module.globs.borrow().iter() {\n-            if !self.is_accessible(glob_import.vis.get()) {\n+            if !self.is_accessible_from(glob_import.vis.get(), parent_scope.module) {\n                 continue\n             }\n             let module = match glob_import.imported_module.get() {\n                 Some(ModuleOrUniformRoot::Module(module)) => module,\n                 Some(_) => continue,\n                 None => return Err((Undetermined, Weak::Yes)),\n             };\n-            let (orig_current_module, mut ident) = (self.current_module, ident.modern());\n+            let tmp_parent_scope;\n+            let (mut adjusted_parent_scope, mut ident) = (parent_scope, ident.modern());\n             match ident.span.glob_adjust(module.expansion, glob_import.span) {\n-                Some(Some(def)) => self.current_module = self.macro_def_scope(def),\n+                Some(Some(def)) => {\n+                    tmp_parent_scope =\n+                        ParentScope { module: self.macro_def_scope(def), ..parent_scope.clone() };\n+                    adjusted_parent_scope = &tmp_parent_scope;\n+                }\n                 Some(None) => {}\n                 None => continue,\n             };\n             let result = self.resolve_ident_in_module_unadjusted(\n                 ModuleOrUniformRoot::Module(module),\n                 ident,\n                 ns,\n+                adjusted_parent_scope,\n                 false,\n                 path_span,\n             );\n-            self.current_module = orig_current_module;\n \n             match result {\n                 Err(Determined) => continue,\n@@ -415,52 +422,6 @@ impl<'a> Resolver<'a> {\n         Err((Determined, Weak::No))\n     }\n \n-    // Add an import directive to the current module.\n-    pub fn add_import_directive(&mut self,\n-                                module_path: Vec<Segment>,\n-                                subclass: ImportDirectiveSubclass<'a>,\n-                                span: Span,\n-                                id: NodeId,\n-                                item: &ast::Item,\n-                                root_span: Span,\n-                                root_id: NodeId,\n-                                vis: ty::Visibility,\n-                                parent_scope: ParentScope<'a>) {\n-        let current_module = parent_scope.module;\n-        let directive = self.arenas.alloc_import_directive(ImportDirective {\n-            parent_scope,\n-            module_path,\n-            imported_module: Cell::new(None),\n-            subclass,\n-            span,\n-            id,\n-            use_span: item.span,\n-            use_span_with_attributes: item.span_with_attributes(),\n-            has_attributes: !item.attrs.is_empty(),\n-            root_span,\n-            root_id,\n-            vis: Cell::new(vis),\n-            used: Cell::new(false),\n-        });\n-\n-        debug!(\"add_import_directive({:?})\", directive);\n-\n-        self.indeterminate_imports.push(directive);\n-        match directive.subclass {\n-            SingleImport { target, type_ns_only, .. } => {\n-                self.per_ns(|this, ns| if !type_ns_only || ns == TypeNS {\n-                    let mut resolution = this.resolution(current_module, target, ns).borrow_mut();\n-                    resolution.single_imports.insert(PtrKey(directive));\n-                });\n-            }\n-            // We don't add prelude imports to the globs since they only affect lexical scopes,\n-            // which are not relevant to import resolution.\n-            GlobImport { is_prelude: true, .. } => {}\n-            GlobImport { .. } => current_module.globs.borrow_mut().push(directive),\n-            _ => unreachable!(),\n-        }\n-    }\n-\n     // Given a binding and an import directive that resolves to it,\n     // return the corresponding binding defined by the import directive.\n     crate fn import(&self, binding: &'a NameBinding<'a>, directive: &'a ImportDirective<'a>)\n@@ -635,25 +596,12 @@ struct UnresolvedImportError {\n }\n \n pub struct ImportResolver<'a, 'b> {\n-    pub resolver: &'a mut Resolver<'b>,\n-}\n-\n-impl<'a, 'b> std::ops::Deref for ImportResolver<'a, 'b> {\n-    type Target = Resolver<'b>;\n-    fn deref(&self) -> &Resolver<'b> {\n-        self.resolver\n-    }\n-}\n-\n-impl<'a, 'b> std::ops::DerefMut for ImportResolver<'a, 'b> {\n-    fn deref_mut(&mut self) -> &mut Resolver<'b> {\n-        self.resolver\n-    }\n+    pub r: &'a mut Resolver<'b>,\n }\n \n impl<'a, 'b> ty::DefIdTree for &'a ImportResolver<'a, 'b> {\n     fn parent(self, id: DefId) -> Option<DefId> {\n-        self.resolver.parent(id)\n+        self.r.parent(id)\n     }\n }\n \n@@ -669,29 +617,29 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n     /// Resolves all imports for the crate. This method performs the fixed-\n     /// point iteration.\n     pub fn resolve_imports(&mut self) {\n-        let mut prev_num_indeterminates = self.indeterminate_imports.len() + 1;\n-        while self.indeterminate_imports.len() < prev_num_indeterminates {\n-            prev_num_indeterminates = self.indeterminate_imports.len();\n-            for import in mem::take(&mut self.indeterminate_imports) {\n+        let mut prev_num_indeterminates = self.r.indeterminate_imports.len() + 1;\n+        while self.r.indeterminate_imports.len() < prev_num_indeterminates {\n+            prev_num_indeterminates = self.r.indeterminate_imports.len();\n+            for import in mem::take(&mut self.r.indeterminate_imports) {\n                 match self.resolve_import(&import) {\n-                    true => self.determined_imports.push(import),\n-                    false => self.indeterminate_imports.push(import),\n+                    true => self.r.determined_imports.push(import),\n+                    false => self.r.indeterminate_imports.push(import),\n                 }\n             }\n         }\n     }\n \n     pub fn finalize_imports(&mut self) {\n-        for module in self.arenas.local_modules().iter() {\n+        for module in self.r.arenas.local_modules().iter() {\n             self.finalize_resolutions_in(module);\n         }\n \n         let mut has_errors = false;\n         let mut seen_spans = FxHashSet::default();\n         let mut errors = vec![];\n         let mut prev_root_id: NodeId = NodeId::from_u32(0);\n-        for i in 0 .. self.determined_imports.len() {\n-            let import = self.determined_imports[i];\n+        for i in 0 .. self.r.determined_imports.len() {\n+            let import = self.r.determined_imports[i];\n             if let Some(err) = self.finalize_import(import) {\n                 has_errors = true;\n \n@@ -706,7 +654,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n \n                 // If the error is a single failed import then create a \"fake\" import\n                 // resolution for it so that later resolve stages won't complain.\n-                self.import_dummy_binding(import);\n+                self.r.import_dummy_binding(import);\n                 if prev_root_id.as_u32() != 0\n                         && prev_root_id.as_u32() != import.root_id.as_u32()\n                         && !errors.is_empty() {\n@@ -735,7 +683,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n         // Report unresolved imports only if no hard error was already reported\n         // to avoid generating multiple errors on the same import.\n         if !has_errors {\n-            for import in &self.indeterminate_imports {\n+            for import in &self.r.indeterminate_imports {\n                 self.throw_unresolved_import_error(errors, Some(MultiSpan::from(import.span)));\n                 break;\n             }\n@@ -774,7 +722,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n             (span, msg)\n         };\n \n-        let mut diag = struct_span_err!(self.resolver.session, span, E0432, \"{}\", &msg);\n+        let mut diag = struct_span_err!(self.r.session, span, E0432, \"{}\", &msg);\n \n         if let Some((_, UnresolvedImportError { note, .. })) = errors.iter().last() {\n             for message in note {\n@@ -798,19 +746,19 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n     /// Attempts to resolve the given import, returning true if its resolution is determined.\n     /// If successful, the resolved bindings are written into the module.\n     fn resolve_import(&mut self, directive: &'b ImportDirective<'b>) -> bool {\n-        debug!(\"(resolving import for module) resolving import `{}::...` in `{}`\",\n-               Segment::names_to_string(&directive.module_path),\n-               module_to_string(self.current_module).unwrap_or_else(|| \"???\".to_string()));\n-\n-        self.current_module = directive.parent_scope.module;\n+        debug!(\n+            \"(resolving import for module) resolving import `{}::...` in `{}`\",\n+            Segment::names_to_string(&directive.module_path),\n+            module_to_string(directive.parent_scope.module).unwrap_or_else(|| \"???\".to_string()),\n+        );\n \n         let module = if let Some(module) = directive.imported_module.get() {\n             module\n         } else {\n             // For better failure detection, pretend that the import will\n             // not define any names while resolving its module path.\n             let orig_vis = directive.vis.replace(ty::Visibility::Invisible);\n-            let path_res = self.resolve_path(\n+            let path_res = self.r.resolve_path(\n                 &directive.module_path,\n                 None,\n                 &directive.parent_scope,\n@@ -841,13 +789,13 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n         };\n \n         let mut indeterminate = false;\n-        self.per_ns(|this, ns| if !type_ns_only || ns == TypeNS {\n+        self.r.per_ns(|this, ns| if !type_ns_only || ns == TypeNS {\n             if let Err(Undetermined) = source_bindings[ns].get() {\n                 // For better failure detection, pretend that the import will\n                 // not define any names while resolving its module path.\n                 let orig_vis = directive.vis.replace(ty::Visibility::Invisible);\n                 let binding = this.resolve_ident_in_module(\n-                    module, source, ns, Some(&directive.parent_scope), false, directive.span\n+                    module, source, ns, &directive.parent_scope, false, directive.span\n                 );\n                 directive.vis.set(orig_vis);\n \n@@ -892,13 +840,11 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n         &mut self,\n         directive: &'b ImportDirective<'b>\n     ) -> Option<UnresolvedImportError> {\n-        self.current_module = directive.parent_scope.module;\n-\n         let orig_vis = directive.vis.replace(ty::Visibility::Invisible);\n-        let prev_ambiguity_errors_len = self.ambiguity_errors.len();\n-        let path_res = self.resolve_path(&directive.module_path, None, &directive.parent_scope,\n+        let prev_ambiguity_errors_len = self.r.ambiguity_errors.len();\n+        let path_res = self.r.resolve_path(&directive.module_path, None, &directive.parent_scope,\n                                          true, directive.span, directive.crate_lint());\n-        let no_ambiguity = self.ambiguity_errors.len() == prev_ambiguity_errors_len;\n+        let no_ambiguity = self.r.ambiguity_errors.len() == prev_ambiguity_errors_len;\n         directive.vis.set(orig_vis);\n         let module = match path_res {\n             PathResult::Module(module) => {\n@@ -908,10 +854,10 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                         span_bug!(directive.span, \"inconsistent resolution for an import\");\n                     }\n                 } else {\n-                    if self.privacy_errors.is_empty() {\n+                    if self.r.privacy_errors.is_empty() {\n                         let msg = \"cannot determine resolution for the import\";\n                         let msg_note = \"import resolution is stuck, try simplifying other imports\";\n-                        self.session.struct_span_err(directive.span, msg).note(msg_note).emit();\n+                        self.r.session.struct_span_err(directive.span, msg).note(msg_note).emit();\n                     }\n                 }\n \n@@ -920,7 +866,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n             PathResult::Failed { is_error_from_last_segment: false, span, label, suggestion } => {\n                 if no_ambiguity {\n                     assert!(directive.imported_module.get().is_none());\n-                    resolve_error(self, span, ResolutionError::FailedToResolve {\n+                    self.r.report_error(span, ResolutionError::FailedToResolve {\n                         label,\n                         suggestion,\n                     });\n@@ -982,7 +928,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                     // 2 segments, so the `resolve_path` above won't trigger it.\n                     let mut full_path = directive.module_path.clone();\n                     full_path.push(Segment::from_ident(Ident::invalid()));\n-                    self.lint_if_path_starts_with_module(\n+                    self.r.lint_if_path_starts_with_module(\n                         directive.crate_lint(),\n                         &full_path,\n                         directive.span,\n@@ -1005,21 +951,21 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                    max_vis.get() != ty::Visibility::Invisible && // Allow empty globs.\n                    !max_vis.get().is_at_least(directive.vis.get(), &*self) {\n                     let msg = \"A non-empty glob must import something with the glob's visibility\";\n-                    self.session.span_err(directive.span, msg);\n+                    self.r.session.span_err(directive.span, msg);\n                 }\n                 return None;\n             }\n             _ => unreachable!(),\n         };\n \n         let mut all_ns_err = true;\n-        self.per_ns(|this, ns| if !type_ns_only || ns == TypeNS {\n+        self.r.per_ns(|this, ns| if !type_ns_only || ns == TypeNS {\n             let orig_vis = directive.vis.replace(ty::Visibility::Invisible);\n             let orig_blacklisted_binding =\n                 mem::replace(&mut this.blacklisted_binding, target_bindings[ns].get());\n             let orig_last_import_segment = mem::replace(&mut this.last_import_segment, true);\n             let binding = this.resolve_ident_in_module(\n-                module, ident, ns, Some(&directive.parent_scope), true, directive.span\n+                module, ident, ns, &directive.parent_scope, true, directive.span\n             );\n             this.last_import_segment = orig_last_import_segment;\n             this.blacklisted_binding = orig_blacklisted_binding;\n@@ -1068,9 +1014,9 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n \n         if all_ns_err {\n             let mut all_ns_failed = true;\n-            self.per_ns(|this, ns| if !type_ns_only || ns == TypeNS {\n+            self.r.per_ns(|this, ns| if !type_ns_only || ns == TypeNS {\n                 let binding = this.resolve_ident_in_module(\n-                    module, ident, ns, Some(&directive.parent_scope), true, directive.span\n+                    module, ident, ns, &directive.parent_scope, true, directive.span\n                 );\n                 if binding.is_ok() {\n                     all_ns_failed = false;\n@@ -1147,14 +1093,14 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                 })\n             } else {\n                 // `resolve_ident_in_module` reported a privacy error.\n-                self.import_dummy_binding(directive);\n+                self.r.import_dummy_binding(directive);\n                 None\n             }\n         }\n \n         let mut reexport_error = None;\n         let mut any_successful_reexport = false;\n-        self.per_ns(|this, ns| {\n+        self.r.per_ns(|this, ns| {\n             if let Ok(binding) = source_bindings[ns].get() {\n                 let vis = directive.vis.get();\n                 if !binding.pseudo_vis().is_at_least(vis, &*this) {\n@@ -1173,12 +1119,12 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                                    re-exported (error E0365), consider declaring with \\\n                                    `pub`\",\n                                    ident);\n-                self.session.buffer_lint(PUB_USE_OF_PRIVATE_EXTERN_CRATE,\n+                self.r.session.buffer_lint(PUB_USE_OF_PRIVATE_EXTERN_CRATE,\n                                          directive.id,\n                                          directive.span,\n                                          &msg);\n             } else if ns == TypeNS {\n-                struct_span_err!(self.session, directive.span, E0365,\n+                struct_span_err!(self.r.session, directive.span, E0365,\n                                  \"`{}` is private, and cannot be re-exported\", ident)\n                     .span_label(directive.span, format!(\"re-export of private `{}`\", ident))\n                     .note(&format!(\"consider declaring type or module `{}` with `pub`\", ident))\n@@ -1187,7 +1133,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                 let msg = format!(\"`{}` is private, and cannot be re-exported\", ident);\n                 let note_msg =\n                     format!(\"consider marking `{}` as `pub` in the imported module\", ident);\n-                struct_span_err!(self.session, directive.span, E0364, \"{}\", &msg)\n+                struct_span_err!(self.r.session, directive.span, E0364, \"{}\", &msg)\n                     .span_note(directive.span, &note_msg)\n                     .emit();\n             }\n@@ -1198,7 +1144,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n             // 2 segments, so the `resolve_path` above won't trigger it.\n             let mut full_path = directive.module_path.clone();\n             full_path.push(Segment::from_ident(ident));\n-            self.per_ns(|this, ns| {\n+            self.r.per_ns(|this, ns| {\n                 if let Ok(binding) = source_bindings[ns].get() {\n                     this.lint_if_path_starts_with_module(\n                         directive.crate_lint(),\n@@ -1213,7 +1159,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n         // Record what this import resolves to for later uses in documentation,\n         // this may resolve to either a value or a type, but for documentation\n         // purposes it's good enough to just favor one over the other.\n-        self.per_ns(|this, ns| if let Some(binding) = source_bindings[ns].get().ok() {\n+        self.r.per_ns(|this, ns| if let Some(binding) = source_bindings[ns].get().ok() {\n             this.import_res_map.entry(directive.id).or_default()[ns] = Some(binding.res());\n         });\n \n@@ -1260,7 +1206,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n             macro_ns: None,\n         };\n \n-        self.per_ns(|this, ns| if let Some(binding) = source_bindings[ns].get().ok() {\n+        self.r.per_ns(|this, ns| if let Some(binding) = source_bindings[ns].get().ok() {\n             if binding.res() == Res::Err {\n                 return;\n             }\n@@ -1272,7 +1218,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n \n             match this.early_resolve_ident_in_lexical_scope(\n                 target,\n-                ScopeSet::Import(ns),\n+                ScopeSet::All(ns, false),\n                 &directive.parent_scope,\n                 false,\n                 false,\n@@ -1298,7 +1244,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n             let mut redundant_spans: Vec<_> = redundant_span.present_items().collect();\n             redundant_spans.sort();\n             redundant_spans.dedup();\n-            self.session.buffer_lint_with_diagnostic(\n+            self.r.session.buffer_lint_with_diagnostic(\n                 UNUSED_IMPORTS,\n                 directive.id,\n                 directive.span,\n@@ -1312,20 +1258,20 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n         let module = match directive.imported_module.get().unwrap() {\n             ModuleOrUniformRoot::Module(module) => module,\n             _ => {\n-                self.session.span_err(directive.span, \"cannot glob-import all possible crates\");\n+                self.r.session.span_err(directive.span, \"cannot glob-import all possible crates\");\n                 return;\n             }\n         };\n \n-        self.populate_module_if_necessary(module);\n+        self.r.populate_module_if_necessary(module);\n \n         if module.is_trait() {\n-            self.session.span_err(directive.span, \"items in traits are not importable.\");\n+            self.r.session.span_err(directive.span, \"items in traits are not importable.\");\n             return;\n         } else if module.def_id() == directive.parent_scope.module.def_id()  {\n             return;\n         } else if let GlobImport { is_prelude: true, .. } = directive.subclass {\n-            self.prelude = Some(module);\n+            self.r.prelude = Some(module);\n             return;\n         }\n \n@@ -1339,18 +1285,19 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n         }).collect::<Vec<_>>();\n         for ((mut ident, ns), binding) in bindings {\n             let scope = match ident.span.reverse_glob_adjust(module.expansion, directive.span) {\n-                Some(Some(def)) => self.macro_def_scope(def),\n-                Some(None) => self.current_module,\n+                Some(Some(def)) => self.r.macro_def_scope(def),\n+                Some(None) => directive.parent_scope.module,\n                 None => continue,\n             };\n-            if self.is_accessible_from(binding.pseudo_vis(), scope) {\n-                let imported_binding = self.import(binding, directive);\n-                let _ = self.try_define(directive.parent_scope.module, ident, ns, imported_binding);\n+            if self.r.is_accessible_from(binding.pseudo_vis(), scope) {\n+                let imported_binding = self.r.import(binding, directive);\n+                let _ =\n+                    self.r.try_define(directive.parent_scope.module, ident, ns, imported_binding);\n             }\n         }\n \n         // Record the destination of this import\n-        self.record_partial_res(directive.id, PartialRes::new(module.res().unwrap()));\n+        self.r.record_partial_res(directive.id, PartialRes::new(module.res().unwrap()));\n     }\n \n     // Miscellaneous post-processing, including recording re-exports,\n@@ -1379,7 +1326,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                 if res != Res::Err {\n                     if let Some(def_id) = res.opt_def_id() {\n                         if !def_id.is_local() {\n-                            self.cstore.export_macros_untracked(def_id.krate);\n+                            self.r.cstore.export_macros_untracked(def_id.krate);\n                         }\n                     }\n                     reexports.push(Export {\n@@ -1405,7 +1352,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                                 let error_id = (DiagnosticMessageId::ErrorId(0), // no code?!\n                                                 Some(binding.span),\n                                                 msg.clone());\n-                                let fresh = self.session.one_time_diagnostics\n+                                let fresh = self.r.session.one_time_diagnostics\n                                     .borrow_mut().insert(error_id);\n                                 if !fresh {\n                                     continue;\n@@ -1414,7 +1361,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                             },\n                             ref s @ _ => bug!(\"unexpected import subclass {:?}\", s)\n                         };\n-                        let mut err = self.session.struct_span_err(binding.span, &msg);\n+                        let mut err = self.r.session.struct_span_err(binding.span, &msg);\n \n                         let imported_module = match directive.imported_module.get() {\n                             Some(ModuleOrUniformRoot::Module(module)) => module,\n@@ -1430,16 +1377,16 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                         let enum_span = enum_resolution.borrow()\n                             .binding.expect(\"binding should exist\")\n                             .span;\n-                        let enum_def_span = self.session.source_map().def_span(enum_span);\n-                        let enum_def_snippet = self.session.source_map()\n+                        let enum_def_span = self.r.session.source_map().def_span(enum_span);\n+                        let enum_def_snippet = self.r.session.source_map()\n                             .span_to_snippet(enum_def_span).expect(\"snippet should exist\");\n                         // potentially need to strip extant `crate`/`pub(path)` for suggestion\n                         let after_vis_index = enum_def_snippet.find(\"enum\")\n                             .expect(\"`enum` keyword should exist in snippet\");\n                         let suggestion = format!(\"pub {}\",\n                                                  &enum_def_snippet[after_vis_index..]);\n \n-                        self.session\n+                        self.r.session\n                             .diag_span_suggestion_once(&mut err,\n                                                        DiagnosticMessageId::ErrorId(0),\n                                                        enum_def_span,\n@@ -1452,7 +1399,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n \n         if reexports.len() > 0 {\n             if let Some(def_id) = module.def_id() {\n-                self.export_map.insert(def_id, reexports);\n+                self.r.export_map.insert(def_id, reexports);\n             }\n         }\n     }"}, {"sha": "5c9fac7eab42175ac66f8cfa7c385f222098c22d", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/9d76a938de25e626a7c79a76789d7885405703e6/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d76a938de25e626a7c79a76789d7885405703e6/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=9d76a938de25e626a7c79a76789d7885405703e6", "patch": "@@ -61,15 +61,11 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n     {\n         let cx = self.cx;\n \n-        // In case we're in a module, try to resolve the relative\n-        // path.\n-        if let Some(id) = parent_id.or(self.mod_ids.last().cloned()) {\n-            // FIXME: `with_scope` requires the `NodeId` of a module.\n-            let node_id = cx.tcx.hir().hir_to_node_id(id);\n+        // In case we're in a module, try to resolve the relative path.\n+        if let Some(module_id) = parent_id.or(self.mod_ids.last().cloned()) {\n+            let module_id = cx.tcx.hir().hir_to_node_id(module_id);\n             let result = cx.enter_resolver(|resolver| {\n-                resolver.with_scope(node_id, |resolver| {\n-                    resolver.resolve_str_path_error(DUMMY_SP, &path_str, ns == ValueNS)\n-                })\n+                resolver.resolve_str_path_error(DUMMY_SP, &path_str, ns, module_id)\n             });\n             let result = match result {\n                 Ok((_, Res::Err)) => Err(()),\n@@ -85,6 +81,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                     Res::Def(DefKind::AssocTy, _) => false,\n                     Res::Def(DefKind::Variant, _) => return handle_variant(cx, res),\n                     // Not a trait item; just return what we found.\n+                    Res::PrimTy(..) => return Ok((res, Some(path_str.to_owned()))),\n                     _ => return Ok((res, None))\n                 };\n \n@@ -133,11 +130,9 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                     .ok_or(());\n             }\n \n-            // FIXME: `with_scope` requires the `NodeId` of a module.\n-            let node_id = cx.tcx.hir().hir_to_node_id(id);\n-            let (_, ty_res) = cx.enter_resolver(|resolver| resolver.with_scope(node_id, |resolver| {\n-                    resolver.resolve_str_path_error(DUMMY_SP, &path, false)\n-            }))?;\n+            let (_, ty_res) = cx.enter_resolver(|resolver| {\n+                resolver.resolve_str_path_error(DUMMY_SP, &path, TypeNS, module_id)\n+            })?;\n             if let Res::Err = ty_res {\n                 return Err(());\n             }"}, {"sha": "58fc74d65a54a0bc191f9407d7c2ca45f5d8997d", "filename": "src/test/ui/hygiene/privacy-early.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/9d76a938de25e626a7c79a76789d7885405703e6/src%2Ftest%2Fui%2Fhygiene%2Fprivacy-early.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d76a938de25e626a7c79a76789d7885405703e6/src%2Ftest%2Fui%2Fhygiene%2Fprivacy-early.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fprivacy-early.rs?ref=9d76a938de25e626a7c79a76789d7885405703e6", "patch": "@@ -0,0 +1,17 @@\n+// edition:2018\n+\n+#![feature(decl_macro)]\n+\n+mod foo {\n+    fn f() {}\n+    macro f() {}\n+\n+    pub macro m() {\n+        use f as g; //~ ERROR `f` is private, and cannot be re-exported\n+        f!();\n+    }\n+}\n+\n+fn main() {\n+    foo::m!();\n+}"}, {"sha": "60e50e05fc30ec9b44fea92e82c4cc463678ca19", "filename": "src/test/ui/hygiene/privacy-early.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/9d76a938de25e626a7c79a76789d7885405703e6/src%2Ftest%2Fui%2Fhygiene%2Fprivacy-early.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9d76a938de25e626a7c79a76789d7885405703e6/src%2Ftest%2Fui%2Fhygiene%2Fprivacy-early.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fprivacy-early.stderr?ref=9d76a938de25e626a7c79a76789d7885405703e6", "patch": "@@ -0,0 +1,21 @@\n+error[E0364]: `f` is private, and cannot be re-exported\n+  --> $DIR/privacy-early.rs:10:13\n+   |\n+LL |         use f as g;\n+   |             ^^^^^^\n+...\n+LL |     foo::m!();\n+   |     ---------- in this macro invocation\n+   |\n+note: consider marking `f` as `pub` in the imported module\n+  --> $DIR/privacy-early.rs:10:13\n+   |\n+LL |         use f as g;\n+   |             ^^^^^^\n+...\n+LL |     foo::m!();\n+   |     ---------- in this macro invocation\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0364`."}, {"sha": "877940c74037bbf7bad004a631591235a4ffd987", "filename": "src/test/ui/impl-trait/multiple-lifetimes/ordinary-bounds-pick-original-type-alias-impl-trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d76a938de25e626a7c79a76789d7885405703e6/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-pick-original-type-alias-impl-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d76a938de25e626a7c79a76789d7885405703e6/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-pick-original-type-alias-impl-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-pick-original-type-alias-impl-trait.rs?ref=9d76a938de25e626a7c79a76789d7885405703e6", "patch": "@@ -1,5 +1,5 @@\n // edition:2018\n-// build-pass (FIXME(62277): could be check-pass?)\n+// check-pass\n // revisions: migrate mir\n //[mir]compile-flags: -Z borrowck=mir\n "}, {"sha": "7d48bb97b106e045a0cd322fddac2a381606a200", "filename": "src/test/ui/resolve/resolve-bad-visibility.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9d76a938de25e626a7c79a76789d7885405703e6/src%2Ftest%2Fui%2Fresolve%2Fresolve-bad-visibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d76a938de25e626a7c79a76789d7885405703e6/src%2Ftest%2Fui%2Fresolve%2Fresolve-bad-visibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fresolve-bad-visibility.rs?ref=9d76a938de25e626a7c79a76789d7885405703e6", "patch": "@@ -4,8 +4,8 @@ trait Tr {}\n pub(in E) struct S; //~ ERROR expected module, found enum `E`\n pub(in Tr) struct Z; //~ ERROR expected module, found trait `Tr`\n pub(in std::vec) struct F; //~ ERROR visibilities can only be restricted to ancestor modules\n-pub(in nonexistent) struct G; //~ ERROR cannot find module `nonexistent` in the crate root\n-pub(in too_soon) struct H; //~ ERROR cannot find module `too_soon` in the crate root\n+pub(in nonexistent) struct G; //~ ERROR failed to resolve\n+pub(in too_soon) struct H; //~ ERROR failed to resolve\n \n // Visibilities are resolved eagerly without waiting for modules becoming fully populated.\n // Visibilities can only use ancestor modules legally which are always available in time,"}, {"sha": "d2fb7c7a9e69d47ee5b77be962d0c35816aa4e43", "filename": "src/test/ui/resolve/resolve-bad-visibility.stderr", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/9d76a938de25e626a7c79a76789d7885405703e6/src%2Ftest%2Fui%2Fresolve%2Fresolve-bad-visibility.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9d76a938de25e626a7c79a76789d7885405703e6/src%2Ftest%2Fui%2Fresolve%2Fresolve-bad-visibility.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fresolve-bad-visibility.stderr?ref=9d76a938de25e626a7c79a76789d7885405703e6", "patch": "@@ -1,9 +1,3 @@\n-error: visibilities can only be restricted to ancestor modules\n-  --> $DIR/resolve-bad-visibility.rs:6:8\n-   |\n-LL | pub(in std::vec) struct F;\n-   |        ^^^^^^^^\n-\n error[E0577]: expected module, found enum `E`\n   --> $DIR/resolve-bad-visibility.rs:4:8\n    |\n@@ -16,17 +10,24 @@ error[E0577]: expected module, found trait `Tr`\n LL | pub(in Tr) struct Z;\n    |        ^^ not a module\n \n-error[E0578]: cannot find module `nonexistent` in the crate root\n+error: visibilities can only be restricted to ancestor modules\n+  --> $DIR/resolve-bad-visibility.rs:6:8\n+   |\n+LL | pub(in std::vec) struct F;\n+   |        ^^^^^^^^\n+\n+error[E0433]: failed to resolve: maybe a missing crate `nonexistent`?\n   --> $DIR/resolve-bad-visibility.rs:7:8\n    |\n LL | pub(in nonexistent) struct G;\n-   |        ^^^^^^^^^^^ not found in the crate root\n+   |        ^^^^^^^^^^^ maybe a missing crate `nonexistent`?\n \n-error[E0578]: cannot find module `too_soon` in the crate root\n+error[E0433]: failed to resolve: maybe a missing crate `too_soon`?\n   --> $DIR/resolve-bad-visibility.rs:8:8\n    |\n LL | pub(in too_soon) struct H;\n-   |        ^^^^^^^^ not found in the crate root\n+   |        ^^^^^^^^ maybe a missing crate `too_soon`?\n \n error: aborting due to 5 previous errors\n \n+For more information about this error, try `rustc --explain E0433`."}, {"sha": "595eaf440c9f45c8e419fff05ec14cdd9b35346c", "filename": "src/test/ui/resolve/visibility-indeterminate.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9d76a938de25e626a7c79a76789d7885405703e6/src%2Ftest%2Fui%2Fresolve%2Fvisibility-indeterminate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d76a938de25e626a7c79a76789d7885405703e6/src%2Ftest%2Fui%2Fresolve%2Fvisibility-indeterminate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fvisibility-indeterminate.rs?ref=9d76a938de25e626a7c79a76789d7885405703e6", "patch": "@@ -0,0 +1,5 @@\n+// edition:2018\n+\n+foo!(); //~ ERROR cannot find macro `foo!` in this scope\n+\n+pub(in ::bar) struct Baz {} //~ ERROR cannot determine resolution for the visibility"}, {"sha": "a259c8090b35d1336dfb310cc7460c032a80b9b8", "filename": "src/test/ui/resolve/visibility-indeterminate.stderr", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/9d76a938de25e626a7c79a76789d7885405703e6/src%2Ftest%2Fui%2Fresolve%2Fvisibility-indeterminate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9d76a938de25e626a7c79a76789d7885405703e6/src%2Ftest%2Fui%2Fresolve%2Fvisibility-indeterminate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fvisibility-indeterminate.stderr?ref=9d76a938de25e626a7c79a76789d7885405703e6", "patch": "@@ -0,0 +1,19 @@\n+error[E0578]: cannot determine resolution for the visibility\n+  --> $DIR/visibility-indeterminate.rs:5:8\n+   |\n+LL | pub(in ::bar) struct Baz {}\n+   |        ^^^^^\n+\n+error: cannot find macro `foo!` in this scope\n+  --> $DIR/visibility-indeterminate.rs:3:1\n+   |\n+LL | foo!();\n+   | ^^^\n+\n+error[E0601]: `main` function not found in crate `visibility_indeterminate`\n+   |\n+   = note: consider adding a `main` function to `$DIR/visibility-indeterminate.rs`\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0601`."}, {"sha": "c2f0711b0c8665295105b31ab2a187787762b504", "filename": "src/test/ui/span/visibility-ty-params.stderr", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9d76a938de25e626a7c79a76789d7885405703e6/src%2Ftest%2Fui%2Fspan%2Fvisibility-ty-params.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9d76a938de25e626a7c79a76789d7885405703e6/src%2Ftest%2Fui%2Fspan%2Fvisibility-ty-params.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fvisibility-ty-params.stderr?ref=9d76a938de25e626a7c79a76789d7885405703e6", "patch": "@@ -4,19 +4,17 @@ error: unexpected generic arguments in path\n LL | m!{ S<u8> }\n    |     ^^^^^\n \n+error[E0577]: expected module, found struct `S`\n+  --> $DIR/visibility-ty-params.rs:6:5\n+   |\n+LL | m!{ S<u8> }\n+   |     ^^^^^ not a module\n+\n error: unexpected generic arguments in path\n   --> $DIR/visibility-ty-params.rs:10:9\n    |\n LL |     m!{ m<> }\n    |         ^^^\n \n-error[E0577]: expected module, found struct `S`\n-  --> $DIR/visibility-ty-params.rs:6:5\n-   |\n-LL | m!{ S<u8> }\n-   |     -^^^^\n-   |     |\n-   |     help: a module with a similar name exists: `m`\n-\n error: aborting due to 3 previous errors\n "}]}