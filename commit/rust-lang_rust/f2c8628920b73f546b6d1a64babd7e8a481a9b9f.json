{"sha": "f2c8628920b73f546b6d1a64babd7e8a481a9b9f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYyYzg2Mjg5MjBiNzNmNTQ2YjZkMWE2NGJhYmQ3ZThhNDgxYTliOWY=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-10-21T18:18:12Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-10-25T22:45:54Z"}, "message": "rustc_mir: use the new validator's Qualif in promotion.", "tree": {"sha": "a4a54106942e06c1b0bf59f3eadfb1babedb2c34", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a4a54106942e06c1b0bf59f3eadfb1babedb2c34"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f2c8628920b73f546b6d1a64babd7e8a481a9b9f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f2c8628920b73f546b6d1a64babd7e8a481a9b9f", "html_url": "https://github.com/rust-lang/rust/commit/f2c8628920b73f546b6d1a64babd7e8a481a9b9f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f2c8628920b73f546b6d1a64babd7e8a481a9b9f/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6c55fb8227423c9d22585711efc7666675a898f2", "url": "https://api.github.com/repos/rust-lang/rust/commits/6c55fb8227423c9d22585711efc7666675a898f2", "html_url": "https://github.com/rust-lang/rust/commit/6c55fb8227423c9d22585711efc7666675a898f2"}], "stats": {"total": 169, "additions": 120, "deletions": 49}, "files": [{"sha": "0c643f462432ebbf41cb8348981077e7bd87f42b", "filename": "src/librustc_mir/transform/check_consts/mod.rs", "status": "modified", "additions": 24, "deletions": 1, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/f2c8628920b73f546b6d1a64babd7e8a481a9b9f/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2c8628920b73f546b6d1a64babd7e8a481a9b9f/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fmod.rs?ref=f2c8628920b73f546b6d1a64babd7e8a481a9b9f", "patch": "@@ -11,7 +11,7 @@ use rustc::ty::{self, TyCtxt};\n pub use self::qualifs::Qualif;\n \n pub mod ops;\n-mod qualifs;\n+pub mod qualifs;\n mod resolver;\n pub mod validation;\n \n@@ -23,6 +23,7 @@ pub struct Item<'mir, 'tcx> {\n     def_id: DefId,\n     param_env: ty::ParamEnv<'tcx>,\n     mode: validation::Mode,\n+    for_promotion: bool,\n }\n \n impl Item<'mir, 'tcx> {\n@@ -41,6 +42,28 @@ impl Item<'mir, 'tcx> {\n             def_id,\n             param_env,\n             mode,\n+            for_promotion: false,\n+        }\n+    }\n+\n+    // HACK(eddyb) this is to get around the panic for a runtime fn from `Item::new`.\n+    // Also, it allows promoting `&mut []`.\n+    pub fn for_promotion(\n+        tcx: TyCtxt<'tcx>,\n+        def_id: DefId,\n+        body: &'mir mir::Body<'tcx>,\n+    ) -> Self {\n+        let param_env = tcx.param_env(def_id);\n+        let mode = validation::Mode::for_item(tcx, def_id)\n+            .unwrap_or(validation::Mode::ConstFn);\n+\n+        Item {\n+            body,\n+            tcx,\n+            def_id,\n+            param_env,\n+            mode,\n+            for_promotion: true,\n         }\n     }\n }"}, {"sha": "e666dd9571f1402cb3da419ce6cd8b00f20ef450", "filename": "src/librustc_mir/transform/check_consts/qualifs.rs", "status": "modified", "additions": 28, "deletions": 18, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/f2c8628920b73f546b6d1a64babd7e8a481a9b9f/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2c8628920b73f546b6d1a64babd7e8a481a9b9f/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs?ref=f2c8628920b73f546b6d1a64babd7e8a481a9b9f", "patch": "@@ -3,7 +3,6 @@\n use rustc::mir::*;\n use rustc::mir::interpret::ConstValue;\n use rustc::ty::{self, Ty};\n-use rustc_index::bit_set::BitSet;\n use syntax_pos::DUMMY_SP;\n \n use super::Item as ConstCx;\n@@ -44,7 +43,7 @@ pub trait Qualif {\n \n     fn in_projection_structurally(\n         cx: &ConstCx<'_, 'tcx>,\n-        per_local: &BitSet<Local>,\n+        per_local: &impl Fn(Local) -> bool,\n         place: PlaceRef<'_, 'tcx>,\n     ) -> bool {\n         if let [proj_base @ .., elem] = place.projection {\n@@ -65,7 +64,7 @@ pub trait Qualif {\n                 ProjectionElem::ConstantIndex { .. } |\n                 ProjectionElem::Downcast(..) => qualif,\n \n-                ProjectionElem::Index(local) => qualif || per_local.contains(*local),\n+                ProjectionElem::Index(local) => qualif || per_local(*local),\n             }\n         } else {\n             bug!(\"This should be called if projection is not empty\");\n@@ -74,22 +73,22 @@ pub trait Qualif {\n \n     fn in_projection(\n         cx: &ConstCx<'_, 'tcx>,\n-        per_local: &BitSet<Local>,\n+        per_local: &impl Fn(Local) -> bool,\n         place: PlaceRef<'_, 'tcx>,\n     ) -> bool {\n         Self::in_projection_structurally(cx, per_local, place)\n     }\n \n     fn in_place(\n         cx: &ConstCx<'_, 'tcx>,\n-        per_local: &BitSet<Local>,\n+        per_local: &impl Fn(Local) -> bool,\n         place: PlaceRef<'_, 'tcx>,\n     ) -> bool {\n         match place {\n             PlaceRef {\n                 base: PlaceBase::Local(local),\n                 projection: [],\n-            } => per_local.contains(*local),\n+            } => per_local(*local),\n             PlaceRef {\n                 base: PlaceBase::Static(box Static {\n                     kind: StaticKind::Promoted(..),\n@@ -112,7 +111,7 @@ pub trait Qualif {\n \n     fn in_operand(\n         cx: &ConstCx<'_, 'tcx>,\n-        per_local: &BitSet<Local>,\n+        per_local: &impl Fn(Local) -> bool,\n         operand: &Operand<'tcx>,\n     ) -> bool {\n         match *operand {\n@@ -143,7 +142,7 @@ pub trait Qualif {\n \n     fn in_rvalue_structurally(\n         cx: &ConstCx<'_, 'tcx>,\n-        per_local: &BitSet<Local>,\n+        per_local: &impl Fn(Local) -> bool,\n         rvalue: &Rvalue<'tcx>,\n     ) -> bool {\n         match *rvalue {\n@@ -185,13 +184,17 @@ pub trait Qualif {\n         }\n     }\n \n-    fn in_rvalue(cx: &ConstCx<'_, 'tcx>, per_local: &BitSet<Local>, rvalue: &Rvalue<'tcx>) -> bool {\n+    fn in_rvalue(\n+        cx: &ConstCx<'_, 'tcx>,\n+        per_local: &impl Fn(Local) -> bool,\n+        rvalue: &Rvalue<'tcx>,\n+    ) -> bool {\n         Self::in_rvalue_structurally(cx, per_local, rvalue)\n     }\n \n     fn in_call(\n         cx: &ConstCx<'_, 'tcx>,\n-        _per_local: &BitSet<Local>,\n+        _per_local: &impl Fn(Local) -> bool,\n         _callee: &Operand<'tcx>,\n         _args: &[Operand<'tcx>],\n         return_ty: Ty<'tcx>,\n@@ -216,7 +219,11 @@ impl Qualif for HasMutInterior {\n         !ty.is_freeze(cx.tcx, cx.param_env, DUMMY_SP)\n     }\n \n-    fn in_rvalue(cx: &ConstCx<'_, 'tcx>, per_local: &BitSet<Local>, rvalue: &Rvalue<'tcx>) -> bool {\n+    fn in_rvalue(\n+        cx: &ConstCx<'_, 'tcx>,\n+        per_local: &impl Fn(Local) -> bool,\n+        rvalue: &Rvalue<'tcx>,\n+    ) -> bool {\n         match *rvalue {\n             // Returning `true` for `Rvalue::Ref` indicates the borrow isn't\n             // allowed in constants (and the `Checker` will error), and/or it\n@@ -231,12 +238,11 @@ impl Qualif for HasMutInterior {\n                         // Inside a `static mut`, &mut [...] is also allowed.\n                         ty::Array(..) | ty::Slice(_) if cx.mode == Mode::StaticMut => {},\n \n-                        // FIXME(ecstaticmorse): uncomment the following match arm to stop marking\n-                        // `&mut []` as `HasMutInterior`.\n-                        /*\n-                        ty::Array(_, len) if len.try_eval_usize(cx.tcx, cx.param_env) == Some(0)\n-                            => {},\n-                        */\n+                        // FIXME(eddyb) the `cx.for_promotion` condition\n+                        // seems unnecessary, given that this is merely a ZST.\n+                        ty::Array(_, len)\n+                            if len.try_eval_usize(cx.tcx, cx.param_env) == Some(0)\n+                                && cx.for_promotion => {},\n \n                         _ => return true,\n                     }\n@@ -275,7 +281,11 @@ impl Qualif for NeedsDrop {\n         ty.needs_drop(cx.tcx, cx.param_env)\n     }\n \n-    fn in_rvalue(cx: &ConstCx<'_, 'tcx>, per_local: &BitSet<Local>, rvalue: &Rvalue<'tcx>) -> bool {\n+    fn in_rvalue(\n+        cx: &ConstCx<'_, 'tcx>,\n+        per_local: &impl Fn(Local) -> bool,\n+        rvalue: &Rvalue<'tcx>,\n+    ) -> bool {\n         if let Rvalue::Aggregate(ref kind, _) = *rvalue {\n             if let AggregateKind::Adt(def, ..) = **kind {\n                 if def.has_dtor(cx.tcx) {"}, {"sha": "d3f1c760724f113000e5b8efd6d0fcbd27dba418", "filename": "src/librustc_mir/transform/check_consts/resolver.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f2c8628920b73f546b6d1a64babd7e8a481a9b9f/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fresolver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2c8628920b73f546b6d1a64babd7e8a481a9b9f/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fresolver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fresolver.rs?ref=f2c8628920b73f546b6d1a64babd7e8a481a9b9f", "patch": "@@ -81,7 +81,13 @@ where\n         return_place: &mir::Place<'tcx>,\n     ) {\n         let return_ty = return_place.ty(self.item.body, self.item.tcx).ty;\n-        let qualif = Q::in_call(self.item, &mut self.qualifs_per_local, func, args, return_ty);\n+        let qualif = Q::in_call(\n+            self.item,\n+            &|l| self.qualifs_per_local.contains(l),\n+            func,\n+            args,\n+            return_ty,\n+        );\n         if !return_place.is_indirect() {\n             self.assign_qualif_direct(return_place, qualif);\n         }\n@@ -114,7 +120,7 @@ where\n         rvalue: &mir::Rvalue<'tcx>,\n         location: Location,\n     ) {\n-        let qualif = Q::in_rvalue(self.item, self.qualifs_per_local, rvalue);\n+        let qualif = Q::in_rvalue(self.item, &|l| self.qualifs_per_local.contains(l), rvalue);\n         if !place.is_indirect() {\n             self.assign_qualif_direct(place, qualif);\n         }\n@@ -129,7 +135,7 @@ where\n         // here; that occurs in `apply_call_return_effect`.\n \n         if let mir::TerminatorKind::DropAndReplace { value, location: dest, .. } = kind {\n-            let qualif = Q::in_operand(self.item, self.qualifs_per_local, value);\n+            let qualif = Q::in_operand(self.item, &|l| self.qualifs_per_local.contains(l), value);\n             if !dest.is_indirect() {\n                 self.assign_qualif_direct(dest, qualif);\n             }"}, {"sha": "fa74663973656348170209bdf9cc17e57f066993", "filename": "src/librustc_mir/transform/check_consts/validation.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f2c8628920b73f546b6d1a64babd7e8a481a9b9f/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2c8628920b73f546b6d1a64babd7e8a481a9b9f/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs?ref=f2c8628920b73f546b6d1a64babd7e8a481a9b9f", "patch": "@@ -369,11 +369,10 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n         // it depends on `HasMutInterior` being set for mutable borrows as well as values with\n         // interior mutability.\n         if let Rvalue::Ref(_, kind, ref borrowed_place) = *rvalue {\n-            let rvalue_has_mut_interior = HasMutInterior::in_rvalue(\n-                &self.item,\n-                self.qualifs.has_mut_interior.get(),\n-                rvalue,\n-            );\n+            let rvalue_has_mut_interior = {\n+                let has_mut_interior = self.qualifs.has_mut_interior.get();\n+                HasMutInterior::in_rvalue(&self.item, &|l| has_mut_interior.contains(l), rvalue)\n+            };\n \n             if rvalue_has_mut_interior {\n                 let is_derived_from_illegal_borrow = match borrowed_place.as_local() {"}, {"sha": "7aaff5735f696a42cd61d51404ca3d886184d67a", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 55, "deletions": 20, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/f2c8628920b73f546b6d1a64babd7e8a481a9b9f/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2c8628920b73f546b6d1a64babd7e8a481a9b9f/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=f2c8628920b73f546b6d1a64babd7e8a481a9b9f", "patch": "@@ -25,12 +25,13 @@ use syntax::ast::LitKind;\n use syntax::symbol::sym;\n use syntax_pos::{Span, DUMMY_SP};\n \n-use rustc_index::bit_set::BitSet;\n use rustc_index::vec::{IndexVec, Idx};\n use rustc_target::spec::abi::Abi;\n \n use std::{iter, mem, usize};\n \n+use crate::transform::check_consts::{qualifs, Item as ConstCx};\n+\n /// State of a temporary during collection and promotion.\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n pub enum TempState {\n@@ -231,9 +232,9 @@ struct Validator<'a, 'tcx> {\n     is_static_mut: bool,\n     is_non_const_fn: bool,\n     temps: &'a IndexVec<Local, TempState>,\n-    // FIXME(eddyb) compute these 2 on the fly.\n-    has_mut_interior: &'a BitSet<Local>,\n-    needs_drop: &'a BitSet<Local>,\n+\n+    // FIXME(eddyb) deduplicate the data in this vs other fields.\n+    const_cx: ConstCx<'a, 'tcx>,\n \n     /// Explicit promotion happens e.g. for constant arguments declared via\n     /// `rustc_args_required_const`.\n@@ -276,15 +277,17 @@ impl<'tcx> Validator<'_, 'tcx> {\n                             PlaceBase::Local(local) => local,\n                             _ => return Err(Unpromotable),\n                         };\n+                        self.validate_local(base)?;\n+\n                         if place.projection.contains(&ProjectionElem::Deref) {\n                             return Err(Unpromotable);\n                         }\n \n-                        // FIXME(eddyb) compute this on the fly.\n-                        let mut has_mut_interior = self.has_mut_interior.contains(base);\n+                        let mut has_mut_interior =\n+                            self.qualif_local::<qualifs::HasMutInterior>(base);\n                         // HACK(eddyb) this should compute the same thing as\n                         // `<HasMutInterior as Qualif>::in_projection` from\n-                        // `qualify_consts` but without recursion.\n+                        // `check_consts::qualifs` but without recursion.\n                         if has_mut_interior {\n                             // This allows borrowing fields which don't have\n                             // `HasMutInterior`, from a type that does, e.g.:\n@@ -311,8 +314,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n                         if has_mut_interior {\n                             return Err(Unpromotable);\n                         }\n-                        // FIXME(eddyb) compute this on the fly.\n-                        if self.needs_drop.contains(base) {\n+                        if self.qualif_local::<qualifs::NeedsDrop>(base) {\n                             return Err(Unpromotable);\n                         }\n                         if let BorrowKind::Mut { .. } = kind {\n@@ -339,7 +341,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n                             }\n                         }\n \n-                        self.validate_local(base)\n+                        Ok(())\n                     }\n                     _ => bug!()\n                 }\n@@ -373,6 +375,42 @@ impl<'tcx> Validator<'_, 'tcx> {\n         }\n     }\n \n+    // FIXME(eddyb) maybe cache this?\n+    fn qualif_local<Q: qualifs::Qualif>(&self, local: Local) -> bool {\n+        let per_local = &|l| self.qualif_local::<Q>(l);\n+\n+        if let TempState::Defined { location: loc, .. } = self.temps[local] {\n+            let num_stmts = self.body[loc.block].statements.len();\n+\n+            if loc.statement_index < num_stmts {\n+                let statement = &self.body[loc.block].statements[loc.statement_index];\n+                match &statement.kind {\n+                    StatementKind::Assign(box(_, rhs)) => {\n+                        Q::in_rvalue(&self.const_cx, per_local, rhs)\n+                    }\n+                    _ => {\n+                        span_bug!(statement.source_info.span, \"{:?} is not an assignment\",\n+                                statement);\n+                    }\n+                }\n+            } else {\n+                let terminator = self.body[loc.block].terminator();\n+                match &terminator.kind {\n+                    TerminatorKind::Call { func, args, .. } => {\n+                        let return_ty = self.body.local_decls[local].ty;\n+                        Q::in_call(&self.const_cx, per_local, func, args, return_ty)\n+                    }\n+                    kind => {\n+                        span_bug!(terminator.source_info.span, \"{:?} not promotable\", kind);\n+                    }\n+                }\n+            }\n+        } else {\n+            let span = self.body.local_decls[local].source_info.span;\n+            span_bug!(span, \"{:?} not promotable, qualif_local shouldn't have been called\", local);\n+        }\n+    }\n+\n     // FIXME(eddyb) maybe cache this?\n     fn validate_local(&self, local: Local) -> Result<(), Unpromotable> {\n         if let TempState::Defined { location: loc, .. } = self.temps[local] {\n@@ -593,13 +631,14 @@ impl<'tcx> Validator<'_, 'tcx> {\n                     }\n                 }\n \n+                self.validate_place(place)?;\n+\n                 // HACK(eddyb) this should compute the same thing as\n                 // `<HasMutInterior as Qualif>::in_projection` from\n-                // `qualify_consts` but without recursion.\n+                // `check_consts::qualifs` but without recursion.\n                 let mut has_mut_interior = match place.base {\n                     PlaceBase::Local(local) => {\n-                        // FIXME(eddyb) compute this on the fly.\n-                        self.has_mut_interior.contains(*local)\n+                        self.qualif_local::<qualifs::HasMutInterior>(*local)\n                     }\n                     PlaceBase::Static(_) => false,\n                 };\n@@ -624,7 +663,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n                     return Err(Unpromotable);\n                 }\n \n-                self.validate_place(place)\n+                Ok(())\n             }\n \n             Rvalue::Aggregate(_, ref operands) => {\n@@ -680,9 +719,6 @@ pub fn validate_candidates(\n     body: &Body<'tcx>,\n     def_id: DefId,\n     temps: &IndexVec<Local, TempState>,\n-    // FIXME(eddyb) compute these 2 on the fly.\n-    has_mut_interior: &BitSet<Local>,\n-    needs_drop: &BitSet<Local>,\n     candidates: &[Candidate],\n ) -> Vec<Candidate> {\n     let mut validator = Validator {\n@@ -693,9 +729,8 @@ pub fn validate_candidates(\n         is_static_mut: false,\n         is_non_const_fn: false,\n         temps,\n-        // FIXME(eddyb) compute these 2 on the fly.\n-        has_mut_interior,\n-        needs_drop,\n+\n+        const_cx: ConstCx::for_promotion(tcx, def_id, body),\n \n         explicit: false,\n     };"}, {"sha": "21feeb1fad61d00cf84fde9ff4ef909eb97f9051", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f2c8628920b73f546b6d1a64babd7e8a481a9b9f/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2c8628920b73f546b6d1a64babd7e8a481a9b9f/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=f2c8628920b73f546b6d1a64babd7e8a481a9b9f", "patch": "@@ -1118,8 +1118,6 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n             self.body,\n             self.def_id,\n             &self.temp_promotion_state,\n-            &self.per_local.0[HasMutInterior::IDX],\n-            &self.per_local.0[NeedsDrop::IDX],\n             &self.unchecked_promotion_candidates,\n         );\n "}]}