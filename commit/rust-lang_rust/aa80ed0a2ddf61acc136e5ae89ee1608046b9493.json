{"sha": "aa80ed0a2ddf61acc136e5ae89ee1608046b9493", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFhODBlZDBhMmRkZjYxYWNjMTM2ZTVhZTg5ZWUxNjA4MDQ2Yjk0OTM=", "commit": {"author": {"name": "Santiago Pastorino", "email": "spastorino@gmail.com", "date": "2020-07-02T22:23:21Z"}, "committer": {"name": "Santiago Pastorino", "email": "spastorino@gmail.com", "date": "2020-07-02T22:23:21Z"}, "message": "Store pairs in SSA", "tree": {"sha": "e2519c737481b5e07f722a672eeec006f34556f1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e2519c737481b5e07f722a672eeec006f34556f1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aa80ed0a2ddf61acc136e5ae89ee1608046b9493", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEF0ntrgrd9qf9uuThgTGiTgx5768FAl7+XlkACgkQgTGiTgx5\n76+low/9EKZYd+5WfqsHOE1uR4MpCxIONyek2v8nO6Zl2bM69YXxHiTfRs3eYCfD\nIiWCNYf7+r1Y2pGS3UGfW1LKgdQB61dmOEeQZkGCF7rkb8ASQHSB2VWOTOaCpLf8\nY+eMzP4jSqW2gkucV0gLAUYpCey5jo1XEBOQZaNeAgAHMF96ezxbgDJpygvzdhvm\n5zbKzXtvxvHDgvr3FGuXSXXCYfp6Bc0mftxPqmgdo63X9fFdVaMrbQ6+zfmrf0p8\nmmolSjwgCJ1zofYUpxld8PhDSDbrnKavPant100az9y2tvl1V9CSiKrnWBP8r/ja\nJHwyalMzZNFwy1ITAFnA0tuHFhVMaKWAOt2G4LD/ro92oqe9AknBFzzf234DLOGk\n9GVaghUETxV3FcIbJHF/08RHmh7JposXx1fyPz/TXICzmD9NOvEPhoSWdND0tOir\n6WJ7jlRognIrAP5ffcBzbuvObuAWPYGDa0REK2VQPmEHtW0h55iiZ0TlxDZhNlno\nkQXvPfggpfldjU5w/HlUiRqobSB57ZADH6EImV3YVV06BKlEoqHXTzxFh9dK8GmN\njiAFdIfRY+4dh6VPPkrWb0D+/KOcs8K+NSuamOtqU6KTOodlEd0T+EqPopENukzF\nlGXcKtHL7jaUKSiWTL6pCiedbvcvBqqKIAAJyN2REKC42G8xZL0=\n=msCg\n-----END PGP SIGNATURE-----", "payload": "tree e2519c737481b5e07f722a672eeec006f34556f1\nparent 6e2ac83a0cbf6681750b1f136137116612799684\nauthor Santiago Pastorino <spastorino@gmail.com> 1593728601 -0300\ncommitter Santiago Pastorino <spastorino@gmail.com> 1593728601 -0300\n\nStore pairs in SSA\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aa80ed0a2ddf61acc136e5ae89ee1608046b9493", "html_url": "https://github.com/rust-lang/rust/commit/aa80ed0a2ddf61acc136e5ae89ee1608046b9493", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aa80ed0a2ddf61acc136e5ae89ee1608046b9493/comments", "author": {"login": "spastorino", "id": 52642, "node_id": "MDQ6VXNlcjUyNjQy", "avatar_url": "https://avatars.githubusercontent.com/u/52642?v=4", "gravatar_id": "", "url": "https://api.github.com/users/spastorino", "html_url": "https://github.com/spastorino", "followers_url": "https://api.github.com/users/spastorino/followers", "following_url": "https://api.github.com/users/spastorino/following{/other_user}", "gists_url": "https://api.github.com/users/spastorino/gists{/gist_id}", "starred_url": "https://api.github.com/users/spastorino/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/spastorino/subscriptions", "organizations_url": "https://api.github.com/users/spastorino/orgs", "repos_url": "https://api.github.com/users/spastorino/repos", "events_url": "https://api.github.com/users/spastorino/events{/privacy}", "received_events_url": "https://api.github.com/users/spastorino/received_events", "type": "User", "site_admin": false}, "committer": {"login": "spastorino", "id": 52642, "node_id": "MDQ6VXNlcjUyNjQy", "avatar_url": "https://avatars.githubusercontent.com/u/52642?v=4", "gravatar_id": "", "url": "https://api.github.com/users/spastorino", "html_url": "https://github.com/spastorino", "followers_url": "https://api.github.com/users/spastorino/followers", "following_url": "https://api.github.com/users/spastorino/following{/other_user}", "gists_url": "https://api.github.com/users/spastorino/gists{/gist_id}", "starred_url": "https://api.github.com/users/spastorino/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/spastorino/subscriptions", "organizations_url": "https://api.github.com/users/spastorino/orgs", "repos_url": "https://api.github.com/users/spastorino/repos", "events_url": "https://api.github.com/users/spastorino/events{/privacy}", "received_events_url": "https://api.github.com/users/spastorino/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6e2ac83a0cbf6681750b1f136137116612799684", "url": "https://api.github.com/repos/rust-lang/rust/commits/6e2ac83a0cbf6681750b1f136137116612799684", "html_url": "https://github.com/rust-lang/rust/commit/6e2ac83a0cbf6681750b1f136137116612799684"}], "stats": {"total": 135, "additions": 131, "deletions": 4}, "files": [{"sha": "7c4d7b12f6e99cd4230b62fa1ea73f17890df226", "filename": "src/abi/comments.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aa80ed0a2ddf61acc136e5ae89ee1608046b9493/src%2Fabi%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa80ed0a2ddf61acc136e5ae89ee1608046b9493/src%2Fabi%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fabi%2Fcomments.rs?ref=aa80ed0a2ddf61acc136e5ae89ee1608046b9493", "patch": "@@ -78,6 +78,10 @@ pub(super) fn add_local_place_comments<'tcx>(\n             assert_eq!(local, place_local);\n             (\"ssa\", Cow::Owned(format!(\",var={}\", var.index())))\n         }\n+        CPlaceInner::VarPair(place_local, var1, var2) => {\n+            assert_eq!(local, place_local);\n+            (\"ssa\", Cow::Owned(format!(\",var=({}, {})\", var1.index(), var2.index())))\n+        }\n         CPlaceInner::Addr(ptr, meta) => {\n             let meta = if let Some(meta) = meta {\n                 Cow::Owned(format!(\",meta={}\", meta))"}, {"sha": "066383fd8319584fbb480592bb4a521b86979e1d", "filename": "src/abi/mod.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/aa80ed0a2ddf61acc136e5ae89ee1608046b9493/src%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa80ed0a2ddf61acc136e5ae89ee1608046b9493/src%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fabi%2Fmod.rs?ref=aa80ed0a2ddf61acc136e5ae89ee1608046b9493", "patch": "@@ -290,7 +290,11 @@ fn local_place<'tcx>(\n     is_ssa: bool,\n ) -> CPlace<'tcx> {\n     let place = if is_ssa {\n-        CPlace::new_var(fx, local, layout)\n+        if let rustc_target::abi::Abi::ScalarPair(_, _) = layout.abi {\n+            CPlace::new_var_pair(fx, local, layout)\n+        } else {\n+            CPlace::new_var(fx, local, layout)\n+        }\n     } else {\n         CPlace::new_stack_slot(fx, layout)\n     };"}, {"sha": "c3436785d90f0e9fe6829b10beba8fba9337065b", "filename": "src/analyze.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/aa80ed0a2ddf61acc136e5ae89ee1608046b9493/src%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa80ed0a2ddf61acc136e5ae89ee1608046b9493/src%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fanalyze.rs?ref=aa80ed0a2ddf61acc136e5ae89ee1608046b9493", "patch": "@@ -11,7 +11,8 @@ pub(crate) enum SsaKind {\n \n pub(crate) fn analyze(fx: &FunctionCx<'_, '_, impl Backend>) -> IndexVec<Local, SsaKind> {\n     let mut flag_map = fx.mir.local_decls.iter().map(|local_decl| {\n-        if fx.clif_type(fx.monomorphize(&local_decl.ty)).is_some() {\n+        let ty = fx.monomorphize(&local_decl.ty);\n+        if fx.clif_type(ty).is_some() || fx.clif_pair_type(ty).is_some() {\n             SsaKind::Ssa\n         } else {\n             SsaKind::NotSsa"}, {"sha": "02b05e5b2dd154df87a84baadfdb98c056f0acc1", "filename": "src/common.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/aa80ed0a2ddf61acc136e5ae89ee1608046b9493/src%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa80ed0a2ddf61acc136e5ae89ee1608046b9493/src%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcommon.rs?ref=aa80ed0a2ddf61acc136e5ae89ee1608046b9493", "patch": "@@ -67,6 +67,19 @@ fn clif_type_from_ty<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> Option<types::Typ\n     })\n }\n \n+fn clif_pair_type_from_ty<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> Option<(types::Type, types::Type)> {\n+    Some(match ty.kind {\n+        ty::Tuple(substs) if substs.len() == 2 => {\n+            let mut types = substs.types();\n+            (\n+                clif_type_from_ty(tcx, types.next().unwrap())?,\n+                clif_type_from_ty(tcx, types.next().unwrap())?,\n+            )\n+        }\n+        _ => return None,\n+    })\n+}\n+\n /// Is a pointer to this type a fat ptr?\n pub(crate) fn has_ptr_meta<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> bool {\n     let ptr_ty = tcx.mk_ptr(TypeAndMut { ty, mutbl: rustc_hir::Mutability::Not });\n@@ -321,6 +334,10 @@ impl<'tcx, B: Backend + 'static> FunctionCx<'_, 'tcx, B> {\n         clif_type_from_ty(self.tcx, ty)\n     }\n \n+    pub(crate) fn clif_pair_type(&self, ty: Ty<'tcx>) -> Option<(Type, Type)> {\n+        clif_pair_type_from_ty(self.tcx, ty)\n+    }\n+\n     pub(crate) fn get_block(&self, bb: BasicBlock) -> Block {\n         *self.block_map.get(bb).unwrap()\n     }"}, {"sha": "709c85d240979c64c6cb208cb95d41690b28a573", "filename": "src/debuginfo/mod.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/aa80ed0a2ddf61acc136e5ae89ee1608046b9493/src%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa80ed0a2ddf61acc136e5ae89ee1608046b9493/src%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdebuginfo%2Fmod.rs?ref=aa80ed0a2ddf61acc136e5ae89ee1608046b9493", "patch": "@@ -405,6 +405,11 @@ fn place_location<'tcx>(\n                 AttributeValue::Exprloc(Expression::new())\n             }\n         }\n+        CPlaceInner::VarPair(_, _, _) => {\n+            // FIXME implement this\n+\n+            AttributeValue::Exprloc(Expression::new())\n+        }\n         CPlaceInner::Addr(_, _) => {\n             // FIXME implement this (used by arguments and returns)\n "}, {"sha": "a55bfddeaaf9a893f0a1925a0de3bca92982cd1c", "filename": "src/value_and_place.rs", "status": "modified", "additions": 98, "deletions": 2, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/aa80ed0a2ddf61acc136e5ae89ee1608046b9493/src%2Fvalue_and_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa80ed0a2ddf61acc136e5ae89ee1608046b9493/src%2Fvalue_and_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvalue_and_place.rs?ref=aa80ed0a2ddf61acc136e5ae89ee1608046b9493", "patch": "@@ -179,12 +179,25 @@ impl<'tcx> CValue<'tcx> {\n                     _ => unreachable!(\"value_field for ByVal with abi {:?}\", layout.abi),\n                 }\n             }\n+            CValueInner::ByValPair(val1, val2) => {\n+                match layout.abi {\n+                    Abi::ScalarPair(_, _) => {\n+                        let val = match field.as_u32() {\n+                            0 => val1,\n+                            1 => val2,\n+                            _ => bug!(\"field should be 0 or 1\"),\n+                        };\n+                        let field_layout = layout.field(&*fx, usize::from(field));\n+                        CValue::by_val(val, field_layout)\n+                    }\n+                    _ => unreachable!(\"value_field for ByValPair with abi {:?}\", layout.abi),\n+                }\n+            }\n             CValueInner::ByRef(ptr, None) => {\n                 let (field_ptr, field_layout) = codegen_field(fx, ptr, None, layout, field);\n                 CValue::by_ref(field_ptr, field_layout)\n             }\n             CValueInner::ByRef(_, Some(_)) => todo!(),\n-            _ => bug!(\"place_field for {:?}\", self),\n         }\n     }\n \n@@ -258,6 +271,7 @@ pub(crate) struct CPlace<'tcx> {\n #[derive(Debug, Copy, Clone)]\n pub(crate) enum CPlaceInner {\n     Var(Local, Variable),\n+    VarPair(Local, Variable, Variable),\n     Addr(Pointer, Option<Value>),\n }\n \n@@ -312,6 +326,25 @@ impl<'tcx> CPlace<'tcx> {\n         }\n     }\n \n+    pub(crate) fn new_var_pair(\n+        fx: &mut FunctionCx<'_, 'tcx, impl Backend>,\n+        local: Local,\n+        layout: TyAndLayout<'tcx>,\n+    ) -> CPlace<'tcx> {\n+        let var1 = Variable::with_u32(fx.next_ssa_var);\n+        fx.next_ssa_var += 1;\n+        let var2 = Variable::with_u32(fx.next_ssa_var);\n+        fx.next_ssa_var += 1;\n+\n+        let (ty1, ty2) = fx.clif_pair_type(layout.ty).unwrap();\n+        fx.bcx.declare_var(var1, ty1);\n+        fx.bcx.declare_var(var2, ty2);\n+        CPlace {\n+            inner: CPlaceInner::VarPair(local, var1, var2),\n+            layout,\n+        }\n+    }\n+\n     pub(crate) fn for_ptr(ptr: Pointer, layout: TyAndLayout<'tcx>) -> CPlace<'tcx> {\n         CPlace {\n             inner: CPlaceInner::Addr(ptr, None),\n@@ -334,6 +367,13 @@ impl<'tcx> CPlace<'tcx> {\n                 fx.bcx.set_val_label(val, cranelift_codegen::ir::ValueLabel::new(var.index()));\n                 CValue::by_val(val, layout)\n             }\n+            CPlaceInner::VarPair(_local, var1, var2) => {\n+                let val1 = fx.bcx.use_var(var1);\n+                fx.bcx.set_val_label(val1, cranelift_codegen::ir::ValueLabel::new(var1.index()));\n+                let val2 = fx.bcx.use_var(var2);\n+                fx.bcx.set_val_label(val2, cranelift_codegen::ir::ValueLabel::new(var2.index()));\n+                CValue::by_val_pair(val1, val2, layout)\n+            }\n             CPlaceInner::Addr(ptr, extra) => {\n                 if let Some(extra) = extra {\n                     CValue::by_ref_unsized(ptr, extra, layout)\n@@ -354,7 +394,8 @@ impl<'tcx> CPlace<'tcx> {\n     pub(crate) fn to_ptr_maybe_unsized(self) -> (Pointer, Option<Value>) {\n         match self.inner {\n             CPlaceInner::Addr(ptr, extra) => (ptr, extra),\n-            CPlaceInner::Var(_, _) => bug!(\"Expected CPlace::Addr, found {:?}\", self),\n+            CPlaceInner::Var(_, _)\n+            | CPlaceInner::VarPair(_, _, _) => bug!(\"Expected CPlace::Addr, found {:?}\", self),\n         }\n     }\n \n@@ -466,6 +507,45 @@ impl<'tcx> CPlace<'tcx> {\n                 fx.bcx.def_var(var, data);\n                 return;\n             }\n+            CPlaceInner::VarPair(_local, var1, var2) => {\n+                let (data1, data2) = CValue(from.0, dst_layout).load_scalar_pair(fx);\n+                let (dst_ty1, dst_ty2) = fx.clif_pair_type(self.layout().ty).unwrap();\n+\n+                let src_ty1 = fx.bcx.func.dfg.value_type(data1);\n+                let data = match (src_ty1, dst_ty1) {\n+                    (_, _) if src_ty1 == dst_ty1 => data1,\n+\n+                    // This is a `write_cvalue_transmute`.\n+                    (types::I32, types::F32) | (types::F32, types::I32)\n+                    | (types::I64, types::F64) | (types::F64, types::I64) => {\n+                        fx.bcx.ins().bitcast(dst_ty1, data1)\n+                    }\n+                    _ if src_ty1.is_vector() && dst_ty1.is_vector() => {\n+                        fx.bcx.ins().raw_bitcast(dst_ty1, data1)\n+                    }\n+                    _ => unreachable!(\"write_cvalue_transmute: {:?} -> {:?}\", src_ty1, dst_ty1),\n+                };\n+                fx.bcx.set_val_label(data, cranelift_codegen::ir::ValueLabel::new(var1.index()));\n+                fx.bcx.def_var(var1, data);\n+\n+                let src_ty2 = fx.bcx.func.dfg.value_type(data2);\n+                let data = match (src_ty2, dst_ty2) {\n+                    (_, _) if src_ty2 == dst_ty2 => data2,\n+\n+                    // This is a `write_cvalue_transmute`.\n+                    (types::I32, types::F32) | (types::F32, types::I32)\n+                    | (types::I64, types::F64) | (types::F64, types::I64) => {\n+                        fx.bcx.ins().bitcast(dst_ty2, data2)\n+                    }\n+                    _ if src_ty2.is_vector() && dst_ty2.is_vector() => {\n+                        fx.bcx.ins().raw_bitcast(dst_ty2, data2)\n+                    }\n+                    _ => unreachable!(\"write_cvalue_transmute: {:?} -> {:?}\", src_ty2, dst_ty2),\n+                };\n+                fx.bcx.set_val_label(data, cranelift_codegen::ir::ValueLabel::new(var2.index()));\n+                fx.bcx.def_var(var2, data);\n+                return;\n+            }\n             CPlaceInner::Addr(ptr, None) => {\n                 if dst_layout.size == Size::ZERO || dst_layout.abi == Abi::Uninhabited {\n                     return;\n@@ -529,6 +609,22 @@ impl<'tcx> CPlace<'tcx> {\n         field: mir::Field,\n     ) -> CPlace<'tcx> {\n         let layout = self.layout();\n+        if let CPlaceInner::VarPair(local, var1, var2) = self.inner {\n+            let layout = layout.field(&*fx, field.index());\n+\n+            match field.as_u32() {\n+                0 => return CPlace {\n+                    inner: CPlaceInner::Var(local, var1),\n+                    layout,\n+                },\n+                1 => return CPlace {\n+                    inner: CPlaceInner::Var(local, var2),\n+                    layout,\n+                },\n+                _ => unreachable!(\"field should be 0 or 1\"),\n+            }\n+        }\n+\n         let (base, extra) = self.to_ptr_maybe_unsized();\n \n         let (field_ptr, field_layout) = codegen_field(fx, base, extra, layout, field);"}]}