{"sha": "e64138c534d356e555842ddc9da20a952a20ab46", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU2NDEzOGM1MzRkMzU2ZTU1NTg0MmRkYzlkYTIwYTk1MmEyMGFiNDY=", "commit": {"author": {"name": "mark", "email": "markm@cs.wisc.edu", "date": "2021-02-13T00:04:37Z"}, "committer": {"name": "mark", "email": "markm@cs.wisc.edu", "date": "2021-03-05T16:10:04Z"}, "message": "use pat<no_top_alt> for patterns in let bindings", "tree": {"sha": "f89110b4a822a6cd4d4391a3c0c21099d1e4a05f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f89110b4a822a6cd4d4391a3c0c21099d1e4a05f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e64138c534d356e555842ddc9da20a952a20ab46", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e64138c534d356e555842ddc9da20a952a20ab46", "html_url": "https://github.com/rust-lang/rust/commit/e64138c534d356e555842ddc9da20a952a20ab46", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e64138c534d356e555842ddc9da20a952a20ab46/comments", "author": {"login": "mark-i-m", "id": 8827840, "node_id": "MDQ6VXNlcjg4Mjc4NDA=", "avatar_url": "https://avatars.githubusercontent.com/u/8827840?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mark-i-m", "html_url": "https://github.com/mark-i-m", "followers_url": "https://api.github.com/users/mark-i-m/followers", "following_url": "https://api.github.com/users/mark-i-m/following{/other_user}", "gists_url": "https://api.github.com/users/mark-i-m/gists{/gist_id}", "starred_url": "https://api.github.com/users/mark-i-m/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mark-i-m/subscriptions", "organizations_url": "https://api.github.com/users/mark-i-m/orgs", "repos_url": "https://api.github.com/users/mark-i-m/repos", "events_url": "https://api.github.com/users/mark-i-m/events{/privacy}", "received_events_url": "https://api.github.com/users/mark-i-m/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mark-i-m", "id": 8827840, "node_id": "MDQ6VXNlcjg4Mjc4NDA=", "avatar_url": "https://avatars.githubusercontent.com/u/8827840?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mark-i-m", "html_url": "https://github.com/mark-i-m", "followers_url": "https://api.github.com/users/mark-i-m/followers", "following_url": "https://api.github.com/users/mark-i-m/following{/other_user}", "gists_url": "https://api.github.com/users/mark-i-m/gists{/gist_id}", "starred_url": "https://api.github.com/users/mark-i-m/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mark-i-m/subscriptions", "organizations_url": "https://api.github.com/users/mark-i-m/orgs", "repos_url": "https://api.github.com/users/mark-i-m/repos", "events_url": "https://api.github.com/users/mark-i-m/events{/privacy}", "received_events_url": "https://api.github.com/users/mark-i-m/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5233edcf1c7ee70ac25e4ec1115c3546f53d8a2d", "url": "https://api.github.com/repos/rust-lang/rust/commits/5233edcf1c7ee70ac25e4ec1115c3546f53d8a2d", "html_url": "https://github.com/rust-lang/rust/commit/5233edcf1c7ee70ac25e4ec1115c3546f53d8a2d"}], "stats": {"total": 931, "additions": 588, "deletions": 343}, "files": [{"sha": "335ceb775e85ae468b5ec372022055da54926b28", "filename": "compiler/rustc_lint/src/unused.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e64138c534d356e555842ddc9da20a952a20ab46/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64138c534d356e555842ddc9da20a952a20ab46/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Funused.rs?ref=e64138c534d356e555842ddc9da20a952a20ab46", "patch": "@@ -847,7 +847,7 @@ impl EarlyLintPass for UnusedParens {\n \n     fn check_stmt(&mut self, cx: &EarlyContext<'_>, s: &ast::Stmt) {\n         if let StmtKind::Local(ref local) = s.kind {\n-            self.check_unused_parens_pat(cx, &local.pat, false, false);\n+            self.check_unused_parens_pat(cx, &local.pat, true, false);\n         }\n \n         <Self as UnusedDelimLint>::check_stmt(self, cx, s)"}, {"sha": "a28595e6fae673bf6bca7775aed8bda698750ee5", "filename": "compiler/rustc_parse/src/parser/item.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e64138c534d356e555842ddc9da20a952a20ab46/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64138c534d356e555842ddc9da20a952a20ab46/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs?ref=e64138c534d356e555842ddc9da20a952a20ab46", "patch": "@@ -1757,8 +1757,9 @@ impl<'a> Parser<'a> {\n             let (pat, ty) = if is_name_required || this.is_named_param() {\n                 debug!(\"parse_param_general parse_pat (is_name_required:{})\", is_name_required);\n \n-                let pat = this.parse_fn_param_pat()?;\n-                if let Err(mut err) = this.expect(&token::Colon) {\n+                let (pat, colon) = this.parse_fn_param_pat_colon()?;\n+                if !colon {\n+                    let mut err = this.unexpected::<()>().unwrap_err();\n                     return if let Some(ident) =\n                         this.parameter_without_type(&mut err, pat, is_name_required, first_param)\n                     {"}, {"sha": "5a68afdfa59f71e7af14555243d9a996ccebc77e", "filename": "compiler/rustc_parse/src/parser/pat.rs", "status": "modified", "additions": 122, "deletions": 62, "changes": 184, "blob_url": "https://github.com/rust-lang/rust/blob/e64138c534d356e555842ddc9da20a952a20ab46/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64138c534d356e555842ddc9da20a952a20ab46/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs?ref=e64138c534d356e555842ddc9da20a952a20ab46", "patch": "@@ -31,6 +31,18 @@ pub enum RecoverComma {\n     No,\n }\n \n+/// The result of `eat_or_separator`. We want to distinguish which case we are in to avoid\n+/// emitting duplicate diagnostics.\n+#[derive(Debug, Clone, Copy)]\n+enum EatOrResult {\n+    /// We recovered from a trailing vert.\n+    TrailingVert,\n+    /// We ate an `|` (or `||` and recovered).\n+    AteOr,\n+    /// We did not eat anything (i.e. the current token is not `|` or `||`).\n+    None,\n+}\n+\n impl<'a> Parser<'a> {\n     /// Parses a pattern.\n     ///\n@@ -55,9 +67,26 @@ impl<'a> Parser<'a> {\n         gate_or: GateOr,\n         rc: RecoverComma,\n     ) -> PResult<'a, P<Pat>> {\n+        self.parse_pat_allow_top_alt_inner(expected, gate_or, rc).map(|(pat, _)| pat)\n+    }\n+\n+    /// Returns the pattern and a bool indicating whether we recovered from a trailing vert (true =\n+    /// recovered).\n+    fn parse_pat_allow_top_alt_inner(\n+        &mut self,\n+        expected: Expected,\n+        gate_or: GateOr,\n+        rc: RecoverComma,\n+    ) -> PResult<'a, (P<Pat>, bool)> {\n+        // Keep track of whether we recovered from a trailing vert so that we can avoid duplicated\n+        // suggestions (which bothers rustfix).\n+        //\n         // Allow a '|' before the pats (RFCs 1925, 2530, and 2535).\n-        let leading_vert_span =\n-            if self.eat_or_separator(None) { Some(self.prev_token.span) } else { None };\n+        let (leading_vert_span, mut trailing_vert) = match self.eat_or_separator(None) {\n+            EatOrResult::AteOr => (Some(self.prev_token.span), false),\n+            EatOrResult::TrailingVert => (None, true),\n+            EatOrResult::None => (None, false),\n+        };\n \n         // Parse the first pattern (`p_0`).\n         let first_pat = self.parse_pat_no_top_alt(expected)?;\n@@ -77,16 +106,24 @@ impl<'a> Parser<'a> {\n                 // If there was a leading vert, treat this as an or-pattern. This improves\n                 // diagnostics.\n                 let span = leading_vert_span.to(self.prev_token.span);\n-                return Ok(self.mk_pat(span, PatKind::Or(vec![first_pat])));\n+                return Ok((self.mk_pat(span, PatKind::Or(vec![first_pat])), trailing_vert));\n             }\n \n-            return Ok(first_pat);\n+            return Ok((first_pat, trailing_vert));\n         }\n \n         // Parse the patterns `p_1 | ... | p_n` where `n > 0`.\n         let lo = leading_vert_span.unwrap_or(first_pat.span);\n         let mut pats = vec![first_pat];\n-        while self.eat_or_separator(Some(lo)) {\n+        loop {\n+            match self.eat_or_separator(Some(lo)) {\n+                EatOrResult::AteOr => {}\n+                EatOrResult::None => break,\n+                EatOrResult::TrailingVert => {\n+                    trailing_vert = true;\n+                    break;\n+                }\n+            }\n             let pat = self.parse_pat_no_top_alt(expected).map_err(|mut err| {\n                 err.span_label(lo, WHILE_PARSING_OR_MSG);\n                 err\n@@ -101,15 +138,63 @@ impl<'a> Parser<'a> {\n             self.sess.gated_spans.gate(sym::or_patterns, or_pattern_span);\n         }\n \n-        Ok(self.mk_pat(or_pattern_span, PatKind::Or(pats)))\n+        Ok((self.mk_pat(or_pattern_span, PatKind::Or(pats)), trailing_vert))\n     }\n \n-    /// Parse the pattern for a function or function pointer parameter.\n-    pub(super) fn parse_fn_param_pat(&mut self) -> PResult<'a, P<Pat>> {\n-        // We actually do _not_ allow top-level or-patterns in function params, but we use\n-        // `parse_pat_allow_top_alt` anyway so that we can detect when a user tries to use it. This\n-        // allows us to print a better error message.\n-        //\n+    /// Parse a pattern and (maybe) a `Colon` in positions where a pattern may be followed by a\n+    /// type annotation (e.g. for `let` bindings or `fn` params).\n+    ///\n+    /// Generally, this corresponds to `pat_no_top_alt` followed by an optional `Colon`. It will\n+    /// eat the `Colon` token if one is present.\n+    ///\n+    /// The return value represents the parsed pattern and `true` if a `Colon` was parsed (`false`\n+    /// otherwise).\n+    pub(super) fn parse_pat_before_ty(\n+        &mut self,\n+        expected: Expected,\n+        gate_or: GateOr,\n+        rc: RecoverComma,\n+        syntax_loc: &str,\n+    ) -> PResult<'a, (P<Pat>, bool)> {\n+        // We use `parse_pat_allow_top_alt` regardless of whether we actually want top-level\n+        // or-patterns so that we can detect when a user tries to use it. This allows us to print a\n+        // better error message.\n+        let (pat, trailing_vert) = self.parse_pat_allow_top_alt_inner(expected, gate_or, rc)?;\n+        let colon = self.eat(&token::Colon);\n+\n+        if let PatKind::Or(pats) = &pat.kind {\n+            let msg = format!(\"top-level or-patterns are not allowed in {}\", syntax_loc);\n+            let (help, fix) = if pats.len() == 1 {\n+                // If all we have is a leading vert, then print a special message. This is the case\n+                // if `parse_pat_allow_top_alt` returns an or-pattern with one variant.\n+                let msg = \"remove the `|`\";\n+                let fix = pprust::pat_to_string(&pat);\n+                (msg, fix)\n+            } else {\n+                let msg = \"wrap the pattern in parentheses\";\n+                let fix = format!(\"({})\", pprust::pat_to_string(&pat));\n+                (msg, fix)\n+            };\n+\n+            if trailing_vert {\n+                // We already emitted an error and suggestion to remove the trailing vert. Don't\n+                // emit again.\n+                self.sess.span_diagnostic.delay_span_bug(pat.span, &msg);\n+            } else {\n+                self.struct_span_err(pat.span, &msg)\n+                    .span_suggestion(pat.span, help, fix, Applicability::MachineApplicable)\n+                    .emit();\n+            }\n+        }\n+\n+        Ok((pat, colon))\n+    }\n+\n+    /// Parse the pattern for a function or function pointer parameter, followed by a colon.\n+    ///\n+    /// The return value represents the parsed pattern and `true` if a `Colon` was parsed (`false`\n+    /// otherwise).\n+    pub(super) fn parse_fn_param_pat_colon(&mut self) -> PResult<'a, (P<Pat>, bool)> {\n         // In order to get good UX, we first recover in the case of a leading vert for an illegal\n         // top-level or-pat. Normally, this means recovering both `|` and `||`, but in this case,\n         // a leading `||` probably doesn't indicate an or-pattern attempt, so we handle that\n@@ -128,53 +213,28 @@ impl<'a> Parser<'a> {\n             self.bump();\n         }\n \n-        let pat = self.parse_pat_allow_top_alt(PARAM_EXPECTED, GateOr::No, RecoverComma::No)?;\n-\n-        if let PatKind::Or(..) = &pat.kind {\n-            self.ban_illegal_fn_param_or_pat(&pat);\n-        }\n-\n-        Ok(pat)\n-    }\n-\n-    /// Ban `A | B` immediately in a parameter pattern and suggest wrapping in parens.\n-    fn ban_illegal_fn_param_or_pat(&self, pat: &Pat) {\n-        // If all we have a leading vert, then print a special message. This is the case if\n-        // `parse_pat_allow_top_alt` returns an or-pattern with one variant.\n-        let (msg, fix) = match &pat.kind {\n-            PatKind::Or(pats) if pats.len() == 1 => {\n-                let msg = \"remove the leading `|`\";\n-                let fix = pprust::pat_to_string(pat);\n-                (msg, fix)\n-            }\n-\n-            _ => {\n-                let msg = \"wrap the pattern in parentheses\";\n-                let fix = format!(\"({})\", pprust::pat_to_string(pat));\n-                (msg, fix)\n-            }\n-        };\n-\n-        self.struct_span_err(pat.span, \"an or-pattern parameter must be wrapped in parentheses\")\n-            .span_suggestion(pat.span, msg, fix, Applicability::MachineApplicable)\n-            .emit();\n+        self.parse_pat_before_ty(\n+            PARAM_EXPECTED,\n+            GateOr::No,\n+            RecoverComma::No,\n+            \"function parameters\",\n+        )\n     }\n \n     /// Eat the or-pattern `|` separator.\n     /// If instead a `||` token is encountered, recover and pretend we parsed `|`.\n-    fn eat_or_separator(&mut self, lo: Option<Span>) -> bool {\n+    fn eat_or_separator(&mut self, lo: Option<Span>) -> EatOrResult {\n         if self.recover_trailing_vert(lo) {\n-            return false;\n-        }\n-\n-        match self.token.kind {\n-            token::OrOr => {\n-                // Found `||`; Recover and pretend we parsed `|`.\n-                self.ban_unexpected_or_or(lo);\n-                self.bump();\n-                true\n-            }\n-            _ => self.eat(&token::BinOp(token::Or)),\n+            EatOrResult::TrailingVert\n+        } else if matches!(self.token.kind, token::OrOr) {\n+            // Found `||`; Recover and pretend we parsed `|`.\n+            self.ban_unexpected_or_or(lo);\n+            self.bump();\n+            EatOrResult::AteOr\n+        } else if self.eat(&token::BinOp(token::Or)) {\n+            EatOrResult::AteOr\n+        } else {\n+            EatOrResult::None\n         }\n     }\n \n@@ -190,14 +250,14 @@ impl<'a> Parser<'a> {\n             matches!(\n                 &token.uninterpolate().kind,\n                 token::FatArrow // e.g. `a | => 0,`.\n-            | token::Ident(kw::If, false) // e.g. `a | if expr`.\n-            | token::Eq // e.g. `let a | = 0`.\n-            | token::Semi // e.g. `let a |;`.\n-            | token::Colon // e.g. `let a | :`.\n-            | token::Comma // e.g. `let (a |,)`.\n-            | token::CloseDelim(token::Bracket) // e.g. `let [a | ]`.\n-            | token::CloseDelim(token::Paren) // e.g. `let (a | )`.\n-            | token::CloseDelim(token::Brace) // e.g. `let A { f: a | }`.\n+                | token::Ident(kw::If, false) // e.g. `a | if expr`.\n+                | token::Eq // e.g. `let a | = 0`.\n+                | token::Semi // e.g. `let a |;`.\n+                | token::Colon // e.g. `let a | :`.\n+                | token::Comma // e.g. `let (a |,)`.\n+                | token::CloseDelim(token::Bracket) // e.g. `let [a | ]`.\n+                | token::CloseDelim(token::Paren) // e.g. `let (a | )`.\n+                | token::CloseDelim(token::Brace) // e.g. `let A { f: a | }`.\n             )\n         });\n         match (is_end_ahead, &self.token.kind) {"}, {"sha": "cabe2b95a49f69333604acce6a5f1abcec42e296", "filename": "compiler/rustc_parse/src/parser/stmt.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e64138c534d356e555842ddc9da20a952a20ab46/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64138c534d356e555842ddc9da20a952a20ab46/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs?ref=e64138c534d356e555842ddc9da20a952a20ab46", "patch": "@@ -13,7 +13,8 @@ use rustc_ast::token::{self, TokenKind};\n use rustc_ast::util::classify;\n use rustc_ast::AstLike;\n use rustc_ast::{AttrStyle, AttrVec, Attribute, MacCall, MacCallStmt, MacStmtStyle};\n-use rustc_ast::{Block, BlockCheckMode, Expr, ExprKind, Local, Stmt, StmtKind, DUMMY_NODE_ID};\n+use rustc_ast::{Block, BlockCheckMode, Expr, ExprKind, Local, Stmt};\n+use rustc_ast::{StmtKind, DUMMY_NODE_ID};\n use rustc_errors::{Applicability, PResult};\n use rustc_span::source_map::{BytePos, Span};\n use rustc_span::symbol::{kw, sym};\n@@ -220,9 +221,10 @@ impl<'a> Parser<'a> {\n     /// Parses a local variable declaration.\n     fn parse_local(&mut self, attrs: AttrVec) -> PResult<'a, P<Local>> {\n         let lo = self.prev_token.span;\n-        let pat = self.parse_pat_allow_top_alt(None, GateOr::Yes, RecoverComma::Yes)?;\n+        let (pat, colon) =\n+            self.parse_pat_before_ty(None, GateOr::Yes, RecoverComma::Yes, \"`let` bindings\")?;\n \n-        let (err, ty) = if self.eat(&token::Colon) {\n+        let (err, ty) = if colon {\n             // Save the state of the parser before parsing type normally, in case there is a `:`\n             // instead of an `=` typo.\n             let parser_snapshot_before_type = self.clone();"}, {"sha": "543d7c21c83176a99c601309cae429c080b45aa4", "filename": "src/test/ui/or-patterns/already-bound-name.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e64138c534d356e555842ddc9da20a952a20ab46/src%2Ftest%2Fui%2For-patterns%2Falready-bound-name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64138c534d356e555842ddc9da20a952a20ab46/src%2Ftest%2Fui%2For-patterns%2Falready-bound-name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2Falready-bound-name.rs?ref=e64138c534d356e555842ddc9da20a952a20ab46", "patch": "@@ -18,28 +18,28 @@ fn main() {\n     let (A(a, _) | B(a), a) = (A(0, 1), 2);\n     //~^ ERROR identifier `a` is bound more than once in the same pattern\n \n-    let A(a, a) | B(a) = A(0, 1);\n+    let (A(a, a) | B(a)) = A(0, 1);\n     //~^ ERROR identifier `a` is bound more than once in the same pattern\n \n-    let B(a) | A(a, a) = A(0, 1);\n+    let (B(a) | A(a, a)) = A(0, 1);\n     //~^ ERROR identifier `a` is bound more than once in the same pattern\n \n     match A(0, 1) {\n         B(a) | A(a, a) => {} // Let's ensure `match` has no funny business.\n         //~^ ERROR identifier `a` is bound more than once in the same pattern\n     }\n \n-    let B(A(a, _) | B(a)) | A(a, A(a, _) | B(a)) = B(B(1));\n+    let (B(A(a, _) | B(a)) | A(a, A(a, _) | B(a))) = B(B(1));\n     //~^ ERROR identifier `a` is bound more than once in the same pattern\n     //~| ERROR identifier `a` is bound more than once in the same pattern\n     //~| ERROR mismatched types\n \n-    let B(_) | A(A(a, _) | B(a), A(a, _) | B(a)) = B(B(1));\n+    let (B(_) | A(A(a, _) | B(a), A(a, _) | B(a))) = B(B(1));\n     //~^ ERROR identifier `a` is bound more than once in the same pattern\n     //~| ERROR identifier `a` is bound more than once in the same pattern\n     //~| ERROR variable `a` is not bound in all patterns\n \n-    let B(A(a, _) | B(a)) | A(A(a, _) | B(a), A(a, _) | B(a)) = B(B(1));\n+    let (B(A(a, _) | B(a)) | A(A(a, _) | B(a), A(a, _) | B(a))) = B(B(1));\n     //~^ ERROR identifier `a` is bound more than once in the same pattern\n     //~| ERROR identifier `a` is bound more than once in the same pattern\n }"}, {"sha": "483154a5e3274d754f6f92857410a3d8bc5d2c0d", "filename": "src/test/ui/or-patterns/already-bound-name.stderr", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/e64138c534d356e555842ddc9da20a952a20ab46/src%2Ftest%2Fui%2For-patterns%2Falready-bound-name.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e64138c534d356e555842ddc9da20a952a20ab46/src%2Ftest%2Fui%2For-patterns%2Falready-bound-name.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2Falready-bound-name.stderr?ref=e64138c534d356e555842ddc9da20a952a20ab46", "patch": "@@ -23,16 +23,16 @@ LL |     let (A(a, _) | B(a), a) = (A(0, 1), 2);\n    |                          ^ used in a pattern more than once\n \n error[E0416]: identifier `a` is bound more than once in the same pattern\n-  --> $DIR/already-bound-name.rs:21:14\n+  --> $DIR/already-bound-name.rs:21:15\n    |\n-LL |     let A(a, a) | B(a) = A(0, 1);\n-   |              ^ used in a pattern more than once\n+LL |     let (A(a, a) | B(a)) = A(0, 1);\n+   |               ^ used in a pattern more than once\n \n error[E0416]: identifier `a` is bound more than once in the same pattern\n-  --> $DIR/already-bound-name.rs:24:21\n+  --> $DIR/already-bound-name.rs:24:22\n    |\n-LL |     let B(a) | A(a, a) = A(0, 1);\n-   |                     ^ used in a pattern more than once\n+LL |     let (B(a) | A(a, a)) = A(0, 1);\n+   |                      ^ used in a pattern more than once\n \n error[E0416]: identifier `a` is bound more than once in the same pattern\n   --> $DIR/already-bound-name.rs:28:21\n@@ -41,55 +41,55 @@ LL |         B(a) | A(a, a) => {} // Let's ensure `match` has no funny business.\n    |                     ^ used in a pattern more than once\n \n error[E0416]: identifier `a` is bound more than once in the same pattern\n-  --> $DIR/already-bound-name.rs:32:36\n+  --> $DIR/already-bound-name.rs:32:37\n    |\n-LL |     let B(A(a, _) | B(a)) | A(a, A(a, _) | B(a)) = B(B(1));\n-   |                                    ^ used in a pattern more than once\n+LL |     let (B(A(a, _) | B(a)) | A(a, A(a, _) | B(a))) = B(B(1));\n+   |                                     ^ used in a pattern more than once\n \n error[E0416]: identifier `a` is bound more than once in the same pattern\n-  --> $DIR/already-bound-name.rs:32:46\n+  --> $DIR/already-bound-name.rs:32:47\n    |\n-LL |     let B(A(a, _) | B(a)) | A(a, A(a, _) | B(a)) = B(B(1));\n-   |                                              ^ used in a pattern more than once\n+LL |     let (B(A(a, _) | B(a)) | A(a, A(a, _) | B(a))) = B(B(1));\n+   |                                               ^ used in a pattern more than once\n \n error[E0416]: identifier `a` is bound more than once in the same pattern\n-  --> $DIR/already-bound-name.rs:37:36\n+  --> $DIR/already-bound-name.rs:37:37\n    |\n-LL |     let B(_) | A(A(a, _) | B(a), A(a, _) | B(a)) = B(B(1));\n-   |                                    ^ used in a pattern more than once\n+LL |     let (B(_) | A(A(a, _) | B(a), A(a, _) | B(a))) = B(B(1));\n+   |                                     ^ used in a pattern more than once\n \n error[E0416]: identifier `a` is bound more than once in the same pattern\n-  --> $DIR/already-bound-name.rs:37:46\n+  --> $DIR/already-bound-name.rs:37:47\n    |\n-LL |     let B(_) | A(A(a, _) | B(a), A(a, _) | B(a)) = B(B(1));\n-   |                                              ^ used in a pattern more than once\n+LL |     let (B(_) | A(A(a, _) | B(a), A(a, _) | B(a))) = B(B(1));\n+   |                                               ^ used in a pattern more than once\n \n error[E0408]: variable `a` is not bound in all patterns\n-  --> $DIR/already-bound-name.rs:37:9\n+  --> $DIR/already-bound-name.rs:37:10\n    |\n-LL |     let B(_) | A(A(a, _) | B(a), A(a, _) | B(a)) = B(B(1));\n-   |         ^^^^ pattern doesn't bind `a`        - variable not in all patterns\n+LL |     let (B(_) | A(A(a, _) | B(a), A(a, _) | B(a))) = B(B(1));\n+   |          ^^^^ pattern doesn't bind `a`        - variable not in all patterns\n \n error[E0416]: identifier `a` is bound more than once in the same pattern\n-  --> $DIR/already-bound-name.rs:42:49\n+  --> $DIR/already-bound-name.rs:42:50\n    |\n-LL |     let B(A(a, _) | B(a)) | A(A(a, _) | B(a), A(a, _) | B(a)) = B(B(1));\n-   |                                                 ^ used in a pattern more than once\n+LL |     let (B(A(a, _) | B(a)) | A(A(a, _) | B(a), A(a, _) | B(a))) = B(B(1));\n+   |                                                  ^ used in a pattern more than once\n \n error[E0416]: identifier `a` is bound more than once in the same pattern\n-  --> $DIR/already-bound-name.rs:42:59\n+  --> $DIR/already-bound-name.rs:42:60\n    |\n-LL |     let B(A(a, _) | B(a)) | A(A(a, _) | B(a), A(a, _) | B(a)) = B(B(1));\n-   |                                                           ^ used in a pattern more than once\n+LL |     let (B(A(a, _) | B(a)) | A(A(a, _) | B(a), A(a, _) | B(a))) = B(B(1));\n+   |                                                            ^ used in a pattern more than once\n \n error[E0308]: mismatched types\n-  --> $DIR/already-bound-name.rs:32:31\n+  --> $DIR/already-bound-name.rs:32:32\n    |\n-LL |     let B(A(a, _) | B(a)) | A(a, A(a, _) | B(a)) = B(B(1));\n-   |             -                 ^                    ------- this expression has type `E<E<{integer}>>`\n-   |             |                 |\n-   |             |                 expected integer, found enum `E`\n-   |             first introduced with type `{integer}` here\n+LL |     let (B(A(a, _) | B(a)) | A(a, A(a, _) | B(a))) = B(B(1));\n+   |              -                 ^                     ------- this expression has type `E<E<{integer}>>`\n+   |              |                 |\n+   |              |                 expected integer, found enum `E`\n+   |              first introduced with type `{integer}` here\n    |\n    = note: expected type `{integer}`\n               found type `E<{integer}>`"}, {"sha": "853ddcf2412328dce1d0bbc08d0b0f7cf2c48ee0", "filename": "src/test/ui/or-patterns/consistent-bindings.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e64138c534d356e555842ddc9da20a952a20ab46/src%2Ftest%2Fui%2For-patterns%2Fconsistent-bindings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64138c534d356e555842ddc9da20a952a20ab46/src%2Ftest%2Fui%2For-patterns%2Fconsistent-bindings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2Fconsistent-bindings.rs?ref=e64138c534d356e555842ddc9da20a952a20ab46", "patch": "@@ -8,9 +8,9 @@\n \n fn main() {\n     // One level:\n-    let Ok(a) | Err(a) = Ok(0);\n-    let Ok(ref a) | Err(ref a) = Ok(0);\n-    let Ok(ref mut a) | Err(ref mut a) = Ok(0);\n+    let (Ok(a) | Err(a)) = Ok(0);\n+    let (Ok(ref a) | Err(ref a)) = Ok(0);\n+    let (Ok(ref mut a) | Err(ref mut a)) = Ok(0);\n \n     // Two levels:\n     enum Tri<S, T, U> {\n@@ -20,10 +20,10 @@ fn main() {\n     }\n     use Tri::*;\n \n-    let Ok((V1(a) | V2(a) | V3(a), b)) | Err(Ok((a, b)) | Err((a, b))): Result<_, Result<_, _>> =\n+    let (Ok((V1(a) | V2(a) | V3(a), b)) | Err(Ok((a, b)) | Err((a, b)))): Result<_, Result<_, _>> =\n         Ok((V1(1), 1));\n \n-    let Ok((V1(a) | V2(a) | V3(a), ref b)) | Err(Ok((a, ref b)) | Err((a, ref b))): Result<\n+    let (Ok((V1(a) | V2(a) | V3(a), ref b)) | Err(Ok((a, ref b)) | Err((a, ref b)))): Result<\n         _,\n         Result<_, _>,\n     > = Ok((V1(1), 1));"}, {"sha": "55c6f60915fa829199beb2752fa08a13f26c1088", "filename": "src/test/ui/or-patterns/const-fn.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e64138c534d356e555842ddc9da20a952a20ab46/src%2Ftest%2Fui%2For-patterns%2Fconst-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64138c534d356e555842ddc9da20a952a20ab46/src%2Ftest%2Fui%2For-patterns%2Fconst-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2Fconst-fn.rs?ref=e64138c534d356e555842ddc9da20a952a20ab46", "patch": "@@ -3,28 +3,28 @@\n \n const fn foo((Ok(a) | Err(a)): Result<i32, i32>) {\n     let x = Ok(3);\n-    let Ok(y) | Err(y) = x;\n+    let (Ok(y) | Err(y)) = x;\n }\n \n const X: () = {\n     let x = Ok(3);\n-    let Ok(y) | Err(y) = x;\n+    let (Ok(y) | Err(y)) = x;\n };\n \n static Y: () = {\n     let x = Ok(3);\n-    let Ok(y) | Err(y) = x;\n+    let (Ok(y) | Err(y)) = x;\n };\n \n static mut Z: () = {\n     let x = Ok(3);\n-    let Ok(y) | Err(y) = x;\n+    let (Ok(y) | Err(y)) = x;\n };\n \n fn main() {\n     let _: [(); {\n         let x = Ok(3);\n-        let Ok(y) | Err(y) = x;\n+        let (Ok(y) | Err(y)) = x;\n         2\n     }];\n }"}, {"sha": "6c592550ec25705e2c5e1704bf8b152f80cb9f22", "filename": "src/test/ui/or-patterns/feature-gate-or_patterns-leading-let.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e64138c534d356e555842ddc9da20a952a20ab46/src%2Ftest%2Fui%2For-patterns%2Ffeature-gate-or_patterns-leading-let.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64138c534d356e555842ddc9da20a952a20ab46/src%2Ftest%2Fui%2For-patterns%2Ffeature-gate-or_patterns-leading-let.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2Ffeature-gate-or_patterns-leading-let.rs?ref=e64138c534d356e555842ddc9da20a952a20ab46", "patch": "@@ -5,4 +5,5 @@ fn main() {}\n #[cfg(FALSE)]\n fn gated_leading_vert_in_let() {\n     let | A; //~ ERROR or-patterns syntax is experimental\n+    //~^ ERROR top-level or-patterns are not allowed\n }"}, {"sha": "d556532cd6ad8bade1914fe93d4b60e44ffeab7c", "filename": "src/test/ui/or-patterns/feature-gate-or_patterns-leading-let.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e64138c534d356e555842ddc9da20a952a20ab46/src%2Ftest%2Fui%2For-patterns%2Ffeature-gate-or_patterns-leading-let.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e64138c534d356e555842ddc9da20a952a20ab46/src%2Ftest%2Fui%2For-patterns%2Ffeature-gate-or_patterns-leading-let.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2Ffeature-gate-or_patterns-leading-let.stderr?ref=e64138c534d356e555842ddc9da20a952a20ab46", "patch": "@@ -1,3 +1,9 @@\n+error: top-level or-patterns are not allowed in `let` bindings\n+  --> $DIR/feature-gate-or_patterns-leading-let.rs:7:9\n+   |\n+LL |     let | A;\n+   |         ^^^ help: remove the `|`: `A`\n+\n error[E0658]: or-patterns syntax is experimental\n   --> $DIR/feature-gate-or_patterns-leading-let.rs:7:9\n    |\n@@ -7,6 +13,6 @@ LL |     let | A;\n    = note: see issue #54883 <https://github.com/rust-lang/rust/issues/54883> for more information\n    = help: add `#![feature(or_patterns)]` to the crate attributes to enable\n \n-error: aborting due to previous error\n+error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0658`."}, {"sha": "8bb45e606be965dbccf792a83d984ec24c5f3bf3", "filename": "src/test/ui/or-patterns/feature-gate-or_patterns.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e64138c534d356e555842ddc9da20a952a20ab46/src%2Ftest%2Fui%2For-patterns%2Ffeature-gate-or_patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64138c534d356e555842ddc9da20a952a20ab46/src%2Ftest%2Fui%2For-patterns%2Ffeature-gate-or_patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2Ffeature-gate-or_patterns.rs?ref=e64138c534d356e555842ddc9da20a952a20ab46", "patch": "@@ -26,7 +26,9 @@ fn or_patterns() {\n     // Gated:\n \n     let | A | B; //~ ERROR or-patterns syntax is experimental\n+    //~^ ERROR top-level or-patterns are not allowed\n     let A | B; //~ ERROR or-patterns syntax is experimental\n+    //~^ ERROR top-level or-patterns are not allowed\n     for | A | B in 0 {} //~ ERROR or-patterns syntax is experimental\n     for A | B in 0 {} //~ ERROR or-patterns syntax is experimental\n     fn fun((A | B): _) {} //~ ERROR or-patterns syntax is experimental"}, {"sha": "7988af5b94213639ad4db93565ad7b211825b495", "filename": "src/test/ui/or-patterns/feature-gate-or_patterns.stderr", "status": "modified", "additions": 25, "deletions": 13, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/e64138c534d356e555842ddc9da20a952a20ab46/src%2Ftest%2Fui%2For-patterns%2Ffeature-gate-or_patterns.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e64138c534d356e555842ddc9da20a952a20ab46/src%2Ftest%2Fui%2For-patterns%2Ffeature-gate-or_patterns.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2Ffeature-gate-or_patterns.stderr?ref=e64138c534d356e555842ddc9da20a952a20ab46", "patch": "@@ -1,3 +1,15 @@\n+error: top-level or-patterns are not allowed in `let` bindings\n+  --> $DIR/feature-gate-or_patterns.rs:28:9\n+   |\n+LL |     let | A | B;\n+   |         ^^^^^^^ help: wrap the pattern in parentheses: `(A | B)`\n+\n+error: top-level or-patterns are not allowed in `let` bindings\n+  --> $DIR/feature-gate-or_patterns.rs:30:9\n+   |\n+LL |     let A | B;\n+   |         ^^^^^ help: wrap the pattern in parentheses: `(A | B)`\n+\n error[E0658]: or-patterns syntax is experimental\n   --> $DIR/feature-gate-or_patterns.rs:5:14\n    |\n@@ -17,7 +29,7 @@ LL |     let | A | B;\n    = help: add `#![feature(or_patterns)]` to the crate attributes to enable\n \n error[E0658]: or-patterns syntax is experimental\n-  --> $DIR/feature-gate-or_patterns.rs:29:9\n+  --> $DIR/feature-gate-or_patterns.rs:30:9\n    |\n LL |     let A | B;\n    |         ^^^^^\n@@ -26,7 +38,7 @@ LL |     let A | B;\n    = help: add `#![feature(or_patterns)]` to the crate attributes to enable\n \n error[E0658]: or-patterns syntax is experimental\n-  --> $DIR/feature-gate-or_patterns.rs:30:9\n+  --> $DIR/feature-gate-or_patterns.rs:32:9\n    |\n LL |     for | A | B in 0 {}\n    |         ^^^^^^^\n@@ -35,7 +47,7 @@ LL |     for | A | B in 0 {}\n    = help: add `#![feature(or_patterns)]` to the crate attributes to enable\n \n error[E0658]: or-patterns syntax is experimental\n-  --> $DIR/feature-gate-or_patterns.rs:31:9\n+  --> $DIR/feature-gate-or_patterns.rs:33:9\n    |\n LL |     for A | B in 0 {}\n    |         ^^^^^\n@@ -44,7 +56,7 @@ LL |     for A | B in 0 {}\n    = help: add `#![feature(or_patterns)]` to the crate attributes to enable\n \n error[E0658]: or-patterns syntax is experimental\n-  --> $DIR/feature-gate-or_patterns.rs:32:13\n+  --> $DIR/feature-gate-or_patterns.rs:34:13\n    |\n LL |     fn fun((A | B): _) {}\n    |             ^^^^^\n@@ -53,7 +65,7 @@ LL |     fn fun((A | B): _) {}\n    = help: add `#![feature(or_patterns)]` to the crate attributes to enable\n \n error[E0658]: or-patterns syntax is experimental\n-  --> $DIR/feature-gate-or_patterns.rs:33:15\n+  --> $DIR/feature-gate-or_patterns.rs:35:15\n    |\n LL |     let _ = |(A | B): u8| ();\n    |               ^^^^^\n@@ -62,7 +74,7 @@ LL |     let _ = |(A | B): u8| ();\n    = help: add `#![feature(or_patterns)]` to the crate attributes to enable\n \n error[E0658]: or-patterns syntax is experimental\n-  --> $DIR/feature-gate-or_patterns.rs:34:10\n+  --> $DIR/feature-gate-or_patterns.rs:36:10\n    |\n LL |     let (A | B);\n    |          ^^^^^\n@@ -71,7 +83,7 @@ LL |     let (A | B);\n    = help: add `#![feature(or_patterns)]` to the crate attributes to enable\n \n error[E0658]: or-patterns syntax is experimental\n-  --> $DIR/feature-gate-or_patterns.rs:35:10\n+  --> $DIR/feature-gate-or_patterns.rs:37:10\n    |\n LL |     let (A | B,);\n    |          ^^^^^\n@@ -80,7 +92,7 @@ LL |     let (A | B,);\n    = help: add `#![feature(or_patterns)]` to the crate attributes to enable\n \n error[E0658]: or-patterns syntax is experimental\n-  --> $DIR/feature-gate-or_patterns.rs:36:11\n+  --> $DIR/feature-gate-or_patterns.rs:38:11\n    |\n LL |     let A(B | C);\n    |           ^^^^^\n@@ -89,7 +101,7 @@ LL |     let A(B | C);\n    = help: add `#![feature(or_patterns)]` to the crate attributes to enable\n \n error[E0658]: or-patterns syntax is experimental\n-  --> $DIR/feature-gate-or_patterns.rs:37:14\n+  --> $DIR/feature-gate-or_patterns.rs:39:14\n    |\n LL |     let E::V(B | C);\n    |              ^^^^^\n@@ -98,7 +110,7 @@ LL |     let E::V(B | C);\n    = help: add `#![feature(or_patterns)]` to the crate attributes to enable\n \n error[E0658]: or-patterns syntax is experimental\n-  --> $DIR/feature-gate-or_patterns.rs:38:17\n+  --> $DIR/feature-gate-or_patterns.rs:40:17\n    |\n LL |     let S { f1: B | C, f2 };\n    |                 ^^^^^\n@@ -107,7 +119,7 @@ LL |     let S { f1: B | C, f2 };\n    = help: add `#![feature(or_patterns)]` to the crate attributes to enable\n \n error[E0658]: or-patterns syntax is experimental\n-  --> $DIR/feature-gate-or_patterns.rs:39:20\n+  --> $DIR/feature-gate-or_patterns.rs:41:20\n    |\n LL |     let E::V { f1: B | C, f2 };\n    |                    ^^^^^\n@@ -116,7 +128,7 @@ LL |     let E::V { f1: B | C, f2 };\n    = help: add `#![feature(or_patterns)]` to the crate attributes to enable\n \n error[E0658]: or-patterns syntax is experimental\n-  --> $DIR/feature-gate-or_patterns.rs:40:10\n+  --> $DIR/feature-gate-or_patterns.rs:42:10\n    |\n LL |     let [A | B];\n    |          ^^^^^\n@@ -169,6 +181,6 @@ LL | accept_pat!([p | q]);\n    = note: see issue #54883 <https://github.com/rust-lang/rust/issues/54883> for more information\n    = help: add `#![feature(or_patterns)]` to the crate attributes to enable\n \n-error: aborting due to 19 previous errors\n+error: aborting due to 21 previous errors\n \n For more information about this error, try `rustc --explain E0658`."}, {"sha": "65e04325e16bdb7430d9721c9f603871cd58e3b6", "filename": "src/test/ui/or-patterns/fn-param-wrap-parens.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e64138c534d356e555842ddc9da20a952a20ab46/src%2Ftest%2Fui%2For-patterns%2Ffn-param-wrap-parens.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/e64138c534d356e555842ddc9da20a952a20ab46/src%2Ftest%2Fui%2For-patterns%2Ffn-param-wrap-parens.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2Ffn-param-wrap-parens.fixed?ref=e64138c534d356e555842ddc9da20a952a20ab46", "patch": "@@ -11,4 +11,4 @@ enum E { A, B }\n use E::*;\n \n #[cfg(FALSE)]\n-fn fun1((A | B): E) {} //~ ERROR an or-pattern parameter must be wrapped in parentheses\n+fn fun1((A | B): E) {} //~ ERROR top-level or-patterns are not allowed"}, {"sha": "aeb4a05ea808ea4055c48f340bbbd90cfe1be64b", "filename": "src/test/ui/or-patterns/fn-param-wrap-parens.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e64138c534d356e555842ddc9da20a952a20ab46/src%2Ftest%2Fui%2For-patterns%2Ffn-param-wrap-parens.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64138c534d356e555842ddc9da20a952a20ab46/src%2Ftest%2Fui%2For-patterns%2Ffn-param-wrap-parens.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2Ffn-param-wrap-parens.rs?ref=e64138c534d356e555842ddc9da20a952a20ab46", "patch": "@@ -11,4 +11,4 @@ enum E { A, B }\n use E::*;\n \n #[cfg(FALSE)]\n-fn fun1(A | B: E) {} //~ ERROR an or-pattern parameter must be wrapped in parentheses\n+fn fun1(A | B: E) {} //~ ERROR top-level or-patterns are not allowed"}, {"sha": "96193c17ae23feaa1624f4d92020ec3a98443276", "filename": "src/test/ui/or-patterns/fn-param-wrap-parens.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e64138c534d356e555842ddc9da20a952a20ab46/src%2Ftest%2Fui%2For-patterns%2Ffn-param-wrap-parens.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e64138c534d356e555842ddc9da20a952a20ab46/src%2Ftest%2Fui%2For-patterns%2Ffn-param-wrap-parens.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2Ffn-param-wrap-parens.stderr?ref=e64138c534d356e555842ddc9da20a952a20ab46", "patch": "@@ -1,4 +1,4 @@\n-error: an or-pattern parameter must be wrapped in parentheses\n+error: top-level or-patterns are not allowed in function parameters\n   --> $DIR/fn-param-wrap-parens.rs:14:9\n    |\n LL | fn fun1(A | B: E) {}"}, {"sha": "2300e9f9f3b7b40b4454bb4dcc1db5ee7378fa41", "filename": "src/test/ui/or-patterns/inconsistent-modes.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e64138c534d356e555842ddc9da20a952a20ab46/src%2Ftest%2Fui%2For-patterns%2Finconsistent-modes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64138c534d356e555842ddc9da20a952a20ab46/src%2Ftest%2Fui%2For-patterns%2Finconsistent-modes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2Finconsistent-modes.rs?ref=e64138c534d356e555842ddc9da20a952a20ab46", "patch": "@@ -4,23 +4,23 @@\n #![allow(non_camel_case_types)]\n fn main() {\n     // One level:\n-    let Ok(a) | Err(ref a): Result<&u8, u8> = Ok(&0);\n+    let (Ok(a) | Err(ref a)): Result<&u8, u8> = Ok(&0);\n     //~^ ERROR variable `a` is bound inconsistently\n-    let Ok(ref mut a) | Err(a): Result<u8, &mut u8> = Ok(0);\n+    let (Ok(ref mut a) | Err(a)): Result<u8, &mut u8> = Ok(0);\n     //~^ ERROR variable `a` is bound inconsistently\n-    let Ok(ref a) | Err(ref mut a): Result<&u8, &mut u8> = Ok(&0);\n+    let (Ok(ref a) | Err(ref mut a)): Result<&u8, &mut u8> = Ok(&0);\n     //~^ ERROR variable `a` is bound inconsistently\n     //~| ERROR mismatched types\n-    let Ok((ref a, b)) | Err((ref mut a, ref b)) = Ok((0, &0));\n+    let (Ok((ref a, b)) | Err((ref mut a, ref b))) = Ok((0, &0));\n     //~^ ERROR variable `a` is bound inconsistently\n     //~| ERROR variable `b` is bound inconsistently\n     //~| ERROR mismatched types\n \n     // Two levels:\n-    let Ok(Ok(a) | Err(a)) | Err(ref a) = Err(0);\n+    let (Ok(Ok(a) | Err(a)) | Err(ref a)) = Err(0);\n     //~^ ERROR variable `a` is bound inconsistently\n \n     // Three levels:\n-    let Ok([Ok((Ok(ref a) | Err(a),)) | Err(a)]) | Err(a) = Err(&1);\n+    let (Ok([Ok((Ok(ref a) | Err(a),)) | Err(a)]) | Err(a)) = Err(&1);\n     //~^ ERROR variable `a` is bound inconsistently\n }"}, {"sha": "99791431eaf25bcb8cee5fbf5f71fb3e38d39aca", "filename": "src/test/ui/or-patterns/inconsistent-modes.stderr", "status": "modified", "additions": 41, "deletions": 41, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/e64138c534d356e555842ddc9da20a952a20ab46/src%2Ftest%2Fui%2For-patterns%2Finconsistent-modes.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e64138c534d356e555842ddc9da20a952a20ab46/src%2Ftest%2Fui%2For-patterns%2Finconsistent-modes.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2Finconsistent-modes.stderr?ref=e64138c534d356e555842ddc9da20a952a20ab46", "patch": "@@ -1,74 +1,74 @@\n error[E0409]: variable `a` is bound inconsistently across alternatives separated by `|`\n-  --> $DIR/inconsistent-modes.rs:7:25\n+  --> $DIR/inconsistent-modes.rs:7:26\n    |\n-LL |     let Ok(a) | Err(ref a): Result<&u8, u8> = Ok(&0);\n-   |            -            ^ bound in different ways\n-   |            |\n-   |            first binding\n+LL |     let (Ok(a) | Err(ref a)): Result<&u8, u8> = Ok(&0);\n+   |             -            ^ bound in different ways\n+   |             |\n+   |             first binding\n \n error[E0409]: variable `a` is bound inconsistently across alternatives separated by `|`\n-  --> $DIR/inconsistent-modes.rs:9:29\n+  --> $DIR/inconsistent-modes.rs:9:30\n    |\n-LL |     let Ok(ref mut a) | Err(a): Result<u8, &mut u8> = Ok(0);\n-   |                    -        ^ bound in different ways\n-   |                    |\n-   |                    first binding\n+LL |     let (Ok(ref mut a) | Err(a)): Result<u8, &mut u8> = Ok(0);\n+   |                     -        ^ bound in different ways\n+   |                     |\n+   |                     first binding\n \n error[E0409]: variable `a` is bound inconsistently across alternatives separated by `|`\n-  --> $DIR/inconsistent-modes.rs:11:33\n+  --> $DIR/inconsistent-modes.rs:11:34\n    |\n-LL |     let Ok(ref a) | Err(ref mut a): Result<&u8, &mut u8> = Ok(&0);\n-   |                - first binding  ^ bound in different ways\n+LL |     let (Ok(ref a) | Err(ref mut a)): Result<&u8, &mut u8> = Ok(&0);\n+   |                 - first binding  ^ bound in different ways\n \n error[E0409]: variable `a` is bound inconsistently across alternatives separated by `|`\n-  --> $DIR/inconsistent-modes.rs:14:39\n+  --> $DIR/inconsistent-modes.rs:14:40\n    |\n-LL |     let Ok((ref a, b)) | Err((ref mut a, ref b)) = Ok((0, &0));\n-   |                 - first binding       ^ bound in different ways\n+LL |     let (Ok((ref a, b)) | Err((ref mut a, ref b))) = Ok((0, &0));\n+   |                  - first binding       ^ bound in different ways\n \n error[E0409]: variable `b` is bound inconsistently across alternatives separated by `|`\n-  --> $DIR/inconsistent-modes.rs:14:46\n+  --> $DIR/inconsistent-modes.rs:14:47\n    |\n-LL |     let Ok((ref a, b)) | Err((ref mut a, ref b)) = Ok((0, &0));\n-   |                    - first binding           ^ bound in different ways\n+LL |     let (Ok((ref a, b)) | Err((ref mut a, ref b))) = Ok((0, &0));\n+   |                     - first binding           ^ bound in different ways\n \n error[E0409]: variable `a` is bound inconsistently across alternatives separated by `|`\n-  --> $DIR/inconsistent-modes.rs:20:38\n+  --> $DIR/inconsistent-modes.rs:20:39\n    |\n-LL |     let Ok(Ok(a) | Err(a)) | Err(ref a) = Err(0);\n-   |                        -             ^ bound in different ways\n-   |                        |\n-   |                        first binding\n+LL |     let (Ok(Ok(a) | Err(a)) | Err(ref a)) = Err(0);\n+   |                         -             ^ bound in different ways\n+   |                         |\n+   |                         first binding\n \n error[E0409]: variable `a` is bound inconsistently across alternatives separated by `|`\n-  --> $DIR/inconsistent-modes.rs:24:33\n+  --> $DIR/inconsistent-modes.rs:24:34\n    |\n-LL |     let Ok([Ok((Ok(ref a) | Err(a),)) | Err(a)]) | Err(a) = Err(&1);\n-   |                        -        ^ bound in different ways\n-   |                        |\n-   |                        first binding\n+LL |     let (Ok([Ok((Ok(ref a) | Err(a),)) | Err(a)]) | Err(a)) = Err(&1);\n+   |                         -        ^ bound in different ways\n+   |                         |\n+   |                         first binding\n \n error[E0308]: mismatched types\n-  --> $DIR/inconsistent-modes.rs:11:25\n+  --> $DIR/inconsistent-modes.rs:11:26\n    |\n-LL |     let Ok(ref a) | Err(ref mut a): Result<&u8, &mut u8> = Ok(&0);\n-   |            -----        ^^^^^^^^^   -------------------- expected due to this\n-   |            |            |\n-   |            |            types differ in mutability\n-   |            first introduced with type `&&u8` here\n+LL |     let (Ok(ref a) | Err(ref mut a)): Result<&u8, &mut u8> = Ok(&0);\n+   |             -----        ^^^^^^^^^    -------------------- expected due to this\n+   |             |            |\n+   |             |            types differ in mutability\n+   |             first introduced with type `&&u8` here\n    |\n    = note: expected type `&&u8`\n               found type `&mut &mut u8`\n    = note: a binding must have the same type in all alternatives\n \n error[E0308]: mismatched types\n-  --> $DIR/inconsistent-modes.rs:14:31\n+  --> $DIR/inconsistent-modes.rs:14:32\n    |\n-LL |     let Ok((ref a, b)) | Err((ref mut a, ref b)) = Ok((0, &0));\n-   |             -----             ^^^^^^^^^            ----------- this expression has type `Result<({integer}, &{integer}), (_, _)>`\n-   |             |                 |\n-   |             |                 types differ in mutability\n-   |             first introduced with type `&{integer}` here\n+LL |     let (Ok((ref a, b)) | Err((ref mut a, ref b))) = Ok((0, &0));\n+   |              -----             ^^^^^^^^^             ----------- this expression has type `Result<({integer}, &{integer}), (_, _)>`\n+   |              |                 |\n+   |              |                 types differ in mutability\n+   |              first introduced with type `&{integer}` here\n    |\n    = note: expected type `&{integer}`\n               found type `&mut _`"}, {"sha": "8e83acc6dcbc00a2e391f77981afca30153d11d7", "filename": "src/test/ui/or-patterns/issue-69875-should-have-been-expanded-earlier-non-exhaustive.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e64138c534d356e555842ddc9da20a952a20ab46/src%2Ftest%2Fui%2For-patterns%2Fissue-69875-should-have-been-expanded-earlier-non-exhaustive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64138c534d356e555842ddc9da20a952a20ab46/src%2Ftest%2Fui%2For-patterns%2Fissue-69875-should-have-been-expanded-earlier-non-exhaustive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2Fissue-69875-should-have-been-expanded-earlier-non-exhaustive.rs?ref=e64138c534d356e555842ddc9da20a952a20ab46", "patch": "@@ -1,7 +1,7 @@\n #![feature(or_patterns)]\n \n fn main() {\n-    let 0 | (1 | 2) = 0; //~ ERROR refutable pattern in local binding\n+    let (0 | (1 | 2)) = 0; //~ ERROR refutable pattern in local binding\n     match 0 {\n         //~^ ERROR non-exhaustive patterns\n         0 | (1 | 2) => {}"}, {"sha": "9ed942d9e0fd5c3fd718e1fef9d11cb60b9846ad", "filename": "src/test/ui/or-patterns/issue-69875-should-have-been-expanded-earlier-non-exhaustive.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e64138c534d356e555842ddc9da20a952a20ab46/src%2Ftest%2Fui%2For-patterns%2Fissue-69875-should-have-been-expanded-earlier-non-exhaustive.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e64138c534d356e555842ddc9da20a952a20ab46/src%2Ftest%2Fui%2For-patterns%2Fissue-69875-should-have-been-expanded-earlier-non-exhaustive.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2Fissue-69875-should-have-been-expanded-earlier-non-exhaustive.stderr?ref=e64138c534d356e555842ddc9da20a952a20ab46", "patch": "@@ -1,16 +1,16 @@\n error[E0005]: refutable pattern in local binding: `i32::MIN..=-1_i32` and `3_i32..=i32::MAX` not covered\n-  --> $DIR/issue-69875-should-have-been-expanded-earlier-non-exhaustive.rs:4:9\n+  --> $DIR/issue-69875-should-have-been-expanded-earlier-non-exhaustive.rs:4:10\n    |\n-LL |     let 0 | (1 | 2) = 0;\n-   |         ^^^^^^^^^^^ patterns `i32::MIN..=-1_i32` and `3_i32..=i32::MAX` not covered\n+LL |     let (0 | (1 | 2)) = 0;\n+   |          ^^^^^^^^^^^ patterns `i32::MIN..=-1_i32` and `3_i32..=i32::MAX` not covered\n    |\n    = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n    = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n    = note: the matched value is of type `i32`\n help: you might want to use `if let` to ignore the variant that isn't matched\n    |\n-LL |     if let 0 | (1 | 2) = 0 { /* */ }\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     if let (0 | (1 | 2)) = 0 { /* */ }\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0004]: non-exhaustive patterns: `i32::MIN..=-1_i32` and `3_i32..=i32::MAX` not covered\n   --> $DIR/issue-69875-should-have-been-expanded-earlier-non-exhaustive.rs:5:11"}, {"sha": "2f080ebf7830b78b22afd72d764a65b5dd25f4bf", "filename": "src/test/ui/or-patterns/issue-69875-should-have-been-expanded-earlier.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e64138c534d356e555842ddc9da20a952a20ab46/src%2Ftest%2Fui%2For-patterns%2Fissue-69875-should-have-been-expanded-earlier.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64138c534d356e555842ddc9da20a952a20ab46/src%2Ftest%2Fui%2For-patterns%2Fissue-69875-should-have-been-expanded-earlier.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2Fissue-69875-should-have-been-expanded-earlier.rs?ref=e64138c534d356e555842ddc9da20a952a20ab46", "patch": "@@ -3,7 +3,7 @@\n #![feature(or_patterns)]\n \n fn main() {\n-    let 0 | (1 | _) = 0;\n+    let (0 | (1 | _)) = 0;\n     if let 0 | (1 | 2) = 0 {}\n     if let x @ 0 | x @ (1 | 2) = 0 {}\n }"}, {"sha": "7f22aa9d9f98003b8ca3351fa07cd36f947e3aaf", "filename": "src/test/ui/or-patterns/let-pattern.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e64138c534d356e555842ddc9da20a952a20ab46/src%2Ftest%2Fui%2For-patterns%2Flet-pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64138c534d356e555842ddc9da20a952a20ab46/src%2Ftest%2Fui%2For-patterns%2Flet-pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2Flet-pattern.rs?ref=e64138c534d356e555842ddc9da20a952a20ab46", "patch": "@@ -3,7 +3,7 @@\n // run-pass\n \n fn or_pat_let(x: Result<u32, u32>) -> u32 {\n-    let Ok(y) | Err(y) = x;\n+    let (Ok(y) | Err(y)) = x;\n     y\n }\n "}, {"sha": "cf98a472106e804ef9145a70583d3e1f5abb52de", "filename": "src/test/ui/or-patterns/mismatched-bindings-async-fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e64138c534d356e555842ddc9da20a952a20ab46/src%2Ftest%2Fui%2For-patterns%2Fmismatched-bindings-async-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64138c534d356e555842ddc9da20a952a20ab46/src%2Ftest%2Fui%2For-patterns%2Fmismatched-bindings-async-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2Fmismatched-bindings-async-fn.rs?ref=e64138c534d356e555842ddc9da20a952a20ab46", "patch": "@@ -8,7 +8,7 @@ async fn a((x | s): String) {}\n //~| ERROR variable `s` is not bound in all patterns\n \n async fn b() {\n-    let x | s = String::new();\n+    let (x | s) = String::new();\n     //~^ ERROR variable `x` is not bound in all patterns\n     //~| ERROR variable `s` is not bound in all patterns\n }"}, {"sha": "d5c77ee39c99cc23802dc791400b54fe2c9346d8", "filename": "src/test/ui/or-patterns/mismatched-bindings-async-fn.stderr", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e64138c534d356e555842ddc9da20a952a20ab46/src%2Ftest%2Fui%2For-patterns%2Fmismatched-bindings-async-fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e64138c534d356e555842ddc9da20a952a20ab46/src%2Ftest%2Fui%2For-patterns%2Fmismatched-bindings-async-fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2Fmismatched-bindings-async-fn.stderr?ref=e64138c534d356e555842ddc9da20a952a20ab46", "patch": "@@ -15,20 +15,20 @@ LL | async fn a((x | s): String) {}\n    |             variable not in all patterns\n \n error[E0408]: variable `s` is not bound in all patterns\n-  --> $DIR/mismatched-bindings-async-fn.rs:11:9\n+  --> $DIR/mismatched-bindings-async-fn.rs:11:10\n    |\n-LL |     let x | s = String::new();\n-   |         ^   - variable not in all patterns\n-   |         |\n-   |         pattern doesn't bind `s`\n+LL |     let (x | s) = String::new();\n+   |          ^   - variable not in all patterns\n+   |          |\n+   |          pattern doesn't bind `s`\n \n error[E0408]: variable `x` is not bound in all patterns\n-  --> $DIR/mismatched-bindings-async-fn.rs:11:13\n+  --> $DIR/mismatched-bindings-async-fn.rs:11:14\n    |\n-LL |     let x | s = String::new();\n-   |         -   ^ pattern doesn't bind `x`\n-   |         |\n-   |         variable not in all patterns\n+LL |     let (x | s) = String::new();\n+   |          -   ^ pattern doesn't bind `x`\n+   |          |\n+   |          variable not in all patterns\n \n error: aborting due to 4 previous errors\n "}, {"sha": "5dd1f16b655802fcd94fbfc7e356ffda3d7b6c37", "filename": "src/test/ui/or-patterns/missing-bindings.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e64138c534d356e555842ddc9da20a952a20ab46/src%2Ftest%2Fui%2For-patterns%2Fmissing-bindings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64138c534d356e555842ddc9da20a952a20ab46/src%2Ftest%2Fui%2For-patterns%2Fmissing-bindings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2Fmissing-bindings.rs?ref=e64138c534d356e555842ddc9da20a952a20ab46", "patch": "@@ -17,7 +17,7 @@ fn check_handling_of_paths() {\n     }\n \n     use bar::foo::{alpha, charlie};\n-    let alpha | beta | charlie = alpha; //~  ERROR variable `beta` is not bound in all patterns\n+    let (alpha | beta | charlie) = alpha; //~  ERROR variable `beta` is not bound in all patterns\n     match Some(alpha) {\n         Some(alpha | beta) => {} //~ ERROR variable `beta` is not bound in all patterns\n     }\n@@ -31,19 +31,19 @@ fn check_misc_nesting() {\n \n     // One level:\n     const X: E<u8> = B(0);\n-    let A(a, _) | _ = X; //~ ERROR variable `a` is not bound in all patterns\n-    let _ | B(a) = X; //~ ERROR variable `a` is not bound in all patterns\n-    let A(..) | B(a) = X; //~ ERROR variable `a` is not bound in all patterns\n-    let A(a, _) | B(_) = X; //~ ERROR variable `a` is not bound in all patterns\n-    let A(_, a) | B(_) = X; //~ ERROR variable `a` is not bound in all patterns\n-    let A(a, b) | B(a) = X; //~ ERROR variable `b` is not bound in all patterns\n+    let (A(a, _) | _) = X; //~ ERROR variable `a` is not bound in all patterns\n+    let (_ | B(a)) = X; //~ ERROR variable `a` is not bound in all patterns\n+    let (A(..) | B(a)) = X; //~ ERROR variable `a` is not bound in all patterns\n+    let (A(a, _) | B(_)) = X; //~ ERROR variable `a` is not bound in all patterns\n+    let (A(_, a) | B(_)) = X; //~ ERROR variable `a` is not bound in all patterns\n+    let (A(a, b) | B(a)) = X; //~ ERROR variable `b` is not bound in all patterns\n \n     // Two levels:\n     const Y: E<E<u8>> = B(B(0));\n-    let A(A(..) | B(_), _) | B(a) = Y; //~ ERROR variable `a` is not bound in all patterns\n-    let A(A(..) | B(a), _) | B(A(a, _) | B(a)) = Y;\n+    let (A(A(..) | B(_), _) | B(a)) = Y; //~ ERROR variable `a` is not bound in all patterns\n+    let (A(A(..) | B(a), _) | B(A(a, _) | B(a))) = Y;\n     //~^ ERROR variable `a` is not bound in all patterns\n-    let A(A(a, b) | B(c), d) | B(e) = Y;\n+    let (A(A(a, b) | B(c), d) | B(e)) = Y;\n     //~^ ERROR variable `a` is not bound in all patterns\n     //~| ERROR variable `a` is not bound in all patterns\n     //~| ERROR variable `b` is not bound in all patterns"}, {"sha": "4702bc6bbf3224dd716f32aa321eb03438ed3664", "filename": "src/test/ui/or-patterns/missing-bindings.stderr", "status": "modified", "additions": 86, "deletions": 86, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/e64138c534d356e555842ddc9da20a952a20ab46/src%2Ftest%2Fui%2For-patterns%2Fmissing-bindings.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e64138c534d356e555842ddc9da20a952a20ab46/src%2Ftest%2Fui%2For-patterns%2Fmissing-bindings.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2Fmissing-bindings.stderr?ref=e64138c534d356e555842ddc9da20a952a20ab46", "patch": "@@ -1,11 +1,11 @@\n error[E0408]: variable `beta` is not bound in all patterns\n-  --> $DIR/missing-bindings.rs:20:9\n+  --> $DIR/missing-bindings.rs:20:10\n    |\n-LL |     let alpha | beta | charlie = alpha;\n-   |         ^^^^^   ----   ^^^^^^^ pattern doesn't bind `beta`\n-   |         |       |\n-   |         |       variable not in all patterns\n-   |         pattern doesn't bind `beta`\n+LL |     let (alpha | beta | charlie) = alpha;\n+   |          ^^^^^   ----   ^^^^^^^ pattern doesn't bind `beta`\n+   |          |       |\n+   |          |       variable not in all patterns\n+   |          pattern doesn't bind `beta`\n \n error[E0408]: variable `beta` is not bound in all patterns\n   --> $DIR/missing-bindings.rs:22:14\n@@ -16,132 +16,132 @@ LL |         Some(alpha | beta) => {}\n    |              pattern doesn't bind `beta`\n \n error[E0408]: variable `a` is not bound in all patterns\n-  --> $DIR/missing-bindings.rs:34:19\n+  --> $DIR/missing-bindings.rs:34:20\n    |\n-LL |     let A(a, _) | _ = X;\n-   |           -       ^ pattern doesn't bind `a`\n-   |           |\n-   |           variable not in all patterns\n+LL |     let (A(a, _) | _) = X;\n+   |            -       ^ pattern doesn't bind `a`\n+   |            |\n+   |            variable not in all patterns\n \n error[E0408]: variable `a` is not bound in all patterns\n-  --> $DIR/missing-bindings.rs:35:9\n+  --> $DIR/missing-bindings.rs:35:10\n    |\n-LL |     let _ | B(a) = X;\n-   |         ^     - variable not in all patterns\n-   |         |\n-   |         pattern doesn't bind `a`\n+LL |     let (_ | B(a)) = X;\n+   |          ^     - variable not in all patterns\n+   |          |\n+   |          pattern doesn't bind `a`\n \n error[E0408]: variable `a` is not bound in all patterns\n-  --> $DIR/missing-bindings.rs:36:9\n+  --> $DIR/missing-bindings.rs:36:10\n    |\n-LL |     let A(..) | B(a) = X;\n-   |         ^^^^^     - variable not in all patterns\n-   |         |\n-   |         pattern doesn't bind `a`\n+LL |     let (A(..) | B(a)) = X;\n+   |          ^^^^^     - variable not in all patterns\n+   |          |\n+   |          pattern doesn't bind `a`\n \n error[E0408]: variable `a` is not bound in all patterns\n-  --> $DIR/missing-bindings.rs:37:19\n+  --> $DIR/missing-bindings.rs:37:20\n    |\n-LL |     let A(a, _) | B(_) = X;\n-   |           -       ^^^^ pattern doesn't bind `a`\n-   |           |\n-   |           variable not in all patterns\n+LL |     let (A(a, _) | B(_)) = X;\n+   |            -       ^^^^ pattern doesn't bind `a`\n+   |            |\n+   |            variable not in all patterns\n \n error[E0408]: variable `a` is not bound in all patterns\n-  --> $DIR/missing-bindings.rs:38:19\n+  --> $DIR/missing-bindings.rs:38:20\n    |\n-LL |     let A(_, a) | B(_) = X;\n-   |              -    ^^^^ pattern doesn't bind `a`\n-   |              |\n-   |              variable not in all patterns\n+LL |     let (A(_, a) | B(_)) = X;\n+   |               -    ^^^^ pattern doesn't bind `a`\n+   |               |\n+   |               variable not in all patterns\n \n error[E0408]: variable `b` is not bound in all patterns\n-  --> $DIR/missing-bindings.rs:39:19\n+  --> $DIR/missing-bindings.rs:39:20\n    |\n-LL |     let A(a, b) | B(a) = X;\n-   |              -    ^^^^ pattern doesn't bind `b`\n-   |              |\n-   |              variable not in all patterns\n+LL |     let (A(a, b) | B(a)) = X;\n+   |               -    ^^^^ pattern doesn't bind `b`\n+   |               |\n+   |               variable not in all patterns\n \n error[E0408]: variable `a` is not bound in all patterns\n-  --> $DIR/missing-bindings.rs:43:9\n+  --> $DIR/missing-bindings.rs:43:10\n    |\n-LL |     let A(A(..) | B(_), _) | B(a) = Y;\n-   |         ^^^^^^^^^^^^^^^^^^     - variable not in all patterns\n-   |         |\n-   |         pattern doesn't bind `a`\n+LL |     let (A(A(..) | B(_), _) | B(a)) = Y;\n+   |          ^^^^^^^^^^^^^^^^^^     - variable not in all patterns\n+   |          |\n+   |          pattern doesn't bind `a`\n \n error[E0408]: variable `a` is not bound in all patterns\n-  --> $DIR/missing-bindings.rs:44:11\n+  --> $DIR/missing-bindings.rs:44:12\n    |\n-LL |     let A(A(..) | B(a), _) | B(A(a, _) | B(a)) = Y;\n-   |           ^^^^^     - variable not in all patterns\n-   |           |\n-   |           pattern doesn't bind `a`\n+LL |     let (A(A(..) | B(a), _) | B(A(a, _) | B(a))) = Y;\n+   |            ^^^^^     - variable not in all patterns\n+   |            |\n+   |            pattern doesn't bind `a`\n \n error[E0408]: variable `a` is not bound in all patterns\n-  --> $DIR/missing-bindings.rs:46:21\n+  --> $DIR/missing-bindings.rs:46:22\n    |\n-LL |     let A(A(a, b) | B(c), d) | B(e) = Y;\n-   |             -       ^^^^ pattern doesn't bind `a`\n-   |             |\n-   |             variable not in all patterns\n+LL |     let (A(A(a, b) | B(c), d) | B(e)) = Y;\n+   |              -       ^^^^ pattern doesn't bind `a`\n+   |              |\n+   |              variable not in all patterns\n \n error[E0408]: variable `b` is not bound in all patterns\n-  --> $DIR/missing-bindings.rs:46:21\n+  --> $DIR/missing-bindings.rs:46:22\n    |\n-LL |     let A(A(a, b) | B(c), d) | B(e) = Y;\n-   |                -    ^^^^ pattern doesn't bind `b`\n-   |                |\n-   |                variable not in all patterns\n+LL |     let (A(A(a, b) | B(c), d) | B(e)) = Y;\n+   |                 -    ^^^^ pattern doesn't bind `b`\n+   |                 |\n+   |                 variable not in all patterns\n \n error[E0408]: variable `c` is not bound in all patterns\n-  --> $DIR/missing-bindings.rs:46:11\n+  --> $DIR/missing-bindings.rs:46:12\n    |\n-LL |     let A(A(a, b) | B(c), d) | B(e) = Y;\n-   |           ^^^^^^^     - variable not in all patterns\n-   |           |\n-   |           pattern doesn't bind `c`\n+LL |     let (A(A(a, b) | B(c), d) | B(e)) = Y;\n+   |            ^^^^^^^     - variable not in all patterns\n+   |            |\n+   |            pattern doesn't bind `c`\n \n error[E0408]: variable `a` is not bound in all patterns\n-  --> $DIR/missing-bindings.rs:46:32\n+  --> $DIR/missing-bindings.rs:46:33\n    |\n-LL |     let A(A(a, b) | B(c), d) | B(e) = Y;\n-   |             -                  ^^^^ pattern doesn't bind `a`\n-   |             |\n-   |             variable not in all patterns\n+LL |     let (A(A(a, b) | B(c), d) | B(e)) = Y;\n+   |              -                  ^^^^ pattern doesn't bind `a`\n+   |              |\n+   |              variable not in all patterns\n \n error[E0408]: variable `b` is not bound in all patterns\n-  --> $DIR/missing-bindings.rs:46:32\n+  --> $DIR/missing-bindings.rs:46:33\n    |\n-LL |     let A(A(a, b) | B(c), d) | B(e) = Y;\n-   |                -               ^^^^ pattern doesn't bind `b`\n-   |                |\n-   |                variable not in all patterns\n+LL |     let (A(A(a, b) | B(c), d) | B(e)) = Y;\n+   |                 -               ^^^^ pattern doesn't bind `b`\n+   |                 |\n+   |                 variable not in all patterns\n \n error[E0408]: variable `c` is not bound in all patterns\n-  --> $DIR/missing-bindings.rs:46:32\n+  --> $DIR/missing-bindings.rs:46:33\n    |\n-LL |     let A(A(a, b) | B(c), d) | B(e) = Y;\n-   |                       -        ^^^^ pattern doesn't bind `c`\n-   |                       |\n-   |                       variable not in all patterns\n+LL |     let (A(A(a, b) | B(c), d) | B(e)) = Y;\n+   |                        -        ^^^^ pattern doesn't bind `c`\n+   |                        |\n+   |                        variable not in all patterns\n \n error[E0408]: variable `d` is not bound in all patterns\n-  --> $DIR/missing-bindings.rs:46:32\n+  --> $DIR/missing-bindings.rs:46:33\n    |\n-LL |     let A(A(a, b) | B(c), d) | B(e) = Y;\n-   |                           -    ^^^^ pattern doesn't bind `d`\n-   |                           |\n-   |                           variable not in all patterns\n+LL |     let (A(A(a, b) | B(c), d) | B(e)) = Y;\n+   |                            -    ^^^^ pattern doesn't bind `d`\n+   |                            |\n+   |                            variable not in all patterns\n \n error[E0408]: variable `e` is not bound in all patterns\n-  --> $DIR/missing-bindings.rs:46:9\n+  --> $DIR/missing-bindings.rs:46:10\n    |\n-LL |     let A(A(a, b) | B(c), d) | B(e) = Y;\n-   |         ^^^^^^^^^^^^^^^^^^^^     - variable not in all patterns\n-   |         |\n-   |         pattern doesn't bind `e`\n+LL |     let (A(A(a, b) | B(c), d) | B(e)) = Y;\n+   |          ^^^^^^^^^^^^^^^^^^^^     - variable not in all patterns\n+   |          |\n+   |          pattern doesn't bind `e`\n \n error[E0408]: variable `a` is not bound in all patterns\n   --> $DIR/missing-bindings.rs:62:29"}, {"sha": "208662b1c425df2655b37274f466a9a06239b524", "filename": "src/test/ui/or-patterns/nested-undelimited-precedence.rs", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/e64138c534d356e555842ddc9da20a952a20ab46/src%2Ftest%2Fui%2For-patterns%2Fnested-undelimited-precedence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64138c534d356e555842ddc9da20a952a20ab46/src%2Ftest%2Fui%2For-patterns%2Fnested-undelimited-precedence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2Fnested-undelimited-precedence.rs?ref=e64138c534d356e555842ddc9da20a952a20ab46", "patch": "@@ -0,0 +1,46 @@\n+// This test tests the precedence of `|` (or-patterns) undelimited nested patterns. In particular,\n+// we want to reserve the syntactic space of a pattern followed by a type annotation for possible\n+// future type ascription, so we need to make sure that any time a pattern is followed by type\n+// annotation (for now), the pattern is not a top-level or-pattern. However, there are also a few\n+// types of patterns that allow undelimited subpatterns that could cause the same ambiguity.\n+// Currently, those should be impossible due to precedence rule. This test enforces that.\n+\n+#![feature(or_patterns)]\n+\n+enum E {\n+    A,\n+    B,\n+}\n+\n+fn foo() {\n+    use E::*;\n+\n+    // ok\n+    let b @ (A | B): E = A;\n+\n+    let b @ A | B: E = A; //~ERROR `b` is not bound in all patterns\n+    //~^ ERROR top-level or-patterns are not allowed\n+}\n+\n+enum F {\n+    A(usize),\n+    B(usize),\n+}\n+\n+fn bar() {\n+    use F::*;\n+\n+    // ok\n+    let (A(x) | B(x)): F = A(3);\n+\n+    let &A(_) | B(_): F = A(3); //~ERROR mismatched types\n+    //~^ ERROR top-level or-patterns are not allowed\n+    let &&A(_) | B(_): F = A(3); //~ERROR mismatched types\n+    //~^ ERROR top-level or-patterns are not allowed\n+    let &mut A(_) | B(_): F = A(3); //~ERROR mismatched types\n+    //~^ ERROR top-level or-patterns are not allowed\n+    let &&mut A(_) | B(_): F = A(3); //~ERROR mismatched types\n+    //~^ ERROR top-level or-patterns are not allowed\n+}\n+\n+fn main() {}"}, {"sha": "1d78d5193cb883d2e7be28da8e65f7912e60d1d6", "filename": "src/test/ui/or-patterns/nested-undelimited-precedence.stderr", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/e64138c534d356e555842ddc9da20a952a20ab46/src%2Ftest%2Fui%2For-patterns%2Fnested-undelimited-precedence.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e64138c534d356e555842ddc9da20a952a20ab46/src%2Ftest%2Fui%2For-patterns%2Fnested-undelimited-precedence.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2Fnested-undelimited-precedence.stderr?ref=e64138c534d356e555842ddc9da20a952a20ab46", "patch": "@@ -0,0 +1,86 @@\n+error: top-level or-patterns are not allowed in `let` bindings\n+  --> $DIR/nested-undelimited-precedence.rs:21:9\n+   |\n+LL |     let b @ A | B: E = A;\n+   |         ^^^^^^^^^ help: wrap the pattern in parentheses: `(b @ A | B)`\n+\n+error: top-level or-patterns are not allowed in `let` bindings\n+  --> $DIR/nested-undelimited-precedence.rs:36:9\n+   |\n+LL |     let &A(_) | B(_): F = A(3);\n+   |         ^^^^^^^^^^^^ help: wrap the pattern in parentheses: `(&A(_) | B(_))`\n+\n+error: top-level or-patterns are not allowed in `let` bindings\n+  --> $DIR/nested-undelimited-precedence.rs:38:9\n+   |\n+LL |     let &&A(_) | B(_): F = A(3);\n+   |         ^^^^^^^^^^^^^ help: wrap the pattern in parentheses: `(&&A(_) | B(_))`\n+\n+error: top-level or-patterns are not allowed in `let` bindings\n+  --> $DIR/nested-undelimited-precedence.rs:40:9\n+   |\n+LL |     let &mut A(_) | B(_): F = A(3);\n+   |         ^^^^^^^^^^^^^^^^ help: wrap the pattern in parentheses: `(&mut A(_) | B(_))`\n+\n+error: top-level or-patterns are not allowed in `let` bindings\n+  --> $DIR/nested-undelimited-precedence.rs:42:9\n+   |\n+LL |     let &&mut A(_) | B(_): F = A(3);\n+   |         ^^^^^^^^^^^^^^^^^ help: wrap the pattern in parentheses: `(&&mut A(_) | B(_))`\n+\n+error[E0408]: variable `b` is not bound in all patterns\n+  --> $DIR/nested-undelimited-precedence.rs:21:17\n+   |\n+LL |     let b @ A | B: E = A;\n+   |         -       ^ pattern doesn't bind `b`\n+   |         |\n+   |         variable not in all patterns\n+\n+error[E0308]: mismatched types\n+  --> $DIR/nested-undelimited-precedence.rs:36:9\n+   |\n+LL |     let &A(_) | B(_): F = A(3);\n+   |         ^^^^^         - expected due to this\n+   |         |\n+   |         expected enum `F`, found reference\n+   |\n+   = note:   expected enum `F`\n+           found reference `&_`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/nested-undelimited-precedence.rs:38:9\n+   |\n+LL |     let &&A(_) | B(_): F = A(3);\n+   |         ^^^^^^         - expected due to this\n+   |         |\n+   |         expected enum `F`, found reference\n+   |\n+   = note:   expected enum `F`\n+           found reference `&_`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/nested-undelimited-precedence.rs:40:9\n+   |\n+LL |     let &mut A(_) | B(_): F = A(3);\n+   |         ^^^^^^^^^         - expected due to this\n+   |         |\n+   |         expected enum `F`, found `&mut _`\n+   |\n+   = note:           expected enum `F`\n+           found mutable reference `&mut _`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/nested-undelimited-precedence.rs:42:9\n+   |\n+LL |     let &&mut A(_) | B(_): F = A(3);\n+   |         ^^^^^^^^^^         - expected due to this\n+   |         |\n+   |         expected enum `F`, found reference\n+   |\n+   = note:   expected enum `F`\n+           found reference `&_`\n+\n+error: aborting due to 10 previous errors\n+\n+Some errors have detailed explanations: E0308, E0408.\n+For more information about an error, try `rustc --explain E0308`."}, {"sha": "11c8a7b69f948e912107bc31de6728c61ab1bc8d", "filename": "src/test/ui/or-patterns/or-patterns-binding-type-mismatch.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e64138c534d356e555842ddc9da20a952a20ab46/src%2Ftest%2Fui%2For-patterns%2For-patterns-binding-type-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64138c534d356e555842ddc9da20a952a20ab46/src%2Ftest%2Fui%2For-patterns%2For-patterns-binding-type-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2For-patterns-binding-type-mismatch.rs?ref=e64138c534d356e555842ddc9da20a952a20ab46", "patch": "@@ -52,10 +52,10 @@ fn main() {\n     = Some((0u8, Some((1u16, 2u32))))\n     {}\n \n-    let Blah::A(_, x, y) | Blah::B(x, y) = Blah::A(1, 1, 2);\n+    let (Blah::A(_, x, y) | Blah::B(x, y)) = Blah::A(1, 1, 2);\n     //~^ ERROR mismatched types\n \n-    let (x, y) | (y, x) = (0u8, 1u16);\n+    let ((x, y) | (y, x)) = (0u8, 1u16);\n     //~^ ERROR mismatched types\n     //~| ERROR mismatched types\n "}, {"sha": "26e14b539dbf29edf7b248f87f4379cdb6214a9a", "filename": "src/test/ui/or-patterns/or-patterns-binding-type-mismatch.stderr", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/e64138c534d356e555842ddc9da20a952a20ab46/src%2Ftest%2Fui%2For-patterns%2For-patterns-binding-type-mismatch.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e64138c534d356e555842ddc9da20a952a20ab46/src%2Ftest%2Fui%2For-patterns%2For-patterns-binding-type-mismatch.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2For-patterns-binding-type-mismatch.stderr?ref=e64138c534d356e555842ddc9da20a952a20ab46", "patch": "@@ -187,35 +187,35 @@ LL |     = Some((0u8, Some((1u16, 2u32))))\n    = note: a binding must have the same type in all alternatives\n \n error[E0308]: mismatched types\n-  --> $DIR/or-patterns-binding-type-mismatch.rs:55:39\n+  --> $DIR/or-patterns-binding-type-mismatch.rs:55:40\n    |\n-LL |     let Blah::A(_, x, y) | Blah::B(x, y) = Blah::A(1, 1, 2);\n-   |                       -               ^    ---------------- this expression has type `Blah`\n-   |                       |               |\n-   |                       |               expected `usize`, found `isize`\n-   |                       first introduced with type `usize` here\n+LL |     let (Blah::A(_, x, y) | Blah::B(x, y)) = Blah::A(1, 1, 2);\n+   |                        -               ^     ---------------- this expression has type `Blah`\n+   |                        |               |\n+   |                        |               expected `usize`, found `isize`\n+   |                        first introduced with type `usize` here\n    |\n    = note: a binding must have the same type in all alternatives\n \n error[E0308]: mismatched types\n-  --> $DIR/or-patterns-binding-type-mismatch.rs:58:19\n+  --> $DIR/or-patterns-binding-type-mismatch.rs:58:20\n    |\n-LL |     let (x, y) | (y, x) = (0u8, 1u16);\n-   |             -     ^       ----------- this expression has type `(u8, u16)`\n-   |             |     |\n-   |             |     expected `u16`, found `u8`\n-   |             first introduced with type `u16` here\n+LL |     let ((x, y) | (y, x)) = (0u8, 1u16);\n+   |              -     ^        ----------- this expression has type `(u8, u16)`\n+   |              |     |\n+   |              |     expected `u16`, found `u8`\n+   |              first introduced with type `u16` here\n    |\n    = note: a binding must have the same type in all alternatives\n \n error[E0308]: mismatched types\n-  --> $DIR/or-patterns-binding-type-mismatch.rs:58:22\n+  --> $DIR/or-patterns-binding-type-mismatch.rs:58:23\n    |\n-LL |     let (x, y) | (y, x) = (0u8, 1u16);\n-   |          -           ^    ----------- this expression has type `(u8, u16)`\n-   |          |           |\n-   |          |           expected `u8`, found `u16`\n-   |          first introduced with type `u8` here\n+LL |     let ((x, y) | (y, x)) = (0u8, 1u16);\n+   |           -           ^     ----------- this expression has type `(u8, u16)`\n+   |           |           |\n+   |           |           expected `u8`, found `u16`\n+   |           first introduced with type `u8` here\n    |\n    = note: a binding must have the same type in all alternatives\n "}, {"sha": "f98b038ae81afa75902daf90eec3a90977572cca", "filename": "src/test/ui/or-patterns/or-patterns-default-binding-modes.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e64138c534d356e555842ddc9da20a952a20ab46/src%2Ftest%2Fui%2For-patterns%2For-patterns-default-binding-modes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64138c534d356e555842ddc9da20a952a20ab46/src%2Ftest%2Fui%2For-patterns%2For-patterns-default-binding-modes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2For-patterns-default-binding-modes.rs?ref=e64138c534d356e555842ddc9da20a952a20ab46", "patch": "@@ -37,11 +37,11 @@ fn main() {\n     if let &(Ok(x) | Err(x)) = res {\n         drop::<u8>(x);\n     }\n-    let Ok(mut x) | &Err(mut x) = res;\n+    let (Ok(mut x) | &Err(mut x)) = res;\n     drop::<u8>(x);\n     let &(Ok(x) | Err(x)) = res;\n     drop::<u8>(x);\n-    let Ok(x) | Err(x) = res;\n+    let (Ok(x) | Err(x)) = res;\n     drop::<&u8>(x);\n     for Ok(mut x) | &Err(mut x) in std::iter::once(res) {\n         drop::<u8>(x);\n@@ -119,9 +119,9 @@ fn main() {\n     }\n \n     let tri = &Tri::A(&Ok(0));\n-    let Tri::A(Ok(mut x) | Err(mut x))\n+    let (Tri::A(Ok(mut x) | Err(mut x))\n     | Tri::B(&Ok(mut x) | Err(mut x))\n-    | &Tri::C(Ok(mut x) | Err(mut x)) = tri;\n+    | &Tri::C(Ok(mut x) | Err(mut x))) = tri;\n     drop::<u8>(x);\n \n     match tri {"}, {"sha": "27a5374ff1848bd6517daf7ce102264c42384870", "filename": "src/test/ui/or-patterns/or-patterns-syntactic-fail.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e64138c534d356e555842ddc9da20a952a20ab46/src%2Ftest%2Fui%2For-patterns%2For-patterns-syntactic-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64138c534d356e555842ddc9da20a952a20ab46/src%2Ftest%2Fui%2For-patterns%2For-patterns-syntactic-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2For-patterns-syntactic-fail.rs?ref=e64138c534d356e555842ddc9da20a952a20ab46", "patch": "@@ -14,8 +14,19 @@ fn no_top_level_or_patterns() {\n     //           -------- This looks like an or-pattern but is in fact `|A| (B: E | ())`.\n \n     // ...and for now neither do we allow or-patterns at the top level of functions.\n-    fn fun1(A | B: E) {} //~ ERROR an or-pattern parameter must be wrapped in parentheses\n+    fn fun1(A | B: E) {}\n+    //~^ ERROR top-level or-patterns are not allowed\n \n     fn fun2(| A | B: E) {}\n-    //~^ ERROR an or-pattern parameter must be wrapped in parentheses\n+    //~^ ERROR top-level or-patterns are not allowed\n+\n+    // We don't allow top-level or-patterns before type annotation in let-statements because we\n+    // want to reserve this syntactic space for possible future type ascription.\n+    let A | B: E = A;\n+    //~^ ERROR top-level or-patterns are not allowed\n+\n+    let | A | B: E = A;\n+    //~^ ERROR top-level or-patterns are not allowed\n+\n+    let (A | B): E = A; // ok -- wrapped in parens\n }"}, {"sha": "929b2088f76ceadc27b6a8c84e24a488e3772417", "filename": "src/test/ui/or-patterns/or-patterns-syntactic-fail.stderr", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e64138c534d356e555842ddc9da20a952a20ab46/src%2Ftest%2Fui%2For-patterns%2For-patterns-syntactic-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e64138c534d356e555842ddc9da20a952a20ab46/src%2Ftest%2Fui%2For-patterns%2For-patterns-syntactic-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2For-patterns-syntactic-fail.stderr?ref=e64138c534d356e555842ddc9da20a952a20ab46", "patch": "@@ -1,15 +1,27 @@\n-error: an or-pattern parameter must be wrapped in parentheses\n+error: top-level or-patterns are not allowed in function parameters\n   --> $DIR/or-patterns-syntactic-fail.rs:17:13\n    |\n LL |     fn fun1(A | B: E) {}\n    |             ^^^^^ help: wrap the pattern in parentheses: `(A | B)`\n \n-error: an or-pattern parameter must be wrapped in parentheses\n-  --> $DIR/or-patterns-syntactic-fail.rs:19:13\n+error: top-level or-patterns are not allowed in function parameters\n+  --> $DIR/or-patterns-syntactic-fail.rs:20:13\n    |\n LL |     fn fun2(| A | B: E) {}\n    |             ^^^^^^^ help: wrap the pattern in parentheses: `(A | B)`\n \n+error: top-level or-patterns are not allowed in `let` bindings\n+  --> $DIR/or-patterns-syntactic-fail.rs:25:9\n+   |\n+LL |     let A | B: E = A;\n+   |         ^^^^^ help: wrap the pattern in parentheses: `(A | B)`\n+\n+error: top-level or-patterns are not allowed in `let` bindings\n+  --> $DIR/or-patterns-syntactic-fail.rs:28:9\n+   |\n+LL |     let | A | B: E = A;\n+   |         ^^^^^^^ help: wrap the pattern in parentheses: `(A | B)`\n+\n error[E0369]: no implementation for `E | ()`\n   --> $DIR/or-patterns-syntactic-fail.rs:13:22\n    |\n@@ -20,6 +32,6 @@ LL |     let _ = |A | B: E| ();\n    |\n    = note: an implementation of `std::ops::BitOr` might be missing for `E`\n \n-error: aborting due to 3 previous errors\n+error: aborting due to 5 previous errors\n \n For more information about this error, try `rustc --explain E0369`."}, {"sha": "3da238f7b9a45284d375273ddc995d575184e0c0", "filename": "src/test/ui/or-patterns/or-patterns-syntactic-pass.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e64138c534d356e555842ddc9da20a952a20ab46/src%2Ftest%2Fui%2For-patterns%2For-patterns-syntactic-pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64138c534d356e555842ddc9da20a952a20ab46/src%2Ftest%2Fui%2For-patterns%2For-patterns-syntactic-pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2For-patterns-syntactic-pass.rs?ref=e64138c534d356e555842ddc9da20a952a20ab46", "patch": "@@ -23,11 +23,11 @@ accept_pat!([p | q]);\n #[cfg(FALSE)]\n fn or_patterns() {\n     // Top level of `let`:\n-    let | A | B;\n-    let A | B;\n-    let A | B: u8;\n-    let A | B = 0;\n-    let A | B: u8 = 0;\n+    let (| A | B);\n+    let (A | B);\n+    let (A | B): u8;\n+    let (A | B) = 0;\n+    let (A | B): u8 = 0;\n \n     // Top level of `for`:\n     for | A | B in 0 {}\n@@ -69,10 +69,10 @@ fn or_patterns() {\n     let [A | B, .. | ..];\n \n     // These bind as `(prefix p) | q` as opposed to `prefix (p | q)`:\n-    let box 0 | 1; // Unstable; we *can* the precedence if we want.\n-    let &0 | 1;\n-    let &mut 0 | 1;\n-    let x @ 0 | 1;\n-    let ref x @ 0 | 1;\n-    let ref mut x @ 0 | 1;\n+    let (box 0 | 1); // Unstable; we *can* change the precedence if we want.\n+    let (&0 | 1);\n+    let (&mut 0 | 1);\n+    let (x @ 0 | 1);\n+    let (ref x @ 0 | 1);\n+    let (ref mut x @ 0 | 1);\n }"}, {"sha": "d23858d42d14619738c7c6a3bfee62415734f58a", "filename": "src/test/ui/or-patterns/remove-leading-vert.fixed", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e64138c534d356e555842ddc9da20a952a20ab46/src%2Ftest%2Fui%2For-patterns%2Fremove-leading-vert.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/e64138c534d356e555842ddc9da20a952a20ab46/src%2Ftest%2Fui%2For-patterns%2Fremove-leading-vert.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2Fremove-leading-vert.fixed?ref=e64138c534d356e555842ddc9da20a952a20ab46", "patch": "@@ -9,7 +9,7 @@ fn main() {}\n \n #[cfg(FALSE)]\n fn leading() {\n-    fn fun1( A: E) {} //~ ERROR an or-pattern parameter must be wrapped in parentheses\n+    fn fun1( A: E) {} //~ ERROR top-level or-patterns are not allowed\n     fn fun2(  A: E) {} //~ ERROR unexpected `||` before function parameter\n     let ( | A): E;\n     let ( | A): (E); //~ ERROR unexpected token `||` in pattern\n@@ -40,6 +40,9 @@ fn trailing() {\n         //~^ ERROR a trailing `|` is not allowed in an or-pattern\n     }\n \n+    // These test trailing-vert in `let` bindings, but they also test that we don't emit a\n+    // duplicate suggestion that would confuse rustfix.\n+\n     let a  : u8 = 0; //~ ERROR a trailing `|` is not allowed in an or-pattern\n     let a  = 0; //~ ERROR a trailing `|` is not allowed in an or-pattern\n     let a  ; //~ ERROR a trailing `|` is not allowed in an or-pattern"}, {"sha": "e753765b3e7957ee0679bcba7f96a9b731ec2493", "filename": "src/test/ui/or-patterns/remove-leading-vert.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e64138c534d356e555842ddc9da20a952a20ab46/src%2Ftest%2Fui%2For-patterns%2Fremove-leading-vert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64138c534d356e555842ddc9da20a952a20ab46/src%2Ftest%2Fui%2For-patterns%2Fremove-leading-vert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2Fremove-leading-vert.rs?ref=e64138c534d356e555842ddc9da20a952a20ab46", "patch": "@@ -9,7 +9,7 @@ fn main() {}\n \n #[cfg(FALSE)]\n fn leading() {\n-    fn fun1( | A: E) {} //~ ERROR an or-pattern parameter must be wrapped in parentheses\n+    fn fun1( | A: E) {} //~ ERROR top-level or-patterns are not allowed\n     fn fun2( || A: E) {} //~ ERROR unexpected `||` before function parameter\n     let ( | A): E;\n     let ( || A): (E); //~ ERROR unexpected token `||` in pattern\n@@ -40,6 +40,9 @@ fn trailing() {\n         //~^ ERROR a trailing `|` is not allowed in an or-pattern\n     }\n \n+    // These test trailing-vert in `let` bindings, but they also test that we don't emit a\n+    // duplicate suggestion that would confuse rustfix.\n+\n     let a | : u8 = 0; //~ ERROR a trailing `|` is not allowed in an or-pattern\n     let a | = 0; //~ ERROR a trailing `|` is not allowed in an or-pattern\n     let a | ; //~ ERROR a trailing `|` is not allowed in an or-pattern"}, {"sha": "0a2b143288dab553e08dc8576c204288e2277bfa", "filename": "src/test/ui/or-patterns/remove-leading-vert.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e64138c534d356e555842ddc9da20a952a20ab46/src%2Ftest%2Fui%2For-patterns%2Fremove-leading-vert.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e64138c534d356e555842ddc9da20a952a20ab46/src%2Ftest%2Fui%2For-patterns%2Fremove-leading-vert.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2Fremove-leading-vert.stderr?ref=e64138c534d356e555842ddc9da20a952a20ab46", "patch": "@@ -1,8 +1,8 @@\n-error: an or-pattern parameter must be wrapped in parentheses\n+error: top-level or-patterns are not allowed in function parameters\n   --> $DIR/remove-leading-vert.rs:12:14\n    |\n LL |     fn fun1( | A: E) {}\n-   |              ^^^ help: remove the leading `|`: `A`\n+   |              ^^^ help: remove the `|`: `A`\n \n error: unexpected `||` before function parameter\n   --> $DIR/remove-leading-vert.rs:13:14\n@@ -135,23 +135,23 @@ LL |         | A | B | => {}\n    |         while parsing this or-pattern starting here\n \n error: a trailing `|` is not allowed in an or-pattern\n-  --> $DIR/remove-leading-vert.rs:43:11\n+  --> $DIR/remove-leading-vert.rs:46:11\n    |\n LL |     let a | : u8 = 0;\n    |         - ^ help: remove the `|`\n    |         |\n    |         while parsing this or-pattern starting here\n \n error: a trailing `|` is not allowed in an or-pattern\n-  --> $DIR/remove-leading-vert.rs:44:11\n+  --> $DIR/remove-leading-vert.rs:47:11\n    |\n LL |     let a | = 0;\n    |         - ^ help: remove the `|`\n    |         |\n    |         while parsing this or-pattern starting here\n \n error: a trailing `|` is not allowed in an or-pattern\n-  --> $DIR/remove-leading-vert.rs:45:11\n+  --> $DIR/remove-leading-vert.rs:48:11\n    |\n LL |     let a | ;\n    |         - ^ help: remove the `|`"}]}