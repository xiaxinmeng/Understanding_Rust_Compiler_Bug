{"sha": "2fc6b0998b3bd8c7ef796a9f4c795814b4ad30ea", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJmYzZiMDk5OGIzYmQ4YzdlZjc5NmE5ZjRjNzk1ODE0YjRhZDMwZWE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-05-15T02:08:19Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-05-15T02:08:19Z"}, "message": "auto merge of #6475 : sonwow/rust/tutorials, r=brson", "tree": {"sha": "a3024b989f204101632a3e25d137f6a1facb4521", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a3024b989f204101632a3e25d137f6a1facb4521"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2fc6b0998b3bd8c7ef796a9f4c795814b4ad30ea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2fc6b0998b3bd8c7ef796a9f4c795814b4ad30ea", "html_url": "https://github.com/rust-lang/rust/commit/2fc6b0998b3bd8c7ef796a9f4c795814b4ad30ea", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2fc6b0998b3bd8c7ef796a9f4c795814b4ad30ea/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cf0f760560385d59427e2b974f24a328345d829b", "url": "https://api.github.com/repos/rust-lang/rust/commits/cf0f760560385d59427e2b974f24a328345d829b", "html_url": "https://github.com/rust-lang/rust/commit/cf0f760560385d59427e2b974f24a328345d829b"}, {"sha": "0c082047bc9c6de966329687a18477e4acb3a197", "url": "https://api.github.com/repos/rust-lang/rust/commits/0c082047bc9c6de966329687a18477e4acb3a197", "html_url": "https://github.com/rust-lang/rust/commit/0c082047bc9c6de966329687a18477e4acb3a197"}], "stats": {"total": 54, "additions": 27, "deletions": 27}, "files": [{"sha": "90b8e1051eba9847137953d912a9bc37cc56a8d7", "filename": "doc/tutorial-borrowed-ptr.md", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/2fc6b0998b3bd8c7ef796a9f4c795814b4ad30ea/doc%2Ftutorial-borrowed-ptr.md", "raw_url": "https://github.com/rust-lang/rust/raw/2fc6b0998b3bd8c7ef796a9f4c795814b4ad30ea/doc%2Ftutorial-borrowed-ptr.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial-borrowed-ptr.md?ref=2fc6b0998b3bd8c7ef796a9f4c795814b4ad30ea", "patch": "@@ -42,14 +42,14 @@ point, but allocated in a different place:\n ~~~\n # struct Point {x: float, y: float}\n let on_the_stack :  Point =  Point {x: 3.0, y: 4.0};\n-let shared_box   : @Point = @Point {x: 5.0, y: 1.0};\n-let unique_box   : ~Point = ~Point {x: 7.0, y: 9.0};\n+let managed_box  : @Point = @Point {x: 5.0, y: 1.0};\n+let owned_box    : ~Point = ~Point {x: 7.0, y: 9.0};\n ~~~\n \n Suppose we wanted to write a procedure that computed the distance between any\n two points, no matter where they were stored. For example, we might like to\n-compute the distance between `on_the_stack` and `shared_box`, or between\n-`shared_box` and `unique_box`. One option is to define a function that takes\n+compute the distance between `on_the_stack` and `managed_box`, or between\n+`managed_box` and `owned_box`. One option is to define a function that takes\n two arguments of type `Point`\u2014that is, it takes the points by value. But if we\n define it this way, calling the function will cause the points to be\n copied. For points, this is probably not so bad, but often copies are\n@@ -73,11 +73,11 @@ Now we can call `compute_distance()` in various ways:\n ~~~\n # struct Point {x: float, y: float}\n # let on_the_stack :  Point =  Point{x: 3.0, y: 4.0};\n-# let shared_box   : @Point = @Point{x: 5.0, y: 1.0};\n-# let unique_box   : ~Point = ~Point{x: 7.0, y: 9.0};\n+# let managed_box  : @Point = @Point{x: 5.0, y: 1.0};\n+# let owned_box    : ~Point = ~Point{x: 7.0, y: 9.0};\n # fn compute_distance(p1: &Point, p2: &Point) -> float { 0f }\n-compute_distance(&on_the_stack, shared_box);\n-compute_distance(shared_box, unique_box);\n+compute_distance(&on_the_stack, managed_box);\n+compute_distance(managed_box, owned_box);\n ~~~\n \n Here, the `&` operator takes the address of the variable\n@@ -87,11 +87,11 @@ value. We also call this _borrowing_ the local variable\n `on_the_stack`, because we have created an alias: that is, another\n name for the same data.\n \n-In contrast, we can pass the boxes `shared_box` and `unique_box` to\n+In contrast, we can pass the boxes `managed_box` and `owned_box` to\n `compute_distance` directly. The compiler automatically converts a box like\n `@Point` or `~Point` to a borrowed pointer like `&Point`. This is another form\n-of borrowing: in this case, the caller lends the contents of the shared or\n-unique box to the callee.\n+of borrowing: in this case, the caller lends the contents of the managed or\n+owned box to the callee.\n \n Whenever a caller lends data to a callee, there are some limitations on what\n the caller can do with the original. For example, if the contents of a\n@@ -155,7 +155,7 @@ let rect_stack   = &Rectangle {origin: Point {x: 1f, y: 2f},\n                                size: Size {w: 3f, h: 4f}};\n let rect_managed = @Rectangle {origin: Point {x: 3f, y: 4f},\n                                size: Size {w: 3f, h: 4f}};\n-let rect_unique  = ~Rectangle {origin: Point {x: 5f, y: 6f},\n+let rect_owned   = ~Rectangle {origin: Point {x: 5f, y: 6f},\n                                size: Size {w: 3f, h: 4f}};\n ~~~\n \n@@ -168,7 +168,7 @@ operator. For example, I could write:\n # struct Rectangle {origin: Point, size: Size}\n # let rect_stack  = &Rectangle {origin: Point {x: 1f, y: 2f}, size: Size {w: 3f, h: 4f}};\n # let rect_managed = @Rectangle {origin: Point {x: 3f, y: 4f}, size: Size {w: 3f, h: 4f}};\n-# let rect_unique = ~Rectangle {origin: Point {x: 5f, y: 6f}, size: Size {w: 3f, h: 4f}};\n+# let rect_owned = ~Rectangle {origin: Point {x: 5f, y: 6f}, size: Size {w: 3f, h: 4f}};\n # fn compute_distance(p1: &Point, p2: &Point) -> float { 0f }\n compute_distance(&rect_stack.origin, &rect_managed.origin);\n ~~~\n@@ -179,7 +179,7 @@ as well as from the managed box, and then compute the distance between them.\n # Borrowing managed boxes and rooting\n \n We\u2019ve seen a few examples so far of borrowing heap boxes, both managed\n-and unique. Up till this point, we\u2019ve glossed over issues of\n+and owned. Up till this point, we\u2019ve glossed over issues of\n safety. As stated in the introduction, at runtime a borrowed pointer\n is simply a pointer, nothing more. Therefore, avoiding C's problems\n with dangling pointers requires a compile-time safety check.\n@@ -258,18 +258,18 @@ fn example2() {\n Now if `x` is reassigned, the pointer `y` will still remain valid. This\n process is called *rooting*.\n \n-# Borrowing unique boxes\n+# Borrowing owned boxes\n \n The previous example demonstrated *rooting*, the process by which the\n compiler ensures that managed boxes remain live for the duration of a\n-borrow. Unfortunately, rooting does not work for borrows of unique\n-boxes, because it is not possible to have two references to a unique\n+borrow. Unfortunately, rooting does not work for borrows of owned\n+boxes, because it is not possible to have two references to a owned\n box.\n \n-For unique boxes, therefore, the compiler will only allow a borrow *if\n-the compiler can guarantee that the unique box will not be reassigned\n+For owned boxes, therefore, the compiler will only allow a borrow *if\n+the compiler can guarantee that the owned box will not be reassigned\n or moved for the lifetime of the pointer*. This does not necessarily\n-mean that the unique box is stored in immutable memory. For example,\n+mean that the owned box is stored in immutable memory. For example,\n the following function is legal:\n \n ~~~\n@@ -294,7 +294,7 @@ and `x` is declared as mutable. However, the compiler can prove that\n and in fact is mutated later in the function.\n \n It may not be clear why we are so concerned about mutating a borrowed\n-variable. The reason is that the runtime system frees any unique box\n+variable. The reason is that the runtime system frees any owned box\n _as soon as its owning reference changes or goes out of\n scope_. Therefore, a program like this is illegal (and would be\n rejected by the compiler):\n@@ -342,7 +342,7 @@ which has been freed.\n \n In fact, the compiler can apply the same kind of reasoning to any\n memory that is _(uniquely) owned by the stack frame_. So we could\n-modify the previous example to introduce additional unique pointers\n+modify the previous example to introduce additional owned pointers\n and structs, and the compiler will still be able to detect possible\n mutations:\n \n@@ -366,7 +366,7 @@ invalidate the pointer `y`.\n # Borrowing and enums\n \n The previous example showed that the type system forbids any borrowing\n-of unique boxes found in aliasable, mutable memory. This restriction\n+of owned boxes found in aliasable, mutable memory. This restriction\n prevents pointers from pointing into freed memory. There is one other\n case where the compiler must be very careful to ensure that pointers\n remain valid: pointers into the interior of an `enum`.\n@@ -462,14 +462,14 @@ of a `float` as if it were a struct with two fields would be a memory\n safety violation.\n \n So, in fact, for every `ref` binding, the compiler will impose the\n-same rules as the ones we saw for borrowing the interior of a unique\n+same rules as the ones we saw for borrowing the interior of a owned\n box: it must be able to guarantee that the `enum` will not be\n overwritten for the duration of the borrow.  In fact, the compiler\n would accept the example we gave earlier. The example is safe because\n the shape pointer has type `&Shape`, which means \"borrowed pointer to\n immutable memory containing a `shape`\". If, however, the type of that\n pointer were `&mut Shape`, then the ref binding would be ill-typed.\n-Just as with unique boxes, the compiler will permit `ref` bindings\n+Just as with owned boxes, the compiler will permit `ref` bindings\n into data owned by the stack frame even if the data are mutable,\n but otherwise it requires that the data reside in immutable memory.\n \n@@ -550,7 +550,7 @@ guarantees; in fact, it cannot guarantee that the pointer will remain\n valid at all once it returns, as the parameter `p` may or may not be\n live in the caller. Therefore, the compiler will report an error here.\n \n-In general, if you borrow a managed (or unique) box to create a\n+In general, if you borrow a managed (or owned) box to create a\n borrowed pointer, the pointer will only be valid within the function\n and cannot be returned. This is why the typical way to return borrowed\n pointers is to take borrowed pointers as input (the only other case in"}, {"sha": "7ee78d622f34048e07bba97eea5924a1bec76e10", "filename": "doc/tutorial.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2fc6b0998b3bd8c7ef796a9f4c795814b4ad30ea/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/2fc6b0998b3bd8c7ef796a9f4c795814b4ad30ea/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=2fc6b0998b3bd8c7ef796a9f4c795814b4ad30ea", "patch": "@@ -1779,7 +1779,7 @@ to a borrowed pointer.\n #    fn draw_value(self) { ... }\n # }\n # let s = Circle(Point { x: 1f, y: 2f }, 3f);\n-// As with typical function arguments, managed and unique pointers\n+// As with typical function arguments, managed and owned pointers\n // are automatically converted to borrowed pointers\n \n (@s).draw_borrowed();"}]}