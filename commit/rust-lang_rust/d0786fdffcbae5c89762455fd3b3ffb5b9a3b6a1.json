{"sha": "d0786fdffcbae5c89762455fd3b3ffb5b9a3b6a1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQwNzg2ZmRmZmNiYWU1Yzg5NzYyNDU1ZmQzYjNmZmI1YjlhM2I2YTE=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-04-22T19:54:03Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-04-22T20:05:16Z"}, "message": "core::rt Wire up task-local storage to the new scheduler", "tree": {"sha": "4ed11ab9d906dcec76902428b34de36dfd53d686", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4ed11ab9d906dcec76902428b34de36dfd53d686"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d0786fdffcbae5c89762455fd3b3ffb5b9a3b6a1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d0786fdffcbae5c89762455fd3b3ffb5b9a3b6a1", "html_url": "https://github.com/rust-lang/rust/commit/d0786fdffcbae5c89762455fd3b3ffb5b9a3b6a1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d0786fdffcbae5c89762455fd3b3ffb5b9a3b6a1/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d7f5e437a28dd85b8a7523af9212a9a1100ea725", "url": "https://api.github.com/repos/rust-lang/rust/commits/d7f5e437a28dd85b8a7523af9212a9a1100ea725", "html_url": "https://github.com/rust-lang/rust/commit/d7f5e437a28dd85b8a7523af9212a9a1100ea725"}], "stats": {"total": 170, "additions": 144, "deletions": 26}, "files": [{"sha": "d29e57a17af15385dcc5ebcdfbd2cd8cdb789e04", "filename": "src/libcore/rt/local_services.rs", "status": "modified", "additions": 54, "deletions": 4, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/d0786fdffcbae5c89762455fd3b3ffb5b9a3b6a1/src%2Flibcore%2Frt%2Flocal_services.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0786fdffcbae5c89762455fd3b3ffb5b9a3b6a1/src%2Flibcore%2Frt%2Flocal_services.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Flocal_services.rs?ref=d0786fdffcbae5c89762455fd3b3ffb5b9a3b6a1", "patch": "@@ -19,6 +19,7 @@\n //! (freestanding rust with local services?).\n \n use prelude::*;\n+use libc::c_void;\n use super::sched::{Task, local_sched};\n use super::local_heap::LocalHeap;\n \n@@ -27,11 +28,12 @@ pub struct LocalServices {\n     gc: GarbageCollector,\n     storage: LocalStorage,\n     logger: Logger,\n-    unwinder: Unwinder\n+    unwinder: Unwinder,\n+    destroyed: bool\n }\n \n pub struct GarbageCollector;\n-pub struct LocalStorage;\n+pub struct LocalStorage(*c_void, Option<~fn(*c_void)>);\n pub struct Logger;\n pub struct Unwinder;\n \n@@ -40,11 +42,34 @@ impl LocalServices {\n         LocalServices {\n             heap: LocalHeap::new(),\n             gc: GarbageCollector,\n-            storage: LocalStorage,\n+            storage: LocalStorage(ptr::null(), None),\n             logger: Logger,\n-            unwinder: Unwinder\n+            unwinder: Unwinder,\n+            destroyed: false\n         }\n     }\n+\n+    /// Must be called manually before finalization to clean up\n+    /// thread-local resources. Some of the routines here expect\n+    /// LocalServices to be available recursively so this must be\n+    /// called unsafely, without removing LocalServices from\n+    /// thread-local-storage.\n+    pub fn destroy(&mut self) {\n+        // This is just an assertion that `destroy` was called unsafely\n+        // and this instance of LocalServices is still accessible.\n+        do borrow_local_services |sched| {\n+            assert!(ptr::ref_eq(sched, self));\n+        }\n+        match self.storage {\n+            LocalStorage(ptr, Some(ref dtor)) => (*dtor)(ptr),\n+            _ => ()\n+        }\n+        self.destroyed = true;\n+    }\n+}\n+\n+impl Drop for LocalServices {\n+    fn finalize(&self) { assert!(self.destroyed) }\n }\n \n /// Borrow a pointer to the installed local services.\n@@ -62,6 +87,19 @@ pub fn borrow_local_services(f: &fn(&mut LocalServices)) {\n     }\n }\n \n+pub unsafe fn unsafe_borrow_local_services() -> &mut LocalServices {\n+    use cast::transmute_mut_region;\n+\n+    match local_sched::unsafe_borrow().current_task {\n+        Some(~ref mut task) => {\n+            transmute_mut_region(&mut task.local_services)\n+        }\n+        None => {\n+            fail!(~\"no local services for schedulers yet\")\n+        }\n+    }\n+}\n+\n #[cfg(test)]\n mod test {\n     use rt::test::*;\n@@ -75,4 +113,16 @@ mod test {\n             assert!(*b == 5);\n         }\n     }\n+\n+    #[test]\n+    fn tls() {\n+        use task::local_data::*;\n+        do run_in_newsched_task() {\n+            unsafe {\n+                fn key(_x: @~str) { }\n+                local_data_set(key, @~\"data\");\n+                assert!(*local_data_get(key).get() == ~\"data\");\n+            }\n+        }\n+    }\n }\n\\ No newline at end of file"}, {"sha": "b7d861b8946b8024807876a9e85dad67b5d265fc", "filename": "src/libcore/rt/sched/mod.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d0786fdffcbae5c89762455fd3b3ffb5b9a3b6a1/src%2Flibcore%2Frt%2Fsched%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0786fdffcbae5c89762455fd3b3ffb5b9a3b6a1/src%2Flibcore%2Frt%2Fsched%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fsched%2Fmod.rs?ref=d0786fdffcbae5c89762455fd3b3ffb5b9a3b6a1", "patch": "@@ -357,6 +357,13 @@ pub impl Task {\n \n             start();\n \n+            unsafe {\n+                // Destroy the local heap, TLS, etc.\n+                let sched = local_sched::unsafe_borrow();\n+                let task = sched.current_task.get_mut_ref();\n+                task.local_services.destroy();\n+            }\n+\n             let sched = local_sched::take();\n             sched.terminate_current_task();\n         };"}, {"sha": "6e919a74ed4f2ed55ceb7b4a5bbe4c0d7179abee", "filename": "src/libcore/task/local_data.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d0786fdffcbae5c89762455fd3b3ffb5b9a3b6a1/src%2Flibcore%2Ftask%2Flocal_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0786fdffcbae5c89762455fd3b3ffb5b9a3b6a1/src%2Flibcore%2Ftask%2Flocal_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Flocal_data.rs?ref=d0786fdffcbae5c89762455fd3b3ffb5b9a3b6a1", "patch": "@@ -27,7 +27,7 @@ magic.\n */\n \n use prelude::*;\n-use task::local_data_priv::{local_get, local_pop, local_modify, local_set};\n+use task::local_data_priv::{local_get, local_pop, local_modify, local_set, Handle};\n use task::rt;\n \n /**\n@@ -53,7 +53,7 @@ pub type LocalDataKey<'self,T> = &'self fn(v: @T);\n pub unsafe fn local_data_pop<T:Durable>(\n     key: LocalDataKey<T>) -> Option<@T> {\n \n-    local_pop(rt::rust_get_task(), key)\n+    local_pop(Handle::new(), key)\n }\n /**\n  * Retrieve a task-local data value. It will also be kept alive in the\n@@ -62,7 +62,7 @@ pub unsafe fn local_data_pop<T:Durable>(\n pub unsafe fn local_data_get<T:Durable>(\n     key: LocalDataKey<T>) -> Option<@T> {\n \n-    local_get(rt::rust_get_task(), key)\n+    local_get(Handle::new(), key)\n }\n /**\n  * Store a value in task-local data. If this key already has a value,\n@@ -71,7 +71,7 @@ pub unsafe fn local_data_get<T:Durable>(\n pub unsafe fn local_data_set<T:Durable>(\n     key: LocalDataKey<T>, data: @T) {\n \n-    local_set(rt::rust_get_task(), key, data)\n+    local_set(Handle::new(), key, data)\n }\n /**\n  * Modify a task-local data value. If the function returns 'None', the\n@@ -81,7 +81,7 @@ pub unsafe fn local_data_modify<T:Durable>(\n     key: LocalDataKey<T>,\n     modify_fn: &fn(Option<@T>) -> Option<@T>) {\n \n-    local_modify(rt::rust_get_task(), key, modify_fn)\n+    local_modify(Handle::new(), key, modify_fn)\n }\n \n #[test]"}, {"sha": "50e8286e738d257cf140a9133114a328522a7d90", "filename": "src/libcore/task/local_data_priv.rs", "status": "modified", "additions": 74, "deletions": 13, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/d0786fdffcbae5c89762455fd3b3ffb5b9a3b6a1/src%2Flibcore%2Ftask%2Flocal_data_priv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0786fdffcbae5c89762455fd3b3ffb5b9a3b6a1/src%2Flibcore%2Ftask%2Flocal_data_priv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Flocal_data_priv.rs?ref=d0786fdffcbae5c89762455fd3b3ffb5b9a3b6a1", "patch": "@@ -18,6 +18,30 @@ use task::rt;\n use task::local_data::LocalDataKey;\n \n use super::rt::rust_task;\n+use rt::local_services::LocalStorage;\n+\n+pub enum Handle {\n+    OldHandle(*rust_task),\n+    NewHandle(*mut LocalStorage)\n+}\n+\n+impl Handle {\n+    pub fn new() -> Handle {\n+        use rt::{context, OldTaskContext};\n+        use rt::local_services::unsafe_borrow_local_services;\n+        unsafe {\n+            match context() {\n+                OldTaskContext => {\n+                    OldHandle(rt::rust_get_task())\n+                }\n+                _ => {\n+                    let local_services = unsafe_borrow_local_services();\n+                    NewHandle(&mut local_services.storage)\n+                }\n+            }\n+        }\n+    }\n+}\n \n pub trait LocalData { }\n impl<T:Durable> LocalData for @T { }\n@@ -39,7 +63,7 @@ type TaskLocalElement = (*libc::c_void, *libc::c_void, @LocalData);\n // Has to be a pointer at outermost layer; the foreign call returns void *.\n type TaskLocalMap = @mut ~[Option<TaskLocalElement>];\n \n-extern fn cleanup_task_local_map(map_ptr: *libc::c_void) {\n+fn cleanup_task_local_map(map_ptr: *libc::c_void) {\n     unsafe {\n         assert!(!map_ptr.is_null());\n         // Get and keep the single reference that was created at the\n@@ -50,8 +74,19 @@ extern fn cleanup_task_local_map(map_ptr: *libc::c_void) {\n }\n \n // Gets the map from the runtime. Lazily initialises if not done so already.\n+unsafe fn get_local_map(handle: Handle) -> TaskLocalMap {\n+    match handle {\n+        OldHandle(task) => get_task_local_map(task),\n+        NewHandle(local_storage) => get_newsched_local_map(local_storage)\n+    }\n+}\n+\n unsafe fn get_task_local_map(task: *rust_task) -> TaskLocalMap {\n \n+    extern fn cleanup_task_local_map_(map_ptr: *libc::c_void) {\n+        cleanup_task_local_map(map_ptr);\n+    }\n+\n     // Relies on the runtime initialising the pointer to null.\n     // Note: The map's box lives in TLS invisibly referenced once. Each time\n     // we retrieve it for get/set, we make another reference, which get/set\n@@ -62,7 +97,7 @@ unsafe fn get_task_local_map(task: *rust_task) -> TaskLocalMap {\n         // Use reinterpret_cast -- transmute would take map away from us also.\n         rt::rust_set_task_local_data(\n             task, cast::reinterpret_cast(&map));\n-        rt::rust_task_local_data_atexit(task, cleanup_task_local_map);\n+        rt::rust_task_local_data_atexit(task, cleanup_task_local_map_);\n         // Also need to reference it an extra time to keep it for now.\n         let nonmut = cast::transmute::<TaskLocalMap,\n                                        @~[Option<TaskLocalElement>]>(map);\n@@ -77,6 +112,32 @@ unsafe fn get_task_local_map(task: *rust_task) -> TaskLocalMap {\n     }\n }\n \n+unsafe fn get_newsched_local_map(local: *mut LocalStorage) -> TaskLocalMap {\n+    match &mut *local {\n+        &LocalStorage(map_ptr, Some(_)) => {\n+            assert!(map_ptr.is_not_null());\n+            let map = cast::transmute(map_ptr);\n+            let nonmut = cast::transmute::<TaskLocalMap,\n+            @~[Option<TaskLocalElement>]>(map);\n+            cast::bump_box_refcount(nonmut);\n+            return map;\n+        }\n+        &LocalStorage(ref mut map_ptr, ref mut at_exit) => {\n+            assert!((*map_ptr).is_null());\n+            let map: TaskLocalMap = @mut ~[];\n+            // Use reinterpret_cast -- transmute would take map away from us also.\n+            *map_ptr = cast::reinterpret_cast(&map);\n+            let at_exit_fn: ~fn(*libc::c_void) = |p|cleanup_task_local_map(p);\n+            *at_exit = Some(at_exit_fn);\n+            // Also need to reference it an extra time to keep it for now.\n+            let nonmut = cast::transmute::<TaskLocalMap,\n+            @~[Option<TaskLocalElement>]>(map);\n+            cast::bump_box_refcount(nonmut);\n+            return map;\n+        }\n+    }\n+}\n+\n unsafe fn key_to_key_value<T:Durable>(\n     key: LocalDataKey<T>) -> *libc::c_void {\n \n@@ -106,10 +167,10 @@ unsafe fn local_data_lookup<T:Durable>(\n }\n \n unsafe fn local_get_helper<T:Durable>(\n-    task: *rust_task, key: LocalDataKey<T>,\n+    handle: Handle, key: LocalDataKey<T>,\n     do_pop: bool) -> Option<@T> {\n \n-    let map = get_task_local_map(task);\n+    let map = get_local_map(handle);\n     // Interpreturn our findings from the map\n     do local_data_lookup(map, key).map |result| {\n         // A reference count magically appears on 'data' out of thin air. It\n@@ -128,23 +189,23 @@ unsafe fn local_get_helper<T:Durable>(\n \n \n pub unsafe fn local_pop<T:Durable>(\n-    task: *rust_task,\n+    handle: Handle,\n     key: LocalDataKey<T>) -> Option<@T> {\n \n-    local_get_helper(task, key, true)\n+    local_get_helper(handle, key, true)\n }\n \n pub unsafe fn local_get<T:Durable>(\n-    task: *rust_task,\n+    handle: Handle,\n     key: LocalDataKey<T>) -> Option<@T> {\n \n-    local_get_helper(task, key, false)\n+    local_get_helper(handle, key, false)\n }\n \n pub unsafe fn local_set<T:Durable>(\n-    task: *rust_task, key: LocalDataKey<T>, data: @T) {\n+    handle: Handle, key: LocalDataKey<T>, data: @T) {\n \n-    let map = get_task_local_map(task);\n+    let map = get_local_map(handle);\n     // Store key+data as *voids. Data is invisibly referenced once; key isn't.\n     let keyval = key_to_key_value(key);\n     // We keep the data in two forms: one as an unsafe pointer, so we can get\n@@ -174,12 +235,12 @@ pub unsafe fn local_set<T:Durable>(\n }\n \n pub unsafe fn local_modify<T:Durable>(\n-    task: *rust_task, key: LocalDataKey<T>,\n+    handle: Handle, key: LocalDataKey<T>,\n     modify_fn: &fn(Option<@T>) -> Option<@T>) {\n \n     // Could be more efficient by doing the lookup work, but this is easy.\n-    let newdata = modify_fn(local_pop(task, key));\n+    let newdata = modify_fn(local_pop(handle, key));\n     if newdata.is_some() {\n-        local_set(task, key, newdata.unwrap());\n+        local_set(handle, key, newdata.unwrap());\n     }\n }"}, {"sha": "1e3857dff9a95b3bbf32f645d8eb0a97a4ea7862", "filename": "src/libcore/task/spawn.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d0786fdffcbae5c89762455fd3b3ffb5b9a3b6a1/src%2Flibcore%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0786fdffcbae5c89762455fd3b3ffb5b9a3b6a1/src%2Flibcore%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fspawn.rs?ref=d0786fdffcbae5c89762455fd3b3ffb5b9a3b6a1", "patch": "@@ -80,7 +80,7 @@ use prelude::*;\n use unstable;\n use ptr;\n use hashmap::HashSet;\n-use task::local_data_priv::{local_get, local_set};\n+use task::local_data_priv::{local_get, local_set, OldHandle};\n use task::rt::rust_task;\n use task::rt;\n use task::{Failure, ManualThreads, PlatformThread, SchedOpts, SingleThreaded};\n@@ -451,7 +451,7 @@ fn gen_child_taskgroup(linked: bool, supervised: bool)\n         /*##################################################################*\n          * Step 1. Get spawner's taskgroup info.\n          *##################################################################*/\n-        let spawner_group = match local_get(spawner, taskgroup_key!()) {\n+        let spawner_group = match local_get(OldHandle(spawner), taskgroup_key!()) {\n             None => {\n                 // Main task, doing first spawn ever. Lazily initialise here.\n                 let mut members = new_taskset();\n@@ -463,7 +463,7 @@ fn gen_child_taskgroup(linked: bool, supervised: bool)\n                 // Main task/group has no ancestors, no notifier, etc.\n                 let group =\n                     @TCB(spawner, tasks, AncestorList(None), true, None);\n-                local_set(spawner, taskgroup_key!(), group);\n+                local_set(OldHandle(spawner), taskgroup_key!(), group);\n                 group\n             }\n             Some(group) => group\n@@ -627,7 +627,7 @@ fn spawn_raw_oldsched(opts: TaskOpts, f: ~fn()) {\n                 let group = @TCB(child, child_arc, ancestors,\n                                  is_main, notifier);\n                 unsafe {\n-                    local_set(child, taskgroup_key!(), group);\n+                    local_set(OldHandle(child), taskgroup_key!(), group);\n                 }\n \n                 // Run the child's body."}]}