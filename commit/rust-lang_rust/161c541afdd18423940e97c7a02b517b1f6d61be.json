{"sha": "161c541afdd18423940e97c7a02b517b1f6d61be", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE2MWM1NDFhZmRkMTg0MjM5NDBlOTdjN2EwMmI1MTdiMWY2ZDYxYmU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-03-29T08:21:30Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-03-29T08:21:30Z"}, "message": "Auto merge of #32541 - troplin:chain-bufread, r=alexcrichton\n\nImplement BufRead for Chain\n\nAddresses #32536", "tree": {"sha": "68f37fb340b54580c1f40ed0d9e328985b07c4ef", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/68f37fb340b54580c1f40ed0d9e328985b07c4ef"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/161c541afdd18423940e97c7a02b517b1f6d61be", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/161c541afdd18423940e97c7a02b517b1f6d61be", "html_url": "https://github.com/rust-lang/rust/commit/161c541afdd18423940e97c7a02b517b1f6d61be", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/161c541afdd18423940e97c7a02b517b1f6d61be/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "21a4d8098fe3e16ba59f7d3cd435551242e5ec6e", "url": "https://api.github.com/repos/rust-lang/rust/commits/21a4d8098fe3e16ba59f7d3cd435551242e5ec6e", "html_url": "https://github.com/rust-lang/rust/commit/21a4d8098fe3e16ba59f7d3cd435551242e5ec6e"}, {"sha": "f611e446624d288da7def4ad175405579c8bc310", "url": "https://api.github.com/repos/rust-lang/rust/commits/f611e446624d288da7def4ad175405579c8bc310", "html_url": "https://github.com/rust-lang/rust/commit/f611e446624d288da7def4ad175405579c8bc310"}], "stats": {"total": 54, "additions": 54, "deletions": 0}, "files": [{"sha": "0f988c7623e389432660afba4846c46881bfd57c", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/161c541afdd18423940e97c7a02b517b1f6d61be/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/161c541afdd18423940e97c7a02b517b1f6d61be/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=161c541afdd18423940e97c7a02b517b1f6d61be", "patch": "@@ -1442,6 +1442,27 @@ impl<T: Read, U: Read> Read for Chain<T, U> {\n     }\n }\n \n+#[stable(feature = \"chain_bufread\", since = \"1.9.0\")]\n+impl<T: BufRead, U: BufRead> BufRead for Chain<T, U> {\n+    fn fill_buf(&mut self) -> Result<&[u8]> {\n+        if !self.done_first {\n+            match self.first.fill_buf()? {\n+                buf if buf.len() == 0 => { self.done_first = true; }\n+                buf => return Ok(buf),\n+            }\n+        }\n+        self.second.fill_buf()\n+    }\n+\n+    fn consume(&mut self, amt: usize) {\n+        if !self.done_first {\n+            self.first.consume(amt)\n+        } else {\n+            self.second.consume(amt)\n+        }\n+    }\n+}\n+\n /// Reader adaptor which limits the bytes read from an underlying reader.\n ///\n /// This struct is generally created by calling [`take()`][take] on a reader.\n@@ -1844,6 +1865,39 @@ mod tests {\n         assert_eq!(0, R.take(0).read(&mut buf).unwrap());\n     }\n \n+    fn cmp_bufread<Br1: BufRead, Br2: BufRead>(mut br1: Br1, mut br2: Br2, exp: &[u8]) {\n+        let mut cat = Vec::new();\n+        loop {\n+            let consume = {\n+                let buf1 = br1.fill_buf().unwrap();\n+                let buf2 = br2.fill_buf().unwrap();\n+                let minlen = if buf1.len() < buf2.len() { buf1.len() } else { buf2.len() };\n+                assert_eq!(buf1[..minlen], buf2[..minlen]);\n+                cat.extend_from_slice(&buf1[..minlen]);\n+                minlen\n+            };\n+            if consume == 0 {\n+                break;\n+            }\n+            br1.consume(consume);\n+            br2.consume(consume);\n+        }\n+        assert_eq!(br1.fill_buf().unwrap().len(), 0);\n+        assert_eq!(br2.fill_buf().unwrap().len(), 0);\n+        assert_eq!(&cat[..], &exp[..])\n+    }\n+\n+    #[test]\n+    fn chain_bufread() {\n+        let testdata = b\"ABCDEFGHIJKL\";\n+        let chain1 = (&testdata[..3]).chain(&testdata[3..6])\n+                                     .chain(&testdata[6..9])\n+                                     .chain(&testdata[9..]);\n+        let chain2 = (&testdata[..4]).chain(&testdata[4..8])\n+                                     .chain(&testdata[8..]);\n+        cmp_bufread(chain1, chain2, &testdata[..]);\n+    }\n+\n     #[bench]\n     fn bench_read_to_end(b: &mut test::Bencher) {\n         b.iter(|| {"}]}