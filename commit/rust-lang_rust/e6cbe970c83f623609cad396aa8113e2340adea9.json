{"sha": "e6cbe970c83f623609cad396aa8113e2340adea9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU2Y2JlOTcwYzgzZjYyMzYwOWNhZDM5NmFhODExM2UyMzQwYWRlYTk=", "commit": {"author": {"name": "mcarton", "email": "cartonmartin+git@gmail.com", "date": "2016-06-15T14:27:56Z"}, "committer": {"name": "mcarton", "email": "cartonmartin+git@gmail.com", "date": "2016-06-15T14:36:22Z"}, "message": "Don't use identifier hygiene in HIR", "tree": {"sha": "a0d49b2f37b201d99c5d5a3ecb424af000358530", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a0d49b2f37b201d99c5d5a3ecb424af000358530"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e6cbe970c83f623609cad396aa8113e2340adea9", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v2\n\niQIcBAABCAAGBQJXYWfnAAoJEF5CfHlMukXoNE8P/Rn/htpxk8bDDzSe72RXwGNR\nY68+y+9GlrdJSFSa4pkAuKzbGIedGKFso9EpMwEeKlZBC5PTDwIyVh0avla2U00v\nVIJ/8tunUpjF+KIw+6vMmz4WBWrJRdeBbUVPLUj7vuuMIfKae2ooj647BTpUa1sQ\nPfZpPu4uscvse4Sqc9ZBuyZ5EFx3F7gwcfm6n6IAz8kvsi48G8lotXO1gSAdMzIa\n3gWRiXAoyfrUjNZbCYuHWiXe7I1K2sXzHSvz3B7UEDkRDYFFQ56Mnng/g2t1ql6w\nKKtXKaIqxwajgU0axOfPwiv0hb0WD3kClvLOjv8z2S64JoihjUg8p34e6781v6SG\n0czzyLOlWWNWcsIAtzIj2uLvOdwLKXBi460OhZDZCGglVv2se266/R3smUHaMxOl\n8wko32YfatwBzA/8/sIvmEkhNV3wpeDFjKfQKWT/UcX7MwrmxYtCrjyPEegcoAoX\n8T4MHiLK6TscFfKxhgVOaIZXrzc2wWepeAfCi2JYd96ZCbzYjhTKstBVIZ0NOmOC\nUQjPiHD2X/2C4FCaaxjuvlz8vl6ceNoYvQMJVN9becjlqsQUnArh/VZZog5K7VTa\nMdvAY+XlN9waqEsLhyd+nIiuYVu9nVhq7HmTNVPnqzBUli8hfurrf4G2PoY5TUNH\nnYKAvgGKX++elplc72Vx\n=doVn\n-----END PGP SIGNATURE-----", "payload": "tree a0d49b2f37b201d99c5d5a3ecb424af000358530\nparent 06fd2468b281efac77af487fcd2cd16233f66e3a\nauthor mcarton <cartonmartin+git@gmail.com> 1466000876 +0200\ncommitter mcarton <cartonmartin+git@gmail.com> 1466001382 +0200\n\nDon't use identifier hygiene in HIR\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e6cbe970c83f623609cad396aa8113e2340adea9", "html_url": "https://github.com/rust-lang/rust/commit/e6cbe970c83f623609cad396aa8113e2340adea9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e6cbe970c83f623609cad396aa8113e2340adea9/comments", "author": {"login": "mcarton", "id": 3751788, "node_id": "MDQ6VXNlcjM3NTE3ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/3751788?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcarton", "html_url": "https://github.com/mcarton", "followers_url": "https://api.github.com/users/mcarton/followers", "following_url": "https://api.github.com/users/mcarton/following{/other_user}", "gists_url": "https://api.github.com/users/mcarton/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcarton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcarton/subscriptions", "organizations_url": "https://api.github.com/users/mcarton/orgs", "repos_url": "https://api.github.com/users/mcarton/repos", "events_url": "https://api.github.com/users/mcarton/events{/privacy}", "received_events_url": "https://api.github.com/users/mcarton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mcarton", "id": 3751788, "node_id": "MDQ6VXNlcjM3NTE3ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/3751788?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcarton", "html_url": "https://github.com/mcarton", "followers_url": "https://api.github.com/users/mcarton/followers", "following_url": "https://api.github.com/users/mcarton/following{/other_user}", "gists_url": "https://api.github.com/users/mcarton/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcarton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcarton/subscriptions", "organizations_url": "https://api.github.com/users/mcarton/orgs", "repos_url": "https://api.github.com/users/mcarton/repos", "events_url": "https://api.github.com/users/mcarton/events{/privacy}", "received_events_url": "https://api.github.com/users/mcarton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "06fd2468b281efac77af487fcd2cd16233f66e3a", "url": "https://api.github.com/repos/rust-lang/rust/commits/06fd2468b281efac77af487fcd2cd16233f66e3a", "html_url": "https://github.com/rust-lang/rust/commit/06fd2468b281efac77af487fcd2cd16233f66e3a"}], "stats": {"total": 73, "additions": 50, "deletions": 23}, "files": [{"sha": "495325764690c18b96e8d2e167cd47a539b2e1ca", "filename": "clippy_lints/src/misc.rs", "status": "modified", "additions": 31, "deletions": 16, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/e6cbe970c83f623609cad396aa8113e2340adea9/clippy_lints%2Fsrc%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6cbe970c83f623609cad396aa8113e2340adea9/clippy_lints%2Fsrc%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc.rs?ref=e6cbe970c83f623609cad396aa8113e2340adea9", "patch": "@@ -10,8 +10,8 @@ use rustc_const_math::ConstFloat;\n use syntax::codemap::{Span, Spanned, ExpnFormat};\n use syntax::ptr::P;\n use utils::{\n-    get_item_name, get_parent_expr, implements_trait, is_integer_literal, match_path, snippet,\n-    span_lint, span_lint_and_then, walk_ptrs_ty\n+    get_item_name, get_parent_expr, implements_trait, in_macro, is_integer_literal, match_path,\n+    snippet, span_lint, span_lint_and_then, walk_ptrs_ty\n };\n \n /// **What it does:** This lint checks for function arguments and let bindings denoted as `ref`.\n@@ -405,15 +405,18 @@ impl LateLintPass for UsedUnderscoreBinding {\n         }\n         let binding = match expr.node {\n             ExprPath(_, ref path) => {\n-                let segment = path.segments\n+                let binding = path.segments\n                                 .last()\n                                 .expect(\"path should always have at least one segment\")\n-                                .name;\n-                if segment.as_str().starts_with('_') &&\n-                   !segment.as_str().starts_with(\"__\") &&\n-                   segment != segment.unhygienize() && // not in bang macro\n-                   is_used(cx, expr) {\n-                    Some(segment.as_str())\n+                                .name\n+                                .as_str();\n+                if binding.starts_with('_') &&\n+                   !binding.starts_with(\"__\") &&\n+                   binding != \"_result\" && // FIXME: #944\n+                   is_used(cx, expr) &&\n+                   // don't lint if the declaration is in a macro\n+                   non_macro_local(cx, &cx.tcx.expect_def(expr.id)) {\n+                    Some(binding)\n                 } else {\n                     None\n                 }\n@@ -429,13 +432,11 @@ impl LateLintPass for UsedUnderscoreBinding {\n             _ => None,\n         };\n         if let Some(binding) = binding {\n-            if binding != \"_result\" { // FIXME: #944\n-                span_lint(cx,\n-                          USED_UNDERSCORE_BINDING,\n-                          expr.span,\n-                          &format!(\"used binding `{}` which is prefixed with an underscore. A leading \\\n-                                    underscore signals that a binding will not be used.\", binding));\n-            }\n+            span_lint(cx,\n+                      USED_UNDERSCORE_BINDING,\n+                      expr.span,\n+                      &format!(\"used binding `{}` which is prefixed with an underscore. A leading \\\n+                                underscore signals that a binding will not be used.\", binding));\n         }\n     }\n }\n@@ -463,3 +464,17 @@ fn in_attributes_expansion(cx: &LateContext, expr: &Expr) -> bool {\n         })\n     })\n }\n+\n+/// Test whether `def` is a variable defined outside a macro.\n+fn non_macro_local(cx: &LateContext, def: &def::Def) -> bool {\n+    match *def {\n+        def::Def::Local(_, id) | def::Def::Upvar(_, id, _, _) => {\n+            if let Some(span) = cx.tcx.map.opt_span(id) {\n+                !in_macro(cx, span)\n+            } else {\n+                true\n+            }\n+        }\n+        _ => false,\n+    }\n+}"}, {"sha": "9838ce0202cfc7e8bfc1e24c2b4c979a92313293", "filename": "clippy_lints/src/shadow.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e6cbe970c83f623609cad396aa8113e2340adea9/clippy_lints%2Fsrc%2Fshadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6cbe970c83f623609cad396aa8113e2340adea9/clippy_lints%2Fsrc%2Fshadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fshadow.rs?ref=e6cbe970c83f623609cad396aa8113e2340adea9", "patch": "@@ -66,7 +66,7 @@ fn check_fn(cx: &LateContext, decl: &FnDecl, block: &Block) {\n     let mut bindings = Vec::new();\n     for arg in &decl.inputs {\n         if let PatKind::Binding(_, ident, _) = arg.pat.node {\n-            bindings.push((ident.node.unhygienize(), ident.span))\n+            bindings.push((ident.node, ident.span))\n         }\n     }\n     check_block(cx, block, &mut bindings);\n@@ -120,7 +120,7 @@ fn check_pat(cx: &LateContext, pat: &Pat, init: &Option<&Expr>, span: Span, bind\n     // TODO: match more stuff / destructuring\n     match pat.node {\n         PatKind::Binding(_, ref ident, ref inner) => {\n-            let name = ident.node.unhygienize();\n+            let name = ident.node;\n             if is_binding(cx, pat) {\n                 let mut new_binding = true;\n                 for tup in bindings.iter_mut() {\n@@ -139,7 +139,6 @@ fn check_pat(cx: &LateContext, pat: &Pat, init: &Option<&Expr>, span: Span, bind\n                 check_pat(cx, p, init, span, bindings);\n             }\n         }\n-        // PatEnum(Path, Option<Vec<P<Pat>>>),\n         PatKind::Struct(_, ref pfields, _) => {\n             if let Some(ref init_struct) = *init {\n                 if let ExprStruct(_, ref efields, _) = init_struct.node {\n@@ -327,7 +326,7 @@ fn is_self_shadow(name: Name, expr: &Expr) -> bool {\n }\n \n fn path_eq_name(name: Name, path: &Path) -> bool {\n-    !path.global && path.segments.len() == 1 && path.segments[0].name.unhygienize() == name\n+    !path.global && path.segments.len() == 1 && path.segments[0].name.as_str() == name.as_str()\n }\n \n struct ContainsSelf {\n@@ -337,7 +336,7 @@ struct ContainsSelf {\n \n impl<'v> Visitor<'v> for ContainsSelf {\n     fn visit_name(&mut self, _: Span, name: Name) {\n-        if self.name == name.unhygienize() {\n+        if self.name == name {\n             self.result = true;\n         }\n     }"}, {"sha": "c3700d1b1cd430108ac7e7439443505195509c2e", "filename": "tests/compile-fail/used_underscore_binding.rs", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e6cbe970c83f623609cad396aa8113e2340adea9/tests%2Fcompile-fail%2Fused_underscore_binding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6cbe970c83f623609cad396aa8113e2340adea9/tests%2Fcompile-fail%2Fused_underscore_binding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fused_underscore_binding.rs?ref=e6cbe970c83f623609cad396aa8113e2340adea9", "patch": "@@ -5,14 +5,27 @@\n #![allow(blacklisted_name)]\n #![deny(used_underscore_binding)]\n \n+macro_rules! test_macro {\n+    () => {{\n+        let _foo = 42;\n+        _foo + 1\n+    }}\n+}\n+\n /// Test that we lint if we use a binding with a single leading underscore\n fn prefix_underscore(_foo: u32) -> u32 {\n     _foo + 1 //~ ERROR used binding `_foo` which is prefixed with an underscore\n }\n \n-/// Test that we lint even if the use is within a macro expansion\n+/// Test that we lint if we use a `_`-variable defined outside within a macro expansion\n fn in_macro(_foo: u32) {\n-    println!(\"{}\", _foo); //~ ERROR used binding `_foo` which is prefixed with an underscore\n+    println!(\"{}\", _foo);\n+    //~^ ERROR used binding `_foo` which is prefixed with an underscore\n+    assert_eq!(_foo, _foo);\n+    //~^ ERROR used binding `_foo` which is prefixed with an underscore\n+    //~| ERROR used binding `_foo` which is prefixed with an underscore\n+\n+    test_macro!() + 1;\n }\n \n // Struct for testing use of fields prefixed with an underscore"}]}