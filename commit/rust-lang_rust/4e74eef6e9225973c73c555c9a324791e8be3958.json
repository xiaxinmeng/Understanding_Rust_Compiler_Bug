{"sha": "4e74eef6e9225973c73c555c9a324791e8be3958", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRlNzRlZWY2ZTkyMjU5NzNjNzNjNTU1YzlhMzI0NzkxZThiZTM5NTg=", "commit": {"author": {"name": "flip1995", "email": "hello@philkrones.com", "date": "2018-11-27T14:13:57Z"}, "committer": {"name": "flip1995", "email": "hello@philkrones.com", "date": "2018-11-27T14:29:23Z"}, "message": "Add applicability level to (nearly) every span_lint_and_sugg function", "tree": {"sha": "6f5aa2019e3e4d2cda7c292f95b0726624e5ded3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6f5aa2019e3e4d2cda7c292f95b0726624e5ded3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4e74eef6e9225973c73c555c9a324791e8be3958", "comment_count": 0, "verification": {"verified": false, "reason": "unknown_key", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE46kBTF5vnyuSPg0W6OiXpYcOQcIFAlv9VMoACgkQ6OiXpYcO\nQcJFgA/+KXvZEN1zOLiTwU/j4HGI8hyxNKwUYLO4HLboXbtwufx3HS0gTKQM7LAj\nxXG9cwXiUE3RwY/AuOq3ruFLhXOwnhxQZx6FujmAuvLzj6HIFszv4T9ok154g6Om\nc3MYp9Lknf+Qxlxbn4dNTlnwOSOSSZyWuQTwR5eGTsSa++xuBCXNMI2HsnG7HF9x\ng8urgcsU1I9HyIo/eRXAVF5pYXqFLxVbMWYRC4PijVJdftn9SG+sI3vZMV/Fow1r\nqIaEtzbtaQrR+wlXLNRm7TTCCjHN4qngRt1y1HS2OZNGgUw+23KHbTUSE6VdJaSJ\noq3nJVB+VXWV/LQFM048xLAJJ8GyOeEelwF/cRDIYBzNlbvDIvtjXTRy79tOoXjA\nknh3vpmFPLUaf9cSpgMvgzJiQ/mYiEL2uQzixbMdqkvtTFhW/ucXqev97WS0kXMX\nPWMcJHOFwL/nrW/KtkkmCqc2JPpQck3nDIFxR52De0smrBiL+QEwX8IxHCgKbe3O\nmEjsYa6Y306Aeq6lwp7Zco+qS87QaEATIT244VQ3Hst5XumYTm9HCEWXn4WqKMc9\nm/LDP2Ue52f+mTUgPxt+bjoqIknKrIpbLlQcL57g1kfw6v1FZ8qmUGi2NghU5qzr\na0dofrENeLUP5UX3XJOT/R6Z9+HnXp3grrqTWUV3KsojmAVD2Sw=\n=uPTA\n-----END PGP SIGNATURE-----", "payload": "tree 6f5aa2019e3e4d2cda7c292f95b0726624e5ded3\nparent 0c6483bf215245c190d7a47bc9f3067bbc887e63\nauthor flip1995 <hello@philkrones.com> 1543328037 +0100\ncommitter flip1995 <hello@philkrones.com> 1543328963 +0100\n\nAdd applicability level to (nearly) every span_lint_and_sugg function\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4e74eef6e9225973c73c555c9a324791e8be3958", "html_url": "https://github.com/rust-lang/rust/commit/4e74eef6e9225973c73c555c9a324791e8be3958", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4e74eef6e9225973c73c555c9a324791e8be3958/comments", "author": {"login": "flip1995", "id": 9744647, "node_id": "MDQ6VXNlcjk3NDQ2NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/9744647?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flip1995", "html_url": "https://github.com/flip1995", "followers_url": "https://api.github.com/users/flip1995/followers", "following_url": "https://api.github.com/users/flip1995/following{/other_user}", "gists_url": "https://api.github.com/users/flip1995/gists{/gist_id}", "starred_url": "https://api.github.com/users/flip1995/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flip1995/subscriptions", "organizations_url": "https://api.github.com/users/flip1995/orgs", "repos_url": "https://api.github.com/users/flip1995/repos", "events_url": "https://api.github.com/users/flip1995/events{/privacy}", "received_events_url": "https://api.github.com/users/flip1995/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flip1995", "id": 9744647, "node_id": "MDQ6VXNlcjk3NDQ2NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/9744647?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flip1995", "html_url": "https://github.com/flip1995", "followers_url": "https://api.github.com/users/flip1995/followers", "following_url": "https://api.github.com/users/flip1995/following{/other_user}", "gists_url": "https://api.github.com/users/flip1995/gists{/gist_id}", "starred_url": "https://api.github.com/users/flip1995/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flip1995/subscriptions", "organizations_url": "https://api.github.com/users/flip1995/orgs", "repos_url": "https://api.github.com/users/flip1995/repos", "events_url": "https://api.github.com/users/flip1995/events{/privacy}", "received_events_url": "https://api.github.com/users/flip1995/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0c6483bf215245c190d7a47bc9f3067bbc887e63", "url": "https://api.github.com/repos/rust-lang/rust/commits/0c6483bf215245c190d7a47bc9f3067bbc887e63", "html_url": "https://github.com/rust-lang/rust/commit/0c6483bf215245c190d7a47bc9f3067bbc887e63"}], "stats": {"total": 364, "additions": 216, "deletions": 148}, "files": [{"sha": "88b61f07422460dacf77b9de35e66d2fec090808", "filename": "clippy_lints/src/attrs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4e74eef6e9225973c73c555c9a324791e8be3958/clippy_lints%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e74eef6e9225973c73c555c9a324791e8be3958/clippy_lints%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fattrs.rs?ref=4e74eef6e9225973c73c555c9a324791e8be3958", "patch": "@@ -532,7 +532,7 @@ impl EarlyLintPass for CfgAttrPass {\n                     \"`cfg_attr` is deprecated for rustfmt and got replaced by tool_attributes\",\n                     \"use\",\n                     format!(\"{}rustfmt::skip]\", attr_style),\n-                    Applicability::Unspecified,\n+                    Applicability::MachineApplicable,\n                 );\n             }\n         }"}, {"sha": "0547837795ddc4ac9a6e6172925146e26c5c69e8", "filename": "clippy_lints/src/bytecount.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4e74eef6e9225973c73c555c9a324791e8be3958/clippy_lints%2Fsrc%2Fbytecount.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e74eef6e9225973c73c555c9a324791e8be3958/clippy_lints%2Fsrc%2Fbytecount.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbytecount.rs?ref=4e74eef6e9225973c73c555c9a324791e8be3958", "patch": "@@ -15,7 +15,8 @@ use crate::rustc::{declare_tool_lint, lint_array};\n use crate::rustc_errors::Applicability;\n use crate::syntax::ast::{Name, UintTy};\n use crate::utils::{\n-    contains_name, get_pat_name, match_type, paths, single_segment_path, snippet, span_lint_and_sugg, walk_ptrs_ty,\n+    contains_name, get_pat_name, match_type, paths, single_segment_path, snippet_with_applicability,\n+    span_lint_and_sugg, walk_ptrs_ty,\n };\n use if_chain::if_chain;\n \n@@ -91,15 +92,16 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ByteCount {\n                         } else {\n                             &filter_args[0]\n                         };\n+                        let mut applicability = Applicability::MachineApplicable;\n                         span_lint_and_sugg(\n                             cx,\n                             NAIVE_BYTECOUNT,\n                             expr.span,\n                             \"You appear to be counting bytes the naive way\",\n                             \"Consider using the bytecount crate\",\n                             format!(\"bytecount::count({}, {})\",\n-                                    snippet(cx, haystack.span, \"..\"),\n-                                    snippet(cx, needle.span, \"..\")),\n+                                    snippet_with_applicability(cx, haystack.span, \"..\", &mut applicability),\n+                                    snippet_with_applicability(cx, needle.span, \"..\", &mut applicability)),\n                             Applicability::Unspecified,\n                         );\n                     }"}, {"sha": "206403791a187b7e0356c31632582cc5a929e0d4", "filename": "clippy_lints/src/collapsible_if.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4e74eef6e9225973c73c555c9a324791e8be3958/clippy_lints%2Fsrc%2Fcollapsible_if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e74eef6e9225973c73c555c9a324791e8be3958/clippy_lints%2Fsrc%2Fcollapsible_if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcollapsible_if.rs?ref=4e74eef6e9225973c73c555c9a324791e8be3958", "patch": "@@ -27,7 +27,7 @@ use crate::rustc::{declare_tool_lint, lint_array};\n use if_chain::if_chain;\n use crate::syntax::ast;\n \n-use crate::utils::{in_macro, snippet_block, span_lint_and_sugg, span_lint_and_then};\n+use crate::utils::{in_macro, snippet_block, snippet_block_with_applicability, span_lint_and_sugg, span_lint_and_then};\n use crate::utils::sugg::Sugg;\n use crate::rustc_errors::Applicability;\n \n@@ -128,14 +128,15 @@ fn check_collapsible_maybe_if_let(cx: &EarlyContext<'_>, else_: &ast::Expr) {\n         then {\n             match else_.node {\n                 ast::ExprKind::If(..) | ast::ExprKind::IfLet(..) => {\n+                    let mut applicability = Applicability::MachineApplicable;\n                     span_lint_and_sugg(\n                         cx,\n                         COLLAPSIBLE_IF,\n                         block.span,\n                         \"this `else { if .. }` block can be collapsed\",\n                         \"try\",\n-                        snippet_block(cx, else_.span, \"..\").into_owned(),\n-                        Applicability::Unspecified,\n+                        snippet_block_with_applicability(cx, else_.span, \"..\", &mut applicability).into_owned(),\n+                        applicability,\n                     );\n                 }\n                 _ => (),"}, {"sha": "693b47f6fff55545b1f4849c75ae31a9b7cec1a0", "filename": "clippy_lints/src/default_trait_access.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4e74eef6e9225973c73c555c9a324791e8be3958/clippy_lints%2Fsrc%2Fdefault_trait_access.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e74eef6e9225973c73c555c9a324791e8be3958/clippy_lints%2Fsrc%2Fdefault_trait_access.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdefault_trait_access.rs?ref=4e74eef6e9225973c73c555c9a324791e8be3958", "patch": "@@ -82,7 +82,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for DefaultTraitAccess {\n                                 &format!(\"Calling {} is more clear than this expression\", replacement),\n                                 \"try\",\n                                 replacement,\n-                                Applicability::Unspecified,\n+                                Applicability::Unspecified, // First resolve the TODO above\n                             );\n                          }\n                     },"}, {"sha": "4d8345dadc3a06bc563d2d1c80a5cc3d51db3608", "filename": "clippy_lints/src/double_comparison.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4e74eef6e9225973c73c555c9a324791e8be3958/clippy_lints%2Fsrc%2Fdouble_comparison.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e74eef6e9225973c73c555c9a324791e8be3958/clippy_lints%2Fsrc%2Fdouble_comparison.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdouble_comparison.rs?ref=4e74eef6e9225973c73c555c9a324791e8be3958", "patch": "@@ -16,7 +16,7 @@ use crate::rustc::{declare_tool_lint, lint_array};\n use crate::rustc_errors::Applicability;\n use crate::syntax::source_map::Span;\n \n-use crate::utils::{snippet, span_lint_and_sugg, SpanlessEq};\n+use crate::utils::{snippet_with_applicability, span_lint_and_sugg, SpanlessEq};\n \n /// **What it does:** Checks for double comparions that could be simpified to a single expression.\n ///\n@@ -71,8 +71,9 @@ impl<'a, 'tcx> Pass {\n         }\n         macro_rules! lint_double_comparison {\n             ($op:tt) => {{\n-                let lhs_str = snippet(cx, llhs.span, \"\");\n-                let rhs_str = snippet(cx, lrhs.span, \"\");\n+                let mut applicability = Applicability::MachineApplicable;\n+                let lhs_str = snippet_with_applicability(cx, llhs.span, \"\", &mut applicability);\n+                let rhs_str = snippet_with_applicability(cx, lrhs.span, \"\", &mut applicability);\n                 let sugg = format!(\"{} {} {}\", lhs_str, stringify!($op), rhs_str);\n                 span_lint_and_sugg(\n                     cx,\n@@ -81,7 +82,7 @@ impl<'a, 'tcx> Pass {\n                     \"This binary expression can be simplified\",\n                     \"try\",\n                     sugg,\n-                    Applicability::Unspecified,\n+                    applicability,\n                 );\n             }}\n         }"}, {"sha": "fe4aea572e050a9c4d971aa5fc2d831d3da636fe", "filename": "clippy_lints/src/duration_subsec.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4e74eef6e9225973c73c555c9a324791e8be3958/clippy_lints%2Fsrc%2Fduration_subsec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e74eef6e9225973c73c555c9a324791e8be3958/clippy_lints%2Fsrc%2Fduration_subsec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fduration_subsec.rs?ref=4e74eef6e9225973c73c555c9a324791e8be3958", "patch": "@@ -17,7 +17,7 @@ use if_chain::if_chain;\n \n use crate::consts::{constant, Constant};\n use crate::utils::paths;\n-use crate::utils::{match_type, snippet, span_lint_and_sugg, walk_ptrs_ty};\n+use crate::utils::{match_type, snippet_with_applicability, span_lint_and_sugg, walk_ptrs_ty};\n \n /// **What it does:** Checks for calculation of subsecond microseconds or milliseconds\n /// from other `Duration` methods.\n@@ -61,14 +61,15 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for DurationSubsec {\n                     (\"subsec_nanos\", 1_000) => \"subsec_micros\",\n                     _ => return,\n                 };\n+                let mut applicability = Applicability::MachineApplicable;\n                 span_lint_and_sugg(\n                     cx,\n                     DURATION_SUBSEC,\n                     expr.span,\n                     &format!(\"Calling `{}()` is more concise than this calculation\", suggested_fn),\n                     \"try\",\n-                    format!(\"{}.{}()\", snippet(cx, args[0].span, \"_\"), suggested_fn),\n-                    Applicability::Unspecified,\n+                    format!(\"{}.{}()\", snippet_with_applicability(cx, args[0].span, \"_\", &mut applicability), suggested_fn),\n+                    applicability,\n                 );\n             }\n         }"}, {"sha": "6043dd46ae714c0575e1878d81b1dd05b034768f", "filename": "clippy_lints/src/excessive_precision.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4e74eef6e9225973c73c555c9a324791e8be3958/clippy_lints%2Fsrc%2Fexcessive_precision.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e74eef6e9225973c73c555c9a324791e8be3958/clippy_lints%2Fsrc%2Fexcessive_precision.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fexcessive_precision.rs?ref=4e74eef6e9225973c73c555c9a324791e8be3958", "patch": "@@ -69,7 +69,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ExcessivePrecision {\n                     \"float has excessive precision\",\n                     \"consider changing the type or truncating it to\",\n                     sugg,\n-                    Applicability::Unspecified,\n+                    Applicability::MachineApplicable,\n                 );\n             }\n         }"}, {"sha": "558d101d68ec6233e0d2f8c9f71c2cb74395dce2", "filename": "clippy_lints/src/infallible_destructuring_match.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4e74eef6e9225973c73c555c9a324791e8be3958/clippy_lints%2Fsrc%2Finfallible_destructuring_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e74eef6e9225973c73c555c9a324791e8be3958/clippy_lints%2Fsrc%2Finfallible_destructuring_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Finfallible_destructuring_match.rs?ref=4e74eef6e9225973c73c555c9a324791e8be3958", "patch": "@@ -8,7 +8,7 @@\n // except according to those terms.\n \n \n-use super::utils::{get_arg_name, match_var, remove_blocks, snippet, span_lint_and_sugg};\n+use super::utils::{get_arg_name, match_var, remove_blocks, snippet_with_applicability, span_lint_and_sugg};\n use crate::rustc::hir::*;\n use crate::rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use crate::rustc::{declare_tool_lint, lint_array};\n@@ -72,6 +72,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n             if match_var(body, arg);\n \n             then {\n+                let mut applicability = Applicability::MachineApplicable;\n                 span_lint_and_sugg(\n                     cx,\n                     INFALLIBLE_DESTRUCTURING_MATCH,\n@@ -81,11 +82,11 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                     \"try this\",\n                     format!(\n                         \"let {}({}) = {};\",\n-                        snippet(cx, variant_name.span, \"..\"),\n-                        snippet(cx, local.pat.span, \"..\"),\n-                        snippet(cx, target.span, \"..\"),\n+                        snippet_with_applicability(cx, variant_name.span, \"..\", &mut applicability),\n+                        snippet_with_applicability(cx, local.pat.span, \"..\", &mut applicability),\n+                        snippet_with_applicability(cx, target.span, \"..\", &mut applicability),\n                     ),\n-                    Applicability::Unspecified,\n+                    applicability,\n                 );\n             }\n         }"}, {"sha": "15c21d776988581f4243395dcd3b480f720b18db", "filename": "clippy_lints/src/len_zero.rs", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/4e74eef6e9225973c73c555c9a324791e8be3958/clippy_lints%2Fsrc%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e74eef6e9225973c73c555c9a324791e8be3958/clippy_lints%2Fsrc%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flen_zero.rs?ref=4e74eef6e9225973c73c555c9a324791e8be3958", "patch": "@@ -17,7 +17,7 @@ use crate::rustc_data_structures::fx::FxHashSet;\n use crate::rustc_errors::Applicability;\n use crate::syntax::ast::{Lit, LitKind, Name};\n use crate::syntax::source_map::{Span, Spanned};\n-use crate::utils::{get_item_name, in_macro, snippet, span_lint, span_lint_and_sugg, walk_ptrs_ty};\n+use crate::utils::{get_item_name, in_macro, snippet_with_applicability, span_lint, span_lint_and_sugg, walk_ptrs_ty};\n \n /// **What it does:** Checks for getting the length of something via `.len()`\n /// just to compare to zero, and suggests using `.is_empty()` where applicable.\n@@ -224,7 +224,15 @@ fn check_cmp(cx: &LateContext<'_, '_>, span: Span, method: &Expr, lit: &Expr, op\n     }\n }\n \n-fn check_len(cx: &LateContext<'_, '_>, span: Span, method_name: Name, args: &[Expr], lit: &Lit, op: &str, compare_to: u32) {\n+fn check_len(\n+    cx: &LateContext<'_, '_>,\n+    span: Span,\n+    method_name: Name,\n+    args: &[Expr],\n+    lit: &Lit,\n+    op: &str,\n+    compare_to: u32,\n+) {\n     if let Spanned {\n         node: LitKind::Int(lit, _),\n         ..\n@@ -236,14 +244,15 @@ fn check_len(cx: &LateContext<'_, '_>, span: Span, method_name: Name, args: &[Ex\n         }\n \n         if method_name == \"len\" && args.len() == 1 && has_is_empty(cx, &args[0]) {\n+            let mut applicability = Applicability::MachineApplicable;\n             span_lint_and_sugg(\n                 cx,\n                 LEN_ZERO,\n                 span,\n                 &format!(\"length comparison to {}\", if compare_to == 0 { \"zero\" } else { \"one\" }),\n                 \"using `is_empty` is clearer and more explicit\",\n-                format!(\"{}{}.is_empty()\", op, snippet(cx, args[0].span, \"_\")),\n-                Applicability::Unspecified,\n+                format!(\"{}{}.is_empty()\", op, snippet_with_applicability(cx, args[0].span, \"_\", &mut applicability)),\n+                applicability,\n             );\n         }\n     }"}, {"sha": "8d7f549da39ef984ec451bbe1593c36881d8e206", "filename": "clippy_lints/src/literal_representation.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4e74eef6e9225973c73c555c9a324791e8be3958/clippy_lints%2Fsrc%2Fliteral_representation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e74eef6e9225973c73c555c9a324791e8be3958/clippy_lints%2Fsrc%2Fliteral_representation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fliteral_representation.rs?ref=4e74eef6e9225973c73c555c9a324791e8be3958", "patch": "@@ -301,7 +301,7 @@ impl WarningType {\n                 \"mistyped literal suffix\",\n                 \"did you mean to write\",\n                 grouping_hint.to_string(),\n-                Applicability::Unspecified,\n+                Applicability::MachineApplicable,\n             ),\n             WarningType::UnreadableLiteral => span_lint_and_sugg(\n                 cx,\n@@ -310,7 +310,7 @@ impl WarningType {\n                 \"long literal lacking separators\",\n                 \"consider\",\n                 grouping_hint.to_owned(),\n-                Applicability::Unspecified,\n+                Applicability::MachineApplicable,\n             ),\n             WarningType::LargeDigitGroups => span_lint_and_sugg(\n                 cx,\n@@ -319,7 +319,7 @@ impl WarningType {\n                 \"digit groups should be smaller\",\n                 \"consider\",\n                 grouping_hint.to_owned(),\n-                Applicability::Unspecified,\n+                Applicability::MachineApplicable,\n             ),\n             WarningType::InconsistentDigitGrouping => span_lint_and_sugg(\n                 cx,\n@@ -328,7 +328,7 @@ impl WarningType {\n                 \"digits grouped inconsistently by underscores\",\n                 \"consider\",\n                 grouping_hint.to_owned(),\n-                Applicability::Unspecified,\n+                Applicability::MachineApplicable,\n             ),\n             WarningType::DecimalRepresentation => span_lint_and_sugg(\n                 cx,\n@@ -337,7 +337,7 @@ impl WarningType {\n                 \"integer literal has a better hexadecimal representation\",\n                 \"consider\",\n                 grouping_hint.to_owned(),\n-                Applicability::Unspecified,\n+                Applicability::MachineApplicable,\n             ),\n         };\n     }"}, {"sha": "0704246d450269ca5719701ebef23b014ac302cf", "filename": "clippy_lints/src/loops.rs", "status": "modified", "additions": 17, "deletions": 12, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/4e74eef6e9225973c73c555c9a324791e8be3958/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e74eef6e9225973c73c555c9a324791e8be3958/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=4e74eef6e9225973c73c555c9a324791e8be3958", "patch": "@@ -35,10 +35,12 @@ use crate::utils::{in_macro, sugg, sext};\n use crate::utils::usage::mutated_variables;\n use crate::consts::{constant, Constant};\n \n-use crate::utils::{get_enclosing_block, get_parent_expr, higher, is_integer_literal, is_refutable,\n-            last_path_segment, match_trait_method, match_type, match_var, multispan_sugg, snippet, snippet_opt,\n-            span_help_and_lint, span_lint, span_lint_and_sugg, span_lint_and_then, SpanlessEq};\n use crate::utils::paths;\n+use crate::utils::{\n+    get_enclosing_block, get_parent_expr, higher, is_integer_literal, is_refutable, last_path_segment,\n+    match_trait_method, match_type, match_var, multispan_sugg, snippet, snippet_opt, snippet_with_applicability,\n+    span_help_and_lint, span_lint, span_lint_and_sugg, span_lint_and_then, SpanlessEq,\n+};\n \n /// **What it does:** Checks for for-loops that manually copy items between\n /// slices that could be optimized by having a memcpy.\n@@ -501,6 +503,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                                 // 1) it was ugly with big bodies;\n                                 // 2) it was not indented properly;\n                                 // 3) it wasn\u2019t very smart (see #675).\n+                                let mut applicability = Applicability::MachineApplicable;\n                                 span_lint_and_sugg(\n                                     cx,\n                                     WHILE_LET_LOOP,\n@@ -509,10 +512,10 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                                     \"try\",\n                                     format!(\n                                         \"while let {} = {} {{ .. }}\",\n-                                        snippet(cx, arms[0].pats[0].span, \"..\"),\n-                                        snippet(cx, matchexpr.span, \"..\")\n+                                        snippet_with_applicability(cx, arms[0].pats[0].span, \"..\", &mut applicability),\n+                                        snippet_with_applicability(cx, matchexpr.span, \"..\", &mut applicability),\n                                     ),\n-                                    Applicability::Unspecified,\n+                                    applicability,\n                                 );\n                             }\n                         },\n@@ -550,7 +553,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                         \"this loop could be written as a `for` loop\",\n                         \"try\",\n                         format!(\"for {} in {} {{ .. }}\", loop_var, iterator),\n-                        Applicability::Unspecified,\n+                        Applicability::HasPlaceholders,\n                     );\n                 }\n             }\n@@ -1006,7 +1009,7 @@ fn detect_manual_memcpy<'a, 'tcx>(\n             let big_sugg = manual_copies\n                 .into_iter()\n                 .map(|(dst_var, src_var)| {\n-                    let start_str = Offset::positive(snippet_opt(cx, start.span).unwrap_or_else(|| \"\".into()));\n+                    let start_str = Offset::positive(snippet(cx, start.span, \"\").to_string());\n                     let dst_offset = print_sum(&start_str, &dst_var.offset);\n                     let dst_limit = print_limit(end, dst_var.offset, &dst_var.var_name);\n                     let src_offset = print_sum(&start_str, &src_var.offset);\n@@ -1305,7 +1308,8 @@ fn check_for_loop_reverse_range<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, arg: &'tcx\n }\n \n fn lint_iter_method(cx: &LateContext<'_, '_>, args: &[Expr], arg: &Expr, method_name: &str) {\n-    let object = snippet(cx, args[0].span, \"_\");\n+    let mut applicability = Applicability::MachineApplicable;\n+    let object = snippet_with_applicability(cx, args[0].span, \"_\", &mut applicability);\n     let muta = if method_name == \"iter_mut\" {\n         \"mut \"\n     } else {\n@@ -1319,7 +1323,7 @@ fn lint_iter_method(cx: &LateContext<'_, '_>, args: &[Expr], arg: &Expr, method_\n          iteration methods\",\n         \"to write this more concisely, try\",\n         format!(\"&{}{}\", muta, object),\n-        Applicability::Unspecified,\n+        applicability,\n     )\n }\n \n@@ -1349,7 +1353,8 @@ fn check_for_loop_arg(cx: &LateContext<'_, '_>, pat: &Pat, arg: &Expr, expr: &Ex\n                         _ => lint_iter_method(cx, args, arg, method_name),\n                     };\n                 } else {\n-                    let object = snippet(cx, args[0].span, \"_\");\n+                    let mut applicability = Applicability::MachineApplicable;\n+                    let object = snippet_with_applicability(cx, args[0].span, \"_\", &mut applicability);\n                     span_lint_and_sugg(\n                         cx,\n                         EXPLICIT_INTO_ITER_LOOP,\n@@ -1358,7 +1363,7 @@ fn check_for_loop_arg(cx: &LateContext<'_, '_>, pat: &Pat, arg: &Expr, expr: &Ex\n                          iteration methods`\",\n                         \"to write this more concisely, try\",\n                         object.to_string(),\n-                        Applicability::Unspecified,\n+                        applicability,\n                     );\n                 }\n             } else if method_name == \"next\" && match_trait_method(cx, arg, &paths::ITERATOR) {"}, {"sha": "4424143160c5f5f1c9c8e92a6ab54aef4fb9ff2c", "filename": "clippy_lints/src/map_clone.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4e74eef6e9225973c73c555c9a324791e8be3958/clippy_lints%2Fsrc%2Fmap_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e74eef6e9225973c73c555c9a324791e8be3958/clippy_lints%2Fsrc%2Fmap_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmap_clone.rs?ref=4e74eef6e9225973c73c555c9a324791e8be3958", "patch": "@@ -15,7 +15,7 @@ use crate::rustc_errors::Applicability;\n use crate::syntax::ast::Ident;\n use crate::syntax::source_map::Span;\n use crate::utils::paths;\n-use crate::utils::{in_macro, match_trait_method, match_type, remove_blocks, snippet, span_lint_and_sugg};\n+use crate::utils::{in_macro, match_trait_method, match_type, remove_blocks, snippet_with_applicability, span_lint_and_sugg};\n use if_chain::if_chain;\n \n #[derive(Clone)]\n@@ -92,14 +92,15 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n fn lint(cx: &LateContext<'_, '_>, replace: Span, root: Span, name: Ident, path: &hir::Expr) {\n     if let hir::ExprKind::Path(hir::QPath::Resolved(None, ref path)) = path.node {\n         if path.segments.len() == 1 && path.segments[0].ident == name {\n+            let mut applicability = Applicability::MachineApplicable;\n             span_lint_and_sugg(\n                 cx,\n                 MAP_CLONE,\n                 replace,\n                 \"You are using an explicit closure for cloning elements\",\n                 \"Consider calling the dedicated `cloned` method\",\n-                format!(\"{}.cloned()\", snippet(cx, root, \"..\")),\n-                Applicability::Unspecified,\n+                format!(\"{}.cloned()\", snippet_with_applicability(cx, root, \"..\", &mut applicability)),\n+                applicability,\n             )\n         }\n     }"}, {"sha": "583cdee843f70a2c09a5f625770a19f73fc673cf", "filename": "clippy_lints/src/matches.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4e74eef6e9225973c73c555c9a324791e8be3958/clippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e74eef6e9225973c73c555c9a324791e8be3958/clippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches.rs?ref=4e74eef6e9225973c73c555c9a324791e8be3958", "patch": "@@ -19,7 +19,7 @@ use crate::syntax::ast::LitKind;\n use crate::syntax::source_map::Span;\n use crate::utils::paths;\n use crate::utils::{expr_block, in_macro, is_allowed, is_expn_of, match_qpath, match_type,\n-    multispan_sugg, remove_blocks, snippet, span_lint_and_sugg, span_lint_and_then,\n+    multispan_sugg, remove_blocks, snippet, snippet_with_applicability, span_lint_and_sugg, span_lint_and_then,\n     span_note_and_lint, walk_ptrs_ty};\n use crate::utils::sugg::Sugg;\n use crate::consts::{constant, Constant};\n@@ -270,7 +270,7 @@ fn report_single_match_single_pattern(cx: &LateContext<'_, '_>, ex: &Expr, arms:\n             expr_block(cx, &arms[0].body, None, \"..\"),\n             els_str,\n         ),\n-        Applicability::Unspecified,\n+        Applicability::HasPlaceholders,\n     );\n }\n \n@@ -478,14 +478,15 @@ fn check_match_as_ref(cx: &LateContext<'_, '_>, ex: &Expr, arms: &[Arm], expr: &\n         };\n         if let Some(rb) = arm_ref {\n             let suggestion = if rb == BindingAnnotation::Ref { \"as_ref\" } else { \"as_mut\" };\n+            let mut applicability = Applicability::MachineApplicable;\n             span_lint_and_sugg(\n                 cx,\n                 MATCH_AS_REF,\n                 expr.span,\n                 &format!(\"use {}() instead\", suggestion),\n                 \"try this\",\n-                format!(\"{}.{}()\", snippet(cx, ex.span, \"_\"), suggestion),\n-                Applicability::Unspecified,\n+                format!(\"{}.{}()\", snippet_with_applicability(cx, ex.span, \"_\", &mut applicability), suggestion),\n+                applicability,\n             )\n         }\n     }"}, {"sha": "f0310b87f6916279bb56be97c673a22963b6efa2", "filename": "clippy_lints/src/mem_replace.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4e74eef6e9225973c73c555c9a324791e8be3958/clippy_lints%2Fsrc%2Fmem_replace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e74eef6e9225973c73c555c9a324791e8be3958/clippy_lints%2Fsrc%2Fmem_replace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmem_replace.rs?ref=4e74eef6e9225973c73c555c9a324791e8be3958", "patch": "@@ -12,7 +12,7 @@ use crate::rustc::hir::{Expr, ExprKind, MutMutable, QPath};\n use crate::rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use crate::rustc::{declare_tool_lint, lint_array};\n use crate::rustc_errors::Applicability;\n-use crate::utils::{match_def_path, match_qpath, opt_def_id, paths, snippet, span_lint_and_sugg};\n+use crate::utils::{match_def_path, match_qpath, opt_def_id, paths, snippet_with_applicability, span_lint_and_sugg};\n use if_chain::if_chain;\n \n /// **What it does:** Checks for `mem::replace()` on an `Option` with\n@@ -80,14 +80,15 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MemReplace {\n                     _ => return,\n                 };\n \n+                let mut applicability = Applicability::MachineApplicable;\n                 span_lint_and_sugg(\n                     cx,\n                     MEM_REPLACE_OPTION_WITH_NONE,\n                     expr.span,\n                     \"replacing an `Option` with `None`\",\n                     \"consider `Option::take()` instead\",\n-                    format!(\"{}.take()\", snippet(cx, replaced_path.span, \"\")),\n-                    Applicability::Unspecified,\n+                    format!(\"{}.take()\", snippet_with_applicability(cx, replaced_path.span, \"\", &mut applicability)),\n+                    applicability,\n                 );\n             }\n         }"}, {"sha": "dc939ad0815795794eee44a8746e9d1b642fabff", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 46, "deletions": 31, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/4e74eef6e9225973c73c555c9a324791e8be3958/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e74eef6e9225973c73c555c9a324791e8be3958/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=4e74eef6e9225973c73c555c9a324791e8be3958", "patch": "@@ -22,8 +22,9 @@ use crate::utils::sugg;\n use crate::utils::{\n     get_arg_name, get_trait_def_id, implements_trait, in_macro, is_copy, is_expn_of, is_self, is_self_ty,\n     iter_input_pats, last_path_segment, match_def_path, match_path, match_qpath, match_trait_method, match_type,\n-    match_var, method_calls, method_chain_args, remove_blocks, return_ty, same_tys, single_segment_path, snippet, snippet_with_macro_callsite, span_lint,\n-    span_lint_and_sugg, span_lint_and_then, span_note_and_lint, walk_ptrs_ty, walk_ptrs_ty_depth, SpanlessEq,\n+    match_var, method_calls, method_chain_args, remove_blocks, return_ty, same_tys, single_segment_path, snippet,\n+    snippet_with_macro_callsite, snippet_with_applicability, span_lint, span_lint_and_sugg, span_lint_and_then,\n+    span_note_and_lint, walk_ptrs_ty, walk_ptrs_ty_depth, SpanlessEq,\n };\n use if_chain::if_chain;\n use matches::matches;\n@@ -1035,14 +1036,15 @@ fn lint_or_fun_call(cx: &LateContext<'_, '_>, expr: &hir::Expr, method_span: Spa\n                     };\n \n                     if implements_trait(cx, arg_ty, default_trait_id, &[]) {\n+                        let mut applicability = Applicability::MachineApplicable;\n                         span_lint_and_sugg(\n                             cx,\n                             OR_FUN_CALL,\n                             span,\n                             &format!(\"use of `{}` followed by a call to `{}`\", name, path),\n                             \"try this\",\n-                            format!(\"{}.unwrap_or_default()\", snippet(cx, self_expr.span, \"_\")),\n-                            Applicability::Unspecified,\n+                            format!(\"{}.unwrap_or_default()\", snippet_with_applicability(cx, self_expr.span, \"_\", &mut applicability)),\n+                            applicability,\n                         );\n                         return true;\n                     }\n@@ -1112,7 +1114,7 @@ fn lint_or_fun_call(cx: &LateContext<'_, '_>, expr: &hir::Expr, method_span: Spa\n             &format!(\"use of `{}` followed by a function call\", name),\n             \"try this\",\n             format!(\"{}_{}({})\", name, suffix, sugg),\n-            Applicability::Unspecified,\n+            Applicability::HasPlaceholders,\n         );\n     }\n \n@@ -1155,11 +1157,15 @@ fn lint_expect_fun_call(cx: &LateContext<'_, '_>, expr: &hir::Expr, method_span:\n         None\n     }\n \n-    fn generate_format_arg_snippet(cx: &LateContext<'_, '_>, a: &hir::Expr) -> String {\n+    fn generate_format_arg_snippet(\n+        cx: &LateContext<'_, '_>,\n+        a: &hir::Expr,\n+        applicability: &mut Applicability,\n+    ) -> String {\n         if let hir::ExprKind::AddrOf(_, ref format_arg) = a.node {\n             if let hir::ExprKind::Match(ref format_arg_expr, _, _) = format_arg.node {\n                 if let hir::ExprKind::Tup(ref format_arg_expr_tup) = format_arg_expr.node {\n-                    return snippet(cx, format_arg_expr_tup[0].span, \"..\").into_owned();\n+                    return snippet_with_applicability(cx, format_arg_expr_tup[0].span, \"..\", applicability).into_owned();\n                 }\n             }\n         };\n@@ -1210,11 +1216,12 @@ fn lint_expect_fun_call(cx: &LateContext<'_, '_>, expr: &hir::Expr, method_span:\n         let span_replace_word = method_span.with_hi(span.hi());\n \n         if let Some(format_args) = extract_format_args(arg) {\n+            let mut applicability = Applicability::MachineApplicable;\n             let args_len = format_args.len();\n             let args: Vec<String> = format_args\n                 .into_iter()\n                 .take(args_len - 1)\n-                .map(|a| generate_format_arg_snippet(cx, a))\n+                .map(|a| generate_format_arg_snippet(cx, a, &mut applicability))\n                 .collect();\n \n             let sugg = args.join(\", \");\n@@ -1226,13 +1233,14 @@ fn lint_expect_fun_call(cx: &LateContext<'_, '_>, expr: &hir::Expr, method_span:\n                 &format!(\"use of `{}` followed by a function call\", name),\n                 \"try this\",\n                 format!(\"unwrap_or_else({} panic!({}))\", closure, sugg),\n-                Applicability::Unspecified,\n+                applicability,\n             );\n \n             return;\n         }\n \n-        let sugg: Cow<'_, _> = snippet(cx, arg.span, \"..\");\n+        let mut applicability = Applicability::MachineApplicable;\n+        let sugg: Cow<'_, _> = snippet_with_applicability(cx, arg.span, \"..\", &mut applicability);\n \n         span_lint_and_sugg(\n             cx,\n@@ -1241,7 +1249,7 @@ fn lint_expect_fun_call(cx: &LateContext<'_, '_>, expr: &hir::Expr, method_span:\n             &format!(\"use of `{}` followed by a function call\", name),\n             \"try this\",\n             format!(\"unwrap_or_else({} {{ let msg = {}; panic!(msg) }}))\", closure, sugg),\n-            Applicability::Unspecified,\n+            applicability,\n         );\n     }\n \n@@ -1358,7 +1366,7 @@ fn lint_clone_on_ref_ptr(cx: &LateContext<'_, '_>, expr: &hir::Expr, arg: &hir::\n             \"using '.clone()' on a ref-counted pointer\",\n             \"try this\",\n             format!(\"{}::<{}>::clone(&{})\", caller_type, subst.type_at(0), snippet(cx, arg.span, \"_\")),\n-            Applicability::Unspecified,\n+            Applicability::Unspecified, // Sometimes unnecessary ::<_> after Rc/Arc/Weak\n         );\n     }\n }\n@@ -1377,6 +1385,7 @@ fn lint_string_extend(cx: &LateContext<'_, '_>, expr: &hir::Expr, args: &[hir::E\n             return;\n         };\n \n+        let mut applicability = Applicability::MachineApplicable;\n         span_lint_and_sugg(\n             cx,\n             STRING_EXTEND_CHARS,\n@@ -1385,11 +1394,11 @@ fn lint_string_extend(cx: &LateContext<'_, '_>, expr: &hir::Expr, args: &[hir::E\n             \"try this\",\n             format!(\n                 \"{}.push_str({}{})\",\n-                snippet(cx, args[0].span, \"_\"),\n+                snippet_with_applicability(cx, args[0].span, \"_\", &mut applicability),\n                 ref_str,\n-                snippet(cx, target.span, \"_\")\n+                snippet_with_applicability(cx, target.span, \"_\", &mut applicability)\n             ),\n-            Applicability::Unspecified,\n+            applicability,\n         );\n     }\n }\n@@ -1466,12 +1475,13 @@ fn lint_unnecessary_fold(cx: &LateContext<'_, '_>, expr: &hir::Expr, fold_args:\n                 let next_point = cx.sess().source_map().next_point(fold_args[0].span);\n                 let fold_span = next_point.with_hi(fold_args[2].span.hi() + BytePos(1));\n \n+                let mut applicability = Applicability::MachineApplicable;\n                 let sugg = if replacement_has_args {\n                     format!(\n                         \".{replacement}(|{s}| {r})\",\n                         replacement = replacement_method_name,\n                         s = second_arg_ident,\n-                        r = snippet(cx, right_expr.span, \"EXPR\"),\n+                        r = snippet_with_applicability(cx, right_expr.span, \"EXPR\", &mut applicability),\n                     )\n                 } else {\n                     format!(\n@@ -1488,7 +1498,7 @@ fn lint_unnecessary_fold(cx: &LateContext<'_, '_>, expr: &hir::Expr, fold_args:\n                     \"this `.fold` can be written more succinctly using another method\",\n                     \"try\",\n                     sugg,\n-                    Applicability::Unspecified,\n+                    applicability,\n                 );\n             }\n         }\n@@ -1552,9 +1562,10 @@ fn lint_iter_nth(cx: &LateContext<'_, '_>, expr: &hir::Expr, iter_args: &[hir::E\n fn lint_get_unwrap(cx: &LateContext<'_, '_>, expr: &hir::Expr, get_args: &[hir::Expr], is_mut: bool) {\n     // Note: we don't want to lint `get_mut().unwrap` for HashMap or BTreeMap,\n     // because they do not implement `IndexMut`\n+    let mut applicability = Applicability::MachineApplicable;\n     let expr_ty = cx.tables.expr_ty(&get_args[0]);\n     let get_args_str = if get_args.len() > 1 {\n-        snippet(cx, get_args[1].span, \"_\")\n+        snippet_with_applicability(cx, get_args[1].span, \"_\", &mut applicability)\n     } else {\n         return; // not linting on a .get().unwrap() chain or variant\n     };\n@@ -1593,10 +1604,10 @@ fn lint_get_unwrap(cx: &LateContext<'_, '_>, expr: &hir::Expr, get_args: &[hir::\n         format!(\n             \"{}{}[{}]\",\n             borrow_str,\n-            snippet(cx, get_args[0].span, \"_\"),\n+            snippet_with_applicability(cx, get_args[0].span, \"_\", &mut applicability),\n             get_args_str\n         ),\n-        Applicability::Unspecified,\n+        applicability,\n     );\n }\n \n@@ -2012,6 +2023,7 @@ fn lint_chars_cmp(\n         if let Some(segment) = single_segment_path(qpath);\n         if segment.ident.name == \"Some\";\n         then {\n+            let mut applicability = Applicability::MachineApplicable;\n             let self_ty = walk_ptrs_ty(cx.tables.expr_ty_adjusted(&args[0][0]));\n \n             if self_ty.sty != ty::Str {\n@@ -2026,10 +2038,10 @@ fn lint_chars_cmp(\n                 \"like this\",\n                 format!(\"{}{}.{}({})\",\n                         if info.eq { \"\" } else { \"!\" },\n-                        snippet(cx, args[0][0].span, \"_\"),\n+                        snippet_with_applicability(cx, args[0][0].span, \"_\", &mut applicability),\n                         suggest,\n-                        snippet(cx, arg_char[0].span, \"_\")),\n-                Applicability::Unspecified,\n+                        snippet_with_applicability(cx, arg_char[0].span, \"_\", &mut applicability)),\n+                applicability,\n             );\n \n             return true;\n@@ -2066,6 +2078,7 @@ fn lint_chars_cmp_with_unwrap<'a, 'tcx>(\n         if let hir::ExprKind::Lit(ref lit) = info.other.node;\n         if let ast::LitKind::Char(c) = lit.node;\n         then {\n+            let mut applicability = Applicability::MachineApplicable;\n             span_lint_and_sugg(\n                 cx,\n                 lint,\n@@ -2074,10 +2087,10 @@ fn lint_chars_cmp_with_unwrap<'a, 'tcx>(\n                 \"like this\",\n                 format!(\"{}{}.{}('{}')\",\n                         if info.eq { \"\" } else { \"!\" },\n-                        snippet(cx, args[0][0].span, \"_\"),\n+                        snippet_with_applicability(cx, args[0][0].span, \"_\", &mut applicability),\n                         suggest,\n                         c),\n-                Applicability::Unspecified,\n+                applicability,\n             );\n \n             return true;\n@@ -2108,7 +2121,8 @@ fn lint_single_char_pattern<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, _expr: &'tcx h\n         if let ast::LitKind::Str(r, _) = lit.node;\n         if r.as_str().len() == 1;\n         then {\n-            let snip = snippet(cx, arg.span, \"..\");\n+            let mut applicability = Applicability::MachineApplicable;\n+            let snip = snippet_with_applicability(cx, arg.span, \"..\", &mut applicability);\n             let hint = format!(\"'{}'\", &snip[1..snip.len() - 1]);\n             span_lint_and_sugg(\n                 cx,\n@@ -2117,7 +2131,7 @@ fn lint_single_char_pattern<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, _expr: &'tcx h\n                 \"single-character string constant used as pattern\",\n                 \"try using a char instead\",\n                 hint,\n-                Applicability::Unspecified,\n+                applicability,\n             );\n         }\n     }\n@@ -2135,14 +2149,15 @@ fn lint_asref(cx: &LateContext<'_, '_>, expr: &hir::Expr, call_name: &str, as_re\n         let (base_res_ty, res_depth) = walk_ptrs_ty_depth(res_ty);\n         let (base_rcv_ty, rcv_depth) = walk_ptrs_ty_depth(rcv_ty);\n         if base_rcv_ty == base_res_ty && rcv_depth >= res_depth {\n+            let mut applicability = Applicability::MachineApplicable;\n             span_lint_and_sugg(\n                 cx,\n                 USELESS_ASREF,\n                 expr.span,\n                 &format!(\"this call to `{}` does nothing\", call_name),\n                 \"try this\",\n-                snippet(cx, recvr.span, \"_\").into_owned(),\n-                Applicability::Unspecified,\n+                snippet_with_applicability(cx, recvr.span, \"_\", &mut applicability).to_string(),\n+                applicability,\n             );\n         }\n     }\n@@ -2207,8 +2222,8 @@ fn lint_into_iter(cx: &LateContext<'_, '_>, expr: &hir::Expr, self_ref_ty: ty::T\n                 kind,\n             ),\n             \"call directly\",\n-            method_name.to_owned(),\n-            Applicability::Unspecified,\n+            method_name.to_string(),\n+            Applicability::MachineApplicable,\n         );\n     }\n }"}, {"sha": "37ccf28d57256a87bb3abfdcec0a522bf65e3292", "filename": "clippy_lints/src/needless_bool.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/4e74eef6e9225973c73c555c9a324791e8be3958/clippy_lints%2Fsrc%2Fneedless_bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e74eef6e9225973c73c555c9a324791e8be3958/clippy_lints%2Fsrc%2Fneedless_bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_bool.rs?ref=4e74eef6e9225973c73c555c9a324791e8be3958", "patch": "@@ -19,7 +19,7 @@ use crate::rustc_errors::Applicability;\n use crate::syntax::ast::LitKind;\n use crate::syntax::source_map::Spanned;\n use crate::utils::sugg::Sugg;\n-use crate::utils::{in_macro, snippet, span_lint, span_lint_and_sugg};\n+use crate::utils::{in_macro, snippet_with_applicability, span_lint, span_lint_and_sugg};\n \n /// **What it does:** Checks for expressions of the form `if c { true } else {\n /// false }`\n@@ -74,7 +74,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessBool {\n         use self::Expression::*;\n         if let ExprKind::If(ref pred, ref then_block, Some(ref else_expr)) = e.node {\n             let reduce = |ret, not| {\n-                let snip = Sugg::hir(cx, pred, \"<predicate>\");\n+                let mut applicability = Applicability::MachineApplicable;\n+                let snip = Sugg::hir_with_applicability(cx, pred, \"<predicate>\", &mut applicability);\n                 let snip = if not { !snip } else { snip };\n \n                 let hint = if ret {\n@@ -90,7 +91,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessBool {\n                     \"this if-then-else expression returns a bool literal\",\n                     \"you can reduce it to\",\n                     hint,\n-                    Applicability::Unspecified,\n+                    applicability,\n                 );\n             };\n             if let ExprKind::Block(ref then_block, _) = then_block.node {\n@@ -142,53 +143,54 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for BoolComparison {\n         }\n \n         if let ExprKind::Binary(Spanned { node: BinOpKind::Eq, .. }, ref left_side, ref right_side) = e.node {\n+            let mut applicability = Applicability::MachineApplicable;\n             match (fetch_bool_expr(left_side), fetch_bool_expr(right_side)) {\n                 (Bool(true), Other) => {\n-                    let hint = snippet(cx, right_side.span, \"..\").into_owned();\n+                    let hint = snippet_with_applicability(cx, right_side.span, \"..\", &mut applicability);\n                     span_lint_and_sugg(\n                         cx,\n                         BOOL_COMPARISON,\n                         e.span,\n                         \"equality checks against true are unnecessary\",\n                         \"try simplifying it as shown\",\n-                        hint,\n-                        Applicability::Unspecified,\n+                        hint.to_string(),\n+                        applicability,\n                     );\n                 },\n                 (Other, Bool(true)) => {\n-                    let hint = snippet(cx, left_side.span, \"..\").into_owned();\n+                    let hint = snippet_with_applicability(cx, left_side.span, \"..\", &mut applicability);\n                     span_lint_and_sugg(\n                         cx,\n                         BOOL_COMPARISON,\n                         e.span,\n                         \"equality checks against true are unnecessary\",\n                         \"try simplifying it as shown\",\n-                        hint,\n-                        Applicability::Unspecified,\n+                        hint.to_string(),\n+                        applicability,\n                     );\n                 },\n                 (Bool(false), Other) => {\n-                    let hint = Sugg::hir(cx, right_side, \"..\");\n+                    let hint = Sugg::hir_with_applicability(cx, right_side, \"..\", &mut applicability);\n                     span_lint_and_sugg(\n                         cx,\n                         BOOL_COMPARISON,\n                         e.span,\n                         \"equality checks against false can be replaced by a negation\",\n                         \"try simplifying it as shown\",\n                         (!hint).to_string(),\n-                        Applicability::Unspecified,\n+                        applicability,\n                     );\n                 },\n                 (Other, Bool(false)) => {\n-                    let hint = Sugg::hir(cx, left_side, \"..\");\n+                    let hint = Sugg::hir_with_applicability(cx, left_side, \"..\", &mut applicability);\n                     span_lint_and_sugg(\n                         cx,\n                         BOOL_COMPARISON,\n                         e.span,\n                         \"equality checks against false can be replaced by a negation\",\n                         \"try simplifying it as shown\",\n                         (!hint).to_string(),\n-                        Applicability::Unspecified,\n+                        applicability,\n                     );\n                 },\n                 _ => (),"}, {"sha": "72ed649c5d9ecc1999860c6027b9c4ebc610903f", "filename": "clippy_lints/src/no_effect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4e74eef6e9225973c73c555c9a324791e8be3958/clippy_lints%2Fsrc%2Fno_effect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e74eef6e9225973c73c555c9a324791e8be3958/clippy_lints%2Fsrc%2Fno_effect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fno_effect.rs?ref=4e74eef6e9225973c73c555c9a324791e8be3958", "patch": "@@ -132,7 +132,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                     \"statement can be reduced\",\n                     \"replace it with\",\n                     snippet,\n-                    Applicability::Unspecified,\n+                    Applicability::MachineApplicable,\n                 );\n             }\n         }"}, {"sha": "d8f2645699d54c7907356312c87599767806ef38", "filename": "clippy_lints/src/precedence.rs", "status": "modified", "additions": 16, "deletions": 14, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/4e74eef6e9225973c73c555c9a324791e8be3958/clippy_lints%2Fsrc%2Fprecedence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e74eef6e9225973c73c555c9a324791e8be3958/clippy_lints%2Fsrc%2Fprecedence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fprecedence.rs?ref=4e74eef6e9225973c73c555c9a324791e8be3958", "patch": "@@ -13,7 +13,7 @@ use crate::rustc::{declare_tool_lint, lint_array};\n use crate::rustc_errors::Applicability;\n use crate::syntax::ast::*;\n use crate::syntax::source_map::Spanned;\n-use crate::utils::{in_macro, snippet, span_lint_and_sugg};\n+use crate::utils::{in_macro, snippet_with_applicability, span_lint_and_sugg};\n \n /// **What it does:** Checks for operations where precedence may be unclear\n /// and suggests to add parentheses. Currently it catches the following:\n@@ -54,48 +54,49 @@ impl EarlyLintPass for Precedence {\n         }\n \n         if let ExprKind::Binary(Spanned { node: op, .. }, ref left, ref right) = expr.node {\n-            let span_sugg = |expr: &Expr, sugg| {\n+            let span_sugg = |expr: &Expr, sugg, appl| {\n                 span_lint_and_sugg(\n                     cx,\n                     PRECEDENCE,\n                     expr.span,\n                     \"operator precedence can trip the unwary\",\n                     \"consider parenthesizing your expression\",\n                     sugg,\n-                    Applicability::Unspecified,\n+                    appl,\n                 );\n             };\n \n             if !is_bit_op(op) {\n                 return;\n             }\n+            let mut applicability = Applicability::MachineApplicable;\n             match (is_arith_expr(left), is_arith_expr(right)) {\n                 (true, true) => {\n                     let sugg = format!(\n                         \"({}) {} ({})\",\n-                        snippet(cx, left.span, \"..\"),\n+                        snippet_with_applicability(cx, left.span, \"..\", &mut applicability),\n                         op.to_string(),\n-                        snippet(cx, right.span, \"..\")\n+                        snippet_with_applicability(cx, right.span, \"..\", &mut applicability)\n                     );\n-                    span_sugg(expr, sugg);\n+                    span_sugg(expr, sugg, applicability);\n                 },\n                 (true, false) => {\n                     let sugg = format!(\n                         \"({}) {} {}\",\n-                        snippet(cx, left.span, \"..\"),\n+                        snippet_with_applicability(cx, left.span, \"..\", &mut applicability),\n                         op.to_string(),\n-                        snippet(cx, right.span, \"..\")\n+                        snippet_with_applicability(cx, right.span, \"..\", &mut applicability)\n                     );\n-                    span_sugg(expr, sugg);\n+                    span_sugg(expr, sugg, applicability);\n                 },\n                 (false, true) => {\n                     let sugg = format!(\n                         \"{} {} ({})\",\n-                        snippet(cx, left.span, \"..\"),\n+                        snippet_with_applicability(cx, left.span, \"..\", &mut applicability),\n                         op.to_string(),\n-                        snippet(cx, right.span, \"..\")\n+                        snippet_with_applicability(cx, right.span, \"..\", &mut applicability)\n                     );\n-                    span_sugg(expr, sugg);\n+                    span_sugg(expr, sugg, applicability);\n                 },\n                 (false, false) => (),\n             }\n@@ -107,14 +108,15 @@ impl EarlyLintPass for Precedence {\n                     if let ExprKind::Lit(ref lit) = slf.node {\n                         match lit.node {\n                             LitKind::Int(..) | LitKind::Float(..) | LitKind::FloatUnsuffixed(..) => {\n+                                let mut applicability = Applicability::MachineApplicable;\n                                 span_lint_and_sugg(\n                                     cx,\n                                     PRECEDENCE,\n                                     expr.span,\n                                     \"unary minus has lower precedence than method call\",\n                                     \"consider adding parentheses to clarify your intent\",\n-                                    format!(\"-({})\", snippet(cx, rhs.span, \"..\")),\n-                                    Applicability::Unspecified,\n+                                    format!(\"-({})\", snippet_with_applicability(cx, rhs.span, \"..\", &mut applicability)),\n+                                    applicability,\n                                 );\n                             },\n                             _ => (),"}, {"sha": "0d37d4d4b0834f2d121465ce8256c4c1070dd93f", "filename": "clippy_lints/src/ptr_offset_with_cast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4e74eef6e9225973c73c555c9a324791e8be3958/clippy_lints%2Fsrc%2Fptr_offset_with_cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e74eef6e9225973c73c555c9a324791e8be3958/clippy_lints%2Fsrc%2Fptr_offset_with_cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fptr_offset_with_cast.rs?ref=4e74eef6e9225973c73c555c9a324791e8be3958", "patch": "@@ -77,7 +77,7 @@ impl<'a, 'tcx> lint::LateLintPass<'a, 'tcx> for Pass {\n                 &msg,\n                 \"try\",\n                 sugg,\n-                Applicability::Unspecified,\n+                Applicability::MachineApplicable,\n             );\n         } else {\n             utils::span_lint(cx, PTR_OFFSET_WITH_CAST, expr.span, &msg);"}, {"sha": "b25ea1d5d3805ee857a093d9e350358a89abe85a", "filename": "clippy_lints/src/redundant_field_names.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4e74eef6e9225973c73c555c9a324791e8be3958/clippy_lints%2Fsrc%2Fredundant_field_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e74eef6e9225973c73c555c9a324791e8be3958/clippy_lints%2Fsrc%2Fredundant_field_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fredundant_field_names.rs?ref=4e74eef6e9225973c73c555c9a324791e8be3958", "patch": "@@ -66,7 +66,7 @@ impl EarlyLintPass for RedundantFieldNames {\n                             \"redundant field names in struct initialization\",\n                             \"replace it with\",\n                             field.ident.to_string(),\n-                            Applicability::Unspecified,\n+                            Applicability::MachineApplicable,\n                         );\n                     }\n                 }"}, {"sha": "7651c6f0a9f0bb66ea3cf4600b605176ff0574ab", "filename": "clippy_lints/src/reference.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4e74eef6e9225973c73c555c9a324791e8be3958/clippy_lints%2Fsrc%2Freference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e74eef6e9225973c73c555c9a324791e8be3958/clippy_lints%2Fsrc%2Freference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Freference.rs?ref=4e74eef6e9225973c73c555c9a324791e8be3958", "patch": "@@ -12,7 +12,7 @@ use crate::rustc::lint::{EarlyContext, EarlyLintPass, LintArray, LintPass};\n use crate::rustc::{declare_tool_lint, lint_array};\n use crate::rustc_errors::Applicability;\n use crate::syntax::ast::{Expr, ExprKind, UnOp};\n-use crate::utils::{snippet, span_lint_and_sugg};\n+use crate::utils::{snippet_with_applicability, span_lint_and_sugg};\n use if_chain::if_chain;\n \n /// **What it does:** Checks for usage of `*&` and `*&mut` in expressions.\n@@ -55,14 +55,15 @@ impl EarlyLintPass for Pass {\n             if let ExprKind::Unary(UnOp::Deref, ref deref_target) = e.node;\n             if let ExprKind::AddrOf(_, ref addrof_target) = without_parens(deref_target).node;\n             then {\n+                let mut applicability = Applicability::MachineApplicable;\n                 span_lint_and_sugg(\n                     cx,\n                     DEREF_ADDROF,\n                     e.span,\n                     \"immediately dereferencing a reference\",\n                     \"try this\",\n-                    format!(\"{}\", snippet(cx, addrof_target.span, \"_\")),\n-                    Applicability::Unspecified,\n+                    format!(\"{}\", snippet_with_applicability(cx, addrof_target.span, \"_\", &mut applicability)),\n+                    applicability,\n                 );\n             }\n         }\n@@ -102,6 +103,7 @@ impl EarlyLintPass for DerefPass {\n             if let ExprKind::Paren(ref parened) = object.node;\n             if let ExprKind::AddrOf(_, ref inner) = parened.node;\n             then {\n+                let mut applicability = Applicability::MachineApplicable;\n                 span_lint_and_sugg(\n                     cx,\n                     REF_IN_DEREF,\n@@ -110,10 +112,10 @@ impl EarlyLintPass for DerefPass {\n                     \"try this\",\n                     format!(\n                         \"{}.{}\",\n-                        snippet(cx, inner.span, \"_\"),\n-                        snippet(cx, field_name.span, \"_\")\n+                        snippet_with_applicability(cx, inner.span, \"_\", &mut applicability),\n+                        snippet_with_applicability(cx, field_name.span, \"_\", &mut applicability)\n                     ),\n-                    Applicability::Unspecified,\n+                    applicability,\n                 );\n             }\n         }"}, {"sha": "e3016b7259baadb983878e9bf986b08b107e3380", "filename": "clippy_lints/src/replace_consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4e74eef6e9225973c73c555c9a324791e8be3958/clippy_lints%2Fsrc%2Freplace_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e74eef6e9225973c73c555c9a324791e8be3958/clippy_lints%2Fsrc%2Freplace_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Freplace_consts.rs?ref=4e74eef6e9225973c73c555c9a324791e8be3958", "patch": "@@ -62,7 +62,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ReplaceConsts {\n                             &format!(\"using `{}`\", const_path.last().expect(\"empty path\")),\n                             \"try this\",\n                             repl_snip.to_string(),\n-                            Applicability::Unspecified,\n+                            Applicability::MachineApplicable,\n                         );\n                         return;\n                     }"}, {"sha": "05d64fbcd04f50c33e39320aab868d632c7b0ad4", "filename": "clippy_lints/src/strings.rs", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4e74eef6e9225973c73c555c9a324791e8be3958/clippy_lints%2Fsrc%2Fstrings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e74eef6e9225973c73c555c9a324791e8be3958/clippy_lints%2Fsrc%2Fstrings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fstrings.rs?ref=4e74eef6e9225973c73c555c9a324791e8be3958", "patch": "@@ -165,7 +165,7 @@ impl LintPass for StringLitAsBytes {\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for StringLitAsBytes {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n         use crate::syntax::ast::{LitKind, StrStyle};\n-        use crate::utils::{in_macro, snippet};\n+        use crate::utils::{in_macro, snippet, snippet_with_applicability};\n \n         if let ExprKind::MethodCall(ref path, _, ref args) = e.node {\n             if path.ident.name == \"as_bytes\" {\n@@ -178,15 +178,20 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for StringLitAsBytes {\n                         } else {\n                             format!(\"\\\"{}\\\"\", lit_content.as_str())\n                         };\n+                        let mut applicability = Applicability::MachineApplicable;\n                         if callsite.starts_with(\"include_str!\") {\n                             span_lint_and_sugg(\n                                 cx,\n                                 STRING_LIT_AS_BYTES,\n                                 e.span,\n                                 \"calling `as_bytes()` on `include_str!(..)`\",\n                                 \"consider using `include_bytes!(..)` instead\",\n-                                snippet(cx, args[0].span, r#\"\"foo\"\"#).replacen(\"include_str\", \"include_bytes\", 1),\n-                                Applicability::Unspecified,\n+                                snippet_with_applicability(cx, args[0].span, r#\"\"foo\"\"#, &mut applicability).replacen(\n+                                    \"include_str\",\n+                                    \"include_bytes\",\n+                                    1,\n+                                ),\n+                                applicability,\n                             );\n                         } else if callsite == expanded\n                             && lit_content.as_str().chars().all(|c| c.is_ascii())\n@@ -198,8 +203,11 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for StringLitAsBytes {\n                                 e.span,\n                                 \"calling `as_bytes()` on a string literal\",\n                                 \"consider using a byte string literal instead\",\n-                                format!(\"b{}\", snippet(cx, args[0].span, r#\"\"foo\"\"#)),\n-                                Applicability::Unspecified,\n+                                format!(\n+                                    \"b{}\",\n+                                    snippet_with_applicability(cx, args[0].span, r#\"\"foo\"\"#, &mut applicability)\n+                                ),\n+                                applicability,\n                             );\n                         }\n                     }"}, {"sha": "836f84e89668f64e463537300d6d33551fb17658", "filename": "clippy_lints/src/trivially_copy_pass_by_ref.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4e74eef6e9225973c73c555c9a324791e8be3958/clippy_lints%2Fsrc%2Ftrivially_copy_pass_by_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e74eef6e9225973c73c555c9a324791e8be3958/clippy_lints%2Fsrc%2Ftrivially_copy_pass_by_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftrivially_copy_pass_by_ref.rs?ref=4e74eef6e9225973c73c555c9a324791e8be3958", "patch": "@@ -15,14 +15,14 @@ use crate::rustc::hir::intravisit::FnKind;\n use crate::rustc::hir::*;\n use crate::rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use crate::rustc::session::config::Config as SessionConfig;\n-use crate::rustc::ty::TyKind;\n+use crate::rustc::ty::{FnSig, TyKind};\n use crate::rustc::{declare_tool_lint, lint_array};\n use crate::rustc_errors::Applicability;\n use crate::rustc_target::abi::LayoutOf;\n use crate::rustc_target::spec::abi::Abi;\n use crate::syntax::ast::NodeId;\n use crate::syntax_pos::Span;\n-use crate::utils::{in_macro, is_copy, is_self, snippet, span_lint_and_sugg};\n+use crate::utils::{in_macro, is_copy, is_self_ty, snippet, span_lint_and_sugg};\n use if_chain::if_chain;\n use matches::matches;\n \n@@ -141,7 +141,9 @@ impl<'a, 'tcx> TriviallyCopyPassByRef {\n                         input.span,\n                         \"this argument is passed by reference, but would be more efficient if passed by value\",\n                         \"consider passing by value instead\",\n-                        value_type);\n+                        value_type,\n+                        Applicability::Unspecified,\n+                    );\n                 }\n             }\n         }"}, {"sha": "61f294e1f3c23a88b061b280a982c41069a4f2f5", "filename": "clippy_lints/src/types.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4e74eef6e9225973c73c555c9a324791e8be3958/clippy_lints%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e74eef6e9225973c73c555c9a324791e8be3958/clippy_lints%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes.rs?ref=4e74eef6e9225973c73c555c9a324791e8be3958", "patch": "@@ -29,7 +29,7 @@ use crate::utils::paths;\n use crate::utils::{\n     clip, comparisons, differing_macro_contexts, higher, in_constant, in_macro, int_bits, last_path_segment,\n     match_def_path, match_path, match_type, multispan_sugg, opt_def_id, same_tys, sext, snippet, snippet_opt,\n-    span_help_and_lint, span_lint, span_lint_and_sugg, span_lint_and_then, unsext,\n+    snippet_with_applicability, span_help_and_lint, span_lint, span_lint_and_sugg, span_lint_and_then, unsext,\n };\n use if_chain::if_chain;\n use std::borrow::Cow;\n@@ -334,20 +334,21 @@ fn check_ty_rptr(cx: &LateContext<'_, '_>, ast_ty: &hir::Ty, is_local: bool, lt:\n                     let ltopt = if lt.is_elided() {\n                         String::new()\n                     } else {\n-                        format!(\"{} \", lt.name.ident().name.as_str())\n+                        format!(\"{} \", lt.name.ident().as_str())\n                     };\n                     let mutopt = if mut_ty.mutbl == Mutability::MutMutable {\n                         \"mut \"\n                     } else {\n                         \"\"\n                     };\n+                    let mut applicability = Applicability::MachineApplicable;\n                     span_lint_and_sugg(\n                         cx,\n                         BORROWED_BOX,\n                         ast_ty.span,\n                         \"you seem to be trying to use `&Box<T>`. Consider using just `&T`\",\n                         \"try\",\n-                        format!(\"&{}{}{}\", ltopt, mutopt, &snippet(cx, inner.span, \"..\")),\n+                        format!(\"&{}{}{}\", ltopt, mutopt, &snippet_with_applicability(cx, inner.span, \"..\", &mut applicability)),\n                         Applicability::Unspecified,\n                     );\n                     return; // don't recurse into the type\n@@ -542,7 +543,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnitArg {\n                                         \"passing a unit value to a function\",\n                                         \"if you intended to pass a unit value, use a unit literal instead\",\n                                         \"()\".to_string(),\n-                                        Applicability::Unspecified,\n+                                        Applicability::MachineApplicable,\n                                     );\n                                 }\n                             }\n@@ -862,6 +863,7 @@ fn span_lossless_lint(cx: &LateContext<'_, '_>, expr: &Expr, op: &Expr, cast_fro\n     if in_constant(cx, expr.id) { return }\n     // The suggestion is to use a function call, so if the original expression\n     // has parens on the outside, they are no longer needed.\n+    let mut applicability = Applicability::MachineApplicable;\n     let opt = snippet_opt(cx, op.span);\n     let sugg = if let Some(ref snip) = opt {\n         if should_strip_parens(op, snip) {\n@@ -870,6 +872,7 @@ fn span_lossless_lint(cx: &LateContext<'_, '_>, expr: &Expr, op: &Expr, cast_fro\n             snip.as_str()\n         }\n     } else {\n+        applicability = Applicability::HasPlaceholders;\n         \"..\"\n     };\n \n@@ -880,7 +883,7 @@ fn span_lossless_lint(cx: &LateContext<'_, '_>, expr: &Expr, op: &Expr, cast_fro\n         &format!(\"casting {} to {} may become silently lossy if types change\", cast_from, cast_to),\n         \"try\",\n         format!(\"{}::from({})\", cast_to, sugg),\n-        Applicability::Unspecified,\n+        applicability,\n     );\n }\n \n@@ -1100,7 +1103,8 @@ fn lint_fn_to_numeric_cast(cx: &LateContext<'_, '_>, expr: &Expr, cast_expr: &Ex\n     }\n     match cast_from.sty {\n         ty::FnDef(..) | ty::FnPtr(_) => {\n-            let from_snippet = snippet(cx, cast_expr.span, \"x\");\n+            let mut applicability = Applicability::MachineApplicable;\n+            let from_snippet = snippet_with_applicability(cx, cast_expr.span, \"x\", &mut applicability);\n \n             let to_nbits = int_ty_to_nbits(cast_to, cx.tcx);\n             if to_nbits < cx.tcx.data_layout.pointer_size.bits() {\n@@ -1111,7 +1115,7 @@ fn lint_fn_to_numeric_cast(cx: &LateContext<'_, '_>, expr: &Expr, cast_expr: &Ex\n                     &format!(\"casting function pointer `{}` to `{}`, which truncates the value\", from_snippet, cast_to),\n                     \"try\",\n                     format!(\"{} as usize\", from_snippet),\n-                    Applicability::Unspecified,\n+                    applicability,\n                 );\n \n             } else if cast_to.sty != ty::Uint(UintTy::Usize) {\n@@ -1122,7 +1126,7 @@ fn lint_fn_to_numeric_cast(cx: &LateContext<'_, '_>, expr: &Expr, cast_expr: &Ex\n                     &format!(\"casting function pointer `{}` to `{}`\", from_snippet, cast_to),\n                     \"try\",\n                     format!(\"{} as usize\", from_snippet),\n-                    Applicability::Unspecified,\n+                    applicability,\n                 );\n             }\n         },"}, {"sha": "564bdb0bb035de6e366446e663b98fbc9932c4ac", "filename": "clippy_lints/src/use_self.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4e74eef6e9225973c73c555c9a324791e8be3958/clippy_lints%2Fsrc%2Fuse_self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e74eef6e9225973c73c555c9a324791e8be3958/clippy_lints%2Fsrc%2Fuse_self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fuse_self.rs?ref=4e74eef6e9225973c73c555c9a324791e8be3958", "patch": "@@ -71,7 +71,7 @@ fn span_use_self_lint(cx: &LateContext<'_, '_>, path: &Path) {\n         \"unnecessary structure name repetition\",\n         \"use the applicable keyword\",\n         \"Self\".to_owned(),\n-        Applicability::Unspecified,\n+        Applicability::MachineApplicable,\n     );\n }\n "}, {"sha": "fd232e2a3669f54f5f528af3ab3a5d689a266fba", "filename": "clippy_lints/src/utils/internal_lints.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4e74eef6e9225973c73c555c9a324791e8be3958/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e74eef6e9225973c73c555c9a324791e8be3958/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs?ref=4e74eef6e9225973c73c555c9a324791e8be3958", "patch": "@@ -282,7 +282,7 @@ impl EarlyLintPass for DefaultHashTypes {\n                 &msg,\n                 \"use\",\n                 replace.to_string(),\n-                Applicability::Unspecified,\n+                Applicability::MaybeIncorrect, // FxHashMap, ... needs another import\n             );\n         }\n     }"}, {"sha": "d7e7de06355cc819a0f9b12fff8766482779be89", "filename": "clippy_lints/src/vec.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/4e74eef6e9225973c73c555c9a324791e8be3958/clippy_lints%2Fsrc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e74eef6e9225973c73c555c9a324791e8be3958/clippy_lints%2Fsrc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fvec.rs?ref=4e74eef6e9225973c73c555c9a324791e8be3958", "patch": "@@ -15,7 +15,7 @@ use crate::rustc::ty::{self, Ty};\n use crate::rustc::{declare_tool_lint, lint_array};\n use crate::rustc_errors::Applicability;\n use crate::syntax::source_map::Span;\n-use crate::utils::{higher, is_copy, snippet, span_lint_and_sugg};\n+use crate::utils::{higher, is_copy, snippet_with_applicability, span_lint_and_sugg};\n use if_chain::if_chain;\n \n /// **What it does:** Checks for usage of `&vec![..]` when using `&[..]` would\n@@ -77,18 +77,23 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n }\n \n fn check_vec_macro<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, vec_args: &higher::VecArgs<'tcx>, span: Span) {\n+    let mut applicability = Applicability::MachineApplicable;\n     let snippet = match *vec_args {\n         higher::VecArgs::Repeat(elem, len) => {\n             if constant(cx, cx.tables, len).is_some() {\n-                format!(\"&[{}; {}]\", snippet(cx, elem.span, \"elem\"), snippet(cx, len.span, \"len\"))\n+                format!(\n+                    \"&[{}; {}]\",\n+                    snippet_with_applicability(cx, elem.span, \"elem\", &mut applicability),\n+                    snippet_with_applicability(cx, len.span, \"len\", &mut applicability)\n+                )\n             } else {\n                 return;\n             }\n         },\n         higher::VecArgs::Vec(args) => if let Some(last) = args.iter().last() {\n             let span = args[0].span.to(last.span);\n \n-            format!(\"&[{}]\", snippet(cx, span, \"..\"))\n+            format!(\"&[{}]\", snippet_with_applicability(cx, span, \"..\", &mut applicability))\n         } else {\n             \"&[]\".into()\n         },\n@@ -101,7 +106,7 @@ fn check_vec_macro<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, vec_args: &higher::VecA\n         \"useless use of `vec!`\",\n         \"you can use a slice directly\",\n         snippet,\n-        Applicability::Unspecified,\n+        applicability,\n     );\n }\n "}, {"sha": "c746815062b8cfbd651dc53a92d43ac52281a96f", "filename": "clippy_lints/src/write.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/4e74eef6e9225973c73c555c9a324791e8be3958/clippy_lints%2Fsrc%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e74eef6e9225973c73c555c9a324791e8be3958/clippy_lints%2Fsrc%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fwrite.rs?ref=4e74eef6e9225973c73c555c9a324791e8be3958", "patch": "@@ -14,7 +14,7 @@ use crate::rustc_errors::Applicability;\n use crate::syntax::ast::*;\n use crate::syntax::parse::{parser, token};\n use crate::syntax::tokenstream::{ThinTokenStream, TokenStream};\n-use crate::utils::{snippet, span_lint, span_lint_and_sugg};\n+use crate::utils::{snippet_with_applicability, span_lint, span_lint_and_sugg};\n use std::borrow::Cow;\n \n /// **What it does:** This lint warns when you use `println!(\"\")` to\n@@ -200,7 +200,7 @@ impl EarlyLintPass for Pass {\n                         \"using `println!(\\\"\\\")`\",\n                         \"replace it with\",\n                         \"println!()\".to_string(),\n-                        Applicability::Unspecified,\n+                        Applicability::MachineApplicable,\n                     );\n                 }\n             }\n@@ -239,9 +239,14 @@ impl EarlyLintPass for Pass {\n             let check_tts = check_tts(cx, &mac.node.tts, true);\n             if let Some(fmtstr) = check_tts.0 {\n                 if fmtstr == \"\" {\n-                    let suggestion = check_tts\n-                        .1\n-                        .map_or(Cow::Borrowed(\"v\"), |expr| snippet(cx, expr.span, \"v\"));\n+                    let mut applicability = Applicability::MachineApplicable;\n+                    let suggestion = check_tts.1.map_or_else(\n+                        move || {\n+                            applicability = Applicability::HasPlaceholders;\n+                            Cow::Borrowed(\"v\")\n+                        },\n+                        move |expr| snippet_with_applicability(cx, expr.span, \"v\", &mut applicability),\n+                    );\n \n                     span_lint_and_sugg(\n                         cx,\n@@ -250,7 +255,7 @@ impl EarlyLintPass for Pass {\n                         format!(\"using `writeln!({}, \\\"\\\")`\", suggestion).as_str(),\n                         \"replace it with\",\n                         format!(\"writeln!({})\", suggestion),\n-                        Applicability::Unspecified,\n+                        applicability,\n                     );\n                 }\n             }"}]}