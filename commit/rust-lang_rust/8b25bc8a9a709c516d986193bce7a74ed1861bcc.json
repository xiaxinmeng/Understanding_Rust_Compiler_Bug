{"sha": "8b25bc8a9a709c516d986193bce7a74ed1861bcc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhiMjViYzhhOWE3MDljNTE2ZDk4NjE5M2JjZTdhNzRlZDE4NjFiY2M=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2016-06-08T09:11:33Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2016-06-08T09:11:33Z"}, "message": "directly push stackframes for constants when they are encountered", "tree": {"sha": "f8ae1406fd9e7df06c53e0fd8f6f2f6ddea2e4ef", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f8ae1406fd9e7df06c53e0fd8f6f2f6ddea2e4ef"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8b25bc8a9a709c516d986193bce7a74ed1861bcc", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v1\n\niQIcBAABAgAGBQJXV+FFAAoJEFbW7qD8Z6xG17cP/RjBOyEYmd3nt3hQyoluN/mI\nnhVz4rwWu3u2bie9ujMBOkPf/ukKajh6j7qmvd/wnjEqm29PXGROcO0ZFQRtst0X\nBYm7V8Ly3PZZJMDRLX43W+k6WbH8azOyuO6m7L19S2q80npkEU6LtaHc0mfJ3ufp\nlG9+CS7fNIFxyaUYDOMuYfTx3ICR7zIcj39IU0yzAFCeC9k+ySDZ4sf4QsTskZr4\nZIuXdH1tUjccgHMdoP2cQQ46yTOb19XfjR1vhOSlFOIxiVceEhP6FXm3+sblgpC8\nW3p77QiUzdIB8snYVjjGZ3+ZvpUisocx+QXHnRbQ9QUii60Xm+Nhg67EBDlxGSl2\nHt+V5lgogK/3uYkdn6ntjEFT/zcZSaFDzUc8yi0EJQVP1WZ7qRQoWpzXTYHDdGOk\niaJE+071bRd8Qu8fpvvWmUKW2STSe3+Bs5uTOlH0w4cdUC1WHMHay8TbpxOPBt6E\nl/mO+t4Z5AfEXRdowJeKQ1WPr5TdnOPPAZMEu8OF9WKjUbMYWnAF6PQs6rhbe69i\nGk0jeLV+7IDMvFFhkwDczNiDYw+lmPMETokcfN+7gqH3C4kySRoTxV2kqpit6br8\nnn9RIx5BDP2MGuQMH/UMB1mqx0YH442C8/VwNcaRd1syc7Zj1zG0OYA8g6vTi0n9\nnUFnAkGsaQ5JDYgkLOWa\n=vmzT\n-----END PGP SIGNATURE-----", "payload": "tree f8ae1406fd9e7df06c53e0fd8f6f2f6ddea2e4ef\nparent 6b939bbd798c42b9e992da36f9158b711063a731\nauthor Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1465377093 +0200\ncommitter Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1465377093 +0200\n\ndirectly push stackframes for constants when they are encountered"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8b25bc8a9a709c516d986193bce7a74ed1861bcc", "html_url": "https://github.com/rust-lang/rust/commit/8b25bc8a9a709c516d986193bce7a74ed1861bcc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8b25bc8a9a709c516d986193bce7a74ed1861bcc/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6b939bbd798c42b9e992da36f9158b711063a731", "url": "https://api.github.com/repos/rust-lang/rust/commits/6b939bbd798c42b9e992da36f9158b711063a731", "html_url": "https://github.com/rust-lang/rust/commit/6b939bbd798c42b9e992da36f9158b711063a731"}], "stats": {"total": 77, "additions": 42, "deletions": 35}, "files": [{"sha": "a05dfb734bf5bb3b1ca5e79460484371445c7406", "filename": "src/interpreter/mod.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8b25bc8a9a709c516d986193bce7a74ed1861bcc/src%2Finterpreter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b25bc8a9a709c516d986193bce7a74ed1861bcc/src%2Finterpreter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fmod.rs?ref=8b25bc8a9a709c516d986193bce7a74ed1861bcc", "patch": "@@ -14,7 +14,7 @@ use std::rc::Rc;\n use std::{iter, mem};\n use syntax::ast;\n use syntax::attr;\n-use syntax::codemap::{self, DUMMY_SP, Span};\n+use syntax::codemap::{self, DUMMY_SP};\n \n use error::{EvalError, EvalResult};\n use memory::{Memory, Pointer};\n@@ -94,9 +94,6 @@ struct Frame<'a, 'tcx: 'a> {\n \n     /// The index of the currently evaluated statment\n     stmt: usize,\n-\n-    // Constants that need to be evaluated before the next statement can be evaluated\n-    constants: Vec<(ConstantId<'tcx>, Span, Pointer, CachedMir<'a, 'tcx>)>,\n }\n \n #[derive(Copy, Clone, Debug, Eq, PartialEq)]\n@@ -409,7 +406,7 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n \n             loop {\n                 match stepper.step()? {\n-                    Constant => trace!(\"next statement requires the computation of a constant\"),\n+                    Constant => trace!(\"computing a constant\"),\n                     Assignment => trace!(\"{:?}\", stepper.stmt()),\n                     Terminator => {\n                         trace!(\"{:?}\", stepper.term().kind);\n@@ -444,7 +441,6 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n             def_id: def_id,\n             substs: substs,\n             stmt: 0,\n-            constants: Vec::new(),\n         });\n \n         let locals: Vec<Pointer> = arg_tys.chain(var_tys).chain(temp_tys).map(|ty| {"}, {"sha": "7499eb07ae9183b02fca273f15d1f7b36b457216", "filename": "src/interpreter/stepper.rs", "status": "modified", "additions": 40, "deletions": 29, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/8b25bc8a9a709c516d986193bce7a74ed1861bcc/src%2Finterpreter%2Fstepper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b25bc8a9a709c516d986193bce7a74ed1861bcc/src%2Finterpreter%2Fstepper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fstepper.rs?ref=8b25bc8a9a709c516d986193bce7a74ed1861bcc", "patch": "@@ -4,7 +4,6 @@ use super::{\n     TerminatorTarget,\n     ConstantId,\n     GlobalEvalContext,\n-    Frame,\n };\n use error::EvalResult;\n use rustc::mir::repr as mir;\n@@ -13,6 +12,7 @@ use rustc::hir::def_id::DefId;\n use rustc::mir::visit::{Visitor, LvalueContext};\n use syntax::codemap::Span;\n use std::rc::Rc;\n+use memory::Pointer;\n \n pub enum Event {\n     Constant,\n@@ -24,13 +24,18 @@ pub enum Event {\n pub struct Stepper<'fncx, 'a: 'fncx, 'b: 'a + 'mir, 'mir: 'fncx, 'tcx: 'b>{\n     fncx: &'fncx mut FnEvalContext<'a, 'b, 'mir, 'tcx>,\n     process: fn (&mut Stepper<'fncx, 'a, 'b, 'mir, 'tcx>) -> EvalResult<()>,\n+\n+    // a cache of the constants to be computed before the next statement/terminator\n+    // this is an optimization, so we don't have to allocate a new vector for every statement\n+    constants: Vec<(ConstantId<'tcx>, Span, Pointer, CachedMir<'mir, 'tcx>)>,\n }\n \n impl<'fncx, 'a, 'b: 'a + 'mir, 'mir, 'tcx: 'b> Stepper<'fncx, 'a, 'b, 'mir, 'tcx> {\n     pub(super) fn new(fncx: &'fncx mut FnEvalContext<'a, 'b, 'mir, 'tcx>) -> Self {\n         Stepper {\n             fncx: fncx,\n             process: Self::dummy,\n+            constants: Vec::new(),\n         }\n     }\n \n@@ -60,22 +65,13 @@ impl<'fncx, 'a, 'b: 'a + 'mir, 'mir, 'tcx: 'b> Stepper<'fncx, 'a, 'b, 'mir, 'tcx\n         match term {\n             TerminatorTarget::Block => {},\n             TerminatorTarget::Return => {\n-                assert!(self.fncx.frame().constants.is_empty());\n                 self.fncx.pop_stack_frame();\n             },\n             TerminatorTarget::Call => {},\n         }\n         Ok(())\n     }\n \n-    fn constant(&mut self) -> EvalResult<()> {\n-        let (cid, span, return_ptr, mir) = self.fncx.frame_mut().constants.pop().expect(\"state machine broken\");\n-        let def_id = cid.def_id();\n-        let substs = cid.substs();\n-        self.fncx.push_stack_frame(def_id, span, mir, substs, Some(return_ptr));\n-        Ok(())\n-    }\n-\n     pub fn step(&mut self) -> EvalResult<Event> {\n         (self.process)(self)?;\n \n@@ -85,48 +81,60 @@ impl<'fncx, 'a, 'b: 'a + 'mir, 'mir, 'tcx: 'b> Stepper<'fncx, 'a, 'b, 'mir, 'tcx\n             return Ok(Event::Done);\n         }\n \n-        if !self.fncx.frame().constants.is_empty() {\n-            self.process = Self::constant;\n-            return Ok(Event::Constant);\n-        }\n-\n         let block = self.fncx.frame().next_block;\n         let stmt = self.fncx.frame().stmt;\n         let mir = self.fncx.mir();\n         let basic_block = mir.basic_block_data(block);\n \n         if let Some(ref stmt) = basic_block.statements.get(stmt) {\n-            assert!(self.fncx.frame().constants.is_empty());\n+            assert!(self.constants.is_empty());\n             ConstantExtractor {\n                 span: stmt.span,\n+                substs: self.fncx.substs(),\n+                def_id: self.fncx.frame().def_id,\n                 gecx: self.fncx.gecx,\n-                frame: self.fncx.stack.last_mut().expect(\"stack empty\"),\n+                constants: &mut self.constants,\n+                mir: &mir,\n             }.visit_statement(block, stmt);\n-            if self.fncx.frame().constants.is_empty() {\n+            if self.constants.is_empty() {\n                 self.process = Self::statement;\n                 return Ok(Event::Assignment);\n             } else {\n-                self.process = Self::constant;\n+                self.process = Self::statement;\n+                self.extract_constants();\n                 return Ok(Event::Constant);\n             }\n         }\n \n         let terminator = basic_block.terminator();\n-        assert!(self.fncx.frame().constants.is_empty());\n+        assert!(self.constants.is_empty());\n         ConstantExtractor {\n             span: terminator.span,\n+            substs: self.fncx.substs(),\n+            def_id: self.fncx.frame().def_id,\n             gecx: self.fncx.gecx,\n-            frame: self.fncx.stack.last_mut().expect(\"stack empty\"),\n+            constants: &mut self.constants,\n+            mir: &mir,\n         }.visit_terminator(block, terminator);\n-        if self.fncx.frame().constants.is_empty() {\n+        if self.constants.is_empty() {\n             self.process = Self::terminator;\n             Ok(Event::Terminator)\n         } else {\n-            self.process = Self::constant;\n+            self.process = Self::statement;\n+            self.extract_constants();\n             Ok(Event::Constant)\n         }\n     }\n \n+    fn extract_constants(&mut self) {\n+        assert!(!self.constants.is_empty());\n+        for (cid, span, return_ptr, mir) in self.constants.drain(..) {\n+            let def_id = cid.def_id();\n+            let substs = cid.substs();\n+            self.fncx.push_stack_frame(def_id, span, mir, substs, Some(return_ptr));\n+        }\n+    }\n+\n     /// returns the statement that will be processed next\n     pub fn stmt(&self) -> &mir::Statement {\n         &self.fncx.basic_block().statements[self.fncx.frame().stmt]\n@@ -144,8 +152,11 @@ impl<'fncx, 'a, 'b: 'a + 'mir, 'mir, 'tcx: 'b> Stepper<'fncx, 'a, 'b, 'mir, 'tcx\n \n struct ConstantExtractor<'a, 'b: 'mir, 'mir: 'a, 'tcx: 'b> {\n     span: Span,\n-    frame: &'a mut Frame<'mir, 'tcx>,\n+    constants: &'a mut Vec<(ConstantId<'tcx>, Span, Pointer, CachedMir<'mir, 'tcx>)>,\n     gecx: &'a mut GlobalEvalContext<'b, 'tcx>,\n+    mir: &'a mir::Mir<'tcx>,\n+    def_id: DefId,\n+    substs: &'tcx subst::Substs<'tcx>,\n }\n \n impl<'a, 'b, 'mir, 'tcx> ConstantExtractor<'a, 'b, 'mir, 'tcx> {\n@@ -160,7 +171,7 @@ impl<'a, 'b, 'mir, 'tcx> ConstantExtractor<'a, 'b, 'mir, 'tcx> {\n         let mir = self.gecx.load_mir(def_id);\n         let ptr = self.gecx.alloc_ret_ptr(mir.return_ty, substs).expect(\"there's no such thing as an unreachable static\");\n         self.gecx.statics.insert(cid.clone(), ptr);\n-        self.frame.constants.push((cid, span, ptr, mir));\n+        self.constants.push((cid, span, ptr, mir));\n     }\n }\n \n@@ -180,19 +191,19 @@ impl<'a, 'b, 'mir, 'tcx> Visitor<'tcx> for ConstantExtractor<'a, 'b, 'mir, 'tcx>\n             },\n             mir::Literal::Promoted { index } => {\n                 let cid = ConstantId::Promoted {\n-                    def_id: self.frame.def_id,\n-                    substs: self.frame.substs,\n+                    def_id: self.def_id,\n+                    substs: self.substs,\n                     index: index,\n                 };\n                 if self.gecx.statics.contains_key(&cid) {\n                     return;\n                 }\n-                let mir = self.frame.mir.promoted[index].clone();\n+                let mir = self.mir.promoted[index].clone();\n                 let return_ty = mir.return_ty;\n                 let return_ptr = self.gecx.alloc_ret_ptr(return_ty, cid.substs()).expect(\"there's no such thing as an unreachable static\");\n                 let mir = CachedMir::Owned(Rc::new(mir));\n                 self.gecx.statics.insert(cid.clone(), return_ptr);\n-                self.frame.constants.push((cid, constant.span, return_ptr, mir));\n+                self.constants.push((cid, constant.span, return_ptr, mir));\n             }\n         }\n     }"}]}