{"sha": "bd80018159f6d563131ab81105d319c15d024f07", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJkODAwMTgxNTlmNmQ1NjMxMzFhYjgxMTA1ZDMxOWMxNWQwMjRmMDc=", "commit": {"author": {"name": "LeSeulArtichaut", "email": "leseulartichaut@gmail.com", "date": "2021-04-04T00:24:02Z"}, "committer": {"name": "LeSeulArtichaut", "email": "leseulartichaut@gmail.com", "date": "2021-05-22T12:36:22Z"}, "message": "Move THIR structure definitions to `rustc_middle`", "tree": {"sha": "aca0fb74dea81abdd9843bf58526fb7647c52443", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aca0fb74dea81abdd9843bf58526fb7647c52443"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bd80018159f6d563131ab81105d319c15d024f07", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bd80018159f6d563131ab81105d319c15d024f07", "html_url": "https://github.com/rust-lang/rust/commit/bd80018159f6d563131ab81105d319c15d024f07", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bd80018159f6d563131ab81105d319c15d024f07/comments", "author": {"login": "LeSeulArtichaut", "id": 38361244, "node_id": "MDQ6VXNlcjM4MzYxMjQ0", "avatar_url": "https://avatars.githubusercontent.com/u/38361244?v=4", "gravatar_id": "", "url": "https://api.github.com/users/LeSeulArtichaut", "html_url": "https://github.com/LeSeulArtichaut", "followers_url": "https://api.github.com/users/LeSeulArtichaut/followers", "following_url": "https://api.github.com/users/LeSeulArtichaut/following{/other_user}", "gists_url": "https://api.github.com/users/LeSeulArtichaut/gists{/gist_id}", "starred_url": "https://api.github.com/users/LeSeulArtichaut/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/LeSeulArtichaut/subscriptions", "organizations_url": "https://api.github.com/users/LeSeulArtichaut/orgs", "repos_url": "https://api.github.com/users/LeSeulArtichaut/repos", "events_url": "https://api.github.com/users/LeSeulArtichaut/events{/privacy}", "received_events_url": "https://api.github.com/users/LeSeulArtichaut/received_events", "type": "User", "site_admin": false}, "committer": {"login": "LeSeulArtichaut", "id": 38361244, "node_id": "MDQ6VXNlcjM4MzYxMjQ0", "avatar_url": "https://avatars.githubusercontent.com/u/38361244?v=4", "gravatar_id": "", "url": "https://api.github.com/users/LeSeulArtichaut", "html_url": "https://github.com/LeSeulArtichaut", "followers_url": "https://api.github.com/users/LeSeulArtichaut/followers", "following_url": "https://api.github.com/users/LeSeulArtichaut/following{/other_user}", "gists_url": "https://api.github.com/users/LeSeulArtichaut/gists{/gist_id}", "starred_url": "https://api.github.com/users/LeSeulArtichaut/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/LeSeulArtichaut/subscriptions", "organizations_url": "https://api.github.com/users/LeSeulArtichaut/orgs", "repos_url": "https://api.github.com/users/LeSeulArtichaut/repos", "events_url": "https://api.github.com/users/LeSeulArtichaut/events{/privacy}", "received_events_url": "https://api.github.com/users/LeSeulArtichaut/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "70cb58ce279444ac0191c4aa6df79becbaf2bdc1", "url": "https://api.github.com/repos/rust-lang/rust/commits/70cb58ce279444ac0191c4aa6df79becbaf2bdc1", "html_url": "https://github.com/rust-lang/rust/commit/70cb58ce279444ac0191c4aa6df79becbaf2bdc1"}], "stats": {"total": 1658, "additions": 833, "deletions": 825}, "files": [{"sha": "04124ca0281933fa23dde8d50c9953659b5909bc", "filename": "compiler/rustc_middle/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bd80018159f6d563131ab81105d319c15d024f07/compiler%2Frustc_middle%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd80018159f6d563131ab81105d319c15d024f07/compiler%2Frustc_middle%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Flib.rs?ref=bd80018159f6d563131ab81105d319c15d024f07", "patch": "@@ -83,6 +83,7 @@ pub mod infer;\n pub mod lint;\n pub mod middle;\n pub mod mir;\n+pub mod thir;\n pub mod traits;\n pub mod ty;\n "}, {"sha": "448a1cb1528573c3f96a9b1209039c05de4bbcfd", "filename": "compiler/rustc_middle/src/thir.rs", "status": "added", "additions": 743, "deletions": 0, "changes": 743, "blob_url": "https://github.com/rust-lang/rust/blob/bd80018159f6d563131ab81105d319c15d024f07/compiler%2Frustc_middle%2Fsrc%2Fthir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd80018159f6d563131ab81105d319c15d024f07/compiler%2Frustc_middle%2Fsrc%2Fthir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fthir.rs?ref=bd80018159f6d563131ab81105d319c15d024f07", "patch": "@@ -0,0 +1,743 @@\n+use rustc_ast::{InlineAsmOptions, InlineAsmTemplatePiece};\n+use rustc_hir as hir;\n+use rustc_hir::def::CtorKind;\n+use rustc_hir::def_id::DefId;\n+use rustc_hir::RangeEnd;\n+use rustc_index::newtype_index;\n+use rustc_index::vec::{Idx, IndexVec};\n+use rustc_middle::infer::canonical::Canonical;\n+use rustc_middle::middle::region;\n+use rustc_middle::mir::{\n+    BinOp, BorrowKind, FakeReadCause, Field, Mutability, UnOp, UserTypeProjection,\n+};\n+use rustc_middle::ty::adjustment::PointerCast;\n+use rustc_middle::ty::subst::SubstsRef;\n+use rustc_middle::ty::{self, AdtDef, Const, Ty, UpvarSubsts, UserType};\n+use rustc_middle::ty::{\n+    CanonicalUserType, CanonicalUserTypeAnnotation, CanonicalUserTypeAnnotations,\n+};\n+use rustc_span::{Span, Symbol, DUMMY_SP};\n+use rustc_target::abi::VariantIdx;\n+use rustc_target::asm::InlineAsmRegOrRegClass;\n+\n+use std::fmt;\n+use std::ops::Index;\n+\n+newtype_index! {\n+    pub struct ArmId {\n+        DEBUG_FORMAT = \"a{}\"\n+    }\n+}\n+\n+newtype_index! {\n+    pub struct ExprId {\n+        DEBUG_FORMAT = \"e{}\"\n+    }\n+}\n+\n+newtype_index! {\n+    pub struct StmtId {\n+        DEBUG_FORMAT = \"s{}\"\n+    }\n+}\n+\n+macro_rules! thir_with_elements {\n+    ($($name:ident: $id:ty => $value:ty,)*) => {\n+        pub struct Thir<'tcx> {\n+            $(\n+                pub $name: IndexVec<$id, $value>,\n+            )*\n+        }\n+\n+        impl<'tcx> Thir<'tcx> {\n+            pub fn new() -> Thir<'tcx> {\n+                Thir {\n+                    $(\n+                        $name: IndexVec::new(),\n+                    )*\n+                }\n+            }\n+        }\n+\n+        $(\n+            impl<'tcx> Index<$id> for Thir<'tcx> {\n+                type Output = $value;\n+                fn index(&self, index: $id) -> &Self::Output {\n+                    &self.$name[index]\n+                }\n+            }\n+        )*\n+    }\n+}\n+\n+thir_with_elements! {\n+    arms: ArmId => Arm<'tcx>,\n+    exprs: ExprId => Expr<'tcx>,\n+    stmts: StmtId => Stmt<'tcx>,\n+}\n+\n+#[derive(Copy, Clone, Debug)]\n+pub enum LintLevel {\n+    Inherited,\n+    Explicit(hir::HirId),\n+}\n+\n+#[derive(Debug)]\n+pub struct Block {\n+    pub targeted_by_break: bool,\n+    pub region_scope: region::Scope,\n+    pub opt_destruction_scope: Option<region::Scope>,\n+    pub span: Span,\n+    pub stmts: Box<[StmtId]>,\n+    pub expr: Option<ExprId>,\n+    pub safety_mode: BlockSafety,\n+}\n+\n+#[derive(Copy, Clone, Debug)]\n+pub enum BlockSafety {\n+    Safe,\n+    ExplicitUnsafe(hir::HirId),\n+    PushUnsafe,\n+    PopUnsafe,\n+}\n+\n+#[derive(Debug)]\n+pub struct Stmt<'tcx> {\n+    pub kind: StmtKind<'tcx>,\n+    pub opt_destruction_scope: Option<region::Scope>,\n+}\n+\n+#[derive(Debug)]\n+pub enum StmtKind<'tcx> {\n+    Expr {\n+        /// scope for this statement; may be used as lifetime of temporaries\n+        scope: region::Scope,\n+\n+        /// expression being evaluated in this statement\n+        expr: ExprId,\n+    },\n+\n+    Let {\n+        /// scope for variables bound in this let; covers this and\n+        /// remaining statements in block\n+        remainder_scope: region::Scope,\n+\n+        /// scope for the initialization itself; might be used as\n+        /// lifetime of temporaries\n+        init_scope: region::Scope,\n+\n+        /// `let <PAT> = ...`\n+        ///\n+        /// if a type is included, it is added as an ascription pattern\n+        pattern: Pat<'tcx>,\n+\n+        /// let pat: ty = <INIT> ...\n+        initializer: Option<ExprId>,\n+\n+        /// the lint level for this let-statement\n+        lint_level: LintLevel,\n+    },\n+}\n+\n+// `Expr` is used a lot. Make sure it doesn't unintentionally get bigger.\n+#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n+rustc_data_structures::static_assert_size!(Expr<'_>, 144);\n+\n+/// The Thir trait implementor lowers their expressions (`&'tcx H::Expr`)\n+/// into instances of this `Expr` enum. This lowering can be done\n+/// basically as lazily or as eagerly as desired: every recursive\n+/// reference to an expression in this enum is an `ExprId`, which\n+/// may in turn be another instance of this enum (boxed), or else an\n+/// unlowered `&'tcx H::Expr`. Note that instances of `Expr` are very\n+/// short-lived. They are created by `Thir::to_expr`, analyzed and\n+/// converted into MIR, and then discarded.\n+///\n+/// If you compare `Expr` to the full compiler AST, you will see it is\n+/// a good bit simpler. In fact, a number of the more straight-forward\n+/// MIR simplifications are already done in the impl of `Thir`. For\n+/// example, method calls and overloaded operators are absent: they are\n+/// expected to be converted into `Expr::Call` instances.\n+#[derive(Debug)]\n+pub struct Expr<'tcx> {\n+    /// type of this expression\n+    pub ty: Ty<'tcx>,\n+\n+    /// lifetime of this expression if it should be spilled into a\n+    /// temporary; should be None only if in a constant context\n+    pub temp_lifetime: Option<region::Scope>,\n+\n+    /// span of the expression in the source\n+    pub span: Span,\n+\n+    /// kind of expression\n+    pub kind: ExprKind<'tcx>,\n+}\n+\n+#[derive(Debug)]\n+pub enum ExprKind<'tcx> {\n+    Scope {\n+        region_scope: region::Scope,\n+        lint_level: LintLevel,\n+        value: ExprId,\n+    },\n+    Box {\n+        value: ExprId,\n+    },\n+    If {\n+        cond: ExprId,\n+        then: ExprId,\n+        else_opt: Option<ExprId>,\n+    },\n+    Call {\n+        ty: Ty<'tcx>,\n+        fun: ExprId,\n+        args: Box<[ExprId]>,\n+        /// Whether this is from a call in HIR, rather than from an overloaded\n+        /// operator. `true` for overloaded function call.\n+        from_hir_call: bool,\n+        /// This `Span` is the span of the function, without the dot and receiver\n+        /// (e.g. `foo(a, b)` in `x.foo(a, b)`\n+        fn_span: Span,\n+    },\n+    Deref {\n+        arg: ExprId,\n+    }, // NOT overloaded!\n+    Binary {\n+        op: BinOp,\n+        lhs: ExprId,\n+        rhs: ExprId,\n+    }, // NOT overloaded!\n+    LogicalOp {\n+        op: LogicalOp,\n+        lhs: ExprId,\n+        rhs: ExprId,\n+    }, // NOT overloaded!\n+    // LogicalOp is distinct from BinaryOp because of lazy evaluation of the operands.\n+    Unary {\n+        op: UnOp,\n+        arg: ExprId,\n+    }, // NOT overloaded!\n+    Cast {\n+        source: ExprId,\n+    },\n+    Use {\n+        source: ExprId,\n+    }, // Use a lexpr to get a vexpr.\n+    NeverToAny {\n+        source: ExprId,\n+    },\n+    Pointer {\n+        cast: PointerCast,\n+        source: ExprId,\n+    },\n+    Loop {\n+        body: ExprId,\n+    },\n+    Match {\n+        scrutinee: ExprId,\n+        arms: Box<[ArmId]>,\n+    },\n+    Block {\n+        body: Block,\n+    },\n+    Assign {\n+        lhs: ExprId,\n+        rhs: ExprId,\n+    },\n+    AssignOp {\n+        op: BinOp,\n+        lhs: ExprId,\n+        rhs: ExprId,\n+    },\n+    Field {\n+        lhs: ExprId,\n+        name: Field,\n+    },\n+    Index {\n+        lhs: ExprId,\n+        index: ExprId,\n+    },\n+    VarRef {\n+        id: hir::HirId,\n+    },\n+    /// Used to represent upvars mentioned in a closure/generator\n+    UpvarRef {\n+        /// DefId of the closure/generator\n+        closure_def_id: DefId,\n+\n+        /// HirId of the root variable\n+        var_hir_id: hir::HirId,\n+    },\n+    Borrow {\n+        borrow_kind: BorrowKind,\n+        arg: ExprId,\n+    },\n+    /// A `&raw [const|mut] $place_expr` raw borrow resulting in type `*[const|mut] T`.\n+    AddressOf {\n+        mutability: hir::Mutability,\n+        arg: ExprId,\n+    },\n+    Break {\n+        label: region::Scope,\n+        value: Option<ExprId>,\n+    },\n+    Continue {\n+        label: region::Scope,\n+    },\n+    Return {\n+        value: Option<ExprId>,\n+    },\n+    ConstBlock {\n+        value: &'tcx Const<'tcx>,\n+    },\n+    Repeat {\n+        value: ExprId,\n+        count: &'tcx Const<'tcx>,\n+    },\n+    Array {\n+        fields: Box<[ExprId]>,\n+    },\n+    Tuple {\n+        fields: Box<[ExprId]>,\n+    },\n+    Adt {\n+        adt_def: &'tcx AdtDef,\n+        variant_index: VariantIdx,\n+        substs: SubstsRef<'tcx>,\n+\n+        /// Optional user-given substs: for something like `let x =\n+        /// Bar::<T> { ... }`.\n+        user_ty: Option<Canonical<'tcx, UserType<'tcx>>>,\n+\n+        fields: Box<[FieldExpr]>,\n+        base: Option<FruInfo<'tcx>>,\n+    },\n+    PlaceTypeAscription {\n+        source: ExprId,\n+        /// Type that the user gave to this expression\n+        user_ty: Option<Canonical<'tcx, UserType<'tcx>>>,\n+    },\n+    ValueTypeAscription {\n+        source: ExprId,\n+        /// Type that the user gave to this expression\n+        user_ty: Option<Canonical<'tcx, UserType<'tcx>>>,\n+    },\n+    Closure {\n+        closure_id: DefId,\n+        substs: UpvarSubsts<'tcx>,\n+        upvars: Box<[ExprId]>,\n+        movability: Option<hir::Movability>,\n+        fake_reads: Vec<(ExprId, FakeReadCause, hir::HirId)>,\n+    },\n+    Literal {\n+        literal: &'tcx Const<'tcx>,\n+        user_ty: Option<Canonical<'tcx, UserType<'tcx>>>,\n+        /// The `DefId` of the `const` item this literal\n+        /// was produced from, if this is not a user-written\n+        /// literal value.\n+        const_id: Option<DefId>,\n+    },\n+    /// A literal containing the address of a `static`.\n+    ///\n+    /// This is only distinguished from `Literal` so that we can register some\n+    /// info for diagnostics.\n+    StaticRef {\n+        literal: &'tcx Const<'tcx>,\n+        def_id: DefId,\n+    },\n+    InlineAsm {\n+        template: &'tcx [InlineAsmTemplatePiece],\n+        operands: Box<[InlineAsmOperand<'tcx>]>,\n+        options: InlineAsmOptions,\n+        line_spans: &'tcx [Span],\n+    },\n+    /// An expression taking a reference to a thread local.\n+    ThreadLocalRef(DefId),\n+    LlvmInlineAsm {\n+        asm: &'tcx hir::LlvmInlineAsmInner,\n+        outputs: Box<[ExprId]>,\n+        inputs: Box<[ExprId]>,\n+    },\n+    Yield {\n+        value: ExprId,\n+    },\n+}\n+\n+#[derive(Debug)]\n+pub struct FieldExpr {\n+    pub name: Field,\n+    pub expr: ExprId,\n+}\n+\n+#[derive(Debug)]\n+pub struct FruInfo<'tcx> {\n+    pub base: ExprId,\n+    pub field_types: Box<[Ty<'tcx>]>,\n+}\n+\n+#[derive(Debug)]\n+pub struct Arm<'tcx> {\n+    pub pattern: Pat<'tcx>,\n+    pub guard: Option<Guard<'tcx>>,\n+    pub body: ExprId,\n+    pub lint_level: LintLevel,\n+    pub scope: region::Scope,\n+    pub span: Span,\n+}\n+\n+#[derive(Debug)]\n+pub enum Guard<'tcx> {\n+    If(ExprId),\n+    IfLet(Pat<'tcx>, ExprId),\n+}\n+\n+#[derive(Copy, Clone, Debug)]\n+pub enum LogicalOp {\n+    And,\n+    Or,\n+}\n+\n+#[derive(Debug)]\n+pub enum InlineAsmOperand<'tcx> {\n+    In {\n+        reg: InlineAsmRegOrRegClass,\n+        expr: ExprId,\n+    },\n+    Out {\n+        reg: InlineAsmRegOrRegClass,\n+        late: bool,\n+        expr: Option<ExprId>,\n+    },\n+    InOut {\n+        reg: InlineAsmRegOrRegClass,\n+        late: bool,\n+        expr: ExprId,\n+    },\n+    SplitInOut {\n+        reg: InlineAsmRegOrRegClass,\n+        late: bool,\n+        in_expr: ExprId,\n+        out_expr: Option<ExprId>,\n+    },\n+    Const {\n+        value: &'tcx Const<'tcx>,\n+        span: Span,\n+    },\n+    SymFn {\n+        expr: ExprId,\n+    },\n+    SymStatic {\n+        def_id: DefId,\n+    },\n+}\n+\n+#[derive(Copy, Clone, Debug, PartialEq)]\n+pub enum BindingMode {\n+    ByValue,\n+    ByRef(BorrowKind),\n+}\n+\n+#[derive(Clone, Debug, PartialEq)]\n+pub struct FieldPat<'tcx> {\n+    pub field: Field,\n+    pub pattern: Pat<'tcx>,\n+}\n+\n+#[derive(Clone, Debug, PartialEq)]\n+pub struct Pat<'tcx> {\n+    pub ty: Ty<'tcx>,\n+    pub span: Span,\n+    pub kind: Box<PatKind<'tcx>>,\n+}\n+\n+impl<'tcx> Pat<'tcx> {\n+    pub fn wildcard_from_ty(ty: Ty<'tcx>) -> Self {\n+        Pat { ty, span: DUMMY_SP, kind: Box::new(PatKind::Wild) }\n+    }\n+}\n+\n+#[derive(Copy, Clone, Debug, PartialEq)]\n+pub struct PatTyProj<'tcx> {\n+    pub user_ty: CanonicalUserType<'tcx>,\n+}\n+\n+impl<'tcx> PatTyProj<'tcx> {\n+    pub fn from_user_type(user_annotation: CanonicalUserType<'tcx>) -> Self {\n+        Self { user_ty: user_annotation }\n+    }\n+\n+    pub fn user_ty(\n+        self,\n+        annotations: &mut CanonicalUserTypeAnnotations<'tcx>,\n+        inferred_ty: Ty<'tcx>,\n+        span: Span,\n+    ) -> UserTypeProjection {\n+        UserTypeProjection {\n+            base: annotations.push(CanonicalUserTypeAnnotation {\n+                span,\n+                user_ty: self.user_ty,\n+                inferred_ty,\n+            }),\n+            projs: Vec::new(),\n+        }\n+    }\n+}\n+\n+#[derive(Copy, Clone, Debug, PartialEq)]\n+pub struct Ascription<'tcx> {\n+    pub user_ty: PatTyProj<'tcx>,\n+    /// Variance to use when relating the type `user_ty` to the **type of the value being\n+    /// matched**. Typically, this is `Variance::Covariant`, since the value being matched must\n+    /// have a type that is some subtype of the ascribed type.\n+    ///\n+    /// Note that this variance does not apply for any bindings within subpatterns. The type\n+    /// assigned to those bindings must be exactly equal to the `user_ty` given here.\n+    ///\n+    /// The only place where this field is not `Covariant` is when matching constants, where\n+    /// we currently use `Contravariant` -- this is because the constant type just needs to\n+    /// be \"comparable\" to the type of the input value. So, for example:\n+    ///\n+    /// ```text\n+    /// match x { \"foo\" => .. }\n+    /// ```\n+    ///\n+    /// requires that `&'static str <: T_x`, where `T_x` is the type of `x`. Really, we should\n+    /// probably be checking for a `PartialEq` impl instead, but this preserves the behavior\n+    /// of the old type-check for now. See #57280 for details.\n+    pub variance: ty::Variance,\n+    pub user_ty_span: Span,\n+}\n+\n+#[derive(Clone, Debug, PartialEq)]\n+pub enum PatKind<'tcx> {\n+    Wild,\n+\n+    AscribeUserType {\n+        ascription: Ascription<'tcx>,\n+        subpattern: Pat<'tcx>,\n+    },\n+\n+    /// `x`, `ref x`, `x @ P`, etc.\n+    Binding {\n+        mutability: Mutability,\n+        name: Symbol,\n+        mode: BindingMode,\n+        var: hir::HirId,\n+        ty: Ty<'tcx>,\n+        subpattern: Option<Pat<'tcx>>,\n+        /// Is this the leftmost occurrence of the binding, i.e., is `var` the\n+        /// `HirId` of this pattern?\n+        is_primary: bool,\n+    },\n+\n+    /// `Foo(...)` or `Foo{...}` or `Foo`, where `Foo` is a variant name from an ADT with\n+    /// multiple variants.\n+    Variant {\n+        adt_def: &'tcx AdtDef,\n+        substs: SubstsRef<'tcx>,\n+        variant_index: VariantIdx,\n+        subpatterns: Vec<FieldPat<'tcx>>,\n+    },\n+\n+    /// `(...)`, `Foo(...)`, `Foo{...}`, or `Foo`, where `Foo` is a variant name from an ADT with\n+    /// a single variant.\n+    Leaf {\n+        subpatterns: Vec<FieldPat<'tcx>>,\n+    },\n+\n+    /// `box P`, `&P`, `&mut P`, etc.\n+    Deref {\n+        subpattern: Pat<'tcx>,\n+    },\n+\n+    /// One of the following:\n+    /// * `&str`, which will be handled as a string pattern and thus exhaustiveness\n+    ///   checking will detect if you use the same string twice in different patterns.\n+    /// * integer, bool, char or float, which will be handled by exhaustivenes to cover exactly\n+    ///   its own value, similar to `&str`, but these values are much simpler.\n+    /// * Opaque constants, that must not be matched structurally. So anything that does not derive\n+    ///   `PartialEq` and `Eq`.\n+    Constant {\n+        value: &'tcx ty::Const<'tcx>,\n+    },\n+\n+    Range(PatRange<'tcx>),\n+\n+    /// Matches against a slice, checking the length and extracting elements.\n+    /// irrefutable when there is a slice pattern and both `prefix` and `suffix` are empty.\n+    /// e.g., `&[ref xs @ ..]`.\n+    Slice {\n+        prefix: Vec<Pat<'tcx>>,\n+        slice: Option<Pat<'tcx>>,\n+        suffix: Vec<Pat<'tcx>>,\n+    },\n+\n+    /// Fixed match against an array; irrefutable.\n+    Array {\n+        prefix: Vec<Pat<'tcx>>,\n+        slice: Option<Pat<'tcx>>,\n+        suffix: Vec<Pat<'tcx>>,\n+    },\n+\n+    /// An or-pattern, e.g. `p | q`.\n+    /// Invariant: `pats.len() >= 2`.\n+    Or {\n+        pats: Vec<Pat<'tcx>>,\n+    },\n+}\n+\n+#[derive(Copy, Clone, Debug, PartialEq)]\n+pub struct PatRange<'tcx> {\n+    pub lo: &'tcx ty::Const<'tcx>,\n+    pub hi: &'tcx ty::Const<'tcx>,\n+    pub end: RangeEnd,\n+}\n+\n+impl<'tcx> fmt::Display for Pat<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        // Printing lists is a chore.\n+        let mut first = true;\n+        let mut start_or_continue = |s| {\n+            if first {\n+                first = false;\n+                \"\"\n+            } else {\n+                s\n+            }\n+        };\n+        let mut start_or_comma = || start_or_continue(\", \");\n+\n+        match *self.kind {\n+            PatKind::Wild => write!(f, \"_\"),\n+            PatKind::AscribeUserType { ref subpattern, .. } => write!(f, \"{}: _\", subpattern),\n+            PatKind::Binding { mutability, name, mode, ref subpattern, .. } => {\n+                let is_mut = match mode {\n+                    BindingMode::ByValue => mutability == Mutability::Mut,\n+                    BindingMode::ByRef(bk) => {\n+                        write!(f, \"ref \")?;\n+                        matches!(bk, BorrowKind::Mut { .. })\n+                    }\n+                };\n+                if is_mut {\n+                    write!(f, \"mut \")?;\n+                }\n+                write!(f, \"{}\", name)?;\n+                if let Some(ref subpattern) = *subpattern {\n+                    write!(f, \" @ {}\", subpattern)?;\n+                }\n+                Ok(())\n+            }\n+            PatKind::Variant { ref subpatterns, .. } | PatKind::Leaf { ref subpatterns } => {\n+                let variant = match *self.kind {\n+                    PatKind::Variant { adt_def, variant_index, .. } => {\n+                        Some(&adt_def.variants[variant_index])\n+                    }\n+                    _ => {\n+                        if let ty::Adt(adt, _) = self.ty.kind() {\n+                            if !adt.is_enum() {\n+                                Some(&adt.variants[VariantIdx::new(0)])\n+                            } else {\n+                                None\n+                            }\n+                        } else {\n+                            None\n+                        }\n+                    }\n+                };\n+\n+                if let Some(variant) = variant {\n+                    write!(f, \"{}\", variant.ident)?;\n+\n+                    // Only for Adt we can have `S {...}`,\n+                    // which we handle separately here.\n+                    if variant.ctor_kind == CtorKind::Fictive {\n+                        write!(f, \" {{ \")?;\n+\n+                        let mut printed = 0;\n+                        for p in subpatterns {\n+                            if let PatKind::Wild = *p.pattern.kind {\n+                                continue;\n+                            }\n+                            let name = variant.fields[p.field.index()].ident;\n+                            write!(f, \"{}{}: {}\", start_or_comma(), name, p.pattern)?;\n+                            printed += 1;\n+                        }\n+\n+                        if printed < variant.fields.len() {\n+                            write!(f, \"{}..\", start_or_comma())?;\n+                        }\n+\n+                        return write!(f, \" }}\");\n+                    }\n+                }\n+\n+                let num_fields = variant.map_or(subpatterns.len(), |v| v.fields.len());\n+                if num_fields != 0 || variant.is_none() {\n+                    write!(f, \"(\")?;\n+                    for i in 0..num_fields {\n+                        write!(f, \"{}\", start_or_comma())?;\n+\n+                        // Common case: the field is where we expect it.\n+                        if let Some(p) = subpatterns.get(i) {\n+                            if p.field.index() == i {\n+                                write!(f, \"{}\", p.pattern)?;\n+                                continue;\n+                            }\n+                        }\n+\n+                        // Otherwise, we have to go looking for it.\n+                        if let Some(p) = subpatterns.iter().find(|p| p.field.index() == i) {\n+                            write!(f, \"{}\", p.pattern)?;\n+                        } else {\n+                            write!(f, \"_\")?;\n+                        }\n+                    }\n+                    write!(f, \")\")?;\n+                }\n+\n+                Ok(())\n+            }\n+            PatKind::Deref { ref subpattern } => {\n+                match self.ty.kind() {\n+                    ty::Adt(def, _) if def.is_box() => write!(f, \"box \")?,\n+                    ty::Ref(_, _, mutbl) => {\n+                        write!(f, \"&{}\", mutbl.prefix_str())?;\n+                    }\n+                    _ => bug!(\"{} is a bad Deref pattern type\", self.ty),\n+                }\n+                write!(f, \"{}\", subpattern)\n+            }\n+            PatKind::Constant { value } => write!(f, \"{}\", value),\n+            PatKind::Range(PatRange { lo, hi, end }) => {\n+                write!(f, \"{}\", lo)?;\n+                write!(f, \"{}\", end)?;\n+                write!(f, \"{}\", hi)\n+            }\n+            PatKind::Slice { ref prefix, ref slice, ref suffix }\n+            | PatKind::Array { ref prefix, ref slice, ref suffix } => {\n+                write!(f, \"[\")?;\n+                for p in prefix {\n+                    write!(f, \"{}{}\", start_or_comma(), p)?;\n+                }\n+                if let Some(ref slice) = *slice {\n+                    write!(f, \"{}\", start_or_comma())?;\n+                    match *slice.kind {\n+                        PatKind::Wild => {}\n+                        _ => write!(f, \"{}\", slice)?,\n+                    }\n+                    write!(f, \"..\")?;\n+                }\n+                for p in suffix {\n+                    write!(f, \"{}{}\", start_or_comma(), p)?;\n+                }\n+                write!(f, \"]\")\n+            }\n+            PatKind::Or { ref pats } => {\n+                for pat in pats {\n+                    write!(f, \"{}{}\", start_or_continue(\" | \"), pat)?;\n+                }\n+                Ok(())\n+            }\n+        }\n+    }\n+}"}, {"sha": "498cbcf7e6e7083d76ca9da38d17e286f01c5818", "filename": "compiler/rustc_mir_build/src/build/block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd80018159f6d563131ab81105d319c15d024f07/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd80018159f6d563131ab81105d319c15d024f07/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fblock.rs?ref=bd80018159f6d563131ab81105d319c15d024f07", "patch": "@@ -1,7 +1,7 @@\n use crate::build::matches::ArmHasGuard;\n use crate::build::ForGuard::OutsideGuard;\n use crate::build::{BlockAnd, BlockAndExtension, BlockFrame, Builder};\n-use crate::thir::*;\n+use rustc_middle::thir::*;\n use rustc_middle::mir::*;\n use rustc_session::lint::builtin::UNSAFE_OP_IN_UNSAFE_FN;\n use rustc_session::lint::Level;"}, {"sha": "dfff47f853fc0e10fb7a473c21139227d7d867f7", "filename": "compiler/rustc_mir_build/src/build/expr/as_constant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd80018159f6d563131ab81105d319c15d024f07/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_constant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd80018159f6d563131ab81105d319c15d024f07/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_constant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_constant.rs?ref=bd80018159f6d563131ab81105d319c15d024f07", "patch": "@@ -1,7 +1,7 @@\n //! See docs in build/expr/mod.rs\n \n use crate::build::Builder;\n-use crate::thir::*;\n+use rustc_middle::thir::*;\n use rustc_middle::mir::*;\n use rustc_middle::ty::CanonicalUserTypeAnnotation;\n "}, {"sha": "5593a44b5226967efa7060b3b45010fba9406196", "filename": "compiler/rustc_mir_build/src/build/expr/as_operand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd80018159f6d563131ab81105d319c15d024f07/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_operand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd80018159f6d563131ab81105d319c15d024f07/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_operand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_operand.rs?ref=bd80018159f6d563131ab81105d319c15d024f07", "patch": "@@ -2,7 +2,7 @@\n \n use crate::build::expr::category::Category;\n use crate::build::{BlockAnd, BlockAndExtension, Builder};\n-use crate::thir::*;\n+use rustc_middle::thir::*;\n use rustc_middle::middle::region;\n use rustc_middle::mir::*;\n "}, {"sha": "37a7418548829663171b72b581915484fa9a3437", "filename": "compiler/rustc_mir_build/src/build/expr/as_place.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd80018159f6d563131ab81105d319c15d024f07/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd80018159f6d563131ab81105d319c15d024f07/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs?ref=bd80018159f6d563131ab81105d319c15d024f07", "patch": "@@ -3,7 +3,7 @@\n use crate::build::expr::category::Category;\n use crate::build::ForGuard::{OutsideGuard, RefWithinGuard};\n use crate::build::{BlockAnd, BlockAndExtension, Builder};\n-use crate::thir::*;\n+use rustc_middle::thir::*;\n use rustc_hir::def_id::DefId;\n use rustc_hir::HirId;\n use rustc_middle::hir::place::ProjectionKind as HirProjectionKind;"}, {"sha": "987f252c4e67a0a71df738aa4705eb5dffa492c6", "filename": "compiler/rustc_mir_build/src/build/expr/as_rvalue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd80018159f6d563131ab81105d319c15d024f07/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd80018159f6d563131ab81105d319c15d024f07/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=bd80018159f6d563131ab81105d319c15d024f07", "patch": "@@ -5,7 +5,7 @@ use rustc_index::vec::Idx;\n use crate::build::expr::as_place::PlaceBase;\n use crate::build::expr::category::{Category, RvalueFunc};\n use crate::build::{BlockAnd, BlockAndExtension, Builder};\n-use crate::thir::*;\n+use rustc_middle::thir::*;\n use rustc_middle::middle::region;\n use rustc_middle::mir::AssertKind;\n use rustc_middle::mir::Place;"}, {"sha": "f05a63f60ee3adba0e75398ccc4c72719ba4667e", "filename": "compiler/rustc_mir_build/src/build/expr/as_temp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd80018159f6d563131ab81105d319c15d024f07/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_temp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd80018159f6d563131ab81105d319c15d024f07/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_temp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_temp.rs?ref=bd80018159f6d563131ab81105d319c15d024f07", "patch": "@@ -2,7 +2,7 @@\n \n use crate::build::scope::DropKind;\n use crate::build::{BlockAnd, BlockAndExtension, Builder};\n-use crate::thir::*;\n+use rustc_middle::thir::*;\n use rustc_data_structures::stack::ensure_sufficient_stack;\n use rustc_middle::middle::region;\n use rustc_middle::mir::*;"}, {"sha": "c834ce6ce68fd160b0073e4f1ff7ad3cc9e90c0a", "filename": "compiler/rustc_mir_build/src/build/expr/category.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd80018159f6d563131ab81105d319c15d024f07/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fcategory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd80018159f6d563131ab81105d319c15d024f07/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fcategory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fcategory.rs?ref=bd80018159f6d563131ab81105d319c15d024f07", "patch": "@@ -1,4 +1,4 @@\n-use crate::thir::*;\n+use rustc_middle::thir::*;\n \n #[derive(Debug, PartialEq)]\n crate enum Category {"}, {"sha": "c74b182fbf07d4db263e70096c1bfb93da84b776", "filename": "compiler/rustc_mir_build/src/build/expr/into.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bd80018159f6d563131ab81105d319c15d024f07/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd80018159f6d563131ab81105d319c15d024f07/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs?ref=bd80018159f6d563131ab81105d319c15d024f07", "patch": "@@ -2,7 +2,7 @@\n \n use crate::build::expr::category::{Category, RvalueFunc};\n use crate::build::{BlockAnd, BlockAndExtension, BlockFrame, Builder};\n-use crate::thir::*;\n+use rustc_middle::thir::*;\n use rustc_ast::InlineAsmOptions;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::stack::ensure_sufficient_stack;\n@@ -337,8 +337,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 block.unit()\n             }\n             ExprKind::InlineAsm { template, ref operands, options, line_spans } => {\n-                use crate::thir;\n-                use rustc_middle::mir;\n+                use rustc_middle::{mir, thir};\n                 let operands = operands\n                     .into_iter()\n                     .map(|op| match *op {"}, {"sha": "33207065883efaf6d15a1f16bd95b7edb7a141de", "filename": "compiler/rustc_mir_build/src/build/expr/stmt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd80018159f6d563131ab81105d319c15d024f07/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd80018159f6d563131ab81105d319c15d024f07/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fstmt.rs?ref=bd80018159f6d563131ab81105d319c15d024f07", "patch": "@@ -1,6 +1,6 @@\n use crate::build::scope::BreakableTarget;\n use crate::build::{BlockAnd, BlockAndExtension, BlockFrame, Builder};\n-use crate::thir::*;\n+use rustc_middle::thir::*;\n use rustc_middle::middle::region;\n use rustc_middle::mir::*;\n "}, {"sha": "8164529dd1ff7d6e3e7c9368d0ec9bba5cbe844d", "filename": "compiler/rustc_mir_build/src/build/matches/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bd80018159f6d563131ab81105d319c15d024f07/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd80018159f6d563131ab81105d319c15d024f07/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs?ref=bd80018159f6d563131ab81105d319c15d024f07", "patch": "@@ -10,7 +10,6 @@ use crate::build::scope::DropKind;\n use crate::build::ForGuard::{self, OutsideGuard, RefWithinGuard};\n use crate::build::{BlockAnd, BlockAndExtension, Builder};\n use crate::build::{GuardFrame, GuardFrameLocal, LocalsForNode};\n-use crate::thir::{self, *};\n use rustc_data_structures::{\n     fx::{FxHashSet, FxIndexMap},\n     stack::ensure_sufficient_stack,\n@@ -19,6 +18,7 @@ use rustc_hir::HirId;\n use rustc_index::bit_set::BitSet;\n use rustc_middle::middle::region;\n use rustc_middle::mir::*;\n+use rustc_middle::thir::{self, *};\n use rustc_middle::ty::{self, CanonicalUserTypeAnnotation, Ty};\n use rustc_span::symbol::Symbol;\n use rustc_span::Span;\n@@ -432,7 +432,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                         ..\n                     },\n                 ascription:\n-                    thir::pattern::Ascription { user_ty: pat_ascription_ty, variance: _, user_ty_span },\n+                    thir::Ascription { user_ty: pat_ascription_ty, variance: _, user_ty_span },\n             } => {\n                 let place =\n                     self.storage_live_binding(block, var, irrefutable_pat.span, OutsideGuard, true);\n@@ -687,7 +687,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n             PatKind::AscribeUserType {\n                 ref subpattern,\n-                ascription: thir::pattern::Ascription { ref user_ty, user_ty_span, variance: _ },\n+                ascription: thir::Ascription { ref user_ty, user_ty_span, variance: _ },\n             } => {\n                 // This corresponds to something like\n                 //"}, {"sha": "13cfc3695cc9f03b560451551902052e2b9fa014", "filename": "compiler/rustc_mir_build/src/build/matches/simplify.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bd80018159f6d563131ab81105d319c15d024f07/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd80018159f6d563131ab81105d319c15d024f07/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fsimplify.rs?ref=bd80018159f6d563131ab81105d319c15d024f07", "patch": "@@ -15,8 +15,8 @@\n use crate::build::expr::as_place::PlaceBuilder;\n use crate::build::matches::{Ascription, Binding, Candidate, MatchPair};\n use crate::build::Builder;\n-use crate::thir::{self, *};\n use rustc_hir::RangeEnd;\n+use rustc_middle::thir::{self, *};\n use rustc_middle::ty;\n use rustc_middle::ty::layout::IntegerExt;\n use rustc_target::abi::{Integer, Size};\n@@ -152,7 +152,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         match *match_pair.pattern.kind {\n             PatKind::AscribeUserType {\n                 ref subpattern,\n-                ascription: thir::pattern::Ascription { variance, user_ty, user_ty_span },\n+                ascription: thir::Ascription { variance, user_ty, user_ty_span },\n             } => {\n                 // Apply the type ascription to the value at `match_pair.place`, which is the\n                 candidate.ascriptions.push(Ascription {"}, {"sha": "c87f42738c67fa3645d0e627a7dcc9efb0ea13a1", "filename": "compiler/rustc_mir_build/src/build/matches/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd80018159f6d563131ab81105d319c15d024f07/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd80018159f6d563131ab81105d319c15d024f07/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs?ref=bd80018159f6d563131ab81105d319c15d024f07", "patch": "@@ -9,11 +9,11 @@ use crate::build::expr::as_place::PlaceBuilder;\n use crate::build::matches::{Candidate, MatchPair, Test, TestKind};\n use crate::build::Builder;\n use crate::thir::pattern::compare_const_vals;\n-use crate::thir::*;\n use rustc_data_structures::fx::FxIndexMap;\n use rustc_hir::{LangItem, RangeEnd};\n use rustc_index::bit_set::BitSet;\n use rustc_middle::mir::*;\n+use rustc_middle::thir::*;\n use rustc_middle::ty::subst::{GenericArg, Subst};\n use rustc_middle::ty::util::IntTypeExt;\n use rustc_middle::ty::{self, adjustment::PointerCast, Ty, TyCtxt};"}, {"sha": "3cf8ae6efd946f33ae207347cd2b70af0a790023", "filename": "compiler/rustc_mir_build/src/build/matches/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd80018159f6d563131ab81105d319c15d024f07/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd80018159f6d563131ab81105d319c15d024f07/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Futil.rs?ref=bd80018159f6d563131ab81105d319c15d024f07", "patch": "@@ -1,8 +1,8 @@\n use crate::build::expr::as_place::PlaceBuilder;\n use crate::build::matches::MatchPair;\n use crate::build::Builder;\n-use crate::thir::*;\n use rustc_middle::mir::*;\n+use rustc_middle::thir::*;\n use rustc_middle::ty;\n use smallvec::SmallVec;\n use std::convert::TryInto;"}, {"sha": "17e8fb5b9bff96afcc87fa9ad2438127eb03906a", "filename": "compiler/rustc_mir_build/src/build/mod.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bd80018159f6d563131ab81105d319c15d024f07/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd80018159f6d563131ab81105d319c15d024f07/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs?ref=bd80018159f6d563131ab81105d319c15d024f07", "patch": "@@ -1,7 +1,8 @@\n use crate::build;\n use crate::build::expr::as_place::PlaceBuilder;\n use crate::build::scope::DropKind;\n-use crate::thir::{build_thir, BindingMode, Expr, ExprId, LintLevel, Pat, PatKind, Thir};\n+use crate::thir::build_thir;\n+use crate::thir::pattern::pat_from_hir;\n use rustc_attr::{self as attr, UnwindAttr};\n use rustc_errors::ErrorReported;\n use rustc_hir as hir;\n@@ -13,6 +14,7 @@ use rustc_infer::infer::{InferCtxt, TyCtxtInferExt};\n use rustc_middle::hir::place::PlaceBase as HirPlaceBase;\n use rustc_middle::middle::region;\n use rustc_middle::mir::*;\n+use rustc_middle::thir::{BindingMode, Expr, ExprId, LintLevel, PatKind, Thir};\n use rustc_middle::ty::subst::Subst;\n use rustc_middle::ty::{self, Ty, TyCtxt, TypeFoldable, TypeckResults};\n use rustc_span::symbol::{kw, sym};\n@@ -1016,7 +1018,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     Node::Pat(pat) | Node::Binding(pat) => pat,\n                     node => bug!(\"pattern became {:?}\", node),\n                 };\n-                let pattern = Pat::from_hir(tcx, self.param_env, self.typeck_results, pat);\n+                let pattern = pat_from_hir(tcx, self.param_env, self.typeck_results, pat);\n                 let original_source_scope = self.source_scope;\n                 let span = pattern.span;\n                 self.set_correct_source_scope_for_arg(arg.hir_id, original_source_scope, span);"}, {"sha": "3de894bd37056e2c1f87097dd88c037171852ae2", "filename": "compiler/rustc_mir_build/src/build/scope.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bd80018159f6d563131ab81105d319c15d024f07/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd80018159f6d563131ab81105d319c15d024f07/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fscope.rs?ref=bd80018159f6d563131ab81105d319c15d024f07", "patch": "@@ -82,11 +82,12 @@ that contains only loops and breakable blocks. It tracks where a `break`,\n */\n \n use crate::build::{BlockAnd, BlockAndExtension, BlockFrame, Builder, CFG};\n-use crate::thir::{Expr, LintLevel};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_index::vec::IndexVec;\n use rustc_middle::middle::region;\n use rustc_middle::mir::*;\n+use rustc_middle::thir::{Expr, LintLevel};\n+\n use rustc_span::{Span, DUMMY_SP};\n \n #[derive(Debug)]"}, {"sha": "77235fe9ab33b5f890244e5e1d55ffc79702dce5", "filename": "compiler/rustc_mir_build/src/thir/cx/block.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bd80018159f6d563131ab81105d319c15d024f07/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd80018159f6d563131ab81105d319c15d024f07/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fblock.rs?ref=bd80018159f6d563131ab81105d319c15d024f07", "patch": "@@ -1,8 +1,8 @@\n use crate::thir::cx::Cx;\n-use crate::thir::{self, *};\n \n use rustc_hir as hir;\n use rustc_middle::middle::region;\n+use rustc_middle::thir::*;\n use rustc_middle::ty;\n \n use rustc_index::vec::Idx;\n@@ -81,7 +81,7 @@ impl<'tcx> Cx<'tcx> {\n                                     ty: pattern.ty,\n                                     span: pattern.span,\n                                     kind: Box::new(PatKind::AscribeUserType {\n-                                        ascription: thir::pattern::Ascription {\n+                                        ascription: Ascription {\n                                             user_ty: PatTyProj::from_user_type(user_ty),\n                                             user_ty_span: ty.span,\n                                             variance: ty::Variance::Covariant,"}, {"sha": "aa4acfab5c81039c32df9f1b56f0dfbefe823ea8", "filename": "compiler/rustc_mir_build/src/thir/cx/expr.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/bd80018159f6d563131ab81105d319c15d024f07/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd80018159f6d563131ab81105d319c15d024f07/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs?ref=bd80018159f6d563131ab81105d319c15d024f07", "patch": "@@ -1,21 +1,24 @@\n use crate::thir::cx::Cx;\n use crate::thir::util::UserAnnotatedTyHelpers;\n-use crate::thir::*;\n use rustc_data_structures::stack::ensure_sufficient_stack;\n use rustc_hir as hir;\n use rustc_hir::def::{CtorKind, CtorOf, DefKind, Res};\n use rustc_index::vec::Idx;\n use rustc_middle::hir::place::Place as HirPlace;\n use rustc_middle::hir::place::PlaceBase as HirPlaceBase;\n use rustc_middle::hir::place::ProjectionKind as HirProjectionKind;\n+use rustc_middle::middle::region;\n use rustc_middle::mir::interpret::Scalar;\n-use rustc_middle::mir::BorrowKind;\n+use rustc_middle::mir::{BinOp, BorrowKind, Field, UnOp};\n+use rustc_middle::thir::*;\n use rustc_middle::ty::adjustment::{\n     Adjust, Adjustment, AutoBorrow, AutoBorrowMutability, PointerCast,\n };\n use rustc_middle::ty::subst::{InternalSubsts, SubstsRef};\n-use rustc_middle::ty::{self, AdtKind, Ty};\n+use rustc_middle::ty::{self, AdtKind, Ty, UpvarSubsts, UserType};\n+use rustc_span::def_id::DefId;\n use rustc_span::Span;\n+use rustc_target::abi::VariantIdx;\n \n impl<'tcx> Cx<'tcx> {\n     crate fn mirror_expr(&mut self, expr: &'tcx hir::Expr<'tcx>) -> ExprId {"}, {"sha": "b9fce9f2a8d6901d5babbf0fac1bd91338d2a99a", "filename": "compiler/rustc_mir_build/src/thir/cx/mod.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bd80018159f6d563131ab81105d319c15d024f07/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd80018159f6d563131ab81105d319c15d024f07/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fmod.rs?ref=bd80018159f6d563131ab81105d319c15d024f07", "patch": "@@ -3,15 +3,17 @@\n //! etc., and instead goes through the `Cx` for most of its work.\n \n use crate::thir::util::UserAnnotatedTyHelpers;\n-use crate::thir::*;\n+use crate::thir::pattern::pat_from_hir;\n \n use rustc_ast as ast;\n use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::Node;\n use rustc_middle::middle::region;\n use rustc_middle::mir::interpret::{LitToConstError, LitToConstInput};\n+use rustc_middle::thir::*;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n+use rustc_span::Span;\n \n pub fn build_thir<'tcx>(\n     tcx: TyCtxt<'tcx>,\n@@ -79,7 +81,7 @@ impl<'tcx> Cx<'tcx> {\n             Node::Pat(p) | Node::Binding(p) => p,\n             node => bug!(\"pattern became {:?}\", node),\n         };\n-        Pat::from_hir(self.tcx, self.param_env, self.typeck_results(), p)\n+        pat_from_hir(self.tcx, self.param_env, self.typeck_results(), p)\n     }\n }\n "}, {"sha": "1ef299c178e1733bb37cec3cd04aed2331ac53c1", "filename": "compiler/rustc_mir_build/src/thir/mod.rs", "status": "modified", "additions": 0, "deletions": 426, "changes": 426, "blob_url": "https://github.com/rust-lang/rust/blob/bd80018159f6d563131ab81105d319c15d024f07/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd80018159f6d563131ab81105d319c15d024f07/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fmod.rs?ref=bd80018159f6d563131ab81105d319c15d024f07", "patch": "@@ -4,438 +4,12 @@\n //! unit-tested and separated from the Rust source and compiler data\n //! structures.\n \n-use rustc_ast::{InlineAsmOptions, InlineAsmTemplatePiece};\n-use rustc_hir as hir;\n-use rustc_hir::def_id::DefId;\n-use rustc_index::newtype_index;\n-use rustc_index::vec::IndexVec;\n-use rustc_middle::infer::canonical::Canonical;\n-use rustc_middle::middle::region;\n-use rustc_middle::mir::{BinOp, BorrowKind, FakeReadCause, Field, UnOp};\n-use rustc_middle::ty::adjustment::PointerCast;\n-use rustc_middle::ty::subst::SubstsRef;\n-use rustc_middle::ty::{AdtDef, Const, Ty, UpvarSubsts, UserType};\n-use rustc_span::Span;\n-use rustc_target::abi::VariantIdx;\n-use rustc_target::asm::InlineAsmRegOrRegClass;\n-\n-use std::ops::Index;\n-\n crate mod constant;\n \n crate mod cx;\n pub use cx::build_thir;\n \n crate mod pattern;\n-pub use self::pattern::{Ascription, BindingMode, FieldPat, Pat, PatKind, PatRange, PatTyProj};\n \n mod util;\n pub mod visit;\n-\n-newtype_index! {\n-    pub struct ArmId {\n-        DEBUG_FORMAT = \"a{}\"\n-    }\n-}\n-\n-newtype_index! {\n-    pub struct ExprId {\n-        DEBUG_FORMAT = \"e{}\"\n-    }\n-}\n-\n-newtype_index! {\n-    pub struct StmtId {\n-        DEBUG_FORMAT = \"s{}\"\n-    }\n-}\n-\n-macro_rules! thir_with_elements {\n-    ($($name:ident: $id:ty => $value:ty,)*) => {\n-        pub struct Thir<'tcx> {\n-            $(\n-                $name: IndexVec<$id, $value>,\n-            )*\n-        }\n-\n-        impl<'tcx> Thir<'tcx> {\n-            fn new() -> Thir<'tcx> {\n-                Thir {\n-                    $(\n-                        $name: IndexVec::new(),\n-                    )*\n-                }\n-            }\n-        }\n-\n-        $(\n-            impl<'tcx> Index<$id> for Thir<'tcx> {\n-                type Output = $value;\n-                fn index(&self, index: $id) -> &Self::Output {\n-                    &self.$name[index]\n-                }\n-            }\n-        )*\n-    }\n-}\n-\n-thir_with_elements! {\n-    arms: ArmId => Arm<'tcx>,\n-    exprs: ExprId => Expr<'tcx>,\n-    stmts: StmtId => Stmt<'tcx>,\n-}\n-\n-#[derive(Copy, Clone, Debug)]\n-pub enum LintLevel {\n-    Inherited,\n-    Explicit(hir::HirId),\n-}\n-\n-#[derive(Debug)]\n-pub struct Block {\n-    pub targeted_by_break: bool,\n-    pub region_scope: region::Scope,\n-    pub opt_destruction_scope: Option<region::Scope>,\n-    pub span: Span,\n-    pub stmts: Box<[StmtId]>,\n-    pub expr: Option<ExprId>,\n-    pub safety_mode: BlockSafety,\n-}\n-\n-#[derive(Copy, Clone, Debug)]\n-pub enum BlockSafety {\n-    Safe,\n-    ExplicitUnsafe(hir::HirId),\n-    PushUnsafe,\n-    PopUnsafe,\n-}\n-\n-#[derive(Debug)]\n-pub struct Stmt<'tcx> {\n-    pub kind: StmtKind<'tcx>,\n-    pub opt_destruction_scope: Option<region::Scope>,\n-}\n-\n-#[derive(Debug)]\n-pub enum StmtKind<'tcx> {\n-    Expr {\n-        /// scope for this statement; may be used as lifetime of temporaries\n-        scope: region::Scope,\n-\n-        /// expression being evaluated in this statement\n-        expr: ExprId,\n-    },\n-\n-    Let {\n-        /// scope for variables bound in this let; covers this and\n-        /// remaining statements in block\n-        remainder_scope: region::Scope,\n-\n-        /// scope for the initialization itself; might be used as\n-        /// lifetime of temporaries\n-        init_scope: region::Scope,\n-\n-        /// `let <PAT> = ...`\n-        ///\n-        /// if a type is included, it is added as an ascription pattern\n-        pattern: Pat<'tcx>,\n-\n-        /// let pat: ty = <INIT> ...\n-        initializer: Option<ExprId>,\n-\n-        /// the lint level for this let-statement\n-        lint_level: LintLevel,\n-    },\n-}\n-\n-// `Expr` is used a lot. Make sure it doesn't unintentionally get bigger.\n-#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n-rustc_data_structures::static_assert_size!(Expr<'_>, 144);\n-\n-/// The Thir trait implementor lowers their expressions (`&'tcx H::Expr`)\n-/// into instances of this `Expr` enum. This lowering can be done\n-/// basically as lazily or as eagerly as desired: every recursive\n-/// reference to an expression in this enum is an `ExprId`, which\n-/// may in turn be another instance of this enum (boxed), or else an\n-/// unlowered `&'tcx H::Expr`. Note that instances of `Expr` are very\n-/// short-lived. They are created by `Thir::to_expr`, analyzed and\n-/// converted into MIR, and then discarded.\n-///\n-/// If you compare `Expr` to the full compiler AST, you will see it is\n-/// a good bit simpler. In fact, a number of the more straight-forward\n-/// MIR simplifications are already done in the impl of `Thir`. For\n-/// example, method calls and overloaded operators are absent: they are\n-/// expected to be converted into `Expr::Call` instances.\n-#[derive(Debug)]\n-pub struct Expr<'tcx> {\n-    /// type of this expression\n-    pub ty: Ty<'tcx>,\n-\n-    /// lifetime of this expression if it should be spilled into a\n-    /// temporary; should be None only if in a constant context\n-    pub temp_lifetime: Option<region::Scope>,\n-\n-    /// span of the expression in the source\n-    pub span: Span,\n-\n-    /// kind of expression\n-    pub kind: ExprKind<'tcx>,\n-}\n-\n-#[derive(Debug)]\n-pub enum ExprKind<'tcx> {\n-    Scope {\n-        region_scope: region::Scope,\n-        lint_level: LintLevel,\n-        value: ExprId,\n-    },\n-    Box {\n-        value: ExprId,\n-    },\n-    If {\n-        cond: ExprId,\n-        then: ExprId,\n-        else_opt: Option<ExprId>,\n-    },\n-    Call {\n-        ty: Ty<'tcx>,\n-        fun: ExprId,\n-        args: Box<[ExprId]>,\n-        /// Whether this is from a call in HIR, rather than from an overloaded\n-        /// operator. `true` for overloaded function call.\n-        from_hir_call: bool,\n-        /// This `Span` is the span of the function, without the dot and receiver\n-        /// (e.g. `foo(a, b)` in `x.foo(a, b)`\n-        fn_span: Span,\n-    },\n-    Deref {\n-        arg: ExprId,\n-    }, // NOT overloaded!\n-    Binary {\n-        op: BinOp,\n-        lhs: ExprId,\n-        rhs: ExprId,\n-    }, // NOT overloaded!\n-    LogicalOp {\n-        op: LogicalOp,\n-        lhs: ExprId,\n-        rhs: ExprId,\n-    }, // NOT overloaded!\n-    // LogicalOp is distinct from BinaryOp because of lazy evaluation of the operands.\n-    Unary {\n-        op: UnOp,\n-        arg: ExprId,\n-    }, // NOT overloaded!\n-    Cast {\n-        source: ExprId,\n-    },\n-    Use {\n-        source: ExprId,\n-    }, // Use a lexpr to get a vexpr.\n-    NeverToAny {\n-        source: ExprId,\n-    },\n-    Pointer {\n-        cast: PointerCast,\n-        source: ExprId,\n-    },\n-    Loop {\n-        body: ExprId,\n-    },\n-    Match {\n-        scrutinee: ExprId,\n-        arms: Box<[ArmId]>,\n-    },\n-    Block {\n-        body: Block,\n-    },\n-    Assign {\n-        lhs: ExprId,\n-        rhs: ExprId,\n-    },\n-    AssignOp {\n-        op: BinOp,\n-        lhs: ExprId,\n-        rhs: ExprId,\n-    },\n-    Field {\n-        lhs: ExprId,\n-        name: Field,\n-    },\n-    Index {\n-        lhs: ExprId,\n-        index: ExprId,\n-    },\n-    VarRef {\n-        id: hir::HirId,\n-    },\n-    /// Used to represent upvars mentioned in a closure/generator\n-    UpvarRef {\n-        /// DefId of the closure/generator\n-        closure_def_id: DefId,\n-\n-        /// HirId of the root variable\n-        var_hir_id: hir::HirId,\n-    },\n-    Borrow {\n-        borrow_kind: BorrowKind,\n-        arg: ExprId,\n-    },\n-    /// A `&raw [const|mut] $place_expr` raw borrow resulting in type `*[const|mut] T`.\n-    AddressOf {\n-        mutability: hir::Mutability,\n-        arg: ExprId,\n-    },\n-    Break {\n-        label: region::Scope,\n-        value: Option<ExprId>,\n-    },\n-    Continue {\n-        label: region::Scope,\n-    },\n-    Return {\n-        value: Option<ExprId>,\n-    },\n-    ConstBlock {\n-        value: &'tcx Const<'tcx>,\n-    },\n-    Repeat {\n-        value: ExprId,\n-        count: &'tcx Const<'tcx>,\n-    },\n-    Array {\n-        fields: Box<[ExprId]>,\n-    },\n-    Tuple {\n-        fields: Box<[ExprId]>,\n-    },\n-    Adt {\n-        adt_def: &'tcx AdtDef,\n-        variant_index: VariantIdx,\n-        substs: SubstsRef<'tcx>,\n-\n-        /// Optional user-given substs: for something like `let x =\n-        /// Bar::<T> { ... }`.\n-        user_ty: Option<Canonical<'tcx, UserType<'tcx>>>,\n-\n-        fields: Box<[FieldExpr]>,\n-        base: Option<FruInfo<'tcx>>,\n-    },\n-    PlaceTypeAscription {\n-        source: ExprId,\n-        /// Type that the user gave to this expression\n-        user_ty: Option<Canonical<'tcx, UserType<'tcx>>>,\n-    },\n-    ValueTypeAscription {\n-        source: ExprId,\n-        /// Type that the user gave to this expression\n-        user_ty: Option<Canonical<'tcx, UserType<'tcx>>>,\n-    },\n-    Closure {\n-        closure_id: DefId,\n-        substs: UpvarSubsts<'tcx>,\n-        upvars: Box<[ExprId]>,\n-        movability: Option<hir::Movability>,\n-        fake_reads: Vec<(ExprId, FakeReadCause, hir::HirId)>,\n-    },\n-    Literal {\n-        literal: &'tcx Const<'tcx>,\n-        user_ty: Option<Canonical<'tcx, UserType<'tcx>>>,\n-        /// The `DefId` of the `const` item this literal\n-        /// was produced from, if this is not a user-written\n-        /// literal value.\n-        const_id: Option<DefId>,\n-    },\n-    /// A literal containing the address of a `static`.\n-    ///\n-    /// This is only distinguished from `Literal` so that we can register some\n-    /// info for diagnostics.\n-    StaticRef {\n-        literal: &'tcx Const<'tcx>,\n-        def_id: DefId,\n-    },\n-    InlineAsm {\n-        template: &'tcx [InlineAsmTemplatePiece],\n-        operands: Box<[InlineAsmOperand<'tcx>]>,\n-        options: InlineAsmOptions,\n-        line_spans: &'tcx [Span],\n-    },\n-    /// An expression taking a reference to a thread local.\n-    ThreadLocalRef(DefId),\n-    LlvmInlineAsm {\n-        asm: &'tcx hir::LlvmInlineAsmInner,\n-        outputs: Box<[ExprId]>,\n-        inputs: Box<[ExprId]>,\n-    },\n-    Yield {\n-        value: ExprId,\n-    },\n-}\n-\n-#[derive(Debug)]\n-pub struct FieldExpr {\n-    pub name: Field,\n-    pub expr: ExprId,\n-}\n-\n-#[derive(Debug)]\n-pub struct FruInfo<'tcx> {\n-    pub base: ExprId,\n-    pub field_types: Box<[Ty<'tcx>]>,\n-}\n-\n-#[derive(Debug)]\n-pub struct Arm<'tcx> {\n-    pub pattern: Pat<'tcx>,\n-    pub guard: Option<Guard<'tcx>>,\n-    pub body: ExprId,\n-    pub lint_level: LintLevel,\n-    pub scope: region::Scope,\n-    pub span: Span,\n-}\n-\n-#[derive(Debug)]\n-pub enum Guard<'tcx> {\n-    If(ExprId),\n-    IfLet(Pat<'tcx>, ExprId),\n-}\n-\n-#[derive(Copy, Clone, Debug)]\n-pub enum LogicalOp {\n-    And,\n-    Or,\n-}\n-\n-#[derive(Debug)]\n-pub enum InlineAsmOperand<'tcx> {\n-    In {\n-        reg: InlineAsmRegOrRegClass,\n-        expr: ExprId,\n-    },\n-    Out {\n-        reg: InlineAsmRegOrRegClass,\n-        late: bool,\n-        expr: Option<ExprId>,\n-    },\n-    InOut {\n-        reg: InlineAsmRegOrRegClass,\n-        late: bool,\n-        expr: ExprId,\n-    },\n-    SplitInOut {\n-        reg: InlineAsmRegOrRegClass,\n-        late: bool,\n-        in_expr: ExprId,\n-        out_expr: Option<ExprId>,\n-    },\n-    Const {\n-        value: &'tcx Const<'tcx>,\n-        span: Span,\n-    },\n-    SymFn {\n-        expr: ExprId,\n-    },\n-    SymStatic {\n-        def_id: DefId,\n-    },\n-}"}, {"sha": "389a7595315c6b2f6656768dec17afa08d4334e3", "filename": "compiler/rustc_mir_build/src/thir/pattern/check_match.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/bd80018159f6d563131ab81105d319c15d024f07/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd80018159f6d563131ab81105d319c15d024f07/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs?ref=bd80018159f6d563131ab81105d319c15d024f07", "patch": "@@ -1,8 +1,8 @@\n use super::usefulness::{\n-    compute_match_usefulness, expand_pattern, MatchArm, MatchCheckCtxt, Reachability,\n+    compute_match_usefulness, expand_pattern, is_wildcard, MatchArm, MatchCheckCtxt, Reachability,\n     UsefulnessReport,\n };\n-use super::{PatCtxt, PatKind, PatternError};\n+use super::{PatCtxt, PatternError};\n \n use rustc_arena::TypedArena;\n use rustc_ast::Mutability;\n@@ -12,6 +12,7 @@ use rustc_hir::def::*;\n use rustc_hir::def_id::DefId;\n use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc_hir::{HirId, Pat};\n+use rustc_middle::thir::PatKind;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_session::lint::builtin::BINDINGS_WITH_VARIANT_NAME;\n use rustc_session::lint::builtin::{IRREFUTABLE_LET_PATTERNS, UNREACHABLE_PATTERNS};\n@@ -344,7 +345,7 @@ fn check_for_bindings_named_same_as_variants(cx: &MatchVisitor<'_, '_>, pat: &Pa\n \n /// Checks for common cases of \"catchall\" patterns that may not be intended as such.\n fn pat_is_catchall(pat: &super::Pat<'_>) -> bool {\n-    use super::PatKind::*;\n+    use PatKind::*;\n     match &*pat.kind {\n         Binding { subpattern: None, .. } => true,\n         Binding { subpattern: Some(s), .. } | Deref { subpattern: s } => pat_is_catchall(s),\n@@ -514,7 +515,7 @@ fn non_exhaustive_match<'p, 'tcx>(\n     if (scrut_ty == cx.tcx.types.usize || scrut_ty == cx.tcx.types.isize)\n         && !is_empty_match\n         && witnesses.len() == 1\n-        && witnesses[0].is_wildcard()\n+        && is_wildcard(&witnesses[0])\n     {\n         err.note(&format!(\n             \"`{}` does not have a fixed maximum value, \\"}, {"sha": "369fff00456a79421e123c81bc41ae7acaf2c9f2", "filename": "compiler/rustc_mir_build/src/thir/pattern/const_to_pat.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bd80018159f6d563131ab81105d319c15d024f07/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd80018159f6d563131ab81105d319c15d024f07/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs?ref=bd80018159f6d563131ab81105d319c15d024f07", "patch": "@@ -2,6 +2,7 @@ use rustc_hir as hir;\n use rustc_index::vec::Idx;\n use rustc_infer::infer::{InferCtxt, TyCtxtInferExt};\n use rustc_middle::mir::Field;\n+use rustc_middle::thir::{FieldPat, Pat, PatKind};\n use rustc_middle::ty::print::with_no_trimmed_paths;\n use rustc_middle::ty::{self, AdtDef, Ty, TyCtxt};\n use rustc_session::lint;\n@@ -12,7 +13,7 @@ use rustc_trait_selection::traits::{self, ObligationCause, PredicateObligation};\n \n use std::cell::Cell;\n \n-use super::{FieldPat, Pat, PatCtxt, PatKind};\n+use super::PatCtxt;\n \n impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n     /// Converts an evaluated constant to a pattern (if possible)."}, {"sha": "4b5b648c5044f3b743755150c2755602279734be", "filename": "compiler/rustc_mir_build/src/thir/pattern/deconstruct_pat.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bd80018159f6d563131ab81105d319c15d024f07/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd80018159f6d563131ab81105d319c15d024f07/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs?ref=bd80018159f6d563131ab81105d319c15d024f07", "patch": "@@ -46,15 +46,15 @@ use self::Constructor::*;\n use self::SliceKind::*;\n \n use super::compare_const_vals;\n-use super::usefulness::{MatchCheckCtxt, PatCtxt};\n-use super::{FieldPat, Pat, PatKind, PatRange};\n+use super::usefulness::{is_wildcard, MatchCheckCtxt, PatCtxt};\n \n use rustc_data_structures::captures::Captures;\n use rustc_index::vec::Idx;\n \n use rustc_hir::{HirId, RangeEnd};\n use rustc_middle::mir::interpret::ConstValue;\n use rustc_middle::mir::Field;\n+use rustc_middle::thir::{FieldPat, Pat, PatKind, PatRange};\n use rustc_middle::ty::layout::IntegerExt;\n use rustc_middle::ty::{self, Const, Ty, TyCtxt};\n use rustc_session::lint;\n@@ -1245,13 +1245,13 @@ impl<'p, 'tcx> Fields<'p, 'tcx> {\n                         // of reporting `[x, _, .., _, y]`, we prefer to report `[x, .., y]`.\n                         // This is incorrect if the size is not known, since `[_, ..]` captures\n                         // arrays of lengths `>= 1` whereas `[..]` captures any length.\n-                        while !prefix.is_empty() && prefix.last().unwrap().is_wildcard() {\n+                        while !prefix.is_empty() && is_wildcard(prefix.last().unwrap()) {\n                             prefix.pop();\n                         }\n                     }\n                     let suffix: Vec<_> = if slice.array_len.is_some() {\n                         // Same as above.\n-                        subpatterns.skip_while(Pat::is_wildcard).collect()\n+                        subpatterns.skip_while(is_wildcard).collect()\n                     } else {\n                         subpatterns.collect()\n                     };"}, {"sha": "3225d302cb30c45e58440a2cdf11b21b4c10be10", "filename": "compiler/rustc_mir_build/src/thir/pattern/mod.rs", "status": "modified", "additions": 17, "deletions": 334, "changes": 351, "blob_url": "https://github.com/rust-lang/rust/blob/bd80018159f6d563131ab81105d319c15d024f07/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd80018159f6d563131ab81105d319c15d024f07/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs?ref=bd80018159f6d563131ab81105d319c15d024f07", "patch": "@@ -11,24 +11,20 @@ use crate::thir::util::UserAnnotatedTyHelpers;\n \n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n-use rustc_hir::def::{CtorKind, CtorOf, DefKind, Res};\n+use rustc_hir::def::{CtorOf, DefKind, Res};\n use rustc_hir::pat_util::EnumerateAndAdjustIterator;\n use rustc_hir::RangeEnd;\n use rustc_index::vec::Idx;\n use rustc_middle::mir::interpret::{get_slice_bytes, ConstValue};\n use rustc_middle::mir::interpret::{ErrorHandled, LitToConstError, LitToConstInput};\n use rustc_middle::mir::UserTypeProjection;\n use rustc_middle::mir::{BorrowKind, Field, Mutability};\n+use rustc_middle::thir::{Ascription, BindingMode, FieldPat, Pat, PatKind, PatRange, PatTyProj};\n use rustc_middle::ty::subst::{GenericArg, SubstsRef};\n use rustc_middle::ty::{self, AdtDef, DefIdTree, Region, Ty, TyCtxt, UserType};\n-use rustc_middle::ty::{\n-    CanonicalUserType, CanonicalUserTypeAnnotation, CanonicalUserTypeAnnotations,\n-};\n-use rustc_span::{Span, Symbol, DUMMY_SP};\n-use rustc_target::abi::VariantIdx;\n+use rustc_span::{Span, Symbol};\n \n use std::cmp::Ordering;\n-use std::fmt;\n \n #[derive(Clone, Debug)]\n crate enum PatternError {\n@@ -39,317 +35,6 @@ crate enum PatternError {\n     NonConstPath(Span),\n }\n \n-#[derive(Copy, Clone, Debug, PartialEq)]\n-pub enum BindingMode {\n-    ByValue,\n-    ByRef(BorrowKind),\n-}\n-\n-#[derive(Clone, Debug, PartialEq)]\n-pub struct FieldPat<'tcx> {\n-    pub field: Field,\n-    pub pattern: Pat<'tcx>,\n-}\n-\n-#[derive(Clone, Debug, PartialEq)]\n-pub struct Pat<'tcx> {\n-    pub ty: Ty<'tcx>,\n-    pub span: Span,\n-    pub kind: Box<PatKind<'tcx>>,\n-}\n-\n-impl<'tcx> Pat<'tcx> {\n-    pub(crate) fn wildcard_from_ty(ty: Ty<'tcx>) -> Self {\n-        Pat { ty, span: DUMMY_SP, kind: Box::new(PatKind::Wild) }\n-    }\n-}\n-\n-#[derive(Copy, Clone, Debug, PartialEq)]\n-pub struct PatTyProj<'tcx> {\n-    pub user_ty: CanonicalUserType<'tcx>,\n-}\n-\n-impl<'tcx> PatTyProj<'tcx> {\n-    pub(crate) fn from_user_type(user_annotation: CanonicalUserType<'tcx>) -> Self {\n-        Self { user_ty: user_annotation }\n-    }\n-\n-    pub(crate) fn user_ty(\n-        self,\n-        annotations: &mut CanonicalUserTypeAnnotations<'tcx>,\n-        inferred_ty: Ty<'tcx>,\n-        span: Span,\n-    ) -> UserTypeProjection {\n-        UserTypeProjection {\n-            base: annotations.push(CanonicalUserTypeAnnotation {\n-                span,\n-                user_ty: self.user_ty,\n-                inferred_ty,\n-            }),\n-            projs: Vec::new(),\n-        }\n-    }\n-}\n-\n-#[derive(Copy, Clone, Debug, PartialEq)]\n-pub struct Ascription<'tcx> {\n-    pub user_ty: PatTyProj<'tcx>,\n-    /// Variance to use when relating the type `user_ty` to the **type of the value being\n-    /// matched**. Typically, this is `Variance::Covariant`, since the value being matched must\n-    /// have a type that is some subtype of the ascribed type.\n-    ///\n-    /// Note that this variance does not apply for any bindings within subpatterns. The type\n-    /// assigned to those bindings must be exactly equal to the `user_ty` given here.\n-    ///\n-    /// The only place where this field is not `Covariant` is when matching constants, where\n-    /// we currently use `Contravariant` -- this is because the constant type just needs to\n-    /// be \"comparable\" to the type of the input value. So, for example:\n-    ///\n-    /// ```text\n-    /// match x { \"foo\" => .. }\n-    /// ```\n-    ///\n-    /// requires that `&'static str <: T_x`, where `T_x` is the type of `x`. Really, we should\n-    /// probably be checking for a `PartialEq` impl instead, but this preserves the behavior\n-    /// of the old type-check for now. See #57280 for details.\n-    pub variance: ty::Variance,\n-    pub user_ty_span: Span,\n-}\n-\n-#[derive(Clone, Debug, PartialEq)]\n-pub enum PatKind<'tcx> {\n-    Wild,\n-\n-    AscribeUserType {\n-        ascription: Ascription<'tcx>,\n-        subpattern: Pat<'tcx>,\n-    },\n-\n-    /// `x`, `ref x`, `x @ P`, etc.\n-    Binding {\n-        mutability: Mutability,\n-        name: Symbol,\n-        mode: BindingMode,\n-        var: hir::HirId,\n-        ty: Ty<'tcx>,\n-        subpattern: Option<Pat<'tcx>>,\n-        /// Is this the leftmost occurrence of the binding, i.e., is `var` the\n-        /// `HirId` of this pattern?\n-        is_primary: bool,\n-    },\n-\n-    /// `Foo(...)` or `Foo{...}` or `Foo`, where `Foo` is a variant name from an ADT with\n-    /// multiple variants.\n-    Variant {\n-        adt_def: &'tcx AdtDef,\n-        substs: SubstsRef<'tcx>,\n-        variant_index: VariantIdx,\n-        subpatterns: Vec<FieldPat<'tcx>>,\n-    },\n-\n-    /// `(...)`, `Foo(...)`, `Foo{...}`, or `Foo`, where `Foo` is a variant name from an ADT with\n-    /// a single variant.\n-    Leaf {\n-        subpatterns: Vec<FieldPat<'tcx>>,\n-    },\n-\n-    /// `box P`, `&P`, `&mut P`, etc.\n-    Deref {\n-        subpattern: Pat<'tcx>,\n-    },\n-\n-    /// One of the following:\n-    /// * `&str`, which will be handled as a string pattern and thus exhaustiveness\n-    ///   checking will detect if you use the same string twice in different patterns.\n-    /// * integer, bool, char or float, which will be handled by exhaustivenes to cover exactly\n-    ///   its own value, similar to `&str`, but these values are much simpler.\n-    /// * Opaque constants, that must not be matched structurally. So anything that does not derive\n-    ///   `PartialEq` and `Eq`.\n-    Constant {\n-        value: &'tcx ty::Const<'tcx>,\n-    },\n-\n-    Range(PatRange<'tcx>),\n-\n-    /// Matches against a slice, checking the length and extracting elements.\n-    /// irrefutable when there is a slice pattern and both `prefix` and `suffix` are empty.\n-    /// e.g., `&[ref xs @ ..]`.\n-    Slice {\n-        prefix: Vec<Pat<'tcx>>,\n-        slice: Option<Pat<'tcx>>,\n-        suffix: Vec<Pat<'tcx>>,\n-    },\n-\n-    /// Fixed match against an array; irrefutable.\n-    Array {\n-        prefix: Vec<Pat<'tcx>>,\n-        slice: Option<Pat<'tcx>>,\n-        suffix: Vec<Pat<'tcx>>,\n-    },\n-\n-    /// An or-pattern, e.g. `p | q`.\n-    /// Invariant: `pats.len() >= 2`.\n-    Or {\n-        pats: Vec<Pat<'tcx>>,\n-    },\n-}\n-\n-#[derive(Copy, Clone, Debug, PartialEq)]\n-pub struct PatRange<'tcx> {\n-    pub lo: &'tcx ty::Const<'tcx>,\n-    pub hi: &'tcx ty::Const<'tcx>,\n-    pub end: RangeEnd,\n-}\n-\n-impl<'tcx> fmt::Display for Pat<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        // Printing lists is a chore.\n-        let mut first = true;\n-        let mut start_or_continue = |s| {\n-            if first {\n-                first = false;\n-                \"\"\n-            } else {\n-                s\n-            }\n-        };\n-        let mut start_or_comma = || start_or_continue(\", \");\n-\n-        match *self.kind {\n-            PatKind::Wild => write!(f, \"_\"),\n-            PatKind::AscribeUserType { ref subpattern, .. } => write!(f, \"{}: _\", subpattern),\n-            PatKind::Binding { mutability, name, mode, ref subpattern, .. } => {\n-                let is_mut = match mode {\n-                    BindingMode::ByValue => mutability == Mutability::Mut,\n-                    BindingMode::ByRef(bk) => {\n-                        write!(f, \"ref \")?;\n-                        matches!(bk, BorrowKind::Mut { .. })\n-                    }\n-                };\n-                if is_mut {\n-                    write!(f, \"mut \")?;\n-                }\n-                write!(f, \"{}\", name)?;\n-                if let Some(ref subpattern) = *subpattern {\n-                    write!(f, \" @ {}\", subpattern)?;\n-                }\n-                Ok(())\n-            }\n-            PatKind::Variant { ref subpatterns, .. } | PatKind::Leaf { ref subpatterns } => {\n-                let variant = match *self.kind {\n-                    PatKind::Variant { adt_def, variant_index, .. } => {\n-                        Some(&adt_def.variants[variant_index])\n-                    }\n-                    _ => {\n-                        if let ty::Adt(adt, _) = self.ty.kind() {\n-                            if !adt.is_enum() {\n-                                Some(&adt.variants[VariantIdx::new(0)])\n-                            } else {\n-                                None\n-                            }\n-                        } else {\n-                            None\n-                        }\n-                    }\n-                };\n-\n-                if let Some(variant) = variant {\n-                    write!(f, \"{}\", variant.ident)?;\n-\n-                    // Only for Adt we can have `S {...}`,\n-                    // which we handle separately here.\n-                    if variant.ctor_kind == CtorKind::Fictive {\n-                        write!(f, \" {{ \")?;\n-\n-                        let mut printed = 0;\n-                        for p in subpatterns {\n-                            if let PatKind::Wild = *p.pattern.kind {\n-                                continue;\n-                            }\n-                            let name = variant.fields[p.field.index()].ident;\n-                            write!(f, \"{}{}: {}\", start_or_comma(), name, p.pattern)?;\n-                            printed += 1;\n-                        }\n-\n-                        if printed < variant.fields.len() {\n-                            write!(f, \"{}..\", start_or_comma())?;\n-                        }\n-\n-                        return write!(f, \" }}\");\n-                    }\n-                }\n-\n-                let num_fields = variant.map_or(subpatterns.len(), |v| v.fields.len());\n-                if num_fields != 0 || variant.is_none() {\n-                    write!(f, \"(\")?;\n-                    for i in 0..num_fields {\n-                        write!(f, \"{}\", start_or_comma())?;\n-\n-                        // Common case: the field is where we expect it.\n-                        if let Some(p) = subpatterns.get(i) {\n-                            if p.field.index() == i {\n-                                write!(f, \"{}\", p.pattern)?;\n-                                continue;\n-                            }\n-                        }\n-\n-                        // Otherwise, we have to go looking for it.\n-                        if let Some(p) = subpatterns.iter().find(|p| p.field.index() == i) {\n-                            write!(f, \"{}\", p.pattern)?;\n-                        } else {\n-                            write!(f, \"_\")?;\n-                        }\n-                    }\n-                    write!(f, \")\")?;\n-                }\n-\n-                Ok(())\n-            }\n-            PatKind::Deref { ref subpattern } => {\n-                match self.ty.kind() {\n-                    ty::Adt(def, _) if def.is_box() => write!(f, \"box \")?,\n-                    ty::Ref(_, _, mutbl) => {\n-                        write!(f, \"&{}\", mutbl.prefix_str())?;\n-                    }\n-                    _ => bug!(\"{} is a bad Deref pattern type\", self.ty),\n-                }\n-                write!(f, \"{}\", subpattern)\n-            }\n-            PatKind::Constant { value } => write!(f, \"{}\", value),\n-            PatKind::Range(PatRange { lo, hi, end }) => {\n-                write!(f, \"{}\", lo)?;\n-                write!(f, \"{}\", end)?;\n-                write!(f, \"{}\", hi)\n-            }\n-            PatKind::Slice { ref prefix, ref slice, ref suffix }\n-            | PatKind::Array { ref prefix, ref slice, ref suffix } => {\n-                write!(f, \"[\")?;\n-                for p in prefix {\n-                    write!(f, \"{}{}\", start_or_comma(), p)?;\n-                }\n-                if let Some(ref slice) = *slice {\n-                    write!(f, \"{}\", start_or_comma())?;\n-                    match *slice.kind {\n-                        PatKind::Wild => {}\n-                        _ => write!(f, \"{}\", slice)?,\n-                    }\n-                    write!(f, \"..\")?;\n-                }\n-                for p in suffix {\n-                    write!(f, \"{}{}\", start_or_comma(), p)?;\n-                }\n-                write!(f, \"]\")\n-            }\n-            PatKind::Or { ref pats } => {\n-                for pat in pats {\n-                    write!(f, \"{}{}\", start_or_continue(\" | \"), pat)?;\n-                }\n-                Ok(())\n-            }\n-        }\n-    }\n-}\n-\n crate struct PatCtxt<'a, 'tcx> {\n     crate tcx: TyCtxt<'tcx>,\n     crate param_env: ty::ParamEnv<'tcx>,\n@@ -358,22 +43,20 @@ crate struct PatCtxt<'a, 'tcx> {\n     include_lint_checks: bool,\n }\n \n-impl<'a, 'tcx> Pat<'tcx> {\n-    crate fn from_hir(\n-        tcx: TyCtxt<'tcx>,\n-        param_env: ty::ParamEnv<'tcx>,\n-        typeck_results: &'a ty::TypeckResults<'tcx>,\n-        pat: &'tcx hir::Pat<'tcx>,\n-    ) -> Self {\n-        let mut pcx = PatCtxt::new(tcx, param_env, typeck_results);\n-        let result = pcx.lower_pattern(pat);\n-        if !pcx.errors.is_empty() {\n-            let msg = format!(\"encountered errors lowering pattern: {:?}\", pcx.errors);\n-            tcx.sess.delay_span_bug(pat.span, &msg);\n-        }\n-        debug!(\"Pat::from_hir({:?}) = {:?}\", pat, result);\n-        result\n-    }\n+crate fn pat_from_hir<'a, 'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    typeck_results: &'a ty::TypeckResults<'tcx>,\n+    pat: &'tcx hir::Pat<'tcx>,\n+) -> Pat<'tcx> {\n+    let mut pcx = PatCtxt::new(tcx, param_env, typeck_results);\n+    let result = pcx.lower_pattern(pat);\n+    if !pcx.errors.is_empty() {\n+        let msg = format!(\"encountered errors lowering pattern: {:?}\", pcx.errors);\n+        tcx.sess.delay_span_bug(pat.span, &msg);\n+    }\n+    debug!(\"pat_from_hir({:?}) = {:?}\", pat, result);\n+    result\n }\n \n impl<'a, 'tcx> PatCtxt<'a, 'tcx> {"}, {"sha": "3e38a7b0418fa3ed6c7ebb26bebc37f709a0c933", "filename": "compiler/rustc_mir_build/src/thir/pattern/usefulness.rs", "status": "modified", "additions": 26, "deletions": 28, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/bd80018159f6d563131ab81105d319c15d024f07/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd80018159f6d563131ab81105d319c15d024f07/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs?ref=bd80018159f6d563131ab81105d319c15d024f07", "patch": "@@ -284,7 +284,6 @@ use self::Usefulness::*;\n use self::WitnessPreference::*;\n \n use super::deconstruct_pat::{Constructor, Fields, SplitWildcard};\n-use super::{Pat, PatKind};\n use super::{PatternFoldable, PatternFolder};\n \n use rustc_data_structures::captures::Captures;\n@@ -294,6 +293,7 @@ use rustc_arena::TypedArena;\n use rustc_hir::def_id::DefId;\n use rustc_hir::HirId;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n+use rustc_middle::thir::{Pat, PatKind};\n use rustc_span::Span;\n \n use smallvec::{smallvec, SmallVec};\n@@ -382,31 +382,29 @@ impl<'tcx> PatternFolder<'tcx> for LiteralExpander {\n     }\n }\n \n-impl<'tcx> Pat<'tcx> {\n-    pub(super) fn is_wildcard(&self) -> bool {\n-        matches!(*self.kind, PatKind::Binding { subpattern: None, .. } | PatKind::Wild)\n-    }\n+pub(super) fn is_wildcard(pat: &Pat<'_>) -> bool {\n+    matches!(*pat.kind, PatKind::Binding { subpattern: None, .. } | PatKind::Wild)\n+}\n \n-    fn is_or_pat(&self) -> bool {\n-        matches!(*self.kind, PatKind::Or { .. })\n-    }\n+fn is_or_pat(pat: &Pat<'_>) -> bool {\n+    matches!(*pat.kind, PatKind::Or { .. })\n+}\n \n-    /// Recursively expand this pattern into its subpatterns. Only useful for or-patterns.\n-    fn expand_or_pat(&self) -> Vec<&Self> {\n-        fn expand<'p, 'tcx>(pat: &'p Pat<'tcx>, vec: &mut Vec<&'p Pat<'tcx>>) {\n-            if let PatKind::Or { pats } = pat.kind.as_ref() {\n-                for pat in pats {\n-                    expand(pat, vec);\n-                }\n-            } else {\n-                vec.push(pat)\n+/// Recursively expand this pattern into its subpatterns. Only useful for or-patterns.\n+fn expand_or_pat<'p, 'tcx>(pat: &'p Pat<'tcx>) -> Vec<&'p Pat<'tcx>> {\n+    fn expand<'p, 'tcx>(pat: &'p Pat<'tcx>, vec: &mut Vec<&'p Pat<'tcx>>) {\n+        if let PatKind::Or { pats } = pat.kind.as_ref() {\n+            for pat in pats {\n+                expand(pat, vec);\n             }\n+        } else {\n+            vec.push(pat)\n         }\n-\n-        let mut pats = Vec::new();\n-        expand(self, &mut pats);\n-        pats\n     }\n+\n+    let mut pats = Vec::new();\n+    expand(pat, &mut pats);\n+    pats\n }\n \n /// A row of a matrix. Rows of len 1 are very common, which is why `SmallVec[_; 2]`\n@@ -451,7 +449,7 @@ impl<'p, 'tcx> PatStack<'p, 'tcx> {\n     // Recursively expand the first pattern into its subpatterns. Only useful if the pattern is an\n     // or-pattern. Panics if `self` is empty.\n     fn expand_or_pat<'a>(&'a self) -> impl Iterator<Item = PatStack<'p, 'tcx>> + Captures<'a> {\n-        self.head().expand_or_pat().into_iter().map(move |pat| {\n+        expand_or_pat(self.head()).into_iter().map(move |pat| {\n             let mut new_patstack = PatStack::from_pattern(pat);\n             new_patstack.pats.extend_from_slice(&self.pats[1..]);\n             new_patstack\n@@ -525,7 +523,7 @@ impl<'p, 'tcx> Matrix<'p, 'tcx> {\n     /// Pushes a new row to the matrix. If the row starts with an or-pattern, this recursively\n     /// expands it.\n     fn push(&mut self, row: PatStack<'p, 'tcx>) {\n-        if !row.is_empty() && row.head().is_or_pat() {\n+        if !row.is_empty() && is_or_pat(row.head()) {\n             for row in row.expand_or_pat() {\n                 self.patterns.push(row);\n             }\n@@ -760,7 +758,7 @@ impl<'p, 'tcx> SubPatSet<'p, 'tcx> {\n                     }\n                 }\n                 SubPatSet::Alt { subpats, pat, alt_count, .. } => {\n-                    let expanded = pat.expand_or_pat();\n+                    let expanded = expand_or_pat(pat);\n                     for i in 0..*alt_count {\n                         let sub_set = subpats.get(&i).unwrap_or(&SubPatSet::Empty);\n                         if sub_set.is_empty() {\n@@ -1118,7 +1116,7 @@ fn is_useful<'p, 'tcx>(\n     let pcx = PatCtxt { cx, ty, span: v.head().span, is_top_level };\n \n     // If the first pattern is an or-pattern, expand it.\n-    let ret = if v.head().is_or_pat() {\n+    let ret = if is_or_pat(v.head()) {\n         debug!(\"expanding or-pattern\");\n         let v_head = v.head();\n         let vs: Vec<_> = v.expand_or_pat().collect();\n@@ -1174,7 +1172,7 @@ fn is_useful<'p, 'tcx>(\n #[derive(Clone, Copy)]\n crate struct MatchArm<'p, 'tcx> {\n     /// The pattern must have been lowered through `check_match::MatchVisitor::lower_pattern`.\n-    crate pat: &'p super::Pat<'tcx>,\n+    crate pat: &'p Pat<'tcx>,\n     crate hir_id: HirId,\n     crate has_guard: bool,\n }\n@@ -1196,7 +1194,7 @@ crate struct UsefulnessReport<'p, 'tcx> {\n     crate arm_usefulness: Vec<(MatchArm<'p, 'tcx>, Reachability)>,\n     /// If the match is exhaustive, this is empty. If not, this contains witnesses for the lack of\n     /// exhaustiveness.\n-    crate non_exhaustiveness_witnesses: Vec<super::Pat<'tcx>>,\n+    crate non_exhaustiveness_witnesses: Vec<Pat<'tcx>>,\n }\n \n /// The entrypoint for the usefulness algorithm. Computes whether a match is exhaustive and which\n@@ -1232,7 +1230,7 @@ crate fn compute_match_usefulness<'p, 'tcx>(\n         })\n         .collect();\n \n-    let wild_pattern = cx.pattern_arena.alloc(super::Pat::wildcard_from_ty(scrut_ty));\n+    let wild_pattern = cx.pattern_arena.alloc(Pat::wildcard_from_ty(scrut_ty));\n     let v = PatStack::from_pattern(wild_pattern);\n     let usefulness = is_useful(cx, &matrix, &v, ConstructWitness, scrut_hir_id, false, true);\n     let non_exhaustiveness_witnesses = match usefulness {"}]}