{"sha": "234e0f27c22eb3ab21363574c755f3f5bc0d6795", "node_id": "C_kwDOAAsO6NoAKDIzNGUwZjI3YzIyZWIzYWIyMTM2MzU3NGM3NTVmM2Y1YmMwZDY3OTU", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-08-23T04:55:30Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-08-23T04:55:30Z"}, "message": "Rollup merge of #100887 - eholk:codegen_call_terminator-cleanup, r=fee1-dead\n\nRefactor part of codegen_call_terminator\n\nI was reading through this code and found the chain of `if let` and a nested match on the same value that was matched in the `if let` to be kind of hard to follow. This PR cleans it up by flattening the `if let` chain and nested match into a single `match` expression.", "tree": {"sha": "654cbec591313c0a6a65e36a7577626c2f5b9a7c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/654cbec591313c0a6a65e36a7577626c2f5b9a7c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/234e0f27c22eb3ab21363574c755f3f5bc0d6795", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjBF3CCRBK7hj4Ov3rIwAA2jcIAJptvWNr6hei1BEnW6AVuUrI\n1AsoF25hPS0XiRiBTTEKRZGk/onLmiCBeZbmCLxra107uI5sb3B2XvuemQ1MiEi4\nY1JWYW/NW/J6KDdUaaWp4SH4TEOzUXC9PbmTMsA+3Z/2gyrk1vITiXfT9dE1tF4f\nshVIsLR4t5dqwxi1tHz9abGRcC22lAC/rjqhEwXc5BnHoSowhmBZkwsj29W8/7vK\n4t6vTCNdif81SllrcDaAu2rxkfTSnQ42iEYMwofpU2mZQM+eHdlcoCuLxQBf/wgi\n74cmi6ZSye5lCvF4bY53FTgLk4CQAGIea8u5TFklsnV4shCmPLPbsXpXaH5OEDA=\n=pJFP\n-----END PGP SIGNATURE-----\n", "payload": "tree 654cbec591313c0a6a65e36a7577626c2f5b9a7c\nparent 8332f6559b815f6b0ee325be689f8c732c07de17\nparent b562f9596373881caa704e6046b2e168dd4a4eed\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1661230530 +0200\ncommitter GitHub <noreply@github.com> 1661230530 +0200\n\nRollup merge of #100887 - eholk:codegen_call_terminator-cleanup, r=fee1-dead\n\nRefactor part of codegen_call_terminator\n\nI was reading through this code and found the chain of `if let` and a nested match on the same value that was matched in the `if let` to be kind of hard to follow. This PR cleans it up by flattening the `if let` chain and nested match into a single `match` expression.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/234e0f27c22eb3ab21363574c755f3f5bc0d6795", "html_url": "https://github.com/rust-lang/rust/commit/234e0f27c22eb3ab21363574c755f3f5bc0d6795", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/234e0f27c22eb3ab21363574c755f3f5bc0d6795/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8332f6559b815f6b0ee325be689f8c732c07de17", "url": "https://api.github.com/repos/rust-lang/rust/commits/8332f6559b815f6b0ee325be689f8c732c07de17", "html_url": "https://github.com/rust-lang/rust/commit/8332f6559b815f6b0ee325be689f8c732c07de17"}, {"sha": "b562f9596373881caa704e6046b2e168dd4a4eed", "url": "https://api.github.com/repos/rust-lang/rust/commits/b562f9596373881caa704e6046b2e168dd4a4eed", "html_url": "https://github.com/rust-lang/rust/commit/b562f9596373881caa704e6046b2e168dd4a4eed"}], "stats": {"total": 91, "additions": 44, "deletions": 47}, "files": [{"sha": "47a40be5d8c5b9df7f478a89c55b45cdac8969d8", "filename": "compiler/rustc_codegen_ssa/src/mir/block.rs", "status": "modified", "additions": 44, "deletions": 47, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/234e0f27c22eb3ab21363574c755f3f5bc0d6795/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/234e0f27c22eb3ab21363574c755f3f5bc0d6795/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs?ref=234e0f27c22eb3ab21363574c755f3f5bc0d6795", "patch": "@@ -798,58 +798,55 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             let mut op = self.codegen_operand(&mut bx, arg);\n \n             if let (0, Some(ty::InstanceDef::Virtual(_, idx))) = (i, def) {\n-                if let Pair(..) = op.val {\n-                    // In the case of Rc<Self>, we need to explicitly pass a\n-                    // *mut RcBox<Self> with a Scalar (not ScalarPair) ABI. This is a hack\n-                    // that is understood elsewhere in the compiler as a method on\n-                    // `dyn Trait`.\n-                    // To get a `*mut RcBox<Self>`, we just keep unwrapping newtypes until\n-                    // we get a value of a built-in pointer type\n-                    'descend_newtypes: while !op.layout.ty.is_unsafe_ptr()\n-                        && !op.layout.ty.is_region_ptr()\n-                    {\n-                        for i in 0..op.layout.fields.count() {\n-                            let field = op.extract_field(&mut bx, i);\n-                            if !field.layout.is_zst() {\n-                                // we found the one non-zero-sized field that is allowed\n-                                // now find *its* non-zero-sized field, or stop if it's a\n-                                // pointer\n-                                op = field;\n-                                continue 'descend_newtypes;\n+                match op.val {\n+                    Pair(data_ptr, meta) => {\n+                        // In the case of Rc<Self>, we need to explicitly pass a\n+                        // *mut RcBox<Self> with a Scalar (not ScalarPair) ABI. This is a hack\n+                        // that is understood elsewhere in the compiler as a method on\n+                        // `dyn Trait`.\n+                        // To get a `*mut RcBox<Self>`, we just keep unwrapping newtypes until\n+                        // we get a value of a built-in pointer type\n+                        'descend_newtypes: while !op.layout.ty.is_unsafe_ptr()\n+                            && !op.layout.ty.is_region_ptr()\n+                        {\n+                            for i in 0..op.layout.fields.count() {\n+                                let field = op.extract_field(&mut bx, i);\n+                                if !field.layout.is_zst() {\n+                                    // we found the one non-zero-sized field that is allowed\n+                                    // now find *its* non-zero-sized field, or stop if it's a\n+                                    // pointer\n+                                    op = field;\n+                                    continue 'descend_newtypes;\n+                                }\n                             }\n+\n+                            span_bug!(span, \"receiver has no non-zero-sized fields {:?}\", op);\n                         }\n \n-                        span_bug!(span, \"receiver has no non-zero-sized fields {:?}\", op);\n+                        // now that we have `*dyn Trait` or `&dyn Trait`, split it up into its\n+                        // data pointer and vtable. Look up the method in the vtable, and pass\n+                        // the data pointer as the first argument\n+                        llfn = Some(meth::VirtualIndex::from_index(idx).get_fn(\n+                            &mut bx,\n+                            meta,\n+                            op.layout.ty,\n+                            &fn_abi,\n+                        ));\n+                        llargs.push(data_ptr);\n+                        continue 'make_args;\n                     }\n-\n-                    // now that we have `*dyn Trait` or `&dyn Trait`, split it up into its\n-                    // data pointer and vtable. Look up the method in the vtable, and pass\n-                    // the data pointer as the first argument\n-                    match op.val {\n-                        Pair(data_ptr, meta) => {\n-                            llfn = Some(meth::VirtualIndex::from_index(idx).get_fn(\n-                                &mut bx,\n-                                meta,\n-                                op.layout.ty,\n-                                &fn_abi,\n-                            ));\n-                            llargs.push(data_ptr);\n-                            continue 'make_args;\n-                        }\n-                        other => bug!(\"expected a Pair, got {:?}\", other),\n+                    Ref(data_ptr, Some(meta), _) => {\n+                        // by-value dynamic dispatch\n+                        llfn = Some(meth::VirtualIndex::from_index(idx).get_fn(\n+                            &mut bx,\n+                            meta,\n+                            op.layout.ty,\n+                            &fn_abi,\n+                        ));\n+                        llargs.push(data_ptr);\n+                        continue;\n                     }\n-                } else if let Ref(data_ptr, Some(meta), _) = op.val {\n-                    // by-value dynamic dispatch\n-                    llfn = Some(meth::VirtualIndex::from_index(idx).get_fn(\n-                        &mut bx,\n-                        meta,\n-                        op.layout.ty,\n-                        &fn_abi,\n-                    ));\n-                    llargs.push(data_ptr);\n-                    continue;\n-                } else {\n-                    span_bug!(span, \"can't codegen a virtual call on {:?}\", op);\n+                    _ => span_bug!(span, \"can't codegen a virtual call on {:?}\", op),\n                 }\n             }\n "}]}