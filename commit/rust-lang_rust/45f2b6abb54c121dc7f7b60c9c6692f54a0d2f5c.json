{"sha": "45f2b6abb54c121dc7f7b60c9c6692f54a0d2f5c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ1ZjJiNmFiYjU0YzEyMWRjN2Y3YjYwYzljNjY5MmY1NGEwZDJmNWM=", "commit": {"author": {"name": "Srinivas Reddy Thatiparthy", "email": "thatiparthysreenivas@gmail.com", "date": "2016-09-26T18:55:47Z"}, "committer": {"name": "Srinivas Reddy Thatiparthy", "email": "thatiparthysreenivas@gmail.com", "date": "2016-09-26T18:55:47Z"}, "message": "run rustfmt on libstd/collections/hash folder", "tree": {"sha": "41e205e487ee5d639e4e05236fa38a624de6bffb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/41e205e487ee5d639e4e05236fa38a624de6bffb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/45f2b6abb54c121dc7f7b60c9c6692f54a0d2f5c", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v1\n\niQIcBAABAgAGBQJX6W8zAAoJEAkcWPS/w2VxxykP/iSgnclPK0qXcpmsrvIuekSQ\nfa+PHN/ViKVQx8z0TpbNH96l8z+oVmwJPhZbOX89VyZSpn4/EM2R1lv7IzNRW3J6\ngvkuCwQs1/M5zYwN3zEzz1Mvu/bKV/gVZZ6OXkkm+HbyjBKChMWjv1UntMHTo1Rv\nq32wqY6sbnF3O1rNC40kjg+KHSzzoVJAwZV3KbuTVyLxr1RlDpJ12x8edYc8c1iA\nUXjGnpEw8716AbKnTXkVdPXMX4TBVNILmZCdFpXA3IR2yFK9R48/KHH/7Quf0wJe\nfqr0i3q7zDpm3kovbz5i/r/+Wiv83Xjx3FgmO1kInQPjRTHNhbnhZ7EetneYw8gN\nygHrMKZjdE42/MMGwiClk8XqDamQK1ZrRiqSfeepL4IQKOiymUPHI9l4xJQ0rJTW\nC45WCVTUL6VFyGcElpBWWCEdcK43jeM8i5DbU/O97ABabnXGTBFE+4MqO6xXrP2t\nPxZkocDMnvpI5ZtGaodNpY6o7hPVe9CIRB6S3N5HcUFX4xq9dskskrfk1/ItgmFQ\nPTtQ3IJ0N3I8OQtGCkKI4D0Dv+fahQeUsLXu+ddgkeuQje7snc3qn/kQwRevaR1Z\n4PAl1lW3RFg1qy2SMkRzdSX9vKYia6QGCILfmKZYc8gWTgtdoqj9lYftGHLuLA3I\nOHVl7PSXxEeosaKY/RUx\n=pSek\n-----END PGP SIGNATURE-----", "payload": "tree 41e205e487ee5d639e4e05236fa38a624de6bffb\nparent c2769285ad6d078c9a4499ad9e11278e4b78023c\nauthor Srinivas Reddy Thatiparthy <thatiparthysreenivas@gmail.com> 1474916147 +0530\ncommitter Srinivas Reddy Thatiparthy <thatiparthysreenivas@gmail.com> 1474916147 +0530\n\nrun rustfmt on libstd/collections/hash folder\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/45f2b6abb54c121dc7f7b60c9c6692f54a0d2f5c", "html_url": "https://github.com/rust-lang/rust/commit/45f2b6abb54c121dc7f7b60c9c6692f54a0d2f5c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/45f2b6abb54c121dc7f7b60c9c6692f54a0d2f5c/comments", "author": {"login": "srinivasreddy", "id": 198396, "node_id": "MDQ6VXNlcjE5ODM5Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/198396?v=4", "gravatar_id": "", "url": "https://api.github.com/users/srinivasreddy", "html_url": "https://github.com/srinivasreddy", "followers_url": "https://api.github.com/users/srinivasreddy/followers", "following_url": "https://api.github.com/users/srinivasreddy/following{/other_user}", "gists_url": "https://api.github.com/users/srinivasreddy/gists{/gist_id}", "starred_url": "https://api.github.com/users/srinivasreddy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/srinivasreddy/subscriptions", "organizations_url": "https://api.github.com/users/srinivasreddy/orgs", "repos_url": "https://api.github.com/users/srinivasreddy/repos", "events_url": "https://api.github.com/users/srinivasreddy/events{/privacy}", "received_events_url": "https://api.github.com/users/srinivasreddy/received_events", "type": "User", "site_admin": false}, "committer": {"login": "srinivasreddy", "id": 198396, "node_id": "MDQ6VXNlcjE5ODM5Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/198396?v=4", "gravatar_id": "", "url": "https://api.github.com/users/srinivasreddy", "html_url": "https://github.com/srinivasreddy", "followers_url": "https://api.github.com/users/srinivasreddy/followers", "following_url": "https://api.github.com/users/srinivasreddy/following{/other_user}", "gists_url": "https://api.github.com/users/srinivasreddy/gists{/gist_id}", "starred_url": "https://api.github.com/users/srinivasreddy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/srinivasreddy/subscriptions", "organizations_url": "https://api.github.com/users/srinivasreddy/orgs", "repos_url": "https://api.github.com/users/srinivasreddy/repos", "events_url": "https://api.github.com/users/srinivasreddy/events{/privacy}", "received_events_url": "https://api.github.com/users/srinivasreddy/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c2769285ad6d078c9a4499ad9e11278e4b78023c", "url": "https://api.github.com/repos/rust-lang/rust/commits/c2769285ad6d078c9a4499ad9e11278e4b78023c", "html_url": "https://github.com/rust-lang/rust/commit/c2769285ad6d078c9a4499ad9e11278e4b78023c"}], "stats": {"total": 717, "additions": 438, "deletions": 279}, "files": [{"sha": "ff6cb7985a4de3a90b39646e518984e6d2feb36c", "filename": "src/libstd/collections/hash/bench.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/45f2b6abb54c121dc7f7b60c9c6692f54a0d2f5c/src%2Flibstd%2Fcollections%2Fhash%2Fbench.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45f2b6abb54c121dc7f7b60c9c6692f54a0d2f5c/src%2Flibstd%2Fcollections%2Fhash%2Fbench.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fbench.rs?ref=45f2b6abb54c121dc7f7b60c9c6692f54a0d2f5c", "patch": "@@ -15,17 +15,17 @@ extern crate test;\n use self::test::Bencher;\n \n #[bench]\n-fn new_drop(b : &mut Bencher) {\n+fn new_drop(b: &mut Bencher) {\n     use super::map::HashMap;\n \n     b.iter(|| {\n-        let m : HashMap<i32, i32> = HashMap::new();\n+        let m: HashMap<i32, i32> = HashMap::new();\n         assert_eq!(m.len(), 0);\n     })\n }\n \n #[bench]\n-fn new_insert_drop(b : &mut Bencher) {\n+fn new_insert_drop(b: &mut Bencher) {\n     use super::map::HashMap;\n \n     b.iter(|| {"}, {"sha": "52117b34ec48427407312be19f80a49139e824d5", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 264, "deletions": 184, "changes": 448, "blob_url": "https://github.com/rust-lang/rust/blob/45f2b6abb54c121dc7f7b60c9c6692f54a0d2f5c/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45f2b6abb54c121dc7f7b60c9c6692f54a0d2f5c/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=45f2b6abb54c121dc7f7b60c9c6692f54a0d2f5c", "patch": "@@ -20,19 +20,8 @@ use mem::{self, replace};\n use ops::{Deref, Index};\n use rand::{self, Rng};\n \n-use super::table::{\n-    self,\n-    Bucket,\n-    EmptyBucket,\n-    FullBucket,\n-    FullBucketMut,\n-    RawTable,\n-    SafeHash\n-};\n-use super::table::BucketState::{\n-    Empty,\n-    Full,\n-};\n+use super::table::{self, Bucket, EmptyBucket, FullBucket, FullBucketMut, RawTable, SafeHash};\n+use super::table::BucketState::{Empty, Full};\n \n const INITIAL_LOG2_CAP: usize = 5;\n const INITIAL_CAPACITY: usize = 1 << INITIAL_LOG2_CAP; // 2^5\n@@ -348,12 +337,9 @@ pub struct HashMap<K, V, S = RandomState> {\n \n /// Search for a pre-hashed key.\n #[inline]\n-fn search_hashed<K, V, M, F>(table: M,\n-                             hash: SafeHash,\n-                             mut is_match: F)\n-                             -> InternalEntry<K, V, M> where\n-    M: Deref<Target=RawTable<K, V>>,\n-    F: FnMut(&K) -> bool,\n+fn search_hashed<K, V, M, F>(table: M, hash: SafeHash, mut is_match: F) -> InternalEntry<K, V, M>\n+    where M: Deref<Target = RawTable<K, V>>,\n+          F: FnMut(&K) -> bool\n {\n     // This is the only function where capacity can be zero. To avoid\n     // undefined behavior when Bucket::new gets the raw bucket in this\n@@ -375,7 +361,7 @@ fn search_hashed<K, V, M, F>(table: M,\n                     elem: NoElem(bucket),\n                 };\n             }\n-            Full(bucket) => bucket\n+            Full(bucket) => bucket,\n         };\n \n         let robin_ib = full.index() as isize - full.displacement() as isize;\n@@ -394,9 +380,7 @@ fn search_hashed<K, V, M, F>(table: M,\n         if hash == full.hash() {\n             // If the key doesn't match, it can't be this one..\n             if is_match(full.read().0) {\n-                return InternalEntry::Occupied {\n-                    elem: full\n-                };\n+                return InternalEntry::Occupied { elem: full };\n             }\n         }\n \n@@ -409,13 +393,13 @@ fn pop_internal<K, V>(starting_bucket: FullBucketMut<K, V>) -> (K, V) {\n     let (empty, retkey, retval) = starting_bucket.take();\n     let mut gap = match empty.gap_peek() {\n         Some(b) => b,\n-        None => return (retkey, retval)\n+        None => return (retkey, retval),\n     };\n \n     while gap.full().displacement() != 0 {\n         gap = match gap.shift() {\n             Some(b) => b,\n-            None => break\n+            None => break,\n         };\n     }\n \n@@ -429,11 +413,11 @@ fn pop_internal<K, V>(starting_bucket: FullBucketMut<K, V>) -> (K, V) {\n ///\n /// `hash`, `k`, and `v` are the elements to \"robin hood\" into the hashtable.\n fn robin_hood<'a, K: 'a, V: 'a>(bucket: FullBucketMut<'a, K, V>,\n-                        mut ib: usize,\n-                        mut hash: SafeHash,\n-                        mut key: K,\n-                        mut val: V)\n-                        -> &'a mut V {\n+                                mut ib: usize,\n+                                mut hash: SafeHash,\n+                                mut key: K,\n+                                mut val: V)\n+                                -> &'a mut V {\n     let starting_index = bucket.index();\n     let size = bucket.table().size();\n     // Save the *starting point*.\n@@ -465,8 +449,8 @@ fn robin_hood<'a, K: 'a, V: 'a>(bucket: FullBucketMut<'a, K, V>,\n                     // FullBucketMut, into just one FullBucketMut. The \"table\"\n                     // refers to the inner FullBucketMut in this context.\n                     return bucket.into_table().into_mut_refs().1;\n-                },\n-                Full(bucket) => bucket\n+                }\n+                Full(bucket) => bucket,\n             };\n \n             let probe_ib = full_bucket.index() - full_bucket.displacement();\n@@ -483,9 +467,12 @@ fn robin_hood<'a, K: 'a, V: 'a>(bucket: FullBucketMut<'a, K, V>,\n }\n \n impl<K, V, S> HashMap<K, V, S>\n-    where K: Eq + Hash, S: BuildHasher\n+    where K: Eq + Hash,\n+          S: BuildHasher\n {\n-    fn make_hash<X: ?Sized>(&self, x: &X) -> SafeHash where X: Hash {\n+    fn make_hash<X: ?Sized>(&self, x: &X) -> SafeHash\n+        where X: Hash\n+    {\n         table::make_hash(&self.hash_builder, x)\n     }\n \n@@ -494,15 +481,17 @@ impl<K, V, S> HashMap<K, V, S>\n     /// search_hashed.\n     #[inline]\n     fn search<'a, Q: ?Sized>(&'a self, q: &Q) -> InternalEntry<K, V, &'a RawTable<K, V>>\n-        where K: Borrow<Q>, Q: Eq + Hash\n+        where K: Borrow<Q>,\n+              Q: Eq + Hash\n     {\n         let hash = self.make_hash(q);\n         search_hashed(&self.table, hash, |k| q.eq(k.borrow()))\n     }\n \n     #[inline]\n     fn search_mut<'a, Q: ?Sized>(&'a mut self, q: &Q) -> InternalEntry<K, V, &'a mut RawTable<K, V>>\n-        where K: Borrow<Q>, Q: Eq + Hash\n+        where K: Borrow<Q>,\n+              Q: Eq + Hash\n     {\n         let hash = self.make_hash(q);\n         search_hashed(&mut self.table, hash, |k| q.eq(k.borrow()))\n@@ -522,7 +511,7 @@ impl<K, V, S> HashMap<K, V, S>\n                     empty.put(hash, k, v);\n                     return;\n                 }\n-                Full(b) => b.into_bucket()\n+                Full(b) => b.into_bucket(),\n             };\n             buckets.next();\n         }\n@@ -561,7 +550,8 @@ impl<K: Hash + Eq, V> HashMap<K, V, RandomState> {\n }\n \n impl<K, V, S> HashMap<K, V, S>\n-    where K: Eq + Hash, S: BuildHasher\n+    where K: Eq + Hash,\n+          S: BuildHasher\n {\n     /// Creates an empty `HashMap` which will use the given hash builder to hash\n     /// keys.\n@@ -613,8 +603,7 @@ impl<K, V, S> HashMap<K, V, S>\n     /// ```\n     #[inline]\n     #[stable(feature = \"hashmap_build_hasher\", since = \"1.7.0\")]\n-    pub fn with_capacity_and_hasher(capacity: usize, hash_builder: S)\n-                                    -> HashMap<K, V, S> {\n+    pub fn with_capacity_and_hasher(capacity: usize, hash_builder: S) -> HashMap<K, V, S> {\n         let resize_policy = DefaultResizePolicy::new();\n         let min_cap = max(INITIAL_CAPACITY, resize_policy.min_capacity(capacity));\n         let internal_cap = min_cap.checked_next_power_of_two().expect(\"capacity overflow\");\n@@ -752,7 +741,7 @@ impl<K, V, S> HashMap<K, V, S>\n                     }\n                     b.into_bucket()\n                 }\n-                Empty(b) => b.into_bucket()\n+                Empty(b) => b.into_bucket(),\n             };\n             bucket.next();\n         }\n@@ -806,16 +795,12 @@ impl<K, V, S> HashMap<K, V, S>\n     fn insert_hashed_nocheck(&mut self, hash: SafeHash, k: K, v: V) -> Option<V> {\n         let entry = search_hashed(&mut self.table, hash, |key| *key == k).into_entry(k);\n         match entry {\n-            Some(Occupied(mut elem)) => {\n-                Some(elem.insert(v))\n-            }\n+            Some(Occupied(mut elem)) => Some(elem.insert(v)),\n             Some(Vacant(elem)) => {\n                 elem.insert(v);\n                 None\n             }\n-            None => {\n-                unreachable!()\n-            }\n+            None => unreachable!(),\n         }\n     }\n \n@@ -979,7 +964,9 @@ impl<K, V, S> HashMap<K, V, S>\n     /// assert_eq!(a.len(), 1);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn len(&self) -> usize { self.table.size() }\n+    pub fn len(&self) -> usize {\n+        self.table.size()\n+    }\n \n     /// Returns true if the map contains no elements.\n     ///\n@@ -995,7 +982,9 @@ impl<K, V, S> HashMap<K, V, S>\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn is_empty(&self) -> bool { self.len() == 0 }\n+    pub fn is_empty(&self) -> bool {\n+        self.len() == 0\n+    }\n \n     /// Clears the map, returning all key-value pairs as an iterator. Keeps the\n     /// allocated memory for reuse.\n@@ -1019,9 +1008,7 @@ impl<K, V, S> HashMap<K, V, S>\n     #[inline]\n     #[stable(feature = \"drain\", since = \"1.6.0\")]\n     pub fn drain(&mut self) -> Drain<K, V> {\n-        Drain {\n-            inner: self.table.drain(),\n-        }\n+        Drain { inner: self.table.drain() }\n     }\n \n     /// Clears the map, removing all key-value pairs. Keeps the allocated memory\n@@ -1064,7 +1051,8 @@ impl<K, V, S> HashMap<K, V, S>\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn get<Q: ?Sized>(&self, k: &Q) -> Option<&V>\n-        where K: Borrow<Q>, Q: Hash + Eq\n+        where K: Borrow<Q>,\n+              Q: Hash + Eq\n     {\n         self.search(k).into_occupied_bucket().map(|bucket| bucket.into_refs().1)\n     }\n@@ -1090,7 +1078,8 @@ impl<K, V, S> HashMap<K, V, S>\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn contains_key<Q: ?Sized>(&self, k: &Q) -> bool\n-        where K: Borrow<Q>, Q: Hash + Eq\n+        where K: Borrow<Q>,\n+              Q: Hash + Eq\n     {\n         self.search(k).into_occupied_bucket().is_some()\n     }\n@@ -1118,7 +1107,8 @@ impl<K, V, S> HashMap<K, V, S>\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn get_mut<Q: ?Sized>(&mut self, k: &Q) -> Option<&mut V>\n-        where K: Borrow<Q>, Q: Hash + Eq\n+        where K: Borrow<Q>,\n+              Q: Hash + Eq\n     {\n         self.search_mut(k).into_occupied_bucket().map(|bucket| bucket.into_mut_refs().1)\n     }\n@@ -1176,10 +1166,11 @@ impl<K, V, S> HashMap<K, V, S>\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn remove<Q: ?Sized>(&mut self, k: &Q) -> Option<V>\n-        where K: Borrow<Q>, Q: Hash + Eq\n+        where K: Borrow<Q>,\n+              Q: Hash + Eq\n     {\n         if self.table.size() == 0 {\n-            return None\n+            return None;\n         }\n \n         self.search_mut(k).into_occupied_bucket().map(|bucket| pop_internal(bucket).1)\n@@ -1188,25 +1179,32 @@ impl<K, V, S> HashMap<K, V, S>\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K, V, S> PartialEq for HashMap<K, V, S>\n-    where K: Eq + Hash, V: PartialEq, S: BuildHasher\n+    where K: Eq + Hash,\n+          V: PartialEq,\n+          S: BuildHasher\n {\n     fn eq(&self, other: &HashMap<K, V, S>) -> bool {\n-        if self.len() != other.len() { return false; }\n+        if self.len() != other.len() {\n+            return false;\n+        }\n \n-        self.iter().all(|(key, value)|\n-            other.get(key).map_or(false, |v| *value == *v)\n-        )\n+        self.iter().all(|(key, value)| other.get(key).map_or(false, |v| *value == *v))\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K, V, S> Eq for HashMap<K, V, S>\n-    where K: Eq + Hash, V: Eq, S: BuildHasher\n-{}\n+    where K: Eq + Hash,\n+          V: Eq,\n+          S: BuildHasher\n+{\n+}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K, V, S> Debug for HashMap<K, V, S>\n-    where K: Eq + Hash + Debug, V: Debug, S: BuildHasher\n+    where K: Eq + Hash + Debug,\n+          V: Debug,\n+          S: BuildHasher\n {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         f.debug_map().entries(self.iter()).finish()\n@@ -1216,7 +1214,7 @@ impl<K, V, S> Debug for HashMap<K, V, S>\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K, V, S> Default for HashMap<K, V, S>\n     where K: Eq + Hash,\n-          S: BuildHasher + Default,\n+          S: BuildHasher + Default\n {\n     /// Creates an empty `HashMap<K, V, S>`, with the `Default` value for the hasher.\n     fn default() -> HashMap<K, V, S> {\n@@ -1228,7 +1226,7 @@ impl<K, V, S> Default for HashMap<K, V, S>\n impl<'a, K, Q: ?Sized, V, S> Index<&'a Q> for HashMap<K, V, S>\n     where K: Eq + Hash + Borrow<Q>,\n           Q: Eq + Hash,\n-          S: BuildHasher,\n+          S: BuildHasher\n {\n     type Output = V;\n \n@@ -1241,79 +1239,71 @@ impl<'a, K, Q: ?Sized, V, S> Index<&'a Q> for HashMap<K, V, S>\n /// HashMap iterator.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Iter<'a, K: 'a, V: 'a> {\n-    inner: table::Iter<'a, K, V>\n+    inner: table::Iter<'a, K, V>,\n }\n \n // FIXME(#19839) Remove in favor of `#[derive(Clone)]`\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V> Clone for Iter<'a, K, V> {\n     fn clone(&self) -> Iter<'a, K, V> {\n-        Iter {\n-            inner: self.inner.clone()\n-        }\n+        Iter { inner: self.inner.clone() }\n     }\n }\n \n /// HashMap mutable values iterator.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IterMut<'a, K: 'a, V: 'a> {\n-    inner: table::IterMut<'a, K, V>\n+    inner: table::IterMut<'a, K, V>,\n }\n \n /// HashMap move iterator.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IntoIter<K, V> {\n-    inner: table::IntoIter<K, V>\n+    inner: table::IntoIter<K, V>,\n }\n \n /// HashMap keys iterator.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Keys<'a, K: 'a, V: 'a> {\n-    inner: Iter<'a, K, V>\n+    inner: Iter<'a, K, V>,\n }\n \n // FIXME(#19839) Remove in favor of `#[derive(Clone)]`\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V> Clone for Keys<'a, K, V> {\n     fn clone(&self) -> Keys<'a, K, V> {\n-        Keys {\n-            inner: self.inner.clone()\n-        }\n+        Keys { inner: self.inner.clone() }\n     }\n }\n \n /// HashMap values iterator.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Values<'a, K: 'a, V: 'a> {\n-    inner: Iter<'a, K, V>\n+    inner: Iter<'a, K, V>,\n }\n \n // FIXME(#19839) Remove in favor of `#[derive(Clone)]`\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V> Clone for Values<'a, K, V> {\n     fn clone(&self) -> Values<'a, K, V> {\n-        Values {\n-            inner: self.inner.clone()\n-        }\n+        Values { inner: self.inner.clone() }\n     }\n }\n \n /// HashMap drain iterator.\n #[stable(feature = \"drain\", since = \"1.6.0\")]\n pub struct Drain<'a, K: 'a, V: 'a> {\n-    inner: table::Drain<'a, K, V>\n+    inner: table::Drain<'a, K, V>,\n }\n \n /// Mutable HashMap values iterator.\n #[stable(feature = \"map_values_mut\", since = \"1.10.0\")]\n pub struct ValuesMut<'a, K: 'a, V: 'a> {\n-    inner: IterMut<'a, K, V>\n+    inner: IterMut<'a, K, V>,\n }\n \n enum InternalEntry<K, V, M> {\n-    Occupied {\n-        elem: FullBucket<K, V, M>,\n-    },\n+    Occupied { elem: FullBucket<K, V, M> },\n     Vacant {\n         hash: SafeHash,\n         elem: VacantEntryState<K, V, M>,\n@@ -1338,7 +1328,7 @@ impl<'a, K, V> InternalEntry<K, V, &'a mut RawTable<K, V>> {\n             InternalEntry::Occupied { elem } => {\n                 Some(Occupied(OccupiedEntry {\n                     key: Some(key),\n-                    elem: elem\n+                    elem: elem,\n                 }))\n             }\n             InternalEntry::Vacant { hash, elem } => {\n@@ -1348,7 +1338,7 @@ impl<'a, K, V> InternalEntry<K, V, &'a mut RawTable<K, V>> {\n                     elem: elem,\n                 }))\n             }\n-            InternalEntry::TableIsEmpty => None\n+            InternalEntry::TableIsEmpty => None,\n         }\n     }\n }\n@@ -1362,27 +1352,29 @@ impl<'a, K, V> InternalEntry<K, V, &'a mut RawTable<K, V>> {\n pub enum Entry<'a, K: 'a, V: 'a> {\n     /// An occupied Entry.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    Occupied(\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")] OccupiedEntry<'a, K, V>\n-    ),\n+    Occupied(#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+             OccupiedEntry<'a, K, V>),\n \n     /// A vacant Entry.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    Vacant(\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")] VacantEntry<'a, K, V>\n-    ),\n+    Vacant(#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+           VacantEntry<'a, K, V>),\n }\n \n #[stable(feature= \"debug_hash_map\", since = \"1.12.0\")]\n impl<'a, K: 'a + Debug, V: 'a + Debug> Debug for Entry<'a, K, V> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n-            Vacant(ref v) => f.debug_tuple(\"Entry\")\n-                              .field(v)\n-                              .finish(),\n-            Occupied(ref o) => f.debug_tuple(\"Entry\")\n-                                .field(o)\n-                                .finish(),\n+            Vacant(ref v) => {\n+                f.debug_tuple(\"Entry\")\n+                    .field(v)\n+                    .finish()\n+            }\n+            Occupied(ref o) => {\n+                f.debug_tuple(\"Entry\")\n+                    .field(o)\n+                    .finish()\n+            }\n         }\n     }\n }\n@@ -1401,9 +1393,9 @@ pub struct OccupiedEntry<'a, K: 'a, V: 'a> {\n impl<'a, K: 'a + Debug, V: 'a + Debug> Debug for OccupiedEntry<'a, K, V> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         f.debug_struct(\"OccupiedEntry\")\n-         .field(\"key\", self.key())\n-         .field(\"value\", self.get())\n-         .finish()\n+            .field(\"key\", self.key())\n+            .field(\"value\", self.get())\n+            .finish()\n     }\n }\n \n@@ -1422,8 +1414,8 @@ pub struct VacantEntry<'a, K: 'a, V: 'a> {\n impl<'a, K: 'a + Debug, V: 'a> Debug for VacantEntry<'a, K, V> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         f.debug_tuple(\"VacantEntry\")\n-         .field(self.key())\n-         .finish()\n+            .field(self.key())\n+            .finish()\n     }\n }\n \n@@ -1438,7 +1430,8 @@ enum VacantEntryState<K, V, M> {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V, S> IntoIterator for &'a HashMap<K, V, S>\n-    where K: Eq + Hash, S: BuildHasher\n+    where K: Eq + Hash,\n+          S: BuildHasher\n {\n     type Item = (&'a K, &'a V);\n     type IntoIter = Iter<'a, K, V>;\n@@ -1450,7 +1443,8 @@ impl<'a, K, V, S> IntoIterator for &'a HashMap<K, V, S>\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V, S> IntoIterator for &'a mut HashMap<K, V, S>\n-    where K: Eq + Hash, S: BuildHasher\n+    where K: Eq + Hash,\n+          S: BuildHasher\n {\n     type Item = (&'a K, &'a mut V);\n     type IntoIter = IterMut<'a, K, V>;\n@@ -1462,7 +1456,8 @@ impl<'a, K, V, S> IntoIterator for &'a mut HashMap<K, V, S>\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K, V, S> IntoIterator for HashMap<K, V, S>\n-    where K: Eq + Hash, S: BuildHasher\n+    where K: Eq + Hash,\n+          S: BuildHasher\n {\n     type Item = (K, V);\n     type IntoIter = IntoIter<K, V>;\n@@ -1485,22 +1480,29 @@ impl<K, V, S> IntoIterator for HashMap<K, V, S>\n     /// let vec: Vec<(&str, isize)> = map.into_iter().collect();\n     /// ```\n     fn into_iter(self) -> IntoIter<K, V> {\n-        IntoIter {\n-            inner: self.table.into_iter()\n-        }\n+        IntoIter { inner: self.table.into_iter() }\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V> Iterator for Iter<'a, K, V> {\n     type Item = (&'a K, &'a V);\n \n-    #[inline] fn next(&mut self) -> Option<(&'a K, &'a V)> { self.inner.next() }\n-    #[inline] fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n+    #[inline]\n+    fn next(&mut self) -> Option<(&'a K, &'a V)> {\n+        self.inner.next()\n+    }\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.inner.size_hint()\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V> ExactSizeIterator for Iter<'a, K, V> {\n-    #[inline] fn len(&self) -> usize { self.inner.len() }\n+    #[inline]\n+    fn len(&self) -> usize {\n+        self.inner.len()\n+    }\n }\n \n #[unstable(feature = \"fused\", issue = \"35602\")]\n@@ -1510,12 +1512,21 @@ impl<'a, K, V> FusedIterator for Iter<'a, K, V> {}\n impl<'a, K, V> Iterator for IterMut<'a, K, V> {\n     type Item = (&'a K, &'a mut V);\n \n-    #[inline] fn next(&mut self) -> Option<(&'a K, &'a mut V)> { self.inner.next() }\n-    #[inline] fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n+    #[inline]\n+    fn next(&mut self) -> Option<(&'a K, &'a mut V)> {\n+        self.inner.next()\n+    }\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.inner.size_hint()\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V> ExactSizeIterator for IterMut<'a, K, V> {\n-    #[inline] fn len(&self) -> usize { self.inner.len() }\n+    #[inline]\n+    fn len(&self) -> usize {\n+        self.inner.len()\n+    }\n }\n #[unstable(feature = \"fused\", issue = \"35602\")]\n impl<'a, K, V> FusedIterator for IterMut<'a, K, V> {}\n@@ -1524,12 +1535,21 @@ impl<'a, K, V> FusedIterator for IterMut<'a, K, V> {}\n impl<K, V> Iterator for IntoIter<K, V> {\n     type Item = (K, V);\n \n-    #[inline] fn next(&mut self) -> Option<(K, V)> { self.inner.next().map(|(_, k, v)| (k, v)) }\n-    #[inline] fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n+    #[inline]\n+    fn next(&mut self) -> Option<(K, V)> {\n+        self.inner.next().map(|(_, k, v)| (k, v))\n+    }\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.inner.size_hint()\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K, V> ExactSizeIterator for IntoIter<K, V> {\n-    #[inline] fn len(&self) -> usize { self.inner.len() }\n+    #[inline]\n+    fn len(&self) -> usize {\n+        self.inner.len()\n+    }\n }\n #[unstable(feature = \"fused\", issue = \"35602\")]\n impl<K, V> FusedIterator for IntoIter<K, V> {}\n@@ -1538,12 +1558,21 @@ impl<K, V> FusedIterator for IntoIter<K, V> {}\n impl<'a, K, V> Iterator for Keys<'a, K, V> {\n     type Item = &'a K;\n \n-    #[inline] fn next(&mut self) -> Option<(&'a K)> { self.inner.next().map(|(k, _)| k) }\n-    #[inline] fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n+    #[inline]\n+    fn next(&mut self) -> Option<(&'a K)> {\n+        self.inner.next().map(|(k, _)| k)\n+    }\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.inner.size_hint()\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V> ExactSizeIterator for Keys<'a, K, V> {\n-    #[inline] fn len(&self) -> usize { self.inner.len() }\n+    #[inline]\n+    fn len(&self) -> usize {\n+        self.inner.len()\n+    }\n }\n #[unstable(feature = \"fused\", issue = \"35602\")]\n impl<'a, K, V> FusedIterator for Keys<'a, K, V> {}\n@@ -1552,12 +1581,21 @@ impl<'a, K, V> FusedIterator for Keys<'a, K, V> {}\n impl<'a, K, V> Iterator for Values<'a, K, V> {\n     type Item = &'a V;\n \n-    #[inline] fn next(&mut self) -> Option<(&'a V)> { self.inner.next().map(|(_, v)| v) }\n-    #[inline] fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n+    #[inline]\n+    fn next(&mut self) -> Option<(&'a V)> {\n+        self.inner.next().map(|(_, v)| v)\n+    }\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.inner.size_hint()\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V> ExactSizeIterator for Values<'a, K, V> {\n-    #[inline] fn len(&self) -> usize { self.inner.len() }\n+    #[inline]\n+    fn len(&self) -> usize {\n+        self.inner.len()\n+    }\n }\n #[unstable(feature = \"fused\", issue = \"35602\")]\n impl<'a, K, V> FusedIterator for Values<'a, K, V> {}\n@@ -1566,12 +1604,21 @@ impl<'a, K, V> FusedIterator for Values<'a, K, V> {}\n impl<'a, K, V> Iterator for ValuesMut<'a, K, V> {\n     type Item = &'a mut V;\n \n-    #[inline] fn next(&mut self) -> Option<(&'a mut V)> { self.inner.next().map(|(_, v)| v) }\n-    #[inline] fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n+    #[inline]\n+    fn next(&mut self) -> Option<(&'a mut V)> {\n+        self.inner.next().map(|(_, v)| v)\n+    }\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.inner.size_hint()\n+    }\n }\n #[stable(feature = \"map_values_mut\", since = \"1.10.0\")]\n impl<'a, K, V> ExactSizeIterator for ValuesMut<'a, K, V> {\n-    #[inline] fn len(&self) -> usize { self.inner.len() }\n+    #[inline]\n+    fn len(&self) -> usize {\n+        self.inner.len()\n+    }\n }\n #[unstable(feature = \"fused\", issue = \"35602\")]\n impl<'a, K, V> FusedIterator for ValuesMut<'a, K, V> {}\n@@ -1580,12 +1627,21 @@ impl<'a, K, V> FusedIterator for ValuesMut<'a, K, V> {}\n impl<'a, K, V> Iterator for Drain<'a, K, V> {\n     type Item = (K, V);\n \n-    #[inline] fn next(&mut self) -> Option<(K, V)> { self.inner.next().map(|(_, k, v)| (k, v)) }\n-    #[inline] fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n+    #[inline]\n+    fn next(&mut self) -> Option<(K, V)> {\n+        self.inner.next().map(|(_, k, v)| (k, v))\n+    }\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.inner.size_hint()\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V> ExactSizeIterator for Drain<'a, K, V> {\n-    #[inline] fn len(&self) -> usize { self.inner.len() }\n+    #[inline]\n+    fn len(&self) -> usize {\n+        self.inner.len()\n+    }\n }\n #[unstable(feature = \"fused\", issue = \"35602\")]\n impl<'a, K, V> FusedIterator for Drain<'a, K, V> {}\n@@ -1880,21 +1936,18 @@ impl<'a, K: 'a, V: 'a> VacantEntry<'a, K, V> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn insert(self, value: V) -> &'a mut V {\n         match self.elem {\n-            NeqElem(bucket, ib) => {\n-                robin_hood(bucket, ib, self.hash, self.key, value)\n-            }\n-            NoElem(bucket) => {\n-                bucket.put(self.hash, self.key, value).into_mut_refs().1\n-            }\n+            NeqElem(bucket, ib) => robin_hood(bucket, ib, self.hash, self.key, value),\n+            NoElem(bucket) => bucket.put(self.hash, self.key, value).into_mut_refs().1,\n         }\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K, V, S> FromIterator<(K, V)> for HashMap<K, V, S>\n-    where K: Eq + Hash, S: BuildHasher + Default\n+    where K: Eq + Hash,\n+          S: BuildHasher + Default\n {\n-    fn from_iter<T: IntoIterator<Item=(K, V)>>(iter: T) -> HashMap<K, V, S> {\n+    fn from_iter<T: IntoIterator<Item = (K, V)>>(iter: T) -> HashMap<K, V, S> {\n         let iterator = iter.into_iter();\n         let lower = iterator.size_hint().0;\n         let mut map = HashMap::with_capacity_and_hasher(lower, Default::default());\n@@ -1905,9 +1958,10 @@ impl<K, V, S> FromIterator<(K, V)> for HashMap<K, V, S>\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K, V, S> Extend<(K, V)> for HashMap<K, V, S>\n-    where K: Eq + Hash, S: BuildHasher\n+    where K: Eq + Hash,\n+          S: BuildHasher\n {\n-    fn extend<T: IntoIterator<Item=(K, V)>>(&mut self, iter: T) {\n+    fn extend<T: IntoIterator<Item = (K, V)>>(&mut self, iter: T) {\n         for (k, v) in iter {\n             self.insert(k, v);\n         }\n@@ -1916,9 +1970,11 @@ impl<K, V, S> Extend<(K, V)> for HashMap<K, V, S>\n \n #[stable(feature = \"hash_extend_copy\", since = \"1.4.0\")]\n impl<'a, K, V, S> Extend<(&'a K, &'a V)> for HashMap<K, V, S>\n-    where K: Eq + Hash + Copy, V: Copy, S: BuildHasher\n+    where K: Eq + Hash + Copy,\n+          V: Copy,\n+          S: BuildHasher\n {\n-    fn extend<T: IntoIterator<Item=(&'a K, &'a V)>>(&mut self, iter: T) {\n+    fn extend<T: IntoIterator<Item = (&'a K, &'a V)>>(&mut self, iter: T) {\n         self.extend(iter.into_iter().map(|(&key, &value)| (key, value)));\n     }\n }\n@@ -1960,7 +2016,8 @@ impl RandomState {\n     /// let s = RandomState::new();\n     /// ```\n     #[inline]\n-    #[allow(deprecated)] // rand\n+    #[allow(deprecated)]\n+    // rand\n     #[stable(feature = \"hashmap_build_hasher\", since = \"1.7.0\")]\n     pub fn new() -> RandomState {\n         // Historically this function did not cache keys from the OS and instead\n@@ -1987,9 +2044,7 @@ impl RandomState {\n             (r.gen(), r.gen())\n         });\n \n-        KEYS.with(|&(k0, k1)| {\n-            RandomState { k0: k0, k1: k1 }\n-        })\n+        KEYS.with(|&(k0, k1)| RandomState { k0: k0, k1: k1 })\n     }\n }\n \n@@ -2035,7 +2090,9 @@ impl Default for RandomState {\n }\n \n impl<K, S, Q: ?Sized> super::Recover<Q> for HashMap<K, (), S>\n-    where K: Eq + Hash + Borrow<Q>, S: BuildHasher, Q: Eq + Hash\n+    where K: Eq + Hash + Borrow<Q>,\n+          S: BuildHasher,\n+          Q: Eq + Hash\n {\n     type Key = K;\n \n@@ -2045,7 +2102,7 @@ impl<K, S, Q: ?Sized> super::Recover<Q> for HashMap<K, (), S>\n \n     fn take(&mut self, key: &Q) -> Option<K> {\n         if self.table.size() == 0 {\n-            return None\n+            return None;\n         }\n \n         self.search_mut(key).into_occupied_bucket().map(|bucket| pop_internal(bucket).0)\n@@ -2069,18 +2126,40 @@ impl<K, S, Q: ?Sized> super::Recover<Q> for HashMap<K, (), S>\n \n #[allow(dead_code)]\n fn assert_covariance() {\n-    fn map_key<'new>(v: HashMap<&'static str, u8>) -> HashMap<&'new str, u8> { v }\n-    fn map_val<'new>(v: HashMap<u8, &'static str>) -> HashMap<u8, &'new str> { v }\n-    fn iter_key<'a, 'new>(v: Iter<'a, &'static str, u8>) -> Iter<'a, &'new str, u8> { v }\n-    fn iter_val<'a, 'new>(v: Iter<'a, u8, &'static str>) -> Iter<'a, u8, &'new str> { v }\n-    fn into_iter_key<'new>(v: IntoIter<&'static str, u8>) -> IntoIter<&'new str, u8> { v }\n-    fn into_iter_val<'new>(v: IntoIter<u8, &'static str>) -> IntoIter<u8, &'new str> { v }\n-    fn keys_key<'a, 'new>(v: Keys<'a, &'static str, u8>) -> Keys<'a, &'new str, u8> { v }\n-    fn keys_val<'a, 'new>(v: Keys<'a, u8, &'static str>) -> Keys<'a, u8, &'new str> { v }\n-    fn values_key<'a, 'new>(v: Values<'a, &'static str, u8>) -> Values<'a, &'new str, u8> { v }\n-    fn values_val<'a, 'new>(v: Values<'a, u8, &'static str>) -> Values<'a, u8, &'new str> { v }\n+    fn map_key<'new>(v: HashMap<&'static str, u8>) -> HashMap<&'new str, u8> {\n+        v\n+    }\n+    fn map_val<'new>(v: HashMap<u8, &'static str>) -> HashMap<u8, &'new str> {\n+        v\n+    }\n+    fn iter_key<'a, 'new>(v: Iter<'a, &'static str, u8>) -> Iter<'a, &'new str, u8> {\n+        v\n+    }\n+    fn iter_val<'a, 'new>(v: Iter<'a, u8, &'static str>) -> Iter<'a, u8, &'new str> {\n+        v\n+    }\n+    fn into_iter_key<'new>(v: IntoIter<&'static str, u8>) -> IntoIter<&'new str, u8> {\n+        v\n+    }\n+    fn into_iter_val<'new>(v: IntoIter<u8, &'static str>) -> IntoIter<u8, &'new str> {\n+        v\n+    }\n+    fn keys_key<'a, 'new>(v: Keys<'a, &'static str, u8>) -> Keys<'a, &'new str, u8> {\n+        v\n+    }\n+    fn keys_val<'a, 'new>(v: Keys<'a, u8, &'static str>) -> Keys<'a, u8, &'new str> {\n+        v\n+    }\n+    fn values_key<'a, 'new>(v: Values<'a, &'static str, u8>) -> Values<'a, &'new str, u8> {\n+        v\n+    }\n+    fn values_val<'a, 'new>(v: Values<'a, u8, &'static str>) -> Values<'a, u8, &'new str> {\n+        v\n+    }\n     fn drain<'new>(d: Drain<'static, &'static str, &'static str>)\n-        -> Drain<'new, &'new str, &'new str> { d }\n+                   -> Drain<'new, &'new str, &'new str> {\n+        d\n+    }\n }\n \n #[cfg(test)]\n@@ -2145,7 +2224,7 @@ mod test_map {\n \n     #[derive(Hash, PartialEq, Eq)]\n     struct Dropable {\n-        k: usize\n+        k: usize,\n     }\n \n     impl Dropable {\n@@ -2189,7 +2268,7 @@ mod test_map {\n \n             for i in 0..100 {\n                 let d1 = Dropable::new(i);\n-                let d2 = Dropable::new(i+100);\n+                let d2 = Dropable::new(i + 100);\n                 m.insert(d1, d2);\n             }\n \n@@ -2248,7 +2327,7 @@ mod test_map {\n \n             for i in 0..100 {\n                 let d1 = Dropable::new(i);\n-                let d2 = Dropable::new(i+100);\n+                let d2 = Dropable::new(i + 100);\n                 hm.insert(d1, d2);\n             }\n \n@@ -2276,13 +2355,13 @@ mod test_map {\n             for _ in half.by_ref() {}\n \n             DROP_VECTOR.with(|v| {\n-                let nk = (0..100).filter(|&i| {\n-                    v.borrow()[i] == 1\n-                }).count();\n+                let nk = (0..100)\n+                    .filter(|&i| v.borrow()[i] == 1)\n+                    .count();\n \n-                let nv = (0..100).filter(|&i| {\n-                    v.borrow()[i+100] == 1\n-                }).count();\n+                let nv = (0..100)\n+                    .filter(|&i| v.borrow()[i + 100] == 1)\n+                    .count();\n \n                 assert_eq!(nk, 50);\n                 assert_eq!(nv, 50);\n@@ -2339,12 +2418,12 @@ mod test_map {\n             for i in 1..1001 {\n                 assert!(m.insert(i, i).is_none());\n \n-                for j in 1..i+1 {\n+                for j in 1..i + 1 {\n                     let r = m.get(&j);\n                     assert_eq!(r, Some(&j));\n                 }\n \n-                for j in i+1..1001 {\n+                for j in i + 1..1001 {\n                     let r = m.get(&j);\n                     assert_eq!(r, None);\n                 }\n@@ -2358,11 +2437,11 @@ mod test_map {\n             for i in 1..1001 {\n                 assert!(m.remove(&i).is_some());\n \n-                for j in 1..i+1 {\n+                for j in 1..i + 1 {\n                     assert!(!m.contains_key(&j));\n                 }\n \n-                for j in i+1..1001 {\n+                for j in i + 1..1001 {\n                     assert!(m.contains_key(&j));\n                 }\n             }\n@@ -2398,7 +2477,8 @@ mod test_map {\n         assert!(m.insert(5, 14).is_none());\n         let new = 100;\n         match m.get_mut(&5) {\n-            None => panic!(), Some(x) => *x = new\n+            None => panic!(),\n+            Some(x) => *x = new,\n         }\n         assert_eq!(m.get(&5), Some(&new));\n     }\n@@ -2517,7 +2597,7 @@ mod test_map {\n         m.insert(1, 2);\n         match m.get(&1) {\n             None => panic!(),\n-            Some(v) => assert_eq!(*v, 2)\n+            Some(v) => assert_eq!(*v, 2),\n         }\n     }\n \n@@ -2680,7 +2760,7 @@ mod test_map {\n     fn test_size_hint() {\n         let xs = [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6)];\n \n-        let map: HashMap<_, _>  = xs.iter().cloned().collect();\n+        let map: HashMap<_, _> = xs.iter().cloned().collect();\n \n         let mut iter = map.iter();\n \n@@ -2693,7 +2773,7 @@ mod test_map {\n     fn test_iter_len() {\n         let xs = [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6)];\n \n-        let map: HashMap<_, _>  = xs.iter().cloned().collect();\n+        let map: HashMap<_, _> = xs.iter().cloned().collect();\n \n         let mut iter = map.iter();\n \n@@ -2706,7 +2786,7 @@ mod test_map {\n     fn test_mut_size_hint() {\n         let xs = [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6)];\n \n-        let mut map: HashMap<_, _>  = xs.iter().cloned().collect();\n+        let mut map: HashMap<_, _> = xs.iter().cloned().collect();\n \n         let mut iter = map.iter_mut();\n \n@@ -2719,7 +2799,7 @@ mod test_map {\n     fn test_iter_mut_len() {\n         let xs = [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6)];\n \n-        let mut map: HashMap<_, _>  = xs.iter().cloned().collect();\n+        let mut map: HashMap<_, _> = xs.iter().cloned().collect();\n \n         let mut iter = map.iter_mut();\n \n@@ -2752,7 +2832,7 @@ mod test_map {\n     }\n \n     #[test]\n-    fn test_entry(){\n+    fn test_entry() {\n         let xs = [(1, 10), (2, 20), (3, 30), (4, 40), (5, 50), (6, 60)];\n \n         let mut map: HashMap<_, _> = xs.iter().cloned().collect();\n@@ -2826,11 +2906,11 @@ mod test_map {\n         for i in 0..1000 {\n             let x = rng.gen_range(-10, 10);\n             match m.entry(x) {\n-                Vacant(_) => {},\n+                Vacant(_) => {}\n                 Occupied(e) => {\n                     println!(\"{}: remove {}\", i, x);\n                     e.remove();\n-                },\n+                }\n             }\n \n             check(&m);\n@@ -2908,7 +2988,7 @@ mod test_map {\n             Vacant(e) => {\n                 assert_eq!(key, *e.key());\n                 e.insert(value.clone());\n-            },\n+            }\n         }\n         assert_eq!(a.len(), 1);\n         assert_eq!(a[key], value);"}, {"sha": "7b3e52e03a14b40e4fa60d649ecf9b9a253e7d96", "filename": "src/libstd/collections/hash/set.rs", "status": "modified", "additions": 159, "deletions": 76, "changes": 235, "blob_url": "https://github.com/rust-lang/rust/blob/45f2b6abb54c121dc7f7b60c9c6692f54a0d2f5c/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45f2b6abb54c121dc7f7b60c9c6692f54a0d2f5c/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs?ref=45f2b6abb54c121dc7f7b60c9c6692f54a0d2f5c", "patch": "@@ -101,7 +101,7 @@ use super::map::{self, HashMap, Keys, RandomState};\n #[derive(Clone)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct HashSet<T, S = RandomState> {\n-    map: HashMap<T, (), S>\n+    map: HashMap<T, (), S>,\n }\n \n impl<T: Hash + Eq> HashSet<T, RandomState> {\n@@ -136,7 +136,8 @@ impl<T: Hash + Eq> HashSet<T, RandomState> {\n }\n \n impl<T, S> HashSet<T, S>\n-    where T: Eq + Hash, S: BuildHasher\n+    where T: Eq + Hash,\n+          S: BuildHasher\n {\n     /// Creates a new empty hash set which will use the given hasher to hash\n     /// keys.\n@@ -184,8 +185,7 @@ impl<T, S> HashSet<T, S>\n     /// ```\n     #[inline]\n     #[stable(feature = \"hashmap_build_hasher\", since = \"1.7.0\")]\n-    pub fn with_capacity_and_hasher(capacity: usize, hasher: S)\n-                                    -> HashSet<T, S> {\n+    pub fn with_capacity_and_hasher(capacity: usize, hasher: S) -> HashSet<T, S> {\n         HashSet { map: HashMap::with_capacity_and_hasher(capacity, hasher) }\n     }\n \n@@ -323,8 +323,9 @@ impl<T, S> HashSet<T, S>\n     /// assert_eq!(diff1, [1, 4].iter().cloned().collect());\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn symmetric_difference<'a>(&'a self, other: &'a HashSet<T, S>)\n-        -> SymmetricDifference<'a, T, S> {\n+    pub fn symmetric_difference<'a>(&'a self,\n+                                    other: &'a HashSet<T, S>)\n+                                    -> SymmetricDifference<'a, T, S> {\n         SymmetricDifference { iter: self.difference(other).chain(other.difference(self)) }\n     }\n \n@@ -388,7 +389,9 @@ impl<T, S> HashSet<T, S>\n     /// assert_eq!(v.len(), 1);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn len(&self) -> usize { self.map.len() }\n+    pub fn len(&self) -> usize {\n+        self.map.len()\n+    }\n \n     /// Returns true if the set contains no elements.\n     ///\n@@ -403,7 +406,9 @@ impl<T, S> HashSet<T, S>\n     /// assert!(!v.is_empty());\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn is_empty(&self) -> bool { self.map.is_empty() }\n+    pub fn is_empty(&self) -> bool {\n+        self.map.is_empty()\n+    }\n \n     /// Clears the set, returning all elements in an iterator.\n     #[inline]\n@@ -425,7 +430,9 @@ impl<T, S> HashSet<T, S>\n     /// assert!(v.is_empty());\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn clear(&mut self) { self.map.clear() }\n+    pub fn clear(&mut self) {\n+        self.map.clear()\n+    }\n \n     /// Returns `true` if the set contains a value.\n     ///\n@@ -444,7 +451,8 @@ impl<T, S> HashSet<T, S>\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn contains<Q: ?Sized>(&self, value: &Q) -> bool\n-        where T: Borrow<Q>, Q: Hash + Eq\n+        where T: Borrow<Q>,\n+              Q: Hash + Eq\n     {\n         self.map.contains_key(value)\n     }\n@@ -456,7 +464,8 @@ impl<T, S> HashSet<T, S>\n     /// the value type.\n     #[stable(feature = \"set_recovery\", since = \"1.9.0\")]\n     pub fn get<Q: ?Sized>(&self, value: &Q) -> Option<&T>\n-        where T: Borrow<Q>, Q: Hash + Eq\n+        where T: Borrow<Q>,\n+              Q: Hash + Eq\n     {\n         Recover::get(&self.map, value)\n     }\n@@ -547,7 +556,9 @@ impl<T, S> HashSet<T, S>\n     /// assert_eq!(set.len(), 1);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn insert(&mut self, value: T) -> bool { self.map.insert(value, ()).is_none() }\n+    pub fn insert(&mut self, value: T) -> bool {\n+        self.map.insert(value, ()).is_none()\n+    }\n \n     /// Adds a value to the set, replacing the existing value, if any, that is equal to the given\n     /// one. Returns the replaced value.\n@@ -576,7 +587,8 @@ impl<T, S> HashSet<T, S>\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn remove<Q: ?Sized>(&mut self, value: &Q) -> bool\n-        where T: Borrow<Q>, Q: Hash + Eq\n+        where T: Borrow<Q>,\n+              Q: Hash + Eq\n     {\n         self.map.remove(value).is_some()\n     }\n@@ -588,27 +600,33 @@ impl<T, S> HashSet<T, S>\n     /// the value type.\n     #[stable(feature = \"set_recovery\", since = \"1.9.0\")]\n     pub fn take<Q: ?Sized>(&mut self, value: &Q) -> Option<T>\n-        where T: Borrow<Q>, Q: Hash + Eq\n+        where T: Borrow<Q>,\n+              Q: Hash + Eq\n     {\n         Recover::take(&mut self.map, value)\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T, S> PartialEq for HashSet<T, S>\n-    where T: Eq + Hash, S: BuildHasher\n+    where T: Eq + Hash,\n+          S: BuildHasher\n {\n     fn eq(&self, other: &HashSet<T, S>) -> bool {\n-        if self.len() != other.len() { return false; }\n+        if self.len() != other.len() {\n+            return false;\n+        }\n \n         self.iter().all(|key| other.contains(key))\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T, S> Eq for HashSet<T, S>\n-    where T: Eq + Hash, S: BuildHasher\n-{}\n+    where T: Eq + Hash,\n+          S: BuildHasher\n+{\n+}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T, S> fmt::Debug for HashSet<T, S>\n@@ -623,9 +641,9 @@ impl<T, S> fmt::Debug for HashSet<T, S>\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T, S> FromIterator<T> for HashSet<T, S>\n     where T: Eq + Hash,\n-          S: BuildHasher + Default,\n+          S: BuildHasher + Default\n {\n-    fn from_iter<I: IntoIterator<Item=T>>(iter: I) -> HashSet<T, S> {\n+    fn from_iter<I: IntoIterator<Item = T>>(iter: I) -> HashSet<T, S> {\n         let iterator = iter.into_iter();\n         let lower = iterator.size_hint().0;\n         let mut set = HashSet::with_capacity_and_hasher(lower, Default::default());\n@@ -637,9 +655,9 @@ impl<T, S> FromIterator<T> for HashSet<T, S>\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T, S> Extend<T> for HashSet<T, S>\n     where T: Eq + Hash,\n-          S: BuildHasher,\n+          S: BuildHasher\n {\n-    fn extend<I: IntoIterator<Item=T>>(&mut self, iter: I) {\n+    fn extend<I: IntoIterator<Item = T>>(&mut self, iter: I) {\n         for k in iter {\n             self.insert(k);\n         }\n@@ -649,17 +667,17 @@ impl<T, S> Extend<T> for HashSet<T, S>\n #[stable(feature = \"hash_extend_copy\", since = \"1.4.0\")]\n impl<'a, T, S> Extend<&'a T> for HashSet<T, S>\n     where T: 'a + Eq + Hash + Copy,\n-          S: BuildHasher,\n+          S: BuildHasher\n {\n-    fn extend<I: IntoIterator<Item=&'a T>>(&mut self, iter: I) {\n+    fn extend<I: IntoIterator<Item = &'a T>>(&mut self, iter: I) {\n         self.extend(iter.into_iter().cloned());\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T, S> Default for HashSet<T, S>\n     where T: Eq + Hash,\n-          S: BuildHasher + Default,\n+          S: BuildHasher + Default\n {\n     /// Creates an empty `HashSet<T, S>` with the `Default` value for the hasher.\n     fn default() -> HashSet<T, S> {\n@@ -670,7 +688,7 @@ impl<T, S> Default for HashSet<T, S>\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, 'b, T, S> BitOr<&'b HashSet<T, S>> for &'a HashSet<T, S>\n     where T: Eq + Hash + Clone,\n-          S: BuildHasher + Default,\n+          S: BuildHasher + Default\n {\n     type Output = HashSet<T, S>;\n \n@@ -702,7 +720,7 @@ impl<'a, 'b, T, S> BitOr<&'b HashSet<T, S>> for &'a HashSet<T, S>\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, 'b, T, S> BitAnd<&'b HashSet<T, S>> for &'a HashSet<T, S>\n     where T: Eq + Hash + Clone,\n-          S: BuildHasher + Default,\n+          S: BuildHasher + Default\n {\n     type Output = HashSet<T, S>;\n \n@@ -734,7 +752,7 @@ impl<'a, 'b, T, S> BitAnd<&'b HashSet<T, S>> for &'a HashSet<T, S>\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, 'b, T, S> BitXor<&'b HashSet<T, S>> for &'a HashSet<T, S>\n     where T: Eq + Hash + Clone,\n-          S: BuildHasher + Default,\n+          S: BuildHasher + Default\n {\n     type Output = HashSet<T, S>;\n \n@@ -766,7 +784,7 @@ impl<'a, 'b, T, S> BitXor<&'b HashSet<T, S>> for &'a HashSet<T, S>\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, 'b, T, S> Sub<&'b HashSet<T, S>> for &'a HashSet<T, S>\n     where T: Eq + Hash + Clone,\n-          S: BuildHasher + Default,\n+          S: BuildHasher + Default\n {\n     type Output = HashSet<T, S>;\n \n@@ -798,13 +816,13 @@ impl<'a, 'b, T, S> Sub<&'b HashSet<T, S>> for &'a HashSet<T, S>\n /// HashSet iterator\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Iter<'a, K: 'a> {\n-    iter: Keys<'a, K, ()>\n+    iter: Keys<'a, K, ()>,\n }\n \n /// HashSet move iterator\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IntoIter<K> {\n-    iter: map::IntoIter<K, ()>\n+    iter: map::IntoIter<K, ()>,\n }\n \n /// HashSet drain iterator\n@@ -834,18 +852,19 @@ pub struct Difference<'a, T: 'a, S: 'a> {\n /// Symmetric difference iterator.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct SymmetricDifference<'a, T: 'a, S: 'a> {\n-    iter: Chain<Difference<'a, T, S>, Difference<'a, T, S>>\n+    iter: Chain<Difference<'a, T, S>, Difference<'a, T, S>>,\n }\n \n /// Set union iterator.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Union<'a, T: 'a, S: 'a> {\n-    iter: Chain<Iter<'a, T>, Difference<'a, T, S>>\n+    iter: Chain<Iter<'a, T>, Difference<'a, T, S>>,\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T, S> IntoIterator for &'a HashSet<T, S>\n-    where T: Eq + Hash, S: BuildHasher\n+    where T: Eq + Hash,\n+          S: BuildHasher\n {\n     type Item = &'a T;\n     type IntoIter = Iter<'a, T>;\n@@ -890,18 +909,26 @@ impl<T, S> IntoIterator for HashSet<T, S>\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K> Clone for Iter<'a, K> {\n-    fn clone(&self) -> Iter<'a, K> { Iter { iter: self.iter.clone() } }\n+    fn clone(&self) -> Iter<'a, K> {\n+        Iter { iter: self.iter.clone() }\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K> Iterator for Iter<'a, K> {\n     type Item = &'a K;\n \n-    fn next(&mut self) -> Option<&'a K> { self.iter.next() }\n-    fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n+    fn next(&mut self) -> Option<&'a K> {\n+        self.iter.next()\n+    }\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.iter.size_hint()\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K> ExactSizeIterator for Iter<'a, K> {\n-    fn len(&self) -> usize { self.iter.len() }\n+    fn len(&self) -> usize {\n+        self.iter.len()\n+    }\n }\n #[unstable(feature = \"fused\", issue = \"35602\")]\n impl<'a, K> FusedIterator for Iter<'a, K> {}\n@@ -910,12 +937,18 @@ impl<'a, K> FusedIterator for Iter<'a, K> {}\n impl<K> Iterator for IntoIter<K> {\n     type Item = K;\n \n-    fn next(&mut self) -> Option<K> { self.iter.next().map(|(k, _)| k) }\n-    fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n+    fn next(&mut self) -> Option<K> {\n+        self.iter.next().map(|(k, _)| k)\n+    }\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.iter.size_hint()\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K> ExactSizeIterator for IntoIter<K> {\n-    fn len(&self) -> usize { self.iter.len() }\n+    fn len(&self) -> usize {\n+        self.iter.len()\n+    }\n }\n #[unstable(feature = \"fused\", issue = \"35602\")]\n impl<K> FusedIterator for IntoIter<K> {}\n@@ -924,12 +957,18 @@ impl<K> FusedIterator for IntoIter<K> {}\n impl<'a, K> Iterator for Drain<'a, K> {\n     type Item = K;\n \n-    fn next(&mut self) -> Option<K> { self.iter.next().map(|(k, _)| k) }\n-    fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n+    fn next(&mut self) -> Option<K> {\n+        self.iter.next().map(|(k, _)| k)\n+    }\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.iter.size_hint()\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K> ExactSizeIterator for Drain<'a, K> {\n-    fn len(&self) -> usize { self.iter.len() }\n+    fn len(&self) -> usize {\n+        self.iter.len()\n+    }\n }\n #[unstable(feature = \"fused\", issue = \"35602\")]\n impl<'a, K> FusedIterator for Drain<'a, K> {}\n@@ -943,17 +982,20 @@ impl<'a, T, S> Clone for Intersection<'a, T, S> {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T, S> Iterator for Intersection<'a, T, S>\n-    where T: Eq + Hash, S: BuildHasher\n+    where T: Eq + Hash,\n+          S: BuildHasher\n {\n     type Item = &'a T;\n \n     fn next(&mut self) -> Option<&'a T> {\n         loop {\n             match self.iter.next() {\n                 None => return None,\n-                Some(elt) => if self.other.contains(elt) {\n-                    return Some(elt)\n-                },\n+                Some(elt) => {\n+                    if self.other.contains(elt) {\n+                        return Some(elt);\n+                    }\n+                }\n             }\n         }\n     }\n@@ -966,8 +1008,10 @@ impl<'a, T, S> Iterator for Intersection<'a, T, S>\n \n #[unstable(feature = \"fused\", issue = \"35602\")]\n impl<'a, T, S> FusedIterator for Intersection<'a, T, S>\n-    where T: Eq + Hash, S: BuildHasher\n-{}\n+    where T: Eq + Hash,\n+          S: BuildHasher\n+{\n+}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T, S> Clone for Difference<'a, T, S> {\n@@ -978,17 +1022,20 @@ impl<'a, T, S> Clone for Difference<'a, T, S> {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T, S> Iterator for Difference<'a, T, S>\n-    where T: Eq + Hash, S: BuildHasher\n+    where T: Eq + Hash,\n+          S: BuildHasher\n {\n     type Item = &'a T;\n \n     fn next(&mut self) -> Option<&'a T> {\n         loop {\n             match self.iter.next() {\n                 None => return None,\n-                Some(elt) => if !self.other.contains(elt) {\n-                    return Some(elt)\n-                },\n+                Some(elt) => {\n+                    if !self.other.contains(elt) {\n+                        return Some(elt);\n+                    }\n+                }\n             }\n         }\n     }\n@@ -1001,8 +1048,10 @@ impl<'a, T, S> Iterator for Difference<'a, T, S>\n \n #[unstable(feature = \"fused\", issue = \"35602\")]\n impl<'a, T, S> FusedIterator for Difference<'a, T, S>\n-    where T: Eq + Hash, S: BuildHasher\n-{}\n+    where T: Eq + Hash,\n+          S: BuildHasher\n+{\n+}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T, S> Clone for SymmetricDifference<'a, T, S> {\n@@ -1013,53 +1062,85 @@ impl<'a, T, S> Clone for SymmetricDifference<'a, T, S> {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T, S> Iterator for SymmetricDifference<'a, T, S>\n-    where T: Eq + Hash, S: BuildHasher\n+    where T: Eq + Hash,\n+          S: BuildHasher\n {\n     type Item = &'a T;\n \n-    fn next(&mut self) -> Option<&'a T> { self.iter.next() }\n-    fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n+    fn next(&mut self) -> Option<&'a T> {\n+        self.iter.next()\n+    }\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.iter.size_hint()\n+    }\n }\n \n #[unstable(feature = \"fused\", issue = \"35602\")]\n impl<'a, T, S> FusedIterator for SymmetricDifference<'a, T, S>\n-    where T: Eq + Hash, S: BuildHasher\n-{}\n+    where T: Eq + Hash,\n+          S: BuildHasher\n+{\n+}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T, S> Clone for Union<'a, T, S> {\n-    fn clone(&self) -> Union<'a, T, S> { Union { iter: self.iter.clone() } }\n+    fn clone(&self) -> Union<'a, T, S> {\n+        Union { iter: self.iter.clone() }\n+    }\n }\n \n #[unstable(feature = \"fused\", issue = \"35602\")]\n impl<'a, T, S> FusedIterator for Union<'a, T, S>\n-    where T: Eq + Hash, S: BuildHasher\n-{}\n+    where T: Eq + Hash,\n+          S: BuildHasher\n+{\n+}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T, S> Iterator for Union<'a, T, S>\n-    where T: Eq + Hash, S: BuildHasher\n+    where T: Eq + Hash,\n+          S: BuildHasher\n {\n     type Item = &'a T;\n \n-    fn next(&mut self) -> Option<&'a T> { self.iter.next() }\n-    fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n+    fn next(&mut self) -> Option<&'a T> {\n+        self.iter.next()\n+    }\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.iter.size_hint()\n+    }\n }\n \n #[allow(dead_code)]\n fn assert_covariance() {\n-    fn set<'new>(v: HashSet<&'static str>) -> HashSet<&'new str> { v }\n-    fn iter<'a, 'new>(v: Iter<'a, &'static str>) -> Iter<'a, &'new str> { v }\n-    fn into_iter<'new>(v: IntoIter<&'static str>) -> IntoIter<&'new str> { v }\n+    fn set<'new>(v: HashSet<&'static str>) -> HashSet<&'new str> {\n+        v\n+    }\n+    fn iter<'a, 'new>(v: Iter<'a, &'static str>) -> Iter<'a, &'new str> {\n+        v\n+    }\n+    fn into_iter<'new>(v: IntoIter<&'static str>) -> IntoIter<&'new str> {\n+        v\n+    }\n     fn difference<'a, 'new>(v: Difference<'a, &'static str, RandomState>)\n-        -> Difference<'a, &'new str, RandomState> { v }\n+                            -> Difference<'a, &'new str, RandomState> {\n+        v\n+    }\n     fn symmetric_difference<'a, 'new>(v: SymmetricDifference<'a, &'static str, RandomState>)\n-        -> SymmetricDifference<'a, &'new str, RandomState> { v }\n+                                      -> SymmetricDifference<'a, &'new str, RandomState> {\n+        v\n+    }\n     fn intersection<'a, 'new>(v: Intersection<'a, &'static str, RandomState>)\n-        -> Intersection<'a, &'new str, RandomState> { v }\n+                              -> Intersection<'a, &'new str, RandomState> {\n+        v\n+    }\n     fn union<'a, 'new>(v: Union<'a, &'static str, RandomState>)\n-        -> Union<'a, &'new str, RandomState> { v }\n-    fn drain<'new>(d: Drain<'static, &'static str>) -> Drain<'new, &'new str> { d }\n+                       -> Union<'a, &'new str, RandomState> {\n+        v\n+    }\n+    fn drain<'new>(d: Drain<'static, &'static str>) -> Drain<'new, &'new str> {\n+        d\n+    }\n }\n \n #[cfg(test)]\n@@ -1346,7 +1427,9 @@ mod test_set {\n                 assert_eq!(last_i, 49);\n             }\n \n-            for _ in &s { panic!(\"s should be empty!\"); }\n+            for _ in &s {\n+                panic!(\"s should be empty!\");\n+            }\n \n             // reset to try again.\n             s.extend(1..100);"}, {"sha": "0ba9ccf19becaf5030ac1b522ba75147c96a7e09", "filename": "src/libstd/collections/hash/table.rs", "status": "modified", "additions": 12, "deletions": 16, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/45f2b6abb54c121dc7f7b60c9c6692f54a0d2f5c/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45f2b6abb54c121dc7f7b60c9c6692f54a0d2f5c/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs?ref=45f2b6abb54c121dc7f7b60c9c6692f54a0d2f5c", "patch": "@@ -449,10 +449,10 @@ impl<'t, K, V> FullBucket<K, V, &'t mut RawTable<K, V>> {\n         unsafe {\n             *self.raw.hash = EMPTY_BUCKET;\n             (EmptyBucket {\n-                raw: self.raw,\n-                idx: self.idx,\n-                table: self.table,\n-            },\n+                 raw: self.raw,\n+                 idx: self.idx,\n+                 table: self.table,\n+             },\n              ptr::read(self.raw.key),\n              ptr::read(self.raw.val))\n         }\n@@ -644,13 +644,13 @@ impl<K, V> RawTable<K, V> {\n \n         // One check for overflow that covers calculation and rounding of size.\n         let size_of_bucket = size_of::<u64>()\n-                                 .checked_add(size_of::<K>())\n-                                 .unwrap()\n-                                 .checked_add(size_of::<V>())\n-                                 .unwrap();\n+            .checked_add(size_of::<K>())\n+            .unwrap()\n+            .checked_add(size_of::<V>())\n+            .unwrap();\n         assert!(size >=\n                 capacity.checked_mul(size_of_bucket)\n-                        .expect(\"capacity overflow\"),\n+                    .expect(\"capacity overflow\"),\n                 \"capacity overflow\");\n \n         let buffer = allocate(size, malloc_alignment);\n@@ -673,10 +673,8 @@ impl<K, V> RawTable<K, V> {\n         let keys_size = self.capacity * size_of::<K>();\n \n         let buffer = *self.hashes as *const u8;\n-        let (keys_offset, vals_offset, oflo) = calculate_offsets(hashes_size,\n-                                                                 keys_size,\n-                                                                 align_of::<K>(),\n-                                                                 align_of::<V>());\n+        let (keys_offset, vals_offset, oflo) =\n+            calculate_offsets(hashes_size, keys_size, align_of::<K>(), align_of::<V>());\n         debug_assert!(!oflo, \"capacity overflow\");\n         unsafe {\n             RawBucket {\n@@ -991,9 +989,7 @@ impl<'a, K, V> Iterator for Drain<'a, K, V> {\n }\n impl<'a, K, V> ExactSizeIterator for Drain<'a, K, V> {\n     fn len(&self) -> usize {\n-        unsafe {\n-            (**self.table).size()\n-        }\n+        unsafe { (**self.table).size() }\n     }\n }\n "}]}