{"sha": "ed7c30b8885afb7e0bf26072dcb7e39658baade0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVkN2MzMGI4ODg1YWZiN2UwYmYyNjA3MmRjYjdlMzk2NThiYWFkZTA=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-03-24T10:12:19Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-03-24T10:23:59Z"}, "message": "rework MIR visitor\n\nWe now visit more things (e.g., types) and also follow a deliberate\nstyle designed to reduce omissions.", "tree": {"sha": "c4d2c1c9b1cfc4e5532e3535547bc493555e3edd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c4d2c1c9b1cfc4e5532e3535547bc493555e3edd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ed7c30b8885afb7e0bf26072dcb7e39658baade0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ed7c30b8885afb7e0bf26072dcb7e39658baade0", "html_url": "https://github.com/rust-lang/rust/commit/ed7c30b8885afb7e0bf26072dcb7e39658baade0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ed7c30b8885afb7e0bf26072dcb7e39658baade0/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0769865f7f42d0c52b35552fe8d17e651d32772a", "url": "https://api.github.com/repos/rust-lang/rust/commits/0769865f7f42d0c52b35552fe8d17e651d32772a", "html_url": "https://github.com/rust-lang/rust/commit/0769865f7f42d0c52b35552fe8d17e651d32772a"}], "stats": {"total": 408, "additions": 382, "deletions": 26}, "files": [{"sha": "47d923cbce359998d7605a4a34d0469c19340211", "filename": "src/librustc/mir/repr.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ed7c30b8885afb7e0bf26072dcb7e39658baade0/src%2Flibrustc%2Fmir%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed7c30b8885afb7e0bf26072dcb7e39658baade0/src%2Flibrustc%2Fmir%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Frepr.rs?ref=ed7c30b8885afb7e0bf26072dcb7e39658baade0", "patch": "@@ -233,8 +233,23 @@ impl Debug for BasicBlock {\n \n #[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n pub struct BasicBlockData<'tcx> {\n+    /// List of statements in this block.\n     pub statements: Vec<Statement<'tcx>>,\n+\n+    /// Terminator for this block.\n+    ///\n+    /// NB. This should generally ONLY be `None` during construction.\n+    /// Therefore, you should generally access it via the\n+    /// `terminator()` or `terminator_mut()` methods. The only\n+    /// exception is that certain passes, such as `simplify_cfg`, swap\n+    /// out the terminator temporarily with `None` while they continue\n+    /// to recurse over the set of basic blocks.\n     pub terminator: Option<Terminator<'tcx>>,\n+\n+    /// If true, this block lies on an unwind path. This is used\n+    /// during trans where distinct kinds of basic blocks may be\n+    /// generated (particularly for MSVC cleanup). Unwind blocks must\n+    /// only branch to other unwind blocks.\n     pub is_cleanup: bool,\n }\n "}, {"sha": "5be2e06841477925b949bded49872d91b882ec9b", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 367, "deletions": 26, "changes": 393, "blob_url": "https://github.com/rust-lang/rust/blob/ed7c30b8885afb7e0bf26072dcb7e39658baade0/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed7c30b8885afb7e0bf26072dcb7e39658baade0/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=ed7c30b8885afb7e0bf26072dcb7e39658baade0", "patch": "@@ -8,12 +8,79 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use middle::const_eval::ConstVal;\n use middle::def_id::DefId;\n-use middle::ty::Region;\n+use middle::subst::Substs;\n+use middle::ty::{ClosureSubsts, FnOutput, Region, Ty};\n use mir::repr::*;\n+use rustc_const_eval::ConstUsize;\n use rustc_data_structures::tuple_slice::TupleSlice;\n use syntax::codemap::Span;\n \n+// # The MIR Visitor\n+//\n+// ## Overview\n+//\n+// There are two visitors, one for immutable and one for mutable references,\n+// but both are generated by the following macro. The code is written according\n+// to the following conventions:\n+//\n+// - introduce a `visit_foo` and a `super_foo` method for every MIR type\n+// - `visit_foo`, by default, calls `super_foo`\n+// - `super_foo`, by default, destructures the `foo` and calls `visit_foo`\n+//\n+// This allows you as a user to override `visit_foo` for types are\n+// interested in, and invoke (within that method) call\n+// `self.super_foo` to get the default behavior. Just as in an OO\n+// language, you should never call `super` methods ordinarily except\n+// in that circumstance.\n+//\n+// For the most part, we do not destructure things external to the\n+// MIR, e.g. types, spans, etc, but simply visit them and stop. This\n+// avoids duplication with other visitors like `TypeFoldable`. But\n+// there is one exception: we do destructure the `FnOutput` to reach\n+// the type within. Just because.\n+//\n+// ## Updating\n+//\n+// The code is written in a very deliberate style intended to minimize\n+// the chance of things being overlooked. You'll notice that we always\n+// use pattern matching to reference fields and we ensure that all\n+// matches are exhaustive.\n+//\n+// For example, the `super_basic_block_data` method begins like this:\n+//\n+// ```rust\n+// fn super_basic_block_data(&mut self,\n+//                           block: BasicBlock,\n+//                           data: & $($mutability)* BasicBlockData<'tcx>) {\n+//     let BasicBlockData {\n+//         ref $($mutability)* statements,\n+//         ref $($mutability)* terminator,\n+//         is_cleanup: _\n+//     } = *data;\n+//\n+//     for statement in statements {\n+//         self.visit_statement(block, statement);\n+//     }\n+//\n+//     ...\n+// }\n+// ```\n+//\n+// Here we used `let BasicBlockData { <fields> } = *data` deliberately,\n+// rather than writing `data.statements` in the body. This is because if one\n+// adds a new field to `BasicBlockData`, one will be forced to revise this code,\n+// and hence one will (hopefully) invoke the correct visit methods (if any).\n+//\n+// For this to work, ALL MATCHES MUST BE EXHAUSTIVE IN FIELDS AND VARIANTS.\n+// That means you never write `..` to skip over fields, nor do you write `_`\n+// to skip over variants in a `match`.\n+//\n+// The only place that `_` is acceptable is to match a field (or\n+// variant argument) that does not require visiting, as in\n+// `is_cleanup` above.\n+\n macro_rules! make_mir_visitor {\n     ($visitor_trait_name:ident, $($mutability:ident)*) => {\n         pub trait $visitor_trait_name<'tcx> {\n@@ -30,6 +97,11 @@ macro_rules! make_mir_visitor {\n                 self.super_basic_block_data(block, data);\n             }\n \n+            fn visit_scope_data(&mut self,\n+                                scope_data: & $($mutability)* ScopeData) {\n+                self.super_scope_data(scope_data);\n+            }\n+\n             fn visit_statement(&mut self,\n                                block: BasicBlock,\n                                statement: & $($mutability)* Statement<'tcx>) {\n@@ -49,6 +121,12 @@ macro_rules! make_mir_visitor {\n                 self.super_terminator(block, terminator);\n             }\n \n+            fn visit_terminator_kind(&mut self,\n+                                     block: BasicBlock,\n+                                     kind: & $($mutability)* TerminatorKind<'tcx>) {\n+                self.super_terminator_kind(block, kind);\n+            }\n+\n             fn visit_rvalue(&mut self,\n                             rvalue: & $($mutability)* Rvalue<'tcx>) {\n                 self.super_rvalue(rvalue);\n@@ -65,6 +143,18 @@ macro_rules! make_mir_visitor {\n                 self.super_lvalue(lvalue, context);\n             }\n \n+            fn visit_projection(&mut self,\n+                                lvalue: & $($mutability)* LvalueProjection<'tcx>,\n+                                context: LvalueContext) {\n+                self.super_projection(lvalue, context);\n+            }\n+\n+            fn visit_projection_elem(&mut self,\n+                                     lvalue: & $($mutability)* LvalueElem<'tcx>,\n+                                     context: LvalueContext) {\n+                self.super_projection_elem(lvalue, context);\n+            }\n+\n             fn visit_branch(&mut self,\n                             source: BasicBlock,\n                             target: BasicBlock) {\n@@ -91,35 +181,143 @@ macro_rules! make_mir_visitor {\n                 self.super_span(span);\n             }\n \n+            fn visit_fn_output(&mut self,\n+                               fn_output: & $($mutability)* FnOutput<'tcx>) {\n+                self.super_fn_output(fn_output);\n+            }\n+\n+            fn visit_ty(&mut self,\n+                        ty: & $($mutability)* Ty<'tcx>) {\n+                self.super_ty(ty);\n+            }\n+\n+            fn visit_substs(&mut self,\n+                            substs: & $($mutability)* &'tcx Substs<'tcx>) {\n+                self.super_substs(substs);\n+            }\n+\n+            fn visit_closure_substs(&mut self,\n+                                    substs: & $($mutability)* &'tcx ClosureSubsts<'tcx>) {\n+                self.super_closure_substs(substs);\n+            }\n+\n+            fn visit_const_val(&mut self,\n+                               const_val: & $($mutability)* ConstVal) {\n+                self.super_const_val(const_val);\n+            }\n+\n+            fn visit_const_usize(&mut self,\n+                                 const_usize: & $($mutability)* ConstUsize) {\n+                self.super_const_usize(const_usize);\n+            }\n+\n+            fn visit_typed_const_val(&mut self,\n+                                     val: & $($mutability)* TypedConstVal<'tcx>) {\n+                self.super_typed_const_val(val);\n+            }\n+\n+            fn visit_var_decl(&mut self,\n+                              var_decl: & $($mutability)* VarDecl<'tcx>) {\n+                self.super_var_decl(var_decl);\n+            }\n+\n+            fn visit_temp_decl(&mut self,\n+                               temp_decl: & $($mutability)* TempDecl<'tcx>) {\n+                self.super_temp_decl(temp_decl);\n+            }\n+\n+            fn visit_arg_decl(&mut self,\n+                              arg_decl: & $($mutability)* ArgDecl<'tcx>) {\n+                self.super_arg_decl(arg_decl);\n+            }\n+\n+            fn visit_scope_id(&mut self,\n+                              scope_id: & $($mutability)* ScopeId) {\n+                self.super_scope_id(scope_id);\n+            }\n+\n             // The `super_xxx` methods comprise the default behavior and are\n             // not meant to be overridden.\n \n             fn super_mir(&mut self,\n                          mir: & $($mutability)* Mir<'tcx>) {\n-                for block in mir.all_basic_blocks() {\n-                    let data = & $($mutability)* mir[block];\n+                let Mir {\n+                    ref $($mutability)* basic_blocks,\n+                    ref $($mutability)* scopes,\n+                    ref $($mutability)* return_ty,\n+                    ref $($mutability)* var_decls,\n+                    ref $($mutability)* arg_decls,\n+                    ref $($mutability)* temp_decls,\n+                    ref $($mutability)* span,\n+                } = *mir;\n+\n+                for (index, data) in basic_blocks.into_iter().enumerate() {\n+                    let block = BasicBlock::new(index);\n                     self.visit_basic_block_data(block, data);\n                 }\n+\n+                for scope in scopes {\n+                    self.visit_scope_data(scope);\n+                }\n+\n+                self.visit_fn_output(return_ty);\n+\n+                for var_decl in var_decls {\n+                    self.visit_var_decl(var_decl);\n+                }\n+\n+                for arg_decl in arg_decls {\n+                    self.visit_arg_decl(arg_decl);\n+                }\n+\n+                for temp_decl in temp_decls {\n+                    self.visit_temp_decl(temp_decl);\n+                }\n+\n+                self.visit_span(span);\n             }\n \n             fn super_basic_block_data(&mut self,\n                                       block: BasicBlock,\n                                       data: & $($mutability)* BasicBlockData<'tcx>) {\n-                for statement in & $($mutability)* data.statements {\n+                let BasicBlockData {\n+                    ref $($mutability)* statements,\n+                    ref $($mutability)* terminator,\n+                    is_cleanup: _\n+                } = *data;\n+\n+                for statement in statements {\n                     self.visit_statement(block, statement);\n                 }\n \n-                if let Some(ref $($mutability)* terminator) = data.terminator {\n+                if let Some(ref $($mutability)* terminator) = *terminator {\n                     self.visit_terminator(block, terminator);\n                 }\n             }\n \n+            fn super_scope_data(&mut self,\n+                                scope_data: & $($mutability)* ScopeData) {\n+                let ScopeData {\n+                    ref $($mutability)* parent_scope,\n+                } = *scope_data;\n+\n+                if let Some(ref $($mutability)* parent_scope) = *parent_scope {\n+                    self.visit_scope_id(parent_scope);\n+                }\n+            }\n+\n             fn super_statement(&mut self,\n                                block: BasicBlock,\n                                statement: & $($mutability)* Statement<'tcx>) {\n-                self.visit_span(& $($mutability)* statement.span);\n-\n-                match statement.kind {\n+                let Statement {\n+                    ref $($mutability)* span,\n+                    ref $($mutability)* scope,\n+                    ref $($mutability)* kind,\n+                } = *statement;\n+\n+                self.visit_span(span);\n+                self.visit_scope_id(scope);\n+                match *kind {\n                     StatementKind::Assign(ref $($mutability)* lvalue,\n                                           ref $($mutability)* rvalue) => {\n                         self.visit_assign(block, lvalue, rvalue);\n@@ -138,7 +336,21 @@ macro_rules! make_mir_visitor {\n             fn super_terminator(&mut self,\n                                 block: BasicBlock,\n                                 terminator: &$($mutability)* Terminator<'tcx>) {\n-                match terminator.kind {\n+                let Terminator {\n+                    ref $($mutability)* span,\n+                    ref $($mutability)* scope,\n+                    ref $($mutability)* kind,\n+                } = *terminator;\n+\n+                self.visit_span(span);\n+                self.visit_scope_id(scope);\n+                self.visit_terminator_kind(block, kind);\n+            }\n+\n+            fn super_terminator_kind(&mut self,\n+                                     block: BasicBlock,\n+                                     kind: & $($mutability)* TerminatorKind<'tcx>) {\n+                match *kind {\n                     TerminatorKind::Goto { target } => {\n                         self.visit_branch(block, target);\n                     }\n@@ -161,10 +373,14 @@ macro_rules! make_mir_visitor {\n                     }\n \n                     TerminatorKind::SwitchInt { ref $($mutability)* discr,\n-                                                switch_ty: _,\n-                                                values: _,\n+                                                ref $($mutability)* switch_ty,\n+                                                ref $($mutability)* values,\n                                                 ref targets } => {\n                         self.visit_lvalue(discr, LvalueContext::Inspect);\n+                        self.visit_ty(switch_ty);\n+                        for value in values {\n+                            self.visit_const_val(value);\n+                        }\n                         for &target in targets {\n                             self.visit_branch(block, target);\n                         }\n@@ -207,8 +423,9 @@ macro_rules! make_mir_visitor {\n                     }\n \n                     Rvalue::Repeat(ref $($mutability)* value,\n-                                   _) => {\n+                                   ref $($mutability)* typed_const_val) => {\n                         self.visit_operand(value);\n+                        self.visit_typed_const_val(typed_const_val);\n                     }\n \n                     Rvalue::Ref(r, bk, ref $($mutability)* path) => {\n@@ -222,34 +439,48 @@ macro_rules! make_mir_visitor {\n                         self.visit_lvalue(path, LvalueContext::Inspect);\n                     }\n \n-                    Rvalue::Cast(_, ref $($mutability)* operand, _) => {\n+                    Rvalue::Cast(_cast_kind,\n+                                 ref $($mutability)* operand,\n+                                 ref $($mutability)* ty) => {\n                         self.visit_operand(operand);\n+                        self.visit_ty(ty);\n                     }\n \n-                    Rvalue::BinaryOp(_,\n+                    Rvalue::BinaryOp(_bin_op,\n                                      ref $($mutability)* lhs,\n                                      ref $($mutability)* rhs) => {\n                         self.visit_operand(lhs);\n                         self.visit_operand(rhs);\n                     }\n \n-                    Rvalue::UnaryOp(_, ref $($mutability)* op) => {\n+                    Rvalue::UnaryOp(_un_op, ref $($mutability)* op) => {\n                         self.visit_operand(op);\n                     }\n \n-                    Rvalue::Box(_) => {\n+                    Rvalue::Box(ref $($mutability)* ty) => {\n+                        self.visit_ty(ty);\n                     }\n \n                     Rvalue::Aggregate(ref $($mutability)* kind,\n                                       ref $($mutability)* operands) => {\n                         match *kind {\n-                            AggregateKind::Closure(ref $($mutability)* def_id, _) => {\n+                            AggregateKind::Vec => {\n+                            }\n+                            AggregateKind::Tuple => {\n+                            }\n+                            AggregateKind::Adt(_adt_def,\n+                                               _variant_index,\n+                                               ref $($mutability)* substs) => {\n+                                self.visit_substs(substs);\n+                            }\n+                            AggregateKind::Closure(ref $($mutability)* def_id,\n+                                                   ref $($mutability)* closure_substs) => {\n                                 self.visit_def_id(def_id);\n+                                self.visit_closure_substs(closure_substs);\n                             }\n-                            _ => { /* nothing to do */ }\n                         }\n \n-                        for operand in & $($mutability)* operands[..] {\n+                        for operand in operands {\n                             self.visit_operand(operand);\n                         }\n                     }\n@@ -264,7 +495,8 @@ macro_rules! make_mir_visitor {\n                     }\n \n                     Rvalue::InlineAsm { ref $($mutability)* outputs,\n-                                        ref $($mutability)* inputs, .. } => {\n+                                        ref $($mutability)* inputs,\n+                                        asm: _ } => {\n                         for output in & $($mutability)* outputs[..] {\n                             self.visit_lvalue(output, LvalueContext::Store);\n                         }\n@@ -289,7 +521,7 @@ macro_rules! make_mir_visitor {\n \n             fn super_lvalue(&mut self,\n                             lvalue: & $($mutability)* Lvalue<'tcx>,\n-                            _context: LvalueContext) {\n+                            context: LvalueContext) {\n                 match *lvalue {\n                     Lvalue::Var(_) |\n                     Lvalue::Temp(_) |\n@@ -300,12 +532,81 @@ macro_rules! make_mir_visitor {\n                         self.visit_def_id(def_id);\n                     }\n                     Lvalue::Projection(ref $($mutability)* proj) => {\n-                        self.visit_lvalue(& $($mutability)* proj.base,\n-                                          LvalueContext::Projection);\n+                        self.visit_projection(proj, context);\n                     }\n                 }\n             }\n \n+            fn super_projection(&mut self,\n+                                proj: & $($mutability)* LvalueProjection<'tcx>,\n+                                context: LvalueContext) {\n+                let Projection {\n+                    ref $($mutability)* base,\n+                    ref $($mutability)* elem,\n+                } = *proj;\n+                self.visit_lvalue(base, LvalueContext::Projection);\n+                self.visit_projection_elem(elem, context);\n+            }\n+\n+            fn super_projection_elem(&mut self,\n+                                     proj: & $($mutability)* LvalueElem<'tcx>,\n+                                     _context: LvalueContext) {\n+                match *proj {\n+                    ProjectionElem::Deref => {\n+                    }\n+                    ProjectionElem::Field(_field, ref $($mutability)* ty) => {\n+                        self.visit_ty(ty);\n+                    }\n+                    ProjectionElem::Index(ref $($mutability)* operand) => {\n+                        self.visit_operand(operand);\n+                    }\n+                    ProjectionElem::ConstantIndex { offset: _,\n+                                                    min_length: _,\n+                                                    from_end: _ } => {\n+                    }\n+                    ProjectionElem::Downcast(_adt_def, _variant_index) => {\n+                    }\n+                }\n+            }\n+\n+            fn super_var_decl(&mut self,\n+                              var_decl: & $($mutability)* VarDecl<'tcx>) {\n+                let VarDecl {\n+                    mutability: _,\n+                    name: _,\n+                    ref $($mutability)* ty,\n+                    ref $($mutability)* scope,\n+                    ref $($mutability)* span,\n+                } = *var_decl;\n+\n+                self.visit_ty(ty);\n+                self.visit_scope_id(scope);\n+                self.visit_span(span);\n+            }\n+\n+            fn super_temp_decl(&mut self,\n+                               temp_decl: & $($mutability)* TempDecl<'tcx>) {\n+                let TempDecl {\n+                    ref $($mutability)* ty,\n+                } = *temp_decl;\n+\n+                self.visit_ty(ty);\n+            }\n+\n+            fn super_arg_decl(&mut self,\n+                              arg_decl: & $($mutability)* ArgDecl<'tcx>) {\n+                let ArgDecl {\n+                    ref $($mutability)* ty,\n+                    spread: _\n+                } = *arg_decl;\n+\n+                self.visit_ty(ty);\n+            }\n+\n+            fn super_scope_id(&mut self,\n+                              _scope_id: & $($mutability)* ScopeId) {\n+            }\n+\n             fn super_branch(&mut self,\n                             _source: BasicBlock,\n                             _target: BasicBlock) {\n@@ -314,17 +615,32 @@ macro_rules! make_mir_visitor {\n             fn super_constant(&mut self,\n                               constant: & $($mutability)* Constant<'tcx>) {\n                 self.visit_span(& $($mutability)* constant.span);\n+                self.visit_ty(& $($mutability)* constant.ty);\n                 self.visit_literal(& $($mutability)* constant.literal);\n             }\n \n+            fn super_typed_const_val(&mut self,\n+                                     constant: & $($mutability)* TypedConstVal<'tcx>) {\n+                let TypedConstVal {\n+                    ref $($mutability)* span,\n+                    ref $($mutability)* ty,\n+                    ref $($mutability)* value,\n+                } = *constant;\n+                self.visit_span(span);\n+                self.visit_ty(ty);\n+                self.visit_const_usize(value);\n+            }\n+\n             fn super_literal(&mut self,\n                              literal: & $($mutability)* Literal<'tcx>) {\n                 match *literal {\n-                    Literal::Item { ref $($mutability)* def_id, .. } => {\n+                    Literal::Item { ref $($mutability)* def_id,\n+                                    ref $($mutability)* substs } => {\n                         self.visit_def_id(def_id);\n+                        self.visit_substs(substs);\n                     },\n-                    Literal::Value { .. } => {\n-                        // Nothing to do\n+                    Literal::Value { ref $($mutability)* value } => {\n+                        self.visit_const_val(value);\n                     }\n                 }\n             }\n@@ -334,6 +650,31 @@ macro_rules! make_mir_visitor {\n \n             fn super_span(&mut self, _span: & $($mutability)* Span) {\n             }\n+\n+            fn super_fn_output(&mut self, fn_output: & $($mutability)* FnOutput<'tcx>) {\n+                match *fn_output {\n+                    FnOutput::FnConverging(ref $($mutability)* ty) => {\n+                        self.visit_ty(ty);\n+                    }\n+                    FnOutput::FnDiverging => {\n+                    }\n+                }\n+            }\n+\n+            fn super_ty(&mut self, _ty: & $($mutability)* Ty<'tcx>) {\n+            }\n+\n+            fn super_substs(&mut self, _substs: & $($mutability)* &'tcx Substs<'tcx>) {\n+            }\n+\n+            fn super_closure_substs(&mut self, _substs: & $($mutability)* &'tcx ClosureSubsts<'tcx>) {\n+            }\n+\n+            fn super_const_val(&mut self, _substs: & $($mutability)* ConstVal) {\n+            }\n+\n+            fn super_const_usize(&mut self, _substs: & $($mutability)* ConstUsize) {\n+            }\n         }\n     }\n }"}]}