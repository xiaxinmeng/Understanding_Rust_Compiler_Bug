{"sha": "4e42f388c375b0d6eb25af087cb2a66069419529", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRlNDJmMzg4YzM3NWIwZDZlYjI1YWYwODdjYjJhNjYwNjk0MTk1Mjk=", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2020-01-22T08:04:50Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2020-02-05T07:45:09Z"}, "message": "Move traits::query datatypes to traits::types.", "tree": {"sha": "17310d17aeefd2e79569b11c6c117fad165f7168", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/17310d17aeefd2e79569b11c6c117fad165f7168"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4e42f388c375b0d6eb25af087cb2a66069419529", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4e42f388c375b0d6eb25af087cb2a66069419529", "html_url": "https://github.com/rust-lang/rust/commit/4e42f388c375b0d6eb25af087cb2a66069419529", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4e42f388c375b0d6eb25af087cb2a66069419529/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a77da35ed425b46a8df1df33ffc9563a47bbee6f", "url": "https://api.github.com/repos/rust-lang/rust/commits/a77da35ed425b46a8df1df33ffc9563a47bbee6f", "html_url": "https://github.com/rust-lang/rust/commit/a77da35ed425b46a8df1df33ffc9563a47bbee6f"}], "stats": {"total": 602, "additions": 353, "deletions": 249}, "files": [{"sha": "a1d7a2836e42d3c032f5a165bea61a95e2b2c6d7", "filename": "src/librustc/traits/query/dropck_outlives.rs", "status": "modified", "additions": 5, "deletions": 74, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/4e42f388c375b0d6eb25af087cb2a66069419529/src%2Flibrustc%2Ftraits%2Fquery%2Fdropck_outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e42f388c375b0d6eb25af087cb2a66069419529/src%2Flibrustc%2Ftraits%2Fquery%2Fdropck_outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fdropck_outlives.rs?ref=4e42f388c375b0d6eb25af087cb2a66069419529", "patch": "@@ -1,10 +1,11 @@\n use crate::infer::at::At;\n use crate::infer::canonical::OriginalQueryValues;\n use crate::infer::InferOk;\n-use crate::ty::subst::GenericArg;\n-use crate::ty::{self, Ty, TyCtxt};\n-use rustc_span::source_map::Span;\n-use std::iter::FromIterator;\n+\n+use rustc::ty::subst::GenericArg;\n+use rustc::ty::{self, Ty, TyCtxt};\n+\n+pub use rustc::traits::query::{DropckOutlivesResult, DtorckConstraint};\n \n impl<'cx, 'tcx> At<'cx, 'tcx> {\n     /// Given a type `ty` of some value being dropped, computes a set\n@@ -65,76 +66,6 @@ impl<'cx, 'tcx> At<'cx, 'tcx> {\n     }\n }\n \n-#[derive(Clone, Debug, Default, HashStable, TypeFoldable, Lift)]\n-pub struct DropckOutlivesResult<'tcx> {\n-    pub kinds: Vec<GenericArg<'tcx>>,\n-    pub overflows: Vec<Ty<'tcx>>,\n-}\n-\n-impl<'tcx> DropckOutlivesResult<'tcx> {\n-    pub fn report_overflows(&self, tcx: TyCtxt<'tcx>, span: Span, ty: Ty<'tcx>) {\n-        if let Some(overflow_ty) = self.overflows.iter().next() {\n-            rustc_errors::struct_span_err!(\n-                tcx.sess,\n-                span,\n-                E0320,\n-                \"overflow while adding drop-check rules for {}\",\n-                ty,\n-            )\n-            .note(&format!(\"overflowed on {}\", overflow_ty))\n-            .emit();\n-        }\n-    }\n-\n-    pub fn into_kinds_reporting_overflows(\n-        self,\n-        tcx: TyCtxt<'tcx>,\n-        span: Span,\n-        ty: Ty<'tcx>,\n-    ) -> Vec<GenericArg<'tcx>> {\n-        self.report_overflows(tcx, span, ty);\n-        let DropckOutlivesResult { kinds, overflows: _ } = self;\n-        kinds\n-    }\n-}\n-\n-/// A set of constraints that need to be satisfied in order for\n-/// a type to be valid for destruction.\n-#[derive(Clone, Debug, HashStable)]\n-pub struct DtorckConstraint<'tcx> {\n-    /// Types that are required to be alive in order for this\n-    /// type to be valid for destruction.\n-    pub outlives: Vec<ty::subst::GenericArg<'tcx>>,\n-\n-    /// Types that could not be resolved: projections and params.\n-    pub dtorck_types: Vec<Ty<'tcx>>,\n-\n-    /// If, during the computation of the dtorck constraint, we\n-    /// overflow, that gets recorded here. The caller is expected to\n-    /// report an error.\n-    pub overflows: Vec<Ty<'tcx>>,\n-}\n-\n-impl<'tcx> DtorckConstraint<'tcx> {\n-    pub fn empty() -> DtorckConstraint<'tcx> {\n-        DtorckConstraint { outlives: vec![], dtorck_types: vec![], overflows: vec![] }\n-    }\n-}\n-\n-impl<'tcx> FromIterator<DtorckConstraint<'tcx>> for DtorckConstraint<'tcx> {\n-    fn from_iter<I: IntoIterator<Item = DtorckConstraint<'tcx>>>(iter: I) -> Self {\n-        let mut result = Self::empty();\n-\n-        for DtorckConstraint { outlives, dtorck_types, overflows } in iter {\n-            result.outlives.extend(outlives);\n-            result.dtorck_types.extend(dtorck_types);\n-            result.overflows.extend(overflows);\n-        }\n-\n-        result\n-    }\n-}\n-\n /// This returns true if the type `ty` is \"trivial\" for\n /// dropck-outlives -- that is, if it doesn't require any types to\n /// outlive. This is similar but not *quite* the same as the"}, {"sha": "80748c5ef388efe15f3109b5f6990e9e6517896c", "filename": "src/librustc/traits/query/method_autoderef.rs", "status": "modified", "additions": 1, "deletions": 33, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/4e42f388c375b0d6eb25af087cb2a66069419529/src%2Flibrustc%2Ftraits%2Fquery%2Fmethod_autoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e42f388c375b0d6eb25af087cb2a66069419529/src%2Flibrustc%2Ftraits%2Fquery%2Fmethod_autoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fmethod_autoderef.rs?ref=4e42f388c375b0d6eb25af087cb2a66069419529", "patch": "@@ -1,33 +1 @@\n-use crate::infer::canonical::{Canonical, QueryResponse};\n-use crate::ty::Ty;\n-use rustc_data_structures::sync::Lrc;\n-\n-#[derive(Debug, HashStable)]\n-pub struct CandidateStep<'tcx> {\n-    pub self_ty: Canonical<'tcx, QueryResponse<'tcx, Ty<'tcx>>>,\n-    pub autoderefs: usize,\n-    /// `true` if the type results from a dereference of a raw pointer.\n-    /// when assembling candidates, we include these steps, but not when\n-    /// picking methods. This so that if we have `foo: *const Foo` and `Foo` has methods\n-    /// `fn by_raw_ptr(self: *const Self)` and `fn by_ref(&self)`, then\n-    /// `foo.by_raw_ptr()` will work and `foo.by_ref()` won't.\n-    pub from_unsafe_deref: bool,\n-    pub unsize: bool,\n-}\n-\n-#[derive(Clone, Debug, HashStable)]\n-pub struct MethodAutoderefStepsResult<'tcx> {\n-    /// The valid autoderef steps that could be find.\n-    pub steps: Lrc<Vec<CandidateStep<'tcx>>>,\n-    /// If Some(T), a type autoderef reported an error on.\n-    pub opt_bad_ty: Option<Lrc<MethodAutoderefBadTy<'tcx>>>,\n-    /// If `true`, `steps` has been truncated due to reaching the\n-    /// recursion limit.\n-    pub reached_recursion_limit: bool,\n-}\n-\n-#[derive(Debug, HashStable)]\n-pub struct MethodAutoderefBadTy<'tcx> {\n-    pub reached_raw_pointer: bool,\n-    pub ty: Canonical<'tcx, QueryResponse<'tcx, Ty<'tcx>>>,\n-}\n+pub use rustc::traits::query::{CandidateStep, MethodAutoderefBadTy, MethodAutoderefStepsResult};"}, {"sha": "20a873dc4c6b6692e69730db871580fb0be8ef3f", "filename": "src/librustc/traits/query/mod.rs", "status": "modified", "additions": 1, "deletions": 36, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/4e42f388c375b0d6eb25af087cb2a66069419529/src%2Flibrustc%2Ftraits%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e42f388c375b0d6eb25af087cb2a66069419529/src%2Flibrustc%2Ftraits%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fmod.rs?ref=4e42f388c375b0d6eb25af087cb2a66069419529", "patch": "@@ -5,46 +5,11 @@\n //! The providers for the queries defined here can be found in\n //! `librustc_traits`.\n \n-use crate::infer::canonical::Canonical;\n-use crate::ty::error::TypeError;\n-use crate::ty::{self, Ty};\n-\n pub mod dropck_outlives;\n pub mod evaluate_obligation;\n pub mod method_autoderef;\n pub mod normalize;\n pub mod outlives_bounds;\n pub mod type_op;\n \n-pub type CanonicalProjectionGoal<'tcx> =\n-    Canonical<'tcx, ty::ParamEnvAnd<'tcx, ty::ProjectionTy<'tcx>>>;\n-\n-pub type CanonicalTyGoal<'tcx> = Canonical<'tcx, ty::ParamEnvAnd<'tcx, Ty<'tcx>>>;\n-\n-pub type CanonicalPredicateGoal<'tcx> = Canonical<'tcx, ty::ParamEnvAnd<'tcx, ty::Predicate<'tcx>>>;\n-\n-pub type CanonicalTypeOpAscribeUserTypeGoal<'tcx> =\n-    Canonical<'tcx, ty::ParamEnvAnd<'tcx, type_op::ascribe_user_type::AscribeUserType<'tcx>>>;\n-\n-pub type CanonicalTypeOpEqGoal<'tcx> =\n-    Canonical<'tcx, ty::ParamEnvAnd<'tcx, type_op::eq::Eq<'tcx>>>;\n-\n-pub type CanonicalTypeOpSubtypeGoal<'tcx> =\n-    Canonical<'tcx, ty::ParamEnvAnd<'tcx, type_op::subtype::Subtype<'tcx>>>;\n-\n-pub type CanonicalTypeOpProvePredicateGoal<'tcx> =\n-    Canonical<'tcx, ty::ParamEnvAnd<'tcx, type_op::prove_predicate::ProvePredicate<'tcx>>>;\n-\n-pub type CanonicalTypeOpNormalizeGoal<'tcx, T> =\n-    Canonical<'tcx, ty::ParamEnvAnd<'tcx, type_op::normalize::Normalize<T>>>;\n-\n-#[derive(Clone, Debug, HashStable)]\n-pub struct NoSolution;\n-\n-pub type Fallible<T> = Result<T, NoSolution>;\n-\n-impl<'tcx> From<TypeError<'tcx>> for NoSolution {\n-    fn from(_: TypeError<'tcx>) -> NoSolution {\n-        NoSolution\n-    }\n-}\n+pub use rustc::traits::types::query::*;"}, {"sha": "737b4fc6bb9dc4a2b994106337af6226db8b6ce2", "filename": "src/librustc/traits/query/normalize.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4e42f388c375b0d6eb25af087cb2a66069419529/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e42f388c375b0d6eb25af087cb2a66069419529/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs?ref=4e42f388c375b0d6eb25af087cb2a66069419529", "patch": "@@ -13,6 +13,8 @@ use crate::ty::{self, Ty, TyCtxt};\n \n use super::NoSolution;\n \n+pub use rustc::traits::query::NormalizationResult;\n+\n impl<'cx, 'tcx> At<'cx, 'tcx> {\n     /// Normalize `value` in the context of the inference context,\n     /// yielding a resulting type, or an error if `value` cannot be\n@@ -59,13 +61,6 @@ impl<'cx, 'tcx> At<'cx, 'tcx> {\n     }\n }\n \n-/// Result from the `normalize_projection_ty` query.\n-#[derive(Clone, Debug, HashStable, TypeFoldable, Lift)]\n-pub struct NormalizationResult<'tcx> {\n-    /// Result of normalization.\n-    pub normalized_ty: Ty<'tcx>,\n-}\n-\n struct QueryNormalizer<'cx, 'tcx> {\n     infcx: &'cx InferCtxt<'cx, 'tcx>,\n     cause: &'cx ObligationCause<'tcx>,"}, {"sha": "594faffa5f3aa3b9ea4f3b8bd34824af03f0a3f8", "filename": "src/librustc/traits/query/outlives_bounds.rs", "status": "modified", "additions": 1, "deletions": 37, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/4e42f388c375b0d6eb25af087cb2a66069419529/src%2Flibrustc%2Ftraits%2Fquery%2Foutlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e42f388c375b0d6eb25af087cb2a66069419529/src%2Flibrustc%2Ftraits%2Fquery%2Foutlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Foutlives_bounds.rs?ref=4e42f388c375b0d6eb25af087cb2a66069419529", "patch": "@@ -6,43 +6,7 @@ use crate::ty::{self, Ty};\n use rustc_hir as hir;\n use rustc_span::source_map::Span;\n \n-use crate::ich::StableHashingContext;\n-use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n-use std::mem;\n-\n-/// Outlives bounds are relationships between generic parameters,\n-/// whether they both be regions (`'a: 'b`) or whether types are\n-/// involved (`T: 'a`). These relationships can be extracted from the\n-/// full set of predicates we understand or also from types (in which\n-/// case they are called implied bounds). They are fed to the\n-/// `OutlivesEnv` which in turn is supplied to the region checker and\n-/// other parts of the inference system.\n-#[derive(Clone, Debug, TypeFoldable, Lift)]\n-pub enum OutlivesBound<'tcx> {\n-    RegionSubRegion(ty::Region<'tcx>, ty::Region<'tcx>),\n-    RegionSubParam(ty::Region<'tcx>, ty::ParamTy),\n-    RegionSubProjection(ty::Region<'tcx>, ty::ProjectionTy<'tcx>),\n-}\n-\n-impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for OutlivesBound<'tcx> {\n-    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n-        mem::discriminant(self).hash_stable(hcx, hasher);\n-        match *self {\n-            OutlivesBound::RegionSubRegion(ref a, ref b) => {\n-                a.hash_stable(hcx, hasher);\n-                b.hash_stable(hcx, hasher);\n-            }\n-            OutlivesBound::RegionSubParam(ref a, ref b) => {\n-                a.hash_stable(hcx, hasher);\n-                b.hash_stable(hcx, hasher);\n-            }\n-            OutlivesBound::RegionSubProjection(ref a, ref b) => {\n-                a.hash_stable(hcx, hasher);\n-                b.hash_stable(hcx, hasher);\n-            }\n-        }\n-    }\n-}\n+pub use rustc::traits::query::OutlivesBound;\n \n impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n     /// Implied bounds are region relationships that we deduce"}, {"sha": "b14b79f090778fbb230369539b1e41848b92368c", "filename": "src/librustc/traits/query/type_op/ascribe_user_type.rs", "status": "modified", "additions": 2, "deletions": 15, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/4e42f388c375b0d6eb25af087cb2a66069419529/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fascribe_user_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e42f388c375b0d6eb25af087cb2a66069419529/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fascribe_user_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fascribe_user_type.rs?ref=4e42f388c375b0d6eb25af087cb2a66069419529", "patch": "@@ -1,21 +1,8 @@\n use crate::infer::canonical::{Canonicalized, CanonicalizedQueryResponse};\n use crate::traits::query::Fallible;\n-use crate::ty::subst::UserSubsts;\n-use crate::ty::{ParamEnvAnd, Ty, TyCtxt};\n-use rustc_hir::def_id::DefId;\n+use rustc::ty::{ParamEnvAnd, TyCtxt};\n \n-#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq, HashStable, TypeFoldable, Lift)]\n-pub struct AscribeUserType<'tcx> {\n-    pub mir_ty: Ty<'tcx>,\n-    pub def_id: DefId,\n-    pub user_substs: UserSubsts<'tcx>,\n-}\n-\n-impl<'tcx> AscribeUserType<'tcx> {\n-    pub fn new(mir_ty: Ty<'tcx>, def_id: DefId, user_substs: UserSubsts<'tcx>) -> Self {\n-        Self { mir_ty, def_id, user_substs }\n-    }\n-}\n+pub use rustc::traits::query::type_op::AscribeUserType;\n \n impl<'tcx> super::QueryTypeOp<'tcx> for AscribeUserType<'tcx> {\n     type QueryResponse = ();"}, {"sha": "1de13430d4623707fe551e1e21b427baea789c81", "filename": "src/librustc/traits/query/type_op/eq.rs", "status": "modified", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4e42f388c375b0d6eb25af087cb2a66069419529/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e42f388c375b0d6eb25af087cb2a66069419529/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Feq.rs?ref=4e42f388c375b0d6eb25af087cb2a66069419529", "patch": "@@ -1,18 +1,8 @@\n use crate::infer::canonical::{Canonicalized, CanonicalizedQueryResponse};\n use crate::traits::query::Fallible;\n-use crate::ty::{ParamEnvAnd, Ty, TyCtxt};\n+use crate::ty::{ParamEnvAnd, TyCtxt};\n \n-#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq, HashStable, TypeFoldable, Lift)]\n-pub struct Eq<'tcx> {\n-    pub a: Ty<'tcx>,\n-    pub b: Ty<'tcx>,\n-}\n-\n-impl<'tcx> Eq<'tcx> {\n-    pub fn new(a: Ty<'tcx>, b: Ty<'tcx>) -> Self {\n-        Self { a, b }\n-    }\n-}\n+pub use rustc::traits::query::type_op::Eq;\n \n impl<'tcx> super::QueryTypeOp<'tcx> for Eq<'tcx> {\n     type QueryResponse = ();"}, {"sha": "2d03d77cf6645fd4517eaff69f11394ca54fbc2a", "filename": "src/librustc/traits/query/type_op/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4e42f388c375b0d6eb25af087cb2a66069419529/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e42f388c375b0d6eb25af087cb2a66069419529/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fmod.rs?ref=4e42f388c375b0d6eb25af087cb2a66069419529", "patch": "@@ -19,6 +19,8 @@ pub mod prove_predicate;\n use self::prove_predicate::ProvePredicate;\n pub mod subtype;\n \n+pub use crate::traits::types::query::type_op::*;\n+\n /// \"Type ops\" are used in NLL to perform some particular action and\n /// extract out the resulting region constraints (or an error if it\n /// cannot be completed)."}, {"sha": "b1e0e29620df6b132ec7cb20a00422868d495ffb", "filename": "src/librustc/traits/query/type_op/normalize.rs", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4e42f388c375b0d6eb25af087cb2a66069419529/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e42f388c375b0d6eb25af087cb2a66069419529/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fnormalize.rs?ref=4e42f388c375b0d6eb25af087cb2a66069419529", "patch": "@@ -4,19 +4,7 @@ use crate::ty::fold::TypeFoldable;\n use crate::ty::{self, Lift, ParamEnvAnd, Ty, TyCtxt};\n use std::fmt;\n \n-#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq, HashStable, TypeFoldable, Lift)]\n-pub struct Normalize<T> {\n-    pub value: T,\n-}\n-\n-impl<'tcx, T> Normalize<T>\n-where\n-    T: fmt::Debug + TypeFoldable<'tcx>,\n-{\n-    pub fn new(value: T) -> Self {\n-        Self { value }\n-    }\n-}\n+pub use rustc::traits::query::type_op::Normalize;\n \n impl<'tcx, T> super::QueryTypeOp<'tcx> for Normalize<T>\n where"}, {"sha": "92cfb82e27e953a97afce53868dec46d5daf247a", "filename": "src/librustc/traits/query/type_op/prove_predicate.rs", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4e42f388c375b0d6eb25af087cb2a66069419529/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fprove_predicate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e42f388c375b0d6eb25af087cb2a66069419529/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fprove_predicate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fprove_predicate.rs?ref=4e42f388c375b0d6eb25af087cb2a66069419529", "patch": "@@ -2,16 +2,7 @@ use crate::infer::canonical::{Canonicalized, CanonicalizedQueryResponse};\n use crate::traits::query::Fallible;\n use crate::ty::{ParamEnvAnd, Predicate, TyCtxt};\n \n-#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq, HashStable, TypeFoldable, Lift)]\n-pub struct ProvePredicate<'tcx> {\n-    pub predicate: Predicate<'tcx>,\n-}\n-\n-impl<'tcx> ProvePredicate<'tcx> {\n-    pub fn new(predicate: Predicate<'tcx>) -> Self {\n-        ProvePredicate { predicate }\n-    }\n-}\n+pub use rustc::traits::query::type_op::ProvePredicate;\n \n impl<'tcx> super::QueryTypeOp<'tcx> for ProvePredicate<'tcx> {\n     type QueryResponse = ();"}, {"sha": "2877a74aaff01bc689713d0979a7d013805fa627", "filename": "src/librustc/traits/query/type_op/subtype.rs", "status": "modified", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4e42f388c375b0d6eb25af087cb2a66069419529/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fsubtype.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e42f388c375b0d6eb25af087cb2a66069419529/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fsubtype.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fsubtype.rs?ref=4e42f388c375b0d6eb25af087cb2a66069419529", "patch": "@@ -1,18 +1,8 @@\n use crate::infer::canonical::{Canonicalized, CanonicalizedQueryResponse};\n use crate::traits::query::Fallible;\n-use crate::ty::{ParamEnvAnd, Ty, TyCtxt};\n+use crate::ty::{ParamEnvAnd, TyCtxt};\n \n-#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq, HashStable, TypeFoldable, Lift)]\n-pub struct Subtype<'tcx> {\n-    pub sub: Ty<'tcx>,\n-    pub sup: Ty<'tcx>,\n-}\n-\n-impl<'tcx> Subtype<'tcx> {\n-    pub fn new(sub: Ty<'tcx>, sup: Ty<'tcx>) -> Self {\n-        Self { sub, sup }\n-    }\n-}\n+pub use rustc::traits::query::type_op::Subtype;\n \n impl<'tcx> super::QueryTypeOp<'tcx> for Subtype<'tcx> {\n     type QueryResponse = ();"}, {"sha": "c795248802672f4e1ffe7642bb79292caad08d1c", "filename": "src/librustc/traits/types/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4e42f388c375b0d6eb25af087cb2a66069419529/src%2Flibrustc%2Ftraits%2Ftypes%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e42f388c375b0d6eb25af087cb2a66069419529/src%2Flibrustc%2Ftraits%2Ftypes%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ftypes%2Fmod.rs?ref=4e42f388c375b0d6eb25af087cb2a66069419529", "patch": "@@ -2,6 +2,7 @@\n //!\n //! [rustc guide]: https://rust-lang.github.io/rustc-guide/traits/resolution.html\n \n+pub mod query;\n pub mod select;\n \n use crate::mir::interpret::ErrorHandled;"}, {"sha": "c90551826202efd4300a90cde649cae91c71d8b0", "filename": "src/librustc/traits/types/query.rs", "status": "added", "additions": 332, "deletions": 0, "changes": 332, "blob_url": "https://github.com/rust-lang/rust/blob/4e42f388c375b0d6eb25af087cb2a66069419529/src%2Flibrustc%2Ftraits%2Ftypes%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e42f388c375b0d6eb25af087cb2a66069419529/src%2Flibrustc%2Ftraits%2Ftypes%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ftypes%2Fquery.rs?ref=4e42f388c375b0d6eb25af087cb2a66069419529", "patch": "@@ -0,0 +1,332 @@\n+//! Experimental types for the trait query interface. The methods\n+//! defined in this module are all based on **canonicalization**,\n+//! which makes a canonical query by replacing unbound inference\n+//! variables and regions, so that results can be reused more broadly.\n+//! The providers for the queries defined here can be found in\n+//! `librustc_traits`.\n+\n+use crate::ich::StableHashingContext;\n+use crate::infer::canonical::{Canonical, QueryResponse};\n+use crate::ty::error::TypeError;\n+use crate::ty::subst::GenericArg;\n+use crate::ty::{self, Ty, TyCtxt};\n+\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n+use rustc_data_structures::sync::Lrc;\n+use rustc_errors::struct_span_err;\n+use rustc_span::source_map::Span;\n+use std::iter::FromIterator;\n+use std::mem;\n+\n+pub mod type_op {\n+    use crate::ty::fold::TypeFoldable;\n+    use crate::ty::subst::UserSubsts;\n+    use crate::ty::{Predicate, Ty};\n+    use rustc_hir::def_id::DefId;\n+    use std::fmt;\n+\n+    #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq, HashStable, TypeFoldable, Lift)]\n+    pub struct AscribeUserType<'tcx> {\n+        pub mir_ty: Ty<'tcx>,\n+        pub def_id: DefId,\n+        pub user_substs: UserSubsts<'tcx>,\n+    }\n+\n+    impl<'tcx> AscribeUserType<'tcx> {\n+        pub fn new(mir_ty: Ty<'tcx>, def_id: DefId, user_substs: UserSubsts<'tcx>) -> Self {\n+            Self { mir_ty, def_id, user_substs }\n+        }\n+    }\n+\n+    #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq, HashStable, TypeFoldable, Lift)]\n+    pub struct Eq<'tcx> {\n+        pub a: Ty<'tcx>,\n+        pub b: Ty<'tcx>,\n+    }\n+\n+    impl<'tcx> Eq<'tcx> {\n+        pub fn new(a: Ty<'tcx>, b: Ty<'tcx>) -> Self {\n+            Self { a, b }\n+        }\n+    }\n+\n+    #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq, HashStable, TypeFoldable, Lift)]\n+    pub struct Subtype<'tcx> {\n+        pub sub: Ty<'tcx>,\n+        pub sup: Ty<'tcx>,\n+    }\n+\n+    impl<'tcx> Subtype<'tcx> {\n+        pub fn new(sub: Ty<'tcx>, sup: Ty<'tcx>) -> Self {\n+            Self { sub, sup }\n+        }\n+    }\n+\n+    #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq, HashStable, TypeFoldable, Lift)]\n+    pub struct ProvePredicate<'tcx> {\n+        pub predicate: Predicate<'tcx>,\n+    }\n+\n+    impl<'tcx> ProvePredicate<'tcx> {\n+        pub fn new(predicate: Predicate<'tcx>) -> Self {\n+            ProvePredicate { predicate }\n+        }\n+    }\n+\n+    #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq, HashStable, TypeFoldable, Lift)]\n+    pub struct Normalize<T> {\n+        pub value: T,\n+    }\n+\n+    impl<'tcx, T> Normalize<T>\n+    where\n+        T: fmt::Debug + TypeFoldable<'tcx>,\n+    {\n+        pub fn new(value: T) -> Self {\n+            Self { value }\n+        }\n+    }\n+}\n+\n+pub type CanonicalProjectionGoal<'tcx> =\n+    Canonical<'tcx, ty::ParamEnvAnd<'tcx, ty::ProjectionTy<'tcx>>>;\n+\n+pub type CanonicalTyGoal<'tcx> = Canonical<'tcx, ty::ParamEnvAnd<'tcx, Ty<'tcx>>>;\n+\n+pub type CanonicalPredicateGoal<'tcx> = Canonical<'tcx, ty::ParamEnvAnd<'tcx, ty::Predicate<'tcx>>>;\n+\n+pub type CanonicalTypeOpAscribeUserTypeGoal<'tcx> =\n+    Canonical<'tcx, ty::ParamEnvAnd<'tcx, type_op::AscribeUserType<'tcx>>>;\n+\n+pub type CanonicalTypeOpEqGoal<'tcx> = Canonical<'tcx, ty::ParamEnvAnd<'tcx, type_op::Eq<'tcx>>>;\n+\n+pub type CanonicalTypeOpSubtypeGoal<'tcx> =\n+    Canonical<'tcx, ty::ParamEnvAnd<'tcx, type_op::Subtype<'tcx>>>;\n+\n+pub type CanonicalTypeOpProvePredicateGoal<'tcx> =\n+    Canonical<'tcx, ty::ParamEnvAnd<'tcx, type_op::ProvePredicate<'tcx>>>;\n+\n+pub type CanonicalTypeOpNormalizeGoal<'tcx, T> =\n+    Canonical<'tcx, ty::ParamEnvAnd<'tcx, type_op::Normalize<T>>>;\n+\n+#[derive(Clone, Debug, HashStable)]\n+pub struct NoSolution;\n+\n+pub type Fallible<T> = Result<T, NoSolution>;\n+\n+impl<'tcx> From<TypeError<'tcx>> for NoSolution {\n+    fn from(_: TypeError<'tcx>) -> NoSolution {\n+        NoSolution\n+    }\n+}\n+\n+#[derive(Clone, Debug, Default, HashStable, TypeFoldable, Lift)]\n+pub struct DropckOutlivesResult<'tcx> {\n+    pub kinds: Vec<GenericArg<'tcx>>,\n+    pub overflows: Vec<Ty<'tcx>>,\n+}\n+\n+impl<'tcx> DropckOutlivesResult<'tcx> {\n+    pub fn report_overflows(&self, tcx: TyCtxt<'tcx>, span: Span, ty: Ty<'tcx>) {\n+        if let Some(overflow_ty) = self.overflows.iter().next() {\n+            let mut err = struct_span_err!(\n+                tcx.sess,\n+                span,\n+                E0320,\n+                \"overflow while adding drop-check rules for {}\",\n+                ty,\n+            );\n+            err.note(&format!(\"overflowed on {}\", overflow_ty));\n+            err.emit();\n+        }\n+    }\n+\n+    pub fn into_kinds_reporting_overflows(\n+        self,\n+        tcx: TyCtxt<'tcx>,\n+        span: Span,\n+        ty: Ty<'tcx>,\n+    ) -> Vec<GenericArg<'tcx>> {\n+        self.report_overflows(tcx, span, ty);\n+        let DropckOutlivesResult { kinds, overflows: _ } = self;\n+        kinds\n+    }\n+}\n+\n+/// A set of constraints that need to be satisfied in order for\n+/// a type to be valid for destruction.\n+#[derive(Clone, Debug, HashStable)]\n+pub struct DtorckConstraint<'tcx> {\n+    /// Types that are required to be alive in order for this\n+    /// type to be valid for destruction.\n+    pub outlives: Vec<ty::subst::GenericArg<'tcx>>,\n+\n+    /// Types that could not be resolved: projections and params.\n+    pub dtorck_types: Vec<Ty<'tcx>>,\n+\n+    /// If, during the computation of the dtorck constraint, we\n+    /// overflow, that gets recorded here. The caller is expected to\n+    /// report an error.\n+    pub overflows: Vec<Ty<'tcx>>,\n+}\n+\n+impl<'tcx> DtorckConstraint<'tcx> {\n+    pub fn empty() -> DtorckConstraint<'tcx> {\n+        DtorckConstraint { outlives: vec![], dtorck_types: vec![], overflows: vec![] }\n+    }\n+}\n+\n+impl<'tcx> FromIterator<DtorckConstraint<'tcx>> for DtorckConstraint<'tcx> {\n+    fn from_iter<I: IntoIterator<Item = DtorckConstraint<'tcx>>>(iter: I) -> Self {\n+        let mut result = Self::empty();\n+\n+        for DtorckConstraint { outlives, dtorck_types, overflows } in iter {\n+            result.outlives.extend(outlives);\n+            result.dtorck_types.extend(dtorck_types);\n+            result.overflows.extend(overflows);\n+        }\n+\n+        result\n+    }\n+}\n+\n+/// This returns true if the type `ty` is \"trivial\" for\n+/// dropck-outlives -- that is, if it doesn't require any types to\n+/// outlive. This is similar but not *quite* the same as the\n+/// `needs_drop` test in the compiler already -- that is, for every\n+/// type T for which this function return true, needs-drop would\n+/// return `false`. But the reverse does not hold: in particular,\n+/// `needs_drop` returns false for `PhantomData`, but it is not\n+/// trivial for dropck-outlives.\n+///\n+/// Note also that `needs_drop` requires a \"global\" type (i.e., one\n+/// with erased regions), but this function does not.\n+pub fn trivial_dropck_outlives<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> bool {\n+    match ty.kind {\n+        // None of these types have a destructor and hence they do not\n+        // require anything in particular to outlive the dtor's\n+        // execution.\n+        ty::Infer(ty::FreshIntTy(_))\n+        | ty::Infer(ty::FreshFloatTy(_))\n+        | ty::Bool\n+        | ty::Int(_)\n+        | ty::Uint(_)\n+        | ty::Float(_)\n+        | ty::Never\n+        | ty::FnDef(..)\n+        | ty::FnPtr(_)\n+        | ty::Char\n+        | ty::GeneratorWitness(..)\n+        | ty::RawPtr(_)\n+        | ty::Ref(..)\n+        | ty::Str\n+        | ty::Foreign(..)\n+        | ty::Error => true,\n+\n+        // [T; N] and [T] have same properties as T.\n+        ty::Array(ty, _) | ty::Slice(ty) => trivial_dropck_outlives(tcx, ty),\n+\n+        // (T1..Tn) and closures have same properties as T1..Tn --\n+        // check if *any* of those are trivial.\n+        ty::Tuple(ref tys) => tys.iter().all(|t| trivial_dropck_outlives(tcx, t.expect_ty())),\n+        ty::Closure(def_id, ref substs) => {\n+            substs.as_closure().upvar_tys(def_id, tcx).all(|t| trivial_dropck_outlives(tcx, t))\n+        }\n+\n+        ty::Adt(def, _) => {\n+            if Some(def.did) == tcx.lang_items().manually_drop() {\n+                // `ManuallyDrop` never has a dtor.\n+                true\n+            } else {\n+                // Other types might. Moreover, PhantomData doesn't\n+                // have a dtor, but it is considered to own its\n+                // content, so it is non-trivial. Unions can have `impl Drop`,\n+                // and hence are non-trivial as well.\n+                false\n+            }\n+        }\n+\n+        // The following *might* require a destructor: needs deeper inspection.\n+        ty::Dynamic(..)\n+        | ty::Projection(..)\n+        | ty::Param(_)\n+        | ty::Opaque(..)\n+        | ty::Placeholder(..)\n+        | ty::Infer(_)\n+        | ty::Bound(..)\n+        | ty::Generator(..) => false,\n+\n+        ty::UnnormalizedProjection(..) => bug!(\"only used with chalk-engine\"),\n+    }\n+}\n+\n+#[derive(Debug, HashStable)]\n+pub struct CandidateStep<'tcx> {\n+    pub self_ty: Canonical<'tcx, QueryResponse<'tcx, Ty<'tcx>>>,\n+    pub autoderefs: usize,\n+    /// `true` if the type results from a dereference of a raw pointer.\n+    /// when assembling candidates, we include these steps, but not when\n+    /// picking methods. This so that if we have `foo: *const Foo` and `Foo` has methods\n+    /// `fn by_raw_ptr(self: *const Self)` and `fn by_ref(&self)`, then\n+    /// `foo.by_raw_ptr()` will work and `foo.by_ref()` won't.\n+    pub from_unsafe_deref: bool,\n+    pub unsize: bool,\n+}\n+\n+#[derive(Clone, Debug, HashStable)]\n+pub struct MethodAutoderefStepsResult<'tcx> {\n+    /// The valid autoderef steps that could be find.\n+    pub steps: Lrc<Vec<CandidateStep<'tcx>>>,\n+    /// If Some(T), a type autoderef reported an error on.\n+    pub opt_bad_ty: Option<Lrc<MethodAutoderefBadTy<'tcx>>>,\n+    /// If `true`, `steps` has been truncated due to reaching the\n+    /// recursion limit.\n+    pub reached_recursion_limit: bool,\n+}\n+\n+#[derive(Debug, HashStable)]\n+pub struct MethodAutoderefBadTy<'tcx> {\n+    pub reached_raw_pointer: bool,\n+    pub ty: Canonical<'tcx, QueryResponse<'tcx, Ty<'tcx>>>,\n+}\n+\n+/// Result from the `normalize_projection_ty` query.\n+#[derive(Clone, Debug, HashStable, TypeFoldable, Lift)]\n+pub struct NormalizationResult<'tcx> {\n+    /// Result of normalization.\n+    pub normalized_ty: Ty<'tcx>,\n+}\n+\n+/// Outlives bounds are relationships between generic parameters,\n+/// whether they both be regions (`'a: 'b`) or whether types are\n+/// involved (`T: 'a`). These relationships can be extracted from the\n+/// full set of predicates we understand or also from types (in which\n+/// case they are called implied bounds). They are fed to the\n+/// `OutlivesEnv` which in turn is supplied to the region checker and\n+/// other parts of the inference system.\n+#[derive(Clone, Debug, TypeFoldable, Lift)]\n+pub enum OutlivesBound<'tcx> {\n+    RegionSubRegion(ty::Region<'tcx>, ty::Region<'tcx>),\n+    RegionSubParam(ty::Region<'tcx>, ty::ParamTy),\n+    RegionSubProjection(ty::Region<'tcx>, ty::ProjectionTy<'tcx>),\n+}\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for OutlivesBound<'tcx> {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+        match *self {\n+            OutlivesBound::RegionSubRegion(ref a, ref b) => {\n+                a.hash_stable(hcx, hasher);\n+                b.hash_stable(hcx, hasher);\n+            }\n+            OutlivesBound::RegionSubParam(ref a, ref b) => {\n+                a.hash_stable(hcx, hasher);\n+                b.hash_stable(hcx, hasher);\n+            }\n+            OutlivesBound::RegionSubProjection(ref a, ref b) => {\n+                a.hash_stable(hcx, hasher);\n+                b.hash_stable(hcx, hasher);\n+            }\n+        }\n+    }\n+}"}]}