{"sha": "b6cab80c181e0212966017c0abe1c3e08b50f5d4", "node_id": "C_kwDOAAsO6NoAKGI2Y2FiODBjMTgxZTAyMTI5NjYwMTdjMGFiZTFjM2UwOGI1MGY1ZDQ", "commit": {"author": {"name": "Cameron Steffen", "email": "cam.steffen94@gmail.com", "date": "2021-10-04T21:11:22Z"}, "committer": {"name": "Cameron Steffen", "email": "cam.steffen94@gmail.com", "date": "2021-10-06T18:10:08Z"}, "message": "Use get_diagnostic_name", "tree": {"sha": "5a1485bbfed98bce9f019f76dc3f14601b5e6316", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5a1485bbfed98bce9f019f76dc3f14601b5e6316"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b6cab80c181e0212966017c0abe1c3e08b50f5d4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b6cab80c181e0212966017c0abe1c3e08b50f5d4", "html_url": "https://github.com/rust-lang/rust/commit/b6cab80c181e0212966017c0abe1c3e08b50f5d4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b6cab80c181e0212966017c0abe1c3e08b50f5d4/comments", "author": {"login": "camsteffen", "id": 5565418, "node_id": "MDQ6VXNlcjU1NjU0MTg=", "avatar_url": "https://avatars.githubusercontent.com/u/5565418?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camsteffen", "html_url": "https://github.com/camsteffen", "followers_url": "https://api.github.com/users/camsteffen/followers", "following_url": "https://api.github.com/users/camsteffen/following{/other_user}", "gists_url": "https://api.github.com/users/camsteffen/gists{/gist_id}", "starred_url": "https://api.github.com/users/camsteffen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camsteffen/subscriptions", "organizations_url": "https://api.github.com/users/camsteffen/orgs", "repos_url": "https://api.github.com/users/camsteffen/repos", "events_url": "https://api.github.com/users/camsteffen/events{/privacy}", "received_events_url": "https://api.github.com/users/camsteffen/received_events", "type": "User", "site_admin": false}, "committer": {"login": "camsteffen", "id": 5565418, "node_id": "MDQ6VXNlcjU1NjU0MTg=", "avatar_url": "https://avatars.githubusercontent.com/u/5565418?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camsteffen", "html_url": "https://github.com/camsteffen", "followers_url": "https://api.github.com/users/camsteffen/followers", "following_url": "https://api.github.com/users/camsteffen/following{/other_user}", "gists_url": "https://api.github.com/users/camsteffen/gists{/gist_id}", "starred_url": "https://api.github.com/users/camsteffen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camsteffen/subscriptions", "organizations_url": "https://api.github.com/users/camsteffen/orgs", "repos_url": "https://api.github.com/users/camsteffen/repos", "events_url": "https://api.github.com/users/camsteffen/events{/privacy}", "received_events_url": "https://api.github.com/users/camsteffen/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "33b9b9530561ada2584c8a9239e6581fef216a2a", "url": "https://api.github.com/repos/rust-lang/rust/commits/33b9b9530561ada2584c8a9239e6581fef216a2a", "html_url": "https://github.com/rust-lang/rust/commit/33b9b9530561ada2584c8a9239e6581fef216a2a"}], "stats": {"total": 186, "additions": 73, "deletions": 113}, "files": [{"sha": "57c1c8f3ecb5c28f033a29389fdf00edd74291f7", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 13, "deletions": 15, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/b6cab80c181e0212966017c0abe1c3e08b50f5d4/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6cab80c181e0212966017c0abe1c3e08b50f5d4/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=b6cab80c181e0212966017c0abe1c3e08b50f5d4", "patch": "@@ -2478,14 +2478,11 @@ impl<'tcx> LateLintPass<'tcx> for InvalidValue {\n                 // Find calls to `mem::{uninitialized,zeroed}` methods.\n                 if let hir::ExprKind::Path(ref qpath) = path_expr.kind {\n                     let def_id = cx.qpath_res(qpath, path_expr.hir_id).opt_def_id()?;\n-\n-                    if cx.tcx.is_diagnostic_item(sym::mem_zeroed, def_id) {\n-                        return Some(InitKind::Zeroed);\n-                    } else if cx.tcx.is_diagnostic_item(sym::mem_uninitialized, def_id) {\n-                        return Some(InitKind::Uninit);\n-                    } else if cx.tcx.is_diagnostic_item(sym::transmute, def_id) && is_zero(&args[0])\n-                    {\n-                        return Some(InitKind::Zeroed);\n+                    match cx.tcx.get_diagnostic_name(def_id) {\n+                        Some(sym::mem_zeroed) => return Some(InitKind::Zeroed),\n+                        Some(sym::mem_uninitialized) => return Some(InitKind::Uninit),\n+                        Some(sym::transmute) if is_zero(&args[0]) => return Some(InitKind::Zeroed),\n+                        _ => {}\n                     }\n                 }\n             } else if let hir::ExprKind::MethodCall(_, _, ref args, _) = expr.kind {\n@@ -2497,11 +2494,10 @@ impl<'tcx> LateLintPass<'tcx> for InvalidValue {\n                     if let hir::ExprKind::Call(ref path_expr, _) = args[0].kind {\n                         if let hir::ExprKind::Path(ref qpath) = path_expr.kind {\n                             let def_id = cx.qpath_res(qpath, path_expr.hir_id).opt_def_id()?;\n-\n-                            if cx.tcx.is_diagnostic_item(sym::maybe_uninit_zeroed, def_id) {\n-                                return Some(InitKind::Zeroed);\n-                            } else if cx.tcx.is_diagnostic_item(sym::maybe_uninit_uninit, def_id) {\n-                                return Some(InitKind::Uninit);\n+                            match cx.tcx.get_diagnostic_name(def_id) {\n+                                Some(sym::maybe_uninit_zeroed) => return Some(InitKind::Zeroed),\n+                                Some(sym::maybe_uninit_uninit) => return Some(InitKind::Uninit),\n+                                _ => {}\n                             }\n                         }\n                     }\n@@ -3091,8 +3087,10 @@ impl<'tcx> LateLintPass<'tcx> for DerefNullPtr {\n                 rustc_hir::ExprKind::Call(ref path, _) => {\n                     if let rustc_hir::ExprKind::Path(ref qpath) = path.kind {\n                         if let Some(def_id) = cx.qpath_res(qpath, path.hir_id).opt_def_id() {\n-                            return cx.tcx.is_diagnostic_item(sym::ptr_null, def_id)\n-                                || cx.tcx.is_diagnostic_item(sym::ptr_null_mut, def_id);\n+                            return matches!(\n+                                cx.tcx.get_diagnostic_name(def_id),\n+                                Some(sym::ptr_null | sym::ptr_null_mut)\n+                            );\n                         }\n                     }\n                 }"}, {"sha": "50a0d211a366a913613ea622df502554413c00bd", "filename": "compiler/rustc_lint/src/internal.rs", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/b6cab80c181e0212966017c0abe1c3e08b50f5d4/compiler%2Frustc_lint%2Fsrc%2Finternal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6cab80c181e0212966017c0abe1c3e08b50f5d4/compiler%2Frustc_lint%2Fsrc%2Finternal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Finternal.rs?ref=b6cab80c181e0212966017c0abe1c3e08b50f5d4", "patch": "@@ -33,12 +33,10 @@ impl LateLintPass<'_> for DefaultHashTypes {\n             // don't lint imports, only actual usages\n             return;\n         }\n-        let replace = if cx.tcx.is_diagnostic_item(sym::HashMap, def_id) {\n-            \"FxHashMap\"\n-        } else if cx.tcx.is_diagnostic_item(sym::HashSet, def_id) {\n-            \"FxHashSet\"\n-        } else {\n-            return;\n+        let replace = match cx.tcx.get_diagnostic_name(def_id) {\n+            Some(sym::HashMap) => \"FxHashMap\",\n+            Some(sym::HashSet) => \"FxHashSet\",\n+            _ => return,\n         };\n         cx.struct_span_lint(DEFAULT_HASH_TYPES, path.span, |lint| {\n             let msg = format!(\n@@ -174,26 +172,29 @@ fn is_ty_or_ty_ctxt(cx: &LateContext<'_>, ty: &Ty<'_>) -> Option<String> {\n     if let TyKind::Path(qpath) = &ty.kind {\n         if let QPath::Resolved(_, path) = qpath {\n             match path.res {\n-                Res::Def(_, did) => {\n-                    if cx.tcx.is_diagnostic_item(sym::Ty, did) {\n-                        return Some(format!(\"Ty{}\", gen_args(path.segments.last().unwrap())));\n-                    } else if cx.tcx.is_diagnostic_item(sym::TyCtxt, did) {\n-                        return Some(format!(\"TyCtxt{}\", gen_args(path.segments.last().unwrap())));\n+                Res::Def(_, def_id) => {\n+                    if let Some(name @ (sym::Ty | sym::TyCtxt)) = cx.tcx.get_diagnostic_name(def_id)\n+                    {\n+                        return Some(format!(\n+                            \"{}{}\",\n+                            name,\n+                            gen_args(path.segments.last().unwrap())\n+                        ));\n                     }\n                 }\n                 // Only lint on `&Ty` and `&TyCtxt` if it is used outside of a trait.\n                 Res::SelfTy(None, Some((did, _))) => {\n                     if let ty::Adt(adt, substs) = cx.tcx.type_of(did).kind() {\n-                        if cx.tcx.is_diagnostic_item(sym::Ty, adt.did) {\n+                        if let Some(name @ (sym::Ty | sym::TyCtxt)) =\n+                            cx.tcx.get_diagnostic_name(adt.did)\n+                        {\n                             // NOTE: This path is currently unreachable as `Ty<'tcx>` is\n                             // defined as a type alias meaning that `impl<'tcx> Ty<'tcx>`\n                             // is not actually allowed.\n                             //\n                             // I(@lcnr) still kept this branch in so we don't miss this\n                             // if we ever change it in the future.\n-                            return Some(format!(\"Ty<{}>\", substs[0]));\n-                        } else if cx.tcx.is_diagnostic_item(sym::TyCtxt, adt.did) {\n-                            return Some(format!(\"TyCtxt<{}>\", substs[0]));\n+                            return Some(format!(\"{}<{}>\", name, substs[0]));\n                         }\n                     }\n                 }"}, {"sha": "103555a67524fd58d53681b0c3ca8b3ade211da2", "filename": "compiler/rustc_lint/src/non_fmt_panic.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b6cab80c181e0212966017c0abe1c3e08b50f5d4/compiler%2Frustc_lint%2Fsrc%2Fnon_fmt_panic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6cab80c181e0212966017c0abe1c3e08b50f5d4/compiler%2Frustc_lint%2Fsrc%2Fnon_fmt_panic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fnon_fmt_panic.rs?ref=b6cab80c181e0212966017c0abe1c3e08b50f5d4", "patch": "@@ -54,9 +54,10 @@ impl<'tcx> LateLintPass<'tcx> for NonPanicFmt {\n                     || Some(def_id) == cx.tcx.lang_items().panic_str()\n                 {\n                     if let Some(id) = f.span.ctxt().outer_expn_data().macro_def_id {\n-                        if cx.tcx.is_diagnostic_item(sym::std_panic_2015_macro, id)\n-                            || cx.tcx.is_diagnostic_item(sym::core_panic_2015_macro, id)\n-                        {\n+                        if matches!(\n+                            cx.tcx.get_diagnostic_name(id),\n+                            Some(sym::core_panic_2015_macro | sym::std_panic_2015_macro)\n+                        ) {\n                             check_panic(cx, f, arg);\n                         }\n                     }"}, {"sha": "d2c970468abc7d8de5800e76aa684710defaad18", "filename": "compiler/rustc_lint/src/noop_method_call.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b6cab80c181e0212966017c0abe1c3e08b50f5d4/compiler%2Frustc_lint%2Fsrc%2Fnoop_method_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6cab80c181e0212966017c0abe1c3e08b50f5d4/compiler%2Frustc_lint%2Fsrc%2Fnoop_method_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fnoop_method_call.rs?ref=b6cab80c181e0212966017c0abe1c3e08b50f5d4", "patch": "@@ -51,9 +51,10 @@ impl<'tcx> LateLintPass<'tcx> for NoopMethodCall {\n             Some((DefKind::AssocFn, did)) => match cx.tcx.trait_of_item(did) {\n                 // Check that we're dealing with a trait method for one of the traits we care about.\n                 Some(trait_id)\n-                    if [sym::Clone, sym::Deref, sym::Borrow]\n-                        .iter()\n-                        .any(|s| cx.tcx.is_diagnostic_item(*s, trait_id)) =>\n+                    if matches!(\n+                        cx.tcx.get_diagnostic_name(trait_id),\n+                        Some(sym::Borrow | sym::Clone | sym::Deref)\n+                    ) =>\n                 {\n                     (trait_id, did)\n                 }"}, {"sha": "708cd56e068b537c40be4088eb3d961194443b2f", "filename": "compiler/rustc_lint/src/types.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b6cab80c181e0212966017c0abe1c3e08b50f5d4/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6cab80c181e0212966017c0abe1c3e08b50f5d4/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs?ref=b6cab80c181e0212966017c0abe1c3e08b50f5d4", "patch": "@@ -1541,8 +1541,7 @@ impl InvalidAtomicOrdering {\n             if let ExprKind::Call(ref func, ref args) = expr.kind;\n             if let ExprKind::Path(ref func_qpath) = func.kind;\n             if let Some(def_id) = cx.qpath_res(func_qpath, func.hir_id).opt_def_id();\n-            if cx.tcx.is_diagnostic_item(sym::fence, def_id) ||\n-                cx.tcx.is_diagnostic_item(sym::compiler_fence, def_id);\n+            if matches!(cx.tcx.get_diagnostic_name(def_id), Some(sym::fence | sym::compiler_fence));\n             if let ExprKind::Path(ref ordering_qpath) = &args[0].kind;\n             if let Some(ordering_def_id) = cx.qpath_res(ordering_qpath, args[0].hir_id).opt_def_id();\n             if Self::matches_ordering(cx, ordering_def_id, &[sym::Relaxed]);"}, {"sha": "183ebc559ae42ba0cd1a978349246c882fca57e9", "filename": "compiler/rustc_typeck/src/check/method/suggest.rs", "status": "modified", "additions": 35, "deletions": 75, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/b6cab80c181e0212966017c0abe1c3e08b50f5d4/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6cab80c181e0212966017c0abe1c3e08b50f5d4/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs?ref=b6cab80c181e0212966017c0abe1c3e08b50f5d4", "patch": "@@ -1047,51 +1047,41 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         err: &mut DiagnosticBuilder<'_>,\n         unsatisfied_predicates: &Vec<(ty::Predicate<'tcx>, Option<ty::Predicate<'tcx>>)>,\n     ) {\n-        let derivables = [\n-            sym::Eq,\n-            sym::PartialEq,\n-            sym::Ord,\n-            sym::PartialOrd,\n-            sym::Clone,\n-            sym::Copy,\n-            sym::Hash,\n-            sym::Default,\n-            sym::Debug,\n-        ];\n-        let mut derives = unsatisfied_predicates\n-            .iter()\n-            .filter_map(|(pred, _)| {\n-                let trait_pred =\n-                    if let ty::PredicateKind::Trait(trait_pred) = pred.kind().skip_binder() {\n-                        trait_pred\n-                    } else {\n-                        return None;\n-                    };\n-                let trait_ref = trait_pred.trait_ref;\n-                let adt_def = if let ty::Adt(adt_def, _) = trait_ref.self_ty().kind() {\n-                    adt_def\n-                } else {\n-                    return None;\n-                };\n-                if adt_def.did.is_local() {\n-                    let diagnostic_items = self.tcx.diagnostic_items(trait_ref.def_id.krate);\n-                    return derivables.iter().find_map(|trait_derivable| {\n-                        let item_def_id = diagnostic_items.name_to_id.get(trait_derivable)?;\n-                        if item_def_id == &trait_pred.trait_ref.def_id\n-                            && !(adt_def.is_enum() && *trait_derivable == sym::Default)\n-                        {\n-                            return Some((\n-                                format!(\"{}\", trait_ref.self_ty()),\n-                                self.tcx.def_span(adt_def.did),\n-                                format!(\"{}\", trait_ref.print_only_trait_name()),\n-                            ));\n-                        }\n-                        None\n-                    });\n-                }\n-                None\n-            })\n-            .collect::<Vec<(String, Span, String)>>();\n+        let mut derives = Vec::<(String, Span, String)>::new();\n+        let mut traits = Vec::<Span>::new();\n+        for (pred, _) in unsatisfied_predicates {\n+            let trait_pred = match pred.kind().skip_binder() {\n+                ty::PredicateKind::Trait(trait_pred) => trait_pred,\n+                _ => continue,\n+            };\n+            let adt = match trait_pred.self_ty().ty_adt_def() {\n+                Some(adt) if adt.did.is_local() => adt,\n+                _ => continue,\n+            };\n+            let can_derive = match self.tcx.get_diagnostic_name(trait_pred.def_id()) {\n+                Some(sym::Default) => !adt.is_enum(),\n+                Some(\n+                    sym::Eq\n+                    | sym::PartialEq\n+                    | sym::Ord\n+                    | sym::PartialOrd\n+                    | sym::Clone\n+                    | sym::Copy\n+                    | sym::Hash\n+                    | sym::Debug,\n+                ) => true,\n+                _ => false,\n+            };\n+            if can_derive {\n+                derives.push((\n+                    format!(\"{}\", trait_pred.self_ty()),\n+                    self.tcx.def_span(adt.did),\n+                    format!(\"{}\", trait_pred.trait_ref.print_only_trait_name()),\n+                ));\n+            } else {\n+                traits.push(self.tcx.def_span(trait_pred.def_id()));\n+            }\n+        }\n         derives.sort();\n         let derives_grouped = derives.into_iter().fold(\n             Vec::<(String, Span, String)>::new(),\n@@ -1106,36 +1096,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 acc\n             },\n         );\n-        let mut traits: Vec<_> = unsatisfied_predicates\n-            .iter()\n-            .filter_map(|(pred, _)| {\n-                let trait_pred =\n-                    if let ty::PredicateKind::Trait(trait_pred) = pred.kind().skip_binder() {\n-                        trait_pred\n-                    } else {\n-                        return None;\n-                    };\n-                if let ty::Adt(adt_def, _) = trait_pred.trait_ref.self_ty().kind() {\n-                    if !adt_def.did.is_local() {\n-                        return None;\n-                    }\n-                } else {\n-                    return None;\n-                };\n-\n-                let did = trait_pred.def_id();\n-                let diagnostic_items = self.tcx.diagnostic_items(did.krate);\n-\n-                if !derivables\n-                    .iter()\n-                    .any(|trait_derivable| diagnostic_items.get(trait_derivable) == Some(&did))\n-                {\n-                    Some(self.tcx.def_span(did))\n-                } else {\n-                    None\n-                }\n-            })\n-            .collect();\n         traits.sort();\n         traits.dedup();\n "}]}