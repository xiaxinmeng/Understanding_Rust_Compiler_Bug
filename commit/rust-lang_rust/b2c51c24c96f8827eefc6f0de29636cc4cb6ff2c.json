{"sha": "b2c51c24c96f8827eefc6f0de29636cc4cb6ff2c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIyYzUxYzI0Yzk2Zjg4MjdlZWZjNmYwZGUyOTYzNmNjNGNiNmZmMmM=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2019-09-19T15:41:10Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2019-09-19T15:50:00Z"}, "message": "avoid generating drops for moved operands of calls\n\nCurrently, after a CALL terminator is created in MIR, we insert DROP\nstatements for all of its operands -- even though they were just moved\nshortly before! These spurious drops are later removed, but not before\ncausing borrow check errors.\n\nThis PR series modifies the drop code to track operands that were\nmoved and avoid creating drops for them.\n\nRight now, I'm only using this mechanism for calls, but it seems\nlikely it could be used in more places.", "tree": {"sha": "fedf90b2380e3fd29ba5bfa23967369f0ae49b91", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fedf90b2380e3fd29ba5bfa23967369f0ae49b91"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b2c51c24c96f8827eefc6f0de29636cc4cb6ff2c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b2c51c24c96f8827eefc6f0de29636cc4cb6ff2c", "html_url": "https://github.com/rust-lang/rust/commit/b2c51c24c96f8827eefc6f0de29636cc4cb6ff2c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b2c51c24c96f8827eefc6f0de29636cc4cb6ff2c/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e35698371d36da83d3aca8322ad812fa5512b90f", "url": "https://api.github.com/repos/rust-lang/rust/commits/e35698371d36da83d3aca8322ad812fa5512b90f", "html_url": "https://github.com/rust-lang/rust/commit/e35698371d36da83d3aca8322ad812fa5512b90f"}], "stats": {"total": 151, "additions": 147, "deletions": 4}, "files": [{"sha": "92efcf44dea3636ce1fcad46d89d0f48322056fc", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b2c51c24c96f8827eefc6f0de29636cc4cb6ff2c/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2c51c24c96f8827eefc6f0de29636cc4cb6ff2c/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=b2c51c24c96f8827eefc6f0de29636cc4cb6ff2c", "patch": "@@ -1917,6 +1917,15 @@ impl<'tcx> Place<'tcx> {\n         }\n     }\n \n+    /// If this place represents a local variable like `_X` with no\n+    /// projections, return `Some(_X)`.\n+    pub fn as_local(&self) -> Option<Local> {\n+        match self {\n+            Place { projection: box [], base: PlaceBase::Local(l) } => Some(*l),\n+            _ => None,\n+        }\n+    }\n+\n     pub fn as_ref(&self) -> PlaceRef<'_, 'tcx> {\n         PlaceRef {\n             base: &self.base,"}, {"sha": "30d53502b11ff1667a39db8a0858887b7c13e0ff", "filename": "src/librustc_mir/build/expr/into.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b2c51c24c96f8827eefc6f0de29636cc4cb6ff2c/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2c51c24c96f8827eefc6f0de29636cc4cb6ff2c/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs?ref=b2c51c24c96f8827eefc6f0de29636cc4cb6ff2c", "patch": "@@ -244,6 +244,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n                     let success = this.cfg.start_new_block();\n                     let cleanup = this.diverge_cleanup();\n+\n+                    this.record_operands_moved(&args);\n+\n                     this.cfg.terminate(\n                         block,\n                         source_info,"}, {"sha": "13d94262b6c5304ca4c9d4c2b41ef6360ea8ebf4", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 89, "deletions": 4, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/b2c51c24c96f8827eefc6f0de29636cc4cb6ff2c/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2c51c24c96f8827eefc6f0de29636cc4cb6ff2c/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=b2c51c24c96f8827eefc6f0de29636cc4cb6ff2c", "patch": "@@ -110,6 +110,8 @@ struct Scope {\n     /// end of the vector (top of the stack) first.\n     drops: Vec<DropData>,\n \n+    moved_locals: Vec<Local>,\n+\n     /// The cache for drop chain on \u201cnormal\u201d exit into a particular BasicBlock.\n     cached_exits: FxHashMap<(BasicBlock, region::Scope), BasicBlock>,\n \n@@ -159,7 +161,7 @@ struct CachedBlock {\n     generator_drop: Option<BasicBlock>,\n }\n \n-#[derive(Debug)]\n+#[derive(Debug, PartialEq, Eq)]\n pub(crate) enum DropKind {\n     Value,\n     Storage,\n@@ -280,6 +282,7 @@ impl<'tcx> Scopes<'tcx> {\n             region_scope: region_scope.0,\n             region_scope_span: region_scope.1.span,\n             drops: vec![],\n+            moved_locals: vec![],\n             cached_generator_drop: None,\n             cached_exits: Default::default(),\n             cached_unwind: CachedBlock::default(),\n@@ -484,7 +487,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             block,\n             unwind_to,\n             self.arg_count,\n-            false,\n+            false, // not generator\n+            false, // not unwind path\n         ));\n \n         block.unit()\n@@ -576,7 +580,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 block,\n                 unwind_to,\n                 self.arg_count,\n-                false,\n+                false, // not generator\n+                false, // not unwind path\n             ));\n \n             scope = next_scope;\n@@ -626,7 +631,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 block,\n                 unwind_to,\n                 self.arg_count,\n-                true,\n+                true, // is generator\n+                true, // is cached path\n             ));\n         }\n \n@@ -822,6 +828,75 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         span_bug!(span, \"region scope {:?} not in scope to drop {:?}\", region_scope, local);\n     }\n \n+    /// Indicates that the \"local operand\" stored in `local` is\n+    /// *moved* at some point during execution (see `local_scope` for\n+    /// more information about what a \"local operand\" is -- in short,\n+    /// it's an intermediate operand created as part of preparing some\n+    /// MIR instruction). We use this information to suppress\n+    /// redundant drops on the non-unwind paths. This results in less\n+    /// MIR, but also avoids spurious borrow check errors\n+    /// (c.f. #64391).\n+    ///\n+    /// Example: when compiling the call to `foo` here:\n+    ///\n+    /// ```rust\n+    /// foo(bar(), ...)\n+    /// ```\n+    ///\n+    /// we would evaluate `bar()` to an operand `_X`. We would also\n+    /// schedule `_X` to be dropped when the expression scope for\n+    /// `foo(bar())` is exited. This is relevant, for example, if the\n+    /// later arguments should unwind (it would ensure that `_X` gets\n+    /// dropped). However, if no unwind occurs, then `_X` will be\n+    /// unconditionally consumed by the `call`:\n+    ///\n+    /// ```\n+    /// bb {\n+    ///   ...\n+    ///   _R = CALL(foo, _X, ...)\n+    /// }\n+    /// ```\n+    ///\n+    /// However, `_X` is still registered to be dropped, and so if we\n+    /// do nothing else, we would generate a `DROP(_X)` that occurs\n+    /// after the call. This will later be optimized out by the\n+    /// drop-elaboation code, but in the meantime it can lead to\n+    /// spurious borrow-check errors -- the problem, ironically, is\n+    /// not the `DROP(_X)` itself, but the (spurious) unwind pathways\n+    /// that it creates. See #64391 for an example.\n+    pub fn record_operands_moved(\n+        &mut self,\n+        operands: &[Operand<'tcx>],\n+    ) {\n+        let scope = match self.local_scope() {\n+            None => {\n+                // if there is no local scope, operands won't be dropped anyway\n+                return;\n+            }\n+\n+            Some(local_scope) => {\n+                self.scopes.iter_mut().find(|scope| scope.region_scope == local_scope)\n+                    .unwrap_or_else(|| bug!(\"scope {:?} not found in scope list!\", local_scope))\n+            }\n+        };\n+\n+        // look for moves of a local variable, like `MOVE(_X)`\n+        let locals_moved = operands.iter().flat_map(|operand| match operand {\n+            Operand::Copy(_) | Operand::Constant(_) => None,\n+            Operand::Move(place) => place.as_local(),\n+        });\n+\n+        for local in locals_moved {\n+            // check if we have a Drop for this operand and -- if so\n+            // -- add it to the list of moved operands. Note that this\n+            // local might not have been an operand created for this\n+            // call, it could come from other places too.\n+            if scope.drops.iter().any(|drop| drop.local == local && drop.kind == DropKind::Value) {\n+                scope.moved_locals.push(local);\n+            }\n+        }\n+    }\n+\n     // Other\n     // =====\n     /// Branch based on a boolean condition.\n@@ -1020,6 +1095,7 @@ fn build_scope_drops<'tcx>(\n     last_unwind_to: BasicBlock,\n     arg_count: usize,\n     generator_drop: bool,\n+    is_cached_path: bool,\n ) -> BlockAnd<()> {\n     debug!(\"build_scope_drops({:?} -> {:?})\", block, scope);\n \n@@ -1046,6 +1122,15 @@ fn build_scope_drops<'tcx>(\n         let drop_data = &scope.drops[drop_idx];\n         let source_info = scope.source_info(drop_data.span);\n         let local = drop_data.local;\n+\n+        // If the operand has been moved, and we are not on an unwind\n+        // path, then don't generate the drop. (We only take this into\n+        // account for non-unwind paths so as not to disturb the\n+        // caching mechanism.)\n+        if !is_cached_path && scope.moved_locals.iter().any(|&o| o == local) {\n+            continue;\n+        }\n+\n         match drop_data.kind {\n             DropKind::Value => {\n                 let unwind_to = get_unwind_to(scope, is_generator, drop_idx, generator_drop)"}, {"sha": "528704c0e45c3981800146600a5e08cea743f4c4", "filename": "src/test/ui/async-await/issues/issue-64391-2.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b2c51c24c96f8827eefc6f0de29636cc4cb6ff2c/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-64391-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2c51c24c96f8827eefc6f0de29636cc4cb6ff2c/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-64391-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-64391-2.rs?ref=b2c51c24c96f8827eefc6f0de29636cc4cb6ff2c", "patch": "@@ -0,0 +1,17 @@\n+// Regression test for #64391\n+//\n+// As described on the issue, the (spurious) `DROP` inserted for the\n+// `\"\".to_string()` value was causing a (spurious) unwind path that\n+// led us to believe that the future might be dropped after `config`\n+// had been dropped. This cannot, in fact, happen.\n+\n+async fn connect() {\n+    let config = 666;\n+    connect2(&config, \"\".to_string()).await\n+}\n+\n+async fn connect2(_config: &u32, _tls: String) {\n+    unimplemented!()\n+}\n+\n+fn main() { }"}, {"sha": "ca819e78fb8cb51c9d4a9cbc4c75d7295ba9b1db", "filename": "src/test/ui/async-await/issues/issue-64433.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/b2c51c24c96f8827eefc6f0de29636cc4cb6ff2c/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-64433.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2c51c24c96f8827eefc6f0de29636cc4cb6ff2c/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-64433.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-64433.rs?ref=b2c51c24c96f8827eefc6f0de29636cc4cb6ff2c", "patch": "@@ -0,0 +1,29 @@\n+// Regression test for issue #64433.\n+//\n+// See issue-64391-2.rs for more details, as that was fixed by the\n+// same PR.\n+//\n+// check-pass\n+\n+#[derive(Debug)]\n+struct A<'a> {\n+    inner: Vec<&'a str>,\n+}\n+\n+struct B {}\n+\n+impl B {\n+    async fn something_with_a(&mut self, a: A<'_>) -> Result<(), String> {\n+        println!(\"{:?}\", a);\n+        Ok(())\n+    }\n+}\n+\n+async fn can_error(some_string: &str) -> Result<(), String> {\n+    let a = A { inner: vec![some_string, \"foo\"] };\n+    let mut b = B {};\n+    Ok(b.something_with_a(a).await.map(|_| ())?)\n+}\n+\n+fn main() {\n+}"}]}