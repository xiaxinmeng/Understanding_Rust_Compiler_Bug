{"sha": "3c60bc02ce6de2823d0b837f90d5db0077fce6f7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNjNjBiYzAyY2U2ZGUyODIzZDBiODM3ZjkwZDVkYjAwNzdmY2U2Zjc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-12-27T00:48:41Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-12-27T00:48:41Z"}, "message": "auto merge of #19254 : nick29581/rust/dxr-glob, r=pcwalton\n\nThere is also some work here to make resolve a bit more stable - it no longer overwrites a specific import with a glob import.\r\n\r\nr?", "tree": {"sha": "465805adb25fba470b8da95ff820a363f32a8dee", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/465805adb25fba470b8da95ff820a363f32a8dee"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3c60bc02ce6de2823d0b837f90d5db0077fce6f7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3c60bc02ce6de2823d0b837f90d5db0077fce6f7", "html_url": "https://github.com/rust-lang/rust/commit/3c60bc02ce6de2823d0b837f90d5db0077fce6f7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3c60bc02ce6de2823d0b837f90d5db0077fce6f7/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c06edbad34f2f8f2fa5138e855a442db1c6324d1", "url": "https://api.github.com/repos/rust-lang/rust/commits/c06edbad34f2f8f2fa5138e855a442db1c6324d1", "html_url": "https://github.com/rust-lang/rust/commit/c06edbad34f2f8f2fa5138e855a442db1c6324d1"}, {"sha": "4b92a5a229ebe7635851fc7bad94108f9de8dcc6", "url": "https://api.github.com/repos/rust-lang/rust/commits/4b92a5a229ebe7635851fc7bad94108f9de8dcc6", "html_url": "https://github.com/rust-lang/rust/commit/4b92a5a229ebe7635851fc7bad94108f9de8dcc6"}], "stats": {"total": 383, "additions": 286, "deletions": 97}, "files": [{"sha": "bccd2a1198a4bb00b11b8204ea51a2c6bc3af9cc", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3c60bc02ce6de2823d0b837f90d5db0077fce6f7/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c60bc02ce6de2823d0b837f90d5db0077fce6f7/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=3c60bc02ce6de2823d0b837f90d5db0077fce6f7", "patch": "@@ -3330,10 +3330,10 @@ mod tests {\n \n #[cfg(test)]\n mod bench {\n+    use super::*;\n     use prelude::*;\n     use test::Bencher;\n     use test::black_box;\n-    use super::*;\n \n     #[bench]\n     fn char_iterator(b: &mut Bencher) {"}, {"sha": "ddda2b38c223a20c5978706a70cef4cc5196fdd7", "filename": "src/libgraphviz/maybe_owned_vec.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3c60bc02ce6de2823d0b837f90d5db0077fce6f7/src%2Flibgraphviz%2Fmaybe_owned_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c60bc02ce6de2823d0b837f90d5db0077fce6f7/src%2Flibgraphviz%2Fmaybe_owned_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Fmaybe_owned_vec.rs?ref=3c60bc02ce6de2823d0b837f90d5db0077fce6f7", "patch": "@@ -14,7 +14,6 @@ pub use self::MaybeOwnedVector::*;\n \n use std::default::Default;\n use std::fmt;\n-use std::iter::FromIterator;\n use std::path::BytesContainer;\n use std::slice;\n "}, {"sha": "51cebbfb52c58ca80262f8d7f34e3e39f7812254", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3c60bc02ce6de2823d0b837f90d5db0077fce6f7/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c60bc02ce6de2823d0b837f90d5db0077fce6f7/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=3c60bc02ce6de2823d0b837f90d5db0077fce6f7", "patch": "@@ -146,6 +146,13 @@ pub fn get_impl_or_trait_item<'tcx>(tcx: &ty::ctxt<'tcx>, def: ast::DefId)\n                                     tcx)\n }\n \n+pub fn get_trait_name(cstore: &cstore::CStore, def: ast::DefId) -> ast::Name {\n+    let cdata = cstore.get_crate_data(def.krate);\n+    decoder::get_trait_name(cstore.intr.clone(),\n+                            &*cdata,\n+                            def.node)\n+}\n+\n pub fn get_trait_item_name_and_kind(cstore: &cstore::CStore, def: ast::DefId)\n                                     -> (ast::Name, def::TraitItemKind) {\n     let cdata = cstore.get_crate_data(def.krate);"}, {"sha": "ee928828827b7ab1935698d5fd933168adc1edd0", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3c60bc02ce6de2823d0b837f90d5db0077fce6f7/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c60bc02ce6de2823d0b837f90d5db0077fce6f7/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=3c60bc02ce6de2823d0b837f90d5db0077fce6f7", "patch": "@@ -781,6 +781,14 @@ pub fn get_impl_items(cdata: Cmd, impl_id: ast::NodeId)\n     impl_items\n }\n \n+pub fn get_trait_name(intr: Rc<IdentInterner>,\n+                      cdata: Cmd,\n+                      id: ast::NodeId)\n+                      -> ast::Name {\n+    let doc = lookup_item(id, cdata.data());\n+    item_name(&*intr, doc)\n+}\n+\n pub fn get_trait_item_name_and_kind(intr: Rc<IdentInterner>,\n                                     cdata: Cmd,\n                                     id: ast::NodeId)"}, {"sha": "c0d5d6b11cf7ea8d89462fbe6ecc7c48c85f1501", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3c60bc02ce6de2823d0b837f90d5db0077fce6f7/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c60bc02ce6de2823d0b837f90d5db0077fce6f7/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=3c60bc02ce6de2823d0b837f90d5db0077fce6f7", "patch": "@@ -77,7 +77,7 @@ use std::mem;\n use std::ops;\n use std::rc::Rc;\n use collections::enum_set::{EnumSet, CLike};\n-use std::collections::hash_map::HashMap;\n+use std::collections::{HashMap, HashSet};\n use std::collections::hash_map::Entry::{Occupied, Vacant};\n use syntax::abi;\n use syntax::ast::{CrateNum, DefId, DUMMY_NODE_ID, Ident, ItemTrait, LOCAL_CRATE};\n@@ -105,6 +105,7 @@ pub struct CrateAnalysis<'tcx> {\n     pub ty_cx: ty::ctxt<'tcx>,\n     pub reachable: NodeSet,\n     pub name: String,\n+    pub glob_map: Option<GlobMap>,\n }\n \n #[deriving(Copy, PartialEq, Eq, Hash)]\n@@ -6285,6 +6286,10 @@ pub type CaptureModeMap = NodeMap<ast::CaptureClause>;\n // Trait method resolution\n pub type TraitMap = NodeMap<Vec<DefId>>;\n \n+// Map from the NodeId of a glob import to a list of items which are actually\n+// imported.\n+pub type GlobMap = HashMap<NodeId, HashSet<Name>>;\n+\n pub fn with_freevars<T, F>(tcx: &ty::ctxt, fid: ast::NodeId, f: F) -> T where\n     F: FnOnce(&[Freevar]) -> T,\n {"}, {"sha": "046b9547cbbc597134ef0b32cb549f2e6c91067b", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3c60bc02ce6de2823d0b837f90d5db0077fce6f7/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c60bc02ce6de2823d0b837f90d5db0077fce6f7/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=3c60bc02ce6de2823d0b837f90d5db0077fce6f7", "patch": "@@ -19,8 +19,6 @@\n use self::UseError::*;\n \n use borrowck::*;\n-use borrowck::LoanPathElem::*;\n-use borrowck::LoanPathKind::*;\n use rustc::middle::expr_use_visitor as euv;\n use rustc::middle::mem_categorization as mc;\n use rustc::middle::region;"}, {"sha": "85cc691fb9db9e1a0a15dbf77fc2280e374ab4d5", "filename": "src/librustc_borrowck/borrowck/gather_loans/gather_moves.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3c60bc02ce6de2823d0b837f90d5db0077fce6f7/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c60bc02ce6de2823d0b837f90d5db0077fce6f7/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs?ref=3c60bc02ce6de2823d0b837f90d5db0077fce6f7", "patch": "@@ -11,7 +11,6 @@\n //! Computes moves.\n \n use borrowck::*;\n-use borrowck::LoanPathKind::*;\n use borrowck::gather_loans::move_error::MoveSpanAndPath;\n use borrowck::gather_loans::move_error::{MoveError, MoveErrorCollector};\n use borrowck::move_data::*;"}, {"sha": "c0e892cdd2798c094b0862fc887fb7787dd216c4", "filename": "src/librustc_borrowck/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3c60bc02ce6de2823d0b837f90d5db0077fce6f7/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c60bc02ce6de2823d0b837f90d5db0077fce6f7/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=3c60bc02ce6de2823d0b837f90d5db0077fce6f7", "patch": "@@ -17,7 +17,6 @@\n // sure that all of these loans are honored.\n \n use borrowck::*;\n-use borrowck::LoanPathKind::*;\n use borrowck::move_data::MoveData;\n use rustc::middle::expr_use_visitor as euv;\n use rustc::middle::mem_categorization as mc;"}, {"sha": "fc15c0eb4ec97ea869f02ea2381390d51d6e013d", "filename": "src/librustc_borrowck/borrowck/gather_loans/restrictions.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3c60bc02ce6de2823d0b837f90d5db0077fce6f7/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c60bc02ce6de2823d0b837f90d5db0077fce6f7/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Frestrictions.rs?ref=3c60bc02ce6de2823d0b837f90d5db0077fce6f7", "patch": "@@ -13,8 +13,6 @@\n pub use self::RestrictionResult::*;\n \n use borrowck::*;\n-use borrowck::LoanPathElem::*;\n-use borrowck::LoanPathKind::*;\n use rustc::middle::expr_use_visitor as euv;\n use rustc::middle::mem_categorization as mc;\n use rustc::middle::ty;"}, {"sha": "4ab5c19430b5c1e30466c2bf495e5f7b07d65e56", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/3c60bc02ce6de2823d0b837f90d5db0077fce6f7/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c60bc02ce6de2823d0b837f90d5db0077fce6f7/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=3c60bc02ce6de2823d0b837f90d5db0077fce6f7", "patch": "@@ -342,17 +342,27 @@ pub fn phase_3_run_analysis_passes<'tcx>(sess: Session,\n     let lang_items = time(time_passes, \"language item collection\", (), |_|\n                           middle::lang_items::collect_language_items(krate, &sess));\n \n+    let make_glob_map = if save_analysis(&sess) {\n+        resolve::MakeGlobMap::Yes\n+    } else {\n+        resolve::MakeGlobMap::No\n+    };\n     let resolve::CrateMap {\n         def_map,\n         freevars,\n         capture_mode_map,\n         export_map,\n         trait_map,\n         external_exports,\n-        last_private_map\n+        last_private_map,\n+        glob_map,\n     } =\n         time(time_passes, \"resolution\", (),\n-             |_| resolve::resolve_crate(&sess, &lang_items, krate));\n+             |_| resolve::resolve_crate(&sess,\n+                                        &ast_map,\n+                                        &lang_items,\n+                                        krate,\n+                                        make_glob_map));\n \n     // Discard MTWT tables that aren't required past resolution.\n     syntax::ext::mtwt::clear_tables();\n@@ -454,14 +464,19 @@ pub fn phase_3_run_analysis_passes<'tcx>(sess: Session,\n         public_items: public_items,\n         reachable: reachable_map,\n         name: name,\n+        glob_map: glob_map,\n     }\n }\n \n+fn save_analysis(sess: &Session) -> bool {\n+    (sess.opts.debugging_opts & config::SAVE_ANALYSIS) != 0\n+}\n+\n pub fn phase_save_analysis(sess: &Session,\n                            krate: &ast::Crate,\n                            analysis: &ty::CrateAnalysis,\n                            odir: &Option<Path>) {\n-    if (sess.opts.debugging_opts & config::SAVE_ANALYSIS) == 0 {\n+    if !save_analysis(sess) {\n         return;\n     }\n     time(sess.time_passes(), \"save analysis\", krate, |krate|"}, {"sha": "1ef1486dd54d25b70fed7e2febead7013bc6c73a", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3c60bc02ce6de2823d0b837f90d5db0077fce6f7/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c60bc02ce6de2823d0b837f90d5db0077fce6f7/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=3c60bc02ce6de2823d0b837f90d5db0077fce6f7", "patch": "@@ -123,7 +123,7 @@ fn test_env<F>(source_string: &str,\n     // run just enough stuff to build a tcx:\n     let lang_items = lang_items::collect_language_items(krate, &sess);\n     let resolve::CrateMap { def_map, freevars, capture_mode_map, .. } =\n-        resolve::resolve_crate(&sess, &lang_items, krate);\n+        resolve::resolve_crate(&sess, &ast_map, &lang_items, krate, resolve::MakeGlobMap::No);\n     let named_region_map = resolve_lifetime::krate(&sess, krate, &def_map);\n     let region_map = region::resolve_crate(&sess, krate);\n     let stability_index = stability::Index::build(krate);"}, {"sha": "78527315199ca3d044c40743789cdafeb51d1dd3", "filename": "src/librustc_resolve/check_unused.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3c60bc02ce6de2823d0b837f90d5db0077fce6f7/src%2Flibrustc_resolve%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c60bc02ce6de2823d0b837f90d5db0077fce6f7/src%2Flibrustc_resolve%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fcheck_unused.rs?ref=3c60bc02ce6de2823d0b837f90d5db0077fce6f7", "patch": "@@ -28,24 +28,24 @@ use syntax::ast::{ViewPathGlob, ViewPathList, ViewPathSimple};\n use syntax::codemap::{Span, DUMMY_SP};\n use syntax::visit::{mod, Visitor};\n \n-struct UnusedImportCheckVisitor<'a, 'b:'a> {\n-    resolver: &'a mut Resolver<'b>\n+struct UnusedImportCheckVisitor<'a, 'b:'a, 'tcx:'b> {\n+    resolver: &'a mut Resolver<'b, 'tcx>\n }\n \n // Deref and DerefMut impls allow treating UnusedImportCheckVisitor as Resolver.\n-impl<'a, 'b> Deref<Resolver<'b>> for UnusedImportCheckVisitor<'a, 'b> {\n-    fn deref<'c>(&'c self) -> &'c Resolver<'b> {\n+impl<'a, 'b, 'tcx:'b> Deref<Resolver<'b, 'tcx>> for UnusedImportCheckVisitor<'a, 'b, 'tcx> {\n+    fn deref<'c>(&'c self) -> &'c Resolver<'b, 'tcx> {\n         &*self.resolver\n     }\n }\n \n-impl<'a, 'b> DerefMut<Resolver<'b>> for UnusedImportCheckVisitor<'a, 'b> {\n-    fn deref_mut<'c>(&'c mut self) -> &'c mut Resolver<'b> {\n+impl<'a, 'b, 'tcx:'b> DerefMut<Resolver<'b, 'tcx>> for UnusedImportCheckVisitor<'a, 'b, 'tcx> {\n+    fn deref_mut<'c>(&'c mut self) -> &'c mut Resolver<'b, 'tcx> {\n         &mut *self.resolver\n     }\n }\n \n-impl<'a, 'b> UnusedImportCheckVisitor<'a, 'b> {\n+impl<'a, 'b, 'tcx> UnusedImportCheckVisitor<'a, 'b, 'tcx> {\n     // We have information about whether `use` (import) directives are actually used now.\n     // If an import is not used at all, we signal a lint error. If an import is only used\n     // for a single namespace, we remove the other namespace from the recorded privacy\n@@ -104,7 +104,7 @@ impl<'a, 'b> UnusedImportCheckVisitor<'a, 'b> {\n     }\n }\n \n-impl<'a, 'b, 'v> Visitor<'v> for UnusedImportCheckVisitor<'a, 'b> {\n+impl<'a, 'b, 'v, 'tcx> Visitor<'v> for UnusedImportCheckVisitor<'a, 'b, 'tcx> {\n     fn visit_view_item(&mut self, vi: &ViewItem) {\n         // Ignore is_public import statements because there's no way to be sure\n         // whether they're used or not. Also ignore imports with a dummy span"}, {"sha": "720883a8e9a5432ed5ecc842c6bd96253e6ef08e", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 164, "deletions": 51, "changes": 215, "blob_url": "https://github.com/rust-lang/rust/blob/3c60bc02ce6de2823d0b837f90d5db0077fce6f7/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c60bc02ce6de2823d0b837f90d5db0077fce6f7/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=3c60bc02ce6de2823d0b837f90d5db0077fce6f7", "patch": "@@ -55,7 +55,7 @@ use rustc::middle::lang_items::LanguageItems;\n use rustc::middle::pat_util::pat_bindings;\n use rustc::middle::privacy::*;\n use rustc::middle::subst::{ParamSpace, FnSpace, TypeSpace};\n-use rustc::middle::ty::{CaptureModeMap, Freevar, FreevarMap, TraitMap};\n+use rustc::middle::ty::{CaptureModeMap, Freevar, FreevarMap, TraitMap, GlobMap};\n use rustc::util::nodemap::{NodeMap, NodeSet, DefIdSet, FnvHashMap};\n use rustc::util::lev_distance::lev_distance;\n \n@@ -66,7 +66,7 @@ use syntax::ast::{ExprPath, ExprStruct, FnDecl};\n use syntax::ast::{ForeignItem, ForeignItemFn, ForeignItemStatic, Generics};\n use syntax::ast::{Ident, ImplItem, Item, ItemConst, ItemEnum, ItemFn};\n use syntax::ast::{ItemForeignMod, ItemImpl, ItemMac, ItemMod, ItemStatic};\n-use syntax::ast::{ItemStruct, ItemTrait, ItemTy, Local};\n+use syntax::ast::{ItemStruct, ItemTrait, ItemTy, Local, LOCAL_CRATE};\n use syntax::ast::{MethodImplItem, Mod, Name, NamedField, NodeId};\n use syntax::ast::{Pat, PatEnum, PatIdent, PatLit};\n use syntax::ast::{PatRange, PatStruct, Path, PathListIdent, PathListMod};\n@@ -82,6 +82,7 @@ use syntax::ast::{Variant, ViewItem, ViewItemExternCrate};\n use syntax::ast::{ViewItemUse, ViewPathGlob, ViewPathList, ViewPathSimple};\n use syntax::ast::{Visibility};\n use syntax::ast;\n+use syntax::ast_map;\n use syntax::ast_util::{mod, PostExpansionMethod, local_def, walk_pat};\n use syntax::attr::AttrMetaMethods;\n use syntax::ext::mtwt;\n@@ -168,7 +169,7 @@ enum NameDefinition {\n     ImportNameDefinition(Def, LastPrivate) //< The name identifies an import.\n }\n \n-impl<'a, 'v> Visitor<'v> for Resolver<'a> {\n+impl<'a, 'v, 'tcx> Visitor<'v> for Resolver<'a, 'tcx> {\n     fn visit_item(&mut self, item: &Item) {\n         self.resolve_item(item);\n     }\n@@ -340,14 +341,24 @@ impl Rib {\n     }\n }\n \n+/// Whether an import can be shadowed by another import.\n+#[deriving(Show,PartialEq,Clone,Copy)]\n+enum Shadowable {\n+    Always,\n+    /// Means that the recorded import obeys the glob shadowing rules, i.e., can\n+    /// only be shadowed by another glob import.\n+    Glob,\n+    Never\n+}\n+\n /// One import directive.\n struct ImportDirective {\n     module_path: Vec<Name>,\n     subclass: ImportDirectiveSubclass,\n     span: Span,\n     id: NodeId,\n     is_public: bool, // see note in ImportResolution about how to use this\n-    shadowable: bool,\n+    shadowable: Shadowable,\n }\n \n impl ImportDirective {\n@@ -356,7 +367,7 @@ impl ImportDirective {\n            span: Span,\n            id: NodeId,\n            is_public: bool,\n-           shadowable: bool)\n+           shadowable: Shadowable)\n            -> ImportDirective {\n         ImportDirective {\n             module_path: module_path,\n@@ -374,13 +385,13 @@ impl ImportDirective {\n struct Target {\n     target_module: Rc<Module>,\n     bindings: Rc<NameBindings>,\n-    shadowable: bool,\n+    shadowable: Shadowable,\n }\n \n impl Target {\n     fn new(target_module: Rc<Module>,\n            bindings: Rc<NameBindings>,\n-           shadowable: bool)\n+           shadowable: Shadowable)\n            -> Target {\n         Target {\n             target_module: target_module,\n@@ -442,6 +453,15 @@ impl ImportResolution {\n             ValueNS => self.value_id,\n         }\n     }\n+\n+    fn shadowable(&self, namespace: Namespace) -> Shadowable {\n+        let target = self.target_for_namespace(namespace);\n+        if target.is_none() {\n+            return Shadowable::Always;\n+        }\n+\n+        target.unwrap().shadowable\n+    }\n }\n \n /// The link from a module up to its nearest parent node.\n@@ -842,9 +862,11 @@ fn namespace_error_to_string(ns: NamespaceError) -> &'static str {\n }\n \n /// The main resolver class.\n-struct Resolver<'a> {\n+struct Resolver<'a, 'tcx:'a> {\n     session: &'a Session,\n \n+    ast_map: &'a ast_map::Map<'tcx>,\n+\n     graph_root: NameBindings,\n \n     trait_item_map: FnvHashMap<(Name, DefId), TraitItemKind>,\n@@ -895,16 +917,21 @@ struct Resolver<'a> {\n     // so as to avoid printing duplicate errors\n     emit_errors: bool,\n \n+    make_glob_map: bool,\n+    // Maps imports to the names of items actually imported (this actually maps\n+    // all imports, but only glob imports are actually interesting).\n+    glob_map: GlobMap,\n+\n     used_imports: HashSet<(NodeId, Namespace)>,\n     used_crates: HashSet<CrateNum>,\n }\n \n-struct BuildReducedGraphVisitor<'a, 'b:'a> {\n-    resolver: &'a mut Resolver<'b>,\n+struct BuildReducedGraphVisitor<'a, 'b:'a, 'tcx:'b> {\n+    resolver: &'a mut Resolver<'b, 'tcx>,\n     parent: ReducedGraphParent\n }\n \n-impl<'a, 'b, 'v> Visitor<'v> for BuildReducedGraphVisitor<'a, 'b> {\n+impl<'a, 'b, 'v, 'tcx> Visitor<'v> for BuildReducedGraphVisitor<'a, 'b, 'tcx> {\n \n     fn visit_item(&mut self, item: &Item) {\n         let p = self.resolver.build_reduced_graph_for_item(item, self.parent.clone());\n@@ -946,8 +973,11 @@ enum FallbackChecks {\n }\n \n \n-impl<'a> Resolver<'a> {\n-    fn new(session: &'a Session, crate_span: Span) -> Resolver<'a> {\n+impl<'a, 'tcx> Resolver<'a, 'tcx> {\n+    fn new(session: &'a Session,\n+           ast_map: &'a ast_map::Map<'tcx>,\n+           crate_span: Span,\n+           make_glob_map: MakeGlobMap) -> Resolver<'a, 'tcx> {\n         let graph_root = NameBindings::new();\n \n         graph_root.define_module(NoParentLink,\n@@ -962,6 +992,8 @@ impl<'a> Resolver<'a> {\n         Resolver {\n             session: session,\n \n+            ast_map: ast_map,\n+\n             // The outermost module has def ID 0; this is not reflected in the\n             // AST.\n \n@@ -997,6 +1029,8 @@ impl<'a> Resolver<'a> {\n             last_private: NodeMap::new(),\n \n             emit_errors: true,\n+            make_glob_map: make_glob_map == MakeGlobMap::Yes,\n+            glob_map: HashMap::new(),\n         }\n     }\n \n@@ -1610,6 +1644,11 @@ impl<'a> Resolver<'a> {\n                                  attr.name() == token::get_name(\n                                     special_idents::prelude_import.name)\n                              });\n+                let shadowable = if shadowable {\n+                    Shadowable::Always\n+                } else {\n+                    Shadowable::Never\n+                };\n \n                 match view_path.node {\n                     ViewPathSimple(binding, ref full_path, id) => {\n@@ -1680,7 +1719,11 @@ impl<'a> Resolver<'a> {\n                                                     view_path.span,\n                                                     id,\n                                                     is_public,\n-                                                    shadowable);\n+                                                    if shadowable == Shadowable::Never {\n+                                                        Shadowable::Glob\n+                                                    } else {\n+                                                        shadowable\n+                                                    });\n                     }\n                 }\n             }\n@@ -2131,7 +2174,7 @@ impl<'a> Resolver<'a> {\n                               span: Span,\n                               id: NodeId,\n                               is_public: bool,\n-                              shadowable: bool) {\n+                              shadowable: Shadowable) {\n         module_.imports.borrow_mut().push(ImportDirective::new(module_path,\n                                                                subclass,\n                                                                span,\n@@ -2326,6 +2369,29 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n+    #[inline]\n+    fn record_import_use(&mut self, import_id: NodeId, name: Name) {\n+        if !self.make_glob_map {\n+            return;\n+        }\n+        if self.glob_map.contains_key(&import_id) {\n+            self.glob_map[import_id].insert(name);\n+            return;\n+        }\n+\n+        let mut new_set = HashSet::new();\n+        new_set.insert(name);\n+        self.glob_map.insert(import_id, new_set);\n+    }\n+\n+    fn get_trait_name(&self, did: DefId) -> Name {\n+        if did.krate == LOCAL_CRATE {\n+            self.ast_map.expect_item(did.node).ident.name\n+        } else {\n+            csearch::get_trait_name(&self.session.cstore, did)\n+        }\n+    }\n+\n     /// Attempts to resolve the given import. The return value indicates\n     /// failure if we're certain the name does not exist, indeterminate if we\n     /// don't know whether the name exists at the moment due to other\n@@ -2338,8 +2404,7 @@ impl<'a> Resolver<'a> {\n         let mut resolution_result = Failed(None);\n         let module_path = &import_directive.module_path;\n \n-        debug!(\"(resolving import for module) resolving import `{}::...` in \\\n-                `{}`\",\n+        debug!(\"(resolving import for module) resolving import `{}::...` in `{}`\",\n                self.names_to_string(module_path[]),\n                self.module_to_string(&*module_));\n \n@@ -2526,7 +2591,8 @@ impl<'a> Resolver<'a> {\n \n                         fn get_binding(this: &mut Resolver,\n                                        import_resolution: &ImportResolution,\n-                                       namespace: Namespace)\n+                                       namespace: Namespace,\n+                                       source: &Name)\n                                     -> NamespaceResult {\n \n                             // Import resolutions must be declared with \"pub\"\n@@ -2550,6 +2616,7 @@ impl<'a> Resolver<'a> {\n                                     let id = import_resolution.id(namespace);\n                                     // track used imports and extern crates as well\n                                     this.used_imports.insert((id, namespace));\n+                                    this.record_import_use(id, *source);\n                                     match target_module.def_id.get() {\n                                         Some(DefId{krate: kid, ..}) => {\n                                             this.used_crates.insert(kid);\n@@ -2564,13 +2631,17 @@ impl<'a> Resolver<'a> {\n                         // The name is an import which has been fully\n                         // resolved. We can, therefore, just follow it.\n                         if value_result.is_unknown() {\n-                            value_result = get_binding(self, import_resolution,\n-                                                       ValueNS);\n+                            value_result = get_binding(self,\n+                                                       import_resolution,\n+                                                       ValueNS,\n+                                                       &source);\n                             value_used_reexport = import_resolution.is_public;\n                         }\n                         if type_result.is_unknown() {\n-                            type_result = get_binding(self, import_resolution,\n-                                                      TypeNS);\n+                            type_result = get_binding(self,\n+                                                      import_resolution,\n+                                                      TypeNS,\n+                                                      &source);\n                             type_used_reexport = import_resolution.is_public;\n                         }\n \n@@ -2752,7 +2823,7 @@ impl<'a> Resolver<'a> {\n         return Success(());\n     }\n \n-    // Resolves a glob import. Note that this function cannot panic; it either\n+    // Resolves a glob import. Note that this function cannot fail; it either\n     // succeeds or bails out (as importing * from an empty module or a module\n     // that exports nothing is valid).\n     fn resolve_glob_import(&mut self,\n@@ -2883,7 +2954,9 @@ impl<'a> Resolver<'a> {\n \n         let mut import_resolutions = module_.import_resolutions.borrow_mut();\n         let dest_import_resolution = match import_resolutions.entry(name) {\n-            Occupied(entry) => entry.into_mut(),\n+            Occupied(entry) => {\n+                entry.into_mut()\n+            }\n             Vacant(entry) => {\n                 // Create a new import resolution from this child.\n                 entry.set(ImportResolution::new(id, is_public))\n@@ -2899,19 +2972,33 @@ impl<'a> Resolver<'a> {\n         // Merge the child item into the import resolution.\n         if name_bindings.defined_in_namespace_with(ValueNS, IMPORTABLE | PUBLIC) {\n             debug!(\"(resolving glob import) ... for value target\");\n-            dest_import_resolution.value_target =\n-                Some(Target::new(containing_module.clone(),\n-                                 name_bindings.clone(),\n-                                 import_directive.shadowable));\n-            dest_import_resolution.value_id = id;\n+            if dest_import_resolution.shadowable(ValueNS) == Shadowable::Never {\n+                let msg = format!(\"a value named `{}` has already been imported \\\n+                                   in this module\",\n+                                  token::get_name(name).get());\n+                self.session.span_err(import_directive.span, msg.as_slice());\n+            } else {\n+                dest_import_resolution.value_target =\n+                    Some(Target::new(containing_module.clone(),\n+                                     name_bindings.clone(),\n+                                     import_directive.shadowable));\n+                dest_import_resolution.value_id = id;\n+            }\n         }\n         if name_bindings.defined_in_namespace_with(TypeNS, IMPORTABLE | PUBLIC) {\n             debug!(\"(resolving glob import) ... for type target\");\n-            dest_import_resolution.type_target =\n-                Some(Target::new(containing_module,\n-                                 name_bindings.clone(),\n-                                 import_directive.shadowable));\n-            dest_import_resolution.type_id = id;\n+            if dest_import_resolution.shadowable(TypeNS) == Shadowable::Never {\n+                let msg = format!(\"a type named `{}` has already been imported \\\n+                                   in this module\",\n+                                  token::get_name(name).get());\n+                self.session.span_err(import_directive.span, msg.as_slice());\n+            } else {\n+                dest_import_resolution.type_target =\n+                    Some(Target::new(containing_module,\n+                                     name_bindings.clone(),\n+                                     import_directive.shadowable));\n+                dest_import_resolution.type_id = id;\n+            }\n         }\n         dest_import_resolution.is_public = is_public;\n \n@@ -2933,7 +3020,7 @@ impl<'a> Resolver<'a> {\n         }\n \n         match *target {\n-            Some(ref target) if !target.shadowable => {\n+            Some(ref target) if target.shadowable != Shadowable::Always => {\n                 let msg = format!(\"a {} named `{}` has already been imported \\\n                                    in this module\",\n                                   match namespace {\n@@ -2976,7 +3063,7 @@ impl<'a> Resolver<'a> {\n                  .borrow()\n                  .contains_key(&name) {\n             match import_resolution.type_target {\n-                Some(ref target) if !target.shadowable => {\n+                Some(ref target) if target.shadowable != Shadowable::Always => {\n                     let msg = format!(\"import `{0}` conflicts with imported \\\n                                        crate in this module \\\n                                        (maybe you meant `use {0}::*`?)\",\n@@ -2998,7 +3085,7 @@ impl<'a> Resolver<'a> {\n         };\n \n         match import_resolution.value_target {\n-            Some(ref target) if !target.shadowable => {\n+            Some(ref target) if target.shadowable != Shadowable::Always => {\n                 if let Some(ref value) = *name_bindings.value_def.borrow() {\n                     let msg = format!(\"import `{}` conflicts with value \\\n                                        in this module\",\n@@ -3014,7 +3101,7 @@ impl<'a> Resolver<'a> {\n         }\n \n         match import_resolution.type_target {\n-            Some(ref target) if !target.shadowable => {\n+            Some(ref target) if target.shadowable != Shadowable::Always => {\n                 if let Some(ref ty) = *name_bindings.type_def.borrow() {\n                     match ty.module_def {\n                         None => {\n@@ -3347,7 +3434,7 @@ impl<'a> Resolver<'a> {\n                 debug!(\"top name bindings succeeded\");\n                 return Success((Target::new(module_.clone(),\n                                             name_bindings.clone(),\n-                                            false),\n+                                            Shadowable::Never),\n                                false));\n             }\n             Some(_) | None => { /* Not found; continue. */ }\n@@ -3369,9 +3456,11 @@ impl<'a> Resolver<'a> {\n                     debug!(\"(resolving item in lexical scope) using \\\n                             import resolution\");\n                     // track used imports and extern crates as well\n-                    self.used_imports.insert((import_resolution.id(namespace), namespace));\n+                    let id = import_resolution.id(namespace);\n+                    self.used_imports.insert((id, namespace));\n+                    self.record_import_use(id, name);\n                     if let Some(DefId{krate: kid, ..}) = target.target_module.def_id.get() {\n-                        self.used_crates.insert(kid);\n+                         self.used_crates.insert(kid);\n                     }\n                     return Success((target, false));\n                 }\n@@ -3384,7 +3473,9 @@ impl<'a> Resolver<'a> {\n                 let name_bindings =\n                     Rc::new(Resolver::create_name_bindings_from_module(module));\n                 debug!(\"lower name bindings succeeded\");\n-                return Success((Target::new(module_, name_bindings, false),\n+                return Success((Target::new(module_,\n+                                            name_bindings,\n+                                            Shadowable::Never),\n                                 false));\n             }\n         }\n@@ -3608,7 +3699,7 @@ impl<'a> Resolver<'a> {\n                 debug!(\"(resolving name in module) found node as child\");\n                 return Success((Target::new(module_.clone(),\n                                             name_bindings.clone(),\n-                                            false),\n+                                            Shadowable::Never),\n                                false));\n             }\n             Some(_) | None => {\n@@ -3645,7 +3736,9 @@ impl<'a> Resolver<'a> {\n                         debug!(\"(resolving name in module) resolved to \\\n                                 import\");\n                         // track used imports and extern crates as well\n-                        self.used_imports.insert((import_resolution.id(namespace), namespace));\n+                        let id = import_resolution.id(namespace);\n+                        self.used_imports.insert((id, namespace));\n+                        self.record_import_use(id, name);\n                         if let Some(DefId{krate: kid, ..}) = target.target_module.def_id.get() {\n                             self.used_crates.insert(kid);\n                         }\n@@ -3661,7 +3754,9 @@ impl<'a> Resolver<'a> {\n             if let Some(module) = module_.external_module_children.borrow().get(&name).cloned() {\n                 let name_bindings =\n                     Rc::new(Resolver::create_name_bindings_from_module(module));\n-                return Success((Target::new(module_, name_bindings, false),\n+                return Success((Target::new(module_,\n+                                            name_bindings,\n+                                            Shadowable::Never),\n                                 false));\n             }\n         }\n@@ -5171,6 +5266,7 @@ impl<'a> Resolver<'a> {\n                             let id = import_resolution.id(namespace);\n                             // track imports and extern crates as well\n                             self.used_imports.insert((id, namespace));\n+                            self.record_import_use(id, name);\n                             match target.target_module.def_id.get() {\n                                 Some(DefId{krate: kid, ..}) => {\n                                     self.used_crates.insert(kid);\n@@ -5859,7 +5955,10 @@ impl<'a> Resolver<'a> {\n                 };\n                 if self.trait_item_map.contains_key(&(name, did)) {\n                     add_trait_info(&mut found_traits, did, name);\n-                    self.used_imports.insert((import.type_id, TypeNS));\n+                    let id = import.type_id;\n+                    self.used_imports.insert((id, TypeNS));\n+                    let trait_name = self.get_trait_name(did);\n+                    self.record_import_use(id, trait_name);\n                     if let Some(DefId{krate: kid, ..}) = target.target_module.def_id.get() {\n                         self.used_crates.insert(kid);\n                     }\n@@ -5993,14 +6092,23 @@ pub struct CrateMap {\n     pub trait_map: TraitMap,\n     pub external_exports: ExternalExports,\n     pub last_private_map: LastPrivateMap,\n+    pub glob_map: Option<GlobMap>\n+}\n+\n+#[deriving(PartialEq,Copy)]\n+pub enum MakeGlobMap {\n+    Yes,\n+    No\n }\n \n /// Entry point to crate resolution.\n-pub fn resolve_crate(session: &Session,\n-                     _: &LanguageItems,\n-                     krate: &Crate)\n-                  -> CrateMap {\n-    let mut resolver = Resolver::new(session, krate.span);\n+pub fn resolve_crate<'a, 'tcx>(session: &'a Session,\n+                               ast_map: &'a ast_map::Map<'tcx>,\n+                               _: &LanguageItems,\n+                               krate: &Crate,\n+                               make_glob_map: MakeGlobMap)\n+                               -> CrateMap {\n+    let mut resolver = Resolver::new(session, ast_map, krate.span, make_glob_map);\n \n     resolver.build_reduced_graph(krate);\n     session.abort_if_errors();\n@@ -6024,5 +6132,10 @@ pub fn resolve_crate(session: &Session,\n         trait_map: resolver.trait_map,\n         external_exports: resolver.external_exports,\n         last_private_map: resolver.last_private,\n+        glob_map: if resolver.make_glob_map {\n+                        Some(resolver.glob_map)\n+                    } else {\n+                        None\n+                    },\n     }\n }"}, {"sha": "80659152f9fc77450dafbae2a5cb26cb4f74b307", "filename": "src/librustc_resolve/record_exports.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3c60bc02ce6de2823d0b837f90d5db0077fce6f7/src%2Flibrustc_resolve%2Frecord_exports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c60bc02ce6de2823d0b837f90d5db0077fce6f7/src%2Flibrustc_resolve%2Frecord_exports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Frecord_exports.rs?ref=3c60bc02ce6de2823d0b837f90d5db0077fce6f7", "patch": "@@ -27,24 +27,24 @@ use syntax::parse::token;\n \n use std::rc::Rc;\n \n-struct ExportRecorder<'a, 'b:'a> {\n-    resolver: &'a mut Resolver<'b>\n+struct ExportRecorder<'a, 'b:'a, 'tcx:'b> {\n+    resolver: &'a mut Resolver<'b, 'tcx>\n }\n \n // Deref and DerefMut impls allow treating ExportRecorder as Resolver.\n-impl<'a, 'b> Deref<Resolver<'b>> for ExportRecorder<'a, 'b> {\n-    fn deref<'c>(&'c self) -> &'c Resolver<'b> {\n+impl<'a, 'b, 'tcx:'b> Deref<Resolver<'b, 'tcx>> for ExportRecorder<'a, 'b, 'tcx> {\n+    fn deref<'c>(&'c self) -> &'c Resolver<'b, 'tcx> {\n         &*self.resolver\n     }\n }\n \n-impl<'a, 'b> DerefMut<Resolver<'b>> for ExportRecorder<'a, 'b> {\n-    fn deref_mut<'c>(&'c mut self) -> &'c mut Resolver<'b> {\n+impl<'a, 'b, 'tcx:'b> DerefMut<Resolver<'b, 'tcx>> for ExportRecorder<'a, 'b, 'tcx> {\n+    fn deref_mut<'c>(&'c mut self) -> &'c mut Resolver<'b, 'tcx> {\n         &mut *self.resolver\n     }\n }\n \n-impl<'a, 'b> ExportRecorder<'a, 'b> {\n+impl<'a, 'b, 'tcx> ExportRecorder<'a, 'b, 'tcx> {\n     fn record_exports_for_module_subtree(&mut self,\n                                          module_: Rc<Module>) {\n         // If this isn't a local krate, then bail out. We don't need to record"}, {"sha": "f491bc84b62c476d158e71bc714d2c691b23ed27", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/3c60bc02ce6de2823d0b837f90d5db0077fce6f7/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c60bc02ce6de2823d0b837f90d5db0077fce6f7/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=3c60bc02ce6de2823d0b837f90d5db0077fce6f7", "patch": "@@ -1197,7 +1197,28 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                                                self.cur_scope);\n                         self.write_sub_paths_truncated(path);\n                     }\n-                    ast::ViewPathGlob(ref path, _) => {\n+                    ast::ViewPathGlob(ref path, id) => {\n+                        // Make a comma-separated list of names of imported modules.\n+                        let mut name_string = String::new();\n+                        let glob_map = &self.analysis.glob_map;\n+                        let glob_map = glob_map.as_ref().unwrap();\n+                        if glob_map.contains_key(&id) {\n+                            let names = glob_map.index(&id);\n+                            for n in names.iter() {\n+                                if name_string.len() > 0 {\n+                                    name_string.push_str(\", \");\n+                                }\n+                                name_string.push_str(n.as_str());\n+                            }\n+                        }\n+\n+                        let sub_span = self.span.sub_span_of_token(path.span,\n+                                                                   token::BinOp(token::Star));\n+                        self.fmt.use_glob_str(path.span,\n+                                              sub_span,\n+                                              id,\n+                                              name_string.as_slice(),\n+                                              self.cur_scope);\n                         self.write_sub_paths(path);\n                     }\n                     ast::ViewPathList(ref path, ref list, _) => {\n@@ -1482,6 +1503,7 @@ pub fn process_crate(sess: &Session,\n         return;\n     }\n \n+    assert!(analysis.glob_map.is_some());\n     let cratename = match attr::find_crate_name(krate.attrs[]) {\n         Some(name) => name.get().to_string(),\n         None => {"}, {"sha": "b2dd9218f1797333420281fc6f6e7eabcac3f5eb", "filename": "src/librustc_trans/save/recorder.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3c60bc02ce6de2823d0b837f90d5db0077fce6f7/src%2Flibrustc_trans%2Fsave%2Frecorder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c60bc02ce6de2823d0b837f90d5db0077fce6f7/src%2Flibrustc_trans%2Fsave%2Frecorder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Frecorder.rs?ref=3c60bc02ce6de2823d0b837f90d5db0077fce6f7", "patch": "@@ -74,6 +74,7 @@ pub enum Row {\n     Impl,\n     Module,\n     UseAlias,\n+    UseGlob,\n     ExternCrate,\n     Inheritance,\n     MethodCall,\n@@ -125,6 +126,7 @@ impl<'a> FmtStrs<'a> {\n             UseAlias => (\"use_alias\",\n                          vec!(\"id\",\"refid\",\"refidcrate\",\"name\",\"scopeid\"),\n                          true, true),\n+            UseGlob => (\"use_glob\", vec!(\"id\",\"value\",\"scopeid\"), true, true),\n             ExternCrate => (\"extern_crate\",\n                             vec!(\"id\",\"name\",\"location\",\"crate\",\"scopeid\"),\n                             true, true),\n@@ -480,6 +482,18 @@ impl<'a> FmtStrs<'a> {\n                               svec!(id, mod_node, mod_crate, name, parent));\n     }\n \n+    pub fn use_glob_str(&mut self,\n+                        span: Span,\n+                        sub_span: Option<Span>,\n+                        id: NodeId,\n+                        values: &str,\n+                        parent: NodeId) {\n+        self.check_and_record(UseGlob,\n+                              span,\n+                              sub_span,\n+                              svec!(id, values, parent));\n+    }\n+\n     pub fn extern_crate_str(&mut self,\n                           span: Span,\n                           sub_span: Option<Span>,"}, {"sha": "e9d862d3781bbf47b21c72f3233667ebf820ae6a", "filename": "src/librustc_trans/save/span_utils.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3c60bc02ce6de2823d0b837f90d5db0077fce6f7/src%2Flibrustc_trans%2Fsave%2Fspan_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c60bc02ce6de2823d0b837f90d5db0077fce6f7/src%2Flibrustc_trans%2Fsave%2Fspan_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fspan_utils.rs?ref=3c60bc02ce6de2823d0b837f90d5db0077fce6f7", "patch": "@@ -280,6 +280,19 @@ impl<'a> SpanUtils<'a> {\n         }\n     }\n \n+    pub fn sub_span_of_token(&self, span: Span, tok: Token) -> Option<Span> {\n+        let mut toks = self.retokenise_span(span);\n+        loop {\n+            let next = toks.real_token();\n+            if next.tok == token::Eof {\n+                return None;\n+            }\n+            if next.tok == tok {\n+                return self.make_sub_span(span, Some(next.sp));\n+            }\n+        }\n+    }\n+\n     pub fn sub_span_after_keyword(&self,\n                               span: Span,\n                               keyword: keywords::Keyword) -> Option<Span> {"}, {"sha": "4b1b92b552cec577f9dea057972c2efd1f03f0f0", "filename": "src/librustc_trans/trans/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3c60bc02ce6de2823d0b837f90d5db0077fce6f7/src%2Flibrustc_trans%2Ftrans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c60bc02ce6de2823d0b837f90d5db0077fce6f7/src%2Flibrustc_trans%2Ftrans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmod.rs?ref=3c60bc02ce6de2823d0b837f90d5db0077fce6f7", "patch": "@@ -69,4 +69,3 @@ pub struct CrateTranslation {\n     pub crate_formats: dependency_format::Dependencies,\n     pub no_builtins: bool,\n }\n-"}, {"sha": "072ac89c7c8235314ab2fac6a7de2475713750dc", "filename": "src/libstd/ascii.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3c60bc02ce6de2823d0b837f90d5db0077fce6f7/src%2Flibstd%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c60bc02ce6de2823d0b837f90d5db0077fce6f7/src%2Flibstd%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fascii.rs?ref=3c60bc02ce6de2823d0b837f90d5db0077fce6f7", "patch": "@@ -630,8 +630,8 @@ static ASCII_UPPER_MAP: [u8, ..256] = [\n \n #[cfg(test)]\n mod tests {\n-    use prelude::*;\n     use super::*;\n+    use prelude::*;\n     use char::from_u32;\n \n     macro_rules! v2ascii {"}, {"sha": "fb369924c64b11b235a85d1d94106748ab433b4a", "filename": "src/libstd/c_str.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3c60bc02ce6de2823d0b837f90d5db0077fce6f7/src%2Flibstd%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c60bc02ce6de2823d0b837f90d5db0077fce6f7/src%2Flibstd%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fc_str.rs?ref=3c60bc02ce6de2823d0b837f90d5db0077fce6f7", "patch": "@@ -534,13 +534,12 @@ pub unsafe fn from_c_multistring<F>(buf: *const libc::c_char,\n \n #[cfg(test)]\n mod tests {\n+    use super::*;\n     use prelude::*;\n     use ptr;\n     use thread::Thread;\n     use libc;\n \n-    use super::*;\n-\n     #[test]\n     fn test_str_multistring_parsing() {\n         unsafe {"}, {"sha": "d3bfaab83da487c859d99d3d71b67884011aa482", "filename": "src/libstd/comm/mod.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3c60bc02ce6de2823d0b837f90d5db0077fce6f7/src%2Flibstd%2Fcomm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c60bc02ce6de2823d0b837f90d5db0077fce6f7/src%2Flibstd%2Fcomm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fmod.rs?ref=3c60bc02ce6de2823d0b837f90d5db0077fce6f7", "patch": "@@ -333,12 +333,10 @@ macro_rules! test {\n         mod $name {\n             #![allow(unused_imports)]\n \n-            use prelude::*;\n-            use rt;\n-\n-            use comm::*;\n             use super::*;\n+            use comm::*;\n             use thread::Thread;\n+            use prelude::*;\n \n             $(#[$a])* #[test] fn f() { $b }\n         }\n@@ -1022,10 +1020,9 @@ impl<T: Send> Drop for Receiver<T> {\n \n #[cfg(test)]\n mod test {\n+    use super::*;\n     use prelude::*;\n-\n     use os;\n-    use super::*;\n \n     pub fn stress_factor() -> uint {\n         match os::getenv(\"RUST_TEST_STRESS\") {"}, {"sha": "01151059530f034587674439f087f2d788983525", "filename": "src/libstd/io/mem.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3c60bc02ce6de2823d0b837f90d5db0077fce6f7/src%2Flibstd%2Fio%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c60bc02ce6de2823d0b837f90d5db0077fce6f7/src%2Flibstd%2Fio%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmem.rs?ref=3c60bc02ce6de2823d0b837f90d5db0077fce6f7", "patch": "@@ -399,9 +399,9 @@ impl<'a> Buffer for BufReader<'a> {\n #[cfg(test)]\n mod test {\n     extern crate \"test\" as test_crate;\n-    use prelude::*;\n     use super::*;\n     use io::*;\n+    use prelude::*;\n     use io;\n     use self::test_crate::Bencher;\n "}, {"sha": "4afc72cde711e46a6128f7e0bba0c1b388c9d5e2", "filename": "src/libstd/io/net/pipe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3c60bc02ce6de2823d0b837f90d5db0077fce6f7/src%2Flibstd%2Fio%2Fnet%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c60bc02ce6de2823d0b837f90d5db0077fce6f7/src%2Flibstd%2Fio%2Fnet%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fpipe.rs?ref=3c60bc02ce6de2823d0b837f90d5db0077fce6f7", "patch": "@@ -266,10 +266,10 @@ impl sys_common::AsInner<UnixAcceptorImp> for UnixAcceptor {\n #[cfg(test)]\n #[allow(experimental)]\n mod tests {\n-    use prelude::*;\n     use super::*;\n     use io::*;\n     use io::test::*;\n+    use prelude::*;\n     use io::fs::PathExtensions;\n     use time::Duration;\n "}, {"sha": "a36703172c3caa9fe34b32ab103b0dd264819a2f", "filename": "src/libstd/io/net/udp.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3c60bc02ce6de2823d0b837f90d5db0077fce6f7/src%2Flibstd%2Fio%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c60bc02ce6de2823d0b837f90d5db0077fce6f7/src%2Flibstd%2Fio%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fudp.rs?ref=3c60bc02ce6de2823d0b837f90d5db0077fce6f7", "patch": "@@ -249,10 +249,10 @@ impl Writer for UdpStream {\n #[allow(experimental)]\n mod test {\n     use super::*;\n-    use prelude::*;\n-    use io::*;\n     use io::net::ip::*;\n+    use io::*;\n     use io::test::*;\n+    use prelude::*;\n \n     // FIXME #11530 this fails on android because tests are run as root\n     #[cfg_attr(any(windows, target_os = \"android\"), ignore)]"}, {"sha": "93aa627ffba13f7f2d3e3b384d8405f2cebad06f", "filename": "src/libstd/io/process.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3c60bc02ce6de2823d0b837f90d5db0077fce6f7/src%2Flibstd%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c60bc02ce6de2823d0b837f90d5db0077fce6f7/src%2Flibstd%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fprocess.rs?ref=3c60bc02ce6de2823d0b837f90d5db0077fce6f7", "patch": "@@ -744,9 +744,9 @@ mod tests {\n     #![allow(unused_imports)]\n \n     use super::*;\n-    use prelude::*;\n     use io::timer::*;\n     use io::*;\n+    use prelude::*;\n     use io::fs::PathExtensions;\n     use time::Duration;\n     use str;"}, {"sha": "d941665f0482f30b876cb8de6c5936664d2f2c55", "filename": "src/libstd/path/posix.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3c60bc02ce6de2823d0b837f90d5db0077fce6f7/src%2Flibstd%2Fpath%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c60bc02ce6de2823d0b837f90d5db0077fce6f7/src%2Flibstd%2Fpath%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fposix.rs?ref=3c60bc02ce6de2823d0b837f90d5db0077fce6f7", "patch": "@@ -447,8 +447,10 @@ static dot_dot_static: &'static [u8] = b\"..\";\n \n #[cfg(test)]\n mod tests {\n-    use prelude::*;\n     use super::*;\n+    use prelude::Option::{mod, Some, None};\n+    use prelude::{Vec, Clone, AsSlice, SliceExt, CloneSliceExt, IteratorExt};\n+    use prelude::{DoubleEndedIteratorExt, Str, StrExt, ToString, GenericPath};\n     use str;\n \n     macro_rules! t {"}, {"sha": "12da1752adf9cae8b8cc64eaa8fabcbc50a55a9f", "filename": "src/libstd/path/windows.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3c60bc02ce6de2823d0b837f90d5db0077fce6f7/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c60bc02ce6de2823d0b837f90d5db0077fce6f7/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=3c60bc02ce6de2823d0b837f90d5db0077fce6f7", "patch": "@@ -1121,8 +1121,10 @@ fn prefix_len(p: Option<PathPrefix>) -> uint {\n \n #[cfg(test)]\n mod tests {\n-    use prelude::*;\n     use super::*;\n+    use prelude::Option::{mod, Some, None};\n+    use prelude::{Vec, Clone, AsSlice, SliceExt, CloneSliceExt, IteratorExt};\n+    use prelude::{DoubleEndedIteratorExt, Str, ToString, GenericPath};\n     use super::PathPrefix::*;\n     use super::parse_prefix;\n "}]}