{"sha": "b181835a6bacfa449f55d46764a10e25d1c471dc", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIxODE4MzVhNmJhY2ZhNDQ5ZjU1ZDQ2NzY0YTEwZTI1ZDFjNDcxZGM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-01-28T08:44:20Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-01-28T08:44:20Z"}, "message": "Auto merge of #68529 - TimDiekmann:rename-alloc, r=Amanieu\n\nRename `Alloc` to `AllocRef`\n\nThe allocator-wg has decided to merge this change upstream in https://github.com/rust-lang/wg-allocators/issues/8#issuecomment-577122958.\n\nThis renames `Alloc` to `AllocRef` because types that implement `Alloc` are a reference, smart pointer, or ZSTs. It is not possible to have an allocator like `MyAlloc([u8; N])`, that owns the memory and also implements `Alloc`, since that would mean, that moving a `Vec<T, MyAlloc>` would need to correct the internal pointer, which is not possible as we don't have move constructors.\n\nFor further explanation please see https://github.com/rust-lang/wg-allocators/issues/8#issuecomment-489464843 and the comments after that one.\n\nAdditionally it clarifies the semantics of `Clone` on an allocator. In the case of `AllocRef`, it is clear that the cloned handle still points to the same allocator instance, and that you can free data allocated from one handle with another handle.\n\nThe initial proposal was to rename `Alloc` to `AllocHandle`, but `Ref` expresses the semantics better than `Handle`. Also, the only appearance of `Handle` in `std` are for windows specific resources, which might be confusing.\n\nBlocked on https://github.com/rust-lang/miri/pull/1160", "tree": {"sha": "7a5af02ac37fe47a4a0761fa5662caa062cb6a60", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7a5af02ac37fe47a4a0761fa5662caa062cb6a60"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b181835a6bacfa449f55d46764a10e25d1c471dc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b181835a6bacfa449f55d46764a10e25d1c471dc", "html_url": "https://github.com/rust-lang/rust/commit/b181835a6bacfa449f55d46764a10e25d1c471dc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b181835a6bacfa449f55d46764a10e25d1c471dc/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "82018665a5f2c34566b30c1b0b5a27c72d3b9a68", "url": "https://api.github.com/repos/rust-lang/rust/commits/82018665a5f2c34566b30c1b0b5a27c72d3b9a68", "html_url": "https://github.com/rust-lang/rust/commit/82018665a5f2c34566b30c1b0b5a27c72d3b9a68"}, {"sha": "7ca25db8162128808714f536fa993aefcf6a2239", "url": "https://api.github.com/repos/rust-lang/rust/commits/7ca25db8162128808714f536fa993aefcf6a2239", "html_url": "https://github.com/rust-lang/rust/commit/7ca25db8162128808714f536fa993aefcf6a2239"}], "stats": {"total": 105, "additions": 60, "deletions": 45}, "files": [{"sha": "9f045ce08a4337dfe790fc5e432c881a5c6316a3", "filename": "src/doc/unstable-book/src/library-features/allocator-api.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b181835a6bacfa449f55d46764a10e25d1c471dc/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fallocator-api.md", "raw_url": "https://github.com/rust-lang/rust/raw/b181835a6bacfa449f55d46764a10e25d1c471dc/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fallocator-api.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fallocator-api.md?ref=b181835a6bacfa449f55d46764a10e25d1c471dc", "patch": "@@ -9,7 +9,7 @@ The tracking issue for this feature is [#32838]\n Sometimes you want the memory for one collection to use a different\n allocator than the memory for another collection. In this case,\n replacing the global allocator is not a workable option. Instead,\n-you need to pass in an instance of an `Alloc` to each collection\n+you need to pass in an instance of an `AllocRef` to each collection\n for which you want a custom allocator.\n \n TBD"}, {"sha": "9fb0de63e6fc5a555472c5ffdfcb4b5c2681df2f", "filename": "src/liballoc/alloc.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/b181835a6bacfa449f55d46764a10e25d1c471dc/src%2Fliballoc%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b181835a6bacfa449f55d46764a10e25d1c471dc/src%2Fliballoc%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Falloc.rs?ref=b181835a6bacfa449f55d46764a10e25d1c471dc", "patch": "@@ -31,14 +31,14 @@ extern \"Rust\" {\n \n /// The global memory allocator.\n ///\n-/// This type implements the [`Alloc`] trait by forwarding calls\n+/// This type implements the [`AllocRef`] trait by forwarding calls\n /// to the allocator registered with the `#[global_allocator]` attribute\n /// if there is one, or the `std` crate\u2019s default.\n ///\n /// Note: while this type is unstable, the functionality it provides can be\n /// accessed through the [free functions in `alloc`](index.html#functions).\n ///\n-/// [`Alloc`]: trait.Alloc.html\n+/// [`AllocRef`]: trait.AllocRef.html\n #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n #[derive(Copy, Clone, Default, Debug)]\n pub struct Global;\n@@ -50,14 +50,14 @@ pub struct Global;\n /// if there is one, or the `std` crate\u2019s default.\n ///\n /// This function is expected to be deprecated in favor of the `alloc` method\n-/// of the [`Global`] type when it and the [`Alloc`] trait become stable.\n+/// of the [`Global`] type when it and the [`AllocRef`] trait become stable.\n ///\n /// # Safety\n ///\n /// See [`GlobalAlloc::alloc`].\n ///\n /// [`Global`]: struct.Global.html\n-/// [`Alloc`]: trait.Alloc.html\n+/// [`AllocRef`]: trait.AllocRef.html\n /// [`GlobalAlloc::alloc`]: trait.GlobalAlloc.html#tymethod.alloc\n ///\n /// # Examples\n@@ -88,14 +88,14 @@ pub unsafe fn alloc(layout: Layout) -> *mut u8 {\n /// if there is one, or the `std` crate\u2019s default.\n ///\n /// This function is expected to be deprecated in favor of the `dealloc` method\n-/// of the [`Global`] type when it and the [`Alloc`] trait become stable.\n+/// of the [`Global`] type when it and the [`AllocRef`] trait become stable.\n ///\n /// # Safety\n ///\n /// See [`GlobalAlloc::dealloc`].\n ///\n /// [`Global`]: struct.Global.html\n-/// [`Alloc`]: trait.Alloc.html\n+/// [`AllocRef`]: trait.AllocRef.html\n /// [`GlobalAlloc::dealloc`]: trait.GlobalAlloc.html#tymethod.dealloc\n #[stable(feature = \"global_alloc\", since = \"1.28.0\")]\n #[inline]\n@@ -110,14 +110,14 @@ pub unsafe fn dealloc(ptr: *mut u8, layout: Layout) {\n /// if there is one, or the `std` crate\u2019s default.\n ///\n /// This function is expected to be deprecated in favor of the `realloc` method\n-/// of the [`Global`] type when it and the [`Alloc`] trait become stable.\n+/// of the [`Global`] type when it and the [`AllocRef`] trait become stable.\n ///\n /// # Safety\n ///\n /// See [`GlobalAlloc::realloc`].\n ///\n /// [`Global`]: struct.Global.html\n-/// [`Alloc`]: trait.Alloc.html\n+/// [`AllocRef`]: trait.AllocRef.html\n /// [`GlobalAlloc::realloc`]: trait.GlobalAlloc.html#method.realloc\n #[stable(feature = \"global_alloc\", since = \"1.28.0\")]\n #[inline]\n@@ -132,14 +132,14 @@ pub unsafe fn realloc(ptr: *mut u8, layout: Layout, new_size: usize) -> *mut u8\n /// if there is one, or the `std` crate\u2019s default.\n ///\n /// This function is expected to be deprecated in favor of the `alloc_zeroed` method\n-/// of the [`Global`] type when it and the [`Alloc`] trait become stable.\n+/// of the [`Global`] type when it and the [`AllocRef`] trait become stable.\n ///\n /// # Safety\n ///\n /// See [`GlobalAlloc::alloc_zeroed`].\n ///\n /// [`Global`]: struct.Global.html\n-/// [`Alloc`]: trait.Alloc.html\n+/// [`AllocRef`]: trait.AllocRef.html\n /// [`GlobalAlloc::alloc_zeroed`]: trait.GlobalAlloc.html#method.alloc_zeroed\n ///\n /// # Examples\n@@ -163,7 +163,7 @@ pub unsafe fn alloc_zeroed(layout: Layout) -> *mut u8 {\n }\n \n #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n-unsafe impl Alloc for Global {\n+unsafe impl AllocRef for Global {\n     #[inline]\n     unsafe fn alloc(&mut self, layout: Layout) -> Result<NonNull<u8>, AllocErr> {\n         NonNull::new(alloc(layout)).ok_or(AllocErr)"}, {"sha": "8735c2c8f36253e5f52d238f5ac8101c62dde001", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b181835a6bacfa449f55d46764a10e25d1c471dc/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b181835a6bacfa449f55d46764a10e25d1c471dc/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=b181835a6bacfa449f55d46764a10e25d1c471dc", "patch": "@@ -145,7 +145,7 @@ use core::ptr::{self, NonNull, Unique};\n use core::slice;\n use core::task::{Context, Poll};\n \n-use crate::alloc::{self, Alloc, Global};\n+use crate::alloc::{self, AllocRef, Global};\n use crate::raw_vec::RawVec;\n use crate::str::from_boxed_utf8_unchecked;\n use crate::vec::Vec;"}, {"sha": "c0a96e89366eabd0e752446cd3b4419eb92f71cb", "filename": "src/liballoc/collections/btree/node.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b181835a6bacfa449f55d46764a10e25d1c471dc/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b181835a6bacfa449f55d46764a10e25d1c471dc/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs?ref=b181835a6bacfa449f55d46764a10e25d1c471dc", "patch": "@@ -36,7 +36,7 @@ use core::mem::{self, MaybeUninit};\n use core::ptr::{self, NonNull, Unique};\n use core::slice;\n \n-use crate::alloc::{Alloc, Global, Layout};\n+use crate::alloc::{AllocRef, Global, Layout};\n use crate::boxed::Box;\n \n const B: usize = 6;"}, {"sha": "e1b549bed18a6be60c10b2cd8d76161dab142e2b", "filename": "src/liballoc/raw_vec.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b181835a6bacfa449f55d46764a10e25d1c471dc/src%2Fliballoc%2Fraw_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b181835a6bacfa449f55d46764a10e25d1c471dc/src%2Fliballoc%2Fraw_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fraw_vec.rs?ref=b181835a6bacfa449f55d46764a10e25d1c471dc", "patch": "@@ -7,7 +7,7 @@ use core::ops::Drop;\n use core::ptr::{self, NonNull, Unique};\n use core::slice;\n \n-use crate::alloc::{handle_alloc_error, Alloc, AllocErr, Global, Layout};\n+use crate::alloc::{handle_alloc_error, AllocErr, AllocRef, Global, Layout};\n use crate::boxed::Box;\n use crate::collections::TryReserveError::{self, *};\n \n@@ -42,13 +42,13 @@ mod tests;\n /// field. This allows zero-sized types to not be special-cased by consumers of\n /// this type.\n #[allow(missing_debug_implementations)]\n-pub struct RawVec<T, A: Alloc = Global> {\n+pub struct RawVec<T, A: AllocRef = Global> {\n     ptr: Unique<T>,\n     cap: usize,\n     a: A,\n }\n \n-impl<T, A: Alloc> RawVec<T, A> {\n+impl<T, A: AllocRef> RawVec<T, A> {\n     /// Like `new`, but parameterized over the choice of allocator for\n     /// the returned `RawVec`.\n     pub const fn new_in(a: A) -> Self {\n@@ -147,7 +147,7 @@ impl<T> RawVec<T, Global> {\n     }\n }\n \n-impl<T, A: Alloc> RawVec<T, A> {\n+impl<T, A: AllocRef> RawVec<T, A> {\n     /// Reconstitutes a `RawVec` from a pointer, capacity, and allocator.\n     ///\n     /// # Undefined Behavior\n@@ -182,7 +182,7 @@ impl<T> RawVec<T, Global> {\n     }\n }\n \n-impl<T, A: Alloc> RawVec<T, A> {\n+impl<T, A: AllocRef> RawVec<T, A> {\n     /// Gets a raw pointer to the start of the allocation. Note that this is\n     /// `Unique::empty()` if `capacity == 0` or `T` is zero-sized. In the former case, you must\n     /// be careful.\n@@ -622,7 +622,7 @@ enum ReserveStrategy {\n \n use ReserveStrategy::*;\n \n-impl<T, A: Alloc> RawVec<T, A> {\n+impl<T, A: AllocRef> RawVec<T, A> {\n     fn reserve_internal(\n         &mut self,\n         used_capacity: usize,\n@@ -700,7 +700,7 @@ impl<T> RawVec<T, Global> {\n     }\n }\n \n-impl<T, A: Alloc> RawVec<T, A> {\n+impl<T, A: AllocRef> RawVec<T, A> {\n     /// Frees the memory owned by the `RawVec` *without* trying to drop its contents.\n     pub unsafe fn dealloc_buffer(&mut self) {\n         let elem_size = mem::size_of::<T>();\n@@ -712,7 +712,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n     }\n }\n \n-unsafe impl<#[may_dangle] T, A: Alloc> Drop for RawVec<T, A> {\n+unsafe impl<#[may_dangle] T, A: AllocRef> Drop for RawVec<T, A> {\n     /// Frees the memory owned by the `RawVec` *without* trying to drop its contents.\n     fn drop(&mut self) {\n         unsafe {"}, {"sha": "63087501f0e27684e4c4525f62c795d042813bc9", "filename": "src/liballoc/raw_vec/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b181835a6bacfa449f55d46764a10e25d1c471dc/src%2Fliballoc%2Fraw_vec%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b181835a6bacfa449f55d46764a10e25d1c471dc/src%2Fliballoc%2Fraw_vec%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fraw_vec%2Ftests.rs?ref=b181835a6bacfa449f55d46764a10e25d1c471dc", "patch": "@@ -19,7 +19,7 @@ fn allocator_param() {\n     struct BoundedAlloc {\n         fuel: usize,\n     }\n-    unsafe impl Alloc for BoundedAlloc {\n+    unsafe impl AllocRef for BoundedAlloc {\n         unsafe fn alloc(&mut self, layout: Layout) -> Result<NonNull<u8>, AllocErr> {\n             let size = layout.size();\n             if size > self.fuel {"}, {"sha": "9dc5447397f09167602c30aa6fa7b11eed67bdee", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b181835a6bacfa449f55d46764a10e25d1c471dc/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b181835a6bacfa449f55d46764a10e25d1c471dc/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=b181835a6bacfa449f55d46764a10e25d1c471dc", "patch": "@@ -252,7 +252,7 @@ use core::ptr::{self, NonNull};\n use core::slice::{self, from_raw_parts_mut};\n use core::usize;\n \n-use crate::alloc::{box_free, handle_alloc_error, Alloc, Global, Layout};\n+use crate::alloc::{box_free, handle_alloc_error, AllocRef, Global, Layout};\n use crate::string::String;\n use crate::vec::Vec;\n "}, {"sha": "fd285242d5be48ec9478ac2d7c509b60ab3194fd", "filename": "src/liballoc/sync.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b181835a6bacfa449f55d46764a10e25d1c471dc/src%2Fliballoc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b181835a6bacfa449f55d46764a10e25d1c471dc/src%2Fliballoc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fsync.rs?ref=b181835a6bacfa449f55d46764a10e25d1c471dc", "patch": "@@ -25,7 +25,7 @@ use core::sync::atomic;\n use core::sync::atomic::Ordering::{Acquire, Relaxed, Release, SeqCst};\n use core::{isize, usize};\n \n-use crate::alloc::{box_free, handle_alloc_error, Alloc, Global, Layout};\n+use crate::alloc::{box_free, handle_alloc_error, AllocRef, Global, Layout};\n use crate::boxed::Box;\n use crate::rc::is_dangling;\n use crate::string::String;"}, {"sha": "7fcfcf9b2945d26184d9ae9e9738c30c1068df69", "filename": "src/liballoc/tests/heap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b181835a6bacfa449f55d46764a10e25d1c471dc/src%2Fliballoc%2Ftests%2Fheap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b181835a6bacfa449f55d46764a10e25d1c471dc/src%2Fliballoc%2Ftests%2Fheap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fheap.rs?ref=b181835a6bacfa449f55d46764a10e25d1c471dc", "patch": "@@ -1,4 +1,4 @@\n-use std::alloc::{Alloc, Global, Layout, System};\n+use std::alloc::{AllocRef, Global, Layout, System};\n \n /// Issue #45955 and #62251.\n #[test]\n@@ -11,7 +11,7 @@ fn std_heap_overaligned_request() {\n     check_overalign_requests(Global)\n }\n \n-fn check_overalign_requests<T: Alloc>(mut allocator: T) {\n+fn check_overalign_requests<T: AllocRef>(mut allocator: T) {\n     for &align in &[4, 8, 16, 32] {\n         // less than and bigger than `MIN_ALIGN`\n         for &size in &[align / 2, align - 1] {"}, {"sha": "1b7dfafbd704c7722cd8ddcce6bae2d9037496db", "filename": "src/libcore/alloc.rs", "status": "modified", "additions": 26, "deletions": 11, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/b181835a6bacfa449f55d46764a10e25d1c471dc/src%2Flibcore%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b181835a6bacfa449f55d46764a10e25d1c471dc/src%2Flibcore%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Falloc.rs?ref=b181835a6bacfa449f55d46764a10e25d1c471dc", "patch": "@@ -31,7 +31,7 @@ const fn size_align<T>() -> (usize, usize) {\n ///\n /// (Note however that layouts are *not* required to have positive\n /// size, even though many allocators require that all memory\n-/// requests have positive size. A caller to the `Alloc::alloc`\n+/// requests have positive size. A caller to the `AllocRef::alloc`\n /// method must either ensure that conditions like this are met, or\n /// use specific allocators with looser requirements.)\n #[stable(feature = \"alloc_layout\", since = \"1.28.0\")]\n@@ -364,8 +364,8 @@ impl fmt::Display for AllocErr {\n /// [`shrink_in_place`] were unable to reuse the given memory block for\n /// a requested layout.\n ///\n-/// [`grow_in_place`]: ./trait.Alloc.html#method.grow_in_place\n-/// [`shrink_in_place`]: ./trait.Alloc.html#method.shrink_in_place\n+/// [`grow_in_place`]: ./trait.AllocRef.html#method.grow_in_place\n+/// [`shrink_in_place`]: ./trait.AllocRef.html#method.shrink_in_place\n #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n #[derive(Clone, PartialEq, Eq, Debug)]\n pub struct CannotReallocInPlace;\n@@ -580,9 +580,14 @@ pub unsafe trait GlobalAlloc {\n     }\n }\n \n-/// An implementation of `Alloc` can allocate, reallocate, and\n+/// An implementation of `AllocRef` can allocate, reallocate, and\n /// deallocate arbitrary blocks of data described via `Layout`.\n ///\n+/// `AllocRef` is designed to be implemented on ZSTs, references, or\n+/// smart pointers because having an allocator like `MyAlloc([u8; N])`\n+/// cannot be moved, without updating the pointers to the allocated\n+/// memory.\n+///\n /// Some of the methods require that a memory block be *currently\n /// allocated* via an allocator. This means that:\n ///\n@@ -598,15 +603,15 @@ pub unsafe trait GlobalAlloc {\n ///   passed to a reallocation method (see above) that returns `Ok`.\n ///\n /// A note regarding zero-sized types and zero-sized layouts: many\n-/// methods in the `Alloc` trait state that allocation requests\n+/// methods in the `AllocRef` trait state that allocation requests\n /// must be non-zero size, or else undefined behavior can result.\n ///\n /// * However, some higher-level allocation methods (`alloc_one`,\n ///   `alloc_array`) are well-defined on zero-sized types and can\n ///   optionally support them: it is left up to the implementor\n ///   whether to return `Err`, or to return `Ok` with some pointer.\n ///\n-/// * If an `Alloc` implementation chooses to return `Ok` in this\n+/// * If an `AllocRef` implementation chooses to return `Ok` in this\n ///   case (i.e., the pointer denotes a zero-sized inaccessible block)\n ///   then that returned pointer must be considered \"currently\n ///   allocated\". On such an allocator, *all* methods that take\n@@ -646,21 +651,24 @@ pub unsafe trait GlobalAlloc {\n ///\n /// # Safety\n ///\n-/// The `Alloc` trait is an `unsafe` trait for a number of reasons, and\n+/// The `AllocRef` trait is an `unsafe` trait for a number of reasons, and\n /// implementors must ensure that they adhere to these contracts:\n ///\n /// * Pointers returned from allocation functions must point to valid memory and\n-///   retain their validity until at least the instance of `Alloc` is dropped\n+///   retain their validity until at least one instance of `AllocRef` is dropped\n ///   itself.\n ///\n+/// * Cloning or moving the allocator must not invalidate pointers returned\n+///   from this allocator. Cloning must return a reference to the same allocator.\n+///\n /// * `Layout` queries and calculations in general must be correct. Callers of\n ///   this trait are allowed to rely on the contracts defined on each method,\n ///   and implementors must ensure such contracts remain true.\n ///\n /// Note that this list may get tweaked over time as clarifications are made in\n /// the future.\n #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n-pub unsafe trait Alloc {\n+pub unsafe trait AllocRef {\n     // (Note: some existing allocators have unspecified but well-defined\n     // behavior in response to a zero size allocation request ;\n     // e.g., in C, `malloc` of 0 will either return a null pointer or a\n@@ -1042,7 +1050,7 @@ pub unsafe trait Alloc {\n     /// must be considered \"currently allocated\" and must be\n     /// acceptable input to methods such as `realloc` or `dealloc`,\n     /// *even if* `T` is a zero-sized type. In other words, if your\n-    /// `Alloc` implementation overrides this method in a manner\n+    /// `AllocRef` implementation overrides this method in a manner\n     /// that can return a zero-sized `ptr`, then all reallocation and\n     /// deallocation methods need to be similarly overridden to accept\n     /// such values as input.\n@@ -1106,7 +1114,7 @@ pub unsafe trait Alloc {\n     /// must be considered \"currently allocated\" and must be\n     /// acceptable input to methods such as `realloc` or `dealloc`,\n     /// *even if* `T` is a zero-sized type. In other words, if your\n-    /// `Alloc` implementation overrides this method in a manner\n+    /// `AllocRef` implementation overrides this method in a manner\n     /// that can return a zero-sized `ptr`, then all reallocation and\n     /// deallocation methods need to be similarly overridden to accept\n     /// such values as input.\n@@ -1219,3 +1227,10 @@ pub unsafe trait Alloc {\n         }\n     }\n }\n+\n+// In order to rename `Alloc` to `AllocRef`, some submoduleshas to be updated as well. The CI fails\n+// if either of the submodules fails to compile. The submodules have their own CI depending on a\n+// specific Rust version, which don't have `AllocRef` yet. This alias is used to make the submodules\n+// compile and pass the CI.\n+#[unstable(feature = \"allocator_api\", issue = \"32838\")]\n+pub use self::AllocRef as Alloc;"}, {"sha": "8965c6860c4e950c5827ce7a161ee5ad19196e9e", "filename": "src/libstd/alloc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b181835a6bacfa449f55d46764a10e25d1c471dc/src%2Flibstd%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b181835a6bacfa449f55d46764a10e25d1c471dc/src%2Flibstd%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Falloc.rs?ref=b181835a6bacfa449f55d46764a10e25d1c471dc", "patch": "@@ -133,9 +133,9 @@ pub use alloc_crate::alloc::*;\n #[derive(Debug, Default, Copy, Clone)]\n pub struct System;\n \n-// The Alloc impl just forwards to the GlobalAlloc impl, which is in `std::sys::*::alloc`.\n+// The AllocRef impl just forwards to the GlobalAlloc impl, which is in `std::sys::*::alloc`.\n #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n-unsafe impl Alloc for System {\n+unsafe impl AllocRef for System {\n     #[inline]\n     unsafe fn alloc(&mut self, layout: Layout) -> Result<NonNull<u8>, AllocErr> {\n         NonNull::new(GlobalAlloc::alloc(self, layout)).ok_or(AllocErr)"}, {"sha": "b821a2c59396282462026cd60f03bee3b112cc00", "filename": "src/test/ui/allocator-alloc-one.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b181835a6bacfa449f55d46764a10e25d1c471dc/src%2Ftest%2Fui%2Fallocator-alloc-one.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b181835a6bacfa449f55d46764a10e25d1c471dc/src%2Ftest%2Fui%2Fallocator-alloc-one.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fallocator-alloc-one.rs?ref=b181835a6bacfa449f55d46764a10e25d1c471dc", "patch": "@@ -4,7 +4,7 @@\n \n #![feature(allocator_api, nonnull)]\n \n-use std::alloc::{Alloc, Global, Layout, handle_alloc_error};\n+use std::alloc::{AllocRef, Global, Layout, handle_alloc_error};\n \n fn main() {\n     unsafe {"}, {"sha": "0b1f6d5a96e56c12fc55dce87caf6eda62acaa70", "filename": "src/test/ui/allocator/custom.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b181835a6bacfa449f55d46764a10e25d1c471dc/src%2Ftest%2Fui%2Fallocator%2Fcustom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b181835a6bacfa449f55d46764a10e25d1c471dc/src%2Ftest%2Fui%2Fallocator%2Fcustom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fallocator%2Fcustom.rs?ref=b181835a6bacfa449f55d46764a10e25d1c471dc", "patch": "@@ -7,7 +7,7 @@\n \n extern crate helper;\n \n-use std::alloc::{self, Global, Alloc, System, Layout};\n+use std::alloc::{self, Global, AllocRef, System, Layout};\n use std::sync::atomic::{AtomicUsize, Ordering};\n \n static HITS: AtomicUsize = AtomicUsize::new(0);"}, {"sha": "37b28c195df5bde883c740dae57d8472e5ff55aa", "filename": "src/test/ui/allocator/xcrate-use.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b181835a6bacfa449f55d46764a10e25d1c471dc/src%2Ftest%2Fui%2Fallocator%2Fxcrate-use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b181835a6bacfa449f55d46764a10e25d1c471dc/src%2Ftest%2Fui%2Fallocator%2Fxcrate-use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fallocator%2Fxcrate-use.rs?ref=b181835a6bacfa449f55d46764a10e25d1c471dc", "patch": "@@ -9,7 +9,7 @@\n extern crate custom;\n extern crate helper;\n \n-use std::alloc::{Global, Alloc, System, Layout};\n+use std::alloc::{Global, AllocRef, System, Layout};\n use std::sync::atomic::{Ordering, AtomicUsize};\n \n #[global_allocator]"}, {"sha": "425aa83e70a8542f664bbf27e4ba48ff92950324", "filename": "src/test/ui/realloc-16687.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b181835a6bacfa449f55d46764a10e25d1c471dc/src%2Ftest%2Fui%2Frealloc-16687.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b181835a6bacfa449f55d46764a10e25d1c471dc/src%2Ftest%2Fui%2Frealloc-16687.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frealloc-16687.rs?ref=b181835a6bacfa449f55d46764a10e25d1c471dc", "patch": "@@ -6,7 +6,7 @@\n \n #![feature(allocator_api)]\n \n-use std::alloc::{Global, Alloc, Layout, handle_alloc_error};\n+use std::alloc::{Global, AllocRef, Layout, handle_alloc_error};\n use std::ptr::{self, NonNull};\n \n fn main() {"}, {"sha": "f50b1c8b17f2886dfdfb76ed1618e49b4523b6ad", "filename": "src/test/ui/regions/regions-mock-codegen.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b181835a6bacfa449f55d46764a10e25d1c471dc/src%2Ftest%2Fui%2Fregions%2Fregions-mock-codegen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b181835a6bacfa449f55d46764a10e25d1c471dc/src%2Ftest%2Fui%2Fregions%2Fregions-mock-codegen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-mock-codegen.rs?ref=b181835a6bacfa449f55d46764a10e25d1c471dc", "patch": "@@ -6,7 +6,7 @@\n \n #![feature(allocator_api)]\n \n-use std::alloc::{Alloc, Global, Layout, handle_alloc_error};\n+use std::alloc::{AllocRef, Global, Layout, handle_alloc_error};\n use std::ptr::NonNull;\n \n struct arena(());"}]}