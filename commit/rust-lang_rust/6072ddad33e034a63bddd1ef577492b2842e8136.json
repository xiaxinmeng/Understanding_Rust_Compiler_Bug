{"sha": "6072ddad33e034a63bddd1ef577492b2842e8136", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYwNzJkZGFkMzNlMDM0YTYzYmRkZDFlZjU3NzQ5MmIyODQyZTgxMzY=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2011-11-18T02:45:18Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2011-11-19T00:32:19Z"}, "message": "sketch out design", "tree": {"sha": "76ba850c486969d08d66efe0fe3478b1058e6573", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/76ba850c486969d08d66efe0fe3478b1058e6573"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6072ddad33e034a63bddd1ef577492b2842e8136", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6072ddad33e034a63bddd1ef577492b2842e8136", "html_url": "https://github.com/rust-lang/rust/commit/6072ddad33e034a63bddd1ef577492b2842e8136", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6072ddad33e034a63bddd1ef577492b2842e8136/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d6ab8ebb07d0f6360d2aa32dec71c24a32c21ea6", "url": "https://api.github.com/repos/rust-lang/rust/commits/d6ab8ebb07d0f6360d2aa32dec71c24a32c21ea6", "html_url": "https://github.com/rust-lang/rust/commit/d6ab8ebb07d0f6360d2aa32dec71c24a32c21ea6"}], "stats": {"total": 152, "additions": 98, "deletions": 54}, "files": [{"sha": "58252ff93308a3ec800af35d5129adeea4c8ba9b", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 98, "deletions": 54, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/6072ddad33e034a63bddd1ef577492b2842e8136/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6072ddad33e034a63bddd1ef577492b2842e8136/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=6072ddad33e034a63bddd1ef577492b2842e8136", "patch": "@@ -5366,7 +5366,7 @@ fn c_stack_tys(ccx: @crate_ctxt,\n       ty::ty_native_fn(_, arg_tys, ret_ty) {\n         let llargtys = type_of_explicit_args(ccx, sp, arg_tys);\n         check non_ty_var(ccx, ret_ty); // NDM does this truly hold?\n-        let llretty = type_of_inner(ccx, sp, ret_ty);\n+        let llretty = T_ptr(type_of_inner(ccx, sp, ret_ty));\n         let bundle_ty = T_struct(llargtys + [llretty]);\n         ret @{\n             arg_tys: llargtys,\n@@ -5385,31 +5385,58 @@ fn c_stack_tys(ccx: @crate_ctxt,\n     }\n }\n \n-// For c-stack ABIs, we must generate shim functions for making\n-// the call.  These shim functions will unpack arguments out of\n-// a struct and then invoke the base function.\n+// For each native function F, we generate a wrapper function W and a shim\n+// function S that all work together.  The wrapper function W is the function\n+// that other rust code actually invokes.  Its job is to marshall the\n+// arguments into a struct.  It then uses a small bit of assembly to switch\n+// over to the C stack and invoke the shim function.  The shim function S then\n+// unpacks the arguments from the struct and invokes the actual function F\n+// according to its specified calling convention.\n //\n // Example: Given a native c-stack function F(x: X, y: Y) -> Z,\n-// we generate a shim function S that is something like:\n+// we generate a wrapper function W that looks like:\n //\n-//     void S(struct F_Args { X x; Y y; Z *z; } *args) {\n+//    void W(Z* dest, void *env, X x, Y y) {\n+//        struct { X x; Y y; Z *z; } args = { x, y, z };\n+//        call_on_c_stack_shim(S, &args);\n+//    }\n+//\n+// The shim function S then looks something like:\n+//\n+//     void S(struct { X x; Y y; Z *z; } *args) {\n //         *args->z = F(args->x, args->y);\n //     }\n //\n+// However, if the return type of F is dynamically sized or of aggregate type,\n+// the shim function looks like:\n+//\n+//     void S(struct { X x; Y y; Z *z; } *args) {\n+//         F(args->z, args->x, args->y);\n+//     }\n+//\n+// Note: on i386, the layout of the args struct is generally the same as the\n+// desired layout of the arguments on the C stack.  Therefore, we could use\n+// upcall_alloc_c_stack() to allocate the `args` structure and switch the\n+// stack pointer appropriately to avoid a round of copies.  (In fact, the shim\n+// function itself is unnecessary). We used to do this, in fact, and will\n+// perhaps do so in the future.\n fn trans_native_mod(lcx: @local_ctxt, native_mod: ast::native_mod) {\n     fn build_shim_fn(lcx: @local_ctxt,\n                      native_item: @ast::native_item,\n-                     llshimfn: ValueRef,\n-                     cc: uint) {\n+                     tys: @c_stack_tys,\n+                     cc: uint) -> ValueRef {\n         let lname = link_name(native_item);\n         let ccx = lcx_ccx(lcx);\n         let span = native_item.span;\n-        let id = native_item.id;\n-        let tys = c_stack_tys(ccx, span, id);\n \n         // Declare the \"prototype\" for the base function F:\n         let llbasefn = decl_fn(ccx.llmod, lname, cc, tys.base_fn_ty);\n \n+        // Create the shim function:\n+        let shim_name = lname + \"__c_stack_shim\";\n+        let llshimfn = decl_internal_cdecl_fn(\n+            ccx.llmod, shim_name, tys.shim_fn_ty);\n+\n         // Declare the body of the shim function:\n         let fcx = new_fn_ctxt(lcx, span, llshimfn);\n         let bcx = new_top_block_ctxt(fcx);\n@@ -5423,11 +5450,39 @@ fn trans_native_mod(lcx: @local_ctxt, native_mod: ast::native_mod) {\n             i += 1u;\n         }\n \n-        // Create the call itself:\n+        // Create the call itself and store the return value:\n         let llretval = CallWithConv(bcx, llbasefn, llargvals, cc);\n-        store_inbounds(bcx, llretval, llargbundle, [0, n as int]);\n+        store_inbounds(bcx, llretval, llargbundle, [0, n as int, 0]);\n+\n+        // Finish up:\n+        build_return(bcx);\n+        finish_fn(fcx, lltop);\n+\n+        ret llshimfn;\n+    }\n+\n+    fn build_wrap_fn(lcx: @local_ctxt,\n+                     native_item: @ast::native_item,\n+                     tys: @c_stack_tys,\n+                     llshimfn: ValueRef,\n+                     llwrapfn: ValueRef) {\n+        let fcx = new_fn_ctxt(lcx, span, llshimfn);\n+        let bcx = new_top_block_ctxt(fcx);\n+        let lltop = bcx.llbb;\n+\n+        // Allocate the struct and write the arguments into it.\n+        let llargbundle = alloca(bcx, tys.bundle_ty);\n+        let imp = 2u, i = 0u, n = vec::len(tys.arg_tys);\n+        while i < n {\n+            let llargval = llvm::LLVMGetParam(llwrapfn, i + imp);\n+            store_inbounds(bcx, llargval, llargbundle, [0, i as int]);\n+            i += 1u;\n+        }\n+        let llretptr = llvm::LLVMGetParam(llwrapfn, 0);\n+        store_inbounds(bcx, llretptr, llargbundle, [0, n as int]);\n+\n+        // Create call itself:\n \n-        // Finish up.\n         build_return(bcx);\n         finish_fn(fcx, lltop);\n     }\n@@ -5445,9 +5500,11 @@ fn trans_native_mod(lcx: @local_ctxt, native_mod: ast::native_mod) {\n         ast::native_item_ty. {}\n         ast::native_item_fn(fn_decl, _) {\n           let id = native_item.id;\n+          let tys = c_stack_tys(ccx, span, id);\n           alt ccx.item_ids.find(id) {\n-            some(llshimfn) {\n-              build_shim_fn(lcx, native_item, llshimfn, cc);\n+            some(llwrapfn) {\n+              let llshimfn = build_shim_fn(lcx, native_item, cc, tys);\n+              build_wrap_fn(lcx, native_item, tys, llshimfn, llwrapfn);\n             }\n \n             none. {\n@@ -5548,14 +5605,6 @@ fn register_fn_full(ccx: @crate_ctxt, sp: span, path: [str], _flav: str,\n     let path = path;\n     let llfty =\n         type_of_fn_from_ty(ccx, sp, node_type, std::vec::len(ty_params));\n-    alt ty::struct(ccx.tcx, node_type) {\n-      ty::ty_fn(_, inputs, output, rs, _) {\n-        check non_ty_var(ccx, output);\n-        llfty = type_of_fn(ccx, sp, false, ast_util::ret_by_ref(rs), inputs,\n-                           output, vec::len(ty_params));\n-      }\n-      _ { ccx.sess.bug(\"register_fn(): fn item doesn't have fn type!\"); }\n-    }\n     let ps: str = mangle_exported_name(ccx, path, node_type);\n     let llfn: ValueRef = decl_cdecl_fn(ccx.llmod, ps, llfty);\n     ccx.item_ids.insert(node_id, llfn);\n@@ -5715,33 +5764,6 @@ fn raw_native_fn_type(ccx: @crate_ctxt, sp: span, args: [ty::arg],\n     ret T_fn(type_of_explicit_args(ccx, sp, args), type_of(ccx, sp, ret_ty));\n }\n \n-fn register_native_fn(ccx: @crate_ctxt, sp: span, _path: [str], name: str,\n-                      id: ast::node_id) {\n-    let fn_type = node_id_type(ccx, id); // NB: has no type params\n-    let abi = ty::ty_fn_abi(ccx.tcx, fn_type);\n-\n-    alt abi {\n-      ast::native_abi_rust_intrinsic. {\n-        let num_ty_param = native_fn_ty_param_count(ccx, id);\n-        let fn_type = native_fn_wrapper_type(ccx, sp, num_ty_param, fn_type);\n-        let ri_name = \"rust_intrinsic_\" + name;\n-        let llnativefn = get_extern_fn(ccx.externs, ccx.llmod, ri_name,\n-                                       lib::llvm::LLVMCCallConv, fn_type);\n-        ccx.item_ids.insert(id, llnativefn);\n-        ccx.item_symbols.insert(id, ri_name);\n-      }\n-\n-      ast::native_abi_cdecl. | ast::native_abi_stdcall. {\n-        let tys = c_stack_tys(ccx, sp, id);\n-        let shim_name = name + \"__c_stack_shim\";\n-        let llshimfn = decl_internal_cdecl_fn(\n-            ccx.llmod, shim_name, tys.shim_fn_ty);\n-        ccx.item_ids.insert(id, llshimfn);\n-        ccx.item_symbols.insert(id, shim_name);\n-      }\n-    }\n-}\n-\n fn item_path(item: @ast::item) -> [str] { ret [item.ident]; }\n \n fn link_name(i: @ast::native_item) -> str {\n@@ -5751,14 +5773,36 @@ fn link_name(i: @ast::native_item) -> str {\n     }\n }\n \n-\n fn collect_native_item(ccx: @crate_ctxt, i: @ast::native_item, &&pt: [str],\n                        _v: vt<[str]>) {\n     alt i.node {\n-      ast::native_item_fn(_, _) {\n+      ast::native_item_fn(_, tps) {\n         if !ccx.obj_methods.contains_key(i.id) {\n-            let name = link_name(i);\n-            register_native_fn(ccx, i.span, pt, name, i.id);\n+            // FIXME NDM abi should come from attr\n+            let abi = ty::ty_fn_abi(ccx.tcx, fn_type);\n+\n+            alt abi {\n+              ast::native_abi_rust_intrinsic. {\n+                // For intrinsics: link the function directly to the intrinsic\n+                // function itself.\n+                let num_ty_param = vec::len(tps);\n+                let node_type = node_id_type(ccx, id);\n+                let fn_type = type_of_fn_from_ty(ccx, sp, node_type, num_ty_param);\n+                let ri_name = \"rust_intrinsic_\" + name;\n+                let llnativefn = get_extern_fn(ccx.externs, ccx.llmod, ri_name,\n+                                               lib::llvm::LLVMCCallConv, fn_type);\n+                ccx.item_ids.insert(id, llnativefn);\n+                ccx.item_symbols.insert(id, ri_name);\n+              }\n+\n+              ast::native_abi_cdecl. | ast::native_abi_stdcall. {\n+                // For true external functions: create a rust wrapper\n+                // and link to that.  The rust wrapper will handle\n+                // switching to the C stack.\n+                let new_pt = pt + [i.ident];\n+                register_fn(ccx, i.span, new_pt, \"native fn\", tps, i.id);\n+              }\n+            }\n         }\n       }\n       _ { }"}]}