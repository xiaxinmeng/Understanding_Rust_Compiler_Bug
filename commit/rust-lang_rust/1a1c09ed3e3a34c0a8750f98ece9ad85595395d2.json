{"sha": "1a1c09ed3e3a34c0a8750f98ece9ad85595395d2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFhMWMwOWVkM2UzYTM0YzBhODc1MGY5OGVjZTlhZDg1NTk1Mzk1ZDI=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-04-11T17:37:02Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-04-11T17:37:02Z"}, "message": "Merge #3951\n\n3951: Simplify records grammar r=matklad a=matklad\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "44136a4ce738d388bb9b0ce9f5569cf68465cbe2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/44136a4ce738d388bb9b0ce9f5569cf68465cbe2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1a1c09ed3e3a34c0a8750f98ece9ad85595395d2", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJekgA+CRBK7hj4Ov3rIwAAdHIIABpcLN8MFOipJTstVQpjAzgQ\n5bKPo/8DMqpWaMz3RVjm9mqa8fWt4lzS/BVewT9DIy9oV6QiAnZBgWvE0osxYGv3\nFzn9CXHB519a3hx211CAMly9MffcQ8tbskOYwsV9peXTsCK83/PfStJdnvMvXxLK\n8y2kiRveSPB4Mqm0ye/mC5+UD3gE4eEwMquFUhHxVYbAzoi2Qo40uR/4IxwDvu0X\n+GMiPQ2a86jkpxqSZ5udcVci1AcJDMkkPCJ9eDbe4hWhcRyXZ5W74tH1TlA6MjHY\nMOkowFhkEh/4Alk4eJj+1uVd+IumdEXM4GsTlespcLHpTywKoA4qhE8Otus4E1E=\n=0VWH\n-----END PGP SIGNATURE-----\n", "payload": "tree 44136a4ce738d388bb9b0ce9f5569cf68465cbe2\nparent 11d400b63b07d3cffbe8d1363b802a2d52f5d786\nparent 0aece75cdd40daa4d48484103cfcd36ba13ba076\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1586626622 +0000\ncommitter GitHub <noreply@github.com> 1586626622 +0000\n\nMerge #3951\n\n3951: Simplify records grammar r=matklad a=matklad\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1a1c09ed3e3a34c0a8750f98ece9ad85595395d2", "html_url": "https://github.com/rust-lang/rust/commit/1a1c09ed3e3a34c0a8750f98ece9ad85595395d2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1a1c09ed3e3a34c0a8750f98ece9ad85595395d2/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "11d400b63b07d3cffbe8d1363b802a2d52f5d786", "url": "https://api.github.com/repos/rust-lang/rust/commits/11d400b63b07d3cffbe8d1363b802a2d52f5d786", "html_url": "https://github.com/rust-lang/rust/commit/11d400b63b07d3cffbe8d1363b802a2d52f5d786"}, {"sha": "0aece75cdd40daa4d48484103cfcd36ba13ba076", "url": "https://api.github.com/repos/rust-lang/rust/commits/0aece75cdd40daa4d48484103cfcd36ba13ba076", "html_url": "https://github.com/rust-lang/rust/commit/0aece75cdd40daa4d48484103cfcd36ba13ba076"}], "stats": {"total": 301, "additions": 180, "deletions": 121}, "files": [{"sha": "58ae6ce418546cd439fa1d56d0403ca47dfc245d", "filename": "crates/ra_hir/src/source_analyzer.rs", "status": "modified", "additions": 16, "deletions": 20, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/1a1c09ed3e3a34c0a8750f98ece9ad85595395d2/crates%2Fra_hir%2Fsrc%2Fsource_analyzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a1c09ed3e3a34c0a8750f98ece9ad85595395d2/crates%2Fra_hir%2Fsrc%2Fsource_analyzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_analyzer.rs?ref=1a1c09ed3e3a34c0a8750f98ece9ad85595395d2", "patch": "@@ -139,7 +139,7 @@ impl SourceAnalyzer {\n         &self,\n         db: &dyn HirDatabase,\n         field: &ast::FieldExpr,\n-    ) -> Option<crate::StructField> {\n+    ) -> Option<StructField> {\n         let expr_id = self.expr_id(db, &field.clone().into())?;\n         self.infer.as_ref()?.field_resolution(expr_id).map(|it| it.into())\n     }\n@@ -148,21 +148,19 @@ impl SourceAnalyzer {\n         &self,\n         db: &dyn HirDatabase,\n         field: &ast::RecordField,\n-    ) -> Option<(crate::StructField, Option<Local>)> {\n-        let (expr_id, local) = match field.expr() {\n-            Some(it) => (self.expr_id(db, &it)?, None),\n-            None => {\n-                let src = InFile { file_id: self.file_id, value: field };\n-                let expr_id = self.body_source_map.as_ref()?.field_init_shorthand_expr(src)?;\n-                let local_name = field.name_ref()?.as_name();\n-                let path = ModPath::from_segments(PathKind::Plain, once(local_name));\n-                let local = match self.resolver.resolve_path_in_value_ns_fully(db.upcast(), &path) {\n-                    Some(ValueNs::LocalBinding(pat_id)) => {\n-                        Some(Local { pat_id, parent: self.resolver.body_owner()? })\n-                    }\n-                    _ => None,\n-                };\n-                (expr_id, local)\n+    ) -> Option<(StructField, Option<Local>)> {\n+        let expr = field.expr()?;\n+        let expr_id = self.expr_id(db, &expr)?;\n+        let local = if field.name_ref().is_some() {\n+            None\n+        } else {\n+            let local_name = field.field_name()?.as_name();\n+            let path = ModPath::from_segments(PathKind::Plain, once(local_name));\n+            match self.resolver.resolve_path_in_value_ns_fully(db.upcast(), &path) {\n+                Some(ValueNs::LocalBinding(pat_id)) => {\n+                    Some(Local { pat_id, parent: self.resolver.body_owner()? })\n+                }\n+                _ => None,\n             }\n         };\n         let struct_field = self.infer.as_ref()?.record_field_resolution(expr_id)?;\n@@ -319,8 +317,7 @@ fn scope_for_offset(\n             if source.file_id != offset.file_id {\n                 return None;\n             }\n-            let syntax_node_ptr =\n-                source.value.either(|it| it.syntax_node_ptr(), |it| it.syntax_node_ptr());\n+            let syntax_node_ptr = source.value.syntax_node_ptr();\n             Some((syntax_node_ptr, scope))\n         })\n         // find containing scope\n@@ -399,8 +396,7 @@ fn adjust(\n             if source.file_id != file_id {\n                 return None;\n             }\n-            let syntax_node_ptr =\n-                source.value.either(|it| it.syntax_node_ptr(), |it| it.syntax_node_ptr());\n+            let syntax_node_ptr = source.value.syntax_node_ptr();\n             Some((syntax_node_ptr, scope))\n         })\n         .map(|(ptr, scope)| (ptr.range(), scope))"}, {"sha": "eafaf48c17eea77cb01a84a8359ca677f2608caa", "filename": "crates/ra_hir_def/src/body.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/1a1c09ed3e3a34c0a8750f98ece9ad85595395d2/crates%2Fra_hir_def%2Fsrc%2Fbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a1c09ed3e3a34c0a8750f98ece9ad85595395d2/crates%2Fra_hir_def%2Fsrc%2Fbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fbody.rs?ref=1a1c09ed3e3a34c0a8750f98ece9ad85595395d2", "patch": "@@ -9,6 +9,8 @@ use drop_bomb::DropBomb;\n use either::Either;\n use hir_expand::{ast_id_map::AstIdMap, hygiene::Hygiene, AstId, HirFileId, InFile, MacroDefId};\n use ra_arena::{map::ArenaMap, Arena};\n+use ra_cfg::CfgOptions;\n+use ra_db::CrateId;\n use ra_prof::profile;\n use ra_syntax::{ast, AstNode, AstPtr};\n use rustc_hash::FxHashMap;\n@@ -24,8 +26,6 @@ use crate::{\n     src::HasSource,\n     AsMacroCall, DefWithBodyId, HasModule, Lookup, ModuleId,\n };\n-use ra_cfg::CfgOptions;\n-use ra_db::CrateId;\n \n /// A subser of Exander that only deals with cfg attributes. We only need it to\n /// avoid cyclic queries in crate def map during enum processing.\n@@ -187,7 +187,7 @@ pub struct Body {\n     pub item_scope: ItemScope,\n }\n \n-pub type ExprPtr = Either<AstPtr<ast::Expr>, AstPtr<ast::RecordField>>;\n+pub type ExprPtr = AstPtr<ast::Expr>;\n pub type ExprSource = InFile<ExprPtr>;\n \n pub type PatPtr = Either<AstPtr<ast::Pat>, AstPtr<ast::SelfParam>>;\n@@ -285,7 +285,7 @@ impl BodySourceMap {\n     }\n \n     pub fn node_expr(&self, node: InFile<&ast::Expr>) -> Option<ExprId> {\n-        let src = node.map(|it| Either::Left(AstPtr::new(it)));\n+        let src = node.map(|it| AstPtr::new(it));\n         self.expr_map.get(&src).cloned()\n     }\n \n@@ -294,11 +294,6 @@ impl BodySourceMap {\n         self.expansions.get(&src).cloned()\n     }\n \n-    pub fn field_init_shorthand_expr(&self, node: InFile<&ast::RecordField>) -> Option<ExprId> {\n-        let src = node.map(|it| Either::Right(AstPtr::new(it)));\n-        self.expr_map.get(&src).cloned()\n-    }\n-\n     pub fn pat_syntax(&self, pat: PatId) -> Result<PatSource, SyntheticSyntax> {\n         self.pat_map_back[pat].clone()\n     }"}, {"sha": "cc2532e88b294197d06280e9c3303ac2cc9721f7", "filename": "crates/ra_hir_def/src/body/lower.rs", "status": "modified", "additions": 6, "deletions": 24, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/1a1c09ed3e3a34c0a8750f98ece9ad85595395d2/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a1c09ed3e3a34c0a8750f98ece9ad85595395d2/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs?ref=1a1c09ed3e3a34c0a8750f98ece9ad85595395d2", "patch": "@@ -27,7 +27,6 @@ use crate::{\n     },\n     item_scope::BuiltinShadowMode,\n     path::GenericArgs,\n-    path::Path,\n     type_ref::{Mutability, TypeRef},\n     AdtId, ConstLoc, ContainerId, DefWithBodyId, EnumLoc, FunctionLoc, Intern, ModuleDefId,\n     StaticLoc, StructLoc, TraitLoc, TypeAliasLoc, UnionLoc,\n@@ -102,7 +101,6 @@ impl ExprCollector<'_> {\n     }\n \n     fn alloc_expr(&mut self, expr: Expr, ptr: AstPtr<ast::Expr>) -> ExprId {\n-        let ptr = Either::Left(ptr);\n         let src = self.expander.to_source(ptr);\n         let id = self.make_expr(expr, Ok(src.clone()));\n         self.source_map.expr_map.insert(src, id);\n@@ -113,13 +111,6 @@ impl ExprCollector<'_> {\n     fn alloc_expr_desugared(&mut self, expr: Expr) -> ExprId {\n         self.make_expr(expr, Err(SyntheticSyntax))\n     }\n-    fn alloc_expr_field_shorthand(&mut self, expr: Expr, ptr: AstPtr<ast::RecordField>) -> ExprId {\n-        let ptr = Either::Right(ptr);\n-        let src = self.expander.to_source(ptr);\n-        let id = self.make_expr(expr, Ok(src.clone()));\n-        self.source_map.expr_map.insert(src, id);\n-        id\n-    }\n     fn empty_block(&mut self) -> ExprId {\n         self.alloc_expr_desugared(Expr::Block { statements: Vec::new(), tail: None })\n     }\n@@ -289,7 +280,7 @@ impl ExprCollector<'_> {\n             ast::Expr::ParenExpr(e) => {\n                 let inner = self.collect_expr_opt(e.expr());\n                 // make the paren expr point to the inner expression as well\n-                let src = self.expander.to_source(Either::Left(syntax_ptr));\n+                let src = self.expander.to_source(syntax_ptr);\n                 self.source_map.expr_map.insert(src, inner);\n                 inner\n             }\n@@ -309,22 +300,13 @@ impl ExprCollector<'_> {\n                             if !self.expander.is_cfg_enabled(&attrs) {\n                                 return None;\n                             }\n+                            let name = field.field_name()?.as_name();\n \n                             Some(RecordLitField {\n-                                name: field\n-                                    .name_ref()\n-                                    .map(|nr| nr.as_name())\n-                                    .unwrap_or_else(Name::missing),\n-                                expr: if let Some(e) = field.expr() {\n-                                    self.collect_expr(e)\n-                                } else if let Some(nr) = field.name_ref() {\n-                                    // field shorthand\n-                                    self.alloc_expr_field_shorthand(\n-                                        Expr::Path(Path::from_name_ref(&nr)),\n-                                        AstPtr::new(&field),\n-                                    )\n-                                } else {\n-                                    self.missing_expr()\n+                                name,\n+                                expr: match field.expr() {\n+                                    Some(e) => self.collect_expr(e),\n+                                    None => self.missing_expr(),\n                                 },\n                             })\n                         })"}, {"sha": "91c7b3e094191e6a476e83cb8a29096939c7939d", "filename": "crates/ra_hir_def/src/path.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1a1c09ed3e3a34c0a8750f98ece9ad85595395d2/crates%2Fra_hir_def%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a1c09ed3e3a34c0a8750f98ece9ad85595395d2/crates%2Fra_hir_def%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fpath.rs?ref=1a1c09ed3e3a34c0a8750f98ece9ad85595395d2", "patch": "@@ -134,11 +134,6 @@ impl Path {\n         lower::lower_path(path, hygiene)\n     }\n \n-    /// Converts an `ast::NameRef` into a single-identifier `Path`.\n-    pub(crate) fn from_name_ref(name_ref: &ast::NameRef) -> Path {\n-        Path { type_anchor: None, mod_path: name_ref.as_name().into(), generic_args: vec![None] }\n-    }\n-\n     /// Converts a known mod path to `Path`.\n     pub(crate) fn from_known_path(\n         path: ModPath,"}, {"sha": "69b527f74498267c6e924fd32281fa9303ba5119", "filename": "crates/ra_hir_ty/src/expr.rs", "status": "modified", "additions": 25, "deletions": 30, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/1a1c09ed3e3a34c0a8750f98ece9ad85595395d2/crates%2Fra_hir_ty%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a1c09ed3e3a34c0a8750f98ece9ad85595395d2/crates%2Fra_hir_ty%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fexpr.rs?ref=1a1c09ed3e3a34c0a8750f98ece9ad85595395d2", "patch": "@@ -89,21 +89,19 @@ impl<'a, 'b> ExprValidator<'a, 'b> {\n         let (_, source_map) = db.body_with_source_map(self.func.into());\n \n         if let Ok(source_ptr) = source_map.expr_syntax(id) {\n-            if let Some(expr) = source_ptr.value.as_ref().left() {\n-                let root = source_ptr.file_syntax(db.upcast());\n-                if let ast::Expr::RecordLit(record_lit) = expr.to_node(&root) {\n-                    if let Some(field_list) = record_lit.record_field_list() {\n-                        let variant_data = variant_data(db.upcast(), variant_def);\n-                        let missed_fields = missed_fields\n-                            .into_iter()\n-                            .map(|idx| variant_data.fields()[idx].name.clone())\n-                            .collect();\n-                        self.sink.push(MissingFields {\n-                            file: source_ptr.file_id,\n-                            field_list: AstPtr::new(&field_list),\n-                            missed_fields,\n-                        })\n-                    }\n+            let root = source_ptr.file_syntax(db.upcast());\n+            if let ast::Expr::RecordLit(record_lit) = &source_ptr.value.to_node(&root) {\n+                if let Some(field_list) = record_lit.record_field_list() {\n+                    let variant_data = variant_data(db.upcast(), variant_def);\n+                    let missed_fields = missed_fields\n+                        .into_iter()\n+                        .map(|idx| variant_data.fields()[idx].name.clone())\n+                        .collect();\n+                    self.sink.push(MissingFields {\n+                        file: source_ptr.file_id,\n+                        field_list: AstPtr::new(&field_list),\n+                        missed_fields,\n+                    })\n                 }\n             }\n         }\n@@ -205,18 +203,16 @@ impl<'a, 'b> ExprValidator<'a, 'b> {\n         }\n \n         if let Ok(source_ptr) = source_map.expr_syntax(id) {\n-            if let Some(expr) = source_ptr.value.as_ref().left() {\n-                let root = source_ptr.file_syntax(db.upcast());\n-                if let ast::Expr::MatchExpr(match_expr) = expr.to_node(&root) {\n-                    if let (Some(match_expr), Some(arms)) =\n-                        (match_expr.expr(), match_expr.match_arm_list())\n-                    {\n-                        self.sink.push(MissingMatchArms {\n-                            file: source_ptr.file_id,\n-                            match_expr: AstPtr::new(&match_expr),\n-                            arms: AstPtr::new(&arms),\n-                        })\n-                    }\n+            let root = source_ptr.file_syntax(db.upcast());\n+            if let ast::Expr::MatchExpr(match_expr) = &source_ptr.value.to_node(&root) {\n+                if let (Some(match_expr), Some(arms)) =\n+                    (match_expr.expr(), match_expr.match_arm_list())\n+                {\n+                    self.sink.push(MissingMatchArms {\n+                        file: source_ptr.file_id,\n+                        match_expr: AstPtr::new(&match_expr),\n+                        arms: AstPtr::new(&arms),\n+                    })\n                 }\n             }\n         }\n@@ -247,9 +243,8 @@ impl<'a, 'b> ExprValidator<'a, 'b> {\n             let (_, source_map) = db.body_with_source_map(self.func.into());\n \n             if let Ok(source_ptr) = source_map.expr_syntax(id) {\n-                if let Some(expr) = source_ptr.value.left() {\n-                    self.sink.push(MissingOkInTailExpr { file: source_ptr.file_id, expr });\n-                }\n+                self.sink\n+                    .push(MissingOkInTailExpr { file: source_ptr.file_id, expr: source_ptr.value });\n             }\n         }\n     }"}, {"sha": "81fc0f63a850717f8dfba207e6e267386b91e28c", "filename": "crates/ra_hir_ty/src/tests.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1a1c09ed3e3a34c0a8750f98ece9ad85595395d2/crates%2Fra_hir_ty%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a1c09ed3e3a34c0a8750f98ece9ad85595395d2/crates%2Fra_hir_ty%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests.rs?ref=1a1c09ed3e3a34c0a8750f98ece9ad85595395d2", "patch": "@@ -82,9 +82,7 @@ fn infer_with_mismatches(content: &str, include_mismatches: bool) -> String {\n \n         for (expr, ty) in inference_result.type_of_expr.iter() {\n             let syntax_ptr = match body_source_map.expr_syntax(expr) {\n-                Ok(sp) => {\n-                    sp.map(|ast| ast.either(|it| it.syntax_node_ptr(), |it| it.syntax_node_ptr()))\n-                }\n+                Ok(sp) => sp.map(|ast| ast.syntax_node_ptr()),\n                 Err(SyntheticSyntax) => continue,\n             };\n             types.push((syntax_ptr.clone(), ty));"}, {"sha": "0b0da6ee495b40bb5bf9b14fb6a8bbed10da45b2", "filename": "crates/ra_ide/src/completion/complete_unqualified_path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1a1c09ed3e3a34c0a8750f98ece9ad85595395d2/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_unqualified_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a1c09ed3e3a34c0a8750f98ece9ad85595395d2/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_unqualified_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_unqualified_path.rs?ref=1a1c09ed3e3a34c0a8750f98ece9ad85595395d2", "patch": "@@ -3,7 +3,7 @@\n use crate::completion::{CompletionContext, Completions};\n \n pub(super) fn complete_unqualified_path(acc: &mut Completions, ctx: &CompletionContext) {\n-    if !(ctx.is_trivial_path && !ctx.is_pat_binding_or_const) {\n+    if !(ctx.is_trivial_path && !ctx.is_pat_binding_or_const && !ctx.record_lit_syntax.is_some()) {\n         return;\n     }\n "}, {"sha": "14a4a14d7b2d19910931e955a1ea8be73482aaae", "filename": "crates/ra_ide/src/completion/completion_context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1a1c09ed3e3a34c0a8750f98ece9ad85595395d2/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcompletion_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a1c09ed3e3a34c0a8750f98ece9ad85595395d2/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcompletion_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcompletion_context.rs?ref=1a1c09ed3e3a34c0a8750f98ece9ad85595395d2", "patch": "@@ -227,7 +227,7 @@ impl<'a> CompletionContext<'a> {\n         self.name_ref_syntax =\n             find_node_at_offset(&original_file, name_ref.syntax().text_range().start());\n         let name_range = name_ref.syntax().text_range();\n-        if name_ref.syntax().parent().and_then(ast::RecordField::cast).is_some() {\n+        if ast::RecordField::for_field_name(&name_ref).is_some() {\n             self.record_lit_syntax =\n                 self.sema.find_node_at_offset_with_macros(&original_file, offset);\n         }"}, {"sha": "49a8c74fba7b2c0b3438f9846232a69fbb39ced8", "filename": "crates/ra_ide_db/src/defs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1a1c09ed3e3a34c0a8750f98ece9ad85595395d2/crates%2Fra_ide_db%2Fsrc%2Fdefs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a1c09ed3e3a34c0a8750f98ece9ad85595395d2/crates%2Fra_ide_db%2Fsrc%2Fdefs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_db%2Fsrc%2Fdefs.rs?ref=1a1c09ed3e3a34c0a8750f98ece9ad85595395d2", "patch": "@@ -216,7 +216,7 @@ pub fn classify_name_ref(\n         }\n     }\n \n-    if let Some(record_field) = ast::RecordField::cast(parent.clone()) {\n+    if let Some(record_field) = ast::RecordField::for_field_name(name_ref) {\n         tested_by!(goto_def_for_record_fields; force);\n         tested_by!(goto_def_for_field_init_shorthand; force);\n         if let Some((field, local)) = sema.resolve_record_field(&record_field) {"}, {"sha": "cb30b25a890ea05b6db8b3743558c07a49370315", "filename": "crates/ra_parser/src/grammar/expressions.rs", "status": "modified", "additions": 25, "deletions": 12, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/1a1c09ed3e3a34c0a8750f98ece9ad85595395d2/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fexpressions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a1c09ed3e3a34c0a8750f98ece9ad85595395d2/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fexpressions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fexpressions.rs?ref=1a1c09ed3e3a34c0a8750f98ece9ad85595395d2", "patch": "@@ -619,26 +619,39 @@ pub(crate) fn record_field_list(p: &mut Parser) {\n     let m = p.start();\n     p.bump(T!['{']);\n     while !p.at(EOF) && !p.at(T!['}']) {\n+        let m = p.start();\n+        // test record_literal_field_with_attr\n+        // fn main() {\n+        //     S { #[cfg(test)] field: 1 }\n+        // }\n+        attributes::outer_attributes(p);\n+\n         match p.current() {\n-            // test record_literal_field_with_attr\n-            // fn main() {\n-            //     S { #[cfg(test)] field: 1 }\n-            // }\n-            IDENT | INT_NUMBER | T![#] => {\n-                let m = p.start();\n-                attributes::outer_attributes(p);\n-                name_ref_or_index(p);\n-                if p.eat(T![:]) {\n-                    expr(p);\n+            IDENT | INT_NUMBER => {\n+                // test_err record_literal_before_ellipsis_recovery\n+                // fn main() {\n+                //     S { field ..S::default() }\n+                // }\n+                if p.nth_at(1, T![:]) || p.nth_at(1, T![..]) {\n+                    name_ref_or_index(p);\n+                    p.expect(T![:]);\n                 }\n+                expr(p);\n                 m.complete(p, RECORD_FIELD);\n             }\n             T![.] if p.at(T![..]) => {\n+                m.abandon(p);\n                 p.bump(T![..]);\n                 expr(p);\n             }\n-            T!['{'] => error_block(p, \"expected a field\"),\n-            _ => p.err_and_bump(\"expected identifier\"),\n+            T!['{'] => {\n+                error_block(p, \"expected a field\");\n+                m.abandon(p);\n+            }\n+            _ => {\n+                p.err_and_bump(\"expected identifier\");\n+                m.abandon(p);\n+            }\n         }\n         if !p.at(T!['}']) {\n             p.expect(T![,]);"}, {"sha": "63e272fbfa53bd17ee66d630aa0ec76b99d52fed", "filename": "crates/ra_syntax/src/ast/extensions.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/1a1c09ed3e3a34c0a8750f98ece9ad85595395d2/crates%2Fra_syntax%2Fsrc%2Fast%2Fextensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a1c09ed3e3a34c0a8750f98ece9ad85595395d2/crates%2Fra_syntax%2Fsrc%2Fast%2Fextensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fextensions.rs?ref=1a1c09ed3e3a34c0a8750f98ece9ad85595395d2", "patch": "@@ -187,6 +187,36 @@ impl ast::StructDef {\n     }\n }\n \n+impl ast::RecordField {\n+    pub fn for_field_name(field_name: &ast::NameRef) -> Option<ast::RecordField> {\n+        let candidate =\n+            field_name.syntax().parent().and_then(ast::RecordField::cast).or_else(|| {\n+                field_name.syntax().ancestors().nth(4).and_then(ast::RecordField::cast)\n+            })?;\n+        if candidate.field_name().as_ref() == Some(field_name) {\n+            Some(candidate)\n+        } else {\n+            None\n+        }\n+    }\n+\n+    /// Deals with field init shorthand\n+    pub fn field_name(&self) -> Option<ast::NameRef> {\n+        if let Some(name_ref) = self.name_ref() {\n+            return Some(name_ref);\n+        }\n+        if let Some(ast::Expr::PathExpr(expr)) = self.expr() {\n+            let path = expr.path()?;\n+            let segment = path.segment()?;\n+            let name_ref = segment.name_ref()?;\n+            if path.qualifier().is_none() {\n+                return Some(name_ref);\n+            }\n+        }\n+        None\n+    }\n+}\n+\n impl ast::EnumVariant {\n     pub fn parent_enum(&self) -> ast::EnumDef {\n         self.syntax()"}, {"sha": "a796e78b1251cebbc2136400be2804471e494dd2", "filename": "crates/ra_syntax/src/lib.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1a1c09ed3e3a34c0a8750f98ece9ad85595395d2/crates%2Fra_syntax%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a1c09ed3e3a34c0a8750f98ece9ad85595395d2/crates%2Fra_syntax%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Flib.rs?ref=1a1c09ed3e3a34c0a8750f98ece9ad85595395d2", "patch": "@@ -19,6 +19,11 @@\n //! [RFC]: <https://github.com/rust-lang/rfcs/pull/2256>\n //! [Swift]: <https://github.com/apple/swift/blob/13d593df6f359d0cb2fc81cfaac273297c539455/lib/Syntax/README.md>\n \n+#[allow(unused)]\n+macro_rules! eprintln {\n+    ($($tt:tt)*) => { stdx::eprintln!($($tt)*) };\n+}\n+\n mod syntax_node;\n mod syntax_error;\n mod parsing;"}, {"sha": "75043c9c048784d27379666026c1f30ca29d3d00", "filename": "crates/ra_syntax/test_data/parser/inline/err/0014_record_literal_before_ellipsis_recovery.rast", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/1a1c09ed3e3a34c0a8750f98ece9ad85595395d2/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Ferr%2F0014_record_literal_before_ellipsis_recovery.rast", "raw_url": "https://github.com/rust-lang/rust/raw/1a1c09ed3e3a34c0a8750f98ece9ad85595395d2/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Ferr%2F0014_record_literal_before_ellipsis_recovery.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Ferr%2F0014_record_literal_before_ellipsis_recovery.rast?ref=1a1c09ed3e3a34c0a8750f98ece9ad85595395d2", "patch": "@@ -0,0 +1,49 @@\n+SOURCE_FILE@[0; 45)\n+  FN_DEF@[0; 44)\n+    FN_KW@[0; 2) \"fn\"\n+    WHITESPACE@[2; 3) \" \"\n+    NAME@[3; 7)\n+      IDENT@[3; 7) \"main\"\n+    PARAM_LIST@[7; 9)\n+      L_PAREN@[7; 8) \"(\"\n+      R_PAREN@[8; 9) \")\"\n+    WHITESPACE@[9; 10) \" \"\n+    BLOCK_EXPR@[10; 44)\n+      BLOCK@[10; 44)\n+        L_CURLY@[10; 11) \"{\"\n+        WHITESPACE@[11; 16) \"\\n    \"\n+        RECORD_LIT@[16; 42)\n+          PATH@[16; 17)\n+            PATH_SEGMENT@[16; 17)\n+              NAME_REF@[16; 17)\n+                IDENT@[16; 17) \"S\"\n+          WHITESPACE@[17; 18) \" \"\n+          RECORD_FIELD_LIST@[18; 42)\n+            L_CURLY@[18; 19) \"{\"\n+            WHITESPACE@[19; 20) \" \"\n+            RECORD_FIELD@[20; 40)\n+              NAME_REF@[20; 25)\n+                IDENT@[20; 25) \"field\"\n+              WHITESPACE@[25; 26) \" \"\n+              RANGE_EXPR@[26; 40)\n+                DOT2@[26; 28) \"..\"\n+                CALL_EXPR@[28; 40)\n+                  PATH_EXPR@[28; 38)\n+                    PATH@[28; 38)\n+                      PATH@[28; 29)\n+                        PATH_SEGMENT@[28; 29)\n+                          NAME_REF@[28; 29)\n+                            IDENT@[28; 29) \"S\"\n+                      COLON2@[29; 31) \"::\"\n+                      PATH_SEGMENT@[31; 38)\n+                        NAME_REF@[31; 38)\n+                          IDENT@[31; 38) \"default\"\n+                  ARG_LIST@[38; 40)\n+                    L_PAREN@[38; 39) \"(\"\n+                    R_PAREN@[39; 40) \")\"\n+            WHITESPACE@[40; 41) \" \"\n+            R_CURLY@[41; 42) \"}\"\n+        WHITESPACE@[42; 43) \"\\n\"\n+        R_CURLY@[43; 44) \"}\"\n+  WHITESPACE@[44; 45) \"\\n\"\n+error [25; 25): expected COLON"}, {"sha": "a4e5b2f69336f67002441eb47ddbe64744ca694c", "filename": "crates/ra_syntax/test_data/parser/inline/err/0014_record_literal_before_ellipsis_recovery.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1a1c09ed3e3a34c0a8750f98ece9ad85595395d2/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Ferr%2F0014_record_literal_before_ellipsis_recovery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a1c09ed3e3a34c0a8750f98ece9ad85595395d2/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Ferr%2F0014_record_literal_before_ellipsis_recovery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Ferr%2F0014_record_literal_before_ellipsis_recovery.rs?ref=1a1c09ed3e3a34c0a8750f98ece9ad85595395d2", "patch": "@@ -0,0 +1,3 @@\n+fn main() {\n+    S { field ..S::default() }\n+}"}, {"sha": "89a61179967d3f80cf4facaf22b6bf6b02abf2fb", "filename": "crates/ra_syntax/test_data/parser/inline/ok/0061_record_lit.rast", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1a1c09ed3e3a34c0a8750f98ece9ad85595395d2/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0061_record_lit.rast", "raw_url": "https://github.com/rust-lang/rust/raw/1a1c09ed3e3a34c0a8750f98ece9ad85595395d2/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0061_record_lit.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0061_record_lit.rast?ref=1a1c09ed3e3a34c0a8750f98ece9ad85595395d2", "patch": "@@ -35,8 +35,11 @@ SOURCE_FILE@[0; 112)\n               L_CURLY@[27; 28) \"{\"\n               WHITESPACE@[28; 29) \" \"\n               RECORD_FIELD@[29; 30)\n-                NAME_REF@[29; 30)\n-                  IDENT@[29; 30) \"x\"\n+                PATH_EXPR@[29; 30)\n+                  PATH@[29; 30)\n+                    PATH_SEGMENT@[29; 30)\n+                      NAME_REF@[29; 30)\n+                        IDENT@[29; 30) \"x\"\n               COMMA@[30; 31) \",\"\n               WHITESPACE@[31; 32) \" \"\n               RECORD_FIELD@[32; 37)\n@@ -62,8 +65,11 @@ SOURCE_FILE@[0; 112)\n               L_CURLY@[48; 49) \"{\"\n               WHITESPACE@[49; 50) \" \"\n               RECORD_FIELD@[50; 51)\n-                NAME_REF@[50; 51)\n-                  IDENT@[50; 51) \"x\"\n+                PATH_EXPR@[50; 51)\n+                  PATH@[50; 51)\n+                    PATH_SEGMENT@[50; 51)\n+                      NAME_REF@[50; 51)\n+                        IDENT@[50; 51) \"x\"\n               COMMA@[51; 52) \",\"\n               WHITESPACE@[52; 53) \" \"\n               RECORD_FIELD@[53; 58)"}, {"sha": "e9ee0b888f45cff0a01e42b2418d9c878de1ec70", "filename": "crates/rust-analyzer/src/cli/analysis_stats.rs", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1a1c09ed3e3a34c0a8750f98ece9ad85595395d2/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fanalysis_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a1c09ed3e3a34c0a8750f98ece9ad85595395d2/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fanalysis_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fanalysis_stats.rs?ref=1a1c09ed3e3a34c0a8750f98ece9ad85595395d2", "patch": "@@ -163,10 +163,7 @@ pub fn analysis_stats(\n                 if let Ok(src) = src {\n                     let original_file = src.file_id.original_file(db);\n                     let line_index = host.analysis().file_line_index(original_file).unwrap();\n-                    let text_range = src.value.either(\n-                        |it| it.syntax_node_ptr().range(),\n-                        |it| it.syntax_node_ptr().range(),\n-                    );\n+                    let text_range = src.value.syntax_node_ptr().range();\n                     let (start, end) = (\n                         line_index.line_col(text_range.start()),\n                         line_index.line_col(text_range.end()),\n@@ -192,12 +189,7 @@ pub fn analysis_stats(\n                         // FIXME: it might be nice to have a function (on Analysis?) that goes from Source<T> -> (LineCol, LineCol) directly\n                         // But also, we should just turn the type mismatches into diagnostics and provide these\n                         let root = db.parse_or_expand(src.file_id).unwrap();\n-                        let node = src.map(|e| {\n-                            e.either(\n-                                |p| p.to_node(&root).syntax().clone(),\n-                                |p| p.to_node(&root).syntax().clone(),\n-                            )\n-                        });\n+                        let node = src.map(|e| e.to_node(&root).syntax().clone());\n                         let original_range = original_range(db, node.as_ref());\n                         let path = db.file_relative_path(original_range.file_id);\n                         let line_index ="}, {"sha": "4164bfd5eda1b96a84c86897fd7c74c3c539f5dc", "filename": "crates/test_utils/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1a1c09ed3e3a34c0a8750f98ece9ad85595395d2/crates%2Ftest_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a1c09ed3e3a34c0a8750f98ece9ad85595395d2/crates%2Ftest_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest_utils%2Fsrc%2Flib.rs?ref=1a1c09ed3e3a34c0a8750f98ece9ad85595395d2", "patch": "@@ -395,7 +395,7 @@ pub fn skip_slow_tests() -> bool {\n     should_skip\n }\n \n-const REWRITE: bool = true;\n+const REWRITE: bool = false;\n \n /// Asserts that `expected` and `actual` strings are equal. If they differ only\n /// in trailing or leading whitespace the test won't fail and"}]}