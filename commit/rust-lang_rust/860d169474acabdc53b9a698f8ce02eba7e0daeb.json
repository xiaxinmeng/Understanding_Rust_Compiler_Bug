{"sha": "860d169474acabdc53b9a698f8ce02eba7e0daeb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg2MGQxNjk0NzRhY2FiZGM1M2I5YTY5OGY4Y2UwMmViYTdlMGRhZWI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-07-03T12:26:14Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-07-03T12:26:14Z"}, "message": "Auto merge of #52014 - pietroalbini:rollup, r=pietroalbini\n\nRollup of 13 pull requests\n\nSuccessful merges:\n\n - #51548 (Initialize LLVM's AMDGPU target machine, if available.)\n - #51809 (Add read_exact_at and write_all_at methods to FileExt on unix)\n - #51914 (add outlives annotations to `BTreeMap`)\n - #51958 (Show known meta items in unknown meta items error)\n - #51973 (Make Stdio handle UnwindSafe)\n - #51977 (bootstrap: tests should use rustc from config.toml)\n - #51978 (Do not suggest changes to str literal if it isn't one)\n - #51979 (Get rid of `TyImplTraitExistential`)\n - #51980 (Emit column info in debuginfo for non msvc like targets)\n - #51982 (incr.comp.: Take names of children into account when computing the ICH of a module's HIR.)\n - #51997 (add entry for cargo-metadata feature to RELEASES)\n - #52004 (toolstate: Fixed detection of changed submodule, and other fixes.)\n - #52006 ( Change --keep-stage to apply more often)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "2cc22e334f2b368e3250239e10eef93d1f991c1e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2cc22e334f2b368e3250239e10eef93d1f991c1e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/860d169474acabdc53b9a698f8ce02eba7e0daeb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/860d169474acabdc53b9a698f8ce02eba7e0daeb", "html_url": "https://github.com/rust-lang/rust/commit/860d169474acabdc53b9a698f8ce02eba7e0daeb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/860d169474acabdc53b9a698f8ce02eba7e0daeb/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "64f8ae08fd5294718466a61f74f6de0135b88035", "url": "https://api.github.com/repos/rust-lang/rust/commits/64f8ae08fd5294718466a61f74f6de0135b88035", "html_url": "https://github.com/rust-lang/rust/commit/64f8ae08fd5294718466a61f74f6de0135b88035"}, {"sha": "492518fcd5a3a0ce145a0b675d480d6c212d4b03", "url": "https://api.github.com/repos/rust-lang/rust/commits/492518fcd5a3a0ce145a0b675d480d6c212d4b03", "html_url": "https://github.com/rust-lang/rust/commit/492518fcd5a3a0ce145a0b675d480d6c212d4b03"}], "stats": {"total": 2180, "additions": 1259, "deletions": 921}, "files": [{"sha": "ba8a39f355c4ba0544643f7dd9900471bd98f81e", "filename": ".travis.yml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/860d169474acabdc53b9a698f8ce02eba7e0daeb/.travis.yml", "raw_url": "https://github.com/rust-lang/rust/raw/860d169474acabdc53b9a698f8ce02eba7e0daeb/.travis.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.travis.yml?ref=860d169474acabdc53b9a698f8ce02eba7e0daeb", "patch": "@@ -169,7 +169,7 @@ matrix:\n     - env: IMAGE=x86_64-gnu-aux\n       if: branch = auto\n     - env: IMAGE=x86_64-gnu-tools\n-      if: branch = auto\n+      if: branch = auto OR (type = pull_request AND commit_message =~ /(?i:^update.*\\b(rls|rustfmt|clippy|miri)\\b)/)\n     - env: IMAGE=x86_64-gnu-debug\n       if: branch = auto\n     - env: IMAGE=x86_64-gnu-nopt"}, {"sha": "9d922f493d08ba7d2017956ea9ccd0f120b906a6", "filename": "RELEASES.md", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/860d169474acabdc53b9a698f8ce02eba7e0daeb/RELEASES.md", "raw_url": "https://github.com/rust-lang/rust/raw/860d169474acabdc53b9a698f8ce02eba7e0daeb/RELEASES.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/RELEASES.md?ref=860d169474acabdc53b9a698f8ce02eba7e0daeb", "patch": "@@ -65,6 +65,7 @@ Cargo\n -----\n - [`cargo-metadata` now includes `authors`, `categories`, `keywords`,\n   `readme`, and `repository` fields.][cargo/5386]\n+- [`cargo-metadata` now includes a package's `metadata` table.][cargo/5360]\n - [Added the `--target-dir` optional argument.][cargo/5393] This allows you to specify\n   a different directory than `target` for placing compilation artifacts.\n - [Cargo will be adding automatic target inference for binaries, benchmarks,\n@@ -114,6 +115,7 @@ Compatibility Notes\n [cargo/5203]: https://github.com/rust-lang/cargo/pull/5203/\n [cargo/5335]: https://github.com/rust-lang/cargo/pull/5335/\n [cargo/5359]: https://github.com/rust-lang/cargo/pull/5359/\n+[cargo/5360]: https://github.com/rust-lang/cargo/pull/5360/\n [cargo/5386]: https://github.com/rust-lang/cargo/pull/5386/\n [cargo/5393]: https://github.com/rust-lang/cargo/pull/5393/\n [`DoubleEndedIterator::rfind`]: https://doc.rust-lang.org/std/iter/trait.DoubleEndedIterator.html#method.rfind"}, {"sha": "512d4d8c5b792ce0e1958574ff59e0168996793c", "filename": "src/bootstrap/bootstrap.py", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/860d169474acabdc53b9a698f8ce02eba7e0daeb/src%2Fbootstrap%2Fbootstrap.py", "raw_url": "https://github.com/rust-lang/rust/raw/860d169474acabdc53b9a698f8ce02eba7e0daeb/src%2Fbootstrap%2Fbootstrap.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbootstrap.py?ref=860d169474acabdc53b9a698f8ce02eba7e0daeb", "patch": "@@ -816,6 +816,8 @@ def bootstrap(help_triggered):\n     env[\"BOOTSTRAP_PYTHON\"] = sys.executable\n     env[\"BUILD_DIR\"] = build.build_dir\n     env[\"RUSTC_BOOTSTRAP\"] = '1'\n+    env[\"CARGO\"] = build.cargo()\n+    env[\"RUSTC\"] = build.rustc()\n     run(args, env=env, verbose=build.verbose)\n \n "}, {"sha": "aef2df3e2780f40e500c68c766b92851accfebdb", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 44, "deletions": 21, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/860d169474acabdc53b9a698f8ce02eba7e0daeb/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/860d169474acabdc53b9a698f8ce02eba7e0daeb/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=860d169474acabdc53b9a698f8ce02eba7e0daeb", "patch": "@@ -24,7 +24,6 @@ use std::io::prelude::*;\n use std::path::{Path, PathBuf};\n use std::process::{Command, Stdio};\n use std::str;\n-use std::cmp::min;\n \n use build_helper::{output, mtime, up_to_date};\n use filetime::FileTime;\n@@ -68,6 +67,18 @@ impl Step for Std {\n         let target = self.target;\n         let compiler = self.compiler;\n \n+        if let Some(keep_stage) = builder.config.keep_stage {\n+            if keep_stage <= compiler.stage {\n+                println!(\"Warning: Using a potentially old libstd. This may not behave well.\");\n+                builder.ensure(StdLink {\n+                    compiler: compiler,\n+                    target_compiler: compiler,\n+                    target,\n+                });\n+                return;\n+            }\n+        }\n+\n         builder.ensure(StartupObjects { compiler, target });\n \n         if builder.force_use_stage1(compiler, target) {\n@@ -351,6 +362,18 @@ impl Step for Test {\n         let target = self.target;\n         let compiler = self.compiler;\n \n+        if let Some(keep_stage) = builder.config.keep_stage {\n+            if keep_stage <= compiler.stage {\n+                println!(\"Warning: Using a potentially old libtest. This may not behave well.\");\n+                builder.ensure(TestLink {\n+                    compiler: compiler,\n+                    target_compiler: compiler,\n+                    target,\n+                });\n+                return;\n+            }\n+        }\n+\n         builder.ensure(Std { compiler, target });\n \n         if builder.force_use_stage1(compiler, target) {\n@@ -467,6 +490,18 @@ impl Step for Rustc {\n         let compiler = self.compiler;\n         let target = self.target;\n \n+        if let Some(keep_stage) = builder.config.keep_stage {\n+            if keep_stage <= compiler.stage {\n+                println!(\"Warning: Using a potentially old librustc. This may not behave well.\");\n+                builder.ensure(RustcLink {\n+                    compiler: compiler,\n+                    target_compiler: compiler,\n+                    target,\n+                });\n+                return;\n+            }\n+        }\n+\n         builder.ensure(Test { compiler, target });\n \n         if builder.force_use_stage1(compiler, target) {\n@@ -873,7 +908,7 @@ impl Step for Assemble {\n     type Output = Compiler;\n \n     fn should_run(run: ShouldRun) -> ShouldRun {\n-        run.all_krates(\"rustc-main\")\n+        run.never()\n     }\n \n     /// Prepare a new compiler from the artifacts in `stage`\n@@ -915,28 +950,16 @@ impl Step for Assemble {\n         // link to these. (FIXME: Is that correct? It seems to be correct most\n         // of the time but I think we do link to these for stage2/bin compilers\n         // when not performing a full bootstrap).\n-        if builder.config.keep_stage.map_or(false, |s| target_compiler.stage <= s) {\n-            builder.verbose(\"skipping compilation of compiler due to --keep-stage\");\n-            let compiler = build_compiler;\n-            for stage in 0..min(target_compiler.stage, builder.config.keep_stage.unwrap()) {\n-                let target_compiler = builder.compiler(stage, target_compiler.host);\n-                let target = target_compiler.host;\n-                builder.ensure(StdLink { compiler, target_compiler, target });\n-                builder.ensure(TestLink { compiler, target_compiler, target });\n-                builder.ensure(RustcLink { compiler, target_compiler, target });\n-            }\n-        } else {\n-            builder.ensure(Rustc {\n+        builder.ensure(Rustc {\n+            compiler: build_compiler,\n+            target: target_compiler.host,\n+        });\n+        for &backend in builder.config.rust_codegen_backends.iter() {\n+            builder.ensure(CodegenBackend {\n                 compiler: build_compiler,\n                 target: target_compiler.host,\n+                backend,\n             });\n-            for &backend in builder.config.rust_codegen_backends.iter() {\n-                builder.ensure(CodegenBackend {\n-                    compiler: build_compiler,\n-                    target: target_compiler.host,\n-                    backend,\n-                });\n-            }\n         }\n \n         let lld_install = if builder.config.lld_enabled {"}, {"sha": "b3ed10257bdacf2d3c11256b45f7959df593b646", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/860d169474acabdc53b9a698f8ce02eba7e0daeb/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/860d169474acabdc53b9a698f8ce02eba7e0daeb/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=860d169474acabdc53b9a698f8ce02eba7e0daeb", "patch": "@@ -23,7 +23,6 @@ use std::cmp;\n \n use num_cpus;\n use toml;\n-use util::exe;\n use cache::{INTERNER, Interned};\n use flags::Flags;\n pub use flags::Subcommand;\n@@ -367,9 +366,8 @@ impl Config {\n         config.src = Config::path_from_python(\"SRC\");\n         config.out = Config::path_from_python(\"BUILD_DIR\");\n \n-        let stage0_root = config.out.join(&config.build).join(\"stage0/bin\");\n-        config.initial_rustc = stage0_root.join(exe(\"rustc\", &config.build));\n-        config.initial_cargo = stage0_root.join(exe(\"cargo\", &config.build));\n+        config.initial_rustc = Config::path_from_python(\"RUSTC\");\n+        config.initial_cargo = Config::path_from_python(\"CARGO\");\n \n         config\n     }"}, {"sha": "3adfbb5e36b51d2088ba4f6aa7f18b11b21fc7b7", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/860d169474acabdc53b9a698f8ce02eba7e0daeb/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/860d169474acabdc53b9a698f8ce02eba7e0daeb/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=860d169474acabdc53b9a698f8ce02eba7e0daeb", "patch": "@@ -1269,17 +1269,15 @@ impl Step for DocTest {\n \n         files.sort();\n \n+        let mut toolstate = ToolState::TestPass;\n         for file in files {\n-            let test_result = markdown_test(builder, compiler, &file);\n-            if self.is_ext_doc {\n-                let toolstate = if test_result {\n-                    ToolState::TestPass\n-                } else {\n-                    ToolState::TestFail\n-                };\n-                builder.save_toolstate(self.name, toolstate);\n+            if !markdown_test(builder, compiler, &file) {\n+                toolstate = ToolState::TestFail;\n             }\n         }\n+        if self.is_ext_doc {\n+            builder.save_toolstate(self.name, toolstate);\n+        }\n     }\n }\n "}, {"sha": "e8197e9085182accd4e53aa2c43f9e7c95ac5fb1", "filename": "src/ci/docker/x86_64-gnu-tools/checktools.sh", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/860d169474acabdc53b9a698f8ce02eba7e0daeb/src%2Fci%2Fdocker%2Fx86_64-gnu-tools%2Fchecktools.sh", "raw_url": "https://github.com/rust-lang/rust/raw/860d169474acabdc53b9a698f8ce02eba7e0daeb/src%2Fci%2Fdocker%2Fx86_64-gnu-tools%2Fchecktools.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-tools%2Fchecktools.sh?ref=860d169474acabdc53b9a698f8ce02eba7e0daeb", "patch": "@@ -79,11 +79,11 @@ status_check() {\n     check_dispatch $1 beta nomicon src/doc/nomicon\n     check_dispatch $1 beta reference src/doc/reference\n     check_dispatch $1 beta rust-by-example src/doc/rust-by-example\n-    check_dispatch $1 beta rls src/tool/rls\n-    check_dispatch $1 beta rustfmt src/tool/rustfmt\n+    check_dispatch $1 beta rls src/tools/rls\n+    check_dispatch $1 beta rustfmt src/tools/rustfmt\n     # these tools are not required for beta to successfully branch\n-    check_dispatch $1 nightly clippy-driver src/tool/clippy\n-    check_dispatch $1 nightly miri src/tool/miri\n+    check_dispatch $1 nightly clippy-driver src/tools/clippy\n+    check_dispatch $1 nightly miri src/tools/miri\n }\n \n # If this PR is intended to update one of these tools, do not let the build pass"}, {"sha": "8c950cd06d9e385373f56175d5253060c4e8390a", "filename": "src/liballoc/collections/btree/map.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/860d169474acabdc53b9a698f8ce02eba7e0daeb/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/860d169474acabdc53b9a698f8ce02eba7e0daeb/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs?ref=860d169474acabdc53b9a698f8ce02eba7e0daeb", "patch": "@@ -149,12 +149,11 @@ unsafe impl<#[may_dangle] K, #[may_dangle] V> Drop for BTreeMap<K, V> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K: Clone, V: Clone> Clone for BTreeMap<K, V> {\n     fn clone(&self) -> BTreeMap<K, V> {\n-        fn clone_subtree<K: Clone, V: Clone>(node: node::NodeRef<marker::Immut,\n-                                                                 K,\n-                                                                 V,\n-                                                                 marker::LeafOrInternal>)\n-                                             -> BTreeMap<K, V> {\n-\n+        fn clone_subtree<'a, K: Clone, V: Clone>(\n+            node: node::NodeRef<marker::Immut<'a>, K, V, marker::LeafOrInternal>\n+        ) -> BTreeMap<K, V>\n+        where K: 'a, V: 'a,\n+        {\n             match node.force() {\n                 Leaf(leaf) => {\n                     let mut out_tree = BTreeMap {\n@@ -1080,7 +1079,11 @@ impl<K: Ord, V> BTreeMap<K, V> {\n \n     /// Calculates the number of elements if it is incorrect.\n     fn recalc_length(&mut self) {\n-        fn dfs<K, V>(node: NodeRef<marker::Immut, K, V, marker::LeafOrInternal>) -> usize {\n+        fn dfs<'a, K, V>(\n+            node: NodeRef<marker::Immut<'a>, K, V, marker::LeafOrInternal>\n+        ) -> usize\n+        where K: 'a, V: 'a\n+        {\n             let mut res = node.len();\n \n             if let Internal(node) = node.force() {"}, {"sha": "a7ed854d016494584fe4009e89b83af3fcc83a26", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/860d169474acabdc53b9a698f8ce02eba7e0daeb/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/860d169474acabdc53b9a698f8ce02eba7e0daeb/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=860d169474acabdc53b9a698f8ce02eba7e0daeb", "patch": "@@ -607,13 +607,6 @@ pub fn walk_ty<'v, V: Visitor<'v>>(visitor: &mut V, typ: &'v Ty) {\n             }\n             visitor.visit_lifetime(lifetime);\n         }\n-        TyImplTraitExistential(_, def_id, ref lifetimes) => {\n-            // we are not recursing into the `existential` item, because it is already being visited\n-            // as part of the surrounding module. The `NodeId` just exists so we don't have to look\n-            // it up everywhere else in the compiler\n-            visitor.visit_def_mention(Def::Existential(def_id));\n-            walk_list!(visitor, visit_lifetime, lifetimes);\n-        }\n         TyTypeof(ref expression) => {\n             visitor.visit_anon_const(expression)\n         }"}, {"sha": "5990340ae29553e222cf7cc5215ce9740e0abfe4", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 18, "deletions": 11, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/860d169474acabdc53b9a698f8ce02eba7e0daeb/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/860d169474acabdc53b9a698f8ce02eba7e0daeb/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=860d169474acabdc53b9a698f8ce02eba7e0daeb", "patch": "@@ -1306,13 +1306,20 @@ impl<'a> LoweringContext<'a> {\n             lctx.items.insert(exist_ty_id.node_id, exist_ty_item);\n \n             // `impl Trait` now just becomes `Foo<'a, 'b, ..>`\n-            hir::TyImplTraitExistential(\n-                hir::ItemId {\n-                    id: exist_ty_id.node_id\n-                },\n-                DefId::local(exist_ty_def_index),\n-                lifetimes,\n-            )\n+            let path = P(hir::Path {\n+                span: exist_ty_span,\n+                def: Def::Existential(DefId::local(exist_ty_def_index)),\n+                segments: hir_vec![hir::PathSegment {\n+                    infer_types: false,\n+                    ident: Ident::new(keywords::Invalid.name(), exist_ty_span),\n+                    args: Some(P(hir::GenericArgs {\n+                        parenthesized: false,\n+                        bindings: HirVec::new(),\n+                        args: lifetimes,\n+                    }))\n+                }],\n+            });\n+            hir::TyPath(hir::QPath::Resolved(None, path))\n         })\n     }\n \n@@ -1321,7 +1328,7 @@ impl<'a> LoweringContext<'a> {\n         exist_ty_id: NodeId,\n         parent_index: DefIndex,\n         bounds: &hir::GenericBounds,\n-    ) -> (HirVec<hir::Lifetime>, HirVec<hir::GenericParam>) {\n+    ) -> (HirVec<hir::GenericArg>, HirVec<hir::GenericParam>) {\n         // This visitor walks over impl trait bounds and creates defs for all lifetimes which\n         // appear in the bounds, excluding lifetimes that are created within the bounds.\n         // e.g. 'a, 'b, but not 'c in `impl for<'c> SomeTrait<'a, 'b, 'c>`\n@@ -1332,7 +1339,7 @@ impl<'a> LoweringContext<'a> {\n             collect_elided_lifetimes: bool,\n             currently_bound_lifetimes: Vec<hir::LifetimeName>,\n             already_defined_lifetimes: HashSet<hir::LifetimeName>,\n-            output_lifetimes: Vec<hir::Lifetime>,\n+            output_lifetimes: Vec<hir::GenericArg>,\n             output_lifetime_params: Vec<hir::GenericParam>,\n         }\n \n@@ -1416,11 +1423,11 @@ impl<'a> LoweringContext<'a> {\n                     && !self.already_defined_lifetimes.contains(&name) {\n                     self.already_defined_lifetimes.insert(name);\n \n-                    self.output_lifetimes.push(hir::Lifetime {\n+                    self.output_lifetimes.push(hir::GenericArg::Lifetime(hir::Lifetime {\n                         id: self.context.next_id().node_id,\n                         span: lifetime.span,\n                         name,\n-                    });\n+                    }));\n \n                     // We need to manually create the ids here, because the\n                     // definitions will go into the explicit `existential type`"}, {"sha": "328cb8225478bdc159c503a1b678203e580d6aaa", "filename": "src/librustc/hir/map/definitions.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/860d169474acabdc53b9a698f8ce02eba7e0daeb/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/860d169474acabdc53b9a698f8ce02eba7e0daeb/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs?ref=860d169474acabdc53b9a698f8ce02eba7e0daeb", "patch": "@@ -23,6 +23,7 @@ use rustc_data_structures::indexed_vec::{IndexVec};\n use rustc_data_structures::stable_hasher::StableHasher;\n use serialize::{Encodable, Decodable, Encoder, Decoder};\n use session::CrateDisambiguator;\n+use std::borrow::Borrow;\n use std::fmt::Write;\n use std::hash::Hash;\n use syntax::ast;\n@@ -389,6 +390,13 @@ pub struct DefPathHash(pub Fingerprint);\n \n impl_stable_hash_for!(tuple_struct DefPathHash { fingerprint });\n \n+impl Borrow<Fingerprint> for DefPathHash {\n+    #[inline]\n+    fn borrow(&self) -> &Fingerprint {\n+        &self.0\n+    }\n+}\n+\n impl Definitions {\n     /// Create new empty definition map.\n     pub fn new() -> Definitions {"}, {"sha": "8d83dd3279c64d4b690c33608b3258128856e7b6", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/860d169474acabdc53b9a698f8ce02eba7e0daeb/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/860d169474acabdc53b9a698f8ce02eba7e0daeb/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=860d169474acabdc53b9a698f8ce02eba7e0daeb", "patch": "@@ -1692,18 +1692,6 @@ pub enum Ty_ {\n     /// A trait object type `Bound1 + Bound2 + Bound3`\n     /// where `Bound` is a trait or a lifetime.\n     TyTraitObject(HirVec<PolyTraitRef>, Lifetime),\n-    /// An existentially quantified (there exists a type satisfying) `impl\n-    /// Bound1 + Bound2 + Bound3` type where `Bound` is a trait or a lifetime.\n-    ///\n-    /// The `Item` is the generated\n-    /// `existential type Foo<'a, 'b>: MyTrait<'a, 'b>;`.\n-    ///\n-    /// The `HirVec<Lifetime>` is the list of lifetimes applied as parameters\n-    /// to the `abstract type`, e.g. the `'c` and `'d` in `-> Foo<'c, 'd>`.\n-    /// This list is only a list of lifetimes and not type parameters\n-    /// because all in-scope type parameters are captured by `impl Trait`,\n-    /// so they are resolved directly through the parent `Generics`.\n-    TyImplTraitExistential(ItemId, DefId, HirVec<Lifetime>),\n     /// Unused for now\n     TyTypeof(AnonConst),\n     /// TyInfer means the type should be inferred instead of it having been"}, {"sha": "4d0969d898e91434b7a92ad72a81fef79444f073", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/860d169474acabdc53b9a698f8ce02eba7e0daeb/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/860d169474acabdc53b9a698f8ce02eba7e0daeb/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=860d169474acabdc53b9a698f8ce02eba7e0daeb", "patch": "@@ -420,15 +420,6 @@ impl<'a> State<'a> {\n                     self.print_lifetime(lifetime)?;\n                 }\n             }\n-            hir::TyImplTraitExistential(hir_id, _def_id, ref _lifetimes) => {\n-                match self.ann.try_fetch_item(hir_id.id).map(|it| &it.node) {\n-                    None => self.word_space(\"impl {{Trait}}\")?,\n-                    Some(&hir::ItemExistential(ref exist_ty)) => {\n-                        self.print_bounds(\"impl\", &exist_ty.bounds)?;\n-                    },\n-                    other => bug!(\"impl Trait pointed to {:#?}\", other),\n-                }\n-            }\n             hir::TyArray(ref ty, ref length) => {\n                 self.s.word(\"[\")?;\n                 self.print_type(&ty)?;"}, {"sha": "a6e35d78dcb5aaef76b09a3ed1cb7c9f03cd4b76", "filename": "src/librustc/ich/fingerprint.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/860d169474acabdc53b9a698f8ce02eba7e0daeb/src%2Flibrustc%2Fich%2Ffingerprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/860d169474acabdc53b9a698f8ce02eba7e0daeb/src%2Flibrustc%2Fich%2Ffingerprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Ffingerprint.rs?ref=860d169474acabdc53b9a698f8ce02eba7e0daeb", "patch": "@@ -45,6 +45,18 @@ impl Fingerprint {\n         )\n     }\n \n+    // Combines two hashes in an order independent way. Make sure this is what\n+    // you want.\n+    #[inline]\n+    pub fn combine_commutative(self, other: Fingerprint) -> Fingerprint {\n+        let a = (self.1 as u128) << 64 | self.0 as u128;\n+        let b = (other.1 as u128) << 64 | other.0 as u128;\n+\n+        let c = a.wrapping_add(b);\n+\n+        Fingerprint((c >> 64) as u64, c as u64)\n+    }\n+\n     pub fn to_hex(&self) -> String {\n         format!(\"{:x}{:x}\", self.0, self.1)\n     }"}, {"sha": "8b62ba119ebb8feadb334100d8b5006a773856f6", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 29, "deletions": 9, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/860d169474acabdc53b9a698f8ce02eba7e0daeb/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/860d169474acabdc53b9a698f8ce02eba7e0daeb/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=860d169474acabdc53b9a698f8ce02eba7e0daeb", "patch": "@@ -14,7 +14,7 @@\n use hir;\n use hir::map::DefPathHash;\n use hir::def_id::{DefId, LocalDefId, CrateNum, CRATE_DEF_INDEX};\n-use ich::{StableHashingContext, NodeIdHashingMode};\n+use ich::{StableHashingContext, NodeIdHashingMode, Fingerprint};\n use rustc_data_structures::stable_hasher::{HashStable, ToStableHashKey,\n                                            StableHasher, StableHasherResult};\n use std::mem;\n@@ -340,7 +340,6 @@ impl_stable_hash_for!(enum hir::Ty_ {\n     TyTup(ts),\n     TyPath(qpath),\n     TyTraitObject(trait_refs, lifetime),\n-    TyImplTraitExistential(existty, def_id, lifetimes),\n     TyTypeof(body_id),\n     TyErr,\n     TyInfer\n@@ -756,13 +755,34 @@ impl_stable_hash_for!(enum hir::ImplPolarity {\n     Negative\n });\n \n-impl_stable_hash_for!(struct hir::Mod {\n-    inner,\n-    // We are not hashing the IDs of the items contained in the module.\n-    // This is harmless and matches the current behavior but it's not\n-    // actually correct. See issue #40876.\n-    item_ids -> _,\n-});\n+impl<'a> HashStable<StableHashingContext<'a>> for hir::Mod {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a>,\n+                                          hasher: &mut StableHasher<W>) {\n+        let hir::Mod {\n+            inner: ref inner_span,\n+            ref item_ids,\n+        } = *self;\n+\n+        inner_span.hash_stable(hcx, hasher);\n+\n+        // Combining the DefPathHashes directly is faster than feeding them\n+        // into the hasher. Because we use a commutative combine, we also don't\n+        // have to sort the array.\n+        let item_ids_hash = item_ids\n+            .iter()\n+            .map(|id| {\n+                let (def_path_hash, local_id) = id.id.to_stable_hash_key(hcx);\n+                debug_assert_eq!(local_id, hir::ItemLocalId(0));\n+                def_path_hash.0\n+            }).fold(Fingerprint::ZERO, |a, b| {\n+                a.combine_commutative(b)\n+            });\n+\n+        item_ids.len().hash_stable(hcx, hasher);\n+        item_ids_hash.hash_stable(hcx, hasher);\n+    }\n+}\n \n impl_stable_hash_for!(struct hir::ForeignMod {\n     abi,"}, {"sha": "369f65c214aa107cc30cf51fcfa5476419722a1e", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 100, "deletions": 91, "changes": 191, "blob_url": "https://github.com/rust-lang/rust/blob/860d169474acabdc53b9a698f8ce02eba7e0daeb/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/860d169474acabdc53b9a698f8ce02eba7e0daeb/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=860d169474acabdc53b9a698f8ce02eba7e0daeb", "patch": "@@ -625,122 +625,131 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 };\n                 self.with(scope, |_, this| this.visit_ty(&mt.ty));\n             }\n-            hir::TyImplTraitExistential(item_id, _, ref lifetimes) => {\n-                // Resolve the lifetimes that are applied to the existential type.\n-                // These are resolved in the current scope.\n-                // `fn foo<'a>() -> impl MyTrait<'a> { ... }` desugars to\n-                // `fn foo<'a>() -> MyAnonTy<'a> { ... }`\n-                //          ^                 ^this gets resolved in the current scope\n-                for lifetime in lifetimes {\n-                    self.visit_lifetime(lifetime);\n-\n-                    // Check for predicates like `impl for<'a> SomeTrait<impl OtherTrait<'a>>`\n-                    // and ban them. Type variables instantiated inside binders aren't\n-                    // well-supported at the moment, so this doesn't work.\n-                    // In the future, this should be fixed and this error should be removed.\n-                    let def = self.map.defs.get(&lifetime.id).cloned();\n-                    if let Some(Region::LateBound(_, def_id, _)) = def {\n-                        if let Some(node_id) = self.tcx.hir.as_local_node_id(def_id) {\n-                            // Ensure that the parent of the def is an item, not HRTB\n-                            let parent_id = self.tcx.hir.get_parent_node(node_id);\n-                            let parent_impl_id = hir::ImplItemId { node_id: parent_id };\n-                            let parent_trait_id = hir::TraitItemId { node_id: parent_id };\n-                            let krate = self.tcx.hir.forest.krate();\n-                            if !(krate.items.contains_key(&parent_id)\n-                                || krate.impl_items.contains_key(&parent_impl_id)\n-                                || krate.trait_items.contains_key(&parent_trait_id))\n-                            {\n-                                span_err!(\n-                                    self.tcx.sess,\n-                                    lifetime.span,\n-                                    E0657,\n-                                    \"`impl Trait` can only capture lifetimes \\\n-                                     bound at the fn or impl level\"\n-                                );\n-                                self.uninsert_lifetime_on_error(lifetime, def.unwrap());\n+            hir::TyPath(hir::QPath::Resolved(None, ref path)) => {\n+                if let Def::Existential(exist_ty_did) = path.def {\n+                    assert!(exist_ty_did.is_local());\n+                    // Resolve the lifetimes that are applied to the existential type.\n+                    // These are resolved in the current scope.\n+                    // `fn foo<'a>() -> impl MyTrait<'a> { ... }` desugars to\n+                    // `fn foo<'a>() -> MyAnonTy<'a> { ... }`\n+                    //          ^                 ^this gets resolved in the current scope\n+                    for lifetime in &path.segments[0].args.as_ref().unwrap().args {\n+                        if let hir::GenericArg::Lifetime(lifetime) = lifetime {\n+                            self.visit_lifetime(lifetime);\n+\n+                            // Check for predicates like `impl for<'a> Trait<impl OtherTrait<'a>>`\n+                            // and ban them. Type variables instantiated inside binders aren't\n+                            // well-supported at the moment, so this doesn't work.\n+                            // In the future, this should be fixed and this error should be removed.\n+                            let def = self.map.defs.get(&lifetime.id).cloned();\n+                            if let Some(Region::LateBound(_, def_id, _)) = def {\n+                                if let Some(node_id) = self.tcx.hir.as_local_node_id(def_id) {\n+                                    // Ensure that the parent of the def is an item, not HRTB\n+                                    let parent_id = self.tcx.hir.get_parent_node(node_id);\n+                                    let parent_impl_id = hir::ImplItemId { node_id: parent_id };\n+                                    let parent_trait_id = hir::TraitItemId { node_id: parent_id };\n+                                    let krate = self.tcx.hir.forest.krate();\n+                                    if !(krate.items.contains_key(&parent_id)\n+                                        || krate.impl_items.contains_key(&parent_impl_id)\n+                                        || krate.trait_items.contains_key(&parent_trait_id))\n+                                    {\n+                                        span_err!(\n+                                            self.tcx.sess,\n+                                            lifetime.span,\n+                                            E0657,\n+                                            \"`impl Trait` can only capture lifetimes \\\n+                                            bound at the fn or impl level\"\n+                                        );\n+                                        self.uninsert_lifetime_on_error(lifetime, def.unwrap());\n+                                    }\n+                                }\n                             }\n                         }\n                     }\n-                }\n \n-                // Resolve the lifetimes in the bounds to the lifetime defs in the generics.\n-                // `fn foo<'a>() -> impl MyTrait<'a> { ... }` desugars to\n-                // `abstract type MyAnonTy<'b>: MyTrait<'b>;`\n-                //                          ^            ^ this gets resolved in the scope of\n-                //                                         the exist_ty generics\n-                let (generics, bounds) = match self.tcx.hir.expect_item(item_id.id).node {\n-                    hir::ItemExistential(hir::ExistTy{ ref generics, ref bounds, .. }) => (\n-                        generics,\n-                        bounds,\n-                    ),\n-                    ref i => bug!(\"impl Trait pointed to non-existential type?? {:#?}\", i),\n-                };\n+                    let id = self.tcx.hir.as_local_node_id(exist_ty_did).unwrap();\n+\n+                    // Resolve the lifetimes in the bounds to the lifetime defs in the generics.\n+                    // `fn foo<'a>() -> impl MyTrait<'a> { ... }` desugars to\n+                    // `abstract type MyAnonTy<'b>: MyTrait<'b>;`\n+                    //                          ^            ^ this gets resolved in the scope of\n+                    //                                         the exist_ty generics\n+                    let (generics, bounds) = match self.tcx.hir.expect_item(id).node {\n+                        hir::ItemExistential(hir::ExistTy{ ref generics, ref bounds, .. }) => (\n+                            generics,\n+                            bounds,\n+                        ),\n+                        ref i => bug!(\"impl Trait pointed to non-existential type?? {:#?}\", i),\n+                    };\n \n-                // We want to start our early-bound indices at the end of the parent scope,\n-                // not including any parent `impl Trait`s.\n-                let mut index = self.next_early_index_for_abstract_type();\n-                debug!(\"visit_ty: index = {}\", index);\n+                    // We want to start our early-bound indices at the end of the parent scope,\n+                    // not including any parent `impl Trait`s.\n+                    let mut index = self.next_early_index_for_abstract_type();\n+                    debug!(\"visit_ty: index = {}\", index);\n \n-                let mut elision = None;\n-                let mut lifetimes = FxHashMap();\n-                let mut type_count = 0;\n-                for param in &generics.params {\n-                    match param.kind {\n-                        GenericParamKind::Lifetime { .. } => {\n-                            let (name, reg) = Region::early(&self.tcx.hir, &mut index, &param);\n-                            if let hir::ParamName::Plain(param_name) = name {\n-                                if param_name.name == keywords::UnderscoreLifetime.name() {\n-                                    // Pick the elided lifetime \"definition\" if one exists\n-                                    // and use it to make an elision scope.\n-                                    elision = Some(reg);\n+                    let mut elision = None;\n+                    let mut lifetimes = FxHashMap();\n+                    let mut type_count = 0;\n+                    for param in &generics.params {\n+                        match param.kind {\n+                            GenericParamKind::Lifetime { .. } => {\n+                                let (name, reg) = Region::early(&self.tcx.hir, &mut index, &param);\n+                                if let hir::ParamName::Plain(param_name) = name {\n+                                    if param_name.name == keywords::UnderscoreLifetime.name() {\n+                                        // Pick the elided lifetime \"definition\" if one exists\n+                                        // and use it to make an elision scope.\n+                                        elision = Some(reg);\n+                                    } else {\n+                                        lifetimes.insert(name, reg);\n+                                    }\n                                 } else {\n                                     lifetimes.insert(name, reg);\n                                 }\n-                            } else {\n-                                lifetimes.insert(name, reg);\n                             }\n-                        }\n-                        GenericParamKind::Type { .. } => {\n-                            type_count += 1;\n+                            GenericParamKind::Type { .. } => {\n+                                type_count += 1;\n+                            }\n                         }\n                     }\n-                }\n-                let next_early_index = index + type_count;\n+                    let next_early_index = index + type_count;\n \n-                if let Some(elision_region) = elision {\n-                    let scope = Scope::Elision {\n-                        elide: Elide::Exact(elision_region),\n-                        s: self.scope,\n-                    };\n-                    self.with(scope, |_old_scope, this| {\n+                    if let Some(elision_region) = elision {\n+                        let scope = Scope::Elision {\n+                            elide: Elide::Exact(elision_region),\n+                            s: self.scope,\n+                        };\n+                        self.with(scope, |_old_scope, this| {\n+                            let scope = Scope::Binder {\n+                                lifetimes,\n+                                next_early_index,\n+                                s: this.scope,\n+                                track_lifetime_uses: true,\n+                                abstract_type_parent: false,\n+                            };\n+                            this.with(scope, |_old_scope, this| {\n+                                this.visit_generics(generics);\n+                                for bound in bounds {\n+                                    this.visit_param_bound(bound);\n+                                }\n+                            });\n+                        });\n+                    } else {\n                         let scope = Scope::Binder {\n                             lifetimes,\n                             next_early_index,\n-                            s: this.scope,\n+                            s: self.scope,\n                             track_lifetime_uses: true,\n                             abstract_type_parent: false,\n                         };\n-                        this.with(scope, |_old_scope, this| {\n+                        self.with(scope, |_old_scope, this| {\n                             this.visit_generics(generics);\n                             for bound in bounds {\n                                 this.visit_param_bound(bound);\n                             }\n                         });\n-                    });\n+                    }\n                 } else {\n-                    let scope = Scope::Binder {\n-                        lifetimes,\n-                        next_early_index,\n-                        s: self.scope,\n-                        track_lifetime_uses: true,\n-                        abstract_type_parent: false,\n-                    };\n-                    self.with(scope, |_old_scope, this| {\n-                        this.visit_generics(generics);\n-                        for bound in bounds {\n-                            this.visit_param_bound(bound);\n-                        }\n-                    });\n+                    intravisit::walk_ty(self, ty)\n                 }\n             }\n             _ => intravisit::walk_ty(self, ty),"}, {"sha": "958d09413edfaed93b4ec343fd3977a62c161243", "filename": "src/librustc_codegen_llvm/debuginfo/source_loc.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/860d169474acabdc53b9a698f8ce02eba7e0daeb/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fsource_loc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/860d169474acabdc53b9a698f8ce02eba7e0daeb/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fsource_loc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fsource_loc.rs?ref=860d169474acabdc53b9a698f8ce02eba7e0daeb", "patch": "@@ -81,16 +81,22 @@ impl InternalDebugLocation {\n \n pub fn set_debug_location(bx: &Builder, debug_location: InternalDebugLocation) {\n     let metadata_node = match debug_location {\n-        KnownLocation { scope, line, .. } => {\n-            // Always set the column to zero like Clang and GCC\n-            let col = UNKNOWN_COLUMN_NUMBER;\n+        KnownLocation { scope, line, col } => {\n+            // For MSVC, set the column number to zero.\n+            // Otherwise, emit it. This mimics clang behaviour.\n+            // See discussion in https://github.com/rust-lang/rust/issues/42921\n+            let col_used =  if bx.cx.sess().target.target.options.is_like_msvc {\n+                UNKNOWN_COLUMN_NUMBER\n+            } else {\n+                col as c_uint\n+            };\n             debug!(\"setting debug location to {} {}\", line, col);\n \n             unsafe {\n                 llvm::LLVMRustDIBuilderCreateDebugLocation(\n                     debug_context(bx.cx).llcontext,\n                     line as c_uint,\n-                    col as c_uint,\n+                    col_used,\n                     scope,\n                     ptr::null_mut())\n             }"}, {"sha": "c4a23ac653ca009a57c8458ce009f7f2b0426352", "filename": "src/librustc_codegen_llvm/mono_item.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/860d169474acabdc53b9a698f8ce02eba7e0daeb/src%2Flibrustc_codegen_llvm%2Fmono_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/860d169474acabdc53b9a698f8ce02eba7e0daeb/src%2Flibrustc_codegen_llvm%2Fmono_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmono_item.rs?ref=860d169474acabdc53b9a698f8ce02eba7e0daeb", "patch": "@@ -25,11 +25,10 @@ use monomorphize::Instance;\n use type_of::LayoutLlvmExt;\n use rustc::hir;\n use rustc::hir::def::Def;\n-use rustc::hir::def_id::DefId;\n+use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n use rustc::mir::mono::{Linkage, Visibility};\n use rustc::ty::TypeFoldable;\n use rustc::ty::layout::LayoutOf;\n-use syntax::attr;\n use std::fmt;\n \n pub use rustc::mir::mono::MonoItem;\n@@ -173,7 +172,7 @@ fn predefine_fn<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n     // visibility as we're going to link this object all over the place but\n     // don't want the symbols to get exported.\n     if linkage != Linkage::Internal && linkage != Linkage::Private &&\n-       attr::contains_name(cx.tcx.hir.krate_attrs(), \"compiler_builtins\") {\n+       cx.tcx.is_compiler_builtins(LOCAL_CRATE) {\n         unsafe {\n             llvm::LLVMRustSetVisibility(lldecl, llvm::Visibility::Hidden);\n         }"}, {"sha": "741758cb954ba4b38e644c4644ddf57f2546e9cb", "filename": "src/librustc_llvm/lib.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/860d169474acabdc53b9a698f8ce02eba7e0daeb/src%2Flibrustc_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/860d169474acabdc53b9a698f8ce02eba7e0daeb/src%2Flibrustc_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Flib.rs?ref=860d169474acabdc53b9a698f8ce02eba7e0daeb", "patch": "@@ -331,6 +331,12 @@ pub fn initialize_available_targets() {\n                  LLVMInitializeAArch64TargetMC,\n                  LLVMInitializeAArch64AsmPrinter,\n                  LLVMInitializeAArch64AsmParser);\n+    init_target!(llvm_component = \"amdgpu\",\n+                 LLVMInitializeAMDGPUTargetInfo,\n+                 LLVMInitializeAMDGPUTarget,\n+                 LLVMInitializeAMDGPUTargetMC,\n+                 LLVMInitializeAMDGPUAsmPrinter,\n+                 LLVMInitializeAMDGPUAsmParser);\n     init_target!(llvm_component = \"mips\",\n                  LLVMInitializeMipsTargetInfo,\n                  LLVMInitializeMipsTarget,"}, {"sha": "3919ba13076f6d839426226056ca2e904b720314", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 15, "deletions": 29, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/860d169474acabdc53b9a698f8ce02eba7e0daeb/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/860d169474acabdc53b9a698f8ce02eba7e0daeb/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=860d169474acabdc53b9a698f8ce02eba7e0daeb", "patch": "@@ -229,8 +229,12 @@ impl<'a, 'tcx> Visitor<'tcx> for EmbargoVisitor<'a, 'tcx> {\n             hir::ItemUse(..) => {}\n             // The interface is empty\n             hir::ItemGlobalAsm(..) => {}\n-            // Checked by visit_ty\n-            hir::ItemExistential(..) => {}\n+            hir::ItemExistential(..) => {\n+                if item_level.is_some() {\n+                    // Reach the (potentially private) type and the API being exposed\n+                    self.reach(item.id).ty().predicates();\n+                }\n+            }\n             // Visit everything\n             hir::ItemConst(..) | hir::ItemStatic(..) |\n             hir::ItemFn(..) | hir::ItemTy(..) => {\n@@ -390,17 +394,6 @@ impl<'a, 'tcx> Visitor<'tcx> for EmbargoVisitor<'a, 'tcx> {\n             module_id = self.tcx.hir.get_parent_node(module_id);\n         }\n     }\n-\n-    fn visit_ty(&mut self, ty: &'tcx hir::Ty) {\n-        if let hir::TyImplTraitExistential(item_id, _, _) = ty.node {\n-            if self.get(item_id.id).is_some() {\n-                // Reach the (potentially private) type and the API being exposed\n-                self.reach(item_id.id).ty().predicates();\n-            }\n-        }\n-\n-        intravisit::walk_ty(self, ty);\n-    }\n }\n \n impl<'b, 'a, 'tcx> ReachEverythingInTheInterfaceVisitor<'b, 'a, 'tcx> {\n@@ -1568,8 +1561,15 @@ impl<'a, 'tcx> Visitor<'tcx> for PrivateItemsInPublicInterfacesVisitor<'a, 'tcx>\n             hir::ItemUse(..) => {}\n             // No subitems\n             hir::ItemGlobalAsm(..) => {}\n-            // Checked in visit_ty\n-            hir::ItemExistential(..) => {}\n+            hir::ItemExistential(..) => {\n+                // Check the traits being exposed, as they're separate,\n+                // e.g. `impl Iterator<Item=T>` has two predicates,\n+                // `X: Iterator` and `<X as Iterator>::Item == T`,\n+                // where `X` is the `impl Iterator<Item=T>` itself,\n+                // stored in `predicates_of`, not in the `Ty` itself.\n+\n+                self.check(item.id, self.inner_visibility).predicates();\n+            }\n             // Subitems of these items have inherited publicity\n             hir::ItemConst(..) | hir::ItemStatic(..) | hir::ItemFn(..) |\n             hir::ItemTy(..) => {\n@@ -1667,20 +1667,6 @@ impl<'a, 'tcx> Visitor<'tcx> for PrivateItemsInPublicInterfacesVisitor<'a, 'tcx>\n         // handled in `visit_item` above\n     }\n \n-    fn visit_ty(&mut self, ty: &'tcx hir::Ty) {\n-        if let hir::TyImplTraitExistential(ref exist_item, _, _) = ty.node {\n-            // Check the traits being exposed, as they're separate,\n-            // e.g. `impl Iterator<Item=T>` has two predicates,\n-            // `X: Iterator` and `<X as Iterator>::Item == T`,\n-            // where `X` is the `impl Iterator<Item=T>` itself,\n-            // stored in `predicates_of`, not in the `Ty` itself.\n-\n-            self.check(exist_item.id, self.inner_visibility).predicates();\n-        }\n-\n-        intravisit::walk_ty(self, ty);\n-    }\n-\n     // Don't recurse into expressions in array sizes or const initializers\n     fn visit_expr(&mut self, _: &'tcx hir::Expr) {}\n     // Don't recurse into patterns in function arguments"}, {"sha": "2e467d315bedd7d7baf21a8f6b15955be39307f3", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/860d169474acabdc53b9a698f8ce02eba7e0daeb/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/860d169474acabdc53b9a698f8ce02eba7e0daeb/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=860d169474acabdc53b9a698f8ce02eba7e0daeb", "patch": "@@ -1095,6 +1095,11 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                     hir::TyStr => tcx.mk_str()\n                 }\n             }\n+            Def::Existential(exist_ty_did) => {\n+                assert!(exist_ty_did.is_local());\n+                let lifetimes = &path.segments[0].args.as_ref().unwrap().args;\n+                self.impl_trait_ty_to_ty(exist_ty_did, lifetimes)\n+            }\n             Def::Err => {\n                 self.set_tainted_by_errors();\n                 return self.tcx().types.err;\n@@ -1140,9 +1145,6 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             hir::TyTraitObject(ref bounds, ref lifetime) => {\n                 self.conv_object_ty_poly_trait_ref(ast_ty.span, bounds, lifetime)\n             }\n-            hir::TyImplTraitExistential(_, def_id, ref lifetimes) => {\n-                self.impl_trait_ty_to_ty(def_id, lifetimes)\n-            }\n             hir::TyPath(hir::QPath::Resolved(ref maybe_qself, ref path)) => {\n                 debug!(\"ast_ty_to_ty: maybe_qself={:?} path={:?}\", maybe_qself, path);\n                 let opt_self_ty = maybe_qself.as_ref().map(|qself| {\n@@ -1195,7 +1197,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n     pub fn impl_trait_ty_to_ty(\n         &self,\n         def_id: DefId,\n-        lifetimes: &[hir::Lifetime],\n+        lifetimes: &[hir::GenericArg],\n     ) -> Ty<'tcx> {\n         debug!(\"impl_trait_ty_to_ty(def_id={:?}, lifetimes={:?})\", def_id, lifetimes);\n         let tcx = self.tcx();\n@@ -1208,7 +1210,11 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                 // Our own parameters are the resolved lifetimes.\n                 match param.kind {\n                     GenericParamDefKind::Lifetime => {\n-                        self.ast_region_to_region(&lifetimes[i], None).into()\n+                        if let hir::GenericArg::Lifetime(lifetime) = &lifetimes[i] {\n+                            self.ast_region_to_region(lifetime, None).into()\n+                        } else {\n+                            bug!()\n+                        }\n                     }\n                     _ => bug!()\n                 }"}, {"sha": "aee64ad3b550c11cd42d951bf556f254f9843fae", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/860d169474acabdc53b9a698f8ce02eba7e0daeb/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/860d169474acabdc53b9a698f8ce02eba7e0daeb/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=860d169474acabdc53b9a698f8ce02eba7e0daeb", "patch": "@@ -264,19 +264,23 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 (&ty::TyStr, &ty::TySlice(arr)) if arr == self.tcx.types.u8 => {\n                     if let hir::ExprLit(_) = expr.node {\n                         if let Ok(src) = cm.span_to_snippet(sp) {\n-                            return Some((sp,\n-                                         \"consider removing the leading `b`\",\n-                                         src[1..].to_string()));\n+                            if src.starts_with(\"b\\\"\") {\n+                                return Some((sp,\n+                                             \"consider removing the leading `b`\",\n+                                             src[1..].to_string()));\n+                            }\n                         }\n                     }\n                 },\n                 (&ty::TyArray(arr, _), &ty::TyStr) |\n                 (&ty::TySlice(arr), &ty::TyStr) if arr == self.tcx.types.u8 => {\n                     if let hir::ExprLit(_) = expr.node {\n                         if let Ok(src) = cm.span_to_snippet(sp) {\n-                            return Some((sp,\n-                                         \"consider adding a leading `b`\",\n-                                         format!(\"b{}\", src)));\n+                            if src.starts_with(\"\\\"\") {\n+                                return Some((sp,\n+                                             \"consider adding a leading `b`\",\n+                                             format!(\"b{}\", src)));\n+                            }\n                         }\n                     }\n                 }"}, {"sha": "4931cbfa5acc386f274537569228089e3c3b4637", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/860d169474acabdc53b9a698f8ce02eba7e0daeb/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/860d169474acabdc53b9a698f8ce02eba7e0daeb/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=860d169474acabdc53b9a698f8ce02eba7e0daeb", "patch": "@@ -875,10 +875,6 @@ fn generics_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             }\n         }\n \n-        NodeTy(&hir::Ty { node: hir::TyImplTraitExistential(..), .. }) => {\n-            bug!(\"impl Trait is desugared to existential type items\");\n-        }\n-\n         _ => &no_generics,\n     };\n "}, {"sha": "f71d62d5a04e1e3cb39a613ec7a4682df613d423", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/860d169474acabdc53b9a698f8ce02eba7e0daeb/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/860d169474acabdc53b9a698f8ce02eba7e0daeb/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=860d169474acabdc53b9a698f8ce02eba7e0daeb", "patch": "@@ -2987,14 +2987,6 @@ impl Clean<Type> for hir::Ty {\n                 }\n             }\n             TyBareFn(ref barefn) => BareFunction(box barefn.clean(cx)),\n-            TyImplTraitExistential(hir_id, _, _) => {\n-                match cx.tcx.hir.expect_item(hir_id.id).node {\n-                    hir::ItemExistential(ref exist_ty) => {\n-                        ImplTrait(exist_ty.bounds.clean(cx))\n-                    },\n-                    ref other => panic!(\"impl Trait pointed to {:#?}\", other),\n-                }\n-            },\n             TyInfer | TyErr => Infer,\n             TyTypeof(..) => panic!(\"Unimplemented type {:?}\", self.node),\n         }"}, {"sha": "fce85a200ba2e98b39784f7279ffa7b5e3ea5ce1", "filename": "src/libstd/io/stdio.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/860d169474acabdc53b9a698f8ce02eba7e0daeb/src%2Flibstd%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/860d169474acabdc53b9a698f8ce02eba7e0daeb/src%2Flibstd%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fstdio.rs?ref=860d169474acabdc53b9a698f8ce02eba7e0daeb", "patch": "@@ -712,9 +712,31 @@ pub fn _eprint(args: fmt::Arguments) {\n \n #[cfg(test)]\n mod tests {\n+    use panic::{UnwindSafe, RefUnwindSafe};\n     use thread;\n     use super::*;\n \n+    #[test]\n+    fn stdout_unwind_safe() {\n+        assert_unwind_safe::<Stdout>();\n+    }\n+    #[test]\n+    fn stdoutlock_unwind_safe() {\n+        assert_unwind_safe::<StdoutLock>();\n+        assert_unwind_safe::<StdoutLock<'static>>();\n+    }\n+    #[test]\n+    fn stderr_unwind_safe() {\n+        assert_unwind_safe::<Stderr>();\n+    }\n+    #[test]\n+    fn stderrlock_unwind_safe() {\n+        assert_unwind_safe::<StderrLock>();\n+        assert_unwind_safe::<StderrLock<'static>>();\n+    }\n+\n+    fn assert_unwind_safe<T: UnwindSafe + RefUnwindSafe>() {}\n+\n     #[test]\n     #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn panic_doesnt_poison() {"}, {"sha": "507e9d881717bbac63ce1a9082cfeadb71be7c0b", "filename": "src/libstd/sys/unix/ext/fs.rs", "status": "modified", "additions": 127, "deletions": 0, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/860d169474acabdc53b9a698f8ce02eba7e0daeb/src%2Flibstd%2Fsys%2Funix%2Fext%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/860d169474acabdc53b9a698f8ce02eba7e0daeb/src%2Flibstd%2Fsys%2Funix%2Fext%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fext%2Ffs.rs?ref=860d169474acabdc53b9a698f8ce02eba7e0daeb", "patch": "@@ -59,6 +59,78 @@ pub trait FileExt {\n     #[stable(feature = \"file_offset\", since = \"1.15.0\")]\n     fn read_at(&self, buf: &mut [u8], offset: u64) -> io::Result<usize>;\n \n+    /// Reads the exact number of byte required to fill `buf` from the given offset.\n+    ///\n+    /// The offset is relative to the start of the file and thus independent\n+    /// from the current cursor.\n+    ///\n+    /// The current file cursor is not affected by this function.\n+    ///\n+    /// Similar to [`Read::read_exact`] but uses [`read_at`] instead of `read`.\n+    ///\n+    /// [`Read::read_exact`]: ../../../../std/io/trait.Read.html#method.read_exact\n+    /// [`read_at`]: #tymethod.read_at\n+    ///\n+    /// # Errors\n+    ///\n+    /// If this function encounters an error of the kind\n+    /// [`ErrorKind::Interrupted`] then the error is ignored and the operation\n+    /// will continue.\n+    ///\n+    /// If this function encounters an \"end of file\" before completely filling\n+    /// the buffer, it returns an error of the kind [`ErrorKind::UnexpectedEof`].\n+    /// The contents of `buf` are unspecified in this case.\n+    ///\n+    /// If any other read error is encountered then this function immediately\n+    /// returns. The contents of `buf` are unspecified in this case.\n+    ///\n+    /// If this function returns an error, it is unspecified how many bytes it\n+    /// has read, but it will never read more than would be necessary to\n+    /// completely fill the buffer.\n+    ///\n+    /// [`ErrorKind::Interrupted`]: ../../../../std/io/enum.ErrorKind.html#variant.Interrupted\n+    /// [`ErrorKind::UnexpectedEof`]: ../../../../std/io/enum.ErrorKind.html#variant.UnexpectedEof\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// #![feature(rw_exact_all_at)]\n+    /// use std::io;\n+    /// use std::fs::File;\n+    /// use std::os::unix::prelude::FileExt;\n+    ///\n+    /// fn main() -> io::Result<()> {\n+    ///     let mut buf = [0u8; 8];\n+    ///     let file = File::open(\"foo.txt\")?;\n+    ///\n+    ///     // We now read exactly 8 bytes from the offset 10.\n+    ///     file.read_exact_at(&mut buf, 10)?;\n+    ///     println!(\"read {} bytes: {:?}\", buf.len(), buf);\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[unstable(feature = \"rw_exact_all_at\", issue = \"51984\")]\n+    fn read_exact_at(&self, mut buf: &mut [u8], mut offset: u64) -> io::Result<()> {\n+        while !buf.is_empty() {\n+            match self.read_at(buf, offset) {\n+                Ok(0) => break,\n+                Ok(n) => {\n+                    let tmp = buf;\n+                    buf = &mut tmp[n..];\n+                    offset += n as u64;\n+                }\n+                Err(ref e) if e.kind() == io::ErrorKind::Interrupted => {}\n+                Err(e) => return Err(e),\n+            }\n+        }\n+        if !buf.is_empty() {\n+            Err(io::Error::new(io::ErrorKind::UnexpectedEof,\n+                               \"failed to fill whole buffer\"))\n+        } else {\n+            Ok(())\n+        }\n+    }\n+\n     /// Writes a number of bytes starting from a given offset.\n     ///\n     /// Returns the number of bytes written.\n@@ -93,6 +165,61 @@ pub trait FileExt {\n     /// ```\n     #[stable(feature = \"file_offset\", since = \"1.15.0\")]\n     fn write_at(&self, buf: &[u8], offset: u64) -> io::Result<usize>;\n+\n+    /// Attempts to write an entire buffer starting from a given offset.\n+    ///\n+    /// The offset is relative to the start of the file and thus independent\n+    /// from the current cursor.\n+    ///\n+    /// The current file cursor is not affected by this function.\n+    ///\n+    /// This method will continuously call [`write_at`] until there is no more data\n+    /// to be written or an error of non-[`ErrorKind::Interrupted`] kind is\n+    /// returned. This method will not return until the entire buffer has been\n+    /// successfully written or such an error occurs. The first error that is\n+    /// not of [`ErrorKind::Interrupted`] kind generated from this method will be\n+    /// returned.\n+    ///\n+    /// # Errors\n+    ///\n+    /// This function will return the first error of\n+    /// non-[`ErrorKind::Interrupted`] kind that [`write_at`] returns.\n+    ///\n+    /// [`ErrorKind::Interrupted`]: ../../../../std/io/enum.ErrorKind.html#variant.Interrupted\n+    /// [`write_at`]: #tymethod.write_at\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// #![feature(rw_exact_all_at)]\n+    /// use std::fs::File;\n+    /// use std::io;\n+    /// use std::os::unix::prelude::FileExt;\n+    ///\n+    /// fn main() -> io::Result<()> {\n+    ///     let file = File::open(\"foo.txt\")?;\n+    ///\n+    ///     // We now write at the offset 10.\n+    ///     file.write_all_at(b\"sushi\", 10)?;\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[unstable(feature = \"rw_exact_all_at\", issue = \"51984\")]\n+    fn write_all_at(&self, mut buf: &[u8], mut offset: u64) -> io::Result<()> {\n+        while !buf.is_empty() {\n+            match self.write_at(buf, offset) {\n+                Ok(0) => return Err(io::Error::new(io::ErrorKind::WriteZero,\n+                                                   \"failed to write whole buffer\")),\n+                Ok(n) => {\n+                    buf = &buf[n..];\n+                    offset += n as u64\n+                }\n+                Err(ref e) if e.kind() == io::ErrorKind::Interrupted => {}\n+                Err(e) => return Err(e),\n+            }\n+        }\n+        Ok(())\n+    }\n }\n \n #[stable(feature = \"file_offset\", since = \"1.15.0\")]"}, {"sha": "071a3a25c7acdab8860b7ad0c577687c35ab1023", "filename": "src/libstd/sys_common/remutex.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/860d169474acabdc53b9a698f8ce02eba7e0daeb/src%2Flibstd%2Fsys_common%2Fremutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/860d169474acabdc53b9a698f8ce02eba7e0daeb/src%2Flibstd%2Fsys_common%2Fremutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fremutex.rs?ref=860d169474acabdc53b9a698f8ce02eba7e0daeb", "patch": "@@ -13,6 +13,7 @@ use marker;\n use ops::Deref;\n use sys_common::poison::{self, TryLockError, TryLockResult, LockResult};\n use sys::mutex as sys;\n+use panic::{UnwindSafe, RefUnwindSafe};\n \n /// A re-entrant mutual exclusion\n ///\n@@ -28,6 +29,9 @@ pub struct ReentrantMutex<T> {\n unsafe impl<T: Send> Send for ReentrantMutex<T> {}\n unsafe impl<T: Send> Sync for ReentrantMutex<T> {}\n \n+impl<T> UnwindSafe for ReentrantMutex<T> {}\n+impl<T> RefUnwindSafe for ReentrantMutex<T> {}\n+\n \n /// An RAII implementation of a \"scoped lock\" of a mutex. When this structure is\n /// dropped (falls out of scope), the lock will be unlocked."}, {"sha": "ecd52a62eab2692601254ed5d9b17ce30593b293", "filename": "src/libsyntax/attr/builtin.rs", "status": "added", "additions": 730, "deletions": 0, "changes": 730, "blob_url": "https://github.com/rust-lang/rust/blob/860d169474acabdc53b9a698f8ce02eba7e0daeb/src%2Flibsyntax%2Fattr%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/860d169474acabdc53b9a698f8ce02eba7e0daeb/src%2Flibsyntax%2Fattr%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr%2Fbuiltin.rs?ref=860d169474acabdc53b9a698f8ce02eba7e0daeb", "patch": "@@ -0,0 +1,730 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Parsing and validation of builtin attributes\n+\n+use ast::{self, Attribute, MetaItem, Name, NestedMetaItemKind};\n+use errors::{Applicability, Handler};\n+use feature_gate::{Features, GatedCfg};\n+use parse::ParseSess;\n+use syntax_pos::{symbol::Symbol, Span};\n+\n+use super::{list_contains_name, mark_used, MetaItemKind};\n+\n+enum AttrError {\n+    MultipleItem(Name),\n+    UnknownMetaItem(Name, &'static [&'static str]),\n+    MissingSince,\n+    MissingFeature,\n+    MultipleStabilityLevels,\n+    UnsupportedLiteral\n+}\n+\n+fn handle_errors(diag: &Handler, span: Span, error: AttrError) {\n+    match error {\n+        AttrError::MultipleItem(item) => span_err!(diag, span, E0538,\n+                                                   \"multiple '{}' items\", item),\n+        AttrError::UnknownMetaItem(item, expected) => {\n+            let expected = expected\n+                .iter()\n+                .map(|name| format!(\"`{}`\", name))\n+                .collect::<Vec<_>>();\n+            struct_span_err!(diag, span, E0541, \"unknown meta item '{}'\", item)\n+                .span_label(span, format!(\"expected one of {}\", expected.join(\", \")))\n+                .emit();\n+        }\n+        AttrError::MissingSince => span_err!(diag, span, E0542, \"missing 'since'\"),\n+        AttrError::MissingFeature => span_err!(diag, span, E0546, \"missing 'feature'\"),\n+        AttrError::MultipleStabilityLevels => span_err!(diag, span, E0544,\n+                                                        \"multiple stability levels\"),\n+        AttrError::UnsupportedLiteral => span_err!(diag, span, E0565, \"unsupported literal\"),\n+    }\n+}\n+\n+#[derive(Copy, Clone, Hash, PartialEq, RustcEncodable, RustcDecodable)]\n+pub enum InlineAttr {\n+    None,\n+    Hint,\n+    Always,\n+    Never,\n+}\n+\n+#[derive(Copy, Clone, PartialEq)]\n+pub enum UnwindAttr {\n+    Allowed,\n+    Aborts,\n+}\n+\n+/// Determine what `#[unwind]` attribute is present in `attrs`, if any.\n+pub fn find_unwind_attr(diagnostic: Option<&Handler>, attrs: &[Attribute]) -> Option<UnwindAttr> {\n+    let syntax_error = |attr: &Attribute| {\n+        mark_used(attr);\n+        diagnostic.map(|d| {\n+            span_err!(d, attr.span, E0633, \"malformed `#[unwind]` attribute\");\n+        });\n+        None\n+    };\n+\n+    attrs.iter().fold(None, |ia, attr| {\n+        if attr.path != \"unwind\" {\n+            return ia;\n+        }\n+        let meta = match attr.meta() {\n+            Some(meta) => meta.node,\n+            None => return ia,\n+        };\n+        match meta {\n+            MetaItemKind::Word => {\n+                syntax_error(attr)\n+            }\n+            MetaItemKind::List(ref items) => {\n+                mark_used(attr);\n+                if items.len() != 1 {\n+                    syntax_error(attr)\n+                } else if list_contains_name(&items[..], \"allowed\") {\n+                    Some(UnwindAttr::Allowed)\n+                } else if list_contains_name(&items[..], \"aborts\") {\n+                    Some(UnwindAttr::Aborts)\n+                } else {\n+                    syntax_error(attr)\n+                }\n+            }\n+            _ => ia,\n+        }\n+    })\n+}\n+\n+/// Represents the #[stable], #[unstable], #[rustc_{deprecated,const_unstable}] attributes.\n+#[derive(RustcEncodable, RustcDecodable, Clone, Debug, PartialEq, Eq, Hash)]\n+pub struct Stability {\n+    pub level: StabilityLevel,\n+    pub feature: Symbol,\n+    pub rustc_depr: Option<RustcDeprecation>,\n+    pub rustc_const_unstable: Option<RustcConstUnstable>,\n+}\n+\n+/// The available stability levels.\n+#[derive(RustcEncodable, RustcDecodable, PartialEq, PartialOrd, Clone, Debug, Eq, Hash)]\n+pub enum StabilityLevel {\n+    // Reason for the current stability level and the relevant rust-lang issue\n+    Unstable { reason: Option<Symbol>, issue: u32 },\n+    Stable { since: Symbol },\n+}\n+\n+impl StabilityLevel {\n+    pub fn is_unstable(&self) -> bool {\n+        if let StabilityLevel::Unstable {..} = *self {\n+            true\n+        } else {\n+            false\n+        }\n+    }\n+    pub fn is_stable(&self) -> bool {\n+        if let StabilityLevel::Stable {..} = *self {\n+            true\n+        } else {\n+            false\n+        }\n+    }\n+}\n+\n+#[derive(RustcEncodable, RustcDecodable, PartialEq, PartialOrd, Clone, Debug, Eq, Hash)]\n+pub struct RustcDeprecation {\n+    pub since: Symbol,\n+    pub reason: Symbol,\n+}\n+\n+#[derive(RustcEncodable, RustcDecodable, PartialEq, PartialOrd, Clone, Debug, Eq, Hash)]\n+pub struct RustcConstUnstable {\n+    pub feature: Symbol,\n+}\n+\n+/// Check if `attrs` contains an attribute like `#![feature(feature_name)]`.\n+/// This will not perform any \"sanity checks\" on the form of the attributes.\n+pub fn contains_feature_attr(attrs: &[Attribute], feature_name: &str) -> bool {\n+    attrs.iter().any(|item| {\n+        item.check_name(\"feature\") &&\n+        item.meta_item_list().map(|list| {\n+            list.iter().any(|mi| {\n+                mi.word().map(|w| w.name() == feature_name)\n+                         .unwrap_or(false)\n+            })\n+        }).unwrap_or(false)\n+    })\n+}\n+\n+/// Find the first stability attribute. `None` if none exists.\n+pub fn find_stability(diagnostic: &Handler, attrs: &[Attribute],\n+                      item_sp: Span) -> Option<Stability> {\n+    find_stability_generic(diagnostic, attrs.iter(), item_sp)\n+}\n+\n+fn find_stability_generic<'a, I>(diagnostic: &Handler,\n+                                 attrs_iter: I,\n+                                 item_sp: Span)\n+                                 -> Option<Stability>\n+    where I: Iterator<Item = &'a Attribute>\n+{\n+    use self::StabilityLevel::*;\n+\n+    let mut stab: Option<Stability> = None;\n+    let mut rustc_depr: Option<RustcDeprecation> = None;\n+    let mut rustc_const_unstable: Option<RustcConstUnstable> = None;\n+\n+    'outer: for attr in attrs_iter {\n+        if ![\n+            \"rustc_deprecated\",\n+            \"rustc_const_unstable\",\n+            \"unstable\",\n+            \"stable\",\n+        ].iter().any(|&s| attr.path == s) {\n+            continue // not a stability level\n+        }\n+\n+        mark_used(attr);\n+\n+        let meta = attr.meta();\n+        if let Some(MetaItem { node: MetaItemKind::List(ref metas), .. }) = meta {\n+            let meta = meta.as_ref().unwrap();\n+            let get = |meta: &MetaItem, item: &mut Option<Symbol>| {\n+                if item.is_some() {\n+                    handle_errors(diagnostic, meta.span, AttrError::MultipleItem(meta.name()));\n+                    return false\n+                }\n+                if let Some(v) = meta.value_str() {\n+                    *item = Some(v);\n+                    true\n+                } else {\n+                    span_err!(diagnostic, meta.span, E0539, \"incorrect meta item\");\n+                    false\n+                }\n+            };\n+\n+            macro_rules! get_meta {\n+                ($($name:ident),+) => {\n+                    $(\n+                        let mut $name = None;\n+                    )+\n+                    for meta in metas {\n+                        if let Some(mi) = meta.meta_item() {\n+                            match &*mi.name().as_str() {\n+                                $(\n+                                    stringify!($name)\n+                                        => if !get(mi, &mut $name) { continue 'outer },\n+                                )+\n+                                _ => {\n+                                    let expected = &[ $( stringify!($name) ),+ ];\n+                                    handle_errors(\n+                                        diagnostic,\n+                                        mi.span,\n+                                        AttrError::UnknownMetaItem(mi.name(), expected));\n+                                    continue 'outer\n+                                }\n+                            }\n+                        } else {\n+                            handle_errors(diagnostic, meta.span, AttrError::UnsupportedLiteral);\n+                            continue 'outer\n+                        }\n+                    }\n+                }\n+            }\n+\n+            match &*meta.name().as_str() {\n+                \"rustc_deprecated\" => {\n+                    if rustc_depr.is_some() {\n+                        span_err!(diagnostic, item_sp, E0540,\n+                                  \"multiple rustc_deprecated attributes\");\n+                        continue 'outer\n+                    }\n+\n+                    get_meta!(since, reason);\n+\n+                    match (since, reason) {\n+                        (Some(since), Some(reason)) => {\n+                            rustc_depr = Some(RustcDeprecation {\n+                                since,\n+                                reason,\n+                            })\n+                        }\n+                        (None, _) => {\n+                            handle_errors(diagnostic, attr.span(), AttrError::MissingSince);\n+                            continue\n+                        }\n+                        _ => {\n+                            span_err!(diagnostic, attr.span(), E0543, \"missing 'reason'\");\n+                            continue\n+                        }\n+                    }\n+                }\n+                \"rustc_const_unstable\" => {\n+                    if rustc_const_unstable.is_some() {\n+                        span_err!(diagnostic, item_sp, E0553,\n+                                  \"multiple rustc_const_unstable attributes\");\n+                        continue 'outer\n+                    }\n+\n+                    get_meta!(feature);\n+                    if let Some(feature) = feature {\n+                        rustc_const_unstable = Some(RustcConstUnstable {\n+                            feature\n+                        });\n+                    } else {\n+                        span_err!(diagnostic, attr.span(), E0629, \"missing 'feature'\");\n+                        continue\n+                    }\n+                }\n+                \"unstable\" => {\n+                    if stab.is_some() {\n+                        handle_errors(diagnostic, attr.span(), AttrError::MultipleStabilityLevels);\n+                        break\n+                    }\n+\n+                    let mut feature = None;\n+                    let mut reason = None;\n+                    let mut issue = None;\n+                    for meta in metas {\n+                        if let Some(mi) = meta.meta_item() {\n+                            match &*mi.name().as_str() {\n+                                \"feature\" => if !get(mi, &mut feature) { continue 'outer },\n+                                \"reason\" => if !get(mi, &mut reason) { continue 'outer },\n+                                \"issue\" => if !get(mi, &mut issue) { continue 'outer },\n+                                _ => {\n+                                    handle_errors(\n+                                        diagnostic,\n+                                        meta.span,\n+                                        AttrError::UnknownMetaItem(\n+                                            mi.name(),\n+                                            &[\"feature\", \"reason\", \"issue\"]\n+                                        ),\n+                                    );\n+                                    continue 'outer\n+                                }\n+                            }\n+                        } else {\n+                            handle_errors(diagnostic, meta.span, AttrError::UnsupportedLiteral);\n+                            continue 'outer\n+                        }\n+                    }\n+\n+                    match (feature, reason, issue) {\n+                        (Some(feature), reason, Some(issue)) => {\n+                            stab = Some(Stability {\n+                                level: Unstable {\n+                                    reason,\n+                                    issue: {\n+                                        if let Ok(issue) = issue.as_str().parse() {\n+                                            issue\n+                                        } else {\n+                                            span_err!(diagnostic, attr.span(), E0545,\n+                                                      \"incorrect 'issue'\");\n+                                            continue\n+                                        }\n+                                    }\n+                                },\n+                                feature,\n+                                rustc_depr: None,\n+                                rustc_const_unstable: None,\n+                            })\n+                        }\n+                        (None, _, _) => {\n+                            handle_errors(diagnostic, attr.span(), AttrError::MissingFeature);\n+                            continue\n+                        }\n+                        _ => {\n+                            span_err!(diagnostic, attr.span(), E0547, \"missing 'issue'\");\n+                            continue\n+                        }\n+                    }\n+                }\n+                \"stable\" => {\n+                    if stab.is_some() {\n+                        handle_errors(diagnostic, attr.span(), AttrError::MultipleStabilityLevels);\n+                        break\n+                    }\n+\n+                    let mut feature = None;\n+                    let mut since = None;\n+                    for meta in metas {\n+                        if let NestedMetaItemKind::MetaItem(ref mi) = meta.node {\n+                            match &*mi.name().as_str() {\n+                                \"feature\" => if !get(mi, &mut feature) { continue 'outer },\n+                                \"since\" => if !get(mi, &mut since) { continue 'outer },\n+                                _ => {\n+                                    handle_errors(\n+                                        diagnostic,\n+                                        meta.span,\n+                                        AttrError::UnknownMetaItem(mi.name(), &[\"since\", \"note\"]),\n+                                    );\n+                                    continue 'outer\n+                                }\n+                            }\n+                        } else {\n+                            handle_errors(diagnostic, meta.span, AttrError::UnsupportedLiteral);\n+                            continue 'outer\n+                        }\n+                    }\n+\n+                    match (feature, since) {\n+                        (Some(feature), Some(since)) => {\n+                            stab = Some(Stability {\n+                                level: Stable {\n+                                    since,\n+                                },\n+                                feature,\n+                                rustc_depr: None,\n+                                rustc_const_unstable: None,\n+                            })\n+                        }\n+                        (None, _) => {\n+                            handle_errors(diagnostic, attr.span(), AttrError::MissingFeature);\n+                            continue\n+                        }\n+                        _ => {\n+                            handle_errors(diagnostic, attr.span(), AttrError::MissingSince);\n+                            continue\n+                        }\n+                    }\n+                }\n+                _ => unreachable!()\n+            }\n+        } else {\n+            span_err!(diagnostic, attr.span(), E0548, \"incorrect stability attribute type\");\n+            continue\n+        }\n+    }\n+\n+    // Merge the deprecation info into the stability info\n+    if let Some(rustc_depr) = rustc_depr {\n+        if let Some(ref mut stab) = stab {\n+            stab.rustc_depr = Some(rustc_depr);\n+        } else {\n+            span_err!(diagnostic, item_sp, E0549,\n+                      \"rustc_deprecated attribute must be paired with \\\n+                       either stable or unstable attribute\");\n+        }\n+    }\n+\n+    // Merge the const-unstable info into the stability info\n+    if let Some(rustc_const_unstable) = rustc_const_unstable {\n+        if let Some(ref mut stab) = stab {\n+            stab.rustc_const_unstable = Some(rustc_const_unstable);\n+        } else {\n+            span_err!(diagnostic, item_sp, E0630,\n+                      \"rustc_const_unstable attribute must be paired with \\\n+                       either stable or unstable attribute\");\n+        }\n+    }\n+\n+    stab\n+}\n+\n+pub fn find_crate_name(attrs: &[Attribute]) -> Option<Symbol> {\n+    super::first_attr_value_str_by_name(attrs, \"crate_name\")\n+}\n+\n+/// Tests if a cfg-pattern matches the cfg set\n+pub fn cfg_matches(cfg: &ast::MetaItem, sess: &ParseSess, features: Option<&Features>) -> bool {\n+    eval_condition(cfg, sess, &mut |cfg| {\n+        if let (Some(feats), Some(gated_cfg)) = (features, GatedCfg::gate(cfg)) {\n+            gated_cfg.check_and_emit(sess, feats);\n+        }\n+        sess.config.contains(&(cfg.name(), cfg.value_str()))\n+    })\n+}\n+\n+/// Evaluate a cfg-like condition (with `any` and `all`), using `eval` to\n+/// evaluate individual items.\n+pub fn eval_condition<F>(cfg: &ast::MetaItem, sess: &ParseSess, eval: &mut F)\n+                         -> bool\n+    where F: FnMut(&ast::MetaItem) -> bool\n+{\n+    match cfg.node {\n+        ast::MetaItemKind::List(ref mis) => {\n+            for mi in mis.iter() {\n+                if !mi.is_meta_item() {\n+                    handle_errors(&sess.span_diagnostic, mi.span, AttrError::UnsupportedLiteral);\n+                    return false;\n+                }\n+            }\n+\n+            // The unwraps below may look dangerous, but we've already asserted\n+            // that they won't fail with the loop above.\n+            match &*cfg.name().as_str() {\n+                \"any\" => mis.iter().any(|mi| {\n+                    eval_condition(mi.meta_item().unwrap(), sess, eval)\n+                }),\n+                \"all\" => mis.iter().all(|mi| {\n+                    eval_condition(mi.meta_item().unwrap(), sess, eval)\n+                }),\n+                \"not\" => {\n+                    if mis.len() != 1 {\n+                        span_err!(sess.span_diagnostic, cfg.span, E0536, \"expected 1 cfg-pattern\");\n+                        return false;\n+                    }\n+\n+                    !eval_condition(mis[0].meta_item().unwrap(), sess, eval)\n+                },\n+                p => {\n+                    span_err!(sess.span_diagnostic, cfg.span, E0537, \"invalid predicate `{}`\", p);\n+                    false\n+                }\n+            }\n+        },\n+        ast::MetaItemKind::Word | ast::MetaItemKind::NameValue(..) => {\n+            eval(cfg)\n+        }\n+    }\n+}\n+\n+\n+#[derive(RustcEncodable, RustcDecodable, PartialEq, PartialOrd, Clone, Debug, Eq, Hash)]\n+pub struct Deprecation {\n+    pub since: Option<Symbol>,\n+    pub note: Option<Symbol>,\n+}\n+\n+/// Find the deprecation attribute. `None` if none exists.\n+pub fn find_deprecation(diagnostic: &Handler, attrs: &[Attribute],\n+                        item_sp: Span) -> Option<Deprecation> {\n+    find_deprecation_generic(diagnostic, attrs.iter(), item_sp)\n+}\n+\n+fn find_deprecation_generic<'a, I>(diagnostic: &Handler,\n+                                   attrs_iter: I,\n+                                   item_sp: Span)\n+                                   -> Option<Deprecation>\n+    where I: Iterator<Item = &'a Attribute>\n+{\n+    let mut depr: Option<Deprecation> = None;\n+\n+    'outer: for attr in attrs_iter {\n+        if attr.path != \"deprecated\" {\n+            continue\n+        }\n+\n+        mark_used(attr);\n+\n+        if depr.is_some() {\n+            span_err!(diagnostic, item_sp, E0550, \"multiple deprecated attributes\");\n+            break\n+        }\n+\n+        depr = if let Some(metas) = attr.meta_item_list() {\n+            let get = |meta: &MetaItem, item: &mut Option<Symbol>| {\n+                if item.is_some() {\n+                    handle_errors(diagnostic, meta.span, AttrError::MultipleItem(meta.name()));\n+                    return false\n+                }\n+                if let Some(v) = meta.value_str() {\n+                    *item = Some(v);\n+                    true\n+                } else {\n+                    span_err!(diagnostic, meta.span, E0551, \"incorrect meta item\");\n+                    false\n+                }\n+            };\n+\n+            let mut since = None;\n+            let mut note = None;\n+            for meta in metas {\n+                if let NestedMetaItemKind::MetaItem(ref mi) = meta.node {\n+                    match &*mi.name().as_str() {\n+                        \"since\" => if !get(mi, &mut since) { continue 'outer },\n+                        \"note\" => if !get(mi, &mut note) { continue 'outer },\n+                        _ => {\n+                            handle_errors(\n+                                diagnostic,\n+                                meta.span,\n+                                AttrError::UnknownMetaItem(mi.name(), &[\"since\", \"note\"]),\n+                            );\n+                            continue 'outer\n+                        }\n+                    }\n+                } else {\n+                    handle_errors(diagnostic, meta.span, AttrError::UnsupportedLiteral);\n+                    continue 'outer\n+                }\n+            }\n+\n+            Some(Deprecation {since: since, note: note})\n+        } else {\n+            Some(Deprecation{since: None, note: None})\n+        }\n+    }\n+\n+    depr\n+}\n+\n+#[derive(PartialEq, Debug, RustcEncodable, RustcDecodable, Copy, Clone)]\n+pub enum ReprAttr {\n+    ReprInt(IntType),\n+    ReprC,\n+    ReprPacked(u32),\n+    ReprSimd,\n+    ReprTransparent,\n+    ReprAlign(u32),\n+}\n+\n+#[derive(Eq, Hash, PartialEq, Debug, RustcEncodable, RustcDecodable, Copy, Clone)]\n+pub enum IntType {\n+    SignedInt(ast::IntTy),\n+    UnsignedInt(ast::UintTy)\n+}\n+\n+impl IntType {\n+    #[inline]\n+    pub fn is_signed(self) -> bool {\n+        use self::IntType::*;\n+\n+        match self {\n+            SignedInt(..) => true,\n+            UnsignedInt(..) => false\n+        }\n+    }\n+}\n+\n+/// Parse #[repr(...)] forms.\n+///\n+/// Valid repr contents: any of the primitive integral type names (see\n+/// `int_type_of_word`, below) to specify enum discriminant type; `C`, to use\n+/// the same discriminant size that the corresponding C enum would or C\n+/// structure layout, `packed` to remove padding, and `transparent` to elegate representation\n+/// concerns to the only non-ZST field.\n+pub fn find_repr_attrs(diagnostic: &Handler, attr: &Attribute) -> Vec<ReprAttr> {\n+    use self::ReprAttr::*;\n+\n+    let mut acc = Vec::new();\n+    if attr.path == \"repr\" {\n+        if let Some(items) = attr.meta_item_list() {\n+            mark_used(attr);\n+            for item in items {\n+                if !item.is_meta_item() {\n+                    handle_errors(diagnostic, item.span, AttrError::UnsupportedLiteral);\n+                    continue\n+                }\n+\n+                let mut recognised = false;\n+                if let Some(mi) = item.word() {\n+                    let word = &*mi.name().as_str();\n+                    let hint = match word {\n+                        \"C\" => Some(ReprC),\n+                        \"packed\" => Some(ReprPacked(1)),\n+                        \"simd\" => Some(ReprSimd),\n+                        \"transparent\" => Some(ReprTransparent),\n+                        _ => match int_type_of_word(word) {\n+                            Some(ity) => Some(ReprInt(ity)),\n+                            None => {\n+                                None\n+                            }\n+                        }\n+                    };\n+\n+                    if let Some(h) = hint {\n+                        recognised = true;\n+                        acc.push(h);\n+                    }\n+                } else if let Some((name, value)) = item.name_value_literal() {\n+                    let parse_alignment = |node: &ast::LitKind| -> Result<u32, &'static str> {\n+                        if let ast::LitKind::Int(literal, ast::LitIntType::Unsuffixed) = node {\n+                            if literal.is_power_of_two() {\n+                                // rustc::ty::layout::Align restricts align to <= 2^29\n+                                if *literal <= 1 << 29 {\n+                                    Ok(*literal as u32)\n+                                } else {\n+                                    Err(\"larger than 2^29\")\n+                                }\n+                            } else {\n+                                Err(\"not a power of two\")\n+                            }\n+                        } else {\n+                            Err(\"not an unsuffixed integer\")\n+                        }\n+                    };\n+\n+                    let mut literal_error = None;\n+                    if name == \"align\" {\n+                        recognised = true;\n+                        match parse_alignment(&value.node) {\n+                            Ok(literal) => acc.push(ReprAlign(literal)),\n+                            Err(message) => literal_error = Some(message)\n+                        };\n+                    }\n+                    else if name == \"packed\" {\n+                        recognised = true;\n+                        match parse_alignment(&value.node) {\n+                            Ok(literal) => acc.push(ReprPacked(literal)),\n+                            Err(message) => literal_error = Some(message)\n+                        };\n+                    }\n+                    if let Some(literal_error) = literal_error {\n+                        span_err!(diagnostic, item.span, E0589,\n+                                  \"invalid `repr(align)` attribute: {}\", literal_error);\n+                    }\n+                } else {\n+                    if let Some(meta_item) = item.meta_item() {\n+                        if meta_item.name() == \"align\" {\n+                            if let MetaItemKind::NameValue(ref value) = meta_item.node {\n+                                recognised = true;\n+                                let mut err = struct_span_err!(diagnostic, item.span, E0693,\n+                                    \"incorrect `repr(align)` attribute format\");\n+                                match value.node {\n+                                    ast::LitKind::Int(int, ast::LitIntType::Unsuffixed) => {\n+                                        err.span_suggestion_with_applicability(\n+                                            item.span,\n+                                            \"use parentheses instead\",\n+                                            format!(\"align({})\", int),\n+                                            Applicability::MachineApplicable\n+                                        );\n+                                    }\n+                                    ast::LitKind::Str(s, _) => {\n+                                        err.span_suggestion_with_applicability(\n+                                            item.span,\n+                                            \"use parentheses instead\",\n+                                            format!(\"align({})\", s),\n+                                            Applicability::MachineApplicable\n+                                        );\n+                                    }\n+                                    _ => {}\n+                                }\n+                                err.emit();\n+                            }\n+                        }\n+                    }\n+                }\n+                if !recognised {\n+                    // Not a word we recognize\n+                    span_err!(diagnostic, item.span, E0552,\n+                              \"unrecognized representation hint\");\n+                }\n+            }\n+        }\n+    }\n+    acc\n+}\n+\n+fn int_type_of_word(s: &str) -> Option<IntType> {\n+    use self::IntType::*;\n+\n+    match s {\n+        \"i8\" => Some(SignedInt(ast::IntTy::I8)),\n+        \"u8\" => Some(UnsignedInt(ast::UintTy::U8)),\n+        \"i16\" => Some(SignedInt(ast::IntTy::I16)),\n+        \"u16\" => Some(UnsignedInt(ast::UintTy::U16)),\n+        \"i32\" => Some(SignedInt(ast::IntTy::I32)),\n+        \"u32\" => Some(UnsignedInt(ast::UintTy::U32)),\n+        \"i64\" => Some(SignedInt(ast::IntTy::I64)),\n+        \"u64\" => Some(UnsignedInt(ast::UintTy::U64)),\n+        \"i128\" => Some(SignedInt(ast::IntTy::I128)),\n+        \"u128\" => Some(UnsignedInt(ast::UintTy::U128)),\n+        \"isize\" => Some(SignedInt(ast::IntTy::Isize)),\n+        \"usize\" => Some(UnsignedInt(ast::UintTy::Usize)),\n+        _ => None\n+    }\n+}"}, {"sha": "4e27d6c15258bedef5e7e59e773f36533eac7ce4", "filename": "src/libsyntax/attr/mod.rs", "status": "renamed", "additions": 10, "deletions": 678, "changes": 688, "blob_url": "https://github.com/rust-lang/rust/blob/860d169474acabdc53b9a698f8ce02eba7e0daeb/src%2Flibsyntax%2Fattr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/860d169474acabdc53b9a698f8ce02eba7e0daeb/src%2Flibsyntax%2Fattr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr%2Fmod.rs?ref=860d169474acabdc53b9a698f8ce02eba7e0daeb", "patch": "@@ -8,20 +8,25 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// Functions dealing with attributes and meta items\n+//! Functions dealing with attributes and meta items\n \n-pub use self::StabilityLevel::*;\n-pub use self::ReprAttr::*;\n+mod builtin;\n+\n+pub use self::builtin::{\n+    cfg_matches, contains_feature_attr, eval_condition, find_crate_name, find_deprecation,\n+    find_repr_attrs, find_stability, find_unwind_attr, Deprecation, InlineAttr, IntType, ReprAttr,\n+    RustcConstUnstable, RustcDeprecation, Stability, StabilityLevel, UnwindAttr,\n+};\n pub use self::IntType::*;\n+pub use self::ReprAttr::*;\n+pub use self::StabilityLevel::*;\n \n use ast;\n use ast::{AttrId, Attribute, Name, Ident, Path, PathSegment};\n use ast::{MetaItem, MetaItemKind, NestedMetaItem, NestedMetaItemKind};\n use ast::{Lit, LitKind, Expr, ExprKind, Item, Local, Stmt, StmtKind, GenericParam};\n use codemap::{BytePos, Spanned, respan, dummy_spanned};\n use syntax_pos::Span;\n-use errors::{Applicability, Handler};\n-use feature_gate::{Features, GatedCfg};\n use parse::lexer::comments::{doc_comment_style, strip_doc_comment_decoration};\n use parse::parser::Parser;\n use parse::{self, ParseSess, PResult};\n@@ -34,29 +39,6 @@ use GLOBALS;\n \n use std::iter;\n \n-enum AttrError {\n-    MultipleItem(Name),\n-    UnknownMetaItem(Name),\n-    MissingSince,\n-    MissingFeature,\n-    MultipleStabilityLevels,\n-    UnsupportedLiteral\n-}\n-\n-fn handle_errors(diag: &Handler, span: Span, error: AttrError) {\n-    match error {\n-        AttrError::MultipleItem(item) => span_err!(diag, span, E0538,\n-                                                   \"multiple '{}' items\", item),\n-        AttrError::UnknownMetaItem(item) => span_err!(diag, span, E0541,\n-                                                      \"unknown meta item '{}'\", item),\n-        AttrError::MissingSince => span_err!(diag, span, E0542, \"missing 'since'\"),\n-        AttrError::MissingFeature => span_err!(diag, span, E0546, \"missing 'feature'\"),\n-        AttrError::MultipleStabilityLevels => span_err!(diag, span, E0544,\n-                                                        \"multiple stability levels\"),\n-        AttrError::UnsupportedLiteral => span_err!(diag, span, E0565, \"unsupported literal\"),\n-    }\n-}\n-\n pub fn mark_used(attr: &Attribute) {\n     debug!(\"Marking {:?} as used.\", attr);\n     let AttrId(id) = attr.id;\n@@ -442,7 +424,6 @@ pub fn mk_spanned_attr_inner(sp: Span, id: AttrId, item: MetaItem) -> Attribute\n     }\n }\n \n-\n /// Returns an outer attribute with the given value.\n pub fn mk_attr_outer(span: Span, id: AttrId, item: MetaItem) -> Attribute {\n     mk_spanned_attr_outer(span, id, item)\n@@ -495,655 +476,6 @@ pub fn first_attr_value_str_by_name(attrs: &[Attribute], name: &str) -> Option<S\n         .and_then(|at| at.value_str())\n }\n \n-/// Check if `attrs` contains an attribute like `#![feature(feature_name)]`.\n-/// This will not perform any \"sanity checks\" on the form of the attributes.\n-pub fn contains_feature_attr(attrs: &[Attribute], feature_name: &str) -> bool {\n-    attrs.iter().any(|item| {\n-        item.check_name(\"feature\") &&\n-        item.meta_item_list().map(|list| {\n-            list.iter().any(|mi| {\n-                mi.word().map(|w| w.name() == feature_name)\n-                         .unwrap_or(false)\n-            })\n-        }).unwrap_or(false)\n-    })\n-}\n-\n-/* Higher-level applications */\n-\n-pub fn find_crate_name(attrs: &[Attribute]) -> Option<Symbol> {\n-    first_attr_value_str_by_name(attrs, \"crate_name\")\n-}\n-\n-#[derive(Copy, Clone, Hash, PartialEq, RustcEncodable, RustcDecodable)]\n-pub enum InlineAttr {\n-    None,\n-    Hint,\n-    Always,\n-    Never,\n-}\n-\n-#[derive(Copy, Clone, PartialEq)]\n-pub enum UnwindAttr {\n-    Allowed,\n-    Aborts,\n-}\n-\n-/// Determine what `#[unwind]` attribute is present in `attrs`, if any.\n-pub fn find_unwind_attr(diagnostic: Option<&Handler>, attrs: &[Attribute]) -> Option<UnwindAttr> {\n-    let syntax_error = |attr: &Attribute| {\n-        mark_used(attr);\n-        diagnostic.map(|d| {\n-            span_err!(d, attr.span, E0633, \"malformed `#[unwind]` attribute\");\n-        });\n-        None\n-    };\n-\n-    attrs.iter().fold(None, |ia, attr| {\n-        if attr.path != \"unwind\" {\n-            return ia;\n-        }\n-        let meta = match attr.meta() {\n-            Some(meta) => meta.node,\n-            None => return ia,\n-        };\n-        match meta {\n-            MetaItemKind::Word => {\n-                syntax_error(attr)\n-            }\n-            MetaItemKind::List(ref items) => {\n-                mark_used(attr);\n-                if items.len() != 1 {\n-                    syntax_error(attr)\n-                } else if list_contains_name(&items[..], \"allowed\") {\n-                    Some(UnwindAttr::Allowed)\n-                } else if list_contains_name(&items[..], \"aborts\") {\n-                    Some(UnwindAttr::Aborts)\n-                } else {\n-                    syntax_error(attr)\n-                }\n-            }\n-            _ => ia,\n-        }\n-    })\n-}\n-\n-\n-/// Tests if a cfg-pattern matches the cfg set\n-pub fn cfg_matches(cfg: &ast::MetaItem, sess: &ParseSess, features: Option<&Features>) -> bool {\n-    eval_condition(cfg, sess, &mut |cfg| {\n-        if let (Some(feats), Some(gated_cfg)) = (features, GatedCfg::gate(cfg)) {\n-            gated_cfg.check_and_emit(sess, feats);\n-        }\n-        sess.config.contains(&(cfg.name(), cfg.value_str()))\n-    })\n-}\n-\n-/// Evaluate a cfg-like condition (with `any` and `all`), using `eval` to\n-/// evaluate individual items.\n-pub fn eval_condition<F>(cfg: &ast::MetaItem, sess: &ParseSess, eval: &mut F)\n-                         -> bool\n-    where F: FnMut(&ast::MetaItem) -> bool\n-{\n-    match cfg.node {\n-        ast::MetaItemKind::List(ref mis) => {\n-            for mi in mis.iter() {\n-                if !mi.is_meta_item() {\n-                    handle_errors(&sess.span_diagnostic, mi.span, AttrError::UnsupportedLiteral);\n-                    return false;\n-                }\n-            }\n-\n-            // The unwraps below may look dangerous, but we've already asserted\n-            // that they won't fail with the loop above.\n-            match &*cfg.name().as_str() {\n-                \"any\" => mis.iter().any(|mi| {\n-                    eval_condition(mi.meta_item().unwrap(), sess, eval)\n-                }),\n-                \"all\" => mis.iter().all(|mi| {\n-                    eval_condition(mi.meta_item().unwrap(), sess, eval)\n-                }),\n-                \"not\" => {\n-                    if mis.len() != 1 {\n-                        span_err!(sess.span_diagnostic, cfg.span, E0536, \"expected 1 cfg-pattern\");\n-                        return false;\n-                    }\n-\n-                    !eval_condition(mis[0].meta_item().unwrap(), sess, eval)\n-                },\n-                p => {\n-                    span_err!(sess.span_diagnostic, cfg.span, E0537, \"invalid predicate `{}`\", p);\n-                    false\n-                }\n-            }\n-        },\n-        ast::MetaItemKind::Word | ast::MetaItemKind::NameValue(..) => {\n-            eval(cfg)\n-        }\n-    }\n-}\n-\n-/// Represents the #[stable], #[unstable], #[rustc_{deprecated,const_unstable}] attributes.\n-#[derive(RustcEncodable, RustcDecodable, Clone, Debug, PartialEq, Eq, Hash)]\n-pub struct Stability {\n-    pub level: StabilityLevel,\n-    pub feature: Symbol,\n-    pub rustc_depr: Option<RustcDeprecation>,\n-    pub rustc_const_unstable: Option<RustcConstUnstable>,\n-}\n-\n-/// The available stability levels.\n-#[derive(RustcEncodable, RustcDecodable, PartialEq, PartialOrd, Clone, Debug, Eq, Hash)]\n-pub enum StabilityLevel {\n-    // Reason for the current stability level and the relevant rust-lang issue\n-    Unstable { reason: Option<Symbol>, issue: u32 },\n-    Stable { since: Symbol },\n-}\n-\n-#[derive(RustcEncodable, RustcDecodable, PartialEq, PartialOrd, Clone, Debug, Eq, Hash)]\n-pub struct RustcDeprecation {\n-    pub since: Symbol,\n-    pub reason: Symbol,\n-}\n-\n-#[derive(RustcEncodable, RustcDecodable, PartialEq, PartialOrd, Clone, Debug, Eq, Hash)]\n-pub struct RustcConstUnstable {\n-    pub feature: Symbol,\n-}\n-\n-#[derive(RustcEncodable, RustcDecodable, PartialEq, PartialOrd, Clone, Debug, Eq, Hash)]\n-pub struct Deprecation {\n-    pub since: Option<Symbol>,\n-    pub note: Option<Symbol>,\n-}\n-\n-impl StabilityLevel {\n-    pub fn is_unstable(&self) -> bool { if let Unstable {..} = *self { true } else { false }}\n-    pub fn is_stable(&self) -> bool { if let Stable {..} = *self { true } else { false }}\n-}\n-\n-fn find_stability_generic<'a, I>(diagnostic: &Handler,\n-                                 attrs_iter: I,\n-                                 item_sp: Span)\n-                                 -> Option<Stability>\n-    where I: Iterator<Item = &'a Attribute>\n-{\n-    let mut stab: Option<Stability> = None;\n-    let mut rustc_depr: Option<RustcDeprecation> = None;\n-    let mut rustc_const_unstable: Option<RustcConstUnstable> = None;\n-\n-    'outer: for attr in attrs_iter {\n-        if ![\n-            \"rustc_deprecated\",\n-            \"rustc_const_unstable\",\n-            \"unstable\",\n-            \"stable\",\n-        ].iter().any(|&s| attr.path == s) {\n-            continue // not a stability level\n-        }\n-\n-        mark_used(attr);\n-\n-        let meta = attr.meta();\n-        if let Some(MetaItem { node: MetaItemKind::List(ref metas), .. }) = meta {\n-            let meta = meta.as_ref().unwrap();\n-            let get = |meta: &MetaItem, item: &mut Option<Symbol>| {\n-                if item.is_some() {\n-                    handle_errors(diagnostic, meta.span, AttrError::MultipleItem(meta.name()));\n-                    return false\n-                }\n-                if let Some(v) = meta.value_str() {\n-                    *item = Some(v);\n-                    true\n-                } else {\n-                    span_err!(diagnostic, meta.span, E0539, \"incorrect meta item\");\n-                    false\n-                }\n-            };\n-\n-            macro_rules! get_meta {\n-                ($($name:ident),+) => {\n-                    $(\n-                        let mut $name = None;\n-                    )+\n-                    for meta in metas {\n-                        if let Some(mi) = meta.meta_item() {\n-                            match &*mi.name().as_str() {\n-                                $(\n-                                    stringify!($name)\n-                                        => if !get(mi, &mut $name) { continue 'outer },\n-                                )+\n-                                _ => {\n-                                    handle_errors(diagnostic, mi.span,\n-                                                  AttrError::UnknownMetaItem(mi.name()));\n-                                    continue 'outer\n-                                }\n-                            }\n-                        } else {\n-                            handle_errors(diagnostic, meta.span, AttrError::UnsupportedLiteral);\n-                            continue 'outer\n-                        }\n-                    }\n-                }\n-            }\n-\n-            match &*meta.name().as_str() {\n-                \"rustc_deprecated\" => {\n-                    if rustc_depr.is_some() {\n-                        span_err!(diagnostic, item_sp, E0540,\n-                                  \"multiple rustc_deprecated attributes\");\n-                        continue 'outer\n-                    }\n-\n-                    get_meta!(since, reason);\n-\n-                    match (since, reason) {\n-                        (Some(since), Some(reason)) => {\n-                            rustc_depr = Some(RustcDeprecation {\n-                                since,\n-                                reason,\n-                            })\n-                        }\n-                        (None, _) => {\n-                            handle_errors(diagnostic, attr.span(), AttrError::MissingSince);\n-                            continue\n-                        }\n-                        _ => {\n-                            span_err!(diagnostic, attr.span(), E0543, \"missing 'reason'\");\n-                            continue\n-                        }\n-                    }\n-                }\n-                \"rustc_const_unstable\" => {\n-                    if rustc_const_unstable.is_some() {\n-                        span_err!(diagnostic, item_sp, E0553,\n-                                  \"multiple rustc_const_unstable attributes\");\n-                        continue 'outer\n-                    }\n-\n-                    get_meta!(feature);\n-                    if let Some(feature) = feature {\n-                        rustc_const_unstable = Some(RustcConstUnstable {\n-                            feature\n-                        });\n-                    } else {\n-                        span_err!(diagnostic, attr.span(), E0629, \"missing 'feature'\");\n-                        continue\n-                    }\n-                }\n-                \"unstable\" => {\n-                    if stab.is_some() {\n-                        handle_errors(diagnostic, attr.span(), AttrError::MultipleStabilityLevels);\n-                        break\n-                    }\n-\n-                    let mut feature = None;\n-                    let mut reason = None;\n-                    let mut issue = None;\n-                    for meta in metas {\n-                        if let Some(mi) = meta.meta_item() {\n-                            match &*mi.name().as_str() {\n-                                \"feature\" => if !get(mi, &mut feature) { continue 'outer },\n-                                \"reason\" => if !get(mi, &mut reason) { continue 'outer },\n-                                \"issue\" => if !get(mi, &mut issue) { continue 'outer },\n-                                _ => {\n-                                    handle_errors(diagnostic, meta.span,\n-                                                  AttrError::UnknownMetaItem(mi.name()));\n-                                    continue 'outer\n-                                }\n-                            }\n-                        } else {\n-                            handle_errors(diagnostic, meta.span, AttrError::UnsupportedLiteral);\n-                            continue 'outer\n-                        }\n-                    }\n-\n-                    match (feature, reason, issue) {\n-                        (Some(feature), reason, Some(issue)) => {\n-                            stab = Some(Stability {\n-                                level: Unstable {\n-                                    reason,\n-                                    issue: {\n-                                        if let Ok(issue) = issue.as_str().parse() {\n-                                            issue\n-                                        } else {\n-                                            span_err!(diagnostic, attr.span(), E0545,\n-                                                      \"incorrect 'issue'\");\n-                                            continue\n-                                        }\n-                                    }\n-                                },\n-                                feature,\n-                                rustc_depr: None,\n-                                rustc_const_unstable: None,\n-                            })\n-                        }\n-                        (None, _, _) => {\n-                            handle_errors(diagnostic, attr.span(), AttrError::MissingFeature);\n-                            continue\n-                        }\n-                        _ => {\n-                            span_err!(diagnostic, attr.span(), E0547, \"missing 'issue'\");\n-                            continue\n-                        }\n-                    }\n-                }\n-                \"stable\" => {\n-                    if stab.is_some() {\n-                        handle_errors(diagnostic, attr.span(), AttrError::MultipleStabilityLevels);\n-                        break\n-                    }\n-\n-                    let mut feature = None;\n-                    let mut since = None;\n-                    for meta in metas {\n-                        if let NestedMetaItemKind::MetaItem(ref mi) = meta.node {\n-                            match &*mi.name().as_str() {\n-                                \"feature\" => if !get(mi, &mut feature) { continue 'outer },\n-                                \"since\" => if !get(mi, &mut since) { continue 'outer },\n-                                _ => {\n-                                    handle_errors(diagnostic, meta.span,\n-                                                  AttrError::UnknownMetaItem(mi.name()));\n-                                    continue 'outer\n-                                }\n-                            }\n-                        } else {\n-                            handle_errors(diagnostic, meta.span, AttrError::UnsupportedLiteral);\n-                            continue 'outer\n-                        }\n-                    }\n-\n-                    match (feature, since) {\n-                        (Some(feature), Some(since)) => {\n-                            stab = Some(Stability {\n-                                level: Stable {\n-                                    since,\n-                                },\n-                                feature,\n-                                rustc_depr: None,\n-                                rustc_const_unstable: None,\n-                            })\n-                        }\n-                        (None, _) => {\n-                            handle_errors(diagnostic, attr.span(), AttrError::MissingFeature);\n-                            continue\n-                        }\n-                        _ => {\n-                            handle_errors(diagnostic, attr.span(), AttrError::MissingSince);\n-                            continue\n-                        }\n-                    }\n-                }\n-                _ => unreachable!()\n-            }\n-        } else {\n-            span_err!(diagnostic, attr.span(), E0548, \"incorrect stability attribute type\");\n-            continue\n-        }\n-    }\n-\n-    // Merge the deprecation info into the stability info\n-    if let Some(rustc_depr) = rustc_depr {\n-        if let Some(ref mut stab) = stab {\n-            stab.rustc_depr = Some(rustc_depr);\n-        } else {\n-            span_err!(diagnostic, item_sp, E0549,\n-                      \"rustc_deprecated attribute must be paired with \\\n-                       either stable or unstable attribute\");\n-        }\n-    }\n-\n-    // Merge the const-unstable info into the stability info\n-    if let Some(rustc_const_unstable) = rustc_const_unstable {\n-        if let Some(ref mut stab) = stab {\n-            stab.rustc_const_unstable = Some(rustc_const_unstable);\n-        } else {\n-            span_err!(diagnostic, item_sp, E0630,\n-                      \"rustc_const_unstable attribute must be paired with \\\n-                       either stable or unstable attribute\");\n-        }\n-    }\n-\n-    stab\n-}\n-\n-fn find_deprecation_generic<'a, I>(diagnostic: &Handler,\n-                                   attrs_iter: I,\n-                                   item_sp: Span)\n-                                   -> Option<Deprecation>\n-    where I: Iterator<Item = &'a Attribute>\n-{\n-    let mut depr: Option<Deprecation> = None;\n-\n-    'outer: for attr in attrs_iter {\n-        if attr.path != \"deprecated\" {\n-            continue\n-        }\n-\n-        mark_used(attr);\n-\n-        if depr.is_some() {\n-            span_err!(diagnostic, item_sp, E0550, \"multiple deprecated attributes\");\n-            break\n-        }\n-\n-        depr = if let Some(metas) = attr.meta_item_list() {\n-            let get = |meta: &MetaItem, item: &mut Option<Symbol>| {\n-                if item.is_some() {\n-                    handle_errors(diagnostic, meta.span, AttrError::MultipleItem(meta.name()));\n-                    return false\n-                }\n-                if let Some(v) = meta.value_str() {\n-                    *item = Some(v);\n-                    true\n-                } else {\n-                    span_err!(diagnostic, meta.span, E0551, \"incorrect meta item\");\n-                    false\n-                }\n-            };\n-\n-            let mut since = None;\n-            let mut note = None;\n-            for meta in metas {\n-                if let NestedMetaItemKind::MetaItem(ref mi) = meta.node {\n-                    match &*mi.name().as_str() {\n-                        \"since\" => if !get(mi, &mut since) { continue 'outer },\n-                        \"note\" => if !get(mi, &mut note) { continue 'outer },\n-                        _ => {\n-                            handle_errors(diagnostic, meta.span,\n-                                          AttrError::UnknownMetaItem(mi.name()));\n-                            continue 'outer\n-                        }\n-                    }\n-                } else {\n-                    handle_errors(diagnostic, meta.span, AttrError::UnsupportedLiteral);\n-                    continue 'outer\n-                }\n-            }\n-\n-            Some(Deprecation {since: since, note: note})\n-        } else {\n-            Some(Deprecation{since: None, note: None})\n-        }\n-    }\n-\n-    depr\n-}\n-\n-/// Find the first stability attribute. `None` if none exists.\n-pub fn find_stability(diagnostic: &Handler, attrs: &[Attribute],\n-                      item_sp: Span) -> Option<Stability> {\n-    find_stability_generic(diagnostic, attrs.iter(), item_sp)\n-}\n-\n-/// Find the deprecation attribute. `None` if none exists.\n-pub fn find_deprecation(diagnostic: &Handler, attrs: &[Attribute],\n-                        item_sp: Span) -> Option<Deprecation> {\n-    find_deprecation_generic(diagnostic, attrs.iter(), item_sp)\n-}\n-\n-\n-/// Parse #[repr(...)] forms.\n-///\n-/// Valid repr contents: any of the primitive integral type names (see\n-/// `int_type_of_word`, below) to specify enum discriminant type; `C`, to use\n-/// the same discriminant size that the corresponding C enum would or C\n-/// structure layout, `packed` to remove padding, and `transparent` to elegate representation\n-/// concerns to the only non-ZST field.\n-pub fn find_repr_attrs(diagnostic: &Handler, attr: &Attribute) -> Vec<ReprAttr> {\n-    let mut acc = Vec::new();\n-    if attr.path == \"repr\" {\n-        if let Some(items) = attr.meta_item_list() {\n-            mark_used(attr);\n-            for item in items {\n-                if !item.is_meta_item() {\n-                    handle_errors(diagnostic, item.span, AttrError::UnsupportedLiteral);\n-                    continue\n-                }\n-\n-                let mut recognised = false;\n-                if let Some(mi) = item.word() {\n-                    let word = &*mi.name().as_str();\n-                    let hint = match word {\n-                        \"C\" => Some(ReprC),\n-                        \"packed\" => Some(ReprPacked(1)),\n-                        \"simd\" => Some(ReprSimd),\n-                        \"transparent\" => Some(ReprTransparent),\n-                        _ => match int_type_of_word(word) {\n-                            Some(ity) => Some(ReprInt(ity)),\n-                            None => {\n-                                None\n-                            }\n-                        }\n-                    };\n-\n-                    if let Some(h) = hint {\n-                        recognised = true;\n-                        acc.push(h);\n-                    }\n-                } else if let Some((name, value)) = item.name_value_literal() {\n-                    let parse_alignment = |node: &ast::LitKind| -> Result<u32, &'static str> {\n-                        if let ast::LitKind::Int(literal, ast::LitIntType::Unsuffixed) = node {\n-                            if literal.is_power_of_two() {\n-                                // rustc::ty::layout::Align restricts align to <= 2^29\n-                                if *literal <= 1 << 29 {\n-                                    Ok(*literal as u32)\n-                                } else {\n-                                    Err(\"larger than 2^29\")\n-                                }\n-                            } else {\n-                                Err(\"not a power of two\")\n-                            }\n-                        } else {\n-                            Err(\"not an unsuffixed integer\")\n-                        }\n-                    };\n-\n-                    let mut literal_error = None;\n-                    if name == \"align\" {\n-                        recognised = true;\n-                        match parse_alignment(&value.node) {\n-                            Ok(literal) => acc.push(ReprAlign(literal)),\n-                            Err(message) => literal_error = Some(message)\n-                        };\n-                    }\n-                    else if name == \"packed\" {\n-                        recognised = true;\n-                        match parse_alignment(&value.node) {\n-                            Ok(literal) => acc.push(ReprPacked(literal)),\n-                            Err(message) => literal_error = Some(message)\n-                        };\n-                    }\n-                    if let Some(literal_error) = literal_error {\n-                        span_err!(diagnostic, item.span, E0589,\n-                                  \"invalid `repr(align)` attribute: {}\", literal_error);\n-                    }\n-                } else {\n-                    if let Some(meta_item) = item.meta_item() {\n-                        if meta_item.name() == \"align\" {\n-                            if let MetaItemKind::NameValue(ref value) = meta_item.node {\n-                                recognised = true;\n-                                let mut err = struct_span_err!(diagnostic, item.span, E0693,\n-                                    \"incorrect `repr(align)` attribute format\");\n-                                match value.node {\n-                                    ast::LitKind::Int(int, ast::LitIntType::Unsuffixed) => {\n-                                        err.span_suggestion_with_applicability(\n-                                            item.span,\n-                                            \"use parentheses instead\",\n-                                            format!(\"align({})\", int),\n-                                            Applicability::MachineApplicable\n-                                        );\n-                                    }\n-                                    ast::LitKind::Str(s, _) => {\n-                                        err.span_suggestion_with_applicability(\n-                                            item.span,\n-                                            \"use parentheses instead\",\n-                                            format!(\"align({})\", s),\n-                                            Applicability::MachineApplicable\n-                                        );\n-                                    }\n-                                    _ => {}\n-                                }\n-                                err.emit();\n-                            }\n-                        }\n-                    }\n-                }\n-                if !recognised {\n-                    // Not a word we recognize\n-                    span_err!(diagnostic, item.span, E0552,\n-                              \"unrecognized representation hint\");\n-                }\n-            }\n-        }\n-    }\n-    acc\n-}\n-\n-fn int_type_of_word(s: &str) -> Option<IntType> {\n-    match s {\n-        \"i8\" => Some(SignedInt(ast::IntTy::I8)),\n-        \"u8\" => Some(UnsignedInt(ast::UintTy::U8)),\n-        \"i16\" => Some(SignedInt(ast::IntTy::I16)),\n-        \"u16\" => Some(UnsignedInt(ast::UintTy::U16)),\n-        \"i32\" => Some(SignedInt(ast::IntTy::I32)),\n-        \"u32\" => Some(UnsignedInt(ast::UintTy::U32)),\n-        \"i64\" => Some(SignedInt(ast::IntTy::I64)),\n-        \"u64\" => Some(UnsignedInt(ast::UintTy::U64)),\n-        \"i128\" => Some(SignedInt(ast::IntTy::I128)),\n-        \"u128\" => Some(UnsignedInt(ast::UintTy::U128)),\n-        \"isize\" => Some(SignedInt(ast::IntTy::Isize)),\n-        \"usize\" => Some(UnsignedInt(ast::UintTy::Usize)),\n-        _ => None\n-    }\n-}\n-\n-#[derive(PartialEq, Debug, RustcEncodable, RustcDecodable, Copy, Clone)]\n-pub enum ReprAttr {\n-    ReprInt(IntType),\n-    ReprC,\n-    ReprPacked(u32),\n-    ReprSimd,\n-    ReprTransparent,\n-    ReprAlign(u32),\n-}\n-\n-#[derive(Eq, Hash, PartialEq, Debug, RustcEncodable, RustcDecodable, Copy, Clone)]\n-pub enum IntType {\n-    SignedInt(ast::IntTy),\n-    UnsignedInt(ast::UintTy)\n-}\n-\n-impl IntType {\n-    #[inline]\n-    pub fn is_signed(self) -> bool {\n-        match self {\n-            SignedInt(..) => true,\n-            UnsignedInt(..) => false\n-        }\n-    }\n-}\n-\n impl MetaItem {\n     fn tokens(&self) -> TokenStream {\n         let mut idents = vec![];", "previous_filename": "src/libsyntax/attr.rs"}, {"sha": "af2ac79ea80721808bcc49e694f9ba8e6c9f52a0", "filename": "src/test/ui/deprecation-sanity.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/860d169474acabdc53b9a698f8ce02eba7e0daeb/src%2Ftest%2Fui%2Fdeprecation-sanity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/860d169474acabdc53b9a698f8ce02eba7e0daeb/src%2Ftest%2Fui%2Fdeprecation-sanity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdeprecation-sanity.rs?ref=860d169474acabdc53b9a698f8ce02eba7e0daeb", "previous_filename": "src/test/compile-fail/deprecation-sanity.rs"}, {"sha": "967eb6e23a379721c5c3e901e73c094b1400d8c7", "filename": "src/test/ui/deprecation-sanity.stderr", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/860d169474acabdc53b9a698f8ce02eba7e0daeb/src%2Ftest%2Fui%2Fdeprecation-sanity.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/860d169474acabdc53b9a698f8ce02eba7e0daeb/src%2Ftest%2Fui%2Fdeprecation-sanity.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdeprecation-sanity.stderr?ref=860d169474acabdc53b9a698f8ce02eba7e0daeb", "patch": "@@ -0,0 +1,46 @@\n+error[E0541]: unknown meta item 'reason'\n+  --> $DIR/deprecation-sanity.rs:14:43\n+   |\n+LL |     #[deprecated(since = \"a\", note = \"a\", reason)] //~ ERROR unknown meta item 'reason'\n+   |                                           ^^^^^^ expected one of `since`, `note`\n+\n+error[E0551]: incorrect meta item\n+  --> $DIR/deprecation-sanity.rs:17:31\n+   |\n+LL |     #[deprecated(since = \"a\", note)] //~ ERROR incorrect meta item\n+   |                               ^^^^\n+\n+error[E0551]: incorrect meta item\n+  --> $DIR/deprecation-sanity.rs:20:18\n+   |\n+LL |     #[deprecated(since, note = \"a\")] //~ ERROR incorrect meta item\n+   |                  ^^^^^\n+\n+error[E0551]: incorrect meta item\n+  --> $DIR/deprecation-sanity.rs:23:31\n+   |\n+LL |     #[deprecated(since = \"a\", note(b))] //~ ERROR incorrect meta item\n+   |                               ^^^^^^^\n+\n+error[E0551]: incorrect meta item\n+  --> $DIR/deprecation-sanity.rs:26:18\n+   |\n+LL |     #[deprecated(since(b), note = \"a\")] //~ ERROR incorrect meta item\n+   |                  ^^^^^^^^\n+\n+error[E0550]: multiple deprecated attributes\n+  --> $DIR/deprecation-sanity.rs:32:1\n+   |\n+LL | fn multiple1() { } //~ ERROR multiple deprecated attributes\n+   | ^^^^^^^^^^^^^^^^^^\n+\n+error[E0538]: multiple 'since' items\n+  --> $DIR/deprecation-sanity.rs:34:27\n+   |\n+LL | #[deprecated(since = \"a\", since = \"b\", note = \"c\")] //~ ERROR multiple 'since' items\n+   |                           ^^^^^^^^^^^\n+\n+error: aborting due to 7 previous errors\n+\n+Some errors occurred: E0538, E0541, E0550, E0551.\n+For more information about an error, try `rustc --explain E0538`."}, {"sha": "82cb722a6560096cafc6f985c71e4cb652083adc", "filename": "src/test/ui/suggestions/issue-48364.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/860d169474acabdc53b9a698f8ce02eba7e0daeb/src%2Ftest%2Fui%2Fsuggestions%2Fissue-48364.rs", "raw_url": "https://github.com/rust-lang/rust/raw/860d169474acabdc53b9a698f8ce02eba7e0daeb/src%2Ftest%2Fui%2Fsuggestions%2Fissue-48364.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fissue-48364.rs?ref=860d169474acabdc53b9a698f8ce02eba7e0daeb", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn foo() -> bool {\n+    b\"\".starts_with(stringify!(foo))\n+    //~^ ERROR mismatched types\n+}\n+\n+fn main() {}"}, {"sha": "b420654a32d8c9bfe6520c3c682ac2bed98184ca", "filename": "src/test/ui/suggestions/issue-48364.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/860d169474acabdc53b9a698f8ce02eba7e0daeb/src%2Ftest%2Fui%2Fsuggestions%2Fissue-48364.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/860d169474acabdc53b9a698f8ce02eba7e0daeb/src%2Ftest%2Fui%2Fsuggestions%2Fissue-48364.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fissue-48364.stderr?ref=860d169474acabdc53b9a698f8ce02eba7e0daeb", "patch": "@@ -0,0 +1,12 @@\n+error[E0308]: mismatched types\n+  --> $DIR/issue-48364.rs:12:21\n+   |\n+LL |     b\"\".starts_with(stringify!(foo))\n+   |                     ^^^^^^^^^^^^^^^ expected slice, found str\n+   |\n+   = note: expected type `&[u8]`\n+              found type `&'static str`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0308`."}]}