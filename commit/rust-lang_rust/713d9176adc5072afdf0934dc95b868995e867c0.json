{"sha": "713d9176adc5072afdf0934dc95b868995e867c0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcxM2Q5MTc2YWRjNTA3MmFmZGYwOTM0ZGM5NWI4Njg5OTVlODY3YzA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-06-17T22:50:17Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-06-17T22:50:17Z"}, "message": "Auto merge of #26326 - nikomatsakis:optimize-fulfillment-cache-in-tcx, r=pcwalton\n\nWhen we successfully resolve a trait reference with no type/lifetime parameters, like `i32: Foo` or `Box<u32>: Sized`, this is in fact globally true. This patch adds a simple global to the tcx to cache such cases. The main advantage of this is really about caching things like `Box<Vec<Foo>>: Sized`. It also points to the need to revamp our caching infrastructure -- the current caches make selection cost cheaper, but we still wind up paying a high cost in the confirmation process, and in particular unrolling out dependent obligations. Moreover, we should probably do caching more uniformly and with a key that takes the where-clauses into account. But that's for later.\r\n\r\nFor me, this shows up as a reasonably nice win (20%) on Servo's script crate (when built in dev mode). This is not as big as my initial measurements suggested, I think because I was building my rustc with more debugging enabled at the time. I've not yet done follow-up profiling and so forth to see where the new hot spots are. Bootstrap times seem to be largely unaffected.\r\n\r\ncc @pcwalton \r\n\r\nThis is technically a [breaking-change] in that functions with unsatisfiable where-clauses may now yield errors where before they may have been accepted. Even before, these functions could never have been *called* by actual code. In the future, such functions will probably become illegal altogether, but in this commit they are still accepted, so long as they do not rely on the unsatisfiable where-clauses. As before, the functions still cannot be called in any case.", "tree": {"sha": "56583a3b9d815678628dbd66206798d28cc65653", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/56583a3b9d815678628dbd66206798d28cc65653"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/713d9176adc5072afdf0934dc95b868995e867c0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/713d9176adc5072afdf0934dc95b868995e867c0", "html_url": "https://github.com/rust-lang/rust/commit/713d9176adc5072afdf0934dc95b868995e867c0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/713d9176adc5072afdf0934dc95b868995e867c0/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8af39cebc547a946b4ae861854c46c9c9a70a923", "url": "https://api.github.com/repos/rust-lang/rust/commits/8af39cebc547a946b4ae861854c46c9c9a70a923", "html_url": "https://github.com/rust-lang/rust/commit/8af39cebc547a946b4ae861854c46c9c9a70a923"}, {"sha": "957935a002aa88adb0f1288a84a0933d06cc297d", "url": "https://api.github.com/repos/rust-lang/rust/commits/957935a002aa88adb0f1288a84a0933d06cc297d", "html_url": "https://github.com/rust-lang/rust/commit/957935a002aa88adb0f1288a84a0933d06cc297d"}], "stats": {"total": 313, "additions": 253, "deletions": 60}, "files": [{"sha": "d80eedf354a0e31218967480f6694421ec7bc999", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/713d9176adc5072afdf0934dc95b868995e867c0/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/713d9176adc5072afdf0934dc95b868995e867c0/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=713d9176adc5072afdf0934dc95b868995e867c0", "patch": "@@ -285,7 +285,7 @@ impl<'a, 'tcx> CheckCrateVisitor<'a, 'tcx> {\n     fn check_static_type(&self, e: &ast::Expr) {\n         let ty = ty::node_id_to_type(self.tcx, e.id);\n         let infcx = infer::new_infer_ctxt(self.tcx);\n-        let mut fulfill_cx = traits::FulfillmentContext::new();\n+        let mut fulfill_cx = traits::FulfillmentContext::new(false);\n         let cause = traits::ObligationCause::new(e.span, e.id, traits::SharedStatic);\n         fulfill_cx.register_builtin_bound(&infcx, ty, ty::BoundSync, cause);\n         let env = ty::empty_parameter_environment(self.tcx);"}, {"sha": "b9117745db2e20aea3cc1f12289a6984a58a3739", "filename": "src/librustc/middle/traits/fulfill.rs", "status": "modified", "additions": 68, "deletions": 4, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/713d9176adc5072afdf0934dc95b868995e867c0/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/713d9176adc5072afdf0934dc95b868995e867c0/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs?ref=713d9176adc5072afdf0934dc95b868995e867c0", "patch": "@@ -28,6 +28,10 @@ use super::select::SelectionContext;\n use super::Unimplemented;\n use super::util::predicate_for_builtin_bound;\n \n+pub struct FulfilledPredicates<'tcx> {\n+    set: HashSet<ty::Predicate<'tcx>>\n+}\n+\n /// The fulfillment context is used to drive trait resolution.  It\n /// consists of a list of obligations that must be (eventually)\n /// satisfied. The job is to track which are satisfied, which yielded\n@@ -44,7 +48,7 @@ pub struct FulfillmentContext<'tcx> {\n     // than the `SelectionCache`: it avoids duplicate errors and\n     // permits recursive obligations, which are often generated from\n     // traits like `Send` et al.\n-    duplicate_set: HashSet<ty::Predicate<'tcx>>,\n+    duplicate_set: FulfilledPredicates<'tcx>,\n \n     // A list of all obligations that have been registered with this\n     // fulfillment context.\n@@ -80,6 +84,8 @@ pub struct FulfillmentContext<'tcx> {\n     // obligations (otherwise, it's easy to fail to walk to a\n     // particular node-id).\n     region_obligations: NodeMap<Vec<RegionObligation<'tcx>>>,\n+\n+    errors_will_be_reported: bool,\n }\n \n #[derive(Clone)]\n@@ -90,12 +96,30 @@ pub struct RegionObligation<'tcx> {\n }\n \n impl<'tcx> FulfillmentContext<'tcx> {\n-    pub fn new() -> FulfillmentContext<'tcx> {\n+    /// Creates a new fulfillment context.\n+    ///\n+    /// `errors_will_be_reported` indicates whether ALL errors that\n+    /// are generated by this fulfillment context will be reported to\n+    /// the end user. This is used to inform caching, because it\n+    /// allows us to conclude that traits that resolve successfully\n+    /// will in fact always resolve successfully (in particular, it\n+    /// guarantees that if some dependent obligation encounters a\n+    /// problem, compilation will be aborted).  If you're not sure of\n+    /// the right value here, pass `false`, as that is the more\n+    /// conservative option.\n+    ///\n+    /// FIXME -- a better option would be to hold back on modifying\n+    /// the global cache until we know that all dependent obligations\n+    /// are also satisfied. In that case, we could actually remove\n+    /// this boolean flag, and we'd also avoid the problem of squelching\n+    /// duplicate errors that occur across fns.\n+    pub fn new(errors_will_be_reported: bool) -> FulfillmentContext<'tcx> {\n         FulfillmentContext {\n-            duplicate_set: HashSet::new(),\n+            duplicate_set: FulfilledPredicates::new(),\n             predicates: Vec::new(),\n             attempted_mark: 0,\n             region_obligations: NodeMap(),\n+            errors_will_be_reported: errors_will_be_reported,\n         }\n     }\n \n@@ -165,7 +189,7 @@ impl<'tcx> FulfillmentContext<'tcx> {\n \n         assert!(!obligation.has_escaping_regions());\n \n-        if !self.duplicate_set.insert(obligation.predicate.clone()) {\n+        if self.is_duplicate_or_add(infcx.tcx, &obligation.predicate) {\n             debug!(\"register_predicate({}) -- already seen, skip\", obligation.repr(infcx.tcx));\n             return;\n         }\n@@ -231,6 +255,28 @@ impl<'tcx> FulfillmentContext<'tcx> {\n         &self.predicates\n     }\n \n+    fn is_duplicate_or_add(&mut self, tcx: &ty::ctxt<'tcx>,\n+                           predicate: &ty::Predicate<'tcx>)\n+                           -> bool {\n+        // This is a kind of dirty hack to allow us to avoid \"rederiving\"\n+        // things that we have already proven in other methods.\n+        //\n+        // The idea is that any predicate that doesn't involve type\n+        // parameters and which only involves the 'static region (and\n+        // no other regions) is universally solvable, since impls are global.\n+        //\n+        // This is particularly important since even if we have a\n+        // cache hit in the selection context, we still wind up\n+        // evaluating the 'nested obligations'.  This cache lets us\n+        // skip those.\n+\n+        if self.errors_will_be_reported && predicate.is_global() {\n+            tcx.fulfilled_predicates.borrow_mut().is_duplicate_or_add(predicate)\n+        } else {\n+            self.duplicate_set.is_duplicate_or_add(predicate)\n+        }\n+    }\n+\n     /// Attempts to select obligations using `selcx`. If `only_new_obligations` is true, then it\n     /// only attempts to select obligations that haven't been seen before.\n     fn select<'a>(&mut self,\n@@ -442,3 +488,21 @@ fn register_region_obligation<'tcx>(tcx: &ty::ctxt<'tcx>,\n         .push(region_obligation);\n \n }\n+\n+impl<'tcx> FulfilledPredicates<'tcx> {\n+    pub fn new() -> FulfilledPredicates<'tcx> {\n+        FulfilledPredicates {\n+            set: HashSet::new()\n+        }\n+    }\n+\n+    pub fn is_duplicate(&self, p: &ty::Predicate<'tcx>) -> bool {\n+        self.set.contains(p)\n+    }\n+\n+    fn is_duplicate_or_add(&mut self, p: &ty::Predicate<'tcx>) -> bool {\n+        !self.set.insert(p.clone())\n+    }\n+}\n+\n+"}, {"sha": "50536f586e7a8579c95c120def5793badf11184e", "filename": "src/librustc/middle/traits/mod.rs", "status": "modified", "additions": 25, "deletions": 10, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/713d9176adc5072afdf0934dc95b868995e867c0/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/713d9176adc5072afdf0934dc95b868995e867c0/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs?ref=713d9176adc5072afdf0934dc95b868995e867c0", "patch": "@@ -32,7 +32,7 @@ pub use self::error_reporting::suggest_new_overflow_limit;\n pub use self::coherence::orphan_check;\n pub use self::coherence::overlapping_impls;\n pub use self::coherence::OrphanCheckErr;\n-pub use self::fulfill::{FulfillmentContext, RegionObligation};\n+pub use self::fulfill::{FulfillmentContext, FulfilledPredicates, RegionObligation};\n pub use self::project::MismatchedProjectionTypes;\n pub use self::project::normalize;\n pub use self::project::Normalized;\n@@ -315,7 +315,7 @@ pub fn evaluate_builtin_bound<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n            ty.repr(infcx.tcx),\n            bound);\n \n-    let mut fulfill_cx = FulfillmentContext::new();\n+    let mut fulfill_cx = FulfillmentContext::new(false);\n \n     // We can use a dummy node-id here because we won't pay any mind\n     // to region obligations that arise (there shouldn't really be any\n@@ -414,9 +414,27 @@ pub fn normalize_param_env_or_error<'a,'tcx>(unnormalized_env: ty::ParameterEnvi\n     debug!(\"normalize_param_env_or_error(unnormalized_env={})\",\n            unnormalized_env.repr(tcx));\n \n+    let predicates: Vec<_> =\n+        util::elaborate_predicates(tcx, unnormalized_env.caller_bounds.clone())\n+        .filter(|p| !p.is_global()) // (*)\n+        .collect();\n+\n+    // (*) Any predicate like `i32: Trait<u32>` or whatever doesn't\n+    // need to be in the *environment* to be proven, so screen those\n+    // out. This is important for the soundness of inter-fn\n+    // caching. Note though that we should probably check that these\n+    // predicates hold at the point where the environment is\n+    // constructed, but I am not currently doing so out of laziness.\n+    // -nmatsakis\n+\n+    debug!(\"normalize_param_env_or_error: elaborated-predicates={}\",\n+           predicates.repr(tcx));\n+\n+    let elaborated_env = unnormalized_env.with_caller_bounds(predicates);\n+\n     let infcx = infer::new_infer_ctxt(tcx);\n-    let predicates = match fully_normalize(&infcx, &unnormalized_env, cause,\n-                                           &unnormalized_env.caller_bounds) {\n+    let predicates = match fully_normalize(&infcx, &elaborated_env, cause,\n+                                           &elaborated_env.caller_bounds) {\n         Ok(predicates) => predicates,\n         Err(errors) => {\n             report_fulfillment_errors(&infcx, &errors);\n@@ -438,14 +456,11 @@ pub fn normalize_param_env_or_error<'a,'tcx>(unnormalized_env: ty::ParameterEnvi\n             // all things considered.\n             let err_msg = fixup_err_to_string(fixup_err);\n             tcx.sess.span_err(span, &err_msg);\n-            return unnormalized_env; // an unnormalized env is better than nothing\n+            return elaborated_env; // an unnormalized env is better than nothing\n         }\n     };\n \n-    debug!(\"normalize_param_env_or_error: predicates={}\",\n-           predicates.repr(tcx));\n-\n-    unnormalized_env.with_caller_bounds(predicates)\n+    elaborated_env.with_caller_bounds(predicates)\n }\n \n pub fn fully_normalize<'a,'tcx,T>(infcx: &InferCtxt<'a,'tcx>,\n@@ -460,7 +475,7 @@ pub fn fully_normalize<'a,'tcx,T>(infcx: &InferCtxt<'a,'tcx>,\n     debug!(\"normalize_param_env(value={})\", value.repr(tcx));\n \n     let mut selcx = &mut SelectionContext::new(infcx, closure_typer);\n-    let mut fulfill_cx = FulfillmentContext::new();\n+    let mut fulfill_cx = FulfillmentContext::new(false);\n     let Normalized { value: normalized_value, obligations } =\n         project::normalize(selcx, cause, value);\n     debug!(\"normalize_param_env: normalized_value={} obligations={}\","}, {"sha": "7915f9a8bdf317e1b7040501ba4a7c125768c541", "filename": "src/librustc/middle/traits/project.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/713d9176adc5072afdf0934dc95b868995e867c0/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/713d9176adc5072afdf0934dc95b868995e867c0/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs?ref=713d9176adc5072afdf0934dc95b868995e867c0", "patch": "@@ -535,7 +535,7 @@ fn assemble_candidates_from_param_env<'cx,'tcx>(\n     obligation_trait_ref: &ty::TraitRef<'tcx>,\n     candidate_set: &mut ProjectionTyCandidateSet<'tcx>)\n {\n-    let env_predicates = selcx.param_env().caller_bounds.clone();\n+    let env_predicates = selcx.param_env().caller_bounds.iter().cloned();\n     assemble_candidates_from_predicates(selcx, obligation, obligation_trait_ref,\n                                         candidate_set, env_predicates);\n }\n@@ -571,22 +571,25 @@ fn assemble_candidates_from_trait_def<'cx,'tcx>(\n     // If so, extract what we know from the trait and try to come up with a good answer.\n     let trait_predicates = ty::lookup_predicates(selcx.tcx(), trait_ref.def_id);\n     let bounds = trait_predicates.instantiate(selcx.tcx(), trait_ref.substs);\n+    let bounds = elaborate_predicates(selcx.tcx(), bounds.predicates.into_vec());\n     assemble_candidates_from_predicates(selcx, obligation, obligation_trait_ref,\n-                                        candidate_set, bounds.predicates.into_vec());\n+                                        candidate_set, bounds)\n }\n \n-fn assemble_candidates_from_predicates<'cx,'tcx>(\n+fn assemble_candidates_from_predicates<'cx,'tcx,I>(\n     selcx: &mut SelectionContext<'cx,'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n     obligation_trait_ref: &ty::TraitRef<'tcx>,\n     candidate_set: &mut ProjectionTyCandidateSet<'tcx>,\n-    env_predicates: Vec<ty::Predicate<'tcx>>)\n+    env_predicates: I)\n+    where I: Iterator<Item=ty::Predicate<'tcx>>\n {\n-    debug!(\"assemble_candidates_from_predicates(obligation={}, env_predicates={})\",\n-           obligation.repr(selcx.tcx()),\n-           env_predicates.repr(selcx.tcx()));\n+    debug!(\"assemble_candidates_from_predicates(obligation={})\",\n+           obligation.repr(selcx.tcx()));\n     let infcx = selcx.infcx();\n-    for predicate in elaborate_predicates(selcx.tcx(), env_predicates) {\n+    for predicate in env_predicates {\n+        debug!(\"assemble_candidates_from_predicates: predicate={}\",\n+               predicate.repr(selcx.tcx()));\n         match predicate {\n             ty::Predicate::Projection(ref data) => {\n                 let same_name = data.item_name() == obligation.predicate.item_name;\n@@ -641,6 +644,7 @@ fn assemble_candidates_from_object_type<'cx,'tcx>(\n     let env_predicates = projection_bounds.iter()\n                                           .map(|p| p.as_predicate())\n                                           .collect();\n+    let env_predicates = elaborate_predicates(selcx.tcx(), env_predicates);\n     assemble_candidates_from_predicates(selcx, obligation, obligation_trait_ref,\n                                         candidate_set, env_predicates)\n }"}, {"sha": "211839fbd25f99f242fc1d12f00841e9eb6f0a68", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/713d9176adc5072afdf0934dc95b868995e867c0/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/713d9176adc5072afdf0934dc95b868995e867c0/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=713d9176adc5072afdf0934dc95b868995e867c0", "patch": "@@ -435,6 +435,14 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         debug!(\"evaluate_predicate_recursively({})\",\n                obligation.repr(self.tcx()));\n \n+        // Check the cache from the tcx of predicates that we know\n+        // have been proven elsewhere. This cache only contains\n+        // predicates that are global in scope and hence unaffected by\n+        // the current environment.\n+        if self.tcx().fulfilled_predicates.borrow().is_duplicate(&obligation.predicate) {\n+            return EvaluatedToOk;\n+        }\n+\n         match obligation.predicate {\n             ty::Predicate::Trait(ref t) => {\n                 assert!(!t.has_escaping_regions());\n@@ -1075,14 +1083,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         debug!(\"assemble_candidates_from_caller_bounds({})\",\n                stack.obligation.repr(self.tcx()));\n \n-        let caller_trait_refs: Vec<_> =\n-            self.param_env().caller_bounds.iter()\n-            .filter_map(|o| o.to_opt_poly_trait_ref())\n-            .collect();\n-\n         let all_bounds =\n-            util::transitive_bounds(\n-                self.tcx(), &caller_trait_refs[..]);\n+            self.param_env().caller_bounds\n+                            .iter()\n+                            .filter_map(|o| o.to_opt_poly_trait_ref());\n \n         let matching_bounds =\n             all_bounds.filter("}, {"sha": "6662e3ef4b3b9f7159da49fcc7f8c3d00720f863", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 57, "deletions": 3, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/713d9176adc5072afdf0934dc95b868995e867c0/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/713d9176adc5072afdf0934dc95b868995e867c0/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=713d9176adc5072afdf0934dc95b868995e867c0", "patch": "@@ -753,6 +753,12 @@ pub struct ctxt<'tcx> {\n     /// for things that do not have to do with the parameters in scope.\n     pub selection_cache: traits::SelectionCache<'tcx>,\n \n+    /// A set of predicates that have been fulfilled *somewhere*.\n+    /// This is used to avoid duplicate work. Predicates are only\n+    /// added to this set when they mention only \"global\" names\n+    /// (i.e., no type or lifetime parameters).\n+    pub fulfilled_predicates: RefCell<traits::FulfilledPredicates<'tcx>>,\n+\n     /// Caches the representation hints for struct definitions.\n     pub repr_hint_cache: RefCell<DefIdMap<Rc<Vec<attr::ReprAttr>>>>,\n \n@@ -815,6 +821,11 @@ bitflags! {\n         const HAS_TY_ERR         = 1 << 6,\n         const HAS_PROJECTION     = 1 << 7,\n         const HAS_TY_CLOSURE     = 1 << 8,\n+\n+        // true if there are \"names\" of types and regions and so forth\n+        // that are local to a particular fn\n+        const HAS_LOCAL_NAMES   = 1 << 9,\n+\n         const NEEDS_SUBST        = TypeFlags::HAS_PARAMS.bits |\n                                    TypeFlags::HAS_SELF.bits |\n                                    TypeFlags::HAS_RE_EARLY_BOUND.bits,\n@@ -830,7 +841,8 @@ bitflags! {\n                                   TypeFlags::HAS_FREE_REGIONS.bits |\n                                   TypeFlags::HAS_TY_ERR.bits |\n                                   TypeFlags::HAS_PROJECTION.bits |\n-                                  TypeFlags::HAS_TY_CLOSURE.bits,\n+                                  TypeFlags::HAS_TY_CLOSURE.bits |\n+                                  TypeFlags::HAS_LOCAL_NAMES.bits,\n \n         // Caches for type_is_sized, type_moves_by_default\n         const SIZEDNESS_CACHED  = 1 << 16,\n@@ -986,6 +998,9 @@ pub fn type_has_ty_infer(ty: Ty) -> bool {\n pub fn type_needs_infer(ty: Ty) -> bool {\n     ty.flags.get().intersects(TypeFlags::HAS_TY_INFER | TypeFlags::HAS_RE_INFER)\n }\n+pub fn type_is_global(ty: Ty) -> bool {\n+    !ty.flags.get().intersects(TypeFlags::HAS_LOCAL_NAMES)\n+}\n pub fn type_has_projection(ty: Ty) -> bool {\n     ty.flags.get().intersects(TypeFlags::HAS_PROJECTION)\n }\n@@ -1288,6 +1303,15 @@ pub struct UpvarBorrow {\n pub type UpvarCaptureMap = FnvHashMap<UpvarId, UpvarCapture>;\n \n impl Region {\n+    pub fn is_global(&self) -> bool {\n+        // does this represent a region that can be named in a global\n+        // way? used in fulfillment caching.\n+        match *self {\n+            ty::ReStatic | ty::ReEmpty => true,\n+            _ => false,\n+        }\n+    }\n+\n     pub fn is_bound(&self) -> bool {\n         match *self {\n             ty::ReEarlyBound(..) => true,\n@@ -2022,6 +2046,29 @@ impl<'tcx> Predicate<'tcx> {\n                 Predicate::Projection(ty::Binder(data.subst(tcx, substs))),\n         }\n     }\n+\n+    // Indicates whether this predicate references only 'global'\n+    // types/lifetimes that are the same regardless of what fn we are\n+    // in. This is used for caching. Errs on the side of returning\n+    // false.\n+    pub fn is_global(&self) -> bool {\n+        match *self {\n+            ty::Predicate::Trait(ref data) => {\n+                let substs = data.skip_binder().trait_ref.substs;\n+\n+                substs.types.iter().all(|t| ty::type_is_global(t)) && {\n+                    match substs.regions {\n+                        subst::ErasedRegions => true,\n+                        subst::NonerasedRegions(ref r) => r.iter().all(|r| r.is_global()),\n+                    }\n+                }\n+            }\n+\n+            _ => {\n+                false\n+            }\n+        }\n+    }\n }\n \n #[derive(Clone, PartialEq, Eq, Hash, Debug)]\n@@ -2325,7 +2372,7 @@ pub struct ParameterEnvironment<'a, 'tcx:'a> {\n \n     /// Obligations that the caller must satisfy. This is basically\n     /// the set of bounds on the in-scope type parameters, translated\n-    /// into Obligations.\n+    /// into Obligations, and elaborated and normalized.\n     pub caller_bounds: Vec<ty::Predicate<'tcx>>,\n \n     /// Caches the results of trait selection. This cache is used\n@@ -2798,6 +2845,7 @@ pub fn mk_ctxt<'tcx>(s: Session,\n         trait_defs: RefCell::new(DefIdMap()),\n         predicates: RefCell::new(DefIdMap()),\n         super_predicates: RefCell::new(DefIdMap()),\n+        fulfilled_predicates: RefCell::new(traits::FulfilledPredicates::new()),\n         map: map,\n         freevars: freevars,\n         tcache: RefCell::new(DefIdMap()),\n@@ -3010,6 +3058,7 @@ impl FlagComputation {\n             }\n \n             &TyParam(ref p) => {\n+                self.add_flags(TypeFlags::HAS_LOCAL_NAMES);\n                 if p.space == subst::SelfSpace {\n                     self.add_flags(TypeFlags::HAS_SELF);\n                 } else {\n@@ -3018,11 +3067,12 @@ impl FlagComputation {\n             }\n \n             &TyClosure(_, substs) => {\n-                self.add_flags(TypeFlags::HAS_TY_CLOSURE);\n+                self.add_flags(TypeFlags::HAS_LOCAL_NAMES);\n                 self.add_substs(substs);\n             }\n \n             &TyInfer(_) => {\n+                self.add_flags(TypeFlags::HAS_LOCAL_NAMES); // it might, right?\n                 self.add_flags(TypeFlags::HAS_TY_INFER)\n             }\n \n@@ -3102,6 +3152,10 @@ impl FlagComputation {\n             ty::ReStatic => {}\n             _ => { self.add_flags(TypeFlags::HAS_FREE_REGIONS); }\n         }\n+\n+        if !r.is_global() {\n+            self.add_flags(TypeFlags::HAS_LOCAL_NAMES);\n+        }\n     }\n \n     fn add_projection_predicate(&mut self, projection_predicate: &ProjectionPredicate) {"}, {"sha": "1cabeb268562daf2770f736090feacd1747e42af", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/713d9176adc5072afdf0934dc95b868995e867c0/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/713d9176adc5072afdf0934dc95b868995e867c0/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=713d9176adc5072afdf0934dc95b868995e867c0", "patch": "@@ -1041,7 +1041,7 @@ pub fn fulfill_obligation<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     // Currently, we use a fulfillment context to completely resolve\n     // all nested obligations. This is because they can inform the\n     // inference of the impl's type parameters.\n-    let mut fulfill_cx = traits::FulfillmentContext::new();\n+    let mut fulfill_cx = traits::FulfillmentContext::new(true);\n     let vtable = selection.map(|predicate| {\n         fulfill_cx.register_predicate_obligation(&infcx, predicate);\n     });\n@@ -1069,7 +1069,7 @@ pub fn normalize_and_test_predicates<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     let infcx = infer::new_infer_ctxt(tcx);\n     let typer = NormalizingClosureTyper::new(tcx);\n     let mut selcx = traits::SelectionContext::new(&infcx, &typer);\n-    let mut fulfill_cx = traits::FulfillmentContext::new();\n+    let mut fulfill_cx = traits::FulfillmentContext::new(false);\n     let cause = traits::ObligationCause::dummy();\n     let traits::Normalized { value: predicates, obligations } =\n         traits::normalize(&mut selcx, cause.clone(), &predicates);"}, {"sha": "e28dd77d5e58e008ddf2c52dd8ccafe8667e0789", "filename": "src/librustc_trans/trans/monomorphize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/713d9176adc5072afdf0934dc95b868995e867c0/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/713d9176adc5072afdf0934dc95b868995e867c0/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs?ref=713d9176adc5072afdf0934dc95b868995e867c0", "patch": "@@ -337,7 +337,7 @@ pub fn normalize_associated_type<'tcx,T>(tcx: &ty::ctxt<'tcx>, value: &T) -> T\n            result.repr(tcx),\n            obligations.repr(tcx));\n \n-    let mut fulfill_cx = traits::FulfillmentContext::new();\n+    let mut fulfill_cx = traits::FulfillmentContext::new(true);\n     for obligation in obligations {\n         fulfill_cx.register_predicate_obligation(&infcx, obligation);\n     }"}, {"sha": "c5861be2716b2e5c2313b8d3ed5f64c50f705fae", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/713d9176adc5072afdf0934dc95b868995e867c0/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/713d9176adc5072afdf0934dc95b868995e867c0/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=713d9176adc5072afdf0934dc95b868995e867c0", "patch": "@@ -45,7 +45,7 @@ pub fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n            impl_trait_ref.repr(tcx));\n \n     let infcx = infer::new_infer_ctxt(tcx);\n-    let mut fulfillment_cx = traits::FulfillmentContext::new();\n+    let mut fulfillment_cx = traits::FulfillmentContext::new(true);\n \n     let trait_to_impl_substs = &impl_trait_ref.substs;\n \n@@ -422,7 +422,7 @@ pub fn compare_const_impl<'tcx>(tcx: &ty::ctxt<'tcx>,\n            impl_trait_ref.repr(tcx));\n \n     let infcx = infer::new_infer_ctxt(tcx);\n-    let mut fulfillment_cx = traits::FulfillmentContext::new();\n+    let mut fulfillment_cx = traits::FulfillmentContext::new(true);\n \n     // The below is for the most part highly similar to the procedure\n     // for methods above. It is simpler in many respects, especially"}, {"sha": "9df0d4aa56b8a99fec5eda6e081dfe9e7f0da49f", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/713d9176adc5072afdf0934dc95b868995e867c0/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/713d9176adc5072afdf0934dc95b868995e867c0/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=713d9176adc5072afdf0934dc95b868995e867c0", "patch": "@@ -386,7 +386,7 @@ impl<'a, 'tcx> Inherited<'a, 'tcx> {\n             closure_tys: RefCell::new(DefIdMap()),\n             closure_kinds: RefCell::new(DefIdMap()),\n             fn_sig_map: RefCell::new(NodeMap()),\n-            fulfillment_cx: RefCell::new(traits::FulfillmentContext::new()),\n+            fulfillment_cx: RefCell::new(traits::FulfillmentContext::new(true)),\n             deferred_call_resolutions: RefCell::new(DefIdMap()),\n             deferred_cast_checks: RefCell::new(Vec::new()),\n         }"}, {"sha": "cd7be46f9e01210ede09af8d4dddc9285bf73927", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/713d9176adc5072afdf0934dc95b868995e867c0/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/713d9176adc5072afdf0934dc95b868995e867c0/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=713d9176adc5072afdf0934dc95b868995e867c0", "patch": "@@ -539,7 +539,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n                 }\n             };\n \n-            let mut fulfill_cx = traits::FulfillmentContext::new();\n+            let mut fulfill_cx = traits::FulfillmentContext::new(true);\n \n             // Register an obligation for `A: Trait<B>`.\n             let cause = traits::ObligationCause::misc(span, impl_did.node);"}, {"sha": "e603cca7f384b838f6ff6313de42723bdf088025", "filename": "src/test/compile-fail/associated-types-path-2.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/713d9176adc5072afdf0934dc95b868995e867c0/src%2Ftest%2Fcompile-fail%2Fassociated-types-path-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/713d9176adc5072afdf0934dc95b868995e867c0/src%2Ftest%2Fcompile-fail%2Fassociated-types-path-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types-path-2.rs?ref=713d9176adc5072afdf0934dc95b868995e867c0", "patch": "@@ -45,7 +45,6 @@ pub fn f1_uint_uint() {\n pub fn f1_uint_int() {\n     f1(2u32, 4i32);\n     //~^ ERROR the trait `Foo` is not implemented\n-    //~| ERROR the trait `Foo` is not implemented\n }\n \n pub fn f2_int() {"}, {"sha": "0aefd0ae28845f1474dc87000d06af4886e1e2e5", "filename": "src/test/compile-fail/cross-fn-cache-hole.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/713d9176adc5072afdf0934dc95b868995e867c0/src%2Ftest%2Fcompile-fail%2Fcross-fn-cache-hole.rs", "raw_url": "https://github.com/rust-lang/rust/raw/713d9176adc5072afdf0934dc95b868995e867c0/src%2Ftest%2Fcompile-fail%2Fcross-fn-cache-hole.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcross-fn-cache-hole.rs?ref=713d9176adc5072afdf0934dc95b868995e867c0", "patch": "@@ -0,0 +1,41 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Check that when there are vacuous predicates in the environment\n+// (which make a fn uncallable) we don't erroneously cache those and\n+// then consider them satisfied elsewhere. The current technique for\n+// doing this is just to filter \"global\" predicates out of the\n+// environment, which means that we wind up with an error in the\n+// function `vacuous`, because even though `i32: Bar<u32>` is implied\n+// by its where clause, that where clause never holds.\n+\n+trait Foo<X,Y>: Bar<X> {\n+}\n+\n+trait Bar<X> { }\n+\n+fn vacuous<A>()\n+    where i32: Foo<u32, A>\n+{\n+    // vacuous could never be called, because it requires that i32:\n+    // Bar<u32>. But the code doesn't check that this could never be\n+    // satisfied.\n+    require::<i32, u32>();\n+    //~^ ERROR the trait `Bar<u32>` is not implemented for the type `i32`\n+}\n+\n+fn require<A,B>()\n+    where A: Bar<B>\n+{\n+}\n+\n+fn main() {\n+    require::<i32, u32>();\n+}"}, {"sha": "da667dcb1e88253feba1aa1682adfbd2f201ef6b", "filename": "src/test/compile-fail/dst-object-from-unsized-type.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/713d9176adc5072afdf0934dc95b868995e867c0/src%2Ftest%2Fcompile-fail%2Fdst-object-from-unsized-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/713d9176adc5072afdf0934dc95b868995e867c0/src%2Ftest%2Fcompile-fail%2Fdst-object-from-unsized-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdst-object-from-unsized-type.rs?ref=713d9176adc5072afdf0934dc95b868995e867c0", "patch": "@@ -12,6 +12,7 @@\n \n trait Foo { fn foo(&self) {} }\n impl Foo for str {}\n+impl Foo for [u8] {}\n \n fn test1<T: ?Sized + Foo>(t: &T) {\n     let u: &Foo = t;\n@@ -28,9 +29,9 @@ fn test3() {\n     //~^ ERROR `core::marker::Sized` is not implemented for the type `str`\n }\n \n-fn test4() {\n-    let _: &Foo = \"hi\" as &Foo;\n-    //~^ ERROR `core::marker::Sized` is not implemented for the type `str`\n+fn test4(x: &[u8]) {\n+    let _: &Foo = x as &Foo;\n+    //~^ ERROR `core::marker::Sized` is not implemented for the type `[u8]`\n }\n \n fn main() { }"}, {"sha": "3474a73b31fdcab834dc557911b1eab3eb09f15a", "filename": "src/test/compile-fail/kindck-impl-type-params.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/713d9176adc5072afdf0934dc95b868995e867c0/src%2Ftest%2Fcompile-fail%2Fkindck-impl-type-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/713d9176adc5072afdf0934dc95b868995e867c0/src%2Ftest%2Fcompile-fail%2Fkindck-impl-type-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-impl-type-params.rs?ref=713d9176adc5072afdf0934dc95b868995e867c0", "patch": "@@ -50,8 +50,10 @@ fn foo2<'a>() {\n }\n \n fn foo3<'a>() {\n-    let t: Box<S<String>> = box S(marker::PhantomData);\n-    let a: Box<Gettable<String>> = t;\n+    struct Foo; // does not impl Copy\n+\n+    let t: Box<S<Foo>> = box S(marker::PhantomData);\n+    let a: Box<Gettable<Foo>> = t;\n     //~^ ERROR the trait `core::marker::Copy` is not implemented\n }\n "}, {"sha": "988961e7fa14a7d522c4f3c13fa4cce01e00f3fb", "filename": "src/test/compile-fail/trait-bounds-on-structs-and-enums.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/713d9176adc5072afdf0934dc95b868995e867c0/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-on-structs-and-enums.rs", "raw_url": "https://github.com/rust-lang/rust/raw/713d9176adc5072afdf0934dc95b868995e867c0/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-on-structs-and-enums.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-on-structs-and-enums.rs?ref=713d9176adc5072afdf0934dc95b868995e867c0", "patch": "@@ -52,7 +52,7 @@ struct TupleLike(\n );\n \n enum Enum {\n-    DictionaryLike { field: Bar<i32> }, //~ ERROR not implemented\n+    DictionaryLike { field: Bar<u8> }, //~ ERROR not implemented\n }\n \n trait PolyTrait<T>\n@@ -62,7 +62,7 @@ trait PolyTrait<T>\n \n struct Struct;\n \n-impl PolyTrait<Foo<usize>> for Struct {\n+impl PolyTrait<Foo<u16>> for Struct {\n //~^ ERROR not implemented\n }\n "}, {"sha": "8dc977a8e490bf3aa213e447e39046e2e2e681c5", "filename": "src/test/compile-fail/traits-negative-impls.rs", "status": "modified", "additions": 18, "deletions": 9, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/713d9176adc5072afdf0934dc95b868995e867c0/src%2Ftest%2Fcompile-fail%2Ftraits-negative-impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/713d9176adc5072afdf0934dc95b868995e867c0/src%2Ftest%2Fcompile-fail%2Ftraits-negative-impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftraits-negative-impls.rs?ref=713d9176adc5072afdf0934dc95b868995e867c0", "patch": "@@ -19,9 +19,6 @@ use std::marker::Send;\n \n struct Outer<T: Send>(T);\n \n-struct TestType;\n-impl !Send for TestType {}\n-\n struct Outer2<T>(T);\n \n unsafe impl<T: Send> Sync for Outer2<T> {}\n@@ -30,29 +27,41 @@ fn is_send<T: Send>(_: T) {}\n fn is_sync<T: Sync>(_: T) {}\n \n fn dummy() {\n+    struct TestType;\n+    impl !Send for TestType {}\n+\n     Outer(TestType);\n-    //~^ ERROR the trait `core::marker::Send` is not implemented for the type `TestType`\n+    //~^ ERROR the trait `core::marker::Send` is not implemented for the type `dummy::TestType`\n \n     is_send(TestType);\n-    //~^ ERROR the trait `core::marker::Send` is not implemented for the type `TestType`\n+    //~^ ERROR the trait `core::marker::Send` is not implemented for the type `dummy::TestType`\n \n     is_send((8, TestType));\n-    //~^ ERROR the trait `core::marker::Send` is not implemented for the type `TestType`\n+    //~^ ERROR the trait `core::marker::Send` is not implemented for the type `dummy::TestType`\n }\n \n fn dummy2() {\n+    struct TestType;\n+    impl !Send for TestType {}\n+\n     is_send(Box::new(TestType));\n-    //~^ ERROR the trait `core::marker::Send` is not implemented for the type `TestType`\n+    //~^ ERROR the trait `core::marker::Send` is not implemented for the type `dummy2::TestType`\n }\n \n fn dummy3() {\n+    struct TestType;\n+    impl !Send for TestType {}\n+\n     is_send(Box::new(Outer2(TestType)));\n-    //~^ ERROR the trait `core::marker::Send` is not implemented for the type `TestType`\n+    //~^ ERROR the trait `core::marker::Send` is not implemented for the type `dummy3::TestType`\n }\n \n fn main() {\n+    struct TestType;\n+    impl !Send for TestType {}\n+\n     // This will complain about a missing Send impl because `Sync` is implement *just*\n     // for T that are `Send`. Look at #20366 and #19950\n     is_sync(Outer2(TestType));\n-    //~^ ERROR the trait `core::marker::Send` is not implemented for the type `TestType`\n+    //~^ ERROR the trait `core::marker::Send` is not implemented for the type `main::TestType`\n }"}, {"sha": "8057ca56621c12930278034aee6bc98b119f3821", "filename": "src/test/compile-fail/typeck-default-trait-impl-trait-where-clause.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/713d9176adc5072afdf0934dc95b868995e867c0/src%2Ftest%2Fcompile-fail%2Ftypeck-default-trait-impl-trait-where-clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/713d9176adc5072afdf0934dc95b868995e867c0/src%2Ftest%2Fcompile-fail%2Ftypeck-default-trait-impl-trait-where-clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftypeck-default-trait-impl-trait-where-clause.rs?ref=713d9176adc5072afdf0934dc95b868995e867c0", "patch": "@@ -40,6 +40,6 @@ fn test() {\n }\n \n fn main() {\n-    foo::<i32>();\n-    //~^ ERROR the trait `NotImplemented` is not implemented for the type `core::option::Option<i32>`\n+    foo::<u32>();\n+    //~^ ERROR the trait `NotImplemented` is not implemented for the type `core::option::Option<u32>`\n }"}, {"sha": "afa574bf85a8d950f5c2d77f61b336c270e304a7", "filename": "src/test/compile-fail/unsized5.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/713d9176adc5072afdf0934dc95b868995e867c0/src%2Ftest%2Fcompile-fail%2Funsized5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/713d9176adc5072afdf0934dc95b868995e867c0/src%2Ftest%2Fcompile-fail%2Funsized5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsized5.rs?ref=713d9176adc5072afdf0934dc95b868995e867c0", "patch": "@@ -24,7 +24,7 @@ struct S3 {\n     g: [usize]\n }\n struct S4 {\n-    f: str, //~ ERROR `core::marker::Sized` is not implemented\n+    f: [u8], //~ ERROR `core::marker::Sized` is not implemented\n     g: usize\n }\n enum E<X: ?Sized> {"}]}