{"sha": "b8c8f0bdf62728198696cab7d00a8fdc3ee381d3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI4YzhmMGJkZjYyNzI4MTk4Njk2Y2FiN2QwMGE4ZmRjM2VlMzgxZDM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-01-08T14:11:19Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-01-08T14:11:19Z"}, "message": "Auto merge of #57114 - Zoxc:query-perf11, r=michaelwoerister\n\nClean up and optimize OpenTask / read_index\n\nr? @michaelwoerister", "tree": {"sha": "4b8b539f0999a9d5c7cb9aaadd100b983072d84c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4b8b539f0999a9d5c7cb9aaadd100b983072d84c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b8c8f0bdf62728198696cab7d00a8fdc3ee381d3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b8c8f0bdf62728198696cab7d00a8fdc3ee381d3", "html_url": "https://github.com/rust-lang/rust/commit/b8c8f0bdf62728198696cab7d00a8fdc3ee381d3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b8c8f0bdf62728198696cab7d00a8fdc3ee381d3/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2f19f8cec96d96d83b393fbbdd61204b87d423e6", "url": "https://api.github.com/repos/rust-lang/rust/commits/2f19f8cec96d96d83b393fbbdd61204b87d423e6", "html_url": "https://github.com/rust-lang/rust/commit/2f19f8cec96d96d83b393fbbdd61204b87d423e6"}, {"sha": "584a52096e207f7884d57da3d1357ce7f056f1da", "url": "https://api.github.com/repos/rust-lang/rust/commits/584a52096e207f7884d57da3d1357ce7f056f1da", "html_url": "https://github.com/rust-lang/rust/commit/584a52096e207f7884d57da3d1357ce7f056f1da"}], "stats": {"total": 303, "additions": 131, "deletions": 172}, "files": [{"sha": "71cacfe370658ae7124162eacf97fef6091faf11", "filename": "src/librustc/dep_graph/graph.rs", "status": "modified", "additions": 119, "deletions": 161, "changes": 280, "blob_url": "https://github.com/rust-lang/rust/blob/b8c8f0bdf62728198696cab7d00a8fdc3ee381d3/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8c8f0bdf62728198696cab7d00a8fdc3ee381d3/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fgraph.rs?ref=b8c8f0bdf62728198696cab7d00a8fdc3ee381d3", "patch": "@@ -122,12 +122,7 @@ impl DepGraph {\n         if let Some(..) = self.data {\n             ty::tls::with_context_opt(|icx| {\n                 let icx = if let Some(icx) = icx { icx } else { return };\n-                match *icx.task {\n-                    OpenTask::Ignore => {\n-                        // ignored\n-                    }\n-                    _ => panic!(\"expected an ignore context\")\n-                }\n+                assert!(icx.task_deps.is_none(), \"expected no task dependency tracking\");\n             })\n         }\n     }\n@@ -137,7 +132,7 @@ impl DepGraph {\n     {\n         ty::tls::with_context(|icx| {\n             let icx = ty::tls::ImplicitCtxt {\n-                task: &OpenTask::Ignore,\n+                task_deps: None,\n                 ..icx.clone()\n             };\n \n@@ -184,12 +179,15 @@ impl DepGraph {\n               R: HashStable<StableHashingContext<'gcx>>,\n     {\n         self.with_task_impl(key, cx, arg, false, task,\n-            |key| OpenTask::Regular(Lock::new(RegularOpenTask {\n-                node: key,\n+            |_key| Some(TaskDeps {\n+                #[cfg(debug_assertions)]\n+                node: Some(_key),\n                 reads: SmallVec::new(),\n                 read_set: Default::default(),\n-            })),\n-            |data, key, fingerprint, task| data.borrow_mut().complete_task(key, task, fingerprint))\n+            }),\n+            |data, key, fingerprint, task| {\n+                data.borrow_mut().complete_task(key, task.unwrap(), fingerprint)\n+            })\n     }\n \n     /// Creates a new dep-graph input with value `input`\n@@ -206,7 +204,7 @@ impl DepGraph {\n         }\n \n         self.with_task_impl(key, cx, input, true, identity_fn,\n-            |_| OpenTask::Ignore,\n+            |_| None,\n             |data, key, fingerprint, _| {\n                 data.borrow_mut().alloc_node(key, SmallVec::new(), fingerprint)\n             })\n@@ -219,18 +217,18 @@ impl DepGraph {\n         arg: A,\n         no_tcx: bool,\n         task: fn(C, A) -> R,\n-        create_task: fn(DepNode) -> OpenTask,\n+        create_task: fn(DepNode) -> Option<TaskDeps>,\n         finish_task_and_alloc_depnode: fn(&Lock<CurrentDepGraph>,\n                                           DepNode,\n                                           Fingerprint,\n-                                          OpenTask) -> DepNodeIndex\n+                                          Option<TaskDeps>) -> DepNodeIndex\n     ) -> (R, DepNodeIndex)\n     where\n         C: DepGraphSafe + StableHashingContextProvider<'gcx>,\n         R: HashStable<StableHashingContext<'gcx>>,\n     {\n         if let Some(ref data) = self.data {\n-            let open_task = create_task(key);\n+            let task_deps = create_task(key).map(|deps| Lock::new(deps));\n \n             // In incremental mode, hash the result of the task. We don't\n             // do anything with the hash yet, but we are computing it\n@@ -248,7 +246,7 @@ impl DepGraph {\n             } else {\n                 ty::tls::with_context(|icx| {\n                     let icx = ty::tls::ImplicitCtxt {\n-                        task: &open_task,\n+                        task_deps: task_deps.as_ref(),\n                         ..icx.clone()\n                     };\n \n@@ -271,7 +269,7 @@ impl DepGraph {\n                 &data.current,\n                 key,\n                 current_fingerprint,\n-                open_task\n+                task_deps.map(|lock| lock.into_inner()),\n             );\n \n             // Determine the color of the new DepNode.\n@@ -304,15 +302,17 @@ impl DepGraph {\n         where OP: FnOnce() -> R\n     {\n         if let Some(ref data) = self.data {\n-            let (result, open_task) = ty::tls::with_context(|icx| {\n-                let task = OpenTask::Anon(Lock::new(AnonOpenTask {\n+            let (result, task_deps) = ty::tls::with_context(|icx| {\n+                let task_deps = Lock::new(TaskDeps {\n+                    #[cfg(debug_assertions)]\n+                    node: None,\n                     reads: SmallVec::new(),\n                     read_set: Default::default(),\n-                }));\n+                });\n \n                 let r = {\n                     let icx = ty::tls::ImplicitCtxt {\n-                        task: &task,\n+                        task_deps: Some(&task_deps),\n                         ..icx.clone()\n                     };\n \n@@ -321,11 +321,11 @@ impl DepGraph {\n                     })\n                 };\n \n-                (r, task)\n+                (r, task_deps.into_inner())\n             });\n             let dep_node_index = data.current\n                                      .borrow_mut()\n-                                     .pop_anon_task(dep_kind, open_task);\n+                                     .complete_anon_task(dep_kind, task_deps);\n             (result, dep_node_index)\n         } else {\n             (op(), DepNodeIndex::INVALID)\n@@ -344,18 +344,23 @@ impl DepGraph {\n               R: HashStable<StableHashingContext<'gcx>>,\n     {\n         self.with_task_impl(key, cx, arg, false, task,\n-            |key| OpenTask::EvalAlways { node: key },\n-            |data, key, fingerprint, task| {\n-                data.borrow_mut().complete_eval_always_task(key, task, fingerprint)\n+            |_| None,\n+            |data, key, fingerprint, _| {\n+                let mut current = data.borrow_mut();\n+                let krate_idx = current.node_to_node_index[\n+                    &DepNode::new_no_params(DepKind::Krate)\n+                ];\n+                current.alloc_node(key, smallvec![krate_idx], fingerprint)\n             })\n     }\n \n     #[inline]\n     pub fn read(&self, v: DepNode) {\n         if let Some(ref data) = self.data {\n-            let mut current = data.current.borrow_mut();\n+            let current = data.current.borrow_mut();\n             if let Some(&dep_node_index) = current.node_to_node_index.get(&v) {\n-                current.read_index(dep_node_index);\n+                std::mem::drop(current);\n+                data.read_index(dep_node_index);\n             } else {\n                 bug!(\"DepKind {:?} should be pre-allocated but isn't.\", v.kind)\n             }\n@@ -365,7 +370,7 @@ impl DepGraph {\n     #[inline]\n     pub fn read_index(&self, dep_node_index: DepNodeIndex) {\n         if let Some(ref data) = self.data {\n-            data.current.borrow_mut().read_index(dep_node_index);\n+            data.read_index(dep_node_index);\n         }\n     }\n \n@@ -446,10 +451,15 @@ impl DepGraph {\n             .cloned()\n     }\n \n-    pub fn edge_deduplication_data(&self) -> (u64, u64) {\n-        let current_dep_graph = self.data.as_ref().unwrap().current.borrow();\n+    pub fn edge_deduplication_data(&self) -> Option<(u64, u64)> {\n+        if cfg!(debug_assertions) {\n+            let current_dep_graph = self.data.as_ref().unwrap().current.borrow();\n \n-        (current_dep_graph.total_read_count, current_dep_graph.total_duplicate_read_count)\n+            Some((current_dep_graph.total_read_count,\n+                  current_dep_graph.total_duplicate_read_count))\n+        } else {\n+            None\n+        }\n     }\n \n     pub fn serialize(&self) -> SerializedDepGraph {\n@@ -827,6 +837,7 @@ struct DepNodeData {\n pub(super) struct CurrentDepGraph {\n     data: IndexVec<DepNodeIndex, DepNodeData>,\n     node_to_node_index: FxHashMap<DepNode, DepNodeIndex>,\n+    #[allow(dead_code)]\n     forbidden_edge: Option<EdgeFilter>,\n \n     // Anonymous DepNodes are nodes the ID of which we compute from the list of\n@@ -890,134 +901,60 @@ impl CurrentDepGraph {\n \n     fn complete_task(\n         &mut self,\n-        key: DepNode,\n-        task: OpenTask,\n+        node: DepNode,\n+        task_deps: TaskDeps,\n         fingerprint: Fingerprint\n     ) -> DepNodeIndex {\n-        if let OpenTask::Regular(task) = task {\n-            let RegularOpenTask {\n-                node,\n-                read_set: _,\n-                reads\n-            } = task.into_inner();\n-            assert_eq!(node, key);\n-\n-            // If this is an input node, we expect that it either has no\n-            // dependencies, or that it just depends on DepKind::CrateMetadata\n-            // or DepKind::Krate. This happens for some \"thin wrapper queries\"\n-            // like `crate_disambiguator` which sometimes have zero deps (for\n-            // when called for LOCAL_CRATE) or they depend on a CrateMetadata\n-            // node.\n-            if cfg!(debug_assertions) {\n-                if node.kind.is_input() && reads.len() > 0 &&\n-                   // FIXME(mw): Special case for DefSpan until Spans are handled\n-                   //            better in general.\n-                   node.kind != DepKind::DefSpan &&\n-                    reads.iter().any(|&i| {\n-                        !(self.data[i].node.kind == DepKind::CrateMetadata ||\n-                          self.data[i].node.kind == DepKind::Krate)\n-                    })\n-                {\n-                    bug!(\"Input node {:?} with unexpected reads: {:?}\",\n-                        node,\n-                        reads.iter().map(|&i| self.data[i].node).collect::<Vec<_>>())\n-                }\n+        // If this is an input node, we expect that it either has no\n+        // dependencies, or that it just depends on DepKind::CrateMetadata\n+        // or DepKind::Krate. This happens for some \"thin wrapper queries\"\n+        // like `crate_disambiguator` which sometimes have zero deps (for\n+        // when called for LOCAL_CRATE) or they depend on a CrateMetadata\n+        // node.\n+        if cfg!(debug_assertions) {\n+            if node.kind.is_input() && task_deps.reads.len() > 0 &&\n+                // FIXME(mw): Special case for DefSpan until Spans are handled\n+                //            better in general.\n+                node.kind != DepKind::DefSpan &&\n+                task_deps.reads.iter().any(|&i| {\n+                    !(self.data[i].node.kind == DepKind::CrateMetadata ||\n+                        self.data[i].node.kind == DepKind::Krate)\n+                })\n+            {\n+                bug!(\"Input node {:?} with unexpected reads: {:?}\",\n+                    node,\n+                    task_deps.reads.iter().map(|&i| self.data[i].node).collect::<Vec<_>>())\n             }\n-\n-            self.alloc_node(node, reads, fingerprint)\n-        } else {\n-            bug!(\"complete_task() - Expected regular task to be popped\")\n         }\n-    }\n-\n-    fn pop_anon_task(&mut self, kind: DepKind, task: OpenTask) -> DepNodeIndex {\n-        if let OpenTask::Anon(task) = task {\n-            let AnonOpenTask {\n-                read_set: _,\n-                reads\n-            } = task.into_inner();\n-            debug_assert!(!kind.is_input());\n-\n-            let mut fingerprint = self.anon_id_seed;\n-            let mut hasher = StableHasher::new();\n \n-            for &read in reads.iter() {\n-                let read_dep_node = self.data[read].node;\n+        self.alloc_node(node, task_deps.reads, fingerprint)\n+    }\n \n-                ::std::mem::discriminant(&read_dep_node.kind).hash(&mut hasher);\n+    fn complete_anon_task(&mut self, kind: DepKind, task_deps: TaskDeps) -> DepNodeIndex {\n+        debug_assert!(!kind.is_input());\n \n-                // Fingerprint::combine() is faster than sending Fingerprint\n-                // through the StableHasher (at least as long as StableHasher\n-                // is so slow).\n-                fingerprint = fingerprint.combine(read_dep_node.hash);\n-            }\n+        let mut fingerprint = self.anon_id_seed;\n+        let mut hasher = StableHasher::new();\n \n-            fingerprint = fingerprint.combine(hasher.finish());\n+        for &read in task_deps.reads.iter() {\n+            let read_dep_node = self.data[read].node;\n \n-            let target_dep_node = DepNode {\n-                kind,\n-                hash: fingerprint,\n-            };\n+            ::std::mem::discriminant(&read_dep_node.kind).hash(&mut hasher);\n \n-            self.intern_node(target_dep_node, reads, Fingerprint::ZERO).0\n-        } else {\n-            bug!(\"pop_anon_task() - Expected anonymous task to be popped\")\n+            // Fingerprint::combine() is faster than sending Fingerprint\n+            // through the StableHasher (at least as long as StableHasher\n+            // is so slow).\n+            fingerprint = fingerprint.combine(read_dep_node.hash);\n         }\n-    }\n \n-    fn complete_eval_always_task(\n-        &mut self,\n-        key: DepNode,\n-        task: OpenTask,\n-        fingerprint: Fingerprint\n-    ) -> DepNodeIndex {\n-        if let OpenTask::EvalAlways {\n-            node,\n-        } = task {\n-            debug_assert_eq!(node, key);\n-            let krate_idx = self.node_to_node_index[&DepNode::new_no_params(DepKind::Krate)];\n-            self.alloc_node(node, smallvec![krate_idx], fingerprint)\n-        } else {\n-            bug!(\"complete_eval_always_task() - Expected eval always task to be popped\");\n-        }\n-    }\n+        fingerprint = fingerprint.combine(hasher.finish());\n \n-    fn read_index(&mut self, source: DepNodeIndex) {\n-        ty::tls::with_context_opt(|icx| {\n-            let icx = if let Some(icx) = icx { icx } else { return };\n-            match *icx.task {\n-                OpenTask::Regular(ref task) => {\n-                    let mut task = task.lock();\n-                    self.total_read_count += 1;\n-                    if task.read_set.insert(source) {\n-                        task.reads.push(source);\n-\n-                        if cfg!(debug_assertions) {\n-                            if let Some(ref forbidden_edge) = self.forbidden_edge {\n-                                let target = &task.node;\n-                                let source = self.data[source].node;\n-                                if forbidden_edge.test(&source, &target) {\n-                                    bug!(\"forbidden edge {:?} -> {:?} created\",\n-                                        source,\n-                                        target)\n-                                }\n-                            }\n-                        }\n-                    } else {\n-                        self.total_duplicate_read_count += 1;\n-                    }\n-                }\n-                OpenTask::Anon(ref task) => {\n-                    let mut task = task.lock();\n-                    if task.read_set.insert(source) {\n-                        task.reads.push(source);\n-                    }\n-                }\n-                OpenTask::Ignore | OpenTask::EvalAlways { .. } => {\n-                    // ignore\n-                }\n-            }\n-        })\n+        let target_dep_node = DepNode {\n+            kind,\n+            hash: fingerprint,\n+        };\n+\n+        self.intern_node(target_dep_node, task_deps.reads, Fingerprint::ZERO).0\n     }\n \n     fn alloc_node(\n@@ -1054,26 +991,47 @@ impl CurrentDepGraph {\n     }\n }\n \n-pub struct RegularOpenTask {\n-    node: DepNode,\n-    reads: SmallVec<[DepNodeIndex; 8]>,\n-    read_set: FxHashSet<DepNodeIndex>,\n+impl DepGraphData {\n+    fn read_index(&self, source: DepNodeIndex) {\n+        ty::tls::with_context_opt(|icx| {\n+            let icx = if let Some(icx) = icx { icx } else {  return };\n+            if let Some(task_deps) = icx.task_deps {\n+                let mut task_deps = task_deps.lock();\n+                if cfg!(debug_assertions) {\n+                    self.current.lock().total_read_count += 1;\n+                }\n+                if task_deps.read_set.insert(source) {\n+                    task_deps.reads.push(source);\n+\n+                    #[cfg(debug_assertions)]\n+                    {\n+                        if let Some(target) = task_deps.node {\n+                            let graph = self.current.lock();\n+                            if let Some(ref forbidden_edge) = graph.forbidden_edge {\n+                                let source = graph.data[source].node;\n+                                if forbidden_edge.test(&source, &target) {\n+                                    bug!(\"forbidden edge {:?} -> {:?} created\",\n+                                        source,\n+                                        target)\n+                                }\n+                            }\n+                        }\n+                    }\n+                } else if cfg!(debug_assertions) {\n+                    self.current.lock().total_duplicate_read_count += 1;\n+                }\n+            }\n+        })\n+    }\n }\n \n-pub struct AnonOpenTask {\n+pub struct TaskDeps {\n+    #[cfg(debug_assertions)]\n+    node: Option<DepNode>,\n     reads: SmallVec<[DepNodeIndex; 8]>,\n     read_set: FxHashSet<DepNodeIndex>,\n }\n \n-pub enum OpenTask {\n-    Regular(Lock<RegularOpenTask>),\n-    Anon(Lock<AnonOpenTask>),\n-    Ignore,\n-    EvalAlways {\n-        node: DepNode,\n-    },\n-}\n-\n // A data structure that stores Option<DepNodeColor> values as a contiguous\n // array, using one u32 per entry.\n struct DepNodeColorMap {"}, {"sha": "022caabcbf3a1eb9ba4fcb3fb980f0529afe5949", "filename": "src/librustc/dep_graph/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8c8f0bdf62728198696cab7d00a8fdc3ee381d3/src%2Flibrustc%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8c8f0bdf62728198696cab7d00a8fdc3ee381d3/src%2Flibrustc%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fmod.rs?ref=b8c8f0bdf62728198696cab7d00a8fdc3ee381d3", "patch": "@@ -10,7 +10,7 @@ pub mod cgu_reuse_tracker;\n \n pub use self::dep_tracking_map::{DepTrackingMap, DepTrackingMapConfig};\n pub use self::dep_node::{DepNode, DepKind, DepConstructor, WorkProductId, label_strs};\n-pub use self::graph::{DepGraph, WorkProduct, DepNodeIndex, DepNodeColor, OpenTask};\n+pub use self::graph::{DepGraph, WorkProduct, DepNodeIndex, DepNodeColor, TaskDeps};\n pub use self::graph::WorkProductFileKind;\n pub use self::prev::PreviousDepGraph;\n pub use self::query::DepGraphQuery;"}, {"sha": "c0ba4329ae05c24d03b05696b3c8fac0ccf81256", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b8c8f0bdf62728198696cab7d00a8fdc3ee381d3/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8c8f0bdf62728198696cab7d00a8fdc3ee381d3/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=b8c8f0bdf62728198696cab7d00a8fdc3ee381d3", "patch": "@@ -1674,7 +1674,7 @@ impl<'gcx> GlobalCtxt<'gcx> {\n                 tcx,\n                 query: icx.query.clone(),\n                 layout_depth: icx.layout_depth,\n-                task: icx.task,\n+                task_deps: icx.task_deps,\n             };\n             ty::tls::enter_context(&new_icx, |_| {\n                 f(tcx)\n@@ -1782,7 +1782,7 @@ pub mod tls {\n     use errors::{Diagnostic, TRACK_DIAGNOSTICS};\n     use rustc_data_structures::OnDrop;\n     use rustc_data_structures::sync::{self, Lrc, Lock};\n-    use dep_graph::OpenTask;\n+    use dep_graph::TaskDeps;\n \n     #[cfg(not(parallel_queries))]\n     use std::cell::Cell;\n@@ -1810,7 +1810,7 @@ pub mod tls {\n \n         /// The current dep graph task. This is used to add dependencies to queries\n         /// when executing them\n-        pub task: &'a OpenTask,\n+        pub task_deps: Option<&'a Lock<TaskDeps>>,\n     }\n \n     /// Sets Rayon's thread local variable which is preserved for Rayon jobs\n@@ -1939,7 +1939,7 @@ pub mod tls {\n                 tcx,\n                 query: None,\n                 layout_depth: 0,\n-                task: &OpenTask::Ignore,\n+                task_deps: None,\n             };\n             enter_context(&icx, |_| {\n                 f(tcx)\n@@ -1969,7 +1969,7 @@ pub mod tls {\n             query: None,\n             tcx,\n             layout_depth: 0,\n-            task: &OpenTask::Ignore,\n+            task_deps: None,\n         };\n         enter_context(&icx, |_| f(tcx))\n     }"}, {"sha": "2d619d19b424393e722ac0d3c86c709761c08d9e", "filename": "src/librustc/ty/query/plumbing.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8c8f0bdf62728198696cab7d00a8fdc3ee381d3/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8c8f0bdf62728198696cab7d00a8fdc3ee381d3/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs?ref=b8c8f0bdf62728198696cab7d00a8fdc3ee381d3", "patch": "@@ -209,7 +209,7 @@ impl<'a, 'tcx, Q: QueryDescription<'tcx>> JobOwner<'a, 'tcx, Q> {\n                 tcx: tcx.global_tcx(),\n                 query: Some(self.job.clone()),\n                 layout_depth: current_icx.layout_depth,\n-                task: current_icx.task,\n+                task_deps: current_icx.task_deps,\n             };\n \n             // Use the ImplicitCtxt while we execute the query"}, {"sha": "6a7553b3882975e28d68b589254ae54ea6534bca", "filename": "src/librustc_incremental/persist/save.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b8c8f0bdf62728198696cab7d00a8fdc3ee381d3/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8c8f0bdf62728198696cab7d00a8fdc3ee381d3/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs?ref=b8c8f0bdf62728198696cab7d00a8fdc3ee381d3", "patch": "@@ -149,8 +149,6 @@ fn encode_dep_graph(tcx: TyCtxt,\n \n         let total_node_count = serialized_graph.nodes.len();\n         let total_edge_count = serialized_graph.edge_list_data.len();\n-        let (total_edge_reads, total_duplicate_edge_reads) =\n-            tcx.dep_graph.edge_deduplication_data();\n \n         let mut counts: FxHashMap<_, Stat> = FxHashMap::default();\n \n@@ -188,8 +186,11 @@ fn encode_dep_graph(tcx: TyCtxt,\n         println!(\"[incremental]\");\n         println!(\"[incremental] Total Node Count: {}\", total_node_count);\n         println!(\"[incremental] Total Edge Count: {}\", total_edge_count);\n-        println!(\"[incremental] Total Edge Reads: {}\", total_edge_reads);\n-        println!(\"[incremental] Total Duplicate Edge Reads: {}\", total_duplicate_edge_reads);\n+        if let Some((total_edge_reads,\n+                     total_duplicate_edge_reads)) = tcx.dep_graph.edge_deduplication_data() {\n+            println!(\"[incremental] Total Edge Reads: {}\", total_edge_reads);\n+            println!(\"[incremental] Total Duplicate Edge Reads: {}\", total_duplicate_edge_reads);\n+        }\n         println!(\"[incremental]\");\n         println!(\"[incremental]  {:<36}| {:<17}| {:<12}| {:<17}|\",\n                  \"Node Kind\","}]}