{"sha": "12b846ab80ca054d2fbfb0320d33badbd5ef0112", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEyYjg0NmFiODBjYTA1NGQyZmJmYjAzMjBkMzNiYWRiZDVlZjAxMTI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-03-09T23:27:14Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-03-09T23:27:14Z"}, "message": "Auto merge of #23038 - nikomatsakis:issue-22978-defaulted-coherence, r=flaper87\n\nFixes #22978.\r\n\r\nr? @FlaPer87", "tree": {"sha": "6a663803fba568f8da1590980ca2513e204e1b3d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6a663803fba568f8da1590980ca2513e204e1b3d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/12b846ab80ca054d2fbfb0320d33badbd5ef0112", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/12b846ab80ca054d2fbfb0320d33badbd5ef0112", "html_url": "https://github.com/rust-lang/rust/commit/12b846ab80ca054d2fbfb0320d33badbd5ef0112", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/12b846ab80ca054d2fbfb0320d33badbd5ef0112/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b83b26bacb6371173cdec6bf68c7ffa69f858c84", "url": "https://api.github.com/repos/rust-lang/rust/commits/b83b26bacb6371173cdec6bf68c7ffa69f858c84", "html_url": "https://github.com/rust-lang/rust/commit/b83b26bacb6371173cdec6bf68c7ffa69f858c84"}, {"sha": "17358d1d2152710feb911fe1c02fcaeba3de4b17", "url": "https://api.github.com/repos/rust-lang/rust/commits/17358d1d2152710feb911fe1c02fcaeba3de4b17", "html_url": "https://github.com/rust-lang/rust/commit/17358d1d2152710feb911fe1c02fcaeba3de4b17"}], "stats": {"total": 430, "additions": 299, "deletions": 131}, "files": [{"sha": "081c64ecae88102920ea0bbaa03e0b4a57d16422", "filename": "src/librustc/metadata/common.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12b846ab80ca054d2fbfb0320d33badbd5ef0112/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12b846ab80ca054d2fbfb0320d33badbd5ef0112/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcommon.rs?ref=12b846ab80ca054d2fbfb0320d33badbd5ef0112", "patch": "@@ -254,3 +254,5 @@ pub const tag_codemap: uint = 0xa1;\n pub const tag_codemap_filemap: uint = 0xa2;\n \n pub const tag_item_super_predicates: uint = 0xa3;\n+\n+pub const tag_defaulted_trait: uint = 0xa4;"}, {"sha": "ed5783c8dba661e4a1927964362abeb0b5e9a602", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/12b846ab80ca054d2fbfb0320d33badbd5ef0112/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12b846ab80ca054d2fbfb0320d33badbd5ef0112/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=12b846ab80ca054d2fbfb0320d33badbd5ef0112", "patch": "@@ -407,7 +407,7 @@ pub fn is_associated_type(cstore: &cstore::CStore, def: ast::DefId) -> bool {\n     decoder::is_associated_type(&*cdata, def.node)\n }\n \n-pub fn is_default_trait(cstore: &cstore::CStore, def: ast::DefId) -> bool {\n-    let cdata = cstore.get_crate_data(def.krate);\n-    decoder::is_default_trait(&*cdata, def.node)\n+pub fn is_defaulted_trait(cstore: &cstore::CStore, trait_def_id: ast::DefId) -> bool {\n+    let cdata = cstore.get_crate_data(trait_def_id.krate);\n+    decoder::is_defaulted_trait(&*cdata, trait_def_id.node)\n }"}, {"sha": "dbbc17c018a2fc92b2b0c235db4750ff8db44b93", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/12b846ab80ca054d2fbfb0320d33badbd5ef0112/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12b846ab80ca054d2fbfb0320d33badbd5ef0112/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=12b846ab80ca054d2fbfb0320d33badbd5ef0112", "patch": "@@ -1537,12 +1537,11 @@ pub fn is_associated_type(cdata: Cmd, id: ast::NodeId) -> bool {\n     }\n }\n \n-pub fn is_default_trait<'tcx>(cdata: Cmd, id: ast::NodeId) -> bool {\n-    let item_doc = lookup_item(id, cdata.data());\n-    match item_family(item_doc) {\n-        Family::DefaultImpl => true,\n-        _ => false\n-    }\n+pub fn is_defaulted_trait<'tcx>(cdata: Cmd, trait_id: ast::NodeId) -> bool {\n+    let trait_doc = lookup_item(trait_id, cdata.data());\n+    assert!(item_family(trait_doc) == Family::Trait);\n+    let defaulted_doc = reader::get_doc(trait_doc, tag_defaulted_trait);\n+    reader::doc_as_u8(defaulted_doc) != 0\n }\n \n pub fn get_imported_filemaps(metadata: &[u8]) -> Vec<codemap::FileMap> {"}, {"sha": "08263eb8e6a03978478147d8ed97b3fd6c4f138a", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/12b846ab80ca054d2fbfb0320d33badbd5ef0112/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12b846ab80ca054d2fbfb0320d33badbd5ef0112/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=12b846ab80ca054d2fbfb0320d33badbd5ef0112", "patch": "@@ -1288,6 +1288,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         let trait_predicates = ty::lookup_predicates(tcx, def_id);\n         encode_unsafety(rbml_w, trait_def.unsafety);\n         encode_paren_sugar(rbml_w, trait_def.paren_sugar);\n+        encode_defaulted(rbml_w, ty::trait_has_default_impl(tcx, def_id));\n         encode_associated_type_names(rbml_w, &trait_def.associated_type_names);\n         encode_generics(rbml_w, ecx, &trait_def.generics, &trait_predicates, tag_item_generics);\n         encode_predicates(rbml_w, ecx, &ty::lookup_super_predicates(tcx, def_id),\n@@ -1660,6 +1661,11 @@ fn encode_paren_sugar(rbml_w: &mut Encoder, paren_sugar: bool) {\n     rbml_w.wr_tagged_u8(tag_paren_sugar, byte);\n }\n \n+fn encode_defaulted(rbml_w: &mut Encoder, is_defaulted: bool) {\n+    let byte: u8 = if is_defaulted {1} else {0};\n+    rbml_w.wr_tagged_u8(tag_defaulted_trait, byte);\n+}\n+\n fn encode_associated_type_names(rbml_w: &mut Encoder, names: &[ast::Name]) {\n     rbml_w.start_tag(tag_associated_type_names);\n     for &name in names {"}, {"sha": "9f841b5acf888e6fd588e24094eea7090d97a287", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 18, "deletions": 36, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/12b846ab80ca054d2fbfb0320d33badbd5ef0112/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12b846ab80ca054d2fbfb0320d33badbd5ef0112/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=12b846ab80ca054d2fbfb0320d33badbd5ef0112", "patch": "@@ -757,8 +757,8 @@ pub struct ctxt<'tcx> {\n     /// Maps a trait onto a list of impls of that trait.\n     pub trait_impls: RefCell<DefIdMap<Rc<RefCell<Vec<ast::DefId>>>>>,\n \n-    /// Maps a trait onto a list of *default* trait implementations\n-    default_trait_impls: RefCell<DefIdMap<ast::DefId>>,\n+    /// A set of traits that have a default impl\n+    traits_with_default_impls: RefCell<DefIdMap<()>>,\n \n     /// Maps a DefId of a type to a list of its inherent impls.\n     /// Contains implementations of methods that are inherent to a type.\n@@ -2591,7 +2591,7 @@ pub fn mk_ctxt<'tcx>(s: Session,\n         destructor_for_type: RefCell::new(DefIdMap()),\n         destructors: RefCell::new(DefIdSet()),\n         trait_impls: RefCell::new(DefIdMap()),\n-        default_trait_impls: RefCell::new(DefIdMap()),\n+        traits_with_default_impls: RefCell::new(DefIdMap()),\n         inherent_impls: RefCell::new(DefIdMap()),\n         impl_items: RefCell::new(DefIdMap()),\n         used_unsafe: RefCell::new(NodeSet()),\n@@ -5975,32 +5975,22 @@ pub fn item_variances(tcx: &ctxt, item_id: ast::DefId) -> Rc<ItemVariances> {\n         || Rc::new(csearch::get_item_variances(&tcx.sess.cstore, item_id)))\n }\n \n-pub fn trait_default_impl(tcx: &ctxt, trait_def_id: DefId) -> Option<ast::DefId> {\n-    match tcx.default_trait_impls.borrow().get(&trait_def_id) {\n-        Some(id) => Some(*id),\n-        None => None\n-    }\n-}\n-\n pub fn trait_has_default_impl(tcx: &ctxt, trait_def_id: DefId) -> bool {\n+    populate_implementations_for_trait_if_necessary(tcx, trait_def_id);\n     match tcx.lang_items.to_builtin_kind(trait_def_id) {\n         Some(BoundSend) | Some(BoundSync) => true,\n-        _ => tcx.default_trait_impls.borrow().contains_key(&trait_def_id)\n+        _ => tcx.traits_with_default_impls.borrow().contains_key(&trait_def_id),\n     }\n }\n \n /// Records a trait-to-implementation mapping.\n-pub fn record_default_trait_implementation(tcx: &ctxt,\n-                                           trait_def_id: DefId,\n-                                           impl_def_id: DefId) {\n-\n+pub fn record_trait_has_default_impl(tcx: &ctxt, trait_def_id: DefId) {\n     // We're using the latest implementation found as the reference one.\n     // Duplicated implementations are caught and reported in the coherence\n     // step.\n-    tcx.default_trait_impls.borrow_mut().insert(trait_def_id, impl_def_id);\n+    tcx.traits_with_default_impls.borrow_mut().insert(trait_def_id, ());\n }\n \n-\n /// Records a trait-to-implementation mapping.\n pub fn record_trait_implementation(tcx: &ctxt,\n                                    trait_def_id: DefId,\n@@ -6031,8 +6021,7 @@ pub fn populate_implementations_for_type_if_necessary(tcx: &ctxt,\n     debug!(\"populate_implementations_for_type_if_necessary: searching for {:?}\", type_id);\n \n     let mut inherent_impls = Vec::new();\n-    csearch::each_implementation_for_type(&tcx.sess.cstore, type_id,\n-            |impl_def_id| {\n+    csearch::each_implementation_for_type(&tcx.sess.cstore, type_id, |impl_def_id| {\n         let impl_items = csearch::get_impl_items(&tcx.sess.cstore, impl_def_id);\n \n         // Record the trait->implementation mappings, if applicable.\n@@ -6078,27 +6067,20 @@ pub fn populate_implementations_for_trait_if_necessary(\n     if trait_id.krate == LOCAL_CRATE {\n         return\n     }\n+\n     if tcx.populated_external_traits.borrow().contains(&trait_id) {\n         return\n     }\n \n-    csearch::each_implementation_for_trait(&tcx.sess.cstore, trait_id,\n-            |implementation_def_id|{\n-        let impl_items = csearch::get_impl_items(&tcx.sess.cstore, implementation_def_id);\n+    if csearch::is_defaulted_trait(&tcx.sess.cstore, trait_id) {\n+        record_trait_has_default_impl(tcx, trait_id);\n+    }\n \n-        if csearch::is_default_trait(&tcx.sess.cstore, implementation_def_id) {\n-            record_default_trait_implementation(tcx, trait_id,\n-                                                implementation_def_id);\n-            tcx.populated_external_traits.borrow_mut().insert(trait_id);\n+    csearch::each_implementation_for_trait(&tcx.sess.cstore, trait_id, |implementation_def_id| {\n+        let impl_items = csearch::get_impl_items(&tcx.sess.cstore, implementation_def_id);\n \n-            // Nothing else to do for default trait implementations since\n-            // they are not allowed to have type parameters, methods, or any\n-            // other item that could be associated to a trait implementation.\n-            return;\n-        } else {\n-            // Record the trait->implementation mapping.\n-            record_trait_implementation(tcx, trait_id, implementation_def_id);\n-        }\n+        // Record the trait->implementation mapping.\n+        record_trait_implementation(tcx, trait_id, implementation_def_id);\n \n         // For any methods that use a default implementation, add them to\n         // the map. This is a bit unfortunate.\n@@ -6108,8 +6090,8 @@ pub fn populate_implementations_for_trait_if_necessary(\n                 MethodTraitItem(method) => {\n                     if let Some(source) = method.provided_source {\n                         tcx.provided_method_sources\n-                           .borrow_mut()\n-                           .insert(method_def_id, source);\n+                            .borrow_mut()\n+                            .insert(method_def_id, source);\n                     }\n                 }\n                 TypeTraitItem(_) => {}"}, {"sha": "e89c96b36e1a23887e2b52631945d2a2c99985dd", "filename": "src/librustc_typeck/coherence/impls.rs", "status": "removed", "additions": 0, "deletions": 47, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/b83b26bacb6371173cdec6bf68c7ffa69f858c84/src%2Flibrustc_typeck%2Fcoherence%2Fimpls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b83b26bacb6371173cdec6bf68c7ffa69f858c84/src%2Flibrustc_typeck%2Fcoherence%2Fimpls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fimpls.rs?ref=b83b26bacb6371173cdec6bf68c7ffa69f858c84", "patch": "@@ -1,47 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Implementations checker: builtin traits and default impls are allowed just\n-//! for structs and enums.\n-\n-use middle::ty;\n-use syntax::ast::{Item, ItemImpl};\n-use syntax::ast;\n-use syntax::visit;\n-\n-pub fn check(tcx: &ty::ctxt) {\n-    let mut impls = ImplsChecker { tcx: tcx };\n-    visit::walk_crate(&mut impls, tcx.map.krate());\n-}\n-\n-struct ImplsChecker<'cx, 'tcx:'cx> {\n-    tcx: &'cx ty::ctxt<'tcx>\n-}\n-\n-impl<'cx, 'tcx,'v> visit::Visitor<'v> for ImplsChecker<'cx, 'tcx> {\n-    fn visit_item(&mut self, item: &'v ast::Item) {\n-        match item.node {\n-            ast::ItemImpl(_, _, _, Some(_), _, _) => {\n-                let trait_ref = ty::impl_id_to_trait_ref(self.tcx, item.id);\n-                if let Some(_) = self.tcx.lang_items.to_builtin_kind(trait_ref.def_id) {\n-                    match trait_ref.self_ty().sty {\n-                        ty::ty_struct(..) | ty::ty_enum(..) => {}\n-                        _ => {\n-                            span_err!(self.tcx.sess, item.span, E0209,\n-                                \"builtin traits can only be \\\n-                                          implemented on structs or enums\");\n-                        }\n-                    }\n-                }\n-            }\n-            _ => {}\n-        }\n-    }\n-}"}, {"sha": "a06dcbaf556bdd7ea032914df2b415844c8dfdb1", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12b846ab80ca054d2fbfb0320d33badbd5ef0112/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12b846ab80ca054d2fbfb0320d33badbd5ef0112/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=12b846ab80ca054d2fbfb0320d33badbd5ef0112", "patch": "@@ -49,7 +49,6 @@ use syntax::visit;\n use util::nodemap::{DefIdMap, FnvHashMap};\n use util::ppaux::Repr;\n \n-mod impls;\n mod orphan;\n mod overlap;\n mod unsafety;\n@@ -583,7 +582,6 @@ pub fn check_coherence(crate_context: &CrateCtxt) {\n         inference_context: new_infer_ctxt(crate_context.tcx),\n         inherent_impls: RefCell::new(FnvHashMap()),\n     }.check(crate_context.tcx.map.krate());\n-    impls::check(crate_context.tcx);\n     unsafety::check(crate_context.tcx);\n     orphan::check(crate_context.tcx);\n     overlap::check(crate_context.tcx);"}, {"sha": "5dfe80cfcb213fd4a441b650af5b3b59802005d4", "filename": "src/librustc_typeck/coherence/orphan.rs", "status": "modified", "additions": 108, "deletions": 5, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/12b846ab80ca054d2fbfb0320d33badbd5ef0112/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12b846ab80ca054d2fbfb0320d33badbd5ef0112/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs?ref=12b846ab80ca054d2fbfb0320d33badbd5ef0112", "patch": "@@ -37,10 +37,13 @@ impl<'cx, 'tcx> OrphanChecker<'cx, 'tcx> {\n                        a trait or new type instead\");\n         }\n     }\n-}\n \n-impl<'cx, 'tcx,'v> visit::Visitor<'v> for OrphanChecker<'cx, 'tcx> {\n-    fn visit_item(&mut self, item: &ast::Item) {\n+    /// Checks exactly one impl for orphan rules and other such\n+    /// restrictions.  In this fn, it can happen that multiple errors\n+    /// apply to a specific impl, so just return after reporting one\n+    /// to prevent inundating the user with a bunch of similar error\n+    /// reports.\n+    fn check_item(&self, item: &ast::Item) {\n         let def_id = ast_util::local_def(item.id);\n         match item.node {\n             ast::ItemImpl(_, _, _, None, _, _) => {\n@@ -63,13 +66,15 @@ impl<'cx, 'tcx,'v> visit::Visitor<'v> for OrphanChecker<'cx, 'tcx> {\n                         span_err!(self.tcx.sess, item.span, E0118,\n                                   \"no base type found for inherent implementation; \\\n                                    implement a trait or new type instead\");\n+                        return;\n                     }\n                 }\n             }\n             ast::ItemImpl(_, _, _, Some(_), _, _) => {\n                 // \"Trait\" impl\n                 debug!(\"coherence2::orphan check: trait impl {}\", item.repr(self.tcx));\n-                let trait_def_id = ty::impl_trait_ref(self.tcx, def_id).unwrap().def_id;\n+                let trait_ref = ty::impl_trait_ref(self.tcx, def_id).unwrap();\n+                let trait_def_id = trait_ref.def_id;\n                 match traits::orphan_check(self.tcx, def_id) {\n                     Ok(()) => { }\n                     Err(traits::OrphanCheckErr::NoLocalInputType) => {\n@@ -80,6 +85,7 @@ impl<'cx, 'tcx,'v> visit::Visitor<'v> for OrphanChecker<'cx, 'tcx> {\n                                  types defined in this crate; \\\n                                  only traits defined in the current crate can be \\\n                                  implemented for arbitrary types\");\n+                            return;\n                         }\n                     }\n                     Err(traits::OrphanCheckErr::UncoveredTy(param_ty)) => {\n@@ -89,9 +95,100 @@ impl<'cx, 'tcx,'v> visit::Visitor<'v> for OrphanChecker<'cx, 'tcx> {\n                                      some local type (e.g. `MyStruct<T>`); only traits defined in \\\n                                      the current crate can be implemented for a type parameter\",\n                                     param_ty.user_string(self.tcx));\n+                            return;\n                         }\n                     }\n                 }\n+\n+                // In addition to the above rules, we restrict impls of defaulted traits\n+                // so that they can only be implemented on structs/enums. To see why this\n+                // restriction exists, consider the following example (#22978). Imagine\n+                // that crate A defines a defaulted trait `Foo` and a fn that operates\n+                // on pairs of types:\n+                //\n+                // ```\n+                // // Crate A\n+                // trait Foo { }\n+                // impl Foo for .. { }\n+                // fn two_foos<A:Foo,B:Foo>(..) {\n+                //     one_foo::<(A,B)>(..)\n+                // }\n+                // fn one_foo<T:Foo>(..) { .. }\n+                // ```\n+                //\n+                // This type-checks fine; in particular the fn\n+                // `two_foos` is able to conclude that `(A,B):Foo`\n+                // because `A:Foo` and `B:Foo`.\n+                //\n+                // Now imagine that crate B comes along and does the following:\n+                //\n+                // ```\n+                // struct A { }\n+                // struct B { }\n+                // impl Foo for A { }\n+                // impl Foo for B { }\n+                // impl !Send for (A, B) { }\n+                // ```\n+                //\n+                // This final impl is legal according to the orpan\n+                // rules, but it invalidates the reasoning from\n+                // `two_foos` above.\n+                debug!(\"trait_ref={} trait_def_id={} trait_has_default_impl={}\",\n+                       trait_ref.repr(self.tcx),\n+                       trait_def_id.repr(self.tcx),\n+                       ty::trait_has_default_impl(self.tcx, trait_def_id));\n+                if\n+                    ty::trait_has_default_impl(self.tcx, trait_def_id) &&\n+                    trait_def_id.krate != ast::LOCAL_CRATE\n+                {\n+                    let self_ty = trait_ref.self_ty();\n+                    let opt_self_def_id = match self_ty.sty {\n+                        ty::ty_struct(self_def_id, _) | ty::ty_enum(self_def_id, _) =>\n+                            Some(self_def_id),\n+                        ty::ty_uniq(..) =>\n+                            self.tcx.lang_items.owned_box(),\n+                        _ =>\n+                            None\n+                    };\n+\n+                    let msg = match opt_self_def_id {\n+                        // We only want to permit structs/enums, but not *all* structs/enums.\n+                        // They must be local to the current crate, so that people\n+                        // can't do `unsafe impl Send for Rc<SomethingLocal>` or\n+                        // `impl !Send for Box<SomethingLocalAndSend>`.\n+                        Some(self_def_id) => {\n+                            if self_def_id.krate == ast::LOCAL_CRATE {\n+                                None\n+                            } else {\n+                                Some(format!(\n+                                    \"cross-crate traits with a default impl, like `{}`, \\\n+                                     can only be implemented for a struct/enum type \\\n+                                     defined in the current crate\",\n+                                    ty::item_path_str(self.tcx, trait_def_id)))\n+                            }\n+                        }\n+                        _ => {\n+                            Some(format!(\n+                                \"cross-crate traits with a default impl, like `{}`, \\\n+                                 can only be implemented for a struct/enum type, \\\n+                                 not `{}`\",\n+                                ty::item_path_str(self.tcx, trait_def_id),\n+                                self_ty.user_string(self.tcx)))\n+                        }\n+                    };\n+\n+                    if let Some(msg) = msg {\n+                        span_err!(self.tcx.sess, item.span, E0321, \"{}\", msg);\n+                        return;\n+                    }\n+                }\n+\n+                // Disallow *all* explicit impls of `Sized` for now.\n+                if Some(trait_def_id) == self.tcx.lang_items.sized_trait() {\n+                    span_err!(self.tcx.sess, item.span, E0322,\n+                              \"explicit impls for the `Sized` trait are not permitted\");\n+                    return;\n+                }\n             }\n             ast::ItemDefaultImpl(..) => {\n                 // \"Trait\" impl\n@@ -100,14 +197,20 @@ impl<'cx, 'tcx,'v> visit::Visitor<'v> for OrphanChecker<'cx, 'tcx> {\n                 if trait_ref.def_id.krate != ast::LOCAL_CRATE {\n                     span_err!(self.tcx.sess, item.span, E0318,\n                               \"cannot create default implementations for traits outside the \\\n-                               crate they're defined in; define a new trait instead.\");\n+                               crate they're defined in; define a new trait instead\");\n+                    return;\n                 }\n             }\n             _ => {\n                 // Not an impl\n             }\n         }\n+    }\n+}\n \n+impl<'cx, 'tcx,'v> visit::Visitor<'v> for OrphanChecker<'cx, 'tcx> {\n+    fn visit_item(&mut self, item: &ast::Item) {\n+        self.check_item(item);\n         visit::walk_item(self, item);\n     }\n }"}, {"sha": "466d00b348b94d33d029c7a34ecbb43b30f71030", "filename": "src/librustc_typeck/coherence/overlap.rs", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/12b846ab80ca054d2fbfb0320d33badbd5ef0112/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12b846ab80ca054d2fbfb0320d33badbd5ef0112/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs?ref=12b846ab80ca054d2fbfb0320d33badbd5ef0112", "patch": "@@ -20,10 +20,11 @@ use syntax::ast;\n use syntax::ast_util;\n use syntax::visit;\n use syntax::codemap::Span;\n+use util::nodemap::DefIdMap;\n use util::ppaux::Repr;\n \n pub fn check(tcx: &ty::ctxt) {\n-    let mut overlap = OverlapChecker { tcx: tcx };\n+    let mut overlap = OverlapChecker { tcx: tcx, default_impls: DefIdMap() };\n     overlap.check_for_overlapping_impls();\n \n     // this secondary walk specifically checks for impls of defaulted\n@@ -33,6 +34,9 @@ pub fn check(tcx: &ty::ctxt) {\n \n struct OverlapChecker<'cx, 'tcx:'cx> {\n     tcx: &'cx ty::ctxt<'tcx>,\n+\n+    // maps from a trait def-id to an impl id\n+    default_impls: DefIdMap<ast::NodeId>,\n }\n \n impl<'cx, 'tcx> OverlapChecker<'cx, 'tcx> {\n@@ -134,24 +138,19 @@ impl<'cx, 'tcx,'v> visit::Visitor<'v> for OverlapChecker<'cx, 'tcx> {\n     fn visit_item(&mut self, item: &'v ast::Item) {\n         match item.node {\n             ast::ItemDefaultImpl(_, _) => {\n+                // look for another default impl; note that due to the\n+                // general orphan/coherence rules, it must always be\n+                // in this crate.\n                 let impl_def_id = ast_util::local_def(item.id);\n-                match ty::impl_trait_ref(self.tcx, impl_def_id) {\n-                    Some(ref trait_ref) => {\n-                        match ty::trait_default_impl(self.tcx, trait_ref.def_id) {\n-                            Some(other_impl) if other_impl != impl_def_id => {\n-                                self.report_overlap_error(trait_ref.def_id,\n-                                                          other_impl,\n-                                                          impl_def_id);\n-                            }\n-                            Some(_) => {}\n-                            None => {\n-                                self.tcx.sess.bug(\n-                                          &format!(\"no default implementation recorded for `{:?}`\",\n-                                          item));\n-                            }\n-                        }\n+                let trait_ref = ty::impl_trait_ref(self.tcx, impl_def_id).unwrap();\n+                let prev_default_impl = self.default_impls.insert(trait_ref.def_id, item.id);\n+                match prev_default_impl {\n+                    Some(prev_id) => {\n+                        self.report_overlap_error(trait_ref.def_id,\n+                                                  impl_def_id,\n+                                                  ast_util::local_def(prev_id));\n                     }\n-                    _ => {}\n+                    None => { }\n                 }\n             }\n             _ => {}"}, {"sha": "bd68802f262c1a1a532b1a03f8ea30d75b328f04", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12b846ab80ca054d2fbfb0320d33badbd5ef0112/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12b846ab80ca054d2fbfb0320d33badbd5ef0112/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=12b846ab80ca054d2fbfb0320d33badbd5ef0112", "patch": "@@ -979,7 +979,7 @@ fn convert_item(ccx: &CrateCtxt, it: &ast::Item) {\n                                                            None,\n                                                            None);\n \n-            ty::record_default_trait_implementation(tcx, trait_ref.def_id, local_def(it.id))\n+            ty::record_trait_has_default_impl(tcx, trait_ref.def_id);\n         }\n         ast::ItemImpl(_, _,\n                       ref generics,"}, {"sha": "03fa269ccf82908651b7056cbba5ed3f63fa1078", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/12b846ab80ca054d2fbfb0320d33badbd5ef0112/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12b846ab80ca054d2fbfb0320d33badbd5ef0112/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=12b846ab80ca054d2fbfb0320d33badbd5ef0112", "patch": "@@ -175,7 +175,9 @@ register_diagnostics! {\n     E0250, // expected constant expr for array length\n     E0318, // can't create default impls for traits outside their crates\n     E0319, // trait impls for defaulted traits allowed just for structs/enums\n-    E0320  // recursive overflow during dropck\n+    E0320, // recursive overflow during dropck\n+    E0321, // extended coherence rules for defaulted traits violated\n+    E0322  // cannot implement Sized explicitly\n }\n \n __build_diagnostic_array! { DIAGNOSTICS }"}, {"sha": "506e7a00c75bcc72271c6f289984e1c5db52618e", "filename": "src/test/auxiliary/typeck-default-trait-impl-cross-crate-coherence-lib.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/12b846ab80ca054d2fbfb0320d33badbd5ef0112/src%2Ftest%2Fauxiliary%2Ftypeck-default-trait-impl-cross-crate-coherence-lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12b846ab80ca054d2fbfb0320d33badbd5ef0112/src%2Ftest%2Fauxiliary%2Ftypeck-default-trait-impl-cross-crate-coherence-lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Ftypeck-default-trait-impl-cross-crate-coherence-lib.rs?ref=12b846ab80ca054d2fbfb0320d33badbd5ef0112", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(optin_builtin_traits)]\n+#![crate_type = \"rlib\"]\n+\n+use std::marker::MarkerTrait;\n+\n+pub trait DefaultedTrait : MarkerTrait { }\n+impl DefaultedTrait for .. { }\n+\n+pub struct Something<T> { t: T }"}, {"sha": "3034be177ca68110a3523bd118d9c503b6b3e552", "filename": "src/test/compile-fail/coherence-impls-copy.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/12b846ab80ca054d2fbfb0320d33badbd5ef0112/src%2Ftest%2Fcompile-fail%2Fcoherence-impls-copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12b846ab80ca054d2fbfb0320d33badbd5ef0112/src%2Ftest%2Fcompile-fail%2Fcoherence-impls-copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-impls-copy.rs?ref=12b846ab80ca054d2fbfb0320d33badbd5ef0112", "patch": "@@ -0,0 +1,39 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(optin_builtin_traits)]\n+\n+use std::marker::Copy;\n+\n+enum TestE {\n+  A\n+}\n+\n+struct MyType;\n+\n+struct NotSync;\n+impl !Sync for NotSync {}\n+\n+impl Copy for TestE {}\n+impl Copy for MyType {}\n+impl Copy for (MyType, MyType) {}\n+//~^ ERROR E0206\n+\n+impl Copy for &'static NotSync {}\n+//~^ ERROR E0206\n+\n+impl Copy for [MyType] {}\n+//~^ ERROR E0206\n+\n+impl Copy for &'static [NotSync] {}\n+//~^ ERROR E0206\n+\n+fn main() {\n+}"}, {"sha": "b05c1ff0f0b7265d62fe90db7dbf8980f7517d52", "filename": "src/test/compile-fail/coherence-impls-send.rs", "status": "renamed", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/12b846ab80ca054d2fbfb0320d33badbd5ef0112/src%2Ftest%2Fcompile-fail%2Fcoherence-impls-send.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12b846ab80ca054d2fbfb0320d33badbd5ef0112/src%2Ftest%2Fcompile-fail%2Fcoherence-impls-send.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-impls-send.rs?ref=12b846ab80ca054d2fbfb0320d33badbd5ef0112", "patch": "@@ -10,7 +10,7 @@\n \n #![feature(optin_builtin_traits)]\n \n-use std::marker::Send;\n+use std::marker::Copy;\n \n enum TestE {\n   A\n@@ -24,20 +24,17 @@ impl !Sync for NotSync {}\n unsafe impl Send for TestE {}\n unsafe impl Send for MyType {}\n unsafe impl Send for (MyType, MyType) {}\n-//~^ ERROR builtin traits can only be implemented on structs or enums\n+//~^ ERROR E0321\n \n unsafe impl Send for &'static NotSync {}\n-//~^ ERROR builtin traits can only be implemented on structs or enums\n+//~^ ERROR E0321\n \n unsafe impl Send for [MyType] {}\n-//~^ ERROR builtin traits can only be implemented on structs or enums\n+//~^ ERROR E0321\n \n unsafe impl Send for &'static [NotSync] {}\n-//~^ ERROR builtin traits can only be implemented on structs or enums\n-//~^^ ERROR conflicting implementations for trait `core::marker::Send`\n-\n-fn is_send<T: Send>() {}\n+//~^ ERROR E0321\n+//~| ERROR conflicting implementations\n \n fn main() {\n-    is_send::<(MyType, TestE)>();\n }", "previous_filename": "src/test/compile-fail/coherence-impls-builtin.rs"}, {"sha": "a9a3ebaffb75abff44bfc810ac3ca74544b24b5b", "filename": "src/test/compile-fail/coherence-impls-sized.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/12b846ab80ca054d2fbfb0320d33badbd5ef0112/src%2Ftest%2Fcompile-fail%2Fcoherence-impls-sized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12b846ab80ca054d2fbfb0320d33badbd5ef0112/src%2Ftest%2Fcompile-fail%2Fcoherence-impls-sized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-impls-sized.rs?ref=12b846ab80ca054d2fbfb0320d33badbd5ef0112", "patch": "@@ -0,0 +1,33 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(optin_builtin_traits)]\n+\n+use std::marker::Copy;\n+\n+enum TestE {\n+  A\n+}\n+\n+struct MyType;\n+\n+struct NotSync;\n+impl !Sync for NotSync {}\n+\n+impl Sized for TestE {} //~ ERROR E0322\n+impl Sized for MyType {} //~ ERROR E0322\n+impl Sized for (MyType, MyType) {} //~ ERROR E0322\n+impl Sized for &'static NotSync {} //~ ERROR E0322\n+impl Sized for [MyType] {} //~ ERROR E0322\n+//~^ ERROR E0277\n+impl Sized for &'static [NotSync] {} //~ ERROR E0322\n+\n+fn main() {\n+}"}, {"sha": "97dffec2dd9bd4758db4a11f9f89107d00581b72", "filename": "src/test/compile-fail/coherence-orphan.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/12b846ab80ca054d2fbfb0320d33badbd5ef0112/src%2Ftest%2Fcompile-fail%2Fcoherence-orphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12b846ab80ca054d2fbfb0320d33badbd5ef0112/src%2Ftest%2Fcompile-fail%2Fcoherence-orphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-orphan.rs?ref=12b846ab80ca054d2fbfb0320d33badbd5ef0112", "patch": "@@ -19,13 +19,15 @@ use lib::TheTrait;\n \n struct TheType;\n \n-impl TheTrait<usize> for isize { } //~ ERROR E0117\n+impl TheTrait<usize> for isize { }\n+//~^ ERROR E0117\n \n impl TheTrait<TheType> for isize { }\n \n impl TheTrait<isize> for TheType { }\n \n-impl !Send for Vec<isize> { } //~ ERROR E0117\n-//~^ ERROR conflicting\n+impl !Send for Vec<isize> { }\n+//~^ ERROR E0117\n+//~| ERROR E0119\n \n fn main() { }"}, {"sha": "3a29bb9c2277cfe0395c11e1ee89b0c9fb6583a0", "filename": "src/test/compile-fail/typeck-default-trait-impl-cross-crate-coherence.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/12b846ab80ca054d2fbfb0320d33badbd5ef0112/src%2Ftest%2Fcompile-fail%2Ftypeck-default-trait-impl-cross-crate-coherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12b846ab80ca054d2fbfb0320d33badbd5ef0112/src%2Ftest%2Fcompile-fail%2Ftypeck-default-trait-impl-cross-crate-coherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftypeck-default-trait-impl-cross-crate-coherence.rs?ref=12b846ab80ca054d2fbfb0320d33badbd5ef0112", "patch": "@@ -0,0 +1,34 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:typeck-default-trait-impl-cross-crate-coherence-lib.rs\n+\n+// Test that we do not consider associated types to be sendable without\n+// some applicable trait bound (and we don't ICE).\n+\n+#![feature(optin_builtin_traits)]\n+\n+extern crate \"typeck-default-trait-impl-cross-crate-coherence-lib\" as lib;\n+\n+use lib::DefaultedTrait;\n+\n+struct A;\n+impl DefaultedTrait for (A,) { } //~ ERROR E0321\n+\n+struct B;\n+impl !DefaultedTrait for (B,) { } //~ ERROR E0321\n+\n+struct C;\n+struct D<T>(T);\n+impl DefaultedTrait for Box<C> { } //~ ERROR E0321\n+impl DefaultedTrait for lib::Something<C> { } //~ ERROR E0321\n+impl DefaultedTrait for D<C> { } // OK\n+\n+fn main() { }"}, {"sha": "a345bd1b65c0ea1f1f7c83ac410dd066e7dfb78c", "filename": "src/test/compile-fail/typeck-default-trait-impl-outside-crate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12b846ab80ca054d2fbfb0320d33badbd5ef0112/src%2Ftest%2Fcompile-fail%2Ftypeck-default-trait-impl-outside-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12b846ab80ca054d2fbfb0320d33badbd5ef0112/src%2Ftest%2Fcompile-fail%2Ftypeck-default-trait-impl-outside-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftypeck-default-trait-impl-outside-crate.rs?ref=12b846ab80ca054d2fbfb0320d33badbd5ef0112", "patch": "@@ -13,6 +13,6 @@\n #![feature(optin_builtin_traits)]\n \n impl Copy for .. {}\n-//~^ ERROR cannot create default implementations for traits outside the crate they're defined in; define a new trait instead.\n+//~^ ERROR E0318\n \n fn main() {}"}]}