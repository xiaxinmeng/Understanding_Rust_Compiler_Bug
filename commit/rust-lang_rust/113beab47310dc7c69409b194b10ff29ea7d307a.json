{"sha": "113beab47310dc7c69409b194b10ff29ea7d307a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjExM2JlYWI0NzMxMGRjN2M2OTQwOWIxOTRiMTBmZjI5ZWE3ZDMwN2E=", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-07-20T14:00:44Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-07-20T14:00:44Z"}, "message": "Cleanup runnables canonical path impl", "tree": {"sha": "46ca073c4a99dcb44b0fb1e1e02b90a968c2fba2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/46ca073c4a99dcb44b0fb1e1e02b90a968c2fba2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/113beab47310dc7c69409b194b10ff29ea7d307a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/113beab47310dc7c69409b194b10ff29ea7d307a", "html_url": "https://github.com/rust-lang/rust/commit/113beab47310dc7c69409b194b10ff29ea7d307a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/113beab47310dc7c69409b194b10ff29ea7d307a/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "97d63d67cd9162edb022f95e60698aab2550d8a7", "url": "https://api.github.com/repos/rust-lang/rust/commits/97d63d67cd9162edb022f95e60698aab2550d8a7", "html_url": "https://github.com/rust-lang/rust/commit/97d63d67cd9162edb022f95e60698aab2550d8a7"}], "stats": {"total": 100, "additions": 49, "deletions": 51}, "files": [{"sha": "ec16b4bbf8d86acacff0f646c2176fb48b344bb3", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/113beab47310dc7c69409b194b10ff29ea7d307a/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/113beab47310dc7c69409b194b10ff29ea7d307a/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=113beab47310dc7c69409b194b10ff29ea7d307a", "patch": "@@ -295,12 +295,12 @@ impl ModuleDef {\n     }\n \n     pub fn canonical_path(&self, db: &dyn HirDatabase) -> Option<String> {\n-        let mut segments = vec![self.name(db)?.to_string()];\n+        let mut segments = vec![self.name(db)?];\n         for m in self.module(db)?.path_to_root(db) {\n-            segments.extend(m.name(db).map(|it| it.to_string()))\n+            segments.extend(m.name(db))\n         }\n         segments.reverse();\n-        Some(segments.join(\"::\"))\n+        Some(segments.into_iter().join(\"::\"))\n     }\n \n     pub fn name(self, db: &dyn HirDatabase) -> Option<Name> {"}, {"sha": "0fd8ad970d6e34a22b44f3f9511a9b41e8272b41", "filename": "crates/ide/src/runnables.rs", "status": "modified", "additions": 46, "deletions": 48, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/113beab47310dc7c69409b194b10ff29ea7d307a/crates%2Fide%2Fsrc%2Frunnables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/113beab47310dc7c69409b194b10ff29ea7d307a/crates%2Fide%2Fsrc%2Frunnables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Frunnables.rs?ref=113beab47310dc7c69409b194b10ff29ea7d307a", "patch": "@@ -157,7 +157,7 @@ pub(crate) fn runnables(db: &RootDatabase, file_id: FileId) -> Vec<Runnable> {\n                 hir::ModuleDef::Function(it) => runnable_fn(&sema, it),\n                 _ => None,\n             };\n-            add_opt(runnable.or_else(|| module_def_doctest(&sema, def)), Some(def));\n+            add_opt(runnable.or_else(|| module_def_doctest(sema.db, def)), Some(def));\n         }\n         Either::Right(impl_) => {\n             add_opt(runnable_impl(&sema, &impl_), None);\n@@ -168,9 +168,9 @@ pub(crate) fn runnables(db: &RootDatabase, file_id: FileId) -> Vec<Runnable> {\n                     (\n                         match assoc {\n                             hir::AssocItem::Function(it) => runnable_fn(&sema, it)\n-                                .or_else(|| module_def_doctest(&sema, it.into())),\n-                            hir::AssocItem::Const(it) => module_def_doctest(&sema, it.into()),\n-                            hir::AssocItem::TypeAlias(it) => module_def_doctest(&sema, it.into()),\n+                                .or_else(|| module_def_doctest(sema.db, it.into())),\n+                            hir::AssocItem::Const(it) => module_def_doctest(sema.db, it.into()),\n+                            hir::AssocItem::TypeAlias(it) => module_def_doctest(sema.db, it.into()),\n                         },\n                         assoc,\n                     )\n@@ -382,61 +382,59 @@ fn runnable_mod_outline_definition(\n     }\n }\n \n-fn module_def_doctest(sema: &Semantics<RootDatabase>, def: hir::ModuleDef) -> Option<Runnable> {\n+fn module_def_doctest(db: &RootDatabase, def: hir::ModuleDef) -> Option<Runnable> {\n     let attrs = match def {\n-        hir::ModuleDef::Module(it) => it.attrs(sema.db),\n-        hir::ModuleDef::Function(it) => it.attrs(sema.db),\n-        hir::ModuleDef::Adt(it) => it.attrs(sema.db),\n-        hir::ModuleDef::Variant(it) => it.attrs(sema.db),\n-        hir::ModuleDef::Const(it) => it.attrs(sema.db),\n-        hir::ModuleDef::Static(it) => it.attrs(sema.db),\n-        hir::ModuleDef::Trait(it) => it.attrs(sema.db),\n-        hir::ModuleDef::TypeAlias(it) => it.attrs(sema.db),\n+        hir::ModuleDef::Module(it) => it.attrs(db),\n+        hir::ModuleDef::Function(it) => it.attrs(db),\n+        hir::ModuleDef::Adt(it) => it.attrs(db),\n+        hir::ModuleDef::Variant(it) => it.attrs(db),\n+        hir::ModuleDef::Const(it) => it.attrs(db),\n+        hir::ModuleDef::Static(it) => it.attrs(db),\n+        hir::ModuleDef::Trait(it) => it.attrs(db),\n+        hir::ModuleDef::TypeAlias(it) => it.attrs(db),\n         hir::ModuleDef::BuiltinType(_) => return None,\n     };\n     if !has_runnable_doc_test(&attrs) {\n         return None;\n     }\n-    let def_name = def.name(sema.db).map(|it| it.to_string());\n-    let test_id = def\n-        .canonical_path(sema.db)\n-        // This probably belongs to canonical path?\n-        .map(|path| {\n-            let assoc_def = match def {\n-                hir::ModuleDef::Function(it) => it.as_assoc_item(sema.db),\n-                hir::ModuleDef::Const(it) => it.as_assoc_item(sema.db),\n-                hir::ModuleDef::TypeAlias(it) => it.as_assoc_item(sema.db),\n-                _ => None,\n-            };\n-            // FIXME: this also looks very wrong\n-            if let Some(assoc_def) = assoc_def {\n-                if let hir::AssocItemContainer::Impl(imp) = assoc_def.container(sema.db) {\n-                    let ty = imp.self_ty(sema.db);\n-                    if let Some(adt) = ty.as_adt() {\n-                        let name = adt.name(sema.db);\n-                        let idx = path.rfind(':').map_or(0, |idx| idx + 1);\n-                        let (prefix, suffix) = path.split_at(idx);\n-                        let mut ty_args = ty.type_arguments().peekable();\n-                        let params = if ty_args.peek().is_some() {\n-                            format!(\n-                                \"<{}>\",\n-                                ty_args.format_with(\", \", |ty, cb| cb(&ty.display(sema.db)))\n-                            )\n-                        } else {\n-                            String::new()\n-                        };\n-                        return format!(\"{}{}{}::{}\", prefix, name, params, suffix);\n+    let def_name = def.name(db)?;\n+    let path = (|| {\n+        let mut path = String::new();\n+        def.module(db)?\n+            .path_to_root(db)\n+            .into_iter()\n+            .rev()\n+            .flat_map(|it| it.name(db))\n+            .for_each(|name| format_to!(path, \"{}::\", name));\n+        // This probably belongs to canonical_path?\n+        if let Some(assoc_item) = def.as_assoc_item(db) {\n+            if let hir::AssocItemContainer::Impl(imp) = assoc_item.container(db) {\n+                let ty = imp.self_ty(db);\n+                if let Some(adt) = ty.as_adt() {\n+                    let name = adt.name(db);\n+                    let mut ty_args = ty.type_arguments().peekable();\n+                    format_to!(path, \"{}\", name);\n+                    if ty_args.peek().is_some() {\n+                        format_to!(\n+                            path,\n+                            \"<{}>\",\n+                            ty_args.format_with(\", \", |ty, cb| cb(&ty.display(db)))\n+                        );\n                     }\n+                    format_to!(path, \"::{}\", def_name);\n+                    return Some(path);\n                 }\n             }\n-            path\n-        })\n-        .map(TestId::Path)\n-        .or_else(|| def_name.clone().map(TestId::Name))?;\n+        }\n+        format_to!(path, \"{}\", def_name);\n+        Some(path)\n+    })();\n+\n+    let test_id = path.map_or_else(|| TestId::Name(def_name.to_string()), TestId::Path);\n \n     let mut nav = match def {\n-        hir::ModuleDef::Module(def) => NavigationTarget::from_module_to_decl(sema.db, def),\n-        def => def.try_to_nav(sema.db)?,\n+        hir::ModuleDef::Module(def) => NavigationTarget::from_module_to_decl(db, def),\n+        def => def.try_to_nav(db)?,\n     };\n     nav.focus_range = None;\n     nav.description = None;"}]}