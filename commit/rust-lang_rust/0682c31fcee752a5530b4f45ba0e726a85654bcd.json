{"sha": "0682c31fcee752a5530b4f45ba0e726a85654bcd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA2ODJjMzFmY2VlNzUyYTU1MzBiNGY0NWJhMGU3MjZhODU2NTRiY2Q=", "commit": {"author": {"name": "Jubilee", "email": "46493976+workingjubilee@users.noreply.github.com", "date": "2021-04-09T14:39:47Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-04-09T14:39:47Z"}, "message": "Merge pull request #80 from rust-lang/feature/comparisons\n\nAdd classification functions", "tree": {"sha": "3ed19cfe66008a49093c8a8f9aa8f4506e707a56", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3ed19cfe66008a49093c8a8f9aa8f4506e707a56"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0682c31fcee752a5530b4f45ba0e726a85654bcd", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgcGczCRBK7hj4Ov3rIwAAdHIIAGpSlE39NNj+21og1k4AjUWn\nkMqCPNWqFM+Jjsdxgf38Y5KVBDlZmKzHFvagattmdemBewX/fWWU7P0pNyT2w5p5\nIpFXHeKb9DWrHXdl1DBdwQz3qWwpKSPcASSI6sWf+rf9lkivKV762l3/cGQwZnlT\nciK/HwUAhGhDCO2AKm4LQt/31Ja9V9/jY5bEbBCewcWsKVzhlsVkLTSJeQ3rsf1c\nGY3AJDdkSIU4gM1S+rYGaII+XZroma+FEcuKhyGSOWtVu/XuEs/uWj3bziI+vAoi\nqutRerebm1BtJyv+2kKhm7VbJJDB5VPOL/fbnbvCLGu2kB89mrl2kWObbFqN/HA=\n=C6zf\n-----END PGP SIGNATURE-----\n", "payload": "tree 3ed19cfe66008a49093c8a8f9aa8f4506e707a56\nparent 4e6d44086cb817cc81b5528d643bab53095773cb\nparent e6a530907a8a6d0ab943ccd7aaebdfef9d609605\nauthor Jubilee <46493976+workingjubilee@users.noreply.github.com> 1617979187 -0700\ncommitter GitHub <noreply@github.com> 1617979187 -0700\n\nMerge pull request #80 from rust-lang/feature/comparisons\n\nAdd classification functions"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0682c31fcee752a5530b4f45ba0e726a85654bcd", "html_url": "https://github.com/rust-lang/rust/commit/0682c31fcee752a5530b4f45ba0e726a85654bcd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0682c31fcee752a5530b4f45ba0e726a85654bcd/comments", "author": {"login": "workingjubilee", "id": 46493976, "node_id": "MDQ6VXNlcjQ2NDkzOTc2", "avatar_url": "https://avatars.githubusercontent.com/u/46493976?v=4", "gravatar_id": "", "url": "https://api.github.com/users/workingjubilee", "html_url": "https://github.com/workingjubilee", "followers_url": "https://api.github.com/users/workingjubilee/followers", "following_url": "https://api.github.com/users/workingjubilee/following{/other_user}", "gists_url": "https://api.github.com/users/workingjubilee/gists{/gist_id}", "starred_url": "https://api.github.com/users/workingjubilee/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/workingjubilee/subscriptions", "organizations_url": "https://api.github.com/users/workingjubilee/orgs", "repos_url": "https://api.github.com/users/workingjubilee/repos", "events_url": "https://api.github.com/users/workingjubilee/events{/privacy}", "received_events_url": "https://api.github.com/users/workingjubilee/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4e6d44086cb817cc81b5528d643bab53095773cb", "url": "https://api.github.com/repos/rust-lang/rust/commits/4e6d44086cb817cc81b5528d643bab53095773cb", "html_url": "https://github.com/rust-lang/rust/commit/4e6d44086cb817cc81b5528d643bab53095773cb"}, {"sha": "e6a530907a8a6d0ab943ccd7aaebdfef9d609605", "url": "https://api.github.com/repos/rust-lang/rust/commits/e6a530907a8a6d0ab943ccd7aaebdfef9d609605", "html_url": "https://github.com/rust-lang/rust/commit/e6a530907a8a6d0ab943ccd7aaebdfef9d609605"}], "stats": {"total": 836, "additions": 537, "deletions": 299}, "files": [{"sha": "455f30dc97eed9cf367adfe66b477e8700817edb", "filename": "crates/core_simd/src/comparisons.rs", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/0682c31fcee752a5530b4f45ba0e726a85654bcd/crates%2Fcore_simd%2Fsrc%2Fcomparisons.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0682c31fcee752a5530b4f45ba0e726a85654bcd/crates%2Fcore_simd%2Fsrc%2Fcomparisons.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fcomparisons.rs?ref=0682c31fcee752a5530b4f45ba0e726a85654bcd", "patch": "@@ -0,0 +1,86 @@\n+use crate::LanesAtMost32;\n+\n+macro_rules! implement_mask_ops {\n+    { $($vector:ident => $mask:ident ($inner_mask_ty:ident, $inner_ty:ident),)* } => {\n+        $(\n+            impl<const LANES: usize> crate::$vector<LANES>\n+            where\n+                crate::$vector<LANES>: LanesAtMost32,\n+                crate::$inner_ty<LANES>: LanesAtMost32,\n+            {\n+                /// Test if each lane is equal to the corresponding lane in `other`.\n+                #[inline]\n+                pub fn lanes_eq(self, other: Self) -> crate::$mask<LANES> {\n+                    unsafe {\n+                        crate::$inner_mask_ty::from_int_unchecked(crate::intrinsics::simd_eq(self, other))\n+                            .into()\n+                    }\n+                }\n+\n+                /// Test if each lane is not equal to the corresponding lane in `other`.\n+                #[inline]\n+                pub fn lanes_ne(self, other: Self) -> crate::$mask<LANES> {\n+                    unsafe {\n+                        crate::$inner_mask_ty::from_int_unchecked(crate::intrinsics::simd_ne(self, other))\n+                            .into()\n+                    }\n+                }\n+\n+                /// Test if each lane is less than the corresponding lane in `other`.\n+                #[inline]\n+                pub fn lanes_lt(self, other: Self) -> crate::$mask<LANES> {\n+                    unsafe {\n+                        crate::$inner_mask_ty::from_int_unchecked(crate::intrinsics::simd_lt(self, other))\n+                            .into()\n+                    }\n+                }\n+\n+                /// Test if each lane is greater than the corresponding lane in `other`.\n+                #[inline]\n+                pub fn lanes_gt(self, other: Self) -> crate::$mask<LANES> {\n+                    unsafe {\n+                        crate::$inner_mask_ty::from_int_unchecked(crate::intrinsics::simd_gt(self, other))\n+                            .into()\n+                    }\n+                }\n+\n+                /// Test if each lane is less than or equal to the corresponding lane in `other`.\n+                #[inline]\n+                pub fn lanes_le(self, other: Self) -> crate::$mask<LANES> {\n+                    unsafe {\n+                        crate::$inner_mask_ty::from_int_unchecked(crate::intrinsics::simd_le(self, other))\n+                            .into()\n+                    }\n+                }\n+\n+                /// Test if each lane is greater than or equal to the corresponding lane in `other`.\n+                #[inline]\n+                pub fn lanes_ge(self, other: Self) -> crate::$mask<LANES> {\n+                    unsafe {\n+                        crate::$inner_mask_ty::from_int_unchecked(crate::intrinsics::simd_ge(self, other))\n+                            .into()\n+                    }\n+                }\n+            }\n+        )*\n+    }\n+}\n+\n+implement_mask_ops! {\n+    SimdI8 => Mask8 (SimdMask8, SimdI8),\n+    SimdI16 => Mask16 (SimdMask16, SimdI16),\n+    SimdI32 => Mask32 (SimdMask32, SimdI32),\n+    SimdI64 => Mask64 (SimdMask64, SimdI64),\n+    SimdI128 => Mask128 (SimdMask128, SimdI128),\n+    SimdIsize => MaskSize (SimdMaskSize, SimdIsize),\n+\n+    SimdU8 => Mask8 (SimdMask8, SimdI8),\n+    SimdU16 => Mask16 (SimdMask16, SimdI16),\n+    SimdU32 => Mask32 (SimdMask32, SimdI32),\n+    SimdU64 => Mask64 (SimdMask64, SimdI64),\n+    SimdU128 => Mask128 (SimdMask128, SimdI128),\n+    SimdUsize => MaskSize (SimdMaskSize, SimdIsize),\n+\n+    SimdF32 => Mask32 (SimdMask32, SimdI32),\n+    SimdF64 => Mask64 (SimdMask64, SimdI64),\n+}"}, {"sha": "50602829d4828a8179b19cb1273cbdc748791825", "filename": "crates/core_simd/src/first.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0682c31fcee752a5530b4f45ba0e726a85654bcd/crates%2Fcore_simd%2Fsrc%2Ffirst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0682c31fcee752a5530b4f45ba0e726a85654bcd/crates%2Fcore_simd%2Fsrc%2Ffirst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Ffirst.rs?ref=0682c31fcee752a5530b4f45ba0e726a85654bcd", "patch": "@@ -1,7 +1,7 @@\n /// Implements common traits on the specified vector `$name`, holding multiple `$lanes` of `$type`.\n macro_rules! impl_vector {\n     { $name:ident, $type:ty } => {\n-        impl<const LANES: usize> $name<LANES> where Self: crate::LanesAtMost64 {\n+        impl<const LANES: usize> $name<LANES> where Self: crate::LanesAtMost32 {\n             /// Construct a SIMD vector by setting all lanes to the given value.\n             pub const fn splat(value: $type) -> Self {\n                 Self([value; LANES])\n@@ -44,31 +44,31 @@ macro_rules! impl_vector {\n             }\n         }\n \n-        impl<const LANES: usize> Copy for $name<LANES> where Self: crate::LanesAtMost64 {}\n+        impl<const LANES: usize> Copy for $name<LANES> where Self: crate::LanesAtMost32 {}\n \n-        impl<const LANES: usize> Clone for $name<LANES> where Self: crate::LanesAtMost64 {\n+        impl<const LANES: usize> Clone for $name<LANES> where Self: crate::LanesAtMost32 {\n             #[inline]\n             fn clone(&self) -> Self {\n                 *self\n             }\n         }\n \n-        impl<const LANES: usize> Default for $name<LANES> where Self: crate::LanesAtMost64 {\n+        impl<const LANES: usize> Default for $name<LANES> where Self: crate::LanesAtMost32 {\n             #[inline]\n             fn default() -> Self {\n                 Self::splat(<$type>::default())\n             }\n         }\n \n-        impl<const LANES: usize> PartialEq for $name<LANES> where Self: crate::LanesAtMost64 {\n+        impl<const LANES: usize> PartialEq for $name<LANES> where Self: crate::LanesAtMost32 {\n             #[inline]\n             fn eq(&self, other: &Self) -> bool {\n                 // TODO use SIMD equality\n                 self.to_array() == other.to_array()\n             }\n         }\n \n-        impl<const LANES: usize> PartialOrd for $name<LANES> where Self: crate::LanesAtMost64 {\n+        impl<const LANES: usize> PartialOrd for $name<LANES> where Self: crate::LanesAtMost32 {\n             #[inline]\n             fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {\n                 // TODO use SIMD equalitya\n@@ -77,43 +77,43 @@ macro_rules! impl_vector {\n         }\n \n         // array references\n-        impl<const LANES: usize> AsRef<[$type; LANES]> for $name<LANES> where Self: crate::LanesAtMost64 {\n+        impl<const LANES: usize> AsRef<[$type; LANES]> for $name<LANES> where Self: crate::LanesAtMost32 {\n             #[inline]\n             fn as_ref(&self) -> &[$type; LANES] {\n                 &self.0\n             }\n         }\n \n-        impl<const LANES: usize> AsMut<[$type; LANES]> for $name<LANES> where Self: crate::LanesAtMost64 {\n+        impl<const LANES: usize> AsMut<[$type; LANES]> for $name<LANES> where Self: crate::LanesAtMost32 {\n             #[inline]\n             fn as_mut(&mut self) -> &mut [$type; LANES] {\n                 &mut self.0\n             }\n         }\n \n         // slice references\n-        impl<const LANES: usize> AsRef<[$type]> for $name<LANES> where Self: crate::LanesAtMost64 {\n+        impl<const LANES: usize> AsRef<[$type]> for $name<LANES> where Self: crate::LanesAtMost32 {\n             #[inline]\n             fn as_ref(&self) -> &[$type] {\n                 &self.0\n             }\n         }\n \n-        impl<const LANES: usize> AsMut<[$type]> for $name<LANES> where Self: crate::LanesAtMost64 {\n+        impl<const LANES: usize> AsMut<[$type]> for $name<LANES> where Self: crate::LanesAtMost32 {\n             #[inline]\n             fn as_mut(&mut self) -> &mut [$type] {\n                 &mut self.0\n             }\n         }\n \n         // vector/array conversion\n-        impl<const LANES: usize> From<[$type; LANES]> for $name<LANES> where Self: crate::LanesAtMost64 {\n+        impl<const LANES: usize> From<[$type; LANES]> for $name<LANES> where Self: crate::LanesAtMost32 {\n             fn from(array: [$type; LANES]) -> Self {\n                 Self(array)\n             }\n         }\n \n-        impl <const LANES: usize> From<$name<LANES>> for [$type; LANES] where $name<LANES>: crate::LanesAtMost64 {\n+        impl <const LANES: usize> From<$name<LANES>> for [$type; LANES] where $name<LANES>: crate::LanesAtMost32 {\n             fn from(vector: $name<LANES>) -> Self {\n                 vector.to_array()\n             }"}, {"sha": "faf0c20e922e5391c3388dd577ae0e9dc7161f49", "filename": "crates/core_simd/src/fmt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0682c31fcee752a5530b4f45ba0e726a85654bcd/crates%2Fcore_simd%2Fsrc%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0682c31fcee752a5530b4f45ba0e726a85654bcd/crates%2Fcore_simd%2Fsrc%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Ffmt.rs?ref=0682c31fcee752a5530b4f45ba0e726a85654bcd", "patch": "@@ -35,7 +35,7 @@ macro_rules! impl_fmt_trait {\n             $( // repeat trait\n                 impl<const LANES: usize> core::fmt::$trait for crate::$type<LANES>\n                 where\n-                    Self: crate::LanesAtMost64,\n+                    Self: crate::LanesAtMost32,\n                 {\n                     fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n                         $format(self.as_ref(), f)"}, {"sha": "fafeed6a62a84b8641d5820b818bfd9af3246443", "filename": "crates/core_simd/src/intrinsics.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0682c31fcee752a5530b4f45ba0e726a85654bcd/crates%2Fcore_simd%2Fsrc%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0682c31fcee752a5530b4f45ba0e726a85654bcd/crates%2Fcore_simd%2Fsrc%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fintrinsics.rs?ref=0682c31fcee752a5530b4f45ba0e726a85654bcd", "patch": "@@ -61,7 +61,6 @@ extern \"platform-intrinsic\" {\n     pub(crate) fn simd_shuffle8<T, U>(x: T, y: T, idx: [u32; 8]) -> U;\n     pub(crate) fn simd_shuffle16<T, U>(x: T, y: T, idx: [u32; 16]) -> U;\n     pub(crate) fn simd_shuffle32<T, U>(x: T, y: T, idx: [u32; 32]) -> U;\n-    pub(crate) fn simd_shuffle64<T, U>(x: T, y: T, idx: [u32; 64]) -> U;\n \n     // {s,u}add.sat\n     pub(crate) fn simd_saturating_add<T>(x: T, y: T) -> T;"}, {"sha": "dc0e02c22a262cd0694ce507f0f4058a32d8365a", "filename": "crates/core_simd/src/lanes_at_most_64.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0682c31fcee752a5530b4f45ba0e726a85654bcd/crates%2Fcore_simd%2Fsrc%2Flanes_at_most_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0682c31fcee752a5530b4f45ba0e726a85654bcd/crates%2Fcore_simd%2Fsrc%2Flanes_at_most_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Flanes_at_most_64.rs?ref=0682c31fcee752a5530b4f45ba0e726a85654bcd", "patch": "@@ -1,15 +1,14 @@\n /// Implemented for bitmask sizes that are supported by the implementation.\n-pub trait LanesAtMost64 {}\n+pub trait LanesAtMost32 {}\n \n macro_rules! impl_for {\n     { $name:ident } => {\n-        impl LanesAtMost64 for $name<1> {}\n-        impl LanesAtMost64 for $name<2> {}\n-        impl LanesAtMost64 for $name<4> {}\n-        impl LanesAtMost64 for $name<8> {}\n-        impl LanesAtMost64 for $name<16> {}\n-        impl LanesAtMost64 for $name<32> {}\n-        impl LanesAtMost64 for $name<64> {}\n+        impl LanesAtMost32 for $name<1> {}\n+        impl LanesAtMost32 for $name<2> {}\n+        impl LanesAtMost32 for $name<4> {}\n+        impl LanesAtMost32 for $name<8> {}\n+        impl LanesAtMost32 for $name<16> {}\n+        impl LanesAtMost32 for $name<32> {}\n     }\n }\n "}, {"sha": "906ee3f06ae54034c68cbfdb780fc4865fa2d472", "filename": "crates/core_simd/src/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0682c31fcee752a5530b4f45ba0e726a85654bcd/crates%2Fcore_simd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0682c31fcee752a5530b4f45ba0e726a85654bcd/crates%2Fcore_simd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Flib.rs?ref=0682c31fcee752a5530b4f45ba0e726a85654bcd", "patch": "@@ -12,6 +12,7 @@ mod permute;\n #[macro_use]\n mod transmute;\n \n+mod comparisons;\n mod fmt;\n mod intrinsics;\n mod ops;\n@@ -20,7 +21,7 @@ mod round;\n mod math;\n \n mod lanes_at_most_64;\n-pub use lanes_at_most_64::LanesAtMost64;\n+pub use lanes_at_most_64::LanesAtMost32;\n \n mod masks;\n pub use masks::*;"}, {"sha": "d7400699fde8da3db3ce56aaf5a459a5a4ea30de", "filename": "crates/core_simd/src/masks/bitmask.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/0682c31fcee752a5530b4f45ba0e726a85654bcd/crates%2Fcore_simd%2Fsrc%2Fmasks%2Fbitmask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0682c31fcee752a5530b4f45ba0e726a85654bcd/crates%2Fcore_simd%2Fsrc%2Fmasks%2Fbitmask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fmasks%2Fbitmask.rs?ref=0682c31fcee752a5530b4f45ba0e726a85654bcd", "patch": "@@ -1,15 +1,15 @@\n-use crate::LanesAtMost64;\n+use crate::LanesAtMost32;\n \n /// A mask where each lane is represented by a single bit.\n #[derive(Copy, Clone, Debug)]\n #[repr(transparent)]\n pub struct BitMask<const LANES: usize>(u64)\n where\n-    BitMask<LANES>: LanesAtMost64;\n+    BitMask<LANES>: LanesAtMost32;\n \n impl<const LANES: usize> BitMask<LANES>\n where\n-    Self: LanesAtMost64,\n+    Self: LanesAtMost32,\n {\n     /// Construct a mask by setting all lanes to the given value.\n     pub fn splat(value: bool) -> Self {\n@@ -43,7 +43,7 @@ where\n \n impl<const LANES: usize> core::ops::BitAnd for BitMask<LANES>\n where\n-    Self: LanesAtMost64,\n+    Self: LanesAtMost32,\n {\n     type Output = Self;\n     #[inline]\n@@ -54,7 +54,7 @@ where\n \n impl<const LANES: usize> core::ops::BitAnd<bool> for BitMask<LANES>\n where\n-    Self: LanesAtMost64,\n+    Self: LanesAtMost32,\n {\n     type Output = Self;\n     #[inline]\n@@ -65,7 +65,7 @@ where\n \n impl<const LANES: usize> core::ops::BitAnd<BitMask<LANES>> for bool\n where\n-    BitMask<LANES>: LanesAtMost64,\n+    BitMask<LANES>: LanesAtMost32,\n {\n     type Output = BitMask<LANES>;\n     #[inline]\n@@ -76,7 +76,7 @@ where\n \n impl<const LANES: usize> core::ops::BitOr for BitMask<LANES>\n where\n-    Self: LanesAtMost64,\n+    Self: LanesAtMost32,\n {\n     type Output = Self;\n     #[inline]\n@@ -87,7 +87,7 @@ where\n \n impl<const LANES: usize> core::ops::BitOr<bool> for BitMask<LANES>\n where\n-    Self: LanesAtMost64,\n+    Self: LanesAtMost32,\n {\n     type Output = Self;\n     #[inline]\n@@ -98,7 +98,7 @@ where\n \n impl<const LANES: usize> core::ops::BitOr<BitMask<LANES>> for bool\n where\n-    BitMask<LANES>: LanesAtMost64,\n+    BitMask<LANES>: LanesAtMost32,\n {\n     type Output = BitMask<LANES>;\n     #[inline]\n@@ -109,7 +109,7 @@ where\n \n impl<const LANES: usize> core::ops::BitXor for BitMask<LANES>\n where\n-    Self: LanesAtMost64,\n+    Self: LanesAtMost32,\n {\n     type Output = Self;\n     #[inline]\n@@ -120,7 +120,7 @@ where\n \n impl<const LANES: usize> core::ops::BitXor<bool> for BitMask<LANES>\n where\n-    Self: LanesAtMost64,\n+    Self: LanesAtMost32,\n {\n     type Output = Self;\n     #[inline]\n@@ -131,7 +131,7 @@ where\n \n impl<const LANES: usize> core::ops::BitXor<BitMask<LANES>> for bool\n where\n-    BitMask<LANES>: LanesAtMost64,\n+    BitMask<LANES>: LanesAtMost32,\n {\n     type Output = BitMask<LANES>;\n     #[inline]\n@@ -142,7 +142,7 @@ where\n \n impl<const LANES: usize> core::ops::Not for BitMask<LANES>\n where\n-    Self: LanesAtMost64,\n+    Self: LanesAtMost32,\n {\n     type Output = BitMask<LANES>;\n     #[inline]\n@@ -153,7 +153,7 @@ where\n \n impl<const LANES: usize> core::ops::BitAndAssign for BitMask<LANES>\n where\n-    Self: LanesAtMost64,\n+    Self: LanesAtMost32,\n {\n     #[inline]\n     fn bitand_assign(&mut self, rhs: Self) {\n@@ -163,7 +163,7 @@ where\n \n impl<const LANES: usize> core::ops::BitAndAssign<bool> for BitMask<LANES>\n where\n-    Self: LanesAtMost64,\n+    Self: LanesAtMost32,\n {\n     #[inline]\n     fn bitand_assign(&mut self, rhs: bool) {\n@@ -173,7 +173,7 @@ where\n \n impl<const LANES: usize> core::ops::BitOrAssign for BitMask<LANES>\n where\n-    Self: LanesAtMost64,\n+    Self: LanesAtMost32,\n {\n     #[inline]\n     fn bitor_assign(&mut self, rhs: Self) {\n@@ -183,7 +183,7 @@ where\n \n impl<const LANES: usize> core::ops::BitOrAssign<bool> for BitMask<LANES>\n where\n-    Self: LanesAtMost64,\n+    Self: LanesAtMost32,\n {\n     #[inline]\n     fn bitor_assign(&mut self, rhs: bool) {\n@@ -193,7 +193,7 @@ where\n \n impl<const LANES: usize> core::ops::BitXorAssign for BitMask<LANES>\n where\n-    Self: LanesAtMost64,\n+    Self: LanesAtMost32,\n {\n     #[inline]\n     fn bitxor_assign(&mut self, rhs: Self) {\n@@ -203,7 +203,7 @@ where\n \n impl<const LANES: usize> core::ops::BitXorAssign<bool> for BitMask<LANES>\n where\n-    Self: LanesAtMost64,\n+    Self: LanesAtMost32,\n {\n     #[inline]\n     fn bitxor_assign(&mut self, rhs: bool) {"}, {"sha": "cca077b14d04a12ae44274e34f1ca3e258f8e805", "filename": "crates/core_simd/src/masks/full_masks.rs", "status": "modified", "additions": 51, "deletions": 32, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/0682c31fcee752a5530b4f45ba0e726a85654bcd/crates%2Fcore_simd%2Fsrc%2Fmasks%2Ffull_masks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0682c31fcee752a5530b4f45ba0e726a85654bcd/crates%2Fcore_simd%2Fsrc%2Fmasks%2Ffull_masks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fmasks%2Ffull_masks.rs?ref=0682c31fcee752a5530b4f45ba0e726a85654bcd", "patch": "@@ -20,16 +20,16 @@ macro_rules! define_mask {\n         #[repr(transparent)]\n         pub struct $name<const $lanes: usize>($type)\n         where\n-            $type: crate::LanesAtMost64;\n+            $type: crate::LanesAtMost32;\n \n         impl<const LANES: usize> Copy for $name<LANES>\n         where\n-            $type: crate::LanesAtMost64,\n+            $type: crate::LanesAtMost32,\n         {}\n \n         impl<const LANES: usize> Clone for $name<LANES>\n         where\n-            $type: crate::LanesAtMost64,\n+            $type: crate::LanesAtMost32,\n         {\n             #[inline]\n             fn clone(&self) -> Self {\n@@ -39,7 +39,7 @@ macro_rules! define_mask {\n \n         impl<const $lanes: usize> $name<$lanes>\n         where\n-            $type: crate::LanesAtMost64,\n+            $type: crate::LanesAtMost32,\n         {\n             /// Construct a mask by setting all lanes to the given value.\n             pub fn splat(value: bool) -> Self {\n@@ -75,11 +75,30 @@ macro_rules! define_mask {\n                     0\n                 }\n             }\n+\n+            /// Creates a mask from an integer vector.\n+            ///\n+            /// # Safety\n+            /// All lanes must be either 0 or -1.\n+            #[inline]\n+            pub unsafe fn from_int_unchecked(value: $type) -> Self {\n+                Self(value)\n+            }\n+\n+            /// Creates a mask from an integer vector.\n+            ///\n+            /// # Panics\n+            /// Panics if any lane is not 0 or -1.\n+            #[inline]\n+            pub fn from_int(value: $type) -> Self {\n+                use core::convert::TryInto;\n+                value.try_into().unwrap()\n+            }\n         }\n \n         impl<const $lanes: usize> core::convert::From<bool> for $name<$lanes>\n         where\n-            $type: crate::LanesAtMost64,\n+            $type: crate::LanesAtMost32,\n         {\n             fn from(value: bool) -> Self {\n                 Self::splat(value)\n@@ -88,7 +107,7 @@ macro_rules! define_mask {\n \n         impl<const $lanes: usize> core::convert::TryFrom<$type> for $name<$lanes>\n         where\n-            $type: crate::LanesAtMost64,\n+            $type: crate::LanesAtMost32,\n         {\n             type Error = TryFromMaskError;\n             fn try_from(value: $type) -> Result<Self, Self::Error> {\n@@ -102,7 +121,7 @@ macro_rules! define_mask {\n \n         impl<const $lanes: usize> core::convert::From<$name<$lanes>> for $type\n         where\n-            $type: crate::LanesAtMost64,\n+            $type: crate::LanesAtMost32,\n         {\n             fn from(value: $name<$lanes>) -> Self {\n                 value.0\n@@ -111,8 +130,8 @@ macro_rules! define_mask {\n \n         impl<const $lanes: usize> core::convert::From<crate::BitMask<$lanes>> for $name<$lanes>\n         where\n-            $type: crate::LanesAtMost64,\n-            crate::BitMask<$lanes>: crate::LanesAtMost64,\n+            $type: crate::LanesAtMost32,\n+            crate::BitMask<$lanes>: crate::LanesAtMost32,\n         {\n             fn from(value: crate::BitMask<$lanes>) -> Self {\n                 // TODO use an intrinsic to do this efficiently (with LLVM's sext instruction)\n@@ -126,8 +145,8 @@ macro_rules! define_mask {\n \n         impl<const $lanes: usize> core::convert::From<$name<$lanes>> for crate::BitMask<$lanes>\n         where\n-            $type: crate::LanesAtMost64,\n-            crate::BitMask<$lanes>: crate::LanesAtMost64,\n+            $type: crate::LanesAtMost32,\n+            crate::BitMask<$lanes>: crate::LanesAtMost32,\n         {\n             fn from(value: $name<$lanes>) -> Self {\n                 // TODO use an intrinsic to do this efficiently (with LLVM's trunc instruction)\n@@ -141,7 +160,7 @@ macro_rules! define_mask {\n \n         impl<const $lanes: usize> core::fmt::Debug for $name<$lanes>\n         where\n-            $type: crate::LanesAtMost64,\n+            $type: crate::LanesAtMost32,\n         {\n             fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n                 f.debug_list()\n@@ -152,7 +171,7 @@ macro_rules! define_mask {\n \n         impl<const $lanes: usize> core::fmt::Binary for $name<$lanes>\n         where\n-            $type: crate::LanesAtMost64,\n+            $type: crate::LanesAtMost32,\n         {\n             fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n                 core::fmt::Binary::fmt(&self.0, f)\n@@ -161,7 +180,7 @@ macro_rules! define_mask {\n \n         impl<const $lanes: usize> core::fmt::Octal for $name<$lanes>\n         where\n-            $type: crate::LanesAtMost64,\n+            $type: crate::LanesAtMost32,\n         {\n             fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n                 core::fmt::Octal::fmt(&self.0, f)\n@@ -170,7 +189,7 @@ macro_rules! define_mask {\n \n         impl<const $lanes: usize> core::fmt::LowerHex for $name<$lanes>\n         where\n-            $type: crate::LanesAtMost64,\n+            $type: crate::LanesAtMost32,\n         {\n             fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n                 core::fmt::LowerHex::fmt(&self.0, f)\n@@ -179,7 +198,7 @@ macro_rules! define_mask {\n \n         impl<const $lanes: usize> core::fmt::UpperHex for $name<$lanes>\n         where\n-            $type: crate::LanesAtMost64,\n+            $type: crate::LanesAtMost32,\n         {\n             fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n                 core::fmt::UpperHex::fmt(&self.0, f)\n@@ -188,7 +207,7 @@ macro_rules! define_mask {\n \n         impl<const LANES: usize> core::ops::BitAnd for $name<LANES>\n         where\n-            $type: crate::LanesAtMost64,\n+            $type: crate::LanesAtMost32,\n         {\n             type Output = Self;\n             #[inline]\n@@ -199,7 +218,7 @@ macro_rules! define_mask {\n \n         impl<const LANES: usize> core::ops::BitAnd<bool> for $name<LANES>\n         where\n-            $type: crate::LanesAtMost64,\n+            $type: crate::LanesAtMost32,\n         {\n             type Output = Self;\n             #[inline]\n@@ -210,7 +229,7 @@ macro_rules! define_mask {\n \n         impl<const LANES: usize> core::ops::BitAnd<$name<LANES>> for bool\n         where\n-            $type: crate::LanesAtMost64,\n+            $type: crate::LanesAtMost32,\n         {\n             type Output = $name<LANES>;\n             #[inline]\n@@ -221,7 +240,7 @@ macro_rules! define_mask {\n \n         impl<const LANES: usize> core::ops::BitOr for $name<LANES>\n         where\n-            $type: crate::LanesAtMost64,\n+            $type: crate::LanesAtMost32,\n         {\n             type Output = Self;\n             #[inline]\n@@ -232,7 +251,7 @@ macro_rules! define_mask {\n \n         impl<const LANES: usize> core::ops::BitOr<bool> for $name<LANES>\n         where\n-            $type: crate::LanesAtMost64,\n+            $type: crate::LanesAtMost32,\n         {\n             type Output = Self;\n             #[inline]\n@@ -243,7 +262,7 @@ macro_rules! define_mask {\n \n         impl<const LANES: usize> core::ops::BitOr<$name<LANES>> for bool\n         where\n-            $type: crate::LanesAtMost64,\n+            $type: crate::LanesAtMost32,\n         {\n             type Output = $name<LANES>;\n             #[inline]\n@@ -254,7 +273,7 @@ macro_rules! define_mask {\n \n         impl<const LANES: usize> core::ops::BitXor for $name<LANES>\n         where\n-            $type: crate::LanesAtMost64,\n+            $type: crate::LanesAtMost32,\n         {\n             type Output = Self;\n             #[inline]\n@@ -265,7 +284,7 @@ macro_rules! define_mask {\n \n         impl<const LANES: usize> core::ops::BitXor<bool> for $name<LANES>\n         where\n-            $type: crate::LanesAtMost64,\n+            $type: crate::LanesAtMost32,\n         {\n             type Output = Self;\n             #[inline]\n@@ -276,7 +295,7 @@ macro_rules! define_mask {\n \n         impl<const LANES: usize> core::ops::BitXor<$name<LANES>> for bool\n         where\n-            $type: crate::LanesAtMost64,\n+            $type: crate::LanesAtMost32,\n         {\n             type Output = $name<LANES>;\n             #[inline]\n@@ -287,7 +306,7 @@ macro_rules! define_mask {\n \n         impl<const LANES: usize> core::ops::Not for $name<LANES>\n         where\n-            $type: crate::LanesAtMost64,\n+            $type: crate::LanesAtMost32,\n         {\n             type Output = $name<LANES>;\n             #[inline]\n@@ -298,7 +317,7 @@ macro_rules! define_mask {\n \n         impl<const LANES: usize> core::ops::BitAndAssign for $name<LANES>\n         where\n-            $type: crate::LanesAtMost64,\n+            $type: crate::LanesAtMost32,\n         {\n             #[inline]\n             fn bitand_assign(&mut self, rhs: Self) {\n@@ -308,7 +327,7 @@ macro_rules! define_mask {\n \n         impl<const LANES: usize> core::ops::BitAndAssign<bool> for $name<LANES>\n         where\n-            $type: crate::LanesAtMost64,\n+            $type: crate::LanesAtMost32,\n         {\n             #[inline]\n             fn bitand_assign(&mut self, rhs: bool) {\n@@ -318,7 +337,7 @@ macro_rules! define_mask {\n \n         impl<const LANES: usize> core::ops::BitOrAssign for $name<LANES>\n         where\n-            $type: crate::LanesAtMost64,\n+            $type: crate::LanesAtMost32,\n         {\n             #[inline]\n             fn bitor_assign(&mut self, rhs: Self) {\n@@ -328,7 +347,7 @@ macro_rules! define_mask {\n \n         impl<const LANES: usize> core::ops::BitOrAssign<bool> for $name<LANES>\n         where\n-            $type: crate::LanesAtMost64,\n+            $type: crate::LanesAtMost32,\n         {\n             #[inline]\n             fn bitor_assign(&mut self, rhs: bool) {\n@@ -338,7 +357,7 @@ macro_rules! define_mask {\n \n         impl<const LANES: usize> core::ops::BitXorAssign for $name<LANES>\n         where\n-            $type: crate::LanesAtMost64,\n+            $type: crate::LanesAtMost32,\n         {\n             #[inline]\n             fn bitxor_assign(&mut self, rhs: Self) {\n@@ -348,7 +367,7 @@ macro_rules! define_mask {\n \n         impl<const LANES: usize> core::ops::BitXorAssign<bool> for $name<LANES>\n         where\n-            $type: crate::LanesAtMost64,\n+            $type: crate::LanesAtMost32,\n         {\n             #[inline]\n             fn bitxor_assign(&mut self, rhs: bool) {"}, {"sha": "0b986aaf7e17bafc122067d342636e25db793bdf", "filename": "crates/core_simd/src/masks/mod.rs", "status": "modified", "additions": 66, "deletions": 98, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/0682c31fcee752a5530b4f45ba0e726a85654bcd/crates%2Fcore_simd%2Fsrc%2Fmasks%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0682c31fcee752a5530b4f45ba0e726a85654bcd/crates%2Fcore_simd%2Fsrc%2Fmasks%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fmasks%2Fmod.rs?ref=0682c31fcee752a5530b4f45ba0e726a85654bcd", "patch": "@@ -7,7 +7,7 @@ pub use full_masks::*;\n mod bitmask;\n pub use bitmask::*;\n \n-use crate::LanesAtMost64;\n+use crate::LanesAtMost32;\n \n macro_rules! define_opaque_mask {\n     {\n@@ -17,17 +17,39 @@ macro_rules! define_opaque_mask {\n     } => {\n         $(#[$attr])*\n         #[allow(non_camel_case_types)]\n-        pub struct $name<const $lanes: usize>($inner_ty) where $bits_ty: LanesAtMost64;\n+        pub struct $name<const $lanes: usize>($inner_ty) where $bits_ty: LanesAtMost32;\n \n         impl<const $lanes: usize> $name<$lanes>\n         where\n-            $bits_ty: LanesAtMost64\n+            $bits_ty: LanesAtMost32\n         {\n             /// Construct a mask by setting all lanes to the given value.\n             pub fn splat(value: bool) -> Self {\n                 Self(<$inner_ty>::splat(value))\n             }\n \n+            /// Converts an array to a SIMD vector.\n+            pub fn from_array(array: [bool; LANES]) -> Self {\n+                let mut vector = Self::splat(false);\n+                let mut i = 0;\n+                while i < $lanes {\n+                    vector.set(i, array[i]);\n+                    i += 1;\n+                }\n+                vector\n+            }\n+\n+            /// Converts a SIMD vector to an array.\n+            pub fn to_array(self) -> [bool; LANES] {\n+                let mut array = [false; LANES];\n+                let mut i = 0;\n+                while i < $lanes {\n+                    array[i] = self.test(i);\n+                    i += 1;\n+                }\n+                array\n+            }\n+\n             /// Tests the value of the specified lane.\n             ///\n             /// # Panics\n@@ -49,8 +71,8 @@ macro_rules! define_opaque_mask {\n \n         impl<const $lanes: usize> From<BitMask<$lanes>> for $name<$lanes>\n         where\n-            $bits_ty: LanesAtMost64,\n-            BitMask<$lanes>: LanesAtMost64,\n+            $bits_ty: LanesAtMost32,\n+            BitMask<$lanes>: LanesAtMost32,\n         {\n             fn from(value: BitMask<$lanes>) -> Self {\n                 Self(value.into())\n@@ -59,8 +81,8 @@ macro_rules! define_opaque_mask {\n \n         impl<const $lanes: usize> From<$name<$lanes>> for crate::BitMask<$lanes>\n         where\n-            $bits_ty: LanesAtMost64,\n-            BitMask<$lanes>: LanesAtMost64,\n+            $bits_ty: LanesAtMost32,\n+            BitMask<$lanes>: LanesAtMost32,\n         {\n             fn from(value: $name<$lanes>) -> Self {\n                 value.0.into()\n@@ -69,7 +91,7 @@ macro_rules! define_opaque_mask {\n \n         impl<const $lanes: usize> From<$inner_ty> for $name<$lanes>\n         where\n-            $bits_ty: LanesAtMost64,\n+            $bits_ty: LanesAtMost32,\n         {\n             fn from(value: $inner_ty) -> Self {\n                 Self(value)\n@@ -78,22 +100,35 @@ macro_rules! define_opaque_mask {\n \n         impl<const $lanes: usize> From<$name<$lanes>> for $inner_ty\n         where\n-            $bits_ty: LanesAtMost64,\n+            $bits_ty: LanesAtMost32,\n         {\n             fn from(value: $name<$lanes>) -> Self {\n                 value.0\n             }\n         }\n \n+        // vector/array conversion\n+        impl<const $lanes: usize> From<[bool; $lanes]> for $name<$lanes> where $bits_ty: crate::LanesAtMost32 {\n+            fn from(array: [bool; $lanes]) -> Self {\n+                Self::from_array(array)\n+            }\n+        }\n+\n+        impl <const $lanes: usize> From<$name<$lanes>> for [bool; $lanes] where $bits_ty: crate::LanesAtMost32 {\n+            fn from(vector: $name<$lanes>) -> Self {\n+                vector.to_array()\n+            }\n+        }\n+\n         impl<const $lanes: usize> Copy for $name<$lanes>\n         where\n             $inner_ty: Copy,\n-            $bits_ty: LanesAtMost64,\n+            $bits_ty: LanesAtMost32,\n         {}\n \n         impl<const $lanes: usize> Clone for $name<$lanes>\n         where\n-            $bits_ty: LanesAtMost64,\n+            $bits_ty: LanesAtMost32,\n         {\n             #[inline]\n             fn clone(&self) -> Self {\n@@ -103,7 +138,7 @@ macro_rules! define_opaque_mask {\n \n         impl<const $lanes: usize> Default for $name<$lanes>\n         where\n-            $bits_ty: LanesAtMost64,\n+            $bits_ty: LanesAtMost32,\n         {\n             #[inline]\n             fn default() -> Self {\n@@ -113,7 +148,7 @@ macro_rules! define_opaque_mask {\n \n         impl<const $lanes: usize> PartialEq for $name<$lanes>\n         where\n-            $bits_ty: LanesAtMost64,\n+            $bits_ty: LanesAtMost32,\n         {\n             #[inline]\n             fn eq(&self, other: &Self) -> bool {\n@@ -123,7 +158,7 @@ macro_rules! define_opaque_mask {\n \n         impl<const $lanes: usize> PartialOrd for $name<$lanes>\n         where\n-            $bits_ty: LanesAtMost64,\n+            $bits_ty: LanesAtMost32,\n         {\n             #[inline]\n             fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {\n@@ -133,7 +168,7 @@ macro_rules! define_opaque_mask {\n \n         impl<const $lanes: usize> core::fmt::Debug for $name<$lanes>\n         where\n-            $bits_ty: LanesAtMost64,\n+            $bits_ty: LanesAtMost32,\n         {\n             fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n                 core::fmt::Debug::fmt(&self.0, f)\n@@ -142,7 +177,7 @@ macro_rules! define_opaque_mask {\n \n         impl<const LANES: usize> core::ops::BitAnd for $name<LANES>\n         where\n-            $bits_ty: LanesAtMost64,\n+            $bits_ty: LanesAtMost32,\n         {\n             type Output = Self;\n             #[inline]\n@@ -153,7 +188,7 @@ macro_rules! define_opaque_mask {\n \n         impl<const LANES: usize> core::ops::BitAnd<bool> for $name<LANES>\n         where\n-            $bits_ty: LanesAtMost64,\n+            $bits_ty: LanesAtMost32,\n         {\n             type Output = Self;\n             #[inline]\n@@ -164,7 +199,7 @@ macro_rules! define_opaque_mask {\n \n         impl<const LANES: usize> core::ops::BitAnd<$name<LANES>> for bool\n         where\n-            $bits_ty: LanesAtMost64,\n+            $bits_ty: LanesAtMost32,\n         {\n             type Output = $name<LANES>;\n             #[inline]\n@@ -175,7 +210,7 @@ macro_rules! define_opaque_mask {\n \n         impl<const LANES: usize> core::ops::BitOr for $name<LANES>\n         where\n-            $bits_ty: LanesAtMost64,\n+            $bits_ty: LanesAtMost32,\n         {\n             type Output = Self;\n             #[inline]\n@@ -186,7 +221,7 @@ macro_rules! define_opaque_mask {\n \n         impl<const LANES: usize> core::ops::BitOr<bool> for $name<LANES>\n         where\n-            $bits_ty: LanesAtMost64,\n+            $bits_ty: LanesAtMost32,\n         {\n             type Output = Self;\n             #[inline]\n@@ -197,7 +232,7 @@ macro_rules! define_opaque_mask {\n \n         impl<const LANES: usize> core::ops::BitOr<$name<LANES>> for bool\n         where\n-            $bits_ty: LanesAtMost64,\n+            $bits_ty: LanesAtMost32,\n         {\n             type Output = $name<LANES>;\n             #[inline]\n@@ -208,7 +243,7 @@ macro_rules! define_opaque_mask {\n \n         impl<const LANES: usize> core::ops::BitXor for $name<LANES>\n         where\n-            $bits_ty: LanesAtMost64,\n+            $bits_ty: LanesAtMost32,\n         {\n             type Output = Self;\n             #[inline]\n@@ -219,7 +254,7 @@ macro_rules! define_opaque_mask {\n \n         impl<const LANES: usize> core::ops::BitXor<bool> for $name<LANES>\n         where\n-            $bits_ty: LanesAtMost64,\n+            $bits_ty: LanesAtMost32,\n         {\n             type Output = Self;\n             #[inline]\n@@ -230,7 +265,7 @@ macro_rules! define_opaque_mask {\n \n         impl<const LANES: usize> core::ops::BitXor<$name<LANES>> for bool\n         where\n-            $bits_ty: LanesAtMost64,\n+            $bits_ty: LanesAtMost32,\n         {\n             type Output = $name<LANES>;\n             #[inline]\n@@ -241,7 +276,7 @@ macro_rules! define_opaque_mask {\n \n         impl<const LANES: usize> core::ops::Not for $name<LANES>\n         where\n-            $bits_ty: LanesAtMost64,\n+            $bits_ty: LanesAtMost32,\n         {\n             type Output = $name<LANES>;\n             #[inline]\n@@ -252,7 +287,7 @@ macro_rules! define_opaque_mask {\n \n         impl<const LANES: usize> core::ops::BitAndAssign for $name<LANES>\n         where\n-            $bits_ty: LanesAtMost64,\n+            $bits_ty: LanesAtMost32,\n         {\n             #[inline]\n             fn bitand_assign(&mut self, rhs: Self) {\n@@ -262,7 +297,7 @@ macro_rules! define_opaque_mask {\n \n         impl<const LANES: usize> core::ops::BitAndAssign<bool> for $name<LANES>\n         where\n-            $bits_ty: LanesAtMost64,\n+            $bits_ty: LanesAtMost32,\n         {\n             #[inline]\n             fn bitand_assign(&mut self, rhs: bool) {\n@@ -272,7 +307,7 @@ macro_rules! define_opaque_mask {\n \n         impl<const LANES: usize> core::ops::BitOrAssign for $name<LANES>\n         where\n-            $bits_ty: LanesAtMost64,\n+            $bits_ty: LanesAtMost32,\n         {\n             #[inline]\n             fn bitor_assign(&mut self, rhs: Self) {\n@@ -282,7 +317,7 @@ macro_rules! define_opaque_mask {\n \n         impl<const LANES: usize> core::ops::BitOrAssign<bool> for $name<LANES>\n         where\n-            $bits_ty: LanesAtMost64,\n+            $bits_ty: LanesAtMost32,\n         {\n             #[inline]\n             fn bitor_assign(&mut self, rhs: bool) {\n@@ -292,7 +327,7 @@ macro_rules! define_opaque_mask {\n \n         impl<const LANES: usize> core::ops::BitXorAssign for $name<LANES>\n         where\n-            $bits_ty: LanesAtMost64,\n+            $bits_ty: LanesAtMost32,\n         {\n             #[inline]\n             fn bitxor_assign(&mut self, rhs: Self) {\n@@ -302,7 +337,7 @@ macro_rules! define_opaque_mask {\n \n         impl<const LANES: usize> core::ops::BitXorAssign<bool> for $name<LANES>\n         where\n-            $bits_ty: LanesAtMost64,\n+            $bits_ty: LanesAtMost32,\n         {\n             #[inline]\n             fn bitxor_assign(&mut self, rhs: bool) {\n@@ -360,73 +395,6 @@ define_opaque_mask! {\n     @bits crate::SimdIsize<LANES>\n }\n \n-macro_rules! implement_mask_ops {\n-    { $($vector:ident => $mask:ident ($inner_ty:ident),)* } => {\n-        $(\n-            impl<const LANES: usize> crate::$vector<LANES>\n-            where\n-                crate::$vector<LANES>: LanesAtMost64,\n-                crate::$inner_ty<LANES>: LanesAtMost64,\n-            {\n-                /// Test if each lane is equal to the corresponding lane in `other`.\n-                #[inline]\n-                pub fn lanes_eq(&self, other: &Self) -> $mask<LANES> {\n-                    unsafe { $mask(crate::intrinsics::simd_eq(self, other)) }\n-                }\n-\n-                /// Test if each lane is not equal to the corresponding lane in `other`.\n-                #[inline]\n-                pub fn lanes_ne(&self, other: &Self) -> $mask<LANES> {\n-                    unsafe { $mask(crate::intrinsics::simd_ne(self, other)) }\n-                }\n-\n-                /// Test if each lane is less than the corresponding lane in `other`.\n-                #[inline]\n-                pub fn lanes_lt(&self, other: &Self) -> $mask<LANES> {\n-                    unsafe { $mask(crate::intrinsics::simd_lt(self, other)) }\n-                }\n-\n-                /// Test if each lane is greater than the corresponding lane in `other`.\n-                #[inline]\n-                pub fn lanes_gt(&self, other: &Self) -> $mask<LANES> {\n-                    unsafe { $mask(crate::intrinsics::simd_gt(self, other)) }\n-                }\n-\n-                /// Test if each lane is less than or equal to the corresponding lane in `other`.\n-                #[inline]\n-                pub fn lanes_le(&self, other: &Self) -> $mask<LANES> {\n-                    unsafe { $mask(crate::intrinsics::simd_le(self, other)) }\n-                }\n-\n-                /// Test if each lane is greater than or equal to the corresponding lane in `other`.\n-                #[inline]\n-                pub fn lanes_ge(&self, other: &Self) -> $mask<LANES> {\n-                    unsafe { $mask(crate::intrinsics::simd_ge(self, other)) }\n-                }\n-            }\n-        )*\n-    }\n-}\n-\n-implement_mask_ops! {\n-    SimdI8 => Mask8 (SimdI8),\n-    SimdI16 => Mask16 (SimdI16),\n-    SimdI32 => Mask32 (SimdI32),\n-    SimdI64 => Mask64 (SimdI64),\n-    SimdI128 => Mask128 (SimdI128),\n-    SimdIsize => MaskSize (SimdIsize),\n-\n-    SimdU8 => Mask8 (SimdI8),\n-    SimdU16 => Mask16 (SimdI16),\n-    SimdU32 => Mask32 (SimdI32),\n-    SimdU64 => Mask64 (SimdI64),\n-    SimdU128 => Mask128 (SimdI128),\n-    SimdUsize => MaskSize (SimdIsize),\n-\n-    SimdF32 => Mask32 (SimdI32),\n-    SimdF64 => Mask64 (SimdI64),\n-}\n-\n /// Vector of eight 8-bit masks\n pub type mask8x8 = Mask8<8>;\n "}, {"sha": "23ff83f11a1c04eb32e380e0cec52c592fe24cac", "filename": "crates/core_simd/src/math.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0682c31fcee752a5530b4f45ba0e726a85654bcd/crates%2Fcore_simd%2Fsrc%2Fmath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0682c31fcee752a5530b4f45ba0e726a85654bcd/crates%2Fcore_simd%2Fsrc%2Fmath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fmath.rs?ref=0682c31fcee752a5530b4f45ba0e726a85654bcd", "patch": "@@ -1,6 +1,6 @@\n macro_rules! impl_uint_arith {\n     ($(($name:ident, $n:ty)),+) => {\n-        $( impl<const LANES: usize> $name<LANES> where Self: crate::LanesAtMost64 {\n+        $( impl<const LANES: usize> $name<LANES> where Self: crate::LanesAtMost32 {\n \n             /// Lanewise saturating add.\n             ///\n@@ -42,7 +42,7 @@ macro_rules! impl_uint_arith {\n \n macro_rules! impl_int_arith {\n     ($(($name:ident, $n:ty)),+) => {\n-        $( impl<const LANES: usize> $name<LANES> where Self: crate::LanesAtMost64 {\n+        $( impl<const LANES: usize> $name<LANES> where Self: crate::LanesAtMost32 {\n \n             /// Lanewise saturating add.\n             ///"}, {"sha": "12d675a064093eac2f136f04acdd66c7d3e7f640", "filename": "crates/core_simd/src/ops.rs", "status": "modified", "additions": 42, "deletions": 42, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/0682c31fcee752a5530b4f45ba0e726a85654bcd/crates%2Fcore_simd%2Fsrc%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0682c31fcee752a5530b4f45ba0e726a85654bcd/crates%2Fcore_simd%2Fsrc%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fops.rs?ref=0682c31fcee752a5530b4f45ba0e726a85654bcd", "patch": "@@ -1,4 +1,4 @@\n-use crate::LanesAtMost64;\n+use crate::LanesAtMost32;\n \n /// Checks if the right-hand side argument of a left- or right-shift would cause overflow.\n fn invalid_shift_rhs<T>(rhs: T) -> bool\n@@ -16,7 +16,7 @@ macro_rules! impl_ref_ops {\n     {\n         impl<const $lanes:ident: usize> core::ops::$trait:ident<$rhs:ty> for $type:ty\n         where\n-            $($bound:path: LanesAtMost64,)*\n+            $($bound:path: LanesAtMost32,)*\n         {\n             type Output = $output:ty;\n \n@@ -26,7 +26,7 @@ macro_rules! impl_ref_ops {\n     } => {\n         impl<const $lanes: usize> core::ops::$trait<$rhs> for $type\n         where\n-            $($bound: LanesAtMost64,)*\n+            $($bound: LanesAtMost32,)*\n         {\n             type Output = $output;\n \n@@ -36,7 +36,7 @@ macro_rules! impl_ref_ops {\n \n         impl<const $lanes: usize> core::ops::$trait<&'_ $rhs> for $type\n         where\n-            $($bound: LanesAtMost64,)*\n+            $($bound: LanesAtMost32,)*\n         {\n             type Output = <$type as core::ops::$trait<$rhs>>::Output;\n \n@@ -48,7 +48,7 @@ macro_rules! impl_ref_ops {\n \n         impl<const $lanes: usize> core::ops::$trait<$rhs> for &'_ $type\n         where\n-            $($bound: LanesAtMost64,)*\n+            $($bound: LanesAtMost32,)*\n         {\n             type Output = <$type as core::ops::$trait<$rhs>>::Output;\n \n@@ -60,7 +60,7 @@ macro_rules! impl_ref_ops {\n \n         impl<const $lanes: usize> core::ops::$trait<&'_ $rhs> for &'_ $type\n         where\n-            $($bound: LanesAtMost64,)*\n+            $($bound: LanesAtMost32,)*\n         {\n             type Output = <$type as core::ops::$trait<$rhs>>::Output;\n \n@@ -75,23 +75,23 @@ macro_rules! impl_ref_ops {\n     {\n         impl<const $lanes:ident: usize> core::ops::$trait:ident<$rhs:ty> for $type:ty\n         where\n-            $($bound:path: LanesAtMost64,)*\n+            $($bound:path: LanesAtMost32,)*\n         {\n             $(#[$attrs:meta])*\n             fn $fn:ident(&mut $self_tok:ident, $rhs_arg:ident: $rhs_arg_ty:ty) $body:tt\n         }\n     } => {\n         impl<const $lanes: usize> core::ops::$trait<$rhs> for $type\n         where\n-            $($bound: LanesAtMost64,)*\n+            $($bound: LanesAtMost32,)*\n         {\n             $(#[$attrs])*\n             fn $fn(&mut $self_tok, $rhs_arg: $rhs_arg_ty) $body\n         }\n \n         impl<const $lanes: usize> core::ops::$trait<&'_ $rhs> for $type\n         where\n-            $($bound: LanesAtMost64,)*\n+            $($bound: LanesAtMost32,)*\n         {\n             $(#[$attrs])*\n             fn $fn(&mut $self_tok, $rhs_arg: &$rhs_arg_ty) {\n@@ -104,23 +104,23 @@ macro_rules! impl_ref_ops {\n     {\n         impl<const $lanes:ident: usize> core::ops::$trait:ident for $type:ty\n         where\n-            $($bound:path: LanesAtMost64,)*\n+            $($bound:path: LanesAtMost32,)*\n         {\n             type Output = $output:ty;\n             fn $fn:ident($self_tok:ident) -> Self::Output $body:tt\n         }\n     } => {\n         impl<const $lanes: usize> core::ops::$trait for $type\n         where\n-            $($bound: LanesAtMost64,)*\n+            $($bound: LanesAtMost32,)*\n         {\n             type Output = $output;\n             fn $fn($self_tok) -> Self::Output $body\n         }\n \n         impl<const $lanes: usize> core::ops::$trait for &'_ $type\n         where\n-            $($bound: LanesAtMost64,)*\n+            $($bound: LanesAtMost32,)*\n         {\n             type Output = <$type as core::ops::$trait>::Output;\n             fn $fn($self_tok) -> Self::Output {\n@@ -167,7 +167,7 @@ macro_rules! impl_op {\n         impl_ref_ops! {\n             impl<const LANES: usize> core::ops::Not for crate::$type<LANES>\n             where\n-                crate::$type<LANES>: LanesAtMost64,\n+                crate::$type<LANES>: LanesAtMost32,\n             {\n                 type Output = Self;\n                 fn not(self) -> Self::Output {\n@@ -181,7 +181,7 @@ macro_rules! impl_op {\n         impl_ref_ops! {\n             impl<const LANES: usize> core::ops::Neg for crate::$type<LANES>\n             where\n-                crate::$type<LANES>: LanesAtMost64,\n+                crate::$type<LANES>: LanesAtMost32,\n             {\n                 type Output = Self;\n                 fn neg(self) -> Self::Output {\n@@ -195,9 +195,9 @@ macro_rules! impl_op {\n         impl_ref_ops! {\n             impl<const LANES: usize> core::ops::Neg for crate::$type<LANES>\n             where\n-                crate::$type<LANES>: LanesAtMost64,\n-                crate::SimdU32<LANES>: LanesAtMost64,\n-                crate::SimdU64<LANES>: LanesAtMost64,\n+                crate::$type<LANES>: LanesAtMost32,\n+                crate::SimdU32<LANES>: LanesAtMost32,\n+                crate::SimdU64<LANES>: LanesAtMost32,\n             {\n                 type Output = Self;\n                 fn neg(self) -> Self::Output {\n@@ -212,7 +212,7 @@ macro_rules! impl_op {\n     { impl Index for $type:ident, $scalar:ty } => {\n         impl<I, const LANES: usize> core::ops::Index<I> for crate::$type<LANES>\n         where\n-            Self: LanesAtMost64,\n+            Self: LanesAtMost32,\n             I: core::slice::SliceIndex<[$scalar]>,\n         {\n             type Output = I::Output;\n@@ -224,7 +224,7 @@ macro_rules! impl_op {\n \n         impl<I, const LANES: usize> core::ops::IndexMut<I> for crate::$type<LANES>\n         where\n-            Self: LanesAtMost64,\n+            Self: LanesAtMost32,\n             I: core::slice::SliceIndex<[$scalar]>,\n         {\n             fn index_mut(&mut self, index: I) -> &mut Self::Output {\n@@ -239,7 +239,7 @@ macro_rules! impl_op {\n         impl_ref_ops! {\n             impl<const LANES: usize> core::ops::$trait<Self> for crate::$type<LANES>\n             where\n-                crate::$type<LANES>: LanesAtMost64,\n+                crate::$type<LANES>: LanesAtMost32,\n             {\n                 type Output = Self;\n \n@@ -255,7 +255,7 @@ macro_rules! impl_op {\n         impl_ref_ops! {\n             impl<const LANES: usize> core::ops::$trait<$scalar> for crate::$type<LANES>\n             where\n-                crate::$type<LANES>: LanesAtMost64,\n+                crate::$type<LANES>: LanesAtMost32,\n             {\n                 type Output = Self;\n \n@@ -269,7 +269,7 @@ macro_rules! impl_op {\n         impl_ref_ops! {\n             impl<const LANES: usize> core::ops::$trait<crate::$type<LANES>> for $scalar\n             where\n-                crate::$type<LANES>: LanesAtMost64,\n+                crate::$type<LANES>: LanesAtMost32,\n             {\n                 type Output = crate::$type<LANES>;\n \n@@ -283,7 +283,7 @@ macro_rules! impl_op {\n         impl_ref_ops! {\n             impl<const LANES: usize> core::ops::$assign_trait<Self> for crate::$type<LANES>\n             where\n-                crate::$type<LANES>: LanesAtMost64,\n+                crate::$type<LANES>: LanesAtMost32,\n             {\n                 #[inline]\n                 fn $assign_trait_fn(&mut self, rhs: Self) {\n@@ -297,7 +297,7 @@ macro_rules! impl_op {\n         impl_ref_ops! {\n             impl<const LANES: usize> core::ops::$assign_trait<$scalar> for crate::$type<LANES>\n             where\n-                crate::$type<LANES>: LanesAtMost64,\n+                crate::$type<LANES>: LanesAtMost32,\n             {\n                 #[inline]\n                 fn $assign_trait_fn(&mut self, rhs: $scalar) {\n@@ -343,7 +343,7 @@ macro_rules! impl_unsigned_int_ops {\n                 impl_ref_ops! {\n                     impl<const LANES: usize> core::ops::Div<Self> for crate::$vector<LANES>\n                     where\n-                        crate::$vector<LANES>: LanesAtMost64,\n+                        crate::$vector<LANES>: LanesAtMost32,\n                     {\n                         type Output = Self;\n \n@@ -371,7 +371,7 @@ macro_rules! impl_unsigned_int_ops {\n                 impl_ref_ops! {\n                     impl<const LANES: usize> core::ops::Div<$scalar> for crate::$vector<LANES>\n                     where\n-                        crate::$vector<LANES>: LanesAtMost64,\n+                        crate::$vector<LANES>: LanesAtMost32,\n                     {\n                         type Output = Self;\n \n@@ -394,7 +394,7 @@ macro_rules! impl_unsigned_int_ops {\n                 impl_ref_ops! {\n                     impl<const LANES: usize> core::ops::Div<crate::$vector<LANES>> for $scalar\n                     where\n-                        crate::$vector<LANES>: LanesAtMost64,\n+                        crate::$vector<LANES>: LanesAtMost32,\n                     {\n                         type Output = crate::$vector<LANES>;\n \n@@ -408,7 +408,7 @@ macro_rules! impl_unsigned_int_ops {\n                 impl_ref_ops! {\n                     impl<const LANES: usize> core::ops::DivAssign<Self> for crate::$vector<LANES>\n                     where\n-                        crate::$vector<LANES>: LanesAtMost64,\n+                        crate::$vector<LANES>: LanesAtMost32,\n                     {\n                         #[inline]\n                         fn div_assign(&mut self, rhs: Self) {\n@@ -420,7 +420,7 @@ macro_rules! impl_unsigned_int_ops {\n                 impl_ref_ops! {\n                     impl<const LANES: usize> core::ops::DivAssign<$scalar> for crate::$vector<LANES>\n                     where\n-                        crate::$vector<LANES>: LanesAtMost64,\n+                        crate::$vector<LANES>: LanesAtMost32,\n                     {\n                         #[inline]\n                         fn div_assign(&mut self, rhs: $scalar) {\n@@ -433,7 +433,7 @@ macro_rules! impl_unsigned_int_ops {\n                 impl_ref_ops! {\n                     impl<const LANES: usize> core::ops::Rem<Self> for crate::$vector<LANES>\n                     where\n-                        crate::$vector<LANES>: LanesAtMost64,\n+                        crate::$vector<LANES>: LanesAtMost32,\n                     {\n                         type Output = Self;\n \n@@ -461,7 +461,7 @@ macro_rules! impl_unsigned_int_ops {\n                 impl_ref_ops! {\n                     impl<const LANES: usize> core::ops::Rem<$scalar> for crate::$vector<LANES>\n                     where\n-                        crate::$vector<LANES>: LanesAtMost64,\n+                        crate::$vector<LANES>: LanesAtMost32,\n                     {\n                         type Output = Self;\n \n@@ -484,7 +484,7 @@ macro_rules! impl_unsigned_int_ops {\n                 impl_ref_ops! {\n                     impl<const LANES: usize> core::ops::Rem<crate::$vector<LANES>> for $scalar\n                     where\n-                        crate::$vector<LANES>: LanesAtMost64,\n+                        crate::$vector<LANES>: LanesAtMost32,\n                     {\n                         type Output = crate::$vector<LANES>;\n \n@@ -498,7 +498,7 @@ macro_rules! impl_unsigned_int_ops {\n                 impl_ref_ops! {\n                     impl<const LANES: usize> core::ops::RemAssign<Self> for crate::$vector<LANES>\n                     where\n-                        crate::$vector<LANES>: LanesAtMost64,\n+                        crate::$vector<LANES>: LanesAtMost32,\n                     {\n                         #[inline]\n                         fn rem_assign(&mut self, rhs: Self) {\n@@ -510,7 +510,7 @@ macro_rules! impl_unsigned_int_ops {\n                 impl_ref_ops! {\n                     impl<const LANES: usize> core::ops::RemAssign<$scalar> for crate::$vector<LANES>\n                     where\n-                        crate::$vector<LANES>: LanesAtMost64,\n+                        crate::$vector<LANES>: LanesAtMost32,\n                     {\n                         #[inline]\n                         fn rem_assign(&mut self, rhs: $scalar) {\n@@ -523,7 +523,7 @@ macro_rules! impl_unsigned_int_ops {\n                 impl_ref_ops! {\n                     impl<const LANES: usize> core::ops::Shl<Self> for crate::$vector<LANES>\n                     where\n-                        crate::$vector<LANES>: LanesAtMost64,\n+                        crate::$vector<LANES>: LanesAtMost32,\n                     {\n                         type Output = Self;\n \n@@ -545,7 +545,7 @@ macro_rules! impl_unsigned_int_ops {\n                 impl_ref_ops! {\n                     impl<const LANES: usize> core::ops::Shl<$scalar> for crate::$vector<LANES>\n                     where\n-                        crate::$vector<LANES>: LanesAtMost64,\n+                        crate::$vector<LANES>: LanesAtMost32,\n                     {\n                         type Output = Self;\n \n@@ -564,7 +564,7 @@ macro_rules! impl_unsigned_int_ops {\n                 impl_ref_ops! {\n                     impl<const LANES: usize> core::ops::ShlAssign<Self> for crate::$vector<LANES>\n                     where\n-                        crate::$vector<LANES>: LanesAtMost64,\n+                        crate::$vector<LANES>: LanesAtMost32,\n                     {\n                         #[inline]\n                         fn shl_assign(&mut self, rhs: Self) {\n@@ -576,7 +576,7 @@ macro_rules! impl_unsigned_int_ops {\n                 impl_ref_ops! {\n                     impl<const LANES: usize> core::ops::ShlAssign<$scalar> for crate::$vector<LANES>\n                     where\n-                        crate::$vector<LANES>: LanesAtMost64,\n+                        crate::$vector<LANES>: LanesAtMost32,\n                     {\n                         #[inline]\n                         fn shl_assign(&mut self, rhs: $scalar) {\n@@ -588,7 +588,7 @@ macro_rules! impl_unsigned_int_ops {\n                 impl_ref_ops! {\n                     impl<const LANES: usize> core::ops::Shr<Self> for crate::$vector<LANES>\n                     where\n-                        crate::$vector<LANES>: LanesAtMost64,\n+                        crate::$vector<LANES>: LanesAtMost32,\n                     {\n                         type Output = Self;\n \n@@ -610,7 +610,7 @@ macro_rules! impl_unsigned_int_ops {\n                 impl_ref_ops! {\n                     impl<const LANES: usize> core::ops::Shr<$scalar> for crate::$vector<LANES>\n                     where\n-                        crate::$vector<LANES>: LanesAtMost64,\n+                        crate::$vector<LANES>: LanesAtMost32,\n                     {\n                         type Output = Self;\n \n@@ -629,7 +629,7 @@ macro_rules! impl_unsigned_int_ops {\n                 impl_ref_ops! {\n                     impl<const LANES: usize> core::ops::ShrAssign<Self> for crate::$vector<LANES>\n                     where\n-                        crate::$vector<LANES>: LanesAtMost64,\n+                        crate::$vector<LANES>: LanesAtMost32,\n                     {\n                         #[inline]\n                         fn shr_assign(&mut self, rhs: Self) {\n@@ -641,7 +641,7 @@ macro_rules! impl_unsigned_int_ops {\n                 impl_ref_ops! {\n                     impl<const LANES: usize> core::ops::ShrAssign<$scalar> for crate::$vector<LANES>\n                     where\n-                        crate::$vector<LANES>: LanesAtMost64,\n+                        crate::$vector<LANES>: LanesAtMost32,\n                     {\n                         #[inline]\n                         fn shr_assign(&mut self, rhs: $scalar) {"}, {"sha": "b27b0a9e1412f0781ab96b3e62858223efb1cbb8", "filename": "crates/core_simd/src/permute.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0682c31fcee752a5530b4f45ba0e726a85654bcd/crates%2Fcore_simd%2Fsrc%2Fpermute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0682c31fcee752a5530b4f45ba0e726a85654bcd/crates%2Fcore_simd%2Fsrc%2Fpermute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fpermute.rs?ref=0682c31fcee752a5530b4f45ba0e726a85654bcd", "patch": "@@ -24,6 +24,5 @@ macro_rules! impl_shuffle_2pow_lanes {\n         impl_shuffle_lane!{ $name, simd_shuffle8, 8 }\n         impl_shuffle_lane!{ $name, simd_shuffle16, 16 }\n         impl_shuffle_lane!{ $name, simd_shuffle32, 32 }\n-        impl_shuffle_lane!{ $name, simd_shuffle64, 64 }\n     }\n }"}, {"sha": "ccad1aad9c44493a891194c73b3a2cc5577302c3", "filename": "crates/core_simd/src/round.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0682c31fcee752a5530b4f45ba0e726a85654bcd/crates%2Fcore_simd%2Fsrc%2Fround.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0682c31fcee752a5530b4f45ba0e726a85654bcd/crates%2Fcore_simd%2Fsrc%2Fround.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fround.rs?ref=0682c31fcee752a5530b4f45ba0e726a85654bcd", "patch": "@@ -4,7 +4,7 @@ macro_rules! implement {\n     } => {\n         impl<const LANES: usize> crate::$type<LANES>\n         where\n-            Self: crate::LanesAtMost64,\n+            Self: crate::LanesAtMost32,\n         {\n             /// Returns the largest integer less than or equal to each lane.\n             #[cfg(feature = \"std\")]\n@@ -25,8 +25,8 @@ macro_rules! implement {\n \n         impl<const LANES: usize> crate::$type<LANES>\n         where\n-            Self: crate::LanesAtMost64,\n-            crate::$int_type<LANES>: crate::LanesAtMost64,\n+            Self: crate::LanesAtMost32,\n+            crate::$int_type<LANES>: crate::LanesAtMost32,\n         {\n             /// Rounds toward zero and converts to the same-width integer type, assuming that\n             /// the value is finite and fits in that type."}, {"sha": "393e39023d9c1937b453bf888ec5b35839cb507e", "filename": "crates/core_simd/src/vector/float.rs", "status": "modified", "additions": 60, "deletions": 8, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/0682c31fcee752a5530b4f45ba0e726a85654bcd/crates%2Fcore_simd%2Fsrc%2Fvector%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0682c31fcee752a5530b4f45ba0e726a85654bcd/crates%2Fcore_simd%2Fsrc%2Fvector%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvector%2Ffloat.rs?ref=0682c31fcee752a5530b4f45ba0e726a85654bcd", "patch": "@@ -4,13 +4,13 @@\n /// `$lanes` of float `$type`, which uses `$bits_ty` as its binary\n /// representation. Called from `define_float_vector!`.\n macro_rules! impl_float_vector {\n-    { $name:ident, $type:ty, $bits_ty:ident } => {\n+    { $name:ident, $type:ty, $bits_ty:ident, $mask_ty:ident, $mask_impl_ty:ident } => {\n         impl_vector! { $name, $type }\n \n         impl<const LANES: usize> $name<LANES>\n         where\n-            Self: crate::LanesAtMost64,\n-            crate::$bits_ty<LANES>: crate::LanesAtMost64,\n+            Self: crate::LanesAtMost32,\n+            crate::$bits_ty<LANES>: crate::LanesAtMost32,\n         {\n             /// Raw transmutation to an unsigned integer vector type with the\n             /// same size and number of lanes.\n@@ -36,17 +36,69 @@ macro_rules! impl_float_vector {\n                 Self::from_bits(self.to_bits() & no_sign)\n             }\n         }\n+\n+        impl<const LANES: usize> $name<LANES>\n+        where\n+            Self: crate::LanesAtMost32,\n+            crate::$bits_ty<LANES>: crate::LanesAtMost32,\n+            crate::$mask_impl_ty<LANES>: crate::LanesAtMost32,\n+        {\n+            /// Returns true for each lane if it has a positive sign, including\n+            /// `+0.0`, `NaN`s with positive sign bit and positive infinity.\n+            #[inline]\n+            pub fn is_sign_positive(self) -> crate::$mask_ty<LANES> {\n+                !self.is_sign_negative()\n+            }\n+\n+            /// Returns true for each lane if it has a negative sign, including\n+            /// `-0.0`, `NaN`s with negative sign bit and negative infinity.\n+            #[inline]\n+            pub fn is_sign_negative(self) -> crate::$mask_ty<LANES> {\n+                let sign_bits = self.to_bits() & crate::$bits_ty::splat((!0 >> 1) + 1);\n+                sign_bits.lanes_gt(crate::$bits_ty::splat(0))\n+            }\n+\n+            /// Returns true for each lane if its value is `NaN`.\n+            #[inline]\n+            pub fn is_nan(self) -> crate::$mask_ty<LANES> {\n+                self.lanes_ne(self)\n+            }\n+\n+            /// Returns true for each lane if its value is positive infinity or negative infinity.\n+            #[inline]\n+            pub fn is_infinite(self) -> crate::$mask_ty<LANES> {\n+                self.abs().lanes_eq(Self::splat(<$type>::INFINITY))\n+            }\n+\n+            /// Returns true for each lane if its value is neither infinite nor `NaN`.\n+            #[inline]\n+            pub fn is_finite(self) -> crate::$mask_ty<LANES> {\n+                self.abs().lanes_lt(Self::splat(<$type>::INFINITY))\n+            }\n+\n+            /// Returns true for each lane if its value is subnormal.\n+            #[inline]\n+            pub fn is_subnormal(self) -> crate::$mask_ty<LANES> {\n+                self.abs().lanes_ne(Self::splat(0.0)) & (self.to_bits() & Self::splat(<$type>::INFINITY).to_bits()).lanes_eq(crate::$bits_ty::splat(0))\n+            }\n+\n+            /// Returns true for each lane if its value is neither neither zero, infinite,\n+            /// subnormal, or `NaN`.\n+            #[inline]\n+            pub fn is_normal(self) -> crate::$mask_ty<LANES> {\n+                !(self.abs().lanes_eq(Self::splat(0.0)) | self.is_nan() | self.is_subnormal() | self.is_infinite())\n+            }\n+        }\n     };\n }\n \n-\n /// A SIMD vector of containing `LANES` `f32` values.\n #[repr(simd)]\n pub struct SimdF32<const LANES: usize>([f32; LANES])\n where\n-    Self: crate::LanesAtMost64;\n+    Self: crate::LanesAtMost32;\n \n-impl_float_vector! { SimdF32, f32, SimdU32 }\n+impl_float_vector! { SimdF32, f32, SimdU32, Mask32, SimdI32 }\n \n from_transmute_x86! { unsafe f32x4 => __m128 }\n from_transmute_x86! { unsafe f32x8 => __m256 }\n@@ -56,9 +108,9 @@ from_transmute_x86! { unsafe f32x8 => __m256 }\n #[repr(simd)]\n pub struct SimdF64<const LANES: usize>([f64; LANES])\n where\n-    Self: crate::LanesAtMost64;\n+    Self: crate::LanesAtMost32;\n \n-impl_float_vector! { SimdF64, f64, SimdU64 }\n+impl_float_vector! { SimdF64, f64, SimdU64, Mask64, SimdI64 }\n \n from_transmute_x86! { unsafe f64x2 => __m128d }\n from_transmute_x86! { unsafe f64x4 => __m256d }"}, {"sha": "5304d11cd6eaf351daf59801448641c9babf0aa7", "filename": "crates/core_simd/src/vector/int.rs", "status": "modified", "additions": 32, "deletions": 16, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/0682c31fcee752a5530b4f45ba0e726a85654bcd/crates%2Fcore_simd%2Fsrc%2Fvector%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0682c31fcee752a5530b4f45ba0e726a85654bcd/crates%2Fcore_simd%2Fsrc%2Fvector%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvector%2Fint.rs?ref=0682c31fcee752a5530b4f45ba0e726a85654bcd", "patch": "@@ -2,20 +2,20 @@\n \n /// Implements additional integer traits (Eq, Ord, Hash) on the specified vector `$name`, holding multiple `$lanes` of `$type`.\n macro_rules! impl_integer_vector {\n-    { $name:ident, $type:ty } => {\n+    { $name:ident, $type:ty, $mask_ty:ident, $mask_impl_ty:ident } => {\n         impl_vector! { $name, $type }\n \n-        impl<const LANES: usize> Eq for $name<LANES> where Self: crate::LanesAtMost64 {}\n+        impl<const LANES: usize> Eq for $name<LANES> where Self: crate::LanesAtMost32 {}\n \n-        impl<const LANES: usize> Ord for $name<LANES> where Self: crate::LanesAtMost64 {\n+        impl<const LANES: usize> Ord for $name<LANES> where Self: crate::LanesAtMost32 {\n             #[inline]\n             fn cmp(&self, other: &Self) -> core::cmp::Ordering {\n                 // TODO use SIMD cmp\n                 self.to_array().cmp(other.as_ref())\n             }\n         }\n \n-        impl<const LANES: usize> core::hash::Hash for $name<LANES> where Self: crate::LanesAtMost64 {\n+        impl<const LANES: usize> core::hash::Hash for $name<LANES> where Self: crate::LanesAtMost32 {\n             #[inline]\n             fn hash<H>(&self, state: &mut H)\n             where\n@@ -24,16 +24,32 @@ macro_rules! impl_integer_vector {\n                 self.as_slice().hash(state)\n             }\n         }\n+\n+        impl<const LANES: usize> $name<LANES>\n+        where\n+            Self: crate::LanesAtMost32,\n+            crate::$mask_impl_ty<LANES>: crate::LanesAtMost32,\n+        {\n+            /// Returns true for each positive lane and false if it is zero or negative.\n+            pub fn is_positive(self) -> crate::$mask_ty<LANES> {\n+                self.lanes_gt(Self::splat(0))\n+            }\n+\n+            /// Returns true for each negative lane and false if it is zero or positive.\n+            pub fn is_negative(self) -> crate::$mask_ty<LANES> {\n+                self.lanes_lt(Self::splat(0))\n+            }\n+        }\n     }\n }\n \n /// A SIMD vector of containing `LANES` `isize` values.\n #[repr(simd)]\n pub struct SimdIsize<const LANES: usize>([isize; LANES])\n where\n-    Self: crate::LanesAtMost64;\n+    Self: crate::LanesAtMost32;\n \n-impl_integer_vector! { SimdIsize, isize }\n+impl_integer_vector! { SimdIsize, isize, MaskSize, SimdIsize }\n \n #[cfg(target_pointer_width = \"32\")]\n from_transmute_x86! { unsafe isizex4 => __m128i }\n@@ -51,9 +67,9 @@ from_transmute_x86! { unsafe isizex4 => __m256i }\n #[repr(simd)]\n pub struct SimdI128<const LANES: usize>([i128; LANES])\n where\n-    Self: crate::LanesAtMost64;\n+    Self: crate::LanesAtMost32;\n \n-impl_integer_vector! { SimdI128, i128 }\n+impl_integer_vector! { SimdI128, i128, Mask128, SimdI128 }\n \n from_transmute_x86! { unsafe i128x2 => __m256i }\n //from_transmute_x86! { unsafe i128x4 => __m512i }\n@@ -62,9 +78,9 @@ from_transmute_x86! { unsafe i128x2 => __m256i }\n #[repr(simd)]\n pub struct SimdI16<const LANES: usize>([i16; LANES])\n where\n-    Self: crate::LanesAtMost64;\n+    Self: crate::LanesAtMost32;\n \n-impl_integer_vector! { SimdI16, i16 }\n+impl_integer_vector! { SimdI16, i16, Mask16, SimdI16 }\n \n from_transmute_x86! { unsafe i16x8 => __m128i }\n from_transmute_x86! { unsafe i16x16 => __m256i }\n@@ -74,9 +90,9 @@ from_transmute_x86! { unsafe i16x16 => __m256i }\n #[repr(simd)]\n pub struct SimdI32<const LANES: usize>([i32; LANES])\n where\n-    Self: crate::LanesAtMost64;\n+    Self: crate::LanesAtMost32;\n \n-impl_integer_vector! { SimdI32, i32 }\n+impl_integer_vector! { SimdI32, i32, Mask32, SimdI32 }\n \n from_transmute_x86! { unsafe i32x4 => __m128i }\n from_transmute_x86! { unsafe i32x8 => __m256i }\n@@ -86,9 +102,9 @@ from_transmute_x86! { unsafe i32x8 => __m256i }\n #[repr(simd)]\n pub struct SimdI64<const LANES: usize>([i64; LANES])\n where\n-    Self: crate::LanesAtMost64;\n+    Self: crate::LanesAtMost32;\n \n-impl_integer_vector! { SimdI64, i64 }\n+impl_integer_vector! { SimdI64, i64, Mask64, SimdI64 }\n \n from_transmute_x86! { unsafe i64x2 => __m128i }\n from_transmute_x86! { unsafe i64x4 => __m256i }\n@@ -98,9 +114,9 @@ from_transmute_x86! { unsafe i64x4 => __m256i }\n #[repr(simd)]\n pub struct SimdI8<const LANES: usize>([i8; LANES])\n where\n-    Self: crate::LanesAtMost64;\n+    Self: crate::LanesAtMost32;\n \n-impl_integer_vector! { SimdI8, i8 }\n+impl_integer_vector! { SimdI8, i8, Mask8, SimdI8 }\n \n from_transmute_x86! { unsafe i8x16 => __m128i }\n from_transmute_x86! { unsafe i8x32 => __m256i }"}, {"sha": "71b5b295112a8f041682ec8a1470584ff7d8d0ba", "filename": "crates/core_simd/src/vector/uint.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0682c31fcee752a5530b4f45ba0e726a85654bcd/crates%2Fcore_simd%2Fsrc%2Fvector%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0682c31fcee752a5530b4f45ba0e726a85654bcd/crates%2Fcore_simd%2Fsrc%2Fvector%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvector%2Fuint.rs?ref=0682c31fcee752a5530b4f45ba0e726a85654bcd", "patch": "@@ -6,17 +6,17 @@ macro_rules! impl_unsigned_vector {\n     { $name:ident, $type:ty } => {\n         impl_vector! { $name, $type }\n \n-        impl<const LANES: usize> Eq for $name<LANES> where Self: crate::LanesAtMost64 {}\n+        impl<const LANES: usize> Eq for $name<LANES> where Self: crate::LanesAtMost32 {}\n \n-        impl<const LANES: usize> Ord for $name<LANES> where Self: crate::LanesAtMost64 {\n+        impl<const LANES: usize> Ord for $name<LANES> where Self: crate::LanesAtMost32 {\n             #[inline]\n             fn cmp(&self, other: &Self) -> core::cmp::Ordering {\n                 // TODO use SIMD cmp\n                 self.to_array().cmp(other.as_ref())\n             }\n         }\n \n-        impl<const LANES: usize> core::hash::Hash for $name<LANES> where Self: crate::LanesAtMost64 {\n+        impl<const LANES: usize> core::hash::Hash for $name<LANES> where Self: crate::LanesAtMost32 {\n             #[inline]\n             fn hash<H>(&self, state: &mut H)\n             where\n@@ -32,7 +32,7 @@ macro_rules! impl_unsigned_vector {\n #[repr(simd)]\n pub struct SimdUsize<const LANES: usize>([usize; LANES])\n where\n-    Self: crate::LanesAtMost64;\n+    Self: crate::LanesAtMost32;\n \n impl_unsigned_vector! { SimdUsize, usize }\n \n@@ -52,7 +52,7 @@ from_transmute_x86! { unsafe usizex4 => __m256i }\n #[repr(simd)]\n pub struct SimdU128<const LANES: usize>([u128; LANES])\n where\n-    Self: crate::LanesAtMost64;\n+    Self: crate::LanesAtMost32;\n \n impl_unsigned_vector! { SimdU128, u128 }\n \n@@ -63,7 +63,7 @@ from_transmute_x86! { unsafe u128x2 => __m256i }\n #[repr(simd)]\n pub struct SimdU16<const LANES: usize>([u16; LANES])\n where\n-    Self: crate::LanesAtMost64;\n+    Self: crate::LanesAtMost32;\n \n impl_unsigned_vector! { SimdU16, u16 }\n \n@@ -75,7 +75,7 @@ from_transmute_x86! { unsafe u16x16 => __m256i }\n #[repr(simd)]\n pub struct SimdU32<const LANES: usize>([u32; LANES])\n where\n-    Self: crate::LanesAtMost64;\n+    Self: crate::LanesAtMost32;\n \n impl_unsigned_vector! { SimdU32, u32 }\n \n@@ -87,7 +87,7 @@ from_transmute_x86! { unsafe u32x8 => __m256i }\n #[repr(simd)]\n pub struct SimdU64<const LANES: usize>([u64; LANES])\n where\n-    Self: crate::LanesAtMost64;\n+    Self: crate::LanesAtMost32;\n \n impl_unsigned_vector! { SimdU64, u64 }\n \n@@ -99,7 +99,7 @@ from_transmute_x86! { unsafe u64x4 => __m256i }\n #[repr(simd)]\n pub struct SimdU8<const LANES: usize>([u8; LANES])\n where\n-    Self: crate::LanesAtMost64;\n+    Self: crate::LanesAtMost32;\n \n impl_unsigned_vector! { SimdU8, u8 }\n "}, {"sha": "048c070a391d545a742c7907da3c4f734f317398", "filename": "crates/core_simd/tests/f32_ops.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0682c31fcee752a5530b4f45ba0e726a85654bcd/crates%2Fcore_simd%2Ftests%2Ff32_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0682c31fcee752a5530b4f45ba0e726a85654bcd/crates%2Fcore_simd%2Ftests%2Ff32_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Ff32_ops.rs?ref=0682c31fcee752a5530b4f45ba0e726a85654bcd", "patch": "@@ -1,3 +1,5 @@\n+#![feature(is_subnormal)]\n+\n #[macro_use]\n mod ops_macros;\n impl_float_tests! { SimdF32, f32, i32 }"}, {"sha": "8f0dd6b7365538e2b64f5455271e53cbe84db3d5", "filename": "crates/core_simd/tests/f64_ops.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0682c31fcee752a5530b4f45ba0e726a85654bcd/crates%2Fcore_simd%2Ftests%2Ff64_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0682c31fcee752a5530b4f45ba0e726a85654bcd/crates%2Fcore_simd%2Ftests%2Ff64_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Ff64_ops.rs?ref=0682c31fcee752a5530b4f45ba0e726a85654bcd", "patch": "@@ -1,3 +1,5 @@\n+#![feature(is_subnormal)]\n+\n #[macro_use]\n mod ops_macros;\n impl_float_tests! { SimdF64, f64, i64 }"}, {"sha": "9c06fbc0411d2fcd266c108ae33f8d41bc1e1895", "filename": "crates/core_simd/tests/mask_ops_impl/mask8.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0682c31fcee752a5530b4f45ba0e726a85654bcd/crates%2Fcore_simd%2Ftests%2Fmask_ops_impl%2Fmask8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0682c31fcee752a5530b4f45ba0e726a85654bcd/crates%2Fcore_simd%2Ftests%2Fmask_ops_impl%2Fmask8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fmask_ops_impl%2Fmask8.rs?ref=0682c31fcee752a5530b4f45ba0e726a85654bcd", "patch": "@@ -1,4 +1,3 @@\n mask_tests! { mask8x8, 8 }\n mask_tests! { mask8x16, 16 }\n mask_tests! { mask8x32, 32 }\n-mask_tests! { mask8x64, 64 }"}, {"sha": "a70a8a9c48b9d0e66ba99481a5bd7c768b794c94", "filename": "crates/core_simd/tests/ops_macros.rs", "status": "modified", "additions": 73, "deletions": 1, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/0682c31fcee752a5530b4f45ba0e726a85654bcd/crates%2Fcore_simd%2Ftests%2Fops_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0682c31fcee752a5530b4f45ba0e726a85654bcd/crates%2Fcore_simd%2Ftests%2Fops_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fops_macros.rs?ref=0682c31fcee752a5530b4f45ba0e726a85654bcd", "patch": "@@ -147,11 +147,27 @@ macro_rules! impl_signed_tests {\n             test_helpers::test_lanes! {\n                 fn neg<const LANES: usize>() {\n                     test_helpers::test_unary_elementwise(\n-                        &<Vector<LANES> as core::ops::Neg>::neg,\n+                        &<Vector::<LANES> as core::ops::Neg>::neg,\n                         &<Scalar as core::ops::Neg>::neg,\n                         &|x| !x.contains(&Scalar::MIN),\n                     );\n                 }\n+\n+                fn is_positive<const LANES: usize>() {\n+                    test_helpers::test_unary_mask_elementwise(\n+                        &Vector::<LANES>::is_positive,\n+                        &Scalar::is_positive,\n+                        &|_| true,\n+                    );\n+                }\n+\n+                fn is_negative<const LANES: usize>() {\n+                    test_helpers::test_unary_mask_elementwise(\n+                        &Vector::<LANES>::is_negative,\n+                        &Scalar::is_negative,\n+                        &|_| true,\n+                    );\n+                }\n             }\n \n             test_helpers::test_lanes_panic! {\n@@ -285,6 +301,62 @@ macro_rules! impl_float_tests {\n             }\n \n             test_helpers::test_lanes! {\n+                fn is_sign_positive<const LANES: usize>() {\n+                    test_helpers::test_unary_mask_elementwise(\n+                        &Vector::<LANES>::is_sign_positive,\n+                        &Scalar::is_sign_positive,\n+                        &|_| true,\n+                    );\n+                }\n+\n+                fn is_sign_negative<const LANES: usize>() {\n+                    test_helpers::test_unary_mask_elementwise(\n+                        &Vector::<LANES>::is_sign_negative,\n+                        &Scalar::is_sign_negative,\n+                        &|_| true,\n+                    );\n+                }\n+\n+                fn is_finite<const LANES: usize>() {\n+                    test_helpers::test_unary_mask_elementwise(\n+                        &Vector::<LANES>::is_finite,\n+                        &Scalar::is_finite,\n+                        &|_| true,\n+                    );\n+                }\n+\n+                fn is_infinite<const LANES: usize>() {\n+                    test_helpers::test_unary_mask_elementwise(\n+                        &Vector::<LANES>::is_infinite,\n+                        &Scalar::is_infinite,\n+                        &|_| true,\n+                    );\n+                }\n+\n+                fn is_nan<const LANES: usize>() {\n+                    test_helpers::test_unary_mask_elementwise(\n+                        &Vector::<LANES>::is_nan,\n+                        &Scalar::is_nan,\n+                        &|_| true,\n+                    );\n+                }\n+\n+                fn is_normal<const LANES: usize>() {\n+                    test_helpers::test_unary_mask_elementwise(\n+                        &Vector::<LANES>::is_normal,\n+                        &Scalar::is_normal,\n+                        &|_| true,\n+                    );\n+                }\n+\n+                fn is_subnormal<const LANES: usize>() {\n+                    test_helpers::test_unary_mask_elementwise(\n+                        &Vector::<LANES>::is_subnormal,\n+                        &Scalar::is_subnormal,\n+                        &|_| true,\n+                    );\n+                }\n+\n                 fn abs<const LANES: usize>() {\n                     test_helpers::test_unary_elementwise(\n                         &Vector::<LANES>::abs,"}, {"sha": "4a41fe3a16ea55ebefaf6f137205e0407ad46a9f", "filename": "crates/test_helpers/src/biteq.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0682c31fcee752a5530b4f45ba0e726a85654bcd/crates%2Ftest_helpers%2Fsrc%2Fbiteq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0682c31fcee752a5530b4f45ba0e726a85654bcd/crates%2Ftest_helpers%2Fsrc%2Fbiteq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest_helpers%2Fsrc%2Fbiteq.rs?ref=0682c31fcee752a5530b4f45ba0e726a85654bcd", "patch": "@@ -5,6 +5,16 @@ pub trait BitEq {\n     fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result;\n }\n \n+impl BitEq for bool {\n+    fn biteq(&self, other: &Self) -> bool {\n+        self == other\n+    }\n+\n+    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n+        write!(f, \"{:?}\", self)\n+    }\n+}\n+\n macro_rules! impl_integer_biteq {\n     { $($type:ty),* } => {\n         $("}, {"sha": "b5bfd96dde85461a8354d7674743995d8e5dbfb5", "filename": "crates/test_helpers/src/lib.rs", "status": "modified", "additions": 58, "deletions": 44, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/0682c31fcee752a5530b4f45ba0e726a85654bcd/crates%2Ftest_helpers%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0682c31fcee752a5530b4f45ba0e726a85654bcd/crates%2Ftest_helpers%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest_helpers%2Fsrc%2Flib.rs?ref=0682c31fcee752a5530b4f45ba0e726a85654bcd", "patch": "@@ -124,6 +124,32 @@ pub fn test_unary_elementwise<Scalar, ScalarResult, Vector, VectorResult, const\n     });\n }\n \n+/// Test a unary vector function against a unary scalar function, applied elementwise.\n+#[inline(never)]\n+pub fn test_unary_mask_elementwise<Scalar, Vector, Mask, const LANES: usize>(\n+    fv: &dyn Fn(Vector) -> Mask,\n+    fs: &dyn Fn(Scalar) -> bool,\n+    check: &dyn Fn([Scalar; LANES]) -> bool,\n+) where\n+    Scalar: Copy + Default + core::fmt::Debug + DefaultStrategy,\n+    Vector: Into<[Scalar; LANES]> + From<[Scalar; LANES]> + Copy,\n+    Mask: Into<[bool; LANES]> + From<[bool; LANES]> + Copy,\n+{\n+    test_1(&|x: [Scalar; LANES]| {\n+        proptest::prop_assume!(check(x));\n+        let result_1: [bool; LANES] = fv(x.into()).into();\n+        let result_2: [bool; LANES] = {\n+            let mut result = [false; LANES];\n+            for (i, o) in x.iter().zip(result.iter_mut()) {\n+                *o = fs(*i);\n+            }\n+            result\n+        };\n+        crate::prop_assert_biteq!(result_1, result_2);\n+        Ok(())\n+    });\n+}\n+\n /// Test a binary vector function against a binary scalar function, applied elementwise.\n #[inline(never)]\n pub fn test_binary_elementwise<\n@@ -243,21 +269,21 @@ macro_rules! test_lanes {\n \n                 fn implementation<const $lanes: usize>()\n                 where\n-                    core_simd::SimdU8<$lanes>: core_simd::LanesAtMost64,\n-                    core_simd::SimdU16<$lanes>: core_simd::LanesAtMost64,\n-                    core_simd::SimdU32<$lanes>: core_simd::LanesAtMost64,\n-                    core_simd::SimdU64<$lanes>: core_simd::LanesAtMost64,\n-                    core_simd::SimdU128<$lanes>: core_simd::LanesAtMost64,\n-                    core_simd::SimdUsize<$lanes>: core_simd::LanesAtMost64,\n-                    core_simd::SimdI8<$lanes>: core_simd::LanesAtMost64,\n-                    core_simd::SimdI16<$lanes>: core_simd::LanesAtMost64,\n-                    core_simd::SimdI32<$lanes>: core_simd::LanesAtMost64,\n-                    core_simd::SimdI64<$lanes>: core_simd::LanesAtMost64,\n-                    core_simd::SimdI128<$lanes>: core_simd::LanesAtMost64,\n-                    core_simd::SimdIsize<$lanes>: core_simd::LanesAtMost64,\n-                    core_simd::SimdF32<$lanes>: core_simd::LanesAtMost64,\n-                    core_simd::SimdF64<$lanes>: core_simd::LanesAtMost64,\n-                    core_simd::BitMask<$lanes>: core_simd::LanesAtMost64,\n+                    core_simd::SimdU8<$lanes>: core_simd::LanesAtMost32,\n+                    core_simd::SimdU16<$lanes>: core_simd::LanesAtMost32,\n+                    core_simd::SimdU32<$lanes>: core_simd::LanesAtMost32,\n+                    core_simd::SimdU64<$lanes>: core_simd::LanesAtMost32,\n+                    core_simd::SimdU128<$lanes>: core_simd::LanesAtMost32,\n+                    core_simd::SimdUsize<$lanes>: core_simd::LanesAtMost32,\n+                    core_simd::SimdI8<$lanes>: core_simd::LanesAtMost32,\n+                    core_simd::SimdI16<$lanes>: core_simd::LanesAtMost32,\n+                    core_simd::SimdI32<$lanes>: core_simd::LanesAtMost32,\n+                    core_simd::SimdI64<$lanes>: core_simd::LanesAtMost32,\n+                    core_simd::SimdI128<$lanes>: core_simd::LanesAtMost32,\n+                    core_simd::SimdIsize<$lanes>: core_simd::LanesAtMost32,\n+                    core_simd::SimdF32<$lanes>: core_simd::LanesAtMost32,\n+                    core_simd::SimdF64<$lanes>: core_simd::LanesAtMost32,\n+                    core_simd::BitMask<$lanes>: core_simd::LanesAtMost32,\n                 $body\n \n                 #[cfg(target_arch = \"wasm32\")]\n@@ -298,16 +324,10 @@ macro_rules! test_lanes {\n                 fn lanes_32() {\n                     implementation::<32>();\n                 }\n-\n-                #[test]\n-                #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test::wasm_bindgen_test)]\n-                fn lanes_64() {\n-                    implementation::<64>();\n-                }\n             }\n         )*\n     }\n-}  \n+}\n \n /// Expand a const-generic `#[should_panic]` test into separate tests for each possible lane count.\n #[macro_export]\n@@ -321,21 +341,21 @@ macro_rules! test_lanes_panic {\n \n                 fn implementation<const $lanes: usize>()\n                 where\n-                    core_simd::SimdU8<$lanes>: core_simd::LanesAtMost64,\n-                    core_simd::SimdU16<$lanes>: core_simd::LanesAtMost64,\n-                    core_simd::SimdU32<$lanes>: core_simd::LanesAtMost64,\n-                    core_simd::SimdU64<$lanes>: core_simd::LanesAtMost64,\n-                    core_simd::SimdU128<$lanes>: core_simd::LanesAtMost64,\n-                    core_simd::SimdUsize<$lanes>: core_simd::LanesAtMost64,\n-                    core_simd::SimdI8<$lanes>: core_simd::LanesAtMost64,\n-                    core_simd::SimdI16<$lanes>: core_simd::LanesAtMost64,\n-                    core_simd::SimdI32<$lanes>: core_simd::LanesAtMost64,\n-                    core_simd::SimdI64<$lanes>: core_simd::LanesAtMost64,\n-                    core_simd::SimdI128<$lanes>: core_simd::LanesAtMost64,\n-                    core_simd::SimdIsize<$lanes>: core_simd::LanesAtMost64,\n-                    core_simd::SimdF32<$lanes>: core_simd::LanesAtMost64,\n-                    core_simd::SimdF64<$lanes>: core_simd::LanesAtMost64,\n-                    core_simd::BitMask<$lanes>: core_simd::LanesAtMost64,\n+                    core_simd::SimdU8<$lanes>: core_simd::LanesAtMost32,\n+                    core_simd::SimdU16<$lanes>: core_simd::LanesAtMost32,\n+                    core_simd::SimdU32<$lanes>: core_simd::LanesAtMost32,\n+                    core_simd::SimdU64<$lanes>: core_simd::LanesAtMost32,\n+                    core_simd::SimdU128<$lanes>: core_simd::LanesAtMost32,\n+                    core_simd::SimdUsize<$lanes>: core_simd::LanesAtMost32,\n+                    core_simd::SimdI8<$lanes>: core_simd::LanesAtMost32,\n+                    core_simd::SimdI16<$lanes>: core_simd::LanesAtMost32,\n+                    core_simd::SimdI32<$lanes>: core_simd::LanesAtMost32,\n+                    core_simd::SimdI64<$lanes>: core_simd::LanesAtMost32,\n+                    core_simd::SimdI128<$lanes>: core_simd::LanesAtMost32,\n+                    core_simd::SimdIsize<$lanes>: core_simd::LanesAtMost32,\n+                    core_simd::SimdF32<$lanes>: core_simd::LanesAtMost32,\n+                    core_simd::SimdF64<$lanes>: core_simd::LanesAtMost32,\n+                    core_simd::BitMask<$lanes>: core_simd::LanesAtMost32,\n                 $body\n \n                 #[test]\n@@ -373,13 +393,7 @@ macro_rules! test_lanes_panic {\n                 fn lanes_32() {\n                     implementation::<32>();\n                 }\n-\n-                #[test]\n-                #[should_panic]\n-                fn lanes_64() {\n-                    implementation::<64>();\n-                }\n             }\n         )*\n     }\n-}  \n+}"}]}