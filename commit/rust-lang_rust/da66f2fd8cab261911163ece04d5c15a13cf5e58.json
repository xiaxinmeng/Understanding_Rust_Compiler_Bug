{"sha": "da66f2fd8cab261911163ece04d5c15a13cf5e58", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRhNjZmMmZkOGNhYjI2MTkxMTE2M2VjZTA0ZDVjMTVhMTNjZjVlNTg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-05-25T16:40:06Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-05-25T16:40:06Z"}, "message": "Auto merge of #33713 - LeoTestard:macro-rules-invalid-lhs, r=pnkfelix\n\nMake sure that macros that didn't pass LHS checking are not expanded.\n\nThis avoid duplicate errors for things like invalid fragment specifiers, or\nparsing errors for ambiguous macros.", "tree": {"sha": "c1ac2626eb06b55e39e806942a73c3c183618020", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c1ac2626eb06b55e39e806942a73c3c183618020"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/da66f2fd8cab261911163ece04d5c15a13cf5e58", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/da66f2fd8cab261911163ece04d5c15a13cf5e58", "html_url": "https://github.com/rust-lang/rust/commit/da66f2fd8cab261911163ece04d5c15a13cf5e58", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/da66f2fd8cab261911163ece04d5c15a13cf5e58/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5229e0efb34f924346febcfe158973486dabdf83", "url": "https://api.github.com/repos/rust-lang/rust/commits/5229e0efb34f924346febcfe158973486dabdf83", "html_url": "https://github.com/rust-lang/rust/commit/5229e0efb34f924346febcfe158973486dabdf83"}, {"sha": "7d521445fd47d8403b63c36b712d0238b62a8771", "url": "https://api.github.com/repos/rust-lang/rust/commits/7d521445fd47d8403b63c36b712d0238b62a8771", "html_url": "https://github.com/rust-lang/rust/commit/7d521445fd47d8403b63c36b712d0238b62a8771"}], "stats": {"total": 142, "additions": 96, "deletions": 46}, "files": [{"sha": "ca5eb8f8003bb8538d2f05904925a8561fc0e8ba", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/da66f2fd8cab261911163ece04d5c15a13cf5e58/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da66f2fd8cab261911163ece04d5c15a13cf5e58/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=da66f2fd8cab261911163ece04d5c15a13cf5e58", "patch": "@@ -549,13 +549,8 @@ pub fn parse_nt<'a>(p: &mut Parser<'a>, sp: Span, name: &str) -> Nonterminal {\n             token::NtPath(Box::new(panictry!(p.parse_path(PathStyle::Type))))\n         },\n         \"meta\" => token::NtMeta(panictry!(p.parse_meta_item())),\n-        _ => {\n-            p.span_fatal_help(sp,\n-                              &format!(\"invalid fragment specifier `{}`\", name),\n-                              \"valid fragment specifiers are `ident`, `block`, \\\n-                               `stmt`, `expr`, `pat`, `ty`, `path`, `meta`, `tt` \\\n-                               and `item`\").emit();\n-            panic!(FatalError);\n-        }\n+        // this is not supposed to happen, since it has been checked\n+        // when compiling the macro.\n+        _ => p.span_bug(sp, \"invalid fragment specifier\")\n     }\n }"}, {"sha": "3522c8863cf52cf9133295f43bfbce613b4a5bde", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 56, "deletions": 37, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/da66f2fd8cab261911163ece04d5c15a13cf5e58/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da66f2fd8cab261911163ece04d5c15a13cf5e58/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=da66f2fd8cab261911163ece04d5c15a13cf5e58", "patch": "@@ -291,17 +291,16 @@ pub fn compile<'cx>(cx: &'cx mut ExtCtxt,\n     let lhses = match **argument_map.get(&lhs_nm.name).unwrap() {\n         MatchedSeq(ref s, _) => {\n             s.iter().map(|m| match **m {\n-                MatchedNonterminal(NtTT(ref tt)) => (**tt).clone(),\n+                MatchedNonterminal(NtTT(ref tt)) => {\n+                    valid &= check_lhs_nt_follows(cx, tt);\n+                    (**tt).clone()\n+                }\n                 _ => cx.span_bug(def.span, \"wrong-structured lhs\")\n             }).collect()\n         }\n         _ => cx.span_bug(def.span, \"wrong-structured lhs\")\n     };\n \n-    for lhs in &lhses {\n-        check_lhs_nt_follows(cx, lhs, def.span);\n-    }\n-\n     let rhses = match **argument_map.get(&rhs_nm.name).unwrap() {\n         MatchedSeq(ref s, _) => {\n             s.iter().map(|m| match **m {\n@@ -330,19 +329,19 @@ pub fn compile<'cx>(cx: &'cx mut ExtCtxt,\n // why is this here? because of https://github.com/rust-lang/rust/issues/27774\n fn ref_slice<A>(s: &A) -> &[A] { use std::slice::from_raw_parts; unsafe { from_raw_parts(s, 1) } }\n \n-fn check_lhs_nt_follows(cx: &mut ExtCtxt, lhs: &TokenTree, sp: Span) {\n+fn check_lhs_nt_follows(cx: &mut ExtCtxt, lhs: &TokenTree) -> bool {\n     // lhs is going to be like TokenTree::Delimited(...), where the\n     // entire lhs is those tts. Or, it can be a \"bare sequence\", not wrapped in parens.\n     match lhs {\n-        &TokenTree::Delimited(_, ref tts) => {\n-            check_matcher(cx, &tts.tts);\n-        },\n-        tt @ &TokenTree::Sequence(..) => {\n-            check_matcher(cx, ref_slice(tt));\n-        },\n-        _ => cx.span_err(sp, \"invalid macro matcher; matchers must be contained \\\n-                              in balanced delimiters or a repetition indicator\")\n-    };\n+        &TokenTree::Delimited(_, ref tts) => check_matcher(cx, &tts.tts),\n+        tt @ &TokenTree::Sequence(..) => check_matcher(cx, ref_slice(tt)),\n+        _ => {\n+            cx.span_err(lhs.get_span(),\n+                        \"invalid macro matcher; matchers must be contained \\\n+                         in balanced delimiters or a repetition indicator\");\n+            false\n+        }\n+    }\n     // we don't abort on errors on rejection, the driver will do that for us\n     // after parsing/expansion. we can report every error in every macro this way.\n }\n@@ -364,28 +363,33 @@ struct OnFail {\n     action: OnFailAction,\n }\n \n-#[derive(Copy, Clone, Debug)]\n+#[derive(Copy, Clone, Debug, PartialEq)]\n enum OnFailAction { Warn, Error, DoNothing }\n \n impl OnFail {\n     fn warn() -> OnFail { OnFail { saw_failure: false, action: OnFailAction::Warn } }\n     fn error() -> OnFail { OnFail { saw_failure: false, action: OnFailAction::Error } }\n     fn do_nothing() -> OnFail { OnFail { saw_failure: false, action: OnFailAction::DoNothing } }\n-    fn react(&mut self, cx: &mut ExtCtxt, sp: Span, msg: &str) {\n+    fn react(&mut self, cx: &mut ExtCtxt, sp: Span, msg: &str, help: Option<&str>) {\n         match self.action {\n             OnFailAction::DoNothing => {}\n-            OnFailAction::Error => cx.span_err(sp, msg),\n+            OnFailAction::Error => {\n+                let mut err = cx.struct_span_err(sp, msg);\n+                if let Some(msg) = help { err.span_help(sp, msg); }\n+                err.emit();\n+            }\n             OnFailAction::Warn => {\n-                cx.struct_span_warn(sp, msg)\n-                    .span_note(sp, \"The above warning will be a hard error in the next release.\")\n+                let mut warn = cx.struct_span_warn(sp, msg);\n+                if let Some(msg) = help { warn.span_help(sp, msg); }\n+                warn.span_note(sp, \"The above warning will be a hard error in the next release.\")\n                     .emit();\n             }\n         };\n         self.saw_failure = true;\n     }\n }\n \n-fn check_matcher(cx: &mut ExtCtxt, matcher: &[TokenTree]) {\n+fn check_matcher(cx: &mut ExtCtxt, matcher: &[TokenTree]) -> bool {\n     // Issue 30450: when we are through a warning cycle, we can just\n     // error on all failure conditions (and remove check_matcher_old).\n \n@@ -400,6 +404,9 @@ fn check_matcher(cx: &mut ExtCtxt, matcher: &[TokenTree]) {\n         OnFail::warn()\n     };\n     check_matcher_new(cx, matcher, &mut on_fail);\n+    // matcher is valid if the new pass didn't see any error,\n+    // or if errors were considered warnings\n+    on_fail.action != OnFailAction::Error || !on_fail.saw_failure\n }\n \n // returns the last token that was checked, for TokenTree::Sequence.\n@@ -435,11 +442,11 @@ fn check_matcher_old<'a, I>(cx: &mut ExtCtxt, matcher: I, follow: &Token, on_fai\n                             // sequence, which may itself be a sequence,\n                             // and so on).\n                             on_fail.react(cx, sp,\n-                                        &format!(\"`${0}:{1}` is followed by a \\\n-                                                  sequence repetition, which is not \\\n-                                                  allowed for `{1}` fragments\",\n-                                                 name, frag_spec)\n-                                        );\n+                                          &format!(\"`${0}:{1}` is followed by a \\\n+                                                    sequence repetition, which is not \\\n+                                                    allowed for `{1}` fragments\",\n+                                                   name, frag_spec),\n+                                          None);\n                             Eof\n                         },\n                         // die next iteration\n@@ -456,8 +463,10 @@ fn check_matcher_old<'a, I>(cx: &mut ExtCtxt, matcher: I, follow: &Token, on_fai\n \n                     // If T' is in the set FOLLOW(NT), continue. Else, reject.\n                     match (&next_token, is_in_follow(cx, &next_token, &frag_spec.name.as_str())) {\n-                        (_, Err(msg)) => {\n-                            on_fail.react(cx, sp, &msg);\n+                        (_, Err((msg, _))) => {\n+                            // no need for help message, those messages\n+                            // are never emitted anyway...\n+                            on_fail.react(cx, sp, &msg, None);\n                             continue\n                         }\n                         (&Eof, _) => return Some((sp, tok.clone())),\n@@ -466,7 +475,7 @@ fn check_matcher_old<'a, I>(cx: &mut ExtCtxt, matcher: I, follow: &Token, on_fai\n                             on_fail.react(cx, sp, &format!(\"`${0}:{1}` is followed by `{2}`, which \\\n                                                       is not allowed for `{1}` fragments\",\n                                                      name, frag_spec,\n-                                                     token_to_string(next)));\n+                                                     token_to_string(next)), None);\n                             continue\n                         },\n                     }\n@@ -494,7 +503,8 @@ fn check_matcher_old<'a, I>(cx: &mut ExtCtxt, matcher: I, follow: &Token, on_fai\n                                         delim.close_token(),\n                                     Some(_) => {\n                                         on_fail.react(cx, sp, \"sequence repetition followed by \\\n-                                                another sequence repetition, which is not allowed\");\n+                                                another sequence repetition, which is not allowed\",\n+                                                      None);\n                                         Eof\n                                     },\n                                     None => Eof\n@@ -514,7 +524,7 @@ fn check_matcher_old<'a, I>(cx: &mut ExtCtxt, matcher: I, follow: &Token, on_fai\n                             Some(&&TokenTree::Delimited(_, ref delim)) => delim.close_token(),\n                             Some(_) => {\n                                 on_fail.react(cx, sp, \"sequence repetition followed by another \\\n-                                             sequence repetition, which is not allowed\");\n+                                             sequence repetition, which is not allowed\", None);\n                                 Eof\n                             },\n                             None => Eof\n@@ -810,7 +820,11 @@ fn check_matcher_core(cx: &mut ExtCtxt,\n             TokenTree::Token(sp, ref tok) => {\n                 let can_be_followed_by_any;\n                 if let Err(bad_frag) = has_legal_fragment_specifier(tok) {\n-                    on_fail.react(cx, sp, &format!(\"invalid fragment specifier `{}`\", bad_frag));\n+                    on_fail.react(cx, sp,\n+                                  &format!(\"invalid fragment specifier `{}`\", bad_frag),\n+                                  Some(\"valid fragment specifiers are `ident`, `block`, \\\n+                                        `stmt`, `expr`, `pat`, `ty`, `path`, `meta`, `tt` \\\n+                                        and `item`\"));\n                     // (This eliminates false positives and duplicates\n                     // from error messages.)\n                     can_be_followed_by_any = true;\n@@ -884,8 +898,8 @@ fn check_matcher_core(cx: &mut ExtCtxt,\n             if let MatchNt(ref name, ref frag_spec) = *t {\n                 for &(sp, ref next_token) in &suffix_first.tokens {\n                     match is_in_follow(cx, next_token, &frag_spec.name.as_str()) {\n-                        Err(msg) => {\n-                            on_fail.react(cx, sp, &msg);\n+                        Err((msg, help)) => {\n+                            on_fail.react(cx, sp, &msg, Some(help));\n                             // don't bother reporting every source of\n                             // conflict for a particular element of `last`.\n                             continue 'each_last;\n@@ -907,7 +921,9 @@ fn check_matcher_core(cx: &mut ExtCtxt,\n                                          name=name,\n                                          frag=frag_spec,\n                                          next=token_to_string(next_token),\n-                                         may_be=may_be));\n+                                         may_be=may_be),\n+                                None\n+                            );\n                         }\n                     }\n                 }\n@@ -978,7 +994,7 @@ fn can_be_followed_by_any(frag: &str) -> bool {\n /// break macros that were relying on that binary operator as a\n /// separator.\n // when changing this do not forget to update doc/book/macros.md!\n-fn is_in_follow(_: &ExtCtxt, tok: &Token, frag: &str) -> Result<bool, String> {\n+fn is_in_follow(_: &ExtCtxt, tok: &Token, frag: &str) -> Result<bool, (String, &'static str)> {\n     if let &CloseDelim(_) = tok {\n         // closing a token tree can never be matched by any fragment;\n         // iow, we always require that `(` and `)` match, etc.\n@@ -1027,7 +1043,10 @@ fn is_in_follow(_: &ExtCtxt, tok: &Token, frag: &str) -> Result<bool, String> {\n                 // harmless\n                 Ok(true)\n             },\n-            _ => Err(format!(\"invalid fragment specifier `{}`\", frag))\n+            _ => Err((format!(\"invalid fragment specifier `{}`\", frag),\n+                     \"valid fragment specifiers are `ident`, `block`, \\\n+                      `stmt`, `expr`, `pat`, `ty`, `path`, `meta`, `tt` \\\n+                      and `item`\"))\n         }\n     }\n }"}, {"sha": "a0ac5d4c7204104237b06da36a47513b8e31d482", "filename": "src/test/compile-fail/invalid-macro-matcher.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da66f2fd8cab261911163ece04d5c15a13cf5e58/src%2Ftest%2Fcompile-fail%2Finvalid-macro-matcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da66f2fd8cab261911163ece04d5c15a13cf5e58/src%2Ftest%2Fcompile-fail%2Finvalid-macro-matcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Finvalid-macro-matcher.rs?ref=da66f2fd8cab261911163ece04d5c15a13cf5e58", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n macro_rules! invalid {\n-    _ => (); //~^ ERROR invalid macro matcher\n+    _ => (); //~ ERROR invalid macro matcher\n }\n \n fn main() {"}, {"sha": "ca6cd664e738516c2db5bd751e8c75b5e6189644", "filename": "src/test/compile-fail/macro-invalid-fragment-spec.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/da66f2fd8cab261911163ece04d5c15a13cf5e58/src%2Ftest%2Fcompile-fail%2Fmacro-invalid-fragment-spec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da66f2fd8cab261911163ece04d5c15a13cf5e58/src%2Ftest%2Fcompile-fail%2Fmacro-invalid-fragment-spec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-invalid-fragment-spec.rs?ref=da66f2fd8cab261911163ece04d5c15a13cf5e58", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+macro_rules! foo(\n+    ($x:foo) => ()\n+    //~^ ERROR invalid fragment specifier\n+    //~| HELP valid fragment specifiers are\n+);\n+\n+fn main() {\n+    foo!(foo);\n+}"}, {"sha": "eed2a207e89ef934a02e3511573bd0568daee11a", "filename": "src/test/compile-fail/macro-missing-delimiters.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/da66f2fd8cab261911163ece04d5c15a13cf5e58/src%2Ftest%2Fcompile-fail%2Fmacro-missing-delimiters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da66f2fd8cab261911163ece04d5c15a13cf5e58/src%2Ftest%2Fcompile-fail%2Fmacro-missing-delimiters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-missing-delimiters.rs?ref=da66f2fd8cab261911163ece04d5c15a13cf5e58", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+macro_rules! baz(\n+    baz => () //~ ERROR invalid macro matcher;\n+);\n+\n+fn main() {\n+    baz!(baz);\n+}"}]}