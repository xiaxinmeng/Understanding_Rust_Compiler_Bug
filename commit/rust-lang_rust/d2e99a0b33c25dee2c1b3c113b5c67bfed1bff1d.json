{"sha": "d2e99a0b33c25dee2c1b3c113b5c67bfed1bff1d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQyZTk5YTBiMzNjMjVkZWUyYzFiM2MxMTNiNWM2N2JmZWQxYmZmMWQ=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-03-20T00:53:57Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-03-21T19:03:13Z"}, "message": "rand: Rewrite OsRng in Rust for windows\n\nThis removes even more rust_builtin.c code, and allows us to more gracefully\nhandle errors (not a process panic, but a task failure).", "tree": {"sha": "48d5cf48c11ef48c1ec892ddc01e837baf8673ee", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/48d5cf48c11ef48c1ec892ddc01e837baf8673ee"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d2e99a0b33c25dee2c1b3c113b5c67bfed1bff1d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d2e99a0b33c25dee2c1b3c113b5c67bfed1bff1d", "html_url": "https://github.com/rust-lang/rust/commit/d2e99a0b33c25dee2c1b3c113b5c67bfed1bff1d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d2e99a0b33c25dee2c1b3c113b5c67bfed1bff1d/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ab1dd09d736fd443883ea4c1d8ec73ff285f6308", "url": "https://api.github.com/repos/rust-lang/rust/commits/ab1dd09d736fd443883ea4c1d8ec73ff285f6308", "html_url": "https://github.com/rust-lang/rust/commit/ab1dd09d736fd443883ea4c1d8ec73ff285f6308"}], "stats": {"total": 267, "additions": 112, "deletions": 155}, "files": [{"sha": "7d9c9e35dfd6e74a73cb09f5f458301336d38886", "filename": "src/librand/os.rs", "status": "modified", "additions": 112, "deletions": 96, "changes": 208, "blob_url": "https://github.com/rust-lang/rust/blob/d2e99a0b33c25dee2c1b3c113b5c67bfed1bff1d/src%2Flibrand%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e99a0b33c25dee2c1b3c113b5c67bfed1bff1d/src%2Flibrand%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fos.rs?ref=d2e99a0b33c25dee2c1b3c113b5c67bfed1bff1d", "patch": "@@ -11,124 +11,140 @@\n //! Interfaces to the operating system provided random number\n //! generators.\n \n-use Rng;\n+pub use self::imp::OSRng;\n \n #[cfg(unix)]\n-use reader::ReaderRng;\n-#[cfg(unix)]\n-use std::io::File;\n-\n-#[cfg(windows)]\n-use std::cast;\n-#[cfg(windows)]\n-use std::libc::{c_long, DWORD, BYTE};\n-#[cfg(windows)]\n-type HCRYPTPROV = c_long;\n-// the extern functions imported from the runtime on Windows are\n-// implemented so that they either succeed or abort(), so we can just\n-// assume they work when we call them.\n-\n-/// A random number generator that retrieves randomness straight from\n-/// the operating system. Platform sources:\n-///\n-/// - Unix-like systems (Linux, Android, Mac OSX): read directly from\n-///   `/dev/urandom`.\n-/// - Windows: calls `CryptGenRandom`, using the default cryptographic\n-///   service provider with the `PROV_RSA_FULL` type.\n-///\n-/// This does not block.\n-#[cfg(unix)]\n-pub struct OSRng {\n-    priv inner: ReaderRng<File>\n-}\n-/// A random number generator that retrieves randomness straight from\n-/// the operating system. Platform sources:\n-///\n-/// - Unix-like systems (Linux, Android, Mac OSX): read directly from\n-///   `/dev/urandom`.\n-/// - Windows: calls `CryptGenRandom`, using the default cryptographic\n-///   service provider with the `PROV_RSA_FULL` type.\n-///\n-/// This does not block.\n-#[cfg(windows)]\n-pub struct OSRng {\n-    priv hcryptprov: HCRYPTPROV\n-}\n-\n-impl OSRng {\n-    /// Create a new `OSRng`.\n+mod imp {\n+    use Rng;\n+    use reader::ReaderRng;\n+    use std::io::File;\n+\n+    /// A random number generator that retrieves randomness straight from\n+    /// the operating system. Platform sources:\n+    ///\n+    /// - Unix-like systems (Linux, Android, Mac OSX): read directly from\n+    ///   `/dev/urandom`.\n+    /// - Windows: calls `CryptGenRandom`, using the default cryptographic\n+    ///   service provider with the `PROV_RSA_FULL` type.\n+    ///\n+    /// This does not block.\n     #[cfg(unix)]\n-    pub fn new() -> OSRng {\n-        let reader = File::open(&Path::new(\"/dev/urandom\"));\n-        let reader = reader.ok().expect(\"Error opening /dev/urandom\");\n-        let reader_rng = ReaderRng::new(reader);\n-\n-        OSRng { inner: reader_rng }\n+    pub struct OSRng {\n+        priv inner: ReaderRng<File>\n     }\n \n-    /// Create a new `OSRng`.\n-    #[cfg(windows)]\n-    pub fn new() -> OSRng {\n-        extern { fn rust_win32_rand_acquire(phProv: *mut HCRYPTPROV); }\n-\n-        let mut hcp = 0;\n-        unsafe {rust_win32_rand_acquire(&mut hcp)};\n+    impl OSRng {\n+        /// Create a new `OSRng`.\n+        pub fn new() -> OSRng {\n+            let reader = File::open(&Path::new(\"/dev/urandom\"));\n+            let reader = reader.ok().expect(\"Error opening /dev/urandom\");\n+            let reader_rng = ReaderRng::new(reader);\n \n-        OSRng { hcryptprov: hcp }\n+            OSRng { inner: reader_rng }\n+        }\n     }\n-}\n \n-#[cfg(unix)]\n-impl Rng for OSRng {\n-    fn next_u32(&mut self) -> u32 {\n-        self.inner.next_u32()\n-    }\n-    fn next_u64(&mut self) -> u64 {\n-        self.inner.next_u64()\n-    }\n-    fn fill_bytes(&mut self, v: &mut [u8]) {\n-        self.inner.fill_bytes(v)\n+    impl Rng for OSRng {\n+        fn next_u32(&mut self) -> u32 {\n+            self.inner.next_u32()\n+        }\n+        fn next_u64(&mut self) -> u64 {\n+            self.inner.next_u64()\n+        }\n+        fn fill_bytes(&mut self, v: &mut [u8]) {\n+            self.inner.fill_bytes(v)\n+        }\n     }\n }\n \n #[cfg(windows)]\n-impl Rng for OSRng {\n-    fn next_u32(&mut self) -> u32 {\n-        let mut v = [0u8, .. 4];\n-        self.fill_bytes(v);\n-        unsafe { cast::transmute(v) }\n-    }\n-    fn next_u64(&mut self) -> u64 {\n-        let mut v = [0u8, .. 8];\n-        self.fill_bytes(v);\n-        unsafe { cast::transmute(v) }\n+mod imp {\n+    use Rng;\n+    use std::cast;\n+    use std::libc::{c_ulong, DWORD, BYTE, LPCSTR, BOOL};\n+    use std::os;\n+\n+    type HCRYPTPROV = c_ulong;\n+\n+    /// A random number generator that retrieves randomness straight from\n+    /// the operating system. Platform sources:\n+    ///\n+    /// - Unix-like systems (Linux, Android, Mac OSX): read directly from\n+    ///   `/dev/urandom`.\n+    /// - Windows: calls `CryptGenRandom`, using the default cryptographic\n+    ///   service provider with the `PROV_RSA_FULL` type.\n+    ///\n+    /// This does not block.\n+    pub struct OSRng {\n+        priv hcryptprov: HCRYPTPROV\n     }\n-    fn fill_bytes(&mut self, v: &mut [u8]) {\n-        extern {\n-            fn rust_win32_rand_gen(hProv: HCRYPTPROV, dwLen: DWORD,\n-                                   pbBuffer: *mut BYTE);\n-        }\n \n-        unsafe {rust_win32_rand_gen(self.hcryptprov, v.len() as DWORD, v.as_mut_ptr())}\n+    static PROV_RSA_FULL: DWORD = 1;\n+    static CRYPT_SILENT: DWORD = 64;\n+    static CRYPT_VERIFYCONTEXT: DWORD = 0xF0000000;\n+\n+    extern \"system\" {\n+        fn CryptAcquireContextA(phProv: *mut HCRYPTPROV,\n+                                pszContainer: LPCSTR,\n+                                pszProvider: LPCSTR,\n+                                dwProvType: DWORD,\n+                                dwFlags: DWORD) -> BOOL;\n+        fn CryptGenRandom(hProv: HCRYPTPROV,\n+                          dwLen: DWORD,\n+                          pbBuffer: *mut BYTE) -> BOOL;\n+        fn CryptReleaseContext(hProv: HCRYPTPROV, dwFlags: DWORD) -> BOOL;\n     }\n-}\n \n-impl Drop for OSRng {\n-    #[cfg(unix)]\n-    fn drop(&mut self) {\n-        // ensure that OSRng is not implicitly copyable on all\n-        // platforms, for consistency.\n+    impl OSRng {\n+        /// Create a new `OSRng`.\n+        pub fn new() -> OSRng {\n+            let mut hcp = 0;\n+            let ret = unsafe {\n+                CryptAcquireContextA(&mut hcp, 0 as LPCSTR, 0 as LPCSTR,\n+                                     PROV_RSA_FULL,\n+                                     CRYPT_VERIFYCONTEXT | CRYPT_SILENT)\n+            };\n+            if ret == 0 {\n+                fail!(\"couldn't create context: {}\", os::last_os_error());\n+            }\n+            OSRng { hcryptprov: hcp }\n+        }\n     }\n \n-    #[cfg(windows)]\n-    fn drop(&mut self) {\n-        extern { fn rust_win32_rand_release(hProv: HCRYPTPROV); }\n+    impl Rng for OSRng {\n+        fn next_u32(&mut self) -> u32 {\n+            let mut v = [0u8, .. 4];\n+            self.fill_bytes(v);\n+            unsafe { cast::transmute(v) }\n+        }\n+        fn next_u64(&mut self) -> u64 {\n+            let mut v = [0u8, .. 8];\n+            self.fill_bytes(v);\n+            unsafe { cast::transmute(v) }\n+        }\n+        fn fill_bytes(&mut self, v: &mut [u8]) {\n+            let ret = unsafe {\n+                CryptGenRandom(self.hcryptprov, v.len() as DWORD,\n+                               v.as_mut_ptr())\n+            };\n+            if ret == 0 {\n+                fail!(\"couldn't generate random bytes: {}\", os::last_os_error());\n+            }\n+        }\n+    }\n \n-        unsafe {rust_win32_rand_release(self.hcryptprov)}\n+    impl Drop for OSRng {\n+        fn drop(&mut self) {\n+            let ret = unsafe {\n+                CryptReleaseContext(self.hcryptprov, 0)\n+            };\n+            if ret == 0 {\n+                fail!(\"couldn't release context: {}\", os::last_os_error());\n+            }\n+        }\n     }\n }\n \n-\n #[cfg(test)]\n mod test {\n     use super::OSRng;"}, {"sha": "9c27fe1c5e446990c370dcc530eda6a5e77b499d", "filename": "src/rt/rust_builtin.c", "status": "modified", "additions": 0, "deletions": 59, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/d2e99a0b33c25dee2c1b3c113b5c67bfed1bff1d/src%2Frt%2Frust_builtin.c", "raw_url": "https://github.com/rust-lang/rust/raw/d2e99a0b33c25dee2c1b3c113b5c67bfed1bff1d/src%2Frt%2Frust_builtin.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_builtin.c?ref=d2e99a0b33c25dee2c1b3c113b5c67bfed1bff1d", "patch": "@@ -387,65 +387,6 @@ rust_unset_sigprocmask() {\n \n #endif\n \n-#if defined(__WIN32__)\n-void\n-win32_require(LPCTSTR fn, BOOL ok) {\n-    if (!ok) {\n-        LPTSTR buf;\n-        DWORD err = GetLastError();\n-        FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |\n-                      FORMAT_MESSAGE_FROM_SYSTEM |\n-                      FORMAT_MESSAGE_IGNORE_INSERTS,\n-                      NULL, err,\n-                      MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),\n-                      (LPTSTR) &buf, 0, NULL );\n-        fprintf(stderr, \"%s failed with error %ld: %s\", fn, err, buf);\n-        LocalFree((HLOCAL)buf);\n-        abort();\n-    }\n-}\n-\n-void\n-rust_win32_rand_acquire(HCRYPTPROV* phProv) {\n-    win32_require\n-        (_T(\"CryptAcquireContext\"),\n-         // changes to the parameters here should be reflected in the docs of\n-         // rand::os::OSRng\n-         CryptAcquireContext(phProv, NULL, NULL, PROV_RSA_FULL,\n-                             CRYPT_VERIFYCONTEXT|CRYPT_SILENT));\n-\n-}\n-void\n-rust_win32_rand_gen(HCRYPTPROV hProv, DWORD dwLen, BYTE* pbBuffer) {\n-    win32_require\n-        (_T(\"CryptGenRandom\"), CryptGenRandom(hProv, dwLen, pbBuffer));\n-}\n-void\n-rust_win32_rand_release(HCRYPTPROV hProv) {\n-    win32_require\n-        (_T(\"CryptReleaseContext\"), CryptReleaseContext(hProv, 0));\n-}\n-\n-#else\n-\n-// these symbols are listed in rustrt.def.in, so they need to exist; but they\n-// should never be called.\n-\n-void\n-rust_win32_rand_acquire() {\n-    abort();\n-}\n-void\n-rust_win32_rand_gen() {\n-    abort();\n-}\n-void\n-rust_win32_rand_release() {\n-    abort();\n-}\n-\n-#endif\n-\n //\n // Local Variables:\n // mode: C++"}]}