{"sha": "97927146dbdcd17a1569f0bb8a4b56fcf347f03c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk3OTI3MTQ2ZGJkY2QxN2ExNTY5ZjBiYjhhNGI1NmZjZjM0N2YwM2M=", "commit": {"author": {"name": "kjeremy", "email": "kjeremy@gmail.com", "date": "2020-07-21T18:07:42Z"}, "committer": {"name": "kjeremy", "email": "kjeremy@gmail.com", "date": "2020-07-21T18:07:42Z"}, "message": "Store document version and pass back to the client", "tree": {"sha": "0a19d63338165d23b4aa9a994b2feebbf020bb76", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0a19d63338165d23b4aa9a994b2feebbf020bb76"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/97927146dbdcd17a1569f0bb8a4b56fcf347f03c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/97927146dbdcd17a1569f0bb8a4b56fcf347f03c", "html_url": "https://github.com/rust-lang/rust/commit/97927146dbdcd17a1569f0bb8a4b56fcf347f03c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/97927146dbdcd17a1569f0bb8a4b56fcf347f03c/comments", "author": {"login": "kjeremy", "id": 4325700, "node_id": "MDQ6VXNlcjQzMjU3MDA=", "avatar_url": "https://avatars.githubusercontent.com/u/4325700?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kjeremy", "html_url": "https://github.com/kjeremy", "followers_url": "https://api.github.com/users/kjeremy/followers", "following_url": "https://api.github.com/users/kjeremy/following{/other_user}", "gists_url": "https://api.github.com/users/kjeremy/gists{/gist_id}", "starred_url": "https://api.github.com/users/kjeremy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kjeremy/subscriptions", "organizations_url": "https://api.github.com/users/kjeremy/orgs", "repos_url": "https://api.github.com/users/kjeremy/repos", "events_url": "https://api.github.com/users/kjeremy/events{/privacy}", "received_events_url": "https://api.github.com/users/kjeremy/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kjeremy", "id": 4325700, "node_id": "MDQ6VXNlcjQzMjU3MDA=", "avatar_url": "https://avatars.githubusercontent.com/u/4325700?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kjeremy", "html_url": "https://github.com/kjeremy", "followers_url": "https://api.github.com/users/kjeremy/followers", "following_url": "https://api.github.com/users/kjeremy/following{/other_user}", "gists_url": "https://api.github.com/users/kjeremy/gists{/gist_id}", "starred_url": "https://api.github.com/users/kjeremy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kjeremy/subscriptions", "organizations_url": "https://api.github.com/users/kjeremy/orgs", "repos_url": "https://api.github.com/users/kjeremy/repos", "events_url": "https://api.github.com/users/kjeremy/events{/privacy}", "received_events_url": "https://api.github.com/users/kjeremy/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "65b89b5471879a80fb6003c9fa0f8f93e2eb38e6", "url": "https://api.github.com/repos/rust-lang/rust/commits/65b89b5471879a80fb6003c9fa0f8f93e2eb38e6", "html_url": "https://github.com/rust-lang/rust/commit/65b89b5471879a80fb6003c9fa0f8f93e2eb38e6"}], "stats": {"total": 44, "additions": 31, "deletions": 13}, "files": [{"sha": "80937dbc4ddb06835d583b847bf014110934bc9e", "filename": "crates/rust-analyzer/src/global_state.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/97927146dbdcd17a1569f0bb8a4b56fcf347f03c/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97927146dbdcd17a1569f0bb8a4b56fcf347f03c/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs?ref=97927146dbdcd17a1569f0bb8a4b56fcf347f03c", "patch": "@@ -12,7 +12,7 @@ use parking_lot::RwLock;\n use ra_db::{CrateId, VfsPath};\n use ra_ide::{Analysis, AnalysisChange, AnalysisHost, FileId};\n use ra_project_model::{CargoWorkspace, ProcMacroClient, ProjectWorkspace, Target};\n-use rustc_hash::{FxHashMap, FxHashSet};\n+use rustc_hash::FxHashMap;\n \n use crate::{\n     config::Config,\n@@ -69,7 +69,7 @@ pub(crate) struct GlobalState {\n     pub(crate) config: Config,\n     pub(crate) analysis_host: AnalysisHost,\n     pub(crate) diagnostics: DiagnosticCollection,\n-    pub(crate) mem_docs: FxHashSet<VfsPath>,\n+    pub(crate) mem_docs: FxHashMap<VfsPath, Option<i64>>,\n     pub(crate) vfs: Arc<RwLock<(vfs::Vfs, FxHashMap<FileId, LineEndings>)>>,\n     pub(crate) status: Status,\n     pub(crate) source_root_config: SourceRootConfig,\n@@ -84,6 +84,7 @@ pub(crate) struct GlobalStateSnapshot {\n     pub(crate) analysis: Analysis,\n     pub(crate) check_fixes: CheckFixes,\n     pub(crate) latest_requests: Arc<RwLock<LatestRequests>>,\n+    mem_docs: FxHashMap<VfsPath, Option<i64>>,\n     vfs: Arc<RwLock<(vfs::Vfs, FxHashMap<FileId, LineEndings>)>>,\n     pub(crate) workspaces: Arc<Vec<ProjectWorkspace>>,\n }\n@@ -117,7 +118,7 @@ impl GlobalState {\n             config,\n             analysis_host,\n             diagnostics: Default::default(),\n-            mem_docs: FxHashSet::default(),\n+            mem_docs: FxHashMap::default(),\n             vfs: Arc::new(RwLock::new((vfs::Vfs::default(), FxHashMap::default()))),\n             status: Status::default(),\n             source_root_config: SourceRootConfig::default(),\n@@ -183,6 +184,7 @@ impl GlobalState {\n             vfs: Arc::clone(&self.vfs),\n             latest_requests: Arc::clone(&self.latest_requests),\n             check_fixes: Arc::clone(&self.diagnostics.check_fixes),\n+            mem_docs: self.mem_docs.clone(),\n         }\n     }\n \n@@ -255,6 +257,11 @@ impl GlobalStateSnapshot {\n         self.vfs.read().1[&id]\n     }\n \n+    pub(crate) fn url_file_version(&self, url: &Url) -> Option<i64> {\n+        let path = from_proto::vfs_path(&url).ok()?;\n+        self.mem_docs.get(&path).copied()?\n+    }\n+\n     pub(crate) fn anchored_path(&self, file_id: FileId, path: &str) -> Url {\n         let mut base = self.vfs.read().0.file_path(file_id);\n         base.pop();"}, {"sha": "00ae6b900f82df89a73e5bc7659029ac7eddc252", "filename": "crates/rust-analyzer/src/main_loop.rs", "status": "modified", "additions": 17, "deletions": 7, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/97927146dbdcd17a1569f0bb8a4b56fcf347f03c/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97927146dbdcd17a1569f0bb8a4b56fcf347f03c/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs?ref=97927146dbdcd17a1569f0bb8a4b56fcf347f03c", "patch": "@@ -210,7 +210,7 @@ impl GlobalState {\n                             let vfs = &mut self.vfs.write().0;\n                             for (path, contents) in files {\n                                 let path = VfsPath::from(path);\n-                                if !self.mem_docs.contains(&path) {\n+                                if !self.mem_docs.contains_key(&path) {\n                                     vfs.set_file_contents(path, contents)\n                                 }\n                             }\n@@ -299,7 +299,7 @@ impl GlobalState {\n         if self.status == Status::Ready && (state_changed || prev_status == Status::Loading) {\n             let subscriptions = self\n                 .mem_docs\n-                .iter()\n+                .keys()\n                 .map(|path| self.vfs.read().0.file_id(&path).unwrap())\n                 .collect::<Vec<_>>();\n \n@@ -310,8 +310,12 @@ impl GlobalState {\n             for file_id in diagnostic_changes {\n                 let url = file_id_to_url(&self.vfs.read().0, file_id);\n                 let diagnostics = self.diagnostics.diagnostics_for(file_id).cloned().collect();\n+                let version = from_proto::vfs_path(&url)\n+                    .map(|path| self.mem_docs.get(&path).copied().flatten())\n+                    .unwrap_or_default();\n+\n                 self.send_notification::<lsp_types::notification::PublishDiagnostics>(\n-                    lsp_types::PublishDiagnosticsParams { uri: url, diagnostics, version: None },\n+                    lsp_types::PublishDiagnosticsParams { uri: url, diagnostics, version },\n                 );\n             }\n         }\n@@ -400,7 +404,11 @@ impl GlobalState {\n             })?\n             .on::<lsp_types::notification::DidOpenTextDocument>(|this, params| {\n                 if let Ok(path) = from_proto::vfs_path(&params.text_document.uri) {\n-                    if !this.mem_docs.insert(path.clone()) {\n+                    if this\n+                        .mem_docs\n+                        .insert(path.clone(), Some(params.text_document.version))\n+                        .is_some()\n+                    {\n                         log::error!(\"duplicate DidOpenTextDocument: {}\", path)\n                     }\n                     this.vfs\n@@ -412,18 +420,20 @@ impl GlobalState {\n             })?\n             .on::<lsp_types::notification::DidChangeTextDocument>(|this, params| {\n                 if let Ok(path) = from_proto::vfs_path(&params.text_document.uri) {\n-                    assert!(this.mem_docs.contains(&path));\n+                    assert!(this.mem_docs.contains_key(&path));\n                     let vfs = &mut this.vfs.write().0;\n                     let file_id = vfs.file_id(&path).unwrap();\n                     let mut text = String::from_utf8(vfs.file_contents(file_id).to_vec()).unwrap();\n                     apply_document_changes(&mut text, params.content_changes);\n-                    vfs.set_file_contents(path, Some(text.into_bytes()))\n+                    vfs.set_file_contents(path.clone(), Some(text.into_bytes()));\n+\n+                    this.mem_docs.insert(path, params.text_document.version);\n                 }\n                 Ok(())\n             })?\n             .on::<lsp_types::notification::DidCloseTextDocument>(|this, params| {\n                 if let Ok(path) = from_proto::vfs_path(&params.text_document.uri) {\n-                    if !this.mem_docs.remove(&path) {\n+                    if this.mem_docs.remove(&path).is_none() {\n                         log::error!(\"orphan DidCloseTextDocument: {}\", path)\n                     }\n                     if let Some(path) = path.as_path() {"}, {"sha": "c6935c029bb5a9d2e55379a609572e309a45e147", "filename": "crates/rust-analyzer/src/to_proto.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/97927146dbdcd17a1569f0bb8a4b56fcf347f03c/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97927146dbdcd17a1569f0bb8a4b56fcf347f03c/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs?ref=97927146dbdcd17a1569f0bb8a4b56fcf347f03c", "patch": "@@ -480,9 +480,10 @@ pub(crate) fn url_from_abs_path(path: &Path) -> lsp_types::Url {\n pub(crate) fn versioned_text_document_identifier(\n     snap: &GlobalStateSnapshot,\n     file_id: FileId,\n-    version: Option<i64>,\n ) -> lsp_types::VersionedTextDocumentIdentifier {\n-    lsp_types::VersionedTextDocumentIdentifier { uri: url(snap, file_id), version }\n+    let url = url(snap, file_id);\n+    let version = snap.url_file_version(&url);\n+    lsp_types::VersionedTextDocumentIdentifier { uri: url, version }\n }\n \n pub(crate) fn location(\n@@ -571,7 +572,7 @@ pub(crate) fn snippet_text_document_edit(\n     is_snippet: bool,\n     source_file_edit: SourceFileEdit,\n ) -> Result<lsp_ext::SnippetTextDocumentEdit> {\n-    let text_document = versioned_text_document_identifier(snap, source_file_edit.file_id, None);\n+    let text_document = versioned_text_document_identifier(snap, source_file_edit.file_id);\n     let line_index = snap.analysis.file_line_index(source_file_edit.file_id)?;\n     let line_endings = snap.file_line_endings(source_file_edit.file_id);\n     let edits = source_file_edit"}]}