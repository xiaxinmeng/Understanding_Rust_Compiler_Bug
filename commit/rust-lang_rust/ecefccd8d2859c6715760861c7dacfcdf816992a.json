{"sha": "ecefccd8d2859c6715760861c7dacfcdf816992a", "node_id": "C_kwDOAAsO6NoAKGVjZWZjY2Q4ZDI4NTljNjcxNTc2MDg2MWM3ZGFjZmNkZjgxNjk5MmE", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-06-25T13:14:09Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-06-25T13:14:09Z"}, "message": "Rollup merge of #98194 - m-ou-se:leak-locked-pthread-mutex, r=Amanieu\n\nLeak pthread_{mutex,rwlock}_t if it's dropped while locked.\n\nFixes https://github.com/rust-lang/rust/issues/85434.", "tree": {"sha": "85e8c78d6b37d2c1be7f2bce20c05fe7280cae87", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/85e8c78d6b37d2c1be7f2bce20c05fe7280cae87"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ecefccd8d2859c6715760861c7dacfcdf816992a", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJitwohCRBK7hj4Ov3rIwAAl10IABcK0g2vPjhaNCJJ0JHH2cgJ\n/4RDCtRbsgkBADMSnbCn/i4q6C7ORrSfGkpVyA5b0pAJ/KpVnMT035OtHM2zNOnl\nvamoxSyhHSw9x9VCy3D1/LiGJK8AgN9Fh+bHxImSypdsw4S9+26uuoB1zLnzpCOV\n3kT+by2oOZqBW5Qy6WBRh7ICFqFagfTdVJL/lLCoZduWTmpzX9BYRum0BfSXzo+U\nC+WhJwzNpIyuIC0E4tLxjVQFnDZ0Xesgwzyw3isCdzTSIx5dLWmCrJ6ZKK+/RHWe\nxQfbbEkTxdS73BS+pvDDkQyk9apUf3o35pR6INqP3ZMdrx3XIrzKiyGDYqJ1wFs=\n=Smnj\n-----END PGP SIGNATURE-----\n", "payload": "tree 85e8c78d6b37d2c1be7f2bce20c05fe7280cae87\nparent 45ef23d78e54ff2d12db78c6445f766f61972c86\nparent e642c5987e1885a6ea9b0f1527810a72bdcdeb3f\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1656162849 +0200\ncommitter GitHub <noreply@github.com> 1656162849 +0200\n\nRollup merge of #98194 - m-ou-se:leak-locked-pthread-mutex, r=Amanieu\n\nLeak pthread_{mutex,rwlock}_t if it's dropped while locked.\n\nFixes https://github.com/rust-lang/rust/issues/85434.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ecefccd8d2859c6715760861c7dacfcdf816992a", "html_url": "https://github.com/rust-lang/rust/commit/ecefccd8d2859c6715760861c7dacfcdf816992a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ecefccd8d2859c6715760861c7dacfcdf816992a/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "45ef23d78e54ff2d12db78c6445f766f61972c86", "url": "https://api.github.com/repos/rust-lang/rust/commits/45ef23d78e54ff2d12db78c6445f766f61972c86", "html_url": "https://github.com/rust-lang/rust/commit/45ef23d78e54ff2d12db78c6445f766f61972c86"}, {"sha": "e642c5987e1885a6ea9b0f1527810a72bdcdeb3f", "url": "https://api.github.com/repos/rust-lang/rust/commits/e642c5987e1885a6ea9b0f1527810a72bdcdeb3f", "html_url": "https://github.com/rust-lang/rust/commit/e642c5987e1885a6ea9b0f1527810a72bdcdeb3f"}], "stats": {"total": 55, "additions": 51, "deletions": 4}, "files": [{"sha": "98afee69ba622903bebc80f4775be49fedfe4193", "filename": "library/std/src/sys/unix/locks/pthread_mutex.rs", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ecefccd8d2859c6715760861c7dacfcdf816992a/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Fpthread_mutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecefccd8d2859c6715760861c7dacfcdf816992a/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Fpthread_mutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Fpthread_mutex.rs?ref=ecefccd8d2859c6715760861c7dacfcdf816992a", "patch": "@@ -1,5 +1,5 @@\n use crate::cell::UnsafeCell;\n-use crate::mem::MaybeUninit;\n+use crate::mem::{forget, MaybeUninit};\n use crate::sys::cvt_nz;\n use crate::sys_common::lazy_box::{LazyBox, LazyInit};\n \n@@ -23,6 +23,24 @@ impl LazyInit for Mutex {\n         unsafe { mutex.init() };\n         mutex\n     }\n+\n+    fn destroy(mutex: Box<Self>) {\n+        // We're not allowed to pthread_mutex_destroy a locked mutex,\n+        // so check first if it's unlocked.\n+        if unsafe { mutex.try_lock() } {\n+            unsafe { mutex.unlock() };\n+            drop(mutex);\n+        } else {\n+            // The mutex is locked. This happens if a MutexGuard is leaked.\n+            // In this case, we just leak the Mutex too.\n+            forget(mutex);\n+        }\n+    }\n+\n+    fn cancel_init(_: Box<Self>) {\n+        // In this case, we can just drop it without any checks,\n+        // since it cannot have been locked yet.\n+    }\n }\n \n impl Mutex {"}, {"sha": "adfe2a88338f55bbca7f7052254d9d5bfeb5d072", "filename": "library/std/src/sys/unix/locks/pthread_rwlock.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ecefccd8d2859c6715760861c7dacfcdf816992a/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Fpthread_rwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecefccd8d2859c6715760861c7dacfcdf816992a/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Fpthread_rwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Fpthread_rwlock.rs?ref=ecefccd8d2859c6715760861c7dacfcdf816992a", "patch": "@@ -1,4 +1,5 @@\n use crate::cell::UnsafeCell;\n+use crate::mem::forget;\n use crate::sync::atomic::{AtomicUsize, Ordering};\n use crate::sys_common::lazy_box::{LazyBox, LazyInit};\n \n@@ -17,6 +18,21 @@ impl LazyInit for RwLock {\n     fn init() -> Box<Self> {\n         Box::new(Self::new())\n     }\n+\n+    fn destroy(mut rwlock: Box<Self>) {\n+        // We're not allowed to pthread_rwlock_destroy a locked rwlock,\n+        // so check first if it's unlocked.\n+        if *rwlock.write_locked.get_mut() || *rwlock.num_readers.get_mut() != 0 {\n+            // The rwlock is locked. This happens if a RwLock{Read,Write}Guard is leaked.\n+            // In this case, we just leak the RwLock too.\n+            forget(rwlock);\n+        }\n+    }\n+\n+    fn cancel_init(_: Box<Self>) {\n+        // In this case, we can just drop it without any checks,\n+        // since it cannot have been locked yet.\n+    }\n }\n \n impl RwLock {"}, {"sha": "63c3316bdeb28b95b691ca914c9120e25488dc69", "filename": "library/std/src/sys_common/lazy_box.rs", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ecefccd8d2859c6715760861c7dacfcdf816992a/library%2Fstd%2Fsrc%2Fsys_common%2Flazy_box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecefccd8d2859c6715760861c7dacfcdf816992a/library%2Fstd%2Fsrc%2Fsys_common%2Flazy_box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Flazy_box.rs?ref=ecefccd8d2859c6715760861c7dacfcdf816992a", "patch": "@@ -21,8 +21,21 @@ pub(crate) trait LazyInit {\n     ///\n     /// It might be called more than once per LazyBox, as multiple threads\n     /// might race to initialize it concurrently, each constructing and initializing\n-    /// their own box. (All but one of them will be destroyed right after.)\n+    /// their own box. All but one of them will be passed to `cancel_init` right after.\n     fn init() -> Box<Self>;\n+\n+    /// Any surplus boxes from `init()` that lost the initialization race\n+    /// are passed to this function for disposal.\n+    ///\n+    /// The default implementation calls destroy().\n+    fn cancel_init(x: Box<Self>) {\n+        Self::destroy(x);\n+    }\n+\n+    /// This is called to destroy a used box.\n+    ///\n+    /// The default implementation just drops it.\n+    fn destroy(_: Box<Self>) {}\n }\n \n impl<T: LazyInit> LazyBox<T> {\n@@ -45,7 +58,7 @@ impl<T: LazyInit> LazyBox<T> {\n             Err(ptr) => {\n                 // Lost the race to another thread.\n                 // Drop the box we created, and use the one from the other thread instead.\n-                drop(unsafe { Box::from_raw(new_ptr) });\n+                T::cancel_init(unsafe { Box::from_raw(new_ptr) });\n                 ptr\n             }\n         }\n@@ -71,7 +84,7 @@ impl<T: LazyInit> Drop for LazyBox<T> {\n     fn drop(&mut self) {\n         let ptr = *self.ptr.get_mut();\n         if !ptr.is_null() {\n-            drop(unsafe { Box::from_raw(ptr) });\n+            T::destroy(unsafe { Box::from_raw(ptr) });\n         }\n     }\n }"}]}