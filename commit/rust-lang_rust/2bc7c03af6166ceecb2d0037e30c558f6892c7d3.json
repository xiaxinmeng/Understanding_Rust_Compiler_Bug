{"sha": "2bc7c03af6166ceecb2d0037e30c558f6892c7d3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJiYzdjMDNhZjYxNjZjZWVjYjJkMDAzN2UzMGM1NThmNjg5MmM3ZDM=", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2018-07-21T10:15:32Z"}, "committer": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2018-07-22T19:02:24Z"}, "message": "Add filter over non generic impls", "tree": {"sha": "3103522f6e859e5e588a059670a076b63d0cf317", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3103522f6e859e5e588a059670a076b63d0cf317"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2bc7c03af6166ceecb2d0037e30c558f6892c7d3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2bc7c03af6166ceecb2d0037e30c558f6892c7d3", "html_url": "https://github.com/rust-lang/rust/commit/2bc7c03af6166ceecb2d0037e30c558f6892c7d3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2bc7c03af6166ceecb2d0037e30c558f6892c7d3/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e8cca55283ec61c5442b4a40e123d03d997c92ff", "url": "https://api.github.com/repos/rust-lang/rust/commits/e8cca55283ec61c5442b4a40e123d03d997c92ff", "html_url": "https://github.com/rust-lang/rust/commit/e8cca55283ec61c5442b4a40e123d03d997c92ff"}], "stats": {"total": 92, "additions": 38, "deletions": 54}, "files": [{"sha": "9a6495694c520bd1236f86215285eebd8c166277", "filename": "src/librustdoc/clean/auto_trait.rs", "status": "modified", "additions": 38, "deletions": 46, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/2bc7c03af6166ceecb2d0037e30c558f6892c7d3/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bc7c03af6166ceecb2d0037e30c558f6892c7d3/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs?ref=2bc7c03af6166ceecb2d0037e30c558f6892c7d3", "patch": "@@ -16,6 +16,8 @@ use rustc::infer::InferOk;\n use std::fmt::Debug;\n use syntax_pos::DUMMY_SP;\n \n+use core::DocAccessLevels;\n+\n use super::*;\n \n pub struct AutoTraitFinder<'a, 'tcx: 'a, 'rcx: 'a> {\n@@ -115,13 +117,38 @@ impl<'a, 'tcx, 'rcx> AutoTraitFinder<'a, 'tcx, 'rcx> {\n                     _ => false,\n                 };*/\n                 for &trait_def_id in self.cx.all_traits.iter() {\n-                    if traits.get(&trait_def_id).is_some() {\n+                    if traits.get(&trait_def_id).is_some() ||\n+                       !self.cx.access_levels.borrow().is_doc_reachable(trait_def_id) {\n                         continue\n                     }\n                     let t_name = self.cx.tcx.item_name(trait_def_id).to_string();\n                     self.cx.tcx.for_each_relevant_impl(trait_def_id, ty, |impl_def_id| {\n                         self.cx.tcx.infer_ctxt().enter(|infcx| {\n+                            let generics = infcx.tcx.generics_of(impl_def_id);\n+\n+                            /*if generics.count() == 0 {\n+                                return;\n+                            }*/\n                             let trait_ref = infcx.tcx.impl_trait_ref(impl_def_id).unwrap();\n+                            /*if !trait_ref.substs.iter().any(|x| match x.unpack() {\n+                                ::rustc::ty::subst::UnpackedKind::Type(ref t) => {\n+                                    match t.sty {\n+                                        ::rustc::ty::TypeVariants::TyParam(_) => true,\n+                                        _ => false,\n+                                    }\n+                                }\n+                                _ => false,\n+                            }) {\n+                                return;\n+                            }*/\n+\n+                            if !match infcx.tcx.type_of(impl_def_id).sty {\n+                                ::rustc::ty::TypeVariants::TyParam(_) => true,\n+                                _ => false,\n+                            } {\n+                                return;\n+                            }\n+\n                             let substs = infcx.fresh_substs_for_item(DUMMY_SP, def_id);\n                             let ty2 = ty.subst(infcx.tcx, substs);\n                             let param_env = param_env.subst(infcx.tcx, substs);\n@@ -146,50 +173,18 @@ impl<'a, 'tcx, 'rcx> AutoTraitFinder<'a, 'tcx, 'rcx> {\n                                     println!(\"==> {}\", infcx.tcx.item_name(trait_def_id).to_string());\n                                 }*/\n                                 if may_apply {\n-                                    if self.cx.crate_name == Some(\"std\".to_string()) && t_name == \"ToString\" {\n-                                        println!(\"may_apply: {:?}\", t_name);\n-                                    }\n                                     // FIXME: add crate's id before the name to avoid removing a\n                                     // trait which doesn't exist.\n                                     if traits.get(&trait_def_id).is_none() {\n-                                        if self.cx.crate_name == Some(\"std\".to_string()) && t_name == \"ToString\" {\n-                                            println!(\"in!\");\n-                                        }\n-                                        /*if print {\n-                                            println!(\"> {}\", infcx.tcx.item_name(trait_def_id).to_string());\n-                                        }*/\n-                                        /*let generics = (infcx.tcx.generics_of(trait_def_id), &predicates).clean(cx);\n-                                        get_path_for_type(self.cx.tcx, trait_def_id, hir::def::Def::Trait)*/\n-                                        /*if let Some(i) = self.get_auto_trait_impl_for(\n-                                            def_id,\n-                                            name.clone(),\n-                                            generics.clone(),\n-                                            def_ctor,\n-                                            trait_def_id,\n-                                        ) {\n-                                            traits.insert(trait_name, i);\n-                                        }*/\n-\n-                                        let mut impls = Vec::new();\n-                                        ::clean::inline::build_impl(&self.cx, impl_def_id, &mut impls);\n-                                        /*if ::std::env::var(\"LOL\").is_ok() {\n-                                            println!(\"=> {} ::> {}\",\n-                                                     infcx.tcx.item_name(trait_def_id).to_string(),\n-                                                     impls.len());\n-                                            println!(\"{:?}\", impls);\n-                                        }*/\n-                                        for impl_ in &mut impls {\n-                                            if let ImplItem(ref mut i) = impl_.inner {\n-                                                i.synthetic = true;\n-                                                i.for_ = ty.clean(&self.cx);\n-                                                //i.visibility = None;\n-                                            }\n-                                            //impl_.visibility = None;\n-                                            if self.cx.crate_name == Some(\"std\".to_string()) && t_name == \"ToString\" {\n-                                                println!(\"**> {:?}\", impl_);\n-                                            }\n+                                        if self.cx.crate_name == Some(\"std\".to_string()) {\n+                                            println!(\"visibility: ({} {}) [{} {:?}] [{} {:?}]\",\n+                                                     self.cx.tcx.item_name(def_id).to_string(), t_name,\n+                                                     impl_def_id.krate, impl_def_id.index,\n+                                                     trait_def_id.krate, trait_def_id.index);\n+                                            println!(\"{:?}\", infcx.tcx.visibility(impl_def_id));\n+                                            println!(\"{:?}\", infcx.tcx.visibility(trait_def_id));\n                                         }\n-                                        //traits.insert(trait_def_id, impls);\n+\n                                         let trait_ = hir::TraitRef {\n                                             path: get_path_for_type(infcx.tcx, trait_def_id, hir::def::Def::Trait),\n                                             ref_id: ast::DUMMY_NODE_ID,\n@@ -198,7 +193,6 @@ impl<'a, 'tcx, 'rcx> AutoTraitFinder<'a, 'tcx, 'rcx> {\n                                                                               .into_iter()\n                                                                               .map(|meth| meth.ident.to_string())\n                                                                               .collect();\n-                                        println!(\"|||> {}\", t_name);\n                                         traits.insert(trait_def_id, Item {\n                                             source: Span::empty(),\n                                             name: None,\n@@ -209,7 +203,8 @@ impl<'a, 'tcx, 'rcx> AutoTraitFinder<'a, 'tcx, 'rcx> {\n                                             deprecation: None,\n                                             inner: ImplItem(Impl {\n                                                 unsafety: hir::Unsafety::Normal,\n-                                                generics: (infcx.tcx.generics_of(trait_def_id), &Default::default()).clean(self.cx),\n+                                                generics: (generics,\n+                                                           &tcx.predicates_of(impl_def_id)).clean(self.cx),\n                                                 provided_trait_methods,\n                                                 trait_: Some(trait_.clean(self.cx)),\n                                                 for_: ty.clean(self.cx),\n@@ -279,9 +274,6 @@ impl<'a, 'tcx, 'rcx> AutoTraitFinder<'a, 'tcx, 'rcx> {\n             \"get_auto_traits: type {:?} auto_traits {:?}\",\n             def_id, auto_traits\n         );\n-        if self.cx.crate_name == Some(\"std\".to_string()) {\n-            println!(\"((((((> {} {:?}\", auto_traits.len(), auto_traits);\n-        }\n         auto_traits\n     }\n "}, {"sha": "fe93dd16ffda91e3aefd3408c0fbc54b67dbf9ea", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2bc7c03af6166ceecb2d0037e30c558f6892c7d3/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bc7c03af6166ceecb2d0037e30c558f6892c7d3/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=2bc7c03af6166ceecb2d0037e30c558f6892c7d3", "patch": "@@ -275,10 +275,6 @@ pub fn build_impls(cx: &DocContext, did: DefId, auto_traits: bool) -> Vec<clean:\n     if auto_traits {\n         let auto_impls = get_auto_traits_with_def_id(cx, did);\n         let mut renderinfo = cx.renderinfo.borrow_mut();\n-\n-        if cx.crate_name == Some(\"std\".to_string()) {\n-            println!(\"=====> {} {:?}\\n\", auto_impls.len(), auto_impls);\n-        }\n         let new_impls: Vec<clean::Item> = auto_impls.into_iter()\n             .filter(|i| renderinfo.inlined.insert(i.def_id)).collect();\n \n@@ -340,9 +336,6 @@ pub fn build_impls(cx: &DocContext, did: DefId, auto_traits: bool) -> Vec<clean:\n             build_impl(cx, def_id, &mut impls);\n \n             let auto_impls = get_auto_traits_with_def_id(cx, def_id);\n-            if cx.crate_name == Some(\"std\".to_string()) {\n-                println!(\"-----> {} {:?}\\n\", auto_impls.len(), auto_impls);\n-            }\n             let mut renderinfo = cx.renderinfo.borrow_mut();\n \n             let new_impls: Vec<clean::Item> = auto_impls.into_iter()"}, {"sha": "7b1817587af9b253999ba61f99ad96a7c0092f13", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2bc7c03af6166ceecb2d0037e30c558f6892c7d3/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bc7c03af6166ceecb2d0037e30c558f6892c7d3/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=2bc7c03af6166ceecb2d0037e30c558f6892c7d3", "patch": "@@ -3584,7 +3584,6 @@ fn render_assoc_items(w: &mut fmt::Formatter,\n         Some(v) => v,\n         None => return Ok(()),\n     };\n-    //println!(\"=======> {:?}\", containing_item.name);\n     let (non_trait, traits): (Vec<_>, _) = v.iter().partition(|i| {\n         /*if let Some(ref t) = i.inner_impl().trait_ {\n             println!(\"++++++> {:?}\", t);"}]}