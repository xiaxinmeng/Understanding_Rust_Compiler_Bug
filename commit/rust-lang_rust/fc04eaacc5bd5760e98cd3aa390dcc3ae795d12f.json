{"sha": "fc04eaacc5bd5760e98cd3aa390dcc3ae795d12f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZjMDRlYWFjYzViZDU3NjBlOThjZDNhYTM5MGRjYzNhZTc5NWQxMmY=", "commit": {"author": {"name": "Taylor Cramer", "email": "cramertaylorj@gmail.com", "date": "2017-02-28T19:05:03Z"}, "committer": {"name": "Taylor Cramer", "email": "cramertaylorj@gmail.com", "date": "2017-03-18T04:01:04Z"}, "message": "Implement ? in catch expressions and add tests", "tree": {"sha": "bc13f89329235a88e2041780079cec6841999e83", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bc13f89329235a88e2041780079cec6841999e83"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fc04eaacc5bd5760e98cd3aa390dcc3ae795d12f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fc04eaacc5bd5760e98cd3aa390dcc3ae795d12f", "html_url": "https://github.com/rust-lang/rust/commit/fc04eaacc5bd5760e98cd3aa390dcc3ae795d12f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fc04eaacc5bd5760e98cd3aa390dcc3ae795d12f/comments", "author": {"login": "cramertj", "id": 5963049, "node_id": "MDQ6VXNlcjU5NjMwNDk=", "avatar_url": "https://avatars.githubusercontent.com/u/5963049?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cramertj", "html_url": "https://github.com/cramertj", "followers_url": "https://api.github.com/users/cramertj/followers", "following_url": "https://api.github.com/users/cramertj/following{/other_user}", "gists_url": "https://api.github.com/users/cramertj/gists{/gist_id}", "starred_url": "https://api.github.com/users/cramertj/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cramertj/subscriptions", "organizations_url": "https://api.github.com/users/cramertj/orgs", "repos_url": "https://api.github.com/users/cramertj/repos", "events_url": "https://api.github.com/users/cramertj/events{/privacy}", "received_events_url": "https://api.github.com/users/cramertj/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cramertj", "id": 5963049, "node_id": "MDQ6VXNlcjU5NjMwNDk=", "avatar_url": "https://avatars.githubusercontent.com/u/5963049?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cramertj", "html_url": "https://github.com/cramertj", "followers_url": "https://api.github.com/users/cramertj/followers", "following_url": "https://api.github.com/users/cramertj/following{/other_user}", "gists_url": "https://api.github.com/users/cramertj/gists{/gist_id}", "starred_url": "https://api.github.com/users/cramertj/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cramertj/subscriptions", "organizations_url": "https://api.github.com/users/cramertj/orgs", "repos_url": "https://api.github.com/users/cramertj/repos", "events_url": "https://api.github.com/users/cramertj/events{/privacy}", "received_events_url": "https://api.github.com/users/cramertj/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "703b246287fa9e7ef39bd66f978f6dc6fa119c15", "url": "https://api.github.com/repos/rust-lang/rust/commits/703b246287fa9e7ef39bd66f978f6dc6fa119c15", "html_url": "https://github.com/rust-lang/rust/commit/703b246287fa9e7ef39bd66f978f6dc6fa119c15"}], "stats": {"total": 842, "additions": 570, "deletions": 272}, "files": [{"sha": "777408457d1f6819ab6f05dccf86187fb0624f73", "filename": "src/librustc/cfg/construct.rs", "status": "modified", "additions": 72, "deletions": 22, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/fc04eaacc5bd5760e98cd3aa390dcc3ae795d12f/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc04eaacc5bd5760e98cd3aa390dcc3ae795d12f/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fconstruct.rs?ref=fc04eaacc5bd5760e98cd3aa390dcc3ae795d12f", "patch": "@@ -22,13 +22,20 @@ struct CFGBuilder<'a, 'tcx: 'a> {\n     graph: CFGGraph,\n     fn_exit: CFGIndex,\n     loop_scopes: Vec<LoopScope>,\n+    breakable_block_scopes: Vec<BlockScope>,\n+}\n+\n+#[derive(Copy, Clone)]\n+struct BlockScope {\n+    block_expr_id: ast::NodeId, // id of breakable block expr node\n+    break_index: CFGIndex, // where to go on `break`\n }\n \n #[derive(Copy, Clone)]\n struct LoopScope {\n     loop_id: ast::NodeId,     // id of loop/while node\n     continue_index: CFGIndex, // where to go on a `loop`\n-    break_index: CFGIndex,    // where to go on a `break\n+    break_index: CFGIndex,    // where to go on a `break`\n }\n \n pub fn construct<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -53,6 +60,7 @@ pub fn construct<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         graph: graph,\n         fn_exit: fn_exit,\n         loop_scopes: Vec::new(),\n+        breakable_block_scopes: Vec::new(),\n     };\n     body_exit = cfg_builder.expr(&body.value, entry);\n     cfg_builder.add_contained_edge(body_exit, fn_exit);\n@@ -66,14 +74,34 @@ pub fn construct<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n     fn block(&mut self, blk: &hir::Block, pred: CFGIndex) -> CFGIndex {\n-        let mut stmts_exit = pred;\n-        for stmt in &blk.stmts {\n-            stmts_exit = self.stmt(stmt, stmts_exit);\n-        }\n+        if let Some(break_to_expr_id) = blk.break_to_expr_id {\n+            let expr_exit = self.add_ast_node(blk.id, &[]);\n+\n+            self.breakable_block_scopes.push(BlockScope {\n+                block_expr_id: break_to_expr_id,\n+                break_index: expr_exit,\n+            });\n+\n+            let mut stmts_exit = pred;\n+            for stmt in &blk.stmts {\n+                stmts_exit = self.stmt(stmt, stmts_exit);\n+            }\n+            let blk_expr_exit = self.opt_expr(&blk.expr, stmts_exit);\n+            self.add_contained_edge(blk_expr_exit, blk_expr_exit);\n+\n+            self.breakable_block_scopes.pop();\n+\n+            expr_exit\n+        } else {\n+            let mut stmts_exit = pred;\n+            for stmt in &blk.stmts {\n+                stmts_exit = self.stmt(stmt, stmts_exit);\n+            }\n \n-        let expr_exit = self.opt_expr(&blk.expr, stmts_exit);\n+            let expr_exit = self.opt_expr(&blk.expr, stmts_exit);\n \n-        self.add_ast_node(blk.id, &[expr_exit])\n+            self.add_ast_node(blk.id, &[expr_exit])\n+        }\n     }\n \n     fn stmt(&mut self, stmt: &hir::Stmt, pred: CFGIndex) -> CFGIndex {\n@@ -295,18 +323,18 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n \n             hir::ExprBreak(destination, ref opt_expr) => {\n                 let v = self.opt_expr(opt_expr, pred);\n-                let loop_scope = self.find_scope(expr, destination);\n+                let (scope_id, break_dest) =\n+                    self.find_scope_edge(expr, destination, ScopeCfKind::Break);\n                 let b = self.add_ast_node(expr.id, &[v]);\n-                self.add_exiting_edge(expr, b,\n-                                      loop_scope, loop_scope.break_index);\n+                self.add_exiting_edge(expr, b, scope_id, break_dest);\n                 self.add_unreachable_node()\n             }\n \n             hir::ExprAgain(destination) => {\n-                let loop_scope = self.find_scope(expr, destination);\n+                let (scope_id, cont_dest) =\n+                    self.find_scope_edge(expr, destination, ScopeCfKind::Continue);\n                 let a = self.add_ast_node(expr.id, &[pred]);\n-                self.add_exiting_edge(expr, a,\n-                                      loop_scope, loop_scope.continue_index);\n+                self.add_exiting_edge(expr, a, scope_id, cont_dest);\n                 self.add_unreachable_node()\n             }\n \n@@ -552,11 +580,11 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n     fn add_exiting_edge(&mut self,\n                         from_expr: &hir::Expr,\n                         from_index: CFGIndex,\n-                        to_loop: LoopScope,\n+                        scope_id: ast::NodeId,\n                         to_index: CFGIndex) {\n         let mut data = CFGEdgeData { exiting_scopes: vec![] };\n         let mut scope = self.tcx.region_maps.node_extent(from_expr.id);\n-        let target_scope = self.tcx.region_maps.node_extent(to_loop.loop_id);\n+        let target_scope = self.tcx.region_maps.node_extent(scope_id);\n         while scope != target_scope {\n             data.exiting_scopes.push(scope.node_id(&self.tcx.region_maps));\n             scope = self.tcx.region_maps.encl_scope(scope);\n@@ -576,20 +604,42 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n         self.graph.add_edge(from_index, self.fn_exit, data);\n     }\n \n-    fn find_scope(&self,\n+    fn find_scope_edge(&self,\n                   expr: &hir::Expr,\n-                  destination: hir::Destination) -> LoopScope {\n-\n-        match destination.loop_id.into() {\n-            Ok(loop_id) => {\n+                  destination: hir::Destination,\n+                  scope_cf_kind: ScopeCfKind) -> (ast::NodeId, CFGIndex) {\n+\n+        match destination.target_id {\n+            hir::ScopeTarget::Block(block_expr_id) => {\n+                for b in &self.breakable_block_scopes {\n+                    if b.block_expr_id == block_expr_id {\n+                        return (block_expr_id, match scope_cf_kind {\n+                            ScopeCfKind::Break => b.break_index,\n+                            ScopeCfKind::Continue => bug!(\"can't continue to block\"),\n+                        });\n+                    }\n+                }\n+                span_bug!(expr.span, \"no block expr for id {}\", block_expr_id);\n+            }\n+            hir::ScopeTarget::Loop(hir::LoopIdResult::Ok(loop_id)) => {\n                 for l in &self.loop_scopes {\n                     if l.loop_id == loop_id {\n-                        return *l;\n+                        return (loop_id, match scope_cf_kind {\n+                            ScopeCfKind::Break => l.break_index,\n+                            ScopeCfKind::Continue => l.continue_index,\n+                        });\n                     }\n                 }\n                 span_bug!(expr.span, \"no loop scope for id {}\", loop_id);\n             }\n-            Err(err) => span_bug!(expr.span, \"loop scope error: {}\", err),\n+            hir::ScopeTarget::Loop(hir::LoopIdResult::Err(err)) =>\n+                span_bug!(expr.span, \"loop scope error: {}\",  err),\n         }\n     }\n }\n+\n+#[derive(Copy, Clone, Eq, PartialEq)]\n+enum ScopeCfKind {\n+    Break,\n+    Continue,\n+}"}, {"sha": "f59b8b757f5cc4de61cb1aae6731a8ee023655e9", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fc04eaacc5bd5760e98cd3aa390dcc3ae795d12f/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc04eaacc5bd5760e98cd3aa390dcc3ae795d12f/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=fc04eaacc5bd5760e98cd3aa390dcc3ae795d12f", "patch": "@@ -1008,18 +1008,24 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n         }\n         ExprBreak(label, ref opt_expr) => {\n             label.ident.map(|ident| {\n-                if let Ok(loop_id) = label.loop_id.into() {\n-                    visitor.visit_def_mention(Def::Label(loop_id));\n-                }\n+                match label.target_id {\n+                    ScopeTarget::Block(node_id) |\n+                    ScopeTarget::Loop(LoopIdResult::Ok(node_id)) =>\n+                        visitor.visit_def_mention(Def::Label(node_id)),\n+                    ScopeTarget::Loop(LoopIdResult::Err(_)) => {},\n+                };\n                 visitor.visit_name(ident.span, ident.node.name);\n             });\n             walk_list!(visitor, visit_expr, opt_expr);\n         }\n         ExprAgain(label) => {\n             label.ident.map(|ident| {\n-                if let Ok(loop_id) = label.loop_id.into() {\n-                    visitor.visit_def_mention(Def::Label(loop_id));\n-                }\n+                match label.target_id {\n+                    ScopeTarget::Block(_) => bug!(\"can't `continue` to a non-loop block\"),\n+                    ScopeTarget::Loop(LoopIdResult::Ok(node_id)) =>\n+                        visitor.visit_def_mention(Def::Label(node_id)),\n+                    ScopeTarget::Loop(LoopIdResult::Err(_)) => {},\n+                };\n                 visitor.visit_name(ident.span, ident.node.name);\n             });\n         }"}, {"sha": "4a927261bdafbd82660167e378a4048ffae1eb3f", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 56, "deletions": 33, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/fc04eaacc5bd5760e98cd3aa390dcc3ae795d12f/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc04eaacc5bd5760e98cd3aa390dcc3ae795d12f/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=fc04eaacc5bd5760e98cd3aa390dcc3ae795d12f", "patch": "@@ -356,22 +356,26 @@ impl<'a> LoweringContext<'a> {\n         o_id.map(|sp_ident| respan(sp_ident.span, sp_ident.node.name))\n     }\n \n-    fn lower_destination(&mut self, destination: Option<(NodeId, Spanned<Ident>)>)\n+    fn lower_loop_destination(&mut self, destination: Option<(NodeId, Spanned<Ident>)>)\n         -> hir::Destination\n     {\n         match destination {\n-            Some((id, label_ident)) => hir::Destination {\n-                ident: Some(label_ident),\n-                loop_id: if let Def::Label(loop_id) = self.expect_full_def(id) {\n+            Some((id, label_ident)) => {\n+                let target = if let Def::Label(loop_id) = self.expect_full_def(id) {\n                     hir::LoopIdResult::Ok(loop_id)\n                 } else {\n                     hir::LoopIdResult::Err(hir::LoopIdError::UnresolvedLabel)\n+                };\n+                hir::Destination {\n+                    ident: Some(label_ident),\n+                    target_id: hir::ScopeTarget::Loop(target),\n                 }\n             },\n             None => hir::Destination {\n                 ident: None,\n-                loop_id: self.loop_scopes.last().map(|innermost_loop_id| Ok(*innermost_loop_id))\n-                            .unwrap_or(Err(hir::LoopIdError::OutsideLoopScope)).into()\n+                target_id: hir::ScopeTarget::Loop(\n+                    self.loop_scopes.last().map(|innermost_loop_id| Ok(*innermost_loop_id))\n+                            .unwrap_or(Err(hir::LoopIdError::OutsideLoopScope)).into())\n             }\n         }\n     }\n@@ -990,7 +994,7 @@ impl<'a> LoweringContext<'a> {\n         bounds.iter().map(|bound| self.lower_ty_param_bound(bound)).collect()\n     }\n \n-    fn lower_block(&mut self, b: &Block) -> P<hir::Block> {\n+    fn lower_block(&mut self, b: &Block, break_to: Option<NodeId>) -> P<hir::Block> {\n         let mut expr = None;\n \n         let mut stmts = b.stmts.iter().flat_map(|s| self.lower_stmt(s)).collect::<Vec<_>>();\n@@ -1008,6 +1012,7 @@ impl<'a> LoweringContext<'a> {\n             expr: expr,\n             rules: self.lower_block_check_mode(&b.rules),\n             span: b.span,\n+            break_to_expr_id: break_to,\n         })\n     }\n \n@@ -1085,7 +1090,7 @@ impl<'a> LoweringContext<'a> {\n             }\n             ItemKind::Fn(ref decl, unsafety, constness, abi, ref generics, ref body) => {\n                 self.with_new_scopes(|this| {\n-                    let body = this.lower_block(body);\n+                    let body = this.lower_block(body, None);\n                     let body = this.expr_block(body, ThinVec::new());\n                     let body_id = this.record_body(body, Some(decl));\n                     hir::ItemFn(this.lower_fn_decl(decl),\n@@ -1179,7 +1184,7 @@ impl<'a> LoweringContext<'a> {\n                                                    hir::TraitMethod::Required(names))\n                     }\n                     TraitItemKind::Method(ref sig, Some(ref body)) => {\n-                        let body = this.lower_block(body);\n+                        let body = this.lower_block(body, None);\n                         let expr = this.expr_block(body, ThinVec::new());\n                         let body_id = this.record_body(expr, Some(&sig.decl));\n                         hir::TraitItemKind::Method(this.lower_method_sig(sig),\n@@ -1235,7 +1240,7 @@ impl<'a> LoweringContext<'a> {\n                         hir::ImplItemKind::Const(this.lower_ty(ty), body_id)\n                     }\n                     ImplItemKind::Method(ref sig, ref body) => {\n-                        let body = this.lower_block(body);\n+                        let body = this.lower_block(body, None);\n                         let expr = this.expr_block(body, ThinVec::new());\n                         let body_id = this.record_body(expr, Some(&sig.decl));\n                         hir::ImplItemKind::Method(this.lower_method_sig(sig), body_id)\n@@ -1662,31 +1667,32 @@ impl<'a> LoweringContext<'a> {\n                                     id: id,\n                                     rules: hir::DefaultBlock,\n                                     span: span,\n+                                    break_to_expr_id: None,\n                                 });\n                                 P(self.expr_block(blk, ThinVec::new()))\n                             }\n                             _ => P(self.lower_expr(els)),\n                         }\n                     });\n \n-                    hir::ExprIf(P(self.lower_expr(cond)), self.lower_block(blk), else_opt)\n+                    hir::ExprIf(P(self.lower_expr(cond)), self.lower_block(blk, None), else_opt)\n                 }\n                 ExprKind::While(ref cond, ref body, opt_ident) => {\n                     self.with_loop_scope(e.id, |this|\n                         hir::ExprWhile(\n                             this.with_loop_condition_scope(|this| P(this.lower_expr(cond))),\n-                            this.lower_block(body),\n+                            this.lower_block(body, None),\n                             this.lower_opt_sp_ident(opt_ident)))\n                 }\n                 ExprKind::Loop(ref body, opt_ident) => {\n                     self.with_loop_scope(e.id, |this|\n-                        hir::ExprLoop(this.lower_block(body),\n+                        hir::ExprLoop(this.lower_block(body, None),\n                                       this.lower_opt_sp_ident(opt_ident),\n                                       hir::LoopSource::Loop))\n                 }\n                 ExprKind::Catch(ref body) => {\n-                    // FIXME(cramertj): Add catch to HIR\n-                    self.with_catch_scope(e.id, |this| hir::ExprBlock(this.lower_block(body)))\n+                    self.with_catch_scope(e.id, |this|\n+                        hir::ExprBlock(this.lower_block(body, Some(e.id))))\n                 }\n                 ExprKind::Match(ref expr, ref arms) => {\n                     hir::ExprMatch(P(self.lower_expr(expr)),\n@@ -1704,7 +1710,7 @@ impl<'a> LoweringContext<'a> {\n                         })\n                     })\n                 }\n-                ExprKind::Block(ref blk) => hir::ExprBlock(self.lower_block(blk)),\n+                ExprKind::Block(ref blk) => hir::ExprBlock(self.lower_block(blk, None)),\n                 ExprKind::Assign(ref el, ref er) => {\n                     hir::ExprAssign(P(self.lower_expr(el)), P(self.lower_expr(er)))\n                 }\n@@ -1783,10 +1789,11 @@ impl<'a> LoweringContext<'a> {\n                     let label_result = if self.is_in_loop_condition && opt_ident.is_none() {\n                         hir::Destination {\n                             ident: opt_ident,\n-                            loop_id: Err(hir::LoopIdError::UnlabeledCfInWhileCondition).into(),\n+                            target_id: hir::ScopeTarget::Loop(\n+                                Err(hir::LoopIdError::UnlabeledCfInWhileCondition).into()),\n                         }\n                     } else {\n-                        self.lower_destination(opt_ident.map(|ident| (e.id, ident)))\n+                        self.lower_loop_destination(opt_ident.map(|ident| (e.id, ident)))\n                     };\n                     hir::ExprBreak(\n                             label_result,\n@@ -1797,11 +1804,11 @@ impl<'a> LoweringContext<'a> {\n                         if self.is_in_loop_condition && opt_ident.is_none() {\n                             hir::Destination {\n                                 ident: opt_ident,\n-                                loop_id: Err(\n-                                    hir::LoopIdError::UnlabeledCfInWhileCondition).into(),\n+                                target_id: hir::ScopeTarget::Loop(Err(\n+                                    hir::LoopIdError::UnlabeledCfInWhileCondition).into()),\n                             }\n                         } else {\n-                            self.lower_destination(opt_ident.map( |ident| (e.id, ident)))\n+                            self.lower_loop_destination(opt_ident.map( |ident| (e.id, ident)))\n                         }),\n                 ExprKind::Ret(ref e) => hir::ExprRet(e.as_ref().map(|x| P(self.lower_expr(x)))),\n                 ExprKind::InlineAsm(ref asm) => {\n@@ -1859,7 +1866,7 @@ impl<'a> LoweringContext<'a> {\n \n                     // `<pat> => <body>`\n                     let pat_arm = {\n-                        let body = self.lower_block(body);\n+                        let body = self.lower_block(body, None);\n                         let body_expr = P(self.expr_block(body, ThinVec::new()));\n                         let pat = self.lower_pat(pat);\n                         self.arm(hir_vec![pat], body_expr)\n@@ -1946,7 +1953,7 @@ impl<'a> LoweringContext<'a> {\n                     // Note that the block AND the condition are evaluated in the loop scope.\n                     // This is done to allow `break` from inside the condition of the loop.\n                     let (body, break_expr, sub_expr) = self.with_loop_scope(e.id, |this| (\n-                        this.lower_block(body),\n+                        this.lower_block(body, None),\n                         this.expr_break(e.span, ThinVec::new()),\n                         this.with_loop_condition_scope(|this| P(this.lower_expr(sub_expr))),\n                     ));\n@@ -2007,7 +2014,8 @@ impl<'a> LoweringContext<'a> {\n \n                     // `::std::option::Option::Some(<pat>) => <body>`\n                     let pat_arm = {\n-                        let body_block = self.with_loop_scope(e.id, |this| this.lower_block(body));\n+                        let body_block = self.with_loop_scope(e.id,\n+                                                              |this| this.lower_block(body, None));\n                         let body_expr = P(self.expr_block(body_block, ThinVec::new()));\n                         let pat = self.lower_pat(pat);\n                         let some_pat = self.pat_some(e.span, pat);\n@@ -2090,14 +2098,12 @@ impl<'a> LoweringContext<'a> {\n                     // match Carrier::translate(<expr>) {\n                     //     Ok(val) => #[allow(unreachable_code)] val,\n                     //     Err(err) => #[allow(unreachable_code)]\n+                    //                 // If there is an enclosing `catch {...}`\n+                    //                 break 'catch_target Carrier::from_error(From::from(err)),\n+                    //                 // Otherwise\n                     //                 return Carrier::from_error(From::from(err)),\n                     // }\n \n-                    // FIXME(cramertj): implement breaking to catch\n-                    if !self.catch_scopes.is_empty() {\n-                        bug!(\"`?` in catch scopes is unimplemented\")\n-                    }\n-\n                     let unstable_span = self.allow_internal_unstable(\"?\", e.span);\n \n                     // Carrier::translate(<expr>)\n@@ -2157,9 +2163,24 @@ impl<'a> LoweringContext<'a> {\n                             P(self.expr_call(e.span, from_err, hir_vec![from_expr]))\n                         };\n \n-                        let ret_expr = P(self.expr(e.span,\n-                                                   hir::Expr_::ExprRet(Some(from_err_expr)),\n-                                                                       ThinVec::from(attrs)));\n+                        let thin_attrs = ThinVec::from(attrs);\n+                        let catch_scope = self.catch_scopes.last().map(|x| *x);\n+                        let ret_expr = if let Some(catch_node) = catch_scope {\n+                            P(self.expr(\n+                                e.span,\n+                                hir::ExprBreak(\n+                                    hir::Destination {\n+                                        ident: None,\n+                                        target_id: hir::ScopeTarget::Block(catch_node),\n+                                    },\n+                                    Some(from_err_expr)\n+                                ),\n+                                thin_attrs))\n+                        } else {\n+                            P(self.expr(e.span,\n+                                        hir::Expr_::ExprRet(Some(from_err_expr)),\n+                                        thin_attrs))\n+                        };\n \n                         let err_pat = self.pat_err(e.span, err_local);\n                         self.arm(hir_vec![err_pat], ret_expr)\n@@ -2302,7 +2323,7 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     fn expr_break(&mut self, span: Span, attrs: ThinVec<Attribute>) -> P<hir::Expr> {\n-        let expr_break = hir::ExprBreak(self.lower_destination(None), None);\n+        let expr_break = hir::ExprBreak(self.lower_loop_destination(None), None);\n         P(self.expr(span, expr_break, attrs))\n     }\n \n@@ -2415,6 +2436,7 @@ impl<'a> LoweringContext<'a> {\n             id: self.next_id(),\n             rules: hir::DefaultBlock,\n             span: span,\n+            break_to_expr_id: None,\n         }\n     }\n \n@@ -2519,6 +2541,7 @@ impl<'a> LoweringContext<'a> {\n             id: id,\n             stmts: stmts,\n             expr: Some(expr),\n+            break_to_expr_id: None,\n         });\n         self.expr_block(block, attrs)\n     }"}, {"sha": "d5f496b90035dc526c6fb22de6f3737cf3bad5d8", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/fc04eaacc5bd5760e98cd3aa390dcc3ae795d12f/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc04eaacc5bd5760e98cd3aa390dcc3ae795d12f/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=fc04eaacc5bd5760e98cd3aa390dcc3ae795d12f", "patch": "@@ -485,6 +485,9 @@ pub struct Block {\n     /// Distinguishes between `unsafe { ... }` and `{ ... }`\n     pub rules: BlockCheckMode,\n     pub span: Span,\n+    /// The id of the expression that `break` breaks to if the block can be broken out of.\n+    /// Currently only `Some(_)` for `catch {}` blocks\n+    pub break_to_expr_id: Option<NodeId>,\n }\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash)]\n@@ -1080,14 +1083,30 @@ impl From<Result<NodeId, LoopIdError>> for LoopIdResult {\n     }\n }\n \n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n+pub enum ScopeTarget {\n+    Block(NodeId),\n+    Loop(LoopIdResult),\n+}\n+\n+impl ScopeTarget {\n+    pub fn opt_id(self) -> Option<NodeId> {\n+        match self {\n+            ScopeTarget::Block(node_id) |\n+            ScopeTarget::Loop(LoopIdResult::Ok(node_id)) => Some(node_id),\n+            ScopeTarget::Loop(LoopIdResult::Err(_)) => None,\n+        }\n+    }\n+}\n+\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n pub struct Destination {\n     // This is `Some(_)` iff there is an explicit user-specified `label\n     pub ident: Option<Spanned<Ident>>,\n \n     // These errors are caught and then reported during the diagnostics pass in\n     // librustc_passes/loops.rs\n-    pub loop_id: LoopIdResult,\n+    pub target_id: ScopeTarget,\n }\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]"}, {"sha": "769dc8aeb54ddce49744a685505a047dd6da0e41", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 66, "deletions": 69, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/fc04eaacc5bd5760e98cd3aa390dcc3ae795d12f/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc04eaacc5bd5760e98cd3aa390dcc3ae795d12f/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=fc04eaacc5bd5760e98cd3aa390dcc3ae795d12f", "patch": "@@ -516,14 +516,15 @@ struct Liveness<'a, 'tcx: 'a> {\n     s: Specials,\n     successors: Vec<LiveNode>,\n     users: Vec<Users>,\n-    // The list of node IDs for the nested loop scopes\n-    // we're in.\n-    loop_scope: Vec<NodeId>,\n+\n     // mappings from loop node ID to LiveNode\n     // (\"break\" label should map to loop node ID,\n     // it probably doesn't now)\n     break_ln: NodeMap<LiveNode>,\n-    cont_ln: NodeMap<LiveNode>\n+    cont_ln: NodeMap<LiveNode>,\n+\n+    // mappings from node ID to LiveNode for \"breakable\" blocks-- currently only `catch {...}`\n+    breakable_block_ln: NodeMap<LiveNode>,\n }\n \n impl<'a, 'tcx> Liveness<'a, 'tcx> {\n@@ -550,9 +551,9 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             s: specials,\n             successors: vec![invalid_node(); num_live_nodes],\n             users: vec![invalid_users(); num_live_nodes * num_vars],\n-            loop_scope: Vec::new(),\n             break_ln: NodeMap(),\n             cont_ln: NodeMap(),\n+            breakable_block_ln: NodeMap(),\n         }\n     }\n \n@@ -793,15 +794,17 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         debug!(\"compute: using id for body, {}\", self.ir.tcx.hir.node_to_pretty_string(body.id));\n \n         let exit_ln = self.s.exit_ln;\n-        let entry_ln: LiveNode = self.with_loop_nodes(body.id, exit_ln, exit_ln, |this| {\n-            // the fallthrough exit is only for those cases where we do not\n-            // explicitly return:\n-            let s = this.s;\n-            this.init_from_succ(s.fallthrough_ln, s.exit_ln);\n-            this.acc(s.fallthrough_ln, s.clean_exit_var, ACC_READ);\n-\n-            this.propagate_through_expr(body, s.fallthrough_ln)\n-        });\n+\n+        self.break_ln.insert(body.id, exit_ln);\n+        self.cont_ln.insert(body.id, exit_ln);\n+\n+        // the fallthrough exit is only for those cases where we do not\n+        // explicitly return:\n+        let s = self.s;\n+        self.init_from_succ(s.fallthrough_ln, s.exit_ln);\n+        self.acc(s.fallthrough_ln, s.clean_exit_var, ACC_READ);\n+\n+        let entry_ln = self.propagate_through_expr(body, s.fallthrough_ln);\n \n         // hack to skip the loop unless debug! is enabled:\n         debug!(\"^^ liveness computation results for body {} (entry={:?})\",\n@@ -818,6 +821,9 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n     fn propagate_through_block(&mut self, blk: &hir::Block, succ: LiveNode)\n                                -> LiveNode {\n+        if let Some(break_to_expr_id) = blk.break_to_expr_id {\n+            self.breakable_block_ln.insert(break_to_expr_id, succ);\n+        }\n         let succ = self.propagate_through_opt_expr(blk.expr.as_ref().map(|e| &**e), succ);\n         blk.stmts.iter().rev().fold(succ, |succ, stmt| {\n             self.propagate_through_stmt(stmt, succ)\n@@ -901,30 +907,32 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n           }\n \n           hir::ExprClosure(.., blk_id, _) => {\n-              debug!(\"{} is an ExprClosure\",\n-                     self.ir.tcx.hir.node_to_pretty_string(expr.id));\n+              debug!(\"{} is an ExprClosure\", self.ir.tcx.hir.node_to_pretty_string(expr.id));\n \n               /*\n               The next-node for a break is the successor of the entire\n               loop. The next-node for a continue is the top of this loop.\n               */\n               let node = self.live_node(expr.id, expr.span);\n-              self.with_loop_nodes(blk_id.node_id, succ, node, |this| {\n-\n-                 // the construction of a closure itself is not important,\n-                 // but we have to consider the closed over variables.\n-                 let caps = match this.ir.capture_info_map.get(&expr.id) {\n-                    Some(caps) => caps.clone(),\n-                    None => {\n-                        span_bug!(expr.span, \"no registered caps\");\n-                     }\n-                 };\n-                 caps.iter().rev().fold(succ, |succ, cap| {\n-                     this.init_from_succ(cap.ln, succ);\n-                     let var = this.variable(cap.var_nid, expr.span);\n-                     this.acc(cap.ln, var, ACC_READ | ACC_USE);\n-                     cap.ln\n-                 })\n+\n+              let break_ln = succ;\n+              let cont_ln = node;\n+              self.break_ln.insert(blk_id.node_id, break_ln);\n+              self.cont_ln.insert(blk_id.node_id, cont_ln);\n+\n+              // the construction of a closure itself is not important,\n+              // but we have to consider the closed over variables.\n+              let caps = match self.ir.capture_info_map.get(&expr.id) {\n+                  Some(caps) => caps.clone(),\n+                  None => {\n+                      span_bug!(expr.span, \"no registered caps\");\n+                  }\n+              };\n+              caps.iter().rev().fold(succ, |succ, cap| {\n+                  self.init_from_succ(cap.ln, succ);\n+                  let var = self.variable(cap.var_nid, expr.span);\n+                  self.acc(cap.ln, var, ACC_READ | ACC_USE);\n+                  cap.ln\n               })\n           }\n \n@@ -1003,28 +1011,33 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n           hir::ExprBreak(label, ref opt_expr) => {\n               // Find which label this break jumps to\n-              let sc = match label.loop_id.into() {\n-                  Ok(loop_id) => loop_id,\n-                  Err(err) => span_bug!(expr.span, \"loop scope error: {}\", err),\n-              };\n+              let target = match label.target_id {\n+                    hir::ScopeTarget::Block(node_id) =>\n+                        self.breakable_block_ln.get(&node_id),\n+                    hir::ScopeTarget::Loop(hir::LoopIdResult::Ok(node_id)) =>\n+                        self.break_ln.get(&node_id),\n+                    hir::ScopeTarget::Loop(hir::LoopIdResult::Err(err)) =>\n+                        span_bug!(expr.span, \"loop scope error: {}\", err),\n+              }.map(|x| *x);\n \n               // Now that we know the label we're going to,\n               // look it up in the break loop nodes table\n \n-              match self.break_ln.get(&sc) {\n-                  Some(&b) => self.propagate_through_opt_expr(opt_expr.as_ref().map(|e| &**e), b),\n+              match target {\n+                  Some(b) => self.propagate_through_opt_expr(opt_expr.as_ref().map(|e| &**e), b),\n                   None => span_bug!(expr.span, \"break to unknown label\")\n               }\n           }\n \n           hir::ExprAgain(label) => {\n               // Find which label this expr continues to\n-              let sc = match label.loop_id.into() {\n-                  Ok(loop_id) => loop_id,\n-                  Err(err) => span_bug!(expr.span, \"loop scope error: {}\", err),\n+              let sc = match label.target_id {\n+                    hir::ScopeTarget::Block(_) => bug!(\"can't `continue` to a non-loop block\"),\n+                    hir::ScopeTarget::Loop(hir::LoopIdResult::Ok(node_id)) => node_id,\n+                    hir::ScopeTarget::Loop(hir::LoopIdResult::Err(err)) =>\n+                        span_bug!(expr.span, \"loop scope error: {}\", err),\n               };\n \n-\n               // Now that we know the label we're going to,\n               // look it up in the continue loop nodes table\n \n@@ -1287,14 +1300,16 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         debug!(\"propagate_through_loop: using id for loop body {} {}\",\n                expr.id, self.ir.tcx.hir.node_to_pretty_string(body.id));\n \n-        let (cond_ln, body_ln) = self.with_loop_nodes(expr.id, succ, ln, |this| {\n-            let cond_ln = match kind {\n-                LoopLoop => ln,\n-                WhileLoop(ref cond) => this.propagate_through_expr(&cond, ln),\n-            };\n-            let body_ln = this.propagate_through_block(body, cond_ln);\n-            (cond_ln, body_ln)\n-        });\n+        let break_ln = succ;\n+        let cont_ln = ln;\n+        self.break_ln.insert(expr.id, break_ln);\n+        self.cont_ln.insert(expr.id, cont_ln);\n+\n+        let cond_ln = match kind {\n+            LoopLoop => ln,\n+            WhileLoop(ref cond) => self.propagate_through_expr(&cond, ln),\n+        };\n+        let body_ln = self.propagate_through_block(body, cond_ln);\n \n         // repeat until fixed point is reached:\n         while self.merge_from_succ(ln, body_ln, first_merge) {\n@@ -1307,29 +1322,11 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                 }\n             };\n             assert!(cond_ln == new_cond_ln);\n-            assert!(body_ln == self.with_loop_nodes(expr.id, succ, ln,\n-            |this| this.propagate_through_block(body, cond_ln)));\n+            assert!(body_ln == self.propagate_through_block(body, cond_ln));\n         }\n \n         cond_ln\n     }\n-\n-    fn with_loop_nodes<R, F>(&mut self,\n-                             loop_node_id: NodeId,\n-                             break_ln: LiveNode,\n-                             cont_ln: LiveNode,\n-                             f: F)\n-                             -> R where\n-        F: FnOnce(&mut Liveness<'a, 'tcx>) -> R,\n-    {\n-        debug!(\"with_loop_nodes: {} {}\", loop_node_id, break_ln.get());\n-        self.loop_scope.push(loop_node_id);\n-        self.break_ln.insert(loop_node_id, break_ln);\n-        self.cont_ln.insert(loop_node_id, cont_ln);\n-        let r = f(self);\n-        self.loop_scope.pop();\n-        r\n-    }\n }\n \n // _______________________________________________________________________"}, {"sha": "e1b0c6a6f042e0ee980b39d05688b45e4277958b", "filename": "src/librustc_mir/build/expr/into.rs", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fc04eaacc5bd5760e98cd3aa390dcc3ae795d12f/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc04eaacc5bd5760e98cd3aa390dcc3ae795d12f/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs?ref=fc04eaacc5bd5760e98cd3aa390dcc3ae795d12f", "patch": "@@ -40,7 +40,19 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 this.in_scope(extent, block, |this| this.into(destination, block, value))\n             }\n             ExprKind::Block { body: ast_block } => {\n-                this.ast_block(destination, block, ast_block)\n+                if let Some(_) = ast_block.break_to_expr_id {\n+                    // This is a `break`-able block (currently only `catch { ... }`)\n+                    let exit_block = this.cfg.start_new_block();\n+                    let block_exit = this.in_breakable_scope(None, exit_block,\n+                                                             destination.clone(), |this| {\n+                        this.ast_block(destination, block, ast_block)\n+                    });\n+                    this.cfg.terminate(unpack!(block_exit), source_info,\n+                                       TerminatorKind::Goto { target: exit_block });\n+                    exit_block.unit()\n+                } else {\n+                    this.ast_block(destination, block, ast_block)\n+                }\n             }\n             ExprKind::Match { discriminant, arms } => {\n                 this.match_expr(destination, expr_span, block, discriminant, arms)\n@@ -165,8 +177,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 this.cfg.terminate(block, source_info,\n                                    TerminatorKind::Goto { target: loop_block });\n \n-                this.in_loop_scope(\n-                    loop_block, exit_block, destination.clone(),\n+                this.in_breakable_scope(\n+                    Some(loop_block), exit_block, destination.clone(),\n                     move |this| {\n                         // conduct the test, if necessary\n                         let body_block;"}, {"sha": "7336da654c1840f550e82d5b66ffc125bd7454ac", "filename": "src/librustc_mir/build/expr/stmt.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fc04eaacc5bd5760e98cd3aa390dcc3ae795d12f/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc04eaacc5bd5760e98cd3aa390dcc3ae795d12f/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fstmt.rs?ref=fc04eaacc5bd5760e98cd3aa390dcc3ae795d12f", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use build::{BlockAnd, BlockAndExtension, Builder};\n-use build::scope::LoopScope;\n+use build::scope::BreakableScope;\n use hair::*;\n use rustc::mir::*;\n \n@@ -77,19 +77,21 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 block.unit()\n             }\n             ExprKind::Continue { label } => {\n-                let LoopScope { continue_block, extent, .. } =\n-                    *this.find_loop_scope(expr_span, label);\n+                let BreakableScope { continue_block, extent, .. } =\n+                    *this.find_breakable_scope(expr_span, label);\n+                let continue_block = continue_block.expect(\n+                    \"Attempted to continue in non-continuable breakable block\");\n                 this.exit_scope(expr_span, extent, block, continue_block);\n                 this.cfg.start_new_block().unit()\n             }\n             ExprKind::Break { label, value } => {\n                 let (break_block, extent, destination) = {\n-                    let LoopScope {\n+                    let BreakableScope {\n                         break_block,\n                         extent,\n                         ref break_destination,\n                         ..\n-                    } = *this.find_loop_scope(expr_span, label);\n+                    } = *this.find_breakable_scope(expr_span, label);\n                     (break_block, extent, break_destination.clone())\n                 };\n                 if let Some(value) = value {"}, {"sha": "db03a1c68f7156023cde3ad4c0b631b71036fb41", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fc04eaacc5bd5760e98cd3aa390dcc3ae795d12f/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc04eaacc5bd5760e98cd3aa390dcc3ae795d12f/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=fc04eaacc5bd5760e98cd3aa390dcc3ae795d12f", "patch": "@@ -36,9 +36,9 @@ pub struct Builder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     /// see the `scope` module for more details\n     scopes: Vec<scope::Scope<'tcx>>,\n \n-    /// the current set of loops; see the `scope` module for more\n+    /// the current set of breakables; see the `scope` module for more\n     /// details\n-    loop_scopes: Vec<scope::LoopScope<'tcx>>,\n+    breakable_scopes: Vec<scope::BreakableScope<'tcx>>,\n \n     /// the vector of all scopes that we have created thus far;\n     /// we track this for debuginfo later\n@@ -248,7 +248,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             scopes: vec![],\n             visibility_scopes: IndexVec::new(),\n             visibility_scope: ARGUMENT_VISIBILITY_SCOPE,\n-            loop_scopes: vec![],\n+            breakable_scopes: vec![],\n             local_decls: IndexVec::from_elem_n(LocalDecl::new_return_pointer(return_ty), 1),\n             var_indices: NodeMap(),\n             unit_temp: None,"}, {"sha": "1de5b9218564fdb73a96682b9fb3dc291c540392", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 25, "deletions": 24, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/fc04eaacc5bd5760e98cd3aa390dcc3ae795d12f/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc04eaacc5bd5760e98cd3aa390dcc3ae795d12f/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=fc04eaacc5bd5760e98cd3aa390dcc3ae795d12f", "patch": "@@ -177,16 +177,16 @@ struct FreeData<'tcx> {\n }\n \n #[derive(Clone, Debug)]\n-pub struct LoopScope<'tcx> {\n+pub struct BreakableScope<'tcx> {\n     /// Extent of the loop\n     pub extent: CodeExtent,\n-    /// Where the body of the loop begins\n-    pub continue_block: BasicBlock,\n-    /// Block to branch into when the loop terminates (either by being `break`-en out from, or by\n-    /// having its condition to become false)\n+    /// Where the body of the loop begins. `None` if block\n+    pub continue_block: Option<BasicBlock>,\n+    /// Block to branch into when the loop or block terminates (either by being `break`-en out\n+    /// from, or by having its condition to become false)\n     pub break_block: BasicBlock,\n-    /// The destination of the loop expression itself (i.e. where to put the result of a `break`\n-    /// expression)\n+    /// The destination of the loop/block expression itself (i.e. where to put the result of a\n+    /// `break` expression)\n     pub break_destination: Lvalue<'tcx>,\n }\n \n@@ -242,28 +242,29 @@ impl<'tcx> Scope<'tcx> {\n impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     // Adding and removing scopes\n     // ==========================\n-    /// Start a loop scope, which tracks where `continue` and `break`\n+    /// Start a breakable scope, which tracks where `continue` and `break`\n     /// should branch to. See module comment for more details.\n     ///\n-    /// Returns the might_break attribute of the LoopScope used.\n-    pub fn in_loop_scope<F>(&mut self,\n-                            loop_block: BasicBlock,\n+    /// Returns the might_break attribute of the BreakableScope used.\n+    pub fn in_breakable_scope<F, R>(&mut self,\n+                            loop_block: Option<BasicBlock>,\n                             break_block: BasicBlock,\n                             break_destination: Lvalue<'tcx>,\n-                            f: F)\n-        where F: FnOnce(&mut Builder<'a, 'gcx, 'tcx>)\n+                            f: F) -> R\n+        where F: FnOnce(&mut Builder<'a, 'gcx, 'tcx>) -> R\n     {\n         let extent = self.topmost_scope();\n-        let loop_scope = LoopScope {\n+        let scope = BreakableScope {\n             extent: extent,\n             continue_block: loop_block,\n             break_block: break_block,\n             break_destination: break_destination,\n         };\n-        self.loop_scopes.push(loop_scope);\n-        f(self);\n-        let loop_scope = self.loop_scopes.pop().unwrap();\n-        assert!(loop_scope.extent == extent);\n+        self.breakable_scopes.push(scope);\n+        let res = f(self);\n+        let breakable_scope = self.breakable_scopes.pop().unwrap();\n+        assert!(breakable_scope.extent == extent);\n+        res\n     }\n \n     /// Convenience wrapper that pushes a scope and then executes `f`\n@@ -381,18 +382,18 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n     // Finding scopes\n     // ==============\n-    /// Finds the loop scope for a given label. This is used for\n+    /// Finds the breakable scope for a given label. This is used for\n     /// resolving `break` and `continue`.\n-    pub fn find_loop_scope(&mut self,\n+    pub fn find_breakable_scope(&mut self,\n                            span: Span,\n                            label: CodeExtent)\n-                           -> &mut LoopScope<'tcx> {\n+                           -> &mut BreakableScope<'tcx> {\n         // find the loop-scope with the correct id\n-        self.loop_scopes.iter_mut()\n+        self.breakable_scopes.iter_mut()\n             .rev()\n-            .filter(|loop_scope| loop_scope.extent == label)\n+            .filter(|breakable_scope| breakable_scope.extent == label)\n             .next()\n-            .unwrap_or_else(|| span_bug!(span, \"no enclosing loop scope found?\"))\n+            .unwrap_or_else(|| span_bug!(span, \"no enclosing breakable scope found\"))\n     }\n \n     /// Given a span and the current visibility scope, make a SourceInfo."}, {"sha": "da58a1ed1f49b2a90c5f72b1fd4f7da63cd0b9b5", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/fc04eaacc5bd5760e98cd3aa390dcc3ae795d12f/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc04eaacc5bd5760e98cd3aa390dcc3ae795d12f/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=fc04eaacc5bd5760e98cd3aa390dcc3ae795d12f", "patch": "@@ -606,22 +606,25 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             }\n         }\n         hir::ExprRet(ref v) => ExprKind::Return { value: v.to_ref() },\n-        hir::ExprBreak(label, ref value) => {\n-            match label.loop_id.into() {\n-                Ok(loop_id) => ExprKind::Break {\n-                    label: cx.tcx.region_maps.node_extent(loop_id),\n+        hir::ExprBreak(dest, ref value) => {\n+            match dest.target_id {\n+                hir::ScopeTarget::Block(target_id) |\n+                hir::ScopeTarget::Loop(hir::LoopIdResult::Ok(target_id)) => ExprKind::Break {\n+                    label: cx.tcx.region_maps.node_extent(target_id),\n                     value: value.to_ref(),\n                 },\n-                Err(err) => bug!(\"invalid loop id for break: {}\", err)\n+                hir::ScopeTarget::Loop(hir::LoopIdResult::Err(err)) =>\n+                    bug!(\"invalid loop id for break: {}\", err)\n             }\n-\n         }\n-        hir::ExprAgain(label) => {\n-            match label.loop_id.into() {\n-                Ok(loop_id) => ExprKind::Continue {\n+        hir::ExprAgain(dest) => {\n+            match dest.target_id {\n+                hir::ScopeTarget::Block(_) => bug!(\"cannot continue to blocks\"),\n+                hir::ScopeTarget::Loop(hir::LoopIdResult::Ok(loop_id)) => ExprKind::Continue {\n                     label: cx.tcx.region_maps.node_extent(loop_id),\n                 },\n-                Err(err) => bug!(\"invalid loop id for continue: {}\", err)\n+                hir::ScopeTarget::Loop(hir::LoopIdResult::Err(err)) =>\n+                    bug!(\"invalid loop id for continue: {}\", err)\n             }\n         }\n         hir::ExprMatch(ref discr, ref arms, _) => {"}, {"sha": "421181c68c4cda90eef45bf85fe12ab59a27e424", "filename": "src/librustc_passes/loops.rs", "status": "modified", "additions": 16, "deletions": 9, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/fc04eaacc5bd5760e98cd3aa390dcc3ae795d12f/src%2Flibrustc_passes%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc04eaacc5bd5760e98cd3aa390dcc3ae795d12f/src%2Flibrustc_passes%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Floops.rs?ref=fc04eaacc5bd5760e98cd3aa390dcc3ae795d12f", "patch": "@@ -87,14 +87,19 @@ impl<'a, 'hir> Visitor<'hir> for CheckLoopVisitor<'a, 'hir> {\n                 self.with_context(Closure, |v| v.visit_nested_body(b));\n             }\n             hir::ExprBreak(label, ref opt_expr) => {\n-                let loop_id = match label.loop_id.into() {\n-                    Ok(loop_id) => loop_id,\n-                    Err(hir::LoopIdError::OutsideLoopScope) => ast::DUMMY_NODE_ID,\n-                    Err(hir::LoopIdError::UnlabeledCfInWhileCondition) => {\n-                        self.emit_unlabled_cf_in_while_condition(e.span, \"break\");\n-                        ast::DUMMY_NODE_ID\n-                    },\n-                    Err(hir::LoopIdError::UnresolvedLabel) => ast::DUMMY_NODE_ID,\n+                let loop_id = match label.target_id {\n+                    hir::ScopeTarget::Block(_) => return,\n+                    hir::ScopeTarget::Loop(loop_res) => {\n+                        match loop_res.into() {\n+                            Ok(loop_id) => loop_id,\n+                            Err(hir::LoopIdError::OutsideLoopScope) => ast::DUMMY_NODE_ID,\n+                            Err(hir::LoopIdError::UnlabeledCfInWhileCondition) => {\n+                                self.emit_unlabled_cf_in_while_condition(e.span, \"break\");\n+                                ast::DUMMY_NODE_ID\n+                            },\n+                            Err(hir::LoopIdError::UnresolvedLabel) => ast::DUMMY_NODE_ID,\n+                        }\n+                    }\n                 };\n \n                 if opt_expr.is_some() {\n@@ -124,7 +129,9 @@ impl<'a, 'hir> Visitor<'hir> for CheckLoopVisitor<'a, 'hir> {\n                 self.require_loop(\"break\", e.span);\n             }\n             hir::ExprAgain(label) => {\n-                if let Err(hir::LoopIdError::UnlabeledCfInWhileCondition) = label.loop_id.into() {\n+                if let hir::ScopeTarget::Loop(\n+                    hir::LoopIdResult::Err(\n+                        hir::LoopIdError::UnlabeledCfInWhileCondition)) = label.target_id {\n                     self.emit_unlabled_cf_in_while_condition(e.span, \"continue\");\n                 }\n                 self.require_loop(\"continue\", e.span)"}, {"sha": "894c5f12297a0fc62a8a238623224ec10c413af0", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 153, "deletions": 87, "changes": 240, "blob_url": "https://github.com/rust-lang/rust/blob/fc04eaacc5bd5760e98cd3aa390dcc3ae795d12f/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc04eaacc5bd5760e98cd3aa390dcc3ae795d12f/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=fc04eaacc5bd5760e98cd3aa390dcc3ae795d12f", "patch": "@@ -402,23 +402,25 @@ impl Diverges {\n }\n \n #[derive(Clone)]\n-pub struct LoopCtxt<'gcx, 'tcx> {\n+pub struct BreakableCtxt<'gcx, 'tcx> {\n     unified: Ty<'tcx>,\n     coerce_to: Ty<'tcx>,\n     break_exprs: Vec<&'gcx hir::Expr>,\n     may_break: bool,\n }\n \n #[derive(Clone)]\n-pub struct EnclosingLoops<'gcx, 'tcx> {\n-    stack: Vec<LoopCtxt<'gcx, 'tcx>>,\n+pub struct EnclosingBreakables<'gcx, 'tcx> {\n+    stack: Vec<BreakableCtxt<'gcx, 'tcx>>,\n     by_id: NodeMap<usize>,\n }\n \n-impl<'gcx, 'tcx> EnclosingLoops<'gcx, 'tcx> {\n-    fn find_loop(&mut self, id: hir::LoopIdResult) -> Option<&mut LoopCtxt<'gcx, 'tcx>> {\n-        let id_res: Result<_,_> = id.into();\n-        if let Some(ix) = id_res.ok().and_then(|id| self.by_id.get(&id).cloned()) {\n+impl<'gcx, 'tcx> EnclosingBreakables<'gcx, 'tcx> {\n+    fn find_breakable(&mut self, target: hir::ScopeTarget)\n+        -> Option<&mut BreakableCtxt<'gcx, 'tcx>>\n+    {\n+        let opt_index = target.opt_id().and_then(|id| self.by_id.get(&id).cloned());\n+        if let Some(ix) = opt_index {\n             Some(&mut self.stack[ix])\n         } else {\n             None\n@@ -448,7 +450,7 @@ pub struct FnCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     /// Whether any child nodes have any type errors.\n     has_errors: Cell<bool>,\n \n-    enclosing_loops: RefCell<EnclosingLoops<'gcx, 'tcx>>,\n+    enclosing_breakables: RefCell<EnclosingBreakables<'gcx, 'tcx>>,\n \n     inh: &'a Inherited<'a, 'gcx, 'tcx>,\n }\n@@ -1429,7 +1431,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                                      ast::CRATE_NODE_ID)),\n             diverges: Cell::new(Diverges::Maybe),\n             has_errors: Cell::new(false),\n-            enclosing_loops: RefCell::new(EnclosingLoops {\n+            enclosing_breakables: RefCell::new(EnclosingBreakables {\n                 stack: Vec::new(),\n                 by_id: NodeMap(),\n             }),\n@@ -3467,10 +3469,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n               }\n               tcx.mk_nil()\n           }\n-          hir::ExprBreak(label, ref expr_opt) => {\n+          hir::ExprBreak(destination, ref expr_opt) => {\n             let coerce_to = {\n-                let mut enclosing_loops = self.enclosing_loops.borrow_mut();\n-                enclosing_loops.find_loop(label.loop_id).map(|ctxt| ctxt.coerce_to)\n+                let mut enclosing_breakables = self.enclosing_breakables.borrow_mut();\n+                enclosing_breakables\n+                    .find_breakable(destination.target_id).map(|ctxt| ctxt.coerce_to)\n             };\n             if let Some(coerce_to) = coerce_to {\n                 let e_ty;\n@@ -3486,8 +3489,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     cause = self.misc(expr.span);\n                 }\n \n-                let mut enclosing_loops = self.enclosing_loops.borrow_mut();\n-                let ctxt = enclosing_loops.find_loop(label.loop_id).unwrap();\n+                let mut enclosing_breakables = self.enclosing_breakables.borrow_mut();\n+                let ctxt = enclosing_breakables.find_breakable(destination.target_id).unwrap();\n \n                 let result = if let Some(ref e) = *expr_opt {\n                     // Special-case the first element, as it has no \"previous expressions\".\n@@ -3517,8 +3520,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n                 ctxt.may_break = true;\n             }\n-            // Otherwise, we failed to find the enclosing loop; this can only happen if the\n-            // `break` was not inside a loop at all, which is caught by the loop-checking pass.\n+            // Otherwise, we failed to find the enclosing breakable; this can only happen if the\n+            // `break` target was not found, which is caught in HIR lowering and reported by the\n+            // loop-checking pass.\n             tcx.types.never\n           }\n           hir::ExprAgain(_) => { tcx.types.never }\n@@ -3575,13 +3579,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n           hir::ExprWhile(ref cond, ref body, _) => {\n             let unified = self.tcx.mk_nil();\n             let coerce_to = unified;\n-            let ctxt = LoopCtxt {\n+            let ctxt = BreakableCtxt {\n                 unified: unified,\n                 coerce_to: coerce_to,\n                 break_exprs: vec![],\n                 may_break: true,\n             };\n-            self.with_loop_ctxt(expr.id, ctxt, || {\n+            self.with_breakable_ctxt(expr.id, ctxt, || {\n                 self.check_expr_has_type(&cond, tcx.types.bool);\n                 let cond_diverging = self.diverges.get();\n                 self.check_block_no_value(&body);\n@@ -3599,14 +3603,14 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n           hir::ExprLoop(ref body, _, _) => {\n             let unified = self.next_ty_var(TypeVariableOrigin::TypeInference(body.span));\n             let coerce_to = expected.only_has_type(self).unwrap_or(unified);\n-            let ctxt = LoopCtxt {\n+            let ctxt = BreakableCtxt {\n                 unified: unified,\n                 coerce_to: coerce_to,\n                 break_exprs: vec![],\n                 may_break: false,\n             };\n \n-            let ctxt = self.with_loop_ctxt(expr.id, ctxt, || {\n+            let (ctxt, ()) = self.with_breakable_ctxt(expr.id, ctxt, || {\n                 self.check_block_no_value(&body);\n             });\n             if ctxt.may_break {\n@@ -3625,8 +3629,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n           hir::ExprClosure(capture, ref decl, body_id, _) => {\n               self.check_expr_closure(expr, capture, &decl, body_id, expected)\n           }\n-          hir::ExprBlock(ref b) => {\n-            self.check_block_with_expected(&b, expected)\n+          hir::ExprBlock(ref body) => {\n+            self.check_block_with_expected(&body, expected)\n           }\n           hir::ExprCall(ref callee, ref args) => {\n               self.check_call(expr, &callee, args, expected)\n@@ -4018,65 +4022,85 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             replace(&mut *fcx_ps, unsafety_state)\n         };\n \n-        for s in &blk.stmts {\n-            self.check_stmt(s);\n-        }\n+        let mut ty = if let Some(break_to_expr_id) = blk.break_to_expr_id {\n+            let unified = self.next_ty_var(TypeVariableOrigin::TypeInference(blk.span));\n+            let coerce_to = expected.only_has_type(self).unwrap_or(unified);\n+            let ctxt = BreakableCtxt {\n+                unified: unified,\n+                coerce_to: coerce_to,\n+                break_exprs: vec![],\n+                may_break: false,\n+            };\n \n-        let mut ty = match blk.expr {\n-            Some(ref e) => self.check_expr_with_expectation(e, expected),\n-            None => self.tcx.mk_nil()\n-        };\n+            let (mut ctxt, (e_ty, cause)) = self.with_breakable_ctxt(break_to_expr_id, ctxt, || {\n+                for s in &blk.stmts {\n+                    self.check_stmt(s);\n+                }\n+                let coerce_to = {\n+                    let mut enclosing_breakables = self.enclosing_breakables.borrow_mut();\n+                    enclosing_breakables.find_breakable(\n+                        hir::ScopeTarget::Block(break_to_expr_id)\n+                    ).unwrap().coerce_to\n+                };\n+                let e_ty;\n+                let cause;\n+                match blk.expr {\n+                    Some(ref e) => {\n+                        e_ty = self.check_expr_with_hint(e, coerce_to);\n+                        cause = self.misc(e.span);\n+                    },\n+                    None => {\n+                        e_ty = self.tcx.mk_nil();\n+                        cause = self.misc(blk.span);\n+                    }\n+                };\n+\n+                (e_ty, cause)\n+            });\n \n-        if self.diverges.get().always() {\n-            ty = self.next_diverging_ty_var(TypeVariableOrigin::DivergingBlockExpr(blk.span));\n-        } else if let ExpectHasType(ety) = expected {\n             if let Some(ref e) = blk.expr {\n-                // Coerce the tail expression to the right type.\n-                self.demand_coerce(e, ty, ety);\n+                let result = if !ctxt.may_break {\n+                    self.try_coerce(e, e_ty, ctxt.coerce_to)\n+                } else {\n+                    self.try_find_coercion_lub(&cause, || ctxt.break_exprs.iter().cloned(),\n+                                               ctxt.unified, e, e_ty)\n+                };\n+                match result {\n+                    Ok(ty) => ctxt.unified = ty,\n+                    Err(err) =>\n+                        self.report_mismatched_types(&cause, ctxt.unified, e_ty, err).emit(),\n+                }\n             } else {\n-                // We're not diverging and there's an expected type, which,\n-                // in case it's not `()`, could result in an error higher-up.\n-                // We have a chance to error here early and be more helpful.\n-                let cause = self.misc(blk.span);\n-                let trace = TypeTrace::types(&cause, false, ty, ety);\n-                match self.sub_types(false, &cause, ty, ety) {\n-                    Ok(InferOk { obligations, .. }) => {\n-                        // FIXME(#32730) propagate obligations\n-                        assert!(obligations.is_empty());\n-                    },\n-                    Err(err) => {\n-                        let mut err = self.report_and_explain_type_error(trace, &err);\n-\n-                        // Be helpful when the user wrote `{... expr;}` and\n-                        // taking the `;` off is enough to fix the error.\n-                        let mut extra_semi = None;\n-                        if let Some(stmt) = blk.stmts.last() {\n-                            if let hir::StmtSemi(ref e, _) = stmt.node {\n-                                if self.can_sub_types(self.node_ty(e.id), ety).is_ok() {\n-                                    extra_semi = Some(stmt);\n-                                }\n-                            }\n-                        }\n-                        if let Some(last_stmt) = extra_semi {\n-                            let original_span = original_sp(self.tcx.sess.codemap(),\n-                                                            last_stmt.span, blk.span);\n-                            let span_semi = Span {\n-                                lo: original_span.hi - BytePos(1),\n-                                hi: original_span.hi,\n-                                expn_id: original_span.expn_id\n-                            };\n-                            err.span_help(span_semi, \"consider removing this semicolon:\");\n-                        }\n+                self.check_block_no_expr(blk, self.tcx.mk_nil(), e_ty);\n+            };\n \n-                        err.emit();\n-                    }\n-                }\n+            ctxt.unified\n+        } else {\n+            for s in &blk.stmts {\n+                self.check_stmt(s);\n             }\n \n-            // We already applied the type (and potentially errored),\n-            // use the expected type to avoid further errors out.\n-            ty = ety;\n-        }\n+            let mut ty = match blk.expr {\n+                Some(ref e) => self.check_expr_with_expectation(e, expected),\n+                None => self.tcx.mk_nil()\n+            };\n+\n+            if self.diverges.get().always() {\n+                ty = self.next_diverging_ty_var(TypeVariableOrigin::DivergingBlockExpr(blk.span));\n+            } else if let ExpectHasType(ety) = expected {\n+                if let Some(ref e) = blk.expr {\n+                    // Coerce the tail expression to the right type.\n+                    self.demand_coerce(e, ty, ety);\n+                } else {\n+                    self.check_block_no_expr(blk, ty, ety);\n+                }\n+\n+                // We already applied the type (and potentially errored),\n+                // use the expected type to avoid further errors out.\n+                ty = ety;\n+            }\n+            ty\n+        };\n \n         if self.has_errors.get() || ty.references_error() {\n             ty = self.tcx.types.err\n@@ -4088,6 +4112,46 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         ty\n     }\n \n+    pub fn check_block_no_expr(&self, blk: &'gcx hir::Block, ty: Ty<'tcx>, ety: Ty<'tcx>) {\n+        // We're not diverging and there's an expected type, which,\n+        // in case it's not `()`, could result in an error higher-up.\n+        // We have a chance to error here early and be more helpful.\n+        let cause = self.misc(blk.span);\n+        let trace = TypeTrace::types(&cause, false, ty, ety);\n+        match self.sub_types(false, &cause, ty, ety) {\n+            Ok(InferOk { obligations, .. }) => {\n+                // FIXME(#32730) propagate obligations\n+                assert!(obligations.is_empty());\n+            },\n+            Err(err) => {\n+                let mut err = self.report_and_explain_type_error(trace, &err);\n+\n+                // Be helpful when the user wrote `{... expr;}` and\n+                // taking the `;` off is enough to fix the error.\n+                let mut extra_semi = None;\n+                if let Some(stmt) = blk.stmts.last() {\n+                    if let hir::StmtSemi(ref e, _) = stmt.node {\n+                        if self.can_sub_types(self.node_ty(e.id), ety).is_ok() {\n+                            extra_semi = Some(stmt);\n+                        }\n+                    }\n+                }\n+                if let Some(last_stmt) = extra_semi {\n+                    let original_span = original_sp(self.tcx.sess.codemap(),\n+                                                    last_stmt.span, blk.span);\n+                    let span_semi = Span {\n+                        lo: original_span.hi - BytePos(1),\n+                        hi: original_span.hi,\n+                        expn_id: original_span.expn_id\n+                    };\n+                    err.span_help(span_semi, \"consider removing this semicolon:\");\n+                }\n+\n+                err.emit();\n+            }\n+        }\n+    }\n+\n     // Instantiates the given path, which must refer to an item with the given\n     // number of type parameters and type.\n     pub fn instantiate_value_path(&self,\n@@ -4485,22 +4549,24 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         })\n     }\n \n-    fn with_loop_ctxt<F: FnOnce()>(&self, id: ast::NodeId, ctxt: LoopCtxt<'gcx, 'tcx>, f: F)\n-                                   -> LoopCtxt<'gcx, 'tcx> {\n+    fn with_breakable_ctxt<F: FnOnce() -> R, R>(&self, id: ast::NodeId,\n+                                        ctxt: BreakableCtxt<'gcx, 'tcx>, f: F)\n+                                   -> (BreakableCtxt<'gcx, 'tcx>, R) {\n         let index;\n         {\n-            let mut enclosing_loops = self.enclosing_loops.borrow_mut();\n-            index = enclosing_loops.stack.len();\n-            enclosing_loops.by_id.insert(id, index);\n-            enclosing_loops.stack.push(ctxt);\n-        }\n-        f();\n-        {\n-            let mut enclosing_loops = self.enclosing_loops.borrow_mut();\n-            debug_assert!(enclosing_loops.stack.len() == index + 1);\n-            enclosing_loops.by_id.remove(&id).expect(\"missing loop context\");\n-            (enclosing_loops.stack.pop().expect(\"missing loop context\"))\n+            let mut enclosing_breakables = self.enclosing_breakables.borrow_mut();\n+            index = enclosing_breakables.stack.len();\n+            enclosing_breakables.by_id.insert(id, index);\n+            enclosing_breakables.stack.push(ctxt);\n         }\n+        let result = f();\n+        let ctxt = {\n+            let mut enclosing_breakables = self.enclosing_breakables.borrow_mut();\n+            debug_assert!(enclosing_breakables.stack.len() == index + 1);\n+            enclosing_breakables.by_id.remove(&id).expect(\"missing breakable context\");\n+            enclosing_breakables.stack.pop().expect(\"missing breakable context\")\n+        };\n+        (ctxt, result)\n     }\n }\n "}, {"sha": "d8de419df6d05c873ea0708c31942938c364387b", "filename": "src/test/compile-fail/catch-bad-lifetime.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/fc04eaacc5bd5760e98cd3aa390dcc3ae795d12f/src%2Ftest%2Fcompile-fail%2Fcatch-bad-lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc04eaacc5bd5760e98cd3aa390dcc3ae795d12f/src%2Ftest%2Fcompile-fail%2Fcatch-bad-lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcatch-bad-lifetime.rs?ref=fc04eaacc5bd5760e98cd3aa390dcc3ae795d12f", "patch": "@@ -0,0 +1,35 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(catch_expr)]\n+\n+pub fn main() {\n+    let _: Result<(), &str> = do catch {\n+        let my_string = String::from(\"\");\n+        let my_str: &str = &my_string;\n+        Err(my_str)?;\n+        Err(\"\")?;\n+        Ok(())\n+    }; //~ ERROR `my_string` does not live long enough\n+\n+    let mut i = 5;\n+    let k = &mut i;\n+    let mut j: Result<(), &mut i32> = do catch {\n+        Err(k)?;\n+        i = 10; //~ ERROR cannot assign to `i` because it is borrowed\n+        Ok(())\n+    };\n+    ::std::mem::drop(k); //~ ERROR use of moved value: `k`\n+    i = 40; //~ ERROR cannot assign to `i` because it is borrowed\n+\n+    let i_ptr = if let Err(i_ptr) = j { i_ptr } else { panic!(\"\") };\n+    *i_ptr = 50;\n+}\n+"}, {"sha": "cff9f508275b60daa9f0061698eaed282bf72fdb", "filename": "src/test/compile-fail/catch-bad-type.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/fc04eaacc5bd5760e98cd3aa390dcc3ae795d12f/src%2Ftest%2Fcompile-fail%2Fcatch-bad-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc04eaacc5bd5760e98cd3aa390dcc3ae795d12f/src%2Ftest%2Fcompile-fail%2Fcatch-bad-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcatch-bad-type.rs?ref=fc04eaacc5bd5760e98cd3aa390dcc3ae795d12f", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(catch_expr)]\n+\n+pub fn main() {\n+    let res: Result<i32, i32> = do catch {\n+        Err(\"\")?; //~ ERROR the trait bound `i32: std::convert::From<&str>` is not satisfied\n+        Ok(5)\n+    };\n+    let res: Result<i32, i32> = do catch {\n+        Ok(\"\") //~ mismatched types\n+    };\n+}"}, {"sha": "c5d116c82ddf806e7ab2c7109fe8a1b47146fcb0", "filename": "src/test/compile-fail/catch-opt-init.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/fc04eaacc5bd5760e98cd3aa390dcc3ae795d12f/src%2Ftest%2Fcompile-fail%2Fcatch-opt-init.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc04eaacc5bd5760e98cd3aa390dcc3ae795d12f/src%2Ftest%2Fcompile-fail%2Fcatch-opt-init.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcatch-opt-init.rs?ref=fc04eaacc5bd5760e98cd3aa390dcc3ae795d12f", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(catch_expr)]\n+\n+pub fn main() {\n+    let cfg_res;\n+    let _: Result<(), ()> = do catch {\n+        Err(())?;\n+        cfg_res = 5;\n+        Ok(())\n+    };\n+    assert_eq!(cfg_res, 5); //~ ERROR use of possibly uninitialized variable\n+}\n+"}, {"sha": "f2852bac27ae8de01648e82886a4cbcb5d0ee4fd", "filename": "src/test/run-pass/catch-expr.rs", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/fc04eaacc5bd5760e98cd3aa390dcc3ae795d12f/src%2Ftest%2Frun-pass%2Fcatch-expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc04eaacc5bd5760e98cd3aa390dcc3ae795d12f/src%2Ftest%2Frun-pass%2Fcatch-expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcatch-expr.rs?ref=fc04eaacc5bd5760e98cd3aa390dcc3ae795d12f", "patch": "@@ -29,4 +29,38 @@ pub fn main() {\n     match catch {\n         _ => {}\n     };\n+\n+    let catch_err = do catch {\n+        Err(22)?;\n+        Ok(1)\n+    };\n+    assert_eq!(catch_err, Err(22));\n+\n+    let catch_okay: Result<i32, i32> = do catch {\n+        if false { Err(25)?; }\n+        Ok::<(), i32>(())?;\n+        Ok(28)\n+    };\n+    assert_eq!(catch_okay, Ok(28));\n+\n+    let catch_from_loop: Result<i32, i32> = do catch {\n+        for i in 0..10 {\n+            if i < 5 { Ok::<i32, i32>(i)?; } else { Err(i)?; }\n+        }\n+        Ok(22)\n+    };\n+    assert_eq!(catch_from_loop, Err(5));\n+\n+    let cfg_init;\n+    let _res: Result<(), ()> = do catch {\n+        cfg_init = 5;\n+        Ok(())\n+    };\n+    assert_eq!(cfg_init, 5);\n+\n+    let my_string = \"test\".to_string();\n+    let res: Result<&str, ()> = do catch {\n+        Ok(&my_string)\n+    };\n+    assert_eq!(res, Ok(\"test\"));\n }"}]}