{"sha": "71bf986f4b2949a1eaf7db339e6995065b3d1988", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcxYmY5ODZmNGIyOTQ5YTFlYWY3ZGIzMzllNjk5NTA2NWIzZDE5ODg=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-04-30T12:07:55Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-04-30T12:07:55Z"}, "message": "Rollup merge of #71655 - RalfJung:const-pattern-soundness, r=oli-obk\n\nMiri: better document and fix dynamic const pattern soundness checks\n\nhttps://github.com/rust-lang/const-eval/issues/42 got me thinking about soundness for consts being used in patterns, and I found a hole in our existing dynamic checks: a const referring to a mutable static *in a different crate* was not caught. This PR fixes that. It also adds some comments that explain which invariants are crucial for soundness of const-patterns.\n\nCuriously, trying to weaponize this soundness hole failed: pattern matching compilation ICEd when encountering the cross-crate static, saying \"expected allocation ID alloc0 to point to memory\". I don't know why that would happen, statics *should* be entirely normal memory for pattern matching to access.\n\nr? @oli-obk\nCc @rust-lang/wg-const-eval", "tree": {"sha": "3dc25ddf97f5158b9e473d1a3422a3b43fbfcdf3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3dc25ddf97f5158b9e473d1a3422a3b43fbfcdf3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/71bf986f4b2949a1eaf7db339e6995065b3d1988", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeqr+bCRBK7hj4Ov3rIwAAdHIIAIEux5UL4EbXD4vUNVuZAjFS\nqmAiYCMtWF4NkVHNWoZW70m318iDFf7ZFTg2xPhs/4F2Aa7GFbm2EY26PLtEwlba\nPxSJqGW3zQKPC+67sAbsYiceF+WhqRVslBFOYdFzQio1WFWyRNLsDMNdzqEcXKPP\nuzDpYFWxbLaqzc2yPkYXE06KrVR2A1ctiizpKIRLvZ6k2l4kzDdoa93ha4+meNut\nYs+tGw3fu415qDM72+P5P5o3yzW/M3QdZ9YnhtgiSAK8GTiecUpmAhA3wt1rO5PU\njxRsTlD4WSMwn6b3E6mvwpsrlCh3AQ1b0i43p2JfDXcWdlBCvnCh3VRtfgb2OVU=\n=XTF5\n-----END PGP SIGNATURE-----\n", "payload": "tree 3dc25ddf97f5158b9e473d1a3422a3b43fbfcdf3\nparent 58d955e6cc84b92a6013a3e170e076f65a0c1b18\nparent 07772fcf6fca44217439154aa37e4854dd5aef34\nauthor Dylan DPC <dylan.dpc@gmail.com> 1588248475 +0200\ncommitter GitHub <noreply@github.com> 1588248475 +0200\n\nRollup merge of #71655 - RalfJung:const-pattern-soundness, r=oli-obk\n\nMiri: better document and fix dynamic const pattern soundness checks\n\nhttps://github.com/rust-lang/const-eval/issues/42 got me thinking about soundness for consts being used in patterns, and I found a hole in our existing dynamic checks: a const referring to a mutable static *in a different crate* was not caught. This PR fixes that. It also adds some comments that explain which invariants are crucial for soundness of const-patterns.\n\nCuriously, trying to weaponize this soundness hole failed: pattern matching compilation ICEd when encountering the cross-crate static, saying \"expected allocation ID alloc0 to point to memory\". I don't know why that would happen, statics *should* be entirely normal memory for pattern matching to access.\n\nr? @oli-obk\nCc @rust-lang/wg-const-eval\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/71bf986f4b2949a1eaf7db339e6995065b3d1988", "html_url": "https://github.com/rust-lang/rust/commit/71bf986f4b2949a1eaf7db339e6995065b3d1988", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/71bf986f4b2949a1eaf7db339e6995065b3d1988/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "58d955e6cc84b92a6013a3e170e076f65a0c1b18", "url": "https://api.github.com/repos/rust-lang/rust/commits/58d955e6cc84b92a6013a3e170e076f65a0c1b18", "html_url": "https://github.com/rust-lang/rust/commit/58d955e6cc84b92a6013a3e170e076f65a0c1b18"}, {"sha": "07772fcf6fca44217439154aa37e4854dd5aef34", "url": "https://api.github.com/repos/rust-lang/rust/commits/07772fcf6fca44217439154aa37e4854dd5aef34", "html_url": "https://github.com/rust-lang/rust/commit/07772fcf6fca44217439154aa37e4854dd5aef34"}], "stats": {"total": 274, "additions": 250, "deletions": 24}, "files": [{"sha": "d97546e4391b536378203e772bb078526aee962c", "filename": "src/librustc_mir/const_eval/eval_queries.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/71bf986f4b2949a1eaf7db339e6995065b3d1988/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71bf986f4b2949a1eaf7db339e6995065b3d1988/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs?ref=71bf986f4b2949a1eaf7db339e6995065b3d1988", "patch": "@@ -193,7 +193,7 @@ fn validate_and_turn_into_const<'tcx>(\n                     mplace.into(),\n                     path,\n                     &mut ref_tracking,\n-                    /*may_ref_to_static*/ is_static,\n+                    /*may_ref_to_static*/ ecx.memory.extra.can_access_statics,\n                 )?;\n             }\n         }"}, {"sha": "7c1ab261eb9c40ab71dd01ffd98015402d905062", "filename": "src/librustc_mir/const_eval/machine.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/71bf986f4b2949a1eaf7db339e6995065b3d1988/src%2Flibrustc_mir%2Fconst_eval%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71bf986f4b2949a1eaf7db339e6995065b3d1988/src%2Flibrustc_mir%2Fconst_eval%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Fmachine.rs?ref=71bf986f4b2949a1eaf7db339e6995065b3d1988", "patch": "@@ -99,7 +99,12 @@ pub struct CompileTimeInterpreter<'mir, 'tcx> {\n \n #[derive(Copy, Clone, Debug)]\n pub struct MemoryExtra {\n-    /// Whether this machine may read from statics\n+    /// We need to make sure consts never point to anything mutable, even recursively. That is\n+    /// relied on for pattern matching on consts with references.\n+    /// To achieve this, two pieces have to work together:\n+    /// * Interning makes everything outside of statics immutable.\n+    /// * Pointers to allocations inside of statics can never leak outside, to a non-static global.\n+    /// This boolean here controls the second part.\n     pub(super) can_access_statics: bool,\n }\n \n@@ -337,6 +342,10 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n             } else if static_def_id.is_some() {\n                 // Machine configuration does not allow us to read statics\n                 // (e.g., `const` initializer).\n+                // See const_eval::machine::MemoryExtra::can_access_statics for why\n+                // this check is so important: if we could read statics, we could read pointers\n+                // to mutable allocations *inside* statics. These allocations are not themselves\n+                // statics, so pointers to them can get around the check in `validity.rs`.\n                 Err(ConstEvalErrKind::ConstAccessesStatic.into())\n             } else {\n                 // Immutable global, this read is fine."}, {"sha": "8560594b583d4126232b9d32ba01a1945b2bbc2c", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/71bf986f4b2949a1eaf7db339e6995065b3d1988/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71bf986f4b2949a1eaf7db339e6995065b3d1988/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=71bf986f4b2949a1eaf7db339e6995065b3d1988", "patch": "@@ -453,7 +453,9 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n                 // thing here: one maps to `GlobalAlloc::Static`, this is the \"lazy\" ID,\n                 // and the other one is maps to `GlobalAlloc::Memory`, this is returned by\n                 // `const_eval_raw` and it is the \"resolved\" ID.\n-                // The resolved ID is never used by the interpreted progrma, it is hidden.\n+                // The resolved ID is never used by the interpreted program, it is hidden.\n+                // This is relied upon for soundness of const-patterns; a pointer to the resolved\n+                // ID would \"sidestep\" the checks that make sure consts do not point to statics!\n                 // The `GlobalAlloc::Memory` branch here is still reachable though; when a static\n                 // contains a reference to memory that was created during its evaluation (i.e., not\n                 // to another static), those inner references only exist in \"resolved\" form."}, {"sha": "df3c353220318bdd665946b662522b939f1a57ec", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/71bf986f4b2949a1eaf7db339e6995065b3d1988/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71bf986f4b2949a1eaf7db339e6995065b3d1988/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=71bf986f4b2949a1eaf7db339e6995065b3d1988", "patch": "@@ -404,19 +404,27 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n                 // Skip validation entirely for some external statics\n                 let alloc_kind = self.ecx.tcx.alloc_map.lock().get(ptr.alloc_id);\n                 if let Some(GlobalAlloc::Static(did)) = alloc_kind {\n-                    // `extern static` cannot be validated as they have no body.\n-                    // FIXME: Statics from other crates are also skipped.\n-                    // They might be checked at a different type, but for now we\n-                    // want to avoid recursing too deeply.  This is not sound!\n-                    if !did.is_local() || self.ecx.tcx.is_foreign_item(did) {\n-                        return Ok(());\n-                    }\n+                    // See const_eval::machine::MemoryExtra::can_access_statics for why\n+                    // this check is so important.\n+                    // This check is reachable when the const just referenced the static,\n+                    // but never read it (so we never entered `before_access_global`).\n+                    // We also need to do it here instead of going on to avoid running\n+                    // into the `before_access_global` check during validation.\n                     if !self.may_ref_to_static && self.ecx.tcx.is_static(did) {\n                         throw_validation_failure!(\n                             format_args!(\"a {} pointing to a static variable\", kind),\n                             self.path\n                         );\n                     }\n+                    // `extern static` cannot be validated as they have no body.\n+                    // FIXME: Statics from other crates are also skipped.\n+                    // They might be checked at a different type, but for now we\n+                    // want to avoid recursing too deeply.  We might miss const-invalid data,\n+                    // but things are still sound otherwise (in particular re: consts\n+                    // referring to statics).\n+                    if !did.is_local() || self.ecx.tcx.is_foreign_item(did) {\n+                        return Ok(());\n+                    }\n                 }\n             }\n             // Proceed recursively even for ZST, no reason to skip them!"}, {"sha": "4fc6ae66a1242d2476b64260e8acc174e252bd50", "filename": "src/test/ui/consts/miri_unleashed/auxiliary/static_cross_crate.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/71bf986f4b2949a1eaf7db339e6995065b3d1988/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fauxiliary%2Fstatic_cross_crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71bf986f4b2949a1eaf7db339e6995065b3d1988/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fauxiliary%2Fstatic_cross_crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fauxiliary%2Fstatic_cross_crate.rs?ref=71bf986f4b2949a1eaf7db339e6995065b3d1988", "patch": "@@ -0,0 +1,3 @@\n+pub static mut ZERO: [u8; 1] = [0];\n+pub static ZERO_REF: &[u8; 1] = unsafe { &ZERO };\n+pub static mut OPT_ZERO: Option<u8> = Some(0);"}, {"sha": "6b205a2f66d9ba5e273fffbc5095aabf20a2e7cd", "filename": "src/test/ui/consts/miri_unleashed/const_refers_to_static.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/71bf986f4b2949a1eaf7db339e6995065b3d1988/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fconst_refers_to_static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71bf986f4b2949a1eaf7db339e6995065b3d1988/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fconst_refers_to_static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fconst_refers_to_static.rs?ref=71bf986f4b2949a1eaf7db339e6995065b3d1988", "patch": "@@ -7,7 +7,8 @@\n use std::sync::atomic::AtomicUsize;\n use std::sync::atomic::Ordering;\n \n-// These tests only cause an error when *using* the const.\n+// These fail during CTFE (as they read a static), so they only cause an error\n+// when *using* the const.\n \n const MUTATE_INTERIOR_MUT: usize = {\n     static FOO: AtomicUsize = AtomicUsize::new(0);"}, {"sha": "acc3b637f58bccb31939b851db75bb248bfa2d6a", "filename": "src/test/ui/consts/miri_unleashed/const_refers_to_static.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/71bf986f4b2949a1eaf7db339e6995065b3d1988/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fconst_refers_to_static.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/71bf986f4b2949a1eaf7db339e6995065b3d1988/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fconst_refers_to_static.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fconst_refers_to_static.stderr?ref=71bf986f4b2949a1eaf7db339e6995065b3d1988", "patch": "@@ -1,47 +1,47 @@\n warning: skipping const checks\n-  --> $DIR/const_refers_to_static.rs:14:5\n+  --> $DIR/const_refers_to_static.rs:15:5\n    |\n LL |     FOO.fetch_add(1, Ordering::Relaxed)\n    |     ^^^\n \n warning: skipping const checks\n-  --> $DIR/const_refers_to_static.rs:14:5\n+  --> $DIR/const_refers_to_static.rs:15:5\n    |\n LL |     FOO.fetch_add(1, Ordering::Relaxed)\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n warning: skipping const checks\n-  --> $DIR/const_refers_to_static.rs:21:17\n+  --> $DIR/const_refers_to_static.rs:22:17\n    |\n LL |     unsafe { *(&FOO as *const _ as *const usize) }\n    |                 ^^^\n \n warning: skipping const checks\n-  --> $DIR/const_refers_to_static.rs:26:32\n+  --> $DIR/const_refers_to_static.rs:27:32\n    |\n LL | const READ_MUT: u32 = unsafe { MUTABLE };\n    |                                ^^^^^^^\n \n warning: skipping const checks\n-  --> $DIR/const_refers_to_static.rs:26:32\n+  --> $DIR/const_refers_to_static.rs:27:32\n    |\n LL | const READ_MUT: u32 = unsafe { MUTABLE };\n    |                                ^^^^^^^\n \n error[E0080]: erroneous constant used\n-  --> $DIR/const_refers_to_static.rs:31:5\n+  --> $DIR/const_refers_to_static.rs:32:5\n    |\n LL |     MUTATE_INTERIOR_MUT;\n    |     ^^^^^^^^^^^^^^^^^^^ referenced constant has errors\n \n error[E0080]: erroneous constant used\n-  --> $DIR/const_refers_to_static.rs:33:5\n+  --> $DIR/const_refers_to_static.rs:34:5\n    |\n LL |     READ_INTERIOR_MUT;\n    |     ^^^^^^^^^^^^^^^^^ referenced constant has errors\n \n error[E0080]: erroneous constant used\n-  --> $DIR/const_refers_to_static.rs:35:5\n+  --> $DIR/const_refers_to_static.rs:36:5\n    |\n LL |     READ_MUT;\n    |     ^^^^^^^^ referenced constant has errors"}, {"sha": "553d90f1891cc38d49bc7044daf3de1fc76144e9", "filename": "src/test/ui/consts/miri_unleashed/const_refers_to_static2.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/71bf986f4b2949a1eaf7db339e6995065b3d1988/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fconst_refers_to_static2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71bf986f4b2949a1eaf7db339e6995065b3d1988/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fconst_refers_to_static2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fconst_refers_to_static2.rs?ref=71bf986f4b2949a1eaf7db339e6995065b3d1988", "patch": "@@ -6,16 +6,21 @@\n use std::sync::atomic::AtomicUsize;\n use std::sync::atomic::Ordering;\n \n-// These tests cause immediate error when *defining* the const.\n+// These only fail during validation (they do not use but just create a reference to a static),\n+// so they cause an immediate error when *defining* the const.\n \n const REF_INTERIOR_MUT: &usize = { //~ ERROR undefined behavior to use this value\n+//~| NOTE encountered a reference pointing to a static variable\n+//~| NOTE\n     static FOO: AtomicUsize = AtomicUsize::new(0);\n     unsafe { &*(&FOO as *const _ as *const usize) }\n     //~^ WARN skipping const checks\n };\n \n // ok some day perhaps\n const READ_IMMUT: &usize = { //~ ERROR it is undefined behavior to use this value\n+//~| NOTE encountered a reference pointing to a static variable\n+//~| NOTE\n     static FOO: usize = 0;\n     &FOO\n     //~^ WARN skipping const checks"}, {"sha": "33f4a42605ccecdaa60006319162cb4dbbc096b9", "filename": "src/test/ui/consts/miri_unleashed/const_refers_to_static2.stderr", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/71bf986f4b2949a1eaf7db339e6995065b3d1988/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fconst_refers_to_static2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/71bf986f4b2949a1eaf7db339e6995065b3d1988/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fconst_refers_to_static2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fconst_refers_to_static2.stderr?ref=71bf986f4b2949a1eaf7db339e6995065b3d1988", "patch": "@@ -1,19 +1,21 @@\n warning: skipping const checks\n-  --> $DIR/const_refers_to_static2.rs:13:18\n+  --> $DIR/const_refers_to_static2.rs:16:18\n    |\n LL |     unsafe { &*(&FOO as *const _ as *const usize) }\n    |                  ^^^\n \n warning: skipping const checks\n-  --> $DIR/const_refers_to_static2.rs:20:6\n+  --> $DIR/const_refers_to_static2.rs:25:6\n    |\n LL |     &FOO\n    |      ^^^\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/const_refers_to_static2.rs:11:1\n+  --> $DIR/const_refers_to_static2.rs:12:1\n    |\n LL | / const REF_INTERIOR_MUT: &usize = {\n+LL | |\n+LL | |\n LL | |     static FOO: AtomicUsize = AtomicUsize::new(0);\n LL | |     unsafe { &*(&FOO as *const _ as *const usize) }\n LL | |\n@@ -23,9 +25,11 @@ LL | | };\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/const_refers_to_static2.rs:18:1\n+  --> $DIR/const_refers_to_static2.rs:21:1\n    |\n LL | / const READ_IMMUT: &usize = {\n+LL | |\n+LL | |\n LL | |     static FOO: usize = 0;\n LL | |     &FOO\n LL | |"}, {"sha": "8bdb48e6f122fd0b1f4e2ff257f93e0f8ba64d8c", "filename": "src/test/ui/consts/miri_unleashed/const_refers_to_static_cross_crate.rs", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/71bf986f4b2949a1eaf7db339e6995065b3d1988/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fconst_refers_to_static_cross_crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71bf986f4b2949a1eaf7db339e6995065b3d1988/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fconst_refers_to_static_cross_crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fconst_refers_to_static_cross_crate.rs?ref=71bf986f4b2949a1eaf7db339e6995065b3d1988", "patch": "@@ -0,0 +1,81 @@\n+// compile-flags: -Zunleash-the-miri-inside-of-you -Zdeduplicate-diagnostics\n+// aux-build:static_cross_crate.rs\n+#![allow(const_err)]\n+\n+#![feature(exclusive_range_pattern, half_open_range_patterns, const_if_match, const_panic)]\n+\n+extern crate static_cross_crate;\n+\n+// Sneaky: reference to a mutable static.\n+// Allowing this would be a disaster for pattern matching, we could violate exhaustiveness checking!\n+const SLICE_MUT: &[u8; 1] = { //~ ERROR undefined behavior to use this value\n+//~| NOTE encountered a reference pointing to a static variable\n+//~| NOTE\n+    unsafe { &static_cross_crate::ZERO }\n+    //~^ WARN skipping const checks\n+};\n+\n+const U8_MUT: &u8 = { //~ ERROR undefined behavior to use this value\n+//~| NOTE encountered a reference pointing to a static variable\n+//~| NOTE\n+    unsafe { &static_cross_crate::ZERO[0] }\n+    //~^ WARN skipping const checks\n+};\n+\n+// Also test indirection that reads from other static. This causes a const_err.\n+#[warn(const_err)] //~ NOTE\n+const U8_MUT2: &u8 = { //~ NOTE\n+    unsafe { &(*static_cross_crate::ZERO_REF)[0] }\n+    //~^ WARN skipping const checks\n+    //~| WARN [const_err]\n+    //~| NOTE constant accesses static\n+};\n+#[warn(const_err)] //~ NOTE\n+const U8_MUT3: &u8 = { //~ NOTE\n+    unsafe { match static_cross_crate::OPT_ZERO { Some(ref u) => u, None => panic!() } }\n+    //~^ WARN skipping const checks\n+    //~| WARN [const_err]\n+    //~| NOTE constant accesses static\n+};\n+\n+pub fn test(x: &[u8; 1]) -> bool {\n+    match x {\n+        SLICE_MUT => true,\n+        //~^ ERROR could not evaluate constant pattern\n+        &[1..] => false,\n+    }\n+}\n+\n+pub fn test2(x: &u8) -> bool {\n+    match x {\n+        U8_MUT => true,\n+        //~^ ERROR could not evaluate constant pattern\n+        &(1..) => false,\n+    }\n+}\n+\n+// We need to use these *in a pattern* to trigger the failure... likely because\n+// the errors above otherwise stop compilation too early?\n+pub fn test3(x: &u8) -> bool {\n+    match x {\n+        U8_MUT2 => true,\n+        //~^ ERROR could not evaluate constant pattern\n+        &(1..) => false,\n+    }\n+}\n+pub fn test4(x: &u8) -> bool {\n+    match x {\n+        U8_MUT3 => true,\n+        //~^ ERROR could not evaluate constant pattern\n+        &(1..) => false,\n+    }\n+}\n+\n+fn main() {\n+    unsafe {\n+        static_cross_crate::ZERO[0] = 1;\n+    }\n+    // Now the pattern is not exhaustive any more!\n+    test(&[0]);\n+    test2(&0);\n+}"}, {"sha": "bc6375f3d5e0b7439cea0f3d2af04963e9e05253", "filename": "src/test/ui/consts/miri_unleashed/const_refers_to_static_cross_crate.stderr", "status": "added", "additions": 113, "deletions": 0, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/71bf986f4b2949a1eaf7db339e6995065b3d1988/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fconst_refers_to_static_cross_crate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/71bf986f4b2949a1eaf7db339e6995065b3d1988/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fconst_refers_to_static_cross_crate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fconst_refers_to_static_cross_crate.stderr?ref=71bf986f4b2949a1eaf7db339e6995065b3d1988", "patch": "@@ -0,0 +1,113 @@\n+warning: skipping const checks\n+  --> $DIR/const_refers_to_static_cross_crate.rs:14:15\n+   |\n+LL |     unsafe { &static_cross_crate::ZERO }\n+   |               ^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/const_refers_to_static_cross_crate.rs:11:1\n+   |\n+LL | / const SLICE_MUT: &[u8; 1] = {\n+LL | |\n+LL | |\n+LL | |     unsafe { &static_cross_crate::ZERO }\n+LL | |\n+LL | | };\n+   | |__^ type validation failed: encountered a reference pointing to a static variable\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+\n+error: could not evaluate constant pattern\n+  --> $DIR/const_refers_to_static_cross_crate.rs:43:9\n+   |\n+LL |         SLICE_MUT => true,\n+   |         ^^^^^^^^^\n+\n+warning: skipping const checks\n+  --> $DIR/const_refers_to_static_cross_crate.rs:21:15\n+   |\n+LL |     unsafe { &static_cross_crate::ZERO[0] }\n+   |               ^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/const_refers_to_static_cross_crate.rs:18:1\n+   |\n+LL | / const U8_MUT: &u8 = {\n+LL | |\n+LL | |\n+LL | |     unsafe { &static_cross_crate::ZERO[0] }\n+LL | |\n+LL | | };\n+   | |__^ type validation failed: encountered a reference pointing to a static variable\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+\n+error: could not evaluate constant pattern\n+  --> $DIR/const_refers_to_static_cross_crate.rs:51:9\n+   |\n+LL |         U8_MUT => true,\n+   |         ^^^^^^\n+\n+warning: skipping const checks\n+  --> $DIR/const_refers_to_static_cross_crate.rs:28:17\n+   |\n+LL |     unsafe { &(*static_cross_crate::ZERO_REF)[0] }\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+warning: any use of this value will cause an error\n+  --> $DIR/const_refers_to_static_cross_crate.rs:28:14\n+   |\n+LL | / const U8_MUT2: &u8 = {\n+LL | |     unsafe { &(*static_cross_crate::ZERO_REF)[0] }\n+   | |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constant accesses static\n+LL | |\n+LL | |\n+LL | |\n+LL | | };\n+   | |__-\n+   |\n+note: the lint level is defined here\n+  --> $DIR/const_refers_to_static_cross_crate.rs:26:8\n+   |\n+LL | #[warn(const_err)]\n+   |        ^^^^^^^^^\n+\n+error: could not evaluate constant pattern\n+  --> $DIR/const_refers_to_static_cross_crate.rs:61:9\n+   |\n+LL |         U8_MUT2 => true,\n+   |         ^^^^^^^\n+\n+warning: skipping const checks\n+  --> $DIR/const_refers_to_static_cross_crate.rs:35:20\n+   |\n+LL |     unsafe { match static_cross_crate::OPT_ZERO { Some(ref u) => u, None => panic!() } }\n+   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+warning: any use of this value will cause an error\n+  --> $DIR/const_refers_to_static_cross_crate.rs:35:51\n+   |\n+LL | / const U8_MUT3: &u8 = {\n+LL | |     unsafe { match static_cross_crate::OPT_ZERO { Some(ref u) => u, None => panic!() } }\n+   | |                                                   ^^^^^^^^^^^ constant accesses static\n+LL | |\n+LL | |\n+LL | |\n+LL | | };\n+   | |__-\n+   |\n+note: the lint level is defined here\n+  --> $DIR/const_refers_to_static_cross_crate.rs:33:8\n+   |\n+LL | #[warn(const_err)]\n+   |        ^^^^^^^^^\n+\n+error: could not evaluate constant pattern\n+  --> $DIR/const_refers_to_static_cross_crate.rs:68:9\n+   |\n+LL |         U8_MUT3 => true,\n+   |         ^^^^^^^\n+\n+error: aborting due to 6 previous errors; 6 warnings emitted\n+\n+For more information about this error, try `rustc --explain E0080`."}]}