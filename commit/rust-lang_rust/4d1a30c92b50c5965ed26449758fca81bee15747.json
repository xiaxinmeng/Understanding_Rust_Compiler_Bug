{"sha": "4d1a30c92b50c5965ed26449758fca81bee15747", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRkMWEzMGM5MmI1MGM1OTY1ZWQyNjQ0OTc1OGZjYTgxYmVlMTU3NDc=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-03-20T22:58:25Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-07-14T11:56:57Z"}, "message": "Remove most of `PartialEq` impls from AST and HIR structures", "tree": {"sha": "ad1638de488e3f30ce91f7e7443b0b7891003a0b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ad1638de488e3f30ce91f7e7443b0b7891003a0b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4d1a30c92b50c5965ed26449758fca81bee15747", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4d1a30c92b50c5965ed26449758fca81bee15747", "html_url": "https://github.com/rust-lang/rust/commit/4d1a30c92b50c5965ed26449758fca81bee15747", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4d1a30c92b50c5965ed26449758fca81bee15747/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0a8275f8b677304458c6161e26436dfe67ab766b", "url": "https://api.github.com/repos/rust-lang/rust/commits/0a8275f8b677304458c6161e26436dfe67ab766b", "html_url": "https://github.com/rust-lang/rust/commit/0a8275f8b677304458c6161e26436dfe67ab766b"}], "stats": {"total": 612, "additions": 315, "deletions": 297}, "files": [{"sha": "7acfe6839540b5ebd2c57e676a63c6d5724ad9f3", "filename": "src/librustc/hir/def_id.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4d1a30c92b50c5965ed26449758fca81bee15747/src%2Flibrustc%2Fhir%2Fdef_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d1a30c92b50c5965ed26449758fca81bee15747/src%2Flibrustc%2Fhir%2Fdef_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef_id.rs?ref=4d1a30c92b50c5965ed26449758fca81bee15747", "patch": "@@ -81,7 +81,7 @@ impl serialize::UseSpecializedDecodable for CrateNum {}\n /// Since the DefIndex is mostly treated as an opaque ID, you probably\n /// don't have to care about these address spaces.\n \n-#[derive(Clone, Eq, Ord, PartialOrd, PartialEq, Hash, Copy)]\n+#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Copy)]\n pub struct DefIndex(u32);\n \n /// The crate root is always assigned index 0 by the AST Map code,\n@@ -150,7 +150,7 @@ impl DefIndex {\n impl serialize::UseSpecializedEncodable for DefIndex {}\n impl serialize::UseSpecializedDecodable for DefIndex {}\n \n-#[derive(Copy, Clone, Eq, PartialEq, Hash)]\n+#[derive(Copy, Clone, Hash)]\n pub enum DefIndexAddressSpace {\n     Low = 0,\n     High = 1,\n@@ -165,7 +165,7 @@ impl DefIndexAddressSpace {\n \n /// A DefId identifies a particular *definition*, by combining a crate\n /// index and a def index.\n-#[derive(Clone, Eq, Ord, PartialOrd, PartialEq, Hash, Copy)]\n+#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Copy)]\n pub struct DefId {\n     pub krate: CrateNum,\n     pub index: DefIndex,\n@@ -216,7 +216,7 @@ impl serialize::UseSpecializedDecodable for DefId {}\n /// few cases where we know that only DefIds from the local crate are expected\n /// and a DefId from a different crate would signify a bug somewhere. This\n /// is when LocalDefId comes in handy.\n-#[derive(Clone, Copy, Eq, PartialEq, Ord, PartialOrd, Hash)]\n+#[derive(Clone, Copy, PartialEq, Eq, Hash)]\n pub struct LocalDefId(DefIndex);\n \n impl LocalDefId {"}, {"sha": "e2c0020db2ff346ee50de183a6809d1b5728ed47", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4d1a30c92b50c5965ed26449758fca81bee15747/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d1a30c92b50c5965ed26449758fca81bee15747/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=4d1a30c92b50c5965ed26449758fca81bee15747", "patch": "@@ -51,7 +51,7 @@ use super::itemlikevisit::DeepVisitor;\n use std::cmp;\n use std::u32;\n \n-#[derive(Copy, Clone, PartialEq, Eq)]\n+#[derive(Copy, Clone)]\n pub enum FnKind<'a> {\n     /// #[xxx] pub async/const/extern \"Abi\" fn foo()\n     ItemFn(Name, &'a Generics, FnHeader, &'a Visibility, &'a [Attribute]),\n@@ -1115,7 +1115,7 @@ pub fn walk_defaultness<'v, V: Visitor<'v>>(_: &mut V, _: &'v Defaultness) {\n     // would be to walk it.\n }\n \n-#[derive(Copy, Clone, RustcEncodable, RustcDecodable, Debug, PartialEq, Eq)]\n+#[derive(Copy, Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct IdRange {\n     pub min: NodeId,\n     pub max: NodeId,"}, {"sha": "cb53f963d41f10c27d6686097dfe792ee4111173", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4d1a30c92b50c5965ed26449758fca81bee15747/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d1a30c92b50c5965ed26449758fca81bee15747/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=4d1a30c92b50c5965ed26449758fca81bee15747", "patch": "@@ -238,7 +238,7 @@ pub fn lower_crate(\n     }.lower_crate(krate)\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq)]\n+#[derive(Copy, Clone, PartialEq)]\n enum ParamMode {\n     /// Any path in a type context.\n     Explicit,\n@@ -1927,7 +1927,7 @@ impl<'a> LoweringContext<'a> {\n             variadic: decl.variadic,\n             has_implicit_self: decl.inputs.get(0).map_or(false, |arg| match arg.ty.node {\n                 TyKind::ImplicitSelf => true,\n-                TyKind::Rptr(_, ref mt) => mt.ty.node == TyKind::ImplicitSelf,\n+                TyKind::Rptr(_, ref mt) => mt.ty.node.is_implicit_self(),\n                 _ => false,\n             }),\n         })"}, {"sha": "9b1bb3310f2fd3807b88235eb1412e40ec3a9648", "filename": "src/librustc/hir/map/definitions.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4d1a30c92b50c5965ed26449758fca81bee15747/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d1a30c92b50c5965ed26449758fca81bee15747/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs?ref=4d1a30c92b50c5965ed26449758fca81bee15747", "patch": "@@ -171,7 +171,7 @@ pub struct Definitions {\n /// A unique identifier that we can use to lookup a definition\n /// precisely. It combines the index of the definition's parent (if\n /// any) with a `DisambiguatedDefPathData`.\n-#[derive(Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, PartialEq, Debug, Hash, RustcEncodable, RustcDecodable)]\n pub struct DefKey {\n     /// Parent path.\n     pub parent: Option<DefIndex>,\n@@ -223,13 +223,13 @@ impl DefKey {\n /// between them. This introduces some artificial ordering dependency\n /// but means that if you have (e.g.) two impls for the same type in\n /// the same module, they do get distinct def-ids.\n-#[derive(Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, PartialEq, Debug, Hash, RustcEncodable, RustcDecodable)]\n pub struct DisambiguatedDefPathData {\n     pub data: DefPathData,\n     pub disambiguator: u32\n }\n \n-#[derive(Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Debug, Hash, RustcEncodable, RustcDecodable)]\n pub struct DefPath {\n     /// the path leading from the crate root to the item\n     pub data: Vec<DisambiguatedDefPathData>,\n@@ -311,7 +311,7 @@ impl DefPath {\n     }\n }\n \n-#[derive(Clone, Debug, Eq, PartialEq, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n pub enum DefPathData {\n     // Root: these should only be used for the root nodes, because\n     // they are treated specially by the `def_path` function.\n@@ -668,8 +668,7 @@ macro_rules! define_global_metadata_kind {\n     (pub enum GlobalMetaDataKind {\n         $($variant:ident),*\n     }) => (\n-        #[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord, Hash,\n-                 RustcEncodable, RustcDecodable)]\n+        #[derive(Clone, Copy, Debug, Hash, RustcEncodable, RustcDecodable)]\n         pub enum GlobalMetaDataKind {\n             $($variant),*\n         }"}, {"sha": "e98e9b1760351e89d269ab7a698596f979f23585", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 84, "deletions": 85, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/4d1a30c92b50c5965ed26449758fca81bee15747/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d1a30c92b50c5965ed26449758fca81bee15747/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=4d1a30c92b50c5965ed26449758fca81bee15747", "patch": "@@ -89,7 +89,7 @@ pub mod svh;\n /// the local_id part of the HirId changing, which is a very useful property in\n /// incremental compilation where we have to persist things through changes to\n /// the code base.\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, PartialOrd, Ord, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n pub struct HirId {\n     pub owner: DefIndex,\n     pub local_id: ItemLocalId,\n@@ -138,7 +138,7 @@ impl serialize::UseSpecializedDecodable for HirId {\n /// integers starting at zero, so a mapping that maps all or most nodes within\n /// an \"item-like\" to something else can be implement by a `Vec` instead of a\n /// tree or hash map.\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, PartialOrd, Ord, Debug,\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug,\n          RustcEncodable, RustcDecodable)]\n pub struct ItemLocalId(pub u32);\n \n@@ -172,7 +172,7 @@ pub const DUMMY_HIR_ID: HirId = HirId {\n \n pub const DUMMY_ITEM_LOCAL_ID: ItemLocalId = ItemLocalId(!0);\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Copy)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash, Copy)]\n pub struct Label {\n     pub ident: Ident,\n }\n@@ -183,7 +183,7 @@ impl fmt::Debug for Label {\n     }\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Copy)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash, Copy)]\n pub struct Lifetime {\n     pub id: NodeId,\n     pub span: Span,\n@@ -312,7 +312,7 @@ impl Lifetime {\n /// A \"Path\" is essentially Rust's notion of a name; for instance:\n /// `std::cmp::PartialEq`. It's represented as a sequence of identifiers,\n /// along with a bunch of supporting information.\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash)]\n pub struct Path {\n     pub span: Span,\n     /// The definition that the path resolved to.\n@@ -341,7 +341,7 @@ impl fmt::Display for Path {\n \n /// A segment of a path: an identifier, an optional lifetime, and a set of\n /// types.\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct PathSegment {\n     /// The identifier portion of this path segment.\n     pub ident: Ident,\n@@ -396,7 +396,7 @@ impl PathSegment {\n     }\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum GenericArg {\n     Lifetime(Lifetime),\n     Type(Ty),\n@@ -411,7 +411,7 @@ impl GenericArg {\n     }\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct GenericArgs {\n     /// The generic arguments for this path segment.\n     pub args: HirVec<GenericArg>,\n@@ -467,7 +467,7 @@ pub enum TraitBoundModifier {\n /// typeck::collect::compute_bounds matches these against\n /// the \"special\" built-in traits (see middle::lang_items) and\n /// detects Copy, Send and Sync.\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum GenericBound {\n     Trait(PolyTraitRef, TraitBoundModifier),\n     Outlives(Lifetime),\n@@ -484,7 +484,7 @@ impl GenericBound {\n \n pub type GenericBounds = HirVec<GenericBound>;\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum GenericParamKind {\n     /// A lifetime definition, eg `'a: 'b + 'c + 'd`.\n     Lifetime {\n@@ -499,7 +499,7 @@ pub enum GenericParamKind {\n     }\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct GenericParam {\n     pub id: NodeId,\n     pub name: ParamName,\n@@ -518,7 +518,7 @@ pub struct GenericParamCount {\n \n /// Represents lifetimes and type parameters attached to a declaration\n /// of a function, enum, trait, etc.\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct Generics {\n     pub params: HirVec<GenericParam>,\n     pub where_clause: WhereClause,\n@@ -568,13 +568,13 @@ impl Generics {\n \n /// Synthetic Type Parameters are converted to an other form during lowering, this allows\n /// to track the original form they had. Useful for error messages.\n-#[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum SyntheticTyParamKind {\n     ImplTrait\n }\n \n /// A `where` clause in a definition\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct WhereClause {\n     pub id: NodeId,\n     pub predicates: HirVec<WherePredicate>,\n@@ -593,7 +593,7 @@ impl WhereClause {\n }\n \n /// A single predicate in a `where` clause\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum WherePredicate {\n     /// A type binding, eg `for<'c> Foo: Send+Clone+'c`\n     BoundPredicate(WhereBoundPredicate),\n@@ -614,7 +614,7 @@ impl WherePredicate {\n }\n \n /// A type bound, eg `for<'c> Foo: Send+Clone+'c`\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct WhereBoundPredicate {\n     pub span: Span,\n     /// Any generics from a `for` binding\n@@ -626,15 +626,15 @@ pub struct WhereBoundPredicate {\n }\n \n /// A lifetime predicate, e.g. `'a: 'b+'c`\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct WhereRegionPredicate {\n     pub span: Span,\n     pub lifetime: Lifetime,\n     pub bounds: GenericBounds,\n }\n \n /// An equality predicate (unsupported), e.g. `T=int`\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct WhereEqPredicate {\n     pub id: NodeId,\n     pub span: Span,\n@@ -650,7 +650,7 @@ pub type CrateConfig = HirVec<P<MetaItem>>;\n /// For more details, see the [rustc guide].\n ///\n /// [rustc guide]: https://rust-lang-nursery.github.io/rustc-guide/hir.html\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct Crate {\n     pub module: Mod,\n     pub attrs: HirVec<Attribute>,\n@@ -748,7 +748,7 @@ impl Crate {\n /// A macro definition, in this crate or imported from another.\n ///\n /// Not parsed directly, but created on macro import or `macro_rules!` expansion.\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct MacroDef {\n     pub name: Name,\n     pub vis: Visibility,\n@@ -759,7 +759,7 @@ pub struct MacroDef {\n     pub legacy: bool,\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct Block {\n     /// Statements in a block\n     pub stmts: HirVec<Stmt>,\n@@ -782,7 +782,7 @@ pub struct Block {\n     pub recovered: bool,\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash)]\n pub struct Pat {\n     pub id: NodeId,\n     pub hir_id: HirId,\n@@ -844,7 +844,7 @@ impl Pat {\n /// Patterns like the fields of Foo `{ x, ref y, ref mut z }`\n /// are treated the same as` x: x, y: ref y, z: ref mut z`,\n /// except is_shorthand is true\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct FieldPat {\n     pub id: NodeId,\n     /// The identifier for the field\n@@ -857,7 +857,7 @@ pub struct FieldPat {\n /// Explicit binding annotations given in the HIR for a binding. Note\n /// that this is not the final binding *mode* that we infer after type\n /// inference.\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n+#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n pub enum BindingAnnotation {\n   /// No binding annotation given: this means that the final binding mode\n   /// will depend on whether we have skipped through a `&` reference\n@@ -878,13 +878,13 @@ pub enum BindingAnnotation {\n   RefMut,\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum RangeEnd {\n     Included,\n     Excluded,\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum PatKind {\n     /// Represents a wildcard pattern (`_`)\n     Wild,\n@@ -940,7 +940,7 @@ impl Mutability {\n     }\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n+#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n pub enum BinOp_ {\n     /// The `+` operator (addition)\n     BiAdd,\n@@ -1069,7 +1069,7 @@ impl Into<ast::BinOpKind> for BinOp_ {\n \n pub type BinOp = Spanned<BinOp_>;\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n+#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n pub enum UnOp {\n     /// The `*` operator for dereferencing\n     UnDeref,\n@@ -1111,7 +1111,7 @@ impl fmt::Debug for Stmt_ {\n     }\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash)]\n pub enum Stmt_ {\n     /// Could be an item or a local (let) binding:\n     StmtDecl(P<Decl>, NodeId),\n@@ -1142,7 +1142,7 @@ impl Stmt_ {\n }\n \n /// Local represents a `let` statement, e.g., `let <pat>:<ty> = <expr>;`\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct Local {\n     pub pat: P<Pat>,\n     pub ty: Option<P<Ty>>,\n@@ -1157,7 +1157,7 @@ pub struct Local {\n \n pub type Decl = Spanned<Decl_>;\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum Decl_ {\n     /// A local (let) binding:\n     DeclLocal(P<Local>),\n@@ -1182,15 +1182,15 @@ impl Decl_ {\n }\n \n /// represents one arm of a 'match'\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct Arm {\n     pub attrs: HirVec<Attribute>,\n     pub pats: HirVec<P<Pat>>,\n     pub guard: Option<P<Expr>>,\n     pub body: P<Expr>,\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct Field {\n     pub id: NodeId,\n     pub ident: Ident,\n@@ -1199,15 +1199,15 @@ pub struct Field {\n     pub is_shorthand: bool,\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n+#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n pub enum BlockCheckMode {\n     DefaultBlock,\n     UnsafeBlock(UnsafeSource),\n     PushUnsafeBlock(UnsafeSource),\n     PopUnsafeBlock(UnsafeSource),\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n+#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n pub enum UnsafeSource {\n     CompilerGenerated,\n     UserProvided,\n@@ -1239,7 +1239,7 @@ pub struct BodyId {\n ///\n /// All bodies have an **owner**, which can be accessed via the HIR\n /// map using `body_owner_def_id()`.\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct Body {\n     pub arguments: HirVec<Arg>,\n     pub value: Expr,\n@@ -1279,7 +1279,7 @@ pub struct AnonConst {\n }\n \n /// An expression\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash)]\n pub struct Expr {\n     pub id: NodeId,\n     pub span: Span,\n@@ -1330,7 +1330,7 @@ impl fmt::Debug for Expr {\n     }\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum Expr_ {\n     /// A `box x` expression.\n     ExprBox(P<Expr>),\n@@ -1432,7 +1432,7 @@ pub enum Expr_ {\n }\n \n /// Optionally `Self`-qualified value/type path or associated extension.\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum QPath {\n     /// Path to a definition, optionally \"fully-qualified\" with a `Self`\n     /// type, if the path points to an associated item in a trait.\n@@ -1452,7 +1452,7 @@ pub enum QPath {\n }\n \n /// Hints at the original code for a let statement\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n pub enum LocalSource {\n     /// A `match _ { .. }`\n     Normal,\n@@ -1479,7 +1479,7 @@ pub enum MatchSource {\n }\n \n /// The loop type that yielded an ExprLoop\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n+#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n pub enum LoopSource {\n     /// A `loop { .. }` loop\n     Loop,\n@@ -1489,7 +1489,7 @@ pub enum LoopSource {\n     ForLoop,\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n pub enum LoopIdError {\n     OutsideLoopScope,\n     UnlabeledCfInWhileCondition,\n@@ -1507,7 +1507,6 @@ impl fmt::Display for LoopIdError {\n     }\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n pub struct Destination {\n     // This is `Some(_)` iff there is an explicit user-specified `label\n     pub label: Option<Label>,\n@@ -1523,22 +1522,22 @@ pub enum GeneratorMovability {\n     Movable,\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n pub enum CaptureClause {\n     CaptureByValue,\n     CaptureByRef,\n }\n \n // NB: If you change this, you'll probably want to change the corresponding\n // type structure in middle/ty.rs as well.\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct MutTy {\n     pub ty: P<Ty>,\n     pub mutbl: Mutability,\n }\n \n /// Represents a method's signature in a trait declaration or implementation.\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct MethodSig {\n     pub header: FnHeader,\n     pub decl: P<FnDecl>,\n@@ -1556,7 +1555,7 @@ pub struct TraitItemId {\n /// possibly including a default implementation. A trait item is\n /// either required (meaning it doesn't have an implementation, just a\n /// signature) or provided (meaning it has a default implementation).\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct TraitItem {\n     pub id: NodeId,\n     pub ident: Ident,\n@@ -1568,7 +1567,7 @@ pub struct TraitItem {\n }\n \n /// A trait method's body (or just argument names).\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum TraitMethod {\n     /// No default body in the trait, just a signature.\n     Required(HirVec<Ident>),\n@@ -1578,7 +1577,7 @@ pub enum TraitMethod {\n }\n \n /// Represents a trait method or associated constant or type\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum TraitItemKind {\n     /// An associated constant with an optional value (otherwise `impl`s\n     /// must contain a value)\n@@ -1599,7 +1598,7 @@ pub struct ImplItemId {\n }\n \n /// Represents anything within an `impl` block\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct ImplItem {\n     pub id: NodeId,\n     pub ident: Ident,\n@@ -1613,7 +1612,7 @@ pub struct ImplItem {\n }\n \n /// Represents different contents within `impl`s\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum ImplItemKind {\n     /// An associated constant of the given type, set to the constant result\n     /// of the expression\n@@ -1625,7 +1624,7 @@ pub enum ImplItemKind {\n }\n \n // Bind a type to an associated type: `A=Foo`.\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct TypeBinding {\n     pub id: NodeId,\n     pub ident: Ident,\n@@ -1634,7 +1633,7 @@ pub struct TypeBinding {\n }\n \n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash)]\n pub struct Ty {\n     pub id: NodeId,\n     pub node: Ty_,\n@@ -1660,7 +1659,7 @@ pub enum PrimTy {\n     TyChar,\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct BareFnTy {\n     pub unsafety: Unsafety,\n     pub abi: Abi,\n@@ -1669,14 +1668,14 @@ pub struct BareFnTy {\n     pub arg_names: HirVec<Ident>,\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct ExistTy {\n     pub generics: Generics,\n     pub bounds: GenericBounds,\n     pub impl_trait_fn: Option<DefId>,\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash, Debug)]\n /// The different kinds of types recognized by the compiler\n pub enum Ty_ {\n     /// A variable length slice (`[T]`)\n@@ -1710,14 +1709,14 @@ pub enum Ty_ {\n     TyErr,\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct InlineAsmOutput {\n     pub constraint: Symbol,\n     pub is_rw: bool,\n     pub is_indirect: bool,\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct InlineAsm {\n     pub asm: Symbol,\n     pub asm_str_style: StrStyle,\n@@ -1731,15 +1730,15 @@ pub struct InlineAsm {\n }\n \n /// represents an argument in a function header\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct Arg {\n     pub pat: P<Pat>,\n     pub id: NodeId,\n     pub hir_id: HirId,\n }\n \n /// Represents the header (not the body) of a function declaration\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct FnDecl {\n     pub inputs: HirVec<Ty>,\n     pub output: FunctionRetTy,\n@@ -1750,7 +1749,7 @@ pub struct FnDecl {\n }\n \n /// Is the trait definition an auto trait?\n-#[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum IsAuto {\n     Yes,\n     No\n@@ -1768,13 +1767,13 @@ pub enum Unsafety {\n     Normal,\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum Constness {\n     Const,\n     NotConst,\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum Defaultness {\n     Default { has_value: bool },\n     Final,\n@@ -1810,7 +1809,7 @@ impl fmt::Display for Unsafety {\n     }\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash)]\n+#[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, Hash)]\n pub enum ImplPolarity {\n     /// `impl Trait for Type`\n     Positive,\n@@ -1828,7 +1827,7 @@ impl fmt::Debug for ImplPolarity {\n }\n \n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum FunctionRetTy {\n     /// Return type is not specified.\n     ///\n@@ -1849,7 +1848,7 @@ impl FunctionRetTy {\n     }\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct Mod {\n     /// A span from the first token past `{` to the last token until `}`.\n     /// For `mod foo;`, the inner span ranges from the first token\n@@ -1858,24 +1857,24 @@ pub struct Mod {\n     pub item_ids: HirVec<ItemId>,\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct ForeignMod {\n     pub abi: Abi,\n     pub items: HirVec<ForeignItem>,\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct GlobalAsm {\n     pub asm: Symbol,\n     pub ctxt: SyntaxContext,\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct EnumDef {\n     pub variants: HirVec<Variant>,\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct Variant_ {\n     pub name: Name,\n     pub attrs: HirVec<Attribute>,\n@@ -1886,7 +1885,7 @@ pub struct Variant_ {\n \n pub type Variant = Spanned<Variant_>;\n \n-#[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum UseKind {\n     /// One import, e.g. `use foo::bar` or `use foo::bar as baz`.\n     /// Also produced for each element of a list `use`, e.g.\n@@ -1908,13 +1907,13 @@ pub enum UseKind {\n /// that the ref_id is for. Note that ref_id's value is not the NodeId of the\n /// trait being referred to but just a unique NodeId that serves as a key\n /// within the DefMap.\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct TraitRef {\n     pub path: Path,\n     pub ref_id: NodeId,\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct PolyTraitRef {\n     /// The `'a` in `<'a> Foo<&'a T>`\n     pub bound_generic_params: HirVec<GenericParam>,\n@@ -1927,7 +1926,7 @@ pub struct PolyTraitRef {\n \n pub type Visibility = Spanned<VisibilityKind>;\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum VisibilityKind {\n     Public,\n     Crate(CrateSugar),\n@@ -1953,7 +1952,7 @@ impl VisibilityKind {\n     }\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct StructField {\n     pub span: Span,\n     pub ident: Ident,\n@@ -1982,7 +1981,7 @@ impl StructField {\n /// used for `Struct`-structs (but still presents). Structures don't have an analogue of \"Id of\n /// the variant itself\" from enum variants.\n /// Id of the whole struct lives in `Item`.\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum VariantData {\n     Struct(HirVec<StructField>, NodeId),\n     Tuple(HirVec<StructField>, NodeId),\n@@ -2027,15 +2026,15 @@ impl VariantData {\n // The bodies for items are stored \"out of line\", in a separate\n // hashmap in the `Crate`. Here we just record the node-id of the item\n // so it can fetched later.\n-#[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Copy, Clone, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct ItemId {\n     pub id: NodeId,\n }\n \n /// An item\n ///\n /// The name might be a dummy name in case of anonymous items\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct Item {\n     pub name: Name,\n     pub id: NodeId,\n@@ -2046,15 +2045,15 @@ pub struct Item {\n     pub span: Span,\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, Copy, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct FnHeader {\n     pub unsafety: Unsafety,\n     pub constness: Constness,\n     pub asyncness: IsAsync,\n     pub abi: Abi,\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum Item_ {\n     /// An `extern crate` item, with optional *original* crate name if the crate was renamed.\n     ///\n@@ -2156,7 +2155,7 @@ impl Item_ {\n /// type or method, and whether it is public). This allows other\n /// passes to find the impl they want without loading the id (which\n /// means fewer edges in the incremental compilation graph).\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct TraitItemRef {\n     pub id: TraitItemId,\n     pub ident: Ident,\n@@ -2171,7 +2170,7 @@ pub struct TraitItemRef {\n /// type or method, and whether it is public). This allows other\n /// passes to find the impl they want without loading the id (which\n /// means fewer edges in the incremental compilation graph).\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct ImplItemRef {\n     pub id: ImplItemId,\n     pub ident: Ident,\n@@ -2181,14 +2180,14 @@ pub struct ImplItemRef {\n     pub defaultness: Defaultness,\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum AssociatedItemKind {\n     Const,\n     Method { has_self: bool },\n     Type,\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct ForeignItem {\n     pub name: Name,\n     pub attrs: HirVec<Attribute>,\n@@ -2199,7 +2198,7 @@ pub struct ForeignItem {\n }\n \n /// An item within an `extern` block\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum ForeignItem_ {\n     /// A foreign function\n     ForeignItemFn(P<FnDecl>, HirVec<Ident>, Generics),"}, {"sha": "377990ef561a76a79416707f8ab79a754b50cd30", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4d1a30c92b50c5965ed26449758fca81bee15747/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d1a30c92b50c5965ed26449758fca81bee15747/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=4d1a30c92b50c5965ed26449758fca81bee15747", "patch": "@@ -1914,7 +1914,9 @@ impl<'a> State<'a> {\n                     if !before.is_empty() {\n                         self.word_space(\",\")?;\n                     }\n-                    if p.node != PatKind::Wild {\n+                    if let PatKind::Wild = p.node {\n+                        // Print nothing\n+                    } else {\n                         self.print_pat(&p)?;\n                     }\n                     self.s.word(\"..\")?;\n@@ -2033,7 +2035,9 @@ impl<'a> State<'a> {\n             s.ann.nested(s, Nested::BodyArgPat(body_id, i))?;\n             i += 1;\n \n-            if ty.node != hir::TyInfer {\n+            if let hir::TyInfer = ty.node {\n+                // Print nothing\n+            } else {\n                 s.s.word(\":\")?;\n                 s.s.space()?;\n                 s.print_type(ty)?;"}, {"sha": "f3f3dcfeea0025349a0bcbc264205119802b6bd2", "filename": "src/librustc/infer/error_reporting/nice_region_error/different_lifetimes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4d1a30c92b50c5965ed26449758fca81bee15747/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d1a30c92b50c5965ed26449758fca81bee15747/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs?ref=4d1a30c92b50c5965ed26449758fca81bee15747", "patch": "@@ -111,7 +111,7 @@ impl<'a, 'gcx, 'tcx> NiceRegionError<'a, 'gcx, 'tcx> {\n \n         let (span_1, span_2, main_label, span_label) = match (sup_is_ret_type, sub_is_ret_type) {\n             (None, None) => {\n-                let (main_label_1, span_label_1) = if ty_sup == ty_sub {\n+                let (main_label_1, span_label_1) = if ty_sup.id == ty_sub.id {\n                     (\n                         format!(\"this type is declared with multiple lifetimes...\"),\n                         format!("}, {"sha": "bbfcfb798909b0e51744af87ee988d0bbcd0d879", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4d1a30c92b50c5965ed26449758fca81bee15747/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d1a30c92b50c5965ed26449758fca81bee15747/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=4d1a30c92b50c5965ed26449758fca81bee15747", "patch": "@@ -174,7 +174,7 @@ pub struct ImplHeader<'tcx> {\n     pub predicates: Vec<Predicate<'tcx>>,\n }\n \n-#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+#[derive(Copy, Clone, Debug, PartialEq)]\n pub struct AssociatedItem {\n     pub def_id: DefId,\n     pub ident: Ident,"}, {"sha": "e48009c16d20d8c87a86c9f22a966e10fff3d1d5", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4d1a30c92b50c5965ed26449758fca81bee15747/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d1a30c92b50c5965ed26449758fca81bee15747/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=4d1a30c92b50c5965ed26449758fca81bee15747", "patch": "@@ -397,7 +397,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n             hir::ItemUnion(..) => \"a union\",\n             hir::ItemTrait(.., ref trait_item_refs) => {\n                 // Issue #11592, traits are always considered exported, even when private.\n-                if it.vis.node == hir::VisibilityKind::Inherited {\n+                if let hir::VisibilityKind::Inherited = it.vis.node {\n                     self.private_traits.insert(it.id);\n                     for trait_item_ref in trait_item_refs {\n                         self.private_traits.insert(trait_item_ref.id.node_id);\n@@ -414,7 +414,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n                 if let Some(node_id) = cx.tcx.hir.as_local_node_id(real_trait) {\n                     match cx.tcx.hir.find(node_id) {\n                         Some(hir_map::NodeItem(item)) => {\n-                            if item.vis.node == hir::VisibilityKind::Inherited {\n+                            if let hir::VisibilityKind::Inherited = item.vis.node {\n                                 for impl_item_ref in impl_item_refs {\n                                     self.private_traits.insert(impl_item_ref.id.node_id);\n                                 }"}, {"sha": "4a9d3e6a1146172dd9c825e16ef81a4953a6df68", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/4d1a30c92b50c5965ed26449758fca81bee15747/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d1a30c92b50c5965ed26449758fca81bee15747/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=4d1a30c92b50c5965ed26449758fca81bee15747", "patch": "@@ -60,19 +60,21 @@ impl<'a> AstValidator<'a> {\n     }\n \n     fn invalid_visibility(&self, vis: &Visibility, note: Option<&str>) {\n-        if vis.node != VisibilityKind::Inherited {\n-            let mut err = struct_span_err!(self.session,\n-                                           vis.span,\n-                                           E0449,\n-                                           \"unnecessary visibility qualifier\");\n-            if vis.node == VisibilityKind::Public {\n-                err.span_label(vis.span, \"`pub` not permitted here because it's implied\");\n-            }\n-            if let Some(note) = note {\n-                err.note(note);\n-            }\n-            err.emit();\n+        if let VisibilityKind::Inherited = vis.node {\n+            return\n+        }\n+\n+        let mut err = struct_span_err!(self.session,\n+                                        vis.span,\n+                                        E0449,\n+                                        \"unnecessary visibility qualifier\");\n+        if vis.node.is_public() {\n+            err.span_label(vis.span, \"`pub` not permitted here because it's implied\");\n+        }\n+        if let Some(note) = note {\n+            err.note(note);\n         }\n+        err.emit();\n     }\n \n     fn check_decl_no_pat<ReportFn: Fn(Span, bool)>(&self, decl: &FnDecl, report_err: ReportFn) {\n@@ -268,7 +270,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n         match item.node {\n             ItemKind::Impl(unsafety, polarity, _, _, Some(..), ref ty, ref impl_items) => {\n                 self.invalid_visibility(&item.vis, None);\n-                if ty.node == TyKind::Err {\n+                if let TyKind::Err = ty.node {\n                     self.err_handler()\n                         .struct_span_err(item.span, \"`impl Trait for .. {}` is an obsolete syntax\")\n                         .help(\"use `auto trait Trait {}` instead\").emit();"}, {"sha": "ec067a6477b6d84a7f12c5b738dd27f90fac2f4a", "filename": "src/librustc_resolve/check_unused.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4d1a30c92b50c5965ed26449758fca81bee15747/src%2Flibrustc_resolve%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d1a30c92b50c5965ed26449758fca81bee15747/src%2Flibrustc_resolve%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fcheck_unused.rs?ref=4d1a30c92b50c5965ed26449758fca81bee15747", "patch": "@@ -86,7 +86,7 @@ impl<'a, 'b> Visitor<'a> for UnusedImportCheckVisitor<'a, 'b> {\n         // because this means that they were generated in some fashion by the\n         // compiler and we don't need to consider them.\n         if let ast::ItemKind::Use(..) = item.node {\n-            if item.vis.node == ast::VisibilityKind::Public || item.span.is_dummy() {\n+            if item.vis.node.is_pub() || item.span.is_dummy() {\n                 return;\n             }\n         }"}, {"sha": "f3086d3ab2b1bdcd3f1302ce5804962b7a1649ff", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4d1a30c92b50c5965ed26449758fca81bee15747/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d1a30c92b50c5965ed26449758fca81bee15747/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=4d1a30c92b50c5965ed26449758fca81bee15747", "patch": "@@ -456,7 +456,7 @@ enum AliasPossibility {\n     Maybe,\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+#[derive(Copy, Clone, Debug)]\n enum PathSource<'a> {\n     // Type paths `Path`.\n     Type,"}, {"sha": "e0de60556a230e26b51df14fdc85f6bc5cb6f846", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4d1a30c92b50c5965ed26449758fca81bee15747/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d1a30c92b50c5965ed26449758fca81bee15747/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=4d1a30c92b50c5965ed26449758fca81bee15747", "patch": "@@ -65,14 +65,14 @@ macro_rules! down_cast_data {\n macro_rules! access_from {\n     ($save_ctxt:expr, $vis:expr, $id:expr) => {\n         Access {\n-            public: $vis.node == ast::VisibilityKind::Public,\n+            public: $vis.node.is_public(),\n             reachable: $save_ctxt.analysis.access_levels.is_reachable($id),\n         }\n     };\n \n     ($save_ctxt:expr, $item:expr) => {\n         Access {\n-            public: $item.vis.node == ast::VisibilityKind::Public,\n+            public: $item.vis.node.is_public(),\n             reachable: $save_ctxt.analysis.access_levels.is_reachable($item.id),\n         }\n     };\n@@ -523,7 +523,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n                     .iter()\n                     .enumerate()\n                     .filter_map(|(i, f)| {\n-                        if include_priv_fields || f.vis.node == ast::VisibilityKind::Public {\n+                        if include_priv_fields || f.vis.node.is_public() {\n                             f.ident\n                                 .map(|i| i.to_string())\n                                 .or_else(|| Some(i.to_string()))"}, {"sha": "bee866db9e467d5560ca2daf3fbfdcb824311206", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4d1a30c92b50c5965ed26449758fca81bee15747/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d1a30c92b50c5965ed26449758fca81bee15747/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=4d1a30c92b50c5965ed26449758fca81bee15747", "patch": "@@ -119,7 +119,7 @@ enum ProbeResult {\n     Match,\n }\n \n-#[derive(Debug, PartialEq, Eq, Clone)]\n+#[derive(Debug, PartialEq, Clone)]\n pub struct Pick<'tcx> {\n     pub item: ty::AssociatedItem,\n     pub kind: PickKind<'tcx>,"}, {"sha": "8d40c21667e67d33b57c735d757253aa91c9e9ad", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4d1a30c92b50c5965ed26449758fca81bee15747/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d1a30c92b50c5965ed26449758fca81bee15747/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=4d1a30c92b50c5965ed26449758fca81bee15747", "patch": "@@ -754,7 +754,7 @@ impl<'a> FromIterator<&'a DocFragment> for String {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Debug, Default, Hash)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, Default, Hash)]\n pub struct Attributes {\n     pub doc_strings: Vec<DocFragment>,\n     pub other_attrs: Vec<ast::Attribute>,\n@@ -974,6 +974,18 @@ impl Attributes {\n     }\n }\n \n+impl PartialEq for Attributes {\n+    fn eq(&self, rhs: &Self) -> bool {\n+        self.doc_strings == rhs.doc_strings &&\n+        self.cfg == rhs.cfg &&\n+        self.span == rhs.span &&\n+        self.links == rhs.links &&\n+        self.other_attrs.id == rhs.other_attrs.id\n+    }\n+}\n+\n+impl Eq for Attributes {}\n+\n impl AttributesExt for Attributes {\n     fn lists<'a>(&'a self, name: &'a str) -> ListAttributesIter<'a> {\n         self.other_attrs.lists(name)\n@@ -1830,7 +1842,7 @@ impl<'tcx> Clean<Type> for ty::ProjectionTy<'tcx> {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Debug, Hash)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Debug, Hash)]\n pub enum GenericParamDefKind {\n     Lifetime,\n     Type {\n@@ -1841,6 +1853,8 @@ pub enum GenericParamDefKind {\n     },\n }\n \n+impl Eq for GenericParamDefKind {}\n+\n #[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Debug, Hash)]\n pub struct GenericParamDef {\n     pub name: String,"}, {"sha": "da705081ff34d20f6c011af30df358cca2b1f316", "filename": "src/libserialize/collection_impls.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4d1a30c92b50c5965ed26449758fca81bee15747/src%2Flibserialize%2Fcollection_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d1a30c92b50c5965ed26449758fca81bee15747/src%2Flibserialize%2Fcollection_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fcollection_impls.rs?ref=4d1a30c92b50c5965ed26449758fca81bee15747", "patch": "@@ -67,7 +67,7 @@ impl<T:Decodable> Decodable for VecDeque<T> {\n \n impl<\n     K: Encodable + PartialEq + Ord,\n-    V: Encodable + PartialEq\n+    V: Encodable\n > Encodable for BTreeMap<K, V> {\n     fn encode<S: Encoder>(&self, e: &mut S) -> Result<(), S::Error> {\n         e.emit_map(self.len(), |e| {\n@@ -84,7 +84,7 @@ impl<\n \n impl<\n     K: Decodable + PartialEq + Ord,\n-    V: Decodable + PartialEq\n+    V: Decodable\n > Decodable for BTreeMap<K, V> {\n     fn decode<D: Decoder>(d: &mut D) -> Result<BTreeMap<K, V>, D::Error> {\n         d.read_map(|d, len| {"}, {"sha": "f689e27a3aba243e67864b5248790fd11fe2f5cf", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 115, "deletions": 100, "changes": 215, "blob_url": "https://github.com/rust-lang/rust/blob/4d1a30c92b50c5965ed26449758fca81bee15747/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d1a30c92b50c5965ed26449758fca81bee15747/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=4d1a30c92b50c5965ed26449758fca81bee15747", "patch": "@@ -34,7 +34,7 @@ use std::u32;\n \n pub use rustc_target::abi::FloatTy;\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Copy)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash, Copy)]\n pub struct Label {\n     pub ident: Ident,\n }\n@@ -45,7 +45,7 @@ impl fmt::Debug for Label {\n     }\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Copy)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash, Copy)]\n pub struct Lifetime {\n     pub id: NodeId,\n     pub ident: Ident,\n@@ -63,7 +63,7 @@ impl fmt::Debug for Lifetime {\n /// along with a bunch of supporting information.\n ///\n /// E.g. `std::cmp::PartialEq`\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash)]\n pub struct Path {\n     pub span: Span,\n     /// The segments in the path: the things separated by `::`.\n@@ -115,7 +115,7 @@ impl Path {\n /// A segment of a path: an identifier, an optional lifetime, and a set of types.\n ///\n /// E.g. `std`, `String` or `Box<T>`\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct PathSegment {\n     /// The identifier portion of this path segment.\n     pub ident: Ident,\n@@ -141,7 +141,7 @@ impl PathSegment {\n /// Arguments of a path segment.\n ///\n /// E.g. `<A, B>` as in `Foo<A, B>` or `(A, B)` as in `Foo(A, B)`\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum GenericArgs {\n     /// The `<'a, A,B,C>` in `foo::bar::baz::<'a, A,B,C>`\n     AngleBracketed(AngleBracketedArgs),\n@@ -158,14 +158,14 @@ impl GenericArgs {\n     }\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum GenericArg {\n     Lifetime(Lifetime),\n     Type(P<Ty>),\n }\n \n /// A path like `Foo<'a, T>`\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Default)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash, Debug, Default)]\n pub struct AngleBracketedArgs {\n     /// Overall span\n     pub span: Span,\n@@ -190,7 +190,7 @@ impl Into<Option<P<GenericArgs>>> for ParenthesisedArgs {\n }\n \n /// A path like `Foo(A,B) -> C`\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct ParenthesisedArgs {\n     /// Overall span\n     pub span: Span,\n@@ -202,7 +202,7 @@ pub struct ParenthesisedArgs {\n     pub output: Option<P<Ty>>,\n }\n \n-#[derive(Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Hash, Debug)]\n+#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]\n pub struct NodeId(u32);\n \n impl NodeId {\n@@ -280,7 +280,7 @@ pub enum TraitBoundModifier {\n /// typeck::collect::compute_bounds matches these against\n /// the \"special\" built-in traits (see middle::lang_items) and\n /// detects Copy, Send and Sync.\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum GenericBound {\n     Trait(PolyTraitRef, TraitBoundModifier),\n     Outlives(Lifetime)\n@@ -297,7 +297,7 @@ impl GenericBound {\n \n pub type GenericBounds = Vec<GenericBound>;\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum GenericParamKind {\n     /// A lifetime definition, e.g. `'a: 'b+'c+'d`.\n     Lifetime,\n@@ -306,7 +306,7 @@ pub enum GenericParamKind {\n     }\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct GenericParam {\n     pub id: NodeId,\n     pub ident: Ident,\n@@ -318,7 +318,7 @@ pub struct GenericParam {\n \n /// Represents lifetime, type and const parameters attached to a declaration of\n /// a function, enum, trait, etc.\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct Generics {\n     pub params: Vec<GenericParam>,\n     pub where_clause: WhereClause,\n@@ -341,15 +341,15 @@ impl Default for Generics {\n }\n \n /// A `where` clause in a definition\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct WhereClause {\n     pub id: NodeId,\n     pub predicates: Vec<WherePredicate>,\n     pub span: Span,\n }\n \n /// A single predicate in a `where` clause\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum WherePredicate {\n     /// A type binding, e.g. `for<'c> Foo: Send+Clone+'c`\n     BoundPredicate(WhereBoundPredicate),\n@@ -372,7 +372,7 @@ impl WherePredicate {\n /// A type bound.\n ///\n /// E.g. `for<'c> Foo: Send+Clone+'c`\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct WhereBoundPredicate {\n     pub span: Span,\n     /// Any generics from a `for` binding\n@@ -386,7 +386,7 @@ pub struct WhereBoundPredicate {\n /// A lifetime predicate.\n ///\n /// E.g. `'a: 'b+'c`\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct WhereRegionPredicate {\n     pub span: Span,\n     pub lifetime: Lifetime,\n@@ -396,7 +396,7 @@ pub struct WhereRegionPredicate {\n /// An equality predicate (unsupported).\n ///\n /// E.g. `T=int`\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct WhereEqPredicate {\n     pub id: NodeId,\n     pub span: Span,\n@@ -408,7 +408,7 @@ pub struct WhereEqPredicate {\n /// used to drive conditional compilation\n pub type CrateConfig = HashSet<(Name, Option<Symbol>)>;\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct Crate {\n     pub module: Mod,\n     pub attrs: Vec<Attribute>,\n@@ -421,7 +421,7 @@ pub type NestedMetaItem = Spanned<NestedMetaItemKind>;\n /// Possible values inside of compile-time attribute lists.\n ///\n /// E.g. the '..' in `#[name(..)]`.\n-#[derive(Clone, Eq, RustcEncodable, RustcDecodable, Hash, Debug, PartialEq)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum NestedMetaItemKind {\n     /// A full MetaItem, for recursive meta items.\n     MetaItem(MetaItem),\n@@ -434,7 +434,7 @@ pub enum NestedMetaItemKind {\n /// A spanned compile-time attribute item.\n ///\n /// E.g. `#[test]`, `#[derive(..)]`, `#[rustfmt::skip]` or `#[feature = \"foo\"]`\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct MetaItem {\n     pub ident: Path,\n     pub node: MetaItemKind,\n@@ -444,7 +444,7 @@ pub struct MetaItem {\n /// A compile-time attribute item.\n ///\n /// E.g. `#[test]`, `#[derive(..)]` or `#[feature = \"foo\"]`\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum MetaItemKind {\n     /// Word meta item.\n     ///\n@@ -463,7 +463,7 @@ pub enum MetaItemKind {\n /// A Block (`{ .. }`).\n ///\n /// E.g. `{ .. }` as in `fn foo() { .. }`\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct Block {\n     /// Statements in a block\n     pub stmts: Vec<Stmt>,\n@@ -474,7 +474,7 @@ pub struct Block {\n     pub recovered: bool,\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash)]\n pub struct Pat {\n     pub id: NodeId,\n     pub node: PatKind,\n@@ -552,7 +552,7 @@ impl Pat {\n /// Patterns like the fields of Foo `{ x, ref y, ref mut z }`\n /// are treated the same as` x: x, y: ref y, z: ref mut z`,\n /// except is_shorthand is true\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct FieldPat {\n     /// The identifier for the field\n     pub ident: Ident,\n@@ -562,25 +562,25 @@ pub struct FieldPat {\n     pub attrs: ThinVec<Attribute>,\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n+#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n pub enum BindingMode {\n     ByRef(Mutability),\n     ByValue(Mutability),\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum RangeEnd {\n     Included(RangeSyntax),\n     Excluded,\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum RangeSyntax {\n     DotDotDot,\n     DotDotEq,\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum PatKind {\n     /// Represents a wildcard pattern (`_`)\n     Wild,\n@@ -633,7 +633,7 @@ pub enum Mutability {\n     Immutable,\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n+#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n pub enum BinOpKind {\n     /// The `+` operator (addition)\n     Add,\n@@ -730,7 +730,7 @@ impl BinOpKind {\n \n pub type BinOp = Spanned<BinOpKind>;\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n pub enum UnOp {\n     /// The `*` operator for dereferencing\n     Deref,\n@@ -759,7 +759,7 @@ impl UnOp {\n }\n \n /// A statement\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash)]\n pub struct Stmt {\n     pub id: NodeId,\n     pub node: StmtKind,\n@@ -800,7 +800,7 @@ impl fmt::Debug for Stmt {\n }\n \n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash)]\n pub enum StmtKind {\n     /// A local (let) binding.\n     Local(P<Local>),\n@@ -816,7 +816,7 @@ pub enum StmtKind {\n     Mac(P<(Mac, MacStmtStyle, ThinVec<Attribute>)>),\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, Copy, PartialEq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum MacStmtStyle {\n     /// The macro statement had a trailing semicolon, e.g. `foo! { ... };`\n     /// `foo!(...);`, `foo![...];`\n@@ -830,7 +830,7 @@ pub enum MacStmtStyle {\n }\n \n /// Local represents a `let` statement, e.g., `let <pat>:<ty> = <expr>;`\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct Local {\n     pub pat: P<Pat>,\n     pub ty: Option<P<Ty>>,\n@@ -851,15 +851,15 @@ pub struct Local {\n ///     _ => { println!(\"no match!\") },\n /// }\n /// ```\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct Arm {\n     pub attrs: Vec<Attribute>,\n     pub pats: Vec<P<Pat>>,\n     pub guard: Option<P<Expr>>,\n     pub body: P<Expr>,\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct Field {\n     pub ident: Ident,\n     pub expr: P<Expr>,\n@@ -868,13 +868,15 @@ pub struct Field {\n     pub attrs: ThinVec<Attribute>,\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n+pub type SpannedIdent = Spanned<Ident>;\n+\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n pub enum BlockCheckMode {\n     Default,\n     Unsafe(UnsafeSource),\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n pub enum UnsafeSource {\n     CompilerGenerated,\n     UserProvided,\n@@ -885,15 +887,15 @@ pub enum UnsafeSource {\n /// These are usually found nested inside types (e.g. array lengths)\n /// or expressions (e.g. repeat counts), and also used to define\n /// explicit discriminant values for enum variants.\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct AnonConst {\n     pub id: NodeId,\n     pub value: P<Expr>,\n }\n \n \n /// An expression\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash,)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash,)]\n pub struct Expr {\n     pub id: NodeId,\n     pub node: ExprKind,\n@@ -1016,15 +1018,15 @@ impl fmt::Debug for Expr {\n }\n \n /// Limit types of a range (inclusive or exclusive)\n-#[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum RangeLimits {\n     /// Inclusive at the beginning, exclusive at the end\n     HalfOpen,\n     /// Inclusive at the beginning and end\n     Closed,\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum ExprKind {\n     /// A `box x` expression.\n     Box(P<Expr>),\n@@ -1181,7 +1183,7 @@ pub enum ExprKind {\n ///  ^~~~~    ^\n ///  ty       position = 0\n /// ```\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct QSelf {\n     pub ty: P<Ty>,\n \n@@ -1193,14 +1195,14 @@ pub struct QSelf {\n }\n \n /// A capture clause\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n+#[derive(Clone, Copy, PartialEq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum CaptureBy {\n     Value,\n     Ref,\n }\n \n /// The movability of a generator / closure literal\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n+#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n pub enum Movability {\n     Static,\n     Movable,\n@@ -1214,7 +1216,7 @@ pub type Mac = Spanned<Mac_>;\n ///\n /// NB: the additional ident for a macro_rules-style macro is actually\n /// stored in the enclosing item. Oog.\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct Mac_ {\n     pub path: Path,\n     pub delim: MacDelimiter,\n@@ -1234,7 +1236,7 @@ impl Mac_ {\n     }\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct MacroDef {\n     pub tokens: ThinTokenStream,\n     pub legacy: bool,\n@@ -1246,7 +1248,7 @@ impl MacroDef {\n     }\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n pub enum StrStyle {\n     /// A regular string, like `\"foo\"`\n     Cooked,\n@@ -1259,7 +1261,7 @@ pub enum StrStyle {\n /// A literal\n pub type Lit = Spanned<LitKind>;\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n pub enum LitIntType {\n     Signed(IntTy),\n     Unsigned(UintTy),\n@@ -1269,7 +1271,7 @@ pub enum LitIntType {\n /// Literal kind.\n ///\n /// E.g. `\"foo\"`, `42`, `12.34` or `bool`\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum LitKind {\n     /// A string literal (`\"foo\"`)\n     Str(Symbol, StrStyle),\n@@ -1335,15 +1337,15 @@ impl LitKind {\n \n // NB: If you change this, you'll probably want to change the corresponding\n // type structure in middle/ty.rs as well.\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct MutTy {\n     pub ty: P<Ty>,\n     pub mutbl: Mutability,\n }\n \n /// Represents a method's signature in a trait declaration,\n /// or in an implementation.\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct MethodSig {\n     pub header: FnHeader,\n     pub decl: P<FnDecl>,\n@@ -1353,7 +1355,7 @@ pub struct MethodSig {\n /// possibly including a default implementation. A trait item is\n /// either required (meaning it doesn't have an implementation, just a\n /// signature) or provided (meaning it has a default implementation).\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct TraitItem {\n     pub id: NodeId,\n     pub ident: Ident,\n@@ -1365,15 +1367,15 @@ pub struct TraitItem {\n     pub tokens: Option<TokenStream>,\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum TraitItemKind {\n     Const(P<Ty>, Option<P<Expr>>),\n     Method(MethodSig, Option<P<Block>>),\n     Type(GenericBounds, Option<P<Ty>>),\n     Macro(Mac),\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct ImplItem {\n     pub id: NodeId,\n     pub ident: Ident,\n@@ -1387,16 +1389,15 @@ pub struct ImplItem {\n     pub tokens: Option<TokenStream>,\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum ImplItemKind {\n     Const(P<Ty>, P<Expr>),\n     Method(MethodSig, P<Block>),\n     Type(P<Ty>),\n     Macro(Mac),\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Copy,\n-         PartialOrd, Ord)]\n+#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, RustcEncodable, RustcDecodable, Hash, Copy)]\n pub enum IntTy {\n     Isize,\n     I8,\n@@ -1449,8 +1450,7 @@ impl IntTy {\n     }\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Copy,\n-         PartialOrd, Ord)]\n+#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, RustcEncodable, RustcDecodable, Hash, Copy)]\n pub enum UintTy {\n     Usize,\n     U8,\n@@ -1501,15 +1501,15 @@ impl fmt::Display for UintTy {\n }\n \n // Bind a type to an associated type: `A=Foo`.\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct TypeBinding {\n     pub id: NodeId,\n     pub ident: Ident,\n     pub ty: P<Ty>,\n     pub span: Span,\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash)]\n pub struct Ty {\n     pub id: NodeId,\n     pub node: TyKind,\n@@ -1522,7 +1522,7 @@ impl fmt::Debug for Ty {\n     }\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct BareFnTy {\n     pub unsafety: Unsafety,\n     pub abi: Abi,\n@@ -1531,7 +1531,7 @@ pub struct BareFnTy {\n }\n \n /// The different kinds of types recognized by the compiler\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum TyKind {\n     /// A variable-length slice (`[T]`)\n     Slice(P<Ty>),\n@@ -1577,8 +1577,17 @@ pub enum TyKind {\n     Err,\n }\n \n+impl TyKind {\n+    pub fn is_implicit_self(&self) -> bool {\n+        if let TyKind::ImplicitSelf = *self { true } else { false }\n+    }\n+    pub(crate) fn is_empty_tuple(&self) -> bool {\n+        if let TyKind::Tup(ref tys) = *self { tys.is_empty() } else { false }\n+    }\n+}\n+\n /// Syntax used to declare a trait object.\n-#[derive(Clone, Copy, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, Copy, PartialEq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum TraitObjectSyntax {\n     Dyn,\n     None,\n@@ -1587,7 +1596,7 @@ pub enum TraitObjectSyntax {\n /// Inline assembly dialect.\n ///\n /// E.g. `\"intel\"` as in `asm!(\"mov eax, 2\" : \"={eax}\"(result) : : : \"intel\")`\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n+#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n pub enum AsmDialect {\n     Att,\n     Intel,\n@@ -1596,7 +1605,7 @@ pub enum AsmDialect {\n /// Inline assembly.\n ///\n /// E.g. `\"={eax}\"(result)` as in `asm!(\"mov eax, 2\" : \"={eax}\"(result) : : : \"intel\")`\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct InlineAsmOutput {\n     pub constraint: Symbol,\n     pub expr: P<Expr>,\n@@ -1607,7 +1616,7 @@ pub struct InlineAsmOutput {\n /// Inline assembly.\n ///\n /// E.g. `asm!(\"NOP\");`\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct InlineAsm {\n     pub asm: Symbol,\n     pub asm_str_style: StrStyle,\n@@ -1623,7 +1632,7 @@ pub struct InlineAsm {\n /// An argument in a function header.\n ///\n /// E.g. `bar: usize` as in `fn foo(bar: usize)`\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct Arg {\n     pub ty: P<Ty>,\n     pub pat: P<Pat>,\n@@ -1633,7 +1642,7 @@ pub struct Arg {\n /// Alternative representation for `Arg`s describing `self` parameter of methods.\n ///\n /// E.g. `&mut self` as in `fn foo(&mut self)`\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum SelfKind {\n     /// `self`, `mut self`\n     Value(Mutability),\n@@ -1651,7 +1660,7 @@ impl Arg {\n             if ident.name == keywords::SelfValue.name() {\n                 return match self.ty.node {\n                     TyKind::ImplicitSelf => Some(respan(self.pat.span, SelfKind::Value(mutbl))),\n-                    TyKind::Rptr(lt, MutTy{ref ty, mutbl}) if ty.node == TyKind::ImplicitSelf => {\n+                    TyKind::Rptr(lt, MutTy{ref ty, mutbl}) if ty.node.is_implicit_self() => {\n                         Some(respan(self.pat.span, SelfKind::Region(lt, mutbl)))\n                     }\n                     _ => Some(respan(self.pat.span.to(self.ty.span),\n@@ -1701,7 +1710,7 @@ impl Arg {\n /// Header (not the body) of a function declaration.\n ///\n /// E.g. `fn foo(bar: baz)`\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct FnDecl {\n     pub inputs: Vec<Arg>,\n     pub output: FunctionRetTy,\n@@ -1718,19 +1727,19 @@ impl FnDecl {\n }\n \n /// Is the trait definition an auto trait?\n-#[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum IsAuto {\n     Yes,\n     No\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum Unsafety {\n     Unsafe,\n     Normal,\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Copy, Clone, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum IsAsync {\n     Async {\n         closure_id: NodeId,\n@@ -1756,13 +1765,13 @@ impl IsAsync {\n     }\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum Constness {\n     Const,\n     NotConst,\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum Defaultness {\n     Default,\n     Final,\n@@ -1777,7 +1786,7 @@ impl fmt::Display for Unsafety {\n     }\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash)]\n+#[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, Hash)]\n pub enum ImplPolarity {\n     /// `impl Trait for Type`\n     Positive,\n@@ -1795,7 +1804,7 @@ impl fmt::Debug for ImplPolarity {\n }\n \n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum FunctionRetTy {\n     /// Return type is not specified.\n     ///\n@@ -1819,7 +1828,7 @@ impl FunctionRetTy {\n /// Module declaration.\n ///\n /// E.g. `mod foo;` or `mod foo { .. }`\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct Mod {\n     /// A span from the first token past `{` to the last token until `}`.\n     /// For `mod foo;`, the inner span ranges from the first token\n@@ -1831,7 +1840,7 @@ pub struct Mod {\n /// Foreign module declaration.\n ///\n /// E.g. `extern { .. }` or `extern C { .. }`\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct ForeignMod {\n     pub abi: Abi,\n     pub items: Vec<ForeignItem>,\n@@ -1840,18 +1849,18 @@ pub struct ForeignMod {\n /// Global inline assembly\n ///\n /// aka module-level assembly or file-scoped assembly\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n pub struct GlobalAsm {\n     pub asm: Symbol,\n     pub ctxt: SyntaxContext,\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct EnumDef {\n     pub variants: Vec<Variant>,\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct Variant_ {\n     pub ident: Ident,\n     pub attrs: Vec<Attribute>,\n@@ -1863,7 +1872,7 @@ pub struct Variant_ {\n pub type Variant = Spanned<Variant_>;\n \n /// Part of `use` item to the right of its prefix.\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum UseTreeKind {\n     /// `use prefix` or `use prefix as rename`\n     ///\n@@ -1878,7 +1887,7 @@ pub enum UseTreeKind {\n \n /// A tree of paths sharing common prefixes.\n /// Used in `use` items both at top-level and inside of braces in import groups.\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct UseTree {\n     pub prefix: Path,\n     pub kind: UseTreeKind,\n@@ -1899,7 +1908,7 @@ impl UseTree {\n /// Distinguishes between Attributes that decorate items and Attributes that\n /// are contained as statements within items. These two cases need to be\n /// distinguished for pretty-printing.\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n+#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n pub enum AttrStyle {\n     Outer,\n     Inner,\n@@ -1910,7 +1919,7 @@ pub struct AttrId(pub usize);\n \n /// Meta-data associated with an item\n /// Doc-comments are promoted to attributes that have is_sugared_doc = true\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct Attribute {\n     pub id: AttrId,\n     pub style: AttrStyle,\n@@ -1926,13 +1935,13 @@ pub struct Attribute {\n /// that the ref_id is for. The impl_id maps to the \"self type\" of this impl.\n /// If this impl is an ItemKind::Impl, the impl_id is redundant (it could be the\n /// same as the impl's node id).\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct TraitRef {\n     pub path: Path,\n     pub ref_id: NodeId,\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct PolyTraitRef {\n     /// The `'a` in `<'a> Foo<&'a T>`\n     pub bound_generic_params: Vec<GenericParam>,\n@@ -1953,7 +1962,7 @@ impl PolyTraitRef {\n     }\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Copy, Clone, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum CrateSugar {\n     /// Source is `pub(crate)`\n     PubCrate,\n@@ -1964,18 +1973,24 @@ pub enum CrateSugar {\n \n pub type Visibility = Spanned<VisibilityKind>;\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum VisibilityKind {\n     Public,\n     Crate(CrateSugar),\n     Restricted { path: P<Path>, id: NodeId },\n     Inherited,\n }\n \n+impl VisibilityKind {\n+    pub fn is_public(&self) -> bool {\n+        if let VisibilityKind::Public = *self { true } else { false }\n+    }\n+}\n+\n /// Field of a struct.\n ///\n /// E.g. `bar: usize` as in `struct Foo { bar: usize }`\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct StructField {\n     pub span: Span,\n     pub ident: Option<Ident>,\n@@ -1996,7 +2011,7 @@ pub struct StructField {\n /// used for `Struct`-structs (but still presents). Structures don't have an analogue of \"Id of\n /// the variant itself\" from enum variants.\n /// Id of the whole struct lives in `Item`.\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum VariantData {\n     /// Struct variant.\n     ///\n@@ -2038,7 +2053,7 @@ impl VariantData {\n /// An item\n ///\n /// The name might be a dummy name in case of anonymous items\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct Item {\n     pub ident: Ident,\n     pub attrs: Vec<Attribute>,\n@@ -2061,7 +2076,7 @@ pub struct Item {\n ///\n /// All the information between the visibility & the name of the function is\n /// included in this struct (e.g. `async unsafe fn` or `const extern \"C\" fn`)\n-#[derive(Clone, Copy, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, Copy, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct FnHeader {\n     pub unsafety: Unsafety,\n     pub asyncness: IsAsync,\n@@ -2080,7 +2095,7 @@ impl Default for FnHeader {\n     }\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum ItemKind {\n     /// An `extern crate` item, with optional *original* crate name if the crate was renamed.\n     ///\n@@ -2179,7 +2194,7 @@ impl ItemKind {\n     }\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct ForeignItem {\n     pub ident: Ident,\n     pub attrs: Vec<Attribute>,\n@@ -2190,7 +2205,7 @@ pub struct ForeignItem {\n }\n \n /// An item within an `extern` block\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum ForeignItemKind {\n     /// A foreign function\n     Fn(P<FnDecl>, Generics),"}, {"sha": "38ddb501085a87da9bf6ac22f6f2f70f08cae36d", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4d1a30c92b50c5965ed26449758fca81bee15747/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d1a30c92b50c5965ed26449758fca81bee15747/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=4d1a30c92b50c5965ed26449758fca81bee15747", "patch": "@@ -725,7 +725,7 @@ pub trait Resolver {\n     fn check_unused_macros(&self);\n }\n \n-#[derive(Copy, Clone, Debug, PartialEq)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n pub enum Determinacy {\n     Determined,\n     Undetermined,"}, {"sha": "2f6bf5b821a8b6eaea9d91ff2457649d60370d95", "filename": "src/libsyntax/ext/tt/quoted.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4d1a30c92b50c5965ed26449758fca81bee15747/src%2Flibsyntax%2Fext%2Ftt%2Fquoted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d1a30c92b50c5965ed26449758fca81bee15747/src%2Flibsyntax%2Fext%2Ftt%2Fquoted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fquoted.rs?ref=4d1a30c92b50c5965ed26449758fca81bee15747", "patch": "@@ -22,7 +22,7 @@ use rustc_data_structures::sync::Lrc;\n \n /// Contains the sub-token-trees of a \"delimited\" token tree, such as the contents of `(`. Note\n /// that the delimiter itself might be `NoDelim`.\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct Delimited {\n     pub delim: token::DelimToken,\n     pub tts: Vec<TokenTree>,\n@@ -60,7 +60,7 @@ impl Delimited {\n     }\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct SequenceRepetition {\n     /// The sequence of token trees\n     pub tts: Vec<TokenTree>,\n@@ -74,7 +74,7 @@ pub struct SequenceRepetition {\n \n /// A Kleene-style [repetition operator](http://en.wikipedia.org/wiki/Kleene_star)\n /// for token sequences.\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n+#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n pub enum KleeneOp {\n     /// Kleene star (`*`) for zero or more repetitions\n     ZeroOrMore,\n@@ -85,7 +85,7 @@ pub enum KleeneOp {\n \n /// Similar to `tokenstream::TokenTree`, except that `$i`, `$i:ident`, and `$(...)`\n /// are \"first-class\" token trees. Useful for parsing macros.\n-#[derive(Debug, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash)]\n+#[derive(Debug, Clone, PartialEq, RustcEncodable, RustcDecodable, Hash)]\n pub enum TokenTree {\n     Token(Span, token::Token),\n     Delimited(Span, Lrc<Delimited>),"}, {"sha": "f033c5006c53af251fb1d514db0d9550e8eca91d", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4d1a30c92b50c5965ed26449758fca81bee15747/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d1a30c92b50c5965ed26449758fca81bee15747/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=4d1a30c92b50c5965ed26449758fca81bee15747", "patch": "@@ -632,7 +632,7 @@ declare_features! (\n // move that documentation into the relevant place in the other docs, and\n // remove the chapter on the flag.\n \n-#[derive(PartialEq, Copy, Clone, Debug)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n pub enum AttributeType {\n     /// Normal, builtin attribute that is consumed\n     /// by the compiler before the unused_attribute check\n@@ -665,7 +665,7 @@ impl AttributeGate {\n     }\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+#[derive(Copy, Clone, Debug)]\n pub enum Stability {\n     Unstable,\n     // Argument is tracking issue link.\n@@ -1113,7 +1113,7 @@ const GATED_CFGS: &[(&str, &str, fn(&Features) -> bool)] = &[\n     (\"target_has_atomic\", \"cfg_target_has_atomic\", cfg_fn!(cfg_target_has_atomic)),\n ];\n \n-#[derive(Debug, Eq, PartialEq)]\n+#[derive(Debug)]\n pub struct GatedCfg {\n     span: Span,\n     index: usize,\n@@ -1272,7 +1272,7 @@ pub enum GateIssue {\n     Library(Option<u32>)\n }\n \n-#[derive(Debug, Copy, Clone, PartialEq, Eq)]\n+#[derive(Debug, Copy, Clone, PartialEq)]\n pub enum GateStrength {\n     /// A hard error. (Most feature gates should use this.)\n     Hard,\n@@ -1704,7 +1704,9 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n \n     fn visit_fn_ret_ty(&mut self, ret_ty: &'a ast::FunctionRetTy) {\n         if let ast::FunctionRetTy::Ty(ref output_ty) = *ret_ty {\n-            if output_ty.node != ast::TyKind::Never {\n+            if let ast::TyKind::Never = output_ty.node {\n+                // Do nothing\n+            } else {\n                 self.visit_ty(output_ty)\n             }\n         }\n@@ -2046,7 +2048,7 @@ pub fn check_crate(krate: &ast::Crate,\n     visit::walk_crate(visitor, krate);\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, Hash)]\n+#[derive(Clone, Copy, Hash)]\n pub enum UnstableFeatures {\n     /// Hard errors for unstable features are active, as on\n     /// beta/stable channels."}, {"sha": "4d59f64bb6b57d3572ff704a196383fecb757508", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4d1a30c92b50c5965ed26449758fca81bee15747/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d1a30c92b50c5965ed26449758fca81bee15747/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=4d1a30c92b50c5965ed26449758fca81bee15747", "patch": "@@ -16,7 +16,7 @@ use parse::token::{self, Nonterminal};\n use parse::parser::{Parser, TokenType, PathStyle};\n use tokenstream::TokenStream;\n \n-#[derive(PartialEq, Eq, Debug)]\n+#[derive(Debug)]\n enum InnerAttributeParsePolicy<'a> {\n     Permitted,\n     NotPermitted { reason: &'a str },\n@@ -94,7 +94,7 @@ impl<'a> Parser<'a> {\n                 let lo = self.span;\n                 self.bump();\n \n-                if inner_parse_policy == InnerAttributeParsePolicy::Permitted {\n+                if let InnerAttributeParsePolicy::Permitted = inner_parse_policy {\n                     self.expected_tokens.push(TokenType::Token(token::Not));\n                 }\n                 let style = if self.token == token::Not {"}, {"sha": "92fcf8650423303b80dd2ee3fd5085c06fcc7f2b", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4d1a30c92b50c5965ed26449758fca81bee15747/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d1a30c92b50c5965ed26449758fca81bee15747/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=4d1a30c92b50c5965ed26449758fca81bee15747", "patch": "@@ -26,7 +26,7 @@ pub mod comments;\n mod tokentrees;\n mod unicode_chars;\n \n-#[derive(Clone, PartialEq, Eq, Debug)]\n+#[derive(Clone, Debug)]\n pub struct TokenAndSpan {\n     pub tok: token::Token,\n     pub sp: Span,"}, {"sha": "8bd4a7d71d714fcbf2b0413d2cc7bacaf2a128d0", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4d1a30c92b50c5965ed26449758fca81bee15747/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d1a30c92b50c5965ed26449758fca81bee15747/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=4d1a30c92b50c5965ed26449758fca81bee15747", "patch": "@@ -95,13 +95,13 @@ pub enum PathStyle {\n     Mod,\n }\n \n-#[derive(Clone, Copy, Debug, PartialEq)]\n+#[derive(Clone, Copy, PartialEq, Debug)]\n enum SemiColonMode {\n     Break,\n     Ignore,\n }\n \n-#[derive(Clone, Copy, Debug, PartialEq)]\n+#[derive(Clone, Copy, PartialEq, Debug)]\n enum BlockMode {\n     Break,\n     Ignore,\n@@ -376,7 +376,7 @@ impl TokenCursor {\n     }\n }\n \n-#[derive(PartialEq, Eq, Clone)]\n+#[derive(Clone, PartialEq)]\n crate enum TokenType {\n     Token(token::Token),\n     Keyword(keywords::Keyword),\n@@ -522,7 +522,7 @@ fn dummy_arg(span: Span) -> Arg {\n     Arg { ty: P(ty), pat: pat, id: ast::DUMMY_NODE_ID }\n }\n \n-#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+#[derive(Copy, Clone, Debug)]\n enum TokenExpectType {\n     Expect,\n     NoExpect,\n@@ -6999,7 +6999,7 @@ impl<'a> Parser<'a> {\n \n         // Verify whether we have encountered a struct or method definition where the user forgot to\n         // add the `struct` or `fn` keyword after writing `pub`: `pub S {}`\n-        if visibility.node == VisibilityKind::Public &&\n+        if visibility.node.is_public() &&\n             self.check_ident() &&\n             self.look_ahead(1, |t| *t != token::Not)\n         {"}, {"sha": "8e9c192c7373bc689c40a146d43a681dfc781395", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4d1a30c92b50c5965ed26449758fca81bee15747/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d1a30c92b50c5965ed26449758fca81bee15747/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=4d1a30c92b50c5965ed26449758fca81bee15747", "patch": "@@ -30,7 +30,7 @@ use std::{cmp, fmt};\n use std::mem;\n use rustc_data_structures::sync::{Lrc, Lock};\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Hash, Debug, Copy)]\n+#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n pub enum BinOpToken {\n     Plus,\n     Minus,\n@@ -45,7 +45,7 @@ pub enum BinOpToken {\n }\n \n /// A delimiter token\n-#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Hash, Debug, Copy)]\n+#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n pub enum DelimToken {\n     /// A round parenthesis: `(` or `)`\n     Paren,\n@@ -67,7 +67,7 @@ impl DelimToken {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Hash, Debug, Copy)]\n+#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n pub enum Lit {\n     Byte(ast::Name),\n     Char(ast::Name),\n@@ -139,7 +139,7 @@ fn ident_can_begin_type(ident: ast::Ident, is_raw: bool) -> bool {\n     ].contains(&ident.name)\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Hash, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Hash, Debug)]\n pub enum Token {\n     /* Expression-operator symbols. */\n     Eq,\n@@ -638,7 +638,7 @@ impl Token {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Eq, Hash)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash)]\n /// For interpolation during macro expansion.\n pub enum Nonterminal {\n     NtItem(P<ast::Item>),"}, {"sha": "b0a9003a45620dabe5416105ba0f8ccfde63bf0a", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4d1a30c92b50c5965ed26449758fca81bee15747/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d1a30c92b50c5965ed26449758fca81bee15747/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=4d1a30c92b50c5965ed26449758fca81bee15747", "patch": "@@ -2641,7 +2641,9 @@ impl<'a> State<'a> {\n                                    |s, p| s.print_pat(p))?;\n                 if let Some(ref p) = *slice {\n                     if !before.is_empty() { self.word_space(\",\")?; }\n-                    if p.node != PatKind::Wild {\n+                    if let PatKind::Wild = p.node {\n+                        // Print nothing\n+                    } else {\n                         self.print_pat(p)?;\n                     }\n                     self.s.word(\"..\")?;"}, {"sha": "b86d19ba3ce00a63eeea7a56fbdcede145b38dda", "filename": "src/libsyntax/ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4d1a30c92b50c5965ed26449758fca81bee15747/src%2Flibsyntax%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d1a30c92b50c5965ed26449758fca81bee15747/src%2Flibsyntax%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fptr.rs?ref=4d1a30c92b50c5965ed26449758fca81bee15747", "patch": "@@ -46,7 +46,7 @@ use serialize::{Encodable, Decodable, Encoder, Decoder};\n use rustc_data_structures::stable_hasher::{StableHasher, StableHasherResult,\n                                            HashStable};\n /// An owned smart pointer.\n-#[derive(Hash, PartialEq, Eq, PartialOrd, Ord)]\n+#[derive(Hash, PartialEq, Eq)]\n pub struct P<T: ?Sized> {\n     ptr: Box<T>\n }"}, {"sha": "b4e1dd75b3b717b6d9bd7a0acec960e2f905f05b", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4d1a30c92b50c5965ed26449758fca81bee15747/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d1a30c92b50c5965ed26449758fca81bee15747/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=4d1a30c92b50c5965ed26449758fca81bee15747", "patch": "@@ -329,7 +329,6 @@ fn ignored_span(cx: &TestCtxt, sp: Span) -> Span {\n     sp.with_ctxt(cx.ctxt)\n }\n \n-#[derive(PartialEq)]\n enum HasTestSignature {\n     Yes,\n     No(BadTestSignature),\n@@ -354,7 +353,7 @@ fn is_test_fn(cx: &TestCtxt, i: &ast::Item) -> bool {\n                 // type implements the `Termination` trait as `libtest` enforces that.\n                 let has_output = match decl.output {\n                     ast::FunctionRetTy::Default(..) => false,\n-                    ast::FunctionRetTy::Ty(ref t) if t.node == ast::TyKind::Tup(vec![]) => false,\n+                    ast::FunctionRetTy::Ty(ref t) if t.node.is_empty_tuple() => false,\n                     _ => true\n                 };\n "}, {"sha": "650d6333b55b5bf8755c895b3a4e120383ad7fac", "filename": "src/libsyntax/tokenstream.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4d1a30c92b50c5965ed26449758fca81bee15747/src%2Flibsyntax%2Ftokenstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d1a30c92b50c5965ed26449758fca81bee15747/src%2Flibsyntax%2Ftokenstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftokenstream.rs?ref=4d1a30c92b50c5965ed26449758fca81bee15747", "patch": "@@ -36,7 +36,7 @@ use std::{fmt, iter, mem};\n use std::hash::{self, Hash};\n \n /// A delimited sequence of token trees\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct Delimited {\n     /// The type of delimiter\n     pub delim: token::DelimToken,\n@@ -93,7 +93,7 @@ impl Delimited {\n ///\n /// The RHS of an MBE macro is the only place `SubstNt`s are substituted.\n /// Nothing special happens to misnamed or misplaced `SubstNt`s.\n-#[derive(Debug, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash)]\n+#[derive(Debug, Clone, PartialEq, RustcEncodable, RustcDecodable, Hash)]\n pub enum TokenTree {\n     /// A single token\n     Token(Span, token::Token),"}, {"sha": "67bc6f947b59a52c0132efe402ec302eaed3513c", "filename": "src/libsyntax/util/parser.rs", "status": "modified", "additions": 3, "deletions": 17, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4d1a30c92b50c5965ed26449758fca81bee15747/src%2Flibsyntax%2Futil%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d1a30c92b50c5965ed26449758fca81bee15747/src%2Flibsyntax%2Futil%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fparser.rs?ref=4d1a30c92b50c5965ed26449758fca81bee15747", "patch": "@@ -11,12 +11,10 @@ use parse::token::{Token, BinOpToken};\n use symbol::keywords;\n use ast::{self, BinOpKind};\n \n-use std::cmp::Ordering;\n-\n /// Associative operator with precedence.\n ///\n /// This is the enum which specifies operator precedence and fixity to the parser.\n-#[derive(Debug, PartialEq, Eq)]\n+#[derive(PartialEq, Debug)]\n pub enum AssocOp {\n     /// `+`\n     Add,\n@@ -70,7 +68,7 @@ pub enum AssocOp {\n     Colon,\n }\n \n-#[derive(Debug, PartialEq, Eq)]\n+#[derive(PartialEq, Debug)]\n pub enum Fixity {\n     /// The operator is left-associative\n     Left,\n@@ -230,7 +228,7 @@ pub const PREC_POSTFIX: i8 = 60;\n pub const PREC_PAREN: i8 = 99;\n pub const PREC_FORCE_PAREN: i8 = 100;\n \n-#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n+#[derive(Debug, Clone, Copy)]\n pub enum ExprPrecedence {\n     Closure,\n     Break,\n@@ -280,18 +278,6 @@ pub enum ExprPrecedence {\n     Async,\n }\n \n-impl PartialOrd for ExprPrecedence {\n-    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n-        Some(self.order().cmp(&other.order()))\n-    }\n-}\n-\n-impl Ord for ExprPrecedence {\n-    fn cmp(&self, other: &Self) -> Ordering {\n-        self.order().cmp(&other.order())\n-    }\n-}\n-\n impl ExprPrecedence {\n     pub fn order(self) -> i8 {\n         match self {"}, {"sha": "9211a2383b6961b133037d05944c00f775690658", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4d1a30c92b50c5965ed26449758fca81bee15747/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d1a30c92b50c5965ed26449758fca81bee15747/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=4d1a30c92b50c5965ed26449758fca81bee15747", "patch": "@@ -28,7 +28,7 @@ use syntax_pos::Span;\n use parse::token::Token;\n use tokenstream::{TokenTree, TokenStream};\n \n-#[derive(Copy, Clone, PartialEq, Eq)]\n+#[derive(Copy, Clone)]\n pub enum FnKind<'a> {\n     /// fn foo() or extern \"Abi\" fn foo()\n     ItemFn(Ident, FnHeader, &'a Visibility, &'a Block),"}, {"sha": "a9f60fd053c07a69dc91784f75cb550111387036", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4d1a30c92b50c5965ed26449758fca81bee15747/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d1a30c92b50c5965ed26449758fca81bee15747/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=4d1a30c92b50c5965ed26449758fca81bee15747", "patch": "@@ -188,7 +188,6 @@ pub use self::StaticFields::*;\n pub use self::SubstructureFields::*;\n \n use std::cell::RefCell;\n-use std::collections::HashSet;\n use std::vec;\n \n use rustc_target::spec::abi::Abi;\n@@ -617,19 +616,16 @@ impl<'a> TraitDef<'a> {\n                     .map(|ty_param| ty_param.ident.name)\n                     .collect();\n \n-                let mut processed_field_types = HashSet::new();\n                 for field_ty in field_tys {\n                     let tys = find_type_parameters(&field_ty, &ty_param_names, self.span, cx);\n \n                     for ty in tys {\n                         // if we have already handled this type, skip it\n                         if let ast::TyKind::Path(_, ref p) = ty.node {\n                             if p.segments.len() == 1 &&\n-                            ty_param_names.contains(&p.segments[0].ident.name) ||\n-                            processed_field_types.contains(&p.segments) {\n+                               ty_param_names.contains(&p.segments[0].ident.name) {\n                                 continue;\n                             };\n-                            processed_field_types.insert(p.segments.clone());\n                         }\n                         let mut bounds: Vec<_> = self.additional_bounds\n                             .iter()\n@@ -913,7 +909,7 @@ impl<'a> MethodDef<'a> {\n                 Self_ if nonstatic => {\n                     self_args.push(arg_expr);\n                 }\n-                Ptr(ref ty, _) if **ty == Self_ && nonstatic => {\n+                Ptr(ref ty, _) if (if let Self_ = **ty { true } else { false }) && nonstatic => {\n                     self_args.push(cx.expr_deref(trait_.span, arg_expr))\n                 }\n                 _ => {"}, {"sha": "dcccb187bef4b0415b04507aceb6b93cb1915a20", "filename": "src/libsyntax_ext/deriving/generic/ty.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4d1a30c92b50c5965ed26449758fca81bee15747/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d1a30c92b50c5965ed26449758fca81bee15747/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs?ref=4d1a30c92b50c5965ed26449758fca81bee15747", "patch": "@@ -24,8 +24,7 @@ use syntax_pos::Span;\n use syntax_pos::symbol::keywords;\n \n /// The types of pointers\n-#[derive(Clone, Eq, PartialEq)]\n-#[allow(dead_code)]\n+#[derive(Clone)]\n pub enum PtrTy<'a> {\n     /// &'lifetime mut\n     Borrowed(Option<&'a str>, ast::Mutability),\n@@ -35,15 +34,15 @@ pub enum PtrTy<'a> {\n \n /// A path, e.g. `::std::option::Option::<i32>` (global). Has support\n /// for type parameters and a lifetime.\n-#[derive(Clone, Eq, PartialEq)]\n+#[derive(Clone)]\n pub struct Path<'a> {\n     path: Vec<&'a str>,\n     lifetime: Option<&'a str>,\n     params: Vec<Box<Ty<'a>>>,\n     kind: PathKind,\n }\n \n-#[derive(Clone, Eq, PartialEq)]\n+#[derive(Clone)]\n pub enum PathKind {\n     Local,\n     Global,\n@@ -107,7 +106,7 @@ impl<'a> Path<'a> {\n }\n \n /// A type. Supports pointers, Self, and literals\n-#[derive(Clone, Eq, PartialEq)]\n+#[derive(Clone)]\n pub enum Ty<'a> {\n     Self_,\n     /// &/Box/ Ty"}, {"sha": "1cf21b5c3ae3a854f601b751fc6affc4c34b8e86", "filename": "src/libsyntax_ext/format_foreign.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4d1a30c92b50c5965ed26449758fca81bee15747/src%2Flibsyntax_ext%2Fformat_foreign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d1a30c92b50c5965ed26449758fca81bee15747/src%2Flibsyntax_ext%2Fformat_foreign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fformat_foreign.rs?ref=4d1a30c92b50c5965ed26449758fca81bee15747", "patch": "@@ -12,7 +12,7 @@ pub mod printf {\n     use super::strcursor::StrCursor as Cur;\n \n     /// Represents a single `printf`-style substitution.\n-    #[derive(Clone, Eq, PartialEq, Debug)]\n+    #[derive(Clone, Debug)]\n     pub enum Substitution<'a> {\n         /// A formatted output substitution.\n         Format(Format<'a>),\n@@ -40,7 +40,7 @@ pub mod printf {\n         }\n     }\n \n-    #[derive(Clone, Eq, PartialEq, Debug)]\n+    #[derive(Clone, Debug)]\n     /// A single `printf`-style formatting directive.\n     pub struct Format<'a> {\n         /// The entire original formatting directive.\n@@ -213,7 +213,7 @@ pub mod printf {\n     }\n \n     /// A general number used in a `printf` formatting directive.\n-    #[derive(Copy, Clone, Eq, PartialEq, Debug)]\n+    #[derive(Copy, Clone, Debug)]\n     pub enum Num {\n         // The range of these values is technically bounded by `NL_ARGMAX`... but, at least for GNU\n         // libc, it apparently has no real fixed limit.  A `u16` is used here on the basis that it\n@@ -739,7 +739,7 @@ pub mod printf {\n pub mod shell {\n     use super::strcursor::StrCursor as Cur;\n \n-    #[derive(Clone, Eq, PartialEq, Debug)]\n+    #[derive(Clone, Debug)]\n     pub enum Substitution<'a> {\n         Ordinal(u8),\n         Name(&'a str),"}, {"sha": "5cbd978257532142708bc7a96be116195ee3a2b9", "filename": "src/libsyntax_ext/proc_macro_registrar.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4d1a30c92b50c5965ed26449758fca81bee15747/src%2Flibsyntax_ext%2Fproc_macro_registrar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d1a30c92b50c5965ed26449758fca81bee15747/src%2Flibsyntax_ext%2Fproc_macro_registrar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fproc_macro_registrar.rs?ref=4d1a30c92b50c5965ed26449758fca81bee15747", "patch": "@@ -103,7 +103,7 @@ impl<'a> CollectProcMacros<'a> {\n     fn check_not_pub_in_root(&self, vis: &ast::Visibility, sp: Span) {\n         if self.is_proc_macro_crate &&\n            self.in_root &&\n-           vis.node == ast::VisibilityKind::Public {\n+           vis.node.is_public() {\n             self.handler.span_err(sp,\n                                   \"`proc-macro` crate types cannot \\\n                                    export any items other than functions \\\n@@ -181,7 +181,7 @@ impl<'a> CollectProcMacros<'a> {\n             Vec::new()\n         };\n \n-        if self.in_root && item.vis.node == ast::VisibilityKind::Public {\n+        if self.in_root && item.vis.node.is_public() {\n             self.derives.push(ProcMacroDerive {\n                 span: item.span,\n                 trait_name,\n@@ -206,7 +206,7 @@ impl<'a> CollectProcMacros<'a> {\n             return;\n         }\n \n-        if self.in_root && item.vis.node == ast::VisibilityKind::Public {\n+        if self.in_root && item.vis.node.is_public() {\n             self.attr_macros.push(ProcMacroDef {\n                 span: item.span,\n                 function_name: item.ident,\n@@ -229,7 +229,7 @@ impl<'a> CollectProcMacros<'a> {\n             return;\n         }\n \n-        if self.in_root && item.vis.node == ast::VisibilityKind::Public {\n+        if self.in_root && item.vis.node.is_public() {\n             self.bang_macros.push(ProcMacroDef {\n                 span: item.span,\n                 function_name: item.ident,\n@@ -271,7 +271,8 @@ impl<'a> Visitor<'a> for CollectProcMacros<'a> {\n         for attr in &item.attrs {\n             if is_proc_macro_attr(&attr) {\n                 if let Some(prev_attr) = found_attr {\n-                    let msg = if attr.path == prev_attr.path {\n+                    let msg = if attr.path.segments[0].ident.name ==\n+                                 prev_attr.path.segments[0].ident.name {\n                         format!(\"Only one `#[{}]` attribute is allowed on any given function\",\n                                 attr.path)\n                     } else {"}, {"sha": "fce8fc3db4e4ed0f55f8ed867f8b6c4f4f541a18", "filename": "src/libsyntax_pos/edition.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4d1a30c92b50c5965ed26449758fca81bee15747/src%2Flibsyntax_pos%2Fedition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d1a30c92b50c5965ed26449758fca81bee15747/src%2Flibsyntax_pos%2Fedition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fedition.rs?ref=4d1a30c92b50c5965ed26449758fca81bee15747", "patch": "@@ -12,7 +12,7 @@ use std::fmt;\n use std::str::FromStr;\n \n /// The edition of the compiler (RFC 2052)\n-#[derive(Clone, Copy, Hash, PartialOrd, Ord, Eq, PartialEq, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Copy, Hash, PartialEq, PartialOrd, Debug, RustcEncodable, RustcDecodable)]\n #[non_exhaustive]\n pub enum Edition {\n     // editions must be kept in order, oldest to newest"}]}