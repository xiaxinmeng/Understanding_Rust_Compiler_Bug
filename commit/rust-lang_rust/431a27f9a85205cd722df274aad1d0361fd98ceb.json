{"sha": "431a27f9a85205cd722df274aad1d0361fd98ceb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQzMWEyN2Y5YTg1MjA1Y2Q3MjJkZjI3NGFhZDFkMDM2MWZkOThjZWI=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-09-14T19:35:01Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-09-14T19:35:26Z"}, "message": "Remove description of nonexistent stuff (reflection, meta directives); add description of attributes and tidy up description of syntax extensions.", "tree": {"sha": "55518b4fe5d5e030b6d8a900e56c364a42176b22", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/55518b4fe5d5e030b6d8a900e56c364a42176b22"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/431a27f9a85205cd722df274aad1d0361fd98ceb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/431a27f9a85205cd722df274aad1d0361fd98ceb", "html_url": "https://github.com/rust-lang/rust/commit/431a27f9a85205cd722df274aad1d0361fd98ceb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/431a27f9a85205cd722df274aad1d0361fd98ceb/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ffeb1752399e70bfc19e59e236abd9f881de4710", "url": "https://api.github.com/repos/rust-lang/rust/commits/ffeb1752399e70bfc19e59e236abd9f881de4710", "html_url": "https://github.com/rust-lang/rust/commit/ffeb1752399e70bfc19e59e236abd9f881de4710"}], "stats": {"total": 116, "additions": 76, "deletions": 40}, "files": [{"sha": "1185ab4f320c679dd803151a82f87659cc3efed7", "filename": "doc/rust.texi", "status": "modified", "additions": 76, "deletions": 40, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/431a27f9a85205cd722df274aad1d0361fd98ceb/doc%2Frust.texi", "raw_url": "https://github.com/rust-lang/rust/raw/431a27f9a85205cd722df274aad1d0361fd98ceb/doc%2Frust.texi", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.texi?ref=431a27f9a85205cd722df274aad1d0361fd98ceb", "patch": "@@ -205,7 +205,6 @@ messages over channels to ports.\n \n @sp 1\n @item Predictable native code, simple runtime\n-@cindex DWARF\n \n The meaning and cost of every operation within a Rust program is intended to\n be easy to model for the reader. The code should not ``surprise'' the\n@@ -978,7 +977,7 @@ m::map<int,str>;\n @section Ref.Gram\n @c * Ref.Gram::                    Grammar.\n \n-@emph{TODO: mostly LL(1), it reads like C, Alef and bits of Napier;\n+@emph{TODO: mostly LL(1), it reads like C++, Alef and bits of Napier;\n formalize here}.\n \n @page\n@@ -1000,7 +999,7 @@ successful produces a single crate in executable form.\n \n @menu\n * Ref.Comp.Crate::              Units of compilation and linking.\n-* Ref.Comp.Meta::               Metadata about a crate.\n+* Ref.Comp.Attr::               Attributes of crates, modules and items.\n * Ref.Comp.Syntax::             Syntax extensions.\n @end menu\n \n@@ -1053,15 +1052,15 @@ symbolic name and leave the task of locating and binding an appropriate crate\n to a compile-time heuristic. In a more controlled case, a @code{use} directive\n may specify any metadata as matching criteria, such as a URI, an author name\n or version number, a checksum or even a cryptographic signature, in order to\n-select an an appropriate imported crate. @xref{Ref.Comp.Meta}.\n+select an an appropriate imported crate. @xref{Ref.Comp.Attr}.\n \n The compiled form of a crate is a loadable and executable object file full of\n machine code, in a standard loadable operating-system format such as ELF, PE\n-or Mach-O. The loadable object contains extensive DWARF metadata, describing:\n+or Mach-O. The loadable object contains metadata, describing:\n @itemize\n @item Metadata required for type reflection.\n @item The publicly exported module structure of the crate.\n-@item Any metadata about the crate, defined by @code{meta} directives.\n+@item Any metadata about the crate, defined by attributes.\n @item The crates to dynamically link with at run-time, with matching criteria\n derived from the same @code{use} directives that guided compile-time imports.\n @end itemize\n@@ -1077,11 +1076,15 @@ derived from the same @code{use} directives that guided compile-time imports.\n An example of a crate:\n \n @example\n-// Metadata about this crate\n-meta (author = \"Jane Doe\",\n-      name = \"projx\"\n-      desc = \"Project X\",\n-      ver = \"2.5\");\n+// Linkage attributes\n+#[ link(name = \"projx\"\n+        vers = \"2.5\",\n+        uuid = \"9cccc5d5-aceb-4af5-8285-811211826b82\") ];\n+\n+// Additional metadata attributes\n+#[ desc = \"Project X\",\n+   license = \"BSD\" ];\n+   author = \"Jane Doe\" ];\n \n // Import a module.\n use std (ver = \"1.0\");\n@@ -1093,34 +1096,77 @@ mod bar @{\n @}\n @end example\n \n-@node       Ref.Comp.Meta\n-@subsection Ref.Comp.Meta\n-@cindex Metadata, in crates\n+@node       Ref.Comp.Attr\n+@subsection Ref.Comp.Attr\n+@cindex Attributes\n+\n+Static entities in Rust -- crates, modules and items -- may have attributes\n+applied to them.@footnote{Attributes in Rust are modeled on Attributes in\n+ECMA-335, C#} An attribute is a general, free-form piece of metadata that is\n+interpreted according to name, convention, and language and compiler version.\n+Attributes may appear as any of:\n+@itemize\n+@item A single identifier, the attribute name\n+@item An identifier followed by the equals sign '=' and a literal, providing a key/value pair\n+@item An identifier followed by a parenthesized list of sub-attribute arguments\n+@end itemize\n+\n+Attributes are applied to an entity by placing them within a hash-list\n+(@code{#[...]}) as either a prefix to the entity or as a semicolon-delimited\n+declaration within the entity body.\n+\n+An example of attributes:\n+\n+@example\n+// A function marked as a unit test\n+#[test]\n+fn test_foo() @{\n+  ...\n+@}\n+\n+// General metadata applied to the enclosing module or crate.\n+#[license = \"BSD\"];\n+\n+// A conditionally-compiled module\n+#[cfg(target_os=\"linux\")]\n+module bar @{\n+  ...\n+@}\n+\n+@end example\n+\n+In future versions of Rust, user-provided extensions to the compiler will be able\n+to use interpret attributes. When this facility is provided, a distinction will be\n+made between language-reserved and user-available attributes.\n \n-@c FIXME: This section is out of date. The @code{meta} keyword has been replaced\n-@c by general crate/item attributes.\n+At present, only the Rust compiler interprets attributes, so all attribute\n+names are effectively reserved. Some significant attributes include:\n \n-In a crate, a @code{meta} directive associates free form key-value metadata\n-with the crate. This metadata can, in turn, be used in providing partial\n-matching parameters to crate importing directives, denoted by the @code{use}\n-keyword.\n+@itemize\n+@item The @code{cfg} attribute, for conditional-compilation by build-configuration\n+@item The @code{link} attribute, describing linkage metadata for a crate\n+@item The @code{test} attribute, for marking functions as unit tests.\n+@end itemize\n \n-Alternatively, metadata can serve as a simple form of documentation.\n+Other attributes may be added or removed during development of the language.\n \n @node          Ref.Comp.Syntax\n @subsection    Ref.Comp.Syntax\n @c * Ref.Comp.Syntax::        Syntax extension.\n @cindex Syntax extension\n \n-@c , statement or item\n-Rust provides a notation for @dfn{syntax extension}. The notation is a marked\n-syntactic form that can appear as an expression in the body of a Rust\n-program. Syntax extensions make use of bracketed lists, which are\n-syntactically vector literals, but which have no run-time semantics. After\n-parsing, the notation is translated into Rust expressions. The name of the\n-extension determines the translation performed. The name may be one of the\n-built-in extensions listed below, or a user-defined extension, defined using\n-@code{macro}.\n+Rust provides a notation for @dfn{syntax extension}. The notation for invoking\n+a syntax extension is a marked syntactic form that can appear as an expression\n+in the body of a Rust program. @xref{Ref.Lex.Syntax}.\n+\n+After parsing, a syntax-extension incovation is expanded into a Rust\n+expression. The name of the extension determines the translation performed. In\n+future versions of Rust, user-provided syntax extensions aside from macros\n+will be provided via external crates.\n+\n+At present, only a set of built-in syntax extensions, as well as macros\n+introduced inline in source code using the @code{macro} extension, may be\n+used. The current built-in syntax extensions are:\n \n @itemize\n @item @code{fmt} expands into code to produce a formatted string, similar to \n@@ -3661,16 +3707,6 @@ queues, as well as code to copy values between queues and their recipients and\n to serialize values for transmission over operating-system inter-process\n communication facilities.\n \n-@node       Ref.Run.Refl\n-@subsection Ref.Run.Refl\n-@c * Ref.Run.Refl::                Runtime reflection system.\n-@cindex Reflection\n-@cindex DWARF\n-\n-The runtime reflection system is driven by the DWARF tables emitted into a\n-crate at compile-time. Reflecting on a slot or item allocates a Rust data\n-structure corresponding to the DWARF DIE for that slot or item.\n-\n @node       Ref.Run.Log\n @subsection Ref.Run.Log\n @c * Ref.Run.Log::                 Runtime logging system."}]}