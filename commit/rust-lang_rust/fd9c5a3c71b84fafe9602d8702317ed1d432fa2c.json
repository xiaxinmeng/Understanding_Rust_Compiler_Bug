{"sha": "fd9c5a3c71b84fafe9602d8702317ed1d432fa2c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZkOWM1YTNjNzFiODRmYWZlOTYwMmQ4NzAyMzE3ZWQxZDQzMmZhMmM=", "commit": {"author": {"name": "Michael Wright", "email": "mikerite@lavabit.com", "date": "2019-08-01T05:02:48Z"}, "committer": {"name": "Michael Wright", "email": "mikerite@lavabit.com", "date": "2019-08-01T05:02:48Z"}, "message": "Merge branch 'master' into dev-fmt-20190728", "tree": {"sha": "0864416b6e949b7a64e960f02174a514a5ce98ab", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0864416b6e949b7a64e960f02174a514a5ce98ab"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fd9c5a3c71b84fafe9602d8702317ed1d432fa2c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fd9c5a3c71b84fafe9602d8702317ed1d432fa2c", "html_url": "https://github.com/rust-lang/rust/commit/fd9c5a3c71b84fafe9602d8702317ed1d432fa2c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fd9c5a3c71b84fafe9602d8702317ed1d432fa2c/comments", "author": null, "committer": null, "parents": [{"sha": "2682bd112e14716fe128879abefff667c8a68766", "url": "https://api.github.com/repos/rust-lang/rust/commits/2682bd112e14716fe128879abefff667c8a68766", "html_url": "https://github.com/rust-lang/rust/commit/2682bd112e14716fe128879abefff667c8a68766"}, {"sha": "d1b4fc9853d80b3953dd5f2bae9d5d70ef7665ab", "url": "https://api.github.com/repos/rust-lang/rust/commits/d1b4fc9853d80b3953dd5f2bae9d5d70ef7665ab", "html_url": "https://github.com/rust-lang/rust/commit/d1b4fc9853d80b3953dd5f2bae9d5d70ef7665ab"}], "stats": {"total": 562, "additions": 443, "deletions": 119}, "files": [{"sha": "089897811a595aa128d57a3947ee68a8e7cc04ea", "filename": "CHANGELOG.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fd9c5a3c71b84fafe9602d8702317ed1d432fa2c/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/fd9c5a3c71b84fafe9602d8702317ed1d432fa2c/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=fd9c5a3c71b84fafe9602d8702317ed1d432fa2c", "patch": "@@ -1138,6 +1138,7 @@ Released 2018-09-13\n [`trivially_copy_pass_by_ref`]: https://rust-lang.github.io/rust-clippy/master/index.html#trivially_copy_pass_by_ref\n [`try_err`]: https://rust-lang.github.io/rust-clippy/master/index.html#try_err\n [`type_complexity`]: https://rust-lang.github.io/rust-clippy/master/index.html#type_complexity\n+[`type_repetition_in_bounds`]: https://rust-lang.github.io/rust-clippy/master/index.html#type_repetition_in_bounds\n [`unicode_not_nfc`]: https://rust-lang.github.io/rust-clippy/master/index.html#unicode_not_nfc\n [`unimplemented`]: https://rust-lang.github.io/rust-clippy/master/index.html#unimplemented\n [`unit_arg`]: https://rust-lang.github.io/rust-clippy/master/index.html#unit_arg"}, {"sha": "38651f72eb3661b99527dd344ee674883e6d7024", "filename": "README.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd9c5a3c71b84fafe9602d8702317ed1d432fa2c/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/fd9c5a3c71b84fafe9602d8702317ed1d432fa2c/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=fd9c5a3c71b84fafe9602d8702317ed1d432fa2c", "patch": "@@ -6,7 +6,7 @@\n \n A collection of lints to catch common mistakes and improve your [Rust](https://github.com/rust-lang/rust) code.\n \n-[There are 308 lints included in this crate!](https://rust-lang.github.io/rust-clippy/master/index.html)\n+[There are 309 lints included in this crate!](https://rust-lang.github.io/rust-clippy/master/index.html)\n \n We have a bunch of lint categories to allow you to choose how much Clippy is supposed to ~~annoy~~ help you:\n "}, {"sha": "9f0b68baf9dbc1d9959f043fa92efa509aaa90f0", "filename": "clippy_dev/src/fmt.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fd9c5a3c71b84fafe9602d8702317ed1d432fa2c/clippy_dev%2Fsrc%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd9c5a3c71b84fafe9602d8702317ed1d432fa2c/clippy_dev%2Fsrc%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_dev%2Fsrc%2Ffmt.rs?ref=fd9c5a3c71b84fafe9602d8702317ed1d432fa2c", "patch": "@@ -16,13 +16,13 @@ pub enum CliError {\n \n impl From<io::Error> for CliError {\n     fn from(error: io::Error) -> Self {\n-        CliError::IoError(error)\n+        Self::IoError(error)\n     }\n }\n \n impl From<walkdir::Error> for CliError {\n     fn from(error: walkdir::Error) -> Self {\n-        CliError::WalkDirError(error)\n+        Self::WalkDirError(error)\n     }\n }\n "}, {"sha": "c23f2fbc01164a2938742681eafad6424747bfd1", "filename": "clippy_lints/src/checked_conversions.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fd9c5a3c71b84fafe9602d8702317ed1d432fa2c/clippy_lints%2Fsrc%2Fchecked_conversions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd9c5a3c71b84fafe9602d8702317ed1d432fa2c/clippy_lints%2Fsrc%2Fchecked_conversions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fchecked_conversions.rs?ref=fd9c5a3c71b84fafe9602d8702317ed1d432fa2c", "patch": "@@ -160,12 +160,12 @@ impl ConversionType {\n     /// Creates a conversion type if the type is allowed & conversion is valid\n     fn try_new(from: &str, to: &str) -> Option<Self> {\n         if UINTS.contains(&from) {\n-            Some(ConversionType::FromUnsigned)\n+            Some(Self::FromUnsigned)\n         } else if SINTS.contains(&from) {\n             if UINTS.contains(&to) {\n-                Some(ConversionType::SignedToUnsigned)\n+                Some(Self::SignedToUnsigned)\n             } else if SINTS.contains(&to) {\n-                Some(ConversionType::SignedToSigned)\n+                Some(Self::SignedToSigned)\n             } else {\n                 None\n             }"}, {"sha": "d18474abdcd4834de7a357da9199f1061dc4d379", "filename": "clippy_lints/src/consts.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/fd9c5a3c71b84fafe9602d8702317ed1d432fa2c/clippy_lints%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd9c5a3c71b84fafe9602d8702317ed1d432fa2c/clippy_lints%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fconsts.rs?ref=fd9c5a3c71b84fafe9602d8702317ed1d432fa2c", "patch": "@@ -48,27 +48,27 @@ pub enum Constant {\n impl PartialEq for Constant {\n     fn eq(&self, other: &Self) -> bool {\n         match (self, other) {\n-            (&Constant::Str(ref ls), &Constant::Str(ref rs)) => ls == rs,\n-            (&Constant::Binary(ref l), &Constant::Binary(ref r)) => l == r,\n-            (&Constant::Char(l), &Constant::Char(r)) => l == r,\n-            (&Constant::Int(l), &Constant::Int(r)) => l == r,\n-            (&Constant::F64(l), &Constant::F64(r)) => {\n+            (&Self::Str(ref ls), &Self::Str(ref rs)) => ls == rs,\n+            (&Self::Binary(ref l), &Self::Binary(ref r)) => l == r,\n+            (&Self::Char(l), &Self::Char(r)) => l == r,\n+            (&Self::Int(l), &Self::Int(r)) => l == r,\n+            (&Self::F64(l), &Self::F64(r)) => {\n                 // We want `Fw32 == FwAny` and `FwAny == Fw64`, and by transitivity we must have\n                 // `Fw32 == Fw64`, so don\u2019t compare them.\n                 // `to_bits` is required to catch non-matching 0.0, -0.0, and NaNs.\n                 l.to_bits() == r.to_bits()\n             },\n-            (&Constant::F32(l), &Constant::F32(r)) => {\n+            (&Self::F32(l), &Self::F32(r)) => {\n                 // We want `Fw32 == FwAny` and `FwAny == Fw64`, and by transitivity we must have\n                 // `Fw32 == Fw64`, so don\u2019t compare them.\n                 // `to_bits` is required to catch non-matching 0.0, -0.0, and NaNs.\n                 f64::from(l).to_bits() == f64::from(r).to_bits()\n             },\n-            (&Constant::Bool(l), &Constant::Bool(r)) => l == r,\n-            (&Constant::Vec(ref l), &Constant::Vec(ref r)) | (&Constant::Tuple(ref l), &Constant::Tuple(ref r)) => {\n+            (&Self::Bool(l), &Self::Bool(r)) => l == r,\n+            (&Self::Vec(ref l), &Self::Vec(ref r)) | (&Self::Tuple(ref l), &Self::Tuple(ref r)) => {\n                 l == r\n             },\n-            (&Constant::Repeat(ref lv, ref ls), &Constant::Repeat(ref rv, ref rs)) => ls == rs && lv == rv,\n+            (&Self::Repeat(ref lv, ref ls), &Self::Repeat(ref rv, ref rs)) => ls == rs && lv == rv,\n             // TODO: are there inter-type equalities?\n             _ => false,\n         }\n@@ -82,38 +82,38 @@ impl Hash for Constant {\n     {\n         std::mem::discriminant(self).hash(state);\n         match *self {\n-            Constant::Str(ref s) => {\n+            Self::Str(ref s) => {\n                 s.hash(state);\n             },\n-            Constant::Binary(ref b) => {\n+            Self::Binary(ref b) => {\n                 b.hash(state);\n             },\n-            Constant::Char(c) => {\n+            Self::Char(c) => {\n                 c.hash(state);\n             },\n-            Constant::Int(i) => {\n+            Self::Int(i) => {\n                 i.hash(state);\n             },\n-            Constant::F32(f) => {\n+            Self::F32(f) => {\n                 f64::from(f).to_bits().hash(state);\n             },\n-            Constant::F64(f) => {\n+            Self::F64(f) => {\n                 f.to_bits().hash(state);\n             },\n-            Constant::Bool(b) => {\n+            Self::Bool(b) => {\n                 b.hash(state);\n             },\n-            Constant::Vec(ref v) | Constant::Tuple(ref v) => {\n+            Self::Vec(ref v) | Self::Tuple(ref v) => {\n                 v.hash(state);\n             },\n-            Constant::Repeat(ref c, l) => {\n+            Self::Repeat(ref c, l) => {\n                 c.hash(state);\n                 l.hash(state);\n             },\n-            Constant::RawPtr(u) => {\n+            Self::RawPtr(u) => {\n                 u.hash(state);\n             },\n-            Constant::Err(ref s) => {\n+            Self::Err(ref s) => {\n                 s.hash(state);\n             },\n         }\n@@ -123,25 +123,25 @@ impl Hash for Constant {\n impl Constant {\n     pub fn partial_cmp(tcx: TyCtxt<'_>, cmp_type: Ty<'_>, left: &Self, right: &Self) -> Option<Ordering> {\n         match (left, right) {\n-            (&Constant::Str(ref ls), &Constant::Str(ref rs)) => Some(ls.cmp(rs)),\n-            (&Constant::Char(ref l), &Constant::Char(ref r)) => Some(l.cmp(r)),\n-            (&Constant::Int(l), &Constant::Int(r)) => {\n+            (&Self::Str(ref ls), &Self::Str(ref rs)) => Some(ls.cmp(rs)),\n+            (&Self::Char(ref l), &Self::Char(ref r)) => Some(l.cmp(r)),\n+            (&Self::Int(l), &Self::Int(r)) => {\n                 if let ty::Int(int_ty) = cmp_type.sty {\n                     Some(sext(tcx, l, int_ty).cmp(&sext(tcx, r, int_ty)))\n                 } else {\n                     Some(l.cmp(&r))\n                 }\n             },\n-            (&Constant::F64(l), &Constant::F64(r)) => l.partial_cmp(&r),\n-            (&Constant::F32(l), &Constant::F32(r)) => l.partial_cmp(&r),\n-            (&Constant::Bool(ref l), &Constant::Bool(ref r)) => Some(l.cmp(r)),\n-            (&Constant::Tuple(ref l), &Constant::Tuple(ref r)) | (&Constant::Vec(ref l), &Constant::Vec(ref r)) => l\n+            (&Self::F64(l), &Self::F64(r)) => l.partial_cmp(&r),\n+            (&Self::F32(l), &Self::F32(r)) => l.partial_cmp(&r),\n+            (&Self::Bool(ref l), &Self::Bool(ref r)) => Some(l.cmp(r)),\n+            (&Self::Tuple(ref l), &Self::Tuple(ref r)) | (&Self::Vec(ref l), &Self::Vec(ref r)) => l\n                 .iter()\n                 .zip(r.iter())\n                 .map(|(li, ri)| Self::partial_cmp(tcx, cmp_type, li, ri))\n                 .find(|r| r.map_or(true, |o| o != Ordering::Equal))\n                 .unwrap_or_else(|| Some(l.len().cmp(&r.len()))),\n-            (&Constant::Repeat(ref lv, ref ls), &Constant::Repeat(ref rv, ref rs)) => {\n+            (&Self::Repeat(ref lv, ref ls), &Self::Repeat(ref rv, ref rs)) => {\n                 match Self::partial_cmp(tcx, cmp_type, lv, rv) {\n                     Some(Equal) => Some(ls.cmp(rs)),\n                     x => x,"}, {"sha": "f276014f43ad52c30b6a2160fcf26c7d2550faec", "filename": "clippy_lints/src/escape.rs", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/fd9c5a3c71b84fafe9602d8702317ed1d432fa2c/clippy_lints%2Fsrc%2Fescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd9c5a3c71b84fafe9602d8702317ed1d432fa2c/clippy_lints%2Fsrc%2Fescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fescape.rs?ref=fd9c5a3c71b84fafe9602d8702317ed1d432fa2c", "patch": "@@ -1,5 +1,5 @@\n use rustc::hir::intravisit as visit;\n-use rustc::hir::*;\n+use rustc::hir::{self, *};\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use rustc::middle::expr_use_visitor::*;\n use rustc::middle::mem_categorization::{cmt_, Categorization};\n@@ -101,6 +101,19 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for BoxedLocal {\n     }\n }\n \n+// TODO: Replace with Map::is_argument(..) when it's fixed\n+fn is_argument(map: &hir::map::Map<'_>, id: HirId) -> bool {\n+    match map.find(id) {\n+        Some(Node::Binding(_)) => (),\n+        _ => return false,\n+    }\n+\n+    match map.find(map.get_parent_node(id)) {\n+        Some(Node::Arg(_)) => true,\n+        _ => false,\n+    }\n+}\n+\n impl<'a, 'tcx> Delegate<'tcx> for EscapeDelegate<'a, 'tcx> {\n     fn consume(&mut self, _: HirId, _: Span, cmt: &cmt_<'tcx>, mode: ConsumeMode) {\n         if let Categorization::Local(lid) = cmt.cat {\n@@ -113,11 +126,13 @@ impl<'a, 'tcx> Delegate<'tcx> for EscapeDelegate<'a, 'tcx> {\n     fn matched_pat(&mut self, _: &Pat, _: &cmt_<'tcx>, _: MatchMode) {}\n     fn consume_pat(&mut self, consume_pat: &Pat, cmt: &cmt_<'tcx>, _: ConsumeMode) {\n         let map = &self.cx.tcx.hir();\n-        if map.is_argument(consume_pat.hir_id) {\n+        if is_argument(map, consume_pat.hir_id) {\n             // Skip closure arguments\n-            if let Some(Node::Expr(..)) = map.find(map.get_parent_node(consume_pat.hir_id)) {\n+            let parent_id = map.get_parent_node(consume_pat.hir_id);\n+            if let Some(Node::Expr(..)) = map.find(map.get_parent_node(parent_id)) {\n                 return;\n             }\n+\n             if is_non_trait_box(cmt.ty) && !self.is_large_box(cmt.ty) {\n                 self.set.insert(consume_pat.hir_id);\n             }"}, {"sha": "e996bac3911e2a7a076be48db06795fd9f1131ff", "filename": "clippy_lints/src/excessive_precision.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fd9c5a3c71b84fafe9602d8702317ed1d432fa2c/clippy_lints%2Fsrc%2Fexcessive_precision.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd9c5a3c71b84fafe9602d8702317ed1d432fa2c/clippy_lints%2Fsrc%2Fexcessive_precision.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fexcessive_precision.rs?ref=fd9c5a3c71b84fafe9602d8702317ed1d432fa2c", "patch": "@@ -143,20 +143,20 @@ impl FloatFormat {\n     fn new(s: &str) -> Self {\n         s.chars()\n             .find_map(|x| match x {\n-                'e' => Some(FloatFormat::LowerExp),\n-                'E' => Some(FloatFormat::UpperExp),\n+                'e' => Some(Self::LowerExp),\n+                'E' => Some(Self::UpperExp),\n                 _ => None,\n             })\n-            .unwrap_or(FloatFormat::Normal)\n+            .unwrap_or(Self::Normal)\n     }\n     fn format<T>(&self, f: T) -> String\n     where\n         T: fmt::UpperExp + fmt::LowerExp + fmt::Display,\n     {\n         match self {\n-            FloatFormat::LowerExp => format!(\"{:e}\", f),\n-            FloatFormat::UpperExp => format!(\"{:E}\", f),\n-            FloatFormat::Normal => format!(\"{}\", f),\n+            Self::LowerExp => format!(\"{:e}\", f),\n+            Self::UpperExp => format!(\"{:E}\", f),\n+            Self::Normal => format!(\"{}\", f),\n         }\n     }\n }"}, {"sha": "908bbeb5e19fbb8df5717ae6023a6ecfdf3e0d8a", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fd9c5a3c71b84fafe9602d8702317ed1d432fa2c/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd9c5a3c71b84fafe9602d8702317ed1d432fa2c/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=fd9c5a3c71b84fafe9602d8702317ed1d432fa2c", "patch": "@@ -263,6 +263,7 @@ pub mod strings;\n pub mod suspicious_trait_impl;\n pub mod swap;\n pub mod temporary_assignment;\n+pub mod trait_bounds;\n pub mod transmute;\n pub mod transmuting_null;\n pub mod trivially_copy_pass_by_ref;\n@@ -588,6 +589,7 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry<'_>, conf: &Conf) {\n     reg.register_late_lint_pass(box checked_conversions::CheckedConversions);\n     reg.register_late_lint_pass(box integer_division::IntegerDivision);\n     reg.register_late_lint_pass(box inherent_to_string::InherentToString);\n+    reg.register_late_lint_pass(box trait_bounds::TraitBounds);\n \n     reg.register_lint_group(\"clippy::restriction\", Some(\"clippy_restriction\"), vec![\n         arithmetic::FLOAT_ARITHMETIC,\n@@ -858,6 +860,7 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry<'_>, conf: &Conf) {\n         swap::ALMOST_SWAPPED,\n         swap::MANUAL_SWAP,\n         temporary_assignment::TEMPORARY_ASSIGNMENT,\n+        trait_bounds::TYPE_REPETITION_IN_BOUNDS,\n         transmute::CROSSPOINTER_TRANSMUTE,\n         transmute::TRANSMUTE_BYTES_TO_STR,\n         transmute::TRANSMUTE_INT_TO_BOOL,\n@@ -1039,6 +1042,7 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry<'_>, conf: &Conf) {\n         reference::REF_IN_DEREF,\n         swap::MANUAL_SWAP,\n         temporary_assignment::TEMPORARY_ASSIGNMENT,\n+        trait_bounds::TYPE_REPETITION_IN_BOUNDS,\n         transmute::CROSSPOINTER_TRANSMUTE,\n         transmute::TRANSMUTE_BYTES_TO_STR,\n         transmute::TRANSMUTE_INT_TO_BOOL,"}, {"sha": "9cc957f1499e70fa52d7e8a20b8e296a3d3e3419", "filename": "clippy_lints/src/literal_representation.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fd9c5a3c71b84fafe9602d8702317ed1d432fa2c/clippy_lints%2Fsrc%2Fliteral_representation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd9c5a3c71b84fafe9602d8702317ed1d432fa2c/clippy_lints%2Fsrc%2Fliteral_representation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fliteral_representation.rs?ref=fd9c5a3c71b84fafe9602d8702317ed1d432fa2c", "patch": "@@ -115,8 +115,8 @@ impl Radix {\n     /// Returns a reasonable digit group size for this radix.\n     crate fn suggest_grouping(&self) -> usize {\n         match *self {\n-            Radix::Binary | Radix::Hexadecimal => 4,\n-            Radix::Octal | Radix::Decimal => 3,\n+            Self::Binary | Self::Hexadecimal => 4,\n+            Self::Octal | Self::Decimal => 3,\n         }\n     }\n }\n@@ -285,7 +285,7 @@ enum WarningType {\n impl WarningType {\n     crate fn display(&self, grouping_hint: &str, cx: &EarlyContext<'_>, span: syntax_pos::Span) {\n         match self {\n-            WarningType::MistypedLiteralSuffix => span_lint_and_sugg(\n+            Self::MistypedLiteralSuffix => span_lint_and_sugg(\n                 cx,\n                 MISTYPED_LITERAL_SUFFIXES,\n                 span,\n@@ -294,7 +294,7 @@ impl WarningType {\n                 grouping_hint.to_string(),\n                 Applicability::MaybeIncorrect,\n             ),\n-            WarningType::UnreadableLiteral => span_lint_and_sugg(\n+            Self::UnreadableLiteral => span_lint_and_sugg(\n                 cx,\n                 UNREADABLE_LITERAL,\n                 span,\n@@ -303,7 +303,7 @@ impl WarningType {\n                 grouping_hint.to_owned(),\n                 Applicability::MachineApplicable,\n             ),\n-            WarningType::LargeDigitGroups => span_lint_and_sugg(\n+            Self::LargeDigitGroups => span_lint_and_sugg(\n                 cx,\n                 LARGE_DIGIT_GROUPS,\n                 span,\n@@ -312,7 +312,7 @@ impl WarningType {\n                 grouping_hint.to_owned(),\n                 Applicability::MachineApplicable,\n             ),\n-            WarningType::InconsistentDigitGrouping => span_lint_and_sugg(\n+            Self::InconsistentDigitGrouping => span_lint_and_sugg(\n                 cx,\n                 INCONSISTENT_DIGIT_GROUPING,\n                 span,\n@@ -321,7 +321,7 @@ impl WarningType {\n                 grouping_hint.to_owned(),\n                 Applicability::MachineApplicable,\n             ),\n-            WarningType::DecimalRepresentation => span_lint_and_sugg(\n+            Self::DecimalRepresentation => span_lint_and_sugg(\n                 cx,\n                 DECIMAL_LITERAL_REPRESENTATION,\n                 span,"}, {"sha": "02dfb3e32aad7fcd9cecb61c8a8587b0b6855b75", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/fd9c5a3c71b84fafe9602d8702317ed1d432fa2c/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd9c5a3c71b84fafe9602d8702317ed1d432fa2c/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=fd9c5a3c71b84fafe9602d8702317ed1d432fa2c", "patch": "@@ -2505,14 +2505,14 @@ impl SelfKind {\n         let is_actually_self = |ty| is_self_ty(ty) || SpanlessEq::new(cx).eq_ty(ty, self_ty);\n         if is_self(arg) {\n             match self {\n-                SelfKind::Value => is_actually_self(ty),\n-                SelfKind::Ref | SelfKind::RefMut => {\n+                Self::Value => is_actually_self(ty),\n+                Self::Ref | Self::RefMut => {\n                     if allow_value_for_ref && is_actually_self(ty) {\n                         return true;\n                     }\n                     match ty.node {\n                         hir::TyKind::Rptr(_, ref mt_ty) => {\n-                            let mutability_match = if self == SelfKind::Ref {\n+                            let mutability_match = if self == Self::Ref {\n                                 mt_ty.mutbl == hir::MutImmutable\n                             } else {\n                                 mt_ty.mutbl == hir::MutMutable\n@@ -2526,20 +2526,20 @@ impl SelfKind {\n             }\n         } else {\n             match self {\n-                SelfKind::Value => false,\n-                SelfKind::Ref => is_as_ref_or_mut_trait(ty, self_ty, generics, &paths::ASREF_TRAIT),\n-                SelfKind::RefMut => is_as_ref_or_mut_trait(ty, self_ty, generics, &paths::ASMUT_TRAIT),\n-                SelfKind::No => true,\n+                Self::Value => false,\n+                Self::Ref => is_as_ref_or_mut_trait(ty, self_ty, generics, &paths::ASREF_TRAIT),\n+                Self::RefMut => is_as_ref_or_mut_trait(ty, self_ty, generics, &paths::ASMUT_TRAIT),\n+                Self::No => true,\n             }\n         }\n     }\n \n     fn description(self) -> &'static str {\n         match self {\n-            SelfKind::Value => \"self by value\",\n-            SelfKind::Ref => \"self by reference\",\n-            SelfKind::RefMut => \"self by mutable reference\",\n-            SelfKind::No => \"no self\",\n+            Self::Value => \"self by value\",\n+            Self::Ref => \"self by reference\",\n+            Self::RefMut => \"self by mutable reference\",\n+            Self::No => \"no self\",\n         }\n     }\n }\n@@ -2609,17 +2609,17 @@ fn single_segment_ty(ty: &hir::Ty) -> Option<&hir::PathSegment> {\n impl Convention {\n     fn check(&self, other: &str) -> bool {\n         match *self {\n-            Convention::Eq(this) => this == other,\n-            Convention::StartsWith(this) => other.starts_with(this) && this != other,\n+            Self::Eq(this) => this == other,\n+            Self::StartsWith(this) => other.starts_with(this) && this != other,\n         }\n     }\n }\n \n impl fmt::Display for Convention {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> Result<(), fmt::Error> {\n         match *self {\n-            Convention::Eq(this) => this.fmt(f),\n-            Convention::StartsWith(this) => this.fmt(f).and_then(|_| '*'.fmt(f)),\n+            Self::Eq(this) => this.fmt(f),\n+            Self::StartsWith(this) => this.fmt(f).and_then(|_| '*'.fmt(f)),\n         }\n     }\n }\n@@ -2636,11 +2636,11 @@ impl OutType {\n     fn matches(self, cx: &LateContext<'_, '_>, ty: &hir::FunctionRetTy) -> bool {\n         let is_unit = |ty: &hir::Ty| SpanlessEq::new(cx).eq_ty_kind(&ty.node, &hir::TyKind::Tup(vec![].into()));\n         match (self, ty) {\n-            (OutType::Unit, &hir::DefaultReturn(_)) => true,\n-            (OutType::Unit, &hir::Return(ref ty)) if is_unit(ty) => true,\n-            (OutType::Bool, &hir::Return(ref ty)) if is_bool(ty) => true,\n-            (OutType::Any, &hir::Return(ref ty)) if !is_unit(ty) => true,\n-            (OutType::Ref, &hir::Return(ref ty)) => matches!(ty.node, hir::TyKind::Rptr(_, _)),\n+            (Self::Unit, &hir::DefaultReturn(_)) => true,\n+            (Self::Unit, &hir::Return(ref ty)) if is_unit(ty) => true,\n+            (Self::Bool, &hir::Return(ref ty)) if is_bool(ty) => true,\n+            (Self::Any, &hir::Return(ref ty)) if !is_unit(ty) => true,\n+            (Self::Ref, &hir::Return(ref ty)) => matches!(ty.node, hir::TyKind::Rptr(_, _)),\n             _ => false,\n         }\n     }"}, {"sha": "644660100b8b891442f9f4309386b3092686b783", "filename": "clippy_lints/src/non_copy_const.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fd9c5a3c71b84fafe9602d8702317ed1d432fa2c/clippy_lints%2Fsrc%2Fnon_copy_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd9c5a3c71b84fafe9602d8702317ed1d432fa2c/clippy_lints%2Fsrc%2Fnon_copy_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnon_copy_const.rs?ref=fd9c5a3c71b84fafe9602d8702317ed1d432fa2c", "patch": "@@ -84,6 +84,7 @@ declare_clippy_lint! {\n     \"referencing const with interior mutability\"\n }\n \n+#[allow(dead_code)]\n #[derive(Copy, Clone)]\n enum Source {\n     Item { item: Span },\n@@ -94,12 +95,12 @@ enum Source {\n impl Source {\n     fn lint(&self) -> (&'static Lint, &'static str, Span) {\n         match self {\n-            Source::Item { item } | Source::Assoc { item, .. } => (\n+            Self::Item { item } | Self::Assoc { item, .. } => (\n                 DECLARE_INTERIOR_MUTABLE_CONST,\n                 \"a const item should never be interior mutable\",\n                 *item,\n             ),\n-            Source::Expr { expr } => (\n+            Self::Expr { expr } => (\n                 BORROW_INTERIOR_MUTABLE_CONST,\n                 \"a const item with interior mutability should not be borrowed\",\n                 *expr,"}, {"sha": "ffd6d4ca0f56ab9609e810d4e60a72bf0f4c1c46", "filename": "clippy_lints/src/ptr_offset_with_cast.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fd9c5a3c71b84fafe9602d8702317ed1d432fa2c/clippy_lints%2Fsrc%2Fptr_offset_with_cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd9c5a3c71b84fafe9602d8702317ed1d432fa2c/clippy_lints%2Fsrc%2Fptr_offset_with_cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fptr_offset_with_cast.rs?ref=fd9c5a3c71b84fafe9602d8702317ed1d432fa2c", "patch": "@@ -133,17 +133,17 @@ enum Method {\n impl Method {\n     fn suggestion(self) -> &'static str {\n         match self {\n-            Method::Offset => \"add\",\n-            Method::WrappingOffset => \"wrapping_add\",\n+            Self::Offset => \"add\",\n+            Self::WrappingOffset => \"wrapping_add\",\n         }\n     }\n }\n \n impl fmt::Display for Method {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match self {\n-            Method::Offset => write!(f, \"offset\"),\n-            Method::WrappingOffset => write!(f, \"wrapping_offset\"),\n+            Self::Offset => write!(f, \"offset\"),\n+            Self::WrappingOffset => write!(f, \"wrapping_offset\"),\n         }\n     }\n }"}, {"sha": "8a719c0dd041bdfd5f05bf0b0eda73d49dbfc1a2", "filename": "clippy_lints/src/trait_bounds.rs", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/fd9c5a3c71b84fafe9602d8702317ed1d432fa2c/clippy_lints%2Fsrc%2Ftrait_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd9c5a3c71b84fafe9602d8702317ed1d432fa2c/clippy_lints%2Fsrc%2Ftrait_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftrait_bounds.rs?ref=fd9c5a3c71b84fafe9602d8702317ed1d432fa2c", "patch": "@@ -0,0 +1,77 @@\n+use crate::utils::{in_macro, snippet, span_help_and_lint, SpanlessHash};\n+use rustc::hir::*;\n+use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n+use rustc::{declare_tool_lint, impl_lint_pass};\n+use rustc_data_structures::fx::FxHashMap;\n+\n+#[derive(Copy, Clone)]\n+pub struct TraitBounds;\n+\n+declare_clippy_lint! {\n+    /// **What it does:** This lint warns about unnecessary type repetitions in trait bounds\n+    ///\n+    /// **Why is this bad?** Repeating the type for every bound makes the code\n+    /// less readable than combining the bounds\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// pub fn foo<T>(t: T) where T: Copy, T: Clone\n+    /// ```\n+    ///\n+    /// Could be written as:\n+    ///\n+    /// ```rust\n+    /// pub fn foo<T>(t: T) where T: Copy + Clone\n+    /// ```\n+    pub TYPE_REPETITION_IN_BOUNDS,\n+    complexity,\n+    \"Types are repeated unnecessary in trait bounds use `+` instead of using `T: _, T: _`\"\n+}\n+\n+impl_lint_pass!(TraitBounds => [TYPE_REPETITION_IN_BOUNDS]);\n+\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TraitBounds {\n+    fn check_generics(&mut self, cx: &LateContext<'a, 'tcx>, gen: &'tcx Generics) {\n+        if in_macro(gen.span) {\n+            return;\n+        }\n+        let hash = |ty| -> u64 {\n+            let mut hasher = SpanlessHash::new(cx, cx.tables);\n+            hasher.hash_ty(ty);\n+            hasher.finish()\n+        };\n+        let mut map = FxHashMap::default();\n+        for bound in &gen.where_clause.predicates {\n+            if let WherePredicate::BoundPredicate(ref p) = bound {\n+                let h = hash(&p.bounded_ty);\n+                if let Some(ref v) = map.insert(h, p.bounds.iter().collect::<Vec<_>>()) {\n+                    let mut hint_string = format!(\n+                        \"consider combining the bounds: `{}:\",\n+                        snippet(cx, p.bounded_ty.span, \"_\")\n+                    );\n+                    for b in v.iter() {\n+                        if let GenericBound::Trait(ref poly_trait_ref, _) = b {\n+                            let path = &poly_trait_ref.trait_ref.path;\n+                            hint_string.push_str(&format!(\" {} +\", path));\n+                        }\n+                    }\n+                    for b in p.bounds.iter() {\n+                        if let GenericBound::Trait(ref poly_trait_ref, _) = b {\n+                            let path = &poly_trait_ref.trait_ref.path;\n+                            hint_string.push_str(&format!(\" {} +\", path));\n+                        }\n+                    }\n+                    hint_string.truncate(hint_string.len() - 2);\n+                    hint_string.push('`');\n+                    span_help_and_lint(\n+                        cx,\n+                        TYPE_REPETITION_IN_BOUNDS,\n+                        p.span,\n+                        \"this type has already been used as a bound predicate\",\n+                        &hint_string,\n+                    );\n+                }\n+            }\n+        }\n+    }\n+}"}, {"sha": "31d4c36585f36be2e3862d7fd6614f3090acfa2d", "filename": "clippy_lints/src/types.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fd9c5a3c71b84fafe9602d8702317ed1d432fa2c/clippy_lints%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd9c5a3c71b84fafe9602d8702317ed1d432fa2c/clippy_lints%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes.rs?ref=fd9c5a3c71b84fafe9602d8702317ed1d432fa2c", "patch": "@@ -1725,10 +1725,10 @@ impl PartialEq for FullInt {\n impl PartialOrd for FullInt {\n     fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n         Some(match (self, other) {\n-            (&FullInt::S(s), &FullInt::S(o)) => s.cmp(&o),\n-            (&FullInt::U(s), &FullInt::U(o)) => s.cmp(&o),\n-            (&FullInt::S(s), &FullInt::U(o)) => Self::cmp_s_u(s, o),\n-            (&FullInt::U(s), &FullInt::S(o)) => Self::cmp_s_u(o, s).reverse(),\n+            (&Self::S(s), &Self::S(o)) => s.cmp(&o),\n+            (&Self::U(s), &Self::U(o)) => s.cmp(&o),\n+            (&Self::S(s), &Self::U(o)) => Self::cmp_s_u(s, o),\n+            (&Self::U(s), &Self::S(o)) => Self::cmp_s_u(o, s).reverse(),\n         })\n     }\n }"}, {"sha": "3f93e019c66755398e4f70e63a339ee63b527e70", "filename": "clippy_lints/src/use_self.rs", "status": "modified", "additions": 38, "deletions": 20, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/fd9c5a3c71b84fafe9602d8702317ed1d432fa2c/clippy_lints%2Fsrc%2Fuse_self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd9c5a3c71b84fafe9602d8702317ed1d432fa2c/clippy_lints%2Fsrc%2Fuse_self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fuse_self.rs?ref=fd9c5a3c71b84fafe9602d8702317ed1d432fa2c", "patch": "@@ -51,9 +51,11 @@ declare_lint_pass!(UseSelf => [USE_SELF]);\n \n const SEGMENTS_MSG: &str = \"segments should be composed of at least 1 element\";\n \n-fn span_use_self_lint(cx: &LateContext<'_, '_>, path: &Path) {\n+fn span_use_self_lint(cx: &LateContext<'_, '_>, path: &Path, last_segment: Option<&PathSegment>) {\n+    let last_segment = last_segment.unwrap_or_else(|| path.segments.last().expect(SEGMENTS_MSG));\n+\n     // Path segments only include actual path, no methods or fields.\n-    let last_path_span = path.segments.last().expect(SEGMENTS_MSG).ident.span;\n+    let last_path_span = last_segment.ident.span;\n     // Only take path up to the end of last_path_span.\n     let span = path.span.with_hi(last_path_span.hi());\n \n@@ -80,22 +82,18 @@ impl<'a, 'tcx> Visitor<'tcx> for TraitImplTyVisitor<'a, 'tcx> {\n         let trait_ty = self.trait_type_walker.next();\n         let impl_ty = self.impl_type_walker.next();\n \n-        if let TyKind::Path(QPath::Resolved(_, path)) = &t.node {\n+        if_chain! {\n+            if let TyKind::Path(QPath::Resolved(_, path)) = &t.node;\n+\n             // The implementation and trait types don't match which means that\n             // the concrete type was specified by the implementation\n-            if impl_ty != trait_ty {\n-                if let Some(impl_ty) = impl_ty {\n-                    if self.item_type == impl_ty {\n-                        let is_self_ty = if let def::Res::SelfTy(..) = path.res {\n-                            true\n-                        } else {\n-                            false\n-                        };\n-\n-                        if !is_self_ty {\n-                            span_use_self_lint(self.cx, path);\n-                        }\n-                    }\n+            if impl_ty != trait_ty;\n+            if let Some(impl_ty) = impl_ty;\n+            if self.item_type == impl_ty;\n+            then {\n+                match path.res {\n+                    def::Res::SelfTy(..) => {},\n+                    _ => span_use_self_lint(self.cx, path, None)\n                 }\n             }\n         }\n@@ -220,15 +218,35 @@ struct UseSelfVisitor<'a, 'tcx> {\n \n impl<'a, 'tcx> Visitor<'tcx> for UseSelfVisitor<'a, 'tcx> {\n     fn visit_path(&mut self, path: &'tcx Path, _id: HirId) {\n+        if path.segments.len() >= 2 {\n+            let last_but_one = &path.segments[path.segments.len() - 2];\n+            if last_but_one.ident.name != kw::SelfUpper {\n+                let enum_def_id = match path.res {\n+                    Res::Def(DefKind::Variant, variant_def_id) =>\n+                        self.cx.tcx.parent(variant_def_id),\n+                    Res::Def(DefKind::Ctor(def::CtorOf::Variant, _), ctor_def_id) => {\n+                        let variant_def_id = self.cx.tcx.parent(ctor_def_id);\n+                        variant_def_id.and_then(|def_id| self.cx.tcx.parent(def_id))\n+                    }\n+                    _ => None\n+                };\n+\n+                if self.item_path.res.opt_def_id() == enum_def_id {\n+                    span_use_self_lint(self.cx, path, Some(last_but_one));\n+                }\n+            }\n+        }\n+\n         if path.segments.last().expect(SEGMENTS_MSG).ident.name != kw::SelfUpper {\n             if self.item_path.res == path.res {\n-                span_use_self_lint(self.cx, path);\n-            } else if let Res::Def(DefKind::Ctor(def::CtorOf::Struct, CtorKind::Fn), ctor_did) = path.res {\n-                if self.item_path.res.opt_def_id() == self.cx.tcx.parent(ctor_did) {\n-                    span_use_self_lint(self.cx, path);\n+                span_use_self_lint(self.cx, path, None);\n+            } else if let Res::Def(DefKind::Ctor(def::CtorOf::Struct, CtorKind::Fn), ctor_def_id) = path.res {\n+                if self.item_path.res.opt_def_id() == self.cx.tcx.parent(ctor_def_id) {\n+                    span_use_self_lint(self.cx, path, None);\n                 }\n             }\n         }\n+\n         walk_path(self, path);\n     }\n "}, {"sha": "0c5db79dfd877ca218659a6edcbde246cb22a628", "filename": "clippy_lints/src/utils/conf.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fd9c5a3c71b84fafe9602d8702317ed1d432fa2c/clippy_lints%2Fsrc%2Futils%2Fconf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd9c5a3c71b84fafe9602d8702317ed1d432fa2c/clippy_lints%2Fsrc%2Futils%2Fconf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fconf.rs?ref=fd9c5a3c71b84fafe9602d8702317ed1d432fa2c", "patch": "@@ -44,15 +44,15 @@ pub enum Error {\n impl fmt::Display for Error {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> Result<(), fmt::Error> {\n         match *self {\n-            Error::Io(ref err) => err.fmt(f),\n-            Error::Toml(ref err) => err.fmt(f),\n+            Self::Io(ref err) => err.fmt(f),\n+            Self::Toml(ref err) => err.fmt(f),\n         }\n     }\n }\n \n impl From<io::Error> for Error {\n     fn from(e: io::Error) -> Self {\n-        Error::Io(e)\n+        Self::Io(e)\n     }\n }\n "}, {"sha": "6fc5939a216026c0b0b20ecf9740461434e5365f", "filename": "clippy_lints/src/utils/hir_utils.rs", "status": "modified", "additions": 102, "deletions": 3, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/fd9c5a3c71b84fafe9602d8702317ed1d432fa2c/clippy_lints%2Fsrc%2Futils%2Fhir_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd9c5a3c71b84fafe9602d8702317ed1d432fa2c/clippy_lints%2Fsrc%2Futils%2Fhir_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fhir_utils.rs?ref=fd9c5a3c71b84fafe9602d8702317ed1d432fa2c", "patch": "@@ -438,9 +438,9 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n                 self.hash_expr(fun);\n                 self.hash_exprs(args);\n             },\n-            ExprKind::Cast(ref e, ref _ty) | ExprKind::Type(ref e, ref _ty) => {\n+            ExprKind::Cast(ref e, ref ty) | ExprKind::Type(ref e, ref ty) => {\n                 self.hash_expr(e);\n-                // TODO: _ty\n+                self.hash_ty(ty);\n             },\n             ExprKind::Closure(cap, _, eid, _, _) => {\n                 match cap {\n@@ -512,7 +512,10 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n                     self.hash_expr(e);\n                 }\n             },\n-            ExprKind::Tup(ref v) | ExprKind::Array(ref v) => {\n+            ExprKind::Tup(ref tup) => {\n+                self.hash_exprs(tup);\n+            },\n+            ExprKind::Array(ref v) => {\n                 self.hash_exprs(v);\n             },\n             ExprKind::Unary(lop, ref le) => {\n@@ -574,4 +577,100 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n             },\n         }\n     }\n+\n+    pub fn hash_lifetime(&mut self, lifetime: &Lifetime) {\n+        std::mem::discriminant(&lifetime.name).hash(&mut self.s);\n+        if let LifetimeName::Param(ref name) = lifetime.name {\n+            std::mem::discriminant(name).hash(&mut self.s);\n+            match name {\n+                ParamName::Plain(ref ident) => {\n+                    ident.name.hash(&mut self.s);\n+                },\n+                ParamName::Fresh(ref size) => {\n+                    size.hash(&mut self.s);\n+                },\n+                ParamName::Error => {},\n+            }\n+        }\n+    }\n+\n+    pub fn hash_ty(&mut self, ty: &Ty) {\n+        self.hash_tykind(&ty.node);\n+    }\n+\n+    pub fn hash_tykind(&mut self, ty: &TyKind) {\n+        std::mem::discriminant(ty).hash(&mut self.s);\n+        match ty {\n+            TyKind::Slice(ty) => {\n+                self.hash_ty(ty);\n+            },\n+            TyKind::Array(ty, anon_const) => {\n+                self.hash_ty(ty);\n+                self.hash_expr(&self.cx.tcx.hir().body(anon_const.body).value);\n+            },\n+            TyKind::Ptr(mut_ty) => {\n+                self.hash_ty(&mut_ty.ty);\n+                mut_ty.mutbl.hash(&mut self.s);\n+            },\n+            TyKind::Rptr(lifetime, mut_ty) => {\n+                self.hash_lifetime(lifetime);\n+                self.hash_ty(&mut_ty.ty);\n+                mut_ty.mutbl.hash(&mut self.s);\n+            },\n+            TyKind::BareFn(bfn) => {\n+                bfn.unsafety.hash(&mut self.s);\n+                bfn.abi.hash(&mut self.s);\n+                for arg in &bfn.decl.inputs {\n+                    self.hash_ty(&arg);\n+                }\n+                match bfn.decl.output {\n+                    FunctionRetTy::DefaultReturn(_) => {\n+                        ().hash(&mut self.s);\n+                    },\n+                    FunctionRetTy::Return(ref ty) => {\n+                        self.hash_ty(ty);\n+                    },\n+                }\n+                bfn.decl.c_variadic.hash(&mut self.s);\n+            },\n+            TyKind::Tup(ty_list) => {\n+                for ty in ty_list {\n+                    self.hash_ty(ty);\n+                }\n+            },\n+            TyKind::Path(qpath) => match qpath {\n+                QPath::Resolved(ref maybe_ty, ref path) => {\n+                    if let Some(ref ty) = maybe_ty {\n+                        self.hash_ty(ty);\n+                    }\n+                    for segment in &path.segments {\n+                        segment.ident.name.hash(&mut self.s);\n+                    }\n+                },\n+                QPath::TypeRelative(ref ty, ref segment) => {\n+                    self.hash_ty(ty);\n+                    segment.ident.name.hash(&mut self.s);\n+                },\n+            },\n+            TyKind::Def(_, arg_list) => {\n+                for arg in arg_list {\n+                    match arg {\n+                        GenericArg::Lifetime(ref l) => self.hash_lifetime(l),\n+                        GenericArg::Type(ref ty) => self.hash_ty(&ty),\n+                        GenericArg::Const(ref ca) => {\n+                            self.hash_expr(&self.cx.tcx.hir().body(ca.value.body).value);\n+                        },\n+                    }\n+                }\n+            },\n+            TyKind::TraitObject(_, lifetime) => {\n+                self.hash_lifetime(lifetime);\n+            },\n+            TyKind::Typeof(anon_const) => {\n+                self.hash_expr(&self.cx.tcx.hir().body(anon_const.body).value);\n+            },\n+            TyKind::CVarArgs(lifetime) => self.hash_lifetime(lifetime),\n+            TyKind::Err | TyKind::Infer | TyKind::Never => {},\n+        }\n+    }\n }"}, {"sha": "49bce5a6cef4d2ef3ff26ccd867189ac35c833ea", "filename": "src/lintlist/mod.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fd9c5a3c71b84fafe9602d8702317ed1d432fa2c/src%2Flintlist%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd9c5a3c71b84fafe9602d8702317ed1d432fa2c/src%2Flintlist%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flintlist%2Fmod.rs?ref=fd9c5a3c71b84fafe9602d8702317ed1d432fa2c", "patch": "@@ -6,7 +6,7 @@ pub use lint::Lint;\n pub use lint::LINT_LEVELS;\n \n // begin lint list, do not remove this comment, it\u2019s used in `update_lints`\n-pub const ALL_LINTS: [Lint; 308] = [\n+pub const ALL_LINTS: [Lint; 309] = [\n     Lint {\n         name: \"absurd_extreme_comparisons\",\n         group: \"correctness\",\n@@ -1848,6 +1848,13 @@ pub const ALL_LINTS: [Lint; 308] = [\n         deprecation: None,\n         module: \"types\",\n     },\n+    Lint {\n+        name: \"type_repetition_in_bounds\",\n+        group: \"complexity\",\n+        desc: \"Types are repeated unnecessary in trait bounds use `+` instead of using `T: _, T: _`\",\n+        deprecation: None,\n+        module: \"trait_bounds\",\n+    },\n     Lint {\n         name: \"unicode_not_nfc\",\n         group: \"pedantic\","}, {"sha": "b60f373e75e1179ffbf8171f3af0819f1901aca8", "filename": "tests/ui/drop_forget_ref.rs", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/fd9c5a3c71b84fafe9602d8702317ed1d432fa2c/tests%2Fui%2Fdrop_forget_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd9c5a3c71b84fafe9602d8702317ed1d432fa2c/tests%2Fui%2Fdrop_forget_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdrop_forget_ref.rs?ref=fd9c5a3c71b84fafe9602d8702317ed1d432fa2c", "patch": "@@ -55,3 +55,38 @@ fn test_similarly_named_function() {\n     forget(&SomeStruct); //OK; call to unrelated function which happens to have the same name\n     std::mem::forget(&SomeStruct);\n }\n+\n+#[derive(Copy, Clone)]\n+pub struct Error;\n+fn produce_half_owl_error() -> Result<(), Error> {\n+    Ok(())\n+}\n+\n+fn produce_half_owl_ok() -> Result<bool, ()> {\n+    Ok(true)\n+}\n+\n+#[allow(dead_code)]\n+fn test_owl_result() -> Result<(), ()> {\n+    produce_half_owl_error().map_err(|_| ())?;\n+    produce_half_owl_ok().map(|_| ())?;\n+    // the following should not be linted,\n+    // we should not force users to use toilet closures\n+    // to produce owl results when drop is more convenient\n+    produce_half_owl_error().map_err(drop)?;\n+    produce_half_owl_ok().map_err(drop)?;\n+    Ok(())\n+}\n+\n+\n+#[allow(dead_code)]\n+fn test_owl_result_2() -> Result<u8, ()> {\n+    produce_half_owl_error().map_err(|_| ())?;\n+    produce_half_owl_ok().map(|_| ())?;\n+    // the following should not be linted,\n+    // we should not force users to use toilet closures\n+    // to produce owl results when drop is more convenient\n+    produce_half_owl_error().map_err(drop)?;\n+    produce_half_owl_ok().map(drop)?;\n+    Ok(1)\n+}"}, {"sha": "207c1bcbbc676da7857dfd211037129e5cd33f90", "filename": "tests/ui/float_cmp.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fd9c5a3c71b84fafe9602d8702317ed1d432fa2c/tests%2Fui%2Ffloat_cmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd9c5a3c71b84fafe9602d8702317ed1d432fa2c/tests%2Fui%2Ffloat_cmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffloat_cmp.rs?ref=fd9c5a3c71b84fafe9602d8702317ed1d432fa2c", "patch": "@@ -8,8 +8,7 @@ const ONE: f32 = ZERO + 1.0;\n \n fn twice<T>(x: T) -> T\n where\n-    T: Add<T, Output = T>,\n-    T: Copy,\n+    T: Add<T, Output = T> + Copy,\n {\n     x + x\n }"}, {"sha": "116e3e90e6372c41c1437832331d4cdf3a60135e", "filename": "tests/ui/float_cmp.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fd9c5a3c71b84fafe9602d8702317ed1d432fa2c/tests%2Fui%2Ffloat_cmp.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fd9c5a3c71b84fafe9602d8702317ed1d432fa2c/tests%2Fui%2Ffloat_cmp.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffloat_cmp.stderr?ref=fd9c5a3c71b84fafe9602d8702317ed1d432fa2c", "patch": "@@ -1,36 +1,36 @@\n error: strict comparison of f32 or f64\n-  --> $DIR/float_cmp.rs:60:5\n+  --> $DIR/float_cmp.rs:59:5\n    |\n LL |     ONE as f64 != 2.0;\n    |     ^^^^^^^^^^^^^^^^^ help: consider comparing them within some error: `(ONE as f64 - 2.0).abs() > error`\n    |\n    = note: `-D clippy::float-cmp` implied by `-D warnings`\n note: std::f32::EPSILON and std::f64::EPSILON are available.\n-  --> $DIR/float_cmp.rs:60:5\n+  --> $DIR/float_cmp.rs:59:5\n    |\n LL |     ONE as f64 != 2.0;\n    |     ^^^^^^^^^^^^^^^^^\n \n error: strict comparison of f32 or f64\n-  --> $DIR/float_cmp.rs:65:5\n+  --> $DIR/float_cmp.rs:64:5\n    |\n LL |     x == 1.0;\n    |     ^^^^^^^^ help: consider comparing them within some error: `(x - 1.0).abs() < error`\n    |\n note: std::f32::EPSILON and std::f64::EPSILON are available.\n-  --> $DIR/float_cmp.rs:65:5\n+  --> $DIR/float_cmp.rs:64:5\n    |\n LL |     x == 1.0;\n    |     ^^^^^^^^\n \n error: strict comparison of f32 or f64\n-  --> $DIR/float_cmp.rs:68:5\n+  --> $DIR/float_cmp.rs:67:5\n    |\n LL |     twice(x) != twice(ONE as f64);\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider comparing them within some error: `(twice(x) - twice(ONE as f64)).abs() > error`\n    |\n note: std::f32::EPSILON and std::f64::EPSILON are available.\n-  --> $DIR/float_cmp.rs:68:5\n+  --> $DIR/float_cmp.rs:67:5\n    |\n LL |     twice(x) != twice(ONE as f64);\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"}, {"sha": "8b538be762b0c3bb9821171388e33c85c99f1fea", "filename": "tests/ui/type_repetition_in_bounds.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/fd9c5a3c71b84fafe9602d8702317ed1d432fa2c/tests%2Fui%2Ftype_repetition_in_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd9c5a3c71b84fafe9602d8702317ed1d432fa2c/tests%2Fui%2Ftype_repetition_in_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype_repetition_in_bounds.rs?ref=fd9c5a3c71b84fafe9602d8702317ed1d432fa2c", "patch": "@@ -0,0 +1,19 @@\n+#[deny(clippy::type_repetition_in_bounds)]\n+\n+pub fn foo<T>(_t: T)\n+where\n+    T: Copy,\n+    T: Clone,\n+{\n+    unimplemented!();\n+}\n+\n+pub fn bar<T, U>(_t: T, _u: U)\n+where\n+    T: Copy,\n+    U: Clone,\n+{\n+    unimplemented!();\n+}\n+\n+fn main() {}"}, {"sha": "a72f512b0129a87da9ba8bfd60bbe6fa7782f352", "filename": "tests/ui/type_repetition_in_bounds.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/fd9c5a3c71b84fafe9602d8702317ed1d432fa2c/tests%2Fui%2Ftype_repetition_in_bounds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fd9c5a3c71b84fafe9602d8702317ed1d432fa2c/tests%2Fui%2Ftype_repetition_in_bounds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype_repetition_in_bounds.stderr?ref=fd9c5a3c71b84fafe9602d8702317ed1d432fa2c", "patch": "@@ -0,0 +1,15 @@\n+error: this type has already been used as a bound predicate\n+  --> $DIR/type_repetition_in_bounds.rs:6:5\n+   |\n+LL |     T: Clone,\n+   |     ^^^^^^^^\n+   |\n+note: lint level defined here\n+  --> $DIR/type_repetition_in_bounds.rs:1:8\n+   |\n+LL | #[deny(clippy::type_repetition_in_bounds)]\n+   |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = help: consider combining the bounds: `T: Copy + Clone`\n+\n+error: aborting due to previous error\n+"}, {"sha": "ac2a1708b65e6e3c409467fd754fe38e82fb59e9", "filename": "tests/ui/use_self.fixed", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fd9c5a3c71b84fafe9602d8702317ed1d432fa2c/tests%2Fui%2Fuse_self.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/fd9c5a3c71b84fafe9602d8702317ed1d432fa2c/tests%2Fui%2Fuse_self.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fuse_self.fixed?ref=fd9c5a3c71b84fafe9602d8702317ed1d432fa2c", "patch": "@@ -265,13 +265,21 @@ mod nesting {\n \n     enum Enum {\n         A,\n+        B(u64),\n+        C { field: bool }\n     }\n     impl Enum {\n         fn method() {\n             #[allow(unused_imports)]\n             use self::Enum::*; // Issue 3425\n             static STATIC: Enum = Enum::A; // Can't use Self as type\n         }\n+\n+        fn method2() {\n+            let _ = Self::B(42);\n+            let _ = Self::C { field: true };\n+            let _ = Self::A;\n+        }\n     }\n }\n "}, {"sha": "21b5833e56ee27189f69057bd9b5b4df478482ae", "filename": "tests/ui/use_self.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fd9c5a3c71b84fafe9602d8702317ed1d432fa2c/tests%2Fui%2Fuse_self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd9c5a3c71b84fafe9602d8702317ed1d432fa2c/tests%2Fui%2Fuse_self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fuse_self.rs?ref=fd9c5a3c71b84fafe9602d8702317ed1d432fa2c", "patch": "@@ -265,13 +265,21 @@ mod nesting {\n \n     enum Enum {\n         A,\n+        B(u64),\n+        C { field: bool }\n     }\n     impl Enum {\n         fn method() {\n             #[allow(unused_imports)]\n             use self::Enum::*; // Issue 3425\n             static STATIC: Enum = Enum::A; // Can't use Self as type\n         }\n+\n+        fn method2() {\n+            let _ = Enum::B(42);\n+            let _ = Enum::C { field: true };\n+            let _ = Enum::A;\n+        }\n     }\n }\n "}, {"sha": "12dd672e3f4b50456d4b2461f87ad3b86a23b7c8", "filename": "tests/ui/use_self.stderr", "status": "modified", "additions": 22, "deletions": 4, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/fd9c5a3c71b84fafe9602d8702317ed1d432fa2c/tests%2Fui%2Fuse_self.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fd9c5a3c71b84fafe9602d8702317ed1d432fa2c/tests%2Fui%2Fuse_self.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fuse_self.stderr?ref=fd9c5a3c71b84fafe9602d8702317ed1d432fa2c", "patch": "@@ -175,22 +175,40 @@ LL |                     Bar { foo: Foo {} }\n    |                     ^^^ help: use the applicable keyword: `Self`\n \n error: unnecessary structure name repetition\n-  --> $DIR/use_self.rs:304:13\n+  --> $DIR/use_self.rs:279:21\n+   |\n+LL |             let _ = Enum::B(42);\n+   |                     ^^^^ help: use the applicable keyword: `Self`\n+\n+error: unnecessary structure name repetition\n+  --> $DIR/use_self.rs:280:21\n+   |\n+LL |             let _ = Enum::C { field: true };\n+   |                     ^^^^ help: use the applicable keyword: `Self`\n+\n+error: unnecessary structure name repetition\n+  --> $DIR/use_self.rs:281:21\n+   |\n+LL |             let _ = Enum::A;\n+   |                     ^^^^ help: use the applicable keyword: `Self`\n+\n+error: unnecessary structure name repetition\n+  --> $DIR/use_self.rs:312:13\n    |\n LL |             nested::A::fun_1();\n    |             ^^^^^^^^^ help: use the applicable keyword: `Self`\n \n error: unnecessary structure name repetition\n-  --> $DIR/use_self.rs:305:13\n+  --> $DIR/use_self.rs:313:13\n    |\n LL |             nested::A::A;\n    |             ^^^^^^^^^ help: use the applicable keyword: `Self`\n \n error: unnecessary structure name repetition\n-  --> $DIR/use_self.rs:307:13\n+  --> $DIR/use_self.rs:315:13\n    |\n LL |             nested::A {};\n    |             ^^^^^^^^^ help: use the applicable keyword: `Self`\n \n-error: aborting due to 31 previous errors\n+error: aborting due to 34 previous errors\n "}]}