{"sha": "5eed9c69ca9fa04a1417f1f14df0bb5bab2fc8c8", "node_id": "C_kwDOAAsO6NoAKDVlZWQ5YzY5Y2E5ZmEwNGExNDE3ZjFmMTRkZjBiYjViYWIyZmM4Yzg", "commit": {"author": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2023-01-12T18:28:22Z"}, "committer": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2023-01-12T18:28:22Z"}, "message": "Revert 4dbd8ad34e7f6820f6e9e99531353e7ffe37b76a, c7dc96155853a3919b973347277d0e9bcaaa22f0, ed519ad746e31f64c4e9255be561785612532d37 and c6477eb71188311f01f409da628fab7062697bd7", "tree": {"sha": "2dacf4c07d2b79b9eb951cfc2918f584af2b1e7a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2dacf4c07d2b79b9eb951cfc2918f584af2b1e7a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5eed9c69ca9fa04a1417f1f14df0bb5bab2fc8c8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5eed9c69ca9fa04a1417f1f14df0bb5bab2fc8c8", "html_url": "https://github.com/rust-lang/rust/commit/5eed9c69ca9fa04a1417f1f14df0bb5bab2fc8c8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5eed9c69ca9fa04a1417f1f14df0bb5bab2fc8c8/comments", "author": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f9ca9d4112f021fd73258e13ec9e353738ba0482", "url": "https://api.github.com/repos/rust-lang/rust/commits/f9ca9d4112f021fd73258e13ec9e353738ba0482", "html_url": "https://github.com/rust-lang/rust/commit/f9ca9d4112f021fd73258e13ec9e353738ba0482"}], "stats": {"total": 343, "additions": 109, "deletions": 234}, "files": [{"sha": "7b43d8ccc67d1fec92a5be0389860e9c8c6658a5", "filename": "clippy_lints/src/dereference.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5eed9c69ca9fa04a1417f1f14df0bb5bab2fc8c8/clippy_lints%2Fsrc%2Fdereference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eed9c69ca9fa04a1417f1f14df0bb5bab2fc8c8/clippy_lints%2Fsrc%2Fdereference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdereference.rs?ref=5eed9c69ca9fa04a1417f1f14df0bb5bab2fc8c8", "patch": "@@ -1282,10 +1282,10 @@ fn referent_used_exactly_once<'tcx>(\n             possible_borrowers.push((body_owner_local_def_id, PossibleBorrowerMap::new(cx, mir)));\n         }\n         let possible_borrower = &mut possible_borrowers.last_mut().unwrap().1;\n-        // If `place.local` were not included here, the `copyable_iterator::warn` test would fail. The\n-        // reason is that `PossibleBorrowerVisitor::visit_terminator` considers `place.local` a possible\n-        // borrower of itself. See the comment in that method for an explanation as to why.\n-        possible_borrower.at_most_borrowers(cx, &[local, place.local], place.local, location)\n+        // If `only_borrowers` were used here, the `copyable_iterator::warn` test would fail. The reason is\n+        // that `PossibleBorrowerVisitor::visit_terminator` considers `place.local` a possible borrower of\n+        // itself. See the comment in that method for an explanation as to why.\n+        possible_borrower.bounded_borrowers(&[local], &[local, place.local], place.local, location)\n             && used_exactly_once(mir, place.local).unwrap_or(false)\n     } else {\n         false"}, {"sha": "c1677fb3da1c4850215dfd6a88e1ee485d4c54ed", "filename": "clippy_lints/src/redundant_clone.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5eed9c69ca9fa04a1417f1f14df0bb5bab2fc8c8/clippy_lints%2Fsrc%2Fredundant_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eed9c69ca9fa04a1417f1f14df0bb5bab2fc8c8/clippy_lints%2Fsrc%2Fredundant_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fredundant_clone.rs?ref=5eed9c69ca9fa04a1417f1f14df0bb5bab2fc8c8", "patch": "@@ -131,7 +131,7 @@ impl<'tcx> LateLintPass<'tcx> for RedundantClone {\n                 // `res = clone(arg)` can be turned into `res = move arg;`\n                 // if `arg` is the only borrow of `cloned` at this point.\n \n-                if cannot_move_out || !possible_borrower.at_most_borrowers(cx, &[arg], cloned, loc) {\n+                if cannot_move_out || !possible_borrower.only_borrowers(&[arg], cloned, loc) {\n                     continue;\n                 }\n \n@@ -178,7 +178,7 @@ impl<'tcx> LateLintPass<'tcx> for RedundantClone {\n                 // StorageDead(pred_arg);\n                 // res = to_path_buf(cloned);\n                 // ```\n-                if cannot_move_out || !possible_borrower.at_most_borrowers(cx, &[arg, cloned], local, loc) {\n+                if cannot_move_out || !possible_borrower.only_borrowers(&[arg, cloned], local, loc) {\n                     continue;\n                 }\n "}, {"sha": "8c695801c73fc18cc13ec4ede95818ff0def8f75", "filename": "clippy_utils/src/mir/possible_borrower.rs", "status": "modified", "additions": 99, "deletions": 172, "changes": 271, "blob_url": "https://github.com/rust-lang/rust/blob/5eed9c69ca9fa04a1417f1f14df0bb5bab2fc8c8/clippy_utils%2Fsrc%2Fmir%2Fpossible_borrower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eed9c69ca9fa04a1417f1f14df0bb5bab2fc8c8/clippy_utils%2Fsrc%2Fmir%2Fpossible_borrower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fmir%2Fpossible_borrower.rs?ref=5eed9c69ca9fa04a1417f1f14df0bb5bab2fc8c8", "patch": "@@ -1,137 +1,89 @@\n-use super::possible_origin::PossibleOriginVisitor;\n+use super::{possible_origin::PossibleOriginVisitor, transitive_relation::TransitiveRelation};\n use crate::ty::is_copy;\n-use rustc_data_structures::fx::{FxHashMap, FxIndexMap};\n+use rustc_data_structures::fx::FxHashMap;\n use rustc_index::bit_set::{BitSet, HybridBitSet};\n use rustc_lint::LateContext;\n-use rustc_middle::mir::{\n-    self, visit::Visitor as _, BasicBlock, Local, Location, Mutability, Statement, StatementKind, Terminator,\n-};\n-use rustc_middle::ty::{self, visit::TypeVisitor, TyCtxt};\n-use rustc_mir_dataflow::{\n-    fmt::DebugWithContext, impls::MaybeStorageLive, lattice::JoinSemiLattice, Analysis, AnalysisDomain,\n-    CallReturnPlaces, ResultsCursor,\n-};\n-use std::borrow::Cow;\n+use rustc_middle::mir::{self, visit::Visitor as _, Mutability};\n+use rustc_middle::ty::{self, visit::TypeVisitor};\n+use rustc_mir_dataflow::{impls::MaybeStorageLive, Analysis, ResultsCursor};\n use std::ops::ControlFlow;\n \n /// Collects the possible borrowers of each local.\n /// For example, `b = &a; c = &a;` will make `b` and (transitively) `c`\n /// possible borrowers of `a`.\n #[allow(clippy::module_name_repetitions)]\n-struct PossibleBorrowerAnalysis<'b, 'tcx> {\n-    tcx: TyCtxt<'tcx>,\n+struct PossibleBorrowerVisitor<'a, 'b, 'tcx> {\n+    possible_borrower: TransitiveRelation,\n     body: &'b mir::Body<'tcx>,\n+    cx: &'a LateContext<'tcx>,\n     possible_origin: FxHashMap<mir::Local, HybridBitSet<mir::Local>>,\n }\n \n-#[derive(Clone, Debug, Eq, PartialEq)]\n-struct PossibleBorrowerState {\n-    map: FxIndexMap<Local, BitSet<Local>>,\n-    domain_size: usize,\n-}\n-\n-impl PossibleBorrowerState {\n-    fn new(domain_size: usize) -> Self {\n+impl<'a, 'b, 'tcx> PossibleBorrowerVisitor<'a, 'b, 'tcx> {\n+    fn new(\n+        cx: &'a LateContext<'tcx>,\n+        body: &'b mir::Body<'tcx>,\n+        possible_origin: FxHashMap<mir::Local, HybridBitSet<mir::Local>>,\n+    ) -> Self {\n         Self {\n-            map: FxIndexMap::default(),\n-            domain_size,\n+            possible_borrower: TransitiveRelation::default(),\n+            cx,\n+            body,\n+            possible_origin,\n         }\n     }\n \n-    #[allow(clippy::similar_names)]\n-    fn add(&mut self, borrowed: Local, borrower: Local) {\n-        self.map\n-            .entry(borrowed)\n-            .or_insert(BitSet::new_empty(self.domain_size))\n-            .insert(borrower);\n-    }\n-}\n-\n-impl<C> DebugWithContext<C> for PossibleBorrowerState {\n-    fn fmt_with(&self, _ctxt: &C, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n-        <_ as std::fmt::Debug>::fmt(self, f)\n-    }\n-    fn fmt_diff_with(&self, _old: &Self, _ctxt: &C, _f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n-        unimplemented!()\n-    }\n-}\n+    fn into_map(\n+        self,\n+        cx: &'a LateContext<'tcx>,\n+        maybe_live: ResultsCursor<'b, 'tcx, MaybeStorageLive>,\n+    ) -> PossibleBorrowerMap<'b, 'tcx> {\n+        let mut map = FxHashMap::default();\n+        for row in (1..self.body.local_decls.len()).map(mir::Local::from_usize) {\n+            if is_copy(cx, self.body.local_decls[row].ty) {\n+                continue;\n+            }\n \n-impl JoinSemiLattice for PossibleBorrowerState {\n-    fn join(&mut self, other: &Self) -> bool {\n-        let mut changed = false;\n-        for (&borrowed, borrowers) in other.map.iter() {\n+            let mut borrowers = self.possible_borrower.reachable_from(row, self.body.local_decls.len());\n+            borrowers.remove(mir::Local::from_usize(0));\n             if !borrowers.is_empty() {\n-                changed |= self\n-                    .map\n-                    .entry(borrowed)\n-                    .or_insert(BitSet::new_empty(self.domain_size))\n-                    .union(borrowers);\n+                map.insert(row, borrowers);\n             }\n         }\n-        changed\n-    }\n-}\n-\n-impl<'b, 'tcx> AnalysisDomain<'tcx> for PossibleBorrowerAnalysis<'b, 'tcx> {\n-    type Domain = PossibleBorrowerState;\n-\n-    const NAME: &'static str = \"possible_borrower\";\n-\n-    fn bottom_value(&self, body: &mir::Body<'tcx>) -> Self::Domain {\n-        PossibleBorrowerState::new(body.local_decls.len())\n-    }\n-\n-    fn initialize_start_block(&self, _body: &mir::Body<'tcx>, _entry_set: &mut Self::Domain) {}\n-}\n \n-impl<'b, 'tcx> PossibleBorrowerAnalysis<'b, 'tcx> {\n-    fn new(\n-        tcx: TyCtxt<'tcx>,\n-        body: &'b mir::Body<'tcx>,\n-        possible_origin: FxHashMap<mir::Local, HybridBitSet<mir::Local>>,\n-    ) -> Self {\n-        Self {\n-            tcx,\n-            body,\n-            possible_origin,\n+        let bs = BitSet::new_empty(self.body.local_decls.len());\n+        PossibleBorrowerMap {\n+            map,\n+            maybe_live,\n+            bitset: (bs.clone(), bs),\n         }\n     }\n }\n \n-impl<'b, 'tcx> Analysis<'tcx> for PossibleBorrowerAnalysis<'b, 'tcx> {\n-    fn apply_call_return_effect(\n-        &self,\n-        _state: &mut Self::Domain,\n-        _block: BasicBlock,\n-        _return_places: CallReturnPlaces<'_, 'tcx>,\n-    ) {\n-    }\n-\n-    fn apply_statement_effect(&self, state: &mut Self::Domain, statement: &Statement<'tcx>, _location: Location) {\n-        if let StatementKind::Assign(box (place, rvalue)) = &statement.kind {\n-            let lhs = place.local;\n-            match rvalue {\n-                mir::Rvalue::Ref(_, _, borrowed) => {\n-                    state.add(borrowed.local, lhs);\n-                },\n-                other => {\n-                    if ContainsRegion\n-                        .visit_ty(place.ty(&self.body.local_decls, self.tcx).ty)\n-                        .is_continue()\n-                    {\n-                        return;\n+impl<'a, 'b, 'tcx> mir::visit::Visitor<'tcx> for PossibleBorrowerVisitor<'a, 'b, 'tcx> {\n+    fn visit_assign(&mut self, place: &mir::Place<'tcx>, rvalue: &mir::Rvalue<'_>, _location: mir::Location) {\n+        let lhs = place.local;\n+        match rvalue {\n+            mir::Rvalue::Ref(_, _, borrowed) => {\n+                self.possible_borrower.add(borrowed.local, lhs);\n+            },\n+            other => {\n+                if ContainsRegion\n+                    .visit_ty(place.ty(&self.body.local_decls, self.cx.tcx).ty)\n+                    .is_continue()\n+                {\n+                    return;\n+                }\n+                rvalue_locals(other, |rhs| {\n+                    if lhs != rhs {\n+                        self.possible_borrower.add(rhs, lhs);\n                     }\n-                    rvalue_locals(other, |rhs| {\n-                        if lhs != rhs {\n-                            state.add(rhs, lhs);\n-                        }\n-                    });\n-                },\n-            }\n+                });\n+            },\n         }\n     }\n \n-    fn apply_terminator_effect(&self, state: &mut Self::Domain, terminator: &Terminator<'tcx>, _location: Location) {\n+    fn visit_terminator(&mut self, terminator: &mir::Terminator<'_>, _loc: mir::Location) {\n         if let mir::TerminatorKind::Call {\n             args,\n             destination: mir::Place { local: dest, .. },\n@@ -171,10 +123,10 @@ impl<'b, 'tcx> Analysis<'tcx> for PossibleBorrowerAnalysis<'b, 'tcx> {\n \n             for y in mutable_variables {\n                 for x in &immutable_borrowers {\n-                    state.add(*x, y);\n+                    self.possible_borrower.add(*x, y);\n                 }\n                 for x in &mutable_borrowers {\n-                    state.add(*x, y);\n+                    self.possible_borrower.add(*x, y);\n                 }\n             }\n         }\n@@ -210,98 +162,73 @@ fn rvalue_locals(rvalue: &mir::Rvalue<'_>, mut visit: impl FnMut(mir::Local)) {\n     }\n }\n \n-/// Result of `PossibleBorrowerAnalysis`.\n+/// Result of `PossibleBorrowerVisitor`.\n #[allow(clippy::module_name_repetitions)]\n pub struct PossibleBorrowerMap<'b, 'tcx> {\n-    body: &'b mir::Body<'tcx>,\n-    possible_borrower: ResultsCursor<'b, 'tcx, PossibleBorrowerAnalysis<'b, 'tcx>>,\n-    maybe_live: ResultsCursor<'b, 'tcx, MaybeStorageLive<'b>>,\n-    pushed: BitSet<Local>,\n-    stack: Vec<Local>,\n+    /// Mapping `Local -> its possible borrowers`\n+    pub map: FxHashMap<mir::Local, HybridBitSet<mir::Local>>,\n+    maybe_live: ResultsCursor<'b, 'tcx, MaybeStorageLive>,\n+    // Caches to avoid allocation of `BitSet` on every query\n+    pub bitset: (BitSet<mir::Local>, BitSet<mir::Local>),\n }\n \n-impl<'b, 'tcx> PossibleBorrowerMap<'b, 'tcx> {\n-    pub fn new(cx: &LateContext<'tcx>, mir: &'b mir::Body<'tcx>) -> Self {\n+impl<'a, 'b, 'tcx> PossibleBorrowerMap<'b, 'tcx> {\n+    pub fn new(cx: &'a LateContext<'tcx>, mir: &'b mir::Body<'tcx>) -> Self {\n         let possible_origin = {\n             let mut vis = PossibleOriginVisitor::new(mir);\n             vis.visit_body(mir);\n             vis.into_map(cx)\n         };\n-        let possible_borrower = PossibleBorrowerAnalysis::new(cx.tcx, mir, possible_origin)\n+        let maybe_storage_live_result = MaybeStorageLive::new(BitSet::new_empty(mir.local_decls.len()))\n             .into_engine(cx.tcx, mir)\n-            .pass_name(\"possible_borrower\")\n+            .pass_name(\"redundant_clone\")\n             .iterate_to_fixpoint()\n             .into_results_cursor(mir);\n-        let maybe_live = MaybeStorageLive::new(Cow::Owned(BitSet::new_empty(mir.local_decls.len())))\n-            .into_engine(cx.tcx, mir)\n-            .pass_name(\"possible_borrower\")\n-            .iterate_to_fixpoint()\n-            .into_results_cursor(mir);\n-        PossibleBorrowerMap {\n-            body: mir,\n-            possible_borrower,\n-            maybe_live,\n-            pushed: BitSet::new_empty(mir.local_decls.len()),\n-            stack: Vec::with_capacity(mir.local_decls.len()),\n-        }\n+        let mut vis = PossibleBorrowerVisitor::new(cx, mir, possible_origin);\n+        vis.visit_body(mir);\n+        vis.into_map(cx, maybe_storage_live_result)\n     }\n \n-    /// Returns true if the set of borrowers of `borrowed` living at `at` includes no more than\n-    /// `borrowers`.\n-    /// Notes:\n-    /// 1. It would be nice if `PossibleBorrowerMap` could store `cx` so that `at_most_borrowers`\n-    /// would not require it to be passed in. But a `PossibleBorrowerMap` is stored in `LintPass`\n-    /// `Dereferencing`, which outlives any `LateContext`.\n-    /// 2. In all current uses of `at_most_borrowers`, `borrowers` is a slice of at most two\n-    /// elements. Thus, `borrowers.contains(...)` is effectively a constant-time operation. If\n-    /// `at_most_borrowers`'s uses were to expand beyond this, its implementation might have to be\n-    /// adjusted.\n-    pub fn at_most_borrowers(\n+    /// Returns true if the set of borrowers of `borrowed` living at `at` matches with `borrowers`.\n+    pub fn only_borrowers(&mut self, borrowers: &[mir::Local], borrowed: mir::Local, at: mir::Location) -> bool {\n+        self.bounded_borrowers(borrowers, borrowers, borrowed, at)\n+    }\n+\n+    /// Returns true if the set of borrowers of `borrowed` living at `at` includes at least `below`\n+    /// but no more than `above`.\n+    pub fn bounded_borrowers(\n         &mut self,\n-        cx: &LateContext<'tcx>,\n-        borrowers: &[mir::Local],\n+        below: &[mir::Local],\n+        above: &[mir::Local],\n         borrowed: mir::Local,\n         at: mir::Location,\n     ) -> bool {\n-        if is_copy(cx, self.body.local_decls[borrowed].ty) {\n-            return true;\n-        }\n-\n-        self.possible_borrower.seek_before_primary_effect(at);\n-        self.maybe_live.seek_before_primary_effect(at);\n-\n-        let possible_borrower = &self.possible_borrower.get().map;\n-        let maybe_live = &self.maybe_live;\n-\n-        self.pushed.clear();\n-        self.stack.clear();\n+        self.maybe_live.seek_after_primary_effect(at);\n \n-        if let Some(borrowers) = possible_borrower.get(&borrowed) {\n-            for b in borrowers.iter() {\n-                if self.pushed.insert(b) {\n-                    self.stack.push(b);\n-                }\n+        self.bitset.0.clear();\n+        let maybe_live = &mut self.maybe_live;\n+        if let Some(bitset) = self.map.get(&borrowed) {\n+            for b in bitset.iter().filter(move |b| maybe_live.contains(*b)) {\n+                self.bitset.0.insert(b);\n             }\n         } else {\n-            // Nothing borrows `borrowed` at `at`.\n-            return true;\n+            return false;\n         }\n \n-        while let Some(borrower) = self.stack.pop() {\n-            if maybe_live.contains(borrower) && !borrowers.contains(&borrower) {\n-                return false;\n-            }\n+        self.bitset.1.clear();\n+        for b in below {\n+            self.bitset.1.insert(*b);\n+        }\n \n-            if let Some(borrowers) = possible_borrower.get(&borrower) {\n-                for b in borrowers.iter() {\n-                    if self.pushed.insert(b) {\n-                        self.stack.push(b);\n-                    }\n-                }\n-            }\n+        if !self.bitset.0.superset(&self.bitset.1) {\n+            return false;\n+        }\n+\n+        for b in above {\n+            self.bitset.0.remove(*b);\n         }\n \n-        true\n+        self.bitset.0.is_empty()\n     }\n \n     pub fn local_is_alive_at(&mut self, local: mir::Local, at: mir::Location) -> bool {"}, {"sha": "4cb7f6b687f1195c3bb429b941c8ca256f6534d3", "filename": "tests/ui/needless_borrow.fixed", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5eed9c69ca9fa04a1417f1f14df0bb5bab2fc8c8/tests%2Fui%2Fneedless_borrow.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/5eed9c69ca9fa04a1417f1f14df0bb5bab2fc8c8/tests%2Fui%2Fneedless_borrow.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_borrow.fixed?ref=5eed9c69ca9fa04a1417f1f14df0bb5bab2fc8c8", "patch": "@@ -1,5 +1,5 @@\n // run-rustfix\n-#![feature(custom_inner_attributes, lint_reasons, rustc_private)]\n+#![feature(lint_reasons)]\n #![allow(\n     unused,\n     clippy::uninlined_format_args,\n@@ -491,14 +491,3 @@ mod issue_9782_method_variant {\n         S.foo::<&[u8; 100]>(&a);\n     }\n }\n-\n-extern crate rustc_lint;\n-extern crate rustc_span;\n-\n-#[allow(dead_code)]\n-mod span_lint {\n-    use rustc_lint::{LateContext, Lint, LintContext};\n-    fn foo(cx: &LateContext<'_>, lint: &'static Lint) {\n-        cx.struct_span_lint(lint, rustc_span::Span::default(), \"\", |diag| diag.note(String::new()));\n-    }\n-}"}, {"sha": "9a01190ed8dbd585127276cde688afa19fd07730", "filename": "tests/ui/needless_borrow.rs", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5eed9c69ca9fa04a1417f1f14df0bb5bab2fc8c8/tests%2Fui%2Fneedless_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eed9c69ca9fa04a1417f1f14df0bb5bab2fc8c8/tests%2Fui%2Fneedless_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_borrow.rs?ref=5eed9c69ca9fa04a1417f1f14df0bb5bab2fc8c8", "patch": "@@ -1,5 +1,5 @@\n // run-rustfix\n-#![feature(custom_inner_attributes, lint_reasons, rustc_private)]\n+#![feature(lint_reasons)]\n #![allow(\n     unused,\n     clippy::uninlined_format_args,\n@@ -491,14 +491,3 @@ mod issue_9782_method_variant {\n         S.foo::<&[u8; 100]>(&a);\n     }\n }\n-\n-extern crate rustc_lint;\n-extern crate rustc_span;\n-\n-#[allow(dead_code)]\n-mod span_lint {\n-    use rustc_lint::{LateContext, Lint, LintContext};\n-    fn foo(cx: &LateContext<'_>, lint: &'static Lint) {\n-        cx.struct_span_lint(lint, rustc_span::Span::default(), \"\", |diag| diag.note(&String::new()));\n-    }\n-}"}, {"sha": "d26c317124b8d18d3dc900d31c8badce92e20af1", "filename": "tests/ui/needless_borrow.stderr", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5eed9c69ca9fa04a1417f1f14df0bb5bab2fc8c8/tests%2Fui%2Fneedless_borrow.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5eed9c69ca9fa04a1417f1f14df0bb5bab2fc8c8/tests%2Fui%2Fneedless_borrow.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_borrow.stderr?ref=5eed9c69ca9fa04a1417f1f14df0bb5bab2fc8c8", "patch": "@@ -216,11 +216,5 @@ error: the borrowed expression implements the required traits\n LL |         foo(&a);\n    |             ^^ help: change this to: `a`\n \n-error: the borrowed expression implements the required traits\n-  --> $DIR/needless_borrow.rs:502:85\n-   |\n-LL |         cx.struct_span_lint(lint, rustc_span::Span::default(), \"\", |diag| diag.note(&String::new()));\n-   |                                                                                     ^^^^^^^^^^^^^^ help: change this to: `String::new()`\n-\n-error: aborting due to 37 previous errors\n+error: aborting due to 36 previous errors\n "}, {"sha": "00b427450935d5077a7ff947a78da65c5221ef2b", "filename": "tests/ui/redundant_clone.fixed", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5eed9c69ca9fa04a1417f1f14df0bb5bab2fc8c8/tests%2Fui%2Fredundant_clone.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/5eed9c69ca9fa04a1417f1f14df0bb5bab2fc8c8/tests%2Fui%2Fredundant_clone.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fredundant_clone.fixed?ref=5eed9c69ca9fa04a1417f1f14df0bb5bab2fc8c8", "patch": "@@ -239,9 +239,3 @@ fn false_negative_5707() {\n     let _z = x.clone(); // pr 7346 can't lint on `x`\n     drop(y);\n }\n-\n-#[allow(unused, clippy::manual_retain)]\n-fn possible_borrower_improvements() {\n-    let mut s = String::from(\"foobar\");\n-    s = s.chars().filter(|&c| c != 'o').collect();\n-}"}, {"sha": "f899127db8d04674fab4e5d5282106da2e7721d8", "filename": "tests/ui/redundant_clone.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5eed9c69ca9fa04a1417f1f14df0bb5bab2fc8c8/tests%2Fui%2Fredundant_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eed9c69ca9fa04a1417f1f14df0bb5bab2fc8c8/tests%2Fui%2Fredundant_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fredundant_clone.rs?ref=5eed9c69ca9fa04a1417f1f14df0bb5bab2fc8c8", "patch": "@@ -239,9 +239,3 @@ fn false_negative_5707() {\n     let _z = x.clone(); // pr 7346 can't lint on `x`\n     drop(y);\n }\n-\n-#[allow(unused, clippy::manual_retain)]\n-fn possible_borrower_improvements() {\n-    let mut s = String::from(\"foobar\");\n-    s = s.chars().filter(|&c| c != 'o').to_owned().collect();\n-}"}, {"sha": "782590034d051cb07c2486e07983958809029a77", "filename": "tests/ui/redundant_clone.stderr", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5eed9c69ca9fa04a1417f1f14df0bb5bab2fc8c8/tests%2Fui%2Fredundant_clone.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5eed9c69ca9fa04a1417f1f14df0bb5bab2fc8c8/tests%2Fui%2Fredundant_clone.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fredundant_clone.stderr?ref=5eed9c69ca9fa04a1417f1f14df0bb5bab2fc8c8", "patch": "@@ -179,17 +179,5 @@ note: this value is dropped without further use\n LL |     foo(&x.clone(), move || {\n    |          ^\n \n-error: redundant clone\n-  --> $DIR/redundant_clone.rs:246:40\n-   |\n-LL |     s = s.chars().filter(|&c| c != 'o').to_owned().collect();\n-   |                                        ^^^^^^^^^^^ help: remove this\n-   |\n-note: this value is dropped without further use\n-  --> $DIR/redundant_clone.rs:246:9\n-   |\n-LL |     s = s.chars().filter(|&c| c != 'o').to_owned().collect();\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-\n-error: aborting due to 16 previous errors\n+error: aborting due to 15 previous errors\n "}]}