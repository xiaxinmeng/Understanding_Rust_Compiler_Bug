{"sha": "e0cc22b4bae8007c59fbe58f2c104ecd743d746a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUwY2MyMmI0YmFlODAwN2M1OWZiZTU4ZjJjMTA0ZWNkNzQzZDc0NmE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-05-31T21:14:02Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-05-31T21:14:02Z"}, "message": "Auto merge of #42336 - Mark-Simulacrum:rollup, r=Mark-Simulacrum\n\nRollup of 7 pull requests\n\n- Successful merges: #42126, #42196, #42252, #42277, #42315, #42329, #42330\n- Failed merges:", "tree": {"sha": "8c4084d31f5b5c2cbc0d4fcf7d32fe9f3f6a932f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8c4084d31f5b5c2cbc0d4fcf7d32fe9f3f6a932f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e0cc22b4bae8007c59fbe58f2c104ecd743d746a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e0cc22b4bae8007c59fbe58f2c104ecd743d746a", "html_url": "https://github.com/rust-lang/rust/commit/e0cc22b4bae8007c59fbe58f2c104ecd743d746a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e0cc22b4bae8007c59fbe58f2c104ecd743d746a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fd7b44b78e39c71e5049a210a0c84a8931835cc3", "url": "https://api.github.com/repos/rust-lang/rust/commits/fd7b44b78e39c71e5049a210a0c84a8931835cc3", "html_url": "https://github.com/rust-lang/rust/commit/fd7b44b78e39c71e5049a210a0c84a8931835cc3"}, {"sha": "7f286a8e38258402c6e8e564864ac0132fac2004", "url": "https://api.github.com/repos/rust-lang/rust/commits/7f286a8e38258402c6e8e564864ac0132fac2004", "html_url": "https://github.com/rust-lang/rust/commit/7f286a8e38258402c6e8e564864ac0132fac2004"}], "stats": {"total": 244, "additions": 171, "deletions": 73}, "files": [{"sha": "11a360ff900fe69a97d767e92fd1a4443f3f1608", "filename": "src/libcore/convert.rs", "status": "modified", "additions": 37, "deletions": 1, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/e0cc22b4bae8007c59fbe58f2c104ecd743d746a/src%2Flibcore%2Fconvert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0cc22b4bae8007c59fbe58f2c104ecd743d746a/src%2Flibcore%2Fconvert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fconvert.rs?ref=e0cc22b4bae8007c59fbe58f2c104ecd743d746a", "patch": "@@ -169,6 +169,40 @@ pub trait AsMut<T: ?Sized> {\n /// - [`From<T>`][From]` for U` implies `Into<U> for T`\n /// - [`into`] is reflexive, which means that `Into<T> for T` is implemented\n ///\n+/// # Implementing `Into`\n+///\n+/// There is one exception to implementing `Into`, and it's kind of esoteric.\n+/// If the destination type is not part of the current crate, and it uses a\n+/// generic variable, then you can't implement `From` directly.  For example,\n+/// take this crate:\n+///\n+/// ```compile_fail\n+/// struct Wrapper<T>(Vec<T>);\n+/// impl<T> From<Wrapper<T>> for Vec<T> {\n+///     fn from(w: Wrapper<T>) -> Vec<T> {\n+///         w.0\n+///     }\n+/// }\n+/// ```\n+///\n+/// To fix this, you can implement `Into` directly:\n+///\n+/// ```\n+/// struct Wrapper<T>(Vec<T>);\n+/// impl<T> Into<Vec<T>> for Wrapper<T> {\n+///     fn into(self) -> Vec<T> {\n+///         self.0\n+///     }\n+/// }\n+/// ```\n+///\n+/// This won't always allow the conversion: for example, `try!` and `?`\n+/// always use `From`. However, in most cases, people use `Into` to do the\n+/// conversions, and this will allow that.\n+///\n+/// In almost all cases, you should try to implement `From`, then fall back\n+/// to `Into` if `From` can't be implemented.\n+///\n /// # Examples\n ///\n /// [`String`] implements `Into<Vec<u8>>`:\n@@ -285,9 +319,11 @@ pub trait From<T>: Sized {\n /// Library authors should not directly implement this trait, but should prefer\n /// implementing the [`TryFrom`] trait, which offers greater flexibility and\n /// provides an equivalent `TryInto` implementation for free, thanks to a\n-/// blanket implementation in the standard library.\n+/// blanket implementation in the standard library. For more information on this,\n+/// see the documentation for [`Into`].\n ///\n /// [`TryFrom`]: trait.TryFrom.html\n+/// [`Into`]: trait.Into.html\n #[unstable(feature = \"try_from\", issue = \"33417\")]\n pub trait TryInto<T>: Sized {\n     /// The type returned in the event of a conversion error."}, {"sha": "85149a0f570788272b5658f72a614c5924843141", "filename": "src/libcore/iter/iterator.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e0cc22b4bae8007c59fbe58f2c104ecd743d746a/src%2Flibcore%2Fiter%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0cc22b4bae8007c59fbe58f2c104ecd743d746a/src%2Flibcore%2Fiter%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fiterator.rs?ref=e0cc22b4bae8007c59fbe58f2c104ecd743d746a", "patch": "@@ -130,9 +130,10 @@ pub trait Iterator {\n     ///\n     /// ```\n     /// // an infinite iterator has no upper bound\n+    /// // and the maximum possible lower bound\n     /// let iter = 0..;\n     ///\n-    /// assert_eq!((0, None), iter.size_hint());\n+    /// assert_eq!((usize::max_value(), None), iter.size_hint());\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "c0313333ea9ee41d604afcbc133968fc6606e3b6", "filename": "src/libcore/iter/range.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e0cc22b4bae8007c59fbe58f2c104ecd743d746a/src%2Flibcore%2Fiter%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0cc22b4bae8007c59fbe58f2c104ecd743d746a/src%2Flibcore%2Fiter%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Frange.rs?ref=e0cc22b4bae8007c59fbe58f2c104ecd743d746a", "patch": "@@ -543,6 +543,11 @@ impl<A: Step> Iterator for ops::RangeFrom<A> where\n         mem::swap(&mut n, &mut self.start);\n         Some(n)\n     }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        (usize::MAX, None)\n+    }\n }\n \n #[unstable(feature = \"fused\", issue = \"35602\")]"}, {"sha": "015cc150dc27c52e73d219aa9c7a33d06cd54ad3", "filename": "src/libcore/iter/traits.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e0cc22b4bae8007c59fbe58f2c104ecd743d746a/src%2Flibcore%2Fiter%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0cc22b4bae8007c59fbe58f2c104ecd743d746a/src%2Flibcore%2Fiter%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits.rs?ref=e0cc22b4bae8007c59fbe58f2c104ecd743d746a", "patch": "@@ -109,7 +109,7 @@ pub trait FromIterator<A>: Sized {\n     ///\n     /// See the [module-level documentation] for more.\n     ///\n-    /// [module-level documentation]: trait.FromIterator.html\n+    /// [module-level documentation]: index.html\n     ///\n     /// # Examples\n     ///\n@@ -219,7 +219,7 @@ pub trait IntoIterator {\n     ///\n     /// See the [module-level documentation] for more.\n     ///\n-    /// [module-level documentation]: trait.IntoIterator.html\n+    /// [module-level documentation]: index.html\n     ///\n     /// # Examples\n     ///"}, {"sha": "d11ad76d65dfe9afd19433f4c1156e51e6f31515", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e0cc22b4bae8007c59fbe58f2c104ecd743d746a/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0cc22b4bae8007c59fbe58f2c104ecd743d746a/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=e0cc22b4bae8007c59fbe58f2c104ecd743d746a", "patch": "@@ -220,7 +220,7 @@ pub fn size_of_val<T: ?Sized>(val: &T) -> usize {\n \n /// Returns the [ABI]-required minimum alignment of a type.\n ///\n-/// Every valid address of a value of the type `T` must be a multiple of this number.\n+/// Every reference to a value of the type `T` must be a multiple of this number.\n ///\n /// This is the alignment used for struct fields. It may be smaller than the preferred alignment.\n ///\n@@ -243,7 +243,7 @@ pub fn min_align_of<T>() -> usize {\n \n /// Returns the [ABI]-required minimum alignment of the type of the value that `val` points to.\n ///\n-/// Every valid address of a value of the type `T` must be a multiple of this number.\n+/// Every reference to a value of the type `T` must be a multiple of this number.\n ///\n /// [ABI]: https://en.wikipedia.org/wiki/Application_binary_interface\n ///\n@@ -264,7 +264,7 @@ pub fn min_align_of_val<T: ?Sized>(val: &T) -> usize {\n \n /// Returns the [ABI]-required minimum alignment of a type.\n ///\n-/// Every valid address of a value of the type `T` must be a multiple of this number.\n+/// Every reference to a value of the type `T` must be a multiple of this number.\n ///\n /// This is the alignment used for struct fields. It may be smaller than the preferred alignment.\n ///\n@@ -285,7 +285,7 @@ pub fn align_of<T>() -> usize {\n \n /// Returns the [ABI]-required minimum alignment of the type of the value that `val` points to.\n ///\n-/// Every valid address of a value of the type `T` must be a multiple of this number.\n+/// Every reference to a value of the type `T` must be a multiple of this number.\n ///\n /// [ABI]: https://en.wikipedia.org/wiki/Application_binary_interface\n ///"}, {"sha": "44d5936c63edd5c6d6e0b256a4401dc3e50a3824", "filename": "src/libcore/tests/iter.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e0cc22b4bae8007c59fbe58f2c104ecd743d746a/src%2Flibcore%2Ftests%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0cc22b4bae8007c59fbe58f2c104ecd743d746a/src%2Flibcore%2Ftests%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fiter.rs?ref=e0cc22b4bae8007c59fbe58f2c104ecd743d746a", "patch": "@@ -764,6 +764,7 @@ fn test_iterator_size_hint() {\n     let v2 = &[10, 11, 12];\n     let vi = v.iter();\n \n+    assert_eq!((0..).size_hint(), (usize::MAX, None));\n     assert_eq!(c.size_hint(), (usize::MAX, None));\n     assert_eq!(vi.clone().size_hint(), (10, Some(10)));\n "}, {"sha": "a6dbbee79a48c83dfa6ab3651e4259f97d03eafc", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e0cc22b4bae8007c59fbe58f2c104ecd743d746a/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0cc22b4bae8007c59fbe58f2c104ecd743d746a/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=e0cc22b4bae8007c59fbe58f2c104ecd743d746a", "patch": "@@ -1682,7 +1682,11 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     {\n         if let InferTables::InProgress(tables) = self.tables {\n             if let Some(id) = self.tcx.hir.as_local_node_id(def_id) {\n-                return tables.borrow().closure_kinds.get(&id).cloned();\n+                return tables.borrow()\n+                             .closure_kinds\n+                             .get(&id)\n+                             .cloned()\n+                             .map(|(kind, _)| kind);\n             }\n         }\n "}, {"sha": "589489b49b4fd1a629e51a8875df09f66fbf4742", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 4, "deletions": 14, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e0cc22b4bae8007c59fbe58f2c104ecd743d746a/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0cc22b4bae8007c59fbe58f2c104ecd743d746a/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=e0cc22b4bae8007c59fbe58f2c104ecd743d746a", "patch": "@@ -1354,7 +1354,7 @@ pub fn build_session_options_and_crate_config(matches: &getopts::Matches)\n     };\n \n     let unparsed_crate_types = matches.opt_strs(\"crate-type\");\n-    let (crate_types, emit_metadata) = parse_crate_types_from_list(unparsed_crate_types)\n+    let crate_types = parse_crate_types_from_list(unparsed_crate_types)\n         .unwrap_or_else(|e| early_error(error_format, &e[..]));\n \n     let mut lint_opts = vec![];\n@@ -1402,9 +1402,7 @@ pub fn build_session_options_and_crate_config(matches: &getopts::Matches)\n             }\n         }\n     };\n-    if emit_metadata {\n-        output_types.insert(OutputType::Metadata, None);\n-    } else if output_types.is_empty() {\n+    if output_types.is_empty() {\n         output_types.insert(OutputType::Exe, None);\n     }\n \n@@ -1629,9 +1627,8 @@ pub fn build_session_options_and_crate_config(matches: &getopts::Matches)\n }\n \n pub fn parse_crate_types_from_list(list_list: Vec<String>)\n-                                   -> Result<(Vec<CrateType>, bool), String> {\n+                                   -> Result<Vec<CrateType>, String> {\n     let mut crate_types: Vec<CrateType> = Vec::new();\n-    let mut emit_metadata = false;\n     for unparsed_crate_type in &list_list {\n         for part in unparsed_crate_type.split(',') {\n             let new_part = match part {\n@@ -1642,13 +1639,6 @@ pub fn parse_crate_types_from_list(list_list: Vec<String>)\n                 \"cdylib\"    => CrateTypeCdylib,\n                 \"bin\"       => CrateTypeExecutable,\n                 \"proc-macro\" => CrateTypeProcMacro,\n-                // FIXME(#38640) remove this when Cargo is fixed.\n-                \"metadata\"  => {\n-                    early_warn(ErrorOutputType::default(), \"--crate-type=metadata is deprecated, \\\n-                                                            prefer --emit=metadata\");\n-                    emit_metadata = true;\n-                    CrateTypeRlib\n-                }\n                 _ => {\n                     return Err(format!(\"unknown crate type: `{}`\",\n                                        part));\n@@ -1660,7 +1650,7 @@ pub fn parse_crate_types_from_list(list_list: Vec<String>)\n         }\n     }\n \n-    return Ok((crate_types, emit_metadata));\n+    Ok(crate_types)\n }\n \n pub mod nightly_options {"}, {"sha": "e3d7aeb22e1fad5390d584d224fbac8bfffd3645", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e0cc22b4bae8007c59fbe58f2c104ecd743d746a/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0cc22b4bae8007c59fbe58f2c104ecd743d746a/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=e0cc22b4bae8007c59fbe58f2c104ecd743d746a", "patch": "@@ -58,6 +58,7 @@ use syntax::abi;\n use syntax::ast::{self, Name, NodeId};\n use syntax::attr;\n use syntax::symbol::{Symbol, keywords};\n+use syntax_pos::Span;\n \n use hir;\n \n@@ -229,8 +230,9 @@ pub struct TypeckTables<'tcx> {\n     /// Records the type of each closure.\n     pub closure_tys: NodeMap<ty::PolyFnSig<'tcx>>,\n \n-    /// Records the kind of each closure.\n-    pub closure_kinds: NodeMap<ty::ClosureKind>,\n+    /// Records the kind of each closure and the span and name of the variable\n+    /// that caused the closure to be this kind.\n+    pub closure_kinds: NodeMap<(ty::ClosureKind, Option<(Span, ast::Name)>)>,\n \n     /// For each fn, records the \"liberated\" types of its arguments\n     /// and return type. Liberated means that all bound regions"}, {"sha": "9b084acc1938fd39eedea5e390239e564171fb1f", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e0cc22b4bae8007c59fbe58f2c104ecd743d746a/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0cc22b4bae8007c59fbe58f2c104ecd743d746a/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=e0cc22b4bae8007c59fbe58f2c104ecd743d746a", "patch": "@@ -39,8 +39,6 @@ use rustc::middle::free_region::RegionRelations;\n use rustc::ty::{self, TyCtxt};\n use rustc::ty::maps::Providers;\n \n-use syntax_pos::DUMMY_SP;\n-\n use std::fmt;\n use std::rc::Rc;\n use std::hash::{Hash, Hasher};\n@@ -587,9 +585,15 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                     verb, msg, nl);\n                 let need_note = match lp.ty.sty {\n                     ty::TypeVariants::TyClosure(id, _) => {\n-                        if let Ok(ty::ClosureKind::FnOnce) =\n-                           ty::queries::closure_kind::try_get(self.tcx, DUMMY_SP, id) {\n-                            err.help(\"closure was moved because it only implements `FnOnce`\");\n+                        let node_id = self.tcx.hir.as_local_node_id(id).unwrap();\n+                        if let Some(&(ty::ClosureKind::FnOnce, Some((span, name)))) =\n+                            self.tables.closure_kinds.get(&node_id)\n+                        {\n+                            err.span_note(span, &format!(\n+                                \"closure cannot be invoked more than once because \\\n+                                it moves the variable `{}` out of its environment\",\n+                                name\n+                            ));\n                             false\n                         } else {\n                             true"}, {"sha": "c2e8269aafef94091e5b2c437c6bb78cc3879713", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0cc22b4bae8007c59fbe58f2c104ecd743d746a/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0cc22b4bae8007c59fbe58f2c104ecd743d746a/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=e0cc22b4bae8007c59fbe58f2c104ecd743d746a", "patch": "@@ -103,7 +103,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         self.tables.borrow_mut().closure_tys.insert(expr.id, sig);\n         match opt_kind {\n             Some(kind) => {\n-                self.tables.borrow_mut().closure_kinds.insert(expr.id, kind);\n+                self.tables.borrow_mut().closure_kinds.insert(expr.id, (kind, None));\n             }\n             None => {}\n         }"}, {"sha": "1a1a9361a89f9929cec3266baa18ceb59676ee12", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0cc22b4bae8007c59fbe58f2c104ecd743d746a/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0cc22b4bae8007c59fbe58f2c104ecd743d746a/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=e0cc22b4bae8007c59fbe58f2c104ecd743d746a", "patch": "@@ -814,7 +814,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n \n             let closure_kinds = &self.tables.borrow().closure_kinds;\n             let closure_kind = match closure_kinds.get(&closure_id) {\n-                Some(&k) => k,\n+                Some(&(k, _)) => k,\n                 None => {\n                     return Err(MethodError::ClosureAmbiguity(trait_def_id));\n                 }"}, {"sha": "3a6fd51693e73539bbc5d085a4727e2a292bd9d2", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0cc22b4bae8007c59fbe58f2c104ecd743d746a/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0cc22b4bae8007c59fbe58f2c104ecd743d746a/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=e0cc22b4bae8007c59fbe58f2c104ecd743d746a", "patch": "@@ -702,7 +702,7 @@ fn closure_kind<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                           def_id: DefId)\n                           -> ty::ClosureKind {\n     let node_id = tcx.hir.as_local_node_id(def_id).unwrap();\n-    tcx.typeck_tables_of(def_id).closure_kinds[&node_id]\n+    tcx.typeck_tables_of(def_id).closure_kinds[&node_id].0\n }\n \n fn adt_destructor<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,"}, {"sha": "114290c52d195469dc23d6fe2b92d29ce182caab", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 38, "deletions": 19, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/e0cc22b4bae8007c59fbe58f2c104ecd743d746a/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0cc22b4bae8007c59fbe58f2c104ecd743d746a/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=e0cc22b4bae8007c59fbe58f2c104ecd743d746a", "patch": "@@ -74,7 +74,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n struct SeedBorrowKind<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     fcx: &'a FnCtxt<'a, 'gcx, 'tcx>,\n-    temp_closure_kinds: NodeMap<ty::ClosureKind>,\n+    temp_closure_kinds: NodeMap<(ty::ClosureKind, Option<(Span, ast::Name)>)>,\n }\n \n impl<'a, 'gcx, 'tcx> Visitor<'gcx> for SeedBorrowKind<'a, 'gcx, 'tcx> {\n@@ -107,7 +107,7 @@ impl<'a, 'gcx, 'tcx> SeedBorrowKind<'a, 'gcx, 'tcx> {\n                      capture_clause: hir::CaptureClause)\n     {\n         if !self.fcx.tables.borrow().closure_kinds.contains_key(&expr.id) {\n-            self.temp_closure_kinds.insert(expr.id, ty::ClosureKind::Fn);\n+            self.temp_closure_kinds.insert(expr.id, (ty::ClosureKind::Fn, None));\n             debug!(\"check_closure: adding closure {:?} as Fn\", expr.id);\n         }\n \n@@ -143,12 +143,12 @@ impl<'a, 'gcx, 'tcx> SeedBorrowKind<'a, 'gcx, 'tcx> {\n \n struct AdjustBorrowKind<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     fcx: &'a FnCtxt<'a, 'gcx, 'tcx>,\n-    temp_closure_kinds: NodeMap<ty::ClosureKind>,\n+    temp_closure_kinds: NodeMap<(ty::ClosureKind, Option<(Span, ast::Name)>)>,\n }\n \n impl<'a, 'gcx, 'tcx> AdjustBorrowKind<'a, 'gcx, 'tcx> {\n     fn new(fcx: &'a FnCtxt<'a, 'gcx, 'tcx>,\n-           temp_closure_kinds: NodeMap<ty::ClosureKind>)\n+           temp_closure_kinds: NodeMap<(ty::ClosureKind, Option<(Span, ast::Name)>)>)\n            -> AdjustBorrowKind<'a, 'gcx, 'tcx> {\n         AdjustBorrowKind { fcx: fcx, temp_closure_kinds: temp_closure_kinds }\n     }\n@@ -211,8 +211,8 @@ impl<'a, 'gcx, 'tcx> AdjustBorrowKind<'a, 'gcx, 'tcx> {\n \n         // If we are also inferred the closure kind here, update the\n         // main table and process any deferred resolutions.\n-        if let Some(&kind) = self.temp_closure_kinds.get(&id) {\n-            self.fcx.tables.borrow_mut().closure_kinds.insert(id, kind);\n+        if let Some(&(kind, context)) = self.temp_closure_kinds.get(&id) {\n+            self.fcx.tables.borrow_mut().closure_kinds.insert(id, (kind, context));\n             let closure_def_id = self.fcx.tcx.hir.local_def_id(id);\n             debug!(\"closure_kind({:?}) = {:?}\", closure_def_id, kind);\n \n@@ -272,6 +272,8 @@ impl<'a, 'gcx, 'tcx> AdjustBorrowKind<'a, 'gcx, 'tcx> {\n             euv::Move(_) => { }\n         }\n \n+        let tcx = self.fcx.tcx;\n+\n         // watch out for a move of the deref of a borrowed pointer;\n         // for that to be legal, the upvar would have to be borrowed\n         // by value instead\n@@ -289,7 +291,9 @@ impl<'a, 'gcx, 'tcx> AdjustBorrowKind<'a, 'gcx, 'tcx> {\n \n                         // to move out of an upvar, this must be a FnOnce closure\n                         self.adjust_closure_kind(upvar_id.closure_expr_id,\n-                                                 ty::ClosureKind::FnOnce);\n+                                                 ty::ClosureKind::FnOnce,\n+                                                 guarantor.span,\n+                                                 tcx.hir.name(upvar_id.var_id));\n \n                         let upvar_capture_map =\n                             &mut self.fcx.tables.borrow_mut().upvar_capture_map;\n@@ -303,7 +307,9 @@ impl<'a, 'gcx, 'tcx> AdjustBorrowKind<'a, 'gcx, 'tcx> {\n                         // to be a FnOnce closure to permit moves out\n                         // of the environment.\n                         self.adjust_closure_kind(upvar_id.closure_expr_id,\n-                                                 ty::ClosureKind::FnOnce);\n+                                                 ty::ClosureKind::FnOnce,\n+                                                 guarantor.span,\n+                                                 tcx.hir.name(upvar_id.var_id));\n                     }\n                     mc::NoteNone => {\n                     }\n@@ -331,7 +337,7 @@ impl<'a, 'gcx, 'tcx> AdjustBorrowKind<'a, 'gcx, 'tcx> {\n \n             Categorization::Deref(base, _, mc::BorrowedPtr(..)) |\n             Categorization::Deref(base, _, mc::Implicit(..)) => {\n-                if !self.try_adjust_upvar_deref(&cmt.note, ty::MutBorrow) {\n+                if !self.try_adjust_upvar_deref(cmt, ty::MutBorrow) {\n                     // assignment to deref of an `&mut`\n                     // borrowed pointer implies that the\n                     // pointer itself must be unique, but not\n@@ -365,7 +371,7 @@ impl<'a, 'gcx, 'tcx> AdjustBorrowKind<'a, 'gcx, 'tcx> {\n \n             Categorization::Deref(base, _, mc::BorrowedPtr(..)) |\n             Categorization::Deref(base, _, mc::Implicit(..)) => {\n-                if !self.try_adjust_upvar_deref(&cmt.note, ty::UniqueImmBorrow) {\n+                if !self.try_adjust_upvar_deref(cmt, ty::UniqueImmBorrow) {\n                     // for a borrowed pointer to be unique, its\n                     // base must be unique\n                     self.adjust_upvar_borrow_kind_for_unique(base);\n@@ -382,7 +388,7 @@ impl<'a, 'gcx, 'tcx> AdjustBorrowKind<'a, 'gcx, 'tcx> {\n     }\n \n     fn try_adjust_upvar_deref(&mut self,\n-                              note: &mc::Note,\n+                              cmt: mc::cmt<'tcx>,\n                               borrow_kind: ty::BorrowKind)\n                               -> bool\n     {\n@@ -394,7 +400,9 @@ impl<'a, 'gcx, 'tcx> AdjustBorrowKind<'a, 'gcx, 'tcx> {\n             ty::ImmBorrow => false,\n         });\n \n-        match *note {\n+        let tcx = self.fcx.tcx;\n+\n+        match cmt.note {\n             mc::NoteUpvarRef(upvar_id) => {\n                 // if this is an implicit deref of an\n                 // upvar, then we need to modify the\n@@ -407,15 +415,21 @@ impl<'a, 'gcx, 'tcx> AdjustBorrowKind<'a, 'gcx, 'tcx> {\n                 }\n \n                 // also need to be in an FnMut closure since this is not an ImmBorrow\n-                self.adjust_closure_kind(upvar_id.closure_expr_id, ty::ClosureKind::FnMut);\n+                self.adjust_closure_kind(upvar_id.closure_expr_id,\n+                                         ty::ClosureKind::FnMut,\n+                                         cmt.span,\n+                                         tcx.hir.name(upvar_id.var_id));\n \n                 true\n             }\n             mc::NoteClosureEnv(upvar_id) => {\n                 // this kind of deref occurs in a `move` closure, or\n                 // for a by-value upvar; in either case, to mutate an\n                 // upvar, we need to be an FnMut closure\n-                self.adjust_closure_kind(upvar_id.closure_expr_id, ty::ClosureKind::FnMut);\n+                self.adjust_closure_kind(upvar_id.closure_expr_id,\n+                                         ty::ClosureKind::FnMut,\n+                                         cmt.span,\n+                                         tcx.hir.name(upvar_id.var_id));\n \n                 true\n             }\n@@ -462,11 +476,13 @@ impl<'a, 'gcx, 'tcx> AdjustBorrowKind<'a, 'gcx, 'tcx> {\n \n     fn adjust_closure_kind(&mut self,\n                            closure_id: ast::NodeId,\n-                           new_kind: ty::ClosureKind) {\n-        debug!(\"adjust_closure_kind(closure_id={}, new_kind={:?})\",\n-               closure_id, new_kind);\n+                           new_kind: ty::ClosureKind,\n+                           upvar_span: Span,\n+                           var_name: ast::Name) {\n+        debug!(\"adjust_closure_kind(closure_id={}, new_kind={:?}, upvar_span={:?}, var_name={})\",\n+               closure_id, new_kind, upvar_span, var_name);\n \n-        if let Some(&existing_kind) = self.temp_closure_kinds.get(&closure_id) {\n+        if let Some(&(existing_kind, _)) = self.temp_closure_kinds.get(&closure_id) {\n             debug!(\"adjust_closure_kind: closure_id={}, existing_kind={:?}, new_kind={:?}\",\n                    closure_id, existing_kind, new_kind);\n \n@@ -482,7 +498,10 @@ impl<'a, 'gcx, 'tcx> AdjustBorrowKind<'a, 'gcx, 'tcx> {\n                 (ty::ClosureKind::Fn, ty::ClosureKind::FnOnce) |\n                 (ty::ClosureKind::FnMut, ty::ClosureKind::FnOnce) => {\n                     // new kind is stronger than the old kind\n-                    self.temp_closure_kinds.insert(closure_id, new_kind);\n+                    self.temp_closure_kinds.insert(\n+                        closure_id,\n+                        (new_kind, Some((upvar_span, var_name)))\n+                    );\n                 }\n             }\n         }"}, {"sha": "936a2e8b2e1be93ae0c9596d8da869a95e91e233", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 23, "deletions": 19, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/e0cc22b4bae8007c59fbe58f2c104ecd743d746a/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0cc22b4bae8007c59fbe58f2c104ecd743d746a/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=e0cc22b4bae8007c59fbe58f2c104ecd743d746a", "patch": "@@ -698,24 +698,6 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    pub fn check_contextual_keyword(&mut self, ident: Ident) -> bool {\n-        self.expected_tokens.push(TokenType::Token(token::Ident(ident)));\n-        if let token::Ident(ref cur_ident) = self.token {\n-            cur_ident.name == ident.name\n-        } else {\n-            false\n-        }\n-    }\n-\n-    pub fn eat_contextual_keyword(&mut self, ident: Ident) -> bool {\n-        if self.check_contextual_keyword(ident) {\n-            self.bump();\n-            true\n-        } else {\n-            false\n-        }\n-    }\n-\n     /// If the given word is not a keyword, signal an error.\n     /// If the next token is not the given word, signal an error.\n     /// Otherwise, eat it.\n@@ -3755,6 +3737,28 @@ impl<'a> Parser<'a> {\n         self.look_ahead(1, |t| t.is_ident() && !t.is_any_keyword())\n     }\n \n+    fn is_defaultness(&self) -> bool {\n+        // `pub` is included for better error messages\n+        self.token.is_keyword(keywords::Default) &&\n+        self.look_ahead(1, |t| t.is_keyword(keywords::Impl) ||\n+                        t.is_keyword(keywords::Const) ||\n+                        t.is_keyword(keywords::Fn) ||\n+                        t.is_keyword(keywords::Unsafe) ||\n+                        t.is_keyword(keywords::Extern) ||\n+                        t.is_keyword(keywords::Type) ||\n+                        t.is_keyword(keywords::Pub))\n+    }\n+\n+    fn eat_defaultness(&mut self) -> bool {\n+        let is_defaultness = self.is_defaultness();\n+        if is_defaultness {\n+            self.bump()\n+        } else {\n+            self.expected_tokens.push(TokenType::Keyword(keywords::Default));\n+        }\n+        is_defaultness\n+    }\n+\n     fn eat_macro_def(&mut self, attrs: &[Attribute], vis: &Visibility)\n                      -> PResult<'a, Option<P<Item>>> {\n         let lo = self.span;\n@@ -5229,7 +5233,7 @@ impl<'a> Parser<'a> {\n \n     /// Parse defaultness: DEFAULT or nothing\n     fn parse_defaultness(&mut self) -> PResult<'a, Defaultness> {\n-        if self.eat_contextual_keyword(keywords::Default.ident()) {\n+        if self.eat_defaultness() {\n             Ok(Defaultness::Default)\n         } else {\n             Ok(Defaultness::Final)"}, {"sha": "028d59a19dd6496e9f02b37a91f1848af393f419", "filename": "src/test/run-pass/macro-named-default.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/e0cc22b4bae8007c59fbe58f2c104ecd743d746a/src%2Ftest%2Frun-pass%2Fmacro-named-default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0cc22b4bae8007c59fbe58f2c104ecd743d746a/src%2Ftest%2Frun-pass%2Fmacro-named-default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-named-default.rs?ref=e0cc22b4bae8007c59fbe58f2c104ecd743d746a", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+macro_rules! default {\n+    ($($x:tt)*) => { $($x)* }\n+}\n+\n+default! {\n+    struct A;\n+}\n+\n+impl A {\n+    default! {\n+        fn foo(&self) {}\n+    }\n+}\n+\n+fn main() {\n+    A.foo();\n+}"}, {"sha": "409964082f2b6582302fad782c72d9932e0936a6", "filename": "src/test/ui/fn_once-moved.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e0cc22b4bae8007c59fbe58f2c104ecd743d746a/src%2Ftest%2Fui%2Ffn_once-moved.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0cc22b4bae8007c59fbe58f2c104ecd743d746a/src%2Ftest%2Fui%2Ffn_once-moved.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffn_once-moved.rs?ref=e0cc22b4bae8007c59fbe58f2c104ecd743d746a", "patch": "@@ -20,5 +20,6 @@ fn main() {\n     debug_dump_dict();\n     debug_dump_dict();\n     //~^ ERROR use of moved value: `debug_dump_dict`\n-    //~| NOTE closure was moved because it only implements `FnOnce`\n+    //~| NOTE closure cannot be invoked more than once because it moves the\n+    //~| variable `dict` out of its environment\n }"}, {"sha": "27b7d91d1d4b63eb3fdf74074f5bf91f7182a026", "filename": "src/test/ui/fn_once-moved.stderr", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e0cc22b4bae8007c59fbe58f2c104ecd743d746a/src%2Ftest%2Fui%2Ffn_once-moved.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e0cc22b4bae8007c59fbe58f2c104ecd743d746a/src%2Ftest%2Fui%2Ffn_once-moved.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffn_once-moved.stderr?ref=e0cc22b4bae8007c59fbe58f2c104ecd743d746a", "patch": "@@ -6,7 +6,11 @@ error[E0382]: use of moved value: `debug_dump_dict`\n 21 |     debug_dump_dict();\n    |     ^^^^^^^^^^^^^^^ value used here after move\n    |\n-   = help: closure was moved because it only implements `FnOnce`\n+note: closure cannot be invoked more than once because it moves the variable `dict` out of its environment\n+  --> $DIR/fn_once-moved.rs:16:29\n+   |\n+16 |         for (key, value) in dict {\n+   |                             ^^^^\n \n error: aborting due to previous error(s)\n "}]}