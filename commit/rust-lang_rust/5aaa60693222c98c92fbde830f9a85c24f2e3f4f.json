{"sha": "5aaa60693222c98c92fbde830f9a85c24f2e3f4f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVhYWE2MDY5MzIyMmM5OGM5MmZiZGU4MzBmOWE4NWMyNGYyZTNmNGY=", "commit": {"author": {"name": "Piotr Czarnecki", "email": "pioczarn@gmail.com", "date": "2014-08-25T13:26:18Z"}, "committer": {"name": "Piotr Czarnecki", "email": "pioczarn@gmail.com", "date": "2014-09-09T19:34:41Z"}, "message": "Optimize for the most common cases of `format!`\n\nFormat specs are ignored and not stored in case they're all default.\nRestore default formatting parameters during iteration.\nPass `None` instead of empty slices of format specs to take advantage\nof non-nullable pointer optimization.\n\nGenerate a call to one of two functions of `fmt::Argument`.", "tree": {"sha": "8e9008e1c6e88131acd62ed5c6cb9977962101cf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8e9008e1c6e88131acd62ed5c6cb9977962101cf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5aaa60693222c98c92fbde830f9a85c24f2e3f4f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5aaa60693222c98c92fbde830f9a85c24f2e3f4f", "html_url": "https://github.com/rust-lang/rust/commit/5aaa60693222c98c92fbde830f9a85c24f2e3f4f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5aaa60693222c98c92fbde830f9a85c24f2e3f4f/comments", "author": {"login": "pczarn", "id": 3356767, "node_id": "MDQ6VXNlcjMzNTY3Njc=", "avatar_url": "https://avatars.githubusercontent.com/u/3356767?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pczarn", "html_url": "https://github.com/pczarn", "followers_url": "https://api.github.com/users/pczarn/followers", "following_url": "https://api.github.com/users/pczarn/following{/other_user}", "gists_url": "https://api.github.com/users/pczarn/gists{/gist_id}", "starred_url": "https://api.github.com/users/pczarn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pczarn/subscriptions", "organizations_url": "https://api.github.com/users/pczarn/orgs", "repos_url": "https://api.github.com/users/pczarn/repos", "events_url": "https://api.github.com/users/pczarn/events{/privacy}", "received_events_url": "https://api.github.com/users/pczarn/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pczarn", "id": 3356767, "node_id": "MDQ6VXNlcjMzNTY3Njc=", "avatar_url": "https://avatars.githubusercontent.com/u/3356767?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pczarn", "html_url": "https://github.com/pczarn", "followers_url": "https://api.github.com/users/pczarn/followers", "following_url": "https://api.github.com/users/pczarn/following{/other_user}", "gists_url": "https://api.github.com/users/pczarn/gists{/gist_id}", "starred_url": "https://api.github.com/users/pczarn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pczarn/subscriptions", "organizations_url": "https://api.github.com/users/pczarn/orgs", "repos_url": "https://api.github.com/users/pczarn/repos", "events_url": "https://api.github.com/users/pczarn/events{/privacy}", "received_events_url": "https://api.github.com/users/pczarn/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "696367fb8de63a3ff264c65981457b9fbd0e7b06", "url": "https://api.github.com/repos/rust-lang/rust/commits/696367fb8de63a3ff264c65981457b9fbd0e7b06", "html_url": "https://github.com/rust-lang/rust/commit/696367fb8de63a3ff264c65981457b9fbd0e7b06"}], "stats": {"total": 180, "additions": 125, "deletions": 55}, "files": [{"sha": "be75bfec32c86dd9fb172a5e42ce8dbbee0c39fd", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 52, "deletions": 6, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/5aaa60693222c98c92fbde830f9a85c24f2e3f4f/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5aaa60693222c98c92fbde830f9a85c24f2e3f4f/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=5aaa60693222c98c92fbde830f9a85c24f2e3f4f", "patch": "@@ -116,11 +116,25 @@ impl<'a> Arguments<'a> {\n     #[cfg(not(stage0))]\n     #[doc(hidden)] #[inline]\n     pub unsafe fn new<'a>(pieces: &'static [&'static str],\n-                          fmt: &'static [rt::Argument<'static>],\n                           args: &'a [Argument<'a>]) -> Arguments<'a> {\n         Arguments {\n             pieces: mem::transmute(pieces),\n-            fmt: mem::transmute(fmt),\n+            fmt: None,\n+            args: args\n+        }\n+    }\n+\n+    /// This function is used to specify nonstandard formatting parameters.\n+    /// The `pieces` array must be at least as long as `fmt` to construct\n+    /// a valid Arguments structure.\n+    #[cfg(not(stage0))]\n+    #[doc(hidden)] #[inline]\n+    pub unsafe fn with_placeholders<'a>(pieces: &'static [&'static str],\n+                                        fmt: &'static [rt::Argument<'static>],\n+                                        args: &'a [Argument<'a>]) -> Arguments<'a> {\n+        Arguments {\n+            pieces: mem::transmute(pieces),\n+            fmt: Some(mem::transmute(fmt)),\n             args: args\n         }\n     }\n@@ -144,8 +158,14 @@ impl<'a> Arguments<'a> {\n /// and `format` functions can be safely performed.\n #[cfg(not(stage0))]\n pub struct Arguments<'a> {\n+    // Format string pieces to print.\n     pieces: &'a [&'a str],\n-    fmt: &'a [rt::Argument<'a>],\n+\n+    // Placeholder specs, or `None` if all specs are default (as in \"{}{}\").\n+    fmt: Option<&'a [rt::Argument<'a>]>,\n+\n+    // Dynamic arguments for interpolation, to be interleaved with string\n+    // pieces. (Every argument is preceded by a string piece.)\n     args: &'a [Argument<'a>],\n }\n \n@@ -276,6 +296,18 @@ uniform_fn_call_workaround! {\n     secret_upper_exp, UpperExp;\n }\n \n+#[cfg(not(stage0))]\n+static DEFAULT_ARGUMENT: rt::Argument<'static> = rt::Argument {\n+    position: rt::ArgumentNext,\n+    format: rt::FormatSpec {\n+        fill: ' ',\n+        align: rt::AlignUnknown,\n+        flags: 0,\n+        precision: rt::CountImplied,\n+        width: rt::CountImplied,\n+    }\n+};\n+\n /// The `write` function takes an output stream, a precompiled format string,\n /// and a list of arguments. The arguments will be formatted according to the\n /// specified format string into the output stream provided.\n@@ -299,11 +331,25 @@ pub fn write(output: &mut FormatWriter, args: &Arguments) -> Result {\n \n     let mut pieces = args.pieces.iter();\n \n-    for arg in args.fmt.iter() {\n-        try!(formatter.buf.write(pieces.next().unwrap().as_bytes()));\n-        try!(formatter.run(arg));\n+    match args.fmt {\n+        None => {\n+            // We can use default formatting parameters for all arguments.\n+            for _ in range(0, args.args.len()) {\n+                try!(formatter.buf.write(pieces.next().unwrap().as_bytes()));\n+                try!(formatter.run(&DEFAULT_ARGUMENT));\n+            }\n+        }\n+        Some(fmt) => {\n+            // Every spec has a corresponding argument that is preceded by\n+            // a string piece.\n+            for (arg, piece) in fmt.iter().zip(pieces.by_ref()) {\n+                try!(formatter.buf.write(piece.as_bytes()));\n+                try!(formatter.run(arg));\n+            }\n+        }\n     }\n \n+    // There can be only one trailing string piece left.\n     match pieces.next() {\n         Some(piece) => {\n             try!(formatter.buf.write(piece.as_bytes()));"}, {"sha": "0bb32c73ca264ce666fb956819cb376515be6efa", "filename": "src/libsyntax/ext/format.rs", "status": "modified", "additions": 73, "deletions": 49, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/5aaa60693222c98c92fbde830f9a85c24f2e3f4f/src%2Flibsyntax%2Fext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5aaa60693222c98c92fbde830f9a85c24f2e3f4f/src%2Flibsyntax%2Fext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fformat.rs?ref=5aaa60693222c98c92fbde830f9a85c24f2e3f4f", "patch": "@@ -56,6 +56,9 @@ struct Context<'a, 'b:'a> {\n     pieces: Vec<Gc<ast::Expr>>,\n     /// Collection of string literals\n     str_pieces: Vec<Gc<ast::Expr>>,\n+    /// Stays `true` if all formatting parameters are default (as in \"{}{}\").\n+    all_pieces_simple: bool,\n+\n     name_positions: HashMap<String, uint>,\n     method_statics: Vec<Gc<ast::Item>>,\n \n@@ -383,7 +386,6 @@ impl<'a, 'b> Context<'a, 'b> {\n     /// Translate a `parse::Piece` to a static `rt::Argument` or append\n     /// to the `literal` string.\n     fn trans_piece(&mut self, piece: &parse::Piece) -> Option<Gc<ast::Expr>> {\n-        // let mut is_not_default = true;\n         let sp = self.fmtsp;\n         match *piece {\n             parse::String(s) => {\n@@ -416,8 +418,25 @@ impl<'a, 'b> Context<'a, 'b> {\n                     }\n                 };\n \n-                // Translate the format\n+                let simple_arg = parse::Argument {\n+                    position: parse::ArgumentNext,\n+                    format: parse::FormatSpec {\n+                        fill: arg.format.fill,\n+                        align: parse::AlignUnknown,\n+                        flags: 0,\n+                        precision: parse::CountImplied,\n+                        width: parse::CountImplied,\n+                        ty: arg.format.ty\n+                    }\n+                };\n+\n                 let fill = match arg.format.fill { Some(c) => c, None => ' ' };\n+\n+                if *arg != simple_arg || fill != ' ' {\n+                    self.all_pieces_simple = false;\n+                }\n+\n+                // Translate the format\n                 let fill = self.ecx.expr_lit(sp, ast::LitChar(fill));\n                 let align = match arg.format.align {\n                     parse::AlignLeft => {\n@@ -453,6 +472,26 @@ impl<'a, 'b> Context<'a, 'b> {\n         }\n     }\n \n+    fn item_static_array(&self,\n+                         name: ast::Ident,\n+                         piece_ty: Gc<ast::Ty>,\n+                         pieces: Vec<Gc<ast::Expr>>)\n+        -> ast::Stmt\n+    {\n+        let pieces_len = self.ecx.expr_uint(self.fmtsp, pieces.len());\n+        let fmt = self.ecx.expr_vec(self.fmtsp, pieces);\n+        let ty = ast::TyFixedLengthVec(\n+            piece_ty,\n+            pieces_len\n+        );\n+        let ty = self.ecx.ty(self.fmtsp, ty);\n+        let st = ast::ItemStatic(ty, ast::MutImmutable, fmt);\n+        let item = self.ecx.item(self.fmtsp, name,\n+                                 self.static_attrs(), st);\n+        let decl = respan(self.fmtsp, ast::DeclItem(item));\n+        respan(self.fmtsp, ast::StmtDecl(box(GC) decl, ast::DUMMY_NODE_ID))\n+    }\n+\n     /// Actually builds the expression which the iformat! block will be expanded\n     /// to\n     fn to_expr(&self, invocation: Invocation) -> Gc<ast::Expr> {\n@@ -471,54 +510,31 @@ impl<'a, 'b> Context<'a, 'b> {\n \n         // Next, build up the static array which will become our precompiled\n         // format \"string\"\n-        let fmt = self.ecx.expr_vec(self.fmtsp, self.str_pieces.clone());\n-        let piece_ty = self.ecx.ty_rptr(self.fmtsp,\n-                                        self.ecx.ty_ident(self.fmtsp,\n-                                             self.ecx.ident_of(\"str\")),\n-                                        Some(self.ecx.lifetime(self.fmtsp,\n-                                             self.ecx.ident_of(\n-                                                 \"'static\").name)),\n-                                        ast::MutImmutable);\n-\n-        let ty = ast::TyFixedLengthVec(\n-            piece_ty,\n-            self.ecx.expr_uint(self.fmtsp, self.str_pieces.len())\n-        );\n-        let ty = self.ecx.ty(self.fmtsp, ty);\n-        let st = ast::ItemStatic(ty, ast::MutImmutable, fmt);\n         let static_str_name = self.ecx.ident_of(\"__STATIC_FMTSTR\");\n-        let item = self.ecx.item(self.fmtsp, static_str_name,\n-                                 self.static_attrs(), st);\n-        let decl = respan(self.fmtsp, ast::DeclItem(item));\n-        lets.push(box(GC) respan(self.fmtsp,\n-                                 ast::StmtDecl(box(GC) decl, ast::DUMMY_NODE_ID)));\n-\n-        // Then, build up the static array which will become our precompiled\n-        // format \"string\"\n-        let fmt = self.ecx.expr_vec(self.fmtsp, self.pieces.clone());\n-        let piece_ty = self.ecx.ty_path(self.ecx.path_all(\n+        let static_lifetime = self.ecx.lifetime(self.fmtsp, self.ecx.ident_of(\"'static\").name);\n+        let piece_ty = self.ecx.ty_rptr(\n                 self.fmtsp,\n-                true, vec!(\n-                    self.ecx.ident_of(\"std\"),\n-                    self.ecx.ident_of(\"fmt\"),\n-                    self.ecx.ident_of(\"rt\"),\n-                    self.ecx.ident_of(\"Argument\")),\n-                vec!(self.ecx.lifetime(self.fmtsp,\n-                                       self.ecx.ident_of(\"'static\").name)),\n-                Vec::new()\n-            ), None);\n-        let ty = ast::TyFixedLengthVec(\n-            piece_ty,\n-            self.ecx.expr_uint(self.fmtsp, self.pieces.len())\n-        );\n-        let ty = self.ecx.ty(self.fmtsp, ty);\n-        let st = ast::ItemStatic(ty, ast::MutImmutable, fmt);\n+                self.ecx.ty_ident(self.fmtsp, self.ecx.ident_of(\"str\")),\n+                Some(static_lifetime),\n+                ast::MutImmutable);\n+        lets.push(box(GC) self.item_static_array(static_str_name,\n+                                                 piece_ty,\n+                                                 self.str_pieces.clone()));\n+\n+        // Then, build up the static array which will store our precompiled\n+        // nonstandard placeholders, if there are any.\n         let static_args_name = self.ecx.ident_of(\"__STATIC_FMTARGS\");\n-        let item = self.ecx.item(self.fmtsp, static_args_name,\n-                                 self.static_attrs(), st);\n-        let decl = respan(self.fmtsp, ast::DeclItem(item));\n-        lets.push(box(GC) respan(self.fmtsp,\n-                                 ast::StmtDecl(box(GC) decl, ast::DUMMY_NODE_ID)));\n+        if !self.all_pieces_simple {\n+            let piece_ty = self.ecx.ty_path(self.ecx.path_all(\n+                    self.fmtsp,\n+                    true, self.rtpath(\"Argument\"),\n+                    vec![static_lifetime],\n+                    vec![]\n+                ), None);\n+            lets.push(box(GC) self.item_static_array(static_args_name,\n+                                                     piece_ty,\n+                                                     self.pieces.clone()));\n+        }\n \n         // Right now there is a bug such that for the expression:\n         //      foo(bar(&1))\n@@ -565,13 +581,20 @@ impl<'a, 'b> Context<'a, 'b> {\n \n         // Now create the fmt::Arguments struct with all our locals we created.\n         let pieces = self.ecx.expr_ident(self.fmtsp, static_str_name);\n-        let fmt = self.ecx.expr_ident(self.fmtsp, static_args_name);\n         let args_slice = self.ecx.expr_ident(self.fmtsp, slicename);\n+\n+        let (fn_name, fn_args) = if self.all_pieces_simple {\n+            (\"new\", vec![pieces, args_slice])\n+        } else {\n+            let fmt = self.ecx.expr_ident(self.fmtsp, static_args_name);\n+            (\"with_placeholders\", vec![pieces, fmt, args_slice])\n+        };\n+\n         let result = self.ecx.expr_call_global(self.fmtsp, vec!(\n                 self.ecx.ident_of(\"std\"),\n                 self.ecx.ident_of(\"fmt\"),\n                 self.ecx.ident_of(\"Arguments\"),\n-                self.ecx.ident_of(\"new\")), vec!(pieces, fmt, args_slice));\n+                self.ecx.ident_of(fn_name)), fn_args);\n \n         // We did all the work of making sure that the arguments\n         // structure is safe, so we can safely have an unsafe block.\n@@ -741,6 +764,7 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt, sp: Span,\n         literal: String::new(),\n         pieces: Vec::new(),\n         str_pieces: Vec::new(),\n+        all_pieces_simple: true,\n         method_statics: Vec::new(),\n         fmtsp: sp,\n     };"}]}