{"sha": "58891278a322f5e09ea0b9da762e37b57fc39d1f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU4ODkxMjc4YTMyMmY1ZTA5ZWEwYjlkYTc2MmUzN2I1N2ZjMzlkMWY=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2015-08-05T16:08:03Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2015-08-17T21:41:38Z"}, "message": "Type check platform-intrinsics in typeck.", "tree": {"sha": "d5b2ca7e9e4606ec15b008982ec197757a7d7730", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d5b2ca7e9e4606ec15b008982ec197757a7d7730"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/58891278a322f5e09ea0b9da762e37b57fc39d1f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/58891278a322f5e09ea0b9da762e37b57fc39d1f", "html_url": "https://github.com/rust-lang/rust/commit/58891278a322f5e09ea0b9da762e37b57fc39d1f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/58891278a322f5e09ea0b9da762e37b57fc39d1f/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cb1eb9d0c41739fc6abf4361c263013004463072", "url": "https://api.github.com/repos/rust-lang/rust/commits/cb1eb9d0c41739fc6abf4361c263013004463072", "html_url": "https://github.com/rust-lang/rust/commit/cb1eb9d0c41739fc6abf4361c263013004463072"}], "stats": {"total": 122, "additions": 110, "deletions": 12}, "files": [{"sha": "aeb336f844facd6efc0efb665f2f37466fdac595", "filename": "mk/crates.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/58891278a322f5e09ea0b9da762e37b57fc39d1f/mk%2Fcrates.mk", "raw_url": "https://github.com/rust-lang/rust/raw/58891278a322f5e09ea0b9da762e37b57fc39d1f/mk%2Fcrates.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcrates.mk?ref=58891278a322f5e09ea0b9da762e37b57fc39d1f", "patch": "@@ -75,7 +75,7 @@ DEPS_rustc_driver := arena flate getopts graphviz libc rustc rustc_back rustc_bo\n \n DEPS_rustc_trans := arena flate getopts graphviz libc rustc rustc_back \\\n \t                log syntax serialize rustc_llvm rustc_platform_intrinsics\n-DEPS_rustc_typeck := rustc syntax\n+DEPS_rustc_typeck := rustc syntax rustc_platform_intrinsics\n DEPS_rustc_borrowck := rustc log graphviz syntax\n DEPS_rustc_resolve := rustc log syntax\n DEPS_rustc_privacy := rustc log syntax"}, {"sha": "1077a84c5a9f876aa1bc5cc8da042c2378351124", "filename": "src/librustc_platform_intrinsics/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/58891278a322f5e09ea0b9da762e37b57fc39d1f/src%2Flibrustc_platform_intrinsics%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58891278a322f5e09ea0b9da762e37b57fc39d1f/src%2Flibrustc_platform_intrinsics%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_platform_intrinsics%2Flib.rs?ref=58891278a322f5e09ea0b9da762e37b57fc39d1f", "patch": "@@ -28,7 +28,7 @@ pub struct Intrinsic {\n     pub definition: IntrinsicDef,\n }\n \n-#[derive(Clone)]\n+#[derive(Clone, Hash, Eq, PartialEq)]\n pub enum Type {\n     Integer(u8),\n     Float(u8),"}, {"sha": "93da9ffb7baa35469d134e28243516001f8b9f3f", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 107, "deletions": 10, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/58891278a322f5e09ea0b9da762e37b57fc39d1f/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58891278a322f5e09ea0b9da762e37b57fc39d1f/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=58891278a322f5e09ea0b9da762e37b57fc39d1f", "patch": "@@ -84,6 +84,7 @@ use self::TupleArgumentsFlag::*;\n use astconv::{self, ast_region_to_region, ast_ty_to_ty, AstConv, PathParamMode};\n use check::_match::pat_ctxt;\n use fmt_macros::{Parser, Piece, Position};\n+use intrinsics;\n use middle::astconv_util::{check_path_args, NO_TPS, NO_REGIONS};\n use middle::def;\n use middle::infer;\n@@ -109,7 +110,7 @@ use util::nodemap::{DefIdMap, FnvHashMap, NodeMap};\n use util::lev_distance::lev_distance;\n \n use std::cell::{Cell, Ref, RefCell};\n-use std::collections::HashSet;\n+use std::collections::{HashSet, HashMap};\n use std::iter;\n use std::mem::replace;\n use std::slice;\n@@ -5386,16 +5387,18 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n                 (0, vec![tcx.mk_fn(None, fn_ty), mut_u8], mut_u8)\n             }\n \n-            name if name.starts_with(\"x86_\") ||\n-                    name.starts_with(\"arm_\") ||\n-                    name.starts_with(\"aarch64_\") => {\n-                // FIXME: skip checking these for now\n-                return\n-            }\n             ref other => {\n-                span_err!(tcx.sess, it.span, E0093,\n-                    \"unrecognized intrinsic function: `{}`\", *other);\n-                return;\n+                match intrinsics::Intrinsic::find(tcx, other) {\n+                    Some(intr) => {\n+                        check_platform_intrinsic_type(ccx, intr, it);\n+                        return\n+                    }\n+                    None => {\n+                        span_err!(tcx.sess, it.span, E0093,\n+                                  \"unrecognized intrinsic function: `{}`\", *other);\n+                        return;\n+                    }\n+                }\n             }\n         };\n         (n_tps, inputs, ty::FnConverging(output))\n@@ -5429,3 +5432,97 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n             });\n     }\n }\n+\n+fn check_platform_intrinsic_type(ccx: &CrateCtxt,\n+                                 expected: intrinsics::Intrinsic, it: &ast::ForeignItem) {\n+    let tcx = ccx.tcx;\n+    let i_ty = tcx.lookup_item_type(local_def(it.id));\n+    let i_n_tps = i_ty.generics.types.len(subst::FnSpace);\n+    if i_n_tps != 0 {\n+        tcx.sess.span_err(it.span,\n+                          &format!(\"intrinsic has wrong number of type parameters: \\\n+                                    found {}, expected 0\",\n+                                   i_n_tps));\n+        return\n+    }\n+\n+    let mut structural_to_nomimal = HashMap::new();\n+\n+    let sig = tcx.no_late_bound_regions(i_ty.ty.fn_sig()).unwrap();\n+    for (i, (expected_arg, arg)) in expected.inputs.iter().zip(&sig.inputs).enumerate() {\n+        match_types(tcx, &format!(\"argument {}\", i + 1), it.span,\n+                    &mut structural_to_nomimal, expected_arg, arg);\n+    }\n+    match_types(tcx, \"return value\", it.span, &mut structural_to_nomimal,\n+                &expected.output, sig.output.unwrap());\n+\n+    // walk the expected type and the actual type in lock step, checking they're\n+    // the same, in a kinda-structural way, i.e. `Vector`s have to be simd structs with\n+    // exactly the right element type\n+    fn match_types<'tcx, 'a>(tcx: &ty::ctxt<'tcx>,\n+                             position: &str,\n+                             span: Span,\n+                             structural_to_nominal: &mut HashMap<&'a intrinsics::Type,\n+                                                                 ty::Ty<'tcx>>,\n+                             expected: &'a intrinsics::Type, t: ty::Ty<'tcx>) {\n+        use intrinsics::Type::*;\n+        match *expected {\n+            Integer(bits) => match (bits, &t.sty) {\n+                (8, &ty::TyInt(ast::TyI8)) | (8, &ty::TyUint(ast::TyU8)) |\n+                (16, &ty::TyInt(ast::TyI16)) | (16, &ty::TyUint(ast::TyU16)) |\n+                (32, &ty::TyInt(ast::TyI32)) | (32, &ty::TyUint(ast::TyU32)) |\n+                (64, &ty::TyInt(ast::TyI64)) | (64, &ty::TyUint(ast::TyU64)) => {},\n+                _ => tcx.sess.span_err(span,\n+                                       &format!(\"intrinsic {} has wrong type: found `{}`, \\\n+                                                 expected `i{n}` or `u{n}`\",\n+                                                position,\n+                                                t, n = bits)),\n+            },\n+            Float(bits) => match (bits, &t.sty) {\n+                (32, &ty::TyFloat(ast::TyF32)) |\n+                (64, &ty::TyFloat(ast::TyF64)) => {},\n+                _ => tcx.sess.span_err(span,\n+                                       &format!(\"intrinsic {} has wrong type: found `{}`, \\\n+                                                 expected `f{n}`\",\n+                                                position,\n+                                                t, n = bits)),\n+            },\n+            Pointer(_) => unimplemented!(),\n+            Vector(ref inner_expected, len) => {\n+                if t.is_simd(tcx) {\n+                    let t_len = t.simd_size(tcx);\n+                    if len as usize != t_len {\n+                        tcx.sess.span_err(span,\n+                                          &format!(\"intrinsic {} has wrong type: found \\\n+                                                    vector with length {}, expected length {}\",\n+                                                   position,\n+                                                   t_len, len));\n+                        return;\n+                    }\n+                    let t_ty = t.simd_type(tcx);\n+                    {\n+                        let previous = structural_to_nominal.entry(expected).or_insert(t);\n+                        if *previous != t {\n+                            tcx.sess.span_err(span,\n+                                              &format!(\"intrinsic {} has wrong type: found `{}`, \\\n+                                                        but already seen this vector type as `{}`\",\n+                                                       position, t, previous));\n+                            return;\n+                        }\n+                    }\n+                    match_types(tcx,\n+                                position,\n+                                span,\n+                                structural_to_nominal,\n+                                inner_expected,\n+                                t_ty)\n+                } else {\n+                    tcx.sess.span_err(span,\n+                                      &format!(\"intrinsic {} has wrong type: found non-simd type {}, \\\n+                                               expected simd type\",\n+                                               position, t));\n+                }\n+            }\n+        }\n+    }\n+}"}, {"sha": "82a605cd14fa4050ce04292395e4ec903ff150fc", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/58891278a322f5e09ea0b9da762e37b57fc39d1f/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58891278a322f5e09ea0b9da762e37b57fc39d1f/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=58891278a322f5e09ea0b9da762e37b57fc39d1f", "patch": "@@ -96,6 +96,7 @@ This API is completely unstable and subject to change.\n extern crate arena;\n extern crate fmt_macros;\n extern crate rustc;\n+extern crate rustc_platform_intrinsics as intrinsics;\n \n pub use rustc::lint;\n pub use rustc::metadata;"}]}