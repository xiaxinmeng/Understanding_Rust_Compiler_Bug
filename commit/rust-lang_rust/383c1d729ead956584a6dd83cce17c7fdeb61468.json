{"sha": "383c1d729ead956584a6dd83cce17c7fdeb61468", "node_id": "C_kwDOAAsO6NoAKDM4M2MxZDcyOWVhZDk1NjU4NGE2ZGQ4M2NjZTE3YzdmZGViNjE0Njg", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-05T10:38:02Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-05T10:38:02Z"}, "message": "Auto merge of #109117 - oli-obk:locks, r=michaelwoerister\n\nAvoid a few locks\n\nWe can use atomics or datastructures tuned for specific access patterns instead of locks. This may be an improvement for parallel rustc, but it's mostly a cleanup making various datastructures only usable in the way they are used right now (append data, never mutate), instead of having a general purpose lock.", "tree": {"sha": "9fc21ebe17133cdb5537cfe8cdc0a716af076630", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9fc21ebe17133cdb5537cfe8cdc0a716af076630"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/383c1d729ead956584a6dd83cce17c7fdeb61468", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/383c1d729ead956584a6dd83cce17c7fdeb61468", "html_url": "https://github.com/rust-lang/rust/commit/383c1d729ead956584a6dd83cce17c7fdeb61468", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/383c1d729ead956584a6dd83cce17c7fdeb61468/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "90a9f69c80812c8694959c1f2d5c336e3300d1e2", "url": "https://api.github.com/repos/rust-lang/rust/commits/90a9f69c80812c8694959c1f2d5c336e3300d1e2", "html_url": "https://github.com/rust-lang/rust/commit/90a9f69c80812c8694959c1f2d5c336e3300d1e2"}, {"sha": "457a162d008befc6baa9acde637f29780c079844", "url": "https://api.github.com/repos/rust-lang/rust/commits/457a162d008befc6baa9acde637f29780c079844", "html_url": "https://github.com/rust-lang/rust/commit/457a162d008befc6baa9acde637f29780c079844"}], "stats": {"total": 184, "additions": 137, "deletions": 47}, "files": [{"sha": "07dcca0fd47b09c43fe844edfd9d4fbb8e8e2e1a", "filename": "Cargo.lock", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/383c1d729ead956584a6dd83cce17c7fdeb61468/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/383c1d729ead956584a6dd83cce17c7fdeb61468/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=383c1d729ead956584a6dd83cce17c7fdeb61468", "patch": "@@ -1418,9 +1418,9 @@ dependencies = [\n \n [[package]]\n name = \"elsa\"\n-version = \"1.8.0\"\n+version = \"1.7.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"f74077c3c3aedb99a2683919698285596662518ea13e5eedcf8bdd43b0d0453b\"\n+checksum = \"848fe615fbb0a74d9ae68dcaa510106d32e37d9416207bbea4bd008bd89c47ed\"\n dependencies = [\n  \"stable_deref_trait\",\n ]"}, {"sha": "24b6b5cfb1f73ec0e5b8745d32fdf344251d0b49", "filename": "compiler/rustc_data_structures/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/383c1d729ead956584a6dd83cce17c7fdeb61468/compiler%2Frustc_data_structures%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/383c1d729ead956584a6dd83cce17c7fdeb61468/compiler%2Frustc_data_structures%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2FCargo.toml?ref=383c1d729ead956584a6dd83cce17c7fdeb61468", "patch": "@@ -32,7 +32,7 @@ stacker = \"0.1.15\"\n tempfile = \"3.2\"\n thin-vec = \"0.2.12\"\n tracing = \"0.1\"\n-elsa = \"1.8\"\n+elsa = \"=1.7.1\"\n \n [dependencies.parking_lot]\n version = \"0.11\""}, {"sha": "e8ee4fb76cc51f5424541a4130c0b05dde48b1bd", "filename": "compiler/rustc_data_structures/src/sync.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/383c1d729ead956584a6dd83cce17c7fdeb61468/compiler%2Frustc_data_structures%2Fsrc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/383c1d729ead956584a6dd83cce17c7fdeb61468/compiler%2Frustc_data_structures%2Fsrc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsync.rs?ref=383c1d729ead956584a6dd83cce17c7fdeb61468", "patch": "@@ -51,7 +51,7 @@ use std::panic::{catch_unwind, resume_unwind, AssertUnwindSafe};\n pub use std::sync::atomic::Ordering;\n pub use std::sync::atomic::Ordering::SeqCst;\n \n-pub use vec::AppendOnlyVec;\n+pub use vec::{AppendOnlyIndexVec, AppendOnlyVec};\n \n mod vec;\n \n@@ -107,6 +107,14 @@ cfg_if! {\n             }\n         }\n \n+        impl Atomic<bool> {\n+            pub fn fetch_or(&self, val: bool, _: Ordering) -> bool {\n+                let result = self.0.get() | val;\n+                self.0.set(val);\n+                result\n+            }\n+        }\n+\n         impl<T: Copy + PartialEq> Atomic<T> {\n             #[inline]\n             pub fn compare_exchange(&self,\n@@ -481,14 +489,6 @@ impl<T: Default> Default for Lock<T> {\n     }\n }\n \n-// FIXME: Probably a bad idea\n-impl<T: Clone> Clone for Lock<T> {\n-    #[inline]\n-    fn clone(&self) -> Self {\n-        Lock::new(self.borrow().clone())\n-    }\n-}\n-\n #[derive(Debug, Default)]\n pub struct RwLock<T>(InnerRwLock<T>);\n "}, {"sha": "aefaa8519d5364d8f063e377597afc948799a762", "filename": "compiler/rustc_data_structures/src/sync/vec.rs", "status": "modified", "additions": 66, "deletions": 2, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/383c1d729ead956584a6dd83cce17c7fdeb61468/compiler%2Frustc_data_structures%2Fsrc%2Fsync%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/383c1d729ead956584a6dd83cce17c7fdeb61468/compiler%2Frustc_data_structures%2Fsrc%2Fsync%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsync%2Fvec.rs?ref=383c1d729ead956584a6dd83cce17c7fdeb61468", "patch": "@@ -2,15 +2,16 @@ use std::marker::PhantomData;\n \n use rustc_index::vec::Idx;\n \n-pub struct AppendOnlyVec<I: Idx, T: Copy> {\n+#[derive(Default)]\n+pub struct AppendOnlyIndexVec<I: Idx, T: Copy> {\n     #[cfg(not(parallel_compiler))]\n     vec: elsa::vec::FrozenVec<T>,\n     #[cfg(parallel_compiler)]\n     vec: elsa::sync::LockFreeFrozenVec<T>,\n     _marker: PhantomData<fn(&I)>,\n }\n \n-impl<I: Idx, T: Copy> AppendOnlyVec<I, T> {\n+impl<I: Idx, T: Copy> AppendOnlyIndexVec<I, T> {\n     pub fn new() -> Self {\n         Self {\n             #[cfg(not(parallel_compiler))]\n@@ -39,3 +40,66 @@ impl<I: Idx, T: Copy> AppendOnlyVec<I, T> {\n         return self.vec.get(i);\n     }\n }\n+\n+#[derive(Default)]\n+pub struct AppendOnlyVec<T: Copy> {\n+    #[cfg(not(parallel_compiler))]\n+    vec: elsa::vec::FrozenVec<T>,\n+    #[cfg(parallel_compiler)]\n+    vec: elsa::sync::LockFreeFrozenVec<T>,\n+}\n+\n+impl<T: Copy> AppendOnlyVec<T> {\n+    pub fn new() -> Self {\n+        Self {\n+            #[cfg(not(parallel_compiler))]\n+            vec: elsa::vec::FrozenVec::new(),\n+            #[cfg(parallel_compiler)]\n+            vec: elsa::sync::LockFreeFrozenVec::new(),\n+        }\n+    }\n+\n+    pub fn push(&self, val: T) -> usize {\n+        #[cfg(not(parallel_compiler))]\n+        let i = self.vec.len();\n+        #[cfg(not(parallel_compiler))]\n+        self.vec.push(val);\n+        #[cfg(parallel_compiler)]\n+        let i = self.vec.push(val);\n+        i\n+    }\n+\n+    pub fn get(&self, i: usize) -> Option<T> {\n+        #[cfg(not(parallel_compiler))]\n+        return self.vec.get_copy(i);\n+        #[cfg(parallel_compiler)]\n+        return self.vec.get(i);\n+    }\n+\n+    pub fn iter_enumerated(&self) -> impl Iterator<Item = (usize, T)> + '_ {\n+        (0..)\n+            .map(|i| (i, self.get(i)))\n+            .take_while(|(_, o)| o.is_some())\n+            .filter_map(|(i, o)| Some((i, o?)))\n+    }\n+\n+    pub fn iter(&self) -> impl Iterator<Item = T> + '_ {\n+        (0..).map(|i| self.get(i)).take_while(|o| o.is_some()).filter_map(|o| o)\n+    }\n+}\n+\n+impl<T: Copy + PartialEq> AppendOnlyVec<T> {\n+    pub fn contains(&self, val: T) -> bool {\n+        self.iter_enumerated().any(|(_, v)| v == val)\n+    }\n+}\n+\n+impl<A: Copy> FromIterator<A> for AppendOnlyVec<A> {\n+    fn from_iter<T: IntoIterator<Item = A>>(iter: T) -> Self {\n+        let this = Self::new();\n+        for val in iter {\n+            this.push(val);\n+        }\n+        this\n+    }\n+}"}, {"sha": "818f450a58c16c2e10218462cb906f7ce0c937c2", "filename": "compiler/rustc_interface/src/queries.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/383c1d729ead956584a6dd83cce17c7fdeb61468/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/383c1d729ead956584a6dd83cce17c7fdeb61468/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs?ref=383c1d729ead956584a6dd83cce17c7fdeb61468", "patch": "@@ -7,7 +7,7 @@ use rustc_codegen_ssa::traits::CodegenBackend;\n use rustc_codegen_ssa::CodegenResults;\n use rustc_data_structures::steal::Steal;\n use rustc_data_structures::svh::Svh;\n-use rustc_data_structures::sync::{AppendOnlyVec, Lrc, OnceCell, RwLock, WorkerLocal};\n+use rustc_data_structures::sync::{AppendOnlyIndexVec, Lrc, OnceCell, RwLock, WorkerLocal};\n use rustc_hir::def_id::{CRATE_DEF_ID, LOCAL_CRATE};\n use rustc_hir::definitions::Definitions;\n use rustc_incremental::DepGraphFuture;\n@@ -215,7 +215,7 @@ impl<'tcx> Queries<'tcx> {\n \n             let cstore = RwLock::new(Box::new(CStore::new(sess)) as _);\n             let definitions = RwLock::new(Definitions::new(sess.local_stable_crate_id()));\n-            let source_span = AppendOnlyVec::new();\n+            let source_span = AppendOnlyIndexVec::new();\n             let _id = source_span.push(krate.spans.inner_span);\n             debug_assert_eq!(_id, CRATE_DEF_ID);\n             let untracked = Untracked { cstore, source_span, definitions };"}, {"sha": "6b387df785e7df66b80784e83e8c38ef86db327d", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/383c1d729ead956584a6dd83cce17c7fdeb61468/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/383c1d729ead956584a6dd83cce17c7fdeb61468/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=383c1d729ead956584a6dd83cce17c7fdeb61468", "patch": "@@ -1947,7 +1947,7 @@ impl KeywordIdents {\n         };\n \n         // Don't lint `r#foo`.\n-        if cx.sess().parse_sess.raw_identifier_spans.borrow().contains(&ident.span) {\n+        if cx.sess().parse_sess.raw_identifier_spans.contains(ident.span) {\n             return;\n         }\n "}, {"sha": "23aceca06223a01142ed448da5a0cda2d025a59d", "filename": "compiler/rustc_metadata/src/creader.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/383c1d729ead956584a6dd83cce17c7fdeb61468/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/383c1d729ead956584a6dd83cce17c7fdeb61468/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs?ref=383c1d729ead956584a6dd83cce17c7fdeb61468", "patch": "@@ -185,7 +185,7 @@ impl CStore {\n     fn push_dependencies_in_postorder(&self, deps: &mut Vec<CrateNum>, cnum: CrateNum) {\n         if !deps.contains(&cnum) {\n             let data = self.get_crate_data(cnum);\n-            for &dep in data.dependencies().iter() {\n+            for dep in data.dependencies() {\n                 if dep != cnum {\n                     self.push_dependencies_in_postorder(deps, dep);\n                 }\n@@ -605,7 +605,7 @@ impl<'a, 'tcx> CrateLoader<'a, 'tcx> {\n         if cmeta.update_extern_crate(extern_crate) {\n             // Propagate the extern crate info to dependencies if it was updated.\n             let extern_crate = ExternCrate { dependency_of: cnum, ..extern_crate };\n-            for &dep_cnum in cmeta.dependencies().iter() {\n+            for dep_cnum in cmeta.dependencies() {\n                 self.update_extern_crate(dep_cnum, extern_crate);\n             }\n         }"}, {"sha": "21ac7e201f9a38ec9c2889f0b5406ad4f572fda9", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/383c1d729ead956584a6dd83cce17c7fdeb61468/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/383c1d729ead956584a6dd83cce17c7fdeb61468/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=383c1d729ead956584a6dd83cce17c7fdeb61468", "patch": "@@ -7,7 +7,7 @@ use rustc_ast as ast;\n use rustc_data_structures::captures::Captures;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::svh::Svh;\n-use rustc_data_structures::sync::{Lock, LockGuard, Lrc, OnceCell};\n+use rustc_data_structures::sync::{AppendOnlyVec, Lock, Lrc, OnceCell};\n use rustc_data_structures::unhash::UnhashMap;\n use rustc_expand::base::{SyntaxExtension, SyntaxExtensionKind};\n use rustc_expand::proc_macro::{AttrProcMacro, BangProcMacro, DeriveProcMacro};\n@@ -109,7 +109,7 @@ pub(crate) struct CrateMetadata {\n     /// IDs as they are seen from the current compilation session.\n     cnum_map: CrateNumMap,\n     /// Same ID set as `cnum_map` plus maybe some injected crates like panic runtime.\n-    dependencies: Lock<Vec<CrateNum>>,\n+    dependencies: AppendOnlyVec<CrateNum>,\n     /// How to link (or not link) this crate to the currently compiled crate.\n     dep_kind: Lock<CrateDepKind>,\n     /// Filesystem location of this crate.\n@@ -1594,7 +1594,7 @@ impl CrateMetadata {\n             .collect();\n         let alloc_decoding_state =\n             AllocDecodingState::new(root.interpret_alloc_index.decode(&blob).collect());\n-        let dependencies = Lock::new(cnum_map.iter().cloned().collect());\n+        let dependencies = cnum_map.iter().copied().collect();\n \n         // Pre-decode the DefPathHash->DefIndex table. This is a cheap operation\n         // that does not copy any data. It just does some data verification.\n@@ -1634,12 +1634,12 @@ impl CrateMetadata {\n         cdata\n     }\n \n-    pub(crate) fn dependencies(&self) -> LockGuard<'_, Vec<CrateNum>> {\n-        self.dependencies.borrow()\n+    pub(crate) fn dependencies(&self) -> impl Iterator<Item = CrateNum> + '_ {\n+        self.dependencies.iter()\n     }\n \n     pub(crate) fn add_dependency(&self, cnum: CrateNum) {\n-        self.dependencies.borrow_mut().push(cnum);\n+        self.dependencies.push(cnum);\n     }\n \n     pub(crate) fn update_extern_crate(&self, new_extern_crate: ExternCrate) -> bool {"}, {"sha": "0e8155afcb4db99b455ffe07248854b02967071f", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/383c1d729ead956584a6dd83cce17c7fdeb61468/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/383c1d729ead956584a6dd83cce17c7fdeb61468/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=383c1d729ead956584a6dd83cce17c7fdeb61468", "patch": "@@ -1712,8 +1712,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             let stability = tcx.lookup_stability(CRATE_DEF_ID);\n             let macros =\n                 self.lazy_array(tcx.resolutions(()).proc_macros.iter().map(|p| p.local_def_index));\n-            let spans = self.tcx.sess.parse_sess.proc_macro_quoted_spans();\n-            for (i, span) in spans.into_iter().enumerate() {\n+            for (i, span) in self.tcx.sess.parse_sess.proc_macro_quoted_spans() {\n                 let span = self.lazy(span);\n                 self.tables.proc_macro_quoted_spans.set_some(i, span);\n             }"}, {"sha": "1f8b650e34cfc9f082e4c807129dd75fdf3ed84e", "filename": "compiler/rustc_middle/src/mir/interpret/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/383c1d729ead956584a6dd83cce17c7fdeb61468/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/383c1d729ead956584a6dd83cce17c7fdeb61468/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs?ref=383c1d729ead956584a6dd83cce17c7fdeb61468", "patch": "@@ -263,7 +263,8 @@ impl AllocDecodingState {\n     }\n \n     pub fn new(data_offsets: Vec<u32>) -> Self {\n-        let decoding_state = vec![Lock::new(State::Empty); data_offsets.len()];\n+        let decoding_state =\n+            std::iter::repeat_with(|| Lock::new(State::Empty)).take(data_offsets.len()).collect();\n \n         Self { decoding_state, data_offsets }\n     }"}, {"sha": "4a7da11a097842ed464a8b70919eda854cc8c223", "filename": "compiler/rustc_parse/src/lexer/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/383c1d729ead956584a6dd83cce17c7fdeb61468/compiler%2Frustc_parse%2Fsrc%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/383c1d729ead956584a6dd83cce17c7fdeb61468/compiler%2Frustc_parse%2Fsrc%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Flexer%2Fmod.rs?ref=383c1d729ead956584a6dd83cce17c7fdeb61468", "patch": "@@ -175,7 +175,7 @@ impl<'a> StringReader<'a> {\n                     if !sym.can_be_raw() {\n                         self.sess.emit_err(errors::CannotBeRawIdent { span, ident: sym });\n                     }\n-                    self.sess.raw_identifier_spans.borrow_mut().push(span);\n+                    self.sess.raw_identifier_spans.push(span);\n                     token::Ident(sym, true)\n                 }\n                 rustc_lexer::TokenKind::UnknownPrefix => {"}, {"sha": "aa57b804779b0846195a9549ddceb1899e2c952c", "filename": "compiler/rustc_parse/src/parser/mod.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/383c1d729ead956584a6dd83cce17c7fdeb61468/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/383c1d729ead956584a6dd83cce17c7fdeb61468/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs?ref=383c1d729ead956584a6dd83cce17c7fdeb61468", "patch": "@@ -29,6 +29,7 @@ use rustc_ast::{Async, AttrArgs, AttrArgsEq, Expr, ExprKind, MacDelimiter, Mutab\n use rustc_ast::{HasAttrs, HasTokens, Unsafe, Visibility, VisibilityKind};\n use rustc_ast_pretty::pprust;\n use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::sync::Ordering;\n use rustc_errors::PResult;\n use rustc_errors::{\n     Applicability, DiagnosticBuilder, ErrorGuaranteed, FatalError, IntoDiagnostic, MultiSpan,\n@@ -1540,8 +1541,10 @@ pub(crate) fn make_unclosed_delims_error(\n }\n \n pub fn emit_unclosed_delims(unclosed_delims: &mut Vec<UnmatchedDelim>, sess: &ParseSess) {\n-    *sess.reached_eof.borrow_mut() |=\n-        unclosed_delims.iter().any(|unmatched_delim| unmatched_delim.found_delim.is_none());\n+    let _ = sess.reached_eof.fetch_or(\n+        unclosed_delims.iter().any(|unmatched_delim| unmatched_delim.found_delim.is_none()),\n+        Ordering::Relaxed,\n+    );\n     for unmatched in unclosed_delims.drain(..) {\n         if let Some(mut e) = make_unclosed_delims_error(unmatched, sess) {\n             e.emit();"}, {"sha": "e3e4b73efa324071e371a3b8f9d147106c862c6d", "filename": "compiler/rustc_passes/src/entry.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/383c1d729ead956584a6dd83cce17c7fdeb61468/compiler%2Frustc_passes%2Fsrc%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/383c1d729ead956584a6dd83cce17c7fdeb61468/compiler%2Frustc_passes%2Fsrc%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fentry.rs?ref=383c1d729ead956584a6dd83cce17c7fdeb61468", "patch": "@@ -187,7 +187,7 @@ fn sigpipe(tcx: TyCtxt<'_>, def_id: DefId) -> u8 {\n \n fn no_main_err(tcx: TyCtxt<'_>, visitor: &EntryContext<'_>) {\n     let sp = tcx.def_span(CRATE_DEF_ID);\n-    if *tcx.sess.parse_sess.reached_eof.borrow() {\n+    if tcx.sess.parse_sess.reached_eof.load(rustc_data_structures::sync::Ordering::Relaxed) {\n         // There's an unclosed brace that made the parser reach `Eof`, we shouldn't complain about\n         // the missing `fn main()` then as it might have been hidden inside an unclosed block.\n         tcx.sess.delay_span_bug(sp, \"`main` not found, but expected unclosed brace error\");"}, {"sha": "6e862db0b2547e98e3b91f7bf106dd5264dee2a8", "filename": "compiler/rustc_query_system/src/cache.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/383c1d729ead956584a6dd83cce17c7fdeb61468/compiler%2Frustc_query_system%2Fsrc%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/383c1d729ead956584a6dd83cce17c7fdeb61468/compiler%2Frustc_query_system%2Fsrc%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fcache.rs?ref=383c1d729ead956584a6dd83cce17c7fdeb61468", "patch": "@@ -7,11 +7,16 @@ use rustc_data_structures::sync::Lock;\n \n use std::hash::Hash;\n \n-#[derive(Clone)]\n pub struct Cache<Key, Value> {\n     hashmap: Lock<FxHashMap<Key, WithDepNode<Value>>>,\n }\n \n+impl<Key: Clone, Value: Clone> Clone for Cache<Key, Value> {\n+    fn clone(&self) -> Self {\n+        Self { hashmap: Lock::new(self.hashmap.borrow().clone()) }\n+    }\n+}\n+\n impl<Key, Value> Default for Cache<Key, Value> {\n     fn default() -> Self {\n         Self { hashmap: Default::default() }"}, {"sha": "dd1721801f37fa1c99d1e478e574103fbd70e86a", "filename": "compiler/rustc_session/src/cstore.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/383c1d729ead956584a6dd83cce17c7fdeb61468/compiler%2Frustc_session%2Fsrc%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/383c1d729ead956584a6dd83cce17c7fdeb61468/compiler%2Frustc_session%2Fsrc%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fcstore.rs?ref=383c1d729ead956584a6dd83cce17c7fdeb61468", "patch": "@@ -6,7 +6,7 @@ use crate::search_paths::PathKind;\n use crate::utils::NativeLibKind;\n use crate::Session;\n use rustc_ast as ast;\n-use rustc_data_structures::sync::{self, AppendOnlyVec, MetadataRef, RwLock};\n+use rustc_data_structures::sync::{self, AppendOnlyIndexVec, MetadataRef, RwLock};\n use rustc_hir::def_id::{CrateNum, DefId, LocalDefId, StableCrateId, LOCAL_CRATE};\n use rustc_hir::definitions::{DefKey, DefPath, DefPathHash, Definitions};\n use rustc_span::hygiene::{ExpnHash, ExpnId};\n@@ -257,6 +257,6 @@ pub type CrateStoreDyn = dyn CrateStore + sync::Sync + sync::Send;\n pub struct Untracked {\n     pub cstore: RwLock<Box<CrateStoreDyn>>,\n     /// Reference span for definitions.\n-    pub source_span: AppendOnlyVec<LocalDefId, Span>,\n+    pub source_span: AppendOnlyIndexVec<LocalDefId, Span>,\n     pub definitions: RwLock<Definitions>,\n }"}, {"sha": "002ae1e3165ac3d3a5fa227d86dca25be35e6d36", "filename": "compiler/rustc_session/src/parse.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/383c1d729ead956584a6dd83cce17c7fdeb61468/compiler%2Frustc_session%2Fsrc%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/383c1d729ead956584a6dd83cce17c7fdeb61468/compiler%2Frustc_session%2Fsrc%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fparse.rs?ref=383c1d729ead956584a6dd83cce17c7fdeb61468", "patch": "@@ -8,7 +8,7 @@ use crate::lint::{\n };\n use rustc_ast::node_id::NodeId;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexSet};\n-use rustc_data_structures::sync::{Lock, Lrc};\n+use rustc_data_structures::sync::{AppendOnlyVec, AtomicBool, Lock, Lrc};\n use rustc_errors::{emitter::SilentEmitter, ColorConfig, Handler};\n use rustc_errors::{\n     fallback_fluent_bundle, Diagnostic, DiagnosticBuilder, DiagnosticId, DiagnosticMessage,\n@@ -194,7 +194,7 @@ pub struct ParseSess {\n     pub edition: Edition,\n     /// Places where raw identifiers were used. This is used to avoid complaining about idents\n     /// clashing with keywords in new editions.\n-    pub raw_identifier_spans: Lock<Vec<Span>>,\n+    pub raw_identifier_spans: AppendOnlyVec<Span>,\n     /// Places where identifiers that contain invalid Unicode codepoints but that look like they\n     /// should be. Useful to avoid bad tokenization when encountering emoji. We group them to\n     /// provide a single error per unique incorrect identifier.\n@@ -208,7 +208,7 @@ pub struct ParseSess {\n     pub gated_spans: GatedSpans,\n     pub symbol_gallery: SymbolGallery,\n     /// The parser has reached `Eof` due to an unclosed brace. Used to silence unnecessary errors.\n-    pub reached_eof: Lock<bool>,\n+    pub reached_eof: AtomicBool,\n     /// Environment variables accessed during the build and their values when they exist.\n     pub env_depinfo: Lock<FxHashSet<(Symbol, Option<Symbol>)>>,\n     /// File paths accessed during the build.\n@@ -219,7 +219,7 @@ pub struct ParseSess {\n     pub assume_incomplete_release: bool,\n     /// Spans passed to `proc_macro::quote_span`. Each span has a numerical\n     /// identifier represented by its position in the vector.\n-    pub proc_macro_quoted_spans: Lock<Vec<Span>>,\n+    pub proc_macro_quoted_spans: AppendOnlyVec<Span>,\n     /// Used to generate new `AttrId`s. Every `AttrId` is unique.\n     pub attr_id_generator: AttrIdGenerator,\n }\n@@ -247,14 +247,14 @@ impl ParseSess {\n             config: FxIndexSet::default(),\n             check_config: CrateCheckConfig::default(),\n             edition: ExpnId::root().expn_data().edition,\n-            raw_identifier_spans: Lock::new(Vec::new()),\n+            raw_identifier_spans: Default::default(),\n             bad_unicode_identifiers: Lock::new(Default::default()),\n             source_map,\n             buffered_lints: Lock::new(vec![]),\n             ambiguous_block_expr_parse: Lock::new(FxHashMap::default()),\n             gated_spans: GatedSpans::default(),\n             symbol_gallery: SymbolGallery::default(),\n-            reached_eof: Lock::new(false),\n+            reached_eof: AtomicBool::new(false),\n             env_depinfo: Default::default(),\n             file_depinfo: Default::default(),\n             type_ascription_path_suggestions: Default::default(),\n@@ -324,13 +324,13 @@ impl ParseSess {\n     }\n \n     pub fn save_proc_macro_span(&self, span: Span) -> usize {\n-        let mut spans = self.proc_macro_quoted_spans.lock();\n-        spans.push(span);\n-        return spans.len() - 1;\n+        self.proc_macro_quoted_spans.push(span)\n     }\n \n-    pub fn proc_macro_quoted_spans(&self) -> Vec<Span> {\n-        self.proc_macro_quoted_spans.lock().clone()\n+    pub fn proc_macro_quoted_spans(&self) -> impl Iterator<Item = (usize, Span)> + '_ {\n+        // This is equivalent to `.iter().copied().enumerate()`, but that isn't possible for\n+        // AppendOnlyVec, so we resort to this scheme.\n+        self.proc_macro_quoted_spans.iter_enumerated()\n     }\n \n     #[track_caller]"}, {"sha": "11cd5811be8b993fd4163c9508f6d3745820907e", "filename": "compiler/rustc_span/src/lib.rs", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/383c1d729ead956584a6dd83cce17c7fdeb61468/compiler%2Frustc_span%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/383c1d729ead956584a6dd83cce17c7fdeb61468/compiler%2Frustc_span%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Flib.rs?ref=383c1d729ead956584a6dd83cce17c7fdeb61468", "patch": "@@ -1318,7 +1318,6 @@ pub struct SourceFileDiffs {\n }\n \n /// A single source in the [`SourceMap`].\n-#[derive(Clone)]\n pub struct SourceFile {\n     /// The name of the file that the source came from. Source that doesn't\n     /// originate from files has names between angle brackets by convention\n@@ -1349,6 +1348,25 @@ pub struct SourceFile {\n     pub cnum: CrateNum,\n }\n \n+impl Clone for SourceFile {\n+    fn clone(&self) -> Self {\n+        Self {\n+            name: self.name.clone(),\n+            src: self.src.clone(),\n+            src_hash: self.src_hash.clone(),\n+            external_src: Lock::new(self.external_src.borrow().clone()),\n+            start_pos: self.start_pos.clone(),\n+            end_pos: self.end_pos.clone(),\n+            lines: Lock::new(self.lines.borrow().clone()),\n+            multibyte_chars: self.multibyte_chars.clone(),\n+            non_narrow_chars: self.non_narrow_chars.clone(),\n+            normalized_pos: self.normalized_pos.clone(),\n+            name_hash: self.name_hash.clone(),\n+            cnum: self.cnum.clone(),\n+        }\n+    }\n+}\n+\n impl<S: Encoder> Encodable<S> for SourceFile {\n     fn encode(&self, s: &mut S) {\n         self.name.encode(s);"}]}