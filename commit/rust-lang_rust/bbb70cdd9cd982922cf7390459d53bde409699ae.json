{"sha": "bbb70cdd9cd982922cf7390459d53bde409699ae", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJiYjcwY2RkOWNkOTgyOTIyY2Y3MzkwNDU5ZDUzYmRlNDA5Njk5YWU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-05-25T01:56:19Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-05-25T01:56:19Z"}, "message": "auto merge of #14402 : huonw/rust/arc-field-rename, r=alexcrichton\n\nPaper over privacy issues with Deref by changing field names.\r\n\r\nTypes that implement Deref can cause weird error messages due to their\r\nprivate fields conflicting with a field of the type they deref to, e.g.,\r\npreviously\r\n\r\n    struct Foo { x: int }\r\n\r\n    let a: Arc<Foo> = ...;\r\n    println!(\"{}\", a.x);\r\n\r\nwould complain the the `x` field of `Arc` was private (since Arc has a\r\nprivate field called `x`) rather than just ignoring it.\r\n\r\nThis patch doesn't fix that issue, but does mean one would have to write\r\n`a._ptr` to hit the same error message, which seems far less\r\ncommon. (This patch `_`-prefixes all private fields of\r\n`Deref`-implementing types.)\r\n\r\ncc #12808", "tree": {"sha": "25c39cad9e52bb386f4d9a7cd5bac6fd376cfe3d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/25c39cad9e52bb386f4d9a7cd5bac6fd376cfe3d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bbb70cdd9cd982922cf7390459d53bde409699ae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bbb70cdd9cd982922cf7390459d53bde409699ae", "html_url": "https://github.com/rust-lang/rust/commit/bbb70cdd9cd982922cf7390459d53bde409699ae", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bbb70cdd9cd982922cf7390459d53bde409699ae/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "07563be6ebe081c8f6666a7b6eb68d8e32774f2f", "url": "https://api.github.com/repos/rust-lang/rust/commits/07563be6ebe081c8f6666a7b6eb68d8e32774f2f", "html_url": "https://github.com/rust-lang/rust/commit/07563be6ebe081c8f6666a7b6eb68d8e32774f2f"}, {"sha": "9698221f919a80f2a0810e17c8ee8e80da8cefeb", "url": "https://api.github.com/repos/rust-lang/rust/commits/9698221f919a80f2a0810e17c8ee8e80da8cefeb", "html_url": "https://github.com/rust-lang/rust/commit/9698221f919a80f2a0810e17c8ee8e80da8cefeb"}], "stats": {"total": 167, "additions": 93, "deletions": 74}, "files": [{"sha": "a408bf8e284e70c2b985130db840023a8c1154e1", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 19, "deletions": 15, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/bbb70cdd9cd982922cf7390459d53bde409699ae/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbb70cdd9cd982922cf7390459d53bde409699ae/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=bbb70cdd9cd982922cf7390459d53bde409699ae", "patch": "@@ -54,7 +54,9 @@ use heap::deallocate;\n /// ```\n #[unsafe_no_drop_flag]\n pub struct Arc<T> {\n-    x: *mut ArcInner<T>,\n+    // FIXME #12808: strange name to try to avoid interfering with\n+    // field accesses of the contained type via Deref\n+    _ptr: *mut ArcInner<T>,\n }\n \n /// A weak pointer to an `Arc`.\n@@ -63,7 +65,9 @@ pub struct Arc<T> {\n /// used to break cycles between `Arc` pointers.\n #[unsafe_no_drop_flag]\n pub struct Weak<T> {\n-    x: *mut ArcInner<T>,\n+    // FIXME #12808: strange name to try to avoid interfering with\n+    // field accesses of the contained type via Deref\n+    _ptr: *mut ArcInner<T>,\n }\n \n struct ArcInner<T> {\n@@ -83,7 +87,7 @@ impl<T: Share + Send> Arc<T> {\n             weak: atomics::AtomicUint::new(1),\n             data: data,\n         };\n-        Arc { x: unsafe { mem::transmute(x) } }\n+        Arc { _ptr: unsafe { mem::transmute(x) } }\n     }\n \n     #[inline]\n@@ -93,7 +97,7 @@ impl<T: Share + Send> Arc<T> {\n         // `ArcInner` structure itself is `Share` because the inner data is\n         // `Share` as well, so we're ok loaning out an immutable pointer to\n         // these contents.\n-        unsafe { &*self.x }\n+        unsafe { &*self._ptr }\n     }\n \n     /// Downgrades a strong pointer to a weak pointer\n@@ -104,7 +108,7 @@ impl<T: Share + Send> Arc<T> {\n     pub fn downgrade(&self) -> Weak<T> {\n         // See the clone() impl for why this is relaxed\n         self.inner().weak.fetch_add(1, atomics::Relaxed);\n-        Weak { x: self.x }\n+        Weak { _ptr: self._ptr }\n     }\n }\n \n@@ -128,7 +132,7 @@ impl<T: Share + Send> Clone for Arc<T> {\n         //\n         // [1]: (www.boost.org/doc/libs/1_55_0/doc/html/atomic/usage_examples.html)\n         self.inner().strong.fetch_add(1, atomics::Relaxed);\n-        Arc { x: self.x }\n+        Arc { _ptr: self._ptr }\n     }\n }\n \n@@ -166,7 +170,7 @@ impl<T: Share + Send> Drop for Arc<T> {\n         // This structure has #[unsafe_no_drop_flag], so this drop glue may run\n         // more than once (but it is guaranteed to be zeroed after the first if\n         // it's run more than once)\n-        if self.x.is_null() { return }\n+        if self._ptr.is_null() { return }\n \n         // Because `fetch_sub` is already atomic, we do not need to synchronize\n         // with other threads unless we are going to delete the object. This\n@@ -198,7 +202,7 @@ impl<T: Share + Send> Drop for Arc<T> {\n \n         if self.inner().weak.fetch_sub(1, atomics::Release) == 1 {\n             atomics::fence(atomics::Acquire);\n-            unsafe { deallocate(self.x as *mut u8, size_of::<ArcInner<T>>(),\n+            unsafe { deallocate(self._ptr as *mut u8, size_of::<ArcInner<T>>(),\n                                 min_align_of::<ArcInner<T>>()) }\n         }\n     }\n@@ -218,14 +222,14 @@ impl<T: Share + Send> Weak<T> {\n             let n = inner.strong.load(atomics::SeqCst);\n             if n == 0 { return None }\n             let old = inner.strong.compare_and_swap(n, n + 1, atomics::SeqCst);\n-            if old == n { return Some(Arc { x: self.x }) }\n+            if old == n { return Some(Arc { _ptr: self._ptr }) }\n         }\n     }\n \n     #[inline]\n     fn inner<'a>(&'a self) -> &'a ArcInner<T> {\n         // See comments above for why this is \"safe\"\n-        unsafe { &*self.x }\n+        unsafe { &*self._ptr }\n     }\n }\n \n@@ -234,22 +238,22 @@ impl<T: Share + Send> Clone for Weak<T> {\n     fn clone(&self) -> Weak<T> {\n         // See comments in Arc::clone() for why this is relaxed\n         self.inner().weak.fetch_add(1, atomics::Relaxed);\n-        Weak { x: self.x }\n+        Weak { _ptr: self._ptr }\n     }\n }\n \n #[unsafe_destructor]\n impl<T: Share + Send> Drop for Weak<T> {\n     fn drop(&mut self) {\n         // see comments above for why this check is here\n-        if self.x.is_null() { return }\n+        if self._ptr.is_null() { return }\n \n         // If we find out that we were the last weak pointer, then its time to\n         // deallocate the data entirely. See the discussion in Arc::drop() about\n         // the memory orderings\n         if self.inner().weak.fetch_sub(1, atomics::Release) == 1 {\n             atomics::fence(atomics::Acquire);\n-            unsafe { deallocate(self.x as *mut u8, size_of::<ArcInner<T>>(),\n+            unsafe { deallocate(self._ptr as *mut u8, size_of::<ArcInner<T>>(),\n                                 min_align_of::<ArcInner<T>>()) }\n         }\n     }\n@@ -261,7 +265,7 @@ mod tests {\n     use std::clone::Clone;\n     use std::comm::channel;\n     use std::mem::drop;\n-    use std::ops::{Drop, Deref, DerefMut};\n+    use std::ops::Drop;\n     use std::option::{Option, Some, None};\n     use std::sync::atomics;\n     use std::task;\n@@ -374,7 +378,7 @@ mod tests {\n \n         let a = Arc::new(Cycle { x: Mutex::new(None) });\n         let b = a.clone().downgrade();\n-        *a.deref().x.lock().deref_mut() = Some(b);\n+        *a.x.lock() = Some(b);\n \n         // hopefully we don't double-free (or leak)...\n     }"}, {"sha": "8ded3c431d4e2774b75297196b716be3e1c6baaf", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 25, "deletions": 21, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/bbb70cdd9cd982922cf7390459d53bde409699ae/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbb70cdd9cd982922cf7390459d53bde409699ae/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=bbb70cdd9cd982922cf7390459d53bde409699ae", "patch": "@@ -45,9 +45,11 @@ struct RcBox<T> {\n /// Immutable reference counted pointer type\n #[unsafe_no_drop_flag]\n pub struct Rc<T> {\n-    ptr: *mut RcBox<T>,\n-    nosend: marker::NoSend,\n-    noshare: marker::NoShare\n+    // FIXME #12808: strange names to try to avoid interfering with\n+    // field accesses of the contained type via Deref\n+    _ptr: *mut RcBox<T>,\n+    _nosend: marker::NoSend,\n+    _noshare: marker::NoShare\n }\n \n impl<T> Rc<T> {\n@@ -60,13 +62,13 @@ impl<T> Rc<T> {\n                 // destructor never frees the allocation while the\n                 // strong destructor is running, even if the weak\n                 // pointer is stored inside the strong one.\n-                ptr: transmute(box RcBox {\n+                _ptr: transmute(box RcBox {\n                     value: value,\n                     strong: Cell::new(1),\n                     weak: Cell::new(1)\n                 }),\n-                nosend: marker::NoSend,\n-                noshare: marker::NoShare\n+                _nosend: marker::NoSend,\n+                _noshare: marker::NoShare\n             }\n         }\n     }\n@@ -77,9 +79,9 @@ impl<T> Rc<T> {\n     pub fn downgrade(&self) -> Weak<T> {\n         self.inc_weak();\n         Weak {\n-            ptr: self.ptr,\n-            nosend: marker::NoSend,\n-            noshare: marker::NoShare\n+            _ptr: self._ptr,\n+            _nosend: marker::NoSend,\n+            _noshare: marker::NoShare\n         }\n     }\n }\n@@ -96,7 +98,7 @@ impl<T> Deref<T> for Rc<T> {\n impl<T> Drop for Rc<T> {\n     fn drop(&mut self) {\n         unsafe {\n-            if !self.ptr.is_null() {\n+            if !self._ptr.is_null() {\n                 self.dec_strong();\n                 if self.strong() == 0 {\n                     ptr::read(self.deref()); // destroy the contained object\n@@ -106,7 +108,7 @@ impl<T> Drop for Rc<T> {\n                     self.dec_weak();\n \n                     if self.weak() == 0 {\n-                        deallocate(self.ptr as *mut u8, size_of::<RcBox<T>>(),\n+                        deallocate(self._ptr as *mut u8, size_of::<RcBox<T>>(),\n                                    min_align_of::<RcBox<T>>())\n                     }\n                 }\n@@ -119,7 +121,7 @@ impl<T> Clone for Rc<T> {\n     #[inline]\n     fn clone(&self) -> Rc<T> {\n         self.inc_strong();\n-        Rc { ptr: self.ptr, nosend: marker::NoSend, noshare: marker::NoShare }\n+        Rc { _ptr: self._ptr, _nosend: marker::NoSend, _noshare: marker::NoShare }\n     }\n }\n \n@@ -154,9 +156,11 @@ impl<T: TotalOrd> TotalOrd for Rc<T> {\n /// Weak reference to a reference-counted box\n #[unsafe_no_drop_flag]\n pub struct Weak<T> {\n-    ptr: *mut RcBox<T>,\n-    nosend: marker::NoSend,\n-    noshare: marker::NoShare\n+    // FIXME #12808: strange names to try to avoid interfering with\n+    // field accesses of the contained type via Deref\n+    _ptr: *mut RcBox<T>,\n+    _nosend: marker::NoSend,\n+    _noshare: marker::NoShare\n }\n \n impl<T> Weak<T> {\n@@ -166,7 +170,7 @@ impl<T> Weak<T> {\n             None\n         } else {\n             self.inc_strong();\n-            Some(Rc { ptr: self.ptr, nosend: marker::NoSend, noshare: marker::NoShare })\n+            Some(Rc { _ptr: self._ptr, _nosend: marker::NoSend, _noshare: marker::NoShare })\n         }\n     }\n }\n@@ -175,12 +179,12 @@ impl<T> Weak<T> {\n impl<T> Drop for Weak<T> {\n     fn drop(&mut self) {\n         unsafe {\n-            if !self.ptr.is_null() {\n+            if !self._ptr.is_null() {\n                 self.dec_weak();\n                 // the weak count starts at 1, and will only go to\n                 // zero if all the strong pointers have disappeared.\n                 if self.weak() == 0 {\n-                    deallocate(self.ptr as *mut u8, size_of::<RcBox<T>>(),\n+                    deallocate(self._ptr as *mut u8, size_of::<RcBox<T>>(),\n                                min_align_of::<RcBox<T>>())\n                 }\n             }\n@@ -192,7 +196,7 @@ impl<T> Clone for Weak<T> {\n     #[inline]\n     fn clone(&self) -> Weak<T> {\n         self.inc_weak();\n-        Weak { ptr: self.ptr, nosend: marker::NoSend, noshare: marker::NoShare }\n+        Weak { _ptr: self._ptr, _nosend: marker::NoSend, _noshare: marker::NoShare }\n     }\n }\n \n@@ -221,12 +225,12 @@ trait RcBoxPtr<T> {\n \n impl<T> RcBoxPtr<T> for Rc<T> {\n     #[inline(always)]\n-    fn inner<'a>(&'a self) -> &'a RcBox<T> { unsafe { &(*self.ptr) } }\n+    fn inner<'a>(&'a self) -> &'a RcBox<T> { unsafe { &(*self._ptr) } }\n }\n \n impl<T> RcBoxPtr<T> for Weak<T> {\n     #[inline(always)]\n-    fn inner<'a>(&'a self) -> &'a RcBox<T> { unsafe { &(*self.ptr) } }\n+    fn inner<'a>(&'a self) -> &'a RcBox<T> { unsafe { &(*self._ptr) } }\n }\n \n #[cfg(test)]"}, {"sha": "3e4c67c4d1ff594679203ffe52fb24147ed01969", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 18, "deletions": 14, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/bbb70cdd9cd982922cf7390459d53bde409699ae/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbb70cdd9cd982922cf7390459d53bde409699ae/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=bbb70cdd9cd982922cf7390459d53bde409699ae", "patch": "@@ -250,7 +250,7 @@ impl<T> RefCell<T> {\n             WRITING => None,\n             borrow => {\n                 self.borrow.set(borrow + 1);\n-                Some(Ref { parent: self })\n+                Some(Ref { _parent: self })\n             }\n         }\n     }\n@@ -280,7 +280,7 @@ impl<T> RefCell<T> {\n         match self.borrow.get() {\n             UNUSED => {\n                 self.borrow.set(WRITING);\n-                Some(RefMut { parent: self })\n+                Some(RefMut { _parent: self })\n             },\n             _ => None\n         }\n@@ -316,22 +316,24 @@ impl<T: Eq> Eq for RefCell<T> {\n \n /// Wraps a borrowed reference to a value in a `RefCell` box.\n pub struct Ref<'b, T> {\n-    parent: &'b RefCell<T>\n+    // FIXME #12808: strange name to try to avoid interfering with\n+    // field accesses of the contained type via Deref\n+    _parent: &'b RefCell<T>\n }\n \n #[unsafe_destructor]\n impl<'b, T> Drop for Ref<'b, T> {\n     fn drop(&mut self) {\n-        let borrow = self.parent.borrow.get();\n+        let borrow = self._parent.borrow.get();\n         debug_assert!(borrow != WRITING && borrow != UNUSED);\n-        self.parent.borrow.set(borrow - 1);\n+        self._parent.borrow.set(borrow - 1);\n     }\n }\n \n impl<'b, T> Deref<T> for Ref<'b, T> {\n     #[inline]\n     fn deref<'a>(&'a self) -> &'a T {\n-        unsafe { &*self.parent.value.get() }\n+        unsafe { &*self._parent.value.get() }\n     }\n }\n \n@@ -345,40 +347,42 @@ impl<'b, T> Deref<T> for Ref<'b, T> {\n pub fn clone_ref<'b, T>(orig: &Ref<'b, T>) -> Ref<'b, T> {\n     // Since this Ref exists, we know the borrow flag\n     // is not set to WRITING.\n-    let borrow = orig.parent.borrow.get();\n+    let borrow = orig._parent.borrow.get();\n     debug_assert!(borrow != WRITING && borrow != UNUSED);\n-    orig.parent.borrow.set(borrow + 1);\n+    orig._parent.borrow.set(borrow + 1);\n \n     Ref {\n-        parent: orig.parent,\n+        _parent: orig._parent,\n     }\n }\n \n /// Wraps a mutable borrowed reference to a value in a `RefCell` box.\n pub struct RefMut<'b, T> {\n-    parent: &'b RefCell<T>\n+    // FIXME #12808: strange name to try to avoid interfering with\n+    // field accesses of the contained type via Deref\n+    _parent: &'b RefCell<T>\n }\n \n #[unsafe_destructor]\n impl<'b, T> Drop for RefMut<'b, T> {\n     fn drop(&mut self) {\n-        let borrow = self.parent.borrow.get();\n+        let borrow = self._parent.borrow.get();\n         debug_assert!(borrow == WRITING);\n-        self.parent.borrow.set(UNUSED);\n+        self._parent.borrow.set(UNUSED);\n     }\n }\n \n impl<'b, T> Deref<T> for RefMut<'b, T> {\n     #[inline]\n     fn deref<'a>(&'a self) -> &'a T {\n-        unsafe { &*self.parent.value.get() }\n+        unsafe { &*self._parent.value.get() }\n     }\n }\n \n impl<'b, T> DerefMut<T> for RefMut<'b, T> {\n     #[inline]\n     fn deref_mut<'a>(&'a mut self) -> &'a mut T {\n-        unsafe { &mut *self.parent.value.get() }\n+        unsafe { &mut *self._parent.value.get() }\n     }\n }\n "}, {"sha": "2c7e16cf18bc1261279c9aedbf03b16c96fda66a", "filename": "src/libstd/local_data.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/bbb70cdd9cd982922cf7390459d53bde409699ae/src%2Flibstd%2Flocal_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbb70cdd9cd982922cf7390459d53bde409699ae/src%2Flibstd%2Flocal_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flocal_data.rs?ref=bbb70cdd9cd982922cf7390459d53bde409699ae", "patch": "@@ -127,10 +127,12 @@ fn key_to_key_value<T: 'static>(key: Key<T>) -> *u8 {\n /// The task-local data can be accessed through this value, and when this\n /// structure is dropped it will return the borrow on the data.\n pub struct Ref<T> {\n-    ptr: &'static T,\n-    key: Key<T>,\n-    index: uint,\n-    nosend: marker::NoSend,\n+    // FIXME #12808: strange names to try to avoid interfering with\n+    // field accesses of the contained type via Deref\n+    _ptr: &'static T,\n+    _key: Key<T>,\n+    _index: uint,\n+    _nosend: marker::NoSend,\n }\n \n impl<T: 'static> KeyValue<T> {\n@@ -233,7 +235,7 @@ impl<T: 'static> KeyValue<T> {\n                 let data = data as *Box<LocalData:Send> as *raw::TraitObject;\n                 &mut *((*data).data as *mut T)\n             };\n-            Ref { ptr: ptr, index: pos, nosend: marker::NoSend, key: self }\n+            Ref { _ptr: ptr, _index: pos, _nosend: marker::NoSend, _key: self }\n         })\n     }\n \n@@ -252,15 +254,15 @@ impl<T: 'static> KeyValue<T> {\n }\n \n impl<T: 'static> Deref<T> for Ref<T> {\n-    fn deref<'a>(&'a self) -> &'a T { self.ptr }\n+    fn deref<'a>(&'a self) -> &'a T { self._ptr }\n }\n \n #[unsafe_destructor]\n impl<T: 'static> Drop for Ref<T> {\n     fn drop(&mut self) {\n         let map = unsafe { get_local_map() };\n \n-        let (_, _, ref mut loan) = *map.get_mut(self.index).get_mut_ref();\n+        let (_, _, ref mut loan) = *map.get_mut(self._index).get_mut_ref();\n         *loan -= 1;\n     }\n }"}, {"sha": "1b620185610e4f50c44b5854e30df21831e42dd1", "filename": "src/libsync/lock.rs", "status": "modified", "additions": 22, "deletions": 17, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/bbb70cdd9cd982922cf7390459d53bde409699ae/src%2Flibsync%2Flock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbb70cdd9cd982922cf7390459d53bde409699ae/src%2Flibsync%2Flock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Flock.rs?ref=bbb70cdd9cd982922cf7390459d53bde409699ae", "patch": "@@ -174,7 +174,9 @@ pub struct Mutex<T> {\n /// An guard which is created by locking a mutex. Through this guard the\n /// underlying data can be accessed.\n pub struct MutexGuard<'a, T> {\n-    data: &'a mut T,\n+    // FIXME #12808: strange name to try to avoid interfering with\n+    // field accesses of the contained type via Deref\n+    _data: &'a mut T,\n     /// Inner condition variable connected to the locked mutex that this guard\n     /// was created from. This can be used for atomic-unlock-and-deschedule.\n     pub cond: Condvar<'a>,\n@@ -221,7 +223,7 @@ impl<T: Send> Mutex<T> {\n         let data = unsafe { &mut *self.data.get() };\n \n         MutexGuard {\n-            data: data,\n+            _data: data,\n             cond: Condvar {\n                 name: \"Mutex\",\n                 poison: PoisonOnFail::new(poison, \"Mutex\"),\n@@ -232,10 +234,10 @@ impl<T: Send> Mutex<T> {\n }\n \n impl<'a, T: Send> Deref<T> for MutexGuard<'a, T> {\n-    fn deref<'a>(&'a self) -> &'a T { &*self.data }\n+    fn deref<'a>(&'a self) -> &'a T { &*self._data }\n }\n impl<'a, T: Send> DerefMut<T> for MutexGuard<'a, T> {\n-    fn deref_mut<'a>(&'a mut self) -> &'a mut T { &mut *self.data }\n+    fn deref_mut<'a>(&'a mut self) -> &'a mut T { &mut *self._data }\n }\n \n /****************************************************************************\n@@ -272,7 +274,9 @@ pub struct RWLock<T> {\n /// A guard which is created by locking an rwlock in write mode. Through this\n /// guard the underlying data can be accessed.\n pub struct RWLockWriteGuard<'a, T> {\n-    data: &'a mut T,\n+    // FIXME #12808: strange name to try to avoid interfering with\n+    // field accesses of the contained type via Deref\n+    _data: &'a mut T,\n     /// Inner condition variable that can be used to sleep on the write mode of\n     /// this rwlock.\n     pub cond: Condvar<'a>,\n@@ -281,8 +285,10 @@ pub struct RWLockWriteGuard<'a, T> {\n /// A guard which is created by locking an rwlock in read mode. Through this\n /// guard the underlying data can be accessed.\n pub struct RWLockReadGuard<'a, T> {\n-    data: &'a T,\n-    guard: raw::RWLockReadGuard<'a>,\n+    // FIXME #12808: strange names to try to avoid interfering with\n+    // field accesses of the contained type via Deref\n+    _data: &'a T,\n+    _guard: raw::RWLockReadGuard<'a>,\n }\n \n impl<T: Send + Share> RWLock<T> {\n@@ -320,7 +326,7 @@ impl<T: Send + Share> RWLock<T> {\n         let data = unsafe { &mut *self.data.get() };\n \n         RWLockWriteGuard {\n-            data: data,\n+            _data: data,\n             cond: Condvar {\n                 name: \"RWLock\",\n                 poison: PoisonOnFail::new(poison, \"RWLock\"),\n@@ -340,8 +346,8 @@ impl<T: Send + Share> RWLock<T> {\n         let guard = self.lock.read();\n         PoisonOnFail::check(unsafe { *self.failed.get() }, \"RWLock\");\n         RWLockReadGuard {\n-            guard: guard,\n-            data: unsafe { &*self.data.get() },\n+            _guard: guard,\n+            _data: unsafe { &*self.data.get() },\n         }\n     }\n }\n@@ -351,25 +357,25 @@ impl<'a, T: Send + Share> RWLockWriteGuard<'a, T> {\n     ///\n     /// This will allow pending readers to come into the lock.\n     pub fn downgrade(self) -> RWLockReadGuard<'a, T> {\n-        let RWLockWriteGuard { data, cond } = self;\n+        let RWLockWriteGuard { _data, cond } = self;\n         // convert the data to read-only explicitly\n-        let data = &*data;\n+        let data = &*_data;\n         let guard = match cond.inner {\n             InnerMutex(..) => unreachable!(),\n             InnerRWLock(guard) => guard.downgrade()\n         };\n-        RWLockReadGuard { guard: guard, data: data }\n+        RWLockReadGuard { _guard: guard, _data: data }\n     }\n }\n \n impl<'a, T: Send + Share> Deref<T> for RWLockReadGuard<'a, T> {\n-    fn deref<'a>(&'a self) -> &'a T { self.data }\n+    fn deref<'a>(&'a self) -> &'a T { self._data }\n }\n impl<'a, T: Send + Share> Deref<T> for RWLockWriteGuard<'a, T> {\n-    fn deref<'a>(&'a self) -> &'a T { &*self.data }\n+    fn deref<'a>(&'a self) -> &'a T { &*self._data }\n }\n impl<'a, T: Send + Share> DerefMut<T> for RWLockWriteGuard<'a, T> {\n-    fn deref_mut<'a>(&'a mut self) -> &'a mut T { &mut *self.data }\n+    fn deref_mut<'a>(&'a mut self) -> &'a mut T { &mut *self._data }\n }\n \n /****************************************************************************\n@@ -812,4 +818,3 @@ mod tests {\n         }\n     }\n }\n-"}]}