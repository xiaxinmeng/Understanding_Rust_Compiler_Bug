{"sha": "9880e29fa195b180423e1ccd31551be0202266ba", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk4ODBlMjlmYTE5NWIxODA0MjNlMWNjZDMxNTUxYmUwMjAyMjY2YmE=", "commit": {"author": {"name": "kennytm", "email": "kennytm@gmail.com", "date": "2018-10-26T10:25:07Z"}, "committer": {"name": "kennytm", "email": "kennytm@gmail.com", "date": "2018-10-26T15:06:35Z"}, "message": "Rollup merge of #55302 - goffrie:impl-stable-hash, r=varkor\n\nExtend the impl_stable_hash_for! macro for miri.\n\nFixes #54075.", "tree": {"sha": "bc25aeedc14ffed46ee891a6bddb6f9f50f50d8a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bc25aeedc14ffed46ee891a6bddb6f9f50f50d8a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9880e29fa195b180423e1ccd31551be0202266ba", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEZ1R8CLMp8f2GxWoQ/vbIBR0OATwFAlvTLXsACgkQ/vbIBR0O\nATwVRg//b4F2lHS4bVkMOQwbD1ahkkiJpFER//Iyvq1lEFSFb52G7t0N3k3H2khL\n63zhuvHxZbW17QEb4UrZ2HEBGGbj+X3yRGdsX3EbFhQNLCwusqbeH9o9yCHp23lj\nTAEdAK95svwAKo2Yjep5W2otq/uZqNoZwK4ZgzpLLyCmKyy5HnPolMzCKMKfJM78\nntLmlWMGAAI3O1+O9MSjwpAKqYUMYcgiP8gvokuKxUFgCL72uNNazgj/1gt5CC7w\nNjnOU/dSum3hH04JVmVz3FiwaP+utuhGzhA1eq4mQgZiuv/PnIfvPaQEc7woDfOz\nBhHD4ihIWx24eiCRpkPORwGh6AsIBSsH92jeaLWYMhU3ti0OiZAQWTGSsJrhaCHq\nlf7MWfXCNdm4y3muz3zBXLPnG9CgcZ7p7h1t6fa8NrJ978c+OTU+Zblc8y5HUMYS\nvbCGu9SKBf69vpACaByW0zCjWH1Owv+x0BxcPYdTVhvtZPHG0UGRBxIkTgcksDmc\nv5jh7PpWV13lj681MGGaZrRxemnN98siwKMmi1BIO2CZn9iMmo/X614qqoMlAio9\nzV6GKi90j6x7yWqi4rHEt1iFc7BOTgs2d1jwYfM07bm53LTVS5tfHxaMLpfFPU1v\n+mHnfnpkTkHxeowp8rtiRLoL4a5G33rBS7ErqTwdbLsu6JHaxCI=\n=VY22\n-----END PGP SIGNATURE-----", "payload": "tree bc25aeedc14ffed46ee891a6bddb6f9f50f50d8a\nparent e897fe711ec4583fbbdce6faa67b4b340883d9e0\nparent 4747d83c7059049ddb088c3d0087ab9e501bbf9a\nauthor kennytm <kennytm@gmail.com> 1540549507 +0800\ncommitter kennytm <kennytm@gmail.com> 1540566395 +0800\n\nRollup merge of #55302 - goffrie:impl-stable-hash, r=varkor\n\nExtend the impl_stable_hash_for! macro for miri.\n\nFixes #54075.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9880e29fa195b180423e1ccd31551be0202266ba", "html_url": "https://github.com/rust-lang/rust/commit/9880e29fa195b180423e1ccd31551be0202266ba", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9880e29fa195b180423e1ccd31551be0202266ba/comments", "author": {"login": "kennytm", "id": 103023, "node_id": "MDQ6VXNlcjEwMzAyMw==", "avatar_url": "https://avatars.githubusercontent.com/u/103023?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kennytm", "html_url": "https://github.com/kennytm", "followers_url": "https://api.github.com/users/kennytm/followers", "following_url": "https://api.github.com/users/kennytm/following{/other_user}", "gists_url": "https://api.github.com/users/kennytm/gists{/gist_id}", "starred_url": "https://api.github.com/users/kennytm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kennytm/subscriptions", "organizations_url": "https://api.github.com/users/kennytm/orgs", "repos_url": "https://api.github.com/users/kennytm/repos", "events_url": "https://api.github.com/users/kennytm/events{/privacy}", "received_events_url": "https://api.github.com/users/kennytm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kennytm", "id": 103023, "node_id": "MDQ6VXNlcjEwMzAyMw==", "avatar_url": "https://avatars.githubusercontent.com/u/103023?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kennytm", "html_url": "https://github.com/kennytm", "followers_url": "https://api.github.com/users/kennytm/followers", "following_url": "https://api.github.com/users/kennytm/following{/other_user}", "gists_url": "https://api.github.com/users/kennytm/gists{/gist_id}", "starred_url": "https://api.github.com/users/kennytm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kennytm/subscriptions", "organizations_url": "https://api.github.com/users/kennytm/orgs", "repos_url": "https://api.github.com/users/kennytm/repos", "events_url": "https://api.github.com/users/kennytm/events{/privacy}", "received_events_url": "https://api.github.com/users/kennytm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e897fe711ec4583fbbdce6faa67b4b340883d9e0", "url": "https://api.github.com/repos/rust-lang/rust/commits/e897fe711ec4583fbbdce6faa67b4b340883d9e0", "html_url": "https://github.com/rust-lang/rust/commit/e897fe711ec4583fbbdce6faa67b4b340883d9e0"}, {"sha": "4747d83c7059049ddb088c3d0087ab9e501bbf9a", "url": "https://api.github.com/repos/rust-lang/rust/commits/4747d83c7059049ddb088c3d0087ab9e501bbf9a", "html_url": "https://github.com/rust-lang/rust/commit/4747d83c7059049ddb088c3d0087ab9e501bbf9a"}], "stats": {"total": 116, "additions": 40, "deletions": 76}, "files": [{"sha": "f21f949c9f5cd220d8508c0e95225d1c7e6c6fd0", "filename": "src/librustc/macros.rs", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/9880e29fa195b180423e1ccd31551be0202266ba/src%2Flibrustc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9880e29fa195b180423e1ccd31551be0202266ba/src%2Flibrustc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmacros.rs?ref=9880e29fa195b180423e1ccd31551be0202266ba", "patch": "@@ -83,7 +83,14 @@ macro_rules! __impl_stable_hash_field {\n macro_rules! impl_stable_hash_for {\n     // FIXME(mark-i-m): Some of these should be `?` rather than `*`. See the git blame and change\n     // them back when `?` is supported again.\n-    (enum $enum_name:path { $( $variant:ident $( ( $($field:ident $(-> $delegate:tt)*),* ) )* ),* $(,)* }) => {\n+    (enum $enum_name:path {\n+        $( $variant:ident\n+           // this incorrectly allows specifying both tuple-like and struct-like fields, as in `Variant(a,b){c,d}`,\n+           // when it should be only one or the other\n+           $( ( $($field:ident $(-> $delegate:tt)*),* ) )*\n+           $( { $($named_field:ident $(-> $named_delegate:tt)*),* } )*\n+        ),* $(,)*\n+    }) => {\n         impl<'a, 'tcx> ::rustc_data_structures::stable_hasher::HashStable<$crate::ich::StableHashingContext<'a>> for $enum_name {\n             #[inline]\n             fn hash_stable<W: ::rustc_data_structures::stable_hasher::StableHasherResult>(&self,\n@@ -94,8 +101,9 @@ macro_rules! impl_stable_hash_for {\n \n                 match *self {\n                     $(\n-                        $variant $( ( $(ref $field),* ) )* => {\n+                        $variant $( ( $(ref $field),* ) )* $( { $(ref $named_field),* } )* => {\n                             $($( __impl_stable_hash_field!($field, __ctx, __hasher $(, $delegate)*) );*)*\n+                            $($( __impl_stable_hash_field!($named_field, __ctx, __hasher $(, $named_delegate)*) );*)*\n                         }\n                     )*\n                 }\n@@ -133,10 +141,11 @@ macro_rules! impl_stable_hash_for {\n         }\n     };\n \n-    (impl<$tcx:lifetime $(, $T:ident)*> for struct $struct_name:path {\n-        $($field:ident),* $(,)*\n+    (impl<$tcx:lifetime $(, $lt:lifetime $(: $lt_bound:lifetime)*)* $(, $T:ident)*> for struct $struct_name:path {\n+        $($field:ident $(-> $delegate:tt)*),* $(,)*\n     }) => {\n-        impl<'a, $tcx, $($T,)*> ::rustc_data_structures::stable_hasher::HashStable<$crate::ich::StableHashingContext<'a>> for $struct_name\n+        impl<'a, $tcx, $($lt $(: $lt_bound)*,)* $($T,)*>\n+            ::rustc_data_structures::stable_hasher::HashStable<$crate::ich::StableHashingContext<'a>> for $struct_name\n             where $($T: ::rustc_data_structures::stable_hasher::HashStable<$crate::ich::StableHashingContext<'a>>),*\n         {\n             #[inline]\n@@ -147,7 +156,7 @@ macro_rules! impl_stable_hash_for {\n                     $(ref $field),*\n                 } = *self;\n \n-                $( $field.hash_stable(__ctx, __hasher));*\n+                $( __impl_stable_hash_field!($field, __ctx, __hasher $(, $delegate)*) );*\n             }\n         }\n     };"}, {"sha": "cff2288fd8720c3ac04cd97045a105d8617d8d29", "filename": "src/librustc_mir/interpret/snapshot.rs", "status": "modified", "additions": 25, "deletions": 70, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/9880e29fa195b180423e1ccd31551be0202266ba/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9880e29fa195b180423e1ccd31551be0202266ba/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs?ref=9880e29fa195b180423e1ccd31551be0202266ba", "patch": "@@ -6,9 +6,8 @@\n // it is not used by the general miri engine, just by CTFE.\n \n use std::hash::{Hash, Hasher};\n-use std::mem;\n \n-use rustc::ich::{StableHashingContext, StableHashingContextProvider};\n+use rustc::ich::StableHashingContextProvider;\n use rustc::mir;\n use rustc::mir::interpret::{\n     AllocId, Pointer, Scalar,\n@@ -20,7 +19,7 @@ use rustc::ty::{self, TyCtxt};\n use rustc::ty::layout::Align;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::indexed_vec::IndexVec;\n-use rustc_data_structures::stable_hasher::{HashStable, StableHasher, StableHasherResult};\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use syntax::ast::Mutability;\n use syntax::source_map::Span;\n \n@@ -217,23 +216,10 @@ impl_snapshot_for!(struct MemPlace {\n     align -> *align, // just copy alignment verbatim\n });\n \n-// Can't use the macro here because that does not support named enum fields.\n-impl<'a> HashStable<StableHashingContext<'a>> for Place {\n-    fn hash_stable<W: StableHasherResult>(\n-        &self, hcx: &mut StableHashingContext<'a>,\n-        hasher: &mut StableHasher<W>)\n-    {\n-        mem::discriminant(self).hash_stable(hcx, hasher);\n-        match self {\n-            Place::Ptr(mem_place) => mem_place.hash_stable(hcx, hasher),\n-\n-            Place::Local { frame, local } => {\n-                frame.hash_stable(hcx, hasher);\n-                local.hash_stable(hcx, hasher);\n-            },\n-        }\n-    }\n-}\n+impl_stable_hash_for!(enum ::interpret::Place {\n+    Ptr(mem_place),\n+    Local { frame, local },\n+});\n impl<'a, Ctx> Snapshot<'a, Ctx> for Place\n     where Ctx: SnapshotContext<'a>,\n {\n@@ -317,20 +303,10 @@ impl<'a, Ctx> Snapshot<'a, Ctx> for &'a Allocation\n     }\n }\n \n-// Can't use the macro here because that does not support named enum fields.\n-impl<'a> HashStable<StableHashingContext<'a>> for StackPopCleanup {\n-    fn hash_stable<W: StableHasherResult>(\n-        &self,\n-        hcx: &mut StableHashingContext<'a>,\n-        hasher: &mut StableHasher<W>)\n-    {\n-        mem::discriminant(self).hash_stable(hcx, hasher);\n-        match self {\n-            StackPopCleanup::Goto(ref block) => block.hash_stable(hcx, hasher),\n-            StackPopCleanup::None { cleanup } => cleanup.hash_stable(hcx, hasher),\n-        }\n-    }\n-}\n+impl_stable_hash_for!(enum ::interpret::eval_context::StackPopCleanup {\n+    Goto(block),\n+    None { cleanup },\n+});\n \n #[derive(Eq, PartialEq)]\n struct FrameSnapshot<'a, 'tcx: 'a> {\n@@ -343,28 +319,17 @@ struct FrameSnapshot<'a, 'tcx: 'a> {\n     stmt: usize,\n }\n \n-// Not using the macro because that does not support types depending on two lifetimes\n-impl<'a, 'mir, 'tcx: 'mir> HashStable<StableHashingContext<'a>> for Frame<'mir, 'tcx> {\n-    fn hash_stable<W: StableHasherResult>(\n-        &self,\n-        hcx: &mut StableHashingContext<'a>,\n-        hasher: &mut StableHasher<W>) {\n-\n-        let Frame {\n-            mir,\n-            instance,\n-            span,\n-            return_to_block,\n-            return_place,\n-            locals,\n-            block,\n-            stmt,\n-        } = self;\n+impl_stable_hash_for!(impl<'tcx, 'mir: 'tcx> for struct Frame<'mir, 'tcx> {\n+    mir,\n+    instance,\n+    span,\n+    return_to_block,\n+    return_place -> (return_place.as_ref().map(|r| &**r)),\n+    locals,\n+    block,\n+    stmt,\n+});\n \n-        (mir, instance, span, return_to_block).hash_stable(hcx, hasher);\n-        (return_place.as_ref().map(|r| &**r), locals, block, stmt).hash_stable(hcx, hasher);\n-    }\n-}\n impl<'a, 'mir, 'tcx, Ctx> Snapshot<'a, Ctx> for &'a Frame<'mir, 'tcx>\n     where Ctx: SnapshotContext<'a>,\n {\n@@ -443,21 +408,11 @@ impl<'a, 'mir, 'tcx> Hash for EvalSnapshot<'a, 'mir, 'tcx>\n     }\n }\n \n-// Not using the macro because we need special handling for `memory`, which the macro\n-// does not support at the same time as the extra bounds on the type.\n-impl<'a, 'b, 'mir, 'tcx> HashStable<StableHashingContext<'b>>\n-    for EvalSnapshot<'a, 'mir, 'tcx>\n-{\n-    fn hash_stable<W: StableHasherResult>(\n-        &self,\n-        hcx: &mut StableHashingContext<'b>,\n-        hasher: &mut StableHasher<W>)\n-    {\n-        // Not hashing memory: Avoid hashing memory all the time during execution\n-        let EvalSnapshot{ memory: _, stack } = self;\n-        stack.hash_stable(hcx, hasher);\n-    }\n-}\n+impl_stable_hash_for!(impl<'tcx, 'b, 'mir> for struct EvalSnapshot<'b, 'mir, 'tcx> {\n+    // Not hashing memory: Avoid hashing memory all the time during execution\n+    memory -> _,\n+    stack,\n+});\n \n impl<'a, 'mir, 'tcx> Eq for EvalSnapshot<'a, 'mir, 'tcx>\n {}"}]}