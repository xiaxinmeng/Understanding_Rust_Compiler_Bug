{"sha": "d47196b2ec23a26c03b1546449f29300d42a4840", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ0NzE5NmIyZWMyM2EyNmMwM2IxNTQ2NDQ5ZjI5MzAwZDQyYTQ4NDA=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-03-02T12:09:13Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-03-06T21:41:49Z"}, "message": "miri value visitor: detect primitives by type, not layout", "tree": {"sha": "d3cb3de728d02119c8ed827ad58ff9a73c42f337", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d3cb3de728d02119c8ed827ad58ff9a73c42f337"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d47196b2ec23a26c03b1546449f29300d42a4840", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d47196b2ec23a26c03b1546449f29300d42a4840", "html_url": "https://github.com/rust-lang/rust/commit/d47196b2ec23a26c03b1546449f29300d42a4840", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d47196b2ec23a26c03b1546449f29300d42a4840/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6548be2ba95c29cfd0f3324f4b314a64853b2f57", "url": "https://api.github.com/repos/rust-lang/rust/commits/6548be2ba95c29cfd0f3324f4b314a64853b2f57", "html_url": "https://github.com/rust-lang/rust/commit/6548be2ba95c29cfd0f3324f4b314a64853b2f57"}], "stats": {"total": 294, "additions": 163, "deletions": 131}, "files": [{"sha": "defb490199b304b2eed937b0bb7df456ad2fb1b9", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 158, "deletions": 126, "changes": 284, "blob_url": "https://github.com/rust-lang/rust/blob/d47196b2ec23a26c03b1546449f29300d42a4840/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d47196b2ec23a26c03b1546449f29300d42a4840/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=d47196b2ec23a26c03b1546449f29300d42a4840", "patch": "@@ -306,23 +306,119 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, 'tcx, M\n         Ok(())\n     }\n \n-    fn visit_primitive(&mut self, value: OpTy<'tcx, M::PointerTag>) -> InterpResult<'tcx> {\n+    /// Check a reference or `Box`.\n+    fn check_safe_pointer(&mut self, value: OpTy<'tcx, M::PointerTag>) -> InterpResult<'tcx> {\n         let value = self.ecx.read_immediate(value)?;\n+        // Handle wide pointers.\n+        // Check metadata early, for better diagnostics\n+        let place = try_validation!(self.ecx.ref_to_mplace(value), \"undefined pointer\", self.path);\n+        if place.layout.is_unsized() {\n+            self.check_wide_ptr_meta(place.meta, place.layout)?;\n+        }\n+        // Make sure this is dereferenceable and all.\n+        let (size, align) = self\n+            .ecx\n+            .size_and_align_of(place.meta, place.layout)?\n+            // for the purpose of validity, consider foreign types to have\n+            // alignment and size determined by the layout (size will be 0,\n+            // alignment should take attributes into account).\n+            .unwrap_or_else(|| (place.layout.size, place.layout.align.abi));\n+        let ptr: Option<_> = match self.ecx.memory.check_ptr_access_align(\n+            place.ptr,\n+            size,\n+            Some(align),\n+            CheckInAllocMsg::InboundsTest,\n+        ) {\n+            Ok(ptr) => ptr,\n+            Err(err) => {\n+                info!(\n+                    \"{:?} did not pass access check for size {:?}, align {:?}\",\n+                    place.ptr, size, align\n+                );\n+                match err.kind {\n+                    err_unsup!(InvalidNullPointerUsage) => {\n+                        throw_validation_failure!(\"a NULL reference\", self.path)\n+                    }\n+                    err_unsup!(AlignmentCheckFailed { required, has }) => {\n+                        throw_validation_failure!(\n+                            format_args!(\n+                                \"an unaligned reference \\\n+                                    (required {} byte alignment but found {})\",\n+                                required.bytes(),\n+                                has.bytes()\n+                            ),\n+                            self.path\n+                        )\n+                    }\n+                    err_unsup!(ReadBytesAsPointer) => throw_validation_failure!(\n+                        \"a dangling reference (created from integer)\",\n+                        self.path\n+                    ),\n+                    _ => throw_validation_failure!(\n+                        \"a dangling reference (not entirely in bounds)\",\n+                        self.path\n+                    ),\n+                }\n+            }\n+        };\n+        // Recursive checking\n+        if let Some(ref mut ref_tracking) = self.ref_tracking_for_consts {\n+            if let Some(ptr) = ptr {\n+                // not a ZST\n+                // Skip validation entirely for some external statics\n+                let alloc_kind = self.ecx.tcx.alloc_map.lock().get(ptr.alloc_id);\n+                if let Some(GlobalAlloc::Static(did)) = alloc_kind {\n+                    // `extern static` cannot be validated as they have no body.\n+                    // FIXME: Statics from other crates are also skipped.\n+                    // They might be checked at a different type, but for now we\n+                    // want to avoid recursing too deeply.  This is not sound!\n+                    if !did.is_local() || self.ecx.tcx.is_foreign_item(did) {\n+                        return Ok(());\n+                    }\n+                }\n+            }\n+            // Proceed recursively even for ZST, no reason to skip them!\n+            // `!` is a ZST and we want to validate it.\n+            // Normalize before handing `place` to tracking because that will\n+            // check for duplicates.\n+            let place = if size.bytes() > 0 {\n+                self.ecx.force_mplace_ptr(place).expect(\"we already bounds-checked\")\n+            } else {\n+                place\n+            };\n+            let path = &self.path;\n+            ref_tracking.track(place, || {\n+                // We need to clone the path anyway, make sure it gets created\n+                // with enough space for the additional `Deref`.\n+                let mut new_path = Vec::with_capacity(path.len() + 1);\n+                new_path.clone_from(path);\n+                new_path.push(PathElem::Deref);\n+                new_path\n+            });\n+        }\n+        Ok(())\n+    }\n+\n+    /// Check if this is a value of primitive type, and if yes check the validity of the value\n+    /// at that type.  Return `true` if the type is indeed primitive.\n+    fn visit_primitive(&mut self, value: OpTy<'tcx, M::PointerTag>) -> InterpResult<'tcx, bool> {\n         // Go over all the primitive types\n         let ty = value.layout.ty;\n         match ty.kind {\n             ty::Bool => {\n-                let value = value.to_scalar_or_undef();\n+                let value = self.ecx.read_scalar(value)?;\n                 try_validation!(value.to_bool(), value, self.path, \"a boolean\");\n+                Ok(true)\n             }\n             ty::Char => {\n-                let value = value.to_scalar_or_undef();\n+                let value = self.ecx.read_scalar(value)?;\n                 try_validation!(value.to_char(), value, self.path, \"a valid unicode codepoint\");\n+                Ok(true)\n             }\n             ty::Float(_) | ty::Int(_) | ty::Uint(_) => {\n+                let value = self.ecx.read_scalar(value)?;\n                 // NOTE: Keep this in sync with the array optimization for int/float\n                 // types below!\n-                let value = value.to_scalar_or_undef();\n                 if self.ref_tracking_for_consts.is_some() {\n                     // Integers/floats in CTFE: Must be scalar bits, pointers are dangerous\n                     let is_bits = value.not_undef().map_or(false, |v| v.is_bits());\n@@ -337,120 +433,68 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, 'tcx, M\n                     // At run-time, for now, we accept *anything* for these types, including\n                     // undef. We should fix that, but let's start low.\n                 }\n+                Ok(true)\n             }\n             ty::RawPtr(..) => {\n                 // We are conservative with undef for integers, but try to\n                 // actually enforce our current rules for raw pointers.\n-                let place =\n-                    try_validation!(self.ecx.ref_to_mplace(value), \"undefined pointer\", self.path);\n+                let place = try_validation!(\n+                    self.ecx.ref_to_mplace(self.ecx.read_immediate(value)?),\n+                    \"undefined pointer\",\n+                    self.path\n+                );\n                 if place.layout.is_unsized() {\n                     self.check_wide_ptr_meta(place.meta, place.layout)?;\n                 }\n+                Ok(true)\n             }\n-            _ if ty.is_box() || ty.is_region_ptr() => {\n-                // Handle wide pointers.\n-                // Check metadata early, for better diagnostics\n-                let place =\n-                    try_validation!(self.ecx.ref_to_mplace(value), \"undefined pointer\", self.path);\n-                if place.layout.is_unsized() {\n-                    self.check_wide_ptr_meta(place.meta, place.layout)?;\n-                }\n-                // Make sure this is dereferenceable and all.\n-                let (size, align) = self\n-                    .ecx\n-                    .size_and_align_of(place.meta, place.layout)?\n-                    // for the purpose of validity, consider foreign types to have\n-                    // alignment and size determined by the layout (size will be 0,\n-                    // alignment should take attributes into account).\n-                    .unwrap_or_else(|| (place.layout.size, place.layout.align.abi));\n-                let ptr: Option<_> = match self.ecx.memory.check_ptr_access_align(\n-                    place.ptr,\n-                    size,\n-                    Some(align),\n-                    CheckInAllocMsg::InboundsTest,\n-                ) {\n-                    Ok(ptr) => ptr,\n-                    Err(err) => {\n-                        info!(\n-                            \"{:?} did not pass access check for size {:?}, align {:?}\",\n-                            place.ptr, size, align\n-                        );\n-                        match err.kind {\n-                            err_unsup!(InvalidNullPointerUsage) => {\n-                                throw_validation_failure!(\"a NULL reference\", self.path)\n-                            }\n-                            err_unsup!(AlignmentCheckFailed { required, has }) => {\n-                                throw_validation_failure!(\n-                                    format_args!(\n-                                        \"an unaligned reference \\\n-                                         (required {} byte alignment but found {})\",\n-                                        required.bytes(),\n-                                        has.bytes()\n-                                    ),\n-                                    self.path\n-                                )\n-                            }\n-                            err_unsup!(ReadBytesAsPointer) => throw_validation_failure!(\n-                                \"a dangling reference (created from integer)\",\n-                                self.path\n-                            ),\n-                            _ => throw_validation_failure!(\n-                                \"a dangling reference (not entirely in bounds)\",\n-                                self.path\n-                            ),\n-                        }\n-                    }\n-                };\n-                // Recursive checking\n-                if let Some(ref mut ref_tracking) = self.ref_tracking_for_consts {\n-                    if let Some(ptr) = ptr {\n-                        // not a ZST\n-                        // Skip validation entirely for some external statics\n-                        let alloc_kind = self.ecx.tcx.alloc_map.lock().get(ptr.alloc_id);\n-                        if let Some(GlobalAlloc::Static(did)) = alloc_kind {\n-                            // `extern static` cannot be validated as they have no body.\n-                            // FIXME: Statics from other crates are also skipped.\n-                            // They might be checked at a different type, but for now we\n-                            // want to avoid recursing too deeply.  This is not sound!\n-                            if !did.is_local() || self.ecx.tcx.is_foreign_item(did) {\n-                                return Ok(());\n-                            }\n-                        }\n-                    }\n-                    // Proceed recursively even for ZST, no reason to skip them!\n-                    // `!` is a ZST and we want to validate it.\n-                    // Normalize before handing `place` to tracking because that will\n-                    // check for duplicates.\n-                    let place = if size.bytes() > 0 {\n-                        self.ecx.force_mplace_ptr(place).expect(\"we already bounds-checked\")\n-                    } else {\n-                        place\n-                    };\n-                    let path = &self.path;\n-                    ref_tracking.track(place, || {\n-                        // We need to clone the path anyway, make sure it gets created\n-                        // with enough space for the additional `Deref`.\n-                        let mut new_path = Vec::with_capacity(path.len() + 1);\n-                        new_path.clone_from(path);\n-                        new_path.push(PathElem::Deref);\n-                        new_path\n-                    });\n-                }\n+            ty::Ref(..) => {\n+                self.check_safe_pointer(value)?;\n+                Ok(true)\n+            }\n+            ty::Adt(def, ..) if def.is_box() => {\n+                // FIXME make sure we have a test for `Box`!\n+                self.check_safe_pointer(value)?;\n+                Ok(true)\n             }\n             ty::FnPtr(_sig) => {\n-                let value = value.to_scalar_or_undef();\n+                let value = self.ecx.read_scalar(value)?;\n                 let _fn = try_validation!(\n                     value.not_undef().and_then(|ptr| self.ecx.memory.get_fn(ptr)),\n                     value,\n                     self.path,\n                     \"a function pointer\"\n                 );\n                 // FIXME: Check if the signature matches\n+                Ok(true)\n             }\n-            // This should be all the (inhabited) primitive types\n-            _ => bug!(\"Unexpected primitive type {}\", value.layout.ty),\n+            ty::Never => throw_validation_failure!(\"a value of the never type `!`\", self.path),\n+            ty::Foreign(..) | ty::FnDef(..) => {\n+                // Nothing to check.\n+                Ok(true)\n+            }\n+            // This should be all the (inhabited) primitive types. The rest is compound, we\n+            // check them by visiting their fields/variants.\n+            // (`Str` UTF-8 check happens in `visit_aggregate`, too.)\n+            ty::Adt(..)\n+            | ty::Tuple(..)\n+            | ty::Array(..)\n+            | ty::Slice(..)\n+            | ty::Str\n+            | ty::Dynamic(..)\n+            | ty::Closure(..)\n+            | ty::Generator(..)\n+            | ty::GeneratorWitness(..) => Ok(false),\n+            // Some types only occur during inference, we should not see them here.\n+            ty::Error\n+            | ty::Infer(..)\n+            | ty::Placeholder(..)\n+            | ty::Bound(..)\n+            | ty::Param(..)\n+            | ty::Opaque(..)\n+            | ty::UnnormalizedProjection(..)\n+            | ty::Projection(..) => bug!(\"Encountered invalid type {:?}\", ty),\n         }\n-        Ok(())\n     }\n \n     fn visit_scalar(\n@@ -558,40 +602,23 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n     }\n \n     #[inline(always)]\n-    fn visit_union(&mut self, _v: Self::V, fields: usize) -> InterpResult<'tcx> {\n-        // Empty unions are not accepted by rustc. That's great, it means we can\n-        // use that as a signal for detecting primitives.  Make sure\n-        // we did not miss any primitive.\n-        assert!(fields > 0);\n+    fn visit_union(&mut self, op: OpTy<'tcx, M::PointerTag>, fields: usize) -> InterpResult<'tcx> {\n+        // Empty unions are not accepted by rustc. But uninhabited enums\n+        // claim to be unions, so allow them, too.\n+        assert!(op.layout.abi.is_uninhabited() || fields > 0);\n         Ok(())\n     }\n \n     #[inline]\n     fn visit_value(&mut self, op: OpTy<'tcx, M::PointerTag>) -> InterpResult<'tcx> {\n         trace!(\"visit_value: {:?}, {:?}\", *op, op.layout);\n \n-        if op.layout.abi.is_uninhabited() {\n-            // Uninhabited types do not have sensible layout, stop right here.\n-            throw_validation_failure!(\n-                format_args!(\"a value of uninhabited type {:?}\", op.layout.ty),\n-                self.path\n-            )\n-        }\n-\n-        // Check primitive types.  We do this after checking for uninhabited types,\n-        // to exclude uninhabited enums (that also appear as fieldless unions here).\n-        // Primitives can have varying layout, so we check them separately and before aggregate\n-        // handling.\n-        // It is CRITICAL that we get this check right, or we might be validating the wrong thing!\n-        let primitive = match op.layout.fields {\n-            // Primitives appear as Union with 0 fields - except for Boxes and fat pointers.\n-            layout::FieldPlacement::Union(0) => true,\n-            _ => op.layout.ty.builtin_deref(true).is_some(),\n-        };\n-        if primitive {\n-            // No need to recurse further or check scalar layout, this is a leaf type.\n-            return self.visit_primitive(op);\n+        // Check primitive types -- the leafs of our recursive descend.\n+        if self.visit_primitive(op)? {\n+            return Ok(());\n         }\n+        // Sanity check: `builtin_deref` does not know any pointers that are not primitive.\n+        assert!(op.layout.ty.builtin_deref(true).is_none());\n \n         // Recursively walk the type. Translate some possible errors to something nicer.\n         match self.walk_value(op) {\n@@ -618,7 +645,12 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n         // scalars, we do the same check on every \"level\" (e.g., first we check\n         // MyNewtype and then the scalar in there).\n         match op.layout.abi {\n-            layout::Abi::Uninhabited => unreachable!(), // checked above\n+            layout::Abi::Uninhabited => {\n+                throw_validation_failure!(\n+                    format_args!(\"a value of uninhabited type {:?}\", op.layout.ty),\n+                    self.path\n+                );\n+            }\n             layout::Abi::Scalar(ref scalar_layout) => {\n                 self.visit_scalar(op, scalar_layout)?;\n             }"}, {"sha": "350d8353fef19efc18c8037f949f8208f004a73b", "filename": "src/test/ui/consts/const-eval/ub-uninhabit.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d47196b2ec23a26c03b1546449f29300d42a4840/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-uninhabit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d47196b2ec23a26c03b1546449f29300d42a4840/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-uninhabit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-uninhabit.stderr?ref=d47196b2ec23a26c03b1546449f29300d42a4840", "patch": "@@ -18,7 +18,7 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-uninhabit.rs:21:1\n    |\n LL | const BAD_BAD_ARRAY: [Bar; 1] = unsafe { (TransmuteUnion::<(), [Bar; 1]> { a: () }).b };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a value of uninhabited type [Bar; 1]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a value of uninhabited type Bar at [0]\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n "}, {"sha": "d0e35615dab42f3944a7c35b82f40b29e8ad7cff", "filename": "src/test/ui/consts/const-eval/validate_uninhabited_zsts.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d47196b2ec23a26c03b1546449f29300d42a4840/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fvalidate_uninhabited_zsts.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d47196b2ec23a26c03b1546449f29300d42a4840/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fvalidate_uninhabited_zsts.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fvalidate_uninhabited_zsts.stderr?ref=d47196b2ec23a26c03b1546449f29300d42a4840", "patch": "@@ -20,7 +20,7 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/validate_uninhabited_zsts.rs:17:1\n    |\n LL | const BAR: [Empty; 3] = [unsafe { std::mem::transmute(()) }; 3];\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a value of uninhabited type [Empty; 3]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a value of uninhabited type Empty at [0]\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n "}, {"sha": "77f0a2ebd4021721434ab61aff16a7f11b7d25e0", "filename": "src/test/ui/consts/validate_never_arrays.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d47196b2ec23a26c03b1546449f29300d42a4840/src%2Ftest%2Fui%2Fconsts%2Fvalidate_never_arrays.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d47196b2ec23a26c03b1546449f29300d42a4840/src%2Ftest%2Fui%2Fconsts%2Fvalidate_never_arrays.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fvalidate_never_arrays.stderr?ref=d47196b2ec23a26c03b1546449f29300d42a4840", "patch": "@@ -2,23 +2,23 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/validate_never_arrays.rs:3:1\n    |\n LL | const _: &[!; 1] = unsafe { &*(1_usize as *const [!; 1]) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a value of uninhabited type [!; 1] at .<deref>\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a value of the never type `!` at .<deref>[0]\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: it is undefined behavior to use this value\n   --> $DIR/validate_never_arrays.rs:6:1\n    |\n LL | const _: &[!] = unsafe { &*(1_usize as *const [!; 1]) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a value of uninhabited type ! at .<deref>[0]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a value of the never type `!` at .<deref>[0]\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: it is undefined behavior to use this value\n   --> $DIR/validate_never_arrays.rs:7:1\n    |\n LL | const _: &[!] = unsafe { &*(1_usize as *const [!; 42]) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a value of uninhabited type ! at .<deref>[0]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a value of the never type `!` at .<deref>[0]\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n "}]}