{"sha": "7e6dbd2b7f271aa773f754c4e5dd49ff046f12ba", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdlNmRiZDJiN2YyNzFhYTc3M2Y3NTRjNGU1ZGQ0OWZmMDQ2ZjEyYmE=", "commit": {"author": {"name": "Vytautas Astrauskas", "email": "astrauv@amazon.com", "date": "2020-03-31T20:45:54Z"}, "committer": {"name": "Vytautas Astrauskas", "email": "astrauv@amazon.com", "date": "2020-04-15T16:25:21Z"}, "message": "Address reviewers' comments: replace resolve_thread_local_allocation_id with resolve_maybe_global_alloc, clarify comments.", "tree": {"sha": "3f9188a06778d1e673212477956333061c033476", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3f9188a06778d1e673212477956333061c033476"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7e6dbd2b7f271aa773f754c4e5dd49ff046f12ba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7e6dbd2b7f271aa773f754c4e5dd49ff046f12ba", "html_url": "https://github.com/rust-lang/rust/commit/7e6dbd2b7f271aa773f754c4e5dd49ff046f12ba", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7e6dbd2b7f271aa773f754c4e5dd49ff046f12ba/comments", "author": null, "committer": null, "parents": [{"sha": "c53210c5501b60165b6eb8487268e3833191316a", "url": "https://api.github.com/repos/rust-lang/rust/commits/c53210c5501b60165b6eb8487268e3833191316a", "html_url": "https://github.com/rust-lang/rust/commit/c53210c5501b60165b6eb8487268e3833191316a"}], "stats": {"total": 50, "additions": 28, "deletions": 22}, "files": [{"sha": "e68d92555db516d99290eddea0859c32fb1e5a73", "filename": "src/librustc_mir/interpret/machine.rs", "status": "modified", "additions": 26, "deletions": 14, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/7e6dbd2b7f271aa773f754c4e5dd49ff046f12ba/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e6dbd2b7f271aa773f754c4e5dd49ff046f12ba/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs?ref=7e6dbd2b7f271aa773f754c4e5dd49ff046f12ba", "patch": "@@ -6,7 +6,7 @@ use std::borrow::{Borrow, Cow};\n use std::hash::Hash;\n \n use rustc_middle::mir;\n-use rustc_middle::ty::{self, Ty};\n+use rustc_middle::ty::{self, query::TyCtxtAt, Ty};\n use rustc_span::def_id::DefId;\n \n use super::{\n@@ -229,29 +229,41 @@ pub trait Machine<'mir, 'tcx>: Sized {\n         Ok(())\n     }\n \n-    /// Called for *every* memory access to determine the real ID of the given allocation.\n-    /// This provides a way for the machine to \"redirect\" certain allocations as it sees fit.\n+    /// Called for *every* memory access to determine the real ID of the given\n+    /// allocation. This provides a way for the machine to \"redirect\" certain\n+    /// allocations as it sees fit.\n     ///\n-    /// This is used by Miri to redirect extern statics to real allocations.\n+    /// This is used by Miri for two purposes:\n+    /// 1.  Redirecting extern statics to real allocations.\n+    /// 2.  Creating unique allocation ids for thread locals.\n+    ///\n+    ///     In Rust, one way for creating a thread local is by marking a static\n+    ///     with `#[thread_local]`. On supported platforms this gets translated\n+    ///     to a LLVM thread local. The problem with supporting these thread\n+    ///     locals in Miri is that in the internals of the compiler they look as\n+    ///     normal statics, except that they have the `thread_local` attribute.\n+    ///     However, in Miri we want to have a property that each allocation has\n+    ///     a unique id and, therefore, for these thread locals we generate a\n+    ///     fresh allocation id for each thread.\n     ///\n     /// This function must be idempotent.\n     #[inline]\n     fn canonical_alloc_id(_mem: &Memory<'mir, 'tcx, Self>, id: AllocId) -> AllocId {\n         id\n     }\n \n-    /// In Rust, thread locals are just special statics. Therefore, the compiler\n-    /// uses the same code for allocating both. However, in Miri we want to have\n-    /// a property that each allocation has a unique id and, therefore, we\n-    /// generate a fresh allocation id for each thread. This function takes a\n-    /// potentially thread local allocation id and resolves the original static\n-    /// allocation id that can be used to compute the value of the static.\n-    #[inline]\n-    fn resolve_thread_local_allocation_id(\n+    /// Called to obtain the `GlobalAlloc` associated with the allocation id.\n+    ///\n+    /// Miri uses this callback to resolve the information about the original\n+    /// thread local static for which `canonical_alloc_id` generated a fresh\n+    /// allocation id.\n+    #[inline(always)]\n+    fn resolve_maybe_global_alloc(\n+        tcx: TyCtxtAt<'tcx>,\n         _memory_extra: &Self::MemoryExtra,\n         id: AllocId,\n-    ) -> AllocId {\n-        id\n+    ) -> Option<mir::interpret::GlobalAlloc<'tcx>> {\n+        tcx.alloc_map.lock().get(id)\n     }\n \n     /// Called to initialize the \"extra\" state of an allocation and make the pointers"}, {"sha": "817d69d2878127e02a3d1f0e756d3ee0e1e691a1", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7e6dbd2b7f271aa773f754c4e5dd49ff046f12ba/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e6dbd2b7f271aa773f754c4e5dd49ff046f12ba/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=7e6dbd2b7f271aa773f754c4e5dd49ff046f12ba", "patch": "@@ -429,9 +429,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         id: AllocId,\n         is_write: bool,\n     ) -> InterpResult<'tcx, Cow<'tcx, Allocation<M::PointerTag, M::AllocExtra>>> {\n-        let alloc =\n-            tcx.alloc_map.lock().get(M::resolve_thread_local_allocation_id(memory_extra, id));\n-        let (alloc, def_id) = match alloc {\n+        let (alloc, def_id) = match M::resolve_maybe_global_alloc(tcx, memory_extra, id) {\n             Some(GlobalAlloc::Memory(mem)) => {\n                 // Memory of a constant or promoted or anonymous memory referenced by a static.\n                 (mem, None)\n@@ -591,11 +589,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         }\n \n         // # Statics\n-        // Can't do this in the match argument, we may get cycle errors since the lock would\n-        // be held throughout the match.\n-        let alloc =\n-            self.tcx.alloc_map.lock().get(M::resolve_thread_local_allocation_id(&self.extra, id));\n-        match alloc {\n+        match M::resolve_maybe_global_alloc(self.tcx, &self.extra, id) {\n             Some(GlobalAlloc::Static(did)) => {\n                 // Use size and align of the type.\n                 let ty = self.tcx.type_of(did);"}]}