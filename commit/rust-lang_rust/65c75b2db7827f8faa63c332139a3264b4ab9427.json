{"sha": "65c75b2db7827f8faa63c332139a3264b4ab9427", "node_id": "C_kwDOAAsO6NoAKDY1Yzc1YjJkYjc4MjdmOGZhYTYzYzMzMjEzOWEzMjY0YjRhYjk0Mjc", "commit": {"author": {"name": "\u0410\u0440\u0442\u0451\u043c \u041f\u0430\u0432\u043b\u043e\u0432", "email": "newpavlov@gmail.com", "date": "2022-04-14T17:44:09Z"}, "committer": {"name": "\u0410\u0440\u0442\u0451\u043c \u041f\u0430\u0432\u043b\u043e\u0432", "email": "newpavlov@gmail.com", "date": "2022-04-14T17:44:09Z"}, "message": "Use rounding in float to Duration conversion methods", "tree": {"sha": "f7b3d928561bb0988a6f2916389598e717be0a04", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f7b3d928561bb0988a6f2916389598e717be0a04"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/65c75b2db7827f8faa63c332139a3264b4ab9427", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/65c75b2db7827f8faa63c332139a3264b4ab9427", "html_url": "https://github.com/rust-lang/rust/commit/65c75b2db7827f8faa63c332139a3264b4ab9427", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/65c75b2db7827f8faa63c332139a3264b4ab9427/comments", "author": {"login": "newpavlov", "id": 329626, "node_id": "MDQ6VXNlcjMyOTYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/329626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/newpavlov", "html_url": "https://github.com/newpavlov", "followers_url": "https://api.github.com/users/newpavlov/followers", "following_url": "https://api.github.com/users/newpavlov/following{/other_user}", "gists_url": "https://api.github.com/users/newpavlov/gists{/gist_id}", "starred_url": "https://api.github.com/users/newpavlov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/newpavlov/subscriptions", "organizations_url": "https://api.github.com/users/newpavlov/orgs", "repos_url": "https://api.github.com/users/newpavlov/repos", "events_url": "https://api.github.com/users/newpavlov/events{/privacy}", "received_events_url": "https://api.github.com/users/newpavlov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "newpavlov", "id": 329626, "node_id": "MDQ6VXNlcjMyOTYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/329626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/newpavlov", "html_url": "https://github.com/newpavlov", "followers_url": "https://api.github.com/users/newpavlov/followers", "following_url": "https://api.github.com/users/newpavlov/following{/other_user}", "gists_url": "https://api.github.com/users/newpavlov/gists{/gist_id}", "starred_url": "https://api.github.com/users/newpavlov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/newpavlov/subscriptions", "organizations_url": "https://api.github.com/users/newpavlov/orgs", "repos_url": "https://api.github.com/users/newpavlov/repos", "events_url": "https://api.github.com/users/newpavlov/events{/privacy}", "received_events_url": "https://api.github.com/users/newpavlov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "563250a65c884c6767dc2ee2e2580360d33d561c", "url": "https://api.github.com/repos/rust-lang/rust/commits/563250a65c884c6767dc2ee2e2580360d33d561c", "html_url": "https://github.com/rust-lang/rust/commit/563250a65c884c6767dc2ee2e2580360d33d561c"}], "stats": {"total": 61, "additions": 38, "deletions": 23}, "files": [{"sha": "fc2484f0cdd44d78dff89e6863e9428fd2405329", "filename": "library/core/src/time.rs", "status": "modified", "additions": 38, "deletions": 23, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/65c75b2db7827f8faa63c332139a3264b4ab9427/library%2Fcore%2Fsrc%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65c75b2db7827f8faa63c332139a3264b4ab9427/library%2Fcore%2Fsrc%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ftime.rs?ref=65c75b2db7827f8faa63c332139a3264b4ab9427", "patch": "@@ -730,9 +730,9 @@ impl Duration {\n     /// // subnormal float\n     /// let res = Duration::from_secs_f64(f64::from_bits(1));\n     /// assert_eq!(res, Duration::new(0, 0));\n-    /// // conversion uses truncation, not rounding\n+    /// // conversion uses rounding\n     /// let res = Duration::from_secs_f64(0.999e-9);\n-    /// assert_eq!(res, Duration::new(0, 0));\n+    /// assert_eq!(res, Duration::new(0, 1));\n     /// ```\n     #[stable(feature = \"duration_float\", since = \"1.38.0\")]\n     #[must_use]\n@@ -760,17 +760,17 @@ impl Duration {\n     /// let res = Duration::from_secs_f32(1e-20);\n     /// assert_eq!(res, Duration::new(0, 0));\n     /// let res = Duration::from_secs_f32(4.2e-7);\n-    /// assert_eq!(res, Duration::new(0, 419));\n+    /// assert_eq!(res, Duration::new(0, 420));\n     /// let res = Duration::from_secs_f32(2.7);\n-    /// assert_eq!(res, Duration::new(2, 700_000_047));\n+    /// assert_eq!(res, Duration::new(2, 700_000_048));\n     /// let res = Duration::from_secs_f32(3e10);\n     /// assert_eq!(res, Duration::new(30_000_001_024, 0));\n     /// // subnormal float\n     /// let res = Duration::from_secs_f32(f32::from_bits(1));\n     /// assert_eq!(res, Duration::new(0, 0));\n-    /// // conversion uses truncation, not rounding\n+    /// // conversion uses rounding\n     /// let res = Duration::from_secs_f32(0.999e-9);\n-    /// assert_eq!(res, Duration::new(0, 0));\n+    /// assert_eq!(res, Duration::new(0, 1));\n     /// ```\n     #[stable(feature = \"duration_float\", since = \"1.38.0\")]\n     #[must_use]\n@@ -815,7 +815,7 @@ impl Duration {\n     /// use std::time::Duration;\n     ///\n     /// let dur = Duration::new(2, 700_000_000);\n-    /// assert_eq!(dur.mul_f32(3.14), Duration::new(8, 478_000_640));\n+    /// assert_eq!(dur.mul_f32(3.14), Duration::new(8, 478_000_641));\n     /// assert_eq!(dur.mul_f32(3.14e5), Duration::new(847800, 0));\n     /// ```\n     #[stable(feature = \"duration_float\", since = \"1.38.0\")]\n@@ -838,8 +838,7 @@ impl Duration {\n     ///\n     /// let dur = Duration::new(2, 700_000_000);\n     /// assert_eq!(dur.div_f64(3.14), Duration::new(0, 859_872_611));\n-    /// // note that truncation is used, not rounding\n-    /// assert_eq!(dur.div_f64(3.14e5), Duration::new(0, 8_598));\n+    /// assert_eq!(dur.div_f64(3.14e5), Duration::new(0, 8_599));\n     /// ```\n     #[stable(feature = \"duration_float\", since = \"1.38.0\")]\n     #[must_use = \"this returns the result of the operation, \\\n@@ -862,9 +861,8 @@ impl Duration {\n     /// let dur = Duration::new(2, 700_000_000);\n     /// // note that due to rounding errors result is slightly\n     /// // different from 0.859_872_611\n-    /// assert_eq!(dur.div_f32(3.14), Duration::new(0, 859_872_579));\n-    /// // note that truncation is used, not rounding\n-    /// assert_eq!(dur.div_f32(3.14e5), Duration::new(0, 8_598));\n+    /// assert_eq!(dur.div_f32(3.14), Duration::new(0, 859_872_580));\n+    /// assert_eq!(dur.div_f32(3.14e5), Duration::new(0, 8_599));\n     /// ```\n     #[stable(feature = \"duration_float\", since = \"1.38.0\")]\n     #[must_use = \"this returns the result of the operation, \\\n@@ -1278,13 +1276,30 @@ macro_rules! try_from_secs {\n         } else if exp < 0 {\n             // the input is less than 1 second\n             let t = <$double_ty>::from(mant) << ($offset + exp);\n-            let nanos = (u128::from(NANOS_PER_SEC) * u128::from(t)) >> ($mant_bits + $offset);\n-            (0, nanos as u32)\n+            let nanos_offset = $mant_bits + $offset;\n+            let nanos_tmp = u128::from(NANOS_PER_SEC) * u128::from(t);\n+            let nanos = (nanos_tmp >> nanos_offset) as u32;\n+            if nanos_tmp & (1 << (nanos_offset - 1)) == 0 {\n+                (0, nanos)\n+            } else if nanos + 1 != NANOS_PER_SEC {\n+                (0, nanos + 1)\n+            } else {\n+                (1, 0)\n+            }\n         } else if exp < $mant_bits {\n-            let secs = mant >> ($mant_bits - exp);\n+            let secs = u64::from(mant >> ($mant_bits - exp));\n             let t = <$double_ty>::from((mant << exp) & MANT_MASK);\n-            let nanos = (<$double_ty>::from(NANOS_PER_SEC) * t) >> $mant_bits;\n-            (u64::from(secs), nanos as u32)\n+            let nanos_tmp = <$double_ty>::from(NANOS_PER_SEC) * t;\n+            let nanos = (nanos_tmp >> $mant_bits) as u32;\n+            if nanos_tmp & (1 << ($mant_bits - 1)) == 0 {\n+                (secs, nanos)\n+            } else if nanos + 1 != NANOS_PER_SEC {\n+                (secs, nanos + 1)\n+            } else {\n+                // `secs + 1` can not overflow since `exp` is less than `$mant_bits`\n+                // and the latter is less than 64 bits for both `f32` and `f64`\n+                (secs + 1, 0)\n+            }\n         } else if exp < 64 {\n             // the input has no fractional part\n             let secs = u64::from(mant) << (exp - $mant_bits);\n@@ -1315,17 +1330,17 @@ impl Duration {\n     /// let res = Duration::try_from_secs_f32(1e-20);\n     /// assert_eq!(res, Ok(Duration::new(0, 0)));\n     /// let res = Duration::try_from_secs_f32(4.2e-7);\n-    /// assert_eq!(res, Ok(Duration::new(0, 419)));\n+    /// assert_eq!(res, Ok(Duration::new(0, 420)));\n     /// let res = Duration::try_from_secs_f32(2.7);\n-    /// assert_eq!(res, Ok(Duration::new(2, 700_000_047)));\n+    /// assert_eq!(res, Ok(Duration::new(2, 700_000_048)));\n     /// let res = Duration::try_from_secs_f32(3e10);\n     /// assert_eq!(res, Ok(Duration::new(30_000_001_024, 0)));\n     /// // subnormal float:\n     /// let res = Duration::try_from_secs_f32(f32::from_bits(1));\n     /// assert_eq!(res, Ok(Duration::new(0, 0)));\n-    /// // conversion uses truncation, not rounding\n+    /// // conversion uses rounding\n     /// let res = Duration::try_from_secs_f32(0.999e-9);\n-    /// assert_eq!(res, Ok(Duration::new(0, 0)));\n+    /// assert_eq!(res, Ok(Duration::new(0, 1)));\n     ///\n     /// let res = Duration::try_from_secs_f32(-5.0);\n     /// assert!(res.is_err());\n@@ -1372,9 +1387,9 @@ impl Duration {\n     /// // subnormal float\n     /// let res = Duration::try_from_secs_f64(f64::from_bits(1));\n     /// assert_eq!(res, Ok(Duration::new(0, 0)));\n-    /// // conversion uses truncation, not rounding\n+    /// // conversion uses rounding\n     /// let res = Duration::try_from_secs_f32(0.999e-9);\n-    /// assert_eq!(res, Ok(Duration::new(0, 0)));\n+    /// assert_eq!(res, Ok(Duration::new(0, 1)));\n     ///\n     /// let res = Duration::try_from_secs_f64(-5.0);\n     /// assert!(res.is_err());"}]}