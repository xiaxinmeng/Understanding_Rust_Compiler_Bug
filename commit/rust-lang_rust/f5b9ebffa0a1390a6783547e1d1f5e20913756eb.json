{"sha": "f5b9ebffa0a1390a6783547e1d1f5e20913756eb", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY1YjllYmZmYTBhMTM5MGE2NzgzNTQ3ZTFkMWY1ZTIwOTEzNzU2ZWI=", "commit": {"author": {"name": "Eric Holk", "email": "eric.holk@gmail.com", "date": "2012-05-14T23:54:43Z"}, "committer": {"name": "Eric Holk", "email": "eric.holk@gmail.com", "date": "2012-05-22T22:31:38Z"}, "message": "Starting on a BFS benchmark, but ran into problems with the deque module, so I used ports and channels as a queue in the simple sequential algorithm.", "tree": {"sha": "ba2ed5a9cc25c35deacb4e46fe4445605acebfe8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ba2ed5a9cc25c35deacb4e46fe4445605acebfe8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f5b9ebffa0a1390a6783547e1d1f5e20913756eb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f5b9ebffa0a1390a6783547e1d1f5e20913756eb", "html_url": "https://github.com/rust-lang/rust/commit/f5b9ebffa0a1390a6783547e1d1f5e20913756eb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f5b9ebffa0a1390a6783547e1d1f5e20913756eb/comments", "author": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0b2f2cabbe3fbe6e18cbf0f8a174b7d4789fc938", "url": "https://api.github.com/repos/rust-lang/rust/commits/0b2f2cabbe3fbe6e18cbf0f8a174b7d4789fc938", "html_url": "https://github.com/rust-lang/rust/commit/0b2f2cabbe3fbe6e18cbf0f8a174b7d4789fc938"}], "stats": {"total": 172, "additions": 172, "deletions": 0}, "files": [{"sha": "681412223374f5be3e960e652786d3648ac42f11", "filename": "src/test/bench/graph500-bfs.rs", "status": "added", "additions": 172, "deletions": 0, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/f5b9ebffa0a1390a6783547e1d1f5e20913756eb/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5b9ebffa0a1390a6783547e1d1f5e20913756eb/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fgraph500-bfs.rs?ref=f5b9ebffa0a1390a6783547e1d1f5e20913756eb", "patch": "@@ -0,0 +1,172 @@\n+/**\n+\n+An implementation of the Graph500 Bread First Search problem in Rust.\n+\n+*/\n+\n+use std;\n+import std::time;\n+import std::map;\n+import std::map::hashmap;\n+import std::deque;\n+import std::deque::t;\n+import io::writer_util;\n+import vec::extensions;\n+import comm::*;\n+\n+type node_id = i64;\n+type graph = [map::set<node_id>];\n+\n+iface queue<T: send> {\n+    fn add_back(T);\n+    fn pop_front() -> T;\n+    fn size() -> uint;\n+}\n+\n+#[doc=\"Creates a queue based on ports and channels.\n+\n+This is admittedly not ideal, but it will help us work around the deque\n+bugs for the time being.\"]\n+fn create_queue<T: send>() -> queue<T> {\n+    type repr<T: send> = {\n+        p : port<T>,\n+        c : chan<T>,\n+        mut s : uint,\n+    };\n+\n+    let p = port();\n+    let c = chan(p);\n+\n+    impl<T: send> of queue<T> for repr<T> {\n+        fn add_back(x : T) {\n+            let x = x;\n+            send(self.c, x);\n+            self.s += 1u;\n+        }\n+\n+        fn pop_front() -> T {\n+            self.s -= 1u;\n+            recv(self.p)\n+        }\n+\n+        fn size() -> uint { self.s }\n+    }\n+\n+    let Q : repr<T> = { p : p, c : c, mut s : 0u };\n+    Q as queue::<T>\n+}\n+\n+fn make_edges(scale: uint, edgefactor: uint) -> [(node_id, node_id)] {\n+    let r = rand::rng();\n+\n+    fn choose_edge(i: node_id, j: node_id, scale: uint, r: rand::rng)\n+        -> (node_id, node_id) {\n+\n+        let A = 0.57;\n+        let B = 0.19;\n+        let C = 0.19;\n+ \n+        if scale == 0u {\n+            (i, j)\n+        }\n+        else {\n+            let i = i * 2;\n+            let j = j * 2;\n+            let scale = scale - 1u;\n+            \n+            let x = r.next_float();\n+\n+            if x < A {\n+                choose_edge(i, j, scale, r)\n+            }\n+            else {\n+                let x = x - A;\n+                if x < B {\n+                    choose_edge(i + 1, j, scale, r)\n+                }\n+                else {\n+                    let x = x - B;\n+                    if x < C {\n+                        choose_edge(i, j + 1, scale, r)\n+                    }\n+                    else {\n+                        choose_edge(i + 1, j + 1, scale, r)\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    vec::from_fn((1u << scale) * edgefactor) {|_i|\n+        choose_edge(0, 0, scale, r)\n+    }\n+}\n+\n+fn make_graph(N: uint, edges: [(node_id, node_id)]) -> graph {\n+    let graph = vec::from_fn(N) {|_i| map::int_hash() };\n+\n+    vec::each(edges) {|e| \n+        let (i, j) = e;\n+        map::set_add(graph[i], j);\n+        map::set_add(graph[j], i);\n+        true\n+    }\n+\n+    graph\n+}\n+\n+#[doc=\"Returns a vector of all the parents in the BFS tree rooted at key.\n+\n+Nodes that are unreachable have a parent of -1.\"]\n+fn bfs(graph: graph, key: node_id) -> [node_id] {\n+    let marks : [mut node_id] \n+        = vec::to_mut(vec::from_elem(vec::len(graph), -1));\n+\n+    let Q = create_queue();\n+\n+    Q.add_back(key);\n+    marks[key] = key;\n+\n+    while Q.size() > 0u {\n+        let t = Q.pop_front();\n+\n+        graph[t].each_key() {|k| \n+            if marks[k] == -1 {\n+                marks[k] = t;\n+                Q.add_back(k);\n+            }\n+            true\n+        };\n+    }\n+\n+    vec::from_mut(marks)\n+}\n+\n+fn main() {\n+    let scale = 14u;\n+\n+    let start = time::precise_time_s();\n+    let edges = make_edges(scale, 16u);\n+    let stop = time::precise_time_s();\n+\n+    io::stdout().write_line(#fmt(\"Generated %? edges in %? seconds.\",\n+                                 vec::len(edges), stop - start));\n+\n+    let start = time::precise_time_s();\n+    let graph = make_graph(1u << scale, edges);\n+    let stop = time::precise_time_s();\n+\n+    let mut total_edges = 0u;\n+    vec::each(graph) {|edges| total_edges += edges.size(); true };\n+\n+    io::stdout().write_line(#fmt(\"Generated graph with %? edges in %? seconds.\",\n+                                 total_edges / 2u,\n+                                 stop - start));\n+    \n+    let start = time::precise_time_s();\n+    let bfs_tree = bfs(graph, 0);\n+    let stop = time::precise_time_s();\n+\n+    io::stdout().write_line(#fmt(\"BFS completed in %? seconds.\",\n+                                 stop - start));\n+}\n\\ No newline at end of file"}]}