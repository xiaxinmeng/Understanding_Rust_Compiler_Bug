{"sha": "2b97174ada7fb1854269558ed2cf3b089e58beee", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJiOTcxNzRhZGE3ZmIxODU0MjY5NTU4ZWQyY2YzYjA4OWU1OGJlZWU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-05-10T08:54:50Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-05-10T08:54:50Z"}, "message": "Auto merge of #41764 - scottmcm:faster-reverse, r=brson\n\nMake [u8]::reverse() 5x faster\n\nSince LLVM doesn't vectorize the loop for us, do unaligned reads of a larger type and use LLVM's bswap intrinsic to do the reversing of the actual bytes.  cfg!-restricted to x86 and x86_64, as I assume it wouldn't help on things like ARMv5.\n\nAlso makes [u16]::reverse() a more modest 1.5x faster by loading/storing u32 and swapping the u16s with ROT16.\n\nThank you ptr::*_unaligned for making this easy :)\n\nBenchmark results (from my i5-2500K):\n```text\n# Before\ntest slice::reverse_u8      ... bench:  273,836 ns/iter (+/- 15,592) =  3829 MB/s\ntest slice::reverse_u16     ... bench:  139,793 ns/iter (+/- 17,748) =  7500 MB/s\ntest slice::reverse_u32     ... bench:   74,997 ns/iter  (+/- 5,130) = 13981 MB/s\ntest slice::reverse_u64     ... bench:   47,452 ns/iter  (+/- 2,213) = 22097 MB/s\n\n# After\ntest slice::reverse_u8      ... bench:   52,170 ns/iter (+/- 3,962) = 20099 MB/s\ntest slice::reverse_u16     ... bench:   93,330 ns/iter (+/- 4,412) = 11235 MB/s\ntest slice::reverse_u32     ... bench:   74,731 ns/iter (+/- 1,425) = 14031 MB/s\ntest slice::reverse_u64     ... bench:   47,556 ns/iter (+/- 3,025) = 22049 MB/s\n```\n\nIf you're curious about the assembly, instead of doing this\n```\nmovzx\teax, byte ptr [rdi]\nmovzx\tecx, byte ptr [rsi]\nmov\tbyte ptr [rdi], cl\nmov\tbyte ptr [rsi], al\n```\nit does this\n```\nmov\trax, qword ptr [rdx]\nmov\trbx, qword ptr [r11 + rcx - 8]\nbswap\trbx\nmov\tqword ptr [rdx], rbx\nbswap\trax\nmov\tqword ptr [r11 + rcx - 8], rax\n```", "tree": {"sha": "880576d0244be04f587f845d2cb96936d213f3ff", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/880576d0244be04f587f845d2cb96936d213f3ff"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2b97174ada7fb1854269558ed2cf3b089e58beee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2b97174ada7fb1854269558ed2cf3b089e58beee", "html_url": "https://github.com/rust-lang/rust/commit/2b97174ada7fb1854269558ed2cf3b089e58beee", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2b97174ada7fb1854269558ed2cf3b089e58beee/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "58b33ad70cdd11f9ce7b5874c6effab9627e51aa", "url": "https://api.github.com/repos/rust-lang/rust/commits/58b33ad70cdd11f9ce7b5874c6effab9627e51aa", "html_url": "https://github.com/rust-lang/rust/commit/58b33ad70cdd11f9ce7b5874c6effab9627e51aa"}, {"sha": "da91361d2a8ea86a42cbe2a23a7ff816cc5500af", "url": "https://api.github.com/repos/rust-lang/rust/commits/da91361d2a8ea86a42cbe2a23a7ff816cc5500af", "html_url": "https://github.com/rust-lang/rust/commit/da91361d2a8ea86a42cbe2a23a7ff816cc5500af"}], "stats": {"total": 86, "additions": 86, "deletions": 0}, "files": [{"sha": "9f356e4b57912af410b56fcb4f4b7903a4c27c88", "filename": "src/libcollections/benches/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2b97174ada7fb1854269558ed2cf3b089e58beee/src%2Flibcollections%2Fbenches%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b97174ada7fb1854269558ed2cf3b089e58beee/src%2Flibcollections%2Fbenches%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbenches%2Flib.rs?ref=2b97174ada7fb1854269558ed2cf3b089e58beee", "patch": "@@ -10,7 +10,9 @@\n \n #![deny(warnings)]\n \n+#![feature(i128_type)]\n #![feature(rand)]\n+#![feature(repr_simd)]\n #![feature(sort_unstable)]\n #![feature(test)]\n "}, {"sha": "0079f2d01036cf76d5fa956a75ce7acdb0ec127f", "filename": "src/libcollections/benches/slice.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/2b97174ada7fb1854269558ed2cf3b089e58beee/src%2Flibcollections%2Fbenches%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b97174ada7fb1854269558ed2cf3b089e58beee/src%2Flibcollections%2Fbenches%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbenches%2Fslice.rs?ref=2b97174ada7fb1854269558ed2cf3b089e58beee", "patch": "@@ -290,3 +290,28 @@ sort!(sort_unstable, sort_unstable_large_random, gen_random, 10000);\n sort!(sort_unstable, sort_unstable_large_big_random, gen_big_random, 10000);\n sort!(sort_unstable, sort_unstable_large_strings, gen_strings, 10000);\n sort_expensive!(sort_unstable_by, sort_unstable_large_random_expensive, gen_random, 10000);\n+\n+macro_rules! reverse {\n+    ($name:ident, $ty:ty, $f:expr) => {\n+        #[bench]\n+        fn $name(b: &mut Bencher) {\n+            // odd length and offset by 1 to be as unaligned as possible\n+            let n = 0xFFFFF;\n+            let mut v: Vec<_> =\n+                (0..1+(n / mem::size_of::<$ty>() as u64))\n+                .map($f)\n+                .collect();\n+            b.iter(|| black_box(&mut v[1..]).reverse());\n+            b.bytes = n;\n+        }\n+    }\n+}\n+\n+reverse!(reverse_u8, u8, |x| x as u8);\n+reverse!(reverse_u16, u16, |x| x as u16);\n+reverse!(reverse_u8x3, [u8;3], |x| [x as u8, (x>>8) as u8, (x>>16) as u8]);\n+reverse!(reverse_u32, u32, |x| x as u32);\n+reverse!(reverse_u64, u64, |x| x as u64);\n+reverse!(reverse_u128, u128, |x| x as u128);\n+#[repr(simd)] struct F64x4(f64, f64, f64, f64);\n+reverse!(reverse_simd_f64x4, F64x4, |x| { let x = x as f64; F64x4(x,x,x,x) });"}, {"sha": "1708f98b7ee47c2ab40ff0807fec183e09de2eea", "filename": "src/libcollections/tests/slice.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2b97174ada7fb1854269558ed2cf3b089e58beee/src%2Flibcollections%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b97174ada7fb1854269558ed2cf3b089e58beee/src%2Flibcollections%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftests%2Fslice.rs?ref=2b97174ada7fb1854269558ed2cf3b089e58beee", "patch": "@@ -379,6 +379,16 @@ fn test_reverse() {\n     let mut v3 = Vec::<i32>::new();\n     v3.reverse();\n     assert!(v3.is_empty());\n+\n+    // check the 1-byte-types path\n+    let mut v = (-50..51i8).collect::<Vec<_>>();\n+    v.reverse();\n+    assert_eq!(v, (-50..51i8).rev().collect::<Vec<_>>());\n+\n+    // check the 2-byte-types path\n+    let mut v = (-50..51i16).collect::<Vec<_>>();\n+    v.reverse();\n+    assert_eq!(v, (-50..51i16).rev().collect::<Vec<_>>());\n }\n \n #[test]"}, {"sha": "e15eb8f24440956b5e1ff88e48b794ecca1194c6", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/2b97174ada7fb1854269558ed2cf3b089e58beee/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b97174ada7fb1854269558ed2cf3b089e58beee/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=2b97174ada7fb1854269558ed2cf3b089e58beee", "patch": "@@ -539,6 +539,55 @@ impl<T> SliceExt for [T] {\n     fn reverse(&mut self) {\n         let mut i: usize = 0;\n         let ln = self.len();\n+\n+        // For very small types, all the individual reads in the normal\n+        // path perform poorly.  We can do better, given efficient unaligned\n+        // load/store, by loading a larger chunk and reversing a register.\n+\n+        // Ideally LLVM would do this for us, as it knows better than we do\n+        // whether unaligned reads are efficient (since that changes between\n+        // different ARM versions, for example) and what the best chunk size\n+        // would be.  Unfortunately, as of LLVM 4.0 (2017-05) it only unrolls\n+        // the loop, so we need to do this ourselves.  (Hypothesis: reverse\n+        // is troublesome because the sides can be aligned differently --\n+        // will be, when the length is odd -- so there's no way of emitting\n+        // pre- and postludes to use fully-aligned SIMD in the middle.)\n+\n+        let fast_unaligned =\n+            cfg!(any(target_arch = \"x86\", target_arch = \"x86_64\"));\n+\n+        if fast_unaligned && mem::size_of::<T>() == 1 {\n+            // Use the llvm.bswap intrinsic to reverse u8s in a usize\n+            let chunk = mem::size_of::<usize>();\n+            while i + chunk - 1 < ln / 2 {\n+                unsafe {\n+                    let pa: *mut T = self.get_unchecked_mut(i);\n+                    let pb: *mut T = self.get_unchecked_mut(ln - i - chunk);\n+                    let va = ptr::read_unaligned(pa as *mut usize);\n+                    let vb = ptr::read_unaligned(pb as *mut usize);\n+                    ptr::write_unaligned(pa as *mut usize, vb.swap_bytes());\n+                    ptr::write_unaligned(pb as *mut usize, va.swap_bytes());\n+                }\n+                i += chunk;\n+            }\n+        }\n+\n+        if fast_unaligned && mem::size_of::<T>() == 2 {\n+            // Use rotate-by-16 to reverse u16s in a u32\n+            let chunk = mem::size_of::<u32>() / 2;\n+            while i + chunk - 1 < ln / 2 {\n+                unsafe {\n+                    let pa: *mut T = self.get_unchecked_mut(i);\n+                    let pb: *mut T = self.get_unchecked_mut(ln - i - chunk);\n+                    let va = ptr::read_unaligned(pa as *mut u32);\n+                    let vb = ptr::read_unaligned(pb as *mut u32);\n+                    ptr::write_unaligned(pa as *mut u32, vb.rotate_left(16));\n+                    ptr::write_unaligned(pb as *mut u32, va.rotate_left(16));\n+                }\n+                i += chunk;\n+            }\n+        }\n+\n         while i < ln / 2 {\n             // Unsafe swap to avoid the bounds check in safe swap.\n             unsafe {"}]}