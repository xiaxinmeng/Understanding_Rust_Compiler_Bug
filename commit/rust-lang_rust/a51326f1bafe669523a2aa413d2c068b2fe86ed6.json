{"sha": "a51326f1bafe669523a2aa413d2c068b2fe86ed6", "node_id": "C_kwDOAAsO6NoAKGE1MTMyNmYxYmFmZTY2OTUyM2EyYWE0MTNkMmMwNjhiMmZlODZlZDY", "commit": {"author": {"name": "David Tolnay", "email": "dtolnay@gmail.com", "date": "2021-12-23T21:02:31Z"}, "committer": {"name": "David Tolnay", "email": "dtolnay@gmail.com", "date": "2021-12-24T00:23:43Z"}, "message": "Add a test suite for stringify macro", "tree": {"sha": "9e7dc7d135fa7b95cc11b666fb6f3adaca00698b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9e7dc7d135fa7b95cc11b666fb6f3adaca00698b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a51326f1bafe669523a2aa413d2c068b2fe86ed6", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEERijF2Cz/ZdaBZKeK+boUO5X/bYIFAmHFEw8ACgkQ+boUO5X/\nbYLdYxAAjD9x3nsdYhBEa9Cmwl4ttHrgnIInxld02bk4ocDzkRMAfywT7739ddoy\nCRjJAYPCRImNY3svUnZD2zqQ4ZgZ6Kw+YsrvL+u0nFiz3QC6p5sBmvKAyO0P+vXs\nQTjAm9ro/SsKiAT7qSpVSlY0RZLpt7z04gcarjpjYQxnbLkILM0L2vsLrE+Q7u15\n0Dqgr+qh9yjDNqVdGQUGwiGjb4aNbyC75DMw9wBXZnHL/P6olIfnJslaS6F7sDwt\nqWGwlm6RvIGDUZLFMXAArwTkv2rPHV0dcQGeDtRh+CCziSVzxGuHkisq+yunLwuM\nyuCCkA0t4T/0f0mqqN7UzR1rM+Vc05dwD9NuFRodH6xqFE5S0ksdnMz8e9/T01QL\nO0JHRZmLcGt1jpr3HnMSWRxshT3ZSaDgpIz+VaHzcm1N2nDjmy6V8bTN6j9GfHMg\n5wnIzZsb1Odehf/ZMAx1ox9ULetAyd/+IS1zV0wdaxxmXkeebPUxU+9sF1xHwtiN\nxR7tn/o23nbNRwBpEdjm28r6sKk8b+zs/NEAXpgvgOSMxWCfbywhsN+vIi+o4SRs\np0uzgs7f7E2eS+E2MmQ1QlgJZAW/Karyr5ohxkEe8De1IUbvUg/zUhXapVumWXqL\n8R8uWFbR2zEp5xnCD7/9BCjaacs7ISHlbkyZX9DkISZnUpLWiwE=\n=3ikv\n-----END PGP SIGNATURE-----", "payload": "tree 9e7dc7d135fa7b95cc11b666fb6f3adaca00698b\nparent c09a9529c51cde41c1101e56049d418edb07bf71\nauthor David Tolnay <dtolnay@gmail.com> 1640293351 -0800\ncommitter David Tolnay <dtolnay@gmail.com> 1640305423 -0800\n\nAdd a test suite for stringify macro\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a51326f1bafe669523a2aa413d2c068b2fe86ed6", "html_url": "https://github.com/rust-lang/rust/commit/a51326f1bafe669523a2aa413d2c068b2fe86ed6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a51326f1bafe669523a2aa413d2c068b2fe86ed6/comments", "author": {"login": "dtolnay", "id": 1940490, "node_id": "MDQ6VXNlcjE5NDA0OTA=", "avatar_url": "https://avatars.githubusercontent.com/u/1940490?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dtolnay", "html_url": "https://github.com/dtolnay", "followers_url": "https://api.github.com/users/dtolnay/followers", "following_url": "https://api.github.com/users/dtolnay/following{/other_user}", "gists_url": "https://api.github.com/users/dtolnay/gists{/gist_id}", "starred_url": "https://api.github.com/users/dtolnay/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dtolnay/subscriptions", "organizations_url": "https://api.github.com/users/dtolnay/orgs", "repos_url": "https://api.github.com/users/dtolnay/repos", "events_url": "https://api.github.com/users/dtolnay/events{/privacy}", "received_events_url": "https://api.github.com/users/dtolnay/received_events", "type": "User", "site_admin": false}, "committer": {"login": "dtolnay", "id": 1940490, "node_id": "MDQ6VXNlcjE5NDA0OTA=", "avatar_url": "https://avatars.githubusercontent.com/u/1940490?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dtolnay", "html_url": "https://github.com/dtolnay", "followers_url": "https://api.github.com/users/dtolnay/followers", "following_url": "https://api.github.com/users/dtolnay/following{/other_user}", "gists_url": "https://api.github.com/users/dtolnay/gists{/gist_id}", "starred_url": "https://api.github.com/users/dtolnay/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dtolnay/subscriptions", "organizations_url": "https://api.github.com/users/dtolnay/orgs", "repos_url": "https://api.github.com/users/dtolnay/repos", "events_url": "https://api.github.com/users/dtolnay/events{/privacy}", "received_events_url": "https://api.github.com/users/dtolnay/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c09a9529c51cde41c1101e56049d418edb07bf71", "url": "https://api.github.com/repos/rust-lang/rust/commits/c09a9529c51cde41c1101e56049d418edb07bf71", "html_url": "https://github.com/rust-lang/rust/commit/c09a9529c51cde41c1101e56049d418edb07bf71"}], "stats": {"total": 894, "additions": 894, "deletions": 0}, "files": [{"sha": "924329d7a8441b086edb7e5e1876ed982c8500b6", "filename": "src/test/ui/macros/stringify.rs", "status": "added", "additions": 894, "deletions": 0, "changes": 894, "blob_url": "https://github.com/rust-lang/rust/blob/a51326f1bafe669523a2aa413d2c068b2fe86ed6/src%2Ftest%2Fui%2Fmacros%2Fstringify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a51326f1bafe669523a2aa413d2c068b2fe86ed6/src%2Ftest%2Fui%2Fmacros%2Fstringify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fstringify.rs?ref=a51326f1bafe669523a2aa413d2c068b2fe86ed6", "patch": "@@ -0,0 +1,894 @@\n+// run-pass\n+// edition:2021\n+// compile-flags: --test\n+\n+#![feature(async_closure)]\n+#![feature(const_trait_impl)]\n+#![feature(generators)]\n+#![feature(half_open_range_patterns)]\n+#![feature(more_qualified_paths)]\n+#![feature(raw_ref_op)]\n+#![deny(unused_macros)]\n+\n+macro_rules! stringify_block {\n+    ($block:block) => {\n+        stringify!($block)\n+    };\n+}\n+\n+macro_rules! stringify_expr {\n+    ($expr:expr) => {\n+        stringify!($expr)\n+    };\n+}\n+\n+macro_rules! stringify_item {\n+    ($item:item) => {\n+        stringify!($item)\n+    };\n+}\n+\n+macro_rules! stringify_meta {\n+    ($meta:meta) => {\n+        stringify!($meta)\n+    };\n+}\n+\n+macro_rules! stringify_pat {\n+    ($pat:pat) => {\n+        stringify!($pat)\n+    };\n+}\n+\n+macro_rules! stringify_path {\n+    ($path:path) => {\n+        stringify!($path)\n+    };\n+}\n+\n+macro_rules! stringify_stmt {\n+    ($stmt:stmt) => {\n+        stringify!($stmt)\n+    };\n+}\n+\n+macro_rules! stringify_ty {\n+    ($ty:ty) => {\n+        stringify!($ty)\n+    };\n+}\n+\n+macro_rules! stringify_vis {\n+    ($vis:vis) => {\n+        stringify!($vis)\n+    };\n+}\n+\n+#[test]\n+fn test_block() {\n+    assert_eq!(stringify_block!({}), \"{}\");\n+    assert_eq!(stringify_block!({ true }), \"{ true }\");\n+    assert_eq!(stringify_block!({ return }), \"{ return }\");\n+    assert_eq!(\n+        stringify_block!({\n+            return;\n+        }),\n+        \"{ return; }\",\n+    );\n+    assert_eq!(\n+        stringify_block!({\n+            let _;\n+            true\n+        }),\n+        \"{ let _; true }\",\n+    );\n+}\n+\n+#[test]\n+fn test_expr() {\n+    // ExprKind::Box\n+    assert_eq!(stringify_expr!(box expr), \"box expr\");\n+\n+    // ExprKind::Array\n+    assert_eq!(stringify_expr!([]), \"[]\");\n+    assert_eq!(stringify_expr!([true]), \"[true]\");\n+    assert_eq!(stringify_expr!([true,]), \"[true]\");\n+    assert_eq!(stringify_expr!([true, true]), \"[true, true]\");\n+\n+    // ExprKind::Call\n+    assert_eq!(stringify_expr!(f()), \"f()\");\n+    assert_eq!(stringify_expr!(f::<u8>()), \"f::<u8>()\");\n+    assert_eq!(stringify_expr!(f::<1>()), \"f::<1>()\");\n+    assert_eq!(stringify_expr!(f::<'a, u8, 1>()), \"f::<'a, u8, 1>()\");\n+    assert_eq!(stringify_expr!(f(true)), \"f(true)\");\n+    assert_eq!(stringify_expr!(f(true,)), \"f(true)\");\n+    assert_eq!(stringify_expr!(()()), \"()()\");\n+\n+    // ExprKind::MethodCall\n+    assert_eq!(stringify_expr!(x.f()), \"x.f()\");\n+    assert_eq!(stringify_expr!(x.f::<u8>()), \"x.f::<u8>()\");\n+\n+    // ExprKind::Tup\n+    assert_eq!(stringify_expr!(()), \"()\");\n+    assert_eq!(stringify_expr!((true,)), \"(true,)\");\n+    assert_eq!(stringify_expr!((true, false)), \"(true, false)\");\n+    assert_eq!(stringify_expr!((true, false,)), \"(true, false)\");\n+\n+    // ExprKind::Binary\n+    assert_eq!(stringify_expr!(true || false), \"true || false\");\n+    assert_eq!(\n+        stringify_expr!(true || false && false),\n+        \"true || false && false\",\n+    );\n+\n+    // ExprKind::Unary\n+    assert_eq!(stringify_expr!(*expr), \"*expr\");\n+    assert_eq!(stringify_expr!(!expr), \"!expr\");\n+    assert_eq!(stringify_expr!(-expr), \"-expr\");\n+\n+    // ExprKind::Lit\n+    assert_eq!(stringify_expr!('x'), \"'x'\");\n+    assert_eq!(stringify_expr!(1_000_i8), \"1_000_i8\");\n+    assert_eq!(stringify_expr!(1.00000000000000001), \"1.00000000000000001\");\n+\n+    // ExprKind::Cast\n+    assert_eq!(stringify_expr!(expr as T), \"expr as T\");\n+    assert_eq!(stringify_expr!(expr as T<u8>), \"expr as T<u8>\");\n+\n+    // ExprKind::Type\n+    assert_eq!(stringify_expr!(expr: T), \"expr: T\");\n+    assert_eq!(stringify_expr!(expr: T<u8>), \"expr: T<u8>\");\n+\n+    // ExprKind::If\n+    assert_eq!(stringify_expr!(if true {}), \"if true {}\");\n+    assert_eq!(\n+        stringify_expr!(if true {\n+        } else {\n+        }),\n+        \"if true {} else {}\",\n+    );\n+    assert_eq!(\n+        stringify_expr!(if let true = true {\n+        } else {\n+        }),\n+        \"if let true = true {} else {}\",\n+    );\n+    assert_eq!(\n+        stringify_expr!(if true {\n+        } else if false {\n+        }),\n+        \"if true {} else if false {}\",\n+    );\n+    assert_eq!(\n+        stringify_expr!(if true {\n+        } else if false {\n+        } else {\n+        }),\n+        \"if true {} else if false {} else {}\",\n+    );\n+    assert_eq!(\n+        stringify_expr!(if true {\n+            return;\n+        } else if false {\n+            0\n+        } else {\n+            0\n+        }),\n+        \"if true { return; } else if false { 0 } else { 0 }\",\n+    );\n+\n+    // ExprKind::While\n+    assert_eq!(stringify_expr!(while true {}), \"while true {}\");\n+    assert_eq!(stringify_expr!('a: while true {}), \"'a: while true {}\");\n+    assert_eq!(\n+        stringify_expr!(while let true = true {}),\n+        \"while let true = true {}\",\n+    );\n+\n+    // ExprKind::ForLoop\n+    assert_eq!(stringify_expr!(for _ in x {}), \"for _ in x {}\");\n+    assert_eq!(stringify_expr!('a: for _ in x {}), \"'a: for _ in x {}\");\n+\n+    // ExprKind::Loop\n+    assert_eq!(stringify_expr!(loop {}), \"loop {}\");\n+    assert_eq!(stringify_expr!('a: loop {}), \"'a: loop {}\");\n+\n+    // ExprKind::Match\n+    assert_eq!(stringify_expr!(match self {}), \"match self {}\");\n+    assert_eq!(\n+        stringify_expr!(match self {\n+            Ok => 1,\n+        }),\n+        \"match self { Ok => 1, }\",\n+    );\n+    assert_eq!(\n+        stringify_expr!(match self {\n+            Ok => 1,\n+            Err => 0,\n+        }),\n+        \"match self { Ok => 1, Err => 0, }\",\n+    );\n+\n+    // ExprKind::Closure\n+    assert_eq!(stringify_expr!(|| {}), \"|| {}\");\n+    assert_eq!(stringify_expr!(|x| {}), \"|x| {}\");\n+    assert_eq!(stringify_expr!(|x: u8| {}), \"|x: u8| {}\");\n+    assert_eq!(stringify_expr!(|| ()), \"|| ()\");\n+    assert_eq!(stringify_expr!(move || self), \"move || self\");\n+    assert_eq!(stringify_expr!(async || self), \"async || self\");\n+    assert_eq!(stringify_expr!(async move || self), \"async move || self\");\n+    assert_eq!(stringify_expr!(static || self), \"static || self\");\n+    assert_eq!(stringify_expr!(static move || self), \"static move || self\");\n+    #[rustfmt::skip] // https://github.com/rust-lang/rustfmt/issues/5149\n+    assert_eq!(\n+        stringify_expr!(static async || self),\n+        \"static async || self\",\n+    );\n+    #[rustfmt::skip] // https://github.com/rust-lang/rustfmt/issues/5149\n+    assert_eq!(\n+        stringify_expr!(static async move || self),\n+        \"static async move || self\",\n+    );\n+    assert_eq!(stringify_expr!(|| -> u8 { self }), \"|| -> u8 { self }\");\n+    assert_eq!(stringify_expr!(1 + || {}), \"1 + (|| {})\"); // ??\n+\n+    // ExprKind::Block\n+    assert_eq!(stringify_expr!({}), \"{}\");\n+    assert_eq!(stringify_expr!(unsafe {}), \"unsafe {}\");\n+    assert_eq!(stringify_expr!('a: {}), \"'a: {}\");\n+    assert_eq!(\n+        stringify_expr!(\n+            #[attr]\n+            {}\n+        ),\n+        \"#[attr] { }\", // FIXME\n+    );\n+    assert_eq!(\n+        stringify_expr!(\n+            {\n+                #![attr]\n+            }\n+        ),\n+        \"{\\n    #![attr]\\n}\",\n+    );\n+\n+    // ExprKind::Async\n+    assert_eq!(stringify_expr!(async {}), \"async {}\");\n+    assert_eq!(stringify_expr!(async move {}), \"async move {}\");\n+\n+    // ExprKind::Await\n+    assert_eq!(stringify_expr!(expr.await), \"expr.await\");\n+\n+    // ExprKind::TryBlock\n+    assert_eq!(stringify_expr!(try {}), \"try  {}\"); // FIXME\n+\n+    // ExprKind::Assign\n+    assert_eq!(stringify_expr!(expr = true), \"expr = true\");\n+\n+    // ExprKind::AssignOp\n+    assert_eq!(stringify_expr!(expr += true), \"expr += true\");\n+\n+    // ExprKind::Field\n+    assert_eq!(stringify_expr!(expr.field), \"expr.field\");\n+    assert_eq!(stringify_expr!(expr.0), \"expr.0\");\n+\n+    // ExprKind::Index\n+    assert_eq!(stringify_expr!(expr[true]), \"expr[true]\");\n+\n+    // ExprKind::Range\n+    assert_eq!(stringify_expr!(..), \"..\");\n+    assert_eq!(stringify_expr!(..hi), \"..hi\");\n+    assert_eq!(stringify_expr!(lo..), \"lo..\");\n+    assert_eq!(stringify_expr!(lo..hi), \"lo..hi\");\n+    assert_eq!(stringify_expr!(..=hi), \"..=hi\");\n+    assert_eq!(stringify_expr!(lo..=hi), \"lo..=hi\");\n+    assert_eq!(stringify_expr!(-2..=-1), \"-2..=-1\");\n+\n+    // ExprKind::Path\n+    assert_eq!(stringify_expr!(thing), \"thing\");\n+    assert_eq!(stringify_expr!(m::thing), \"m::thing\");\n+    assert_eq!(stringify_expr!(self::thing), \"self::thing\");\n+    assert_eq!(stringify_expr!(crate::thing), \"crate::thing\");\n+    assert_eq!(stringify_expr!(Self::thing), \"Self::thing\");\n+    assert_eq!(stringify_expr!(<Self as T>::thing), \"<Self as T>::thing\");\n+    assert_eq!(stringify_expr!(Self::<'static>), \"Self::<'static>\");\n+\n+    // ExprKind::AddrOf\n+    assert_eq!(stringify_expr!(&expr), \"&expr\");\n+    assert_eq!(stringify_expr!(&mut expr), \"&mut expr\");\n+    assert_eq!(stringify_expr!(&raw const expr), \"&raw const expr\");\n+    assert_eq!(stringify_expr!(&raw mut expr), \"&raw mut expr\");\n+\n+    // ExprKind::Break\n+    assert_eq!(stringify_expr!(break), \"break\");\n+    assert_eq!(stringify_expr!(break 'a), \"break 'a\");\n+    assert_eq!(stringify_expr!(break true), \"break true\");\n+    assert_eq!(stringify_expr!(break 'a true), \"break 'a true\");\n+\n+    // ExprKind::Continue\n+    assert_eq!(stringify_expr!(continue), \"continue\");\n+    assert_eq!(stringify_expr!(continue 'a), \"continue 'a\");\n+\n+    // ExprKind::Ret\n+    assert_eq!(stringify_expr!(return), \"return\");\n+    assert_eq!(stringify_expr!(return true), \"return true\");\n+\n+    // ExprKind::MacCall\n+    assert_eq!(stringify_expr!(mac!(...)), \"mac!(...)\");\n+    assert_eq!(stringify_expr!(mac![...]), \"mac![...]\");\n+    assert_eq!(stringify_expr!(mac! { ... }), \"mac! { ... }\");\n+\n+    // ExprKind::Struct\n+    assert_eq!(stringify_expr!(Struct {}), \"Struct{}\"); // FIXME\n+    #[rustfmt::skip] // https://github.com/rust-lang/rustfmt/issues/5151\n+    assert_eq!(stringify_expr!(<Struct as Trait>::Type {}), \"<Struct as Trait>::Type{}\");\n+    assert_eq!(stringify_expr!(Struct { .. }), \"Struct{..}\"); // FIXME\n+    assert_eq!(stringify_expr!(Struct { ..base }), \"Struct{..base}\"); // FIXME\n+    assert_eq!(stringify_expr!(Struct { x }), \"Struct{x,}\");\n+    assert_eq!(stringify_expr!(Struct { x, .. }), \"Struct{x, ..}\");\n+    assert_eq!(stringify_expr!(Struct { x, ..base }), \"Struct{x, ..base}\");\n+    assert_eq!(stringify_expr!(Struct { x: true }), \"Struct{x: true,}\");\n+    assert_eq!(\n+        stringify_expr!(Struct { x: true, .. }),\n+        \"Struct{x: true, ..}\",\n+    );\n+    assert_eq!(\n+        stringify_expr!(Struct { x: true, ..base }),\n+        \"Struct{x: true, ..base}\",\n+    );\n+\n+    // ExprKind::Repeat\n+    assert_eq!(stringify_expr!([(); 0]), \"[(); 0]\");\n+\n+    // ExprKind::Paren\n+    assert_eq!(stringify_expr!((expr)), \"(expr)\");\n+\n+    // ExprKind::Try\n+    assert_eq!(stringify_expr!(expr?), \"expr?\");\n+\n+    // ExprKind::Yield\n+    assert_eq!(stringify_expr!(yield), \"yield\");\n+    assert_eq!(stringify_expr!(yield true), \"yield true\");\n+}\n+\n+#[test]\n+fn test_item() {\n+    // ItemKind::ExternCrate\n+    assert_eq!(\n+        stringify_item!(\n+            extern crate std;\n+        ),\n+        \"extern crate std;\",\n+    );\n+    assert_eq!(\n+        stringify_item!(\n+            pub extern crate self as std;\n+        ),\n+        \"pub extern crate self as std;\",\n+    );\n+\n+    // ItemKind::Use\n+    assert_eq!(\n+        stringify_item!(\n+            pub use crate::{a, b::c};\n+        ),\n+        \"pub use crate::{a, b::c};\",\n+    );\n+\n+    // ItemKind::Static\n+    assert_eq!(\n+        stringify_item!(\n+            pub static S: () = {};\n+        ),\n+        \"pub static S: () = {};\",\n+    );\n+    assert_eq!(\n+        stringify_item!(\n+            static mut S: () = {};\n+        ),\n+        \"static mut S: () = {};\",\n+    );\n+    assert_eq!(\n+        stringify_item!(\n+            static S: ();\n+        ),\n+        \"static S: () ;\", // FIXME\n+    );\n+    assert_eq!(\n+        stringify_item!(\n+            static mut S: ();\n+        ),\n+        \"static mut S: () ;\",\n+    );\n+\n+    // ItemKind::Const\n+    assert_eq!(\n+        stringify_item!(\n+            pub const S: () = {};\n+        ),\n+        \"pub const S: () = {};\",\n+    );\n+    assert_eq!(\n+        stringify_item!(\n+            const S: ();\n+        ),\n+        \"const S: () ;\", // FIXME\n+    );\n+\n+    // ItemKind::Fn\n+    assert_eq!(\n+        stringify_item!(\n+            pub default const async unsafe extern \"C\" fn f() {}\n+        ),\n+        \"pub default const async unsafe extern \\\"C\\\" fn f() {}\",\n+    );\n+\n+    // ItemKind::Mod\n+    assert_eq!(\n+        stringify_item!(\n+            pub mod m;\n+        ),\n+        \"pub mod m;\",\n+    );\n+    assert_eq!(\n+        stringify_item!(\n+            mod m {}\n+        ),\n+        \"mod m {}\",\n+    );\n+    assert_eq!(\n+        stringify_item!(\n+            unsafe mod m;\n+        ),\n+        \"unsafe mod m;\",\n+    );\n+    assert_eq!(\n+        stringify_item!(\n+            unsafe mod m {}\n+        ),\n+        \"unsafe mod m {}\",\n+    );\n+\n+    // ItemKind::ForeignMod\n+    assert_eq!(\n+        stringify_item!(\n+            extern \"C\" {}\n+        ),\n+        \"extern \\\"C\\\" {}\",\n+    );\n+    #[rustfmt::skip]\n+    assert_eq!(\n+        stringify_item!(\n+            pub extern \"C\" {}\n+        ),\n+        \"extern \\\"C\\\" {}\",\n+    );\n+    assert_eq!(\n+        stringify_item!(\n+            unsafe extern \"C++\" {}\n+        ),\n+        \"unsafe extern \\\"C++\\\" {}\",\n+    );\n+\n+    // ItemKind::TyAlias\n+    #[rustfmt::skip]\n+    assert_eq!(\n+        stringify_item!(\n+            pub default type Type<'a>: Bound\n+            where\n+                Self: 'a,\n+            = T;\n+        ),\n+        \"pub default type Type<'a>: Bound where Self: 'a = T;\",\n+    );\n+\n+    // ItemKind::Enum\n+    assert_eq!(\n+        stringify_item!(\n+            pub enum Void {}\n+        ),\n+        \"pub enum Void {}\",\n+    );\n+    assert_eq!(\n+        stringify_item!(\n+            enum Empty {\n+                Unit,\n+                Tuple(),\n+                Struct {},\n+            }\n+        ),\n+        \"enum Empty { Unit, Tuple(), Struct {}, }\",\n+    );\n+    assert_eq!(\n+        stringify_item!(\n+            enum Enum<T> where T: 'a {\n+                Unit,\n+                Tuple(T),\n+                Struct { t: T },\n+            }\n+        ),\n+        \"enum Enum<T> where T: 'a {\\n    Unit,\\n    Tuple(T),\\n    Struct {\\n        t: T,\\n    },\\n}\",\n+    );\n+\n+    // ItemKind::Struct\n+    assert_eq!(\n+        stringify_item!(\n+            pub struct Unit;\n+        ),\n+        \"pub struct Unit;\",\n+    );\n+    assert_eq!(\n+        stringify_item!(\n+            struct Tuple();\n+        ),\n+        \"struct Tuple();\",\n+    );\n+    assert_eq!(\n+        stringify_item!(\n+            struct Tuple(T);\n+        ),\n+        \"struct Tuple(T);\",\n+    );\n+    assert_eq!(\n+        stringify_item!(\n+            struct Struct {}\n+        ),\n+        \"struct Struct {}\",\n+    );\n+    assert_eq!(\n+        stringify_item!(\n+            struct Struct<T>\n+            where\n+                T: 'a,\n+            {\n+                t: T,\n+            }\n+        ),\n+        \"struct Struct<T> where T: 'a {\\n    t: T,\\n}\",\n+    );\n+\n+    // ItemKind::Union\n+    assert_eq!(\n+        stringify_item!(\n+            pub union Union {}\n+        ),\n+        \"pub union Union {}\",\n+    );\n+    assert_eq!(\n+        stringify_item!(\n+            union Union<T> where T: 'a {\n+                t: T,\n+            }\n+        ),\n+        \"union Union<T> where T: 'a {\\n    t: T,\\n}\",\n+    );\n+\n+    // ItemKind::Trait\n+    assert_eq!(\n+        stringify_item!(\n+            pub unsafe auto trait Send {}\n+        ),\n+        \"pub unsafe auto trait Send {}\",\n+    );\n+    assert_eq!(\n+        stringify_item!(\n+            trait Trait<'a>: Sized\n+            where\n+                Self: 'a,\n+            {\n+            }\n+        ),\n+        \"trait Trait<'a>: Sized where Self: 'a {}\",\n+    );\n+\n+    // ItemKind::TraitAlias\n+    assert_eq!(\n+        stringify_item!(\n+            pub trait Trait<T> = Sized where T: 'a;\n+        ),\n+        \"\", // FIXME\n+    );\n+\n+    // ItemKind::Impl\n+    assert_eq!(\n+        stringify_item!(\n+            pub impl Struct {}\n+        ),\n+        \"pub impl Struct {}\",\n+    );\n+    assert_eq!(\n+        stringify_item!(\n+            impl<T> Struct<T> {}\n+        ),\n+        \"impl <T> Struct<T> {}\", // FIXME\n+    );\n+    assert_eq!(\n+        stringify_item!(\n+            pub impl Trait for Struct {}\n+        ),\n+        \"pub impl Trait for Struct {}\",\n+    );\n+    assert_eq!(\n+        stringify_item!(\n+            impl ~const Struct {}\n+        ),\n+        \"impl Struct {}\", // FIXME\n+    );\n+\n+    // ItemKind::MacCall\n+    assert_eq!(stringify_item!(mac!(...);), \"mac!(...);\");\n+    assert_eq!(stringify_item!(mac![...];), \"mac![...];\");\n+    assert_eq!(stringify_item!(mac! { ... }), \"mac! { ... }\");\n+\n+    // ItemKind::MacroDef\n+    assert_eq!(\n+        stringify_item!(\n+            macro_rules! stringify {\n+                () => {};\n+            }\n+        ),\n+        \"macro_rules! stringify { () => {} ; }\", // FIXME\n+    );\n+    assert_eq!(\n+        stringify_item!(\n+            pub macro stringify() {}\n+        ),\n+        \"pub macro stringify { () => {} }\",\n+    );\n+}\n+\n+#[test]\n+fn test_meta() {\n+    assert_eq!(stringify_meta!(k), \"k\");\n+    assert_eq!(stringify_meta!(k = \"v\"), \"k = \\\"v\\\"\");\n+    assert_eq!(stringify_meta!(list(k1, k2 = \"v\")), \"list(k1, k2 = \\\"v\\\")\");\n+    assert_eq!(stringify_meta!(serde::k), \"serde::k\");\n+}\n+\n+#[test]\n+fn test_pat() {\n+    // PatKind::Wild\n+    assert_eq!(stringify_pat!(_), \"_\");\n+\n+    // PatKind::Ident\n+    assert_eq!(stringify_pat!(_x), \"_x\");\n+    assert_eq!(stringify_pat!(ref _x), \"ref _x\");\n+    assert_eq!(stringify_pat!(mut _x), \"mut _x\");\n+    assert_eq!(stringify_pat!(ref mut _x), \"ref mut _x\");\n+    assert_eq!(stringify_pat!(ref mut _x @ _), \"ref mut _x @ _\");\n+\n+    // PatKind::Struct\n+    assert_eq!(stringify_pat!(Struct {}), \"Struct {  }\"); // FIXME\n+    assert_eq!(stringify_pat!(Struct::<u8> {}), \"Struct::<u8> {  }\");\n+    assert_eq!(\n+        stringify_pat!(Struct::<'static> {}),\n+        \"Struct::<'static> {  }\",\n+    );\n+    assert_eq!(stringify_pat!(Struct { x }), \"Struct { x }\");\n+    assert_eq!(stringify_pat!(Struct { x: _x }), \"Struct { x: _x }\");\n+    assert_eq!(stringify_pat!(Struct { .. }), \"Struct { .. }\");\n+    assert_eq!(stringify_pat!(Struct { x, .. }), \"Struct { x, .. }\");\n+    assert_eq!(stringify_pat!(Struct { x: _x, .. }), \"Struct { x: _x, .. }\");\n+    #[rustfmt::skip] // https://github.com/rust-lang/rustfmt/issues/5151\n+    assert_eq!(\n+        stringify_pat!(<Struct as Trait>::Type {}),\n+        \"<Struct as Trait>::Type {  }\",\n+    );\n+\n+    // PatKind::TupleStruct\n+    assert_eq!(stringify_pat!(Tuple()), \"Tuple()\");\n+    assert_eq!(stringify_pat!(Tuple::<u8>()), \"Tuple::<u8>()\");\n+    assert_eq!(stringify_pat!(Tuple::<'static>()), \"Tuple::<'static>()\");\n+    assert_eq!(stringify_pat!(Tuple(x)), \"Tuple(x)\");\n+    assert_eq!(stringify_pat!(Tuple(..)), \"Tuple(..)\");\n+    assert_eq!(stringify_pat!(Tuple(x, ..)), \"Tuple(x, ..)\");\n+    assert_eq!(\n+        stringify_pat!(<Struct as Trait>::Type()),\n+        \"<Struct as Trait>::Type()\",\n+    );\n+\n+    // PatKind::Or\n+    assert_eq!(stringify_pat!(true | false), \"true | false\");\n+    assert_eq!(stringify_pat!(| true), \"true\");\n+    assert_eq!(stringify_pat!(|true| false), \"true | false\");\n+\n+    // PatKind::Path\n+    assert_eq!(stringify_pat!(crate::Path), \"crate::Path\");\n+    assert_eq!(stringify_pat!(Path::<u8>), \"Path::<u8>\");\n+    assert_eq!(stringify_pat!(Path::<'static>), \"Path::<'static>\");\n+    assert_eq!(\n+        stringify_pat!(<Struct as Trait>::Type),\n+        \"<Struct as Trait>::Type\",\n+    );\n+\n+    // PatKind::Tuple\n+    assert_eq!(stringify_pat!(()), \"()\");\n+    assert_eq!(stringify_pat!((true,)), \"(true,)\");\n+    assert_eq!(stringify_pat!((true, false)), \"(true, false)\");\n+\n+    // PatKind::Box\n+    assert_eq!(stringify_pat!(box pat), \"box pat\");\n+\n+    // PatKind::Ref\n+    assert_eq!(stringify_pat!(&pat), \"&pat\");\n+    assert_eq!(stringify_pat!(&mut pat), \"&mut pat\");\n+\n+    // PatKind::Lit\n+    assert_eq!(stringify_pat!(1_000_i8), \"1_000_i8\");\n+\n+    // PatKind::Range\n+    assert_eq!(stringify_pat!(..1), \"..1\");\n+    assert_eq!(stringify_pat!(0..), \"0 ..\"); // FIXME\n+    assert_eq!(stringify_pat!(0..1), \"0 ..1\");\n+    assert_eq!(stringify_pat!(0..=1), \"0 ..=1\");\n+    assert_eq!(stringify_pat!(-2..=-1), \"-2 ..=-1\");\n+\n+    // PatKind::Slice\n+    assert_eq!(stringify_pat!([]), \"[]\");\n+    assert_eq!(stringify_pat!([true]), \"[true]\");\n+    assert_eq!(stringify_pat!([true,]), \"[true]\");\n+    assert_eq!(stringify_pat!([true, false]), \"[true, false]\");\n+\n+    // PatKind::Rest\n+    assert_eq!(stringify_pat!(..), \"..\");\n+\n+    // PatKind::Paren\n+    assert_eq!(stringify_pat!((pat)), \"(pat)\");\n+\n+    // PatKind::MacCall\n+    assert_eq!(stringify_pat!(mac!(...)), \"mac!(...)\");\n+    assert_eq!(stringify_pat!(mac![...]), \"mac![...]\");\n+    assert_eq!(stringify_pat!(mac! { ... }), \"mac! { ... }\");\n+}\n+\n+#[test]\n+fn test_path() {\n+    assert_eq!(stringify_path!(thing), \"thing\");\n+    assert_eq!(stringify_path!(m::thing), \"m::thing\");\n+    assert_eq!(stringify_path!(self::thing), \"self::thing\");\n+    assert_eq!(stringify_path!(crate::thing), \"crate::thing\");\n+    assert_eq!(stringify_path!(Self::thing), \"Self::thing\");\n+    assert_eq!(stringify_path!(Self<'static>), \"Self<'static>\");\n+    assert_eq!(stringify_path!(Self::<'static>), \"Self<'static>\");\n+    assert_eq!(stringify_path!(Self()), \"Self()\");\n+    assert_eq!(stringify_path!(Self() -> ()), \"Self() -> ()\");\n+}\n+\n+#[test]\n+fn test_stmt() {\n+    // StmtKind::Local\n+    assert_eq!(stringify_stmt!(let _), \"let _;\");\n+    assert_eq!(stringify_stmt!(let x = true), \"let x = true;\");\n+    assert_eq!(stringify_stmt!(let x: bool = true), \"let x: bool = true;\");\n+\n+    // StmtKind::Item\n+    assert_eq!(\n+        stringify_stmt!(\n+            struct S;\n+        ),\n+        \"struct S;\",\n+    );\n+\n+    // StmtKind::Expr\n+    assert_eq!(stringify_stmt!(loop {}), \"loop {}\");\n+\n+    // StmtKind::Semi\n+    assert_eq!(stringify_stmt!(1 + 1), \"1 + 1;\");\n+\n+    // StmtKind::Empty\n+    assert_eq!(stringify_stmt!(;), \";\");\n+\n+    // StmtKind::MacCall\n+    assert_eq!(stringify_stmt!(mac!(...)), \"mac!(...)\");\n+    assert_eq!(stringify_stmt!(mac![...]), \"mac![...]\");\n+    assert_eq!(stringify_stmt!(mac! { ... }), \"mac! { ... }\");\n+}\n+\n+#[test]\n+fn test_ty() {\n+    // TyKind::Slice\n+    assert_eq!(stringify_ty!([T]), \"[T]\");\n+\n+    // TyKind::Array\n+    assert_eq!(stringify_ty!([T; 0]), \"[T; 0]\");\n+\n+    // TyKind::Ptr\n+    assert_eq!(stringify_ty!(*const T), \"*const T\");\n+    assert_eq!(stringify_ty!(*mut T), \"*mut T\");\n+\n+    // TyKind::Rptr\n+    assert_eq!(stringify_ty!(&T), \"&T\");\n+    assert_eq!(stringify_ty!(&mut T), \"&mut T\");\n+    assert_eq!(stringify_ty!(&'a T), \"&'a T\");\n+    assert_eq!(stringify_ty!(&'a mut T), \"&'a mut T\");\n+\n+    // TyKind::BareFn\n+    assert_eq!(stringify_ty!(fn()), \"fn()\");\n+    assert_eq!(stringify_ty!(fn() -> ()), \"fn() -> ()\");\n+    assert_eq!(stringify_ty!(fn(u8)), \"fn(u8)\");\n+    assert_eq!(stringify_ty!(fn(x: u8)), \"fn(x: u8)\");\n+    #[rustfmt::skip]\n+    assert_eq!(stringify_ty!(for<> fn()), \"fn()\");\n+    assert_eq!(stringify_ty!(for<'a> fn()), \"for<'a>fn()\"); // FIXME\n+\n+    // TyKind::Never\n+    assert_eq!(stringify_ty!(!), \"!\");\n+\n+    // TyKind::Tup\n+    assert_eq!(stringify_ty!(()), \"()\");\n+    assert_eq!(stringify_ty!((T,)), \"(T,)\");\n+    assert_eq!(stringify_ty!((T, U)), \"(T, U)\");\n+\n+    // TyKind::Path\n+    assert_eq!(stringify_ty!(T), \"T\");\n+    assert_eq!(stringify_ty!(Ref<'a>), \"Ref<'a>\");\n+    assert_eq!(stringify_ty!(PhantomData<T>), \"PhantomData<T>\");\n+    assert_eq!(stringify_ty!(PhantomData::<T>), \"PhantomData<T>\");\n+    assert_eq!(stringify_ty!(Fn() -> !), \"Fn() -> !\");\n+    assert_eq!(stringify_ty!(Fn(u8) -> !), \"Fn(u8) -> !\");\n+    assert_eq!(\n+        stringify_ty!(<Struct as Trait>::Type),\n+        \"<Struct as Trait>::Type\",\n+    );\n+\n+    // TyKind::TraitObject\n+    assert_eq!(stringify_ty!(dyn Send), \"dyn Send\");\n+    assert_eq!(stringify_ty!(dyn Send + 'a), \"dyn Send + 'a\");\n+    assert_eq!(stringify_ty!(dyn 'a + Send), \"dyn 'a + Send\");\n+    assert_eq!(stringify_ty!(dyn ?Sized), \"dyn ?Sized\");\n+    assert_eq!(stringify_ty!(dyn ~const Clone), \"dyn Clone\"); // FIXME\n+    assert_eq!(stringify_ty!(dyn for<'a> Send), \"dyn for<'a> Send\");\n+\n+    // TyKind::ImplTrait\n+    assert_eq!(stringify_ty!(impl Send), \"impl Send\");\n+    assert_eq!(stringify_ty!(impl Send + 'a), \"impl Send + 'a\");\n+    assert_eq!(stringify_ty!(impl 'a + Send), \"impl 'a + Send\");\n+    assert_eq!(stringify_ty!(impl ?Sized), \"impl ?Sized\");\n+    assert_eq!(stringify_ty!(impl ~const Clone), \"impl Clone\"); // FIXME\n+    assert_eq!(stringify_ty!(impl for<'a> Send), \"impl for<'a> Send\");\n+\n+    // TyKind::Paren\n+    assert_eq!(stringify_ty!((T)), \"(T)\");\n+\n+    // TyKind::Infer\n+    assert_eq!(stringify_ty!(_), \"_\");\n+\n+    // TyKind::MacCall\n+    assert_eq!(stringify_ty!(mac!(...)), \"mac!(...)\");\n+    assert_eq!(stringify_ty!(mac![...]), \"mac![...]\");\n+    assert_eq!(stringify_ty!(mac! { ... }), \"mac! { ... }\");\n+}\n+\n+#[test]\n+fn test_vis() {\n+    // VisibilityKind::Public\n+    assert_eq!(stringify_vis!(pub), \"pub \");\n+\n+    // VisibilityKind::Crate\n+    assert_eq!(stringify_vis!(crate), \"crate \");\n+\n+    // VisibilityKind::Restricted\n+    assert_eq!(stringify_vis!(pub(self)), \"pub(self) \");\n+    assert_eq!(stringify_vis!(pub(super)), \"pub(super) \");\n+    assert_eq!(stringify_vis!(pub(in self)), \"pub(self) \");\n+    assert_eq!(stringify_vis!(pub(in super)), \"pub(super) \");\n+    assert_eq!(stringify_vis!(pub(in path::to)), \"pub(in path::to) \");\n+    assert_eq!(stringify_vis!(pub(in ::path::to)), \"pub(in ::path::to) \");\n+    assert_eq!(\n+        stringify_vis!(pub(in self::path::to)),\n+        \"pub(in self::path::to) \",\n+    );\n+    assert_eq!(\n+        stringify_vis!(pub(in super::path::to)),\n+        \"pub(in super::path::to) \",\n+    );\n+\n+    // VisibilityKind::Inherited\n+    // Directly calling `stringify_vis!()` does not work.\n+    macro_rules! stringify_inherited_vis {\n+        ($vis:vis struct) => {\n+            stringify_vis!($vis)\n+        };\n+    }\n+    assert_eq!(stringify_inherited_vis!(struct), \"\");\n+}"}]}