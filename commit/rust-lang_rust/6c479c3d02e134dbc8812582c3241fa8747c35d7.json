{"sha": "6c479c3d02e134dbc8812582c3241fa8747c35d7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZjNDc5YzNkMDJlMTM0ZGJjODgxMjU4MmMzMjQxZmE4NzQ3YzM1ZDc=", "commit": {"author": {"name": "Christian", "email": "chris_veenman@hotmail.com", "date": "2019-03-25T21:21:05Z"}, "committer": {"name": "Christian", "email": "chris_veenman@hotmail.com", "date": "2019-03-25T21:21:05Z"}, "message": "Formatting changes, including better wrapping and creating short summary lines.", "tree": {"sha": "ab0e3c23f3786309c5f359cdcfaee65e49e6574b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ab0e3c23f3786309c5f359cdcfaee65e49e6574b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6c479c3d02e134dbc8812582c3241fa8747c35d7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6c479c3d02e134dbc8812582c3241fa8747c35d7", "html_url": "https://github.com/rust-lang/rust/commit/6c479c3d02e134dbc8812582c3241fa8747c35d7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6c479c3d02e134dbc8812582c3241fa8747c35d7/comments", "author": null, "committer": null, "parents": [{"sha": "70ce4b168d697a55a5aaaebf39e4bda5c4b9db58", "url": "https://api.github.com/repos/rust-lang/rust/commits/70ce4b168d697a55a5aaaebf39e4bda5c4b9db58", "html_url": "https://github.com/rust-lang/rust/commit/70ce4b168d697a55a5aaaebf39e4bda5c4b9db58"}], "stats": {"total": 37, "additions": 21, "deletions": 16}, "files": [{"sha": "cee4fc6f49a713cdfb8ae38350154d5628e226eb", "filename": "src/libcore/convert.rs", "status": "modified", "additions": 21, "deletions": 16, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/6c479c3d02e134dbc8812582c3241fa8747c35d7/src%2Flibcore%2Fconvert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c479c3d02e134dbc8812582c3241fa8747c35d7/src%2Flibcore%2Fconvert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fconvert.rs?ref=6c479c3d02e134dbc8812582c3241fa8747c35d7", "patch": "@@ -1,6 +1,6 @@\n+//! Traits for conversions between types.\n //!\n //! The traits in this module provide a way to convert from one type to another type.\n-//!\n //! Each trait serves a different purpose:\n //!\n //! - Implement the [`AsRef`] trait for cheap reference-to-reference conversions\n@@ -99,12 +99,14 @@ use fmt;\n pub const fn identity<T>(x: T) -> T { x }\n \n /// Used to do a cheap reference-to-reference conversion.\n+///\n /// This trait is similar to [`AsMut`] which is used for converting between mutable references.\n /// If you need to do a costly conversion it is better to implement [`From`] with type\n /// `&T` or write a custom function.\n ///\n ///\n /// `AsRef` is very similar to, but serves a slightly different purpose than [`Borrow`]:\n+///\n /// - Use `AsRef` when the goal is to simply convert into a reference\n /// - Use `Borrow` when the goal is related to writing code that is agnostic to\n ///   the type of borrow and whether it is a reference or value\n@@ -127,6 +129,7 @@ pub const fn identity<T>(x: T) -> T { x }\n ///\n /// By using trait bounds we can accept arguments of different types as long as they can be\n /// converted a the specified type `T`.\n+///\n /// For example: By creating a generic function that takes an `AsRef<str>` we express that we\n /// want to accept all references that can be converted to &str as an argument.\n /// Since both [`String`] and `&str` implement `AsRef<str>` we can accept both as input argument.\n@@ -153,6 +156,7 @@ pub trait AsRef<T: ?Sized> {\n }\n \n /// Used to do a cheap mutable-to-mutable reference conversion.\n+///\n /// This trait is similar to [`AsRef`] but used for converting between mutable\n /// references. If you need to do a costly conversion it is better to\n /// implement [`From`] with type `&mut T` or write a custom function.\n@@ -199,9 +203,9 @@ pub trait AsMut<T: ?Sized> {\n ///\n /// One should only implement [`Into`] if a conversion to a type outside the current crate is\n /// required. Otherwise one should always prefer implementing [`From`] over [`Into`] because\n-/// implementing [`From`] automatically provides one with a implementation of [`Into`]\n-/// thanks to the blanket implementation in the standard library.\n-/// [`From`] cannot do these type of conversions because of Rust's orphaning rules.\n+/// implementing [`From`] automatically provides one with a implementation of [`Into`] thanks to\n+/// the blanket implementation in the standard library. [`From`] cannot do these type of\n+/// conversions because of Rust's orphaning rules.\n ///\n /// **Note: This trait must not fail**. If the conversion can fail, use [`TryInto`].\n ///\n@@ -211,6 +215,7 @@ pub trait AsMut<T: ?Sized> {\n /// - [`Into`]` is reflexive, which means that `Into<T> for T` is implemented\n ///\n /// # Implementing `Into` for conversions to external types\n+///\n /// If the destination type is not part of the current crate\n /// then you can't implement [`From`] directly.\n /// For example, take this code:\n@@ -239,6 +244,7 @@ pub trait AsMut<T: ?Sized> {\n /// It is important to understand that `Into` does not provide a [`From`] implementation\n /// (as [`From`] does with `Into`). Therefore, you should always try to implement [`From`]\n /// and then fall back to `Into` if [`From`] can't be implemented.\n+///\n /// Prefer using `Into` over [`From`] when specifying trait bounds on a generic function\n /// to ensure that types that only implement `Into` can be used as well.\n ///\n@@ -280,19 +286,19 @@ pub trait Into<T>: Sized {\n /// One should always prefer implementing [`From`] over [`Into`]\n /// because implementing [`From`] automatically provides one with a implementation of [`Into`]\n /// thanks to the blanket implementation in the standard library.\n+///\n /// Only implement [`Into`] if a conversion to a type outside the current crate is required.\n /// [`From`] cannot do these type of conversions because of Rust's orphaning rules.\n /// See [`Into`] for more details.\n ///\n /// Prefer using [`Into`] over using [`From`] when specifying trait bounds on a generic function.\n /// This way, types that directly implement [`Into`] can be used as arguments as well.\n ///\n-/// The [`From`] is also very useful when performing error handling.\n-/// When constructing a function that is capable of failing, the return type\n-/// will generally be of the form `Result<T, E>`.\n+/// The [`From`] is also very useful when performing error handling. When constructing a function\n+/// that is capable of failing, the return type will generally be of the form `Result<T, E>`.\n /// The `From` trait simplifies error handling by allowing a function to return a single error type\n-/// that encapsulate multiple error types. See the \"Examples\" section\n-/// and [the book][book] for more details.\n+/// that encapsulate multiple error types. See the \"Examples\" section and [the book][book] for more\n+/// details.\n ///\n /// **Note: This trait must not fail**. If the conversion can fail, use [`TryFrom`].\n ///\n@@ -313,13 +319,12 @@ pub trait Into<T>: Sized {\n /// assert_eq!(string, other_string);\n /// ```\n ///\n-/// While performing error handling it is often useful to implement `From`\n-/// for your own error type. By converting underlying error types to our own custom error type\n-/// that encapsulates the underlying error type, we can return a single error type\n-/// without losing information on the underlying cause. The '?' operator automatically converts\n-/// the underlying error type to our custom error type by calling `Into<CliError>::into`\n-/// which is automatically provided when implementing `From`.\n-/// The compiler then infers which implementation of `Into` should be used.\n+/// While performing error handling it is often useful to implement `From` for your own error type.\n+/// By converting underlying error types to our own custom error type that encapsulates the\n+/// underlying error type, we can return a single error type without losing information on the\n+/// underlying cause. The '?' operator automatically converts the underlying error type to our\n+/// custom error type by calling `Into<CliError>::into` which is automatically provided when\n+/// implementing `From`. The compiler then infers which implementation of `Into` should be used.\n ///\n /// ```\n /// use std::fs;"}]}