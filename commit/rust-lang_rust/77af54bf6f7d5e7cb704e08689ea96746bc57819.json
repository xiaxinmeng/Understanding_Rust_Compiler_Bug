{"sha": "77af54bf6f7d5e7cb704e08689ea96746bc57819", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc3YWY1NGJmNmY3ZDVlN2NiNzA0ZTA4Njg5ZWE5Njc0NmJjNTc4MTk=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-06-20T06:14:24Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-06-20T21:53:28Z"}, "message": "Reduce confusing variable naming in resolve\n\n'id' is now used for node_ids, 'name' for idents", "tree": {"sha": "bfa933ee26219d7d6408a4d4aa4b60c0650cb090", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bfa933ee26219d7d6408a4d4aa4b60c0650cb090"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/77af54bf6f7d5e7cb704e08689ea96746bc57819", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/77af54bf6f7d5e7cb704e08689ea96746bc57819", "html_url": "https://github.com/rust-lang/rust/commit/77af54bf6f7d5e7cb704e08689ea96746bc57819", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/77af54bf6f7d5e7cb704e08689ea96746bc57819/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "75681f9ad7a6b79c5a34fd80c95c22258e30ddb5", "url": "https://api.github.com/repos/rust-lang/rust/commits/75681f9ad7a6b79c5a34fd80c95c22258e30ddb5", "html_url": "https://github.com/rust-lang/rust/commit/75681f9ad7a6b79c5a34fd80c95c22258e30ddb5"}], "stats": {"total": 106, "additions": 55, "deletions": 51}, "files": [{"sha": "f24d0e71859bb9b155781cf2aaa22f6152b92789", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 55, "deletions": 51, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/77af54bf6f7d5e7cb704e08689ea96746bc57819/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77af54bf6f7d5e7cb704e08689ea96746bc57819/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=77af54bf6f7d5e7cb704e08689ea96746bc57819", "patch": "@@ -502,12 +502,12 @@ fn resolve_import(&env e, &@ast::view_item it, &scopes sc) {\n             }\n         }\n     }\n-    fn register(&env e, def_id defid, &span sp, &ident id,\n+    fn register(&env e, def_id defid, &span sp, &ident name,\n                 &option::t[def] val, &option::t[def] typ,\n                 &option::t[def] md) {\n         if (option::is_none(val) && option::is_none(typ) &&\n                 option::is_none(md)) {\n-            unresolved_err(e, sp, id, \"import\");\n+            unresolved_err(e, sp, name, \"import\");\n         } else {\n             e.imports.insert(defid._1, resolved(val, typ, md));\n         }\n@@ -538,8 +538,8 @@ fn ns_name(namespace ns) -> str {\n     }\n }\n \n-fn unresolved_err(&env e, &span sp, &ident id, &str kind) {\n-    e.sess.span_err(sp, mk_unresolved_msg(id, kind));\n+fn unresolved_err(&env e, &span sp, &ident name, &str kind) {\n+    e.sess.span_err(sp, mk_unresolved_msg(name, kind));\n }\n \n fn unresolved_fatal(&env e, &span sp, &ident id, &str kind) -> ! {\n@@ -566,11 +566,11 @@ fn lookup_path_strict(&env e, &scopes sc, &span sp, vec[ident] idents,\n     ret dcur;\n }\n \n-fn lookup_in_scope_strict(&env e, scopes sc, &span sp, &ident id,\n+fn lookup_in_scope_strict(&env e, scopes sc, &span sp, &ident name,\n                           namespace ns) -> option::t[def] {\n-    alt (lookup_in_scope(e, sc, sp, id, ns)) {\n+    alt (lookup_in_scope(e, sc, sp, name, ns)) {\n         case (none) {\n-            unresolved_err(e, sp, id, ns_name(ns));\n+            unresolved_err(e, sp, name, ns_name(ns));\n             ret none;\n         }\n         case (some(?d)) { ret some(d); }\n@@ -598,35 +598,37 @@ fn def_is_obj_field(&def d) -> bool {\n     ret alt (d) { case (ast::def_obj_field(_)) { true } case (_) { false } };\n }\n \n-fn lookup_in_scope(&env e, scopes sc, &span sp, &ident id, namespace ns) ->\n+fn lookup_in_scope(&env e, scopes sc, &span sp, &ident name, namespace ns) ->\n    option::t[def] {\n-    fn in_scope(&env e, &span sp, &ident id, &scope s, namespace ns) ->\n+    fn in_scope(&env e, &span sp, &ident name, &scope s, namespace ns) ->\n        option::t[def] {\n         //not recursing through globs\n \n         alt (s) {\n             case (scope_crate(?c)) {\n-                ret lookup_in_local_mod(e, -1, sp, id, ns, inside);\n+                ret lookup_in_local_mod(e, -1, sp, name, ns, inside);\n             }\n             case (scope_item(?it)) {\n                 alt (it.node) {\n                     case (ast::item_obj(?ob, ?ty_params, _)) {\n-                        ret lookup_in_obj(id, ob, ty_params, ns);\n+                        ret lookup_in_obj(name, ob, ty_params, ns);\n                     }\n                     case (ast::item_tag(_, ?ty_params)) {\n                         if (ns == ns_type) {\n-                            ret lookup_in_ty_params(id, ty_params);\n+                            ret lookup_in_ty_params(name, ty_params);\n                         }\n                     }\n                     case (ast::item_mod(_)) {\n-                        ret lookup_in_local_mod(e, it.id, sp, id, ns, inside);\n+                        ret lookup_in_local_mod\n+                            (e, it.id, sp, name, ns, inside);\n                     }\n                     case (ast::item_native_mod(?m)) {\n-                        ret lookup_in_local_native_mod(e, it.id, sp, id, ns);\n+                        ret lookup_in_local_native_mod\n+                            (e, it.id, sp, name, ns);\n                     }\n                     case (ast::item_ty(_, ?ty_params)) {\n                         if (ns == ns_type) {\n-                            ret lookup_in_ty_params(id, ty_params);\n+                            ret lookup_in_ty_params(name, ty_params);\n                         }\n                     }\n                     case (_) { }\n@@ -636,23 +638,23 @@ fn lookup_in_scope(&env e, scopes sc, &span sp, &ident id, namespace ns) ->\n                 alt (it.node) {\n                     case (ast::native_item_fn(_, _, ?decl, ?ty_params, _))\n                          {\n-                        ret lookup_in_fn(id, decl, ty_params, ns);\n+                        ret lookup_in_fn(name, decl, ty_params, ns);\n                     }\n                 }\n             }\n             case (scope_fn(?decl, ?ty_params)) {\n-                ret lookup_in_fn(id, decl, ty_params, ns);\n+                ret lookup_in_fn(name, decl, ty_params, ns);\n             }\n             case (scope_loop(?local)) {\n                 if (ns == ns_value) {\n-                    if (str::eq(local.node.ident, id)) {\n+                    if (str::eq(local.node.ident, name)) {\n                         ret some(ast::def_local(local_def(local.node.id)));\n                     }\n                 }\n             }\n-            case (scope_block(?b)) { ret lookup_in_block(id, b.node, ns); }\n+            case (scope_block(?b)) { ret lookup_in_block(name, b.node, ns); }\n             case (scope_arm(?a)) {\n-                if (ns == ns_value) { ret lookup_in_pat(id, *a.pat); }\n+                if (ns == ns_value) { ret lookup_in_pat(name, *a.pat); }\n             }\n         }\n         ret none[def];\n@@ -665,7 +667,7 @@ fn lookup_in_scope(&env e, scopes sc, &span sp, &ident id, namespace ns) ->\n         alt ({ sc }) {\n             case (nil) { ret none[def]; }\n             case (cons(?hd, ?tl)) {\n-                auto fnd = in_scope(e, sp, id, hd, ns);\n+                auto fnd = in_scope(e, sp, name, hd, ns);\n                 if (!option::is_none(fnd)) {\n                     auto df = option::get(fnd);\n                     if (left_fn && def_is_local(df) ||\n@@ -686,89 +688,90 @@ fn lookup_in_scope(&env e, scopes sc, &span sp, &ident id, namespace ns) ->\n \n }\n \n-fn lookup_in_ty_params(&ident id, &vec[ast::ty_param] ty_params) ->\n+fn lookup_in_ty_params(&ident name, &vec[ast::ty_param] ty_params) ->\n    option::t[def] {\n     auto i = 0u;\n     for (ast::ty_param tp in ty_params) {\n-        if (str::eq(tp, id)) { ret some(ast::def_ty_arg(i)); }\n+        if (str::eq(tp, name)) { ret some(ast::def_ty_arg(i)); }\n         i += 1u;\n     }\n     ret none[def];\n }\n \n-fn lookup_in_pat(&ident ident, &ast::pat pat) -> option::t[def] {\n+fn lookup_in_pat(&ident name, &ast::pat pat) -> option::t[def] {\n     alt (pat.node) {\n-        case (ast::pat_bind(?name, ?id)) {\n-            if (str::eq(name, ident)) {\n+        case (ast::pat_bind(?p_name, ?id)) {\n+            if (str::eq(p_name, name)) {\n                 ret some(ast::def_binding(local_def(id)));\n             }\n         }\n         case (ast::pat_wild(_)) { }\n         case (ast::pat_lit(_, _)) { }\n         case (ast::pat_tag(_, ?pats, _)) {\n             for (@ast::pat p in pats) {\n-                auto found = lookup_in_pat(ident, *p);\n+                auto found = lookup_in_pat(name, *p);\n                 if (!option::is_none(found)) { ret found; }\n             }\n         }\n     }\n     ret none[def];\n }\n \n-fn lookup_in_fn(&ident id, &ast::fn_decl decl, &vec[ast::ty_param] ty_params,\n+fn lookup_in_fn(&ident name, &ast::fn_decl decl,\n+                &vec[ast::ty_param] ty_params,\n                 namespace ns) -> option::t[def] {\n     alt (ns) {\n         case (ns_value) {\n             for (ast::arg a in decl.inputs) {\n-                if (str::eq(a.ident, id)) {\n+                if (str::eq(a.ident, name)) {\n                     ret some(ast::def_arg(local_def(a.id)));\n                 }\n             }\n             ret none[def];\n         }\n-        case (ns_type) { ret lookup_in_ty_params(id, ty_params); }\n+        case (ns_type) { ret lookup_in_ty_params(name, ty_params); }\n         case (_) { ret none[def]; }\n     }\n }\n \n-fn lookup_in_obj(&ident id, &ast::_obj ob, &vec[ast::ty_param] ty_params,\n+fn lookup_in_obj(&ident name, &ast::_obj ob, &vec[ast::ty_param] ty_params,\n                  namespace ns) -> option::t[def] {\n     alt (ns) {\n         case (ns_value) {\n             for (ast::obj_field f in ob.fields) {\n-                if (str::eq(f.ident, id)) {\n+                if (str::eq(f.ident, name)) {\n                     ret some(ast::def_obj_field(local_def(f.id)));\n                 }\n             }\n             ret none[def];\n         }\n-        case (ns_type) { ret lookup_in_ty_params(id, ty_params); }\n+        case (ns_type) { ret lookup_in_ty_params(name, ty_params); }\n         case (_) { ret none[def]; }\n     }\n }\n \n-fn lookup_in_block(&ident id, &ast::block_ b, namespace ns) ->\n+fn lookup_in_block(&ident name, &ast::block_ b, namespace ns) ->\n    option::t[def] {\n     for (@ast::stmt st in b.stmts) {\n         alt (st.node) {\n             case (ast::stmt_decl(?d, _)) {\n                 alt (d.node) {\n                     case (ast::decl_local(?loc)) {\n-                        if (ns == ns_value && str::eq(id, loc.node.ident)) {\n+                        if (ns == ns_value && str::eq(name, loc.node.ident)) {\n                             ret some(ast::def_local(local_def(loc.node.id)));\n                         }\n                     }\n                     case (ast::decl_item(?it)) {\n                         alt (it.node) {\n                             case (ast::item_tag(?variants, _)) {\n                                 if (ns == ns_type) {\n-                                    if (str::eq(it.ident, id)) {\n+                                    if (str::eq(it.ident, name)) {\n                                         ret some(ast::def_ty\n                                                  (local_def(it.id)));\n                                     }\n                                 } else if (ns == ns_value) {\n                                     for (ast::variant v in variants) {\n-                                        if (str::eq(v.node.name, id)) {\n+                                        if (str::eq(v.node.name, name)) {\n                                             auto i = v.node.id;\n                                             ret some(ast::def_variant\n                                                      (local_def(it.id),\n@@ -778,7 +781,7 @@ fn lookup_in_block(&ident id, &ast::block_ b, namespace ns) ->\n                                 }\n                             }\n                             case (_) {\n-                                if (str::eq(it.ident, id)) {\n+                                if (str::eq(it.ident, name)) {\n                                     auto found = found_def_item(it, ns);\n                                     if (!option::is_none(found)) {\n                                         ret found;\n@@ -839,39 +842,40 @@ fn found_def_item(&@ast::item i, namespace ns) -> option::t[def] {\n     ret none[def];\n }\n \n-fn lookup_in_mod_strict(&env e, def m, &span sp, &ident id, namespace ns,\n+fn lookup_in_mod_strict(&env e, def m, &span sp, &ident name, namespace ns,\n                         dir dr) -> option::t[def] {\n-    alt (lookup_in_mod(e, m, sp, id, ns, dr)) {\n+    alt (lookup_in_mod(e, m, sp, name, ns, dr)) {\n         case (none) {\n-            unresolved_err(e, sp, id, ns_name(ns));\n+            unresolved_err(e, sp, name, ns_name(ns));\n             ret none;\n         }\n         case (some(?d)) { ret some(d); }\n     }\n }\n \n-fn lookup_in_mod(&env e, def m, &span sp, &ident id, namespace ns, dir dr) ->\n+fn lookup_in_mod(&env e, def m, &span sp, &ident name, namespace ns,\n+                 dir dr) ->\n    option::t[def] {\n     auto defid = ast::def_id_of_def(m);\n     if (defid._0 != ast::local_crate) {\n         // examining a module in an external crate\n \n-        auto cached = e.ext_cache.find(tup(defid, id, ns));\n+        auto cached = e.ext_cache.find(tup(defid, name, ns));\n         if (!option::is_none(cached)) { ret cached; }\n-        auto path = [id];\n+        auto path = [name];\n         if (defid._1 != -1) { path = e.ext_map.get(defid) + path; }\n         auto fnd = lookup_external(e, defid._0, path, ns);\n         if (!option::is_none(fnd)) {\n-            e.ext_cache.insert(tup(defid, id, ns), option::get(fnd));\n+            e.ext_cache.insert(tup(defid, name, ns), option::get(fnd));\n         }\n         ret fnd;\n     }\n     alt (m) {\n         case (ast::def_mod(?defid)) {\n-            ret lookup_in_local_mod(e, defid._1, sp, id, ns, dr);\n+            ret lookup_in_local_mod(e, defid._1, sp, name, ns, dr);\n         }\n         case (ast::def_native_mod(?defid)) {\n-            ret lookup_in_local_native_mod(e, defid._1, sp, id, ns);\n+            ret lookup_in_local_native_mod(e, defid._1, sp, name, ns);\n         }\n     }\n }\n@@ -1319,13 +1323,13 @@ fn checker(&env e, str kind) -> checker {\n     ret @rec(mutable seen=seen, kind=kind, sess=e.sess);\n }\n \n-fn add_name(&checker ch, &span sp, &ident id) {\n+fn add_name(&checker ch, &span sp, &ident name) {\n     for (ident s in ch.seen) {\n-        if (str::eq(s, id)) {\n-            ch.sess.span_fatal(sp, \"duplicate \" + ch.kind + \" name: \" + id);\n+        if (str::eq(s, name)) {\n+            ch.sess.span_fatal(sp, \"duplicate \" + ch.kind + \" name: \" + name);\n         }\n     }\n-    vec::push(ch.seen, id);\n+    vec::push(ch.seen, name);\n }\n \n fn ident_id(&ident i) -> ident { ret i; }"}]}