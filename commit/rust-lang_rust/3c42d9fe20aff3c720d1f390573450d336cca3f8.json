{"sha": "3c42d9fe20aff3c720d1f390573450d336cca3f8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNjNDJkOWZlMjBhZmYzYzcyMGQxZjM5MDU3MzQ1MGQzMzZjY2EzZjg=", "commit": {"author": {"name": "Anders Kaseorg", "email": "andersk@mit.edu", "date": "2021-02-19T18:33:03Z"}, "committer": {"name": "Anders Kaseorg", "email": "andersk@mit.edu", "date": "2021-03-25T06:08:13Z"}, "message": "libtest: Index tests by a unique TestId\n\nThis more robustly avoids problems with duplicate TestDesc.  See #81852\nand #82274.\n\nSigned-off-by: Anders Kaseorg <andersk@mit.edu>", "tree": {"sha": "14a11ad34bc73a1ddcd87f49b7c320fc4a129599", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/14a11ad34bc73a1ddcd87f49b7c320fc4a129599"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3c42d9fe20aff3c720d1f390573450d336cca3f8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3c42d9fe20aff3c720d1f390573450d336cca3f8", "html_url": "https://github.com/rust-lang/rust/commit/3c42d9fe20aff3c720d1f390573450d336cca3f8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3c42d9fe20aff3c720d1f390573450d336cca3f8/comments", "author": {"login": "andersk", "id": 26471, "node_id": "MDQ6VXNlcjI2NDcx", "avatar_url": "https://avatars.githubusercontent.com/u/26471?v=4", "gravatar_id": "", "url": "https://api.github.com/users/andersk", "html_url": "https://github.com/andersk", "followers_url": "https://api.github.com/users/andersk/followers", "following_url": "https://api.github.com/users/andersk/following{/other_user}", "gists_url": "https://api.github.com/users/andersk/gists{/gist_id}", "starred_url": "https://api.github.com/users/andersk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/andersk/subscriptions", "organizations_url": "https://api.github.com/users/andersk/orgs", "repos_url": "https://api.github.com/users/andersk/repos", "events_url": "https://api.github.com/users/andersk/events{/privacy}", "received_events_url": "https://api.github.com/users/andersk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "andersk", "id": 26471, "node_id": "MDQ6VXNlcjI2NDcx", "avatar_url": "https://avatars.githubusercontent.com/u/26471?v=4", "gravatar_id": "", "url": "https://api.github.com/users/andersk", "html_url": "https://github.com/andersk", "followers_url": "https://api.github.com/users/andersk/followers", "following_url": "https://api.github.com/users/andersk/following{/other_user}", "gists_url": "https://api.github.com/users/andersk/gists{/gist_id}", "starred_url": "https://api.github.com/users/andersk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/andersk/subscriptions", "organizations_url": "https://api.github.com/users/andersk/orgs", "repos_url": "https://api.github.com/users/andersk/repos", "events_url": "https://api.github.com/users/andersk/events{/privacy}", "received_events_url": "https://api.github.com/users/andersk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "26c7e55f47bf3a93a2e369d162dcc02ddf106f3a", "url": "https://api.github.com/repos/rust-lang/rust/commits/26c7e55f47bf3a93a2e369d162dcc02ddf106f3a", "html_url": "https://github.com/rust-lang/rust/commit/26c7e55f47bf3a93a2e369d162dcc02ddf106f3a"}], "stats": {"total": 116, "additions": 75, "deletions": 41}, "files": [{"sha": "169154187f2500004904fd69f2da0a336faea120", "filename": "library/test/src/bench.rs", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/3c42d9fe20aff3c720d1f390573450d336cca3f8/library%2Ftest%2Fsrc%2Fbench.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c42d9fe20aff3c720d1f390573450d336cca3f8/library%2Ftest%2Fsrc%2Fbench.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Fbench.rs?ref=3c42d9fe20aff3c720d1f390573450d336cca3f8", "patch": "@@ -2,7 +2,11 @@\n pub use std::hint::black_box;\n \n use super::{\n-    event::CompletedTest, options::BenchMode, test_result::TestResult, types::TestDesc, Sender,\n+    event::CompletedTest,\n+    options::BenchMode,\n+    test_result::TestResult,\n+    types::{TestDesc, TestId},\n+    Sender,\n };\n \n use crate::stats;\n@@ -177,8 +181,13 @@ where\n     }\n }\n \n-pub fn benchmark<F>(desc: TestDesc, monitor_ch: Sender<CompletedTest>, nocapture: bool, f: F)\n-where\n+pub fn benchmark<F>(\n+    id: TestId,\n+    desc: TestDesc,\n+    monitor_ch: Sender<CompletedTest>,\n+    nocapture: bool,\n+    f: F,\n+) where\n     F: FnMut(&mut Bencher),\n {\n     let mut bs = Bencher { mode: BenchMode::Auto, summary: None, bytes: 0 };\n@@ -213,7 +222,7 @@ where\n     };\n \n     let stdout = data.lock().unwrap().to_vec();\n-    let message = CompletedTest::new(desc, test_result, None, stdout);\n+    let message = CompletedTest::new(id, desc, test_result, None, stdout);\n     monitor_ch.send(message).unwrap();\n }\n "}, {"sha": "206f3e10e847dc10ac23e8c31c8bcbcbcd08ff95", "filename": "library/test/src/event.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3c42d9fe20aff3c720d1f390573450d336cca3f8/library%2Ftest%2Fsrc%2Fevent.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c42d9fe20aff3c720d1f390573450d336cca3f8/library%2Ftest%2Fsrc%2Fevent.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Fevent.rs?ref=3c42d9fe20aff3c720d1f390573450d336cca3f8", "patch": "@@ -3,10 +3,11 @@\n \n use super::test_result::TestResult;\n use super::time::TestExecTime;\n-use super::types::TestDesc;\n+use super::types::{TestDesc, TestId};\n \n #[derive(Debug, Clone)]\n pub struct CompletedTest {\n+    pub id: TestId,\n     pub desc: TestDesc,\n     pub result: TestResult,\n     pub exec_time: Option<TestExecTime>,\n@@ -15,12 +16,13 @@ pub struct CompletedTest {\n \n impl CompletedTest {\n     pub fn new(\n+        id: TestId,\n         desc: TestDesc,\n         result: TestResult,\n         exec_time: Option<TestExecTime>,\n         stdout: Vec<u8>,\n     ) -> Self {\n-        Self { desc, result, exec_time, stdout }\n+        Self { id, desc, result, exec_time, stdout }\n     }\n }\n "}, {"sha": "2e0864f303cc93dea6ce01aabf90eea6029ff788", "filename": "library/test/src/lib.rs", "status": "modified", "additions": 34, "deletions": 23, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/3c42d9fe20aff3c720d1f390573450d336cca3f8/library%2Ftest%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c42d9fe20aff3c720d1f390573450d336cca3f8/library%2Ftest%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Flib.rs?ref=3c42d9fe20aff3c720d1f390573450d336cca3f8", "patch": "@@ -54,7 +54,7 @@ pub mod test {\n         time::{TestExecTime, TestTimeOptions},\n         types::{\n             DynTestFn, DynTestName, StaticBenchFn, StaticTestFn, StaticTestName, TestDesc,\n-            TestDescAndFn, TestName, TestType,\n+            TestDescAndFn, TestId, TestName, TestType,\n         },\n     };\n }\n@@ -215,9 +215,10 @@ where\n \n     // Use a deterministic hasher\n     type TestMap =\n-        HashMap<TestDesc, RunningTest, BuildHasherDefault<collections::hash_map::DefaultHasher>>;\n+        HashMap<TestId, RunningTest, BuildHasherDefault<collections::hash_map::DefaultHasher>>;\n \n     struct TimeoutEntry {\n+        id: TestId,\n         desc: TestDesc,\n         timeout: Instant,\n     }\n@@ -249,7 +250,9 @@ where\n \n     let (filtered_tests, filtered_benchs): (Vec<_>, _) = filtered_tests\n         .into_iter()\n-        .partition(|e| matches!(e.testfn, StaticTestFn(_) | DynTestFn(_)));\n+        .enumerate()\n+        .map(|(i, e)| (TestId(i), e))\n+        .partition(|(_, e)| matches!(e.testfn, StaticTestFn(_) | DynTestFn(_)));\n \n     let concurrency = opts.test_threads.unwrap_or_else(get_concurrency);\n \n@@ -278,7 +281,7 @@ where\n                 break;\n             }\n             let timeout_entry = timeout_queue.pop_front().unwrap();\n-            if running_tests.contains_key(&timeout_entry.desc) {\n+            if running_tests.contains_key(&timeout_entry.id) {\n                 timed_out.push(timeout_entry.desc);\n             }\n         }\n@@ -294,11 +297,11 @@ where\n \n     if concurrency == 1 {\n         while !remaining.is_empty() {\n-            let test = remaining.pop().unwrap();\n+            let (id, test) = remaining.pop().unwrap();\n             let event = TestEvent::TeWait(test.desc.clone());\n             notify_about_test_event(event)?;\n             let join_handle =\n-                run_test(opts, !opts.run_tests, test, run_strategy, tx.clone(), Concurrent::No);\n+                run_test(opts, !opts.run_tests, id, test, run_strategy, tx.clone(), Concurrent::No);\n             assert!(join_handle.is_none());\n             let completed_test = rx.recv().unwrap();\n \n@@ -308,7 +311,7 @@ where\n     } else {\n         while pending > 0 || !remaining.is_empty() {\n             while pending < concurrency && !remaining.is_empty() {\n-                let test = remaining.pop().unwrap();\n+                let (id, test) = remaining.pop().unwrap();\n                 let timeout = time::get_default_test_timeout();\n                 let desc = test.desc.clone();\n \n@@ -317,13 +320,14 @@ where\n                 let join_handle = run_test(\n                     opts,\n                     !opts.run_tests,\n+                    id,\n                     test,\n                     run_strategy,\n                     tx.clone(),\n                     Concurrent::Yes,\n                 );\n-                running_tests.insert(desc.clone(), RunningTest { join_handle });\n-                timeout_queue.push_back(TimeoutEntry { desc, timeout });\n+                running_tests.insert(id, RunningTest { join_handle });\n+                timeout_queue.push_back(TimeoutEntry { id, desc, timeout });\n                 pending += 1;\n             }\n \n@@ -352,13 +356,12 @@ where\n             }\n \n             let mut completed_test = res.unwrap();\n-            if let Some(running_test) = running_tests.remove(&completed_test.desc) {\n-                if let Some(join_handle) = running_test.join_handle {\n-                    if let Err(_) = join_handle.join() {\n-                        if let TrOk = completed_test.result {\n-                            completed_test.result =\n-                                TrFailedMsg(\"panicked after reporting success\".to_string());\n-                        }\n+            let running_test = running_tests.remove(&completed_test.id).unwrap();\n+            if let Some(join_handle) = running_test.join_handle {\n+                if let Err(_) = join_handle.join() {\n+                    if let TrOk = completed_test.result {\n+                        completed_test.result =\n+                            TrFailedMsg(\"panicked after reporting success\".to_string());\n                     }\n                 }\n             }\n@@ -371,10 +374,10 @@ where\n \n     if opts.bench_benchmarks {\n         // All benchmarks run at the end, in serial.\n-        for b in filtered_benchs {\n+        for (id, b) in filtered_benchs {\n             let event = TestEvent::TeWait(b.desc.clone());\n             notify_about_test_event(event)?;\n-            run_test(opts, false, b, run_strategy, tx.clone(), Concurrent::No);\n+            run_test(opts, false, id, b, run_strategy, tx.clone(), Concurrent::No);\n             let completed_test = rx.recv().unwrap();\n \n             let event = TestEvent::TeResult(completed_test);\n@@ -448,6 +451,7 @@ pub fn convert_benchmarks_to_tests(tests: Vec<TestDescAndFn>) -> Vec<TestDescAnd\n pub fn run_test(\n     opts: &TestOpts,\n     force_ignore: bool,\n+    id: TestId,\n     test: TestDescAndFn,\n     strategy: RunStrategy,\n     monitor_ch: Sender<CompletedTest>,\n@@ -461,7 +465,7 @@ pub fn run_test(\n         && !cfg!(target_os = \"emscripten\");\n \n     if force_ignore || desc.ignore || ignore_because_no_process_support {\n-        let message = CompletedTest::new(desc, TrIgnored, None, Vec::new());\n+        let message = CompletedTest::new(id, desc, TrIgnored, None, Vec::new());\n         monitor_ch.send(message).unwrap();\n         return None;\n     }\n@@ -474,6 +478,7 @@ pub fn run_test(\n     }\n \n     fn run_test_inner(\n+        id: TestId,\n         desc: TestDesc,\n         monitor_ch: Sender<CompletedTest>,\n         testfn: Box<dyn FnOnce() + Send>,\n@@ -484,6 +489,7 @@ pub fn run_test(\n \n         let runtest = move || match opts.strategy {\n             RunStrategy::InProcess => run_test_in_process(\n+                id,\n                 desc,\n                 opts.nocapture,\n                 opts.time.is_some(),\n@@ -492,6 +498,7 @@ pub fn run_test(\n                 opts.time,\n             ),\n             RunStrategy::SpawnPrimary => spawn_test_subprocess(\n+                id,\n                 desc,\n                 opts.nocapture,\n                 opts.time.is_some(),\n@@ -530,14 +537,14 @@ pub fn run_test(\n     match testfn {\n         DynBenchFn(bencher) => {\n             // Benchmarks aren't expected to panic, so we run them all in-process.\n-            crate::bench::benchmark(desc, monitor_ch, opts.nocapture, |harness| {\n+            crate::bench::benchmark(id, desc, monitor_ch, opts.nocapture, |harness| {\n                 bencher.run(harness)\n             });\n             None\n         }\n         StaticBenchFn(benchfn) => {\n             // Benchmarks aren't expected to panic, so we run them all in-process.\n-            crate::bench::benchmark(desc, monitor_ch, opts.nocapture, benchfn);\n+            crate::bench::benchmark(id, desc, monitor_ch, opts.nocapture, benchfn);\n             None\n         }\n         DynTestFn(f) => {\n@@ -546,13 +553,15 @@ pub fn run_test(\n                 _ => panic!(\"Cannot run dynamic test fn out-of-process\"),\n             };\n             run_test_inner(\n+                id,\n                 desc,\n                 monitor_ch,\n                 Box::new(move || __rust_begin_short_backtrace(f)),\n                 test_run_opts,\n             )\n         }\n         StaticTestFn(f) => run_test_inner(\n+            id,\n             desc,\n             monitor_ch,\n             Box::new(move || __rust_begin_short_backtrace(f)),\n@@ -571,6 +580,7 @@ fn __rust_begin_short_backtrace<F: FnOnce()>(f: F) {\n }\n \n fn run_test_in_process(\n+    id: TestId,\n     desc: TestDesc,\n     nocapture: bool,\n     report_time: bool,\n@@ -599,11 +609,12 @@ fn run_test_in_process(\n         Err(e) => calc_result(&desc, Err(e.as_ref()), &time_opts, &exec_time),\n     };\n     let stdout = data.lock().unwrap_or_else(|e| e.into_inner()).to_vec();\n-    let message = CompletedTest::new(desc, test_result, exec_time, stdout);\n+    let message = CompletedTest::new(id, desc, test_result, exec_time, stdout);\n     monitor_ch.send(message).unwrap();\n }\n \n fn spawn_test_subprocess(\n+    id: TestId,\n     desc: TestDesc,\n     nocapture: bool,\n     report_time: bool,\n@@ -653,7 +664,7 @@ fn spawn_test_subprocess(\n         (result, test_output, exec_time)\n     })();\n \n-    let message = CompletedTest::new(desc, result, exec_time, test_output);\n+    let message = CompletedTest::new(id, desc, result, exec_time, test_output);\n     monitor_ch.send(message).unwrap();\n }\n "}, {"sha": "6a3f31b74ea5995f834a9563754663787ab969fa", "filename": "library/test/src/tests.rs", "status": "modified", "additions": 19, "deletions": 11, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/3c42d9fe20aff3c720d1f390573450d336cca3f8/library%2Ftest%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c42d9fe20aff3c720d1f390573450d336cca3f8/library%2Ftest%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Ftests.rs?ref=3c42d9fe20aff3c720d1f390573450d336cca3f8", "patch": "@@ -94,7 +94,7 @@ pub fn do_not_run_ignored_tests() {\n         testfn: DynTestFn(Box::new(f)),\n     };\n     let (tx, rx) = channel();\n-    run_test(&TestOpts::new(), false, desc, RunStrategy::InProcess, tx, Concurrent::No);\n+    run_test(&TestOpts::new(), false, TestId(0), desc, RunStrategy::InProcess, tx, Concurrent::No);\n     let result = rx.recv().unwrap().result;\n     assert_ne!(result, TrOk);\n }\n@@ -113,7 +113,7 @@ pub fn ignored_tests_result_in_ignored() {\n         testfn: DynTestFn(Box::new(f)),\n     };\n     let (tx, rx) = channel();\n-    run_test(&TestOpts::new(), false, desc, RunStrategy::InProcess, tx, Concurrent::No);\n+    run_test(&TestOpts::new(), false, TestId(0), desc, RunStrategy::InProcess, tx, Concurrent::No);\n     let result = rx.recv().unwrap().result;\n     assert_eq!(result, TrIgnored);\n }\n@@ -136,7 +136,7 @@ fn test_should_panic() {\n         testfn: DynTestFn(Box::new(f)),\n     };\n     let (tx, rx) = channel();\n-    run_test(&TestOpts::new(), false, desc, RunStrategy::InProcess, tx, Concurrent::No);\n+    run_test(&TestOpts::new(), false, TestId(0), desc, RunStrategy::InProcess, tx, Concurrent::No);\n     let result = rx.recv().unwrap().result;\n     assert_eq!(result, TrOk);\n }\n@@ -159,7 +159,7 @@ fn test_should_panic_good_message() {\n         testfn: DynTestFn(Box::new(f)),\n     };\n     let (tx, rx) = channel();\n-    run_test(&TestOpts::new(), false, desc, RunStrategy::InProcess, tx, Concurrent::No);\n+    run_test(&TestOpts::new(), false, TestId(0), desc, RunStrategy::InProcess, tx, Concurrent::No);\n     let result = rx.recv().unwrap().result;\n     assert_eq!(result, TrOk);\n }\n@@ -187,7 +187,7 @@ fn test_should_panic_bad_message() {\n         testfn: DynTestFn(Box::new(f)),\n     };\n     let (tx, rx) = channel();\n-    run_test(&TestOpts::new(), false, desc, RunStrategy::InProcess, tx, Concurrent::No);\n+    run_test(&TestOpts::new(), false, TestId(0), desc, RunStrategy::InProcess, tx, Concurrent::No);\n     let result = rx.recv().unwrap().result;\n     assert_eq!(result, TrFailedMsg(failed_msg.to_string()));\n }\n@@ -219,7 +219,7 @@ fn test_should_panic_non_string_message_type() {\n         testfn: DynTestFn(Box::new(f)),\n     };\n     let (tx, rx) = channel();\n-    run_test(&TestOpts::new(), false, desc, RunStrategy::InProcess, tx, Concurrent::No);\n+    run_test(&TestOpts::new(), false, TestId(0), desc, RunStrategy::InProcess, tx, Concurrent::No);\n     let result = rx.recv().unwrap().result;\n     assert_eq!(result, TrFailedMsg(failed_msg));\n }\n@@ -243,7 +243,15 @@ fn test_should_panic_but_succeeds() {\n             testfn: DynTestFn(Box::new(f)),\n         };\n         let (tx, rx) = channel();\n-        run_test(&TestOpts::new(), false, desc, RunStrategy::InProcess, tx, Concurrent::No);\n+        run_test(\n+            &TestOpts::new(),\n+            false,\n+            TestId(0),\n+            desc,\n+            RunStrategy::InProcess,\n+            tx,\n+            Concurrent::No,\n+        );\n         let result = rx.recv().unwrap().result;\n         assert_eq!(\n             result,\n@@ -270,7 +278,7 @@ fn report_time_test_template(report_time: bool) -> Option<TestExecTime> {\n \n     let test_opts = TestOpts { time_options, ..TestOpts::new() };\n     let (tx, rx) = channel();\n-    run_test(&test_opts, false, desc, RunStrategy::InProcess, tx, Concurrent::No);\n+    run_test(&test_opts, false, TestId(0), desc, RunStrategy::InProcess, tx, Concurrent::No);\n     let exec_time = rx.recv().unwrap().exec_time;\n     exec_time\n }\n@@ -305,7 +313,7 @@ fn time_test_failure_template(test_type: TestType) -> TestResult {\n \n     let test_opts = TestOpts { time_options: Some(time_options), ..TestOpts::new() };\n     let (tx, rx) = channel();\n-    run_test(&test_opts, false, desc, RunStrategy::InProcess, tx, Concurrent::No);\n+    run_test(&test_opts, false, TestId(0), desc, RunStrategy::InProcess, tx, Concurrent::No);\n     let result = rx.recv().unwrap().result;\n \n     result\n@@ -637,7 +645,7 @@ pub fn test_bench_no_iter() {\n         test_type: TestType::Unknown,\n     };\n \n-    crate::bench::benchmark(desc, tx, true, f);\n+    crate::bench::benchmark(TestId(0), desc, tx, true, f);\n     rx.recv().unwrap();\n }\n \n@@ -657,7 +665,7 @@ pub fn test_bench_iter() {\n         test_type: TestType::Unknown,\n     };\n \n-    crate::bench::benchmark(desc, tx, true, f);\n+    crate::bench::benchmark(TestId(0), desc, tx, true, f);\n     rx.recv().unwrap();\n }\n "}, {"sha": "c5d91f653b3563e6f33bb29275718615aa66bd2d", "filename": "library/test/src/types.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3c42d9fe20aff3c720d1f390573450d336cca3f8/library%2Ftest%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c42d9fe20aff3c720d1f390573450d336cca3f8/library%2Ftest%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Ftypes.rs?ref=3c42d9fe20aff3c720d1f390573450d336cca3f8", "patch": "@@ -112,9 +112,13 @@ impl fmt::Debug for TestFn {\n     }\n }\n \n+// A unique integer associated with each test.\n+#[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]\n+pub struct TestId(pub usize);\n+\n // The definition of a single test. A test runner will run a list of\n // these.\n-#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n+#[derive(Clone, Debug)]\n pub struct TestDesc {\n     pub name: TestName,\n     pub ignore: bool,"}]}