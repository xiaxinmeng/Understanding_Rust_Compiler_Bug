{"sha": "c4e28ae06842c2066fadb70a1a4f3dc3f1e26e3c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM0ZTI4YWUwNjg0MmMyMDY2ZmFkYjcwYTFhNGYzZGMzZjFlMjZlM2M=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-11-19T08:26:27Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-11-19T08:26:27Z"}, "message": "auto merge of #10542 : huonw/rust/open01, r=alexcrichton\n\nProvide `Closed01` and `Open01` that generate directly from the\r\nclosed/open intervals from 0 to 1, in contrast to the plain impls for\r\nf32 and f64 which generate the half-open [0,1).\r\n\r\nFixes #7755.", "tree": {"sha": "0576e46722adeaa0ab3e8069444e29d8272a15eb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0576e46722adeaa0ab3e8069444e29d8272a15eb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c4e28ae06842c2066fadb70a1a4f3dc3f1e26e3c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c4e28ae06842c2066fadb70a1a4f3dc3f1e26e3c", "html_url": "https://github.com/rust-lang/rust/commit/c4e28ae06842c2066fadb70a1a4f3dc3f1e26e3c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c4e28ae06842c2066fadb70a1a4f3dc3f1e26e3c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f4c22f75d46e94985d2fe45c896bde65e991b13d", "url": "https://api.github.com/repos/rust-lang/rust/commits/f4c22f75d46e94985d2fe45c896bde65e991b13d", "html_url": "https://github.com/rust-lang/rust/commit/f4c22f75d46e94985d2fe45c896bde65e991b13d"}, {"sha": "e6fb622af103a0d642a9b54c78c9183aec5c0d8b", "url": "https://api.github.com/repos/rust-lang/rust/commits/e6fb622af103a0d642a9b54c78c9183aec5c0d8b", "html_url": "https://github.com/rust-lang/rust/commit/e6fb622af103a0d642a9b54c78c9183aec5c0d8b"}], "stats": {"total": 161, "additions": 122, "deletions": 39}, "files": [{"sha": "7e8c193cb777e7472e7271c6714dbe05288d488a", "filename": "src/libstd/rand/distributions/gamma.rs", "status": "modified", "additions": 3, "deletions": 12, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c4e28ae06842c2066fadb70a1a4f3dc3f1e26e3c/src%2Flibstd%2Frand%2Fdistributions%2Fgamma.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4e28ae06842c2066fadb70a1a4f3dc3f1e26e3c/src%2Flibstd%2Frand%2Fdistributions%2Fgamma.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fdistributions%2Fgamma.rs?ref=c4e28ae06842c2066fadb70a1a4f3dc3f1e26e3c", "patch": "@@ -10,7 +10,7 @@\n \n //! The Gamma distribution.\n \n-use rand::Rng;\n+use rand::{Rng, Open01};\n use super::{IndependentSample, Sample, StandardNormal, Exp};\n use num;\n \n@@ -142,11 +142,7 @@ impl IndependentSample<f64> for Gamma {\n }\n impl IndependentSample<f64> for GammaSmallShape {\n     fn ind_sample<R: Rng>(&self, rng: &mut R) -> f64 {\n-        // Need (0, 1) here.\n-        let mut u = rng.gen::<f64>();\n-        while u == 0. {\n-            u = rng.gen();\n-        }\n+        let u = *rng.gen::<Open01<f64>>();\n \n         self.large_shape.ind_sample(rng) * num::pow(u, self.inv_shape)\n     }\n@@ -161,12 +157,7 @@ impl IndependentSample<f64> for GammaLargeShape {\n             }\n \n             let v = v_cbrt * v_cbrt * v_cbrt;\n-            // Need (0, 1) here, not [0, 1). This would be faster if\n-            // we were generating an f64 in (0, 1) directly.\n-            let mut u = rng.gen::<f64>();\n-            while u == 0.0 {\n-                u = rng.gen();\n-            }\n+            let u = *rng.gen::<Open01<f64>>();\n \n             let x_sqr = x * x;\n             if u < 1.0 - 0.0331 * x_sqr * x_sqr ||"}, {"sha": "9697fc22ccd5fa2795868aadc3bf0eff3e630293", "filename": "src/libstd/rand/distributions/mod.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c4e28ae06842c2066fadb70a1a4f3dc3f1e26e3c/src%2Flibstd%2Frand%2Fdistributions%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4e28ae06842c2066fadb70a1a4f3dc3f1e26e3c/src%2Flibstd%2Frand%2Fdistributions%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fdistributions%2Fmod.rs?ref=c4e28ae06842c2066fadb70a1a4f3dc3f1e26e3c", "patch": "@@ -23,7 +23,7 @@ that do not need to record state.\n use iter::range;\n use option::{Some, None};\n use num;\n-use rand::{Rng,Rand};\n+use rand::{Rng, Rand, Open01};\n use clone::Clone;\n \n pub use self::range::Range;\n@@ -276,10 +276,12 @@ impl Rand for StandardNormal {\n             let mut x = 1.0f64;\n             let mut y = 0.0f64;\n \n-            // FIXME #7755: infinities?\n             while -2.0 * y < x * x {\n-                x = rng.gen::<f64>().ln() / ziggurat_tables::ZIG_NORM_R;\n-                y = rng.gen::<f64>().ln();\n+                let x_ = *rng.gen::<Open01<f64>>();\n+                let y_ = *rng.gen::<Open01<f64>>();\n+\n+                x = x_.ln() / ziggurat_tables::ZIG_NORM_R;\n+                y = y_.ln();\n             }\n \n             if u < 0.0 { x - ziggurat_tables::ZIG_NORM_R } else { ziggurat_tables::ZIG_NORM_R - x }"}, {"sha": "a2b555028faafb23d2dc387354f00be3434d5f5d", "filename": "src/libstd/rand/mod.rs", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/c4e28ae06842c2066fadb70a1a4f3dc3f1e26e3c/src%2Flibstd%2Frand%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4e28ae06842c2066fadb70a1a4f3dc3f1e26e3c/src%2Flibstd%2Frand%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fmod.rs?ref=c4e28ae06842c2066fadb70a1a4f3dc3f1e26e3c", "patch": "@@ -647,6 +647,46 @@ pub fn random<T: Rand>() -> T {\n     task_rng().gen()\n }\n \n+/// A wrapper for generating floating point numbers uniformly in the\n+/// open interval `(0,1)` (not including either endpoint).\n+///\n+/// Use `Closed01` for the closed interval `[0,1]`, and the default\n+/// `Rand` implementation for `f32` and `f64` for the half-open\n+/// `[0,1)`.\n+///\n+/// # Example\n+/// ```rust\n+/// use std::rand::{random, Open01};\n+///\n+/// fn main() {\n+///     println!(\"f32 from (0,1): {}\", *random::<Open01<f32>>());\n+///\n+///     let x: Open01<f64> = random();\n+///     println!(\"f64 from (0,1): {}\", *x);\n+/// }\n+/// ```\n+pub struct Open01<F>(F);\n+\n+/// A wrapper for generating floating point numbers uniformly in the\n+/// closed interval `[0,1]` (including both endpoints).\n+///\n+/// Use `Open01` for the closed interval `(0,1)`, and the default\n+/// `Rand` implementation of `f32` and `f64` for the half-open\n+/// `[0,1)`.\n+///\n+/// # Example\n+/// ```rust\n+/// use std::rand::{random, Closed01};\n+///\n+/// fn main() {\n+///     println!(\"f32 from [0,1]: {}\", *random::<Closed01<f32>>());\n+///\n+///     let x: Closed01<f64> = random();\n+///     println!(\"f64 from [0,1]: {}\", *x);\n+/// }\n+/// ```\n+pub struct Closed01<F>(F);\n+\n #[cfg(test)]\n mod test {\n     use iter::{Iterator, range};"}, {"sha": "ff722b739a86a70eceb2ae140185aea1bc105969", "filename": "src/libstd/rand/rand_impls.rs", "status": "modified", "additions": 73, "deletions": 23, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/c4e28ae06842c2066fadb70a1a4f3dc3f1e26e3c/src%2Flibstd%2Frand%2Frand_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4e28ae06842c2066fadb70a1a4f3dc3f1e26e3c/src%2Flibstd%2Frand%2Frand_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Frand_impls.rs?ref=c4e28ae06842c2066fadb70a1a4f3dc3f1e26e3c", "patch": "@@ -94,32 +94,52 @@ impl Rand for u64 {\n     }\n }\n \n-impl Rand for f32 {\n-    /// A random `f32` in the range `[0, 1)`, using 24 bits of\n-    /// precision.\n-    #[inline]\n-    fn rand<R: Rng>(rng: &mut R) -> f32 {\n-        // using any more than 24 bits will cause (e.g.) 0xffff_ffff\n-        // to correspond to 1 exactly, so we need to drop 8 to\n-        // guarantee the open end.\n+macro_rules! float_impls {\n+    ($mod_name:ident, $ty:ty, $mantissa_bits:expr, $method_name:ident, $ignored_bits:expr) => {\n+        mod $mod_name {\n+            use rand::{Rand, Rng, Open01, Closed01};\n \n-        static SCALE: f32 = (1u32 << 24) as f32;\n-        (rng.next_u32() >> 8) as f32 / SCALE\n-    }\n-}\n-\n-impl Rand for f64 {\n-    /// A random `f64` in the range `[0, 1)`, using 53 bits of\n-    /// precision.\n-    #[inline]\n-    fn rand<R: Rng>(rng: &mut R) -> f64 {\n-        // as for f32, but using more bits.\n+            static SCALE: $ty = (1u64 << $mantissa_bits) as $ty;\n \n-        static SCALE: f64 = (1u64 << 53) as f64;\n-        (rng.next_u64() >> 11) as f64 / SCALE\n+            impl Rand for $ty {\n+                /// Generate a floating point number in the half-open\n+                /// interval `[0,1)`.\n+                ///\n+                /// See `Closed01` for the closed interval `[0,1]`,\n+                /// and `Open01` for the open interval `(0,1)`.\n+                #[inline]\n+                fn rand<R: Rng>(rng: &mut R) -> $ty {\n+                    // using any more than `mantissa_bits` bits will\n+                    // cause (e.g.) 0xffff_ffff to correspond to 1\n+                    // exactly, so we need to drop some (8 for f32, 11\n+                    // for f64) to guarantee the open end.\n+                    (rng.$method_name() >> $ignored_bits) as $ty / SCALE\n+                }\n+            }\n+            impl Rand for Open01<$ty> {\n+                #[inline]\n+                fn rand<R: Rng>(rng: &mut R) -> Open01<$ty> {\n+                    // add a small amount (specifically 2 bits below\n+                    // the precision of f64/f32 at 1.0), so that small\n+                    // numbers are larger than 0, but large numbers\n+                    // aren't pushed to/above 1.\n+                    Open01(((rng.$method_name() >> $ignored_bits) as $ty + 0.25) / SCALE)\n+                }\n+            }\n+            impl Rand for Closed01<$ty> {\n+                #[inline]\n+                fn rand<R: Rng>(rng: &mut R) -> Closed01<$ty> {\n+                    // divide by the maximum value of the numerator to\n+                    // get a non-zero probability of getting exactly\n+                    // 1.0.\n+                    Closed01((rng.$method_name() >> $ignored_bits) as $ty / (SCALE - 1.0))\n+                }\n+            }\n+        }\n     }\n }\n-\n+float_impls! { f64_rand_impls, f64, 53, next_u64, 11 }\n+float_impls! { f32_rand_impls, f32, 24, next_u32, 8 }\n \n impl Rand for char {\n     #[inline]\n@@ -206,7 +226,10 @@ impl<T: Rand + 'static> Rand for @T {\n \n #[cfg(test)]\n mod tests {\n-    use rand::Rng;\n+    use rand::{Rng, task_rng, Open01, Closed01};\n+    use iter::range;\n+    use option::{None, Some};\n+\n     struct ConstantRng(u64);\n     impl Rng for ConstantRng {\n         fn next_u32(&mut self) -> u32 {\n@@ -216,9 +239,36 @@ mod tests {\n             **self\n         }\n     }\n+\n     fn floating_point_edge_cases() {\n         // the test for exact equality is correct here.\n         assert!(ConstantRng(0xffff_ffff).gen::<f32>() != 1.0)\n         assert!(ConstantRng(0xffff_ffff_ffff_ffff).gen::<f64>() != 1.0)\n     }\n+\n+    fn rand_open() {\n+        // this is unlikely to catch an incorrect implementation that\n+        // generates exactly 0 or 1, but it keeps it sane.\n+        let mut rng = task_rng();\n+        for _ in range(0, 1_000) {\n+            // strict inequalities\n+            let f = *rng.gen::<Open01<f64>>();\n+            assert!(0.0 < f && f < 1.0);\n+\n+            let f = *rng.gen::<Open01<f32>>();\n+            assert!(0.0 < f && f < 1.0);\n+        }\n+    }\n+\n+    fn rand_closed() {\n+        let mut rng = task_rng();\n+        for _ in range(0, 1_000) {\n+            // strict inequalities\n+            let f = *rng.gen::<Closed01<f64>>();\n+            assert!(0.0 <= f && f <= 1.0);\n+\n+            let f = *rng.gen::<Closed01<f32>>();\n+            assert!(0.0 <= f && f <= 1.0);\n+        }\n+    }\n }"}]}