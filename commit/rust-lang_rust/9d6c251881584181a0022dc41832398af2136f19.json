{"sha": "9d6c251881584181a0022dc41832398af2136f19", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlkNmMyNTE4ODE1ODQxODFhMDAyMmRjNDE4MzIzOThhZjIxMzZmMTk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-10-16T22:21:35Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-10-16T22:21:35Z"}, "message": "auto merge of #9885 : thestinger/rust/vector, r=brson\n\nThe goal here is to avoid requiring a division or multiplication to compare against the length. The bounds check previously used an incorrect micro-optimization to replace the division by a multiplication, but now neither is necessary *for slices*. Unique/managed vectors will have to do a division to get the length until they are reworked/replaced.", "tree": {"sha": "ca1c195cd237e8af82db081b74c679786d65bc6d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ca1c195cd237e8af82db081b74c679786d65bc6d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9d6c251881584181a0022dc41832398af2136f19", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9d6c251881584181a0022dc41832398af2136f19", "html_url": "https://github.com/rust-lang/rust/commit/9d6c251881584181a0022dc41832398af2136f19", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9d6c251881584181a0022dc41832398af2136f19/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fa03c9454640032bb1b6a33f996eee0f39e2b946", "url": "https://api.github.com/repos/rust-lang/rust/commits/fa03c9454640032bb1b6a33f996eee0f39e2b946", "html_url": "https://github.com/rust-lang/rust/commit/fa03c9454640032bb1b6a33f996eee0f39e2b946"}, {"sha": "bd7610f3e3861f5b2323ef03ed1c3ccbb7acef55", "url": "https://api.github.com/repos/rust-lang/rust/commits/bd7610f3e3861f5b2323ef03ed1c3ccbb7acef55", "html_url": "https://github.com/rust-lang/rust/commit/bd7610f3e3861f5b2323ef03ed1c3ccbb7acef55"}], "stats": {"total": 375, "additions": 236, "deletions": 139}, "files": [{"sha": "dbcfb4eebbffae8eaaee7df796e0315691296c98", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 7, "deletions": 16, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/9d6c251881584181a0022dc41832398af2136f19/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d6c251881584181a0022dc41832398af2136f19/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=9d6c251881584181a0022dc41832398af2136f19", "patch": "@@ -1025,8 +1025,7 @@ fn extract_vec_elems(bcx: @mut Block,\n                       -> ExtractedBlock {\n     let _icx = push_ctxt(\"match::extract_vec_elems\");\n     let vec_datum = match_datum(bcx, val, pat_id);\n-    let (bcx, base, len) = vec_datum.get_vec_base_and_len(bcx, pat_span,\n-                                                          pat_id, 0);\n+    let (bcx, base, len) = vec_datum.get_vec_base_and_len(bcx, pat_span, pat_id, 0);\n     let vt = tvec::vec_types(bcx, node_id_type(bcx, pat_id));\n \n     let mut elems = do vec::from_fn(elem_count) |i| {\n@@ -1043,13 +1042,9 @@ fn extract_vec_elems(bcx: @mut Block,\n     };\n     if slice.is_some() {\n         let n = slice.unwrap();\n-        let slice_offset = Mul(bcx, vt.llunit_size,\n-            C_int(bcx.ccx(), n as int)\n-        );\n-        let slice_begin = tvec::pointer_add(bcx, base, slice_offset);\n-        let slice_len_offset = Mul(bcx, vt.llunit_size,\n-            C_int(bcx.ccx(), (elem_count - 1u) as int)\n-        );\n+        let slice_byte_offset = Mul(bcx, vt.llunit_size, C_uint(bcx.ccx(), n));\n+        let slice_begin = tvec::pointer_add_byte(bcx, base, slice_byte_offset);\n+        let slice_len_offset = C_uint(bcx.ccx(), elem_count - 1u);\n         let slice_len = Sub(bcx, len, slice_len_offset);\n         let slice_ty = ty::mk_evec(bcx.tcx(),\n             ty::mt {ty: vt.unit_ty, mutbl: ast::MutImmutable},\n@@ -1059,9 +1054,7 @@ fn extract_vec_elems(bcx: @mut Block,\n         Store(bcx, slice_begin,\n             GEPi(bcx, scratch.val, [0u, abi::slice_elt_base])\n         );\n-        Store(bcx, slice_len,\n-            GEPi(bcx, scratch.val, [0u, abi::slice_elt_len])\n-        );\n+        Store(bcx, slice_len, GEPi(bcx, scratch.val, [0u, abi::slice_elt_len]));\n         elems[n] = scratch.val;\n         scratch.add_clean(bcx);\n     }\n@@ -1647,10 +1640,8 @@ fn compile_submatch_continue(mut bcx: @mut Block,\n             vec_len(*) => {\n                 let vt = tvec::vec_types(bcx, node_id_type(bcx, pat_id));\n                 let unboxed = load_if_immediate(bcx, val, vt.vec_ty);\n-                let (_, len) = tvec::get_base_and_len(\n-                    bcx, unboxed, vt.vec_ty\n-                );\n-                test_val = SDiv(bcx, len, vt.llunit_size);\n+                let (_, len) = tvec::get_base_and_len(bcx, unboxed, vt.vec_ty);\n+                test_val = len;\n                 kind = compare_vec_len;\n             }\n         }"}, {"sha": "e28d6a6899c8b96c635caf7075bd4c746fee2046", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9d6c251881584181a0022dc41832398af2136f19/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d6c251881584181a0022dc41832398af2136f19/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=9d6c251881584181a0022dc41832398af2136f19", "patch": "@@ -54,7 +54,7 @@ use middle::trans::glue;\n use middle::trans::inline;\n use middle::trans::llrepr::LlvmRepr;\n use middle::trans::machine;\n-use middle::trans::machine::{llalign_of_min, llsize_of, llsize_of_alloc};\n+use middle::trans::machine::{llalign_of_min, llsize_of};\n use middle::trans::meth;\n use middle::trans::monomorphize;\n use middle::trans::tvec;\n@@ -745,7 +745,7 @@ pub fn iter_structural_ty(cx: @mut Block, av: ValueRef, t: ty::t,\n       }\n       ty::ty_estr(ty::vstore_fixed(_)) |\n       ty::ty_evec(_, ty::vstore_fixed(_)) => {\n-        let (base, len) = tvec::get_base_and_len(cx, av, t);\n+        let (base, len) = tvec::get_base_and_byte_len(cx, av, t);\n         cx = tvec::iter_vec_raw(cx, base, t, len, f);\n       }\n       ty::ty_tup(ref args) => {\n@@ -2910,7 +2910,7 @@ pub fn decl_gc_metadata(ccx: &mut CrateContext, llmod_id: &str) {\n     }\n }\n \n-pub fn create_module_map(ccx: &mut CrateContext) -> (ValueRef, uint, uint) {\n+pub fn create_module_map(ccx: &mut CrateContext) -> (ValueRef, uint) {\n     let str_slice_type = Type::struct_([Type::i8p(), ccx.int_type], false);\n     let elttype = Type::struct_([str_slice_type, ccx.int_type], false);\n     let maptype = Type::array(&elttype, ccx.module_data.len() as u64);\n@@ -2942,7 +2942,7 @@ pub fn create_module_map(ccx: &mut CrateContext) -> (ValueRef, uint, uint) {\n     unsafe {\n         llvm::LLVMSetInitializer(map, C_array(elttype, elts));\n     }\n-    return (map, keys.len(), llsize_of_alloc(ccx, elttype));\n+    return (map, keys.len())\n }\n \n \n@@ -3004,19 +3004,17 @@ pub fn fill_crate_map(ccx: &mut CrateContext, map: ValueRef) {\n         lib::llvm::SetLinkage(vec_elements, lib::llvm::InternalLinkage);\n \n         llvm::LLVMSetInitializer(vec_elements, C_array(ccx.int_type, subcrates));\n-        let (mod_map, mod_count, mod_struct_size) = create_module_map(ccx);\n+        let (mod_map, mod_count) = create_module_map(ccx);\n \n         llvm::LLVMSetInitializer(map, C_struct(\n             [C_i32(2),\n              C_struct([\n                 p2i(ccx, mod_map),\n-                // byte size of the module map array, an entry consists of two integers\n-                C_int(ccx, ((mod_count * mod_struct_size) as int))\n+                C_uint(ccx, mod_count)\n              ], false),\n              C_struct([\n                 p2i(ccx, vec_elements),\n-                // byte size of the subcrates array, an entry consists of an integer\n-                C_int(ccx, (subcrates.len() * llsize_of_alloc(ccx, ccx.int_type)) as int)\n+                C_uint(ccx, subcrates.len())\n              ], false)\n         ], false));\n     }"}, {"sha": "f85b8de35dd5b6187fea7dbb17f56f93255784c5", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 18, "deletions": 30, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/9d6c251881584181a0022dc41832398af2136f19/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d6c251881584181a0022dc41832398af2136f19/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=9d6c251881584181a0022dc41832398af2136f19", "patch": "@@ -83,23 +83,18 @@ pub fn const_ptrcast(cx: &mut CrateContext, a: ValueRef, t: Type) -> ValueRef {\n     }\n }\n \n-pub fn const_vec(cx: @mut CrateContext, e: &ast::Expr, es: &[@ast::Expr])\n-    -> (ValueRef, ValueRef, Type, bool) {\n-    unsafe {\n-        let vec_ty = ty::expr_ty(cx.tcx, e);\n-        let unit_ty = ty::sequence_element_type(cx.tcx, vec_ty);\n-        let llunitty = type_of::type_of(cx, unit_ty);\n-        let unit_sz = machine::llsize_of(cx, llunitty);\n-        let sz = llvm::LLVMConstMul(C_uint(cx, es.len()), unit_sz);\n-        let (vs, inlineable) = vec::unzip(es.iter().map(|e| const_expr(cx, *e)));\n-        // If the vector contains enums, an LLVM array won't work.\n-        let v = if vs.iter().any(|vi| val_ty(*vi) != llunitty) {\n-            C_struct(vs, false)\n-        } else {\n-            C_array(llunitty, vs)\n-        };\n-        return (v, sz, llunitty, inlineable.iter().fold(true, |a, &b| a && b));\n-    }\n+fn const_vec(cx: @mut CrateContext, e: &ast::Expr, es: &[@ast::Expr]) -> (ValueRef, Type, bool) {\n+    let vec_ty = ty::expr_ty(cx.tcx, e);\n+    let unit_ty = ty::sequence_element_type(cx.tcx, vec_ty);\n+    let llunitty = type_of::type_of(cx, unit_ty);\n+    let (vs, inlineable) = vec::unzip(es.iter().map(|e| const_expr(cx, *e)));\n+    // If the vector contains enums, an LLVM array won't work.\n+    let v = if vs.iter().any(|vi| val_ty(*vi) != llunitty) {\n+        C_struct(vs, false)\n+    } else {\n+        C_array(llunitty, vs)\n+    };\n+    (v, llunitty, inlineable.iter().fold(true, |a, &b| a && b))\n }\n \n fn const_addr_of(cx: &mut CrateContext, cv: ValueRef) -> ValueRef {\n@@ -225,9 +220,8 @@ pub fn const_expr(cx: @mut CrateContext, e: &ast::Expr) -> (ValueRef, bool) {\n                             assert_eq!(abi::slice_elt_len, 1);\n \n                             match ty::get(ty).sty {\n-                                ty::ty_evec(_, ty::vstore_fixed(*)) => {\n-                                    let size = machine::llsize_of(cx, val_ty(llconst));\n-                                    llconst = C_struct([llptr, size], false);\n+                                ty::ty_evec(_, ty::vstore_fixed(len)) => {\n+                                    llconst = C_struct([llptr, C_uint(cx, len)], false);\n                                 }\n                                 _ => {}\n                             }\n@@ -412,14 +406,8 @@ fn const_expr_unadjusted(cx: @mut CrateContext,\n                           (bv, C_uint(cx, u)),\n \n                       ty::vstore_slice(_) => {\n-                          let unit_ty = ty::sequence_element_type(cx.tcx, bt);\n-                          let llunitty = type_of::type_of(cx, unit_ty);\n-                          let unit_sz = machine::llsize_of(cx, llunitty);\n-\n                           let e1 = const_get_elt(cx, bv, [0]);\n-                          (const_deref_ptr(cx, e1),\n-                           llvm::LLVMConstUDiv(const_get_elt(cx, bv, [1]),\n-                                               unit_sz))\n+                          (const_deref_ptr(cx, e1), const_get_elt(cx, bv, [1]))\n                       },\n                       _ => cx.sess.span_bug(base.span,\n                                             \"index-expr base must be fixed-size or slice\")\n@@ -538,7 +526,7 @@ fn const_expr_unadjusted(cx: @mut CrateContext,\n               }\n           }\n           ast::ExprVec(ref es, ast::MutImmutable) => {\n-            let (v, _, _, inlineable) = const_vec(cx, e, *es);\n+            let (v, _, inlineable) = const_vec(cx, e, *es);\n             (v, inlineable)\n           }\n           ast::ExprVstore(sub, ast::ExprVstoreSlice) => {\n@@ -550,7 +538,7 @@ fn const_expr_unadjusted(cx: @mut CrateContext,\n                 }\n               }\n               ast::ExprVec(ref es, ast::MutImmutable) => {\n-                let (cv, sz, llunitty, _) = const_vec(cx, e, *es);\n+                let (cv, llunitty, _) = const_vec(cx, e, *es);\n                 let llty = val_ty(cv);\n                 let gv = do \"const\".with_c_str |name| {\n                     llvm::LLVMAddGlobal(cx.llmod, llty.to_ref(), name)\n@@ -559,7 +547,7 @@ fn const_expr_unadjusted(cx: @mut CrateContext,\n                 llvm::LLVMSetGlobalConstant(gv, True);\n                 SetLinkage(gv, PrivateLinkage);\n                 let p = const_ptrcast(cx, gv, llunitty);\n-                (C_struct([p, sz], false), false)\n+                (C_struct([p, C_uint(cx, es.len())], false), false)\n               }\n               _ => cx.sess.span_bug(e.span, \"bad const-slice expr\")\n             }"}, {"sha": "6411283b79d0e089a740723977fc27c8c43f21df", "filename": "src/librustc/middle/trans/datum.rs", "status": "modified", "additions": 30, "deletions": 6, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/9d6c251881584181a0022dc41832398af2136f19/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d6c251881584181a0022dc41832398af2136f19/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=9d6c251881584181a0022dc41832398af2136f19", "patch": "@@ -770,12 +770,36 @@ impl Datum {\n         DatumBlock { bcx: bcx, datum: datum }\n     }\n \n+    pub fn get_vec_base_and_byte_len(&self,\n+                                     mut bcx: @mut Block,\n+                                     span: Span,\n+                                     expr_id: ast::NodeId,\n+                                     derefs: uint)\n+                                     -> (@mut Block, ValueRef, ValueRef) {\n+        //! Converts a vector into the slice pair. Performs rooting\n+        //! and write guards checks.\n+\n+        // only imp't for @[] and @str, but harmless\n+        bcx = write_guard::root_and_write_guard(self, bcx, span, expr_id, derefs);\n+        let (base, len) = self.get_vec_base_and_byte_len_no_root(bcx);\n+        (bcx, base, len)\n+    }\n+\n+    pub fn get_vec_base_and_byte_len_no_root(&self, bcx: @mut Block)\n+                                             -> (ValueRef, ValueRef) {\n+        //! Converts a vector into the slice pair. Des not root\n+        //! nor perform write guard checks.\n+\n+        let llval = self.to_appropriate_llval(bcx);\n+        tvec::get_base_and_byte_len(bcx, llval, self.ty)\n+    }\n+\n     pub fn get_vec_base_and_len(&self,\n-                                mut bcx: @mut Block,\n-                                span: Span,\n-                                expr_id: ast::NodeId,\n-                                derefs: uint)\n-                                -> (@mut Block, ValueRef, ValueRef) {\n+                                     mut bcx: @mut Block,\n+                                     span: Span,\n+                                     expr_id: ast::NodeId,\n+                                     derefs: uint)\n+                                     -> (@mut Block, ValueRef, ValueRef) {\n         //! Converts a vector into the slice pair. Performs rooting\n         //! and write guards checks.\n \n@@ -786,7 +810,7 @@ impl Datum {\n     }\n \n     pub fn get_vec_base_and_len_no_root(&self, bcx: @mut Block)\n-                                        -> (ValueRef, ValueRef) {\n+                                             -> (ValueRef, ValueRef) {\n         //! Converts a vector into the slice pair. Des not root\n         //! nor perform write guard checks.\n "}, {"sha": "7ccca6df000fac0dddef063a136d99bb40a5b72c", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d6c251881584181a0022dc41832398af2136f19/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d6c251881584181a0022dc41832398af2136f19/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=9d6c251881584181a0022dc41832398af2136f19", "patch": "@@ -1867,7 +1867,7 @@ fn vec_slice_metadata(cx: &mut CrateContext,\n             offset: ComputedMemberOffset,\n         },\n         MemberDescription {\n-            name: @\"size_in_bytes\",\n+            name: @\"length\",\n             llvm_type: member_llvm_types[1],\n             type_metadata: type_metadata(cx, ty::mk_uint(), span),\n             offset: ComputedMemberOffset,"}, {"sha": "48d3e3f7c58b893d4c4f62ae805ea11ecd7b629f", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9d6c251881584181a0022dc41832398af2136f19/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d6c251881584181a0022dc41832398af2136f19/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=9d6c251881584181a0022dc41832398af2136f19", "patch": "@@ -274,6 +274,7 @@ pub fn trans_to_datum(bcx: @mut Block, expr: &ast::Expr) -> DatumBlock {\n                                    ty::vstore_slice(ty::re_static));\n \n         let scratch = scratch_datum(bcx, slice_ty, \"__adjust\", false);\n+\n         Store(bcx, base, GEPi(bcx, scratch.val, [0u, abi::slice_elt_base]));\n         Store(bcx, len, GEPi(bcx, scratch.val, [0u, abi::slice_elt_len]));\n         DatumBlock {bcx: bcx, datum: scratch}\n@@ -972,21 +973,16 @@ fn trans_lvalue_unadjusted(bcx: @mut Block, expr: &ast::Expr) -> DatumBlock {\n \n         let vt = tvec::vec_types(bcx, base_datum.ty);\n         base::maybe_name_value(bcx.ccx(), vt.llunit_size, \"unit_sz\");\n-        let scaled_ix = Mul(bcx, ix_val, vt.llunit_size);\n-        base::maybe_name_value(bcx.ccx(), scaled_ix, \"scaled_ix\");\n \n         let (bcx, base, len) =\n-            base_datum.get_vec_base_and_len(bcx, index_expr.span,\n-                                            index_expr.id, 0);\n+            base_datum.get_vec_base_and_len(bcx, index_expr.span, index_expr.id, 0);\n \n         debug2!(\"trans_index: base {}\", bcx.val_to_str(base));\n         debug2!(\"trans_index: len {}\", bcx.val_to_str(len));\n \n-        let bounds_check = ICmp(bcx, lib::llvm::IntUGE, scaled_ix, len);\n+        let bounds_check = ICmp(bcx, lib::llvm::IntUGE, ix_val, len);\n         let bcx = do with_cond(bcx, bounds_check) |bcx| {\n-            let unscaled_len = UDiv(bcx, len, vt.llunit_size);\n-            controlflow::trans_fail_bounds_check(bcx, index_expr.span,\n-                                                 ix_val, unscaled_len)\n+            controlflow::trans_fail_bounds_check(bcx, index_expr.span, ix_val, len)\n         };\n         let elt = InBoundsGEP(bcx, base, [ix_val]);\n         let elt = PointerCast(bcx, elt, vt.llunit_ty.ptr_to());"}, {"sha": "bde98eff41ce777a45d1edce4a05fcf29bd545e0", "filename": "src/librustc/middle/trans/tvec.rs", "status": "modified", "additions": 42, "deletions": 9, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/9d6c251881584181a0022dc41832398af2136f19/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d6c251881584181a0022dc41832398af2136f19/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=9d6c251881584181a0022dc41832398af2136f19", "patch": "@@ -77,8 +77,8 @@ pub fn get_dataptr(bcx: @mut Block, vptr: ValueRef) -> ValueRef {\n     GEPi(bcx, vptr, [0u, abi::vec_elt_elems, 0u])\n }\n \n-pub fn pointer_add(bcx: @mut Block, ptr: ValueRef, bytes: ValueRef) -> ValueRef {\n-    let _icx = push_ctxt(\"tvec::pointer_add\");\n+pub fn pointer_add_byte(bcx: @mut Block, ptr: ValueRef, bytes: ValueRef) -> ValueRef {\n+    let _icx = push_ctxt(\"tvec::pointer_add_byte\");\n     let old_ty = val_ty(ptr);\n     let bptr = PointerCast(bcx, ptr, Type::i8p());\n     return PointerCast(bcx, InBoundsGEP(bcx, bptr, [bytes]), old_ty);\n@@ -237,8 +237,7 @@ pub fn trans_slice_vstore(bcx: @mut Block,\n         Ignore => {}\n         SaveIn(lldest) => {\n             Store(bcx, llfixed, GEPi(bcx, lldest, [0u, abi::slice_elt_base]));\n-            let lllen = Mul(bcx, llcount, vt.llunit_size);\n-            Store(bcx, lllen, GEPi(bcx, lldest, [0u, abi::slice_elt_len]));\n+            Store(bcx, llcount, GEPi(bcx, lldest, [0u, abi::slice_elt_len]));\n         }\n     }\n \n@@ -502,15 +501,14 @@ pub fn elements_required(bcx: @mut Block, content_expr: &ast::Expr) -> uint {\n     }\n }\n \n-pub fn get_base_and_len(bcx: @mut Block,\n-                        llval: ValueRef,\n+pub fn get_base_and_byte_len(bcx: @mut Block, llval: ValueRef,\n                         vec_ty: ty::t) -> (ValueRef, ValueRef) {\n     //!\n     //\n     // Converts a vector into the slice pair.  The vector should be stored in\n     // `llval` which should be either immediate or by-ref as appropriate for\n     // the vector type.  If you have a datum, you would probably prefer to\n-    // call `Datum::get_base_and_len()` which will handle any conversions for\n+    // call `Datum::get_base_and_byte_len()` which will handle any conversions for\n     // you.\n \n     let ccx = bcx.ccx();\n@@ -529,7 +527,8 @@ pub fn get_base_and_len(bcx: @mut Block,\n         }\n         ty::vstore_slice(_) => {\n             let base = Load(bcx, GEPi(bcx, llval, [0u, abi::slice_elt_base]));\n-            let len = Load(bcx, GEPi(bcx, llval, [0u, abi::slice_elt_len]));\n+            let count = Load(bcx, GEPi(bcx, llval, [0u, abi::slice_elt_len]));\n+            let len = Mul(bcx, count, vt.llunit_size);\n             (base, len)\n         }\n         ty::vstore_uniq | ty::vstore_box => {\n@@ -539,6 +538,40 @@ pub fn get_base_and_len(bcx: @mut Block,\n     }\n }\n \n+pub fn get_base_and_len(bcx: @mut Block, llval: ValueRef, vec_ty: ty::t) -> (ValueRef, ValueRef) {\n+    //!\n+    //\n+    // Converts a vector into the slice pair.  The vector should be stored in\n+    // `llval` which should be either immediate or by-ref as appropriate for\n+    // the vector type.  If you have a datum, you would probably prefer to\n+    // call `Datum::get_base_and_len()` which will handle any conversions for\n+    // you.\n+\n+    let ccx = bcx.ccx();\n+    let vt = vec_types(bcx, vec_ty);\n+\n+    let vstore = match ty::get(vt.vec_ty).sty {\n+      ty::ty_estr(vst) | ty::ty_evec(_, vst) => vst,\n+      _ => ty::vstore_uniq\n+    };\n+\n+    match vstore {\n+        ty::vstore_fixed(n) => {\n+            let base = GEPi(bcx, llval, [0u, 0u]);\n+            (base, C_uint(ccx, n))\n+        }\n+        ty::vstore_slice(_) => {\n+            let base = Load(bcx, GEPi(bcx, llval, [0u, abi::slice_elt_base]));\n+            let count = Load(bcx, GEPi(bcx, llval, [0u, abi::slice_elt_len]));\n+            (base, count)\n+        }\n+        ty::vstore_uniq | ty::vstore_box => {\n+            let body = get_bodyptr(bcx, llval, vec_ty);\n+            (get_dataptr(bcx, body), UDiv(bcx, get_fill(bcx, body), vt.llunit_size))\n+        }\n+    }\n+}\n+\n pub type iter_vec_block<'self> = &'self fn(@mut Block, ValueRef, ty::t) -> @mut Block;\n \n pub fn iter_vec_raw(bcx: @mut Block, data_ptr: ValueRef, vec_ty: ty::t,\n@@ -551,7 +584,7 @@ pub fn iter_vec_raw(bcx: @mut Block, data_ptr: ValueRef, vec_ty: ty::t,\n     // FIXME (#3729): Optimize this when the size of the unit type is\n     // statically known to not use pointer casts, which tend to confuse\n     // LLVM.\n-    let data_end_ptr = pointer_add(bcx, data_ptr, fill);\n+    let data_end_ptr = pointer_add_byte(bcx, data_ptr, fill);\n \n     // Now perform the iteration.\n     let header_bcx = base::sub_block(bcx, \"iter_vec_loop_header\");"}, {"sha": "1e76effd0d248987ce4669e077fd98cfd59d3c29", "filename": "src/libstd/rand/mod.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9d6c251881584181a0022dc41832398af2136f19/src%2Flibstd%2Frand%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d6c251881584181a0022dc41832398af2136f19/src%2Flibstd%2Frand%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fmod.rs?ref=9d6c251881584181a0022dc41832398af2136f19", "patch": "@@ -52,6 +52,8 @@ fn main () {\n  ```\n */\n \n+use sys::size_of;\n+use unstable::raw::Slice;\n use cast;\n use container::Container;\n use iter::{Iterator, range};\n@@ -133,10 +135,10 @@ pub trait Rng {\n     ///    println!(\"{:?}\", v);\n     /// }\n     /// ```\n-    fn fill_bytes(&mut self, mut dest: &mut [u8]) {\n-        // this relies on the lengths being transferred correctly when\n-        // transmuting between vectors like this.\n-        let as_u64: &mut &mut [u64] = unsafe { cast::transmute(&mut dest) };\n+    fn fill_bytes(&mut self, dest: &mut [u8]) {\n+        let mut slice: Slice<u64> = unsafe { cast::transmute_copy(&dest) };\n+        slice.len /= size_of::<u64>();\n+        let as_u64: &mut [u64] = unsafe { cast::transmute(slice) };\n         for dest in as_u64.mut_iter() {\n             *dest = self.next_u64();\n         }\n@@ -147,7 +149,9 @@ pub trait Rng {\n \n         // space for a u32\n         if remaining >= 4 {\n-            let as_u32: &mut &mut [u32] = unsafe { cast::transmute(&mut dest) };\n+            let mut slice: Slice<u32> = unsafe { cast::transmute_copy(&dest) };\n+            slice.len /= size_of::<u32>();\n+            let as_u32: &mut [u32] = unsafe { cast::transmute(slice) };\n             as_u32[as_u32.len() - 1] = self.next_u32();\n             remaining -= 4;\n         }"}, {"sha": "49d5bb3918b8d9b112ebaa89d850663b074de895", "filename": "src/libstd/repr.rs", "status": "modified", "additions": 19, "deletions": 16, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/9d6c251881584181a0022dc41832398af2136f19/src%2Flibstd%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d6c251881584181a0022dc41832398af2136f19/src%2Flibstd%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frepr.rs?ref=9d6c251881584181a0022dc41832398af2136f19", "patch": "@@ -186,12 +186,7 @@ impl<'self> ReprVisitor<'self> {\n         }\n     }\n \n-    pub fn write_vec_range(&mut self,\n-                           _mtbl: uint,\n-                           ptr: *(),\n-                           len: uint,\n-                           inner: *TyDesc)\n-                           -> bool {\n+    pub fn write_vec_range(&mut self, ptr: *(), len: uint, inner: *TyDesc) -> bool {\n         let mut p = ptr as *u8;\n         let (sz, al) = unsafe { ((*inner).size, (*inner).align) };\n         self.writer.write(['[' as u8]);\n@@ -213,13 +208,8 @@ impl<'self> ReprVisitor<'self> {\n         true\n     }\n \n-    pub fn write_unboxed_vec_repr(&mut self,\n-                                  mtbl: uint,\n-                                  v: &raw::Vec<()>,\n-                                  inner: *TyDesc)\n-                                  -> bool {\n-        self.write_vec_range(mtbl, ptr::to_unsafe_ptr(&v.data),\n-                             v.fill, inner)\n+    pub fn write_unboxed_vec_repr(&mut self, _: uint, v: &raw::Vec<()>, inner: *TyDesc) -> bool {\n+        self.write_vec_range(ptr::to_unsafe_ptr(&v.data), v.fill, inner)\n     }\n \n     fn write_escaped_char(&mut self, ch: char, is_str: bool) {\n@@ -377,19 +367,32 @@ impl<'self> TyVisitor for ReprVisitor<'self> {\n         }\n     }\n \n+    #[cfg(stage0)]\n     fn visit_evec_slice(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n         do self.get::<raw::Slice<()>> |this, s| {\n             this.writer.write(['&' as u8]);\n             this.write_mut_qualifier(mtbl);\n-            this.write_vec_range(mtbl, s.data, s.len, inner);\n+            this.write_vec_range(s.data, s.len, inner);\n+        }\n+    }\n+\n+    #[cfg(not(stage0))]\n+    fn visit_evec_slice(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n+        do self.get::<raw::Slice<()>> |this, s| {\n+            this.writer.write(['&' as u8]);\n+            this.write_mut_qualifier(mtbl);\n+            let size = unsafe {\n+                if (*inner).size == 0 { 1 } else { (*inner).size }\n+            };\n+            this.write_vec_range(s.data, s.len * size, inner);\n         }\n     }\n \n     fn visit_evec_fixed(&mut self, n: uint, sz: uint, _align: uint,\n-                        mtbl: uint, inner: *TyDesc) -> bool {\n+                        _: uint, inner: *TyDesc) -> bool {\n         let assumed_size = if sz == 0 { n } else { sz };\n         do self.get::<()> |this, b| {\n-            this.write_vec_range(mtbl, ptr::to_unsafe_ptr(b), assumed_size, inner);\n+            this.write_vec_range(ptr::to_unsafe_ptr(b), assumed_size, inner);\n         }\n     }\n "}, {"sha": "e30d0e7736798d9f887f6d49a02646385136318c", "filename": "src/libstd/unstable/lang.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d6c251881584181a0022dc41832398af2136f19/src%2Flibstd%2Funstable%2Flang.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d6c251881584181a0022dc41832398af2136f19/src%2Flibstd%2Funstable%2Flang.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Flang.rs?ref=9d6c251881584181a0022dc41832398af2136f19", "patch": "@@ -25,7 +25,7 @@ pub fn fail_(expr: *c_char, file: *c_char, line: size_t) -> ! {\n pub fn fail_bounds_check(file: *c_char, line: size_t,\n                          index: size_t, len: size_t) {\n     let msg = format!(\"index out of bounds: the len is {} but the index is {}\",\n-                      len as int, index as int);\n+                      len as uint, index as uint);\n     do msg.with_c_str |buf| {\n         fail_(buf, file, line);\n     }"}, {"sha": "93374d97db55d5d0ff3c31c1a56577968ae12bd8", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/9d6c251881584181a0022dc41832398af2136f19/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d6c251881584181a0022dc41832398af2136f19/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=9d6c251881584181a0022dc41832398af2136f19", "patch": "@@ -974,6 +974,7 @@ pub trait ImmutableVector<'self, T> {\n \n impl<'self,T> ImmutableVector<'self, T> for &'self [T] {\n     #[inline]\n+    #[cfg(stage0)]\n     fn slice(&self, start: uint, end: uint) -> &'self [T] {\n         assert!(start <= end);\n         assert!(end <= self.len());\n@@ -986,10 +987,27 @@ impl<'self,T> ImmutableVector<'self, T> for &'self [T] {\n             }\n         }\n     }\n+\n+    #[inline]\n+    #[cfg(not(stage0))]\n+    fn slice(&self, start: uint, end: uint) -> &'self [T] {\n+        assert!(start <= end);\n+        assert!(end <= self.len());\n+        do self.as_imm_buf |p, _len| {\n+            unsafe {\n+                cast::transmute(Slice {\n+                    data: ptr::offset(p, start as int),\n+                    len: (end - start)\n+                })\n+            }\n+        }\n+    }\n+\n     #[inline]\n     fn slice_from(&self, start: uint) -> &'self [T] {\n         self.slice(start, self.len())\n     }\n+\n     #[inline]\n     fn slice_to(&self, end: uint) -> &'self [T] {\n         self.slice(0, end)\n@@ -1130,10 +1148,18 @@ impl<'self,T> ImmutableVector<'self, T> for &'self [T] {\n     }\n \n     #[inline]\n+    #[cfg(stage0)]\n     fn as_imm_buf<U>(&self, f: &fn(*T, uint) -> U) -> U {\n         let s = self.repr();\n         f(s.data, s.len / sys::nonzero_size_of::<T>())\n     }\n+\n+    #[inline]\n+    #[cfg(not(stage0))]\n+    fn as_imm_buf<U>(&self, f: &fn(*T, uint) -> U) -> U {\n+        let s = self.repr();\n+        f(s.data, s.len)\n+    }\n }\n \n /// Extension methods for vectors contain `Eq` elements.\n@@ -1899,6 +1925,7 @@ pub trait MutableVector<'self, T> {\n \n impl<'self,T> MutableVector<'self, T> for &'self mut [T] {\n     #[inline]\n+    #[cfg(stage0)]\n     fn mut_slice(self, start: uint, end: uint) -> &'self mut [T] {\n         assert!(start <= end);\n         assert!(end <= self.len());\n@@ -1912,6 +1939,21 @@ impl<'self,T> MutableVector<'self, T> for &'self mut [T] {\n         }\n     }\n \n+    #[inline]\n+    #[cfg(not(stage0))]\n+    fn mut_slice(self, start: uint, end: uint) -> &'self mut [T] {\n+        assert!(start <= end);\n+        assert!(end <= self.len());\n+        do self.as_mut_buf |p, _len| {\n+            unsafe {\n+                cast::transmute(Slice {\n+                    data: ptr::mut_offset(p, start as int) as *T,\n+                    len: (end - start)\n+                })\n+            }\n+        }\n+    }\n+\n     #[inline]\n     fn mut_slice_from(self, start: uint) -> &'self mut [T] {\n         let len = self.len();\n@@ -1991,11 +2033,18 @@ impl<'self,T> MutableVector<'self, T> for &'self mut [T] {\n     }\n \n     #[inline]\n+    #[cfg(stage0)]\n     fn as_mut_buf<U>(self, f: &fn(*mut T, uint) -> U) -> U {\n         let Slice{ data, len } = self.repr();\n         f(data as *mut T, len / sys::nonzero_size_of::<T>())\n     }\n \n+    #[inline]\n+    #[cfg(not(stage0))]\n+    fn as_mut_buf<U>(self, f: &fn(*mut T, uint) -> U) -> U {\n+        let Slice{ data, len } = self.repr();\n+        f(data as *mut T, len)\n+    }\n }\n \n /// Trait for &[T] where T is Cloneable\n@@ -2083,6 +2132,7 @@ pub mod raw {\n      * not bytes).\n      */\n     #[inline]\n+    #[cfg(stage0)]\n     pub unsafe fn buf_as_slice<T,U>(p: *T,\n                                     len: uint,\n                                     f: &fn(v: &[T]) -> U) -> U {\n@@ -2097,6 +2147,22 @@ pub mod raw {\n      * not bytes).\n      */\n     #[inline]\n+    #[cfg(not(stage0))]\n+    pub unsafe fn buf_as_slice<T,U>(p: *T,\n+                                    len: uint,\n+                                    f: &fn(v: &[T]) -> U) -> U {\n+        f(cast::transmute(Slice {\n+            data: p,\n+            len: len\n+        }))\n+    }\n+\n+    /**\n+     * Form a slice from a pointer and length (as a number of units,\n+     * not bytes).\n+     */\n+    #[inline]\n+    #[cfg(stage0)]\n     pub unsafe fn mut_buf_as_slice<T,U>(p: *mut T,\n                                         len: uint,\n                                         f: &fn(v: &mut [T]) -> U) -> U {\n@@ -2106,6 +2172,21 @@ pub mod raw {\n         }))\n     }\n \n+    /**\n+     * Form a slice from a pointer and length (as a number of units,\n+     * not bytes).\n+     */\n+    #[inline]\n+    #[cfg(not(stage0))]\n+    pub unsafe fn mut_buf_as_slice<T,U>(p: *mut T,\n+                                        len: uint,\n+                                        f: &fn(v: &mut [T]) -> U) -> U {\n+        f(cast::transmute(Slice {\n+            data: p as *T,\n+            len: len\n+        }))\n+    }\n+\n     /**\n      * Unchecked vector indexing.\n      */"}, {"sha": "1b6dfaecfcd9cdeb6dc338874ee1bd4b7970eceb", "filename": "src/test/debug-info/vec-slices.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/9d6c251881584181a0022dc41832398af2136f19/src%2Ftest%2Fdebug-info%2Fvec-slices.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d6c251881584181a0022dc41832398af2136f19/src%2Ftest%2Fdebug-info%2Fvec-slices.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fvec-slices.rs?ref=9d6c251881584181a0022dc41832398af2136f19", "patch": "@@ -13,33 +13,33 @@\n // debugger:rbreak zzz\n // debugger:run\n // debugger:finish\n-// debugger:print empty.size_in_bytes\n+// debugger:print empty.length\n // check:$1 = 0\n \n-// debugger:print singleton.size_in_bytes\n-// check:$2 = 8\n+// debugger:print singleton.length\n+// check:$2 = 1\n // debugger:print *((int64_t[1]*)(singleton.data_ptr))\n // check:$3 = {1}\n \n-// debugger:print multiple.size_in_bytes\n-// check:$4 = 32\n+// debugger:print multiple.length\n+// check:$4 = 4\n // debugger:print *((int64_t[4]*)(multiple.data_ptr))\n // check:$5 = {2, 3, 4, 5}\n \n-// debugger:print slice_of_slice.size_in_bytes\n-// check:$6 = 16\n+// debugger:print slice_of_slice.length\n+// check:$6 = 2\n // debugger:print *((int64_t[2]*)(slice_of_slice.data_ptr))\n // check:$7 = {3, 4}\n \n-// debugger:print padded_tuple.size_in_bytes\n-// check:$8 = 16\n+// debugger:print padded_tuple.length\n+// check:$8 = 2\n // debugger:print padded_tuple.data_ptr[0]\n // check:$9 = {6, 7}\n // debugger:print padded_tuple.data_ptr[1]\n // check:$10 = {8, 9}\n \n-// debugger:print padded_struct.size_in_bytes\n-// check:$11 = 24\n+// debugger:print padded_struct.length\n+// check:$11 = 2\n // debugger:print padded_struct.data_ptr[0]\n // check:$12 = {x = 10, y = 11, z = 12}\n // debugger:print padded_struct.data_ptr[1]"}, {"sha": "679f060a55d7c25cc54c7b9a62cb5a9d76f8d142", "filename": "src/test/run-fail/bounds-check-no-overflow.rs", "status": "renamed", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9d6c251881584181a0022dc41832398af2136f19/src%2Ftest%2Frun-fail%2Fbounds-check-no-overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d6c251881584181a0022dc41832398af2136f19/src%2Ftest%2Frun-fail%2Fbounds-check-no-overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fbounds-check-no-overflow.rs?ref=9d6c251881584181a0022dc41832398af2136f19", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,12 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern:index out of bounds: the len is 1024 but the index is -1\n+// error-pattern:index out of bounds: the len is 3 but the index is\n \n-use std::vec;\n+use std::uint::max_value;\n+use std::sys::size_of;\n \n fn main() {\n-    let v = vec::from_fn(1024u, {|n| n});\n-    // this should trip a bounds check\n-    error2!(\"{:?}\", v[-1i8]);\n+    let xs = [1, 2, 3];\n+    xs[max_value / size_of::<int>() + 1];\n }", "previous_filename": "src/test/run-fail/small-negative-indexing.rs"}, {"sha": "99ce79b3b6c0ca2c4278df1d2c704e9a2c17cf55", "filename": "src/test/run-fail/vec-underrun.rs", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/fa03c9454640032bb1b6a33f996eee0f39e2b946/src%2Ftest%2Frun-fail%2Fvec-underrun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa03c9454640032bb1b6a33f996eee0f39e2b946/src%2Ftest%2Frun-fail%2Fvec-underrun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fvec-underrun.rs?ref=fa03c9454640032bb1b6a33f996eee0f39e2b946", "patch": "@@ -1,21 +0,0 @@\n-// -*- rust -*-\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-\n-// error-pattern:index out of bounds: the len is 2 but the index is -1\n-fn main() {\n-    let v: ~[int] = ~[10, 20];\n-    let x: int = 0;\n-    assert_eq!(v[x], 10);\n-    // Bounds-check failure.\n-\n-    assert_eq!(v[x - 1], 20);\n-}"}, {"sha": null, "filename": "src/test/run-pass/generic-static-methods.rs", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/9d6c251881584181a0022dc41832398af2136f19/src%2Ftest%2Frun-pass%2Fgeneric-static-methods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d6c251881584181a0022dc41832398af2136f19/src%2Ftest%2Frun-pass%2Fgeneric-static-methods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-static-methods.rs?ref=9d6c251881584181a0022dc41832398af2136f19"}]}