{"sha": "908815ce98ab9e2e359bec8cb3f4869510e04515", "node_id": "C_kwDOAAsO6NoAKDkwODgxNWNlOThhYjllMmUzNTliZWM4Y2IzZjQ4Njk1MTBlMDQ1MTU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-11-29T01:03:48Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-11-29T01:03:48Z"}, "message": "Auto merge of #8001 - Jarcho:unprefixed_strlen, r=giraffate\n\nImprove `strlen_on_c_string`\n\nfixes: #7436\n\nchangelog: lint `strlen_on_c_string` when used without a fully-qualified path\nchangelog: suggest removing the surrounding unsafe block for `strlen_on_c_string` when possible", "tree": {"sha": "1e28d37ed35346bfd80ffcd9c7239359b407a95d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1e28d37ed35346bfd80ffcd9c7239359b407a95d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/908815ce98ab9e2e359bec8cb3f4869510e04515", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/908815ce98ab9e2e359bec8cb3f4869510e04515", "html_url": "https://github.com/rust-lang/rust/commit/908815ce98ab9e2e359bec8cb3f4869510e04515", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/908815ce98ab9e2e359bec8cb3f4869510e04515/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4e84dd121f822c7bc7eb5199370c7173957ed2b2", "url": "https://api.github.com/repos/rust-lang/rust/commits/4e84dd121f822c7bc7eb5199370c7173957ed2b2", "html_url": "https://github.com/rust-lang/rust/commit/4e84dd121f822c7bc7eb5199370c7173957ed2b2"}, {"sha": "a135347f5d638788f4546d684e0d1d64baaeb607", "url": "https://api.github.com/repos/rust-lang/rust/commits/a135347f5d638788f4546d684e0d1d64baaeb607", "html_url": "https://github.com/rust-lang/rust/commit/a135347f5d638788f4546d684e0d1d64baaeb607"}], "stats": {"total": 244, "additions": 197, "deletions": 47}, "files": [{"sha": "fee01fb0bd186db7999e817c8f3751e0d2cf6d82", "filename": "clippy_lints/src/strlen_on_c_strings.rs", "status": "modified", "additions": 36, "deletions": 29, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/908815ce98ab9e2e359bec8cb3f4869510e04515/clippy_lints%2Fsrc%2Fstrlen_on_c_strings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/908815ce98ab9e2e359bec8cb3f4869510e04515/clippy_lints%2Fsrc%2Fstrlen_on_c_strings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fstrlen_on_c_strings.rs?ref=908815ce98ab9e2e359bec8cb3f4869510e04515", "patch": "@@ -1,13 +1,14 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::paths;\n-use clippy_utils::source::snippet_with_macro_callsite;\n-use clippy_utils::ty::{is_type_diagnostic_item, is_type_ref_to_diagnostic_item};\n+use clippy_utils::source::snippet_with_context;\n+use clippy_utils::ty::is_type_diagnostic_item;\n+use clippy_utils::visitors::is_expr_unsafe;\n+use clippy_utils::{get_parent_node, match_libc_symbol};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n-use rustc_hir as hir;\n+use rustc_hir::{Block, BlockCheckMode, Expr, ExprKind, Node, UnsafeSource};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::symbol::{sym, Symbol};\n+use rustc_span::symbol::sym;\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -39,41 +40,47 @@ declare_clippy_lint! {\n declare_lint_pass!(StrlenOnCStrings => [STRLEN_ON_C_STRINGS]);\n \n impl LateLintPass<'tcx> for StrlenOnCStrings {\n-    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n-        if expr.span.from_expansion() {\n-            return;\n-        }\n-\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         if_chain! {\n-            if let hir::ExprKind::Call(func, [recv]) = expr.kind;\n-            if let hir::ExprKind::Path(hir::QPath::Resolved(_, path)) = func.kind;\n-\n-            if (&paths::LIBC_STRLEN).iter().map(|x| Symbol::intern(x)).eq(\n-                path.segments.iter().map(|seg| seg.ident.name));\n-            if let hir::ExprKind::MethodCall(path, _, args, _) = recv.kind;\n-            if args.len() == 1;\n-            if !args.iter().any(|e| e.span.from_expansion());\n+            if !expr.span.from_expansion();\n+            if let ExprKind::Call(func, [recv]) = expr.kind;\n+            if let ExprKind::Path(path) = &func.kind;\n+            if let Some(did) = cx.qpath_res(path, func.hir_id).opt_def_id();\n+            if match_libc_symbol(cx, did, \"strlen\");\n+            if let ExprKind::MethodCall(path, _, [self_arg], _) = recv.kind;\n+            if !recv.span.from_expansion();\n             if path.ident.name == sym::as_ptr;\n             then {\n-                let cstring = &args[0];\n-                let ty = cx.typeck_results().expr_ty(cstring);\n-                let val_name = snippet_with_macro_callsite(cx, cstring.span, \"..\");\n-                let sugg = if is_type_diagnostic_item(cx, ty, sym::cstring_type){\n-                    format!(\"{}.as_bytes().len()\", val_name)\n-                } else if is_type_ref_to_diagnostic_item(cx, ty, sym::CStr){\n-                    format!(\"{}.to_bytes().len()\", val_name)\n+                let ctxt = expr.span.ctxt();\n+                let span = match get_parent_node(cx.tcx, expr.hir_id) {\n+                    Some(Node::Block(&Block {\n+                        rules: BlockCheckMode::UnsafeBlock(UnsafeSource::UserProvided), span, ..\n+                    }))\n+                    if span.ctxt() == ctxt && !is_expr_unsafe(cx, self_arg) => {\n+                        span\n+                    }\n+                    _ => expr.span,\n+                };\n+\n+                let ty = cx.typeck_results().expr_ty(self_arg).peel_refs();\n+                let mut app = Applicability::MachineApplicable;\n+                let val_name = snippet_with_context(cx, self_arg.span, ctxt, \"..\", &mut app).0;\n+                let method_name = if is_type_diagnostic_item(cx, ty, sym::cstring_type) {\n+                    \"as_bytes\"\n+                } else if is_type_diagnostic_item(cx, ty, sym::CStr) {\n+                    \"to_bytes\"\n                 } else {\n                     return;\n                 };\n \n                 span_lint_and_sugg(\n                     cx,\n                     STRLEN_ON_C_STRINGS,\n-                    expr.span,\n+                    span,\n                     \"using `libc::strlen` on a `CString` or `CStr` value\",\n-                    \"try this (you might also need to get rid of `unsafe` block in some cases):\",\n-                    sugg,\n-                    Applicability::Unspecified // Sometimes unnecessary `unsafe` block\n+                    \"try this\",\n+                    format!(\"{}.{}().len()\", val_name, method_name),\n+                    app,\n                 );\n             }\n         }"}, {"sha": "f011380c127a25c10939ed22c1cb07796248e5a4", "filename": "clippy_utils/src/lib.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/908815ce98ab9e2e359bec8cb3f4869510e04515/clippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/908815ce98ab9e2e359bec8cb3f4869510e04515/clippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Flib.rs?ref=908815ce98ab9e2e359bec8cb3f4869510e04515", "patch": "@@ -1597,6 +1597,14 @@ pub fn match_def_path<'tcx>(cx: &LateContext<'tcx>, did: DefId, syms: &[&str]) -\n     syms.iter().map(|x| Symbol::intern(x)).eq(path.iter().copied())\n }\n \n+/// Checks if the given `DefId` matches the `libc` item.\n+pub fn match_libc_symbol(cx: &LateContext<'_>, did: DefId, name: &str) -> bool {\n+    let path = cx.get_def_path(did);\n+    // libc is meant to be used as a flat list of names, but they're all actually defined in different\n+    // modules based on the target platform. Ignore everything but crate name and the item name.\n+    path.first().map_or(false, |s| s.as_str() == \"libc\") && path.last().map_or(false, |s| s.as_str() == name)\n+}\n+\n pub fn match_panic_call(cx: &LateContext<'_>, expr: &'tcx Expr<'_>) -> Option<&'tcx Expr<'tcx>> {\n     if let ExprKind::Call(func, [arg]) = expr.kind {\n         expr_path_res(cx, func)"}, {"sha": "3ffa548e4701f809a7f068454ca4796625376068", "filename": "clippy_utils/src/paths.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/908815ce98ab9e2e359bec8cb3f4869510e04515/clippy_utils%2Fsrc%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/908815ce98ab9e2e359bec8cb3f4869510e04515/clippy_utils%2Fsrc%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fpaths.rs?ref=908815ce98ab9e2e359bec8cb3f4869510e04515", "patch": "@@ -86,7 +86,6 @@ pub const ITERTOOLS_NEXT_TUPLE: [&str; 3] = [\"itertools\", \"Itertools\", \"next_tup\n pub const KW_MODULE: [&str; 3] = [\"rustc_span\", \"symbol\", \"kw\"];\n #[cfg(feature = \"internal-lints\")]\n pub const LATE_CONTEXT: [&str; 2] = [\"rustc_lint\", \"LateContext\"];\n-pub const LIBC_STRLEN: [&str; 2] = [\"libc\", \"strlen\"];\n #[cfg(any(feature = \"internal-lints\", feature = \"metadata-collector-lint\"))]\n pub const LINT: [&str; 2] = [\"rustc_lint_defs\", \"Lint\"];\n pub const MEM_DISCRIMINANT: [&str; 3] = [\"core\", \"mem\", \"discriminant\"];"}, {"sha": "4bfd3c64b9c361acb61001600277e3064bbb2ff3", "filename": "clippy_utils/src/visitors.rs", "status": "modified", "additions": 65, "deletions": 2, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/908815ce98ab9e2e359bec8cb3f4869510e04515/clippy_utils%2Fsrc%2Fvisitors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/908815ce98ab9e2e359bec8cb3f4869510e04515/clippy_utils%2Fsrc%2Fvisitors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fvisitors.rs?ref=908815ce98ab9e2e359bec8cb3f4869510e04515", "patch": "@@ -1,8 +1,10 @@\n use crate::path_to_local_id;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n-use rustc_hir::intravisit::{self, walk_expr, NestedVisitorMap, Visitor};\n-use rustc_hir::{Arm, Block, Body, BodyId, Expr, ExprKind, HirId, Stmt, UnOp};\n+use rustc_hir::intravisit::{self, walk_block, walk_expr, NestedVisitorMap, Visitor};\n+use rustc_hir::{\n+    Arm, Block, BlockCheckMode, Body, BodyId, Expr, ExprKind, HirId, ItemId, ItemKind, Stmt, UnOp, Unsafety,\n+};\n use rustc_lint::LateContext;\n use rustc_middle::hir::map::Map;\n use rustc_middle::ty;\n@@ -317,3 +319,64 @@ pub fn is_const_evaluatable(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) -> bool {\n     v.visit_expr(e);\n     v.is_const\n }\n+\n+/// Checks if the given expression performs an unsafe operation outside of an unsafe block.\n+pub fn is_expr_unsafe(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) -> bool {\n+    struct V<'a, 'tcx> {\n+        cx: &'a LateContext<'tcx>,\n+        is_unsafe: bool,\n+    }\n+    impl<'tcx> Visitor<'tcx> for V<'_, 'tcx> {\n+        type Map = Map<'tcx>;\n+        fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+            NestedVisitorMap::OnlyBodies(self.cx.tcx.hir())\n+        }\n+        fn visit_expr(&mut self, e: &'tcx Expr<'_>) {\n+            if self.is_unsafe {\n+                return;\n+            }\n+            match e.kind {\n+                ExprKind::Unary(UnOp::Deref, e) if self.cx.typeck_results().expr_ty(e).is_unsafe_ptr() => {\n+                    self.is_unsafe = true;\n+                },\n+                ExprKind::MethodCall(..)\n+                    if self\n+                        .cx\n+                        .typeck_results()\n+                        .type_dependent_def_id(e.hir_id)\n+                        .map_or(false, |id| self.cx.tcx.fn_sig(id).unsafety() == Unsafety::Unsafe) =>\n+                {\n+                    self.is_unsafe = true;\n+                },\n+                ExprKind::Call(func, _) => match *self.cx.typeck_results().expr_ty(func).peel_refs().kind() {\n+                    ty::FnDef(id, _) if self.cx.tcx.fn_sig(id).unsafety() == Unsafety::Unsafe => self.is_unsafe = true,\n+                    ty::FnPtr(sig) if sig.unsafety() == Unsafety::Unsafe => self.is_unsafe = true,\n+                    _ => walk_expr(self, e),\n+                },\n+                ExprKind::Path(ref p)\n+                    if self\n+                        .cx\n+                        .qpath_res(p, e.hir_id)\n+                        .opt_def_id()\n+                        .map_or(false, |id| self.cx.tcx.is_mutable_static(id)) =>\n+                {\n+                    self.is_unsafe = true;\n+                },\n+                _ => walk_expr(self, e),\n+            }\n+        }\n+        fn visit_block(&mut self, b: &'tcx Block<'_>) {\n+            if !matches!(b.rules, BlockCheckMode::UnsafeBlock(_)) {\n+                walk_block(self, b);\n+            }\n+        }\n+        fn visit_nested_item(&mut self, id: ItemId) {\n+            if let ItemKind::Impl(i) = &self.cx.tcx.hir().item(id).kind {\n+                self.is_unsafe = i.unsafety == Unsafety::Unsafe;\n+            }\n+        }\n+    }\n+    let mut v = V { cx, is_unsafe: false };\n+    v.visit_expr(e);\n+    v.is_unsafe\n+}"}, {"sha": "947a59bcc027a255dc5f81d90f3bcd37021ec1f5", "filename": "tests/ui/strlen_on_c_strings.fixed", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/908815ce98ab9e2e359bec8cb3f4869510e04515/tests%2Fui%2Fstrlen_on_c_strings.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/908815ce98ab9e2e359bec8cb3f4869510e04515/tests%2Fui%2Fstrlen_on_c_strings.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fstrlen_on_c_strings.fixed?ref=908815ce98ab9e2e359bec8cb3f4869510e04515", "patch": "@@ -0,0 +1,34 @@\n+// run-rustfix\n+\n+#![warn(clippy::strlen_on_c_strings)]\n+#![allow(dead_code)]\n+#![feature(rustc_private)]\n+extern crate libc;\n+\n+#[allow(unused)]\n+use libc::strlen;\n+use std::ffi::{CStr, CString};\n+\n+fn main() {\n+    // CString\n+    let cstring = CString::new(\"foo\").expect(\"CString::new failed\");\n+    let _ = cstring.as_bytes().len();\n+\n+    // CStr\n+    let cstr = CStr::from_bytes_with_nul(b\"foo\\0\").expect(\"CStr::from_bytes_with_nul failed\");\n+    let _ = cstr.to_bytes().len();\n+\n+    let _ = cstr.to_bytes().len();\n+\n+    let pcstr: *const &CStr = &cstr;\n+    let _ = unsafe { (*pcstr).to_bytes().len() };\n+\n+    unsafe fn unsafe_identity<T>(x: T) -> T {\n+        x\n+    }\n+    let _ = unsafe { unsafe_identity(cstr).to_bytes().len() };\n+    let _ = unsafe { unsafe_identity(cstr) }.to_bytes().len();\n+\n+    let f: unsafe fn(_) -> _ = unsafe_identity;\n+    let _ = unsafe { f(cstr).to_bytes().len() };\n+}"}, {"sha": "1237f1ab03acd07ebe1f5037fd28eb07fddb7048", "filename": "tests/ui/strlen_on_c_strings.rs", "status": "modified", "additions": 20, "deletions": 2, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/908815ce98ab9e2e359bec8cb3f4869510e04515/tests%2Fui%2Fstrlen_on_c_strings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/908815ce98ab9e2e359bec8cb3f4869510e04515/tests%2Fui%2Fstrlen_on_c_strings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fstrlen_on_c_strings.rs?ref=908815ce98ab9e2e359bec8cb3f4869510e04515", "patch": "@@ -1,16 +1,34 @@\n+// run-rustfix\n+\n #![warn(clippy::strlen_on_c_strings)]\n #![allow(dead_code)]\n #![feature(rustc_private)]\n extern crate libc;\n \n+#[allow(unused)]\n+use libc::strlen;\n use std::ffi::{CStr, CString};\n \n fn main() {\n     // CString\n     let cstring = CString::new(\"foo\").expect(\"CString::new failed\");\n-    let len = unsafe { libc::strlen(cstring.as_ptr()) };\n+    let _ = unsafe { libc::strlen(cstring.as_ptr()) };\n \n     // CStr\n     let cstr = CStr::from_bytes_with_nul(b\"foo\\0\").expect(\"CStr::from_bytes_with_nul failed\");\n-    let len = unsafe { libc::strlen(cstr.as_ptr()) };\n+    let _ = unsafe { libc::strlen(cstr.as_ptr()) };\n+\n+    let _ = unsafe { strlen(cstr.as_ptr()) };\n+\n+    let pcstr: *const &CStr = &cstr;\n+    let _ = unsafe { strlen((*pcstr).as_ptr()) };\n+\n+    unsafe fn unsafe_identity<T>(x: T) -> T {\n+        x\n+    }\n+    let _ = unsafe { strlen(unsafe_identity(cstr).as_ptr()) };\n+    let _ = unsafe { strlen(unsafe { unsafe_identity(cstr) }.as_ptr()) };\n+\n+    let f: unsafe fn(_) -> _ = unsafe_identity;\n+    let _ = unsafe { strlen(f(cstr).as_ptr()) };\n }"}, {"sha": "296268a5f1df79988635dd896c9715e3215cb9c9", "filename": "tests/ui/strlen_on_c_strings.stderr", "status": "modified", "additions": 34, "deletions": 13, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/908815ce98ab9e2e359bec8cb3f4869510e04515/tests%2Fui%2Fstrlen_on_c_strings.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/908815ce98ab9e2e359bec8cb3f4869510e04515/tests%2Fui%2Fstrlen_on_c_strings.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fstrlen_on_c_strings.stderr?ref=908815ce98ab9e2e359bec8cb3f4869510e04515", "patch": "@@ -1,25 +1,46 @@\n error: using `libc::strlen` on a `CString` or `CStr` value\n-  --> $DIR/strlen_on_c_strings.rs:11:24\n+  --> $DIR/strlen_on_c_strings.rs:15:13\n    |\n-LL |     let len = unsafe { libc::strlen(cstring.as_ptr()) };\n-   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     let _ = unsafe { libc::strlen(cstring.as_ptr()) };\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `cstring.as_bytes().len()`\n    |\n    = note: `-D clippy::strlen-on-c-strings` implied by `-D warnings`\n-help: try this (you might also need to get rid of `unsafe` block in some cases):\n+\n+error: using `libc::strlen` on a `CString` or `CStr` value\n+  --> $DIR/strlen_on_c_strings.rs:19:13\n+   |\n+LL |     let _ = unsafe { libc::strlen(cstr.as_ptr()) };\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `cstr.to_bytes().len()`\n+\n+error: using `libc::strlen` on a `CString` or `CStr` value\n+  --> $DIR/strlen_on_c_strings.rs:21:13\n+   |\n+LL |     let _ = unsafe { strlen(cstr.as_ptr()) };\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `cstr.to_bytes().len()`\n+\n+error: using `libc::strlen` on a `CString` or `CStr` value\n+  --> $DIR/strlen_on_c_strings.rs:24:22\n    |\n-LL |     let len = unsafe { cstring.as_bytes().len() };\n-   |                        ~~~~~~~~~~~~~~~~~~~~~~~~\n+LL |     let _ = unsafe { strlen((*pcstr).as_ptr()) };\n+   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `(*pcstr).to_bytes().len()`\n \n error: using `libc::strlen` on a `CString` or `CStr` value\n-  --> $DIR/strlen_on_c_strings.rs:15:24\n+  --> $DIR/strlen_on_c_strings.rs:29:22\n    |\n-LL |     let len = unsafe { libc::strlen(cstr.as_ptr()) };\n-   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     let _ = unsafe { strlen(unsafe_identity(cstr).as_ptr()) };\n+   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `unsafe_identity(cstr).to_bytes().len()`\n+\n+error: using `libc::strlen` on a `CString` or `CStr` value\n+  --> $DIR/strlen_on_c_strings.rs:30:13\n    |\n-help: try this (you might also need to get rid of `unsafe` block in some cases):\n+LL |     let _ = unsafe { strlen(unsafe { unsafe_identity(cstr) }.as_ptr()) };\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `unsafe { unsafe_identity(cstr) }.to_bytes().len()`\n+\n+error: using `libc::strlen` on a `CString` or `CStr` value\n+  --> $DIR/strlen_on_c_strings.rs:33:22\n    |\n-LL |     let len = unsafe { cstr.to_bytes().len() };\n-   |                        ~~~~~~~~~~~~~~~~~~~~~\n+LL |     let _ = unsafe { strlen(f(cstr).as_ptr()) };\n+   |                      ^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `f(cstr).to_bytes().len()`\n \n-error: aborting due to 2 previous errors\n+error: aborting due to 7 previous errors\n "}]}