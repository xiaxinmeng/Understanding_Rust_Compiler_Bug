{"sha": "5e8bf872f6adf145b75610dc216e942a84343179", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVlOGJmODcyZjZhZGYxNDViNzU2MTBkYzIxNmU5NDJhODQzNDMxNzk=", "commit": {"author": {"name": "Baoshan", "email": "pangbw@gmail.com", "date": "2019-09-11T04:21:48Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-09-11T04:21:48Z"}, "message": "Merge pull request #21 from rust-lang/master\n\nSync with rust-lang/rust master branch", "tree": {"sha": "fba9fd9e3b84c88b19e650ba1da44075f23b7220", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fba9fd9e3b84c88b19e650ba1da44075f23b7220"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5e8bf872f6adf145b75610dc216e942a84343179", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdeHZcCRBK7hj4Ov3rIwAAdHIIAGZJPb0LxG+EV/ZoVvYU/HcA\nhKYRFvz0Qe3MkS6w0yMxolhXalzgW0Y+dtkutCoLcvx7KVvjaPU6EOrGecrqpnwk\nelGbI753CSO8Ep9arJ10m87sv4Dif90gI6WK57AbClNZTOPLxZMan+ZoVGoTO/Dd\noE18DNtxOYpSe95rVgc6ani7U6wYT87NhXm8q6Wrjc8coW1fXSiJUTAS5EwRQ14D\n2qyy3it+LC4CKjr81rFg+gewslJecaRrD7bR/I3/48kgEouixJr7J2SVyEivccaq\n+PyWM37LmVbtPTW4AF8YDl16tOeMgq3fVFkOIU9QSvj2LJT97NDL0z4m/3j0X24=\n=km1F\n-----END PGP SIGNATURE-----\n", "payload": "tree fba9fd9e3b84c88b19e650ba1da44075f23b7220\nparent 76f17219c71973fd4a58f2f8020eec4d8f5dcd11\nparent 34e82a7b793a6cdd27df762bf46bab8cdc92b14a\nauthor Baoshan <pangbw@gmail.com> 1568175708 -0700\ncommitter GitHub <noreply@github.com> 1568175708 -0700\n\nMerge pull request #21 from rust-lang/master\n\nSync with rust-lang/rust master branch"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5e8bf872f6adf145b75610dc216e942a84343179", "html_url": "https://github.com/rust-lang/rust/commit/5e8bf872f6adf145b75610dc216e942a84343179", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5e8bf872f6adf145b75610dc216e942a84343179/comments", "author": {"login": "BaoshanPang", "id": 3380860, "node_id": "MDQ6VXNlcjMzODA4NjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3380860?v=4", "gravatar_id": "", "url": "https://api.github.com/users/BaoshanPang", "html_url": "https://github.com/BaoshanPang", "followers_url": "https://api.github.com/users/BaoshanPang/followers", "following_url": "https://api.github.com/users/BaoshanPang/following{/other_user}", "gists_url": "https://api.github.com/users/BaoshanPang/gists{/gist_id}", "starred_url": "https://api.github.com/users/BaoshanPang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/BaoshanPang/subscriptions", "organizations_url": "https://api.github.com/users/BaoshanPang/orgs", "repos_url": "https://api.github.com/users/BaoshanPang/repos", "events_url": "https://api.github.com/users/BaoshanPang/events{/privacy}", "received_events_url": "https://api.github.com/users/BaoshanPang/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "76f17219c71973fd4a58f2f8020eec4d8f5dcd11", "url": "https://api.github.com/repos/rust-lang/rust/commits/76f17219c71973fd4a58f2f8020eec4d8f5dcd11", "html_url": "https://github.com/rust-lang/rust/commit/76f17219c71973fd4a58f2f8020eec4d8f5dcd11"}, {"sha": "34e82a7b793a6cdd27df762bf46bab8cdc92b14a", "url": "https://api.github.com/repos/rust-lang/rust/commits/34e82a7b793a6cdd27df762bf46bab8cdc92b14a", "html_url": "https://github.com/rust-lang/rust/commit/34e82a7b793a6cdd27df762bf46bab8cdc92b14a"}], "stats": {"total": 44817, "additions": 25018, "deletions": 19799}, "files": [{"sha": "da8044de405a6afc1466e7a2f2e2d8b9b937c2f0", "filename": ".mailmap", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/.mailmap", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/.mailmap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.mailmap?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -117,6 +117,9 @@ Jason Toffaletti <toffaletti@gmail.com> Jason Toffaletti <jason@topsy.com>\n Jauhien Piatlicki <jauhien@gentoo.org> Jauhien Piatlicki <jpiatlicki@zertisa.com>\n Jay True <glacjay@gmail.com>\n Jeremy Letang <letang.jeremy@gmail.com>\n+Jeremy Stucki <dev@jeremystucki.ch> <stucki.jeremy@gmail.com>\n+Jeremy Stucki <dev@jeremystucki.ch> <jeremy@myelin.ch>\n+Jeremy Stucki <dev@jeremystucki.ch>\n Jethro Beekman <github@jbeekman.nl>\n Jihyun Yu <j.yu@navercorp.com> <yjh0502@gmail.com>\n Jihyun Yu <j.yu@navercorp.com> jihyun <jihyun@nablecomm.com>\n@@ -181,12 +184,19 @@ Neil Pankey <npankey@gmail.com> <neil@wire.im>\n Nick Platt <platt.nicholas@gmail.com>\n Nicole Mazzuca <npmazzuca@gmail.com>\n Nif Ward <nif.ward@gmail.com>\n-Oliver Schneider <oliver.schneider@kit.edu> oli-obk <github6541940@oli-obk.de>\n-Oliver Schneider <oliver.schneider@kit.edu> Oliver 'ker' Schneider <rust19446194516@oli-obk.de>\n-Oliver Schneider <oliver.schneider@kit.edu> Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de>\n-Oliver Schneider <oliver.schneider@kit.edu> Oliver Schneider <git-spam9815368754983@oli-obk.de>\n-Oliver Schneider <oliver.schneider@kit.edu> Oliver Schneider <github333195615777966@oli-obk.de>\n-Oliver Schneider <oliver.schneider@kit.edu> Oliver Schneider <github6541940@oli-obk.de>\n+Oliver Scherer <oliver.schneider@kit.edu> <git-spam-no-reply9815368754983@oli-obk.de>\n+Oliver Scherer <oliver.schneider@kit.edu> <git-spam9815368754983@oli-obk.de>\n+Oliver Scherer <oliver.schneider@kit.edu> <github333195615777966@oli-obk.de>\n+Oliver Scherer <oliver.schneider@kit.edu> <github6541940@oli-obk.de>\n+Oliver Scherer <oliver.schneider@kit.edu> <rust19446194516@oli-obk.de>\n+Oliver Scherer <oliver.schneider@kit.edu> <git-no-reply-9879165716479413131@oli-obk.de>\n+Oliver Scherer <oliver.schneider@kit.edu> <git1984941651981@oli-obk.de>\n+Oliver Scherer <oliver.schneider@kit.edu> <github35764891676564198441@oli-obk.de>\n+Oliver Scherer <oliver.schneider@kit.edu> <github6541940@oli-obk.de>\n+Oliver Scherer <oliver.schneider@kit.edu> <oli-obk@users.noreply.github.com>\n+Oliver Scherer <oliver.schneider@kit.edu> <public.oliver.schneider@kit.edu>\n+Oliver Scherer <oliver.schneider@kit.edu> <obk8176014uqher834@olio-obk.de>\n+Oliver Scherer <oliver.schneider@kit.edu>\n O\u017ebolt Menegatti <ozbolt.menegatti@gmail.com> gareins <ozbolt.menegatti@gmail.com>\n Paul Faria <paul_faria@ultimatesoftware.com> Paul Faria <Nashenas88@gmail.com>\n Peer Aramillo Irizar <peer.aramillo.irizar@gmail.com> parir <peer.aramillo.irizar@gmail.com>"}, {"sha": "27ee38146097b21b25b3a8bc36e26544bd417916", "filename": "Cargo.lock", "status": "modified", "additions": 486, "deletions": 224, "changes": 710, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -109,9 +109,9 @@ dependencies = [\n \n [[package]]\n name = \"backtrace\"\n-version = \"0.3.35\"\n+version = \"0.3.37\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"1371048253fa3bac6704bfd6bbfc922ee9bdcee8881330d40f308b81cc5adc55\"\n+checksum = \"5180c5a20655b14a819b652fd2378fa5f1697b6c9ddad3e695c2f9cedf6df4e2\"\n dependencies = [\n  \"backtrace-sys\",\n  \"cfg-if\",\n@@ -185,7 +185,7 @@ dependencies = [\n  \"serde\",\n  \"serde_json\",\n  \"time\",\n- \"toml 0.4.10\",\n+ \"toml\",\n ]\n \n [[package]]\n@@ -202,7 +202,7 @@ name = \"build-manifest\"\n version = \"0.1.0\"\n dependencies = [\n  \"serde\",\n- \"toml 0.4.10\",\n+ \"toml\",\n ]\n \n [[package]]\n@@ -223,9 +223,9 @@ checksum = \"560c32574a12a89ecd91f5e742165893f86e3ab98d21f8ea548658eb9eef5f40\"\n \n [[package]]\n name = \"bytecount\"\n-version = \"0.5.1\"\n+version = \"0.6.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"be0fdd54b507df8f22012890aadd099979befdba27713c767993f8380112ca7c\"\n+checksum = \"b0017894339f586ccb943b01b9555de56770c11cda818e7e3d8bd93f4ed7f46e\"\n dependencies = [\n  \"packed_simd\",\n ]\n@@ -277,7 +277,7 @@ dependencies = [\n  \"crypto-hash\",\n  \"curl\",\n  \"curl-sys\",\n- \"env_logger 0.6.0\",\n+ \"env_logger\",\n  \"failure\",\n  \"filetime\",\n  \"flate2\",\n@@ -287,7 +287,7 @@ dependencies = [\n  \"git2-curl\",\n  \"glob\",\n  \"hex\",\n- \"home 0.4.2\",\n+ \"home\",\n  \"ignore\",\n  \"im-rc\",\n  \"jobserver\",\n@@ -309,14 +309,14 @@ dependencies = [\n  \"same-file\",\n  \"semver\",\n  \"serde\",\n- \"serde_ignored 0.1.0\",\n+ \"serde_ignored\",\n  \"serde_json\",\n  \"shell-escape\",\n  \"strip-ansi-escapes\",\n  \"tar\",\n  \"tempfile\",\n  \"termcolor\",\n- \"toml 0.5.3\",\n+ \"toml\",\n  \"unicode-width\",\n  \"url 2.1.0\",\n  \"walkdir\",\n@@ -392,9 +392,9 @@ dependencies = [\n \n [[package]]\n name = \"clap\"\n-version = \"2.32.0\"\n+version = \"2.33.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"b957d88f4b6a63b9d70d5f454ac8011819c6efa7727858f458ab71c756ce2d3e\"\n+checksum = \"5067f5bb2d80ef5d68b4c87db81601f0b75bca627bc2ef76b141d7b846a3c6d9\"\n dependencies = [\n  \"ansi_term\",\n  \"atty\",\n@@ -442,7 +442,7 @@ dependencies = [\n  \"semver\",\n  \"serde\",\n  \"smallvec\",\n- \"toml 0.5.3\",\n+ \"toml\",\n  \"unicode-normalization\",\n  \"url 2.1.0\",\n ]\n@@ -507,7 +507,7 @@ name = \"compiletest\"\n version = \"0.0.0\"\n dependencies = [\n  \"diff\",\n- \"env_logger 0.5.13\",\n+ \"env_logger\",\n  \"getopts\",\n  \"lazy_static 1.3.0\",\n  \"libc\",\n@@ -753,9 +753,9 @@ checksum = \"d2a368589465391e127e10c9e3a08efc8df66fd49b87dc8524c764bbe7f2ef82\"\n dependencies = [\n  \"fnv\",\n  \"ident_case\",\n- \"proc-macro2\",\n- \"quote\",\n- \"syn\",\n+ \"proc-macro2 0.4.30\",\n+ \"quote 0.6.12\",\n+ \"syn 0.15.35\",\n ]\n \n [[package]]\n@@ -765,8 +765,8 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"244e8987bd4e174385240cde20a3657f607fb0797563c28255c353b5819a07b1\"\n dependencies = [\n  \"darling_core\",\n- \"quote\",\n- \"syn\",\n+ \"quote 0.6.12\",\n+ \"syn 0.15.35\",\n ]\n \n [[package]]\n@@ -781,9 +781,9 @@ version = \"0.5.6\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"6ca414e896ae072546f4d789f452daaecf60ddee4c9df5dc6d5936d769e3d87c\"\n dependencies = [\n- \"proc-macro2\",\n- \"quote\",\n- \"syn\",\n+ \"proc-macro2 0.4.30\",\n+ \"quote 0.6.12\",\n+ \"syn 0.15.35\",\n ]\n \n [[package]]\n@@ -792,10 +792,10 @@ version = \"0.13.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"3f57d78cf3bd45270dad4e70c21ec77a960b36c7a841ff9db76aaa775a8fb871\"\n dependencies = [\n- \"proc-macro2\",\n- \"quote\",\n+ \"proc-macro2 0.4.30\",\n+ \"quote 0.6.12\",\n  \"rustc_version\",\n- \"syn\",\n+ \"syn 0.15.35\",\n ]\n \n [[package]]\n@@ -909,21 +909,9 @@ dependencies = [\n \n [[package]]\n name = \"env_logger\"\n-version = \"0.5.13\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"15b0a4d2e39f8420210be8b27eeda28029729e2fd4291019455016c348240c38\"\n-dependencies = [\n- \"atty\",\n- \"humantime\",\n- \"log\",\n- \"termcolor\",\n-]\n-\n-[[package]]\n-name = \"env_logger\"\n-version = \"0.6.0\"\n+version = \"0.6.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"afb070faf94c85d17d50ca44f6ad076bce18ae92f0037d350947240a36e9d42e\"\n+checksum = \"aafcde04e90a5226a6443b7aabdb016ba2f8307c847d524724bd9b346dd1a2d3\"\n dependencies = [\n  \"atty\",\n  \"humantime\",\n@@ -946,6 +934,7 @@ name = \"error_index_generator\"\n version = \"0.0.0\"\n dependencies = [\n  \"rustdoc\",\n+ \"walkdir\",\n ]\n \n [[package]]\n@@ -964,9 +953,9 @@ version = \"0.1.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"ea1063915fd7ef4309e222a5a07cf9c319fb9c7836b1f89b85458672dbb127e1\"\n dependencies = [\n- \"proc-macro2\",\n- \"quote\",\n- \"syn\",\n+ \"proc-macro2 0.4.30\",\n+ \"quote 0.6.12\",\n+ \"syn 0.15.35\",\n  \"synstructure\",\n ]\n \n@@ -1010,6 +999,7 @@ dependencies = [\n name = \"fmt_macros\"\n version = \"0.0.0\"\n dependencies = [\n+ \"rustc_lexer\",\n  \"syntax_pos\",\n ]\n \n@@ -1138,28 +1128,31 @@ dependencies = [\n \n [[package]]\n name = \"getopts\"\n-version = \"0.2.19\"\n+version = \"0.2.21\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"72327b15c228bfe31f1390f93dd5e9279587f0463836393c9df719ce62a3e450\"\n+checksum = \"14dbbfd5c71d70241ecf9e6f13737f7b5ce823821063188d7e46c41d371eebd5\"\n dependencies = [\n+ \"rustc-std-workspace-core\",\n+ \"rustc-std-workspace-std\",\n  \"unicode-width\",\n ]\n \n [[package]]\n name = \"getrandom\"\n-version = \"0.1.8\"\n+version = \"0.1.12\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"34f33de6f0ae7c9cb5e574502a562e2b512799e32abb801cd1e79ad952b62b49\"\n+checksum = \"473a1265acc8ff1e808cd0a1af8cee3c2ee5200916058a2ca113c29f2d903571\"\n dependencies = [\n  \"cfg-if\",\n  \"libc\",\n+ \"wasi\",\n ]\n \n [[package]]\n name = \"git2\"\n-version = \"0.9.2\"\n+version = \"0.10.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"8cb400360e8a4d61b10e648285bbfa919bbf9519d0d5d5720354456f44349226\"\n+checksum = \"327d698f86a7ebdfeb86a4238ccdb004828939d3a3555b6ead679541d14e36c0\"\n dependencies = [\n  \"bitflags\",\n  \"libc\",\n@@ -1172,9 +1165,9 @@ dependencies = [\n \n [[package]]\n name = \"git2-curl\"\n-version = \"0.10.1\"\n+version = \"0.11.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"2293de73491c3dc4174c5949ef53d2cc037b27613f88d72032e3f5237247a7dd\"\n+checksum = \"cd6527e480187ce19aaf4fa6acfb7657b25628ce31cb8ffabdfca3bf731524c5\"\n dependencies = [\n  \"curl\",\n  \"git2\",\n@@ -1269,19 +1262,9 @@ checksum = \"805026a5d0141ffc30abb3be3173848ad46a1b1664fe632428479619a3644d77\"\n \n [[package]]\n name = \"home\"\n-version = \"0.3.3\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"80dff82fb58cfbbc617fb9a9184b010be0529201553cda50ad04372bc2333aff\"\n-dependencies = [\n- \"scopeguard 0.3.3\",\n- \"winapi 0.3.6\",\n-]\n-\n-[[package]]\n-name = \"home\"\n-version = \"0.4.2\"\n+version = \"0.5.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"013e4e6e9134211bb4d6bf53dd8cfb75d9e2715cc33614b9c0827718c6fbe0b8\"\n+checksum = \"c07c315e106bd6f83f026a20ddaeef2706782e490db1dcdd37caad38a0e895b3\"\n dependencies = [\n  \"scopeguard 1.0.0\",\n  \"winapi 0.3.6\",\n@@ -1296,9 +1279,9 @@ dependencies = [\n  \"log\",\n  \"mac\",\n  \"markup5ever\",\n- \"proc-macro2\",\n- \"quote\",\n- \"syn\",\n+ \"proc-macro2 0.4.30\",\n+ \"quote 0.6.12\",\n+ \"syn 0.15.35\",\n ]\n \n [[package]]\n@@ -1536,11 +1519,30 @@ version = \"0.11.13\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"9ad0485404155f45cce53a40d4b2d6ac356418300daed05273d9e26f91c390be\"\n \n+[[package]]\n+name = \"jsonrpc-client-transports\"\n+version = \"13.1.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"39577db48b004cffb4c5b8e5c9b993c177c52599ecbee88711e815acf65144db\"\n+dependencies = [\n+ \"failure\",\n+ \"futures\",\n+ \"jsonrpc-core\",\n+ \"jsonrpc-pubsub\",\n+ \"jsonrpc-server-utils\",\n+ \"log\",\n+ \"parity-tokio-ipc\",\n+ \"serde\",\n+ \"serde_json\",\n+ \"tokio\",\n+ \"url 1.7.2\",\n+]\n+\n [[package]]\n name = \"jsonrpc-core\"\n-version = \"12.0.0\"\n+version = \"13.1.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"288dca7f9713710a29e485076b9340156cb701edb46a881f5d0c31aa4f5b9143\"\n+checksum = \"dd42951eb35079520ee29b7efbac654d85821b397ef88c8151600ef7e2d00217\"\n dependencies = [\n  \"futures\",\n  \"log\",\n@@ -1549,6 +1551,70 @@ dependencies = [\n  \"serde_json\",\n ]\n \n+[[package]]\n+name = \"jsonrpc-core-client\"\n+version = \"13.1.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"f047c10738edee7c3c6acf5241a0ce33df32ef9230c1a7fb03e4a77ee72c992f\"\n+dependencies = [\n+ \"jsonrpc-client-transports\",\n+]\n+\n+[[package]]\n+name = \"jsonrpc-derive\"\n+version = \"13.1.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"29f9149f785deaae92a4c834a9a1a83a4313b8cfedccf15362cd4cf039a64501\"\n+dependencies = [\n+ \"proc-macro-crate\",\n+ \"proc-macro2 0.4.30\",\n+ \"quote 0.6.12\",\n+ \"syn 0.15.35\",\n+]\n+\n+[[package]]\n+name = \"jsonrpc-ipc-server\"\n+version = \"13.1.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"256c5e4292c17b4c2ecdf542299dc8e9d6b3939c075c54825570ad9317fe5751\"\n+dependencies = [\n+ \"jsonrpc-core\",\n+ \"jsonrpc-server-utils\",\n+ \"log\",\n+ \"parity-tokio-ipc\",\n+ \"parking_lot 0.9.0\",\n+ \"tokio-service\",\n+]\n+\n+[[package]]\n+name = \"jsonrpc-pubsub\"\n+version = \"13.1.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"e2c08b444cc0ed70263798834343d0ac875e664257df8079160f23ac1ea79446\"\n+dependencies = [\n+ \"jsonrpc-core\",\n+ \"log\",\n+ \"parking_lot 0.9.0\",\n+ \"serde\",\n+]\n+\n+[[package]]\n+name = \"jsonrpc-server-utils\"\n+version = \"13.1.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"44561bfdd31401bad790527f1e951dde144f2341ddc3e1b859d32945e1a34eff\"\n+dependencies = [\n+ \"bytes\",\n+ \"globset\",\n+ \"jsonrpc-core\",\n+ \"lazy_static 1.3.0\",\n+ \"log\",\n+ \"num_cpus\",\n+ \"tokio\",\n+ \"tokio-codec\",\n+ \"unicase 2.4.0\",\n+]\n+\n [[package]]\n name = \"kernel32-sys\"\n version = \"0.2.2\"\n@@ -1579,9 +1645,9 @@ checksum = \"b294d6fa9ee409a054354afc4352b0b9ef7ca222c69b8812cbea9e7d2bf3783f\"\n \n [[package]]\n name = \"libc\"\n-version = \"0.2.60\"\n+version = \"0.2.62\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"d44e80633f007889c7eff624b709ab43c92d708caad982295768a7b13ca3b5eb\"\n+checksum = \"34fcd2c08d2f832f376f4173a231990fa5aef4e99fb569867318a227ef4c06ba\"\n dependencies = [\n  \"rustc-std-workspace-core\",\n ]\n@@ -1601,9 +1667,9 @@ dependencies = [\n \n [[package]]\n name = \"libgit2-sys\"\n-version = \"0.8.2\"\n+version = \"0.9.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"4c179ed6d19cd3a051e68c177fbbc214e79ac4724fac3a850ec9f3d3eb8a5578\"\n+checksum = \"8c2078aec6f4b16d1b89f6a72e4f6eb1e75ffa85312023291e89c6d3087bc8fb\"\n dependencies = [\n  \"cc\",\n  \"libc\",\n@@ -1663,11 +1729,20 @@ dependencies = [\n  \"scopeguard 0.3.3\",\n ]\n \n+[[package]]\n+name = \"lock_api\"\n+version = \"0.3.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"f8912e782533a93a167888781b836336a6ca5da6175c05944c86cf28c31104dc\"\n+dependencies = [\n+ \"scopeguard 1.0.0\",\n+]\n+\n [[package]]\n name = \"log\"\n-version = \"0.4.6\"\n+version = \"0.4.8\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"c84ec4b527950aa83a329754b01dbe3f58361d1c5efacd1f6d68c494d08a17c6\"\n+checksum = \"14b6052be84e6b71ab17edffc2eeabf5c2c3ae1fdb464aae35ac50c67a44e1f7\"\n dependencies = [\n  \"cfg-if\",\n ]\n@@ -1694,18 +1769,15 @@ dependencies = [\n \n [[package]]\n name = \"lsp-types\"\n-version = \"0.57.2\"\n+version = \"0.60.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"b62b77309737b1e262b3bbf37ff8faa740562c633b14702afe9be85dbcb6f88a\"\n+checksum = \"fe3edefcd66dde1f7f1df706f46520a3c93adc5ca4bc5747da6621195e894efd\"\n dependencies = [\n  \"bitflags\",\n- \"num-derive\",\n- \"num-traits\",\n  \"serde\",\n- \"serde_derive\",\n  \"serde_json\",\n- \"url 1.7.2\",\n- \"url_serde\",\n+ \"serde_repr\",\n+ \"url 2.1.0\",\n ]\n \n [[package]]\n@@ -1770,7 +1842,7 @@ dependencies = [\n  \"chrono\",\n  \"clap\",\n  \"elasticlunr-rs\",\n- \"env_logger 0.6.0\",\n+ \"env_logger\",\n  \"error-chain\",\n  \"handlebars\",\n  \"itertools 0.8.0\",\n@@ -1785,7 +1857,7 @@ dependencies = [\n  \"serde_json\",\n  \"shlex\",\n  \"tempfile\",\n- \"toml 0.5.3\",\n+ \"toml\",\n  \"toml-query\",\n ]\n \n@@ -1795,7 +1867,7 @@ version = \"0.3.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"77d1f0ba4d1e6b86fa18e8853d026d7d76a97eb7eb5eb052ed80901e43b7fc10\"\n dependencies = [\n- \"env_logger 0.6.0\",\n+ \"env_logger\",\n  \"failure\",\n  \"log\",\n  \"mdbook\",\n@@ -1808,7 +1880,7 @@ dependencies = [\n  \"serde\",\n  \"serde_derive\",\n  \"serde_json\",\n- \"structopt\",\n+ \"structopt 0.2.18\",\n  \"url 1.7.2\",\n ]\n \n@@ -1988,7 +2060,8 @@ dependencies = [\n  \"colored\",\n  \"compiletest_rs\",\n  \"directories\",\n- \"env_logger 0.6.0\",\n+ \"env_logger\",\n+ \"getrandom\",\n  \"hex\",\n  \"log\",\n  \"num-traits\",\n@@ -2040,18 +2113,6 @@ version = \"0.1.12\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"9a2228dca57108069a5262f2ed8bd2e82496d2e074a06d1ccc7ce1687b6ae0a2\"\n \n-[[package]]\n-name = \"num-derive\"\n-version = \"0.2.3\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"8af1847c907c2f04d7bfd572fb25bbb4385c637fe5be163cf2f8c5d778fe1e7d\"\n-dependencies = [\n- \"num-traits\",\n- \"proc-macro2\",\n- \"quote\",\n- \"syn\",\n-]\n-\n [[package]]\n name = \"num-integer\"\n version = \"0.1.39\"\n@@ -2185,14 +2246,43 @@ dependencies = [\n  \"unwind\",\n ]\n \n+[[package]]\n+name = \"parity-tokio-ipc\"\n+version = \"0.2.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"8281bf4f1d6429573f89589bf68d89451c46750977a8264f8ea3edbabeba7947\"\n+dependencies = [\n+ \"bytes\",\n+ \"futures\",\n+ \"log\",\n+ \"mio-named-pipes\",\n+ \"miow 0.3.3\",\n+ \"rand 0.7.0\",\n+ \"tokio\",\n+ \"tokio-named-pipes\",\n+ \"tokio-uds\",\n+ \"winapi 0.3.6\",\n+]\n+\n [[package]]\n name = \"parking_lot\"\n version = \"0.7.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"ab41b4aed082705d1056416ae4468b6ea99d52599ecf3169b00088d43113e337\"\n dependencies = [\n- \"lock_api\",\n- \"parking_lot_core\",\n+ \"lock_api 0.1.3\",\n+ \"parking_lot_core 0.4.0\",\n+]\n+\n+[[package]]\n+name = \"parking_lot\"\n+version = \"0.9.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"f842b1982eb6c2fe34036a4fbfb06dd185a3f5c8edfaacdf7d1ea10b07de6252\"\n+dependencies = [\n+ \"lock_api 0.3.1\",\n+ \"parking_lot_core 0.6.2\",\n+ \"rustc_version\",\n ]\n \n [[package]]\n@@ -2208,6 +2298,21 @@ dependencies = [\n  \"winapi 0.3.6\",\n ]\n \n+[[package]]\n+name = \"parking_lot_core\"\n+version = \"0.6.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"b876b1b9e7ac6e1a74a6da34d25c42e17e8862aa409cbbbdcfc8d86c6f3bc62b\"\n+dependencies = [\n+ \"cfg-if\",\n+ \"cloudabi\",\n+ \"libc\",\n+ \"redox_syscall\",\n+ \"rustc_version\",\n+ \"smallvec\",\n+ \"winapi 0.3.6\",\n+]\n+\n [[package]]\n name = \"percent-encoding\"\n version = \"1.0.1\"\n@@ -2247,9 +2352,9 @@ checksum = \"63120576c4efd69615b5537d3d052257328a4ca82876771d6944424ccfd9f646\"\n dependencies = [\n  \"pest\",\n  \"pest_meta\",\n- \"proc-macro2\",\n- \"quote\",\n- \"syn\",\n+ \"proc-macro2 0.4.30\",\n+ \"quote 0.6.12\",\n+ \"syn 0.15.35\",\n ]\n \n [[package]]\n@@ -2320,9 +2425,9 @@ checksum = \"676e8eb2b1b4c9043511a9b7bea0915320d7e502b0a079fb03f9635a5252b18c\"\n \n [[package]]\n name = \"polonius-engine\"\n-version = \"0.9.0\"\n+version = \"0.10.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"f6b8a5defa2aef9ba4999aaa745fbc01c622ecea35964a306adc3e44be4f3b5b\"\n+checksum = \"50fa9dbfd0d3d60594da338cfe6f94028433eecae4b11b7e83fd99759227bbfe\"\n dependencies = [\n  \"datafrog\",\n  \"log\",\n@@ -2358,22 +2463,54 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"df8b3f4e0475def7d9c2e5de8e5a1306949849761e107b360d03e98eafaffd61\"\n dependencies = [\n  \"chrono\",\n- \"env_logger 0.6.0\",\n+ \"env_logger\",\n  \"log\",\n ]\n \n+[[package]]\n+name = \"proc-macro-crate\"\n+version = \"0.1.4\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"e10d4b51f154c8a7fb96fd6dad097cb74b863943ec010ac94b9fd1be8861fe1e\"\n+dependencies = [\n+ \"toml\",\n+]\n+\n+[[package]]\n+name = \"proc-macro-error\"\n+version = \"0.2.6\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"aeccfe4d5d8ea175d5f0e4a2ad0637e0f4121d63bd99d356fb1f39ab2e7c6097\"\n+dependencies = [\n+ \"proc-macro2 1.0.3\",\n+ \"quote 1.0.2\",\n+ \"syn 1.0.5\",\n+]\n+\n [[package]]\n name = \"proc-macro2\"\n version = \"0.4.30\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"cf3d2011ab5c909338f7887f4fc896d35932e29146c12c8d01da6b22a80ba759\"\n dependencies = [\n- \"unicode-xid\",\n+ \"unicode-xid 0.1.0\",\n+]\n+\n+[[package]]\n+name = \"proc-macro2\"\n+version = \"1.0.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"e98a83a9f9b331f54b924e68a66acb1bb35cb01fb0a23645139967abefb697e8\"\n+dependencies = [\n+ \"unicode-xid 0.2.0\",\n ]\n \n [[package]]\n name = \"proc_macro\"\n version = \"0.0.0\"\n+dependencies = [\n+ \"std\",\n+]\n \n [[package]]\n name = \"profiler_builtins\"\n@@ -2420,19 +2557,28 @@ version = \"0.6.12\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"faf4799c5d274f3868a4aae320a0a182cbd2baee377b378f080e16a23e9d80db\"\n dependencies = [\n- \"proc-macro2\",\n+ \"proc-macro2 0.4.30\",\n+]\n+\n+[[package]]\n+name = \"quote\"\n+version = \"1.0.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"053a8c8bcc71fcce321828dc897a98ab9760bef03a4fc36693c231e5b3216cfe\"\n+dependencies = [\n+ \"proc-macro2 1.0.3\",\n ]\n \n [[package]]\n name = \"racer\"\n-version = \"2.1.25\"\n+version = \"2.1.27\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"0727b9d7baaf9e42851145545d7b980b5c1752bd16a4c77c925c5e573d0069d9\"\n+checksum = \"dde22b84ab75220015cbd91240222402bf885cbe3a5dc856475771abb82533ae\"\n dependencies = [\n  \"bitflags\",\n  \"clap\",\n  \"derive_more\",\n- \"env_logger 0.6.0\",\n+ \"env_logger\",\n  \"humantime\",\n  \"lazy_static 1.3.0\",\n  \"log\",\n@@ -2719,18 +2865,18 @@ checksum = \"cabe4fa914dec5870285fa7f71f602645da47c486e68486d2b4ceb4a343e90ac\"\n \n [[package]]\n name = \"rls\"\n-version = \"1.38.0\"\n+version = \"1.39.0\"\n dependencies = [\n  \"cargo\",\n  \"cargo_metadata\",\n  \"clippy_lints\",\n  \"crossbeam-channel\",\n  \"difference\",\n- \"env_logger 0.6.0\",\n+ \"env_logger\",\n  \"failure\",\n  \"futures\",\n  \"heck\",\n- \"home 0.3.3\",\n+ \"home\",\n  \"itertools 0.8.0\",\n  \"jsonrpc-core\",\n  \"lazy_static 1.3.0\",\n@@ -2745,6 +2891,7 @@ dependencies = [\n  \"regex\",\n  \"rls-analysis\",\n  \"rls-data\",\n+ \"rls-ipc\",\n  \"rls-rustc\",\n  \"rls-span\",\n  \"rls-vfs\",\n@@ -2754,14 +2901,14 @@ dependencies = [\n  \"rustfmt-nightly\",\n  \"serde\",\n  \"serde_derive\",\n- \"serde_ignored 0.0.4\",\n+ \"serde_ignored\",\n  \"serde_json\",\n  \"tempfile\",\n  \"tokio\",\n  \"tokio-process\",\n  \"tokio-timer\",\n- \"toml 0.5.3\",\n- \"url 1.7.2\",\n+ \"toml\",\n+ \"url 2.1.0\",\n  \"walkdir\",\n ]\n \n@@ -2792,9 +2939,33 @@ dependencies = [\n  \"serde\",\n ]\n \n+[[package]]\n+name = \"rls-ipc\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"jsonrpc-core\",\n+ \"jsonrpc-core-client\",\n+ \"jsonrpc-derive\",\n+ \"jsonrpc-ipc-server\",\n+ \"rls-data\",\n+ \"serde\",\n+]\n+\n [[package]]\n name = \"rls-rustc\"\n version = \"0.6.0\"\n+dependencies = [\n+ \"clippy_lints\",\n+ \"env_logger\",\n+ \"failure\",\n+ \"futures\",\n+ \"log\",\n+ \"rand 0.6.1\",\n+ \"rls-data\",\n+ \"rls-ipc\",\n+ \"serde\",\n+ \"tokio\",\n+]\n \n [[package]]\n name = \"rls-span\"\n@@ -2841,7 +3012,7 @@ dependencies = [\n  \"log\",\n  \"measureme\",\n  \"num_cpus\",\n- \"parking_lot\",\n+ \"parking_lot 0.7.1\",\n  \"polonius-engine\",\n  \"rustc-rayon\",\n  \"rustc-rayon-core\",\n@@ -2860,25 +3031,25 @@ dependencies = [\n \n [[package]]\n name = \"rustc-ap-arena\"\n-version = \"546.0.0\"\n+version = \"583.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"4dc2e1e68b64268c543bfa6e63e3c0d9ea58074c71396f42f76931f35a9287f9\"\n+checksum = \"f59b76d334bd533f3fdc5c651c27678c5e80fac67c6f7da22ba21a58878c55f5\"\n dependencies = [\n  \"rustc-ap-rustc_data_structures\",\n  \"smallvec\",\n ]\n \n [[package]]\n name = \"rustc-ap-graphviz\"\n-version = \"546.0.0\"\n+version = \"583.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"c108d647ce0dd46477b048eafff5a6273b5652e02d47424b0cd684147379c811\"\n+checksum = \"3e632ef08ca17458acfd46d2ead3d541a1c249586cd5329f5fe333dacfab6142\"\n \n [[package]]\n name = \"rustc-ap-rustc_data_structures\"\n-version = \"546.0.0\"\n+version = \"583.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"656771744e0783cb8e4481e3b8b1f975687610aaf18833b898018111a0e0e582\"\n+checksum = \"e89e2c7be68185418f3cd56af3df8b29007a59a1cebefa63612d055f9bcb1a36\"\n dependencies = [\n  \"cfg-if\",\n  \"crossbeam-utils 0.6.5\",\n@@ -2887,7 +3058,7 @@ dependencies = [\n  \"jobserver\",\n  \"lazy_static 1.3.0\",\n  \"log\",\n- \"parking_lot\",\n+ \"parking_lot 0.7.1\",\n  \"rustc-ap-graphviz\",\n  \"rustc-ap-serialize\",\n  \"rustc-hash\",\n@@ -2899,44 +3070,48 @@ dependencies = [\n \n [[package]]\n name = \"rustc-ap-rustc_errors\"\n-version = \"546.0.0\"\n+version = \"583.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"e37064f6624bc799bfaa2968b61ee6880926dea2a8bba69f18aef6c8e69c9604\"\n+checksum = \"1e47cb380abeb72b01e42b2342d592f7eeea7d536c2f1f0d0e550dc509e46333\"\n dependencies = [\n  \"annotate-snippets\",\n  \"atty\",\n  \"log\",\n  \"rustc-ap-rustc_data_structures\",\n  \"rustc-ap-serialize\",\n  \"rustc-ap-syntax_pos\",\n+ \"term_size\",\n  \"termcolor\",\n  \"unicode-width\",\n ]\n \n [[package]]\n name = \"rustc-ap-rustc_lexer\"\n-version = \"546.0.0\"\n+version = \"583.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"ef5bc0a971823637ea23a857f0ef1467f44b1e05d71968821f83a0abe53e0fe3\"\n+checksum = \"494cfaf67f49217d67d0774eeecbba61ac89acf478db97ef11f113ed8a959305\"\n+dependencies = [\n+ \"unicode-xid 0.2.0\",\n+]\n \n [[package]]\n name = \"rustc-ap-rustc_macros\"\n-version = \"546.0.0\"\n+version = \"583.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"b90037e3336fe8835f468db44d0848ae10d9cc8533ae89b55828883f905b7e80\"\n+checksum = \"e2e5d36becc59b4497f9cbd3ae0610081de0207a1d0e95c066369167b14f486f\"\n dependencies = [\n  \"itertools 0.8.0\",\n- \"proc-macro2\",\n- \"quote\",\n- \"syn\",\n+ \"proc-macro2 0.4.30\",\n+ \"quote 0.6.12\",\n+ \"syn 0.15.35\",\n  \"synstructure\",\n ]\n \n [[package]]\n name = \"rustc-ap-rustc_target\"\n-version = \"546.0.0\"\n+version = \"583.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"cadf9ca07315eab3a7a21f63872f9cc81e250fd6ede0419c24f8926ade73a45d\"\n+checksum = \"a7bfc5f96dfc3b9f8d5b57884f7f37467ecff6776cd4b8b491a7daece6fdd7c2\"\n dependencies = [\n  \"bitflags\",\n  \"log\",\n@@ -2947,19 +3122,19 @@ dependencies = [\n \n [[package]]\n name = \"rustc-ap-serialize\"\n-version = \"546.0.0\"\n+version = \"583.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"61673783f2089e01033ffa82d1988f55175402071b31253a358292e1624d4602\"\n+checksum = \"2bb9ee231cf79eded39c56647499f83d6136ff5c8c0baaa9e21b6febee00f4f6\"\n dependencies = [\n  \"indexmap\",\n  \"smallvec\",\n ]\n \n [[package]]\n name = \"rustc-ap-syntax\"\n-version = \"546.0.0\"\n+version = \"583.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"28f3dd1346d5b0269c07a4a78855e309a298ab569c9c1302d4d4f57f8eee4e84\"\n+checksum = \"b3827fc208814efbde82d613e31d11b4250ce9e8cf8afe4a4d47bbbd099632c9\"\n dependencies = [\n  \"bitflags\",\n  \"lazy_static 1.3.0\",\n@@ -2977,9 +3152,9 @@ dependencies = [\n \n [[package]]\n name = \"rustc-ap-syntax_pos\"\n-version = \"546.0.0\"\n+version = \"583.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"45e67b526dbda3a0c7dab91c8947d43685e7697f52686a4949da3c179cd7c979\"\n+checksum = \"930ed81c34f325e512cc315c04d676fa84a373879d5c43bb54054a0522b05213\"\n dependencies = [\n  \"cfg-if\",\n  \"rustc-ap-arena\",\n@@ -3050,31 +3225,38 @@ checksum = \"dcf128d1287d2ea9d80910b5f1120d0b8eede3fbf1abe91c40d39ea7d51e6fda\"\n \n [[package]]\n name = \"rustc-std-workspace-alloc\"\n-version = \"1.0.0\"\n+version = \"1.99.0\"\n dependencies = [\n  \"alloc\",\n ]\n \n [[package]]\n name = \"rustc-std-workspace-core\"\n-version = \"1.0.0\"\n+version = \"1.99.0\"\n dependencies = [\n  \"core\",\n ]\n \n+[[package]]\n+name = \"rustc-std-workspace-std\"\n+version = \"1.99.0\"\n+dependencies = [\n+ \"std\",\n+]\n+\n [[package]]\n name = \"rustc-workspace-hack\"\n version = \"1.0.0\"\n dependencies = [\n  \"byteorder\",\n  \"crossbeam-utils 0.6.5\",\n- \"parking_lot\",\n+ \"parking_lot 0.7.1\",\n  \"rand 0.6.1\",\n  \"scopeguard 0.3.3\",\n  \"serde\",\n  \"serde_json\",\n  \"smallvec\",\n- \"syn\",\n+ \"syn 0.15.35\",\n  \"winapi 0.3.6\",\n ]\n \n@@ -3114,11 +3296,7 @@ dependencies = [\n name = \"rustc_codegen_llvm\"\n version = \"0.0.0\"\n dependencies = [\n- \"cc\",\n- \"memmap\",\n- \"num_cpus\",\n  \"rustc_llvm\",\n- \"tempfile\",\n ]\n \n [[package]]\n@@ -3132,7 +3310,7 @@ dependencies = [\n  \"log\",\n  \"memmap\",\n  \"num_cpus\",\n- \"parking_lot\",\n+ \"parking_lot 0.7.1\",\n  \"rustc\",\n  \"rustc_apfloat\",\n  \"rustc_codegen_utils\",\n@@ -3175,7 +3353,7 @@ dependencies = [\n  \"jobserver\",\n  \"lazy_static 1.3.0\",\n  \"log\",\n- \"parking_lot\",\n+ \"parking_lot 0.7.1\",\n  \"rustc-hash\",\n  \"rustc-rayon\",\n  \"rustc-rayon-core\",\n@@ -3188,7 +3366,7 @@ dependencies = [\n name = \"rustc_driver\"\n version = \"0.0.0\"\n dependencies = [\n- \"env_logger 0.5.13\",\n+ \"env_logger\",\n  \"graphviz\",\n  \"log\",\n  \"rustc\",\n@@ -3218,6 +3396,7 @@ dependencies = [\n  \"rustc_data_structures\",\n  \"serialize\",\n  \"syntax_pos\",\n+ \"term_size\",\n  \"termcolor\",\n  \"unicode-width\",\n ]\n@@ -3232,7 +3411,7 @@ version = \"0.0.0\"\n dependencies = [\n  \"graphviz\",\n  \"log\",\n- \"rand 0.6.1\",\n+ \"rand 0.7.0\",\n  \"rustc\",\n  \"rustc_data_structures\",\n  \"rustc_fs_util\",\n@@ -3275,7 +3454,7 @@ dependencies = [\n name = \"rustc_lexer\"\n version = \"0.1.0\"\n dependencies = [\n- \"unicode-xid\",\n+ \"unicode-xid 0.2.0\",\n ]\n \n [[package]]\n@@ -3314,9 +3493,9 @@ name = \"rustc_macros\"\n version = \"0.1.0\"\n dependencies = [\n  \"itertools 0.8.0\",\n- \"proc-macro2\",\n- \"quote\",\n- \"syn\",\n+ \"proc-macro2 0.4.30\",\n+ \"quote 0.6.12\",\n+ \"syn 0.15.35\",\n  \"synstructure\",\n ]\n \n@@ -3353,6 +3532,7 @@ dependencies = [\n  \"rustc_apfloat\",\n  \"rustc_data_structures\",\n  \"rustc_errors\",\n+ \"rustc_lexer\",\n  \"rustc_target\",\n  \"serialize\",\n  \"smallvec\",\n@@ -3554,26 +3734,25 @@ dependencies = [\n \n [[package]]\n name = \"rustfmt-config_proc_macro\"\n-version = \"0.1.2\"\n+version = \"0.2.0\"\n dependencies = [\n- \"proc-macro2\",\n- \"quote\",\n+ \"proc-macro2 1.0.3\",\n+ \"quote 1.0.2\",\n  \"serde\",\n- \"syn\",\n+ \"syn 1.0.5\",\n ]\n \n [[package]]\n name = \"rustfmt-nightly\"\n-version = \"1.4.4\"\n+version = \"1.4.8\"\n dependencies = [\n  \"annotate-snippets\",\n- \"atty\",\n  \"bytecount\",\n  \"cargo_metadata\",\n  \"derive-new\",\n  \"diff\",\n  \"dirs\",\n- \"env_logger 0.6.0\",\n+ \"env_logger\",\n  \"failure\",\n  \"getopts\",\n  \"ignore\",\n@@ -3588,9 +3767,9 @@ dependencies = [\n  \"rustfmt-config_proc_macro\",\n  \"serde\",\n  \"serde_json\",\n- \"structopt\",\n+ \"structopt 0.3.1\",\n  \"term 0.6.0\",\n- \"toml 0.5.3\",\n+ \"toml\",\n  \"unicode-segmentation\",\n  \"unicode-width\",\n  \"unicode_categories\",\n@@ -3697,18 +3876,9 @@ version = \"1.0.81\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"477b13b646f5b5b56fc95bedfc3b550d12141ce84f466f6c44b9a17589923885\"\n dependencies = [\n- \"proc-macro2\",\n- \"quote\",\n- \"syn\",\n-]\n-\n-[[package]]\n-name = \"serde_ignored\"\n-version = \"0.0.4\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"190e9765dcedb56be63b6e0993a006c7e3b071a016a304736e4a315dc01fb142\"\n-dependencies = [\n- \"serde\",\n+ \"proc-macro2 0.4.30\",\n+ \"quote 0.6.12\",\n+ \"syn 0.15.35\",\n ]\n \n [[package]]\n@@ -3731,6 +3901,17 @@ dependencies = [\n  \"serde\",\n ]\n \n+[[package]]\n+name = \"serde_repr\"\n+version = \"0.1.5\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"cd02c7587ec314570041b2754829f84d873ced14a96d1fd1823531e11db40573\"\n+dependencies = [\n+ \"proc-macro2 1.0.3\",\n+ \"quote 1.0.2\",\n+ \"syn 1.0.5\",\n+]\n+\n [[package]]\n name = \"serde_urlencoded\"\n version = \"0.5.5\"\n@@ -3847,12 +4028,13 @@ dependencies = [\n  \"panic_abort\",\n  \"panic_unwind\",\n  \"profiler_builtins\",\n- \"rand 0.6.1\",\n+ \"rand 0.7.0\",\n  \"rustc_asan\",\n  \"rustc_lsan\",\n  \"rustc_msan\",\n  \"rustc_tsan\",\n  \"unwind\",\n+ \"wasi\",\n ]\n \n [[package]]\n@@ -3887,8 +4069,8 @@ checksum = \"1eea1eee654ef80933142157fdad9dd8bc43cf7c74e999e369263496f04ff4da\"\n dependencies = [\n  \"phf_generator\",\n  \"phf_shared\",\n- \"proc-macro2\",\n- \"quote\",\n+ \"proc-macro2 0.4.30\",\n+ \"quote 0.6.12\",\n  \"string_cache_shared\",\n ]\n \n@@ -3909,9 +4091,9 @@ dependencies = [\n \n [[package]]\n name = \"strsim\"\n-version = \"0.7.0\"\n+version = \"0.8.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"bb4f380125926a99e52bc279241539c018323fab05ad6368b56f93d9369ff550\"\n+checksum = \"8ea5119cdb4c55b55d432abb513a0429384878c15dde60cc77b1c99de1a95a6a\"\n \n [[package]]\n name = \"structopt\"\n@@ -3920,7 +4102,17 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"16c2cdbf9cc375f15d1b4141bc48aeef444806655cd0e904207edc8d68d86ed7\"\n dependencies = [\n  \"clap\",\n- \"structopt-derive\",\n+ \"structopt-derive 0.2.18\",\n+]\n+\n+[[package]]\n+name = \"structopt\"\n+version = \"0.3.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"2ac9d6e93dd792b217bf89cda5c14566e3043960c6f9da890c2ba5d09d07804c\"\n+dependencies = [\n+ \"clap\",\n+ \"structopt-derive 0.3.1\",\n ]\n \n [[package]]\n@@ -3930,9 +4122,22 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"53010261a84b37689f9ed7d395165029f9cc7abb9f56bbfe86bee2597ed25107\"\n dependencies = [\n  \"heck\",\n- \"proc-macro2\",\n- \"quote\",\n- \"syn\",\n+ \"proc-macro2 0.4.30\",\n+ \"quote 0.6.12\",\n+ \"syn 0.15.35\",\n+]\n+\n+[[package]]\n+name = \"structopt-derive\"\n+version = \"0.3.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"2ae9e5165d463a0dea76967d021f8d0f9316057bf5163aa2a4843790e842ff37\"\n+dependencies = [\n+ \"heck\",\n+ \"proc-macro-error\",\n+ \"proc-macro2 1.0.3\",\n+ \"quote 1.0.2\",\n+ \"syn 1.0.5\",\n ]\n \n [[package]]\n@@ -3948,9 +4153,9 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"8baacebd7b7c9b864d83a6ba7a246232983e277b86fa5cdec77f565715a4b136\"\n dependencies = [\n  \"heck\",\n- \"proc-macro2\",\n- \"quote\",\n- \"syn\",\n+ \"proc-macro2 0.4.30\",\n+ \"quote 0.6.12\",\n+ \"syn 0.15.35\",\n ]\n \n [[package]]\n@@ -3959,9 +4164,20 @@ version = \"0.15.35\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"641e117d55514d6d918490e47102f7e08d096fdde360247e4a10f7a91a8478d3\"\n dependencies = [\n- \"proc-macro2\",\n- \"quote\",\n- \"unicode-xid\",\n+ \"proc-macro2 0.4.30\",\n+ \"quote 0.6.12\",\n+ \"unicode-xid 0.1.0\",\n+]\n+\n+[[package]]\n+name = \"syn\"\n+version = \"1.0.5\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"66850e97125af79138385e9b88339cbcd037e3f28ceab8c5ad98e64f0f1f80bf\"\n+dependencies = [\n+ \"proc-macro2 1.0.3\",\n+ \"quote 1.0.2\",\n+ \"unicode-xid 0.2.0\",\n ]\n \n [[package]]\n@@ -3970,10 +4186,10 @@ version = \"0.10.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"02353edf96d6e4dc81aea2d8490a7e9db177bf8acb0e951c24940bf866cb313f\"\n dependencies = [\n- \"proc-macro2\",\n- \"quote\",\n- \"syn\",\n- \"unicode-xid\",\n+ \"proc-macro2 0.4.30\",\n+ \"quote 0.6.12\",\n+ \"syn 0.15.35\",\n+ \"unicode-xid 0.1.0\",\n ]\n \n [[package]]\n@@ -4002,6 +4218,7 @@ dependencies = [\n  \"log\",\n  \"rustc_data_structures\",\n  \"rustc_errors\",\n+ \"rustc_lexer\",\n  \"rustc_target\",\n  \"smallvec\",\n  \"syntax\",\n@@ -4067,6 +4284,10 @@ dependencies = [\n [[package]]\n name = \"term\"\n version = \"0.0.0\"\n+dependencies = [\n+ \"core\",\n+ \"std\",\n+]\n \n [[package]]\n name = \"term\"\n@@ -4089,6 +4310,17 @@ dependencies = [\n  \"winapi 0.3.6\",\n ]\n \n+[[package]]\n+name = \"term_size\"\n+version = \"0.3.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"9e5b9a66db815dcfd2da92db471106457082577c3c278d4138ab3e3b4e189327\"\n+dependencies = [\n+ \"kernel32-sys\",\n+ \"libc\",\n+ \"winapi 0.2.8\",\n+]\n+\n [[package]]\n name = \"termcolor\"\n version = \"1.0.4\"\n@@ -4113,8 +4345,13 @@ dependencies = [\n name = \"test\"\n version = \"0.0.0\"\n dependencies = [\n+ \"core\",\n  \"getopts\",\n+ \"libc\",\n+ \"panic_abort\",\n+ \"panic_unwind\",\n  \"proc_macro\",\n+ \"std\",\n  \"term 0.0.0\",\n ]\n \n@@ -4131,9 +4368,9 @@ dependencies = [\n \n [[package]]\n name = \"textwrap\"\n-version = \"0.10.0\"\n+version = \"0.11.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"307686869c93e71f94da64286f9a9524c0f308a9e1c87a583de8e9c9039ad3f6\"\n+checksum = \"d326610f408c7a4eb6f51c37c330e496b08506c9457c9d34287ecc38809fb060\"\n dependencies = [\n  \"unicode-width\",\n ]\n@@ -4256,6 +4493,19 @@ dependencies = [\n  \"log\",\n ]\n \n+[[package]]\n+name = \"tokio-named-pipes\"\n+version = \"0.1.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"9d282d483052288b2308ba5ee795f5673b159c9bdf63c385a05609da782a5eae\"\n+dependencies = [\n+ \"bytes\",\n+ \"futures\",\n+ \"mio\",\n+ \"mio-named-pipes\",\n+ \"tokio\",\n+]\n+\n [[package]]\n name = \"tokio-process\"\n version = \"0.2.3\"\n@@ -4284,12 +4534,21 @@ dependencies = [\n  \"log\",\n  \"mio\",\n  \"num_cpus\",\n- \"parking_lot\",\n+ \"parking_lot 0.7.1\",\n  \"slab\",\n  \"tokio-executor\",\n  \"tokio-io\",\n ]\n \n+[[package]]\n+name = \"tokio-service\"\n+version = \"0.1.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"24da22d077e0f15f55162bdbdc661228c1581892f52074fb242678d015b45162\"\n+dependencies = [\n+ \"futures\",\n+]\n+\n [[package]]\n name = \"tokio-signal\"\n version = \"0.2.7\"\n@@ -4382,15 +4641,6 @@ dependencies = [\n  \"tokio-reactor\",\n ]\n \n-[[package]]\n-name = \"toml\"\n-version = \"0.4.10\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"758664fc71a3a69038656bee8b6be6477d2a6c315a6b81f7081f591bffa4111f\"\n-dependencies = [\n- \"serde\",\n-]\n-\n [[package]]\n name = \"toml\"\n version = \"0.5.3\"\n@@ -4411,7 +4661,7 @@ dependencies = [\n  \"is-match\",\n  \"lazy_static 1.3.0\",\n  \"regex\",\n- \"toml 0.5.3\",\n+ \"toml\",\n  \"toml-query_derive\",\n ]\n \n@@ -4422,8 +4672,8 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"3c99ca245ec273c7e75c8ee58f47b882d0146f3c2c8495158082c6671e8b5335\"\n dependencies = [\n  \"darling\",\n- \"quote\",\n- \"syn\",\n+ \"quote 0.6.12\",\n+ \"syn 0.15.35\",\n ]\n \n [[package]]\n@@ -4491,16 +4741,27 @@ checksum = \"aa6024fc12ddfd1c6dbc14a80fa2324d4568849869b779f6bd37e5e4c03344d1\"\n \n [[package]]\n name = \"unicode-width\"\n-version = \"0.1.5\"\n+version = \"0.1.6\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"882386231c45df4700b275c7ff55b6f3698780a650026380e72dabe76fa46526\"\n+checksum = \"7007dbd421b92cc6e28410fe7362e2e0a2503394908f417b68ec8d1c364c4e20\"\n+dependencies = [\n+ \"compiler_builtins\",\n+ \"rustc-std-workspace-core\",\n+ \"rustc-std-workspace-std\",\n+]\n \n [[package]]\n name = \"unicode-xid\"\n version = \"0.1.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"fc72304796d0818e357ead4e000d19c9c174ab23dc11093ac919054d20a6a7fc\"\n \n+[[package]]\n+name = \"unicode-xid\"\n+version = \"0.2.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"826e7639553986605ec5979c7dd957c7895e93eabed50ab2ffa7f6128a75097c\"\n+\n [[package]]\n name = \"unicode_categories\"\n version = \"0.1.1\"\n@@ -4549,16 +4810,6 @@ dependencies = [\n  \"serde\",\n ]\n \n-[[package]]\n-name = \"url_serde\"\n-version = \"0.2.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"74e7d099f1ee52f823d4bdd60c93c3602043c728f5db3b97bdb548467f7bddea\"\n-dependencies = [\n- \"serde\",\n- \"url 1.7.2\",\n-]\n-\n [[package]]\n name = \"utf-8\"\n version = \"0.7.2\"\n@@ -4646,6 +4897,17 @@ dependencies = [\n  \"try-lock\",\n ]\n \n+[[package]]\n+name = \"wasi\"\n+version = \"0.7.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"b89c3ce4ce14bdc6fb6beaf9ec7928ca331de5df7e5ea278375642a2f478570d\"\n+dependencies = [\n+ \"compiler_builtins\",\n+ \"rustc-std-workspace-alloc\",\n+ \"rustc-std-workspace-core\",\n+]\n+\n [[package]]\n name = \"winapi\"\n version = \"0.2.8\""}, {"sha": "a242f090fbc07e889723c334dcb8689b3314be7b", "filename": "Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -68,6 +68,7 @@ rustc-workspace-hack = { path = 'src/tools/rustc-workspace-hack' }\n # here\n rustc-std-workspace-core = { path = 'src/tools/rustc-std-workspace-core' }\n rustc-std-workspace-alloc = { path = 'src/tools/rustc-std-workspace-alloc' }\n+rustc-std-workspace-std = { path = 'src/tools/rustc-std-workspace-std' }\n \n [patch.\"https://github.com/rust-lang/rust-clippy\"]\n clippy_lints = { path = \"src/tools/clippy/clippy_lints\" }"}, {"sha": "4c2e4eef6552fb3e51567480056ed80c28a0415f", "filename": "README.md", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -32,6 +32,7 @@ or reading the [rustc guide][rustcguidebuild].\n    * `cmake` 3.4.3 or later\n    * `curl`\n    * `git`\n+   * `ssl` which comes in `libssl-dev` or `openssl-devel`\n \n 2. Clone the [source] with `git`:\n \n@@ -56,6 +57,8 @@ or reading the [rustc guide][rustcguidebuild].\n     an installation (using `./x.py install`) that you set the `prefix` value\n     in the `[install]` section to a directory that you have write permissions.\n \n+    Create install directory if you are not installing in default directory\n+\n 4. Build and install:\n \n     ```sh"}, {"sha": "848147c2974c1d77bc1a7c7c4e88c6cb7bef9cfe", "filename": "config.toml.example", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/config.toml.example", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/config.toml.example", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/config.toml.example?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -184,7 +184,7 @@\n # default.\n #extended = false\n \n-# Installs chosen set of extended tools if enables. By default builds all.\n+# Installs chosen set of extended tools if enabled. By default builds all.\n # If chosen tool failed to build the installation fails.\n #tools = [\"cargo\", \"rls\", \"clippy\", \"rustfmt\", \"analysis\", \"src\"]\n \n@@ -382,11 +382,6 @@\n # This is the name of the directory in which codegen backends will get installed\n #codegen-backends-dir = \"codegen-backends\"\n \n-# Flag indicating whether `libstd` calls an imported function to handle basic IO\n-# when targeting WebAssembly. Enable this to debug tests for the `wasm32-unknown-unknown`\n-# target, as without this option the test output will not be captured.\n-#wasm-syscall = false\n-\n # Indicates whether LLD will be compiled and made available in the sysroot for\n # rustc to execute.\n #lld = false"}, {"sha": "c27c318f5ad07201703bd2a424fc5caed3ac80f3", "filename": "src/bootstrap/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Fbootstrap%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Fbootstrap%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2FCargo.toml?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -44,7 +44,7 @@ cc = \"1.0.35\"\n libc = \"0.2\"\n serde = { version = \"1.0.8\", features = [\"derive\"] }\n serde_json = \"1.0.2\"\n-toml = \"0.4\"\n+toml = \"0.5\"\n lazy_static = \"1.3.0\"\n time = \"0.1\"\n petgraph = \"0.4.13\""}, {"sha": "138b7f4b261046bad584bd2acd730da9e5b1bcf0", "filename": "src/bootstrap/bin/main.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Fbootstrap%2Fbin%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Fbootstrap%2Fbin%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbin%2Fmain.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -5,9 +5,6 @@\n //! parent directory, and otherwise documentation can be found throughout the `build`\n //! directory in each respective module.\n \n-// NO-RUSTC-WRAPPER\n-#![deny(warnings, rust_2018_idioms, unused_lifetimes)]\n-\n use std::env;\n \n use bootstrap::{Config, Build};"}, {"sha": "84415baa3a14085a63b572e0e4d625c18d077a42", "filename": "src/bootstrap/bin/rustc.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Fbootstrap%2Fbin%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Fbootstrap%2Fbin%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbin%2Frustc.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -15,9 +15,6 @@\n //! switching compilers for the bootstrap and for build scripts will probably\n //! never get replaced.\n \n-// NO-RUSTC-WRAPPER\n-#![deny(warnings, rust_2018_idioms, unused_lifetimes)]\n-\n use std::env;\n use std::ffi::OsString;\n use std::io;\n@@ -122,16 +119,18 @@ fn main() {\n         cmd.arg(format!(\"-Cdebuginfo={}\", debuginfo_level));\n     }\n \n-    if env::var_os(\"RUSTC_DENY_WARNINGS\").is_some() &&\n-       env::var_os(\"RUSTC_EXTERNAL_TOOL\").is_none() {\n-        // When extending this list, search for `NO-RUSTC-WRAPPER` and add the new lints\n-        // there as well, some code doesn't go through this `rustc` wrapper.\n-        cmd.arg(\"-Dwarnings\");\n-        cmd.arg(\"-Drust_2018_idioms\");\n-        cmd.arg(\"-Dunused_lifetimes\");\n+    if env::var_os(\"RUSTC_EXTERNAL_TOOL\").is_none() {\n+        // When extending this list, add the new lints to the RUSTFLAGS of the\n+        // build_bootstrap function of src/bootstrap/bootstrap.py as well as\n+        // some code doesn't go through this `rustc` wrapper.\n+        cmd.arg(\"-Wrust_2018_idioms\");\n+        cmd.arg(\"-Wunused_lifetimes\");\n         if use_internal_lints(crate_name) {\n             cmd.arg(\"-Zunstable-options\");\n-            cmd.arg(\"-Drustc::internal\");\n+            cmd.arg(\"-Wrustc::internal\");\n+        }\n+        if env::var_os(\"RUSTC_DENY_WARNINGS\").is_some() {\n+            cmd.arg(\"-Dwarnings\");\n         }\n     }\n "}, {"sha": "a13ff69a7b56f79f91a490541f3808cff974c004", "filename": "src/bootstrap/bin/rustdoc.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Fbootstrap%2Fbin%2Frustdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Fbootstrap%2Fbin%2Frustdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbin%2Frustdoc.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -2,12 +2,10 @@\n //!\n //! See comments in `src/bootstrap/rustc.rs` for more information.\n \n-// NO-RUSTC-WRAPPER\n-#![deny(warnings, rust_2018_idioms, unused_lifetimes)]\n-\n use std::env;\n use std::process::Command;\n use std::path::PathBuf;\n+use std::ffi::OsString;\n \n fn main() {\n     let args = env::args_os().skip(1).collect::<Vec<_>>();\n@@ -47,7 +45,9 @@ fn main() {\n         cmd.arg(\"-Z\").arg(\"force-unstable-if-unmarked\");\n     }\n     if let Some(linker) = env::var_os(\"RUSTC_TARGET_LINKER\") {\n-        cmd.arg(\"--linker\").arg(linker).arg(\"-Z\").arg(\"unstable-options\");\n+        let mut arg = OsString::from(\"-Clinker=\");\n+        arg.push(&linker);\n+        cmd.arg(arg);\n     }\n \n     // Bootstrap's Cargo-command builder sets this variable to the current Rust version; let's pick"}, {"sha": "65129eeeec5041a267012ab20b59a31ec32b7a1b", "filename": "src/bootstrap/bootstrap.py", "status": "modified", "additions": 41, "deletions": 8, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Fbootstrap%2Fbootstrap.py", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Fbootstrap%2Fbootstrap.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbootstrap.py?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -320,7 +320,7 @@ class RustBuild(object):\n     def __init__(self):\n         self.cargo_channel = ''\n         self.date = ''\n-        self._download_url = 'https://static.rust-lang.org'\n+        self._download_url = ''\n         self.rustc_channel = ''\n         self.build = ''\n         self.build_dir = os.path.join(os.getcwd(), \"build\")\n@@ -523,6 +523,10 @@ def get_toml(self, key, section=None):\n         'value2'\n         >>> rb.get_toml('key', 'c') is None\n         True\n+\n+        >>> rb.config_toml = 'key1 = true'\n+        >>> rb.get_toml(\"key1\")\n+        'true'\n         \"\"\"\n \n         cur_section = None\n@@ -571,6 +575,12 @@ def get_string(line):\n \n         >>> RustBuild.get_string('    \"devel\"   ')\n         'devel'\n+        >>> RustBuild.get_string(\"    'devel'   \")\n+        'devel'\n+        >>> RustBuild.get_string('devel') is None\n+        True\n+        >>> RustBuild.get_string('    \"devel   ')\n+        ''\n         \"\"\"\n         start = line.find('\"')\n         if start != -1:\n@@ -631,6 +641,9 @@ def build_bootstrap(self):\n         target_linker = self.get_toml(\"linker\", build_section)\n         if target_linker is not None:\n             env[\"RUSTFLAGS\"] += \"-C linker=\" + target_linker + \" \"\n+        env[\"RUSTFLAGS\"] += \" -Wrust_2018_idioms -Wunused_lifetimes \"\n+        if self.get_toml(\"deny-warnings\", \"rust\") != \"false\":\n+            env[\"RUSTFLAGS\"] += \"-Dwarnings \"\n \n         env[\"PATH\"] = os.path.join(self.bin_root(), \"bin\") + \\\n             os.pathsep + env[\"PATH\"]\n@@ -666,7 +679,7 @@ def check_submodule(self, module, slow_submodules):\n     def update_submodule(self, module, checked_out, recorded_submodules):\n         module_path = os.path.join(self.rust_root, module)\n \n-        if checked_out != None:\n+        if checked_out is not None:\n             default_encoding = sys.getdefaultencoding()\n             checked_out = checked_out.communicate()[0].decode(default_encoding).strip()\n             if recorded_submodules[module] == checked_out:\n@@ -695,6 +708,14 @@ def update_submodules(self):\n         if (not os.path.exists(os.path.join(self.rust_root, \".git\"))) or \\\n                 self.get_toml('submodules') == \"false\":\n             return\n+\n+        # check the existence of 'git' command\n+        try:\n+            subprocess.check_output(['git', '--version'])\n+        except (subprocess.CalledProcessError, OSError):\n+            print(\"error: `git` is not found, please make sure it's installed and in the path.\")\n+            sys.exit(1)\n+\n         slow_submodules = self.get_toml('fast-submodules') == \"false\"\n         start_time = time()\n         if slow_submodules:\n@@ -731,9 +752,19 @@ def update_submodules(self):\n             self.update_submodule(module[0], module[1], recorded_submodules)\n         print(\"Submodules updated in %.2f seconds\" % (time() - start_time))\n \n+    def set_normal_environment(self):\n+        \"\"\"Set download URL for normal environment\"\"\"\n+        if 'RUSTUP_DIST_SERVER' in os.environ:\n+            self._download_url = os.environ['RUSTUP_DIST_SERVER']\n+        else:\n+            self._download_url = 'https://static.rust-lang.org'\n+\n     def set_dev_environment(self):\n         \"\"\"Set download URL for development environment\"\"\"\n-        self._download_url = 'https://dev-static.rust-lang.org'\n+        if 'RUSTUP_DEV_DIST_SERVER' in os.environ:\n+            self._download_url = os.environ['RUSTUP_DEV_DIST_SERVER']\n+        else:\n+            self._download_url = 'https://dev-static.rust-lang.org'\n \n     def check_vendored_status(self):\n         \"\"\"Check that vendoring is configured properly\"\"\"\n@@ -809,13 +840,13 @@ def bootstrap(help_triggered):\n     except (OSError, IOError):\n         pass\n \n-    match = re.search(r'\\nverbose = (\\d+)', build.config_toml)\n-    if match is not None:\n-        build.verbose = max(build.verbose, int(match.group(1)))\n+    config_verbose = build.get_toml('verbose', 'build')\n+    if config_verbose is not None:\n+        build.verbose = max(build.verbose, int(config_verbose))\n \n-    build.use_vendored_sources = '\\nvendor = true' in build.config_toml\n+    build.use_vendored_sources = build.get_toml('vendor', 'build') == 'true'\n \n-    build.use_locked_deps = '\\nlocked-deps = true' in build.config_toml\n+    build.use_locked_deps = build.get_toml('locked-deps', 'build') == 'true'\n \n     build.check_vendored_status()\n \n@@ -826,6 +857,8 @@ def bootstrap(help_triggered):\n \n     if 'dev' in data:\n         build.set_dev_environment()\n+    else:\n+        build.set_normal_environment()\n \n     build.update_submodules()\n "}, {"sha": "4f5de1ecd2b44f8aa0cabf0e56249e191f62197d", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -337,7 +337,6 @@ impl<'a> Builder<'a> {\n         match kind {\n             Kind::Build => describe!(\n                 compile::Std,\n-                compile::Test,\n                 compile::Rustc,\n                 compile::CodegenBackend,\n                 compile::StartupObjects,\n@@ -363,7 +362,6 @@ impl<'a> Builder<'a> {\n             ),\n             Kind::Check | Kind::Clippy | Kind::Fix => describe!(\n                 check::Std,\n-                check::Test,\n                 check::Rustc,\n                 check::CodegenBackend,\n                 check::Rustdoc\n@@ -425,8 +423,6 @@ impl<'a> Builder<'a> {\n                 doc::TheBook,\n                 doc::Standalone,\n                 doc::Std,\n-                doc::Test,\n-                doc::WhitelistedRustc,\n                 doc::Rustc,\n                 doc::Rustdoc,\n                 doc::ErrorIndex,\n@@ -801,7 +797,7 @@ impl<'a> Builder<'a> {\n         }\n \n         match mode {\n-            Mode::Std | Mode::Test | Mode::ToolBootstrap | Mode::ToolStd | Mode::ToolTest=> {},\n+            Mode::Std | Mode::ToolBootstrap | Mode::ToolStd => {},\n             Mode::Rustc | Mode::Codegen | Mode::ToolRustc => {\n                 // Build proc macros both for the host and the target\n                 if target != compiler.host && cmd != \"check\" {\n@@ -852,7 +848,6 @@ impl<'a> Builder<'a> {\n         // things still build right, please do!\n         match mode {\n             Mode::Std => metadata.push_str(\"std\"),\n-            Mode::Test => metadata.push_str(\"test\"),\n             _ => {},\n         }\n         cargo.env(\"__CARGO_DEFAULT_LIB_METADATA\", &metadata);\n@@ -875,8 +870,7 @@ impl<'a> Builder<'a> {\n         }\n \n         if cmd == \"clippy\" {\n-            extra_args.push_str(\"-Zforce-unstable-if-unmarked -Zunstable-options \\\n-                --json-rendered=termcolor\");\n+            extra_args.push_str(\"-Zforce-unstable-if-unmarked\");\n         }\n \n         if !extra_args.is_empty() {\n@@ -949,9 +943,9 @@ impl<'a> Builder<'a> {\n \n         let debuginfo_level = match mode {\n             Mode::Rustc | Mode::Codegen => self.config.rust_debuginfo_level_rustc,\n-            Mode::Std | Mode::Test => self.config.rust_debuginfo_level_std,\n+            Mode::Std => self.config.rust_debuginfo_level_std,\n             Mode::ToolBootstrap | Mode::ToolStd |\n-            Mode::ToolTest | Mode::ToolRustc => self.config.rust_debuginfo_level_tools,\n+            Mode::ToolRustc => self.config.rust_debuginfo_level_tools,\n         };\n         cargo.env(\"RUSTC_DEBUGINFO_LEVEL\", debuginfo_level.to_string());\n \n@@ -1151,7 +1145,6 @@ impl<'a> Builder<'a> {\n \n         match (mode, self.config.rust_codegen_units_std, self.config.rust_codegen_units) {\n             (Mode::Std, Some(n), _) |\n-            (Mode::Test, Some(n), _) |\n             (_, _, Some(n)) => {\n                 cargo.env(\"RUSTC_CODEGEN_UNITS\", n.to_string());\n             }"}, {"sha": "2bb90fdb04edcef41bfe0e2df25743d1f4460307", "filename": "src/bootstrap/builder/tests.rs", "status": "modified", "additions": 64, "deletions": 89, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Fbootstrap%2Fbuilder%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Fbootstrap%2Fbuilder%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder%2Ftests.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -365,27 +365,6 @@ fn dist_with_same_targets_and_hosts() {\n             },\n         ]\n     );\n-    assert_eq!(\n-        first(builder.cache.all::<compile::Test>()),\n-        &[\n-            compile::Test {\n-                compiler: Compiler { host: a, stage: 0 },\n-                target: a,\n-            },\n-            compile::Test {\n-                compiler: Compiler { host: a, stage: 1 },\n-                target: a,\n-            },\n-            compile::Test {\n-                compiler: Compiler { host: a, stage: 2 },\n-                target: a,\n-            },\n-            compile::Test {\n-                compiler: Compiler { host: a, stage: 1 },\n-                target: b,\n-            },\n-        ]\n-    );\n     assert_eq!(\n         first(builder.cache.all::<compile::Assemble>()),\n         &[\n@@ -415,7 +394,47 @@ fn build_default() {\n     let b = INTERNER.intern_str(\"B\");\n     let c = INTERNER.intern_str(\"C\");\n \n-    assert!(!builder.cache.all::<compile::Std>().is_empty());\n+    assert_eq!(\n+        first(builder.cache.all::<compile::Std>()),\n+        &[\n+            compile::Std {\n+                compiler: Compiler { host: a, stage: 0 },\n+                target: a,\n+            },\n+            compile::Std {\n+                compiler: Compiler { host: a, stage: 1 },\n+                target: a,\n+            },\n+            compile::Std {\n+                compiler: Compiler { host: a, stage: 2 },\n+                target: a,\n+            },\n+            compile::Std {\n+                compiler: Compiler { host: b, stage: 2 },\n+                target: a,\n+            },\n+            compile::Std {\n+                compiler: Compiler { host: a, stage: 1 },\n+                target: b,\n+            },\n+            compile::Std {\n+                compiler: Compiler { host: a, stage: 2 },\n+                target: b,\n+            },\n+            compile::Std {\n+                compiler: Compiler { host: b, stage: 2 },\n+                target: b,\n+            },\n+            compile::Std {\n+                compiler: Compiler { host: a, stage: 2 },\n+                target: c,\n+            },\n+            compile::Std {\n+                compiler: Compiler { host: b, stage: 2 },\n+                target: c,\n+            },\n+        ]\n+    );\n     assert!(!builder.cache.all::<compile::Assemble>().is_empty());\n     assert_eq!(\n         first(builder.cache.all::<compile::Rustc>()),\n@@ -450,63 +469,61 @@ fn build_default() {\n             },\n         ]\n     );\n+}\n+\n+#[test]\n+fn build_with_target_flag() {\n+    let mut config = configure(&[\"B\"], &[\"C\"]);\n+    config.skip_only_host_steps = true;\n+    let build = Build::new(config);\n+    let mut builder = Builder::new(&build);\n+    builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Build), &[]);\n+\n+    let a = INTERNER.intern_str(\"A\");\n+    let b = INTERNER.intern_str(\"B\");\n+    let c = INTERNER.intern_str(\"C\");\n \n     assert_eq!(\n-        first(builder.cache.all::<compile::Test>()),\n+        first(builder.cache.all::<compile::Std>()),\n         &[\n-            compile::Test {\n+            compile::Std {\n                 compiler: Compiler { host: a, stage: 0 },\n                 target: a,\n             },\n-            compile::Test {\n+            compile::Std {\n                 compiler: Compiler { host: a, stage: 1 },\n                 target: a,\n             },\n-            compile::Test {\n+            compile::Std {\n                 compiler: Compiler { host: a, stage: 2 },\n                 target: a,\n             },\n-            compile::Test {\n+            compile::Std {\n                 compiler: Compiler { host: b, stage: 2 },\n                 target: a,\n             },\n-            compile::Test {\n+            compile::Std {\n                 compiler: Compiler { host: a, stage: 1 },\n                 target: b,\n             },\n-            compile::Test {\n+            compile::Std {\n                 compiler: Compiler { host: a, stage: 2 },\n                 target: b,\n             },\n-            compile::Test {\n+            compile::Std {\n                 compiler: Compiler { host: b, stage: 2 },\n                 target: b,\n             },\n-            compile::Test {\n+            compile::Std {\n                 compiler: Compiler { host: a, stage: 2 },\n                 target: c,\n             },\n-            compile::Test {\n+            compile::Std {\n                 compiler: Compiler { host: b, stage: 2 },\n                 target: c,\n             },\n         ]\n     );\n-}\n-\n-#[test]\n-fn build_with_target_flag() {\n-    let mut config = configure(&[\"B\"], &[\"C\"]);\n-    config.skip_only_host_steps = true;\n-    let build = Build::new(config);\n-    let mut builder = Builder::new(&build);\n-    builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Build), &[]);\n-\n-    let a = INTERNER.intern_str(\"A\");\n-    let b = INTERNER.intern_str(\"B\");\n-    let c = INTERNER.intern_str(\"C\");\n-\n-    assert!(!builder.cache.all::<compile::Std>().is_empty());\n     assert_eq!(\n         first(builder.cache.all::<compile::Assemble>()),\n         &[\n@@ -541,48 +558,6 @@ fn build_with_target_flag() {\n             },\n         ]\n     );\n-\n-    assert_eq!(\n-        first(builder.cache.all::<compile::Test>()),\n-        &[\n-            compile::Test {\n-                compiler: Compiler { host: a, stage: 0 },\n-                target: a,\n-            },\n-            compile::Test {\n-                compiler: Compiler { host: a, stage: 1 },\n-                target: a,\n-            },\n-            compile::Test {\n-                compiler: Compiler { host: a, stage: 2 },\n-                target: a,\n-            },\n-            compile::Test {\n-                compiler: Compiler { host: b, stage: 2 },\n-                target: a,\n-            },\n-            compile::Test {\n-                compiler: Compiler { host: a, stage: 1 },\n-                target: b,\n-            },\n-            compile::Test {\n-                compiler: Compiler { host: a, stage: 2 },\n-                target: b,\n-            },\n-            compile::Test {\n-                compiler: Compiler { host: b, stage: 2 },\n-                target: b,\n-            },\n-            compile::Test {\n-                compiler: Compiler { host: a, stage: 2 },\n-                target: c,\n-            },\n-            compile::Test {\n-                compiler: Compiler { host: b, stage: 2 },\n-                target: c,\n-            },\n-        ]\n-    );\n }\n \n #[test]"}, {"sha": "205a80c3a3a9e5b2129bb7be7fcd2308197e8b40", "filename": "src/bootstrap/check.rs", "status": "modified", "additions": 3, "deletions": 54, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Fbootstrap%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Fbootstrap%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcheck.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -1,6 +1,6 @@\n //! Implementation of compiling the compiler and standard library, in \"check\"-based modes.\n \n-use crate::compile::{run_cargo, std_cargo, test_cargo, rustc_cargo, rustc_cargo_env,\n+use crate::compile::{run_cargo, std_cargo, rustc_cargo, rustc_cargo_env,\n                      add_to_sysroot};\n use crate::builder::{RunConfig, Builder, Kind, ShouldRun, Step};\n use crate::tool::{prepare_tool_cargo, SourceType};\n@@ -34,7 +34,7 @@ impl Step for Std {\n     const DEFAULT: bool = true;\n \n     fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n-        run.all_krates(\"std\")\n+        run.all_krates(\"test\")\n     }\n \n     fn make_run(run: RunConfig<'_>) {\n@@ -92,7 +92,7 @@ impl Step for Rustc {\n         let compiler = builder.compiler(0, builder.config.build);\n         let target = self.target;\n \n-        builder.ensure(Test { target });\n+        builder.ensure(Std { target });\n \n         let mut cargo = builder.cargo(compiler, Mode::Rustc, target,\n             cargo_subcommand(builder.kind));\n@@ -159,47 +159,6 @@ impl Step for CodegenBackend {\n     }\n }\n \n-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n-pub struct Test {\n-    pub target: Interned<String>,\n-}\n-\n-impl Step for Test {\n-    type Output = ();\n-    const DEFAULT: bool = true;\n-\n-    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n-        run.all_krates(\"test\")\n-    }\n-\n-    fn make_run(run: RunConfig<'_>) {\n-        run.builder.ensure(Test {\n-            target: run.target,\n-        });\n-    }\n-\n-    fn run(self, builder: &Builder<'_>) {\n-        let compiler = builder.compiler(0, builder.config.build);\n-        let target = self.target;\n-\n-        builder.ensure(Std { target });\n-\n-        let mut cargo = builder.cargo(compiler, Mode::Test, target, cargo_subcommand(builder.kind));\n-        test_cargo(builder, &compiler, target, &mut cargo);\n-\n-        builder.info(&format!(\"Checking test artifacts ({} -> {})\", &compiler.host, target));\n-        run_cargo(builder,\n-                  &mut cargo,\n-                  args(builder.kind),\n-                  &libtest_stamp(builder, compiler, target),\n-                  true);\n-\n-        let libdir = builder.sysroot_libdir(compiler, target);\n-        let hostdir = builder.sysroot_libdir(compiler, compiler.host);\n-        add_to_sysroot(builder, &libdir, &hostdir, &libtest_stamp(builder, compiler, target));\n-    }\n-}\n-\n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n pub struct Rustdoc {\n     pub target: Interned<String>,\n@@ -258,16 +217,6 @@ pub fn libstd_stamp(\n     builder.cargo_out(compiler, Mode::Std, target).join(\".libstd-check.stamp\")\n }\n \n-/// Cargo's output path for libtest in a given stage, compiled by a particular\n-/// compiler for the specified target.\n-pub fn libtest_stamp(\n-    builder: &Builder<'_>,\n-    compiler: Compiler,\n-    target: Interned<String>,\n-) -> PathBuf {\n-    builder.cargo_out(compiler, Mode::Test, target).join(\".libtest-check.stamp\")\n-}\n-\n /// Cargo's output path for librustc in a given stage, compiled by a particular\n /// compiler for the specified target.\n pub fn librustc_stamp("}, {"sha": "9a964457ef285b630ad8bcf31fa5dc9c6b32388b", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 5, "deletions": 137, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -39,7 +39,7 @@ impl Step for Std {\n     const DEFAULT: bool = true;\n \n     fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n-        run.all_krates(\"std\")\n+        run.all_krates(\"test\")\n     }\n \n     fn make_run(run: RunConfig<'_>) {\n@@ -212,11 +212,12 @@ pub fn std_cargo(builder: &Builder<'_>,\n                 emscripten: false,\n             });\n             cargo.env(\"LLVM_CONFIG\", llvm_config);\n+            cargo.env(\"RUSTC_BUILD_SANITIZERS\", \"1\");\n         }\n \n         cargo.arg(\"--features\").arg(features)\n             .arg(\"--manifest-path\")\n-            .arg(builder.src.join(\"src/libstd/Cargo.toml\"));\n+            .arg(builder.src.join(\"src/libtest/Cargo.toml\"));\n \n         if target.contains(\"musl\") {\n             if let Some(p) = builder.musl_root(target) {\n@@ -358,129 +359,6 @@ impl Step for StartupObjects {\n     }\n }\n \n-#[derive(Debug, PartialOrd, Ord, Copy, Clone, PartialEq, Eq, Hash)]\n-pub struct Test {\n-    pub target: Interned<String>,\n-    pub compiler: Compiler,\n-}\n-\n-impl Step for Test {\n-    type Output = ();\n-    const DEFAULT: bool = true;\n-\n-    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n-        run.all_krates(\"test\")\n-    }\n-\n-    fn make_run(run: RunConfig<'_>) {\n-        run.builder.ensure(Test {\n-            compiler: run.builder.compiler(run.builder.top_stage, run.host),\n-            target: run.target,\n-        });\n-    }\n-\n-    /// Builds libtest.\n-    ///\n-    /// This will build libtest and supporting libraries for a particular stage of\n-    /// the build using the `compiler` targeting the `target` architecture. The\n-    /// artifacts created will also be linked into the sysroot directory.\n-    fn run(self, builder: &Builder<'_>) {\n-        let target = self.target;\n-        let compiler = self.compiler;\n-\n-        builder.ensure(Std { compiler, target });\n-\n-        if builder.config.keep_stage.contains(&compiler.stage) {\n-            builder.info(\"Warning: Using a potentially old libtest. This may not behave well.\");\n-            builder.ensure(TestLink {\n-                compiler,\n-                target_compiler: compiler,\n-                target,\n-            });\n-            return;\n-        }\n-\n-        let compiler_to_use = builder.compiler_for(compiler.stage, compiler.host, target);\n-        if compiler_to_use != compiler {\n-            builder.ensure(Test {\n-                compiler: compiler_to_use,\n-                target,\n-            });\n-            builder.info(\n-                &format!(\"Uplifting stage1 test ({} -> {})\", builder.config.build, target));\n-            builder.ensure(TestLink {\n-                compiler: compiler_to_use,\n-                target_compiler: compiler,\n-                target,\n-            });\n-            return;\n-        }\n-\n-        let mut cargo = builder.cargo(compiler, Mode::Test, target, \"build\");\n-        test_cargo(builder, &compiler, target, &mut cargo);\n-\n-        builder.info(&format!(\"Building stage{} test artifacts ({} -> {})\", compiler.stage,\n-                &compiler.host, target));\n-        run_cargo(builder,\n-                  &mut cargo,\n-                  vec![],\n-                  &libtest_stamp(builder, compiler, target),\n-                  false);\n-\n-        builder.ensure(TestLink {\n-            compiler: builder.compiler(compiler.stage, builder.config.build),\n-            target_compiler: compiler,\n-            target,\n-        });\n-    }\n-}\n-\n-/// Same as `std_cargo`, but for libtest\n-pub fn test_cargo(builder: &Builder<'_>,\n-                  _compiler: &Compiler,\n-                  _target: Interned<String>,\n-                  cargo: &mut Command) {\n-    if let Some(target) = env::var_os(\"MACOSX_STD_DEPLOYMENT_TARGET\") {\n-        cargo.env(\"MACOSX_DEPLOYMENT_TARGET\", target);\n-    }\n-    cargo.arg(\"--manifest-path\")\n-        .arg(builder.src.join(\"src/libtest/Cargo.toml\"));\n-}\n-\n-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n-pub struct TestLink {\n-    pub compiler: Compiler,\n-    pub target_compiler: Compiler,\n-    pub target: Interned<String>,\n-}\n-\n-impl Step for TestLink {\n-    type Output = ();\n-\n-    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n-        run.never()\n-    }\n-\n-    /// Same as `std_link`, only for libtest\n-    fn run(self, builder: &Builder<'_>) {\n-        let compiler = self.compiler;\n-        let target_compiler = self.target_compiler;\n-        let target = self.target;\n-        builder.info(&format!(\"Copying stage{} test from stage{} ({} -> {} / {})\",\n-                target_compiler.stage,\n-                compiler.stage,\n-                &compiler.host,\n-                target_compiler.host,\n-                target));\n-        add_to_sysroot(\n-            builder,\n-            &builder.sysroot_libdir(target_compiler, target),\n-            &builder.sysroot_libdir(target_compiler, compiler.host),\n-            &libtest_stamp(builder, compiler, target)\n-        );\n-    }\n-}\n-\n #[derive(Debug, PartialOrd, Ord, Copy, Clone, PartialEq, Eq, Hash)]\n pub struct Rustc {\n     pub target: Interned<String>,\n@@ -512,7 +390,7 @@ impl Step for Rustc {\n         let compiler = self.compiler;\n         let target = self.target;\n \n-        builder.ensure(Test { compiler, target });\n+        builder.ensure(Std { compiler, target });\n \n         if builder.config.keep_stage.contains(&compiler.stage) {\n             builder.info(\"Warning: Using a potentially old librustc. This may not behave well.\");\n@@ -541,7 +419,7 @@ impl Step for Rustc {\n         }\n \n         // Ensure that build scripts and proc macros have a std / libproc_macro to link against.\n-        builder.ensure(Test {\n+        builder.ensure(Std {\n             compiler: builder.compiler(self.compiler.stage, builder.config.build),\n             target: builder.config.build,\n         });\n@@ -872,16 +750,6 @@ pub fn libstd_stamp(\n     builder.cargo_out(compiler, Mode::Std, target).join(\".libstd.stamp\")\n }\n \n-/// Cargo's output path for libtest in a given stage, compiled by a particular\n-/// compiler for the specified target.\n-pub fn libtest_stamp(\n-    builder: &Builder<'_>,\n-    compiler: Compiler,\n-    target: Interned<String>,\n-) -> PathBuf {\n-    builder.cargo_out(compiler, Mode::Test, target).join(\".libtest.stamp\")\n-}\n-\n /// Cargo's output path for librustc in a given stage, compiled by a particular\n /// compiler for the specified target.\n pub fn librustc_stamp("}, {"sha": "43d9264eaca92ee6584485ed37a2e1e71a503762", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -122,7 +122,6 @@ pub struct Config {\n \n     // libstd features\n     pub backtrace: bool, // support for RUST_BACKTRACE\n-    pub wasm_syscall: bool,\n \n     // misc\n     pub low_priority: bool,\n@@ -318,7 +317,6 @@ struct Rust {\n     save_toolstates: Option<String>,\n     codegen_backends: Option<Vec<String>>,\n     codegen_backends_dir: Option<String>,\n-    wasm_syscall: Option<bool>,\n     lld: Option<bool>,\n     lldb: Option<bool>,\n     llvm_tools: Option<bool>,\n@@ -558,7 +556,6 @@ impl Config {\n             if let Some(true) = rust.incremental {\n                 config.incremental = true;\n             }\n-            set(&mut config.wasm_syscall, rust.wasm_syscall);\n             set(&mut config.lld_enabled, rust.lld);\n             set(&mut config.lldb_enabled, rust.lldb);\n             set(&mut config.llvm_tools_enabled, rust.llvm_tools);"}, {"sha": "500d5766a899e4945874793483f1630daf55a8b1", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -678,12 +678,7 @@ impl Step for Std {\n         if builder.hosts.iter().any(|t| t == target) {\n             builder.ensure(compile::Rustc { compiler, target });\n         } else {\n-            if builder.no_std(target) == Some(true) {\n-                // the `test` doesn't compile for no-std targets\n-                builder.ensure(compile::Std { compiler, target });\n-            } else {\n-                builder.ensure(compile::Test { compiler, target });\n-            }\n+            builder.ensure(compile::Std { compiler, target });\n         }\n \n         let image = tmpdir(builder).join(format!(\"{}-{}-image\", name, target));\n@@ -813,6 +808,7 @@ fn copy_src_dirs(builder: &Builder<'_>, src_dirs: &[&str], exclude_dirs: &[&str]\n             \"llvm-project/lld\", \"llvm-project\\\\lld\",\n             \"llvm-project/lldb\", \"llvm-project\\\\lldb\",\n             \"llvm-project/llvm\", \"llvm-project\\\\llvm\",\n+            \"llvm-project/compiler-rt\", \"llvm-project\\\\compiler-rt\",\n         ];\n         if spath.contains(\"llvm-project\") && !spath.ends_with(\"llvm-project\")\n             && !LLVM_PROJECTS.iter().any(|path| spath.contains(path))\n@@ -912,6 +908,7 @@ impl Step for Src {\n             \"src/libproc_macro\",\n             \"src/tools/rustc-std-workspace-core\",\n             \"src/tools/rustc-std-workspace-alloc\",\n+            \"src/tools/rustc-std-workspace-std\",\n             \"src/librustc\",\n             \"src/libsyntax\",\n         ];"}, {"sha": "6faedc80ad3f5d34acb391001d4b1e86490f1536", "filename": "src/bootstrap/doc.rs", "status": "modified", "additions": 4, "deletions": 131, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Fbootstrap%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Fbootstrap%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdoc.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -375,7 +375,7 @@ impl Step for Standalone {\n                up_to_date(&footer, &html) &&\n                up_to_date(&favicon, &html) &&\n                up_to_date(&full_toc, &html) &&\n-               up_to_date(&version_info, &html) &&\n+               (builder.config.dry_run || up_to_date(&version_info, &html)) &&\n                (builder.config.dry_run || up_to_date(&rustdoc, &html)) {\n                 continue\n             }\n@@ -413,7 +413,7 @@ impl Step for Std {\n \n     fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         let builder = run.builder;\n-        run.all_krates(\"std\").default_condition(builder.config.docs)\n+        run.all_krates(\"test\").default_condition(builder.config.docs)\n     }\n \n     fn make_run(run: RunConfig<'_>) {\n@@ -478,138 +478,12 @@ impl Step for Std {\n             builder.run(&mut cargo);\n             builder.cp_r(&my_out, &out);\n         };\n-        for krate in &[\"alloc\", \"core\", \"std\"] {\n+        for krate in &[\"alloc\", \"core\", \"std\", \"proc_macro\", \"test\"] {\n             run_cargo_rustdoc_for(krate);\n         }\n     }\n }\n \n-#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n-pub struct Test {\n-    stage: u32,\n-    target: Interned<String>,\n-}\n-\n-impl Step for Test {\n-    type Output = ();\n-    const DEFAULT: bool = true;\n-\n-    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n-        let builder = run.builder;\n-        run.krate(\"test\").default_condition(builder.config.docs)\n-    }\n-\n-    fn make_run(run: RunConfig<'_>) {\n-        run.builder.ensure(Test {\n-            stage: run.builder.top_stage,\n-            target: run.target,\n-        });\n-    }\n-\n-    /// Compile all libtest documentation.\n-    ///\n-    /// This will generate all documentation for libtest and its dependencies. This\n-    /// is largely just a wrapper around `cargo doc`.\n-    fn run(self, builder: &Builder<'_>) {\n-        let stage = self.stage;\n-        let target = self.target;\n-        builder.info(&format!(\"Documenting stage{} test ({})\", stage, target));\n-        let out = builder.doc_out(target);\n-        t!(fs::create_dir_all(&out));\n-        let compiler = builder.compiler_for(stage, builder.config.build, target);\n-\n-        // Build libstd docs so that we generate relative links\n-        builder.ensure(Std { stage, target });\n-\n-        builder.ensure(compile::Test { compiler, target });\n-        let out_dir = builder.stage_out(compiler, Mode::Test)\n-                           .join(target).join(\"doc\");\n-\n-        // See docs in std above for why we symlink\n-        let my_out = builder.crate_doc_out(target);\n-        t!(symlink_dir_force(&builder.config, &my_out, &out_dir));\n-\n-        let mut cargo = builder.cargo(compiler, Mode::Test, target, \"doc\");\n-        compile::test_cargo(builder, &compiler, target, &mut cargo);\n-\n-        cargo.arg(\"--no-deps\")\n-             .arg(\"-p\").arg(\"test\")\n-             .env(\"RUSTDOC_RESOURCE_SUFFIX\", crate::channel::CFG_RELEASE_NUM)\n-             .env(\"RUSTDOC_GENERATE_REDIRECT_PAGES\", \"1\");\n-\n-        builder.run(&mut cargo);\n-        builder.cp_r(&my_out, &out);\n-    }\n-}\n-\n-#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n-pub struct WhitelistedRustc {\n-    stage: u32,\n-    target: Interned<String>,\n-}\n-\n-impl Step for WhitelistedRustc {\n-    type Output = ();\n-    const DEFAULT: bool = true;\n-    const ONLY_HOSTS: bool = true;\n-\n-    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n-        let builder = run.builder;\n-        run.krate(\"rustc-main\").default_condition(builder.config.docs)\n-    }\n-\n-    fn make_run(run: RunConfig<'_>) {\n-        run.builder.ensure(WhitelistedRustc {\n-            stage: run.builder.top_stage,\n-            target: run.target,\n-        });\n-    }\n-\n-    /// Generates whitelisted compiler crate documentation.\n-    ///\n-    /// This will generate all documentation for crates that are whitelisted\n-    /// to be included in the standard documentation. This documentation is\n-    /// included in the standard Rust documentation, so we should always\n-    /// document it and symlink to merge with the rest of the std and test\n-    /// documentation. We don't build other compiler documentation\n-    /// here as we want to be able to keep it separate from the standard\n-    /// documentation. This is largely just a wrapper around `cargo doc`.\n-    fn run(self, builder: &Builder<'_>) {\n-        let stage = self.stage;\n-        let target = self.target;\n-        builder.info(&format!(\"Documenting stage{} whitelisted compiler ({})\", stage, target));\n-        let out = builder.doc_out(target);\n-        t!(fs::create_dir_all(&out));\n-        let compiler = builder.compiler_for(stage, builder.config.build, target);\n-\n-        // Build libstd docs so that we generate relative links\n-        builder.ensure(Std { stage, target });\n-\n-        builder.ensure(compile::Rustc { compiler, target });\n-        let out_dir = builder.stage_out(compiler, Mode::Rustc)\n-                           .join(target).join(\"doc\");\n-\n-        // See docs in std above for why we symlink\n-        let my_out = builder.crate_doc_out(target);\n-        t!(symlink_dir_force(&builder.config, &my_out, &out_dir));\n-\n-        let mut cargo = builder.cargo(compiler, Mode::Rustc, target, \"doc\");\n-        compile::rustc_cargo(builder, &mut cargo);\n-\n-        // We don't want to build docs for internal compiler dependencies in this\n-        // step (there is another step for that). Therefore, we whitelist the crates\n-        // for which docs must be built.\n-        for krate in &[\"proc_macro\"] {\n-            cargo.arg(\"-p\").arg(krate)\n-                 .env(\"RUSTDOC_RESOURCE_SUFFIX\", crate::channel::CFG_RELEASE_NUM)\n-                 .env(\"RUSTDOC_GENERATE_REDIRECT_PAGES\", \"1\");\n-        }\n-\n-        builder.run(&mut cargo);\n-        builder.cp_r(&my_out, &out);\n-    }\n-}\n-\n #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Rustc {\n     stage: u32,\n@@ -825,8 +699,7 @@ impl Step for ErrorIndex {\n         index.arg(crate::channel::CFG_RELEASE_NUM);\n \n         // FIXME: shouldn't have to pass this env var\n-        index.env(\"CFG_BUILD\", &builder.config.build)\n-             .env(\"RUSTC_ERROR_METADATA_DST\", builder.extended_error_dir());\n+        index.env(\"CFG_BUILD\", &builder.config.build);\n \n         builder.run(&mut index);\n     }"}, {"sha": "d9580b598155edc946002b2a77efa6ad0d73ad7f", "filename": "src/bootstrap/flags.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Fbootstrap%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Fbootstrap%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fflags.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -36,7 +36,7 @@ pub struct Flags {\n     // This overrides the deny-warnings configuation option,\n     // which passes -Dwarnings to the compiler invocations.\n     //\n-    // true => deny, false => allow\n+    // true => deny, false => warn\n     pub deny_warnings: Option<bool>,\n }\n \n@@ -556,10 +556,10 @@ fn split(s: &[String]) -> Vec<String> {\n fn parse_deny_warnings(matches: &getopts::Matches) -> Option<bool> {\n     match matches.opt_str(\"warnings\").as_ref().map(|v| v.as_str()) {\n         Some(\"deny\") => Some(true),\n-        Some(\"allow\") => Some(false),\n+        Some(\"warn\") => Some(false),\n         Some(value) => {\n             eprintln!(\n-                r#\"invalid value for --warnings: {:?}, expected \"allow\" or \"deny\"\"#,\n+                r#\"invalid value for --warnings: {:?}, expected \"warn\" or \"deny\"\"#,\n                 value,\n                 );\n             process::exit(1);"}, {"sha": "5d7581c8211be84c1e05b0ae27663f69aa992202", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -103,9 +103,6 @@\n //! More documentation can be found in each respective module below, and you can\n //! also check out the `src/bootstrap/README.md` file for more information.\n \n-// NO-RUSTC-WRAPPER\n-#![deny(warnings, rust_2018_idioms, unused_lifetimes)]\n-\n #![feature(core_intrinsics)]\n #![feature(drain_filter)]\n \n@@ -297,9 +294,6 @@ pub enum Mode {\n     /// Build the standard library, placing output in the \"stageN-std\" directory.\n     Std,\n \n-    /// Build libtest, placing output in the \"stageN-test\" directory.\n-    Test,\n-\n     /// Build librustc, and compiler libraries, placing output in the \"stageN-rustc\" directory.\n     Rustc,\n \n@@ -315,7 +309,6 @@ pub enum Mode {\n     /// Compile a tool which uses all libraries we compile (up to rustc).\n     /// Doesn't use the stage0 compiler libraries like \"other\", and includes\n     /// tools like rustdoc, cargo, rls, etc.\n-    ToolTest,\n     ToolStd,\n     ToolRustc,\n }\n@@ -502,9 +495,6 @@ impl Build {\n         if self.config.profiler {\n             features.push_str(\" profiler\");\n         }\n-        if self.config.wasm_syscall {\n-            features.push_str(\" wasm_syscall\");\n-        }\n         features\n     }\n \n@@ -536,11 +526,10 @@ impl Build {\n     fn stage_out(&self, compiler: Compiler, mode: Mode) -> PathBuf {\n         let suffix = match mode {\n             Mode::Std => \"-std\",\n-            Mode::Test => \"-test\",\n             Mode::Rustc => \"-rustc\",\n             Mode::Codegen => \"-codegen\",\n             Mode::ToolBootstrap => \"-bootstrap-tools\",\n-            Mode::ToolStd | Mode::ToolTest | Mode::ToolRustc => \"-tools\",\n+            Mode::ToolStd | Mode::ToolRustc => \"-tools\",\n         };\n         self.out.join(&*compiler.host)\n                 .join(format!(\"stage{}{}\", compiler.stage, suffix))"}, {"sha": "7bf9ea2688f4c5a872d3f6f0b3f1ac645a9a7811", "filename": "src/bootstrap/native.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Fbootstrap%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Fbootstrap%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fnative.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -81,26 +81,29 @@ impl Step for Llvm {\n             (info, \"src/llvm-project/llvm\", builder.llvm_out(target), dir.join(\"bin\"))\n         };\n \n-        if !llvm_info.is_git() {\n-            println!(\n-                \"git could not determine the LLVM submodule commit hash. \\\n-                Assuming that an LLVM build is necessary.\",\n-            );\n-        }\n-\n         let build_llvm_config = llvm_config_ret_dir\n             .join(exe(\"llvm-config\", &*builder.config.build));\n         let done_stamp = out_dir.join(\"llvm-finished-building\");\n \n-        if let Some(llvm_commit) = llvm_info.sha() {\n-            if done_stamp.exists() {\n+        if done_stamp.exists() {\n+            if let Some(llvm_commit) = llvm_info.sha() {\n                 let done_contents = t!(fs::read(&done_stamp));\n \n                 // If LLVM was already built previously and the submodule's commit didn't change\n                 // from the previous build, then no action is required.\n                 if done_contents == llvm_commit.as_bytes() {\n-                    return build_llvm_config\n+                    return build_llvm_config;\n                 }\n+            } else {\n+                builder.info(\n+                    \"Could not determine the LLVM submodule commit hash. \\\n+                     Assuming that an LLVM rebuild is not necessary.\",\n+                );\n+                builder.info(&format!(\n+                    \"To force LLVM to rebuild, remove the file `{}`\",\n+                    done_stamp.display()\n+                ));\n+                return build_llvm_config;\n             }\n         }\n \n@@ -303,9 +306,7 @@ impl Step for Llvm {\n \n         cfg.build();\n \n-        if let Some(llvm_commit) = llvm_info.sha() {\n-            t!(fs::write(&done_stamp, llvm_commit));\n-        }\n+        t!(fs::write(&done_stamp, llvm_info.sha().unwrap_or(\"\")));\n \n         build_llvm_config\n     }"}, {"sha": "00d87f3841cfffd04af86c5c3139f36591aa3565", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 13, "deletions": 41, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -1040,21 +1040,10 @@ impl Step for Compiletest {\n             builder.ensure(compile::Rustc { compiler, target });\n         }\n \n-        if builder.no_std(target) == Some(true) {\n-            // the `test` doesn't compile for no-std targets\n-            builder.ensure(compile::Std { compiler, target });\n-        } else {\n-            builder.ensure(compile::Test { compiler, target });\n-        }\n-\n-        if builder.no_std(target) == Some(true) {\n-            // for no_std run-make (e.g., thumb*),\n-            // we need a host compiler which is called by cargo.\n-            builder.ensure(compile::Std { compiler, target: compiler.host });\n-        }\n+        builder.ensure(compile::Std { compiler, target });\n+        // ensure that `libproc_macro` is available on the host.\n+        builder.ensure(compile::Std { compiler, target: compiler.host });\n \n-        // HACK(eddyb) ensure that `libproc_macro` is available on the host.\n-        builder.ensure(compile::Test { compiler, target: compiler.host });\n         // Also provide `rust_test_helpers` for the host.\n         builder.ensure(native::TestHelpers { target: compiler.host });\n \n@@ -1338,7 +1327,10 @@ impl Step for Compiletest {\n             cmd.env(\"RUSTC_PROFILER_SUPPORT\", \"1\");\n         }\n \n-        cmd.env(\"RUST_TEST_TMPDIR\", builder.out.join(\"tmp\"));\n+        let tmp = builder.out.join(\"tmp\");\n+        std::fs::create_dir_all(&tmp).unwrap();\n+        cmd.env(\"RUST_TEST_TMPDIR\", tmp);\n+\n \n         cmd.arg(\"--adb-path\").arg(\"adb\");\n         cmd.arg(\"--adb-test-dir\").arg(ADB_TEST_DIR);\n@@ -1399,7 +1391,7 @@ impl Step for DocTest {\n     fn run(self, builder: &Builder<'_>) {\n         let compiler = self.compiler;\n \n-        builder.ensure(compile::Test {\n+        builder.ensure(compile::Std {\n             compiler,\n             target: compiler.host,\n         });\n@@ -1535,8 +1527,7 @@ impl Step for ErrorIndex {\n         );\n         tool.arg(\"markdown\")\n             .arg(&output)\n-            .env(\"CFG_BUILD\", &builder.config.build)\n-            .env(\"RUSTC_ERROR_METADATA_DST\", builder.extended_error_dir());\n+            .env(\"CFG_BUILD\", &builder.config.build);\n \n         builder.info(&format!(\"Testing error-index stage{}\", compiler.stage));\n         let _time = util::timeit(&builder);\n@@ -1710,8 +1701,7 @@ impl Step for Crate {\n \n     fn should_run(mut run: ShouldRun<'_>) -> ShouldRun<'_> {\n         let builder = run.builder;\n-        run = run.krate(\"test\");\n-        for krate in run.builder.in_tree_crates(\"std\") {\n+        for krate in run.builder.in_tree_crates(\"test\") {\n             if !(krate.name.starts_with(\"rustc_\") && krate.name.ends_with(\"san\")) {\n                 run = run.path(krate.local_path(&builder).to_str().unwrap());\n             }\n@@ -1735,14 +1725,9 @@ impl Step for Crate {\n             });\n         };\n \n-        for krate in builder.in_tree_crates(\"std\") {\n-            if run.path.ends_with(&krate.local_path(&builder)) {\n-                make(Mode::Std, krate);\n-            }\n-        }\n         for krate in builder.in_tree_crates(\"test\") {\n             if run.path.ends_with(&krate.local_path(&builder)) {\n-                make(Mode::Test, krate);\n+                make(Mode::Std, krate);\n             }\n         }\n     }\n@@ -1762,7 +1747,7 @@ impl Step for Crate {\n         let test_kind = self.test_kind;\n         let krate = self.krate;\n \n-        builder.ensure(compile::Test { compiler, target });\n+        builder.ensure(compile::Std { compiler, target });\n         builder.ensure(RemoteCopyLibs { compiler, target });\n \n         // If we're not doing a full bootstrap but we're testing a stage2\n@@ -1776,9 +1761,6 @@ impl Step for Crate {\n             Mode::Std => {\n                 compile::std_cargo(builder, &compiler, target, &mut cargo);\n             }\n-            Mode::Test => {\n-                compile::test_cargo(builder, &compiler, target, &mut cargo);\n-            }\n             Mode::Rustc => {\n                 builder.ensure(compile::Rustc { compiler, target });\n                 compile::rustc_cargo(builder, &mut cargo);\n@@ -1832,16 +1814,6 @@ impl Step for Crate {\n                     .expect(\"nodejs not configured\"),\n             );\n         } else if target.starts_with(\"wasm32\") {\n-            // Warn about running tests without the `wasm_syscall` feature enabled.\n-            // The javascript shim implements the syscall interface so that test\n-            // output can be correctly reported.\n-            if !builder.config.wasm_syscall {\n-                builder.info(\n-                    \"Libstd was built without `wasm_syscall` feature enabled: \\\n-                     test output may not be visible.\"\n-                );\n-            }\n-\n             // On the wasm32-unknown-unknown target we're using LTO which is\n             // incompatible with `-C prefer-dynamic`, so disable that here\n             cargo.env(\"RUSTC_NO_PREFER_DYNAMIC\", \"1\");\n@@ -1980,7 +1952,7 @@ impl Step for RemoteCopyLibs {\n             return;\n         }\n \n-        builder.ensure(compile::Test { compiler, target });\n+        builder.ensure(compile::Std { compiler, target });\n \n         builder.info(&format!(\"REMOTE copy libs to emulator ({})\", target));\n         t!(fs::create_dir_all(builder.out.join(\"tmp\")));"}, {"sha": "54fe26f18e741d0a7558ada111628bb68cc84ee3", "filename": "src/bootstrap/tool.rs", "status": "modified", "additions": 3, "deletions": 36, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Fbootstrap%2Ftool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Fbootstrap%2Ftool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftool.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -577,12 +577,6 @@ impl Step for Cargo {\n     }\n \n     fn run(self, builder: &Builder<'_>) -> PathBuf {\n-        // Cargo depends on procedural macros, so make sure the host\n-        // libstd/libproc_macro is available.\n-        builder.ensure(compile::Test {\n-            compiler: self.compiler,\n-            target: builder.config.build,\n-        });\n         builder.ensure(ToolBuild {\n             compiler: self.compiler,\n             target: self.target,\n@@ -650,31 +644,10 @@ macro_rules! tool_extended {\n \n tool_extended!((self, builder),\n     Cargofmt, rustfmt, \"src/tools/rustfmt\", \"cargo-fmt\", {};\n-    CargoClippy, clippy, \"src/tools/clippy\", \"cargo-clippy\", {\n-        // Clippy depends on procedural macros, so make sure that's built for\n-        // the compiler itself.\n-        builder.ensure(compile::Test {\n-            compiler: self.compiler,\n-            target: builder.config.build,\n-        });\n-    };\n-    Clippy, clippy, \"src/tools/clippy\", \"clippy-driver\", {\n-        // Clippy depends on procedural macros, so make sure that's built for\n-        // the compiler itself.\n-        builder.ensure(compile::Test {\n-            compiler: self.compiler,\n-            target: builder.config.build,\n-        });\n-    };\n+    CargoClippy, clippy, \"src/tools/clippy\", \"cargo-clippy\", {};\n+    Clippy, clippy, \"src/tools/clippy\", \"clippy-driver\", {};\n     Miri, miri, \"src/tools/miri\", \"miri\", {};\n-    CargoMiri, miri, \"src/tools/miri\", \"cargo-miri\", {\n-        // Miri depends on procedural macros, so make sure that's built for\n-        // the compiler itself.\n-        builder.ensure(compile::Test {\n-            compiler: self.compiler,\n-            target: builder.config.build,\n-        });\n-    };\n+    CargoMiri, miri, \"src/tools/miri\", \"cargo-miri\", {};\n     Rls, rls, \"src/tools/rls\", \"rls\", {\n         let clippy = builder.ensure(Clippy {\n             compiler: self.compiler,\n@@ -684,12 +657,6 @@ tool_extended!((self, builder),\n         if clippy.is_some() {\n             self.extra_features.push(\"clippy\".to_owned());\n         }\n-        // RLS depends on procedural macros, so make sure that's built for\n-        // the compiler itself.\n-        builder.ensure(compile::Test {\n-            compiler: self.compiler,\n-            target: builder.config.build,\n-        });\n     };\n     Rustfmt, rustfmt, \"src/tools/rustfmt\", \"rustfmt\", {};\n );"}, {"sha": "f035a7119188a1aa3c415e09096e20b8e896104f", "filename": "src/build_helper/lib.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Fbuild_helper%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Fbuild_helper%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbuild_helper%2Flib.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -1,6 +1,3 @@\n-// NO-RUSTC-WRAPPER\n-#![deny(warnings, rust_2018_idioms, unused_lifetimes)]\n-\n use std::fs::File;\n use std::path::{Path, PathBuf};\n use std::process::{Command, Stdio};\n@@ -262,7 +259,7 @@ pub fn native_lib_boilerplate(\n     if !up_to_date(Path::new(\"build.rs\"), &timestamp) || !up_to_date(src_dir, &timestamp) {\n         Ok(NativeLibBoilerplate {\n             src_dir: src_dir.to_path_buf(),\n-            out_dir: out_dir,\n+            out_dir,\n         })\n     } else {\n         Err(())"}, {"sha": "105791194628b3130866d55f5293fb1b6431756d", "filename": "src/ci/docker/dist-various-1/Dockerfile", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Fci%2Fdocker%2Fdist-various-1%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Fci%2Fdocker%2Fdist-various-1%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-various-1%2FDockerfile?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -104,9 +104,7 @@ ENV TARGETS=$TARGETS,armv5te-unknown-linux-musleabi\n ENV TARGETS=$TARGETS,armv7-unknown-linux-musleabihf\n ENV TARGETS=$TARGETS,aarch64-unknown-linux-musl\n ENV TARGETS=$TARGETS,sparc64-unknown-linux-gnu\n-# FIXME: temporarily disable the redox builder,\n-# see: https://github.com/rust-lang/rust/issues/63160\n-# ENV TARGETS=$TARGETS,x86_64-unknown-redox\n+ENV TARGETS=$TARGETS,x86_64-unknown-redox\n ENV TARGETS=$TARGETS,thumbv6m-none-eabi\n ENV TARGETS=$TARGETS,thumbv7m-none-eabi\n ENV TARGETS=$TARGETS,thumbv7em-none-eabi\n@@ -132,7 +130,7 @@ ENV CC_mipsel_unknown_linux_musl=mipsel-openwrt-linux-gcc \\\n     CC_thumbv7neon_unknown_linux_gnueabihf=arm-linux-gnueabihf-gcc \\\n     AR_thumbv7neon_unknown_linux_gnueabihf=arm-linux-gnueabihf-ar \\\n     CXX_thumbv7neon_unknown_linux_gnueabihf=arm-linux-gnueabihf-g++\n-    \n+\n ENV RUST_CONFIGURE_ARGS \\\n       --musl-root-armv5te=/musl-armv5te \\\n       --musl-root-arm=/musl-arm \\"}, {"sha": "de8c359d16757a223b84fce8afce6ae2331bd61d", "filename": "src/ci/docker/dist-various-1/install-mipsel-musl.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Fci%2Fdocker%2Fdist-various-1%2Finstall-mipsel-musl.sh", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Fci%2Fdocker%2Fdist-various-1%2Finstall-mipsel-musl.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-various-1%2Finstall-mipsel-musl.sh?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -5,7 +5,7 @@ mkdir /usr/local/mipsel-linux-musl\n # Note that this originally came from:\n # https://downloads.openwrt.org/snapshots/trunk/malta/generic/\n # OpenWrt-Toolchain-malta-le_gcc-5.3.0_musl-1.1.15.Linux-x86_64.tar.bz2\n-URL=\"https://rust-lang-ci2.s3.amazonaws.com/libc\"\n+URL=\"https://rust-lang-ci-mirrors.s3-us-west-1.amazonaws.com/rustc\"\n FILE=\"OpenWrt-Toolchain-malta-le_gcc-5.3.0_musl-1.1.15.Linux-x86_64.tar.bz2\"\n curl -L \"$URL/$FILE\" | tar xjf - -C /usr/local/mipsel-linux-musl --strip-components=2\n "}, {"sha": "5ca585c4a7552efb546e7681c3de0712f4ae4fdc", "filename": "src/doc/embedded-book", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fembedded-book?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -1 +1 @@\n-Subproject commit c5da1e11915d3f28266168baaf55822f7e3fe999\n+Subproject commit 5ca585c4a7552efb546e7681c3de0712f4ae4fdc"}, {"sha": "38b9a76bc8b59ac862663807fc51c9b757337fd6", "filename": "src/doc/nomicon", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -1 +1 @@\n-Subproject commit 8a7d05615e5bc0a7fb961b4919c44f5221ee54da\n+Subproject commit 38b9a76bc8b59ac862663807fc51c9b757337fd6"}, {"sha": "1944efed35989ba57fa397c0724c4921310311fc", "filename": "src/doc/reference", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -1 +1 @@\n-Subproject commit b4b3536839042a6743fc76f0d9ad2a812020aeaa\n+Subproject commit 1944efed35989ba57fa397c0724c4921310311fc"}, {"sha": "e76be6b2dc84c6a992e186157efe29d625e29b94", "filename": "src/doc/rust-by-example", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frust-by-example?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -1 +1 @@\n-Subproject commit f2c15ba5ee89ae9469a2cf60494977749901d764\n+Subproject commit e76be6b2dc84c6a992e186157efe29d625e29b94"}, {"sha": "941968db2fd9c85788a4f971c8e425d46b4cb734", "filename": "src/doc/rustc-guide", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc-guide?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -1 +1 @@\n-Subproject commit 6f4ba673ff9d4613e98415bc095347a6a0031e9c\n+Subproject commit 941968db2fd9c85788a4f971c8e425d46b4cb734"}, {"sha": "5eea9c86879001ef9a13ee6f3c8ecbc487697ccc", "filename": "src/doc/rustc/src/command-line-arguments.md", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Fdoc%2Frustc%2Fsrc%2Fcommand-line-arguments.md", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Fdoc%2Frustc%2Fsrc%2Fcommand-line-arguments.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fcommand-line-arguments.md?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -304,3 +304,10 @@ to customize the output:\n \n Note that it is invalid to combine the `--json` argument with the `--color`\n argument, and it is required to combine `--json` with `--error-format=json`.\n+\n+## `@path`: load command-line flags from a path\n+\n+If you specify `@path` on the command-line, then it will open `path` and read\n+command line options from it. These options are one per line; a blank line indicates\n+an empty option. The file can use Unix or Windows style line endings, and must be\n+encoded as UTF-8."}, {"sha": "6f1bbe60569fd4ccfeadcfceefb68c7ec97ced13", "filename": "src/doc/rustc/src/linker-plugin-lto.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Fdoc%2Frustc%2Fsrc%2Flinker-plugin-lto.md", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Fdoc%2Frustc%2Fsrc%2Flinker-plugin-lto.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Flinker-plugin-lto.md?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -105,5 +105,6 @@ The following table shows known good combinations of toolchain versions.\n | Rust 1.34 |     \u2717     |     \u2713     |\n | Rust 1.35 |     \u2717     |     \u2713     |\n | Rust 1.36 |     \u2717     |     \u2713     |\n+| Rust 1.37 |     \u2717     |     \u2713     |\n \n Note that the compatibility policy for this feature might change in the future."}, {"sha": "d3dfc3197e2f69749bc3e6537f4d55fb97376016", "filename": "src/doc/rustc/src/lints/listing/allowed-by-default.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flisting%2Fallowed-by-default.md", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flisting%2Fallowed-by-default.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flisting%2Fallowed-by-default.md?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -208,7 +208,7 @@ error: missing documentation for a function\n \n To fix the lint, add documentation to all items.\n \n-## single-use-lifetime\n+## single-use-lifetimes\n \n This lint detects lifetimes that are only used once. Some example code that\n triggers this lint:"}, {"sha": "49d05b5038df74dd8ff7bd53545adc7fdfc123d9", "filename": "src/doc/rustdoc/src/unstable-features.md", "status": "modified", "additions": 50, "deletions": 13, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Fdoc%2Frustdoc%2Fsrc%2Funstable-features.md", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Fdoc%2Frustdoc%2Fsrc%2Funstable-features.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc%2Fsrc%2Funstable-features.md?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -311,19 +311,6 @@ When `rustdoc` receives this flag, it will print an extra \"Version (version)\" in\n the crate root's docs. You can use this flag to differentiate between different versions of your\n library's documentation.\n \n-### `--linker`: control the linker used for documentation tests\n-\n-Using this flag looks like this:\n-\n-```bash\n-$ rustdoc --test src/lib.rs -Z unstable-options --linker foo\n-$ rustdoc --test README.md -Z unstable-options --linker foo\n-```\n-\n-When `rustdoc` runs your documentation tests, it needs to compile and link the tests as executables\n-before running them. This flag can be used to change the linker used on these executables. It's\n-equivalent to passing `-C linker=foo` to `rustc`.\n-\n ### `--sort-modules-by-appearance`: control how items on module pages are sorted\n \n Using this flag looks like this:\n@@ -484,3 +471,53 @@ Some methodology notes about what rustdoc counts in this metric:\n \n Public items that are not documented can be seen with the built-in `missing_docs` lint. Private\n items that are not documented can be seen with Clippy's `missing_docs_in_private_items` lint.\n+\n+### `--enable-per-target-ignores`: allow `ignore-foo` style filters for doctests\n+\n+Using this flag looks like this:\n+\n+```bash\n+$ rustdoc src/lib.rs -Z unstable-options --enable-per-target-ignores\n+```\n+\n+This flag allows you to tag doctests with compiltest style `ignore-foo` filters that prevent\n+rustdoc from running that test if the target triple string contains foo. For example:\n+\n+```rust\n+///```ignore-foo,ignore-bar\n+///assert!(2 == 2);\n+///```\n+struct Foo;\n+```\n+\n+This will not be run when the build target is `super-awesome-foo` or `less-bar-awesome`.\n+If the flag is not enabled, then rustdoc will consume the filter, but do nothing with it, and\n+the above example will be run for all targets.\n+If you want to preserve backwards compatibility for older versions of rustdoc, you can use\n+\n+```rust\n+///```ignore,ignore-foo\n+///assert!(2 == 2);\n+///```\n+struct Foo;\n+```\n+\n+In older versions, this will be ignored on all targets, but on newer versions `ignore-gnu` will\n+override `ignore`.\n+\n+### `--runtool`, `--runtool-arg`: program to run tests with; args to pass to it\n+\n+Using thses options looks like this:\n+\n+```bash\n+$ rustdoc src/lib.rs -Z unstable-options --runtool runner --runtool-arg --do-thing --runtool-arg --do-other-thing\n+```\n+\n+These options can be used to run the doctest under a program, and also pass arguments to\n+that program. For example, if you want to run your doctests under valgrind you might run\n+\n+```bash\n+$ rustdoc src/lib.rs -Z unstable-options --runtool valgrind\n+```\n+\n+Another use case would be to run a test inside an emulator, or through a Virtual Machine."}, {"sha": "68877b48433d5462d3581d202f483a87d90224f3", "filename": "src/doc/unstable-book/src/language-features/plugin.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fplugin.md", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fplugin.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fplugin.md?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -57,12 +57,12 @@ extern crate rustc;\n extern crate rustc_driver;\n \n use syntax::parse::token::{self, Token};\n-use syntax::tokenstream::TokenTree;\n+use syntax::tokenstream::{TokenTree, TokenStream};\n use syntax::ext::base::{ExtCtxt, MacResult, DummyResult, MacEager};\n use syntax_pos::Span;\n use rustc_driver::plugin::Registry;\n \n-fn expand_rn(cx: &mut ExtCtxt, sp: Span, args: &[TokenTree])\n+fn expand_rn(cx: &mut ExtCtxt, sp: Span, args: TokenStream)\n         -> Box<dyn MacResult + 'static> {\n \n     static NUMERALS: &'static [(&'static str, usize)] = &[\n@@ -78,7 +78,7 @@ fn expand_rn(cx: &mut ExtCtxt, sp: Span, args: &[TokenTree])\n         return DummyResult::any(sp);\n     }\n \n-    let text = match args[0] {\n+    let text = match args.into_trees().next().unwrap() {\n         TokenTree::Token(Token { kind: token::Ident(s, _), .. }) => s.to_string(),\n         _ => {\n             cx.span_err(sp, \"argument should be a single identifier\");"}, {"sha": "7c2e91474c1f1710e5f85c62d09c47ea957e19ba", "filename": "src/etc/lldb_batchmode.py", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Fetc%2Flldb_batchmode.py", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Fetc%2Flldb_batchmode.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Flldb_batchmode.py?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -45,7 +45,10 @@ def normalize_whitespace(s):\n \n def breakpoint_callback(frame, bp_loc, dict):\n     \"\"\"This callback is registered with every breakpoint and makes sure that the\n-    frame containing the breakpoint location is selected\"\"\"\n+    frame containing the breakpoint location is selected \"\"\"\n+\n+    # HACK(eddyb) print a newline to avoid continuing an unfinished line.\n+    print(\"\")\n     print(\"Hit breakpoint \" + str(bp_loc))\n \n     # Select the frame and the thread containing it"}, {"sha": "262a53eabe3c7bf3030eafc9c8c79a8d3000522c", "filename": "src/etc/wasm32-shim.js", "status": "modified", "additions": 1, "deletions": 107, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Fetc%2Fwasm32-shim.js", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Fetc%2Fwasm32-shim.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fwasm32-shim.js?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -15,113 +15,7 @@ const buffer = fs.readFileSync(process.argv[2]);\n Error.stackTraceLimit = 20;\n \n let m = new WebAssembly.Module(buffer);\n-\n-let memory = null;\n-\n-function viewstruct(data, fields) {\n-  return new Uint32Array(memory.buffer).subarray(data/4, data/4 + fields);\n-}\n-\n-function copystr(a, b) {\n-  let view = new Uint8Array(memory.buffer).subarray(a, a + b);\n-  return String.fromCharCode.apply(null, view);\n-}\n-\n-function syscall_write([fd, ptr, len]) {\n-  let s = copystr(ptr, len);\n-  switch (fd) {\n-    case 1: process.stdout.write(s); break;\n-    case 2: process.stderr.write(s); break;\n-  }\n-}\n-\n-function syscall_exit([code]) {\n-  process.exit(code);\n-}\n-\n-function syscall_args(params) {\n-  let [ptr, len] = params;\n-\n-  // Calculate total required buffer size\n-  let totalLen = -1;\n-  for (let i = 2; i < process.argv.length; ++i) {\n-    totalLen += Buffer.byteLength(process.argv[i]) + 1;\n-  }\n-  if (totalLen < 0) { totalLen = 0; }\n-  params[2] = totalLen;\n-\n-  // If buffer is large enough, copy data\n-  if (len >= totalLen) {\n-    let view = new Uint8Array(memory.buffer);\n-    for (let i = 2; i < process.argv.length; ++i) {\n-      let value = process.argv[i];\n-      Buffer.from(value).copy(view, ptr);\n-      ptr += Buffer.byteLength(process.argv[i]) + 1;\n-    }\n-  }\n-}\n-\n-function syscall_getenv(params) {\n-  let [keyPtr, keyLen, valuePtr, valueLen] = params;\n-\n-  let key = copystr(keyPtr, keyLen);\n-  let value = process.env[key];\n-\n-  if (value == null) {\n-    params[4] = 0xFFFFFFFF;\n-  } else {\n-    let view = new Uint8Array(memory.buffer);\n-    let totalLen = Buffer.byteLength(value);\n-    params[4] = totalLen;\n-    if (valueLen >= totalLen) {\n-      Buffer.from(value).copy(view, valuePtr);\n-    }\n-  }\n-}\n-\n-function syscall_time(params) {\n-  let t = Date.now();\n-  let secs = Math.floor(t / 1000);\n-  let millis = t % 1000;\n-  params[1] = Math.floor(secs / 0x100000000);\n-  params[2] = secs % 0x100000000;\n-  params[3] = Math.floor(millis * 1000000);\n-}\n-\n-let imports = {};\n-imports.env = {\n-  // These are generated by LLVM itself for various intrinsic calls. Hopefully\n-  // one day this is not necessary and something will automatically do this.\n-  fmod: function(x, y) { return x % y; },\n-  exp2: function(x) { return Math.pow(2, x); },\n-  exp2f: function(x) { return Math.pow(2, x); },\n-  ldexp: function(x, y) { return x * Math.pow(2, y); },\n-  ldexpf: function(x, y) { return x * Math.pow(2, y); },\n-  sin: Math.sin,\n-  sinf: Math.sin,\n-  cos: Math.cos,\n-  cosf: Math.cos,\n-  log: Math.log,\n-  log2: Math.log2,\n-  log10: Math.log10,\n-  log10f: Math.log10,\n-\n-  rust_wasm_syscall: function(index, data) {\n-    switch (index) {\n-      case 1: syscall_write(viewstruct(data, 3)); return true;\n-      case 2: syscall_exit(viewstruct(data, 1)); return true;\n-      case 3: syscall_args(viewstruct(data, 3)); return true;\n-      case 4: syscall_getenv(viewstruct(data, 5)); return true;\n-      case 6: syscall_time(viewstruct(data, 4)); return true;\n-      default:\n-        console.log(\"Unsupported syscall: \" + index);\n-        return false;\n-    }\n-  }\n-};\n-\n-let instance = new WebAssembly.Instance(m, imports);\n-memory = instance.exports.memory;\n+let instance = new WebAssembly.Instance(m, {});\n try {\n   instance.exports.main();\n } catch (e) {"}, {"sha": "816a71f2557982a22b7d53c5dea848098dd96291", "filename": "src/liballoc/collections/linked_list.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Fliballoc%2Fcollections%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Fliballoc%2Fcollections%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Flinked_list.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -276,7 +276,7 @@ impl<T> LinkedList<T> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn new() -> Self {\n+    pub const fn new() -> Self {\n         LinkedList {\n             head: None,\n             tail: None,"}, {"sha": "a4a0fbb194dd448083c320643d2c8a2ef505a60b", "filename": "src/liballoc/collections/vec_deque.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Fliballoc%2Fcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Fliballoc%2Fcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fvec_deque.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -1810,7 +1810,7 @@ impl<T> VecDeque<T> {\n         other\n     }\n \n-    /// Moves all the elements of `other` into `Self`, leaving `other` empty.\n+    /// Moves all the elements of `other` into `self`, leaving `other` empty.\n     ///\n     /// # Panics\n     ///\n@@ -1847,7 +1847,7 @@ impl<T> VecDeque<T> {\n     ///\n     /// let mut buf = VecDeque::new();\n     /// buf.extend(1..5);\n-    /// buf.retain(|&x| x%2 == 0);\n+    /// buf.retain(|&x| x % 2 == 0);\n     /// assert_eq!(buf, [2, 4]);\n     /// ```\n     ///"}, {"sha": "d5dc2d4b8688d79b0c8f5e25f76fbc759992cef8", "filename": "src/liballoc/vec.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Fliballoc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Fliballoc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -291,6 +291,7 @@ use crate::raw_vec::RawVec;\n /// [`reserve`]: ../../std/vec/struct.Vec.html#method.reserve\n /// [owned slice]: ../../std/boxed/struct.Box.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[cfg_attr(all(not(bootstrap), not(test)), rustc_diagnostic_item = \"vec_type\")]\n pub struct Vec<T> {\n     buf: RawVec<T>,\n     len: usize,"}, {"sha": "32ec26975e375291ec503bd2194c7419e041f917", "filename": "src/libcore/bool.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibcore%2Fbool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibcore%2Fbool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbool.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -0,0 +1,45 @@\n+//! impl bool {}\n+\n+#[cfg(not(boostrap_stdarch_ignore_this))]\n+#[lang = \"bool\"]\n+impl bool {\n+    /// Returns `Some(t)` if the `bool` is `true`, or `None` otherwise.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(bool_to_option)]\n+    ///\n+    /// assert_eq!(false.then(0), None);\n+    /// assert_eq!(true.then(0), Some(0));\n+    /// ```\n+    #[unstable(feature = \"bool_to_option\", issue = \"64260\")]\n+    #[inline]\n+    pub fn then<T>(self, t: T) -> Option<T> {\n+        if self {\n+            Some(t)\n+        } else {\n+            None\n+        }\n+    }\n+\n+    /// Returns `Some(f())` if the `bool` is `true`, or `None` otherwise.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(bool_to_option)]\n+    ///\n+    /// assert_eq!(false.then_with(|| 0), None);\n+    /// assert_eq!(true.then_with(|| 0), Some(0));\n+    /// ```\n+    #[unstable(feature = \"bool_to_option\", issue = \"64260\")]\n+    #[inline]\n+    pub fn then_with<T, F: FnOnce() -> T>(self, f: F) -> Option<T> {\n+        if self {\n+            Some(f())\n+        } else {\n+            None\n+        }\n+    }\n+}"}, {"sha": "a69eb0f6d4b20fb1b05e621f4b962f1eb7c465d0", "filename": "src/libcore/char/methods.rs", "status": "modified", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibcore%2Fchar%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibcore%2Fchar%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar%2Fmethods.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -547,29 +547,6 @@ impl char {\n         }\n     }\n \n-    /// Returns `true` if this `char` satisfies the `XID_Start` Unicode property, and false\n-    /// otherwise.\n-    ///\n-    /// `XID_Start` is a Unicode Derived Property specified in\n-    /// [UAX #31](http://unicode.org/reports/tr31/#NFKC_Modifications),\n-    /// mostly similar to `ID_Start` but modified for closure under `NFKx`.\n-    #[unstable(feature = \"unicode_internals\", issue = \"0\")]\n-    pub fn is_xid_start(self) -> bool {\n-        derived_property::XID_Start(self)\n-    }\n-\n-    /// Returns `true` if this `char` satisfies the `XID_Continue` Unicode property, and false\n-    /// otherwise.\n-    ///\n-    /// `XID_Continue` is a Unicode Derived Property specified in\n-    /// [UAX #31](http://unicode.org/reports/tr31/#NFKC_Modifications),\n-    /// mostly similar to `ID_Continue` but modified for closure under NFKx.\n-    #[unstable(feature = \"unicode_internals\", issue = \"0\")]\n-    #[inline]\n-    pub fn is_xid_continue(self) -> bool {\n-        derived_property::XID_Continue(self)\n-    }\n-\n     /// Returns `true` if this `char` is lowercase.\n     ///\n     /// 'Lowercase' is defined according to the terms of the Unicode Derived Core"}, {"sha": "7ec2295f97e368913b98dc4ce0b0fdde5f392655", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 18, "deletions": 8, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -9,14 +9,22 @@\n //! * [`Ord`] and [`PartialOrd`] are traits that allow you to define total and\n //!   partial orderings between values, respectively. Implementing them overloads\n //!   the `<`, `<=`, `>`, and `>=` operators.\n-//! * [`Ordering`][cmp::Ordering] is an enum returned by the\n-//!   main functions of [`Ord`] and [`PartialOrd`], and describes an ordering.\n-//! * [`Reverse`][cmp::Reverse] is a struct that allows you to easily reverse\n-//!   an ordering.\n-//! * [`max`][cmp::max] and [`min`][cmp::min] are functions that build off of\n-//!   [`Ord`] and allow you to find the maximum or minimum of two values.\n+//! * [`Ordering`] is an enum returned by the main functions of [`Ord`] and\n+//!   [`PartialOrd`], and describes an ordering.\n+//! * [`Reverse`] is a struct that allows you to easily reverse an ordering.\n+//! * [`max`] and [`min`] are functions that build off of [`Ord`] and allow you\n+//!   to find the maximum or minimum of two values.\n //!\n //! For more details, see the respective documentation of each item in the list.\n+//!\n+//! [`Eq`]: trait.Eq.html\n+//! [`PartialEq`]: trait.PartialEq.html\n+//! [`Ord`]: trait.Ord.html\n+//! [`PartialOrd`]: trait.PartialOrd.html\n+//! [`Ordering`]: enum.Ordering.html\n+//! [`Reverse`]: struct.Reverse.html\n+//! [`max`]: fn.max.html\n+//! [`min`]: fn.min.html\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n@@ -1012,8 +1020,10 @@ mod impls {\n             impl Ord for $t {\n                 #[inline]\n                 fn cmp(&self, other: &$t) -> Ordering {\n-                    if *self == *other { Equal }\n-                    else if *self < *other { Less }\n+                    // The order here is important to generate more optimal assembly.\n+                    // See <https://github.com/rust-lang/rust/issues/63758> for more info.\n+                    if *self < *other { Less }\n+                    else if *self == *other { Equal }\n                     else { Greater }\n                 }\n             }"}, {"sha": "402a7b2c95a46f1e4638ddb5c4500f1dfd379003", "filename": "src/libcore/convert.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibcore%2Fconvert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibcore%2Fconvert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fconvert.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -104,22 +104,17 @@ pub const fn identity<T>(x: T) -> T { x }\n /// If you need to do a costly conversion it is better to implement [`From`] with type\n /// `&T` or write a custom function.\n ///\n-/// `AsRef` has the same signature as [`Borrow`], but `Borrow` is different in few aspects:\n+/// `AsRef` has the same signature as [`Borrow`], but [`Borrow`] is different in few aspects:\n ///\n-/// - Unlike `AsRef`, `Borrow` has a blanket impl for any `T`, and can be used to accept either\n+/// - Unlike `AsRef`, [`Borrow`] has a blanket impl for any `T`, and can be used to accept either\n ///   a reference or a value.\n-/// - `Borrow` also requires that `Hash`, `Eq` and `Ord` for borrowed value are\n+/// - [`Borrow`] also requires that [`Hash`], [`Eq`] and [`Ord`] for borrowed value are\n ///   equivalent to those of the owned value. For this reason, if you want to\n-///   borrow only a single field of a struct you can implement `AsRef`, but not `Borrow`.\n-///\n-/// [`Borrow`]: ../../std/borrow/trait.Borrow.html\n+///   borrow only a single field of a struct you can implement `AsRef`, but not [`Borrow`].\n ///\n /// **Note: This trait must not fail**. If the conversion can fail, use a\n /// dedicated method which returns an [`Option<T>`] or a [`Result<T, E>`].\n ///\n-/// [`Option<T>`]: ../../std/option/enum.Option.html\n-/// [`Result<T, E>`]: ../../std/result/enum.Result.html\n-///\n /// # Generic Implementations\n ///\n /// - `AsRef` auto-dereferences if the inner type is a reference or a mutable\n@@ -132,9 +127,16 @@ pub const fn identity<T>(x: T) -> T { x }\n /// converted to the specified type `T`.\n ///\n /// For example: By creating a generic function that takes an `AsRef<str>` we express that we\n-/// want to accept all references that can be converted to `&str` as an argument.\n-/// Since both [`String`] and `&str` implement `AsRef<str>` we can accept both as input argument.\n+/// want to accept all references that can be converted to [`&str`] as an argument.\n+/// Since both [`String`] and [`&str`] implement `AsRef<str>` we can accept both as input argument.\n ///\n+/// [`Option<T>`]: ../../std/option/enum.Option.html\n+/// [`Result<T, E>`]: ../../std/result/enum.Result.html\n+/// [`Borrow`]: ../../std/borrow/trait.Borrow.html\n+/// [`Hash`]: ../../std/hash/trait.Hash.html\n+/// [`Eq`]: ../../std/cmp/trait.Eq.html\n+/// [`Ord`]: ../../std/cmp/trait.Ord.html\n+/// [`&str`]: ../../std/primitive.str.html\n /// [`String`]: ../../std/string/struct.String.html\n ///\n /// ```"}, {"sha": "7e35188bc1082e7fbe1e5042b7871851201359bc", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -518,7 +518,8 @@ impl Display for Arguments<'_> {\n     label=\"`{Self}` cannot be formatted using `{{:?}}` because it doesn't implement `{Debug}`\",\n )]\n #[doc(alias = \"{:?}\")]\n-#[lang = \"debug_trait\"]\n+#[cfg_attr(boostrap_stdarch_ignore_this, lang = \"debug_trait\")]\n+#[cfg_attr(not(boostrap_stdarch_ignore_this), rustc_diagnostic_item = \"debug_trait\")]\n pub trait Debug {\n     /// Formats the value using the given formatter.\n     ///"}, {"sha": "6439fa0e0c8b82425762e311bd2a59e2ea57a1ef", "filename": "src/libcore/hint.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibcore%2Fhint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibcore%2Fhint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhint.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -104,11 +104,19 @@ pub fn spin_loop() {\n     }\n }\n \n-/// A function that is opaque to the optimizer, to allow benchmarks to\n-/// pretend to use outputs to assist in avoiding dead-code\n-/// elimination.\n+/// An identity function that *__hints__* to the compiler to be maximally pessimistic about what\n+/// `black_box` could do.\n ///\n-/// This function is a no-op, and does not even read from `dummy`.\n+/// [`std::convert::identity`]: https://doc.rust-lang.org/core/convert/fn.identity.html\n+///\n+/// Unlike [`std::convert::identity`], a Rust compiler is encouraged to assume that `black_box` can\n+/// use `x` in any possible valid way that Rust code is allowed to without introducing undefined\n+/// behavior in the calling code. This property makes `black_box` useful for writing code in which\n+/// certain optimizations are not desired, such as benchmarks.\n+///\n+/// Note however, that `black_box` is only (and can only be) provided on a \"best-effort\" basis. The\n+/// extent to which it can block optimisations may vary depending upon the platform and code-gen\n+/// backend used. Programs cannot rely on `black_box` for *correctness* in any way.\n #[inline]\n #[unstable(feature = \"test\", issue = \"50297\")]\n #[allow(unreachable_code)] // this makes #[cfg] a bit easier below."}, {"sha": "3b8edc2ad61770aa786c86a4ce6b3b00e77abd06", "filename": "src/libcore/iter/adapters/mod.rs", "status": "modified", "additions": 45, "deletions": 10, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -5,7 +5,7 @@ use crate::usize;\n use crate::intrinsics;\n \n use super::{Iterator, DoubleEndedIterator, ExactSizeIterator, FusedIterator, TrustedLen};\n-use super::LoopState;\n+use super::{LoopState, from_fn};\n \n mod chain;\n mod flatten;\n@@ -66,13 +66,6 @@ impl<I> Iterator for Rev<I> where I: DoubleEndedIterator {\n     {\n         self.iter.rfind(predicate)\n     }\n-\n-    #[inline]\n-    fn rposition<P>(&mut self, predicate: P) -> Option<usize> where\n-        P: FnMut(Self::Item) -> bool\n-    {\n-        self.iter.position(predicate)\n-    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -541,6 +534,26 @@ impl<I> Iterator for StepBy<I> where I: Iterator {\n             self.iter.nth(nth - 1);\n         }\n     }\n+\n+    fn try_fold<Acc, F, R>(&mut self, mut acc: Acc, mut f: F) -> R\n+    where\n+        F: FnMut(Acc, Self::Item) -> R,\n+        R: Try<Ok = Acc>,\n+    {\n+        #[inline]\n+        fn nth<I: Iterator>(iter: &mut I, step: usize) -> impl FnMut() -> Option<I::Item> + '_ {\n+            move || iter.nth(step)\n+        }\n+\n+        if self.first_take {\n+            self.first_take = false;\n+            match self.iter.next() {\n+                None => return Try::from_ok(acc),\n+                Some(x) => acc = f(acc, x)?,\n+            }\n+        }\n+        from_fn(nth(&mut self.iter, self.step)).try_fold(acc, f)\n+    }\n }\n \n impl<I> StepBy<I> where I: ExactSizeIterator {\n@@ -574,6 +587,28 @@ impl<I> DoubleEndedIterator for StepBy<I> where I: DoubleEndedIterator + ExactSi\n             .saturating_add(self.next_back_index());\n         self.iter.nth_back(n)\n     }\n+\n+    fn try_rfold<Acc, F, R>(&mut self, init: Acc, mut f: F) -> R\n+    where\n+        F: FnMut(Acc, Self::Item) -> R,\n+        R: Try<Ok = Acc>,\n+    {\n+        #[inline]\n+        fn nth_back<I: DoubleEndedIterator>(\n+            iter: &mut I,\n+            step: usize,\n+        ) -> impl FnMut() -> Option<I::Item> + '_ {\n+            move || iter.nth_back(step)\n+        }\n+\n+        match self.next_back() {\n+            None => Try::from_ok(init),\n+            Some(x) => {\n+                let acc = f(init, x)?;\n+                from_fn(nth_back(&mut self.iter, self.step)).try_fold(acc, f)\n+            }\n+        }\n+    }\n }\n \n // StepBy can only make the iterator shorter, so the len will still fit.\n@@ -1309,7 +1344,7 @@ impl<I> DoubleEndedIterator for Peekable<I> where I: DoubleEndedIterator {\n         Self: Sized, F: FnMut(B, Self::Item) -> R, R: Try<Ok=B>\n     {\n         match self.peeked.take() {\n-            Some(None) => return Try::from_ok(init),\n+            Some(None) => Try::from_ok(init),\n             Some(Some(v)) => match self.iter.try_rfold(init, &mut f).into_result() {\n                 Ok(acc) => f(acc, v),\n                 Err(e) => {\n@@ -1326,7 +1361,7 @@ impl<I> DoubleEndedIterator for Peekable<I> where I: DoubleEndedIterator {\n         where Fold: FnMut(Acc, Self::Item) -> Acc,\n     {\n         match self.peeked {\n-            Some(None) => return init,\n+            Some(None) => init,\n             Some(Some(v)) => {\n                 let acc = self.iter.rfold(init, &mut fold);\n                 fold(acc, v)"}, {"sha": "c09df3f7f22cbd8c650cf85a33a93fe5c77061ff", "filename": "src/libcore/iter/traits/iterator.rs", "status": "modified", "additions": 183, "deletions": 6, "changes": 189, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -2546,11 +2546,51 @@ pub trait Iterator {\n \n     /// Lexicographically compares the elements of this `Iterator` with those\n     /// of another.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::cmp::Ordering;\n+    ///\n+    /// assert_eq!([1].iter().cmp([1].iter()), Ordering::Equal);\n+    /// assert_eq!([1].iter().cmp([1, 2].iter()), Ordering::Less);\n+    /// assert_eq!([1, 2].iter().cmp([1].iter()), Ordering::Greater);\n+    /// ```\n     #[stable(feature = \"iter_order\", since = \"1.5.0\")]\n-    fn cmp<I>(mut self, other: I) -> Ordering where\n+    fn cmp<I>(self, other: I) -> Ordering\n+    where\n         I: IntoIterator<Item = Self::Item>,\n         Self::Item: Ord,\n         Self: Sized,\n+    {\n+        self.cmp_by(other, |x, y| x.cmp(&y))\n+    }\n+\n+    /// Lexicographically compares the elements of this `Iterator` with those\n+    /// of another with respect to the specified comparison function.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// #![feature(iter_order_by)]\n+    ///\n+    /// use std::cmp::Ordering;\n+    ///\n+    /// let xs = [1, 2, 3, 4];\n+    /// let ys = [1, 4, 9, 16];\n+    ///\n+    /// assert_eq!(xs.iter().cmp_by(&ys, |&x, &y| x.cmp(&y)), Ordering::Less);\n+    /// assert_eq!(xs.iter().cmp_by(&ys, |&x, &y| (x * x).cmp(&y)), Ordering::Equal);\n+    /// assert_eq!(xs.iter().cmp_by(&ys, |&x, &y| (2 * x).cmp(&y)), Ordering::Greater);\n+    /// ```\n+    #[unstable(feature = \"iter_order_by\", issue = \"0\")]\n+    fn cmp_by<I, F>(mut self, other: I, mut cmp: F) -> Ordering\n+    where\n+        Self: Sized,\n+        I: IntoIterator,\n+        F: FnMut(Self::Item, I::Item) -> Ordering,\n     {\n         let mut other = other.into_iter();\n \n@@ -2569,7 +2609,7 @@ pub trait Iterator {\n                 Some(val) => val,\n             };\n \n-            match x.cmp(&y) {\n+            match cmp(x, y) {\n                 Ordering::Equal => (),\n                 non_eq => return non_eq,\n             }\n@@ -2578,11 +2618,62 @@ pub trait Iterator {\n \n     /// Lexicographically compares the elements of this `Iterator` with those\n     /// of another.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::cmp::Ordering;\n+    ///\n+    /// assert_eq!([1.].iter().partial_cmp([1.].iter()), Some(Ordering::Equal));\n+    /// assert_eq!([1.].iter().partial_cmp([1., 2.].iter()), Some(Ordering::Less));\n+    /// assert_eq!([1., 2.].iter().partial_cmp([1.].iter()), Some(Ordering::Greater));\n+    ///\n+    /// assert_eq!([std::f64::NAN].iter().partial_cmp([1.].iter()), None);\n+    /// ```\n     #[stable(feature = \"iter_order\", since = \"1.5.0\")]\n-    fn partial_cmp<I>(mut self, other: I) -> Option<Ordering> where\n+    fn partial_cmp<I>(self, other: I) -> Option<Ordering>\n+    where\n         I: IntoIterator,\n         Self::Item: PartialOrd<I::Item>,\n         Self: Sized,\n+    {\n+        self.partial_cmp_by(other, |x, y| x.partial_cmp(&y))\n+    }\n+\n+    /// Lexicographically compares the elements of this `Iterator` with those\n+    /// of another with respect to the specified comparison function.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// #![feature(iter_order_by)]\n+    ///\n+    /// use std::cmp::Ordering;\n+    ///\n+    /// let xs = [1.0, 2.0, 3.0, 4.0];\n+    /// let ys = [1.0, 4.0, 9.0, 16.0];\n+    ///\n+    /// assert_eq!(\n+    ///     xs.iter().partial_cmp_by(&ys, |&x, &y| x.partial_cmp(&y)),\n+    ///     Some(Ordering::Less)\n+    /// );\n+    /// assert_eq!(\n+    ///     xs.iter().partial_cmp_by(&ys, |&x, &y| (x * x).partial_cmp(&y)),\n+    ///     Some(Ordering::Equal)\n+    /// );\n+    /// assert_eq!(\n+    ///     xs.iter().partial_cmp_by(&ys, |&x, &y| (2.0 * x).partial_cmp(&y)),\n+    ///     Some(Ordering::Greater)\n+    /// );\n+    /// ```\n+    #[unstable(feature = \"iter_order_by\", issue = \"0\")]\n+    fn partial_cmp_by<I, F>(mut self, other: I, mut partial_cmp: F) -> Option<Ordering>\n+    where\n+        Self: Sized,\n+        I: IntoIterator,\n+        F: FnMut(Self::Item, I::Item) -> Option<Ordering>,\n     {\n         let mut other = other.into_iter();\n \n@@ -2601,7 +2692,7 @@ pub trait Iterator {\n                 Some(val) => val,\n             };\n \n-            match x.partial_cmp(&y) {\n+            match partial_cmp(x, y) {\n                 Some(Ordering::Equal) => (),\n                 non_eq => return non_eq,\n             }\n@@ -2610,11 +2701,44 @@ pub trait Iterator {\n \n     /// Determines if the elements of this `Iterator` are equal to those of\n     /// another.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// assert_eq!([1].iter().eq([1].iter()), true);\n+    /// assert_eq!([1].iter().eq([1, 2].iter()), false);\n+    /// ```\n     #[stable(feature = \"iter_order\", since = \"1.5.0\")]\n-    fn eq<I>(mut self, other: I) -> bool where\n+    fn eq<I>(self, other: I) -> bool\n+    where\n         I: IntoIterator,\n         Self::Item: PartialEq<I::Item>,\n         Self: Sized,\n+    {\n+        self.eq_by(other, |x, y| x == y)\n+    }\n+\n+    /// Determines if the elements of this `Iterator` are equal to those of\n+    /// another with respect to the specified equality function.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// #![feature(iter_order_by)]\n+    ///\n+    /// let xs = [1, 2, 3, 4];\n+    /// let ys = [1, 4, 9, 16];\n+    ///\n+    /// assert!(xs.iter().eq_by(&ys, |&x, &y| x * x == y));\n+    /// ```\n+    #[unstable(feature = \"iter_order_by\", issue = \"0\")]\n+    fn eq_by<I, F>(mut self, other: I, mut eq: F) -> bool\n+    where\n+        Self: Sized,\n+        I: IntoIterator,\n+        F: FnMut(Self::Item, I::Item) -> bool,\n     {\n         let mut other = other.into_iter();\n \n@@ -2629,12 +2753,21 @@ pub trait Iterator {\n                 Some(val) => val,\n             };\n \n-            if x != y { return false }\n+            if !eq(x, y) {\n+                return false;\n+            }\n         }\n     }\n \n     /// Determines if the elements of this `Iterator` are unequal to those of\n     /// another.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// assert_eq!([1].iter().ne([1].iter()), false);\n+    /// assert_eq!([1].iter().ne([1, 2].iter()), true);\n+    /// ```\n     #[stable(feature = \"iter_order\", since = \"1.5.0\")]\n     fn ne<I>(self, other: I) -> bool where\n         I: IntoIterator,\n@@ -2646,6 +2779,14 @@ pub trait Iterator {\n \n     /// Determines if the elements of this `Iterator` are lexicographically\n     /// less than those of another.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// assert_eq!([1].iter().lt([1].iter()), false);\n+    /// assert_eq!([1].iter().lt([1, 2].iter()), true);\n+    /// assert_eq!([1, 2].iter().lt([1].iter()), false);\n+    /// ```\n     #[stable(feature = \"iter_order\", since = \"1.5.0\")]\n     fn lt<I>(self, other: I) -> bool where\n         I: IntoIterator,\n@@ -2657,6 +2798,14 @@ pub trait Iterator {\n \n     /// Determines if the elements of this `Iterator` are lexicographically\n     /// less or equal to those of another.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// assert_eq!([1].iter().le([1].iter()), true);\n+    /// assert_eq!([1].iter().le([1, 2].iter()), true);\n+    /// assert_eq!([1, 2].iter().le([1].iter()), false);\n+    /// ```\n     #[stable(feature = \"iter_order\", since = \"1.5.0\")]\n     fn le<I>(self, other: I) -> bool where\n         I: IntoIterator,\n@@ -2671,6 +2820,14 @@ pub trait Iterator {\n \n     /// Determines if the elements of this `Iterator` are lexicographically\n     /// greater than those of another.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// assert_eq!([1].iter().gt([1].iter()), false);\n+    /// assert_eq!([1].iter().gt([1, 2].iter()), false);\n+    /// assert_eq!([1, 2].iter().gt([1].iter()), true);\n+    /// ```\n     #[stable(feature = \"iter_order\", since = \"1.5.0\")]\n     fn gt<I>(self, other: I) -> bool where\n         I: IntoIterator,\n@@ -2682,6 +2839,14 @@ pub trait Iterator {\n \n     /// Determines if the elements of this `Iterator` are lexicographically\n     /// greater than or equal to those of another.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// assert_eq!([1].iter().ge([1].iter()), true);\n+    /// assert_eq!([1].iter().ge([1, 2].iter()), false);\n+    /// assert_eq!([1, 2].iter().ge([1].iter()), true);\n+    /// ```\n     #[stable(feature = \"iter_order\", since = \"1.5.0\")]\n     fn ge<I>(self, other: I) -> bool where\n         I: IntoIterator,\n@@ -2730,6 +2895,18 @@ pub trait Iterator {\n     /// function to determine the ordering of two elements. Apart from that, it's equivalent to\n     /// [`is_sorted`]; see its documentation for more information.\n     ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(is_sorted)]\n+    ///\n+    /// assert!([1, 2, 2, 9].iter().is_sorted_by(|a, b| a.partial_cmp(b)));\n+    /// assert!(![1, 3, 2, 4].iter().is_sorted_by(|a, b| a.partial_cmp(b)));\n+    /// assert!([0].iter().is_sorted_by(|a, b| a.partial_cmp(b)));\n+    /// assert!(std::iter::empty::<i32>().is_sorted_by(|a, b| a.partial_cmp(b)));\n+    /// assert!(![0.0, 1.0, std::f32::NAN].iter().is_sorted_by(|a, b| a.partial_cmp(b)));\n+    /// ```\n+    ///\n     /// [`is_sorted`]: trait.Iterator.html#method.is_sorted\n     #[unstable(feature = \"is_sorted\", reason = \"new API\", issue = \"53485\")]\n     fn is_sorted_by<F>(mut self, mut compare: F) -> bool"}, {"sha": "a2cc585fc51fd3ae11a246c7306eb03197b02c41", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -87,7 +87,7 @@\n #![feature(link_llvm_intrinsics)]\n #![feature(never_type)]\n #![feature(nll)]\n-#![feature(bind_by_move_pattern_guards)]\n+#![cfg_attr(boostrap_stdarch_ignore_this, feature(bind_by_move_pattern_guards))]\n #![feature(exhaustive_patterns)]\n #![feature(no_core)]\n #![feature(on_unimplemented)]\n@@ -227,6 +227,7 @@ pub mod task;\n pub mod alloc;\n \n // note: does not need to be public\n+mod bool;\n mod tuple;\n mod unit;\n "}, {"sha": "384bc87499887ad84542a5fd8573e3722b393ff0", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -734,7 +734,6 @@ pub(crate) mod builtin {\n     #[allow_internal_unstable(fmt_internals)]\n     #[rustc_builtin_macro]\n     #[macro_export]\n-    #[rustc_macro_transparency = \"opaque\"]\n     macro_rules! format_args {\n         ($fmt:expr) => ({ /* compiler built-in */ });\n         ($fmt:expr, $($args:tt)*) => ({ /* compiler built-in */ })\n@@ -747,7 +746,6 @@ pub(crate) mod builtin {\n     #[allow_internal_unstable(fmt_internals)]\n     #[rustc_builtin_macro]\n     #[macro_export]\n-    #[rustc_macro_transparency = \"opaque\"]\n     macro_rules! format_args_nl {\n         ($fmt:expr) => ({ /* compiler built-in */ });\n         ($fmt:expr, $($args:tt)*) => ({ /* compiler built-in */ })\n@@ -1235,42 +1233,38 @@ pub(crate) mod builtin {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[allow_internal_unstable(test, rustc_attrs)]\n     #[rustc_builtin_macro]\n-    #[rustc_macro_transparency = \"semitransparent\"]\n     pub macro test($item:item) { /* compiler built-in */ }\n \n     /// Attribute macro applied to a function to turn it into a benchmark test.\n-    #[unstable(feature = \"test\", issue = \"50297\",\n-               reason = \"`bench` is a part of custom test frameworks which are unstable\")]\n+    #[cfg_attr(not(boostrap_stdarch_ignore_this), unstable(soft, feature = \"test\", issue = \"50297\",\n+               reason = \"`bench` is a part of custom test frameworks which are unstable\"))]\n+    #[cfg_attr(boostrap_stdarch_ignore_this, unstable(feature = \"test\", issue = \"50297\",\n+               reason = \"`bench` is a part of custom test frameworks which are unstable\"))]\n     #[allow_internal_unstable(test, rustc_attrs)]\n     #[rustc_builtin_macro]\n-    #[rustc_macro_transparency = \"semitransparent\"]\n     pub macro bench($item:item) { /* compiler built-in */ }\n \n     /// An implementation detail of the `#[test]` and `#[bench]` macros.\n     #[unstable(feature = \"custom_test_frameworks\", issue = \"50297\",\n                reason = \"custom test frameworks are an unstable feature\")]\n     #[allow_internal_unstable(test, rustc_attrs)]\n     #[rustc_builtin_macro]\n-    #[rustc_macro_transparency = \"semitransparent\"]\n     pub macro test_case($item:item) { /* compiler built-in */ }\n \n     /// Attribute macro applied to a static to register it as a global allocator.\n     #[stable(feature = \"global_allocator\", since = \"1.28.0\")]\n     #[allow_internal_unstable(rustc_attrs)]\n     #[rustc_builtin_macro]\n-    #[rustc_macro_transparency = \"semitransparent\"]\n     pub macro global_allocator($item:item) { /* compiler built-in */ }\n \n     /// Unstable implementation detail of the `rustc` compiler, do not use.\n     #[rustc_builtin_macro]\n-    #[cfg_attr(boostrap_stdarch_ignore_this, rustc_macro_transparency = \"semitransparent\")]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[allow_internal_unstable(core_intrinsics, libstd_sys_internals)]\n     pub macro RustcDecodable($item:item) { /* compiler built-in */ }\n \n     /// Unstable implementation detail of the `rustc` compiler, do not use.\n     #[rustc_builtin_macro]\n-    #[cfg_attr(boostrap_stdarch_ignore_this, rustc_macro_transparency = \"semitransparent\")]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[allow_internal_unstable(core_intrinsics)]\n     pub macro RustcEncodable($item:item) { /* compiler built-in */ }"}, {"sha": "22e7573eca65b28c5693df365dc17af90fa5ed32", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -315,7 +315,7 @@ impl f32 {\n     /// use std::f32;\n     ///\n     /// let x = 2.0_f32;\n-    /// let abs_difference = (x.recip() - (1.0/x)).abs();\n+    /// let abs_difference = (x.recip() - (1.0 / x)).abs();\n     ///\n     /// assert!(abs_difference <= f32::EPSILON);\n     /// ```"}, {"sha": "bbe1d040780602df44831bab76ff835a01da7898", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -327,7 +327,7 @@ impl f64 {\n     ///\n     /// ```\n     /// let x = 2.0_f64;\n-    /// let abs_difference = (x.recip() - (1.0/x)).abs();\n+    /// let abs_difference = (x.recip() - (1.0 / x)).abs();\n     ///\n     /// assert!(abs_difference < 1e-10);\n     /// ```"}, {"sha": "df1c00ccd184f17e7c4cdf9004b8eff68ad95ef9", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 9, "deletions": 21, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -1401,12 +1401,8 @@ $EndFeature, \"\n ```\"),\n             #[stable(feature = \"no_panic_abs\", since = \"1.13.0\")]\n             #[inline]\n-            pub fn wrapping_abs(self) -> Self {\n-                if self.is_negative() {\n-                    self.wrapping_neg()\n-                } else {\n-                    self\n-                }\n+            pub const fn wrapping_abs(self) -> Self {\n+                (self ^ (self >> ($BITS - 1))).wrapping_sub(self >> ($BITS - 1))\n             }\n         }\n \n@@ -1764,12 +1760,8 @@ $EndFeature, \"\n ```\"),\n             #[stable(feature = \"no_panic_abs\", since = \"1.13.0\")]\n             #[inline]\n-            pub fn overflowing_abs(self) -> (Self, bool) {\n-                if self.is_negative() {\n-                    self.overflowing_neg()\n-                } else {\n-                    (self, false)\n-                }\n+            pub const fn overflowing_abs(self) -> (Self, bool) {\n+                (self ^ (self >> ($BITS - 1))).overflowing_sub(self >> ($BITS - 1))\n             }\n         }\n \n@@ -1973,15 +1965,11 @@ $EndFeature, \"\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             #[inline]\n             #[rustc_inherit_overflow_checks]\n-            pub fn abs(self) -> Self {\n-                if self.is_negative() {\n-                    // Note that the #[inline] above means that the overflow\n-                    // semantics of this negation depend on the crate we're being\n-                    // inlined into.\n-                    -self\n-                } else {\n-                    self\n-                }\n+            pub const fn abs(self) -> Self {\n+                // Note that the #[inline] above means that the overflow\n+                // semantics of the subtraction depend on the crate we're being\n+                // inlined into.\n+                (self ^ (self >> ($BITS - 1))) - (self >> ($BITS - 1))\n             }\n         }\n "}, {"sha": "59a10ae99bb6aa5bff9c66a5ebe3b2520a22a807", "filename": "src/libcore/num/wrapping.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibcore%2Fnum%2Fwrapping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibcore%2Fnum%2Fwrapping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fwrapping.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -18,6 +18,8 @@ macro_rules! sh_impl_signed {\n                 }\n             }\n         }\n+        forward_ref_binop! { impl Shl, shl for Wrapping<$t>, $f,\n+                #[stable(feature = \"wrapping_ref_ops\", since = \"1.39.0\")] }\n \n         #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n         impl ShlAssign<$f> for Wrapping<$t> {\n@@ -41,6 +43,8 @@ macro_rules! sh_impl_signed {\n                 }\n             }\n         }\n+        forward_ref_binop! { impl Shr, shr for Wrapping<$t>, $f,\n+                #[stable(feature = \"wrapping_ref_ops\", since = \"1.39.0\")] }\n \n         #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n         impl ShrAssign<$f> for Wrapping<$t> {\n@@ -64,6 +68,8 @@ macro_rules! sh_impl_unsigned {\n                 Wrapping(self.0.wrapping_shl((other & self::shift_max::$t as $f) as u32))\n             }\n         }\n+        forward_ref_binop! { impl Shl, shl for Wrapping<$t>, $f,\n+                #[stable(feature = \"wrapping_ref_ops\", since = \"1.39.0\")] }\n \n         #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n         impl ShlAssign<$f> for Wrapping<$t> {\n@@ -83,6 +89,8 @@ macro_rules! sh_impl_unsigned {\n                 Wrapping(self.0.wrapping_shr((other & self::shift_max::$t as $f) as u32))\n             }\n         }\n+        forward_ref_binop! { impl Shr, shr for Wrapping<$t>, $f,\n+                #[stable(feature = \"wrapping_ref_ops\", since = \"1.39.0\")] }\n \n         #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n         impl ShrAssign<$f> for Wrapping<$t> {"}, {"sha": "4a0a2720fe44161116254e719ffc8403423606bf", "filename": "src/libcore/ops/function.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibcore%2Fops%2Ffunction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibcore%2Fops%2Ffunction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Ffunction.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -185,14 +185,6 @@ pub trait FnMut<Args> : FnOnce<Args> {\n ///\n /// # Examples\n ///\n-/// ## Calling a by-value closure\n-///\n-/// ```\n-/// let x = 5;\n-/// let square_x = move || x * x;\n-/// assert_eq!(square_x(), 25);\n-/// ```\n-///\n /// ## Using a `FnOnce` parameter\n ///\n /// ```"}, {"sha": "79bd04b724390dd297b859fe367b8f5b93838e13", "filename": "src/libcore/option.rs", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -1110,6 +1110,18 @@ impl<T: Deref> Option<T> {\n     /// to the original one, additionally coercing the contents via [`Deref`].\n     ///\n     /// [`Deref`]: ../../std/ops/trait.Deref.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(inner_deref)]\n+    ///\n+    /// let x: Option<String> = Some(\"hey\".to_owned());\n+    /// assert_eq!(x.as_deref(), Some(\"hey\"));\n+    ///\n+    /// let x: Option<String> = None;\n+    /// assert_eq!(x.as_deref(), None);\n+    /// ```\n     pub fn as_deref(&self) -> Option<&T::Target> {\n         self.as_ref().map(|t| t.deref())\n     }\n@@ -1121,6 +1133,18 @@ impl<T: DerefMut> Option<T> {\n     ///\n     /// Leaves the original `Option` in-place, creating a new one containing a mutable reference to\n     /// the inner type's `Deref::Target` type.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(inner_deref)]\n+    ///\n+    /// let mut x: Option<String> = Some(\"hey\".to_owned());\n+    /// assert_eq!(x.as_deref_mut().map(|x| {\n+    ///     x.make_ascii_uppercase();\n+    ///     x\n+    /// }), Some(\"HEY\".to_owned().as_mut_str()));\n+    /// ```\n     pub fn as_deref_mut(&mut self) -> Option<&mut T::Target> {\n         self.as_mut().map(|t| t.deref_mut())\n     }\n@@ -1199,6 +1223,13 @@ impl<T: Clone> Clone for Option<T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Default for Option<T> {\n     /// Returns [`None`][Option::None].\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let opt: Option<u32> = Option::default();\n+    /// assert!(opt.is_none());\n+    /// ```\n     #[inline]\n     fn default() -> Option<T> { None }\n }"}, {"sha": "1080fd32a8862dd697dee5ca4cca6212db7ec553", "filename": "src/libcore/pin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibcore%2Fpin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibcore%2Fpin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpin.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -462,7 +462,7 @@ impl<P: Deref<Target: Unpin>> Pin<P> {\n     /// can ignore the pinning invariants when unwrapping it.\n     ///\n     /// [`Unpin`]: ../../std/marker/trait.Unpin.html\n-    #[unstable(feature = \"pin_into_inner\", issue = \"60245\")]\n+    #[stable(feature = \"pin_into_inner\", since = \"1.39.0\")]\n     #[inline(always)]\n     pub fn into_inner(pin: Pin<P>) -> P {\n         pin.pointer\n@@ -569,7 +569,7 @@ impl<P: Deref> Pin<P> {\n     ///\n     /// [`Unpin`]: ../../std/marker/trait.Unpin.html\n     /// [`Pin::into_inner`]: #method.into_inner\n-    #[unstable(feature = \"pin_into_inner\", issue = \"60245\")]\n+    #[stable(feature = \"pin_into_inner\", since = \"1.39.0\")]\n     #[inline(always)]\n     pub unsafe fn into_inner_unchecked(pin: Pin<P>) -> P {\n         pin.pointer"}, {"sha": "ed40a5f31d9bd75105b25c289407e86d62b2516d", "filename": "src/libcore/result.rs", "status": "modified", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -820,6 +820,87 @@ impl<T, E> Result<T, E> {\n     }\n }\n \n+impl<T: Copy, E> Result<&T, E> {\n+    /// Maps a `Result<&T, E>` to a `Result<T, E>` by copying the contents of the\n+    /// `Ok` part.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(result_copied)]\n+    /// let val = 12;\n+    /// let x: Result<&i32, i32> = Ok(&val);\n+    /// assert_eq!(x, Ok(&12));\n+    /// let copied = x.copied();\n+    /// assert_eq!(copied, Ok(12));\n+    /// ```\n+    #[unstable(feature = \"result_copied\", reason = \"newly added\", issue = \"63168\")]\n+    pub fn copied(self) -> Result<T, E> {\n+        self.map(|&t| t)\n+    }\n+}\n+\n+impl<T: Copy, E> Result<&mut T, E> {\n+    /// Maps a `Result<&mut T, E>` to a `Result<T, E>` by copying the contents of the\n+    /// `Ok` part.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(result_copied)]\n+    /// let mut val = 12;\n+    /// let x: Result<&mut i32, i32> = Ok(&mut val);\n+    /// assert_eq!(x, Ok(&mut 12));\n+    /// let copied = x.copied();\n+    /// assert_eq!(copied, Ok(12));\n+    /// ```\n+    #[unstable(feature = \"result_copied\", reason = \"newly added\", issue = \"63168\")]\n+    pub fn copied(self) -> Result<T, E> {\n+        self.map(|&mut t| t)\n+    }\n+}\n+\n+impl<T: Clone, E> Result<&T, E> {\n+    /// Maps a `Result<&T, E>` to a `Result<T, E>` by cloning the contents of the\n+    /// `Ok` part.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(result_cloned)]\n+    /// let val = 12;\n+    /// let x: Result<&i32, i32> = Ok(&val);\n+    /// assert_eq!(x, Ok(&12));\n+    /// let cloned = x.cloned();\n+    /// assert_eq!(cloned, Ok(12));\n+    /// ```\n+    #[unstable(feature = \"result_cloned\", reason = \"newly added\", issue = \"63168\")]\n+    pub fn cloned(self) -> Result<T, E> {\n+        self.map(|t| t.clone())\n+    }\n+}\n+\n+impl<T: Clone, E> Result<&mut T, E> {\n+    /// Maps a `Result<&mut T, E>` to a `Result<T, E>` by cloning the contents of the\n+    /// `Ok` part.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(result_cloned)]\n+    /// let mut val = 12;\n+    /// let x: Result<&mut i32, i32> = Ok(&mut val);\n+    /// assert_eq!(x, Ok(&mut 12));\n+    /// let cloned = x.cloned();\n+    /// assert_eq!(cloned, Ok(12));\n+    /// ```\n+    #[unstable(feature = \"result_cloned\", reason = \"newly added\", issue = \"63168\")]\n+    pub fn cloned(self) -> Result<T, E> {\n+        self.map(|t| t.clone())\n+    }\n+}\n+\n+\n impl<T, E: fmt::Debug> Result<T, E> {\n     /// Unwraps a result, yielding the content of an [`Ok`].\n     ///"}, {"sha": "931768564ca3cf8c5a34fca6a14e376567c4f1eb", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -3026,8 +3026,7 @@ macro_rules! len {\n         if size == 0 {\n             // This _cannot_ use `unchecked_sub` because we depend on wrapping\n             // to represent the length of long ZST slice iterators.\n-            let diff = ($self.end as usize).wrapping_sub(start as usize);\n-            diff\n+            ($self.end as usize).wrapping_sub(start as usize)\n         } else {\n             // We know that `start <= end`, so can do better than `offset_from`,\n             // which needs to deal in signed.  By setting appropriate flags here"}, {"sha": "5e5b5593fd8a7d19fa949d5ab2a9cbe8c19f7033", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -2170,6 +2170,7 @@ impl str {\n     #[inline(always)]\n     #[rustc_const_unstable(feature=\"const_str_as_bytes\")]\n     pub const fn as_bytes(&self) -> &[u8] {\n+        #[repr(C)]\n         union Slices<'a> {\n             str: &'a str,\n             slice: &'a [u8],\n@@ -3557,7 +3558,7 @@ impl str {\n     /// A string is a sequence of bytes. `start` in this context means the first\n     /// position of that byte string; for a left-to-right language like English or\n     /// Russian, this will be left side, and for right-to-left languages like\n-    /// like Arabic or Hebrew, this will be the right side.\n+    /// Arabic or Hebrew, this will be the right side.\n     ///\n     /// # Examples\n     ///\n@@ -3594,7 +3595,7 @@ impl str {\n     /// A string is a sequence of bytes. `end` in this context means the last\n     /// position of that byte string; for a left-to-right language like English or\n     /// Russian, this will be right side, and for right-to-left languages like\n-    /// like Arabic or Hebrew, this will be the left side.\n+    /// Arabic or Hebrew, this will be the left side.\n     ///\n     /// # Examples\n     ///\n@@ -3761,7 +3762,7 @@ impl str {\n     /// A string is a sequence of bytes. `start` in this context means the first\n     /// position of that byte string; for a left-to-right language like English or\n     /// Russian, this will be left side, and for right-to-left languages like\n-    /// like Arabic or Hebrew, this will be the right side.\n+    /// Arabic or Hebrew, this will be the right side.\n     ///\n     /// # Examples\n     ///\n@@ -3800,7 +3801,7 @@ impl str {\n     /// A string is a sequence of bytes. `end` in this context means the last\n     /// position of that byte string; for a left-to-right language like English or\n     /// Russian, this will be right side, and for right-to-left languages like\n-    /// like Arabic or Hebrew, this will be the left side.\n+    /// Arabic or Hebrew, this will be the left side.\n     ///\n     /// # Examples\n     ///"}, {"sha": "0f1e6e89451e9b4294a6aad180c3250e623f2122", "filename": "src/libcore/tests/bool.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibcore%2Ftests%2Fbool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibcore%2Ftests%2Fbool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fbool.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -0,0 +1,7 @@\n+#[test]\n+fn test_bool_to_option() {\n+    assert_eq!(false.then(0), None);\n+    assert_eq!(true.then(0), Some(0));\n+    assert_eq!(false.then_with(|| 0), None);\n+    assert_eq!(true.then_with(|| 0), Some(0));\n+}"}, {"sha": "c9096b713f20ec42b532913a6eba398888140b4e", "filename": "src/libcore/tests/iter.rs", "status": "modified", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibcore%2Ftests%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibcore%2Ftests%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fiter.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -57,6 +57,62 @@ fn test_multi_iter() {\n     assert!(xs.iter().lt(xs.iter().skip(2)));\n }\n \n+#[test]\n+fn test_cmp_by() {\n+    use core::cmp::Ordering;\n+\n+    let f = |x: i32, y: i32| (x * x).cmp(&y);\n+    let xs = || [1, 2, 3, 4].iter().copied();\n+    let ys = || [1, 4, 16].iter().copied();\n+\n+    assert_eq!(xs().cmp_by(ys(), f), Ordering::Less);\n+    assert_eq!(ys().cmp_by(xs(), f), Ordering::Greater);\n+    assert_eq!(xs().cmp_by(xs().map(|x| x * x), f), Ordering::Equal);\n+    assert_eq!(xs().rev().cmp_by(ys().rev(), f), Ordering::Greater);\n+    assert_eq!(xs().cmp_by(ys().rev(), f), Ordering::Less);\n+    assert_eq!(xs().cmp_by(ys().take(2), f), Ordering::Greater);\n+}\n+\n+#[test]\n+fn test_partial_cmp_by() {\n+    use core::cmp::Ordering;\n+    use core::f64;\n+\n+    let f = |x: i32, y: i32| (x * x).partial_cmp(&y);\n+    let xs = || [1, 2, 3, 4].iter().copied();\n+    let ys = || [1, 4, 16].iter().copied();\n+\n+    assert_eq!(xs().partial_cmp_by(ys(), f), Some(Ordering::Less));\n+    assert_eq!(ys().partial_cmp_by(xs(), f), Some(Ordering::Greater));\n+    assert_eq!(xs().partial_cmp_by(xs().map(|x| x * x), f), Some(Ordering::Equal));\n+    assert_eq!(xs().rev().partial_cmp_by(ys().rev(), f), Some(Ordering::Greater));\n+    assert_eq!(xs().partial_cmp_by(xs().rev(), f), Some(Ordering::Less));\n+    assert_eq!(xs().partial_cmp_by(ys().take(2), f), Some(Ordering::Greater));\n+\n+    let f = |x: f64, y: f64| (x * x).partial_cmp(&y);\n+    let xs = || [1.0, 2.0, 3.0, 4.0].iter().copied();\n+    let ys = || [1.0, 4.0, f64::NAN, 16.0].iter().copied();\n+\n+    assert_eq!(xs().partial_cmp_by(ys(), f), None);\n+    assert_eq!(ys().partial_cmp_by(xs(), f), Some(Ordering::Greater));\n+}\n+\n+#[test]\n+fn test_eq_by() {\n+    let f = |x: i32, y: i32| x * x == y;\n+    let xs = || [1, 2, 3, 4].iter().copied();\n+    let ys = || [1, 4, 9, 16].iter().copied();\n+\n+    assert!(xs().eq_by(ys(), f));\n+    assert!(!ys().eq_by(xs(), f));\n+    assert!(!xs().eq_by(xs(), f));\n+    assert!(!ys().eq_by(ys(), f));\n+\n+    assert!(!xs().take(3).eq_by(ys(), f));\n+    assert!(!xs().eq_by(ys().take(3), f));\n+    assert!(xs().take(3).eq_by(ys().take(3), f));\n+}\n+\n #[test]\n fn test_counter_from_iter() {\n     let it = (0..).step_by(5).take(10);\n@@ -329,6 +385,23 @@ fn test_iterator_step_by_nth_overflow() {\n     assert_eq!(it.0, (usize::MAX as Bigger) * 1);\n }\n \n+#[test]\n+fn test_iterator_step_by_nth_try_fold() {\n+    let mut it = (0..).step_by(10);\n+    assert_eq!(it.try_fold(0, i8::checked_add), None);\n+    assert_eq!(it.next(), Some(60));\n+    assert_eq!(it.try_fold(0, i8::checked_add), None);\n+    assert_eq!(it.next(), Some(90));\n+\n+    let mut it = (100..).step_by(10);\n+    assert_eq!(it.try_fold(50, i8::checked_add), None);\n+    assert_eq!(it.next(), Some(110));\n+\n+    let mut it = (100..=100).step_by(10);\n+    assert_eq!(it.next(), Some(100));\n+    assert_eq!(it.try_fold(0, i8::checked_add), Some(0));\n+}\n+\n #[test]\n fn test_iterator_step_by_nth_back() {\n     let mut it = (0..16).step_by(5);\n@@ -354,6 +427,24 @@ fn test_iterator_step_by_nth_back() {\n     assert_eq!(it().nth_back(42), None);\n }\n \n+#[test]\n+fn test_iterator_step_by_nth_try_rfold() {\n+    let mut it = (0..100).step_by(10);\n+    assert_eq!(it.try_rfold(0, i8::checked_add), None);\n+    assert_eq!(it.next_back(), Some(70));\n+    assert_eq!(it.next(), Some(0));\n+    assert_eq!(it.try_rfold(0, i8::checked_add), None);\n+    assert_eq!(it.next_back(), Some(30));\n+\n+    let mut it = (0..100).step_by(10);\n+    assert_eq!(it.try_rfold(50, i8::checked_add), None);\n+    assert_eq!(it.next_back(), Some(80));\n+\n+    let mut it = (100..=100).step_by(10);\n+    assert_eq!(it.next_back(), Some(100));\n+    assert_eq!(it.try_fold(0, i8::checked_add), Some(0));\n+}\n+\n #[test]\n #[should_panic]\n fn test_iterator_step_by_zero() {\n@@ -1688,6 +1779,12 @@ fn test_rposition() {\n     assert!(v.iter().rposition(g).is_none());\n }\n \n+#[test]\n+fn test_rev_rposition() {\n+    let v = [0, 0, 1, 1];\n+    assert_eq!(v.iter().rev().rposition(|&x| x == 1), Some(1));\n+}\n+\n #[test]\n #[should_panic]\n fn test_rposition_panic() {"}, {"sha": "050195cd2ef51eaca905ce2b05e9f0ae15556393", "filename": "src/libcore/tests/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Flib.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -1,3 +1,4 @@\n+#![feature(bool_to_option)]\n #![feature(bound_cloned)]\n #![feature(box_syntax)]\n #![feature(cell_update)]\n@@ -32,6 +33,7 @@\n #![feature(const_fn)]\n #![feature(iter_partition_in_place)]\n #![feature(iter_is_partitioned)]\n+#![feature(iter_order_by)]\n \n extern crate test;\n \n@@ -40,6 +42,7 @@ mod any;\n mod array;\n mod ascii;\n mod atomic;\n+mod bool;\n mod cell;\n mod char;\n mod clone;"}, {"sha": "a3ec9fd51f064cb90b5d325221bba48b313487a5", "filename": "src/libcore/unicode/mod.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibcore%2Funicode%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibcore%2Funicode%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funicode%2Fmod.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -13,8 +13,3 @@ pub mod derived_property {\n pub mod conversions {\n     pub use crate::unicode::tables::conversions::{to_lower, to_upper};\n }\n-\n-// For use in libsyntax\n-pub mod property {\n-    pub use crate::unicode::tables::property::Pattern_White_Space;\n-}"}, {"sha": "4e8b4ecad0200c9a7afcf2dadbacbc57286f5b40", "filename": "src/libcore/unicode/printable.py", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibcore%2Funicode%2Fprintable.py", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibcore%2Funicode%2Fprintable.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funicode%2Fprintable.py?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -60,7 +60,7 @@ def get_codepoints(f):\n         yield Codepoint(codepoint, class_)\n         prev_codepoint = codepoint\n \n-    if class_first != None:\n+    if class_first is not None:\n         raise ValueError(\"Missing Last after First\")\n \n     for c in range(prev_codepoint + 1, NUM_CODEPOINTS):"}, {"sha": "5b5be485431217849a1c4e87e0fb98467d01cd04", "filename": "src/libcore/unicode/tables.rs", "status": "modified", "additions": 0, "deletions": 375, "changes": 375, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibcore%2Funicode%2Ftables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibcore%2Funicode%2Ftables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funicode%2Ftables.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -890,384 +890,9 @@ pub(crate) mod derived_property {\n         Uppercase_table.lookup(c)\n     }\n \n-    const XID_Continue_table: &super::BoolTrie = &super::BoolTrie {\n-        r1: [\n-            0x03ff000000000000, 0x07fffffe87fffffe, 0x04a0040000000000, 0xff7fffffff7fffff,\n-            0xffffffffffffffff, 0xffffffffffffffff, 0xffffffffffffffff, 0xffffffffffffffff,\n-            0xffffffffffffffff, 0xffffffffffffffff, 0xffffffffffffffff, 0x0000501f0003ffc3,\n-            0xffffffffffffffff, 0xb8dfffffffffffff, 0xfffffffbffffd7c0, 0xffbfffffffffffff,\n-            0xffffffffffffffff, 0xffffffffffffffff, 0xfffffffffffffcfb, 0xffffffffffffffff,\n-            0xfffeffffffffffff, 0xffffffff027fffff, 0xbffffffffffe01ff, 0x000787ffffff00b6,\n-            0xffffffff07ff0000, 0xffffc3ffffffffff, 0xffffffffffffffff, 0x9ffffdff9fefffff,\n-            0xffffffffffff0000, 0xffffffffffffe7ff, 0x0003ffffffffffff, 0x243fffffffffffff\n-        ],\n-        r2: [\n-            0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23,\n-            24, 25, 26, 27, 28, 29, 30, 31, 4, 32, 33, 34, 4, 4, 4, 4, 4, 35, 36, 37, 38, 39, 40,\n-            41, 42, 4, 4, 4, 4, 4, 4, 4, 4, 43, 44, 45, 46, 47, 4, 48, 49, 50, 51, 52, 53, 54, 55,\n-            56, 57, 58, 59, 60, 4, 61, 4, 62, 63, 64, 65, 66, 4, 4, 4, 67, 4, 4, 4, 4, 68, 69, 70,\n-            71, 72, 73, 74, 75, 76, 77, 78, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60,\n-            60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60,\n-            60, 60, 60, 60, 60, 79, 80, 4, 81, 82, 83, 84, 85, 60, 60, 60, 60, 60, 60, 60, 60, 86,\n-            42, 87, 88, 89, 4, 90, 91, 60, 60, 60, 60, 60, 60, 60, 60, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n-            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n-            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n-            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n-            4, 4, 4, 4, 4, 52, 60, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n-            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n-            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n-            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n-            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n-            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n-            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n-            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n-            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n-            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n-            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n-            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 92, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n-            4, 4, 4, 4, 4, 93, 94, 4, 4, 4, 4, 95, 96, 4, 97, 98, 4, 99, 100, 101, 62, 4, 102, 103,\n-            104, 4, 105, 106, 107, 4, 108, 109, 110, 4, 111, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n-            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n-            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n-            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n-            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n-            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n-            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 112, 113, 60, 60, 60, 60, 60, 60, 60,\n-            60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60,\n-            60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60,\n-            60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60,\n-            60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60,\n-            60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60,\n-            60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 4, 4, 4, 4, 4, 103, 4, 114,\n-            115, 116, 97, 117, 4, 118, 4, 4, 119, 120, 121, 122, 123, 124, 4, 125, 126, 127, 128,\n-            129\n-        ],\n-        r3: &[\n-            0x00003fffffffffff, 0x000007ff0fffffff, 0x3fdfffff00000000, 0xfffffffbfff80000,\n-            0xffffffffffffffff, 0xfffeffcfffffffff, 0xf3c5fdfffff99fef, 0x5003ffcfb080799f,\n-            0xd36dfdfffff987ee, 0x003fffc05e023987, 0xf3edfdfffffbbfee, 0xfe00ffcf00013bbf,\n-            0xf3edfdfffff99fee, 0x0002ffcfb0c0399f, 0xc3ffc718d63dc7ec, 0x0000ffc000813dc7,\n-            0xe3fffdfffffddfff, 0x0000ffcf07603ddf, 0xf3effdfffffddfef, 0x0006ffcf40603ddf,\n-            0xfffffffffffddfef, 0xfc00ffcf80f07ddf, 0x2ffbfffffc7fffec, 0x000cffc0ff5f847f,\n-            0x07fffffffffffffe, 0x0000000003ff7fff, 0x3fffffaffffff7d6, 0x00000000f3ff3f5f,\n-            0xc2a003ff03000001, 0xfffe1ffffffffeff, 0x1ffffffffeffffdf, 0x0000000000000040,\n-            0xffffffffffff03ff, 0xffffffff3fffffff, 0xf7ffffffffff20bf, 0xffffffff3d7f3dff,\n-            0x7f3dffffffff3dff, 0xffffffffff7fff3d, 0xffffffffff3dffff, 0x0003fe00e7ffffff,\n-            0xffffffff0000ffff, 0x3f3fffffffffffff, 0xfffffffffffffffe, 0xffff9fffffffffff,\n-            0xffffffff07fffffe, 0x01ffc7ffffffffff, 0x001fffff001fdfff, 0x000ddfff000fffff,\n-            0x000003ff308fffff, 0xffffffff03ff3800, 0x01ffffffffffffff, 0xffff07ffffffffff,\n-            0x003fffffffffffff, 0x0fff0fff7fffffff, 0x001f3fffffffffc0, 0xffff0fffffffffff,\n-            0x0000000007ff03ff, 0xffffffff0fffffff, 0x9fffffff7fffffff, 0x3fff008003ff03ff,\n-            0x0000000000000000, 0x000ff80003ff0fff, 0x000fffffffffffff, 0x00ffffffffffffff,\n-            0x3fffffffffffe3ff, 0xe7ffffffffff01ff, 0x07fffffffff70000, 0xfbffffffffffffff,\n-            0xffffffff3f3fffff, 0x3fffffffaaff3f3f, 0x5fdfffffffffffff, 0x1fdc1fff0fcf1fdc,\n-            0x8000000000000000, 0x8002000000100001, 0x000000001fff0000, 0x0001ffe21fff0000,\n-            0xf3fffd503f2ffc84, 0xffffffff000043e0, 0x00000000000001ff, 0xffff7fffffffffff,\n-            0xffffffff7fffffff, 0x000ff81fffffffff, 0xffff20bfffffffff, 0x800080ffffffffff,\n-            0x7f7f7f7f007fffff, 0xffffffff7f7f7f7f, 0x1f3efffe000000e0, 0xfffffffee67fffff,\n-            0xf7ffffffffffffff, 0xfffeffffffffffe0, 0x07ffffff00007fff, 0xffff000000000000,\n-            0x0000ffffffffffff, 0x0000000000001fff, 0x3fffffffffff0000, 0x00000fffffff1fff,\n-            0xbff0ffffffffffff, 0x0003ffffffffffff, 0xfffffffcff800000, 0xfffffffffffff9ff,\n-            0xff8000000000007c, 0x000000ffffffffff, 0xe8ffffff03ff003f, 0xffff3fffffffffff,\n-            0x1fffffff000fffff, 0x7fffffff03ff8001, 0x007fffffffffffff, 0xfc7fffff03ff3fff,\n-            0x007cffff38000007, 0xffff7f7f007e7e7e, 0xffff00fff7ffffff, 0x03ff37ffffffffff,\n-            0xffff000fffffffff, 0x0ffffffffffff87f, 0x0000000003ffffff, 0x5f7ffdffe0f8007f,\n-            0xffffffffffffffdb, 0xfffffffffff80000, 0xfffffff03fffffff, 0x3fffffffffffffff,\n-            0xffffffffffff0000, 0xfffffffffffcffff, 0x03ff0000000000ff, 0x0018ffff0000ffff,\n-            0xaa8a00000000e000, 0x1fffffffffffffff, 0x87fffffe03ff0000, 0xffffffc007fffffe,\n-            0x7fffffffffffffff, 0x000000001cfcfcfc\n-        ],\n-        r4: [\n-            0, 1, 2, 3, 4, 5, 6, 7, 8, 5, 5, 9, 5, 10, 11, 5, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 12, 13,\n-            14, 7, 15, 16, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n-            5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n-            5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n-            5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n-            5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n-            5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n-            5, 5, 5, 5, 5, 5, 5, 17, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n-            5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5\n-        ],\n-        r5: &[\n-            0, 1, 2, 3, 4, 5, 4, 6, 4, 4, 7, 8, 9, 10, 11, 12, 2, 2, 13, 14, 15, 16, 4, 4, 2, 2, 2,\n-            2, 17, 18, 4, 4, 19, 20, 21, 22, 23, 4, 24, 4, 25, 26, 27, 28, 29, 30, 31, 4, 2, 32, 33,\n-            33, 34, 4, 4, 4, 4, 4, 4, 4, 35, 36, 4, 37, 2, 38, 3, 39, 40, 41, 2, 42, 43, 4, 44, 45,\n-            46, 47, 4, 4, 2, 48, 2, 49, 4, 4, 50, 51, 2, 52, 53, 54, 55, 4, 4, 4, 3, 4, 56, 57, 4,\n-            4, 58, 59, 60, 61, 62, 53, 4, 4, 4, 4, 63, 64, 65, 4, 66, 67, 68, 4, 4, 4, 4, 37, 4, 4,\n-            4, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 69, 4, 2, 70, 2, 2, 2, 71, 4, 4, 4, 4,\n-            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n-            4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 70, 4, 4, 4,\n-            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n-            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n-            4, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 72, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n-            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n-            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n-            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n-            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n-            4, 2, 2, 2, 2, 2, 2, 2, 2, 53, 73, 4, 74, 17, 75, 76, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2,\n-            4, 4, 2, 77, 78, 79, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n-            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n-            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n-            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 80, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 33, 4,\n-            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 2, 21, 81, 2, 2, 2, 2,\n-            2, 82, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n-            4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 83, 84, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n-            4, 85, 86, 4, 4, 87, 4, 4, 4, 4, 4, 4, 2, 88, 89, 90, 91, 92, 2, 2, 2, 2, 93, 94, 95,\n-            96, 97, 98, 4, 4, 4, 4, 4, 4, 4, 4, 99, 100, 101, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n-            4, 4, 4, 4, 4, 4, 4, 4, 102, 4, 4, 4, 103, 104, 4, 4, 4, 4, 4, 105, 4, 4, 4, 4, 4, 4, 4,\n-            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 106, 2, 107, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n-            4, 4, 4, 4, 4, 4, 4, 4, 4, 108, 109, 110, 4, 4, 4, 4, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n-            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 111, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n-            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n-            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 5, 2, 2, 2, 11,\n-            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n-            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n-            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n-            2, 2, 112, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n-            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 113, 4, 4,\n-            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n-            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 2, 2, 2, 2, 2, 114, 4, 4, 4,\n-            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 115, 4,\n-            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n-            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4\n-        ],\n-        r6: &[\n-            0xb7ffff7fffffefff, 0x000000003fff3fff, 0xffffffffffffffff, 0x07ffffffffffffff,\n-            0x0000000000000000, 0x001fffffffffffff, 0x2000000000000000, 0xffffffff1fffffff,\n-            0x000000010001ffff, 0xffffe000ffffffff, 0x07ffffffffff07ff, 0xffffffff3fffffff,\n-            0x00000000003eff0f, 0xffff03ff3fffffff, 0x0fffffffff0fffff, 0xffff00ffffffffff,\n-            0x0000000fffffffff, 0x007fffffffffffff, 0x000000ff003fffff, 0x91bffffffffffd3f,\n-            0x007fffff003fffff, 0x000000007fffffff, 0x0037ffff00000000, 0x03ffffff003fffff,\n-            0xc0ffffffffffffff, 0x873ffffffeeff06f, 0x1fffffff00000000, 0x000000001fffffff,\n-            0x0000007ffffffeff, 0x003fffffffffffff, 0x0007ffff003fffff, 0x000000000003ffff,\n-            0x00000000000001ff, 0x0007ffffffffffff, 0x03ff00ffffffffff, 0xffff00801fffffff,\n-            0x000000000001ffff, 0x007fffff00000000, 0x8000ffc00000007f, 0x03ff01ffffff0000,\n-            0xffdfffffffffffff, 0x004fffffffff0070, 0x0000000017ff1e1f, 0x40fffffffffbffff,\n-            0xffff01ffbfffbd7f, 0x03ff07ffffffffff, 0xfbedfdfffff99fef, 0x001f1fcfe081399f,\n-            0x00000000c3ff07ff, 0x0000000003ff00bf, 0xff3fffffffffffff, 0x000000003f000001,\n-            0x0000000003ff0011, 0x01ffffffffffffff, 0x00000000000003ff, 0x03ff0fffe7ffffff,\n-            0xffffffff00000000, 0x800003ffffffffff, 0xfffffcff00000000, 0x0000001bfcffffff,\n-            0x7fffffffffffffff, 0xffffffffffff0080, 0x0000000023ffffff, 0xff7ffffffffffdff,\n-            0xfffc000003ff0001, 0x007ffefffffcffff, 0xb47ffffffffffb7f, 0xfffffdbf03ff00ff,\n-            0x000003ff01fb7fff, 0x0000000003ffffff, 0x00007fffffffffff, 0x000000000000000f,\n-            0x000000000000007f, 0x000003ff7fffffff, 0x001f3fffffff0000, 0xe0fffff803ff000f,\n-            0x000000000000ffff, 0xffffffffffff87ff, 0x00000000ffff80ff, 0x0000000b00000000,\n-            0x00ffffffffffffff, 0xffff00f000070000, 0x0fffffffffffffff, 0x1fff07ffffffffff,\n-            0x0000000063ff01ff, 0xf807e3e000000000, 0x00003c0000000fe7, 0x000000000000001c,\n-            0xffffffffffdfffff, 0xebffde64dfffffff, 0xffffffffffffffef, 0x7bffffffdfdfe7bf,\n-            0xfffffffffffdfc5f, 0xffffff3fffffffff, 0xf7fffffff7fffffd, 0xffdfffffffdfffff,\n-            0xffff7fffffff7fff, 0xfffffdfffffffdff, 0xffffffffffffcff7, 0xf87fffffffffffff,\n-            0x00201fffffffffff, 0x0000fffef8000010, 0x000007dbf9ffff7f, 0x3fff1fffffffffff,\n-            0x00000000000043ff, 0x03ffffffffffffff, 0x00000000007f001f, 0x0000000003ff0fff,\n-            0x0af7fe96ffffffef, 0x5ef7f796aa96ea84, 0x0ffffbee0ffffbff, 0x00000000007fffff,\n-            0xffff0003ffffffff, 0x00000001ffffffff, 0x000000003fffffff, 0x0000ffffffffffff\n-        ],\n-    };\n-\n-    pub fn XID_Continue(c: char) -> bool {\n-        XID_Continue_table.lookup(c)\n-    }\n-\n-    const XID_Start_table: &super::BoolTrie = &super::BoolTrie {\n-        r1: [\n-            0x0000000000000000, 0x07fffffe07fffffe, 0x0420040000000000, 0xff7fffffff7fffff,\n-            0xffffffffffffffff, 0xffffffffffffffff, 0xffffffffffffffff, 0xffffffffffffffff,\n-            0xffffffffffffffff, 0xffffffffffffffff, 0xffffffffffffffff, 0x0000501f0003ffc3,\n-            0x0000000000000000, 0xb8df000000000000, 0xfffffffbffffd740, 0xffbfffffffffffff,\n-            0xffffffffffffffff, 0xffffffffffffffff, 0xfffffffffffffc03, 0xffffffffffffffff,\n-            0xfffeffffffffffff, 0xffffffff027fffff, 0x00000000000001ff, 0x000787ffffff0000,\n-            0xffffffff00000000, 0xfffec000000007ff, 0xffffffffffffffff, 0x9c00c060002fffff,\n-            0x0000fffffffd0000, 0xffffffffffffe000, 0x0002003fffffffff, 0x043007fffffffc00\n-        ],\n-        r2: [\n-            0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23,\n-            24, 23, 25, 26, 27, 28, 29, 3, 30, 31, 32, 33, 34, 34, 34, 34, 34, 35, 36, 37, 38, 39,\n-            40, 41, 42, 34, 34, 34, 34, 34, 34, 34, 34, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53,\n-            54, 55, 56, 57, 58, 59, 60, 3, 61, 62, 63, 64, 65, 66, 67, 68, 34, 34, 34, 3, 34, 34,\n-            34, 34, 69, 70, 71, 72, 3, 73, 74, 3, 75, 76, 77, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n-            3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 78,\n-            79, 34, 80, 81, 82, 83, 84, 3, 3, 3, 3, 3, 3, 3, 3, 85, 42, 86, 87, 88, 34, 89, 90, 3,\n-            3, 3, 3, 3, 3, 3, 3, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-            34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-            34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-            34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-            34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 53, 3, 34,\n-            34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-            34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-            34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-            34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-            34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-            34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-            34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-            34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-            34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-            34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-            34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-            34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-            34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-            34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-            34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 91, 34, 34, 34,\n-            34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 92, 93, 34, 34, 34, 34, 94,\n-            95, 96, 91, 97, 34, 98, 99, 100, 48, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110,\n-            111, 112, 34, 113, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-            34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-            34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-            34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-            34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-            34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-            34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-            34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-            34, 34, 34, 114, 115, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n-            3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n-            3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n-            3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n-            3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 34, 34, 34, 34, 34,\n-            116, 34, 117, 118, 119, 120, 121, 34, 122, 34, 34, 123, 124, 125, 126, 3, 127, 34, 128,\n-            129, 130, 131, 132\n-        ],\n-        r3: &[\n-            0x00000110043fffff, 0x000007ff01ffffff, 0x3fdfffff00000000, 0x0000000000000000,\n-            0x23fffffffffffff0, 0xfffe0003ff010000, 0x23c5fdfffff99fe1, 0x10030003b0004000,\n-            0x036dfdfffff987e0, 0x001c00005e000000, 0x23edfdfffffbbfe0, 0x0200000300010000,\n-            0x23edfdfffff99fe0, 0x00020003b0000000, 0x03ffc718d63dc7e8, 0x0000000000010000,\n-            0x23fffdfffffddfe0, 0x0000000307000000, 0x23effdfffffddfe1, 0x0006000340000000,\n-            0x27fffffffffddfe0, 0xfc00000380704000, 0x2ffbfffffc7fffe0, 0x000000000000007f,\n-            0x0005fffffffffffe, 0x2005ffaffffff7d6, 0x00000000f000005f, 0x0000000000000001,\n-            0x00001ffffffffeff, 0x0000000000001f00, 0x800007ffffffffff, 0xffe1c0623c3f0000,\n-            0xffffffff00004003, 0xf7ffffffffff20bf, 0xffffffffffffffff, 0xffffffff3d7f3dff,\n-            0x7f3dffffffff3dff, 0xffffffffff7fff3d, 0xffffffffff3dffff, 0x0000000007ffffff,\n-            0xffffffff0000ffff, 0x3f3fffffffffffff, 0xfffffffffffffffe, 0xffff9fffffffffff,\n-            0xffffffff07fffffe, 0x01ffc7ffffffffff, 0x0003ffff0003dfff, 0x0001dfff0003ffff,\n-            0x000fffffffffffff, 0x0000000010800000, 0xffffffff00000000, 0x01ffffffffffffff,\n-            0xffff05ffffffffff, 0x003fffffffffffff, 0x000000007fffffff, 0x001f3fffffff0000,\n-            0xffff0fffffffffff, 0x00000000000003ff, 0xffffffff007fffff, 0x00000000001fffff,\n-            0x0000008000000000, 0x000fffffffffffe0, 0x0000000000000fe0, 0xfc00c001fffffff8,\n-            0x0000003fffffffff, 0x0000000fffffffff, 0x3ffffffffc00e000, 0xe7ffffffffff01ff,\n-            0x046fde0000000000, 0xffffffff3f3fffff, 0x3fffffffaaff3f3f, 0x5fdfffffffffffff,\n-            0x1fdc1fff0fcf1fdc, 0x8002000000000000, 0x000000001fff0000, 0xf3fffd503f2ffc84,\n-            0xffffffff000043e0, 0x00000000000001ff, 0xffff7fffffffffff, 0xffffffff7fffffff,\n-            0x000c781fffffffff, 0xffff20bfffffffff, 0x000080ffffffffff, 0x7f7f7f7f007fffff,\n-            0x000000007f7f7f7f, 0x1f3e03fe000000e0, 0xfffffffee07fffff, 0xf7ffffffffffffff,\n-            0xfffeffffffffffe0, 0x07ffffff00007fff, 0xffff000000000000, 0x0000ffffffffffff,\n-            0x0000000000001fff, 0x3fffffffffff0000, 0x00000c00ffff1fff, 0x80007fffffffffff,\n-            0xffffffff3fffffff, 0xfffffffcff800000, 0xfffffffffffff9ff, 0xff8000000000007c,\n-            0x00000007fffff7bb, 0x000ffffffffffffc, 0x68fc000000000000, 0xffff003ffffffc00,\n-            0x1fffffff0000007f, 0x0007fffffffffff0, 0x7c00ffdf00008000, 0x000001ffffffffff,\n-            0xc47fffff00000ff7, 0x3e62ffffffffffff, 0x001c07ff38000005, 0xffff7f7f007e7e7e,\n-            0xffff00fff7ffffff, 0x00000007ffffffff, 0xffff000fffffffff, 0x0ffffffffffff87f,\n-            0xffff3fffffffffff, 0x0000000003ffffff, 0x5f7ffdffa0f8007f, 0xffffffffffffffdb,\n-            0x0003ffffffffffff, 0xfffffffffff80000, 0xfffffff03fffffff, 0x3fffffffffffffff,\n-            0xffffffffffff0000, 0xfffffffffffcffff, 0x03ff0000000000ff, 0xaa8a000000000000,\n-            0x1fffffffffffffff, 0x07fffffe00000000, 0xffffffc007fffffe, 0x7fffffff3fffffff,\n-            0x000000001cfcfcfc\n-        ],\n-        r4: [\n-            0, 1, 2, 3, 4, 5, 6, 7, 8, 5, 5, 9, 5, 10, 11, 5, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 12, 13,\n-            14, 7, 15, 16, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n-            5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n-            5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n-            5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n-            5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n-            5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n-            5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n-            5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5\n-        ],\n-        r5: &[\n-            0, 1, 2, 3, 4, 5, 4, 4, 4, 4, 6, 7, 8, 9, 10, 11, 2, 2, 12, 13, 14, 15, 4, 4, 2, 2, 2,\n-            2, 16, 17, 4, 4, 18, 19, 20, 21, 22, 4, 23, 4, 24, 25, 26, 27, 28, 29, 30, 4, 2, 31, 32,\n-            32, 15, 4, 4, 4, 4, 4, 4, 4, 33, 34, 4, 35, 36, 4, 37, 38, 39, 40, 41, 42, 43, 4, 44,\n-            20, 45, 46, 4, 4, 5, 47, 48, 49, 4, 4, 50, 51, 48, 52, 53, 4, 54, 4, 4, 4, 55, 4, 56,\n-            57, 4, 4, 58, 59, 60, 61, 62, 63, 4, 4, 4, 4, 64, 65, 66, 4, 67, 68, 69, 4, 4, 4, 4, 70,\n-            4, 4, 4, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 71, 4, 2, 50, 2, 2, 2, 72, 4, 4,\n-            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n-            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 50, 4,\n-            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n-            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n-            4, 4, 4, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 73, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n-            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n-            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n-            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n-            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n-            4, 4, 4, 2, 2, 2, 2, 2, 2, 2, 2, 63, 20, 4, 74, 48, 75, 66, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n-            4, 2, 4, 4, 2, 76, 77, 78, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n-            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n-            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n-            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 79, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n-            32, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 2, 20, 80, 2,\n-            2, 2, 2, 2, 81, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n-            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 82, 83, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n-            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 84, 85, 86, 87, 88, 2, 2, 2, 2, 89, 90,\n-            91, 92, 93, 94, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n-            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 95, 96, 4, 4, 4, 4, 4, 55, 4, 4, 4, 4, 4, 4, 4, 4,\n-            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 97, 2, 98, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n-            4, 4, 4, 4, 4, 4, 4, 99, 100, 101, 4, 4, 4, 4, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n-            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 102, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n-            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n-            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 5, 2, 2, 2, 10, 2, 2, 2,\n-            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n-            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n-            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 103,\n-            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n-            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 104, 4, 4, 4, 4, 4,\n-            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n-            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 2, 2, 2, 2, 2, 105, 4, 4, 4, 4, 4, 4,\n-            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4\n-        ],\n-        r6: &[\n-            0xb7ffff7fffffefff, 0x000000003fff3fff, 0xffffffffffffffff, 0x07ffffffffffffff,\n-            0x0000000000000000, 0x001fffffffffffff, 0xffffffff1fffffff, 0x000000000001ffff,\n-            0xffffe000ffffffff, 0x003fffffffff07ff, 0xffffffff3fffffff, 0x00000000003eff0f,\n-            0xffff00003fffffff, 0x0fffffffff0fffff, 0xffff00ffffffffff, 0x0000000fffffffff,\n-            0x007fffffffffffff, 0x000000ff003fffff, 0x91bffffffffffd3f, 0x007fffff003fffff,\n-            0x000000007fffffff, 0x0037ffff00000000, 0x03ffffff003fffff, 0xc0ffffffffffffff,\n-            0x003ffffffeef0001, 0x1fffffff00000000, 0x000000001fffffff, 0x0000001ffffffeff,\n-            0x003fffffffffffff, 0x0007ffff003fffff, 0x000000000003ffff, 0x00000000000001ff,\n-            0x0007ffffffffffff, 0xffff00801fffffff, 0x000000000000003f, 0x007fffff00000000,\n-            0x00fffffffffffff8, 0x0000fffffffffff8, 0x000001ffffff0000, 0x0000007ffffffff8,\n-            0x0047ffffffff0010, 0x0007fffffffffff8, 0x000000001400001e, 0x00000ffffffbffff,\n-            0xffff01ffbfffbd7f, 0x23edfdfffff99fe0, 0x00000003e0010000, 0x0000000080000780,\n-            0x0000ffffffffffff, 0x00000000000000b0, 0x00007fffffffffff, 0x000000000f000000,\n-            0x0000000000000010, 0x010007ffffffffff, 0x0000000007ffffff, 0x00000fffffffffff,\n-            0xffffffff00000000, 0x80000000ffffffff, 0xfffffcff00000000, 0x0000000a0001ffff,\n-            0x0407fffffffff801, 0xfffffffff0010000, 0x00000000200003ff, 0x01ffffffffffffff,\n-            0x00007ffffffffdff, 0xfffc000000000001, 0x000000000000ffff, 0x0001fffffffffb7f,\n-            0xfffffdbf00000040, 0x00000000010003ff, 0x0007ffff00000000, 0x0000000003ffffff,\n-            0x000000000000000f, 0x000000000000007f, 0x00003fffffff0000, 0xe0fffff80000000f,\n-            0x00000000000107ff, 0x00000000fff80000, 0x0000000b00000000, 0x00ffffffffffffff,\n-            0xffff00f000070000, 0x0fffffffffffffff, 0x1fff07ffffffffff, 0x0000000003ff01ff,\n-            0xffffffffffdfffff, 0xebffde64dfffffff, 0xffffffffffffffef, 0x7bffffffdfdfe7bf,\n-            0xfffffffffffdfc5f, 0xffffff3fffffffff, 0xf7fffffff7fffffd, 0xffdfffffffdfffff,\n-            0xffff7fffffff7fff, 0xfffffdfffffffdff, 0x0000000000000ff7, 0x3f801fffffffffff,\n-            0x0000000000004000, 0x000000000000001f, 0x000000000000080f, 0x0af7fe96ffffffef,\n-            0x5ef7f796aa96ea84, 0x0ffffbee0ffffbff, 0x00000000007fffff, 0xffff0003ffffffff,\n-            0x00000001ffffffff, 0x000000003fffffff\n-        ],\n-    };\n-\n-    pub fn XID_Start(c: char) -> bool {\n-        XID_Start_table.lookup(c)\n-    }\n-\n }\n \n pub(crate) mod property {\n-    const Pattern_White_Space_table: &super::SmallBoolTrie = &super::SmallBoolTrie {\n-        r1: &[\n-            0, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n-            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n-            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n-            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n-            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3\n-        ],\n-        r2: &[\n-            0x0000000100003e00, 0x0000000000000000, 0x0000000000000020, 0x000003000000c000\n-        ],\n-    };\n-\n-    pub fn Pattern_White_Space(c: char) -> bool {\n-        Pattern_White_Space_table.lookup(c)\n-    }\n-\n     const White_Space_table: &super::SmallBoolTrie = &super::SmallBoolTrie {\n         r1: &[\n             0, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,"}, {"sha": "89894f7932d79fac161d5673d6b7778d9dd710f4", "filename": "src/libcore/unicode/unicode.py", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibcore%2Funicode%2Funicode.py", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibcore%2Funicode%2Funicode.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funicode%2Funicode.py?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -728,7 +728,7 @@ def generate_property_module(mod, grouped_categories, category_subset):\n \n     yield \"pub(crate) mod %s {\\n\" % mod\n     for cat in sorted(category_subset):\n-        if cat in (\"Cc\", \"White_Space\", \"Pattern_White_Space\"):\n+        if cat in (\"Cc\", \"White_Space\"):\n             generator = generate_small_bool_trie(\"%s_table\" % cat, grouped_categories[cat])\n         else:\n             generator = generate_bool_trie(\"%s_table\" % cat, grouped_categories[cat])\n@@ -841,19 +841,18 @@ def main():\n     unicode_data = load_unicode_data(get_path(UnicodeFiles.UNICODE_DATA))\n     load_special_casing(get_path(UnicodeFiles.SPECIAL_CASING), unicode_data)\n \n-    want_derived = {\"XID_Start\", \"XID_Continue\", \"Alphabetic\", \"Lowercase\", \"Uppercase\",\n+    want_derived = {\"Alphabetic\", \"Lowercase\", \"Uppercase\",\n                     \"Cased\", \"Case_Ignorable\", \"Grapheme_Extend\"}\n     derived = load_properties(get_path(UnicodeFiles.DERIVED_CORE_PROPERTIES), want_derived)\n \n     props = load_properties(get_path(UnicodeFiles.PROPS),\n-                            {\"White_Space\", \"Join_Control\", \"Noncharacter_Code_Point\",\n-                             \"Pattern_White_Space\"})\n+                            {\"White_Space\", \"Join_Control\", \"Noncharacter_Code_Point\"})\n \n     # Category tables\n     for (name, categories, category_subset) in (\n             (\"general_category\", unicode_data.general_categories, [\"N\", \"Cc\"]),\n             (\"derived_property\", derived, want_derived),\n-            (\"property\", props, [\"White_Space\", \"Pattern_White_Space\"])\n+            (\"property\", props, [\"White_Space\"])\n     ):\n         for fragment in generate_property_module(name, categories, category_subset):\n             buf.write(fragment)"}, {"sha": "fff4ec716dfdad4e3453f7217bbbaf118fd4a4d0", "filename": "src/libfmt_macros/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibfmt_macros%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibfmt_macros%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfmt_macros%2FCargo.toml?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -10,4 +10,4 @@ path = \"lib.rs\"\n \n [dependencies]\n syntax_pos = { path = \"../libsyntax_pos\" }\n-\n+rustc_lexer = { path = \"../librustc_lexer\" }"}, {"sha": "f9c1be20b8bc132aed7ac28364713e714427a797", "filename": "src/libfmt_macros/lib.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibfmt_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibfmt_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfmt_macros%2Flib.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -597,12 +597,11 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    /// Parses a word starting at the current position. A word is considered to\n-    /// be an alphabetic character followed by any number of alphanumeric\n-    /// characters.\n+    /// Parses a word starting at the current position. A word is the same as\n+    /// Rust identifier, except that it can't start with `_` character.\n     fn word(&mut self) -> &'a str {\n         let start = match self.cur.peek() {\n-            Some(&(pos, c)) if c.is_xid_start() => {\n+            Some(&(pos, c)) if c != '_' && rustc_lexer::is_id_start(c) => {\n                 self.cur.next();\n                 pos\n             }\n@@ -611,7 +610,7 @@ impl<'a> Parser<'a> {\n             }\n         };\n         while let Some(&(pos, c)) = self.cur.peek() {\n-            if c.is_xid_continue() {\n+            if rustc_lexer::is_id_continue(c) {\n                 self.cur.next();\n             } else {\n                 return &self.input[start..pos];"}, {"sha": "187bdac80019d51e914a6c70ec31e914c567d231", "filename": "src/libproc_macro/Cargo.toml", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibproc_macro%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibproc_macro%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2FCargo.toml?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -6,3 +6,6 @@ edition = \"2018\"\n \n [lib]\n path = \"lib.rs\"\n+\n+[dependencies]\n+std = { path = \"../libstd\" }"}, {"sha": "d408fef75153e2f83c597d9bfa6547b66585b1e2", "filename": "src/libproc_macro/lib.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibproc_macro%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibproc_macro%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Flib.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -19,12 +19,15 @@\n \n #![feature(nll)]\n #![feature(staged_api)]\n+#![feature(allow_internal_unstable)]\n #![feature(const_fn)]\n+#![feature(decl_macro)]\n #![feature(extern_types)]\n #![feature(in_band_lifetimes)]\n #![feature(optin_builtin_traits)]\n #![feature(mem_take)]\n #![feature(non_exhaustive)]\n+#![feature(rustc_attrs)]\n #![feature(specialization)]\n \n #![recursion_limit=\"256\"]\n@@ -222,11 +225,10 @@ pub mod token_stream {\n ///\n /// Unquoting is done with `$`, and works by taking the single next ident as the unquoted term.\n /// To quote `$` itself, use `$$`.\n-///\n-/// This is a dummy macro, the actual implementation is in `quote::quote`.`\n #[unstable(feature = \"proc_macro_quote\", issue = \"54722\")]\n-#[macro_export]\n-macro_rules! quote { () => {} }\n+#[allow_internal_unstable(proc_macro_def_site)]\n+#[cfg_attr(not(bootstrap), rustc_builtin_macro)]\n+pub macro quote ($($t:tt)*) { /* compiler built-in */ }\n \n #[unstable(feature = \"proc_macro_internals\", issue = \"27812\")]\n #[doc(hidden)]"}, {"sha": "144e2d6bac43bb3061ecbb3c785965732e56c7e5", "filename": "src/libproc_macro/quote.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibproc_macro%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibproc_macro%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Fquote.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -57,9 +57,9 @@ macro_rules! quote {\n }\n \n /// Quote a `TokenStream` into a `TokenStream`.\n-/// This is the actual `quote!()` proc macro.\n+/// This is the actual implementation of the `quote!()` proc macro.\n ///\n-/// It is manually loaded in `CStore::load_macro_untracked`.\n+/// It is loaded by the compiler in `register_builtin_macros`.\n #[unstable(feature = \"proc_macro_quote\", issue = \"54722\")]\n pub fn quote(stream: TokenStream) -> TokenStream {\n     if stream.is_empty() {"}, {"sha": "a479fabafc014202760dc3ff67196de40ab07dd0", "filename": "src/librustc/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2FCargo.toml?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -21,7 +21,7 @@ scoped-tls = \"1.0\"\n log = { version = \"0.4\", features = [\"release_max_level_info\", \"std\"] }\n rustc-rayon = \"0.2.0\"\n rustc-rayon-core = \"0.2.0\"\n-polonius-engine  = \"0.9.0\"\n+polonius-engine  = \"0.10.0\"\n rustc_apfloat = { path = \"../librustc_apfloat\" }\n rustc_target = { path = \"../librustc_target\" }\n rustc_macros = { path = \"../librustc_macros\" }"}, {"sha": "d4fc1b12830a12eeb4af48f5a5306f0841da4252", "filename": "src/librustc/arena.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Farena.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -25,6 +25,16 @@ macro_rules! arena_types {\n             [] adt_def: rustc::ty::AdtDef,\n             [] steal_mir: rustc::ty::steal::Steal<rustc::mir::Body<$tcx>>,\n             [] mir: rustc::mir::Body<$tcx>,\n+            [] steal_promoted: rustc::ty::steal::Steal<\n+                rustc_data_structures::indexed_vec::IndexVec<\n+                    rustc::mir::Promoted,\n+                    rustc::mir::Body<$tcx>\n+                >\n+            >,\n+            [] promoted: rustc_data_structures::indexed_vec::IndexVec<\n+                rustc::mir::Promoted,\n+                rustc::mir::Body<$tcx>\n+            >,\n             [] tables: rustc::ty::TypeckTables<$tcx>,\n             [] const_allocs: rustc::mir::interpret::Allocation,\n             [] vtable_method: Option<(\n@@ -84,6 +94,10 @@ macro_rules! arena_types {\n                         rustc::hir::def_id::CrateNum\n                     >\n                 >,\n+            [few] diagnostic_items: rustc_data_structures::fx::FxHashMap<\n+                syntax::symbol::Symbol,\n+                rustc::hir::def_id::DefId,\n+            >,\n             [few] resolve_lifetimes: rustc::middle::resolve_lifetime::ResolveLifetimes,\n             [decode] generic_predicates: rustc::ty::GenericPredicates<'tcx>,\n             [few] lint_levels: rustc::lint::LintLevelMap,\n@@ -173,7 +187,7 @@ impl<T: Copy> ArenaAllocatable for T {}\n \n unsafe trait ArenaField<'tcx>: Sized {\n     /// Returns a specific arena to allocate from.\n-    /// If None is returned, the DropArena will be used.\n+    /// If `None` is returned, the `DropArena` will be used.\n     fn arena<'a>(arena: &'a Arena<'tcx>) -> Option<&'a TypedArena<Self>>;\n }\n "}, {"sha": "eee33846139e673dcdea38ac9a8977807ae573af", "filename": "src/librustc/error_codes.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ferror_codes.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -1,7 +1,8 @@\n // Error messages for EXXXX errors.\n-// Each message should start and end with a new line, and be wrapped to 80 characters.\n-// In vim you can `:set tw=80` and use `gq` to wrap paragraphs. Use `:set tw=0` to disable.\n-register_long_diagnostics! {\n+// Each message should start and end with a new line, and be wrapped to 80\n+// characters.  In vim you can `:set tw=80` and use `gq` to wrap paragraphs. Use\n+// `:set tw=0` to disable.\n+syntax::register_diagnostics! {\n E0038: r##\"\n Trait objects like `Box<Trait>` can only be constructed when certain\n requirements are satisfied by the trait in question.\n@@ -39,7 +40,7 @@ Generally, `Self: Sized` is used to indicate that the trait should not be used\n as a trait object. If the trait comes from your own crate, consider removing\n this restriction.\n \n-### Method references the `Self` type in its arguments or return type\n+### Method references the `Self` type in its parameters or return type\n \n This happens when a trait has a method like the following:\n \n@@ -2183,11 +2184,7 @@ Examples of erroneous code:\n static X: u32 = 42;\n ```\n \"##,\n-\n-}\n-\n-\n-register_diagnostics! {\n+;\n //  E0006, // merged with E0005\n //  E0101, // replaced with E0282\n //  E0102, // replaced with E0282\n@@ -2206,7 +2203,8 @@ register_diagnostics! {\n //  E0305, // expected constant\n     E0311, // thing may not live long enough\n     E0312, // lifetime of reference outlives lifetime of borrowed content\n-    E0313, // lifetime of borrowed pointer outlives lifetime of captured variable\n+    E0313, // lifetime of borrowed pointer outlives lifetime of captured\n+           // variable\n     E0314, // closure outlives stack frame\n     E0315, // cannot invoke closure outside of its lifetime\n     E0316, // nested quantification of lifetimes\n@@ -2223,23 +2221,25 @@ register_diagnostics! {\n     E0483, // lifetime of operand does not outlive the operation\n     E0484, // reference is not valid at the time of borrow\n     E0485, // automatically reference is not valid at the time of borrow\n-    E0486, // type of expression contains references that are not valid during...\n+    E0486, // type of expression contains references that are not valid during..\n     E0487, // unsafe use of destructor: destructor might be called while...\n     E0488, // lifetime of variable does not enclose its declaration\n     E0489, // type/lifetime parameter not in scope here\n     E0490, // a value of type `..` is borrowed for too long\n-    E0495, // cannot infer an appropriate lifetime due to conflicting requirements\n+    E0495, // cannot infer an appropriate lifetime due to conflicting\n+           // requirements\n     E0566, // conflicting representation hints\n     E0623, // lifetime mismatch where both parameters are anonymous regions\n-    E0628, // generators cannot have explicit arguments\n+    E0628, // generators cannot have explicit parameters\n     E0631, // type mismatch in closure arguments\n     E0637, // \"'_\" is not a valid lifetime bound\n     E0657, // `impl Trait` can only capture lifetimes bound at the fn level\n     E0687, // in-band lifetimes cannot be used in `fn`/`Fn` syntax\n     E0688, // in-band lifetimes cannot be mixed with explicit lifetime binders\n     E0697, // closures cannot be static\n     E0707, // multiple elided lifetimes used in arguments of `async fn`\n-    E0708, // `async` non-`move` closures with arguments are not currently supported\n+    E0708, // `async` non-`move` closures with parameters are not currently\n+           // supported\n     E0709, // multiple different lifetimes used in arguments of `async fn`\n     E0710, // an unknown tool name found in scoped lint\n     E0711, // a feature has been declared with conflicting stability attributes"}, {"sha": "1df09429e519f835948af6007239498a3beefe14", "filename": "src/librustc/hir/check_attr.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fcheck_attr.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -4,13 +4,12 @@\n //! conflicts between multiple such attributes attached to the same\n //! item.\n \n-\n-use crate::ty::TyCtxt;\n-use crate::ty::query::Providers;\n-\n use crate::hir;\n use crate::hir::def_id::DefId;\n use crate::hir::intravisit::{self, Visitor, NestedVisitorMap};\n+use crate::ty::TyCtxt;\n+use crate::ty::query::Providers;\n+\n use std::fmt::{self, Display};\n use syntax::symbol::sym;\n use syntax_pos::Span;"}, {"sha": "f7d31ca06ee56e173dc8d900632d980de17d8206", "filename": "src/librustc/hir/def.rs", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Fhir%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Fhir%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -1,15 +1,17 @@\n+use self::Namespace::*;\n+\n use crate::hir::def_id::{DefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n+use crate::hir;\n+use crate::ty;\n use crate::util::nodemap::DefIdMap;\n+\n use syntax::ast;\n use syntax::ext::base::MacroKind;\n use syntax::ast::NodeId;\n use syntax_pos::Span;\n use rustc_macros::HashStable;\n-use crate::hir;\n-use crate::ty;\n-use std::fmt::Debug;\n \n-use self::Namespace::*;\n+use std::fmt::Debug;\n \n /// Encodes if a `DefKind::Ctor` is the constructor of an enum variant or a struct.\n #[derive(Clone, Copy, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, HashStable)]\n@@ -115,7 +117,7 @@ impl DefKind {\n         }\n     }\n \n-    /// An English article for the def.\n+    /// Gets an English article for the definition.\n     pub fn article(&self) -> &'static str {\n         match *self {\n             DefKind::AssocTy\n@@ -134,18 +136,22 @@ pub enum Res<Id = hir::HirId> {\n     Def(DefKind, DefId),\n \n     // Type namespace\n+\n     PrimTy(hir::PrimTy),\n     SelfTy(Option<DefId> /* trait */, Option<DefId> /* impl */),\n     ToolMod, // e.g., `rustfmt` in `#[rustfmt::skip]`\n \n     // Value namespace\n+\n     SelfCtor(DefId /* impl */),  // `DefId` refers to the impl\n     Local(Id),\n \n     // Macro namespace\n+\n     NonMacroAttr(NonMacroAttrKind), // e.g., `#[inline]` or `#[rustfmt::skip]`\n \n     // All namespaces\n+\n     Err,\n }\n \n@@ -330,7 +336,7 @@ impl NonMacroAttrKind {\n }\n \n impl<Id> Res<Id> {\n-    /// Return the `DefId` of this `Def` if it has an id, else panic.\n+    /// Return the `DefId` of this `Def` if it has an ID, else panic.\n     pub fn def_id(&self) -> DefId\n     where\n         Id: Debug,\n@@ -340,7 +346,7 @@ impl<Id> Res<Id> {\n         })\n     }\n \n-    /// Return `Some(..)` with the `DefId` of this `Res` if it has a id, else `None`.\n+    /// Return `Some(..)` with the `DefId` of this `Res` if it has a ID, else `None`.\n     pub fn opt_def_id(&self) -> Option<DefId> {\n         match *self {\n             Res::Def(_, id) => Some(id),\n@@ -379,7 +385,7 @@ impl<Id> Res<Id> {\n         }\n     }\n \n-    /// An English article for the res.\n+    /// Gets an English article for the `Res`.\n     pub fn article(&self) -> &'static str {\n         match *self {\n             Res::Def(kind, _) => kind.article(),"}, {"sha": "d0bdc149131835c8bc62d9c300d18e37c1c2669d", "filename": "src/librustc/hir/def_id.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Fhir%2Fdef_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Fhir%2Fdef_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef_id.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -11,7 +11,7 @@ newtype_index! {\n \n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n pub enum CrateNum {\n-    /// A special CrateNum that we use for the tcx.rcache when decoding from\n+    /// A special `CrateNum` that we use for the `tcx.rcache` when decoding from\n     /// the incr. comp. cache.\n     ReservedForIncrCompCache,\n     Index(CrateId),\n@@ -26,11 +26,10 @@ impl ::std::fmt::Debug for CrateNum {\n     }\n }\n \n-/// Item definitions in the currently-compiled crate would have the CrateNum\n-/// LOCAL_CRATE in their DefId.\n+/// Item definitions in the currently-compiled crate would have the `CrateNum`\n+/// `LOCAL_CRATE` in their `DefId`.\n pub const LOCAL_CRATE: CrateNum = CrateNum::Index(CrateId::from_u32_const(0));\n \n-\n impl Idx for CrateNum {\n     #[inline]\n     fn new(value: usize) -> Self {"}, {"sha": "1f125de9672168d6e599aeef32378264ad20dbc7", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 18, "deletions": 16, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -31,11 +31,13 @@\n //! This order consistency is required in a few places in rustc, for\n //! example generator inference, and possibly also HIR borrowck.\n \n-use syntax::ast::{Ident, Name, Attribute};\n-use syntax_pos::Span;\n+use super::itemlikevisit::DeepVisitor;\n+\n use crate::hir::*;\n use crate::hir::map::Map;\n-use super::itemlikevisit::DeepVisitor;\n+\n+use syntax::ast::{Ident, Name, Attribute};\n+use syntax_pos::Span;\n \n #[derive(Copy, Clone)]\n pub enum FnKind<'a> {\n@@ -139,7 +141,7 @@ impl<'this, 'tcx> NestedVisitorMap<'this, 'tcx> {\n /// explicitly, you need to override each method. (And you also need\n /// to monitor future changes to `Visitor` in case a new method with a\n /// new default implementation gets introduced.)\n-pub trait Visitor<'v> : Sized {\n+pub trait Visitor<'v>: Sized {\n     ///////////////////////////////////////////////////////////////////////////\n     // Nested items.\n \n@@ -162,8 +164,8 @@ pub trait Visitor<'v> : Sized {\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'v>;\n \n     /// Invoked when a nested item is encountered. By default does\n-    /// nothing unless you override `nested_visit_map` to return\n-    /// `Some(_)`, in which case it will walk the item. **You probably\n+    /// nothing unless you override `nested_visit_map` to return other than\n+    /// `None`, in which case it will walk the item. **You probably\n     /// don't want to override this method** -- instead, override\n     /// `nested_visit_map` or use the \"shallow\" or \"deep\" visit\n     /// patterns described on `itemlikevisit::ItemLikeVisitor`. The only\n@@ -201,17 +203,17 @@ pub trait Visitor<'v> : Sized {\n \n     /// Invoked to visit the body of a function, method or closure. Like\n     /// visit_nested_item, does nothing by default unless you override\n-    /// `nested_visit_map` to return `Some(_)`, in which case it will walk the\n-    /// body.\n+    /// `nested_visit_map` to return other htan `None`, in which case it will walk\n+    /// the body.\n     fn visit_nested_body(&mut self, id: BodyId) {\n         let opt_body = self.nested_visit_map().intra().map(|map| map.body(id));\n         if let Some(body) = opt_body {\n             self.visit_body(body);\n         }\n     }\n \n-    fn visit_arg(&mut self, arg: &'v Arg) {\n-        walk_arg(self, arg)\n+    fn visit_param(&mut self, param: &'v Param) {\n+        walk_param(self, param)\n     }\n \n     /// Visits the top-level item and (optionally) nested items / impl items. See\n@@ -400,7 +402,7 @@ pub fn walk_mod<'v, V: Visitor<'v>>(visitor: &mut V, module: &'v Mod, mod_hir_id\n }\n \n pub fn walk_body<'v, V: Visitor<'v>>(visitor: &mut V, body: &'v Body) {\n-    walk_list!(visitor, visit_arg, &body.arguments);\n+    walk_list!(visitor, visit_param, &body.params);\n     visitor.visit_expr(&body.value);\n }\n \n@@ -454,10 +456,10 @@ pub fn walk_trait_ref<'v, V>(visitor: &mut V, trait_ref: &'v TraitRef)\n     visitor.visit_path(&trait_ref.path, trait_ref.hir_ref_id)\n }\n \n-pub fn walk_arg<'v, V: Visitor<'v>>(visitor: &mut V, arg: &'v Arg) {\n-    visitor.visit_id(arg.hir_id);\n-    visitor.visit_pat(&arg.pat);\n-    walk_list!(visitor, visit_attribute, &arg.attrs);\n+pub fn walk_param<'v, V: Visitor<'v>>(visitor: &mut V, param: &'v Param) {\n+    visitor.visit_id(param.hir_id);\n+    visitor.visit_pat(&param.pat);\n+    walk_list!(visitor, visit_attribute, &param.attrs);\n }\n \n pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item) {\n@@ -603,7 +605,7 @@ pub fn walk_ty<'v, V: Visitor<'v>>(visitor: &mut V, typ: &'v Ty) {\n             visitor.visit_lifetime(lifetime);\n             visitor.visit_ty(&mutable_type.ty)\n         }\n-        TyKind::Never => {},\n+        TyKind::Never => {}\n         TyKind::Tup(ref tuple_element_types) => {\n             walk_list!(visitor, visit_ty, tuple_element_types);\n         }"}, {"sha": "39dd46c2d2903473e35e8b26a88e3163d24add3d", "filename": "src/librustc/hir/itemlikevisit.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Fhir%2Fitemlikevisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Fhir%2Fitemlikevisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fitemlikevisit.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -1,7 +1,7 @@\n use super::{Item, ImplItem, TraitItem};\n use super::intravisit::Visitor;\n \n-/// The \"item-like visitor\" visitor defines only the top-level methods\n+/// The \"item-like visitor\" defines only the top-level methods\n /// that can be invoked by `Crate::visit_all_item_likes()`. Whether\n /// this trait is the right one to implement will depend on the\n /// overall pattern you need. Here are the three available patterns,\n@@ -18,22 +18,21 @@ use super::intravisit::Visitor;\n ///    an item, but don't care about how item-like things are nested\n ///    within one another.\n ///    - Example: Examine each expression to look for its type and do some check or other.\n-///    - How: Implement `intravisit::Visitor` and use\n-///      `tcx.hir().krate().visit_all_item_likes(visitor.as_deep_visitor())`. Within\n-///      your `intravisit::Visitor` impl, implement methods like\n-///      `visit_expr()`; don't forget to invoke\n-///      `intravisit::walk_visit_expr()` to keep walking the subparts.\n+///    - How: Implement `intravisit::Visitor` and override the `nested_visit_map()` method\n+///      to return `NestedVisitorMap::OnlyBodies` and use\n+///      `tcx.hir().krate().visit_all_item_likes(&mut visitor.as_deep_visitor())`. Within\n+///      your `intravisit::Visitor` impl, implement methods like `visit_expr()` (don't forget\n+///      to invoke `intravisit::walk_expr()` to keep walking the subparts).\n ///    - Pro: Visitor methods for any kind of HIR node, not just item-like things.\n ///    - Pro: Integrates well into dependency tracking.\n ///    - Con: Don't get information about nesting between items\n /// 3. **Nested visit**: Want to visit the whole HIR and you care about the nesting between\n ///    item-like things.\n ///    - Example: Lifetime resolution, which wants to bring lifetimes declared on the\n ///      impl into scope while visiting the impl-items, and then back out again.\n-///    - How: Implement `intravisit::Visitor` and override the\n-///      `nested_visit_map()` methods to return\n-///      `NestedVisitorMap::All`. Walk your crate with\n-///      `intravisit::walk_crate()` invoked on `tcx.hir().krate()`.\n+///    - How: Implement `intravisit::Visitor` and override the `nested_visit_map()` method\n+///      to return `NestedVisitorMap::All`. Walk your crate with `intravisit::walk_crate()`\n+///      invoked on `tcx.hir().krate()`.\n ///    - Pro: Visitor methods for any kind of HIR node, not just item-like things.\n ///    - Pro: Preserves nesting information\n ///    - Con: Does not integrate well into dependency tracking.\n@@ -79,7 +78,7 @@ impl<'v, 'hir, V> ItemLikeVisitor<'hir> for DeepVisitor<'v, V>\n     }\n }\n \n-/// A parallel variant of ItemLikeVisitor\n+/// A parallel variant of `ItemLikeVisitor`.\n pub trait ParItemLikeVisitor<'hir> {\n     fn visit_item(&self, item: &'hir Item);\n     fn visit_trait_item(&self, trait_item: &'hir TraitItem);"}, {"sha": "b50cfa00f09ef63e433b29102fe273dfb0f1caa2", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 56, "deletions": 31, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -79,7 +79,7 @@ const HIR_ID_COUNTER_LOCKED: u32 = 0xFFFFFFFF;\n pub struct LoweringContext<'a> {\n     crate_root: Option<Symbol>,\n \n-    /// Used to assign ids to HIR nodes that do not directly correspond to an AST node.\n+    /// Used to assign IDs to HIR nodes that do not directly correspond to AST nodes.\n     sess: &'a Session,\n \n     cstore: &'a dyn CrateStore,\n@@ -126,7 +126,7 @@ pub struct LoweringContext<'a> {\n     /// lifetime definitions in the corresponding impl or function generics.\n     lifetimes_to_define: Vec<(Span, ParamName)>,\n \n-    /// Whether or not in-band lifetimes are being collected. This is used to\n+    /// `true` if in-band lifetimes are being collected. This is used to\n     /// indicate whether or not we're in a place where new lifetimes will result\n     /// in in-band lifetime definitions, such a function or an impl header,\n     /// including implicit lifetimes from `impl_header_lifetime_elision`.\n@@ -154,13 +154,13 @@ pub struct LoweringContext<'a> {\n }\n \n pub trait Resolver {\n-    /// Obtain resolution for a `NodeId` with a single resolution.\n+    /// Obtains resolution for a `NodeId` with a single resolution.\n     fn get_partial_res(&mut self, id: NodeId) -> Option<PartialRes>;\n \n-    /// Obtain per-namespace resolutions for `use` statement with the given `NoedId`.\n+    /// Obtains per-namespace resolutions for `use` statement with the given `NodeId`.\n     fn get_import_res(&mut self, id: NodeId) -> PerNS<Option<Res<NodeId>>>;\n \n-    /// Obtain resolution for a label with the given `NodeId`.\n+    /// Obtains resolution for a label with the given `NodeId`.\n     fn get_label_res(&mut self, id: NodeId) -> Option<NodeId>;\n \n     /// We must keep the set of definitions up to date as we add nodes that weren't in the AST.\n@@ -425,19 +425,44 @@ impl<'a> LoweringContext<'a> {\n \n         impl<'tcx, 'interner> Visitor<'tcx> for MiscCollector<'tcx, 'interner> {\n             fn visit_pat(&mut self, p: &'tcx Pat) {\n-                match p.node {\n+                if let PatKind::Paren(..) | PatKind::Rest = p.node {\n                     // Doesn't generate a HIR node\n-                    PatKind::Paren(..) | PatKind::Rest => {},\n-                    _ => {\n-                        if let Some(owner) = self.hir_id_owner {\n-                            self.lctx.lower_node_id_with_owner(p.id, owner);\n-                        }\n-                    }\n-                };\n+                } else if let Some(owner) = self.hir_id_owner {\n+                    self.lctx.lower_node_id_with_owner(p.id, owner);\n+                }\n \n                 visit::walk_pat(self, p)\n             }\n \n+            // HACK(or_patterns; Centril | dlrobertson): Avoid creating\n+            // HIR  nodes for `PatKind::Or` for the top level of a `ast::Arm`.\n+            // This is a temporary hack that should go away once we push down\n+            // `arm.pats: HirVec<P<Pat>>` -> `arm.pat: P<Pat>` to HIR. // Centril\n+            fn visit_arm(&mut self, arm: &'tcx Arm) {\n+                match &arm.pat.node {\n+                    PatKind::Or(pats) => pats.iter().for_each(|p| self.visit_pat(p)),\n+                    _ => self.visit_pat(&arm.pat),\n+                }\n+                walk_list!(self, visit_expr, &arm.guard);\n+                self.visit_expr(&arm.body);\n+                walk_list!(self, visit_attribute, &arm.attrs);\n+            }\n+\n+            // HACK(or_patterns; Centril | dlrobertson): Same as above. // Centril\n+            fn visit_expr(&mut self, e: &'tcx Expr) {\n+                if let ExprKind::Let(pat, scrutinee) = &e.node {\n+                    walk_list!(self, visit_attribute, e.attrs.iter());\n+                    match &pat.node {\n+                        PatKind::Or(pats) => pats.iter().for_each(|p| self.visit_pat(p)),\n+                        _ => self.visit_pat(&pat),\n+                    }\n+                    self.visit_expr(scrutinee);\n+                    self.visit_expr_post(e);\n+                    return;\n+                }\n+                visit::walk_expr(self, e)\n+            }\n+\n             fn visit_item(&mut self, item: &'tcx Item) {\n                 let hir_id = self.lctx.allocate_hir_id_counter(item.id);\n \n@@ -510,12 +535,12 @@ impl<'a> LoweringContext<'a> {\n                             &f.generic_params\n                         );\n                         // Mirrors visit::walk_fn_decl\n-                        for argument in &f.decl.inputs {\n+                        for parameter in &f.decl.inputs {\n                             // We don't lower the ids of argument patterns\n                             self.with_hir_id_owner(None, |this| {\n-                                this.visit_pat(&argument.pat);\n+                                this.visit_pat(&parameter.pat);\n                             });\n-                            self.visit_ty(&argument.ty)\n+                            self.visit_ty(&parameter.ty)\n                         }\n                         self.visit_fn_ret_ty(&f.decl.output)\n                     }\n@@ -674,7 +699,7 @@ impl<'a> LoweringContext<'a> {\n     fn lower_res(&mut self, res: Res<NodeId>) -> Res {\n         res.map_id(|id| {\n             self.lower_node_id_generic(id, |_| {\n-                panic!(\"expected node_id to be lowered already for res {:#?}\", res)\n+                panic!(\"expected `NodeId` to be lowered already for res {:#?}\", res);\n             })\n         })\n     }\n@@ -735,7 +760,7 @@ impl<'a> LoweringContext<'a> {\n     ///\n     /// Presuming that in-band lifetimes are enabled, then\n     /// `self.anonymous_lifetime_mode` will be updated to match the\n-    /// argument while `f` is running (and restored afterwards).\n+    /// parameter while `f` is running (and restored afterwards).\n     fn collect_in_band_defs<T, F>(\n         &mut self,\n         parent_id: DefId,\n@@ -880,7 +905,7 @@ impl<'a> LoweringContext<'a> {\n     ///\n     /// Presuming that in-band lifetimes are enabled, then\n     /// `self.anonymous_lifetime_mode` will be updated to match the\n-    /// argument while `f` is running (and restored afterwards).\n+    /// parameter while `f` is running (and restored afterwards).\n     fn add_in_band_defs<F, T>(\n         &mut self,\n         generics: &Generics,\n@@ -1080,7 +1105,7 @@ impl<'a> LoweringContext<'a> {\n                     ImplTraitContext::Disallowed(_) if self.is_in_dyn_type =>\n                         (true, ImplTraitContext::OpaqueTy(None)),\n \n-                    // We are in the argument position, but not within a dyn type:\n+                    // We are in the parameter position, but not within a dyn type:\n                     //\n                     //     fn foo(x: impl Iterator<Item: Debug>)\n                     //\n@@ -1204,7 +1229,7 @@ impl<'a> LoweringContext<'a> {\n                                 unsafety: this.lower_unsafety(f.unsafety),\n                                 abi: f.abi,\n                                 decl: this.lower_fn_decl(&f.decl, None, false, None),\n-                                arg_names: this.lower_fn_args_to_names(&f.decl),\n+                                param_names: this.lower_fn_params_to_names(&f.decl),\n                             }))\n                         },\n                     )\n@@ -1339,7 +1364,7 @@ impl<'a> LoweringContext<'a> {\n                     }\n                 }\n             }\n-            TyKind::Mac(_) => bug!(\"`TyMac` should have been expanded by now.\"),\n+            TyKind::Mac(_) => bug!(\"`TyMac` should have been expanded by now\"),\n             TyKind::CVarArgs => {\n                 // Create the implicit lifetime of the \"spoofed\" `VaListImpl`.\n                 let span = self.sess.source_map().next_point(t.span.shrink_to_lo());\n@@ -2093,12 +2118,12 @@ impl<'a> LoweringContext<'a> {\n         }\n     }\n \n-    fn lower_fn_args_to_names(&mut self, decl: &FnDecl) -> hir::HirVec<Ident> {\n+    fn lower_fn_params_to_names(&mut self, decl: &FnDecl) -> hir::HirVec<Ident> {\n         decl.inputs\n             .iter()\n-            .map(|arg| match arg.pat.node {\n+            .map(|param| match param.pat.node {\n                 PatKind::Ident(_, ident, _) => ident,\n-                _ => Ident::new(kw::Invalid, arg.pat.span),\n+                _ => Ident::new(kw::Invalid, param.pat.span),\n             })\n             .collect()\n     }\n@@ -2136,11 +2161,11 @@ impl<'a> LoweringContext<'a> {\n         let inputs = self.with_anonymous_lifetime_mode(lt_mode, |this| {\n             decl.inputs\n                 .iter()\n-                .map(|arg| {\n+                .map(|param| {\n                     if let Some((_, ibty)) = &mut in_band_ty_params {\n-                        this.lower_ty_direct(&arg.ty, ImplTraitContext::Universal(ibty))\n+                        this.lower_ty_direct(&param.ty, ImplTraitContext::Universal(ibty))\n                     } else {\n-                        this.lower_ty_direct(&arg.ty, ImplTraitContext::disallowed())\n+                        this.lower_ty_direct(&param.ty, ImplTraitContext::disallowed())\n                     }\n                 })\n                 .collect::<HirVec<_>>()\n@@ -2205,7 +2230,7 @@ impl<'a> LoweringContext<'a> {\n     //\n     //     type OpaqueTy<generics_from_parent_fn> = impl Future<Output = T>;\n     //\n-    // `inputs`: lowered types of arguments to the function (used to collect lifetimes)\n+    // `inputs`: lowered types of parameters to the function (used to collect lifetimes)\n     // `output`: unlowered output type (`T` in `-> T`)\n     // `fn_def_id`: `DefId` of the parent function (used to create child impl trait definition)\n     // `opaque_ty_node_id`: `NodeId` of the opaque `impl Trait` type that should be created\n@@ -2974,7 +2999,7 @@ impl<'a> LoweringContext<'a> {\n             }\n             StmtKind::Expr(ref e) => hir::StmtKind::Expr(P(self.lower_expr(e))),\n             StmtKind::Semi(ref e) => hir::StmtKind::Semi(P(self.lower_expr(e))),\n-            StmtKind::Mac(..) => panic!(\"Shouldn't exist here\"),\n+            StmtKind::Mac(..) => panic!(\"shouldn't exist here\"),\n         };\n         smallvec![hir::Stmt {\n             hir_id: self.lower_node_id(s.id),\n@@ -3162,7 +3187,7 @@ impl<'a> LoweringContext<'a> {\n \n         hir::Path {\n             span,\n-            res: res.map_id(|_| panic!(\"unexpected node_id\")),\n+            res: res.map_id(|_| panic!(\"unexpected `NodeId`\")),\n             segments: segments.into(),\n         }\n     }"}, {"sha": "a46cdabbb518fd74c1dd8270e60fd872b97095ae", "filename": "src/librustc/hir/lowering/expr.rs", "status": "modified", "additions": 56, "deletions": 60, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -68,7 +68,7 @@ impl LoweringContext<'_> {\n                 let ohs = P(self.lower_expr(ohs));\n                 hir::ExprKind::AddrOf(m, ohs)\n             }\n-            ExprKind::Let(ref pats, ref scrutinee) => self.lower_expr_let(e.span, pats, scrutinee),\n+            ExprKind::Let(ref pat, ref scrutinee) => self.lower_expr_let(e.span, pat, scrutinee),\n             ExprKind::If(ref cond, ref then, ref else_opt) => {\n                 self.lower_expr_if(e.span, cond, then, else_opt.as_deref())\n             }\n@@ -227,16 +227,11 @@ impl LoweringContext<'_> {\n         }\n     }\n \n-    /// Emit an error and lower `ast::ExprKind::Let(pats, scrutinee)` into:\n+    /// Emit an error and lower `ast::ExprKind::Let(pat, scrutinee)` into:\n     /// ```rust\n     /// match scrutinee { pats => true, _ => false }\n     /// ```\n-    fn lower_expr_let(\n-        &mut self,\n-        span: Span,\n-        pats: &[AstP<Pat>],\n-        scrutinee: &Expr\n-    ) -> hir::ExprKind {\n+    fn lower_expr_let(&mut self, span: Span, pat: &Pat, scrutinee: &Expr) -> hir::ExprKind {\n         // If we got here, the `let` expression is not allowed.\n         self.sess\n             .struct_span_err(span, \"`let` expressions are not supported here\")\n@@ -246,23 +241,23 @@ impl LoweringContext<'_> {\n \n         // For better recovery, we emit:\n         // ```\n-        // match scrutinee { pats => true, _ => false }\n+        // match scrutinee { pat => true, _ => false }\n         // ```\n         // While this doesn't fully match the user's intent, it has key advantages:\n         // 1. We can avoid using `abort_if_errors`.\n-        // 2. We can typeck both `pats` and `scrutinee`.\n-        // 3. `pats` is allowed to be refutable.\n+        // 2. We can typeck both `pat` and `scrutinee`.\n+        // 3. `pat` is allowed to be refutable.\n         // 4. The return type of the block is `bool` which seems like what the user wanted.\n         let scrutinee = self.lower_expr(scrutinee);\n         let then_arm = {\n-            let pats = pats.iter().map(|pat| self.lower_pat(pat)).collect();\n+            let pat = self.lower_pat_top_hack(pat);\n             let expr = self.expr_bool(span, true);\n-            self.arm(pats, P(expr))\n+            self.arm(pat, P(expr))\n         };\n         let else_arm = {\n-            let pats = hir_vec![self.pat_wild(span)];\n+            let pat = self.pat_wild(span);\n             let expr = self.expr_bool(span, false);\n-            self.arm(pats, P(expr))\n+            self.arm(hir_vec![pat], P(expr))\n         };\n         hir::ExprKind::Match(\n             P(scrutinee),\n@@ -291,13 +286,12 @@ impl LoweringContext<'_> {\n         // Handle then + scrutinee:\n         let then_blk = self.lower_block(then, false);\n         let then_expr = self.expr_block(then_blk, ThinVec::new());\n-        let (then_pats, scrutinee, desugar) = match cond.node {\n+        let (then_pat, scrutinee, desugar) = match cond.node {\n             // `<pat> => <then>`:\n-            ExprKind::Let(ref pats, ref scrutinee) => {\n+            ExprKind::Let(ref pat, ref scrutinee) => {\n                 let scrutinee = self.lower_expr(scrutinee);\n-                let pats = pats.iter().map(|pat| self.lower_pat(pat)).collect();\n-                let desugar = hir::MatchSource::IfLetDesugar { contains_else_clause };\n-                (pats, scrutinee, desugar)\n+                let pat = self.lower_pat_top_hack(pat);\n+                (pat, scrutinee, hir::MatchSource::IfLetDesugar { contains_else_clause })\n             }\n             // `true => <then>`:\n             _ => {\n@@ -312,13 +306,11 @@ impl LoweringContext<'_> {\n                 // to preserve drop semantics since `if cond { ... }` does not\n                 // let temporaries live outside of `cond`.\n                 let cond = self.expr_drop_temps(span_block, P(cond), ThinVec::new());\n-\n-                let desugar = hir::MatchSource::IfDesugar { contains_else_clause };\n-                let pats = hir_vec![self.pat_bool(span, true)];\n-                (pats, cond, desugar)\n+                let pat = self.pat_bool(span, true);\n+                (hir_vec![pat], cond, hir::MatchSource::IfDesugar { contains_else_clause })\n             }\n         };\n-        let then_arm = self.arm(then_pats, P(then_expr));\n+        let then_arm = self.arm(then_pat, P(then_expr));\n \n         hir::ExprKind::Match(P(scrutinee), vec![then_arm, else_arm].into(), desugar)\n     }\n@@ -345,8 +337,8 @@ impl LoweringContext<'_> {\n         // Handle then + scrutinee:\n         let then_blk = self.lower_block(body, false);\n         let then_expr = self.expr_block(then_blk, ThinVec::new());\n-        let (then_pats, scrutinee, desugar, source) = match cond.node {\n-            ExprKind::Let(ref pats, ref scrutinee) => {\n+        let (then_pat, scrutinee, desugar, source) = match cond.node {\n+            ExprKind::Let(ref pat, ref scrutinee) => {\n                 // to:\n                 //\n                 //   [opt_ident]: loop {\n@@ -356,9 +348,8 @@ impl LoweringContext<'_> {\n                 //     }\n                 //   }\n                 let scrutinee = self.with_loop_condition_scope(|t| t.lower_expr(scrutinee));\n-                let pats = pats.iter().map(|pat| self.lower_pat(pat)).collect();\n-                let desugar = hir::MatchSource::WhileLetDesugar;\n-                (pats, scrutinee, desugar, hir::LoopSource::WhileLet)\n+                let pat = self.lower_pat_top_hack(pat);\n+                (pat, scrutinee, hir::MatchSource::WhileLetDesugar, hir::LoopSource::WhileLet)\n             }\n             _ => {\n                 // We desugar: `'label: while $cond $body` into:\n@@ -383,14 +374,12 @@ impl LoweringContext<'_> {\n                 // to preserve drop semantics since `while cond { ... }` does not\n                 // let temporaries live outside of `cond`.\n                 let cond = self.expr_drop_temps(span_block, P(cond), ThinVec::new());\n-\n-                let desugar = hir::MatchSource::WhileDesugar;\n                 // `true => <then>`:\n-                let pats = hir_vec![self.pat_bool(span, true)];\n-                (pats, cond, desugar, hir::LoopSource::While)\n+                let pat = self.pat_bool(span, true);\n+                (hir_vec![pat], cond, hir::MatchSource::WhileDesugar, hir::LoopSource::While)\n             }\n         };\n-        let then_arm = self.arm(then_pats, P(then_expr));\n+        let then_arm = self.arm(then_pat, P(then_expr));\n \n         // `match <scrutinee> { ... }`\n         let match_expr = self.expr_match(\n@@ -440,7 +429,7 @@ impl LoweringContext<'_> {\n         hir::Arm {\n             hir_id: self.next_id(),\n             attrs: self.lower_attrs(&arm.attrs),\n-            pats: arm.pats.iter().map(|x| self.lower_pat(x)).collect(),\n+            pats: self.lower_pat_top_hack(&arm.pat),\n             guard: match arm.guard {\n                 Some(ref x) => Some(hir::Guard::If(P(self.lower_expr(x)))),\n                 _ => None,\n@@ -450,6 +439,16 @@ impl LoweringContext<'_> {\n         }\n     }\n \n+    /// HACK(or_patterns; Centril | dlrobertson): For now we don't push down top level or-patterns\n+    /// `p | q` into `hir::PatKind::Or(...)` as post-lowering bits of the compiler are not ready\n+    /// to deal with it. This should by fixed by pushing it down to HIR and then HAIR.\n+    fn lower_pat_top_hack(&mut self, pat: &Pat) -> HirVec<P<hir::Pat>> {\n+        match pat.node {\n+            PatKind::Or(ref ps) => ps.iter().map(|x| self.lower_pat(x)).collect(),\n+            _ => hir_vec![self.lower_pat(pat)],\n+        }\n+    }\n+\n     pub(super) fn make_async_expr(\n         &mut self,\n         capture_clause: CaptureBy,\n@@ -508,14 +507,13 @@ impl LoweringContext<'_> {\n \n     /// Desugar `<expr>.await` into:\n     /// ```rust\n-    /// {\n-    ///     let mut pinned = <expr>;\n-    ///     loop {\n+    /// match <expr> {\n+    ///     mut pinned => loop {\n     ///         match ::std::future::poll_with_tls_context(unsafe {\n-    ///             ::std::pin::Pin::new_unchecked(&mut pinned)\n+    ///             <::std::pin::Pin>::new_unchecked(&mut pinned)\n     ///         }) {\n     ///             ::std::task::Poll::Ready(result) => break result,\n-    ///             ::std::task::Poll::Pending => {},\n+    ///             ::std::task::Poll::Pending => {}\n     ///         }\n     ///         yield ();\n     ///     }\n@@ -550,21 +548,12 @@ impl LoweringContext<'_> {\n             self.allow_gen_future.clone(),\n         );\n \n-        // let mut pinned = <expr>;\n-        let expr = P(self.lower_expr(expr));\n         let pinned_ident = Ident::with_dummy_span(sym::pinned);\n         let (pinned_pat, pinned_pat_hid) = self.pat_ident_binding_mode(\n             span,\n             pinned_ident,\n             hir::BindingAnnotation::Mutable,\n         );\n-        let pinned_let = self.stmt_let_pat(\n-            ThinVec::new(),\n-            span,\n-            Some(expr),\n-            pinned_pat,\n-            hir::LocalSource::AwaitDesugar,\n-        );\n \n         // ::std::future::poll_with_tls_context(unsafe {\n         //     ::std::pin::Pin::new_unchecked(&mut pinned)\n@@ -622,7 +611,7 @@ impl LoweringContext<'_> {\n             self.arm(hir_vec![pending_pat], empty_block)\n         };\n \n-        let match_stmt = {\n+        let inner_match_stmt = {\n             let match_expr = self.expr_match(\n                 span,\n                 poll_expr,\n@@ -644,10 +633,11 @@ impl LoweringContext<'_> {\n \n         let loop_block = P(self.block_all(\n             span,\n-            hir_vec![match_stmt, yield_stmt],\n+            hir_vec![inner_match_stmt, yield_stmt],\n             None,\n         ));\n \n+        // loop { .. }\n         let loop_expr = P(hir::Expr {\n             hir_id: loop_hir_id,\n             node: hir::ExprKind::Loop(\n@@ -659,10 +649,14 @@ impl LoweringContext<'_> {\n             attrs: ThinVec::new(),\n         });\n \n-        hir::ExprKind::Block(\n-            P(self.block_all(span, hir_vec![pinned_let], Some(loop_expr))),\n-            None,\n-        )\n+        // mut pinned => loop { ... }\n+        let pinned_arm = self.arm(hir_vec![pinned_pat], loop_expr);\n+\n+        // match <expr> {\n+        //     mut pinned => loop { .. }\n+        // }\n+        let expr = P(self.lower_expr(expr));\n+        hir::ExprKind::Match(expr, hir_vec![pinned_arm], hir::MatchSource::AwaitDesugar)\n     }\n \n     fn lower_expr_closure(\n@@ -724,7 +718,7 @@ impl LoweringContext<'_> {\n                         self.sess,\n                         fn_decl_span,\n                         E0628,\n-                        \"generators cannot have explicit arguments\"\n+                        \"generators cannot have explicit parameters\"\n                     );\n                     self.sess.abort_if_errors();\n                 }\n@@ -775,7 +769,7 @@ impl LoweringContext<'_> {\n                     this.sess,\n                     fn_decl_span,\n                     E0708,\n-                    \"`async` non-`move` closures with arguments are not currently supported\",\n+                    \"`async` non-`move` closures with parameters are not currently supported\",\n                 )\n                 .help(\n                     \"consider using `let` statements to manually capture \\\n@@ -1255,7 +1249,6 @@ impl LoweringContext<'_> {\n                 ThinVec::from(attrs.clone()),\n             ));\n             let ok_pat = self.pat_ok(span, val_pat);\n-\n             self.arm(hir_vec![ok_pat], val_expr)\n         };\n \n@@ -1486,7 +1479,10 @@ impl LoweringContext<'_> {\n         }\n     }\n \n-    fn arm(&mut self, pats: hir::HirVec<P<hir::Pat>>, expr: P<hir::Expr>) -> hir::Arm {\n+    /// HACK(or_patterns; Centril | dlrobertson): For now we don't push down top level or-patterns\n+    /// `p | q` into `hir::PatKind::Or(...)` as post-lowering bits of the compiler are not ready\n+    /// to deal with it. This should by fixed by pushing it down to HIR and then HAIR.\n+    fn arm(&mut self, pats: HirVec<P<hir::Pat>>, expr: P<hir::Expr>) -> hir::Arm {\n         hir::Arm {\n             hir_id: self.next_id(),\n             attrs: hir_vec![],"}, {"sha": "5f82e42abb308ccc32efd82bcc56cf9f15774cd9", "filename": "src/librustc/hir/lowering/item.rs", "status": "modified", "additions": 42, "deletions": 42, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Fhir%2Flowering%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Fhir%2Flowering%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering%2Fitem.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -718,9 +718,9 @@ impl LoweringContext<'_> {\n                         AnonymousLifetimeMode::PassThrough,\n                         |this, _| {\n                             (\n-                                // Disallow impl Trait in foreign items\n+                                // Disallow `impl Trait` in foreign items.\n                                 this.lower_fn_decl(fdec, None, false, None),\n-                                this.lower_fn_args_to_names(fdec),\n+                                this.lower_fn_params_to_names(fdec),\n                             )\n                         },\n                     );\n@@ -732,7 +732,7 @@ impl LoweringContext<'_> {\n                         self.lower_ty(t, ImplTraitContext::disallowed()), self.lower_mutability(m))\n                 }\n                 ForeignItemKind::Ty => hir::ForeignItemKind::Type,\n-                ForeignItemKind::Macro(_) => panic!(\"shouldn't exist here\"),\n+                ForeignItemKind::Macro(_) => panic!(\"macro shouldn't exist here\"),\n             },\n             vis: self.lower_visibility(&i.vis, None),\n             span: i.span,\n@@ -827,7 +827,7 @@ impl LoweringContext<'_> {\n                 ),\n             ),\n             TraitItemKind::Method(ref sig, None) => {\n-                let names = self.lower_fn_args_to_names(&sig.decl);\n+                let names = self.lower_fn_params_to_names(&sig.decl);\n                 let (generics, sig) = self.lower_method_sig(\n                     &i.generics,\n                     sig,\n@@ -1028,10 +1028,10 @@ impl LoweringContext<'_> {\n         }\n     }\n \n-    fn record_body(&mut self, arguments: HirVec<hir::Arg>, value: hir::Expr) -> hir::BodyId {\n+    fn record_body(&mut self, params: HirVec<hir::Param>, value: hir::Expr) -> hir::BodyId {\n         let body = hir::Body {\n             generator_kind: self.generator_kind,\n-            arguments,\n+            params,\n             value,\n         };\n         let id = body.id();\n@@ -1041,21 +1041,21 @@ impl LoweringContext<'_> {\n \n     fn lower_body(\n         &mut self,\n-        f: impl FnOnce(&mut LoweringContext<'_>) -> (HirVec<hir::Arg>, hir::Expr),\n+        f: impl FnOnce(&mut LoweringContext<'_>) -> (HirVec<hir::Param>, hir::Expr),\n     ) -> hir::BodyId {\n         let prev_gen_kind = self.generator_kind.take();\n-        let (arguments, result) = f(self);\n-        let body_id = self.record_body(arguments, result);\n+        let (parameters, result) = f(self);\n+        let body_id = self.record_body(parameters, result);\n         self.generator_kind = prev_gen_kind;\n         body_id\n     }\n \n-    fn lower_arg(&mut self, arg: &Arg) -> hir::Arg {\n-        hir::Arg {\n-            attrs: self.lower_attrs(&arg.attrs),\n-            hir_id: self.lower_node_id(arg.id),\n-            pat: self.lower_pat(&arg.pat),\n-            span: arg.span,\n+    fn lower_param(&mut self, param: &Param) -> hir::Param {\n+        hir::Param {\n+            attrs: self.lower_attrs(&param.attrs),\n+            hir_id: self.lower_node_id(param.id),\n+            pat: self.lower_pat(&param.pat),\n+            span: param.span,\n         }\n     }\n \n@@ -1065,7 +1065,7 @@ impl LoweringContext<'_> {\n         body: impl FnOnce(&mut LoweringContext<'_>) -> hir::Expr,\n     ) -> hir::BodyId {\n         self.lower_body(|this| (\n-            decl.inputs.iter().map(|x| this.lower_arg(x)).collect(),\n+            decl.inputs.iter().map(|x| this.lower_param(x)).collect(),\n             body(this),\n         ))\n     }\n@@ -1093,10 +1093,10 @@ impl LoweringContext<'_> {\n         };\n \n         self.lower_body(|this| {\n-            let mut arguments: Vec<hir::Arg> = Vec::new();\n+            let mut parameters: Vec<hir::Param> = Vec::new();\n             let mut statements: Vec<hir::Stmt> = Vec::new();\n \n-            // Async function arguments are lowered into the closure body so that they are\n+            // Async function parameters are lowered into the closure body so that they are\n             // captured and so that the drop order matches the equivalent non-async functions.\n             //\n             // from:\n@@ -1121,13 +1121,13 @@ impl LoweringContext<'_> {\n             //\n             // If `<pattern>` is a simple ident, then it is lowered to a single\n             // `let <pattern> = <pattern>;` statement as an optimization.\n-            for (index, argument) in decl.inputs.iter().enumerate() {\n-                let argument = this.lower_arg(argument);\n-                let span = argument.pat.span;\n+            for (index, parameter) in decl.inputs.iter().enumerate() {\n+                let parameter = this.lower_param(parameter);\n+                let span = parameter.pat.span;\n \n                 // Check if this is a binding pattern, if so, we can optimize and avoid adding a\n-                // `let <pat> = __argN;` statement. In this case, we do not rename the argument.\n-                let (ident, is_simple_argument) = match argument.pat.node {\n+                // `let <pat> = __argN;` statement. In this case, we do not rename the parameter.\n+                let (ident, is_simple_parameter) = match parameter.pat.node {\n                     hir::PatKind::Binding(hir::BindingAnnotation::Unannotated, _, ident, _) =>\n                         (ident, true),\n                     _ => {\n@@ -1142,32 +1142,32 @@ impl LoweringContext<'_> {\n                 let desugared_span =\n                     this.mark_span_with_reason(DesugaringKind::Async, span, None);\n \n-                // Construct an argument representing `__argN: <ty>` to replace the argument of the\n+                // Construct a parameter representing `__argN: <ty>` to replace the parameter of the\n                 // async function.\n                 //\n-                // If this is the simple case, this argument will end up being the same as the\n-                // original argument, but with a different pattern id.\n+                // If this is the simple case, this parameter will end up being the same as the\n+                // original parameter, but with a different pattern id.\n                 let mut stmt_attrs = ThinVec::new();\n-                stmt_attrs.extend(argument.attrs.iter().cloned());\n-                let (new_argument_pat, new_argument_id) = this.pat_ident(desugared_span, ident);\n-                let new_argument = hir::Arg {\n-                    attrs: argument.attrs,\n-                    hir_id: argument.hir_id,\n-                    pat: new_argument_pat,\n-                    span: argument.span,\n+                stmt_attrs.extend(parameter.attrs.iter().cloned());\n+                let (new_parameter_pat, new_parameter_id) = this.pat_ident(desugared_span, ident);\n+                let new_parameter = hir::Param {\n+                    attrs: parameter.attrs,\n+                    hir_id: parameter.hir_id,\n+                    pat: new_parameter_pat,\n+                    span: parameter.span,\n                 };\n \n \n-                if is_simple_argument {\n+                if is_simple_parameter {\n                     // If this is the simple case, then we only insert one statement that is\n                     // `let <pat> = <pat>;`. We re-use the original argument's pattern so that\n                     // `HirId`s are densely assigned.\n-                    let expr = this.expr_ident(desugared_span, ident, new_argument_id);\n+                    let expr = this.expr_ident(desugared_span, ident, new_parameter_id);\n                     let stmt = this.stmt_let_pat(\n                         stmt_attrs,\n                         desugared_span,\n                         Some(P(expr)),\n-                        argument.pat,\n+                        parameter.pat,\n                         hir::LocalSource::AsyncFn\n                     );\n                     statements.push(stmt);\n@@ -1179,7 +1179,7 @@ impl LoweringContext<'_> {\n                     // let <pat> = __argN;\n                     // ```\n                     //\n-                    // The first statement moves the argument into the closure and thus ensures\n+                    // The first statement moves the parameter into the closure and thus ensures\n                     // that the drop order is correct.\n                     //\n                     // The second statement creates the bindings that the user wrote.\n@@ -1189,7 +1189,7 @@ impl LoweringContext<'_> {\n                     // statement.\n                     let (move_pat, move_id) = this.pat_ident_binding_mode(\n                         desugared_span, ident, hir::BindingAnnotation::Mutable);\n-                    let move_expr = this.expr_ident(desugared_span, ident, new_argument_id);\n+                    let move_expr = this.expr_ident(desugared_span, ident, new_parameter_id);\n                     let move_stmt = this.stmt_let_pat(\n                         ThinVec::new(),\n                         desugared_span,\n@@ -1199,21 +1199,21 @@ impl LoweringContext<'_> {\n                     );\n \n                     // Construct the `let <pat> = __argN;` statement. We re-use the original\n-                    // argument's pattern so that `HirId`s are densely assigned.\n+                    // parameter's pattern so that `HirId`s are densely assigned.\n                     let pattern_expr = this.expr_ident(desugared_span, ident, move_id);\n                     let pattern_stmt = this.stmt_let_pat(\n                         stmt_attrs,\n                         desugared_span,\n                         Some(P(pattern_expr)),\n-                        argument.pat,\n+                        parameter.pat,\n                         hir::LocalSource::AsyncFn\n                     );\n \n                     statements.push(move_stmt);\n                     statements.push(pattern_stmt);\n                 };\n \n-                arguments.push(new_argument);\n+                parameters.push(new_parameter);\n             }\n \n             let async_expr = this.make_async_expr(\n@@ -1222,7 +1222,7 @@ impl LoweringContext<'_> {\n                     let body = this.lower_block_with_stmts(body, false, statements);\n                     this.expr_block(body, ThinVec::new())\n                 });\n-            (HirVec::from(arguments), this.expr(body.span, async_expr, ThinVec::new()))\n+            (HirVec::from(parameters), this.expr(body.span, async_expr, ThinVec::new()))\n         })\n     }\n "}, {"sha": "4179cf2ff807fd0d169900eef3e3c8bbec10afcf", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -186,7 +186,7 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n             });\n \n         let mut upstream_crates: Vec<_> = cstore.crates_untracked().iter().map(|&cnum| {\n-            let name = cstore.crate_name_untracked(cnum).as_str();\n+            let name = cstore.crate_name_untracked(cnum).as_interned_str();\n             let disambiguator = cstore.crate_disambiguator_untracked(cnum).to_fingerprint();\n             let hash = cstore.crate_hash_untracked(cnum);\n             (name, disambiguator, hash)\n@@ -340,7 +340,7 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n     /// their outer items.\n \n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'hir> {\n-        panic!(\"visit_nested_xxx must be manually implemented in this visitor\")\n+        panic!(\"`visit_nested_xxx` must be manually implemented in this visitor\");\n     }\n \n     fn visit_nested_item(&mut self, item: ItemId) {\n@@ -363,11 +363,11 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n         self.currently_in_body = prev_in_body;\n     }\n \n-    fn visit_arg(&mut self, arg: &'hir Arg) {\n-        let node = Node::Arg(arg);\n-        self.insert(arg.pat.span, arg.hir_id, node);\n-        self.with_parent(arg.hir_id, |this| {\n-            intravisit::walk_arg(this, arg);\n+    fn visit_param(&mut self, param: &'hir Param) {\n+        let node = Node::Param(param);\n+        self.insert(param.pat.span, param.hir_id, node);\n+        self.with_parent(param.hir_id, |this| {\n+            intravisit::walk_param(this, param);\n         });\n     }\n "}, {"sha": "bffb4df836e3b799960cca9f0e680c598b7f838d", "filename": "src/librustc/hir/map/def_collector.rs", "status": "modified", "additions": 60, "deletions": 5, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -154,31 +154,41 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n         });\n     }\n \n-    fn visit_variant(&mut self, v: &'a Variant, g: &'a Generics, item_id: NodeId) {\n+    fn visit_variant(&mut self, v: &'a Variant) {\n+        if v.is_placeholder {\n+            return self.visit_macro_invoc(v.id);\n+        }\n         let def = self.create_def(v.id,\n                                   DefPathData::TypeNs(v.ident.as_interned_str()),\n                                   v.span);\n         self.with_parent(def, |this| {\n             if let Some(ctor_hir_id) = v.data.ctor_id() {\n                 this.create_def(ctor_hir_id, DefPathData::Ctor, v.span);\n             }\n-            visit::walk_variant(this, v, g, item_id)\n+            visit::walk_variant(this, v)\n         });\n     }\n \n-    fn visit_variant_data(&mut self, data: &'a VariantData, _: Ident,\n-                          _: &'a Generics, _: NodeId, _: Span) {\n+    fn visit_variant_data(&mut self, data: &'a VariantData) {\n         for (index, field) in data.fields().iter().enumerate() {\n+            if field.is_placeholder {\n+                self.visit_macro_invoc(field.id);\n+                continue;\n+            }\n             let name = field.ident.map(|ident| ident.name)\n                 .unwrap_or_else(|| sym::integer(index));\n             let def = self.create_def(field.id,\n                                       DefPathData::ValueNs(name.as_interned_str()),\n                                       field.span);\n-            self.with_parent(def, |this| this.visit_struct_field(field));\n+            self.with_parent(def, |this| visit::walk_struct_field(this, field));\n         }\n     }\n \n     fn visit_generic_param(&mut self, param: &'a GenericParam) {\n+        if param.is_placeholder {\n+            self.visit_macro_invoc(param.id);\n+            return;\n+        }\n         let name = param.ident.as_interned_str();\n         let def_path_data = match param.kind {\n             GenericParamKind::Lifetime { .. } => DefPathData::LifetimeNs(name),\n@@ -295,4 +305,49 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n             }\n         }\n     }\n+\n+    fn visit_arm(&mut self, arm: &'a Arm) {\n+        if arm.is_placeholder {\n+            self.visit_macro_invoc(arm.id)\n+        } else {\n+            visit::walk_arm(self, arm)\n+        }\n+    }\n+\n+    fn visit_field(&mut self, f: &'a Field) {\n+        if f.is_placeholder {\n+            self.visit_macro_invoc(f.id)\n+        } else {\n+            visit::walk_field(self, f)\n+        }\n+    }\n+\n+    fn visit_field_pattern(&mut self, fp: &'a FieldPat) {\n+        if fp.is_placeholder {\n+            self.visit_macro_invoc(fp.id)\n+        } else {\n+            visit::walk_field_pattern(self, fp)\n+        }\n+    }\n+\n+    fn visit_param(&mut self, p: &'a Param) {\n+        if p.is_placeholder {\n+            self.visit_macro_invoc(p.id)\n+        } else {\n+            visit::walk_param(self, p)\n+        }\n+    }\n+\n+    fn visit_struct_field(&mut self, sf: &'a StructField) {\n+        if sf.is_placeholder {\n+            self.visit_macro_invoc(sf.id)\n+        } else {\n+            let name = sf.ident.map(|ident| ident.name)\n+                .unwrap_or_else(|| panic!(\"don't know the field number in this context\"));\n+            let def = self.create_def(sf.id,\n+                                        DefPathData::ValueNs(name.as_interned_str()),\n+                                        sf.span);\n+            self.with_parent(def, |this| visit::walk_struct_field(this, sf));\n+        }\n+    }\n }"}, {"sha": "651fe8449ac935cd8c4957b68f947b8fb3bd67d4", "filename": "src/librustc/hir/map/definitions.rs", "status": "modified", "additions": 41, "deletions": 36, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -7,23 +7,24 @@\n use crate::hir;\n use crate::hir::def_id::{CrateNum, DefId, DefIndex, LOCAL_CRATE, CRATE_DEF_INDEX};\n use crate::ich::Fingerprint;\n+use crate::session::CrateDisambiguator;\n+use crate::util::nodemap::NodeMap;\n+\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::indexed_vec::{IndexVec};\n use rustc_data_structures::stable_hasher::StableHasher;\n-use crate::session::CrateDisambiguator;\n use std::borrow::Borrow;\n use std::fmt::Write;\n use std::hash::Hash;\n use syntax::ast;\n use syntax::ext::hygiene::ExpnId;\n use syntax::symbol::{Symbol, sym, InternedString};\n use syntax_pos::{Span, DUMMY_SP};\n-use crate::util::nodemap::NodeMap;\n \n-/// The DefPathTable maps DefIndexes to DefKeys and vice versa.\n-/// Internally the DefPathTable holds a tree of DefKeys, where each DefKey\n-/// stores the DefIndex of its parent.\n-/// There is one DefPathTable for each crate.\n+/// The `DefPathTable` maps `DefIndex`es to `DefKey`s and vice versa.\n+/// Internally the `DefPathTable` holds a tree of `DefKey`s, where each `DefKey`\n+/// stores the `DefIndex` of its parent.\n+/// There is one `DefPathTable` for each crate.\n #[derive(Clone, Default, RustcDecodable, RustcEncodable)]\n pub struct DefPathTable {\n     index_to_key: Vec<DefKey>,\n@@ -121,7 +122,7 @@ impl DefKey {\n     fn compute_stable_hash(&self, parent_hash: DefPathHash) -> DefPathHash {\n         let mut hasher = StableHasher::new();\n \n-        // We hash a 0u8 here to disambiguate between regular DefPath hashes,\n+        // We hash a `0u8` here to disambiguate between regular `DefPath` hashes,\n         // and the special \"root_parent\" below.\n         0u8.hash(&mut hasher);\n         parent_hash.hash(&mut hasher);\n@@ -145,8 +146,7 @@ impl DefKey {\n                                crate_disambiguator: CrateDisambiguator)\n                                -> DefPathHash {\n         let mut hasher = StableHasher::new();\n-        // Disambiguate this from a regular DefPath hash,\n-        // see compute_stable_hash() above.\n+        // Disambiguate this from a regular `DefPath` hash; see `compute_stable_hash()` above.\n         1u8.hash(&mut hasher);\n         crate_name.hash(&mut hasher);\n         crate_disambiguator.hash(&mut hasher);\n@@ -155,10 +155,10 @@ impl DefKey {\n }\n \n /// A pair of `DefPathData` and an integer disambiguator. The integer is\n-/// normally 0, but in the event that there are multiple defs with the\n+/// normally `0`, but in the event that there are multiple defs with the\n /// same `parent` and `data`, we use this field to disambiguate\n /// between them. This introduces some artificial ordering dependency\n-/// but means that if you have (e.g.) two impls for the same type in\n+/// but means that if you have, e.g., two impls for the same type in\n /// the same module, they do get distinct `DefId`s.\n #[derive(Clone, PartialEq, Debug, Hash, RustcEncodable, RustcDecodable)]\n pub struct DisambiguatedDefPathData {\n@@ -277,29 +277,34 @@ impl DefPath {\n pub enum DefPathData {\n     // Root: these should only be used for the root nodes, because\n     // they are treated specially by the `def_path` function.\n-    /// The crate root (marker)\n+\n+    /// The crate root (marker).\n     CrateRoot,\n-    // Catch-all for random DefId things like `DUMMY_NODE_ID`\n+    // Catch-all for random `DefId` things like `DUMMY_NODE_ID`.\n     Misc,\n+\n     // Different kinds of items and item-like things:\n-    /// An impl\n+\n+    /// An impl.\n     Impl,\n-    /// Something in the type NS\n+    /// Something in the type namespace.\n     TypeNs(InternedString),\n-    /// Something in the value NS\n+    /// Something in the value namespace.\n     ValueNs(InternedString),\n-    /// Something in the macro NS\n+    /// Something in the macro namespace.\n     MacroNs(InternedString),\n-    /// Something in the lifetime NS\n+    /// Something in the lifetime namespace.\n     LifetimeNs(InternedString),\n-    /// A closure expression\n+    /// A closure expression.\n     ClosureExpr,\n-    // Subportions of items\n-    /// Implicit ctor for a unit or tuple-like struct or enum variant.\n+\n+    // Subportions of items:\n+\n+    /// Implicit constructor for a unit or tuple-like struct or enum variant.\n     Ctor,\n-    /// A constant expression (see {ast,hir}::AnonConst).\n+    /// A constant expression (see `{ast,hir}::AnonConst`).\n     AnonConst,\n-    /// An `impl Trait` type node\n+    /// An `impl Trait` type node.\n     ImplTrait,\n     /// Identifies a piece of crate metadata that is global to a whole crate\n     /// (as opposed to just one item). `GlobalMetaData` components are only\n@@ -435,7 +440,7 @@ impl Definitions {\n         self.node_to_def_index.insert(ast::CRATE_NODE_ID, root_index);\n         self.set_invocation_parent(ExpnId::root(), root_index);\n \n-        // Allocate some other DefIndices that always must exist.\n+        // Allocate some other `DefIndex`es that always must exist.\n         GlobalMetaDataKind::allocate_def_indices(self);\n \n         root_index\n@@ -458,7 +463,7 @@ impl Definitions {\n                 data,\n                 self.table.def_key(self.node_to_def_index[&node_id]));\n \n-        // The root node must be created with create_root_def()\n+        // The root node must be created with `create_root_def()`.\n         assert!(data != DefPathData::CrateRoot);\n \n         // Find the next free disambiguator for this key.\n@@ -486,9 +491,9 @@ impl Definitions {\n         assert_eq!(index.index(), self.def_index_to_node.len());\n         self.def_index_to_node.push(node_id);\n \n-        // Some things for which we allocate DefIndices don't correspond to\n-        // anything in the AST, so they don't have a NodeId. For these cases\n-        // we don't need a mapping from NodeId to DefIndex.\n+        // Some things for which we allocate `DefIndex`es don't correspond to\n+        // anything in the AST, so they don't have a `NodeId`. For these cases\n+        // we don't need a mapping from `NodeId` to `DefIndex`.\n         if node_id != ast::DUMMY_NODE_ID {\n             debug!(\"create_def_with_parent: def_index_to_node[{:?} <-> {:?}\", index, node_id);\n             self.node_to_def_index.insert(node_id, index);\n@@ -498,20 +503,20 @@ impl Definitions {\n             self.expansions_that_defined.insert(index, expn_id);\n         }\n \n-        // The span is added if it isn't dummy\n+        // The span is added if it isn't dummy.\n         if !span.is_dummy() {\n             self.def_index_to_span.insert(index, span);\n         }\n \n         index\n     }\n \n-    /// Initialize the `ast::NodeId` to `HirId` mapping once it has been generated during\n+    /// Initializes the `ast::NodeId` to `HirId` mapping once it has been generated during\n     /// AST to HIR lowering.\n     pub fn init_node_id_to_hir_id_mapping(&mut self,\n                                           mapping: IndexVec<ast::NodeId, hir::HirId>) {\n         assert!(self.node_to_hir_id.is_empty(),\n-                \"Trying initialize NodeId -> HirId mapping twice\");\n+                \"trying to initialize `NodeId` -> `HirId` mapping twice\");\n         self.node_to_hir_id = mapping;\n     }\n \n@@ -533,7 +538,7 @@ impl Definitions {\n \n     pub fn set_invocation_parent(&mut self, invoc_id: ExpnId, parent: DefIndex) {\n         let old_parent = self.invocation_parents.insert(invoc_id, parent);\n-        assert!(old_parent.is_none(), \"parent def-index is reset for an invocation\");\n+        assert!(old_parent.is_none(), \"parent `DefIndex` is reset for an invocation\");\n     }\n }\n \n@@ -585,9 +590,9 @@ impl DefPathData {\n     }\n }\n \n-// We define the GlobalMetaDataKind enum with this macro because we want to\n+// We define the `GlobalMetaDataKind` enum with this macro because we want to\n // make sure that we exhaustively iterate over all variants when registering\n-// the corresponding DefIndices in the DefTable.\n+// the corresponding `DefIndex`es in the `DefTable`.\n macro_rules! define_global_metadata_kind {\n     (pub enum GlobalMetaDataKind {\n         $($variant:ident),*\n@@ -609,7 +614,7 @@ macro_rules! define_global_metadata_kind {\n                         DUMMY_SP\n                     );\n \n-                    // Make sure calling def_index does not crash.\n+                    // Make sure calling `def_index` does not crash.\n                     instance.def_index(&definitions.table);\n                 })*\n             }\n@@ -623,7 +628,7 @@ macro_rules! define_global_metadata_kind {\n                     }\n                 };\n \n-                // These DefKeys are all right after the root,\n+                // These `DefKey`s are all right after the root,\n                 // so a linear search is fine.\n                 let index = def_path_table.index_to_key\n                                           .iter()"}, {"sha": "5cec8a593f12af42337d18b12bf41164b2a516f1", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 38, "deletions": 32, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -5,10 +5,15 @@ pub use self::definitions::{\n };\n \n use crate::dep_graph::{DepGraph, DepNode, DepKind, DepNodeIndex};\n-\n+use crate::hir::*;\n+use crate::hir::DefKind;\n use crate::hir::def_id::{CRATE_DEF_INDEX, DefId, LocalDefId};\n-\n+use crate::hir::itemlikevisit::ItemLikeVisitor;\n+use crate::hir::print::Nested;\n use crate::middle::cstore::CrateStoreDyn;\n+use crate::ty::query::Providers;\n+use crate::util::nodemap::FxHashMap;\n+use crate::util::common::time;\n \n use rustc_target::spec::abi::Abi;\n use rustc_data_structures::svh::Svh;\n@@ -18,15 +23,7 @@ use syntax::source_map::Spanned;\n use syntax::ext::base::MacroKind;\n use syntax_pos::{Span, DUMMY_SP};\n \n-use crate::hir::*;\n-use crate::hir::DefKind;\n-use crate::hir::itemlikevisit::ItemLikeVisitor;\n-use crate::hir::print::Nested;\n-use crate::util::nodemap::FxHashMap;\n-use crate::util::common::time;\n-\n use std::result::Result::Err;\n-use crate::ty::query::Providers;\n \n pub mod blocks;\n mod collector;\n@@ -360,7 +357,7 @@ impl<'hir> Map<'hir> {\n             Node::Pat(_) |\n             Node::Binding(_) |\n             Node::Local(_) |\n-            Node::Arg(_) |\n+            Node::Param(_) |\n             Node::Arm(_) |\n             Node::Lifetime(_) |\n             Node::Visibility(_) |\n@@ -514,8 +511,7 @@ impl<'hir> Map<'hir> {\n         &self.forest.krate.attrs\n     }\n \n-    pub fn get_module(&self, module: DefId) -> (&'hir Mod, Span, HirId)\n-    {\n+    pub fn get_module(&self, module: DefId) -> (&'hir Mod, Span, HirId) {\n         let hir_id = self.as_local_hir_id(module).unwrap();\n         self.read(hir_id);\n         match self.find_entry(hir_id).unwrap().node {\n@@ -525,7 +521,7 @@ impl<'hir> Map<'hir> {\n                 ..\n             }) => (m, span, hir_id),\n             Node::Crate => (&self.forest.krate.module, self.forest.krate.span, hir_id),\n-            _ => panic!(\"not a module\")\n+            node => panic!(\"not a module: {:?}\", node),\n         }\n     }\n \n@@ -628,7 +624,7 @@ impl<'hir> Map<'hir> {\n             .unwrap_or(hir_id)\n     }\n \n-    /// Check if the node is an argument. An argument is a local variable whose\n+    /// Checks if the node is an argument. An argument is a local variable whose\n     /// immediate parent is an item or a closure.\n     pub fn is_argument(&self, id: HirId) -> bool {\n         match self.find(id) {\n@@ -679,6 +675,16 @@ impl<'hir> Map<'hir> {\n         }\n     }\n \n+    /// Wether `hir_id` corresponds to a `mod` or a crate.\n+    pub fn is_hir_id_module(&self, hir_id: HirId) -> bool {\n+        match self.lookup(hir_id) {\n+            Some(Entry { node: Node::Item(Item { node: ItemKind::Mod(_), .. }), .. }) |\n+            Some(Entry { node: Node::Crate, .. }) => true,\n+            _ => false,\n+        }\n+    }\n+\n+\n     /// If there is some error when walking the parents (e.g., a node does not\n     /// have a parent in the map or a node can't be found), then we return the\n     /// last good `HirId` we found. Note that reaching the crate root (`id == 0`),\n@@ -724,7 +730,7 @@ impl<'hir> Map<'hir> {\n     /// ```\n     /// fn foo(x: usize) -> bool {\n     ///     if x == 1 {\n-    ///         true  // `get_return_block` gets passed the `id` corresponding\n+    ///         true  // If `get_return_block` gets passed the `id` corresponding\n     ///     } else {  // to this, it will return `foo`'s `HirId`.\n     ///         false\n     ///     }\n@@ -734,7 +740,7 @@ impl<'hir> Map<'hir> {\n     /// ```\n     /// fn foo(x: usize) -> bool {\n     ///     loop {\n-    ///         true  // `get_return_block` gets passed the `id` corresponding\n+    ///         true  // If `get_return_block` gets passed the `id` corresponding\n     ///     }         // to this, it will return `None`.\n     ///     false\n     /// }\n@@ -955,7 +961,7 @@ impl<'hir> Map<'hir> {\n     pub fn attrs(&self, id: HirId) -> &'hir [ast::Attribute] {\n         self.read(id); // reveals attributes on the node\n         let attrs = match self.find_entry(id).map(|entry| entry.node) {\n-            Some(Node::Arg(a)) => Some(&a.attrs[..]),\n+            Some(Node::Param(a)) => Some(&a.attrs[..]),\n             Some(Node::Local(l)) => Some(&l.attrs[..]),\n             Some(Node::Item(i)) => Some(&i.attrs[..]),\n             Some(Node::ForeignItem(fi)) => Some(&fi.attrs[..]),\n@@ -985,9 +991,9 @@ impl<'hir> Map<'hir> {\n         self.map.iter().enumerate().filter_map(|(i, local_map)| {\n             local_map.as_ref().map(|m| (i, m))\n         }).flat_map(move |(array_index, local_map)| {\n-            // Iterate over each valid entry in the local map\n+            // Iterate over each valid entry in the local map.\n             local_map.iter_enumerated().filter_map(move |(i, entry)| entry.map(move |_| {\n-                // Reconstruct the HirId based on the 3 indices we used to find it\n+                // Reconstruct the `HirId` based on the 3 indices we used to find it.\n                 HirId {\n                     owner: DefIndex::from(array_index),\n                     local_id: i,\n@@ -1019,7 +1025,7 @@ impl<'hir> Map<'hir> {\n     pub fn span(&self, hir_id: HirId) -> Span {\n         self.read(hir_id); // reveals span from node\n         match self.find_entry(hir_id).map(|entry| entry.node) {\n-            Some(Node::Arg(arg)) => arg.span,\n+            Some(Node::Param(param)) => param.span,\n             Some(Node::Item(item)) => item.span,\n             Some(Node::ForeignItem(foreign_item)) => foreign_item.span,\n             Some(Node::TraitItem(trait_method)) => trait_method.span,\n@@ -1198,7 +1204,7 @@ pub fn map_crate<'hir>(sess: &crate::session::Session,\n         definitions,\n     };\n \n-    time(sess, \"validate hir map\", || {\n+    time(sess, \"validate HIR map\", || {\n         hir_id_validator::check_crate(&map);\n     });\n \n@@ -1214,15 +1220,15 @@ impl<'hir> print::PpAnn for Map<'hir> {\n             Nested::TraitItem(id) => state.print_trait_item(self.trait_item(id)),\n             Nested::ImplItem(id) => state.print_impl_item(self.impl_item(id)),\n             Nested::Body(id) => state.print_expr(&self.body(id).value),\n-            Nested::BodyArgPat(id, i) => state.print_pat(&self.body(id).arguments[i].pat)\n+            Nested::BodyParamPat(id, i) => state.print_pat(&self.body(id).params[i].pat)\n         }\n     }\n }\n \n impl<'a> print::State<'a> {\n     pub fn print_node(&mut self, node: Node<'_>) {\n         match node {\n-            Node::Arg(a)          => self.print_arg(&a),\n+            Node::Param(a)        => self.print_param(&a),\n             Node::Item(a)         => self.print_item(&a),\n             Node::ForeignItem(a)  => self.print_foreign_item(&a),\n             Node::TraitItem(a)    => self.print_trait_item(a),\n@@ -1238,18 +1244,18 @@ impl<'a> print::State<'a> {\n             Node::Pat(a)          => self.print_pat(&a),\n             Node::Arm(a)          => self.print_arm(&a),\n             Node::Block(a)        => {\n-                // containing cbox, will be closed by print-block at }\n+                // Containing cbox, will be closed by print-block at `}`.\n                 self.cbox(print::INDENT_UNIT);\n-                // head-ibox, will be closed by print-block after {\n+                // Head-ibox, will be closed by print-block after `{`.\n                 self.ibox(0);\n                 self.print_block(&a)\n             }\n             Node::Lifetime(a)     => self.print_lifetime(&a),\n             Node::Visibility(a)   => self.print_visibility(&a),\n             Node::GenericParam(_) => bug!(\"cannot print Node::GenericParam\"),\n             Node::Field(_)        => bug!(\"cannot print StructField\"),\n-            // these cases do not carry enough information in the\n-            // hir_map to reconstruct their full structure for pretty\n+            // These cases do not carry enough information in the\n+            // `hir_map` to reconstruct their full structure for pretty\n             // printing.\n             Node::Ctor(..)        => bug!(\"cannot print isolated Ctor\"),\n             Node::Local(a)        => self.print_local_decl(&a),\n@@ -1264,8 +1270,8 @@ fn hir_id_to_string(map: &Map<'_>, id: HirId, include_id: bool) -> String {\n     let id_str = if include_id { &id_str[..] } else { \"\" };\n \n     let path_str = || {\n-        // This functionality is used for debugging, try to use TyCtxt to get\n-        // the user-friendly path, otherwise fall back to stringifying DefPath.\n+        // This functionality is used for debugging, try to use `TyCtxt` to get\n+        // the user-friendly path, otherwise fall back to stringifying `DefPath`.\n         crate::ty::tls::with_opt(|tcx| {\n             if let Some(tcx) = tcx {\n                 let def_id = map.local_def_id(id);\n@@ -1364,8 +1370,8 @@ fn hir_id_to_string(map: &Map<'_>, id: HirId, include_id: bool) -> String {\n         Some(Node::Pat(_)) => {\n             format!(\"pat {}{}\", map.hir_to_pretty_string(id), id_str)\n         }\n-        Some(Node::Arg(_)) => {\n-            format!(\"arg {}{}\", map.hir_to_pretty_string(id), id_str)\n+        Some(Node::Param(_)) => {\n+            format!(\"param {}{}\", map.hir_to_pretty_string(id), id_str)\n         }\n         Some(Node::Arm(_)) => {\n             format!(\"arm {}{}\", map.hir_to_pretty_string(id), id_str)"}, {"sha": "f5e644625729b98f75a8ca095418be2a2f4a8fa8", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 36, "deletions": 37, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -13,26 +13,24 @@ pub use self::UnsafeSource::*;\n use crate::hir::def::{Res, DefKind};\n use crate::hir::def_id::{DefId, DefIndex, LocalDefId, CRATE_DEF_INDEX};\n use crate::hir::ptr::P;\n-use crate::util::nodemap::{NodeMap, FxHashSet};\n use crate::mir::mono::Linkage;\n+use crate::ty::AdtKind;\n+use crate::ty::query::Providers;\n+use crate::util::nodemap::{NodeMap, FxHashSet};\n \n use errors::FatalError;\n use syntax_pos::{Span, DUMMY_SP, symbol::InternedString, MultiSpan};\n use syntax::source_map::Spanned;\n-use rustc_target::spec::abi::Abi;\n use syntax::ast::{self, CrateSugar, Ident, Name, NodeId, AsmDialect};\n use syntax::ast::{Attribute, Label, LitKind, StrStyle, FloatTy, IntTy, UintTy};\n use syntax::attr::{InlineAttr, OptimizeAttr};\n use syntax::symbol::{Symbol, kw};\n use syntax::tokenstream::TokenStream;\n use syntax::util::parser::ExprPrecedence;\n-use crate::ty::AdtKind;\n-use crate::ty::query::Providers;\n-\n+use rustc_target::spec::abi::Abi;\n use rustc_data_structures::sync::{par_for_each_in, Send, Sync};\n use rustc_data_structures::thin_vec::ThinVec;\n use rustc_macros::HashStable;\n-\n use rustc_serialize::{self, Encoder, Encodable, Decoder, Decodable};\n use std::collections::{BTreeSet, BTreeMap};\n use std::fmt;\n@@ -99,7 +97,8 @@ impl rustc_serialize::UseSpecializedEncodable for HirId {\n         } = *self;\n \n         owner.encode(s)?;\n-        local_id.encode(s)\n+        local_id.encode(s)?;\n+        Ok(())\n     }\n }\n \n@@ -121,7 +120,7 @@ impl fmt::Display for HirId {\n     }\n }\n \n-// Hack to ensure that we don't try to access the private parts of `ItemLocalId` in this module\n+// Hack to ensure that we don't try to access the private parts of `ItemLocalId` in this module.\n mod item_local_id_inner {\n     use rustc_data_structures::indexed_vec::Idx;\n     use rustc_macros::HashStable;\n@@ -746,7 +745,7 @@ pub struct Crate {\n     // Attributes from non-exported macros, kept only for collecting the library feature list.\n     pub non_exported_macro_attrs: HirVec<Attribute>,\n \n-    // N.B., we use a BTreeMap here so that `visit_all_items` iterates\n+    // N.B., we use a `BTreeMap` here so that `visit_all_items` iterates\n     // over the ids in increasing order. In principle it should not\n     // matter what order we visit things in, but in *practice* it\n     // does, because it can affect the order in which errors are\n@@ -1030,7 +1029,7 @@ pub enum Mutability {\n }\n \n impl Mutability {\n-    /// Returns `MutMutable` only if both arguments are mutable.\n+    /// Returns `MutMutable` only if both `self` and `other` are mutable.\n     pub fn and(self, other: Self) -> Self {\n         match self {\n             MutMutable => other,\n@@ -1324,15 +1323,15 @@ pub struct BodyId {\n ///\n /// Here, the `Body` associated with `foo()` would contain:\n ///\n-/// - an `arguments` array containing the `(x, y)` pattern\n+/// - an `params` array containing the `(x, y)` pattern\n /// - a `value` containing the `x + y` expression (maybe wrapped in a block)\n /// - `generator_kind` would be `None`\n ///\n /// All bodies have an **owner**, which can be accessed via the HIR\n /// map using `body_owner_def_id()`.\n #[derive(RustcEncodable, RustcDecodable, Debug)]\n pub struct Body {\n-    pub arguments: HirVec<Arg>,\n+    pub params: HirVec<Param>,\n     pub value: Expr,\n     pub generator_kind: Option<GeneratorKind>,\n }\n@@ -1403,13 +1402,13 @@ pub struct AnonConst {\n     pub body: BodyId,\n }\n \n-/// An expression\n+/// An expression.\n #[derive(RustcEncodable, RustcDecodable)]\n pub struct Expr {\n-    pub span: Span,\n+    pub hir_id: HirId,\n     pub node: ExprKind,\n     pub attrs: ThinVec<Attribute>,\n-    pub hir_id: HirId,\n+    pub span: Span,\n }\n \n // `Expr` is used a lot. Make sure it doesn't unintentionally get bigger.\n@@ -1644,7 +1643,7 @@ pub enum LocalSource {\n     /// A desugared `for _ in _ { .. }` loop.\n     ForLoopDesugar,\n     /// When lowering async functions, we create locals within the `async move` so that\n-    /// all arguments are dropped after the future is polled.\n+    /// all parameters are dropped after the future is polled.\n     ///\n     /// ```ignore (pseudo-Rust)\n     /// async fn foo(<pattern> @ x: Type) {\n@@ -1940,7 +1939,7 @@ pub struct BareFnTy {\n     pub abi: Abi,\n     pub generic_params: HirVec<GenericParam>,\n     pub decl: P<FnDecl>,\n-    pub arg_names: HirVec<Ident>,\n+    pub param_names: HirVec<Ident>,\n }\n \n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n@@ -2027,9 +2026,9 @@ pub struct InlineAsm {\n     pub dialect: AsmDialect,\n }\n \n-/// Represents an argument in a function header.\n+/// Represents a parameter in a function header.\n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n-pub struct Arg {\n+pub struct Param {\n     pub attrs: HirVec<Attribute>,\n     pub hir_id: HirId,\n     pub pat: P<Pat>,\n@@ -2039,9 +2038,9 @@ pub struct Arg {\n /// Represents the header (not the body) of a function declaration.\n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct FnDecl {\n-    /// The types of the function's arguments.\n+    /// The types of the function's parameters.\n     ///\n-    /// Additional argument data is stored in the function's [body](Body::arguments).\n+    /// Additional argument data is stored in the function's [body](Body::parameters).\n     pub inputs: HirVec<Ty>,\n     pub output: FunctionRetTy,\n     pub c_variadic: bool,\n@@ -2422,37 +2421,37 @@ pub enum ItemKind {\n     ///\n     /// or just\n     ///\n-    /// `use foo::bar::baz;` (with `as baz` implicitly on the right)\n+    /// `use foo::bar::baz;` (with `as baz` implicitly on the right).\n     Use(P<Path>, UseKind),\n \n-    /// A `static` item\n+    /// A `static` item.\n     Static(P<Ty>, Mutability, BodyId),\n-    /// A `const` item\n+    /// A `const` item.\n     Const(P<Ty>, BodyId),\n-    /// A function declaration\n+    /// A function declaration.\n     Fn(P<FnDecl>, FnHeader, Generics, BodyId),\n-    /// A module\n+    /// A module.\n     Mod(Mod),\n-    /// An external module\n+    /// An external module.\n     ForeignMod(ForeignMod),\n-    /// Module-level inline assembly (from global_asm!)\n+    /// Module-level inline assembly (from `global_asm!`).\n     GlobalAsm(P<GlobalAsm>),\n-    /// A type alias, e.g., `type Foo = Bar<u8>`\n+    /// A type alias, e.g., `type Foo = Bar<u8>`.\n     TyAlias(P<Ty>, Generics),\n-    /// An opaque `impl Trait` type alias, e.g., `type Foo = impl Bar;`\n+    /// An opaque `impl Trait` type alias, e.g., `type Foo = impl Bar;`.\n     OpaqueTy(OpaqueTy),\n-    /// An enum definition, e.g., `enum Foo<A, B> {C<A>, D<B>}`\n+    /// An enum definition, e.g., `enum Foo<A, B> {C<A>, D<B>}`.\n     Enum(EnumDef, Generics),\n-    /// A struct definition, e.g., `struct Foo<A> {x: A}`\n+    /// A struct definition, e.g., `struct Foo<A> {x: A}`.\n     Struct(VariantData, Generics),\n-    /// A union definition, e.g., `union Foo<A, B> {x: A, y: B}`\n+    /// A union definition, e.g., `union Foo<A, B> {x: A, y: B}`.\n     Union(VariantData, Generics),\n-    /// A trait definition\n+    /// A trait definition.\n     Trait(IsAuto, Unsafety, Generics, GenericBounds, HirVec<TraitItemRef>),\n-    /// A trait alias\n+    /// A trait alias.\n     TraitAlias(Generics, GenericBounds),\n \n-    /// An implementation, eg `impl<A> Trait for Foo { .. }`\n+    /// An implementation, e.g., `impl<A> Trait for Foo { .. }`.\n     Impl(Unsafety,\n          ImplPolarity,\n          Defaultness,\n@@ -2721,7 +2720,7 @@ impl CodegenFnAttrs {\n \n #[derive(Copy, Clone, Debug)]\n pub enum Node<'hir> {\n-    Arg(&'hir Arg),\n+    Param(&'hir Param),\n     Item(&'hir Item),\n     ForeignItem(&'hir ForeignItem),\n     TraitItem(&'hir TraitItem),"}, {"sha": "cfbfb5eceb550f4016afe6b49f82cc29b462de5b", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 21, "deletions": 20, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -33,7 +33,7 @@ pub enum Nested {\n     TraitItem(hir::TraitItemId),\n     ImplItem(hir::ImplItemId),\n     Body(hir::BodyId),\n-    BodyArgPat(hir::BodyId, usize)\n+    BodyParamPat(hir::BodyId, usize)\n }\n \n pub trait PpAnn {\n@@ -62,7 +62,7 @@ impl PpAnn for hir::Crate {\n             Nested::TraitItem(id) => state.print_trait_item(self.trait_item(id)),\n             Nested::ImplItem(id) => state.print_impl_item(self.impl_item(id)),\n             Nested::Body(id) => state.print_expr(&self.body(id).value),\n-            Nested::BodyArgPat(id, i) => state.print_pat(&self.body(id).arguments[i].pat)\n+            Nested::BodyParamPat(id, i) => state.print_pat(&self.body(id).params[i].pat)\n         }\n     }\n }\n@@ -318,7 +318,7 @@ impl<'a> State<'a> {\n             }\n             hir::TyKind::BareFn(ref f) => {\n                 self.print_ty_fn(f.abi, f.unsafety, &f.decl, None, &f.generic_params,\n-                                 &f.arg_names[..]);\n+                                 &f.param_names[..]);\n             }\n             hir::TyKind::Def(..) => {},\n             hir::TyKind::Path(ref qpath) => {\n@@ -1290,14 +1290,14 @@ impl<'a> State<'a> {\n             hir::ExprKind::Closure(capture_clause, ref decl, body, _fn_decl_span, _gen) => {\n                 self.print_capture_clause(capture_clause);\n \n-                self.print_closure_args(&decl, body);\n+                self.print_closure_params(&decl, body);\n                 self.s.space();\n \n-                // this is a bare expression\n+                // This is a bare expression.\n                 self.ann.nested(self, Nested::Body(body));\n                 self.end(); // need to close a box\n \n-                // a box will be closed by print_expr, but we didn't want an overall\n+                // A box will be closed by `print_expr`, but we didn't want an overall\n                 // wrapper so we closed the corresponding opening. so create an\n                 // empty box to satisfy the close.\n                 self.ibox(0);\n@@ -1307,9 +1307,9 @@ impl<'a> State<'a> {\n                     self.print_ident(label.ident);\n                     self.word_space(\":\");\n                 }\n-                // containing cbox, will be closed by print-block at }\n+                // containing cbox, will be closed by print-block at `}`\n                 self.cbox(INDENT_UNIT);\n-                // head-box, will be closed by print-block after {\n+                // head-box, will be closed by print-block after `{`\n                 self.ibox(0);\n                 self.print_block(&blk);\n             }\n@@ -1759,7 +1759,7 @@ impl<'a> State<'a> {\n                         self.word_space(\",\");\n                     }\n                     if let PatKind::Wild = p.node {\n-                        // Print nothing\n+                        // Print nothing.\n                     } else {\n                         self.print_pat(&p);\n                     }\n@@ -1775,7 +1775,7 @@ impl<'a> State<'a> {\n         self.ann.post(self, AnnNode::Pat(pat))\n     }\n \n-    pub fn print_arg(&mut self, arg: &hir::Arg) {\n+    pub fn print_param(&mut self, arg: &hir::Param) {\n         self.print_outer_attributes(&arg.attrs);\n         self.print_pat(&arg.pat);\n     }\n@@ -1864,7 +1864,7 @@ impl<'a> State<'a> {\n                 s.s.word(\":\");\n                 s.s.space();\n             } else if let Some(body_id) = body_id {\n-                s.ann.nested(s, Nested::BodyArgPat(body_id, i));\n+                s.ann.nested(s, Nested::BodyParamPat(body_id, i));\n                 s.s.word(\":\");\n                 s.s.space();\n             }\n@@ -1881,17 +1881,17 @@ impl<'a> State<'a> {\n         self.print_where_clause(&generics.where_clause)\n     }\n \n-    fn print_closure_args(&mut self, decl: &hir::FnDecl, body_id: hir::BodyId) {\n+    fn print_closure_params(&mut self, decl: &hir::FnDecl, body_id: hir::BodyId) {\n         self.s.word(\"|\");\n         let mut i = 0;\n         self.commasep(Inconsistent, &decl.inputs, |s, ty| {\n             s.ibox(INDENT_UNIT);\n \n-            s.ann.nested(s, Nested::BodyArgPat(body_id, i));\n+            s.ann.nested(s, Nested::BodyParamPat(body_id, i));\n             i += 1;\n \n             if let hir::TyKind::Infer = ty.node {\n-                // Print nothing\n+                // Print nothing.\n             } else {\n                 s.s.word(\":\");\n                 s.s.space();\n@@ -2221,14 +2221,15 @@ impl<'a> State<'a> {\n     }\n }\n \n-// Dup'ed from parse::classify, but adapted for the HIR.\n /// Does this expression require a semicolon to be treated\n /// as a statement? The negation of this: 'can this expression\n /// be used as a statement without a semicolon' -- is used\n /// as an early-bail-out in the parser so that, for instance,\n ///     if true {...} else {...}\n ///      |x| 5\n /// isn't parsed as (if true {...} else {...} | x) | 5\n+//\n+// Duplicated from `parse::classify`, but adapted for the HIR.\n fn expr_requires_semi_to_be_stmt(e: &hir::Expr) -> bool {\n     match e.node {\n         hir::ExprKind::Match(..) |\n@@ -2238,7 +2239,7 @@ fn expr_requires_semi_to_be_stmt(e: &hir::Expr) -> bool {\n     }\n }\n \n-/// this statement requires a semicolon after it.\n+/// This statement requires a semicolon after it.\n /// note that in one case (stmt_semi), we've already\n /// seen the semicolon, and thus don't need another.\n fn stmt_ends_with_semi(stmt: &hir::StmtKind) -> bool {\n@@ -2277,7 +2278,7 @@ fn bin_op_to_assoc_op(op: hir::BinOpKind) -> AssocOp {\n     }\n }\n \n-/// Expressions that syntactically contain an \"exterior\" struct literal i.e., not surrounded by any\n+/// Expressions that syntactically contain an \"exterior\" struct literal, i.e., not surrounded by any\n /// parens or other delimiters, e.g., `X { y: 1 }`, `X { y: 1 }.method()`, `foo == X { y: 1 }` and\n /// `X { y: 1 } == foo` all do, but `(X { y: 1 }) == foo` does not.\n fn contains_exterior_struct_lit(value: &hir::Expr) -> bool {\n@@ -2287,20 +2288,20 @@ fn contains_exterior_struct_lit(value: &hir::Expr) -> bool {\n         hir::ExprKind::Assign(ref lhs, ref rhs) |\n         hir::ExprKind::AssignOp(_, ref lhs, ref rhs) |\n         hir::ExprKind::Binary(_, ref lhs, ref rhs) => {\n-            // X { y: 1 } + X { y: 2 }\n+            // `X { y: 1 } + X { y: 2 }`\n             contains_exterior_struct_lit(&lhs) || contains_exterior_struct_lit(&rhs)\n         }\n         hir::ExprKind::Unary(_, ref x) |\n         hir::ExprKind::Cast(ref x, _) |\n         hir::ExprKind::Type(ref x, _) |\n         hir::ExprKind::Field(ref x, _) |\n         hir::ExprKind::Index(ref x, _) => {\n-            // &X { y: 1 }, X { y: 1 }.y\n+            // `&X { y: 1 }, X { y: 1 }.y`\n             contains_exterior_struct_lit(&x)\n         }\n \n         hir::ExprKind::MethodCall(.., ref exprs) => {\n-            // X { y: 1 }.bar(...)\n+            // `X { y: 1 }.bar(...)`\n             contains_exterior_struct_lit(&exprs[0])\n         }\n "}, {"sha": "182a9ade8c36ead44a39da901c9126bc1cf5c4b3", "filename": "src/librustc/ich/hcx.rs", "status": "modified", "additions": 25, "deletions": 29, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Fich%2Fhcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Fich%2Fhcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fhcx.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -12,17 +12,16 @@ use std::hash as std_hash;\n use std::cell::RefCell;\n \n use syntax::ast;\n-\n use syntax::source_map::SourceMap;\n use syntax::ext::hygiene::SyntaxContext;\n use syntax::symbol::Symbol;\n use syntax::tokenstream::DelimSpan;\n use syntax_pos::{Span, DUMMY_SP};\n use syntax_pos::hygiene;\n \n-use rustc_data_structures::stable_hasher::{HashStable,\n-                                           StableHasher, StableHasherResult,\n-                                           ToStableHashKey};\n+use rustc_data_structures::stable_hasher::{\n+    HashStable, StableHasher, StableHasherResult, ToStableHashKey,\n+};\n use rustc_data_structures::fx::{FxHashSet, FxHashMap};\n use smallvec::SmallVec;\n \n@@ -32,9 +31,9 @@ fn compute_ignored_attr_names() -> FxHashSet<Symbol> {\n }\n \n /// This is the context state available during incr. comp. hashing. It contains\n-/// enough information to transform DefIds and HirIds into stable DefPaths (i.e.\n-/// a reference to the TyCtxt) and it holds a few caches for speeding up various\n-/// things (e.g., each DefId/DefPath is only hashed once).\n+/// enough information to transform `DefId`s and `HirId`s into stable `DefPath`s (i.e.,\n+/// a reference to the `TyCtxt`) and it holds a few caches for speeding up various\n+/// things (e.g., each `DefId`/`DefPath` is only hashed once).\n #[derive(Clone)]\n pub struct StableHashingContext<'a> {\n     sess: &'a Session,\n@@ -46,7 +45,7 @@ pub struct StableHashingContext<'a> {\n     node_id_hashing_mode: NodeIdHashingMode,\n \n     // Very often, we are hashing something that does not need the\n-    // CachingSourceMapView, so we initialize it lazily.\n+    // `CachingSourceMapView`, so we initialize it lazily.\n     raw_source_map: &'a SourceMap,\n     caching_source_map: Option<CachingSourceMapView<'a>>,\n }\n@@ -57,24 +56,24 @@ pub enum NodeIdHashingMode {\n     HashDefPath,\n }\n \n-/// The BodyResolver allows to map a BodyId to the corresponding hir::Body.\n-/// We could also just store a plain reference to the hir::Crate but we want\n+/// The `BodyResolver` allows mapping a `BodyId` to the corresponding `hir::Body`.\n+/// We could also just store a plain reference to the `hir::Crate` but we want\n /// to avoid that the crate is used to get untracked access to all of the HIR.\n #[derive(Clone, Copy)]\n struct BodyResolver<'tcx>(&'tcx hir::Crate);\n \n impl<'tcx> BodyResolver<'tcx> {\n-    // Return a reference to the hir::Body with the given BodyId.\n-    // DOES NOT DO ANY TRACKING, use carefully.\n+    /// Returns a reference to the `hir::Body` with the given `BodyId`.\n+    /// **Does not do any tracking**; use carefully.\n     fn body(self, id: hir::BodyId) -> &'tcx hir::Body {\n         self.0.body(id)\n     }\n }\n \n impl<'a> StableHashingContext<'a> {\n-    // The `krate` here is only used for mapping BodyIds to Bodies.\n-    // Don't use it for anything else or you'll run the risk of\n-    // leaking data out of the tracking system.\n+    /// The `krate` here is only used for mapping `BodyId`s to `Body`s.\n+    /// Don't use it for anything else or you'll run the risk of\n+    /// leaking data out of the tracking system.\n     #[inline]\n     pub fn new(sess: &'a Session,\n                krate: &'a hir::Crate,\n@@ -217,9 +216,7 @@ impl<'a> StableHashingContextProvider<'a> for StableHashingContext<'a> {\n     }\n }\n \n-impl<'a> crate::dep_graph::DepGraphSafe for StableHashingContext<'a> {\n-}\n-\n+impl<'a> crate::dep_graph::DepGraphSafe for StableHashingContext<'a> {}\n \n impl<'a> HashStable<StableHashingContext<'a>> for hir::BodyId {\n     fn hash_stable<W: StableHasherResult>(&self,\n@@ -292,16 +289,15 @@ impl<'a> ToStableHashKey<StableHashingContext<'a>> for ast::NodeId {\n }\n \n impl<'a> HashStable<StableHashingContext<'a>> for Span {\n-\n-    // Hash a span in a stable way. We can't directly hash the span's BytePos\n-    // fields (that would be similar to hashing pointers, since those are just\n-    // offsets into the SourceMap). Instead, we hash the (file name, line, column)\n-    // triple, which stays the same even if the containing SourceFile has moved\n-    // within the SourceMap.\n-    // Also note that we are hashing byte offsets for the column, not unicode\n-    // codepoint offsets. For the purpose of the hash that's sufficient.\n-    // Also, hashing filenames is expensive so we avoid doing it twice when the\n-    // span starts and ends in the same file, which is almost always the case.\n+    /// Hashes a span in a stable way. We can't directly hash the span's `BytePos`\n+    /// fields (that would be similar to hashing pointers, since those are just\n+    /// offsets into the `SourceMap`). Instead, we hash the (file name, line, column)\n+    /// triple, which stays the same even if the containing `SourceFile` has moved\n+    /// within the `SourceMap`.\n+    /// Also note that we are hashing byte offsets for the column, not unicode\n+    /// codepoint offsets. For the purpose of the hash that's sufficient.\n+    /// Also, hashing filenames is expensive so we avoid doing it twice when the\n+    /// span starts and ends in the same file, which is almost always the case.\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n@@ -340,7 +336,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for Span {\n         }\n \n         std_hash::Hash::hash(&TAG_VALID_SPAN, hasher);\n-        // We truncate the stable_id hash and line and col numbers. The chances\n+        // We truncate the stable ID hash and line and column numbers. The chances\n         // of causing a collision this way should be minimal.\n         std_hash::Hash::hash(&(file_lo.name_hash as u64), hasher);\n "}, {"sha": "6e6492d0426f257c7fe9927b9361f9c9c5a3bf48", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -5,8 +5,10 @@ use crate::hir;\n use crate::hir::map::DefPathHash;\n use crate::hir::def_id::{DefId, LocalDefId, CrateNum, CRATE_DEF_INDEX};\n use crate::ich::{StableHashingContext, NodeIdHashingMode, Fingerprint};\n-use rustc_data_structures::stable_hasher::{HashStable, ToStableHashKey,\n-                                           StableHasher, StableHasherResult};\n+\n+use rustc_data_structures::stable_hasher::{\n+    HashStable, ToStableHashKey, StableHasher, StableHasherResult,\n+};\n use smallvec::SmallVec;\n use std::mem;\n use syntax::ast;\n@@ -82,9 +84,9 @@ for hir::ItemLocalId {\n     }\n }\n \n-// The following implementations of HashStable for ItemId, TraitItemId, and\n-// ImplItemId deserve special attention. Normally we do not hash NodeIds within\n-// the HIR, since they just signify a HIR nodes own path. But ItemId et al\n+// The following implementations of HashStable for `ItemId`, `TraitItemId`, and\n+// `ImplItemId` deserve special attention. Normally we do not hash `NodeId`s within\n+// the HIR, since they just signify a HIR nodes own path. But `ItemId` et al\n // are used when another item in the HIR is *referenced* and we certainly\n // want to pick up on a reference changing its target, so we hash the NodeIds\n // in \"DefPath Mode\".\n@@ -131,7 +133,6 @@ impl<'a> HashStable<StableHashingContext<'a>> for hir::ImplItemId {\n     }\n }\n \n-\n impl_stable_hash_for!(struct ast::Label {\n     ident\n });\n@@ -241,7 +242,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for hir::ImplItem {\n     }\n }\n \n-impl_stable_hash_for!(enum ::syntax::ast::CrateSugar {\n+impl_stable_hash_for!(enum ast::CrateSugar {\n     JustCrate,\n     PubCrate,\n });\n@@ -331,13 +332,13 @@ impl<'a> HashStable<StableHashingContext<'a>> for hir::Body {\n                                           hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         let hir::Body {\n-            arguments,\n+            params,\n             value,\n             generator_kind,\n         } = self;\n \n         hcx.with_node_id_hashing_mode(NodeIdHashingMode::Ignore, |hcx| {\n-            arguments.hash_stable(hcx, hasher);\n+            params.hash_stable(hcx, hasher);\n             value.hash_stable(hcx, hasher);\n             generator_kind.hash_stable(hcx, hasher);\n         });\n@@ -365,8 +366,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for hir::def_id::DefIndex {\n     }\n }\n \n-impl<'a> ToStableHashKey<StableHashingContext<'a>>\n-for hir::def_id::DefIndex {\n+impl<'a> ToStableHashKey<StableHashingContext<'a>> for hir::def_id::DefIndex {\n     type KeyType = DefPathHash;\n \n     #[inline]"}, {"sha": "a33181e5925cda13aef96e1b5f138237beb138e3", "filename": "src/librustc/ich/impls_syntax.rs", "status": "modified", "additions": 11, "deletions": 24, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_syntax.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -9,7 +9,7 @@ use std::mem;\n use syntax::ast;\n use syntax::feature_gate;\n use syntax::parse::token;\n-use syntax::symbol::{InternedString, LocalInternedString};\n+use syntax::symbol::InternedString;\n use syntax::tokenstream;\n use syntax_pos::SourceFile;\n \n@@ -39,27 +39,6 @@ impl<'a> ToStableHashKey<StableHashingContext<'a>> for InternedString {\n     }\n }\n \n-impl<'a> HashStable<StableHashingContext<'a>> for LocalInternedString {\n-    #[inline]\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        let s: &str = &**self;\n-        s.hash_stable(hcx, hasher);\n-    }\n-}\n-\n-impl<'a> ToStableHashKey<StableHashingContext<'a>> for LocalInternedString {\n-    type KeyType = LocalInternedString;\n-\n-    #[inline]\n-    fn to_stable_hash_key(&self,\n-                          _: &StableHashingContext<'a>)\n-                          -> LocalInternedString {\n-        self.clone()\n-    }\n-}\n-\n impl<'a> HashStable<StableHashingContext<'a>> for ast::Name {\n     #[inline]\n     fn hash_stable<W: StableHasherResult>(&self,\n@@ -136,9 +115,10 @@ for ::syntax::attr::StabilityLevel {\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n-            ::syntax::attr::StabilityLevel::Unstable { ref reason, ref issue } => {\n+            ::syntax::attr::StabilityLevel::Unstable { ref reason, ref issue, ref is_soft } => {\n                 reason.hash_stable(hcx, hasher);\n                 issue.hash_stable(hcx, hasher);\n+                is_soft.hash_stable(hcx, hasher);\n             }\n             ::syntax::attr::StabilityLevel::Stable { ref since } => {\n                 since.hash_stable(hcx, hasher);\n@@ -402,7 +382,6 @@ impl_stable_hash_for!(struct ::syntax_pos::hygiene::ExpnData {\n     parent -> _,\n     call_site,\n     def_site,\n-    default_transparency,\n     allow_internal_unstable,\n     allow_internal_unsafe,\n     local_inner_macros,\n@@ -412,9 +391,17 @@ impl_stable_hash_for!(struct ::syntax_pos::hygiene::ExpnData {\n impl_stable_hash_for!(enum ::syntax_pos::hygiene::ExpnKind {\n     Root,\n     Macro(kind, descr),\n+    AstPass(kind),\n     Desugaring(kind)\n });\n \n+impl_stable_hash_for!(enum ::syntax_pos::hygiene::AstPass {\n+    StdImports,\n+    TestHarness,\n+    ProcMacroHarness,\n+    PluginMacroDefs,\n+});\n+\n impl_stable_hash_for!(enum ::syntax_pos::hygiene::DesugaringKind {\n     CondTemporary,\n     Async,"}, {"sha": "f230c53728748d4a215cc7186a98b79303977fee", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 11, "deletions": 15, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -168,25 +168,21 @@ impl<'a> HashStable<StableHashingContext<'a>> for mir::interpret::AllocId {\n     }\n }\n \n-// Allocations treat their relocations specially\n-impl<'a> HashStable<StableHashingContext<'a>> for mir::interpret::Allocation {\n+// `Relocations` with default type parameters is a sorted map.\n+impl<'a, Tag> HashStable<StableHashingContext<'a>>\n+for mir::interpret::Relocations<Tag>\n+where\n+    Tag: HashStable<StableHashingContext<'a>>,\n+{\n     fn hash_stable<W: StableHasherResult>(\n         &self,\n         hcx: &mut StableHashingContext<'a>,\n         hasher: &mut StableHasher<W>,\n     ) {\n-        let mir::interpret::Allocation {\n-            bytes, relocations, undef_mask, align, mutability,\n-            extra: _,\n-        } = self;\n-        bytes.hash_stable(hcx, hasher);\n-        relocations.len().hash_stable(hcx, hasher);\n-        for reloc in relocations.iter() {\n+        self.len().hash_stable(hcx, hasher);\n+        for reloc in self.iter() {\n             reloc.hash_stable(hcx, hasher);\n         }\n-        undef_mask.hash_stable(hcx, hasher);\n-        align.hash_stable(hcx, hasher);\n-        mutability.hash_stable(hcx, hasher);\n     }\n }\n \n@@ -208,7 +204,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for ty::TyVid {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           _hcx: &mut StableHashingContext<'a>,\n                                           _hasher: &mut StableHasher<W>) {\n-        // TyVid values are confined to an inference context and hence\n+        // `TyVid` values are confined to an inference context and hence\n         // should not be hashed.\n         bug!(\"ty::TyKind::hash_stable() - can't hash a TyVid {:?}.\", *self)\n     }\n@@ -218,7 +214,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for ty::IntVid {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           _hcx: &mut StableHashingContext<'a>,\n                                           _hasher: &mut StableHasher<W>) {\n-        // IntVid values are confined to an inference context and hence\n+        // `IntVid` values are confined to an inference context and hence\n         // should not be hashed.\n         bug!(\"ty::TyKind::hash_stable() - can't hash an IntVid {:?}.\", *self)\n     }\n@@ -228,7 +224,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for ty::FloatVid {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           _hcx: &mut StableHashingContext<'a>,\n                                           _hasher: &mut StableHasher<W>) {\n-        // FloatVid values are confined to an inference context and hence\n+        // `FloatVid` values are confined to an inference context and hence\n         // should not be hashed.\n         bug!(\"ty::TyKind::hash_stable() - can't hash a FloatVid {:?}.\", *self)\n     }"}, {"sha": "5883be6e26883b636527e0f5821979aecda787d5", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -1136,12 +1136,19 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         if let Some((expected, found)) = expected_found {\n             match (terr, is_simple_error, expected == found) {\n                 (&TypeError::Sorts(ref values), false, true) => {\n+                    let sort_string = | a_type: Ty<'tcx> |\n+                        if let ty::Opaque(def_id, _) = a_type.sty {\n+                            format!(\" (opaque type at {})\", self.tcx.sess.source_map()\n+                                .mk_substr_filename(self.tcx.def_span(def_id)))\n+                        } else {\n+                            format!(\" ({})\", a_type.sort_string(self.tcx))\n+                        };\n                     diag.note_expected_found_extra(\n                         &\"type\",\n                         expected,\n                         found,\n-                        &format!(\" ({})\", values.expected.sort_string(self.tcx)),\n-                        &format!(\" ({})\", values.found.sort_string(self.tcx)),\n+                        &sort_string(values.expected),\n+                        &sort_string(values.found),\n                     );\n                 }\n                 (_, false, _) => {\n@@ -1627,7 +1634,7 @@ impl<'tcx> ObligationCause<'tcx> {\n             MainFunctionType => Error0580(\"main function has wrong type\"),\n             StartFunctionType => Error0308(\"start function has wrong type\"),\n             IntrinsicType => Error0308(\"intrinsic has wrong type\"),\n-            MethodReceiver => Error0308(\"mismatched method receiver\"),\n+            MethodReceiver => Error0308(\"mismatched `self` parameter type\"),\n \n             // In the case where we have no more specific thing to\n             // say, also take a look at the error code, maybe we can\n@@ -1636,6 +1643,9 @@ impl<'tcx> ObligationCause<'tcx> {\n                 TypeError::CyclicTy(ty) if ty.is_closure() || ty.is_generator() => {\n                     Error0644(\"closure/generator type that references itself\")\n                 }\n+                TypeError::IntrinsicCast => {\n+                    Error0308(\"cannot coerce intrinsics to function pointers\")\n+                }\n                 _ => Error0308(\"mismatched types\"),\n             },\n         }\n@@ -1650,7 +1660,7 @@ impl<'tcx> ObligationCause<'tcx> {\n                 hir::MatchSource::IfLetDesugar { .. } => \"`if let` arms have compatible types\",\n                 _ => \"match arms have compatible types\",\n             },\n-            IfExpression { .. } => \"if and else have compatible types\",\n+            IfExpression { .. } => \"if and else have incompatible types\",\n             IfExpressionWithNoElse => \"if missing an else returns ()\",\n             MainFunctionType => \"`main` function has the correct type\",\n             StartFunctionType => \"`start` function has the correct type\","}, {"sha": "7068fe3601a62de8e562237094ce5afde888a230", "filename": "src/librustc/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 35, "deletions": 10, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -78,12 +78,12 @@ impl<'a, 'tcx> Visitor<'tcx> for FindLocalByTypeVisitor<'a, 'tcx> {\n     }\n \n     fn visit_body(&mut self, body: &'tcx Body) {\n-        for argument in &body.arguments {\n+        for param in &body.params {\n             if let (None, Some(ty)) = (\n                 self.found_arg_pattern,\n-                self.node_matches_type(argument.hir_id),\n+                self.node_matches_type(param.hir_id),\n             ) {\n-                self.found_arg_pattern = Some(&*argument.pat);\n+                self.found_arg_pattern = Some(&*param.pat);\n                 self.found_ty = Some(ty);\n             }\n         }\n@@ -150,12 +150,12 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         &self,\n         ty: Ty<'tcx>,\n         highlight: Option<ty::print::RegionHighlightMode>,\n-    ) -> String {\n+    ) -> (String, Option<Span>) {\n         if let ty::Infer(ty::TyVar(ty_vid)) = ty.sty {\n             let ty_vars = self.type_variables.borrow();\n-            if let TypeVariableOriginKind::TypeParameterDefinition(name) =\n-                ty_vars.var_origin(ty_vid).kind {\n-                return name.to_string();\n+            let var_origin = ty_vars.var_origin(ty_vid);\n+            if let TypeVariableOriginKind::TypeParameterDefinition(name) = var_origin.kind {\n+                return (name.to_string(), Some(var_origin.span));\n             }\n         }\n \n@@ -165,7 +165,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             printer.region_highlight_mode = highlight;\n         }\n         let _ = ty.print(printer);\n-        s\n+        (s, None)\n     }\n \n     pub fn need_type_info_err(\n@@ -175,7 +175,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         ty: Ty<'tcx>,\n     ) -> DiagnosticBuilder<'tcx> {\n         let ty = self.resolve_vars_if_possible(&ty);\n-        let name = self.extract_type_name(&ty, None);\n+        let (name, name_sp) = self.extract_type_name(&ty, None);\n \n         let mut local_visitor = FindLocalByTypeVisitor::new(&self, ty, &self.tcx.hir());\n         let ty_to_string = |ty: Ty<'tcx>| -> String {\n@@ -200,6 +200,14 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         }\n         let err_span = if let Some(pattern) = local_visitor.found_arg_pattern {\n             pattern.span\n+        } else if let Some(span) = name_sp {\n+            // `span` here lets us point at `sum` instead of the entire right hand side expr:\n+            // error[E0282]: type annotations needed\n+            //  --> file2.rs:3:15\n+            //   |\n+            // 3 |     let _ = x.sum() as f64;\n+            //   |               ^^^ cannot infer type for `S`\n+            span\n         } else {\n             span\n         };\n@@ -325,6 +333,23 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             };\n             err.span_label(pattern.span, msg);\n         }\n+        // Instead of the following:\n+        // error[E0282]: type annotations needed\n+        //  --> file2.rs:3:15\n+        //   |\n+        // 3 |     let _ = x.sum() as f64;\n+        //   |             --^^^--------- cannot infer type for `S`\n+        //   |\n+        //   = note: type must be known at this point\n+        // We want:\n+        // error[E0282]: type annotations needed\n+        //  --> file2.rs:3:15\n+        //   |\n+        // 3 |     let _ = x.sum() as f64;\n+        //   |               ^^^ cannot infer type for `S`\n+        //   |\n+        //   = note: type must be known at this point\n+        let span = name_sp.unwrap_or(span);\n         if !err.span.span_labels().iter().any(|span_label| {\n                 span_label.label.is_some() && span_label.span == span\n             }) && local_visitor.found_arg_pattern.is_none()\n@@ -342,7 +367,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         ty: Ty<'tcx>,\n     ) -> DiagnosticBuilder<'tcx> {\n         let ty = self.resolve_vars_if_possible(&ty);\n-        let name = self.extract_type_name(&ty, None);\n+        let name = self.extract_type_name(&ty, None).0;\n         let mut err = struct_span_err!(\n             self.tcx.sess, span, E0698, \"type inside {} must be known in this context\", kind,\n         );"}, {"sha": "979815fa7f1843199df09f4e141df8a246abf387", "filename": "src/librustc/infer/error_reporting/nice_region_error/different_lifetimes.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -2,7 +2,7 @@\n //! where both the regions are anonymous.\n \n use crate::infer::error_reporting::nice_region_error::NiceRegionError;\n-use crate::infer::error_reporting::nice_region_error::util::AnonymousArgInfo;\n+use crate::infer::error_reporting::nice_region_error::util::AnonymousParamInfo;\n use crate::util::common::ErrorReported;\n \n impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n@@ -59,13 +59,13 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n         let ty_sub = self.find_anon_type(sub, &bregion_sub)?;\n \n         debug!(\n-            \"try_report_anon_anon_conflict: found_arg1={:?} sup={:?} br1={:?}\",\n+            \"try_report_anon_anon_conflict: found_param1={:?} sup={:?} br1={:?}\",\n             ty_sub,\n             sup,\n             bregion_sup\n         );\n         debug!(\n-            \"try_report_anon_anon_conflict: found_arg2={:?} sub={:?} br2={:?}\",\n+            \"try_report_anon_anon_conflict: found_param2={:?} sub={:?} br2={:?}\",\n             ty_sup,\n             sub,\n             bregion_sub\n@@ -74,24 +74,24 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n         let (ty_sup, ty_fndecl_sup) = ty_sup;\n         let (ty_sub, ty_fndecl_sub) = ty_sub;\n \n-        let AnonymousArgInfo {\n-            arg: anon_arg_sup, ..\n-        } = self.find_arg_with_region(sup, sup)?;\n-        let AnonymousArgInfo {\n-            arg: anon_arg_sub, ..\n-        } = self.find_arg_with_region(sub, sub)?;\n+        let AnonymousParamInfo {\n+            param: anon_param_sup, ..\n+        } = self.find_param_with_region(sup, sup)?;\n+        let AnonymousParamInfo {\n+            param: anon_param_sub, ..\n+        } = self.find_param_with_region(sub, sub)?;\n \n         let sup_is_ret_type =\n             self.is_return_type_anon(scope_def_id_sup, bregion_sup, ty_fndecl_sup);\n         let sub_is_ret_type =\n             self.is_return_type_anon(scope_def_id_sub, bregion_sub, ty_fndecl_sub);\n \n-        let span_label_var1 = match anon_arg_sup.pat.simple_ident() {\n+        let span_label_var1 = match anon_param_sup.pat.simple_ident() {\n             Some(simple_ident) => format!(\" from `{}`\", simple_ident),\n             None => String::new(),\n         };\n \n-        let span_label_var2 = match anon_arg_sub.pat.simple_ident() {\n+        let span_label_var2 = match anon_param_sub.pat.simple_ident() {\n             Some(simple_ident) => format!(\" into `{}`\", simple_ident),\n             None => String::new(),\n         };"}, {"sha": "604115cfc371157225e7ca912bdb6797a1cd41cd", "filename": "src/librustc/infer/error_reporting/nice_region_error/named_anon_conflict.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -6,7 +6,7 @@ use crate::ty;\n use errors::{Applicability, DiagnosticBuilder};\n \n impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n-    /// When given a `ConcreteFailure` for a function with arguments containing a named region and\n+    /// When given a `ConcreteFailure` for a function with parameters containing a named region and\n     /// an anonymous region, emit an descriptive diagnostic error.\n     pub(super) fn try_report_named_anon_conflict(&self) -> Option<DiagnosticBuilder<'a>> {\n         let (span, sub, sup) = self.get_regions();\n@@ -24,23 +24,23 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n         // only introduced anonymous regions in parameters) as well as a\n         // version new_ty of its type where the anonymous region is replaced\n         // with the named one.//scope_def_id\n-        let (named, anon, anon_arg_info, region_info) = if self.is_named_region(sub)\n+        let (named, anon, anon_param_info, region_info) = if self.is_named_region(sub)\n             && self.tcx().is_suitable_region(sup).is_some()\n-            && self.find_arg_with_region(sup, sub).is_some()\n+            && self.find_param_with_region(sup, sub).is_some()\n         {\n             (\n                 sub,\n                 sup,\n-                self.find_arg_with_region(sup, sub).unwrap(),\n+                self.find_param_with_region(sup, sub).unwrap(),\n                 self.tcx().is_suitable_region(sup).unwrap(),\n             )\n         } else if self.is_named_region(sup) && self.tcx().is_suitable_region(sub).is_some()\n-            && self.find_arg_with_region(sub, sup).is_some()\n+            && self.find_param_with_region(sub, sup).is_some()\n         {\n             (\n                 sup,\n                 sub,\n-                self.find_arg_with_region(sub, sup).unwrap(),\n+                self.find_param_with_region(sub, sup).unwrap(),\n                 self.tcx().is_suitable_region(sub).unwrap(),\n             )\n         } else {\n@@ -49,20 +49,20 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n \n         debug!(\"try_report_named_anon_conflict: named = {:?}\", named);\n         debug!(\n-            \"try_report_named_anon_conflict: anon_arg_info = {:?}\",\n-            anon_arg_info\n+            \"try_report_named_anon_conflict: anon_param_info = {:?}\",\n+            anon_param_info\n         );\n         debug!(\n             \"try_report_named_anon_conflict: region_info = {:?}\",\n             region_info\n         );\n \n-        let (arg, new_ty, new_ty_span, br, is_first, scope_def_id, is_impl_item) = (\n-            anon_arg_info.arg,\n-            anon_arg_info.arg_ty,\n-            anon_arg_info.arg_ty_span,\n-            anon_arg_info.bound_region,\n-            anon_arg_info.is_first,\n+        let (param, new_ty, new_ty_span, br, is_first, scope_def_id, is_impl_item) = (\n+            anon_param_info.param,\n+            anon_param_info.param_ty,\n+            anon_param_info.param_ty_span,\n+            anon_param_info.bound_region,\n+            anon_param_info.is_first,\n             region_info.def_id,\n             region_info.is_impl_item,\n         );\n@@ -95,7 +95,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n             }\n         }\n \n-        let (error_var, span_label_var) = match arg.pat.simple_ident() {\n+        let (error_var, span_label_var) = match param.pat.simple_ident() {\n             Some(simple_ident) => (\n                 format!(\"the type of `{}`\", simple_ident),\n                 format!(\"the type of `{}`\", simple_ident),"}, {"sha": "668c99da0034fa5bc05725fca3406c4a2bc60e0f", "filename": "src/librustc/infer/error_reporting/nice_region_error/util.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -10,37 +10,37 @@ use syntax_pos::Span;\n // The struct contains the information about the anonymous region\n // we are searching for.\n #[derive(Debug)]\n-pub(super) struct AnonymousArgInfo<'tcx> {\n-    // the argument corresponding to the anonymous region\n-    pub arg: &'tcx hir::Arg,\n-    // the type corresponding to the anonymopus region argument\n-    pub arg_ty: Ty<'tcx>,\n+pub(super) struct AnonymousParamInfo<'tcx> {\n+    // the parameter corresponding to the anonymous region\n+    pub param: &'tcx hir::Param,\n+    // the type corresponding to the anonymopus region parameter\n+    pub param_ty: Ty<'tcx>,\n     // the ty::BoundRegion corresponding to the anonymous region\n     pub bound_region: ty::BoundRegion,\n-    // arg_ty_span contains span of argument type\n-    pub arg_ty_span : Span,\n+    // param_ty_span contains span of parameter type\n+    pub param_ty_span : Span,\n     // corresponds to id the argument is the first parameter\n     // in the declaration\n     pub is_first: bool,\n }\n \n impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n-    // This method walks the Type of the function body arguments using\n+    // This method walks the Type of the function body parameters using\n     // `fold_regions()` function and returns the\n-    // &hir::Arg of the function argument corresponding to the anonymous\n+    // &hir::Param of the function parameter corresponding to the anonymous\n     // region and the Ty corresponding to the named region.\n     // Currently only the case where the function declaration consists of\n     // one named region and one anonymous region is handled.\n     // Consider the example `fn foo<'a>(x: &'a i32, y: &i32) -> &'a i32`\n-    // Here, we would return the hir::Arg for y, we return the type &'a\n+    // Here, we would return the hir::Param for y, we return the type &'a\n     // i32, which is the type of y but with the anonymous region replaced\n     // with 'a, the corresponding bound region and is_first which is true if\n-    // the hir::Arg is the first argument in the function declaration.\n-    pub(super) fn find_arg_with_region(\n+    // the hir::Param is the first parameter in the function declaration.\n+    pub(super) fn find_param_with_region(\n         &self,\n         anon_region: Region<'tcx>,\n         replace_region: Region<'tcx>,\n-    ) -> Option<AnonymousArgInfo<'_>> {\n+    ) -> Option<AnonymousParamInfo<'_>> {\n         let (id, bound_region) = match *anon_region {\n             ty::ReFree(ref free_region) => (free_region.scope, free_region.bound_region),\n             ty::ReEarlyBound(ebr) => (\n@@ -57,16 +57,16 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n                 let owner_id = hir.body_owner(body_id);\n                 let fn_decl = hir.fn_decl_by_hir_id(owner_id).unwrap();\n                 if let Some(tables) = self.tables {\n-                    body.arguments\n+                    body.params\n                         .iter()\n                         .enumerate()\n-                        .filter_map(|(index, arg)| {\n+                        .filter_map(|(index, param)| {\n                             // May return None; sometimes the tables are not yet populated.\n                             let ty_hir_id = fn_decl.inputs[index].hir_id;\n-                            let arg_ty_span = hir.span(ty_hir_id);\n-                            let ty = tables.node_type_opt(arg.hir_id)?;\n+                            let param_ty_span = hir.span(ty_hir_id);\n+                            let ty = tables.node_type_opt(param.hir_id)?;\n                             let mut found_anon_region = false;\n-                            let new_arg_ty = self.tcx().fold_regions(&ty, &mut false, |r, _| {\n+                            let new_param_ty = self.tcx().fold_regions(&ty, &mut false, |r, _| {\n                                 if *r == *anon_region {\n                                     found_anon_region = true;\n                                     replace_region\n@@ -76,10 +76,10 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n                             });\n                             if found_anon_region {\n                                 let is_first = index == 0;\n-                                Some(AnonymousArgInfo {\n-                                    arg: arg,\n-                                    arg_ty: new_arg_ty,\n-                                    arg_ty_span : arg_ty_span,\n+                                Some(AnonymousParamInfo {\n+                                    param: param,\n+                                    param_ty: new_param_ty,\n+                                    param_ty_span : param_ty_span,\n                                     bound_region: bound_region,\n                                     is_first: is_first,\n                                 })"}, {"sha": "8638f42976f046daee626580817142e3feafda6f", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -1321,13 +1321,13 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         T: TypeFoldable<'tcx>,\n     {\n         if !value.needs_infer() {\n-            return value.clone(); // avoid duplicated subst-folding\n+            return value.clone(); // Avoid duplicated subst-folding.\n         }\n         let mut r = resolve::OpportunisticVarResolver::new(self);\n         value.fold_with(&mut r)\n     }\n \n-    /// Returns first unresolved variable contained in `T`. In the\n+    /// Returns the first unresolved variable contained in `T`. In the\n     /// process of visiting `T`, this will resolve (where possible)\n     /// type variables in `T`, but it never constructs the final,\n     /// resolved type, so it's more efficient than\n@@ -1460,9 +1460,9 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             }\n         }\n \n-        let copy_def_id = self.tcx.require_lang_item(lang_items::CopyTraitLangItem);\n+        let copy_def_id = self.tcx.require_lang_item(lang_items::CopyTraitLangItem, None);\n \n-        // this can get called from typeck (by euv), and moves_by_default\n+        // This can get called from typeck (by euv), and `moves_by_default`\n         // rightly refuses to work with inference variables, but\n         // moves_by_default has a cache, which we want to use in other\n         // cases.\n@@ -1482,7 +1482,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         closure_kind_ty.to_opt_closure_kind()\n     }\n \n-    /// Obtain the signature of a closure. For closures, unlike\n+    /// Obtains the signature of a closure. For closures, unlike\n     /// `tcx.fn_sig(def_id)`, this method will work during the\n     /// type-checking of the enclosing function and return the closure\n     /// signature in its partially inferred state."}, {"sha": "63ef82a7401a3b33666adf5715d3bf96f6b7559e", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -45,7 +45,6 @@\n #![feature(non_exhaustive)]\n #![feature(optin_builtin_traits)]\n #![feature(range_is_empty)]\n-#![feature(rustc_diagnostic_macros)]\n #![feature(slice_patterns)]\n #![feature(specialization)]\n #![feature(unboxed_closures)]\n@@ -62,6 +61,7 @@\n #![feature(log_syntax)]\n #![feature(mem_take)]\n #![feature(associated_type_bounds)]\n+#![feature(rustc_attrs)]\n \n #![recursion_limit=\"512\"]\n \n@@ -87,16 +87,13 @@ mod tests;\n #[macro_use]\n mod macros;\n \n-// N.B., this module needs to be declared first so diagnostics are\n-// registered before they are used.\n pub mod error_codes;\n \n #[macro_use]\n pub mod query;\n \n #[macro_use]\n pub mod arena;\n-pub mod cfg;\n pub mod dep_graph;\n pub mod hir;\n pub mod ich;\n@@ -109,6 +106,7 @@ pub mod middle {\n     pub mod cstore;\n     pub mod dead;\n     pub mod dependency_format;\n+    pub mod diagnostic_items;\n     pub mod entry;\n     pub mod exported_symbols;\n     pub mod free_region;\n@@ -141,6 +139,3 @@ pub mod util {\n \n // Allows macros to refer to this crate as `::rustc`\n extern crate self as rustc;\n-\n-// Build the diagnostics array at the end so that the metadata includes error use sites.\n-__build_diagnostic_array! { librustc, DIAGNOSTICS }"}, {"sha": "dd290572d7bb790208278e70e43dd050050005dd", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -395,6 +395,12 @@ declare_lint! {\n     \"reservation of a two-phased borrow conflicts with other shared borrows\"\n }\n \n+declare_lint! {\n+    pub SOFT_UNSTABLE,\n+    Deny,\n+    \"a feature gate that doesn't break dependent crates\"\n+}\n+\n declare_lint_pass! {\n     /// Does nothing as a lint pass, but registers some `Lint`s\n     /// that are used by other parts of the compiler.\n@@ -460,6 +466,7 @@ declare_lint_pass! {\n         NESTED_IMPL_TRAIT,\n         MUTABLE_BORROW_RESERVATION_CONFLICT,\n         INDIRECT_STRUCTURAL_MATCH,\n+        SOFT_UNSTABLE,\n     ]\n }\n "}, {"sha": "c658120b95df36a393aa7c773b9f4906cec6971d", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 34, "deletions": 39, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -16,32 +16,32 @@\n \n use self::TargetLint::*;\n \n-use std::slice;\n-use rustc_data_structures::sync::{ReadGuard, Lock, ParallelIterator, join, par_iter};\n+use crate::hir;\n+use crate::hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n+use crate::hir::intravisit as hir_visit;\n+use crate::hir::intravisit::Visitor;\n+use crate::hir::map::{definitions::DisambiguatedDefPathData, DefPathData};\n use crate::lint::{EarlyLintPass, LateLintPass, EarlyLintPassObject, LateLintPassObject};\n use crate::lint::{LintArray, Level, Lint, LintId, LintPass, LintBuffer};\n use crate::lint::builtin::BuiltinLintDiagnostics;\n use crate::lint::levels::{LintLevelSets, LintLevelsBuilder};\n use crate::middle::privacy::AccessLevels;\n-use rustc_serialize::{Decoder, Decodable, Encoder, Encodable};\n use crate::session::{config, early_error, Session};\n use crate::ty::{self, print::Printer, subst::Kind, TyCtxt, Ty};\n use crate::ty::layout::{LayoutError, LayoutOf, TyLayout};\n use crate::util::nodemap::FxHashMap;\n use crate::util::common::time;\n \n+use errors::DiagnosticBuilder;\n+use std::slice;\n use std::default::Default as StdDefault;\n+use rustc_data_structures::sync::{ReadGuard, Lock, ParallelIterator, join, par_iter};\n+use rustc_serialize::{Decoder, Decodable, Encoder, Encodable};\n use syntax::ast;\n use syntax::edition;\n-use syntax_pos::{MultiSpan, Span, symbol::{LocalInternedString, Symbol}};\n-use errors::DiagnosticBuilder;\n-use crate::hir;\n-use crate::hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n-use crate::hir::intravisit as hir_visit;\n-use crate::hir::intravisit::Visitor;\n-use crate::hir::map::{definitions::DisambiguatedDefPathData, DefPathData};\n use syntax::util::lev_distance::find_best_match_for_name;\n use syntax::visit as ast_visit;\n+use syntax_pos::{MultiSpan, Span, symbol::Symbol};\n \n /// Information about the registered lints.\n ///\n@@ -405,7 +405,7 @@ impl LintStore {\n     pub fn check_lint_name(\n         &self,\n         lint_name: &str,\n-        tool_name: Option<LocalInternedString>,\n+        tool_name: Option<Symbol>,\n     ) -> CheckLintNameResult<'_> {\n         let complete_name = if let Some(tool_name) = tool_name {\n             format!(\"{}::{}\", tool_name, lint_name)\n@@ -966,10 +966,10 @@ for LateContextAndPass<'a, 'tcx, T> {\n         self.context.tables = old_tables;\n     }\n \n-    fn visit_arg(&mut self, arg: &'tcx hir::Arg) {\n-        self.with_lint_attrs(arg.hir_id, &arg.attrs, |cx| {\n-            lint_callback!(cx, check_arg, arg);\n-            hir_visit::walk_arg(cx, arg);\n+    fn visit_param(&mut self, param: &'tcx hir::Param) {\n+        self.with_lint_attrs(param.hir_id, &param.attrs, |cx| {\n+            lint_callback!(cx, check_param, param);\n+            hir_visit::walk_param(cx, param);\n         });\n     }\n \n@@ -1040,13 +1040,13 @@ for LateContextAndPass<'a, 'tcx, T> {\n \n     fn visit_variant_data(&mut self,\n                         s: &'tcx hir::VariantData,\n-                        name: ast::Name,\n-                        g: &'tcx hir::Generics,\n-                        item_id: hir::HirId,\n+                        _: ast::Name,\n+                        _: &'tcx hir::Generics,\n+                        _: hir::HirId,\n                         _: Span) {\n-        lint_callback!(self, check_struct_def, s, name, g, item_id);\n+        lint_callback!(self, check_struct_def, s);\n         hir_visit::walk_struct_def(self, s);\n-        lint_callback!(self, check_struct_def_post, s, name, g, item_id);\n+        lint_callback!(self, check_struct_def_post, s);\n     }\n \n     fn visit_struct_field(&mut self, s: &'tcx hir::StructField) {\n@@ -1061,9 +1061,9 @@ for LateContextAndPass<'a, 'tcx, T> {\n                      g: &'tcx hir::Generics,\n                      item_id: hir::HirId) {\n         self.with_lint_attrs(v.id, &v.attrs, |cx| {\n-            lint_callback!(cx, check_variant, v, g);\n+            lint_callback!(cx, check_variant, v);\n             hir_visit::walk_variant(cx, v, g, item_id);\n-            lint_callback!(cx, check_variant_post, v, g);\n+            lint_callback!(cx, check_variant_post, v);\n         })\n     }\n \n@@ -1163,10 +1163,10 @@ for LateContextAndPass<'a, 'tcx, T> {\n }\n \n impl<'a, T: EarlyLintPass> ast_visit::Visitor<'a> for EarlyContextAndPass<'a, T> {\n-    fn visit_arg(&mut self, arg: &'a ast::Arg) {\n-        self.with_lint_attrs(arg.id, &arg.attrs, |cx| {\n-            run_early_pass!(cx, check_arg, arg);\n-            ast_visit::walk_arg(cx, arg);\n+    fn visit_param(&mut self, param: &'a ast::Param) {\n+        self.with_lint_attrs(param.id, &param.attrs, |cx| {\n+            run_early_pass!(cx, check_param, param);\n+            ast_visit::walk_param(cx, param);\n         });\n     }\n \n@@ -1214,18 +1214,13 @@ impl<'a, T: EarlyLintPass> ast_visit::Visitor<'a> for EarlyContextAndPass<'a, T>\n         run_early_pass!(self, check_fn_post, fk, decl, span, id);\n     }\n \n-    fn visit_variant_data(&mut self,\n-                        s: &'a ast::VariantData,\n-                        ident: ast::Ident,\n-                        g: &'a ast::Generics,\n-                        item_id: ast::NodeId,\n-                        _: Span) {\n-        run_early_pass!(self, check_struct_def, s, ident, g, item_id);\n+    fn visit_variant_data(&mut self, s: &'a ast::VariantData) {\n+        run_early_pass!(self, check_struct_def, s);\n         if let Some(ctor_hir_id) = s.ctor_id() {\n             self.check_id(ctor_hir_id);\n         }\n         ast_visit::walk_struct_def(self, s);\n-        run_early_pass!(self, check_struct_def_post, s, ident, g, item_id);\n+        run_early_pass!(self, check_struct_def_post, s);\n     }\n \n     fn visit_struct_field(&mut self, s: &'a ast::StructField) {\n@@ -1235,11 +1230,11 @@ impl<'a, T: EarlyLintPass> ast_visit::Visitor<'a> for EarlyContextAndPass<'a, T>\n         })\n     }\n \n-    fn visit_variant(&mut self, v: &'a ast::Variant, g: &'a ast::Generics, item_id: ast::NodeId) {\n-        self.with_lint_attrs(item_id, &v.attrs, |cx| {\n-            run_early_pass!(cx, check_variant, v, g);\n-            ast_visit::walk_variant(cx, v, g, item_id);\n-            run_early_pass!(cx, check_variant_post, v, g);\n+    fn visit_variant(&mut self, v: &'a ast::Variant) {\n+        self.with_lint_attrs(v.id, &v.attrs, |cx| {\n+            run_early_pass!(cx, check_variant, v);\n+            ast_visit::walk_variant(cx, v);\n+            run_early_pass!(cx, check_variant_post, v);\n         })\n     }\n "}, {"sha": "13834eaf40f576591e17ac71c75536a31bc4ac38", "filename": "src/librustc/lint/internal.rs", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Flint%2Finternal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Flint%2Finternal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Finternal.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -159,29 +159,23 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TyTyKind {\n }\n \n fn lint_ty_kind_usage(cx: &LateContext<'_, '_>, segment: &PathSegment) -> bool {\n-    if segment.ident.name == sym::TyKind {\n-        if let Some(res) = segment.res {\n-            if let Some(did) = res.opt_def_id() {\n-                return cx.match_def_path(did, TYKIND_PATH);\n-            }\n+    if let Some(res) = segment.res {\n+        if let Some(did) = res.opt_def_id() {\n+            return cx.tcx.is_diagnostic_item(sym::TyKind, did);\n         }\n     }\n \n     false\n }\n \n-const TYKIND_PATH: &[Symbol] = &[sym::rustc, sym::ty, sym::sty, sym::TyKind];\n-const TY_PATH: &[Symbol] = &[sym::rustc, sym::ty, sym::Ty];\n-const TYCTXT_PATH: &[Symbol] = &[sym::rustc, sym::ty, sym::context, sym::TyCtxt];\n-\n fn is_ty_or_ty_ctxt(cx: &LateContext<'_, '_>, ty: &Ty) -> Option<String> {\n     match &ty.node {\n         TyKind::Path(qpath) => {\n             if let QPath::Resolved(_, path) = qpath {\n                 let did = path.res.opt_def_id()?;\n-                if cx.match_def_path(did, TY_PATH) {\n+                if cx.tcx.is_diagnostic_item(sym::Ty, did) {\n                     return Some(format!(\"Ty{}\", gen_args(path.segments.last().unwrap())));\n-                } else if cx.match_def_path(did, TYCTXT_PATH) {\n+                } else if cx.tcx.is_diagnostic_item(sym::TyCtxt, did) {\n                     return Some(format!(\"TyCtxt{}\", gen_args(path.segments.last().unwrap())));\n                 }\n             }"}, {"sha": "cbc6dbdba7e6cc9716f29a7c2e8c295291c483ea", "filename": "src/librustc/lint/levels.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Flint%2Flevels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Flint%2Flevels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Flevels.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -291,7 +291,7 @@ impl<'a> LintLevelsBuilder<'a> {\n                         continue;\n                     }\n \n-                    Some(tool_ident.as_str())\n+                    Some(tool_ident.name)\n                 } else {\n                     None\n                 };"}, {"sha": "5b490b701267deae304e620ddce0e8178eb2b305", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 41, "deletions": 57, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -206,7 +206,7 @@ macro_rules! declare_lint_pass {\n macro_rules! late_lint_methods {\n     ($macro:path, $args:tt, [$hir:tt]) => (\n         $macro!($args, [$hir], [\n-            fn check_arg(a: &$hir hir::Arg);\n+            fn check_param(a: &$hir hir::Param);\n             fn check_body(a: &$hir hir::Body);\n             fn check_body_post(a: &$hir hir::Body);\n             fn check_name(a: Span, b: ast::Name);\n@@ -248,21 +248,11 @@ macro_rules! late_lint_methods {\n             fn check_trait_item_post(a: &$hir hir::TraitItem);\n             fn check_impl_item(a: &$hir hir::ImplItem);\n             fn check_impl_item_post(a: &$hir hir::ImplItem);\n-            fn check_struct_def(\n-                a: &$hir hir::VariantData,\n-                b: ast::Name,\n-                c: &$hir hir::Generics,\n-                d: hir::HirId\n-            );\n-            fn check_struct_def_post(\n-                a: &$hir hir::VariantData,\n-                b: ast::Name,\n-                c: &$hir hir::Generics,\n-                d: hir::HirId\n-            );\n+            fn check_struct_def(a: &$hir hir::VariantData);\n+            fn check_struct_def_post(a: &$hir hir::VariantData);\n             fn check_struct_field(a: &$hir hir::StructField);\n-            fn check_variant(a: &$hir hir::Variant, b: &$hir hir::Generics);\n-            fn check_variant_post(a: &$hir hir::Variant, b: &$hir hir::Generics);\n+            fn check_variant(a: &$hir hir::Variant);\n+            fn check_variant_post(a: &$hir hir::Variant);\n             fn check_lifetime(a: &$hir hir::Lifetime);\n             fn check_path(a: &$hir hir::Path, b: hir::HirId);\n             fn check_attribute(a: &$hir ast::Attribute);\n@@ -359,7 +349,7 @@ macro_rules! declare_combined_late_lint_pass {\n macro_rules! early_lint_methods {\n     ($macro:path, $args:tt) => (\n         $macro!($args, [\n-            fn check_arg(a: &ast::Arg);\n+            fn check_param(a: &ast::Param);\n             fn check_ident(a: ast::Ident);\n             fn check_crate(a: &ast::Crate);\n             fn check_crate_post(a: &ast::Crate);\n@@ -395,21 +385,11 @@ macro_rules! early_lint_methods {\n             fn check_trait_item_post(a: &ast::TraitItem);\n             fn check_impl_item(a: &ast::ImplItem);\n             fn check_impl_item_post(a: &ast::ImplItem);\n-            fn check_struct_def(\n-                a: &ast::VariantData,\n-                b: ast::Ident,\n-                c: &ast::Generics,\n-                d: ast::NodeId\n-            );\n-            fn check_struct_def_post(\n-                a: &ast::VariantData,\n-                b: ast::Ident,\n-                c: &ast::Generics,\n-                d: ast::NodeId\n-            );\n+            fn check_struct_def(a: &ast::VariantData);\n+            fn check_struct_def_post(a: &ast::VariantData);\n             fn check_struct_field(a: &ast::StructField);\n-            fn check_variant(a: &ast::Variant, b: &ast::Generics);\n-            fn check_variant_post(a: &ast::Variant, b: &ast::Generics);\n+            fn check_variant(a: &ast::Variant);\n+            fn check_variant_post(a: &ast::Variant);\n             fn check_lifetime(a: &ast::Lifetime);\n             fn check_path(a: &ast::Path, b: ast::NodeId);\n             fn check_attribute(a: &ast::Attribute);\n@@ -666,6 +646,30 @@ pub fn struct_lint_level<'a>(sess: &'a Session,\n         (Level::Forbid, None) => sess.struct_err(msg),\n     };\n \n+    // Check for future incompatibility lints and issue a stronger warning.\n+    let lints = sess.lint_store.borrow();\n+    let lint_id = LintId::of(lint);\n+    let future_incompatible = lints.future_incompatible(lint_id);\n+\n+    // If this code originates in a foreign macro, aka something that this crate\n+    // did not itself author, then it's likely that there's nothing this crate\n+    // can do about it. We probably want to skip the lint entirely.\n+    if err.span.primary_spans().iter().any(|s| in_external_macro(sess, *s)) {\n+        // Any suggestions made here are likely to be incorrect, so anything we\n+        // emit shouldn't be automatically fixed by rustfix.\n+        err.allow_suggestions(false);\n+\n+        // If this is a future incompatible lint it'll become a hard error, so\n+        // we have to emit *something*. Also allow lints to whitelist themselves\n+        // on a case-by-case basis for emission in a foreign macro.\n+        if future_incompatible.is_none() && !lint.report_in_external_macro {\n+            err.cancel();\n+            // Don't continue further, since we don't want to have\n+            // `diag_span_note_once` called for a diagnostic that isn't emitted.\n+            return err;\n+        }\n+    }\n+\n     let name = lint.name_lower();\n     match src {\n         LintSource::Default => {\n@@ -715,10 +719,6 @@ pub fn struct_lint_level<'a>(sess: &'a Session,\n \n     err.code(DiagnosticId::Lint(name));\n \n-    // Check for future incompatibility lints and issue a stronger warning.\n-    let lints = sess.lint_store.borrow();\n-    let lint_id = LintId::of(lint);\n-    let future_incompatible = lints.future_incompatible(lint_id);\n     if let Some(future_incompatible) = future_incompatible {\n         const STANDARD_MESSAGE: &str =\n             \"this was previously accepted by the compiler but is being phased out; \\\n@@ -743,22 +743,6 @@ pub fn struct_lint_level<'a>(sess: &'a Session,\n         err.note(&citation);\n     }\n \n-    // If this code originates in a foreign macro, aka something that this crate\n-    // did not itself author, then it's likely that there's nothing this crate\n-    // can do about it. We probably want to skip the lint entirely.\n-    if err.span.primary_spans().iter().any(|s| in_external_macro(sess, *s)) {\n-        // Any suggestions made here are likely to be incorrect, so anything we\n-        // emit shouldn't be automatically fixed by rustfix.\n-        err.allow_suggestions(false);\n-\n-        // If this is a future incompatible lint it'll become a hard error, so\n-        // we have to emit *something*. Also allow lints to whitelist themselves\n-        // on a case-by-case basis for emission in a foreign macro.\n-        if future_incompatible.is_none() && !lint.report_in_external_macro {\n-            err.cancel()\n-        }\n-    }\n-\n     return err\n }\n \n@@ -812,9 +796,9 @@ impl intravisit::Visitor<'tcx> for LintLevelMapBuilder<'tcx> {\n         intravisit::NestedVisitorMap::All(&self.tcx.hir())\n     }\n \n-    fn visit_arg(&mut self, arg: &'tcx hir::Arg) {\n-        self.with_lint_attrs(arg.hir_id, &arg.attrs, |builder| {\n-            intravisit::walk_arg(builder, arg);\n+    fn visit_param(&mut self, param: &'tcx hir::Param) {\n+        self.with_lint_attrs(param.hir_id, &param.attrs, |builder| {\n+            intravisit::walk_param(builder, param);\n         });\n     }\n \n@@ -888,23 +872,23 @@ pub fn in_external_macro(sess: &Session, span: Span) -> bool {\n     let expn_data = span.ctxt().outer_expn_data();\n     match expn_data.kind {\n         ExpnKind::Root | ExpnKind::Desugaring(DesugaringKind::ForLoop) => false,\n-        ExpnKind::Desugaring(_) => true, // well, it's \"external\"\n+        ExpnKind::AstPass(_) | ExpnKind::Desugaring(_) => true, // well, it's \"external\"\n         ExpnKind::Macro(MacroKind::Bang, _) => {\n             if expn_data.def_site.is_dummy() {\n-                // dummy span for the def_site means it's an external macro\n+                // Dummy span for the `def_site` means it's an external macro.\n                 return true;\n             }\n             match sess.source_map().span_to_snippet(expn_data.def_site) {\n                 Ok(code) => !code.starts_with(\"macro_rules\"),\n-                // no snippet = external macro or compiler-builtin expansion\n+                // No snippet means external macro or compiler-builtin expansion.\n                 Err(_) => true,\n             }\n         }\n         ExpnKind::Macro(..) => true, // definitely a plugin\n     }\n }\n \n-/// Returns whether `span` originates in a derive macro's expansion\n+/// Returns `true` if `span` originates in a derive-macro's expansion.\n pub fn in_derive_expansion(span: Span) -> bool {\n     if let ExpnKind::Macro(MacroKind::Derive, _) = span.ctxt().outer_expn_data().kind {\n         return true;"}, {"sha": "d4805a7c7832252731a46186446e7c35298d4a43", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -30,10 +30,11 @@ fn should_explore(tcx: TyCtxt<'_>, hir_id: hir::HirId) -> bool {\n         Some(Node::Item(..)) |\n         Some(Node::ImplItem(..)) |\n         Some(Node::ForeignItem(..)) |\n-        Some(Node::TraitItem(..)) =>\n-            true,\n-        _ =>\n-            false\n+        Some(Node::TraitItem(..)) |\n+        Some(Node::Variant(..)) |\n+        Some(Node::AnonConst(..)) |\n+        Some(Node::Pat(..)) => true,\n+        _ => false\n     }\n }\n \n@@ -75,7 +76,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n                 self.check_def_id(res.def_id());\n             }\n             _ if self.in_pat => {},\n-            Res::PrimTy(..) | Res::SelfTy(..) | Res::SelfCtor(..) |\n+            Res::PrimTy(..) | Res::SelfCtor(..) |\n             Res::Local(..) => {}\n             Res::Def(DefKind::Ctor(CtorOf::Variant, ..), ctor_def_id) => {\n                 let variant_id = self.tcx.parent(ctor_def_id).unwrap();\n@@ -92,6 +93,14 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n                     self.check_def_id(variant_id);\n                 }\n             }\n+            Res::SelfTy(t, i) => {\n+                if let Some(t) = t {\n+                    self.check_def_id(t);\n+                }\n+                if let Some(i) = i {\n+                    self.check_def_id(i);\n+                }\n+            }\n             Res::ToolMod | Res::NonMacroAttr(..) | Res::Err => {}\n             _ => {\n                 self.check_def_id(res.def_id());\n@@ -271,7 +280,7 @@ impl<'a, 'tcx> Visitor<'tcx> for MarkSymbolVisitor<'a, 'tcx> {\n                 let res = self.tables.qpath_res(path, pat.hir_id);\n                 self.handle_field_pattern_match(pat, res, fields);\n             }\n-            PatKind::Path(ref qpath @ hir::QPath::TypeRelative(..)) => {\n+            PatKind::Path(ref qpath) => {\n                 let res = self.tables.qpath_res(qpath, pat.hir_id);\n                 self.handle_res(res);\n             }\n@@ -298,6 +307,11 @@ impl<'a, 'tcx> Visitor<'tcx> for MarkSymbolVisitor<'a, 'tcx> {\n         }\n         intravisit::walk_ty(self, ty);\n     }\n+\n+    fn visit_anon_const(&mut self, c: &'tcx hir::AnonConst) {\n+        self.live_symbols.insert(c.hir_id);\n+        intravisit::walk_anon_const(self, c);\n+    }\n }\n \n fn has_allow_dead_code_or_lang_attr("}, {"sha": "dfae169b27824abe35d7242c0c6ee3e7ac66139e", "filename": "src/librustc/middle/diagnostic_items.rs", "status": "added", "additions": 123, "deletions": 0, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Fmiddle%2Fdiagnostic_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Fmiddle%2Fdiagnostic_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdiagnostic_items.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -0,0 +1,123 @@\n+//! Detecting diagnostic items.\n+//!\n+//! Diagnostic items are items that are not language-inherent, but can reasonably be expected to\n+//! exist for diagnostic purposes. This allows diagnostic authors to refer to specific items\n+//! directly, without having to guess module paths and crates.\n+//! Examples are:\n+//!\n+//! * Traits like `Debug`, that have no bearing on language semantics\n+//!\n+//! * Compiler internal types like `Ty` and `TyCtxt`\n+\n+use crate::hir::def_id::{DefId, LOCAL_CRATE};\n+use crate::ty::TyCtxt;\n+use crate::util::nodemap::FxHashMap;\n+\n+use syntax::ast;\n+use syntax::symbol::{Symbol, sym};\n+use crate::hir::itemlikevisit::ItemLikeVisitor;\n+use crate::hir;\n+\n+struct DiagnosticItemCollector<'tcx> {\n+    // items from this crate\n+    items: FxHashMap<Symbol, DefId>,\n+    tcx: TyCtxt<'tcx>,\n+}\n+\n+impl<'v, 'tcx> ItemLikeVisitor<'v> for DiagnosticItemCollector<'tcx> {\n+    fn visit_item(&mut self, item: &hir::Item) {\n+        self.observe_item(&item.attrs, item.hir_id);\n+    }\n+\n+    fn visit_trait_item(&mut self, trait_item: &hir::TraitItem) {\n+        self.observe_item(&trait_item.attrs, trait_item.hir_id);\n+    }\n+\n+    fn visit_impl_item(&mut self, impl_item: &hir::ImplItem) {\n+        self.observe_item(&impl_item.attrs, impl_item.hir_id);\n+    }\n+}\n+\n+impl<'tcx> DiagnosticItemCollector<'tcx> {\n+    fn new(tcx: TyCtxt<'tcx>) -> DiagnosticItemCollector<'tcx> {\n+        DiagnosticItemCollector {\n+            tcx,\n+            items: Default::default(),\n+        }\n+    }\n+\n+    fn observe_item(&mut self, attrs: &[ast::Attribute], hir_id: hir::HirId) {\n+        if let Some(name) = extract(attrs) {\n+            let def_id = self.tcx.hir().local_def_id(hir_id);\n+            // insert into our table\n+            collect_item(self.tcx, &mut self.items, name, def_id);\n+        }\n+    }\n+}\n+\n+fn collect_item(\n+    tcx: TyCtxt<'_>,\n+    items: &mut FxHashMap<Symbol, DefId>,\n+    name: Symbol,\n+    item_def_id: DefId,\n+) {\n+    // Check for duplicates.\n+    if let Some(original_def_id) = items.insert(name, item_def_id) {\n+        if original_def_id != item_def_id {\n+            let mut err = match tcx.hir().span_if_local(item_def_id) {\n+                Some(span) => tcx.sess.struct_span_err(\n+                    span,\n+                    &format!(\"duplicate diagnostic item found: `{}`.\", name)),\n+                None => tcx.sess.struct_err(&format!(\n+                        \"duplicate diagnostic item in crate `{}`: `{}`.\",\n+                        tcx.crate_name(item_def_id.krate),\n+                        name)),\n+            };\n+            if let Some(span) = tcx.hir().span_if_local(original_def_id) {\n+                span_note!(&mut err, span, \"first defined here.\");\n+            } else {\n+                err.note(&format!(\"first defined in crate `{}`.\",\n+                                    tcx.crate_name(original_def_id.krate)));\n+            }\n+            err.emit();\n+        }\n+    }\n+}\n+\n+/// Extract the first `rustc_diagnostic_item = \"$name\"` out of a list of attributes.\n+fn extract(attrs: &[ast::Attribute]) -> Option<Symbol> {\n+    attrs.iter().find_map(|attr| {\n+        if attr.check_name(sym::rustc_diagnostic_item) {\n+            attr.value_str()\n+        } else {\n+            None\n+        }\n+    })\n+}\n+\n+/// Traverse and collect the diagnostic items in the current\n+pub fn collect<'tcx>(tcx: TyCtxt<'tcx>) -> &'tcx FxHashMap<Symbol, DefId> {\n+    // Initialize the collector.\n+    let mut collector = DiagnosticItemCollector::new(tcx);\n+\n+    // Collect diagnostic items in this crate.\n+    tcx.hir().krate().visit_all_item_likes(&mut collector);\n+\n+    tcx.arena.alloc(collector.items)\n+}\n+\n+\n+/// Traverse and collect all the diagnostic items in all crates.\n+pub fn collect_all<'tcx>(tcx: TyCtxt<'tcx>) -> &'tcx FxHashMap<Symbol, DefId> {\n+    // Initialize the collector.\n+    let mut collector = FxHashMap::default();\n+\n+    // Collect diagnostic items in other crates.\n+    for &cnum in tcx.crates().iter().chain(std::iter::once(&LOCAL_CRATE)) {\n+        for (&name, &def_id) in tcx.diagnostic_items(cnum).iter() {\n+            collect_item(tcx, &mut collector, name, def_id);\n+        }\n+    }\n+\n+    tcx.arena.alloc(collector)\n+}"}, {"sha": "93bb301f0951a99eaa34e66f63acb09faad385fd", "filename": "src/librustc/middle/entry.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Fmiddle%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Fmiddle%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fentry.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -16,17 +16,17 @@ struct EntryContext<'a, 'tcx> {\n \n     map: &'a hir_map::Map<'tcx>,\n \n-    // The top-level function called 'main'\n+    /// The top-level function called 'main'.\n     main_fn: Option<(HirId, Span)>,\n \n-    // The function that has attribute named 'main'\n+    /// The function that has attribute named 'main'.\n     attr_main_fn: Option<(HirId, Span)>,\n \n-    // The function that has the attribute 'start' on it\n+    /// The function that has the attribute 'start' on it.\n     start_fn: Option<(HirId, Span)>,\n \n-    // The functions that one might think are 'main' but aren't, e.g.\n-    // main functions not defined at the top level. For diagnostics.\n+    /// The functions that one might think are 'main' but aren't, e.g.\n+    /// main functions not defined at the top level. For diagnostics.\n     non_main_fns: Vec<(HirId, Span)> ,\n }\n \n@@ -39,11 +39,11 @@ impl<'a, 'tcx> ItemLikeVisitor<'tcx> for EntryContext<'a, 'tcx> {\n     }\n \n     fn visit_trait_item(&mut self, _trait_item: &'tcx TraitItem) {\n-        // entry fn is never a trait item\n+        // Entry fn is never a trait item.\n     }\n \n     fn visit_impl_item(&mut self, _impl_item: &'tcx ImplItem) {\n-        // entry fn is never an impl item\n+        // Entry fn is never a trait item.\n     }\n }\n \n@@ -54,7 +54,7 @@ fn entry_fn(tcx: TyCtxt<'_>, cnum: CrateNum) -> Option<(DefId, EntryFnType)> {\n         *ty == config::CrateType::Executable\n     });\n     if !any_exe {\n-        // No need to find a main function\n+        // No need to find a main function.\n         return None;\n     }\n \n@@ -148,7 +148,7 @@ fn configure_main(tcx: TyCtxt<'_>, visitor: &EntryContext<'_, '_>) -> Option<(De\n     } else if let Some((hir_id, _)) = visitor.main_fn {\n         Some((tcx.hir().local_def_id(hir_id), EntryFnType::Main))\n     } else {\n-        // No main function\n+        // There is no main function.\n         let mut err = struct_err!(tcx.sess, E0601,\n             \"`main` function not found in crate `{}`\", tcx.crate_name(LOCAL_CRATE));\n         if !visitor.non_main_fns.is_empty() {"}, {"sha": "de6dadabcbf5623f846f9ecc70f8b1a17e4a1a92", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -313,23 +313,23 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n     pub fn consume_body(&mut self, body: &hir::Body) {\n         debug!(\"consume_body(body={:?})\", body);\n \n-        for arg in &body.arguments {\n-            let arg_ty = return_if_err!(self.mc.pat_ty_adjusted(&arg.pat));\n-            debug!(\"consume_body: arg_ty = {:?}\", arg_ty);\n+        for param in &body.params {\n+            let param_ty = return_if_err!(self.mc.pat_ty_adjusted(&param.pat));\n+            debug!(\"consume_body: param_ty = {:?}\", param_ty);\n \n             let fn_body_scope_r =\n                 self.tcx().mk_region(ty::ReScope(\n                     region::Scope {\n                         id: body.value.hir_id.local_id,\n                         data: region::ScopeData::Node\n                 }));\n-            let arg_cmt = Rc::new(self.mc.cat_rvalue(\n-                arg.hir_id,\n-                arg.pat.span,\n-                fn_body_scope_r, // Args live only as long as the fn body.\n-                arg_ty));\n+            let param_cmt = Rc::new(self.mc.cat_rvalue(\n+                param.hir_id,\n+                param.pat.span,\n+                fn_body_scope_r, // Parameters live only as long as the fn body.\n+                param_ty));\n \n-            self.walk_irrefutable_pat(arg_cmt, &arg.pat);\n+            self.walk_irrefutable_pat(param_cmt, &param.pat);\n         }\n \n         self.consume_expr(&body.value);\n@@ -596,7 +596,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n             }\n \n             hir::StmtKind::Item(_) => {\n-                // we don't visit nested items in this visitor,\n+                // We don't visit nested items in this visitor,\n                 // only the fn body we were given.\n             }\n "}, {"sha": "c5d9a722ae18e09c5c9fdbebd9151f1a13295021", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -3,10 +3,8 @@\n //! Language items are items that represent concepts intrinsic to the language\n //! itself. Examples are:\n //!\n-//! * Traits that specify \"kinds\"; e.g., \"Sync\", \"Send\".\n-//!\n-//! * Traits that represent operators; e.g., \"Add\", \"Sub\", \"Index\".\n-//!\n+//! * Traits that specify \"kinds\"; e.g., `Sync`, `Send`.\n+//! * Traits that represent operators; e.g., `Add`, `Sub`, `Index`.\n //! * Functions called by the compiler itself.\n \n pub use self::LangItem::*;\n@@ -151,11 +149,11 @@ impl ItemLikeVisitor<'v> for LanguageItemCollector<'tcx> {\n     }\n \n     fn visit_trait_item(&mut self, _trait_item: &hir::TraitItem) {\n-        // at present, lang items are always items, not trait items\n+        // At present, lang items are always items, not trait items.\n     }\n \n     fn visit_impl_item(&mut self, _impl_item: &hir::ImplItem) {\n-        // at present, lang items are always items, not impl items\n+        // At present, lang items are always items, not impl items.\n     }\n }\n \n@@ -204,7 +202,7 @@ impl LanguageItemCollector<'tcx> {\n     }\n }\n \n-/// Extract the first `lang = \"$name\"` out of a list of attributes.\n+/// Extracts the first `lang = \"$name\"` out of a list of attributes.\n /// The attributes `#[panic_handler]` and `#[alloc_error_handler]`\n /// are also extracted out when found.\n pub fn extract(attrs: &[ast::Attribute]) -> Option<(Symbol, Span)> {\n@@ -216,7 +214,7 @@ pub fn extract(attrs: &[ast::Attribute]) -> Option<(Symbol, Span)> {\n     }))\n }\n \n-/// Traverse and collect all the lang items in all crates.\n+/// Traverses and collects all the lang items in all crates.\n pub fn collect<'tcx>(tcx: TyCtxt<'tcx>) -> LanguageItems {\n     // Initialize the collector.\n     let mut collector = LanguageItemCollector::new(tcx);\n@@ -246,6 +244,7 @@ pub fn collect<'tcx>(tcx: TyCtxt<'tcx>) -> LanguageItems {\n \n language_item_table! {\n //  Variant name,                Name,                 Method name,             Target;\n+    BoolImplItem,                \"bool\",               bool_impl,               Target::Impl;\n     CharImplItem,                \"char\",               char_impl,               Target::Impl;\n     StrImplItem,                 \"str\",                str_impl,                Target::Impl;\n     SliceImplItem,               \"slice\",              slice_impl,              Target::Impl;\n@@ -367,9 +366,7 @@ language_item_table! {\n \n     MaybeUninitLangItem,         \"maybe_uninit\",       maybe_uninit,            Target::Union;\n \n-    DebugTraitLangItem,          \"debug_trait\",        debug_trait,             Target::Trait;\n-\n-    // Align offset for stride != 1, must not panic.\n+    // Align offset for stride != 1; must not panic.\n     AlignOffsetLangItem,         \"align_offset\",       align_offset_fn,         Target::Fn;\n \n     TerminationTraitLangItem,    \"termination\",        termination,             Target::Trait;\n@@ -380,10 +377,14 @@ language_item_table! {\n \n impl<'tcx> TyCtxt<'tcx> {\n     /// Returns the `DefId` for a given `LangItem`.\n-    /// If not found, fatally abort compilation.\n-    pub fn require_lang_item(&self, lang_item: LangItem) -> DefId {\n+    /// If not found, fatally aborts compilation.\n+    pub fn require_lang_item(&self, lang_item: LangItem, span: Option<Span>) -> DefId {\n         self.lang_items().require(lang_item).unwrap_or_else(|msg| {\n-            self.sess.fatal(&msg)\n+            if let Some(span) = span {\n+                self.sess.span_fatal(span, &msg)\n+            } else {\n+                self.sess.fatal(&msg)\n+            }\n         })\n     }\n }"}, {"sha": "00013bfc574f4e108ce489807281d0c089fe4ecf", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -242,7 +242,7 @@ struct LocalInfo {\n \n #[derive(Copy, Clone, Debug)]\n enum VarKind {\n-    Arg(HirId, ast::Name),\n+    Param(HirId, ast::Name),\n     Local(LocalInfo),\n     CleanExit\n }\n@@ -298,7 +298,7 @@ impl IrMaps<'tcx> {\n         self.num_vars += 1;\n \n         match vk {\n-            Local(LocalInfo { id: node_id, .. }) | Arg(node_id, _) => {\n+            Local(LocalInfo { id: node_id, .. }) | Param(node_id, _) => {\n                 self.variable_map.insert(node_id, v);\n             },\n             CleanExit => {}\n@@ -320,7 +320,7 @@ impl IrMaps<'tcx> {\n \n     fn variable_name(&self, var: Variable) -> String {\n         match self.var_kinds[var.get()] {\n-            Local(LocalInfo { name, .. }) | Arg(_, name) => {\n+            Local(LocalInfo { name, .. }) | Param(_, name) => {\n                 name.to_string()\n             },\n             CleanExit => \"<clean-exit>\".to_owned()\n@@ -330,7 +330,7 @@ impl IrMaps<'tcx> {\n     fn variable_is_shorthand(&self, var: Variable) -> bool {\n         match self.var_kinds[var.get()] {\n             Local(LocalInfo { is_shorthand, .. }) => is_shorthand,\n-            Arg(..) | CleanExit => false\n+            Param(..) | CleanExit => false\n         }\n     }\n \n@@ -371,21 +371,21 @@ fn visit_fn<'tcx>(\n \n     let body = ir.tcx.hir().body(body_id);\n \n-    for arg in &body.arguments {\n-        let is_shorthand = match arg.pat.node {\n+    for param in &body.params {\n+        let is_shorthand = match param.pat.node {\n             crate::hir::PatKind::Struct(..) => true,\n             _ => false,\n         };\n-        arg.pat.each_binding(|_bm, hir_id, _x, ident| {\n-            debug!(\"adding argument {:?}\", hir_id);\n+        param.pat.each_binding(|_bm, hir_id, _x, ident| {\n+            debug!(\"adding parameters {:?}\", hir_id);\n             let var = if is_shorthand {\n                 Local(LocalInfo {\n                     id: hir_id,\n                     name: ident.name,\n                     is_shorthand: true,\n                 })\n             } else {\n-                Arg(hir_id, ident.name)\n+                Param(hir_id, ident.name)\n             };\n             fn_maps.add_variable(var);\n         })\n@@ -1525,8 +1525,8 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     }\n \n     fn warn_about_unused_args(&self, body: &hir::Body, entry_ln: LiveNode) {\n-        for arg in &body.arguments {\n-            arg.pat.each_binding(|_bm, hir_id, _, ident| {\n+        for param in &body.params {\n+            param.pat.each_binding(|_bm, hir_id, _, ident| {\n                 let sp = ident.span;\n                 let var = self.variable(hir_id, sp);\n                 // Ignore unused self."}, {"sha": "b9d8a4ec68fadd2109370da0eb121034e078f3f8", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 41, "deletions": 45, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -6,29 +6,27 @@\n //!\n //! [rustc guide]: https://rust-lang.github.io/rustc-guide/mir/borrowck.html\n \n+use crate::hir;\n+use crate::hir::Node;\n+use crate::hir::def_id::DefId;\n+use crate::hir::intravisit::{self, Visitor, NestedVisitorMap};\n+use crate::hir::{Block, Arm, Pat, PatKind, Stmt, Expr, Local};\n use crate::ich::{StableHashingContext, NodeIdHashingMode};\n use crate::util::nodemap::{FxHashMap, FxHashSet};\n-use crate::ty;\n+use crate::ty::{self, DefIdTree, TyCtxt};\n+use crate::ty::query::Providers;\n \n-use std::mem;\n-use std::fmt;\n+use rustc_data_structures::indexed_vec::Idx;\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher, StableHasherResult};\n use rustc_macros::HashStable;\n use syntax::source_map;\n use syntax_pos::{Span, DUMMY_SP};\n-use crate::ty::{DefIdTree, TyCtxt};\n-use crate::ty::query::Providers;\n \n-use crate::hir;\n-use crate::hir::Node;\n-use crate::hir::def_id::DefId;\n-use crate::hir::intravisit::{self, Visitor, NestedVisitorMap};\n-use crate::hir::{Block, Arm, Pat, PatKind, Stmt, Expr, Local};\n-use rustc_data_structures::indexed_vec::Idx;\n-use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n-                                           StableHasherResult};\n+use std::fmt;\n+use std::mem;\n \n-/// Scope represents a statically-describable scope that can be\n-/// used to bound the lifetime/region for values.\n+/// Represents a statically-describable scope that can be used to\n+/// bound the lifetime/region for values.\n ///\n /// `Node(node_id)`: Any AST node that has any scope at all has the\n /// `Node(node_id)` scope. Other variants represent special cases not\n@@ -225,25 +223,25 @@ pub struct ScopeTree {\n     /// have lifetime parameters free in this body.\n     root_parent: Option<hir::HirId>,\n \n-    /// `parent_map` maps from a scope ID to the enclosing scope id;\n+    /// Maps from a scope ID to the enclosing scope id;\n     /// this is usually corresponding to the lexical nesting, though\n     /// in the case of closures the parent scope is the innermost\n     /// conditional expression or repeating block. (Note that the\n     /// enclosing scope ID for the block associated with a closure is\n     /// the closure itself.)\n     parent_map: FxHashMap<Scope, (Scope, ScopeDepth)>,\n \n-    /// `var_map` maps from a variable or binding ID to the block in\n-    /// which that variable is declared.\n+    /// Maps from a variable or binding ID to the block in which that\n+    /// variable is declared.\n     var_map: FxHashMap<hir::ItemLocalId, Scope>,\n \n-    /// maps from a `NodeId` to the associated destruction scope (if any)\n+    /// Maps from a `NodeId` to the associated destruction scope (if any).\n     destruction_scopes: FxHashMap<hir::ItemLocalId, Scope>,\n \n-    /// `rvalue_scopes` includes entries for those expressions whose cleanup scope is\n-    /// larger than the default. The map goes from the expression id\n-    /// to the cleanup scope id. For rvalues not present in this\n-    /// table, the appropriate cleanup scope is the innermost\n+    /// `rvalue_scopes` includes entries for those expressions whose\n+    /// cleanup scope is larger than the default. The map goes from the\n+    /// expression ID to the cleanup scope id. For rvalues not present in\n+    /// this table, the appropriate cleanup scope is the innermost\n     /// enclosing statement, conditional expression, or repeating\n     /// block (see `terminating_scopes`).\n     /// In constants, None is used to indicate that certain expressions\n@@ -318,7 +316,7 @@ pub struct ScopeTree {\n     ///     4. By `2.` and `3.`, `D` is *statically* storage-dead at `U`,\n     ///     QED.\n     ///\n-    /// I don't think this property relies on `3.` in an essential way - it\n+    /// This property ought to not on (3) in an essential way -- it\n     /// is probably still correct even if we have \"unrestricted\" terminating\n     /// scopes. However, why use the complicated proof when a simple one\n     /// works?\n@@ -341,20 +339,20 @@ pub struct ScopeTree {\n \n #[derive(Debug, Copy, Clone, RustcEncodable, RustcDecodable, HashStable)]\n pub struct YieldData {\n-    /// `Span` of the yield.\n+    /// The `Span` of the yield.\n     pub span: Span,\n-    /// The number of expressions and patterns appearing before the `yield` in the body + 1.\n+    /// The number of expressions and patterns appearing before the `yield` in the body plus one.\n     pub expr_and_pat_count: usize,\n     pub source: hir::YieldSource,\n }\n \n #[derive(Debug, Copy, Clone)]\n pub struct Context {\n-    /// the root of the current region tree. This is typically the id\n+    /// The root of the current region tree. This is typically the id\n     /// of the innermost fn body. Each fn forms its own disjoint tree\n     /// in the region hierarchy. These fn bodies are themselves\n     /// arranged into a tree. See the \"Modeling closures\" section of\n-    /// the README in infer::region_constraints for more\n+    /// the README in `infer::region_constraints` for more\n     /// details.\n     root_id: Option<hir::ItemLocalId>,\n \n@@ -369,15 +367,15 @@ pub struct Context {\n struct RegionResolutionVisitor<'tcx> {\n     tcx: TyCtxt<'tcx>,\n \n-    // The number of expressions and patterns visited in the current body\n+    // The number of expressions and patterns visited in the current body.\n     expr_and_pat_count: usize,\n     // When this is `true`, we record the `Scopes` we encounter\n     // when processing a Yield expression. This allows us to fix\n     // up their indices.\n     pessimistic_yield: bool,\n-    // Stores scopes when pessimistic_yield is true.\n+    // Stores scopes when `pessimistic_yield` is `true`.\n     fixup_scopes: Vec<Scope>,\n-    // Generated scope tree:\n+    // The generated scope tree.\n     scope_tree: ScopeTree,\n \n     cx: Context,\n@@ -411,7 +409,7 @@ struct ExprLocatorVisitor {\n     expr_and_pat_count: usize,\n }\n \n-// This visitor has to have the same visit_expr calls as RegionResolutionVisitor\n+// This visitor has to have the same `visit_expr` calls as `RegionResolutionVisitor`\n // since `expr_count` is compared against the results there.\n impl<'tcx> Visitor<'tcx> for ExprLocatorVisitor {\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n@@ -456,7 +454,7 @@ impl<'tcx> ScopeTree {\n             assert!(prev.is_none());\n         }\n \n-        // record the destruction scopes for later so we can query them\n+        // Record the destruction scopes for later so we can query them.\n         if let ScopeData::Destruction = child.data {\n             self.destruction_scopes.insert(child.item_local_id(), child);\n         }\n@@ -478,7 +476,7 @@ impl<'tcx> ScopeTree {\n         self.destruction_scopes.get(&n).cloned()\n     }\n \n-    /// Records that `sub_closure` is defined within `sup_closure`. These ids\n+    /// Records that `sub_closure` is defined within `sup_closure`. These IDs\n     /// should be the ID of the block that is the fn body, which is\n     /// also the root of the region hierarchy for that fn.\n     fn record_closure_parent(&mut self,\n@@ -505,14 +503,14 @@ impl<'tcx> ScopeTree {\n         self.rvalue_scopes.insert(var, lifetime);\n     }\n \n+    /// Returns the narrowest scope that encloses `id`, if any.\n     pub fn opt_encl_scope(&self, id: Scope) -> Option<Scope> {\n-        //! Returns the narrowest scope that encloses `id`, if any.\n         self.parent_map.get(&id).cloned().map(|(p, _)| p)\n     }\n \n+    /// Returns the narrowest scope that encloses `id`, if any.\n     #[allow(dead_code)] // used in cfg\n     pub fn encl_scope(&self, id: Scope) -> Scope {\n-        //! Returns the narrowest scope that encloses `id`, if any.\n         self.opt_encl_scope(id).unwrap()\n     }\n \n@@ -522,16 +520,15 @@ impl<'tcx> ScopeTree {\n             bug!(\"no enclosing scope for id {:?}\", var_id))\n     }\n \n+    /// Returns the scope when the temp created by `expr_id` will be cleaned up.\n     pub fn temporary_scope(&self, expr_id: hir::ItemLocalId) -> Option<Scope> {\n-        //! Returns the scope when temp created by expr_id will be cleaned up\n-\n-        // check for a designated rvalue scope\n+        // Check for a designated rvalue scope.\n         if let Some(&s) = self.rvalue_scopes.get(&expr_id) {\n             debug!(\"temporary_scope({:?}) = {:?} [custom]\", expr_id, s);\n             return s;\n         }\n \n-        // else, locate the innermost terminating scope\n+        // Otherwise, locate the innermost terminating scope\n         // if there's one. Static items, for instance, won't\n         // have an enclosing scope, hence no scope will be\n         // returned.\n@@ -552,9 +549,8 @@ impl<'tcx> ScopeTree {\n         return None;\n     }\n \n+    /// Returns the lifetime of the variable `id`.\n     pub fn var_region(&self, id: hir::ItemLocalId) -> ty::RegionKind {\n-        //! Returns the lifetime of the variable `id`.\n-\n         let scope = ty::ReScope(self.var_scope(id));\n         debug!(\"var_region({:?}) = {:?}\", id, scope);\n         scope\n@@ -589,7 +585,7 @@ impl<'tcx> ScopeTree {\n         return true;\n     }\n \n-    /// Returns the ID of the innermost containing body\n+    /// Returns the ID of the innermost containing body.\n     pub fn containing_body(&self, mut scope: Scope) -> Option<hir::ItemLocalId> {\n         loop {\n             if let ScopeData::CallSite = scope.data {\n@@ -1383,8 +1379,8 @@ impl<'tcx> Visitor<'tcx> for RegionResolutionVisitor<'tcx> {\n \n         // The arguments and `self` are parented to the fn.\n         self.cx.var_parent = self.cx.parent.take();\n-        for argument in &body.arguments {\n-            self.visit_pat(&argument.pat);\n+        for param in &body.params {\n+            self.visit_pat(&param.pat);\n         }\n \n         // The body of the every fn is a root scope."}, {"sha": "8836a632a7ca89bddb6cb710f696d0aa27debc74", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -2557,7 +2557,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             } = info;\n \n             let help_name = if let Some(ident) = parent.and_then(|body| {\n-                self.tcx.hir().body(body).arguments[index].pat.simple_ident()\n+                self.tcx.hir().body(body).params[index].pat.simple_ident()\n             }) {\n                 format!(\"`{}`\", ident)\n             } else {"}, {"sha": "c06a0feb6a99381f6f8d870e992b80c610832cec", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -438,6 +438,7 @@ impl<'tcx> Index<'tcx> {\n                     level: attr::StabilityLevel::Unstable {\n                         reason: Some(Symbol::intern(reason)),\n                         issue: 27812,\n+                        is_soft: false,\n                     },\n                     feature: sym::rustc_private,\n                     rustc_depr: None,\n@@ -480,7 +481,7 @@ pub fn provide(providers: &mut Providers<'_>) {\n }\n \n pub fn report_unstable(\n-    sess: &Session, feature: Symbol, reason: Option<Symbol>, issue: u32, span: Span\n+    sess: &Session, feature: Symbol, reason: Option<Symbol>, issue: u32, is_soft: bool, span: Span\n ) {\n     let msg = match reason {\n         Some(r) => format!(\"use of unstable library feature '{}': {}\", feature, r),\n@@ -505,7 +506,13 @@ pub fn report_unstable(\n     let error_id = (DiagnosticMessageId::StabilityId(issue), span_key, msg.clone());\n     let fresh = sess.one_time_diagnostics.borrow_mut().insert(error_id);\n     if fresh {\n-        emit_feature_err(&sess.parse_sess, feature, span, GateIssue::Library(Some(issue)), &msg);\n+        if is_soft {\n+            sess.buffer_lint(lint::builtin::SOFT_UNSTABLE, CRATE_NODE_ID, span, &msg);\n+        } else {\n+            emit_feature_err(\n+                &sess.parse_sess, feature, span, GateIssue::Library(Some(issue)), &msg\n+            );\n+        }\n     }\n }\n \n@@ -621,6 +628,7 @@ pub enum EvalResult {\n         feature: Symbol,\n         reason: Option<Symbol>,\n         issue: u32,\n+        is_soft: bool,\n     },\n     /// The item does not have the `#[stable]` or `#[unstable]` marker assigned.\n     Unmarked,\n@@ -720,7 +728,9 @@ impl<'tcx> TyCtxt<'tcx> {\n         }\n \n         match stability {\n-            Some(&Stability { level: attr::Unstable { reason, issue }, feature, .. }) => {\n+            Some(&Stability {\n+                level: attr::Unstable { reason, issue, is_soft }, feature, ..\n+            }) => {\n                 if span.allows_unstable(feature) {\n                     debug!(\"stability: skipping span={:?} since it is internal\", span);\n                     return EvalResult::Allow;\n@@ -744,7 +754,7 @@ impl<'tcx> TyCtxt<'tcx> {\n                     }\n                 }\n \n-                EvalResult::Deny { feature, reason, issue }\n+                EvalResult::Deny { feature, reason, issue, is_soft }\n             }\n             Some(_) => {\n                 // Stable APIs are always ok to call and deprecated APIs are\n@@ -767,8 +777,8 @@ impl<'tcx> TyCtxt<'tcx> {\n     pub fn check_stability(self, def_id: DefId, id: Option<HirId>, span: Span) {\n         match self.eval_stability(def_id, id, span) {\n             EvalResult::Allow => {}\n-            EvalResult::Deny { feature, reason, issue } =>\n-                report_unstable(self.sess, feature, reason, issue, span),\n+            EvalResult::Deny { feature, reason, issue, is_soft } =>\n+                report_unstable(self.sess, feature, reason, issue, is_soft, span),\n             EvalResult::Unmarked => {\n                 // The API could be uncallable for other reasons, for example when a private module\n                 // was referenced."}, {"sha": "1f604877841a730e117322eb4bced048ded902d1", "filename": "src/librustc/mir/cache.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Fmir%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Fmir%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fcache.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -27,7 +27,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for Cache {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           _: &mut StableHashingContext<'a>,\n                                           _: &mut StableHasher<W>) {\n-        // do nothing\n+        // Do nothing.\n     }\n }\n "}, {"sha": "755cda792ba797091591f3bb2c1d75614ea69134", "filename": "src/librustc/mir/interpret/allocation.rs", "status": "modified", "additions": 274, "deletions": 63, "changes": 337, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -4,38 +4,53 @@ use super::{\n     Pointer, InterpResult, AllocId, ScalarMaybeUndef, write_target_uint, read_target_uint, Scalar,\n };\n \n+use crate::mir;\n use crate::ty::layout::{Size, Align};\n+\n+use rustc_data_structures::sorted_map::SortedMap;\n+use rustc_target::abi::HasDataLayout;\n use syntax::ast::Mutability;\n use std::iter;\n-use crate::mir;\n use std::ops::{Range, Deref, DerefMut};\n-use rustc_data_structures::sorted_map::SortedMap;\n-use rustc_target::abi::HasDataLayout;\n use std::borrow::Cow;\n \n-#[derive(Clone, Debug, Eq, PartialEq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n-pub struct Allocation<Tag=(),Extra=()> {\n+// NOTE: When adding new fields, make sure to adjust the `Snapshot` impl in\n+// `src/librustc_mir/interpret/snapshot.rs`.\n+#[derive(\n+    Clone,\n+    Debug,\n+    Eq,\n+    PartialEq,\n+    PartialOrd,\n+    Ord,\n+    Hash,\n+    RustcEncodable,\n+    RustcDecodable,\n+    HashStable,\n+)]\n+pub struct Allocation<Tag = (),Extra = ()> {\n     /// The actual bytes of the allocation.\n-    /// Note that the bytes of a pointer represent the offset of the pointer\n-    pub bytes: Vec<u8>,\n+    /// Note that the bytes of a pointer represent the offset of the pointer.\n+    bytes: Vec<u8>,\n     /// Maps from byte addresses to extra data for each pointer.\n     /// Only the first byte of a pointer is inserted into the map; i.e.,\n     /// every entry in this map applies to `pointer_size` consecutive bytes starting\n     /// at the given offset.\n-    pub relocations: Relocations<Tag>,\n-    /// Denotes undefined memory. Reading from undefined memory is forbidden in miri\n-    pub undef_mask: UndefMask,\n+    relocations: Relocations<Tag>,\n+    /// Denotes which part of this allocation is initialized.\n+    undef_mask: UndefMask,\n+    /// The size of the allocation. Currently, must always equal `bytes.len()`.\n+    pub size: Size,\n     /// The alignment of the allocation to detect unaligned reads.\n     pub align: Align,\n-    /// Whether the allocation is mutable.\n+    /// `true` if the allocation is mutable.\n     /// Also used by codegen to determine if a static should be put into mutable memory,\n     /// which happens for `static mut` and `static` with interior mutability.\n     pub mutability: Mutability,\n     /// Extra state for the machine.\n     pub extra: Extra,\n }\n \n-\n pub trait AllocationExtra<Tag>: ::std::fmt::Debug + Clone {\n     // There is no constructor in here because the constructor's type depends\n     // on `MemoryKind`, and making things sufficiently generic leads to painful\n@@ -77,19 +92,20 @@ pub trait AllocationExtra<Tag>: ::std::fmt::Debug + Clone {\n     }\n }\n \n-// For Tag=() and no extra state, we have is a trivial implementation.\n+// For `Tag = ()` and no extra state, we have a trivial implementation.\n impl AllocationExtra<()> for () { }\n \n // The constructors are all without extra; the extra gets added by a machine hook later.\n impl<Tag> Allocation<Tag> {\n     /// Creates a read-only allocation initialized by the given bytes\n     pub fn from_bytes<'a>(slice: impl Into<Cow<'a, [u8]>>, align: Align) -> Self {\n         let bytes = slice.into().into_owned();\n-        let undef_mask = UndefMask::new(Size::from_bytes(bytes.len() as u64), true);\n+        let size = Size::from_bytes(bytes.len() as u64);\n         Self {\n             bytes,\n             relocations: Relocations::new(),\n-            undef_mask,\n+            undef_mask: UndefMask::new(size, true),\n+            size,\n             align,\n             mutability: Mutability::Immutable,\n             extra: (),\n@@ -106,16 +122,70 @@ impl<Tag> Allocation<Tag> {\n             bytes: vec![0; size.bytes() as usize],\n             relocations: Relocations::new(),\n             undef_mask: UndefMask::new(size, false),\n+            size,\n             align,\n             mutability: Mutability::Mutable,\n             extra: (),\n         }\n     }\n }\n \n+impl Allocation<()> {\n+    /// Add Tag and Extra fields\n+    pub fn retag<T, E>(\n+        self,\n+        mut tagger: impl FnMut(AllocId) -> T,\n+        extra: E,\n+    ) -> Allocation<T, E> {\n+        Allocation {\n+            bytes: self.bytes,\n+            size: self.size,\n+            relocations: Relocations::from_presorted(\n+                self.relocations.iter()\n+                    // The allocations in the relocations (pointers stored *inside* this allocation)\n+                    // all get the base pointer tag.\n+                    .map(|&(offset, ((), alloc))| {\n+                        let tag = tagger(alloc);\n+                        (offset, (tag, alloc))\n+                    })\n+                    .collect()\n+            ),\n+            undef_mask: self.undef_mask,\n+            align: self.align,\n+            mutability: self.mutability,\n+            extra,\n+        }\n+    }\n+}\n+\n+/// Raw accessors. Provide access to otherwise private bytes.\n+impl<Tag, Extra> Allocation<Tag, Extra> {\n+    pub fn len(&self) -> usize {\n+        self.size.bytes() as usize\n+    }\n+\n+    /// Looks at a slice which may describe undefined bytes or describe a relocation. This differs\n+    /// from `get_bytes_with_undef_and_ptr` in that it does no relocation checks (even on the\n+    /// edges) at all. It further ignores `AllocationExtra` callbacks.\n+    /// This must not be used for reads affecting the interpreter execution.\n+    pub fn inspect_with_undef_and_ptr_outside_interpreter(&self, range: Range<usize>) -> &[u8] {\n+        &self.bytes[range]\n+    }\n+\n+    /// Returns the undef mask.\n+    pub fn undef_mask(&self) -> &UndefMask {\n+        &self.undef_mask\n+    }\n+\n+    /// Returns the relocation list.\n+    pub fn relocations(&self) -> &Relocations<Tag> {\n+        &self.relocations\n+    }\n+}\n+\n impl<'tcx> rustc_serialize::UseSpecializedDecodable for &'tcx Allocation {}\n \n-/// Byte accessors\n+/// Byte accessors.\n impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n     /// Just a small local helper function to avoid a bit of code repetition.\n     /// Returns the range of this allocation that was meant.\n@@ -125,16 +195,16 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n         offset: Size,\n         size: Size\n     ) -> Range<usize> {\n-        let end = offset + size; // this does overflow checking\n+        let end = offset + size; // This does overflow checking.\n         assert_eq!(\n             end.bytes() as usize as u64, end.bytes(),\n             \"cannot handle this access on this host architecture\"\n         );\n         let end = end.bytes() as usize;\n         assert!(\n-            end <= self.bytes.len(),\n+            end <= self.len(),\n             \"Out-of-bounds access at offset {}, size {} in allocation of size {}\",\n-            offset.bytes(), size.bytes(), self.bytes.len()\n+            offset.bytes(), size.bytes(), self.len()\n         );\n         (offset.bytes() as usize)..end\n     }\n@@ -162,7 +232,7 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n             self.check_defined(ptr, size)?;\n             self.check_relocations(cx, ptr, size)?;\n         } else {\n-            // We still don't want relocations on the *edges*\n+            // We still don't want relocations on the *edges*.\n             self.check_relocation_edges(cx, ptr, size)?;\n         }\n \n@@ -171,7 +241,7 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n         Ok(&self.bytes[range])\n     }\n \n-    /// Check that these bytes are initialized and not pointer bytes, and then return them\n+    /// Checks that these bytes are initialized and not pointer bytes, and then return them\n     /// as a slice.\n     ///\n     /// It is the caller's responsibility to check bounds and alignment beforehand.\n@@ -223,7 +293,7 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n     }\n }\n \n-/// Reading and writing\n+/// Reading and writing.\n impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n     /// Reads bytes until a `0` is encountered. Will error if the end of the allocation is reached\n     /// before a `0` is found.\n@@ -259,9 +329,9 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n         allow_ptr_and_undef: bool,\n     ) -> InterpResult<'tcx>\n     {\n-        // Check bounds and relocations on the edges\n+        // Check bounds and relocations on the edges.\n         self.get_bytes_with_undef_and_ptr(cx, ptr, size)?;\n-        // Check undef and ptr\n+        // Check undef and ptr.\n         if !allow_ptr_and_undef {\n             self.check_defined(ptr, size)?;\n             self.check_relocations(cx, ptr, size)?;\n@@ -302,12 +372,12 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n         Ok(())\n     }\n \n-    /// Read a *non-ZST* scalar\n+    /// Reads a *non-ZST* scalar.\n     ///\n-    /// zsts can't be read out of two reasons:\n-    /// * byteorder cannot work with zero element buffers\n-    /// * in order to obtain a `Pointer` we need to check for ZSTness anyway due to integer pointers\n-    ///   being valid for ZSTs\n+    /// ZSTs can't be read for two reasons:\n+    /// * byte-order cannot work with zero-element buffers;\n+    /// * in order to obtain a `Pointer`, we need to check for ZSTness anyway due to integer\n+    ///   pointers being valid for ZSTs.\n     ///\n     /// It is the caller's responsibility to check bounds and alignment beforehand.\n     pub fn read_scalar(\n@@ -317,20 +387,20 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n         size: Size\n     ) -> InterpResult<'tcx, ScalarMaybeUndef<Tag>>\n     {\n-        // get_bytes_unchecked tests relocation edges\n+        // `get_bytes_unchecked` tests relocation edges.\n         let bytes = self.get_bytes_with_undef_and_ptr(cx, ptr, size)?;\n         // Undef check happens *after* we established that the alignment is correct.\n-        // We must not return Ok() for unaligned pointers!\n+        // We must not return `Ok()` for unaligned pointers!\n         if self.check_defined(ptr, size).is_err() {\n-            // this inflates undefined bytes to the entire scalar, even if only a few\n-            // bytes are undefined\n+            // This inflates undefined bytes to the entire scalar, even if only a few\n+            // bytes are undefined.\n             return Ok(ScalarMaybeUndef::Undef);\n         }\n-        // Now we do the actual reading\n+        // Now we do the actual reading.\n         let bits = read_target_uint(cx.data_layout().endian, bytes).unwrap();\n-        // See if we got a pointer\n+        // See if we got a pointer.\n         if size != cx.data_layout().pointer_size {\n-            // *Now* better make sure that the inside also is free of relocations.\n+            // *Now*, we better make sure that the inside is free of relocations too.\n             self.check_relocations(cx, ptr, size)?;\n         } else {\n             match self.relocations.get(&ptr.offset) {\n@@ -345,7 +415,7 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n         Ok(ScalarMaybeUndef::Scalar(Scalar::from_uint(bits, size)))\n     }\n \n-    /// Read a pointer-sized scalar.\n+    /// Reads a pointer-sized scalar.\n     ///\n     /// It is the caller's responsibility to check bounds and alignment beforehand.\n     pub fn read_ptr_sized(\n@@ -357,12 +427,12 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n         self.read_scalar(cx, ptr, cx.data_layout().pointer_size)\n     }\n \n-    /// Write a *non-ZST* scalar\n+    /// Writes a *non-ZST* scalar.\n     ///\n-    /// zsts can't be read out of two reasons:\n-    /// * byteorder cannot work with zero element buffers\n-    /// * in oder to obtain a `Pointer` we need to check for ZSTness anyway due to integer pointers\n-    ///   being valid for ZSTs\n+    /// ZSTs can't be read for two reasons:\n+    /// * byte-order cannot work with zero-element buffers;\n+    /// * in order to obtain a `Pointer`, we need to check for ZSTness anyway due to integer\n+    ///   pointers being valid for ZSTs.\n     ///\n     /// It is the caller's responsibility to check bounds and alignment beforehand.\n     pub fn write_scalar(\n@@ -390,7 +460,7 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n         let dst = self.get_bytes_mut(cx, ptr, type_size)?;\n         write_target_uint(endian, dst, bytes).unwrap();\n \n-        // See if we have to also write a relocation\n+        // See if we have to also write a relocation.\n         match val {\n             Scalar::Ptr(val) => {\n                 self.relocations.insert(\n@@ -404,7 +474,7 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n         Ok(())\n     }\n \n-    /// Write a pointer-sized scalar.\n+    /// Writes a pointer-sized scalar.\n     ///\n     /// It is the caller's responsibility to check bounds and alignment beforehand.\n     pub fn write_ptr_sized(\n@@ -419,10 +489,10 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n     }\n }\n \n-/// Relocations\n+/// Relocations.\n impl<'tcx, Tag: Copy, Extra> Allocation<Tag, Extra> {\n-    /// Returns all relocations overlapping with the given ptr-offset pair.\n-    pub fn relocations(\n+    /// Returns all relocations overlapping with the given pointer-offset pair.\n+    pub fn get_relocations(\n         &self,\n         cx: &impl HasDataLayout,\n         ptr: Pointer<Tag>,\n@@ -431,7 +501,7 @@ impl<'tcx, Tag: Copy, Extra> Allocation<Tag, Extra> {\n         // We have to go back `pointer_size - 1` bytes, as that one would still overlap with\n         // the beginning of this range.\n         let start = ptr.offset.bytes().saturating_sub(cx.data_layout().pointer_size.bytes() - 1);\n-        let end = ptr.offset + size; // this does overflow checking\n+        let end = ptr.offset + size; // This does overflow checking.\n         self.relocations.range(Size::from_bytes(start)..end)\n     }\n \n@@ -443,7 +513,7 @@ impl<'tcx, Tag: Copy, Extra> Allocation<Tag, Extra> {\n         ptr: Pointer<Tag>,\n         size: Size,\n     ) -> InterpResult<'tcx> {\n-        if self.relocations(cx, ptr, size).is_empty() {\n+        if self.get_relocations(cx, ptr, size).is_empty() {\n             Ok(())\n         } else {\n             throw_unsup!(ReadPointerAsBytes)\n@@ -465,7 +535,7 @@ impl<'tcx, Tag: Copy, Extra> Allocation<Tag, Extra> {\n         // Find the start and end of the given range and its outermost relocations.\n         let (first, last) = {\n             // Find all relocations overlapping the given range.\n-            let relocations = self.relocations(cx, ptr, size);\n+            let relocations = self.get_relocations(cx, ptr, size);\n             if relocations.is_empty() {\n                 return Ok(());\n             }\n@@ -491,7 +561,7 @@ impl<'tcx, Tag: Copy, Extra> Allocation<Tag, Extra> {\n         Ok(())\n     }\n \n-    /// Error if there are relocations overlapping with the edges of the\n+    /// Errors if there are relocations overlapping with the edges of the\n     /// given memory range.\n     #[inline]\n     fn check_relocation_edges(\n@@ -507,7 +577,7 @@ impl<'tcx, Tag: Copy, Extra> Allocation<Tag, Extra> {\n }\n \n \n-/// Undefined bytes\n+/// Undefined bytes.\n impl<'tcx, Tag, Extra> Allocation<Tag, Extra> {\n     /// Checks that a range of bytes is defined. If not, returns the `ReadUndefBytes`\n     /// error which will report the first byte which is undefined.\n@@ -536,9 +606,97 @@ impl<'tcx, Tag, Extra> Allocation<Tag, Extra> {\n     }\n }\n \n-/// Relocations\n+/// Run-length encoding of the undef mask.\n+/// Used to copy parts of a mask multiple times to another allocation.\n+pub struct AllocationDefinedness {\n+    /// The definedness of the first range.\n+    initial: bool,\n+    /// The lengths of ranges that are run-length encoded.\n+    /// The definedness of the ranges alternate starting with `initial`.\n+    ranges: smallvec::SmallVec::<[u64; 1]>,\n+}\n+\n+/// Transferring the definedness mask to other allocations.\n+impl<Tag, Extra> Allocation<Tag, Extra> {\n+    /// Creates a run-length encoding of the undef mask.\n+    pub fn compress_undef_range(\n+        &self,\n+        src: Pointer<Tag>,\n+        size: Size,\n+    ) -> AllocationDefinedness {\n+        // Since we are copying `size` bytes from `src` to `dest + i * size` (`for i in 0..repeat`),\n+        // a naive undef mask copying algorithm would repeatedly have to read the undef mask from\n+        // the source and write it to the destination. Even if we optimized the memory accesses,\n+        // we'd be doing all of this `repeat` times.\n+        // Therefor we precompute a compressed version of the undef mask of the source value and\n+        // then write it back `repeat` times without computing any more information from the source.\n+\n+        // A precomputed cache for ranges of defined/undefined bits\n+        // 0000010010001110 will become\n+        // `[5, 1, 2, 1, 3, 3, 1]`,\n+        // where each element toggles the state.\n+\n+        let mut ranges = smallvec::SmallVec::<[u64; 1]>::new();\n+        let initial = self.undef_mask.get(src.offset);\n+        let mut cur_len = 1;\n+        let mut cur = initial;\n+\n+        for i in 1..size.bytes() {\n+            // FIXME: optimize to bitshift the current undef block's bits and read the top bit.\n+            if self.undef_mask.get(src.offset + Size::from_bytes(i)) == cur {\n+                cur_len += 1;\n+            } else {\n+                ranges.push(cur_len);\n+                cur_len = 1;\n+                cur = !cur;\n+            }\n+        }\n+\n+        ranges.push(cur_len);\n+\n+        AllocationDefinedness { ranges, initial, }\n+    }\n+\n+    /// Applies multiple instances of the run-length encoding to the undef mask.\n+    pub fn mark_compressed_undef_range(\n+        &mut self,\n+        defined: &AllocationDefinedness,\n+        dest: Pointer<Tag>,\n+        size: Size,\n+        repeat: u64,\n+    ) {\n+        // An optimization where we can just overwrite an entire range of definedness bits if\n+        // they are going to be uniformly `1` or `0`.\n+        if defined.ranges.len() <= 1 {\n+            self.undef_mask.set_range_inbounds(\n+                dest.offset,\n+                dest.offset + size * repeat,\n+                defined.initial,\n+            );\n+            return;\n+        }\n+\n+        for mut j in 0..repeat {\n+            j *= size.bytes();\n+            j += dest.offset.bytes();\n+            let mut cur = defined.initial;\n+            for range in &defined.ranges {\n+                let old_j = j;\n+                j += range;\n+                self.undef_mask.set_range_inbounds(\n+                    Size::from_bytes(old_j),\n+                    Size::from_bytes(j),\n+                    cur,\n+                );\n+                cur = !cur;\n+            }\n+        }\n+    }\n+}\n+\n+/// Relocations.\n #[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, RustcEncodable, RustcDecodable)]\n-pub struct Relocations<Tag=(), Id=AllocId>(SortedMap<Size, (Tag, Id)>);\n+pub struct Relocations<Tag = (), Id = AllocId>(SortedMap<Size, (Tag, Id)>);\n \n impl<Tag, Id> Relocations<Tag, Id> {\n     pub fn new() -> Self {\n@@ -566,6 +724,59 @@ impl<Tag> DerefMut for Relocations<Tag> {\n     }\n }\n \n+/// A partial, owned list of relocations to transfer into another allocation.\n+pub struct AllocationRelocations<Tag> {\n+    relative_relocations: Vec<(Size, (Tag, AllocId))>,\n+}\n+\n+impl<Tag: Copy, Extra> Allocation<Tag, Extra> {\n+    pub fn prepare_relocation_copy(\n+        &self,\n+        cx: &impl HasDataLayout,\n+        src: Pointer<Tag>,\n+        size: Size,\n+        dest: Pointer<Tag>,\n+        length: u64,\n+    ) -> AllocationRelocations<Tag> {\n+        let relocations = self.get_relocations(cx, src, size);\n+        if relocations.is_empty() {\n+            return AllocationRelocations { relative_relocations: Vec::new() };\n+        }\n+\n+        let mut new_relocations = Vec::with_capacity(relocations.len() * (length as usize));\n+\n+        for i in 0..length {\n+            new_relocations.extend(\n+                relocations\n+                .iter()\n+                .map(|&(offset, reloc)| {\n+                    // compute offset for current repetition\n+                    let dest_offset = dest.offset + (i * size);\n+                    (\n+                        // shift offsets from source allocation to destination allocation\n+                        offset + dest_offset - src.offset,\n+                        reloc,\n+                    )\n+                })\n+            );\n+        }\n+\n+        AllocationRelocations {\n+            relative_relocations: new_relocations,\n+        }\n+    }\n+\n+    /// Applies a relocation copy.\n+    /// The affected range, as defined in the parameters to `prepare_relocation_copy` is expected\n+    /// to be clear of relocations.\n+    pub fn mark_relocation_range(\n+        &mut self,\n+        relocations: AllocationRelocations<Tag>,\n+    ) {\n+        self.relocations.insert_presorted(relocations.relative_relocations);\n+    }\n+}\n+\n ////////////////////////////////////////////////////////////////////////////////\n // Undefined byte tracking\n ////////////////////////////////////////////////////////////////////////////////\n@@ -627,8 +838,8 @@ impl UndefMask {\n         let (blocka, bita) = bit_index(start);\n         let (blockb, bitb) = bit_index(end);\n         if blocka == blockb {\n-            // first set all bits but the first `bita`\n-            // then unset the last `64 - bitb` bits\n+            // First set all bits except the first `bita`,\n+            // then unset the last `64 - bitb` bits.\n             let range = if bitb == 0 {\n                 u64::max_value() << bita\n             } else {\n@@ -643,24 +854,24 @@ impl UndefMask {\n         }\n         // across block boundaries\n         if new_state {\n-            // set bita..64 to 1\n+            // Set `bita..64` to `1`.\n             self.blocks[blocka] |= u64::max_value() << bita;\n-            // set 0..bitb to 1\n+            // Set `0..bitb` to `1`.\n             if bitb != 0 {\n                 self.blocks[blockb] |= u64::max_value() >> (64 - bitb);\n             }\n-            // fill in all the other blocks (much faster than one bit at a time)\n+            // Fill in all the other blocks (much faster than one bit at a time).\n             for block in (blocka + 1) .. blockb {\n                 self.blocks[block] = u64::max_value();\n             }\n         } else {\n-            // set bita..64 to 0\n+            // Set `bita..64` to `0`.\n             self.blocks[blocka] &= !(u64::max_value() << bita);\n-            // set 0..bitb to 0\n+            // Set `0..bitb` to `0`.\n             if bitb != 0 {\n                 self.blocks[blockb] &= !(u64::max_value() >> (64 - bitb));\n             }\n-            // fill in all the other blocks (much faster than one bit at a time)\n+            // Fill in all the other blocks (much faster than one bit at a time).\n             for block in (blocka + 1) .. blockb {\n                 self.blocks[block] = 0;\n             }\n@@ -697,7 +908,7 @@ impl UndefMask {\n             let additional_blocks = amount.bytes() / Self::BLOCK_SIZE + 1;\n             assert_eq!(additional_blocks as usize as u64, additional_blocks);\n             self.blocks.extend(\n-                // FIXME(oli-obk): optimize this by repeating `new_state as Block`\n+                // FIXME(oli-obk): optimize this by repeating `new_state as Block`.\n                 iter::repeat(0).take(additional_blocks as usize),\n             );\n         }"}, {"sha": "09c822f7508a02b20383f42f483f1b6dbe74da8c", "filename": "src/librustc/mir/interpret/error.rs", "status": "modified", "additions": 13, "deletions": 15, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -1,23 +1,21 @@\n-use std::{fmt, env};\n+use super::{RawConst, Pointer, CheckInAllocMsg, ScalarMaybeUndef};\n \n use crate::hir;\n use crate::hir::map::definitions::DefPathData;\n use crate::mir;\n use crate::ty::{self, Ty, layout};\n use crate::ty::layout::{Size, Align, LayoutError};\n-use rustc_target::spec::abi::Abi;\n-use rustc_macros::HashStable;\n-\n-use super::{RawConst, Pointer, CheckInAllocMsg, ScalarMaybeUndef};\n+use crate::ty::query::TyCtxtAt;\n \n use backtrace::Backtrace;\n-\n-use crate::ty::query::TyCtxtAt;\n use errors::DiagnosticBuilder;\n-\n+use rustc_macros::HashStable;\n+use rustc_target::spec::abi::Abi;\n use syntax_pos::{Pos, Span};\n use syntax::symbol::Symbol;\n \n+use std::{fmt, env};\n+\n #[derive(Debug, Copy, Clone, PartialEq, Eq, HashStable, RustcEncodable, RustcDecodable)]\n pub enum ErrorHandled {\n     /// Already reported a lint or an error for this evaluation.\n@@ -430,13 +428,13 @@ impl fmt::Debug for UnsupportedOpInfo<'tcx> {\n         match self {\n             PointerOutOfBounds { ptr, msg, allocation_size } => {\n                 write!(f, \"{} failed: pointer must be in-bounds at offset {}, \\\n-                          but is outside bounds of allocation {} which has size {}\",\n+                           but is outside bounds of allocation {} which has size {}\",\n                     msg, ptr.offset.bytes(), ptr.alloc_id, allocation_size.bytes())\n             },\n             ValidationFailure(ref err) => {\n                 write!(f, \"type validation failed: {}\", err)\n             }\n-            NoMirFor(ref func) => write!(f, \"no mir for `{}`\", func),\n+            NoMirFor(ref func) => write!(f, \"no MIR for `{}`\", func),\n             FunctionAbiMismatch(caller_abi, callee_abi) =>\n                 write!(f, \"tried to call a function with ABI {:?} using caller ABI {:?}\",\n                     callee_abi, caller_abi),\n@@ -451,9 +449,9 @@ impl fmt::Debug for UnsupportedOpInfo<'tcx> {\n             FunctionArgCountMismatch =>\n                 write!(f, \"tried to call a function with incorrect number of arguments\"),\n             ReallocatedWrongMemoryKind(ref old, ref new) =>\n-                write!(f, \"tried to reallocate memory from {} to {}\", old, new),\n+                write!(f, \"tried to reallocate memory from `{}` to `{}`\", old, new),\n             DeallocatedWrongMemoryKind(ref old, ref new) =>\n-                write!(f, \"tried to deallocate {} memory but gave {} as the kind\", old, new),\n+                write!(f, \"tried to deallocate `{}` memory but gave `{}` as the kind\", old, new),\n             InvalidChar(c) =>\n                 write!(f, \"tried to interpret an invalid 32-bit value as a char: {}\", c),\n             AlignmentCheckFailed { required, has } =>\n@@ -462,7 +460,7 @@ impl fmt::Debug for UnsupportedOpInfo<'tcx> {\n             TypeNotPrimitive(ty) =>\n                 write!(f, \"expected primitive type, got {}\", ty),\n             PathNotFound(ref path) =>\n-                write!(f, \"Cannot find path {:?}\", path),\n+                write!(f, \"cannot find path {:?}\", path),\n             IncorrectAllocationInformation(size, size2, align, align2) =>\n                 write!(f, \"incorrect alloc info: expected size {} and align {}, \\\n                            got size {} and align {}\",\n@@ -525,7 +523,7 @@ impl fmt::Debug for UnsupportedOpInfo<'tcx> {\n             InvalidBoolOp(_) =>\n                 write!(f, \"invalid boolean operation\"),\n             UnterminatedCString(_) =>\n-                write!(f, \"attempted to get length of a null terminated string, but no null \\\n+                write!(f, \"attempted to get length of a null-terminated string, but no null \\\n                     found before end of allocation\"),\n             ReadUndefBytes(_) =>\n                 write!(f, \"attempted to read undefined bytes\"),\n@@ -582,7 +580,7 @@ pub type InterpResult<'tcx, T = ()> = Result<T, InterpErrorInfo<'tcx>>;\n \n impl fmt::Display for InterpError<'_> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        // Forward `Display` to `Debug`\n+        // Forward `Display` to `Debug`.\n         write!(f, \"{:?}\", self)\n     }\n }"}, {"sha": "23433c2e8834d28dc65e8b162712e62451a96db6", "filename": "src/librustc/mir/interpret/mod.rs", "status": "modified", "additions": 55, "deletions": 54, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -1,4 +1,4 @@\n-//! An interpreter for MIR used in CTFE and by miri\n+//! An interpreter for MIR used in CTFE and by miri.\n \n #[macro_export]\n macro_rules! err_unsup {\n@@ -107,21 +107,21 @@ pub use self::allocation::{Allocation, AllocationExtra, Relocations, UndefMask};\n \n pub use self::pointer::{Pointer, PointerArithmetic, CheckInAllocMsg};\n \n-use std::fmt;\n use crate::mir;\n use crate::hir::def_id::DefId;\n use crate::ty::{self, TyCtxt, Instance, subst::UnpackedKind};\n+use crate::ty::codec::TyDecoder;\n use crate::ty::layout::{self, Size};\n use std::io;\n+use std::fmt;\n+use std::num::NonZeroU32;\n+use std::sync::atomic::{AtomicU32, Ordering};\n use rustc_serialize::{Encoder, Decodable, Encodable};\n use rustc_data_structures::fx::FxHashMap;\n-use rustc_data_structures::sync::{Lock as Mutex, HashMapExt};\n+use rustc_data_structures::sync::{Lock, HashMapExt};\n use rustc_data_structures::tiny_list::TinyList;\n use rustc_macros::HashStable;\n use byteorder::{WriteBytesExt, ReadBytesExt, LittleEndian, BigEndian};\n-use crate::ty::codec::TyDecoder;\n-use std::sync::atomic::{AtomicU32, Ordering};\n-use std::num::NonZeroU32;\n \n /// Uniquely identifies a specific constant or static.\n #[derive(Copy, Clone, Debug, Eq, PartialEq, Hash, RustcEncodable, RustcDecodable, HashStable)]\n@@ -152,8 +152,8 @@ pub fn specialized_encode_alloc_id<'tcx, E: Encoder>(\n     tcx: TyCtxt<'tcx>,\n     alloc_id: AllocId,\n ) -> Result<(), E::Error> {\n-    let alloc: GlobalAlloc<'tcx> =\n-        tcx.alloc_map.lock().get(alloc_id).expect(\"no value for AllocId\");\n+    let alloc: GlobalAlloc<'tcx> = tcx.alloc_map.lock().get(alloc_id)\n+        .expect(\"no value for given alloc ID\");\n     match alloc {\n         GlobalAlloc::Memory(alloc) => {\n             trace!(\"encoding {:?} with {:#?}\", alloc_id, alloc);\n@@ -166,8 +166,8 @@ pub fn specialized_encode_alloc_id<'tcx, E: Encoder>(\n             fn_instance.encode(encoder)?;\n         }\n         GlobalAlloc::Static(did) => {\n-            // referring to statics doesn't need to know about their allocations,\n-            // just about its DefId\n+            // References to statics doesn't need to know about their allocations,\n+            // just about its `DefId`.\n             AllocDiscriminant::Static.encode(encoder)?;\n             did.encode(encoder)?;\n         }\n@@ -187,19 +187,18 @@ enum State {\n }\n \n pub struct AllocDecodingState {\n-    // For each AllocId we keep track of which decoding state it's currently in.\n-    decoding_state: Vec<Mutex<State>>,\n+    // For each `AllocId`, we keep track of which decoding state it's currently in.\n+    decoding_state: Vec<Lock<State>>,\n     // The offsets of each allocation in the data stream.\n     data_offsets: Vec<u32>,\n }\n \n impl AllocDecodingState {\n-\n     pub fn new_decoding_session(&self) -> AllocDecodingSession<'_> {\n         static DECODER_SESSION_ID: AtomicU32 = AtomicU32::new(0);\n         let counter = DECODER_SESSION_ID.fetch_add(1, Ordering::SeqCst);\n \n-        // Make sure this is never zero\n+        // Make sure this is never zero.\n         let session_id = DecodingSessionId::new((counter & 0x7FFFFFFF) + 1).unwrap();\n \n         AllocDecodingSession {\n@@ -208,10 +207,10 @@ impl AllocDecodingState {\n         }\n     }\n \n-    pub fn new(data_offsets: Vec<u32>) -> AllocDecodingState {\n-        let decoding_state = vec![Mutex::new(State::Empty); data_offsets.len()];\n+    pub fn new(data_offsets: Vec<u32>) -> Self {\n+        let decoding_state = vec![Lock::new(State::Empty); data_offsets.len()];\n \n-        AllocDecodingState {\n+        Self {\n             decoding_state,\n             data_offsets,\n         }\n@@ -225,23 +224,23 @@ pub struct AllocDecodingSession<'s> {\n }\n \n impl<'s> AllocDecodingSession<'s> {\n-    // Decodes an AllocId in a thread-safe way.\n+    /// Decodes an `AllocId` in a thread-safe way.\n     pub fn decode_alloc_id<D>(&self, decoder: &mut D) -> Result<AllocId, D::Error>\n     where\n         D: TyDecoder<'tcx>,\n     {\n-        // Read the index of the allocation\n+        // Read the index of the allocation.\n         let idx = decoder.read_u32()? as usize;\n         let pos = self.state.data_offsets[idx] as usize;\n \n-        // Decode the AllocDiscriminant now so that we know if we have to reserve an\n-        // AllocId.\n+        // Decode the `AllocDiscriminant` now so that we know if we have to reserve an\n+        // `AllocId`.\n         let (alloc_kind, pos) = decoder.with_position(pos, |decoder| {\n             let alloc_kind = AllocDiscriminant::decode(decoder)?;\n             Ok((alloc_kind, decoder.position()))\n         })?;\n \n-        // Check the decoding state, see if it's already decoded or if we should\n+        // Check the decoding state to see if it's already decoded or if we should\n         // decode it here.\n         let alloc_id = {\n             let mut entry = self.state.decoding_state[idx].lock();\n@@ -251,20 +250,20 @@ impl<'s> AllocDecodingSession<'s> {\n                     return Ok(alloc_id);\n                 }\n                 ref mut entry @ State::Empty => {\n-                    // We are allowed to decode\n+                    // We are allowed to decode.\n                     match alloc_kind {\n                         AllocDiscriminant::Alloc => {\n                             // If this is an allocation, we need to reserve an\n-                            // AllocId so we can decode cyclic graphs.\n+                            // `AllocId` so we can decode cyclic graphs.\n                             let alloc_id = decoder.tcx().alloc_map.lock().reserve();\n                             *entry = State::InProgress(\n                                 TinyList::new_single(self.session_id),\n                                 alloc_id);\n                             Some(alloc_id)\n                         },\n                         AllocDiscriminant::Fn | AllocDiscriminant::Static => {\n-                            // Fns and statics cannot be cyclic and their AllocId\n-                            // is determined later by interning\n+                            // Fns and statics cannot be cyclic, and their `AllocId`\n+                            // is determined later by interning.\n                             *entry = State::InProgressNonAlloc(\n                                 TinyList::new_single(self.session_id));\n                             None\n@@ -273,9 +272,9 @@ impl<'s> AllocDecodingSession<'s> {\n                 }\n                 State::InProgressNonAlloc(ref mut sessions) => {\n                     if sessions.contains(&self.session_id) {\n-                        bug!(\"This should be unreachable\")\n+                        bug!(\"this should be unreachable\");\n                     } else {\n-                        // Start decoding concurrently\n+                        // Start decoding concurrently.\n                         sessions.insert(self.session_id);\n                         None\n                     }\n@@ -285,37 +284,38 @@ impl<'s> AllocDecodingSession<'s> {\n                         // Don't recurse.\n                         return Ok(alloc_id)\n                     } else {\n-                        // Start decoding concurrently\n+                        // Start decoding concurrently.\n                         sessions.insert(self.session_id);\n                         Some(alloc_id)\n                     }\n                 }\n             }\n         };\n \n-        // Now decode the actual data\n+        // Now decode the actual data.\n         let alloc_id = decoder.with_position(pos, |decoder| {\n             match alloc_kind {\n                 AllocDiscriminant::Alloc => {\n-                    let allocation = <&'tcx Allocation as Decodable>::decode(decoder)?;\n-                    // We already have a reserved AllocId.\n+                    let alloc = <&'tcx Allocation as Decodable>::decode(decoder)?;\n+                    // We already have a reserved `AllocId`.\n                     let alloc_id = alloc_id.unwrap();\n-                    trace!(\"decoded alloc {:?} {:#?}\", alloc_id, allocation);\n-                    decoder.tcx().alloc_map.lock().set_alloc_id_same_memory(alloc_id, allocation);\n+                    trace!(\"decoded alloc {:?}: {:#?}\", alloc_id, alloc);\n+                    decoder.tcx().alloc_map.lock().set_alloc_id_same_memory(alloc_id, alloc);\n                     Ok(alloc_id)\n                 },\n                 AllocDiscriminant::Fn => {\n                     assert!(alloc_id.is_none());\n-                    trace!(\"creating fn alloc id\");\n+                    trace!(\"creating fn alloc ID\");\n                     let instance = ty::Instance::decode(decoder)?;\n                     trace!(\"decoded fn alloc instance: {:?}\", instance);\n                     let alloc_id = decoder.tcx().alloc_map.lock().create_fn_alloc(instance);\n                     Ok(alloc_id)\n                 },\n                 AllocDiscriminant::Static => {\n                     assert!(alloc_id.is_none());\n-                    trace!(\"creating extern static alloc id at\");\n+                    trace!(\"creating extern static alloc ID\");\n                     let did = DefId::decode(decoder)?;\n+                    trace!(\"decoded static def-ID: {:?}\", did);\n                     let alloc_id = decoder.tcx().alloc_map.lock().create_static_alloc(did);\n                     Ok(alloc_id)\n                 }\n@@ -340,7 +340,7 @@ impl fmt::Display for AllocId {\n /// a static, or a \"real\" allocation with some data in it.\n #[derive(Debug, Clone, Eq, PartialEq, Hash, RustcDecodable, RustcEncodable, HashStable)]\n pub enum GlobalAlloc<'tcx> {\n-    /// The alloc ID is used as a function pointer\n+    /// The alloc ID is used as a function pointer.\n     Function(Instance<'tcx>),\n     /// The alloc ID points to a \"lazy\" static variable that did not get computed (yet).\n     /// This is also used to break the cycle in recursive statics.\n@@ -350,16 +350,17 @@ pub enum GlobalAlloc<'tcx> {\n }\n \n pub struct AllocMap<'tcx> {\n-    /// Lets you know what an `AllocId` refers to.\n+    /// Maps `AllocId`s to their corresponding allocations.\n     alloc_map: FxHashMap<AllocId, GlobalAlloc<'tcx>>,\n \n     /// Used to ensure that statics and functions only get one associated `AllocId`.\n     /// Should never contain a `GlobalAlloc::Memory`!\n-    /// FIXME: Should we just have two separate dedup maps for statics and functions each?\n+    //\n+    // FIXME: Should we just have two separate dedup maps for statics and functions each?\n     dedup: FxHashMap<GlobalAlloc<'tcx>, AllocId>,\n \n     /// The `AllocId` to assign to the next requested ID.\n-    /// Always incremented, never gets smaller.\n+    /// Always incremented; never gets smaller.\n     next_id: AllocId,\n }\n \n@@ -389,7 +390,7 @@ impl<'tcx> AllocMap<'tcx> {\n         next\n     }\n \n-    /// Reserve a new ID *if* this allocation has not been dedup-reserved before.\n+    /// Reserves a new ID *if* this allocation has not been dedup-reserved before.\n     /// Should only be used for function pointers and statics, we don't want\n     /// to dedup IDs for \"real\" memory!\n     fn reserve_and_set_dedup(&mut self, alloc: GlobalAlloc<'tcx>) -> AllocId {\n@@ -430,17 +431,17 @@ impl<'tcx> AllocMap<'tcx> {\n             }\n         });\n         if is_generic {\n-            // Get a fresh ID\n+            // Get a fresh ID.\n             let id = self.reserve();\n             self.alloc_map.insert(id, GlobalAlloc::Function(instance));\n             id\n         } else {\n-            // Deduplicate\n+            // Deduplicate.\n             self.reserve_and_set_dedup(GlobalAlloc::Function(instance))\n         }\n     }\n \n-    /// Intern the `Allocation` and return a new `AllocId`, even if there's already an identical\n+    /// Interns the `Allocation` and return a new `AllocId`, even if there's already an identical\n     /// `Allocation` with a different `AllocId`.\n     /// Statics with identical content will still point to the same `Allocation`, i.e.,\n     /// their data will be deduplicated through `Allocation` interning -- but they\n@@ -465,19 +466,19 @@ impl<'tcx> AllocMap<'tcx> {\n     pub fn unwrap_memory(&self, id: AllocId) -> &'tcx Allocation {\n         match self.get(id) {\n             Some(GlobalAlloc::Memory(mem)) => mem,\n-            _ => bug!(\"expected allocation id {} to point to memory\", id),\n+            _ => bug!(\"expected allocation ID {} to point to memory\", id),\n         }\n     }\n \n-    /// Freeze an `AllocId` created with `reserve` by pointing it at an `Allocation`. Trying to\n+    /// Freezes an `AllocId` created with `reserve` by pointing it at an `Allocation`. Trying to\n     /// call this function twice, even with the same `Allocation` will ICE the compiler.\n     pub fn set_alloc_id_memory(&mut self, id: AllocId, mem: &'tcx Allocation) {\n         if let Some(old) = self.alloc_map.insert(id, GlobalAlloc::Memory(mem)) {\n-            bug!(\"tried to set allocation id {}, but it was already existing as {:#?}\", id, old);\n+            bug!(\"tried to set allocation ID {}, but it was already existing as {:#?}\", id, old);\n         }\n     }\n \n-    /// Freeze an `AllocId` created with `reserve` by pointing it at an `Allocation`. May be called\n+    /// Freezes an `AllocId` created with `reserve` by pointing it at an `Allocation`. May be called\n     /// twice for the same `(AllocId, Allocation)` pair.\n     fn set_alloc_id_same_memory(&mut self, id: AllocId, mem: &'tcx Allocation) {\n         self.alloc_map.insert_same(id, GlobalAlloc::Memory(mem));\n@@ -513,7 +514,7 @@ pub fn read_target_uint(endianness: layout::Endian, mut source: &[u8]) -> Result\n // Methods to facilitate working with signed integers stored in a u128\n ////////////////////////////////////////////////////////////////////////////////\n \n-/// Truncate `value` to `size` bits and then sign-extend it to 128 bits\n+/// Truncates `value` to `size` bits and then sign-extend it to 128 bits\n /// (i.e., if it is negative, fill with 1's on the left).\n #[inline]\n pub fn sign_extend(value: u128, size: Size) -> u128 {\n@@ -522,14 +523,14 @@ pub fn sign_extend(value: u128, size: Size) -> u128 {\n         // Truncated until nothing is left.\n         return 0;\n     }\n-    // sign extend\n+    // Sign-extend it.\n     let shift = 128 - size;\n-    // shift the unsigned value to the left\n-    // and back to the right as signed (essentially fills with FF on the left)\n+    // Shift the unsigned value to the left, then shift back to the right as signed\n+    // (essentially fills with FF on the left).\n     (((value << shift) as i128) >> shift) as u128\n }\n \n-/// Truncate `value` to `size` bits.\n+/// Truncates `value` to `size` bits.\n #[inline]\n pub fn truncate(value: u128, size: Size) -> u128 {\n     let size = size.bits();\n@@ -538,6 +539,6 @@ pub fn truncate(value: u128, size: Size) -> u128 {\n         return 0;\n     }\n     let shift = 128 - size;\n-    // truncate (shift left to drop out leftover values, shift right to fill with zeroes)\n+    // Truncate (shift left to drop out leftover values, shift right to fill with zeroes).\n     (value << shift) >> shift\n }"}, {"sha": "1bb4d9ea4d6d92edddac3a6541ec36a84f930145", "filename": "src/librustc/mir/interpret/pointer.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Fmir%2Finterpret%2Fpointer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Fmir%2Finterpret%2Fpointer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fpointer.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -86,18 +86,17 @@ pub trait PointerArithmetic: layout::HasDataLayout {\n \n impl<T: layout::HasDataLayout> PointerArithmetic for T {}\n \n-\n-/// Pointer is generic over the type that represents a reference to Allocations,\n+/// `Pointer` is generic over the type that represents a reference to `Allocation`s,\n /// thus making it possible for the most convenient representation to be used in\n /// each context.\n ///\n-/// Defaults to the index based and loosely coupled AllocId.\n+/// Defaults to the index based and loosely coupled `AllocId`.\n ///\n /// Pointer is also generic over the `Tag` associated with each pointer,\n /// which is used to do provenance tracking during execution.\n #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd,\n          RustcEncodable, RustcDecodable, Hash, HashStable)]\n-pub struct Pointer<Tag=(),Id=AllocId> {\n+pub struct Pointer<Tag = (), Id = AllocId> {\n     pub alloc_id: Id,\n     pub offset: Size,\n     pub tag: Tag,\n@@ -117,7 +116,7 @@ impl<Id: fmt::Debug> fmt::Debug for Pointer<(), Id> {\n     }\n }\n \n-/// Produces a `Pointer` which points to the beginning of the Allocation\n+/// Produces a `Pointer` which points to the beginning of the `Allocation`.\n impl From<AllocId> for Pointer {\n     #[inline(always)]\n     fn from(alloc_id: AllocId) -> Self {"}, {"sha": "d72d879059369adb2f64d61aa2c7ae598ba564c8", "filename": "src/librustc/mir/interpret/value.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -91,7 +91,7 @@ impl<'tcx> ConstValue<'tcx> {\n /// of a simple value or a pointer into another `Allocation`\n #[derive(Clone, Copy, Eq, PartialEq, Ord, PartialOrd,\n          RustcEncodable, RustcDecodable, Hash, HashStable)]\n-pub enum Scalar<Tag=(), Id=AllocId> {\n+pub enum Scalar<Tag = (), Id = AllocId> {\n     /// The raw bytes of a simple value.\n     Raw {\n         /// The first `size` bytes of `data` are the value.\n@@ -359,7 +359,7 @@ impl<'tcx, Tag> Scalar<Tag> {\n \n     #[inline(always)]\n     pub fn assert_bits(self, target_size: Size) -> u128 {\n-        self.to_bits(target_size).expect(\"Expected Raw bits but got a Pointer\")\n+        self.to_bits(target_size).expect(\"expected Raw bits but got a Pointer\")\n     }\n \n     /// Do not call this method!  Use either `assert_ptr` or `force_ptr`.\n@@ -374,7 +374,7 @@ impl<'tcx, Tag> Scalar<Tag> {\n \n     #[inline(always)]\n     pub fn assert_ptr(self) -> Pointer<Tag> {\n-        self.to_ptr().expect(\"Expected a Pointer but got Raw bits\")\n+        self.to_ptr().expect(\"expected a Pointer but got Raw bits\")\n     }\n \n     /// Do not call this method!  Dispatch based on the type instead.\n@@ -482,8 +482,8 @@ impl<Tag> From<Pointer<Tag>> for Scalar<Tag> {\n     }\n }\n \n-#[derive(Clone, Copy, Eq, PartialEq, Ord, PartialOrd, RustcEncodable, RustcDecodable, Hash)]\n-pub enum ScalarMaybeUndef<Tag=(), Id=AllocId> {\n+#[derive(Clone, Copy, Eq, PartialEq, Ord, PartialOrd, Hash, RustcEncodable, RustcDecodable)]\n+pub enum ScalarMaybeUndef<Tag = (), Id = AllocId> {\n     Scalar(Scalar<Tag, Id>),\n     Undef,\n }"}, {"sha": "18a5142208d2d6dcb0cce0260769c79ea1f5ae04", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 182, "deletions": 98, "changes": 280, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -18,6 +18,7 @@ use crate::ty::{\n     self, AdtDef, CanonicalUserTypeAnnotations, ClosureSubsts, GeneratorSubsts, Region, Ty, TyCtxt,\n     UserTypeAnnotationIndex,\n };\n+\n use polonius_engine::Atom;\n use rustc_data_structures::bit_set::BitMatrix;\n use rustc_data_structures::fx::FxHashSet;\n@@ -70,7 +71,7 @@ impl<'tcx> HasLocalDecls<'tcx> for Body<'tcx> {\n \n /// The various \"big phases\" that MIR goes through.\n ///\n-/// Warning: ordering of variants is significant\n+/// Warning: ordering of variants is significant.\n #[derive(Copy, Clone, RustcEncodable, RustcDecodable, Debug, PartialEq, Eq, PartialOrd, Ord)]\n pub enum MirPhase {\n     Build = 0,\n@@ -80,16 +81,16 @@ pub enum MirPhase {\n }\n \n impl MirPhase {\n-    /// Gets the index of the current MirPhase within the set of all MirPhases.\n+    /// Gets the index of the current MirPhase within the set of all `MirPhase`s.\n     pub fn phase_index(&self) -> usize {\n         *self as usize\n     }\n }\n \n-/// Lowered representation of a single function.\n+/// The lowered representation of a single function.\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct Body<'tcx> {\n-    /// List of basic blocks. References to basic block use a newtyped index type `BasicBlock`\n+    /// A list of basic blocks. References to basic block use a newtyped index type `BasicBlock`\n     /// that indexes into this vector.\n     basic_blocks: IndexVec<BasicBlock, BasicBlockData<'tcx>>,\n \n@@ -100,23 +101,18 @@ pub struct Body<'tcx> {\n     /// us to see the difference and forego optimization on the inlined promoted items.\n     pub phase: MirPhase,\n \n-    /// List of source scopes; these are referenced by statements\n+    /// A list of source scopes; these are referenced by statements\n     /// and used for debuginfo. Indexed by a `SourceScope`.\n     pub source_scopes: IndexVec<SourceScope, SourceScopeData>,\n \n     /// Crate-local information for each source scope, that can't (and\n     /// needn't) be tracked across crates.\n     pub source_scope_local_data: ClearCrossCrate<IndexVec<SourceScope, SourceScopeLocalData>>,\n \n-    /// Rvalues promoted from this function, such as borrows of constants.\n-    /// Each of them is the Body of a constant with the fn's type parameters\n-    /// in scope, but a separate set of locals.\n-    pub promoted: IndexVec<Promoted, Body<'tcx>>,\n-\n-    /// Yields type of the function, if it is a generator.\n+    /// The yield type of the function, if it is a generator.\n     pub yield_ty: Option<Ty<'tcx>>,\n \n-    /// Generator drop glue\n+    /// Generator drop glue.\n     pub generator_drop: Option<Box<Body<'tcx>>>,\n \n     /// The layout of a generator. Produced by the state transformation.\n@@ -129,10 +125,10 @@ pub struct Body<'tcx> {\n     /// variables and temporaries.\n     pub local_decls: LocalDecls<'tcx>,\n \n-    /// User type annotations\n+    /// User type annotations.\n     pub user_type_annotations: CanonicalUserTypeAnnotations<'tcx>,\n \n-    /// Number of arguments this function takes.\n+    /// The number of arguments this function takes.\n     ///\n     /// Starting at local 1, `arg_count` locals will be provided by the caller\n     /// and can be assumed to be initialized.\n@@ -148,10 +144,11 @@ pub struct Body<'tcx> {\n \n     /// Names and capture modes of all the closure upvars, assuming\n     /// the first argument is either the closure or a reference to it.\n+    //\n     // NOTE(eddyb) This is *strictly* a temporary hack for codegen\n     // debuginfo generation, and will be removed at some point.\n-    // Do **NOT** use it for anything else, upvar information should not be\n-    // in the MIR, please rely on local crate HIR or other side-channels.\n+    // Do **NOT** use it for anything else; upvar information should not be\n+    // in the MIR, so please rely on local crate HIR or other side-channels.\n     pub __upvar_debuginfo_codegen_only_do_not_use: Vec<UpvarDebuginfo>,\n \n     /// Mark this MIR of a const context other than const functions as having converted a `&&` or\n@@ -162,10 +159,10 @@ pub struct Body<'tcx> {\n     /// List of places where control flow was destroyed. Used for error reporting.\n     pub control_flow_destroyed: Vec<(Span, String)>,\n \n-    /// A span representing this MIR, for error reporting\n+    /// A span representing this MIR, for error reporting.\n     pub span: Span,\n \n-    /// A cache for various calculations\n+    /// A cache for various calculations.\n     cache: cache::Cache,\n }\n \n@@ -174,7 +171,6 @@ impl<'tcx> Body<'tcx> {\n         basic_blocks: IndexVec<BasicBlock, BasicBlockData<'tcx>>,\n         source_scopes: IndexVec<SourceScope, SourceScopeData>,\n         source_scope_local_data: ClearCrossCrate<IndexVec<SourceScope, SourceScopeLocalData>>,\n-        promoted: IndexVec<Promoted, Body<'tcx>>,\n         yield_ty: Option<Ty<'tcx>>,\n         local_decls: LocalDecls<'tcx>,\n         user_type_annotations: CanonicalUserTypeAnnotations<'tcx>,\n@@ -183,7 +179,7 @@ impl<'tcx> Body<'tcx> {\n         span: Span,\n         control_flow_destroyed: Vec<(Span, String)>,\n     ) -> Self {\n-        // We need `arg_count` locals, and one for the return place\n+        // We need `arg_count` locals, and one for the return place.\n         assert!(\n             local_decls.len() >= arg_count + 1,\n             \"expected at least {} locals, got {}\",\n@@ -196,7 +192,6 @@ impl<'tcx> Body<'tcx> {\n             basic_blocks,\n             source_scopes,\n             source_scope_local_data,\n-            promoted,\n             yield_ty,\n             generator_drop: None,\n             generator_layout: None,\n@@ -391,12 +386,12 @@ impl<'tcx> Body<'tcx> {\n         true\n     }\n \n-    /// Returns the return type, it always return first element from `local_decls` array\n+    /// Returns the return type; it always return first element from `local_decls` array.\n     pub fn return_ty(&self) -> Ty<'tcx> {\n         self.local_decls[RETURN_PLACE].ty\n     }\n \n-    /// Gets the location of the terminator for the given block\n+    /// Gets the location of the terminator for the given block.\n     pub fn terminator_loc(&self, bb: BasicBlock) -> Location {\n         Location { block: bb, statement_index: self[bb].statements.len() }\n     }\n@@ -418,7 +413,6 @@ impl_stable_hash_for!(struct Body<'tcx> {\n     basic_blocks,\n     source_scopes,\n     source_scope_local_data,\n-    promoted,\n     yield_ty,\n     generator_drop,\n     generator_layout,\n@@ -471,7 +465,7 @@ impl<T: Decodable> rustc_serialize::UseSpecializedDecodable for ClearCrossCrate<\n /// Most passes can work with it as a whole, within a single function.\n #[derive(Copy, Clone, Debug, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, HashStable)]\n pub struct SourceInfo {\n-    /// Source span for the AST pertaining to this MIR entity.\n+    /// The source span for the AST pertaining to this MIR entity.\n     pub span: Span,\n \n     /// The source scope, keeping track of which bindings can be\n@@ -599,13 +593,13 @@ impl Atom for Local {\n /// Classifies locals into categories. See `Body::local_kind`.\n #[derive(PartialEq, Eq, Debug, HashStable)]\n pub enum LocalKind {\n-    /// User-declared variable binding\n+    /// User-declared variable binding.\n     Var,\n-    /// Compiler-introduced temporary\n+    /// Compiler-introduced temporary.\n     Temp,\n-    /// Function argument\n+    /// Function argument.\n     Arg,\n-    /// Location of function's return value\n+    /// Location of function's return value.\n     ReturnPointer,\n }\n \n@@ -627,7 +621,7 @@ pub struct VarBindingForm<'tcx> {\n     /// (b) it gives a way to separate this case from the remaining cases\n     ///     for diagnostics.\n     pub opt_match_place: Option<(Option<Place<'tcx>>, Span)>,\n-    /// Span of the pattern in which this variable was bound.\n+    /// The span of the pattern in which this variable was bound.\n     pub pat_span: Span,\n }\n \n@@ -729,12 +723,12 @@ impl_stable_hash_for!(struct BlockTailInfo { tail_result_is_ignored });\n /// argument, or the return place.\n #[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n pub struct LocalDecl<'tcx> {\n-    /// `let mut x` vs `let x`.\n+    /// Whether this is a mutable minding (i.e., `let x` or `let mut x`).\n     ///\n     /// Temporaries and the return place are always mutable.\n     pub mutability: Mutability,\n \n-    /// Some(binding_mode) if this corresponds to a user-declared local variable.\n+    /// `Some(binding_mode)` if this corresponds to a user-declared local variable.\n     ///\n     /// This is solely used for local diagnostics when generating\n     /// warnings/errors when compiling the current crate, and\n@@ -768,7 +762,7 @@ pub struct LocalDecl<'tcx> {\n     /// intervening statement context).\n     pub is_block_tail: Option<BlockTailInfo>,\n \n-    /// Type of this local.\n+    /// The type of this local.\n     pub ty: Ty<'tcx>,\n \n     /// If the user manually ascribed a type to this variable,\n@@ -777,7 +771,7 @@ pub struct LocalDecl<'tcx> {\n     /// region inference.\n     pub user_ty: UserTypeProjections,\n \n-    /// Name of the local, used in debuginfo and pretty-printing.\n+    /// The name of the local, used in debuginfo and pretty-printing.\n     ///\n     /// Note that function arguments can also have this set to `Some(_)`\n     /// to generate better debuginfo.\n@@ -845,8 +839,8 @@ pub struct LocalDecl<'tcx> {\n     /// ROOT SCOPE\n     ///  \u2502{ argument x: &str }\n     ///  \u2502\n-    ///  \u2502 \u2502{ #[allow(unused_mut)] } // this is actually split into 2 scopes\n-    ///  \u2502 \u2502                        // in practice because I'm lazy.\n+    ///  \u2502 \u2502{ #[allow(unused_mut)] } // This is actually split into 2 scopes\n+    ///  \u2502 \u2502                         // in practice because I'm lazy.\n     ///  \u2502 \u2502\n     ///  \u2502 \u2502\u2190 x.source_info.scope\n     ///  \u2502 \u2502\u2190 `x.parse().unwrap()`\n@@ -860,7 +854,7 @@ pub struct LocalDecl<'tcx> {\n     ///  \u2502\n     ///  \u2502 \u2502{ let x: u32 }\n     ///  \u2502 \u2502\u2190 x.visibility_scope\n-    ///  \u2502 \u2502\u2190 `drop(x)` // this accesses `x: u32`\n+    ///  \u2502 \u2502\u2190 `drop(x)` // This accesses `x: u32`.\n     /// ```\n     pub source_info: SourceInfo,\n \n@@ -1046,16 +1040,16 @@ pub struct Terminator<'tcx> {\n \n #[derive(Clone, RustcEncodable, RustcDecodable, HashStable)]\n pub enum TerminatorKind<'tcx> {\n-    /// block should have one successor in the graph; we jump there\n+    /// Block should have one successor in the graph; we jump there.\n     Goto { target: BasicBlock },\n \n-    /// operand evaluates to an integer; jump depending on its value\n-    /// to one of the targets, and otherwise fallback to `otherwise`\n+    /// Operand evaluates to an integer; jump depending on its value\n+    /// to one of the targets, and otherwise fallback to `otherwise`.\n     SwitchInt {\n-        /// discriminant value being tested\n+        /// The discriminant value being tested.\n         discr: Operand<'tcx>,\n \n-        /// type of value being tested\n+        /// The type of value being tested.\n         switch_ty: Ty<'tcx>,\n \n         /// Possible values. The locations to branch to in each case\n@@ -1065,6 +1059,7 @@ pub enum TerminatorKind<'tcx> {\n         /// Possible branch sites. The last element of this vector is used\n         /// for the otherwise branch, so targets.len() == values.len() + 1\n         /// should hold.\n+        //\n         // This invariant is quite non-obvious and also could be improved.\n         // One way to make this invariant is to have something like this instead:\n         //\n@@ -1077,7 +1072,7 @@ pub enum TerminatorKind<'tcx> {\n     },\n \n     /// Indicates that the landing pad is finished and unwinding should\n-    /// continue. Emitted by build::scope::diverge_cleanup.\n+    /// continue. Emitted by `build::scope::diverge_cleanup`.\n     Resume,\n \n     /// Indicates that the landing pad is finished and that the process\n@@ -1091,10 +1086,10 @@ pub enum TerminatorKind<'tcx> {\n     /// Indicates a terminator that can never be reached.\n     Unreachable,\n \n-    /// Drop the Place\n+    /// Drop the `Place`.\n     Drop { location: Place<'tcx>, target: BasicBlock, unwind: Option<BasicBlock> },\n \n-    /// Drop the Place and assign the new value over it. This ensures\n+    /// Drop the `Place` and assign the new value over it. This ensures\n     /// that the assignment to `P` occurs *even if* the destructor for\n     /// place unwinds. Its semantics are best explained by the\n     /// elaboration:\n@@ -1127,9 +1122,9 @@ pub enum TerminatorKind<'tcx> {\n         unwind: Option<BasicBlock>,\n     },\n \n-    /// Block ends with a call of a converging function\n+    /// Block ends with a call of a converging function.\n     Call {\n-        /// The function that\u2019s being called\n+        /// The function that\u2019s being called.\n         func: Operand<'tcx>,\n         /// Arguments the function is called with.\n         /// These are owned by the callee, which is free to modify them.\n@@ -1140,7 +1135,7 @@ pub enum TerminatorKind<'tcx> {\n         destination: Option<(Place<'tcx>, BasicBlock)>,\n         /// Cleanups to be done if the call unwinds.\n         cleanup: Option<BasicBlock>,\n-        /// Whether this is from a call in HIR, rather than from an overloaded\n+        /// `true` if this is from a call in HIR rather than from an overloaded\n         /// operator. True for overloaded function call.\n         from_hir_call: bool,\n     },\n@@ -1155,40 +1150,40 @@ pub enum TerminatorKind<'tcx> {\n         cleanup: Option<BasicBlock>,\n     },\n \n-    /// A suspend point\n+    /// A suspend point.\n     Yield {\n-        /// The value to return\n+        /// The value to return.\n         value: Operand<'tcx>,\n-        /// Where to resume to\n+        /// Where to resume to.\n         resume: BasicBlock,\n-        /// Cleanup to be done if the generator is dropped at this suspend point\n+        /// Cleanup to be done if the generator is dropped at this suspend point.\n         drop: Option<BasicBlock>,\n     },\n \n-    /// Indicates the end of the dropping of a generator\n+    /// Indicates the end of the dropping of a generator.\n     GeneratorDrop,\n \n     /// A block where control flow only ever takes one real path, but borrowck\n     /// needs to be more conservative.\n     FalseEdges {\n-        /// The target normal control flow will take\n+        /// The target normal control flow will take.\n         real_target: BasicBlock,\n         /// A block control flow could conceptually jump to, but won't in\n-        /// practice\n+        /// practice.\n         imaginary_target: BasicBlock,\n     },\n     /// A terminator for blocks that only take one path in reality, but where we\n     /// reserve the right to unwind in borrowck, even if it won't happen in practice.\n     /// This can arise in infinite loops with no function calls for example.\n     FalseUnwind {\n-        /// The target normal control flow will take\n+        /// The target normal control flow will take.\n         real_target: BasicBlock,\n         /// The imaginary cleanup block link. This particular path will never be taken\n         /// in practice, but in order to avoid fragility we want to always\n         /// consider it in borrowck. We don't want to accept programs which\n-        /// pass borrowck only when panic=abort or some assertions are disabled\n-        /// due to release vs. debug mode builds. This needs to be an Option because\n-        /// of the remove_noop_landing_pads and no_landing_pads passes\n+        /// pass borrowck only when `panic=abort` or some assertions are disabled\n+        /// due to release vs. debug mode builds. This needs to be an `Option` because\n+        /// of the `remove_noop_landing_pads` and `no_landing_pads` passes.\n         unwind: Option<BasicBlock>,\n     },\n }\n@@ -1453,7 +1448,7 @@ impl<'tcx> Debug for TerminatorKind<'tcx> {\n }\n \n impl<'tcx> TerminatorKind<'tcx> {\n-    /// Write the \"head\" part of the terminator; that is, its name and the data it uses to pick the\n+    /// Writes the \"head\" part of the terminator; that is, its name and the data it uses to pick the\n     /// successor basic block, if any. The only information not included is the list of possible\n     /// successors, which may be rendered differently between the text and the graphviz format.\n     pub fn fmt_head<W: Write>(&self, fmt: &mut W) -> fmt::Result {\n@@ -1555,7 +1550,7 @@ pub struct Statement<'tcx> {\n #[cfg(target_arch = \"x86_64\")]\n static_assert_size!(Statement<'_>, 56);\n \n-impl<'tcx> Statement<'tcx> {\n+impl Statement<'_> {\n     /// Changes a statement to a nop. This is both faster than deleting instructions and avoids\n     /// invalidating statement indices in `Location`s.\n     pub fn make_nop(&mut self) {\n@@ -1623,20 +1618,20 @@ pub enum StatementKind<'tcx> {\n     Nop,\n }\n \n-/// `RetagKind` describes what kind of retag is to be performed.\n+/// Describes what kind of retag is to be performed.\n #[derive(Copy, Clone, RustcEncodable, RustcDecodable, Debug, PartialEq, Eq, HashStable)]\n pub enum RetagKind {\n-    /// The initial retag when entering a function\n+    /// The initial retag when entering a function.\n     FnEntry,\n-    /// Retag preparing for a two-phase borrow\n+    /// Retag preparing for a two-phase borrow.\n     TwoPhase,\n-    /// Retagging raw pointers\n+    /// Retagging raw pointers.\n     Raw,\n-    /// A \"normal\" retag\n+    /// A \"normal\" retag.\n     Default,\n }\n \n-/// The `FakeReadCause` describes the type of pattern why a `FakeRead` statement exists.\n+/// The `FakeReadCause` describes the type of pattern why a FakeRead statement exists.\n #[derive(Copy, Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum FakeReadCause {\n     /// Inject a fake read of the borrowed input at the end of each guards\n@@ -1677,7 +1672,7 @@ pub struct InlineAsm<'tcx> {\n     pub inputs: Box<[(Span, Operand<'tcx>)]>,\n }\n \n-impl<'tcx> Debug for Statement<'tcx> {\n+impl Debug for Statement<'_> {\n     fn fmt(&self, fmt: &mut Formatter<'_>) -> fmt::Result {\n         use self::StatementKind::*;\n         match self.kind {\n@@ -1737,23 +1732,32 @@ pub enum PlaceBase<'tcx> {\n }\n \n /// We store the normalized type to avoid requiring normalization when reading MIR\n-#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n pub struct Static<'tcx> {\n     pub ty: Ty<'tcx>,\n-    pub kind: StaticKind,\n+    pub kind: StaticKind<'tcx>,\n+    /// The `DefId` of the item this static was declared in. For promoted values, usually, this is\n+    /// the same as the `DefId` of the `mir::Body` containing the `Place` this promoted appears in.\n+    /// However, after inlining, that might no longer be the case as inlined `Place`s are copied\n+    /// into the calling frame.\n+    pub def_id: DefId,\n }\n \n #[derive(\n-    Clone, PartialEq, Eq, PartialOrd, Ord, Hash, HashStable, RustcEncodable, RustcDecodable,\n+    Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, HashStable, RustcEncodable, RustcDecodable,\n )]\n-pub enum StaticKind {\n-    Promoted(Promoted),\n-    Static(DefId),\n+pub enum StaticKind<'tcx> {\n+    /// Promoted references consist of an id (`Promoted`) and the substs necessary to monomorphize\n+    /// it. Usually, these substs are just the identity substs for the item. However, the inliner\n+    /// will adjust these substs when it inlines a function based on the substs at the callsite.\n+    Promoted(Promoted, SubstsRef<'tcx>),\n+    Static,\n }\n \n impl_stable_hash_for!(struct Static<'tcx> {\n     ty,\n-    kind\n+    kind,\n+    def_id\n });\n \n /// The `Projection` data structure defines things of the form `base.x`, `*b` or `b[index]`.\n@@ -1807,6 +1811,23 @@ pub enum ProjectionElem<V, T> {\n     Downcast(Option<Symbol>, VariantIdx),\n }\n \n+impl<V, T> ProjectionElem<V, T> {\n+    /// Returns `true` if the target of this projection may refer to a different region of memory\n+    /// than the base.\n+    fn is_indirect(&self) -> bool {\n+        match self {\n+            Self::Deref => true,\n+\n+            | Self::Field(_, _)\n+            | Self::Index(_)\n+            | Self::ConstantIndex { .. }\n+            | Self::Subslice { .. }\n+            | Self::Downcast(_, _)\n+            => false\n+        }\n+    }\n+}\n+\n /// Alias for projections as they appear in places, where the base is a place\n /// and the index is a local.\n pub type PlaceElem<'tcx> = ProjectionElem<Local, Ty<'tcx>>;\n@@ -1868,6 +1889,14 @@ impl<'tcx> Place<'tcx> {\n         }\n     }\n \n+    /// Returns `true` if this `Place` contains a `Deref` projection.\n+    ///\n+    /// If `Place::is_indirect` returns false, the caller knows that the `Place` refers to the\n+    /// same region of memory as its base.\n+    pub fn is_indirect(&self) -> bool {\n+        self.iterate(|_, mut projections| projections.any(|proj| proj.elem.is_indirect()))\n+    }\n+\n     /// Finds the innermost `Local` from this `Place`, *if* it is either a local itself or\n     /// a single deref of a local.\n     //\n@@ -2047,7 +2076,7 @@ impl<'p, 'tcx> Iterator for ProjectionsIter<'p, 'tcx> {\n \n impl<'p, 'tcx> FusedIterator for ProjectionsIter<'p, 'tcx> {}\n \n-impl<'tcx> Debug for Place<'tcx> {\n+impl Debug for Place<'_> {\n     fn fmt(&self, fmt: &mut Formatter<'_>) -> fmt::Result {\n         self.iterate(|_place_base, place_projections| {\n             // FIXME: remove this collect once we have migrated to slices\n@@ -2114,10 +2143,12 @@ impl Debug for PlaceBase<'_> {\n     fn fmt(&self, fmt: &mut Formatter<'_>) -> fmt::Result {\n         match *self {\n             PlaceBase::Local(id) => write!(fmt, \"{:?}\", id),\n-            PlaceBase::Static(box self::Static { ty, kind: StaticKind::Static(def_id) }) => {\n+            PlaceBase::Static(box self::Static { ty, kind: StaticKind::Static, def_id }) => {\n                 write!(fmt, \"({}: {:?})\", ty::tls::with(|tcx| tcx.def_path_str(def_id)), ty)\n             }\n-            PlaceBase::Static(box self::Static { ty, kind: StaticKind::Promoted(promoted) }) => {\n+            PlaceBase::Static(box self::Static {\n+                ty, kind: StaticKind::Promoted(promoted, _), def_id: _\n+            }) => {\n                 write!(fmt, \"({:?}: {:?})\", promoted, ty)\n             }\n         }\n@@ -2143,7 +2174,7 @@ pub struct SourceScopeData {\n \n #[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n pub struct SourceScopeLocalData {\n-    /// A HirId with lint levels equivalent to this scope's lint levels.\n+    /// An `HirId` with lint levels equivalent to this scope's lint levels.\n     pub lint_root: hir::HirId,\n     /// The unsafe block that contains this node.\n     pub safety: Safety,\n@@ -2732,11 +2763,12 @@ impl<'a, 'b> graph::GraphSuccessors<'b> for Body<'a> {\n \n #[derive(Copy, Clone, PartialEq, Eq, Hash, Ord, PartialOrd, HashStable)]\n pub struct Location {\n-    /// the location is within this block\n+    /// The block that the location is within.\n     pub block: BasicBlock,\n \n-    /// the location is the start of the statement; or, if `statement_index`\n-    /// == num-statements, then the start of the terminator.\n+    /// The location is the position of the start of the statement; or, if\n+    /// `statement_index` equals the number of statements, then the start of the\n+    /// terminator.\n     pub statement_index: usize,\n }\n \n@@ -2799,7 +2831,7 @@ impl Location {\n #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, HashStable)]\n pub enum UnsafetyViolationKind {\n     General,\n-    /// Permitted in const fn and regular fns.\n+    /// Permitted both in `const fn`s and regular `fn`s.\n     GeneralAndConstFn,\n     ExternStatic(hir::HirId),\n     BorrowPacked(hir::HirId),\n@@ -2815,9 +2847,9 @@ pub struct UnsafetyViolation {\n \n #[derive(Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, HashStable)]\n pub struct UnsafetyCheckResult {\n-    /// Violations that are propagated *upwards* from this function\n+    /// Violations that are propagated *upwards* from this function.\n     pub violations: Lrc<[UnsafetyViolation]>,\n-    /// unsafe blocks in this function, along with whether they are used. This is\n+    /// `unsafe` blocks in this function, along with whether they are used. This is\n     /// used for the \"unused_unsafe\" lint.\n     pub unsafe_blocks: Lrc<[(hir::HirId, bool)]>,\n }\n@@ -2829,7 +2861,7 @@ newtype_index! {\n     }\n }\n \n-/// The layout of generator state\n+/// The layout of generator state.\n #[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n pub struct GeneratorLayout<'tcx> {\n     /// The type of every local stored inside the generator.\n@@ -2844,11 +2876,14 @@ pub struct GeneratorLayout<'tcx> {\n     /// layout.\n     pub storage_conflicts: BitMatrix<GeneratorSavedLocal, GeneratorSavedLocal>,\n \n-    /// Names and scopes of all the stored generator locals.\n-    /// NOTE(tmandry) This is *strictly* a temporary hack for codegen\n+    /// The names and scopes of all the stored generator locals.\n+    ///\n+    /// N.B., this is *strictly* a temporary hack for codegen\n     /// debuginfo generation, and will be removed at some point.\n     /// Do **NOT** use it for anything else, local information should not be\n     /// in the MIR, please rely on local crate HIR or other side-channels.\n+    //\n+    // FIXME(tmandry): see above.\n     pub __local_debuginfo_codegen_only_do_not_use: IndexVec<GeneratorSavedLocal, LocalDecl<'tcx>>,\n }\n \n@@ -2906,7 +2941,7 @@ pub struct BorrowCheckResult<'tcx> {\n /// instances assigned one of these same indices. Those regions will\n /// be substituted away by the creator. We use `ReClosureBound` in\n /// that case because the regions must be allocated in the global\n-/// TyCtxt, and hence we cannot use `ReVar` (which is what we use\n+/// `TyCtxt`, and hence we cannot use `ReVar` (which is what we use\n /// internally within the rest of the NLL code).\n #[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n pub struct ClosureRegionRequirements<'tcx> {\n@@ -2922,8 +2957,8 @@ pub struct ClosureRegionRequirements<'tcx> {\n     pub outlives_requirements: Vec<ClosureOutlivesRequirement<'tcx>>,\n }\n \n-/// Indicates an outlives constraint between a type or between two\n-/// free-regions declared on the closure.\n+/// Indicates an outlives-constraint between a type or between two\n+/// free regions declared on the closure.\n #[derive(Copy, Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n pub struct ClosureOutlivesRequirement<'tcx> {\n     // This region or type ...\n@@ -2939,11 +2974,11 @@ pub struct ClosureOutlivesRequirement<'tcx> {\n     pub category: ConstraintCategory,\n }\n \n-/// Outlives constraints can be categorized to determine whether and why they\n+/// Outlives-constraints can be categorized to determine whether and why they\n /// are interesting (for error reporting). Order of variants indicates sort\n /// order of the category, thereby influencing diagnostic output.\n ///\n-/// See also [rustc_mir::borrow_check::nll::constraints]\n+/// See also [rustc_mir::borrow_check::nll::constraints].\n #[derive(\n     Copy,\n     Clone,\n@@ -2991,7 +3026,7 @@ pub enum ConstraintCategory {\n     Internal,\n }\n \n-/// The subject of a ClosureOutlivesRequirement -- that is, the thing\n+/// The subject of a `ClosureOutlivesRequirement` -- that is, the thing\n /// that must outlive some region.\n #[derive(Copy, Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n pub enum ClosureOutlivesSubject<'tcx> {\n@@ -3009,7 +3044,7 @@ pub enum ClosureOutlivesSubject<'tcx> {\n }\n \n /*\n- * TypeFoldable implementations for MIR types\n+ * `TypeFoldable` implementations for MIR types\n */\n \n CloneTypeFoldableAndLiftImpls! {\n@@ -3032,7 +3067,6 @@ BraceStructTypeFoldableImpl! {\n         basic_blocks,\n         source_scopes,\n         source_scope_local_data,\n-        promoted,\n         yield_ty,\n         generator_drop,\n         generator_layout,\n@@ -3226,13 +3260,63 @@ impl<'tcx> TypeFoldable<'tcx> for Terminator<'tcx> {\n impl<'tcx> TypeFoldable<'tcx> for Place<'tcx> {\n     fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n         Place {\n-            base: self.base.clone(),\n+            base: self.base.fold_with(folder),\n             projection: self.projection.fold_with(folder),\n         }\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.projection.visit_with(visitor)\n+        self.base.visit_with(visitor) || self.projection.visit_with(visitor)\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for PlaceBase<'tcx> {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+        match self {\n+            PlaceBase::Local(local) => PlaceBase::Local(local.fold_with(folder)),\n+            PlaceBase::Static(static_) => PlaceBase::Static(static_.fold_with(folder)),\n+        }\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        match self {\n+            PlaceBase::Local(local) => local.visit_with(visitor),\n+            PlaceBase::Static(static_) => (**static_).visit_with(visitor),\n+        }\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for Static<'tcx> {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+        Static {\n+            ty: self.ty.fold_with(folder),\n+            kind: self.kind.fold_with(folder),\n+            def_id: self.def_id,\n+        }\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        let Static { ty, kind, def_id: _ } = self;\n+\n+        ty.visit_with(visitor) || kind.visit_with(visitor)\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for StaticKind<'tcx> {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+        match self {\n+            StaticKind::Promoted(promoted, substs) =>\n+                StaticKind::Promoted(promoted.fold_with(folder), substs.fold_with(folder)),\n+            StaticKind::Static => StaticKind::Static\n+        }\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        match self {\n+            StaticKind::Promoted(promoted, substs) =>\n+                promoted.visit_with(visitor) || substs.visit_with(visitor),\n+            StaticKind::Static => { false }\n+        }\n     }\n }\n "}, {"sha": "821367e9ea12c480645c9c0f3ad12bc93593355d", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -708,7 +708,7 @@ macro_rules! make_mir_visitor {\n                     PlaceBase::Local(local) => {\n                         self.visit_local(local, context, location);\n                     }\n-                    PlaceBase::Static(box Static { kind: _, ty }) => {\n+                    PlaceBase::Static(box Static { kind: _, ty, def_id: _ }) => {\n                         self.visit_ty(& $($mutability)? *ty, TyContext::Location(location));\n                     }\n                 }\n@@ -724,10 +724,6 @@ macro_rules! make_mir_visitor {\n                 }\n \n                 match & $($mutability)? proj.elem {\n-                    ProjectionElem::Deref => {\n-                    }\n-                    ProjectionElem::Subslice { from: _, to: _ } => {\n-                    }\n                     ProjectionElem::Field(_field, ty) => {\n                         self.visit_ty(ty, TyContext::Location(location));\n                     }\n@@ -738,11 +734,12 @@ macro_rules! make_mir_visitor {\n                             location\n                         );\n                     }\n+                    ProjectionElem::Deref |\n+                    ProjectionElem::Subslice { from: _, to: _ } |\n                     ProjectionElem::ConstantIndex { offset: _,\n                                                     min_length: _,\n-                                                    from_end: _ } => {\n-                    }\n-                    ProjectionElem::Downcast(_name, _variant_index) => {\n+                                                    from_end: _ } |\n+                    ProjectionElem::Downcast(_, _) => {\n                     }\n                 }\n             }"}, {"sha": "4ebc2e72490d4565f769cfb5ac2b86f56d6ad494", "filename": "src/librustc/query/mod.rs", "status": "modified", "additions": 34, "deletions": 4, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fquery%2Fmod.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -17,7 +17,6 @@ use crate::traits::query::{\n use std::borrow::Cow;\n use syntax_pos::symbol::InternedString;\n \n-\n // Each of these queries corresponds to a function pointer field in the\n // `Providers` struct for requesting a value of that type, and a method\n // on `tcx: TyCtxt` (and `tcx.at(span)`) for doing that request in a way\n@@ -110,7 +109,11 @@ rustc_queries! {\n             no_hash\n         }\n \n-        query mir_validated(_: DefId) -> &'tcx Steal<mir::Body<'tcx>> {\n+        query mir_validated(_: DefId) ->\n+            (\n+                &'tcx Steal<mir::Body<'tcx>>,\n+                &'tcx Steal<IndexVec<mir::Promoted, mir::Body<'tcx>>>\n+            ) {\n             no_hash\n         }\n \n@@ -125,7 +128,17 @@ rustc_queries! {\n             }\n         }\n \n-        query promoted_mir(key: DefId) -> &'tcx IndexVec<mir::Promoted, mir::Body<'tcx>> { }\n+        query promoted_mir(key: DefId) -> &'tcx IndexVec<mir::Promoted, mir::Body<'tcx>> {\n+            cache_on_disk_if { key.is_local() }\n+            load_cached(tcx, id) {\n+                let promoted: Option<\n+                    rustc_data_structures::indexed_vec::IndexVec<\n+                        crate::mir::Promoted,\n+                        crate::mir::Body<'tcx>\n+                    >> = tcx.queries.on_disk_cache.try_load_query_result(tcx, id);\n+                promoted.map(|p| &*tcx.arena.alloc(p))\n+            }\n+        }\n     }\n \n     TypeChecking {\n@@ -790,7 +803,7 @@ rustc_queries! {\n     }\n \n     BorrowChecking {\n-        // Lifetime resolution. See `middle::resolve_lifetimes`.\n+        /// Lifetime resolution. See `middle::resolve_lifetimes`.\n         query resolve_lifetimes(_: CrateNum) -> &'tcx ResolveLifetimes {\n             desc { \"resolving lifetimes\" }\n         }\n@@ -832,13 +845,30 @@ rustc_queries! {\n             -> &'tcx [(Symbol, Option<Symbol>)] {\n             desc { \"calculating the lib features defined in a crate\" }\n         }\n+        /// Returns the lang items defined in another crate by loading it from metadata.\n+        // FIXME: It is illegal to pass a `CrateNum` other than `LOCAL_CRATE` here, just get rid\n+        // of that argument?\n         query get_lang_items(_: CrateNum) -> &'tcx LanguageItems {\n             eval_always\n             desc { \"calculating the lang items map\" }\n         }\n+\n+        /// Returns all diagnostic items defined in all crates.\n+        query all_diagnostic_items(_: CrateNum) -> &'tcx FxHashMap<Symbol, DefId> {\n+            eval_always\n+            desc { \"calculating the diagnostic items map\" }\n+        }\n+\n+        /// Returns the lang items defined in another crate by loading it from metadata.\n         query defined_lang_items(_: CrateNum) -> &'tcx [(DefId, usize)] {\n             desc { \"calculating the lang items defined in a crate\" }\n         }\n+\n+        /// Returns the diagnostic items defined in a crate.\n+        query diagnostic_items(_: CrateNum) -> &'tcx FxHashMap<Symbol, DefId> {\n+            desc { \"calculating the diagnostic items map in a crate\" }\n+        }\n+\n         query missing_lang_items(_: CrateNum) -> &'tcx [LangItem] {\n             desc { \"calculating the missing lang items in a crate\" }\n         }"}, {"sha": "c74b2fee41d6c298428cd02935151e8485148706", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 91, "deletions": 86, "changes": 177, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -1,36 +1,36 @@\n //! Contains infrastructure for configuring the compiler, including parsing\n-//! command line options.\n-\n-use std::str::FromStr;\n+//! command-line options.\n \n+use crate::lint;\n+use crate::middle::cstore;\n use crate::session::{early_error, early_warn, Session};\n use crate::session::search_paths::SearchPath;\n \n+use rustc_data_structures::fx::FxHashSet;\n+\n use rustc_target::spec::{LinkerFlavor, MergeFunctions, PanicStrategy, RelroLevel};\n use rustc_target::spec::{Target, TargetTriple};\n-use crate::lint;\n-use crate::middle::cstore;\n \n use syntax;\n use syntax::ast::{self, IntTy, UintTy, MetaItemKind};\n use syntax::source_map::{FileName, FilePathMapping};\n use syntax::edition::{Edition, EDITION_NAME_LIST, DEFAULT_EDITION};\n+use syntax::parse::{ParseSess, new_parser_from_source_str};\n use syntax::parse::token;\n-use syntax::parse;\n use syntax::symbol::{sym, Symbol};\n use syntax::feature_gate::UnstableFeatures;\n-use errors::emitter::HumanReadableErrorType;\n \n+use errors::emitter::HumanReadableErrorType;\n use errors::{ColorConfig, FatalError, Handler};\n \n use getopts;\n-use std::collections::{BTreeMap, BTreeSet};\n-use std::collections::btree_map::Iter as BTreeMapIter;\n-use std::collections::btree_map::Keys as BTreeMapKeysIter;\n-use std::collections::btree_map::Values as BTreeMapValuesIter;\n \n-use rustc_data_structures::fx::FxHashSet;\n-use std::{fmt, str};\n+use std::collections::{BTreeMap, BTreeSet};\n+use std::collections::btree_map::{\n+    Iter as BTreeMapIter, Keys as BTreeMapKeysIter, Values as BTreeMapValuesIter,\n+};\n+use std::fmt;\n+use std::str::{self, FromStr};\n use std::hash::Hasher;\n use std::collections::hash_map::DefaultHasher;\n use std::iter::FromIterator;\n@@ -241,14 +241,14 @@ pub enum ErrorOutputType {\n }\n \n impl Default for ErrorOutputType {\n-    fn default() -> ErrorOutputType {\n-        ErrorOutputType::HumanReadable(HumanReadableErrorType::Default(ColorConfig::Auto))\n+    fn default() -> Self {\n+        Self::HumanReadable(HumanReadableErrorType::Default(ColorConfig::Auto))\n     }\n }\n \n-// Use tree-based collections to cheaply get a deterministic Hash implementation.\n-// DO NOT switch BTreeMap out for an unsorted container type! That would break\n-// dependency tracking for command-line arguments.\n+/// Use tree-based collections to cheaply get a deterministic `Hash` implementation.\n+/// *Do not* switch `BTreeMap` out for an unsorted container type! That would break\n+/// dependency tracking for command-line arguments.\n #[derive(Clone, Hash)]\n pub struct OutputTypes(BTreeMap<OutputType, Option<PathBuf>>);\n \n@@ -281,7 +281,7 @@ impl OutputTypes {\n         self.0.len()\n     }\n \n-    // True if any of the output types require codegen or linking.\n+    // Returns `true` if any of the output types require codegen or linking.\n     pub fn should_codegen(&self) -> bool {\n         self.0.keys().any(|k| match *k {\n             OutputType::Bitcode\n@@ -295,9 +295,9 @@ impl OutputTypes {\n     }\n }\n \n-// Use tree-based collections to cheaply get a deterministic Hash implementation.\n-// DO NOT switch BTreeMap or BTreeSet out for an unsorted container type! That\n-// would break dependency tracking for command-line arguments.\n+/// Use tree-based collections to cheaply get a deterministic `Hash` implementation.\n+/// *Do not* switch `BTreeMap` or `BTreeSet` out for an unsorted container type! That\n+/// would break dependency tracking for command-line arguments.\n #[derive(Clone, Hash)]\n pub struct Externs(BTreeMap<String, ExternEntry>);\n \n@@ -327,7 +327,7 @@ macro_rules! hash_option {\n     ($opt_name:ident, $opt_expr:expr, $sub_hashes:expr, [TRACKED]) => ({\n         if $sub_hashes.insert(stringify!($opt_name),\n                               $opt_expr as &dyn dep_tracking::DepTrackingHash).is_some() {\n-            bug!(\"Duplicate key in CLI DepTrackingHash: {}\", stringify!($opt_name))\n+            bug!(\"duplicate key in CLI DepTrackingHash: {}\", stringify!($opt_name))\n         }\n     });\n }\n@@ -362,7 +362,7 @@ macro_rules! top_level_options {\n     );\n }\n \n-// The top-level command-line options struct\n+// The top-level command-line options struct.\n //\n // For each option, one has to specify how it behaves with regard to the\n // dependency tracking system of incremental compilation. This is done via the\n@@ -376,16 +376,16 @@ macro_rules! top_level_options {\n // Incremental compilation is not influenced by this option.\n //\n // If you add a new option to this struct or one of the sub-structs like\n-// CodegenOptions, think about how it influences incremental compilation. If in\n+// `CodegenOptions`, think about how it influences incremental compilation. If in\n // doubt, specify [TRACKED], which is always \"correct\" but might lead to\n // unnecessary re-compilation.\n top_level_options!(\n     pub struct Options {\n         // The crate config requested for the session, which may be combined\n-        // with additional crate configurations during the compile process\n+        // with additional crate configurations during the compile process.\n         crate_types: Vec<CrateType> [TRACKED],\n         optimize: OptLevel [TRACKED],\n-        // Include the debug_assertions flag into dependency tracking, since it\n+        // Include the `debug_assertions` flag in dependency tracking, since it\n         // can influence whether overflow checks are done or not.\n         debug_assertions: bool [TRACKED],\n         debuginfo: DebugInfo [TRACKED],\n@@ -402,8 +402,8 @@ top_level_options!(\n         test: bool [TRACKED],\n         error_format: ErrorOutputType [UNTRACKED],\n \n-        // if Some, enable incremental compilation, using the given\n-        // directory to store intermediate results\n+        // If `Some`, enable incremental compilation, using the given\n+        // directory to store intermediate results.\n         incremental: Option<PathBuf> [UNTRACKED],\n \n         debugging_opts: DebuggingOptions [TRACKED],\n@@ -418,7 +418,7 @@ top_level_options!(\n         // written `extern crate name as std`. Defaults to `std`. Used by\n         // out-of-tree drivers.\n         alt_std_name: Option<String> [TRACKED],\n-        // Indicates how the compiler should treat unstable features\n+        // Indicates how the compiler should treat unstable features.\n         unstable_features: UnstableFeatures [TRACKED],\n \n         // Indicates whether this run of the compiler is actually rustdoc. This\n@@ -434,12 +434,12 @@ top_level_options!(\n         cli_forced_codegen_units: Option<usize> [UNTRACKED],\n         cli_forced_thinlto_off: bool [UNTRACKED],\n \n-        // Remap source path prefixes in all output (messages, object files, debug, etc)\n+        // Remap source path prefixes in all output (messages, object files, debug, etc.).\n         remap_path_prefix: Vec<(PathBuf, PathBuf)> [UNTRACKED],\n \n         edition: Edition [TRACKED],\n \n-        // Whether or not we're emitting JSON blobs about each artifact produced\n+        // `true` if we're emitting JSON blobs about each artifact produced\n         // by the compiler.\n         json_artifact_notifications: bool [TRACKED],\n     }\n@@ -468,7 +468,7 @@ pub enum BorrowckMode {\n }\n \n impl BorrowckMode {\n-    /// Should we run the MIR-based borrow check, but also fall back\n+    /// Returns whether we should run the MIR-based borrow check, but also fall back\n     /// on the AST borrow check if the MIR-based one errors.\n     pub fn migrate(self) -> bool {\n         match self {\n@@ -477,7 +477,7 @@ impl BorrowckMode {\n         }\n     }\n \n-    /// Should we emit the AST-based borrow checker errors?\n+    /// Returns whether we should emit the AST-based borrow checker errors.\n     pub fn use_ast(self) -> bool {\n         match self {\n             BorrowckMode::Mir => false,\n@@ -487,12 +487,13 @@ impl BorrowckMode {\n }\n \n pub enum Input {\n-    /// Loads source from file\n+    /// Load source code from a file.\n     File(PathBuf),\n+    /// Load source code from a string.\n     Str {\n-        /// String that is shown in place of a filename\n+        /// A string that is shown in place of a filename.\n         name: FileName,\n-        /// Anonymous source string\n+        /// An anonymous string containing the source code.\n         input: String,\n     },\n }\n@@ -651,7 +652,7 @@ impl Options {\n         FilePathMapping::new(self.remap_path_prefix.clone())\n     }\n \n-    /// Returns `true` if there will be an output file generated\n+    /// Returns `true` if there will be an output file generated.\n     pub fn will_create_output_file(&self) -> bool {\n         !self.debugging_opts.parse_only && // The file is just being parsed\n             !self.debugging_opts.ls // The file is just being queried\n@@ -709,16 +710,14 @@ impl Passes {\n     }\n }\n \n-/// Declare a macro that will define all CodegenOptions/DebuggingOptions fields and parsers all\n-/// at once. The goal of this macro is to define an interface that can be\n-/// programmatically used by the option parser in order to initialize the struct\n-/// without hardcoding field names all over the place.\n+/// Defines all `CodegenOptions`/`DebuggingOptions` fields and parsers all at once. The goal of this\n+/// macro is to define an interface that can be programmatically used by the option parser\n+/// to initialize the struct without hardcoding field names all over the place.\n ///\n-/// The goal is to invoke this macro once with the correct fields, and then this\n-/// macro generates all necessary code. The main gotcha of this macro is the\n-/// cgsetters module which is a bunch of generated code to parse an option into\n-/// its respective field in the struct. There are a few hand-written parsers for\n-/// parsing specific types of values in this module.\n+/// The goal is to invoke this macro once with the correct fields, and then this macro generates all\n+/// necessary code. The main gotcha of this macro is the `cgsetters` module which is a bunch of\n+/// generated code to parse an option into its respective field in the struct. There are a few\n+/// hand-written parsers for parsing specific types of values in this module.\n macro_rules! options {\n     ($struct_name:ident, $setter_name:ident, $defaultfn:ident,\n      $buildfn:ident, $prefix:expr, $outputname:expr,\n@@ -1292,6 +1291,8 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n         \"show macro backtraces even for non-local macros\"),\n     teach: bool = (false, parse_bool, [TRACKED],\n         \"show extended diagnostic help\"),\n+    terminal_width: Option<usize> = (None, parse_opt_uint, [UNTRACKED],\n+        \"set the current terminal width\"),\n     continue_parse_after_error: bool = (false, parse_bool, [TRACKED],\n         \"attempt to recover from parse errors (experimental)\"),\n     dep_tasks: bool = (false, parse_bool, [UNTRACKED],\n@@ -1537,7 +1538,7 @@ pub fn default_configuration(sess: &Session) -> ast::CrateConfig {\n     ret\n }\n \n-/// Converts the crate cfg! configuration from String to Symbol.\n+/// Converts the crate `cfg!` configuration from `String` to `Symbol`.\n /// `rustc_interface::interface::Config` accepts this in the compiler configuration,\n /// but the symbol interner is not yet set up then, so we must convert it later.\n pub fn to_crate_config(cfg: FxHashSet<(String, Option<String>)>) -> ast::CrateConfig {\n@@ -1548,9 +1549,9 @@ pub fn to_crate_config(cfg: FxHashSet<(String, Option<String>)>) -> ast::CrateCo\n \n pub fn build_configuration(sess: &Session, mut user_cfg: ast::CrateConfig) -> ast::CrateConfig {\n     // Combine the configuration requested by the session (command line) with\n-    // some default and generated configuration items\n+    // some default and generated configuration items.\n     let default_cfg = default_configuration(sess);\n-    // If the user wants a test runner, then add the test cfg\n+    // If the user wants a test runner, then add the test cfg.\n     if sess.opts.test {\n         user_cfg.insert((sym::test, None));\n     }\n@@ -1719,13 +1720,7 @@ pub fn rustc_short_optgroups() -> Vec<RustcOptGroup> {\n                              static, framework, or dylib (the default).\",\n             \"[KIND=]NAME\",\n         ),\n-        opt::multi_s(\n-            \"\",\n-            \"crate-type\",\n-            \"Comma separated list of types of crates\n-                                    for the compiler to emit\",\n-            \"[bin|lib|rlib|dylib|cdylib|staticlib|proc-macro]\",\n-        ),\n+        make_crate_type_option(),\n         opt::opt_s(\n             \"\",\n             \"crate-name\",\n@@ -1855,13 +1850,13 @@ pub fn rustc_optgroups() -> Vec<RustcOptGroup> {\n     opts\n }\n \n-// Convert strings provided as --cfg [cfgspec] into a crate_cfg\n+// Converts strings provided as `--cfg [cfgspec]` into a `crate_cfg`.\n pub fn parse_cfgspecs(cfgspecs: Vec<String>) -> FxHashSet<(String, Option<String>)> {\n     syntax::with_default_globals(move || {\n         let cfg = cfgspecs.into_iter().map(|s| {\n-            let sess = parse::ParseSess::new(FilePathMapping::empty());\n+            let sess = ParseSess::new(FilePathMapping::empty());\n             let filename = FileName::cfg_spec_source_code(&s);\n-            let mut parser = parse::new_parser_from_source_str(&sess, filename, s.to_string());\n+            let mut parser = new_parser_from_source_str(&sess, filename, s.to_string());\n \n             macro_rules! error {($reason: expr) => {\n                 early_error(ErrorOutputType::default(),\n@@ -1921,7 +1916,7 @@ pub fn get_cmd_lint_options(matches: &getopts::Matches,\n     (lint_opts, describe_lints, lint_cap)\n }\n \n-/// Parse the `--color` flag\n+/// Parses the `--color` flag.\n pub fn parse_color(matches: &getopts::Matches) -> ColorConfig {\n     match matches.opt_str(\"color\").as_ref().map(|s| &s[..]) {\n         Some(\"auto\") => ColorConfig::Auto,\n@@ -1933,7 +1928,7 @@ pub fn parse_color(matches: &getopts::Matches) -> ColorConfig {\n         Some(arg) => early_error(\n             ErrorOutputType::default(),\n             &format!(\n-                \"argument for --color must be auto, \\\n+                \"argument for `--color` must be auto, \\\n                  always or never (instead was `{}`)\",\n                 arg\n             ),\n@@ -1978,16 +1973,16 @@ pub fn parse_json(matches: &getopts::Matches) -> (HumanReadableErrorType, bool)\n     (json_rendered(json_color), json_artifact_notifications)\n }\n \n-/// Parse the `--error-format` flag\n+/// Parses the `--error-format` flag.\n pub fn parse_error_format(\n     matches: &getopts::Matches,\n     color: ColorConfig,\n     json_rendered: HumanReadableErrorType,\n ) -> ErrorOutputType {\n-    // We need the opts_present check because the driver will send us Matches\n+    // We need the `opts_present` check because the driver will send us Matches\n     // with only stable options if no unstable options are used. Since error-format\n-    // is unstable, it will not be present. We have to use opts_present not\n-    // opt_present because the latter will panic.\n+    // is unstable, it will not be present. We have to use `opts_present` not\n+    // `opt_present` because the latter will panic.\n     let error_format = if matches.opts_present(&[\"error-format\".to_owned()]) {\n         match matches.opt_str(\"error-format\").as_ref().map(|s| &s[..]) {\n             None |\n@@ -2002,7 +1997,7 @@ pub fn parse_error_format(\n             Some(arg) => early_error(\n                 ErrorOutputType::HumanReadable(HumanReadableErrorType::Default(color)),\n                 &format!(\n-                    \"argument for --error-format must be `human`, `json` or \\\n+                    \"argument for `--error-format` must be `human`, `json` or \\\n                      `short` (instead was `{}`)\",\n                     arg\n                 ),\n@@ -2041,7 +2036,7 @@ pub fn build_session_options_and_crate_config(\n             early_error(\n                 ErrorOutputType::default(),\n                 &format!(\n-                    \"argument for --edition must be one of: \\\n+                    \"argument for `--edition` must be one of: \\\n                      {}. (instead was `{}`)\",\n                     EDITION_NAME_LIST,\n                     arg\n@@ -2055,7 +2050,7 @@ pub fn build_session_options_and_crate_config(\n         early_error(\n                 ErrorOutputType::default(),\n                 &format!(\n-                    \"Edition {} is unstable and only \\\n+                    \"edition {} is unstable and only \\\n                      available for nightly builds of rustc.\",\n                     edition,\n                 )\n@@ -2079,14 +2074,14 @@ pub fn build_session_options_and_crate_config(\n         if let ErrorOutputType::Json { pretty: true, json_rendered } = error_format {\n             early_error(\n                 ErrorOutputType::Json { pretty: false, json_rendered },\n-                \"--error-format=pretty-json is unstable\",\n+                \"`--error-format=pretty-json` is unstable\",\n             );\n         }\n         if let ErrorOutputType::HumanReadable(HumanReadableErrorType::AnnotateSnippet(_)) =\n             error_format {\n             early_error(\n                 ErrorOutputType::Json { pretty: false, json_rendered },\n-                \"--error-format=human-annotate-rs is unstable\",\n+                \"`--error-format=human-annotate-rs` is unstable\",\n             );\n         }\n     }\n@@ -2120,7 +2115,7 @@ pub fn build_session_options_and_crate_config(\n     let mut codegen_units = cg.codegen_units;\n     let mut disable_thinlto = false;\n \n-    // Issue #30063: if user requests llvm-related output to one\n+    // Issue #30063: if user requests LLVM-related output to one\n     // particular path, disable codegen-units.\n     let incompatible: Vec<_> = output_types\n         .iter()\n@@ -2136,8 +2131,8 @@ pub fn build_session_options_and_crate_config(\n                         early_warn(\n                             error_format,\n                             &format!(\n-                                \"--emit={} with -o incompatible with \\\n-                                 -C codegen-units=N for N > 1\",\n+                                \"`--emit={}` with `-o` incompatible with \\\n+                                 `-C codegen-units=N` for N > 1\",\n                                 ot\n                             ),\n                         );\n@@ -2157,21 +2152,21 @@ pub fn build_session_options_and_crate_config(\n     if debugging_opts.threads == Some(0) {\n         early_error(\n             error_format,\n-            \"Value for threads must be a positive nonzero integer\",\n+            \"value for threads must be a positive non-zero integer\",\n         );\n     }\n \n     if debugging_opts.threads.unwrap_or(1) > 1 && debugging_opts.fuel.is_some() {\n         early_error(\n             error_format,\n-            \"Optimization fuel is incompatible with multiple threads\",\n+            \"optimization fuel is incompatible with multiple threads\",\n         );\n     }\n \n     if codegen_units == Some(0) {\n         early_error(\n             error_format,\n-            \"Value for codegen units must be a positive nonzero integer\",\n+            \"value for codegen units must be a positive non-zero integer\",\n         );\n     }\n \n@@ -2418,10 +2413,10 @@ pub fn build_session_options_and_crate_config(\n         )\n     }\n \n-    // We start out with a Vec<(Option<String>, bool)>>,\n-    // and later convert it into a BTreeSet<(Option<String>, bool)>\n+    // We start out with a `Vec<(Option<String>, bool)>>`,\n+    // and later convert it into a `BTreeSet<(Option<String>, bool)>`\n     // This allows to modify entries in-place to set their correct\n-    // 'public' value\n+    // 'public' value.\n     let mut externs: BTreeMap<String, ExternEntry> = BTreeMap::new();\n     for (arg, private) in matches.opt_strs(\"extern\").into_iter().map(|v| (v, false))\n         .chain(matches.opt_strs(\"extern-private\").into_iter().map(|v| (v, true))) {\n@@ -2506,6 +2501,16 @@ pub fn build_session_options_and_crate_config(\n     )\n }\n \n+pub fn make_crate_type_option() -> RustcOptGroup {\n+    opt::multi_s(\n+        \"\",\n+        \"crate-type\",\n+        \"Comma separated list of types of crates\n+                                for the compiler to emit\",\n+        \"[bin|lib|rlib|dylib|cdylib|staticlib|proc-macro]\",\n+    )\n+}\n+\n pub fn parse_crate_types_from_list(list_list: Vec<String>) -> Result<Vec<CrateType>, String> {\n     let mut crate_types: Vec<CrateType> = Vec::new();\n     for unparsed_crate_type in &list_list {\n@@ -2610,15 +2615,15 @@ impl fmt::Display for CrateType {\n /// The values of all command-line arguments that are relevant for dependency\n /// tracking are hashed into a single value that determines whether the\n /// incremental compilation cache can be re-used or not. This hashing is done\n-/// via the DepTrackingHash trait defined below, since the standard Hash\n-/// implementation might not be suitable (e.g., arguments are stored in a Vec,\n+/// via the `DepTrackingHash` trait defined below, since the standard `Hash`\n+/// implementation might not be suitable (e.g., arguments are stored in a `Vec`,\n /// the hash of which is order dependent, but we might not want the order of\n /// arguments to make a difference for the hash).\n ///\n-/// However, since the value provided by Hash::hash often *is* suitable,\n+/// However, since the value provided by `Hash::hash` often *is* suitable,\n /// especially for primitive types, there is the\n-/// impl_dep_tracking_hash_via_hash!() macro that allows to simply reuse the\n-/// Hash implementation for DepTrackingHash. It's important though that\n+/// `impl_dep_tracking_hash_via_hash!()` macro that allows to simply reuse the\n+/// `Hash` implementation for `DepTrackingHash`. It's important though that\n /// we have an opt-in scheme here, so one is hopefully forced to think about\n /// how the hash should be calculated when adding a new command-line argument.\n mod dep_tracking {\n@@ -2631,9 +2636,9 @@ mod dep_tracking {\n     use super::{CrateType, DebugInfo, ErrorOutputType, OptLevel, OutputTypes,\n                 Passes, Sanitizer, LtoCli, LinkerPluginLto, SwitchWithOptPath,\n                 SymbolManglingVersion};\n-    use syntax::feature_gate::UnstableFeatures;\n     use rustc_target::spec::{MergeFunctions, PanicStrategy, RelroLevel, TargetTriple};\n     use syntax::edition::Edition;\n+    use syntax::feature_gate::UnstableFeatures;\n \n     pub trait DepTrackingHash {\n         fn hash(&self, hasher: &mut DefaultHasher, error_format: ErrorOutputType);"}, {"sha": "8656ebb2e6d72ad36190e32a6c158d39312ec46e", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 37, "deletions": 30, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -79,24 +79,24 @@ pub struct Session {\n     /// if the value stored here has been affected by path remapping.\n     pub working_dir: (PathBuf, bool),\n \n-    // FIXME: lint_store and buffered_lints are not thread-safe,\n-    // but are only used in a single thread\n+    // FIXME: `lint_store` and `buffered_lints` are not thread-safe,\n+    // but are only used in a single thread.\n     pub lint_store: RwLock<lint::LintStore>,\n     pub buffered_lints: Lock<Option<lint::LintBuffer>>,\n \n-    /// Set of (DiagnosticId, Option<Span>, message) tuples tracking\n+    /// Set of `(DiagnosticId, Option<Span>, message)` tuples tracking\n     /// (sub)diagnostics that have been set once, but should not be set again,\n     /// in order to avoid redundantly verbose output (Issue #24690, #44953).\n     pub one_time_diagnostics: Lock<FxHashSet<(DiagnosticMessageId, Option<Span>, String)>>,\n     pub plugin_llvm_passes: OneThread<RefCell<Vec<String>>>,\n     pub plugin_attributes: Lock<Vec<(Symbol, AttributeType)>>,\n     pub crate_types: Once<Vec<config::CrateType>>,\n     pub dependency_formats: Once<dependency_format::Dependencies>,\n-    /// The crate_disambiguator is constructed out of all the `-C metadata`\n+    /// The `crate_disambiguator` is constructed out of all the `-C metadata`\n     /// arguments passed to the compiler. Its value together with the crate-name\n     /// forms a unique global identifier for the crate. It is used to allow\n     /// multiple crates with the same name to coexist. See the\n-    /// rustc_codegen_llvm::back::symbol_names module for more information.\n+    /// `rustc_codegen_llvm::back::symbol_names` module for more information.\n     pub crate_disambiguator: Once<CrateDisambiguator>,\n \n     features: Once<feature_gate::Features>,\n@@ -111,7 +111,7 @@ pub struct Session {\n     /// The maximum number of stackframes allowed in const eval.\n     pub const_eval_stack_frame_limit: usize,\n \n-    /// The metadata::creader module may inject an allocator/panic_runtime\n+    /// The `metadata::creader` module may inject an allocator/`panic_runtime`\n     /// dependency if it didn't already find one, and this tracks what was\n     /// injected.\n     pub allocator_kind: Once<Option<AllocatorKind>>,\n@@ -130,7 +130,7 @@ pub struct Session {\n     /// Used by `-Z profile-queries` in `util::common`.\n     pub profile_channel: Lock<Option<mpsc::Sender<ProfileQueriesMsg>>>,\n \n-    /// Used by -Z self-profile\n+    /// Used by `-Z self-profile`.\n     pub self_profiling: Option<Arc<SelfProfiler>>,\n \n     /// Some measurements that are being gathered during compilation.\n@@ -187,16 +187,16 @@ pub struct PerfStats {\n     pub normalize_projection_ty: AtomicUsize,\n }\n \n-/// Enum to support dispatch of one-time diagnostics (in Session.diag_once)\n+/// Enum to support dispatch of one-time diagnostics (in `Session.diag_once`).\n enum DiagnosticBuilderMethod {\n     Note,\n     SpanNote,\n     SpanSuggestion(String), // suggestion\n-                            // add more variants as needed to support one-time diagnostics\n+                            // Add more variants as needed to support one-time diagnostics.\n }\n \n-/// Diagnostic message ID\u2014used by `Session.one_time_diagnostics` to avoid\n-/// emitting the same message more than once\n+/// Diagnostic message ID, used by `Session.one_time_diagnostics` to avoid\n+/// emitting the same message more than once.\n #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n pub enum DiagnosticMessageId {\n     ErrorId(u16), // EXXXX error code as integer\n@@ -408,7 +408,7 @@ impl Session {\n             Some(next) => {\n                 self.next_node_id.set(ast::NodeId::from_usize(next));\n             }\n-            None => bug!(\"Input too large, ran out of node ids!\"),\n+            None => bug!(\"input too large; ran out of node-IDs!\"),\n         }\n \n         id\n@@ -440,11 +440,11 @@ impl Session {\n                     diag_builder.note(message);\n                 }\n                 DiagnosticBuilderMethod::SpanNote => {\n-                    let span = span_maybe.expect(\"span_note needs a span\");\n+                    let span = span_maybe.expect(\"`span_note` needs a span\");\n                     diag_builder.span_note(span, message);\n                 }\n                 DiagnosticBuilderMethod::SpanSuggestion(suggestion) => {\n-                    let span = span_maybe.expect(\"span_suggestion_* needs a span\");\n+                    let span = span_maybe.expect(\"`span_suggestion_*` needs a span\");\n                     diag_builder.span_suggestion(\n                         span,\n                         message,\n@@ -688,7 +688,7 @@ impl Session {\n \n     pub fn must_not_eliminate_frame_pointers(&self) -> bool {\n         // \"mcount\" function relies on stack pointer.\n-        // See https://sourceware.org/binutils/docs/gprof/Implementation.html\n+        // See <https://sourceware.org/binutils/docs/gprof/Implementation.html>.\n         if self.instrument_mcount() {\n             true\n         } else if let Some(x) = self.opts.cg.force_frame_pointers {\n@@ -699,7 +699,7 @@ impl Session {\n     }\n \n     /// Returns the symbol name for the registrar function,\n-    /// given the crate Svh and the function DefIndex.\n+    /// given the crate `Svh` and the function `DefIndex`.\n     pub fn generate_plugin_registrar_symbol(&self, disambiguator: CrateDisambiguator) -> String {\n         format!(\n             \"__rustc_plugin_registrar_{}__\",\n@@ -719,7 +719,7 @@ impl Session {\n             &self.sysroot,\n             self.opts.target_triple.triple(),\n             &self.opts.search_paths,\n-            // target_tlib_path==None means it's the same as host_tlib_path.\n+            // `target_tlib_path == None` means it's the same as `host_tlib_path`.\n             self.target_tlib_path.as_ref().unwrap_or(&self.host_tlib_path),\n             kind,\n         )\n@@ -779,12 +779,12 @@ impl Session {\n         if let IncrCompSession::Active { .. } = *incr_comp_session {\n         } else {\n             bug!(\n-                \"Trying to finalize IncrCompSession `{:?}`\",\n+                \"trying to finalize `IncrCompSession` `{:?}`\",\n                 *incr_comp_session\n-            )\n+            );\n         }\n \n-        // Note: This will also drop the lock file, thus unlocking the directory\n+        // Note: this will also drop the lock file, thus unlocking the directory.\n         *incr_comp_session = IncrCompSession::Finalized {\n             session_directory: new_directory_path,\n         };\n@@ -800,13 +800,15 @@ impl Session {\n             } => session_directory.clone(),\n             IncrCompSession::InvalidBecauseOfErrors { .. } => return,\n             _ => bug!(\n-                \"Trying to invalidate IncrCompSession `{:?}`\",\n+                \"trying to invalidate `IncrCompSession` `{:?}`\",\n                 *incr_comp_session\n             ),\n         };\n \n-        // Note: This will also drop the lock file, thus unlocking the directory\n-        *incr_comp_session = IncrCompSession::InvalidBecauseOfErrors { session_directory };\n+        // Note: this will also drop the lock file, thus unlocking the directory.\n+        *incr_comp_session = IncrCompSession::InvalidBecauseOfErrors {\n+            session_directory,\n+        };\n     }\n \n     pub fn incr_comp_session_dir(&self) -> cell::Ref<'_, PathBuf> {\n@@ -815,8 +817,8 @@ impl Session {\n             incr_comp_session,\n             |incr_comp_session| match *incr_comp_session {\n                 IncrCompSession::NotInitialized => bug!(\n-                    \"Trying to get session directory from IncrCompSession `{:?}`\",\n-                    *incr_comp_session\n+                    \"trying to get session directory from `IncrCompSession`: {:?}\",\n+                    *incr_comp_session,\n                 ),\n                 IncrCompSession::Active {\n                     ref session_directory,\n@@ -1055,13 +1057,15 @@ fn default_emitter(\n                         Some(source_map.clone()),\n                         short,\n                         sopts.debugging_opts.teach,\n+                        sopts.debugging_opts.terminal_width,\n                     ),\n                     Some(dst) => EmitterWriter::new(\n                         dst,\n                         Some(source_map.clone()),\n                         short,\n                         false, // no teach messages when writing to a buffer\n                         false, // no colors when writing to a buffer\n+                        None,  // no terminal width\n                     ),\n                 };\n                 Box::new(emitter.ui_testing(sopts.debugging_opts.ui_testing))\n@@ -1183,7 +1187,10 @@ fn build_session_(\n     );\n     let target_cfg = config::build_target_config(&sopts, &span_diagnostic);\n \n-    let p_s = parse::ParseSess::with_span_handler(span_diagnostic, source_map);\n+    let parse_sess = parse::ParseSess::with_span_handler(\n+        span_diagnostic,\n+        source_map,\n+    );\n     let sysroot = match &sopts.maybe_sysroot {\n         Some(sysroot) => sysroot.clone(),\n         None => filesearch::get_or_default_sysroot(),\n@@ -1212,7 +1219,7 @@ fn build_session_(\n     let print_fuel = AtomicU64::new(0);\n \n     let working_dir = env::current_dir().unwrap_or_else(|e|\n-        p_s.span_diagnostic\n+        parse_sess.span_diagnostic\n             .fatal(&format!(\"Current directory is invalid: {}\", e))\n             .raise()\n     );\n@@ -1230,7 +1237,7 @@ fn build_session_(\n         opts: sopts,\n         host_tlib_path,\n         target_tlib_path,\n-        parse_sess: p_s,\n+        parse_sess,\n         sysroot,\n         local_crate_source_file,\n         working_dir,\n@@ -1375,7 +1382,7 @@ pub fn early_error(output: config::ErrorOutputType, msg: &str) -> ! {\n     let emitter: Box<dyn Emitter + sync::Send> = match output {\n         config::ErrorOutputType::HumanReadable(kind) => {\n             let (short, color_config) = kind.unzip();\n-            Box::new(EmitterWriter::stderr(color_config, None, short, false))\n+            Box::new(EmitterWriter::stderr(color_config, None, short, false, None))\n         }\n         config::ErrorOutputType::Json { pretty, json_rendered } =>\n             Box::new(JsonEmitter::basic(pretty, json_rendered)),\n@@ -1389,7 +1396,7 @@ pub fn early_warn(output: config::ErrorOutputType, msg: &str) {\n     let emitter: Box<dyn Emitter + sync::Send> = match output {\n         config::ErrorOutputType::HumanReadable(kind) => {\n             let (short, color_config) = kind.unzip();\n-            Box::new(EmitterWriter::stderr(color_config, None, short, false))\n+            Box::new(EmitterWriter::stderr(color_config, None, short, false, None))\n         }\n         config::ErrorOutputType::Json { pretty, json_rendered } =>\n             Box::new(JsonEmitter::basic(pretty, json_rendered)),"}, {"sha": "03cc00d87e3cd3091843b68545bb2e32672efc5e", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 89, "deletions": 23, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -1,20 +1,21 @@\n use super::{\n+    ConstEvalFailure,\n+    EvaluationResult,\n     FulfillmentError,\n     FulfillmentErrorCode,\n     MismatchedProjectionTypes,\n+    ObjectSafetyViolation,\n     Obligation,\n     ObligationCause,\n     ObligationCauseCode,\n     OnUnimplementedDirective,\n     OnUnimplementedNote,\n     OutputTypeParameterMismatch,\n-    TraitNotObjectSafe,\n-    ConstEvalFailure,\n+    Overflow,\n     PredicateObligation,\n     SelectionContext,\n     SelectionError,\n-    ObjectSafetyViolation,\n-    Overflow,\n+    TraitNotObjectSafe,\n };\n \n use crate::hir;\n@@ -35,7 +36,7 @@ use crate::util::nodemap::{FxHashMap, FxHashSet};\n use errors::{Applicability, DiagnosticBuilder};\n use std::fmt;\n use syntax::ast;\n-use syntax::symbol::sym;\n+use syntax::symbol::{sym, kw};\n use syntax_pos::{DUMMY_SP, Span, ExpnKind};\n \n impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n@@ -657,19 +658,22 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                             span,\n                             E0277,\n                             \"{}\",\n-                            message.unwrap_or_else(||\n-                                format!(\"the trait bound `{}` is not satisfied{}\",\n-                                        trait_ref.to_predicate(), post_message)\n-                            ));\n+                            message.unwrap_or_else(|| format!(\n+                                \"the trait bound `{}` is not satisfied{}\",\n+                                trait_ref.to_predicate(),\n+                                post_message,\n+                            )));\n \n                         let explanation =\n                             if obligation.cause.code == ObligationCauseCode::MainFunctionType {\n                                 \"consider using `()`, or a `Result`\".to_owned()\n                             } else {\n-                                format!(\"{}the trait `{}` is not implemented for `{}`\",\n-                                        pre_message,\n-                                        trait_ref,\n-                                        trait_ref.self_ty())\n+                                format!(\n+                                    \"{}the trait `{}` is not implemented for `{}`\",\n+                                    pre_message,\n+                                    trait_ref,\n+                                    trait_ref.self_ty(),\n+                                )\n                             };\n \n                         if let Some(ref s) = label {\n@@ -686,6 +690,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                         }\n \n                         self.suggest_borrow_on_unsized_slice(&obligation.cause.code, &mut err);\n+                        self.suggest_fn_call(&obligation, &mut err, &trait_ref);\n                         self.suggest_remove_reference(&obligation, &mut err, &trait_ref);\n                         self.suggest_semicolon_removal(&obligation, &mut err, span, &trait_ref);\n \n@@ -953,6 +958,57 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         }\n     }\n \n+    fn suggest_fn_call(\n+        &self,\n+        obligation: &PredicateObligation<'tcx>,\n+        err: &mut DiagnosticBuilder<'tcx>,\n+        trait_ref: &ty::Binder<ty::TraitRef<'tcx>>,\n+    ) {\n+        let self_ty = trait_ref.self_ty();\n+        match self_ty.sty {\n+            ty::FnDef(def_id, _) => {\n+                // We tried to apply the bound to an `fn`. Check whether calling it would evaluate\n+                // to a type that *would* satisfy the trait binding. If it would, suggest calling\n+                // it: `bar(foo)` -> `bar(foo)`. This case is *very* likely to be hit if `foo` is\n+                // `async`.\n+                let output_ty = self_ty.fn_sig(self.tcx).output();\n+                let new_trait_ref = ty::TraitRef {\n+                    def_id: trait_ref.def_id(),\n+                    substs: self.tcx.mk_substs_trait(output_ty.skip_binder(), &[]),\n+                };\n+                let obligation = Obligation::new(\n+                    obligation.cause.clone(),\n+                    obligation.param_env,\n+                    new_trait_ref.to_predicate(),\n+                );\n+                match self.evaluate_obligation(&obligation) {\n+                    Ok(EvaluationResult::EvaluatedToOk) |\n+                    Ok(EvaluationResult::EvaluatedToOkModuloRegions) |\n+                    Ok(EvaluationResult::EvaluatedToAmbig) => {\n+                        if let Some(hir::Node::Item(hir::Item {\n+                            ident,\n+                            node: hir::ItemKind::Fn(.., body_id),\n+                            ..\n+                        })) = self.tcx.hir().get_if_local(def_id) {\n+                            let body = self.tcx.hir().body(*body_id);\n+                            err.help(&format!(\n+                                \"use parentheses to call the function: `{}({})`\",\n+                                ident,\n+                                body.params.iter()\n+                                    .map(|arg| match &arg.pat.node {\n+                                        hir::PatKind::Binding(_, _, ident, None)\n+                                        if ident.name != kw::SelfLower => ident.to_string(),\n+                                        _ => \"_\".to_string(),\n+                                    }).collect::<Vec<_>>().join(\", \")));\n+                        }\n+                    }\n+                    _ => {}\n+                }\n+            }\n+            _ => {}\n+        }\n+    }\n+\n     /// Whenever references are used by mistake, like `for (i, e) in &vec.iter().enumerate()`,\n     /// suggest removing these references until we reach a type that implements the trait.\n     fn suggest_remove_reference(\n@@ -1044,7 +1100,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 node: hir::ExprKind::Closure(_, ref _decl, id, span, _),\n                 ..\n             }) => {\n-                (self.tcx.sess.source_map().def_span(span), self.tcx.hir().body(id).arguments.iter()\n+                (self.tcx.sess.source_map().def_span(span),\n+                 self.tcx.hir().body(id).params.iter()\n                     .map(|arg| {\n                         if let hir::Pat {\n                             node: hir::PatKind::Tuple(ref args, _),\n@@ -1327,7 +1384,10 @@ impl<'tcx> TyCtxt<'tcx> {\n         let mut reported_violations = FxHashSet::default();\n         for violation in violations {\n             if reported_violations.insert(violation.clone()) {\n-                err.note(&violation.error_msg());\n+                match violation.span() {\n+                    Some(span) => err.span_label(span, violation.error_msg()),\n+                    None => err.note(&violation.error_msg()),\n+                };\n             }\n         }\n         Some(err)\n@@ -1534,25 +1594,31 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 err.note(\"only the last element of a tuple may have a dynamically sized type\");\n             }\n             ObligationCauseCode::ProjectionWf(data) => {\n-                err.note(&format!(\"required so that the projection `{}` is well-formed\",\n-                                  data));\n+                err.note(&format!(\n+                    \"required so that the projection `{}` is well-formed\",\n+                    data,\n+                ));\n             }\n             ObligationCauseCode::ReferenceOutlivesReferent(ref_ty) => {\n-                err.note(&format!(\"required so that reference `{}` does not outlive its referent\",\n-                                  ref_ty));\n+                err.note(&format!(\n+                    \"required so that reference `{}` does not outlive its referent\",\n+                    ref_ty,\n+                ));\n             }\n             ObligationCauseCode::ObjectTypeBound(object_ty, region) => {\n-                err.note(&format!(\"required so that the lifetime bound of `{}` for `{}` \\\n-                                   is satisfied\",\n-                                  region, object_ty));\n+                err.note(&format!(\n+                    \"required so that the lifetime bound of `{}` for `{}` is satisfied\",\n+                    region,\n+                    object_ty,\n+                ));\n             }\n             ObligationCauseCode::ItemObligation(item_def_id) => {\n                 let item_name = tcx.def_path_str(item_def_id);\n                 let msg = format!(\"required by `{}`\", item_name);\n \n                 if let Some(sp) = tcx.hir().span_if_local(item_def_id) {\n                     let sp = tcx.sess.source_map().def_span(sp);\n-                    err.span_note(sp, &msg);\n+                    err.span_label(sp, &msg);\n                 } else {\n                     err.note(&msg);\n                 }"}, {"sha": "a7990c4af69fd50fd0bfa7862689d4d243982b7a", "filename": "src/librustc/traits/object_safety.rs", "status": "modified", "additions": 59, "deletions": 42, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fobject_safety.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -20,7 +20,7 @@ use std::borrow::Cow;\n use std::iter::{self};\n use syntax::ast::{self};\n use syntax::symbol::InternedString;\n-use syntax_pos::Span;\n+use syntax_pos::{Span, DUMMY_SP};\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n pub enum ObjectSafetyViolation {\n@@ -32,10 +32,10 @@ pub enum ObjectSafetyViolation {\n     SupertraitSelf,\n \n     /// Method has something illegal.\n-    Method(ast::Name, MethodViolationCode),\n+    Method(ast::Name, MethodViolationCode, Span),\n \n     /// Associated const.\n-    AssocConst(ast::Name),\n+    AssocConst(ast::Name, Span),\n }\n \n impl ObjectSafetyViolation {\n@@ -46,22 +46,35 @@ impl ObjectSafetyViolation {\n             ObjectSafetyViolation::SupertraitSelf =>\n                 \"the trait cannot use `Self` as a type parameter \\\n                  in the supertraits or where-clauses\".into(),\n-            ObjectSafetyViolation::Method(name, MethodViolationCode::StaticMethod) =>\n-                format!(\"method `{}` has no receiver\", name).into(),\n-            ObjectSafetyViolation::Method(name, MethodViolationCode::ReferencesSelf) =>\n-                format!(\"method `{}` references the `Self` type \\\n-                         in its arguments or return type\", name).into(),\n-            ObjectSafetyViolation::Method(name,\n-                                            MethodViolationCode::WhereClauseReferencesSelf(_)) =>\n-                format!(\"method `{}` references the `Self` type in where clauses\", name).into(),\n-            ObjectSafetyViolation::Method(name, MethodViolationCode::Generic) =>\n+            ObjectSafetyViolation::Method(name, MethodViolationCode::StaticMethod, _) =>\n+                format!(\"associated function `{}` has no `self` parameter\", name).into(),\n+            ObjectSafetyViolation::Method(name, MethodViolationCode::ReferencesSelf, _) => format!(\n+                \"method `{}` references the `Self` type in its parameters or return type\",\n+                name,\n+            ).into(),\n+            ObjectSafetyViolation::Method(\n+                name,\n+                MethodViolationCode::WhereClauseReferencesSelf,\n+                _,\n+            ) => format!(\"method `{}` references the `Self` type in where clauses\", name).into(),\n+            ObjectSafetyViolation::Method(name, MethodViolationCode::Generic, _) =>\n                 format!(\"method `{}` has generic type parameters\", name).into(),\n-            ObjectSafetyViolation::Method(name, MethodViolationCode::UndispatchableReceiver) =>\n-                format!(\"method `{}`'s receiver cannot be dispatched on\", name).into(),\n-            ObjectSafetyViolation::AssocConst(name) =>\n+            ObjectSafetyViolation::Method(name, MethodViolationCode::UndispatchableReceiver, _) =>\n+                format!(\"method `{}`'s `self` parameter cannot be dispatched on\", name).into(),\n+            ObjectSafetyViolation::AssocConst(name, _) =>\n                 format!(\"the trait cannot contain associated consts like `{}`\", name).into(),\n         }\n     }\n+\n+    pub fn span(&self) -> Option<Span> {\n+        // When `span` comes from a separate crate, it'll be `DUMMY_SP`. Treat it as `None` so\n+        // diagnostics use a `note` instead of a `span_label`.\n+        match *self {\n+            ObjectSafetyViolation::AssocConst(_, span) |\n+            ObjectSafetyViolation::Method(_, _, span) if span != DUMMY_SP => Some(span),\n+            _ => None,\n+        }\n+    }\n }\n \n /// Reasons a method might not be object-safe.\n@@ -74,7 +87,7 @@ pub enum MethodViolationCode {\n     ReferencesSelf,\n \n     /// e.g., `fn foo(&self) where Self: Clone`\n-    WhereClauseReferencesSelf(Span),\n+    WhereClauseReferencesSelf,\n \n     /// e.g., `fn foo<A>()`\n     Generic,\n@@ -88,9 +101,10 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// astconv -- currently, `Self` in supertraits. This is needed\n     /// because `object_safety_violations` can't be used during\n     /// type collection.\n-    pub fn astconv_object_safety_violations(self, trait_def_id: DefId)\n-                                            -> Vec<ObjectSafetyViolation>\n-    {\n+    pub fn astconv_object_safety_violations(\n+        self,\n+        trait_def_id: DefId,\n+    ) -> Vec<ObjectSafetyViolation> {\n         debug_assert!(self.generics_of(trait_def_id).has_self);\n         let violations = traits::supertrait_def_ids(self, trait_def_id)\n             .filter(|&def_id| self.predicates_reference_self(def_id, true))\n@@ -116,19 +130,19 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n \n     /// We say a method is *vtable safe* if it can be invoked on a trait\n-    /// object.  Note that object-safe traits can have some\n-    /// non-vtable-safe methods, so long as they require `Self:Sized` or\n-    /// otherwise ensure that they cannot be used when `Self=Trait`.\n+    /// object. Note that object-safe traits can have some\n+    /// non-vtable-safe methods, so long as they require `Self: Sized` or\n+    /// otherwise ensure that they cannot be used when `Self = Trait`.\n     pub fn is_vtable_safe_method(self, trait_def_id: DefId, method: &ty::AssocItem) -> bool {\n         debug_assert!(self.generics_of(trait_def_id).has_self);\n         debug!(\"is_vtable_safe_method({:?}, {:?})\", trait_def_id, method);\n-        // Any method that has a `Self : Sized` requisite can't be called.\n+        // Any method that has a `Self: Sized` bound cannot be called.\n         if self.generics_require_sized_self(method.def_id) {\n             return false;\n         }\n \n         match self.virtual_call_violation_for_method(trait_def_id, method) {\n-            None | Some(MethodViolationCode::WhereClauseReferencesSelf(_)) => true,\n+            None | Some(MethodViolationCode::WhereClauseReferencesSelf) => true,\n             Some(_) => false,\n         }\n     }\n@@ -138,12 +152,15 @@ impl<'tcx> TyCtxt<'tcx> {\n         let mut violations: Vec<_> = self.associated_items(trait_def_id)\n             .filter(|item| item.kind == ty::AssocKind::Method)\n             .filter_map(|item|\n-                self.object_safety_violation_for_method(trait_def_id, &item)\n-                    .map(|code| ObjectSafetyViolation::Method(item.ident.name, code))\n+                self.object_safety_violation_for_method(trait_def_id, &item).map(|code| {\n+                    ObjectSafetyViolation::Method(item.ident.name, code, item.ident.span)\n+                })\n             ).filter(|violation| {\n-                if let ObjectSafetyViolation::Method(_,\n-                    MethodViolationCode::WhereClauseReferencesSelf(span)) = violation\n-                {\n+                if let ObjectSafetyViolation::Method(\n+                    _,\n+                    MethodViolationCode::WhereClauseReferencesSelf,\n+                    span,\n+                ) = violation {\n                     // Using `CRATE_NODE_ID` is wrong, but it's hard to get a more precise id.\n                     // It's also hard to get a use site span, so we use the method definition span.\n                     self.lint_node_note(\n@@ -169,7 +186,7 @@ impl<'tcx> TyCtxt<'tcx> {\n \n         violations.extend(self.associated_items(trait_def_id)\n             .filter(|item| item.kind == ty::AssocKind::Const)\n-            .map(|item| ObjectSafetyViolation::AssocConst(item.ident.name)));\n+            .map(|item| ObjectSafetyViolation::AssocConst(item.ident.name, item.ident.span)));\n \n         debug!(\"object_safety_violations_for_trait(trait_def_id={:?}) = {:?}\",\n                trait_def_id,\n@@ -325,24 +342,23 @@ impl<'tcx> TyCtxt<'tcx> {\n                 .visit_tys_shallow(|t| {\n                     self.contains_illegal_self_type_reference(trait_def_id, t)\n                 }) {\n-            let span = self.def_span(method.def_id);\n-            return Some(MethodViolationCode::WhereClauseReferencesSelf(span));\n+            return Some(MethodViolationCode::WhereClauseReferencesSelf);\n         }\n \n         let receiver_ty = self.liberate_late_bound_regions(\n             method.def_id,\n             &sig.map_bound(|sig| sig.inputs()[0]),\n         );\n \n-        // until `unsized_locals` is fully implemented, `self: Self` can't be dispatched on.\n+        // Until `unsized_locals` is fully implemented, `self: Self` can't be dispatched on.\n         // However, this is already considered object-safe. We allow it as a special case here.\n         // FIXME(mikeyhew) get rid of this `if` statement once `receiver_is_dispatchable` allows\n-        // `Receiver: Unsize<Receiver[Self => dyn Trait]>`\n+        // `Receiver: Unsize<Receiver[Self => dyn Trait]>`.\n         if receiver_ty != self.types.self_param {\n             if !self.receiver_is_dispatchable(method, receiver_ty) {\n                 return Some(MethodViolationCode::UndispatchableReceiver);\n             } else {\n-                // sanity check to make sure the receiver actually has the layout of a pointer\n+                // Do sanity check to make sure the receiver actually has the layout of a pointer.\n \n                 use crate::ty::layout::Abi;\n \n@@ -352,12 +368,12 @@ impl<'tcx> TyCtxt<'tcx> {\n                     match self.layout_of(param_env.and(ty)) {\n                         Ok(layout) => &layout.abi,\n                         Err(err) => bug!(\n-                            \"Error: {}\\n while computing layout for type {:?}\", err, ty\n+                            \"error: {}\\n while computing layout for type {:?}\", err, ty\n                         )\n                     }\n                 };\n \n-                // e.g., Rc<()>\n+                // e.g., `Rc<()>`\n                 let unit_receiver_ty = self.receiver_for_self_ty(\n                     receiver_ty, self.mk_unit(), method.def_id\n                 );\n@@ -368,7 +384,7 @@ impl<'tcx> TyCtxt<'tcx> {\n                         self.sess.delay_span_bug(\n                             self.def_span(method.def_id),\n                             &format!(\n-                                \"Receiver when Self = () should have a Scalar ABI, found {:?}\",\n+                                \"receiver when `Self = ()` should have a Scalar ABI; found {:?}\",\n                                 abi\n                             ),\n                         );\n@@ -379,7 +395,7 @@ impl<'tcx> TyCtxt<'tcx> {\n                     trait_def_id, self.mk_region(ty::ReStatic)\n                 );\n \n-                // e.g., Rc<dyn Trait>\n+                // e.g., `Rc<dyn Trait>`\n                 let trait_object_receiver = self.receiver_for_self_ty(\n                     receiver_ty, trait_object_ty, method.def_id\n                 );\n@@ -390,7 +406,8 @@ impl<'tcx> TyCtxt<'tcx> {\n                         self.sess.delay_span_bug(\n                             self.def_span(method.def_id),\n                             &format!(\n-                                \"Receiver when Self = {} should have a ScalarPair ABI, found {:?}\",\n+                                \"receiver when `Self = {}` should have a ScalarPair ABI; \\\n+                                 found {:?}\",\n                                 trait_object_ty, abi\n                             ),\n                         );\n@@ -402,8 +419,8 @@ impl<'tcx> TyCtxt<'tcx> {\n         None\n     }\n \n-    /// Performs a type substitution to produce the version of receiver_ty when `Self = self_ty`\n-    /// e.g., for receiver_ty = `Rc<Self>` and self_ty = `Foo`, returns `Rc<Foo>`.\n+    /// Performs a type substitution to produce the version of `receiver_ty` when `Self = self_ty`.\n+    /// For example, for `receiver_ty = Rc<Self>` and `self_ty = Foo`, returns `Rc<Foo>`.\n     fn receiver_for_self_ty(\n         self,\n         receiver_ty: Ty<'tcx>,"}, {"sha": "5a988d9509e800ee8cb903b36810b8c218c638a3", "filename": "src/librustc/traits/on_unimplemented.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -9,10 +9,9 @@ use syntax::ast::{MetaItem, NestedMetaItem};\n use syntax::attr;\n use syntax::symbol::{Symbol, kw, sym};\n use syntax_pos::Span;\n-use syntax_pos::symbol::LocalInternedString;\n \n #[derive(Clone, Debug)]\n-pub struct OnUnimplementedFormatString(LocalInternedString);\n+pub struct OnUnimplementedFormatString(Symbol);\n \n #[derive(Debug)]\n pub struct OnUnimplementedDirective {\n@@ -89,19 +88,19 @@ impl<'tcx> OnUnimplementedDirective {\n             if item.check_name(sym::message) && message.is_none() {\n                 if let Some(message_) = item.value_str() {\n                     message = Some(OnUnimplementedFormatString::try_parse(\n-                        tcx, trait_def_id, message_.as_str(), span)?);\n+                        tcx, trait_def_id, message_, span)?);\n                     continue;\n                 }\n             } else if item.check_name(sym::label) && label.is_none() {\n                 if let Some(label_) = item.value_str() {\n                     label = Some(OnUnimplementedFormatString::try_parse(\n-                        tcx, trait_def_id, label_.as_str(), span)?);\n+                        tcx, trait_def_id, label_, span)?);\n                     continue;\n                 }\n             } else if item.check_name(sym::note) && note.is_none() {\n                 if let Some(note_) = item.value_str() {\n                     note = Some(OnUnimplementedFormatString::try_parse(\n-                        tcx, trait_def_id, note_.as_str(), span)?);\n+                        tcx, trait_def_id, note_, span)?);\n                     continue;\n                 }\n             } else if item.check_name(sym::on) && is_root &&\n@@ -154,7 +153,7 @@ impl<'tcx> OnUnimplementedDirective {\n                 message: None,\n                 subcommands: vec![],\n                 label: Some(OnUnimplementedFormatString::try_parse(\n-                    tcx, trait_def_id, value.as_str(), attr.span)?),\n+                    tcx, trait_def_id, value, attr.span)?),\n                 note: None,\n             }))\n         } else {\n@@ -218,7 +217,7 @@ impl<'tcx> OnUnimplementedFormatString {\n     fn try_parse(\n         tcx: TyCtxt<'tcx>,\n         trait_def_id: DefId,\n-        from: LocalInternedString,\n+        from: Symbol,\n         err_sp: Span,\n     ) -> Result<Self, ErrorReported> {\n         let result = OnUnimplementedFormatString(from);\n@@ -234,7 +233,8 @@ impl<'tcx> OnUnimplementedFormatString {\n     ) -> Result<(), ErrorReported> {\n         let name = tcx.item_name(trait_def_id);\n         let generics = tcx.generics_of(trait_def_id);\n-        let parser = Parser::new(&self.0, None, vec![], false);\n+        let s = self.0.as_str();\n+        let parser = Parser::new(&s, None, vec![], false);\n         let mut result = Ok(());\n         for token in parser {\n             match token {\n@@ -294,7 +294,8 @@ impl<'tcx> OnUnimplementedFormatString {\n         }).collect::<FxHashMap<Symbol, String>>();\n         let empty_string = String::new();\n \n-        let parser = Parser::new(&self.0, None, vec![], false);\n+        let s = self.0.as_str();\n+        let parser = Parser::new(&s, None, vec![], false);\n         parser.map(|p|\n             match p {\n                 Piece::String(s) => s,"}, {"sha": "87a23f655a8f33560917b9db59563381a8c42fdf", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 1, "deletions": 35, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -15,7 +15,6 @@ use super::util;\n use crate::hir::def_id::DefId;\n use crate::infer::{InferCtxt, InferOk, LateBoundRegionConversionTime};\n use crate::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n-use crate::mir::interpret::{GlobalId, ConstValue};\n use rustc_data_structures::snapshot_map::{Snapshot, SnapshotMap};\n use rustc_macros::HashStable;\n use syntax::ast::Ident;\n@@ -397,40 +396,7 @@ impl<'a, 'b, 'tcx> TypeFolder<'tcx> for AssocTypeNormalizer<'a, 'b, 'tcx> {\n     }\n \n     fn fold_const(&mut self, constant: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n-        if let ConstValue::Unevaluated(def_id, substs) = constant.val {\n-            let tcx = self.selcx.tcx().global_tcx();\n-            let param_env = self.param_env;\n-            if !param_env.has_local_value() {\n-                if substs.needs_infer() || substs.has_placeholders() {\n-                    let identity_substs = InternalSubsts::identity_for_item(tcx, def_id);\n-                    let instance = ty::Instance::resolve(tcx, param_env, def_id, identity_substs);\n-                    if let Some(instance) = instance {\n-                        let cid = GlobalId {\n-                            instance,\n-                            promoted: None\n-                        };\n-                        if let Ok(evaluated) = tcx.const_eval(param_env.and(cid)) {\n-                            let evaluated = evaluated.subst(tcx, substs);\n-                            return evaluated;\n-                        }\n-                    }\n-                } else {\n-                    if !substs.has_local_value() {\n-                        let instance = ty::Instance::resolve(tcx, param_env, def_id, substs);\n-                        if let Some(instance) = instance {\n-                            let cid = GlobalId {\n-                                instance,\n-                                promoted: None\n-                            };\n-                            if let Ok(evaluated) = tcx.const_eval(param_env.and(cid)) {\n-                                return evaluated;\n-                            }\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-        constant\n+        constant.eval(self.selcx.tcx(), self.param_env)\n     }\n }\n "}, {"sha": "b9557ceaa6d9f87aaf53cd7b540e3723509f69a2", "filename": "src/librustc/traits/query/evaluate_obligation.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Ftraits%2Fquery%2Fevaluate_obligation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Ftraits%2Fquery%2Fevaluate_obligation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fevaluate_obligation.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -1,7 +1,8 @@\n use crate::infer::InferCtxt;\n use crate::infer::canonical::OriginalQueryValues;\n-use crate::traits::{EvaluationResult, PredicateObligation, SelectionContext,\n-             TraitQueryMode, OverflowError};\n+use crate::traits::{\n+    EvaluationResult, PredicateObligation, SelectionContext, TraitQueryMode, OverflowError,\n+};\n \n impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n     /// Evaluates whether the predicate can be satisfied (by any means)"}, {"sha": "039dea1ffcd1655d4346485a8129d9c57e0c38ad", "filename": "src/librustc/traits/query/method_autoderef.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Ftraits%2Fquery%2Fmethod_autoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Ftraits%2Fquery%2Fmethod_autoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fmethod_autoderef.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -6,11 +6,11 @@ use crate::ty::Ty;\n pub struct CandidateStep<'tcx> {\n     pub self_ty: Canonical<'tcx, QueryResponse<'tcx, Ty<'tcx>>>,\n     pub autoderefs: usize,\n-    // true if the type results from a dereference of a raw pointer.\n-    // when assembling candidates, we include these steps, but not when\n-    // picking methods. This so that if we have `foo: *const Foo` and `Foo` has methods\n-    // `fn by_raw_ptr(self: *const Self)` and `fn by_ref(&self)`, then\n-    // `foo.by_raw_ptr()` will work and `foo.by_ref()` won't.\n+    /// `true` if the type results from a dereference of a raw pointer.\n+    /// when assembling candidates, we include these steps, but not when\n+    /// picking methods. This so that if we have `foo: *const Foo` and `Foo` has methods\n+    /// `fn by_raw_ptr(self: *const Self)` and `fn by_ref(&self)`, then\n+    /// `foo.by_raw_ptr()` will work and `foo.by_ref()` won't.\n     pub from_unsafe_deref: bool,\n     pub unsize: bool,\n }"}, {"sha": "c31ff3ab1b55ddfba793327ca3665875abd26d4d", "filename": "src/librustc/traits/query/normalize.rs", "status": "modified", "additions": 2, "deletions": 36, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -5,11 +5,10 @@\n use crate::infer::at::At;\n use crate::infer::canonical::OriginalQueryValues;\n use crate::infer::{InferCtxt, InferOk};\n-use crate::mir::interpret::{GlobalId, ConstValue};\n use crate::traits::project::Normalized;\n use crate::traits::{Obligation, ObligationCause, PredicateObligation, Reveal};\n use crate::ty::fold::{TypeFoldable, TypeFolder};\n-use crate::ty::subst::{Subst, InternalSubsts};\n+use crate::ty::subst::Subst;\n use crate::ty::{self, Ty, TyCtxt};\n \n use super::NoSolution;\n@@ -191,40 +190,7 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for QueryNormalizer<'cx, 'tcx> {\n     }\n \n     fn fold_const(&mut self, constant: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n-        if let ConstValue::Unevaluated(def_id, substs) = constant.val {\n-            let tcx = self.infcx.tcx.global_tcx();\n-            let param_env = self.param_env;\n-            if !param_env.has_local_value() {\n-                if substs.needs_infer() || substs.has_placeholders() {\n-                    let identity_substs = InternalSubsts::identity_for_item(tcx, def_id);\n-                    let instance = ty::Instance::resolve(tcx, param_env, def_id, identity_substs);\n-                    if let Some(instance) = instance {\n-                        let cid = GlobalId {\n-                            instance,\n-                            promoted: None,\n-                        };\n-                        if let Ok(evaluated) = tcx.const_eval(param_env.and(cid)) {\n-                            let evaluated = evaluated.subst(tcx, substs);\n-                            return evaluated;\n-                        }\n-                    }\n-                } else {\n-                    if !substs.has_local_value() {\n-                        let instance = ty::Instance::resolve(tcx, param_env, def_id, substs);\n-                        if let Some(instance) = instance {\n-                            let cid = GlobalId {\n-                                instance,\n-                                promoted: None,\n-                            };\n-                            if let Ok(evaluated) = tcx.const_eval(param_env.and(cid)) {\n-                                return evaluated;\n-                            }\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-        constant\n+        constant.eval(self.infcx.tcx, self.param_env)\n     }\n }\n "}, {"sha": "217c887d5254eb66bcee93b126fb557500af9db7", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -3513,7 +3513,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n                 // We can only make objects from sized types.\n                 let tr = ty::TraitRef {\n-                    def_id: tcx.require_lang_item(lang_items::SizedTraitLangItem),\n+                    def_id: tcx.require_lang_item(lang_items::SizedTraitLangItem, None),\n                     substs: tcx.mk_substs_trait(source, &[]),\n                 };\n                 nested.push(predicate_to_obligation(tr.to_predicate()));"}, {"sha": "3d36790c94b8c4bbf9ac37929f2ec0f6841c1647", "filename": "src/librustc/traits/util.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Futil.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -512,7 +512,7 @@ pub fn impl_trait_ref_and_oblig<'a, 'tcx>(\n     (impl_trait_ref, impl_obligations)\n }\n \n-/// See `super::obligations_for_generics`\n+/// See [`super::obligations_for_generics`].\n pub fn predicates_for_generics<'tcx>(cause: ObligationCause<'tcx>,\n                                      recursion_depth: usize,\n                                      param_env: ty::ParamEnv<'tcx>,\n@@ -562,7 +562,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         predicate_for_trait_ref(cause, param_env, trait_ref, recursion_depth)\n     }\n \n-    /// Cast a trait reference into a reference to one of its super\n+    /// Casts a trait reference into a reference to one of its super\n     /// traits; returns `None` if `target_trait_def_id` is not a\n     /// supertrait.\n     pub fn upcast_choices(self,\n@@ -571,7 +571,7 @@ impl<'tcx> TyCtxt<'tcx> {\n                           -> Vec<ty::PolyTraitRef<'tcx>>\n     {\n         if source_trait_ref.def_id() == target_trait_def_id {\n-            return vec![source_trait_ref]; // shorcut the most common case\n+            return vec![source_trait_ref]; // Shortcut the most common case.\n         }\n \n         supertraits(self, source_trait_ref)"}, {"sha": "1aa21501129c8ab41718b6fc465f05c292ddc627", "filename": "src/librustc/ty/codec.rs", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Fty%2Fcodec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Fty%2Fcodec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcodec.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -284,9 +284,11 @@ where\n #[macro_export]\n macro_rules! __impl_decoder_methods {\n     ($($name:ident -> $ty:ty;)*) => {\n-        $(fn $name(&mut self) -> Result<$ty, Self::Error> {\n-            self.opaque.$name()\n-        })*\n+        $(\n+            fn $name(&mut self) -> Result<$ty, Self::Error> {\n+                self.opaque.$name()\n+            }\n+        )*\n     }\n }\n \n@@ -327,14 +329,17 @@ macro_rules! impl_arena_allocatable_decoders {\n macro_rules! implement_ty_decoder {\n     ($DecoderName:ident <$($typaram:tt),*>) => {\n         mod __ty_decoder_impl {\n-            use super::$DecoderName;\n+            use std::borrow::Cow;\n+\n+            use rustc_serialize::{Decoder, SpecializedDecoder};\n+\n             use $crate::infer::canonical::CanonicalVarInfos;\n             use $crate::ty;\n             use $crate::ty::codec::*;\n             use $crate::ty::subst::SubstsRef;\n             use $crate::hir::def_id::{CrateNum};\n-            use rustc_serialize::{Decoder, SpecializedDecoder};\n-            use std::borrow::Cow;\n+\n+            use super::$DecoderName;\n \n             impl<$($typaram ),*> Decoder for $DecoderName<$($typaram),*> {\n                 type Error = String;\n@@ -368,8 +373,8 @@ macro_rules! implement_ty_decoder {\n                 }\n             }\n \n-            // FIXME(#36588) These impls are horribly unsound as they allow\n-            // the caller to pick any lifetime for 'tcx, including 'static,\n+            // FIXME(#36588): These impls are horribly unsound as they allow\n+            // the caller to pick any lifetime for `'tcx`, including `'static`,\n             // by using the unspecialized proxies to them.\n \n             arena_types!(impl_arena_allocatable_decoders, [$DecoderName [$($typaram),*]], 'tcx);"}, {"sha": "8e8472a5aacc9b54966345befd0fc459e3455479", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 118, "deletions": 88, "changes": 206, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -7,7 +7,7 @@ use crate::session::Session;\n use crate::session::config::{BorrowckMode, OutputFilenames};\n use crate::session::config::CrateType;\n use crate::middle;\n-use crate::hir::{TraitCandidate, HirId, ItemKind, ItemLocalId, Node};\n+use crate::hir::{self, TraitCandidate, HirId, ItemKind, ItemLocalId, Node};\n use crate::hir::def::{Res, DefKind, Export};\n use crate::hir::def_id::{CrateNum, DefId, DefIndex, LOCAL_CRATE};\n use crate::hir::map as hir_map;\n@@ -21,7 +21,7 @@ use crate::middle::cstore::EncodedMetadata;\n use crate::middle::lang_items;\n use crate::middle::resolve_lifetime::{self, ObjectLifetimeDefault};\n use crate::middle::stability;\n-use crate::mir::{Body, interpret, ProjectionKind};\n+use crate::mir::{Body, interpret, ProjectionKind, Promoted};\n use crate::mir::interpret::{ConstValue, Allocation, Scalar};\n use crate::ty::subst::{Kind, InternalSubsts, SubstsRef, Subst};\n use crate::ty::ReprOptions;\n@@ -45,15 +45,16 @@ use crate::ty::CanonicalPolyFnSig;\n use crate::util::common::ErrorReported;\n use crate::util::nodemap::{DefIdMap, DefIdSet, ItemLocalMap, ItemLocalSet};\n use crate::util::nodemap::{FxHashMap, FxHashSet};\n+\n use errors::DiagnosticBuilder;\n-use smallvec::SmallVec;\n-use rustc_data_structures::stable_hasher::{HashStable, hash_stable_hashmap,\n-                                           StableHasher, StableHasherResult,\n-                                           StableVec};\n use arena::SyncDroplessArena;\n+use smallvec::SmallVec;\n+use rustc_data_structures::stable_hasher::{\n+    HashStable, StableHasher, StableHasherResult, StableVec, hash_stable_hashmap,\n+};\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n-use rustc_data_structures::sync::{Lrc, Lock, WorkerLocal};\n use rustc_data_structures::sharded::ShardedHashMap;\n+use rustc_data_structures::sync::{Lrc, Lock, WorkerLocal};\n use std::any::Any;\n use std::borrow::Borrow;\n use std::cmp::Ordering;\n@@ -74,8 +75,6 @@ use syntax::feature_gate;\n use syntax::symbol::{Symbol, InternedString, kw, sym};\n use syntax_pos::Span;\n \n-use crate::hir;\n-\n pub struct AllArenas {\n     pub interner: SyncDroplessArena,\n }\n@@ -91,10 +90,10 @@ impl AllArenas {\n type InternedSet<'tcx, T> = ShardedHashMap<Interned<'tcx, T>, ()>;\n \n pub struct CtxtInterners<'tcx> {\n-    /// The arena that types, regions, etc are allocated from\n+    /// The arena that types, regions, etc. are allocated from.\n     arena: &'tcx SyncDroplessArena,\n \n-    /// Specifically use a speedy hash algorithm for these hash sets,\n+    /// Specifically use a speedy hash algorithm for these hash sets, since\n     /// they're accessed quite often.\n     type_: InternedSet<'tcx, TyS<'tcx>>,\n     type_list: InternedSet<'tcx, List<Ty<'tcx>>>,\n@@ -129,7 +128,7 @@ impl<'tcx> CtxtInterners<'tcx> {\n         }\n     }\n \n-    /// Intern a type\n+    /// Interns a type.\n     #[allow(rustc::usage_of_ty_tykind)]\n     #[inline(never)]\n     fn intern_ty(&self,\n@@ -144,7 +143,6 @@ impl<'tcx> CtxtInterners<'tcx> {\n                 outer_exclusive_binder: flags.outer_exclusive_binder,\n             };\n \n-\n             Interned(self.arena.alloc(ty_struct))\n         }).0\n     }\n@@ -978,6 +976,7 @@ pub struct FreeRegionInfo {\n ///\n /// [rustc guide]: https://rust-lang.github.io/rustc-guide/ty.html\n #[derive(Copy, Clone)]\n+#[cfg_attr(not(bootstrap), rustc_diagnostic_item = \"TyCtxt\")]\n pub struct TyCtxt<'tcx> {\n     gcx: &'tcx GlobalCtxt<'tcx>,\n }\n@@ -1024,7 +1023,7 @@ pub struct GlobalCtxt<'tcx> {\n \n     hir_map: hir_map::Map<'tcx>,\n \n-    /// A map from DefPathHash -> DefId. Includes DefIds from the local crate\n+    /// A map from `DefPathHash` -> `DefId`. Includes `DefId`s from the local crate\n     /// as well as all upstream crates. Only populated in incremental mode.\n     pub def_path_hash_to_def_id: Option<FxHashMap<DefPathHash, DefId>>,\n \n@@ -1096,6 +1095,16 @@ impl<'tcx> TyCtxt<'tcx> {\n         self.arena.alloc(Steal::new(mir))\n     }\n \n+    pub fn alloc_steal_promoted(self, promoted: IndexVec<Promoted, Body<'tcx>>) ->\n+        &'tcx Steal<IndexVec<Promoted, Body<'tcx>>> {\n+        self.arena.alloc(Steal::new(promoted))\n+    }\n+\n+    pub fn intern_promoted(self, promoted: IndexVec<Promoted, Body<'tcx>>) ->\n+        &'tcx IndexVec<Promoted, Body<'tcx>> {\n+        self.arena.alloc(promoted)\n+    }\n+\n     pub fn alloc_adt_def(\n         self,\n         did: DefId,\n@@ -1113,9 +1122,9 @@ impl<'tcx> TyCtxt<'tcx> {\n         })\n     }\n \n-    /// Allocates a byte or string literal for `mir::interpret`, read-only\n+    /// Allocates a read-only byte or string literal for `mir::interpret`.\n     pub fn allocate_bytes(self, bytes: &[u8]) -> interpret::AllocId {\n-        // create an allocation that just contains these bytes\n+        // Create an allocation that just contains these bytes.\n         let alloc = interpret::Allocation::from_byte_aligned_bytes(bytes);\n         let alloc = self.intern_const_alloc(alloc);\n         self.alloc_map.lock().create_memory_alloc(alloc)\n@@ -1298,10 +1307,22 @@ impl<'tcx> TyCtxt<'tcx> {\n         self.get_lib_features(LOCAL_CRATE)\n     }\n \n+    /// Obtain all lang items of this crate and all dependencies (recursively)\n     pub fn lang_items(self) -> &'tcx middle::lang_items::LanguageItems {\n         self.get_lang_items(LOCAL_CRATE)\n     }\n \n+    /// Obtain the given diagnostic item's `DefId`. Use `is_diagnostic_item` if you just want to\n+    /// compare against another `DefId`, since `is_diagnostic_item` is cheaper.\n+    pub fn get_diagnostic_item(self, name: Symbol) -> Option<DefId> {\n+        self.all_diagnostic_items(LOCAL_CRATE).get(&name).copied()\n+    }\n+\n+    /// Check whether the diagnostic item with the given `name` has the given `DefId`.\n+    pub fn is_diagnostic_item(self, name: Symbol, did: DefId) -> bool {\n+        self.diagnostic_items(did.krate).get(&name) == Some(&did)\n+    }\n+\n     pub fn stability(self) -> &'tcx stability::Index<'tcx> {\n         self.stability_index(LOCAL_CRATE)\n     }\n@@ -1323,7 +1344,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n \n     /// Converts a `DefId` into its fully expanded `DefPath` (every\n-    /// `DefId` is really just an interned def-path).\n+    /// `DefId` is really just an interned `DefPath`).\n     ///\n     /// Note that if `id` is not local to this crate, the result will\n     ///  be a non-local `DefPath`.\n@@ -1379,6 +1400,10 @@ impl<'tcx> TyCtxt<'tcx> {\n         self.cstore.metadata_encoding_version().to_vec()\n     }\n \n+    pub fn encode_metadata(self)-> EncodedMetadata {\n+        self.cstore.encode_metadata(self)\n+    }\n+\n     // Note that this is *untracked* and should only be used within the query\n     // system if the result is otherwise tracked through queries\n     pub fn crate_data_as_rc_any(self, cnum: CrateNum) -> Lrc<dyn Any> {\n@@ -1423,25 +1448,25 @@ impl<'tcx> TyCtxt<'tcx> {\n         self.queries.on_disk_cache.serialize(self.global_tcx(), encoder)\n     }\n \n-    /// If true, we should use the AST-based borrowck (we may *also* use\n+    /// If `true`, we should use the AST-based borrowck (we may *also* use\n     /// the MIR-based borrowck).\n     pub fn use_ast_borrowck(self) -> bool {\n         self.borrowck_mode().use_ast()\n     }\n \n-    /// If true, we should use the MIR-based borrow check, but also\n-    /// fall back on the AST borrow check if the MIR-based one errors.\n+    /// If `true`, we should use the MIR-based borrowck, but also\n+    /// fall back on the AST borrowck if the MIR-based one errors.\n     pub fn migrate_borrowck(self) -> bool {\n         self.borrowck_mode().migrate()\n     }\n \n-    /// If true, make MIR codegen for `match` emit a temp that holds a\n+    /// If `true`, make MIR codegen for `match` emit a temp that holds a\n     /// borrow of the input to the match expression.\n     pub fn generate_borrow_of_any_match_input(&self) -> bool {\n         self.emit_read_for_match()\n     }\n \n-    /// If true, make MIR codegen for `match` emit FakeRead\n+    /// If `true`, make MIR codegen for `match` emit FakeRead\n     /// statements (which simulate the maximal effect of executing the\n     /// patterns in a match arm).\n     pub fn emit_read_for_match(&self) -> bool {\n@@ -1494,7 +1519,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         })\n     }\n \n-    // This method returns the DefId and the BoundRegion corresponding to the given region.\n+    // Returns the `DefId` and the `BoundRegion` corresponding to the given region.\n     pub fn is_suitable_region(&self, region: Region<'tcx>) -> Option<FreeRegionInfo> {\n         let (suitable_region_binding_scope, bound_region) = match *region {\n             ty::ReFree(ref free_region) => (free_region.scope, free_region.bound_region),\n@@ -1527,18 +1552,18 @@ impl<'tcx> TyCtxt<'tcx> {\n         &self,\n         scope_def_id: DefId,\n     ) -> Option<Ty<'tcx>> {\n-        // HACK: `type_of_def_id()` will fail on these (#55796), so return None\n+        // HACK: `type_of_def_id()` will fail on these (#55796), so return `None`.\n         let hir_id = self.hir().as_local_hir_id(scope_def_id).unwrap();\n         match self.hir().get(hir_id) {\n             Node::Item(item) => {\n                 match item.node {\n-                    ItemKind::Fn(..) => { /* type_of_def_id() will work */ }\n+                    ItemKind::Fn(..) => { /* `type_of_def_id()` will work */ }\n                     _ => {\n                         return None;\n                     }\n                 }\n             }\n-            _ => { /* type_of_def_id() will work or panic */ }\n+            _ => { /* `type_of_def_id()` will work or panic */ }\n         }\n \n         let ret_ty = self.type_of(scope_def_id);\n@@ -1556,7 +1581,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         }\n     }\n \n-    // Here we check if the bound region is in Impl Item.\n+    // Checks if the bound region is in Impl Item.\n     pub fn is_bound_region_in_impl_item(\n         &self,\n         suitable_region_binding_scope: DefId,\n@@ -1576,23 +1601,15 @@ impl<'tcx> TyCtxt<'tcx> {\n         false\n     }\n \n-    /// Determine whether identifiers in the assembly have strict naming rules.\n+    /// Determines whether identifiers in the assembly have strict naming rules.\n     /// Currently, only NVPTX* targets need it.\n     pub fn has_strict_asm_symbol_naming(&self) -> bool {\n-        self.gcx.sess.target.target.arch.contains(\"nvptx\")\n-    }\n-}\n-\n-impl<'tcx> TyCtxt<'tcx> {\n-    pub fn encode_metadata(self)\n-        -> EncodedMetadata\n-    {\n-        self.cstore.encode_metadata(self)\n+        self.sess.target.target.arch.contains(\"nvptx\")\n     }\n }\n \n impl<'tcx> GlobalCtxt<'tcx> {\n-    /// Call the closure with a local `TyCtxt` using the given arena.\n+    /// Calls the closure with a local `TyCtxt` using the given arena.\n     /// `interners` is a slot passed so we can create a CtxtInterners\n     /// with the same lifetime as `arena`.\n     pub fn enter_local<F, R>(&'tcx self, f: F) -> R\n@@ -1628,7 +1645,7 @@ impl<'tcx> GlobalCtxt<'tcx> {\n /// It would be more efficient if `TypedArena` provided a way to\n /// determine whether the address is in the allocated range.\n ///\n-/// None is returned if the value or one of the components is not part\n+/// `None` is returned if the value or one of the components is not part\n /// of the provided context.\n /// For `Ty`, `None` can be returned if either the type interner doesn't\n /// contain the `TyKind` key or if the address of the interned\n@@ -1639,7 +1656,6 @@ pub trait Lift<'tcx>: fmt::Debug {\n     fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted>;\n }\n \n-\n macro_rules! nop_lift {\n     ($ty:ty => $lifted:ty) => {\n         impl<'a, 'tcx> Lift<'tcx> for $ty {\n@@ -1686,7 +1702,7 @@ nop_list_lift!{Predicate<'a> => Predicate<'tcx>}\n nop_list_lift!{CanonicalVarInfo => CanonicalVarInfo}\n nop_list_lift!{ProjectionKind => ProjectionKind}\n \n-// this is the impl for `&'a InternalSubsts<'a>`\n+// This is the impl for `&'a InternalSubsts<'a>`.\n nop_list_lift!{Kind<'a> => Kind<'tcx>}\n \n pub mod tls {\n@@ -1709,43 +1725,43 @@ pub mod tls {\n     use rustc_rayon_core as rayon_core;\n \n     /// This is the implicit state of rustc. It contains the current\n-    /// TyCtxt and query. It is updated when creating a local interner or\n-    /// executing a new query. Whenever there's a TyCtxt value available\n-    /// you should also have access to an ImplicitCtxt through the functions\n+    /// `TyCtxt` and query. It is updated when creating a local interner or\n+    /// executing a new query. Whenever there's a `TyCtxt` value available\n+    /// you should also have access to an `ImplicitCtxt` through the functions\n     /// in this module.\n     #[derive(Clone)]\n     pub struct ImplicitCtxt<'a, 'tcx> {\n-        /// The current TyCtxt. Initially created by `enter_global` and updated\n-        /// by `enter_local` with a new local interner\n+        /// The current `TyCtxt`. Initially created by `enter_global` and updated\n+        /// by `enter_local` with a new local interner.\n         pub tcx: TyCtxt<'tcx>,\n \n-        /// The current query job, if any. This is updated by JobOwner::start in\n-        /// ty::query::plumbing when executing a query\n+        /// The current query job, if any. This is updated by `JobOwner::start` in\n+        /// `ty::query::plumbing` when executing a query.\n         pub query: Option<Lrc<query::QueryJob<'tcx>>>,\n \n         /// Where to store diagnostics for the current query job, if any.\n-        /// This is updated by JobOwner::start in ty::query::plumbing when executing a query\n+        /// This is updated by `JobOwner::start` in `ty::query::plumbing` when executing a query.\n         pub diagnostics: Option<&'a Lock<ThinVec<Diagnostic>>>,\n \n         /// Used to prevent layout from recursing too deeply.\n         pub layout_depth: usize,\n \n         /// The current dep graph task. This is used to add dependencies to queries\n-        /// when executing them\n+        /// when executing them.\n         pub task_deps: Option<&'a Lock<TaskDeps>>,\n     }\n \n-    /// Sets Rayon's thread local variable which is preserved for Rayon jobs\n+    /// Sets Rayon's thread-local variable, which is preserved for Rayon jobs\n     /// to `value` during the call to `f`. It is restored to its previous value after.\n-    /// This is used to set the pointer to the new ImplicitCtxt.\n+    /// This is used to set the pointer to the new `ImplicitCtxt`.\n     #[cfg(parallel_compiler)]\n     #[inline]\n     fn set_tlv<F: FnOnce() -> R, R>(value: usize, f: F) -> R {\n         rayon_core::tlv::with(value, f)\n     }\n \n-    /// Gets Rayon's thread local variable which is preserved for Rayon jobs.\n-    /// This is used to get the pointer to the current ImplicitCtxt.\n+    /// Gets Rayon's thread-local variable, which is preserved for Rayon jobs.\n+    /// This is used to get the pointer to the current `ImplicitCtxt`.\n     #[cfg(parallel_compiler)]\n     #[inline]\n     fn get_tlv() -> usize {\n@@ -1754,13 +1770,13 @@ pub mod tls {\n \n     #[cfg(not(parallel_compiler))]\n     thread_local! {\n-        /// A thread local variable which stores a pointer to the current ImplicitCtxt.\n+        /// A thread local variable that stores a pointer to the current `ImplicitCtxt`.\n         static TLV: Cell<usize> = Cell::new(0);\n     }\n \n     /// Sets TLV to `value` during the call to `f`.\n     /// It is restored to its previous value after.\n-    /// This is used to set the pointer to the new ImplicitCtxt.\n+    /// This is used to set the pointer to the new `ImplicitCtxt`.\n     #[cfg(not(parallel_compiler))]\n     #[inline]\n     fn set_tlv<F: FnOnce() -> R, R>(value: usize, f: F) -> R {\n@@ -1770,14 +1786,14 @@ pub mod tls {\n         f()\n     }\n \n-    /// This is used to get the pointer to the current ImplicitCtxt.\n+    /// Gets the pointer to the current `ImplicitCtxt`.\n     #[cfg(not(parallel_compiler))]\n     fn get_tlv() -> usize {\n         TLV.with(|tlv| tlv.get())\n     }\n \n     /// This is a callback from libsyntax as it cannot access the implicit state\n-    /// in librustc otherwise\n+    /// in librustc otherwise.\n     fn span_debug(span: syntax_pos::Span, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         with_opt(|tcx| {\n             if let Some(tcx) = tcx {\n@@ -1802,7 +1818,7 @@ pub mod tls {\n         })\n     }\n \n-    /// Sets up the callbacks from libsyntax on the current thread\n+    /// Sets up the callbacks from libsyntax on the current thread.\n     pub fn with_thread_locals<F, R>(f: F) -> R\n         where F: FnOnce() -> R\n     {\n@@ -1827,7 +1843,7 @@ pub mod tls {\n         })\n     }\n \n-    /// Sets `context` as the new current ImplicitCtxt for the duration of the function `f`\n+    /// Sets `context` as the new current `ImplicitCtxt` for the duration of the function `f`.\n     #[inline]\n     pub fn enter_context<'a, 'tcx, F, R>(context: &ImplicitCtxt<'a, 'tcx>, f: F) -> R\n     where\n@@ -1838,19 +1854,19 @@ pub mod tls {\n         })\n     }\n \n-    /// Enters GlobalCtxt by setting up libsyntax callbacks and\n-    /// creating a initial TyCtxt and ImplicitCtxt.\n-    /// This happens once per rustc session and TyCtxts only exists\n+    /// Enters `GlobalCtxt` by setting up libsyntax callbacks and\n+    /// creating a initial `TyCtxt` and `ImplicitCtxt`.\n+    /// This happens once per rustc session and `TyCtxt`s only exists\n     /// inside the `f` function.\n     pub fn enter_global<'tcx, F, R>(gcx: &'tcx GlobalCtxt<'tcx>, f: F) -> R\n     where\n         F: FnOnce(TyCtxt<'tcx>) -> R,\n     {\n-        // Update GCX_PTR to indicate there's a GlobalCtxt available\n+        // Update `GCX_PTR` to indicate there's a `GlobalCtxt` available.\n         GCX_PTR.with(|lock| {\n             *lock.lock() = gcx as *const _ as usize;\n         });\n-        // Set GCX_PTR back to 0 when we exit\n+        // Set `GCX_PTR` back to 0 when we exit.\n         let _on_drop = OnDrop(move || {\n             GCX_PTR.with(|lock| *lock.lock() = 0);\n         });\n@@ -1871,12 +1887,12 @@ pub mod tls {\n     }\n \n     scoped_thread_local! {\n-        /// Stores a pointer to the GlobalCtxt if one is available.\n-        /// This is used to access the GlobalCtxt in the deadlock handler given to Rayon.\n+        /// Stores a pointer to the `GlobalCtxt` if one is available.\n+        /// This is used to access the `GlobalCtxt` in the deadlock handler given to Rayon.\n         pub static GCX_PTR: Lock<usize>\n     }\n \n-    /// Creates a TyCtxt and ImplicitCtxt based on the GCX_PTR thread local.\n+    /// Creates a `TyCtxt` and `ImplicitCtxt` based on the `GCX_PTR` thread local.\n     /// This is used in the deadlock handler.\n     pub unsafe fn with_global<F, R>(f: F) -> R\n     where\n@@ -1898,7 +1914,7 @@ pub mod tls {\n         enter_context(&icx, |_| f(tcx))\n     }\n \n-    /// Allows access to the current ImplicitCtxt in a closure if one is available\n+    /// Allows access to the current `ImplicitCtxt` in a closure if one is available.\n     #[inline]\n     pub fn with_context_opt<F, R>(f: F) -> R\n     where\n@@ -1908,16 +1924,16 @@ pub mod tls {\n         if context == 0 {\n             f(None)\n         } else {\n-            // We could get a ImplicitCtxt pointer from another thread.\n-            // Ensure that ImplicitCtxt is Sync\n+            // We could get a `ImplicitCtxt` pointer from another thread.\n+            // Ensure that `ImplicitCtxt` is `Sync`.\n             sync::assert_sync::<ImplicitCtxt<'_, '_>>();\n \n             unsafe { f(Some(&*(context as *const ImplicitCtxt<'_, '_>))) }\n         }\n     }\n \n-    /// Allows access to the current ImplicitCtxt.\n-    /// Panics if there is no ImplicitCtxt available\n+    /// Allows access to the current `ImplicitCtxt`.\n+    /// Panics if there is no `ImplicitCtxt` available.\n     #[inline]\n     pub fn with_context<F, R>(f: F) -> R\n     where\n@@ -1926,11 +1942,11 @@ pub mod tls {\n         with_context_opt(|opt_context| f(opt_context.expect(\"no ImplicitCtxt stored in tls\")))\n     }\n \n-    /// Allows access to the current ImplicitCtxt whose tcx field has the same global\n-    /// interner as the tcx argument passed in. This means the closure is given an ImplicitCtxt\n-    /// with the same 'tcx lifetime as the TyCtxt passed in.\n-    /// This will panic if you pass it a TyCtxt which has a different global interner from\n-    /// the current ImplicitCtxt's tcx field.\n+    /// Allows access to the current `ImplicitCtxt` whose tcx field has the same global\n+    /// interner as the tcx argument passed in. This means the closure is given an `ImplicitCtxt`\n+    /// with the same `'tcx` lifetime as the `TyCtxt` passed in.\n+    /// This will panic if you pass it a `TyCtxt` which has a different global interner from\n+    /// the current `ImplicitCtxt`'s `tcx` field.\n     #[inline]\n     pub fn with_related_context<'tcx, F, R>(tcx: TyCtxt<'tcx>, f: F) -> R\n     where\n@@ -1945,8 +1961,8 @@ pub mod tls {\n         })\n     }\n \n-    /// Allows access to the TyCtxt in the current ImplicitCtxt.\n-    /// Panics if there is no ImplicitCtxt available\n+    /// Allows access to the `TyCtxt` in the current `ImplicitCtxt`.\n+    /// Panics if there is no `ImplicitCtxt` available.\n     #[inline]\n     pub fn with<F, R>(f: F) -> R\n     where\n@@ -1955,8 +1971,8 @@ pub mod tls {\n         with_context(|context| f(context.tcx))\n     }\n \n-    /// Allows access to the TyCtxt in the current ImplicitCtxt.\n-    /// The closure is passed None if there is no ImplicitCtxt available\n+    /// Allows access to the `TyCtxt` in the current `ImplicitCtxt`.\n+    /// The closure is passed None if there is no `ImplicitCtxt` available.\n     #[inline]\n     pub fn with_opt<F, R>(f: F) -> R\n     where\n@@ -1968,7 +1984,7 @@ pub mod tls {\n \n macro_rules! sty_debug_print {\n     ($ctxt: expr, $($variant: ident),*) => {{\n-        // curious inner module to allow variant names to be used as\n+        // Curious inner module to allow variant names to be used as\n         // variable names.\n         #[allow(non_snake_case)]\n         mod inner {\n@@ -2242,9 +2258,9 @@ slice_interners!(\n     projs: _intern_projs(ProjectionKind)\n );\n \n-// This isn't a perfect fit: CanonicalVarInfo slices are always\n+// This isn't a perfect fit: `CanonicalVarInfo` slices are always\n // allocated in the global arena, so this `intern_method!` macro is\n-// overly general.  But we just return false for the code that checks\n+// overly general. However, we just return `false` for the code that checks\n // whether they belong in the thread-local arena, so no harm done, and\n // seems better than open-coding the rest.\n intern_method! {\n@@ -2343,7 +2359,7 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     #[inline]\n     pub fn mk_adt(self, def: &'tcx AdtDef, substs: SubstsRef<'tcx>) -> Ty<'tcx> {\n-        // take a copy of substs so that we own the vectors inside\n+        // Take a copy of substs so that we own the vectors inside.\n         self.mk_ty(Adt(def, substs))\n     }\n \n@@ -2375,13 +2391,19 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     #[inline]\n     pub fn mk_box(self, ty: Ty<'tcx>) -> Ty<'tcx> {\n-        let def_id = self.require_lang_item(lang_items::OwnedBoxLangItem);\n+        let def_id = self.require_lang_item(lang_items::OwnedBoxLangItem, None);\n+        self.mk_generic_adt(def_id, ty)\n+    }\n+\n+    #[inline]\n+    pub fn mk_lang_item(self, ty: Ty<'tcx>, item: lang_items::LangItem)  -> Ty<'tcx> {\n+        let def_id = self.require_lang_item(item, None);\n         self.mk_generic_adt(def_id, ty)\n     }\n \n     #[inline]\n     pub fn mk_maybe_uninit(self, ty: Ty<'tcx>) -> Ty<'tcx> {\n-        let def_id = self.require_lang_item(lang_items::MaybeUninitLangItem);\n+        let def_id = self.require_lang_item(lang_items::MaybeUninitLangItem, None);\n         self.mk_generic_adt(def_id, ty)\n     }\n \n@@ -2886,6 +2908,14 @@ pub fn provide(providers: &mut ty::query::Providers<'_>) {\n         assert_eq!(id, LOCAL_CRATE);\n         tcx.arena.alloc(middle::lang_items::collect(tcx))\n     };\n+    providers.diagnostic_items = |tcx, id| {\n+        assert_eq!(id, LOCAL_CRATE);\n+        middle::diagnostic_items::collect(tcx)\n+    };\n+    providers.all_diagnostic_items = |tcx, id| {\n+        assert_eq!(id, LOCAL_CRATE);\n+        middle::diagnostic_items::collect_all(tcx)\n+    };\n     providers.maybe_unused_trait_import = |tcx, id| {\n         tcx.maybe_unused_trait_imports.contains(&id)\n     };"}, {"sha": "62910ec320494fd3053edb09211d9ea284ea3e37", "filename": "src/librustc/ty/error.rs", "status": "modified", "additions": 26, "deletions": 12, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ferror.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -4,6 +4,7 @@ use std::borrow::Cow;\n use std::fmt;\n use rustc_target::spec::abi;\n use syntax::ast;\n+use syntax::errors::pluralise;\n use errors::{Applicability, DiagnosticBuilder};\n use syntax_pos::Span;\n \n@@ -46,6 +47,8 @@ pub enum TypeError<'tcx> {\n     ExistentialMismatch(ExpectedFound<&'tcx ty::List<ty::ExistentialPredicate<'tcx>>>),\n \n     ConstMismatch(ExpectedFound<&'tcx ty::Const<'tcx>>),\n+\n+    IntrinsicCast,\n }\n \n #[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Hash, Debug, Copy)]\n@@ -80,12 +83,6 @@ impl<'tcx> fmt::Display for TypeError<'tcx> {\n             }\n         };\n \n-        macro_rules! pluralise {\n-            ($x:expr) => {\n-                if $x != 1 { \"s\" } else { \"\" }\n-            };\n-        }\n-\n         match *self {\n             CyclicTy(_) => write!(f, \"cyclic type of infinite size\"),\n             Mismatch => write!(f, \"types differ\"),\n@@ -179,6 +176,9 @@ impl<'tcx> fmt::Display for TypeError<'tcx> {\n             ConstMismatch(ref values) => {\n                 write!(f, \"expected `{}`, found `{}`\", values.expected, values.found)\n             }\n+            IntrinsicCast => {\n+                write!(f, \"cannot coerce intrinsics to function pointers\")\n+            }\n         }\n     }\n }\n@@ -195,7 +195,9 @@ impl<'tcx> ty::TyS<'tcx> {\n             ty::Array(_, n) => {\n                 let n = tcx.lift_to_global(&n).unwrap();\n                 match n.try_eval_usize(tcx, ty::ParamEnv::empty()) {\n-                    Some(n) => format!(\"array of {} elements\", n).into(),\n+                    Some(n) => {\n+                        format!(\"array of {} element{}\", n, if n != 1 { \"s\" } else { \"\" }).into()\n+                    }\n                     None => \"array\".into(),\n                 }\n             }\n@@ -247,20 +249,32 @@ impl<'tcx> ty::TyS<'tcx> {\n }\n \n impl<'tcx> TyCtxt<'tcx> {\n-    pub fn note_and_explain_type_err(self,\n-                                     db: &mut DiagnosticBuilder<'_>,\n-                                     err: &TypeError<'tcx>,\n-                                     sp: Span) {\n+    pub fn note_and_explain_type_err(\n+        self,\n+        db: &mut DiagnosticBuilder<'_>,\n+        err: &TypeError<'tcx>,\n+        sp: Span,\n+    ) {\n         use self::TypeError::*;\n \n-        match err.clone() {\n+        match err {\n             Sorts(values) => {\n                 let expected_str = values.expected.sort_string(self);\n                 let found_str = values.found.sort_string(self);\n                 if expected_str == found_str && expected_str == \"closure\" {\n                     db.note(\"no two closures, even if identical, have the same type\");\n                     db.help(\"consider boxing your closure and/or using it as a trait object\");\n                 }\n+                if expected_str == found_str && expected_str == \"opaque type\" { // Issue #63167\n+                    db.note(\"distinct uses of `impl Trait` result in different opaque types\");\n+                    let e_str = values.expected.to_string();\n+                    let f_str = values.found.to_string();\n+                    if &e_str == &f_str && &e_str == \"impl std::future::Future\" {\n+                        // FIXME: use non-string based check.\n+                        db.help(\"if both `Future`s have the same `Output` type, consider \\\n+                                 `.await`ing on both of them\");\n+                    }\n+                }\n                 if let (ty::Infer(ty::IntVar(_)), ty::Float(_)) =\n                        (&values.found.sty, &values.expected.sty) // Issue #53280\n                 {"}, {"sha": "1e08ae45951d1e4db2b17a19b36af95c1009954b", "filename": "src/librustc/ty/fold.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffold.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -39,8 +39,8 @@ use std::collections::BTreeMap;\n use std::fmt;\n use crate::util::nodemap::FxHashSet;\n \n-/// The TypeFoldable trait is implemented for every type that can be folded.\n-/// Basically, every type that has a corresponding method in TypeFolder.\n+/// This trait is implemented for every type that can be folded.\n+/// Basically, every type that has a corresponding method in `TypeFolder`.\n ///\n /// To implement this conveniently, use the\n /// `BraceStructTypeFoldableImpl` etc macros found in `macros.rs`."}, {"sha": "63cc60d80aada4e682db73528e837dacac1d313d", "filename": "src/librustc/ty/inhabitedness/def_id_forest.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Fty%2Finhabitedness%2Fdef_id_forest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Fty%2Finhabitedness%2Fdef_id_forest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finhabitedness%2Fdef_id_forest.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -4,20 +4,20 @@ use rustc::hir::CRATE_HIR_ID;\n use crate::ty::context::TyCtxt;\n use crate::ty::{DefId, DefIdTree};\n \n-/// Represents a forest of DefIds closed under the ancestor relation. That is,\n-/// if a DefId representing a module is contained in the forest then all\n-/// DefIds defined in that module or submodules are also implicitly contained\n+/// Represents a forest of `DefId`s closed under the ancestor relation. That is,\n+/// if a `DefId` representing a module is contained in the forest then all\n+/// `DefId`s defined in that module or submodules are also implicitly contained\n /// in the forest.\n ///\n /// This is used to represent a set of modules in which a type is visibly\n /// uninhabited.\n #[derive(Clone)]\n pub struct DefIdForest {\n-    /// The minimal set of DefIds required to represent the whole set.\n-    /// If A and B are DefIds in the DefIdForest, and A is a descendant\n-    /// of B, then only B will be in root_ids.\n-    /// We use a SmallVec here because (for its use for caching inhabitedness)\n-    /// its rare that this will contain even two ids.\n+    /// The minimal set of `DefId`s required to represent the whole set.\n+    /// If A and B are DefIds in the `DefIdForest`, and A is a descendant\n+    /// of B, then only B will be in `root_ids`.\n+    /// We use a `SmallVec` here because (for its use for caching inhabitedness)\n+    /// its rare that this will contain even two IDs.\n     root_ids: SmallVec<[DefId; 1]>,\n }\n \n@@ -37,7 +37,7 @@ impl<'tcx> DefIdForest {\n         DefIdForest::from_id(crate_id)\n     }\n \n-    /// Creates a forest containing a DefId and all its descendants.\n+    /// Creates a forest containing a `DefId` and all its descendants.\n     pub fn from_id(id: DefId) -> DefIdForest {\n         let mut root_ids = SmallVec::new();\n         root_ids.push(id);"}, {"sha": "1a0e3517338773209352e43f4f282800ebc41c2b", "filename": "src/librustc/ty/inhabitedness/mod.rs", "status": "modified", "additions": 18, "deletions": 17, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -1,16 +1,16 @@\n+pub use self::def_id_forest::DefIdForest;\n+\n use crate::ty::context::TyCtxt;\n use crate::ty::{AdtDef, VariantDef, FieldDef, Ty, TyS};\n use crate::ty::{DefId, SubstsRef};\n use crate::ty::{AdtKind, Visibility};\n use crate::ty::TyKind::*;\n use crate::ty;\n \n-pub use self::def_id_forest::DefIdForest;\n-\n mod def_id_forest;\n \n-// The methods in this module calculate DefIdForests of modules in which a\n-// AdtDef/VariantDef/FieldDef is visibly uninhabited.\n+// The methods in this module calculate `DefIdForest`s of modules in which a\n+// `AdtDef`/`VariantDef`/`FieldDef` is visibly uninhabited.\n //\n // # Example\n // ```rust\n@@ -36,24 +36,25 @@ mod def_id_forest;\n //     y: c::AlsoSecretlyUninhabited,\n // }\n // ```\n-// In this code, the type Foo will only be visibly uninhabited inside the\n-// modules b, c and d. Calling uninhabited_from on Foo or its AdtDef will\n-// return the forest of modules {b, c->d} (represented in a DefIdForest by the\n-// set {b, c})\n+// In this code, the type `Foo` will only be visibly uninhabited inside the\n+// modules `b`, `c` and `d`. Calling `uninhabited_from` on `Foo` or its `AdtDef` will\n+// return the forest of modules {`b`, `c`->`d`} (represented in a `DefIdForest` by the\n+// set {`b`, `c`}).\n //\n-// We need this information for pattern-matching on Foo or types that contain\n-// Foo.\n+// We need this information for pattern-matching on `Foo` or types that contain\n+// `Foo`.\n //\n // # Example\n // ```rust\n // let foo_result: Result<T, Foo> = ... ;\n // let Ok(t) = foo_result;\n // ```\n-// This code should only compile in modules where the uninhabitedness of Foo is\n+// This code should only compile in modules where the uninhabitedness of `Foo` is\n // visible.\n \n impl<'tcx> TyCtxt<'tcx> {\n     /// Checks whether a type is visibly uninhabited from a particular module.\n+    ///\n     /// # Example\n     /// ```rust\n     /// enum Void {}\n@@ -91,7 +92,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// visible.\n     pub fn is_ty_uninhabited_from(self, module: DefId, ty: Ty<'tcx>) -> bool {\n         // To check whether this type is uninhabited at all (not just from the\n-        // given node) you could check whether the forest is empty.\n+        // given node), you could check whether the forest is empty.\n         // ```\n         // forest.is_empty()\n         // ```\n@@ -108,7 +109,7 @@ impl<'tcx> TyCtxt<'tcx> {\n }\n \n impl<'tcx> AdtDef {\n-    /// Calculate the forest of DefIds from which this adt is visibly uninhabited.\n+    /// Calculates the forest of `DefId`s from which this ADT is visibly uninhabited.\n     fn uninhabited_from(&self, tcx: TyCtxt<'tcx>, substs: SubstsRef<'tcx>) -> DefIdForest {\n         // Non-exhaustive ADTs from other crates are always considered inhabited.\n         if self.is_variant_list_non_exhaustive() && !self.did.is_local() {\n@@ -122,7 +123,7 @@ impl<'tcx> AdtDef {\n }\n \n impl<'tcx> VariantDef {\n-    /// Calculate the forest of DefIds from which this variant is visibly uninhabited.\n+    /// Calculates the forest of `DefId`s from which this variant is visibly uninhabited.\n     pub fn uninhabited_from(\n         &self,\n         tcx: TyCtxt<'tcx>,\n@@ -148,7 +149,7 @@ impl<'tcx> VariantDef {\n }\n \n impl<'tcx> FieldDef {\n-    /// Calculate the forest of DefIds from which this field is visibly uninhabited.\n+    /// Calculates the forest of `DefId`s from which this field is visibly uninhabited.\n     fn uninhabited_from(\n         &self,\n         tcx: TyCtxt<'tcx>,\n@@ -159,7 +160,7 @@ impl<'tcx> FieldDef {\n             self.ty(tcx, substs).uninhabited_from(tcx)\n         };\n         // FIXME(canndrew): Currently enum fields are (incorrectly) stored with\n-        // Visibility::Invisible so we need to override self.vis if we're\n+        // `Visibility::Invisible` so we need to override `self.vis` if we're\n         // dealing with an enum.\n         if is_enum {\n             data_uninhabitedness()\n@@ -178,7 +179,7 @@ impl<'tcx> FieldDef {\n }\n \n impl<'tcx> TyS<'tcx> {\n-    /// Calculate the forest of DefIds from which this type is visibly uninhabited.\n+    /// Calculates the forest of `DefId`s from which this type is visibly uninhabited.\n     fn uninhabited_from(&self, tcx: TyCtxt<'tcx>) -> DefIdForest {\n         match self.sty {\n             Adt(def, substs) => def.uninhabited_from(tcx, substs),"}, {"sha": "a26fa72f330410180080ffa6f143e1be1819e210", "filename": "src/librustc/ty/instance.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finstance.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -327,7 +327,7 @@ impl<'tcx> Instance<'tcx> {\n     }\n \n     pub fn resolve_drop_in_place(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> ty::Instance<'tcx> {\n-        let def_id = tcx.require_lang_item(DropInPlaceFnLangItem);\n+        let def_id = tcx.require_lang_item(DropInPlaceFnLangItem, None);\n         let substs = tcx.intern_substs(&[ty.into()]);\n         Instance::resolve(tcx, ty::ParamEnv::reveal_all(), def_id, substs).unwrap()\n     }"}, {"sha": "5ec4754c4535bc54019426bea5cef721428e9c52", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 19, "deletions": 30, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -273,14 +273,12 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                              repr: &ReprOptions,\n                              kind: StructKind) -> Result<LayoutDetails, LayoutError<'tcx>> {\n         let dl = self.data_layout();\n-        let packed = repr.packed();\n-        if packed && repr.align > 0 {\n+        let pack = repr.pack;\n+        if pack.is_some() && repr.align.is_some() {\n             bug!(\"struct cannot be packed and aligned\");\n         }\n \n-        let pack = Align::from_bytes(repr.pack as u64).unwrap();\n-\n-        let mut align = if packed {\n+        let mut align = if pack.is_some() {\n             dl.i8_align\n         } else {\n             dl.aggregate_align\n@@ -303,7 +301,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n             };\n             let optimizing = &mut inverse_memory_index[..end];\n             let field_align = |f: &TyLayout<'_>| {\n-                if packed { f.align.abi.min(pack) } else { f.align.abi }\n+                if let Some(pack) = pack { f.align.abi.min(pack) } else { f.align.abi }\n             };\n             match kind {\n                 StructKind::AlwaysSized |\n@@ -334,7 +332,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n         let mut largest_niche_available = 0;\n \n         if let StructKind::Prefixed(prefix_size, prefix_align) = kind {\n-            let prefix_align = if packed {\n+            let prefix_align = if let Some(pack) = pack {\n                 prefix_align.min(pack)\n             } else {\n                 prefix_align\n@@ -355,7 +353,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n             }\n \n             // Invariant: offset < dl.obj_size_bound() <= 1<<61\n-            let field_align = if packed {\n+            let field_align = if let Some(pack) = pack {\n                 field.align.min(AbiAndPrefAlign::new(pack))\n             } else {\n                 field.align\n@@ -379,10 +377,8 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                 .ok_or(LayoutError::SizeOverflow(ty))?;\n         }\n \n-        if repr.align > 0 {\n-            let repr_align = repr.align as u64;\n-            align = align.max(AbiAndPrefAlign::new(Align::from_bytes(repr_align).unwrap()));\n-            debug!(\"univariant repr_align: {:?}\", repr_align);\n+        if let Some(repr_align) = repr.align {\n+            align = align.max(AbiAndPrefAlign::new(repr_align));\n         }\n \n         debug!(\"univariant min_size: {:?}\", offset);\n@@ -730,23 +726,18 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                 }).collect::<Result<IndexVec<VariantIdx, _>, _>>()?;\n \n                 if def.is_union() {\n-                    let packed = def.repr.packed();\n-                    if packed && def.repr.align > 0 {\n-                        bug!(\"Union cannot be packed and aligned\");\n+                    if def.repr.pack.is_some() && def.repr.align.is_some() {\n+                        bug!(\"union cannot be packed and aligned\");\n                     }\n \n-                    let pack = Align::from_bytes(def.repr.pack as u64).unwrap();\n-\n-                    let mut align = if packed {\n+                    let mut align = if def.repr.pack.is_some() {\n                         dl.i8_align\n                     } else {\n                         dl.aggregate_align\n                     };\n \n-                    if def.repr.align > 0 {\n-                        let repr_align = def.repr.align as u64;\n-                        align = align.max(\n-                            AbiAndPrefAlign::new(Align::from_bytes(repr_align).unwrap()));\n+                    if let Some(repr_align) = def.repr.align {\n+                        align = align.max(AbiAndPrefAlign::new(repr_align));\n                     }\n \n                     let optimize = !def.repr.inhibit_union_abi_opt();\n@@ -755,13 +746,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                     let index = VariantIdx::new(0);\n                     for field in &variants[index] {\n                         assert!(!field.is_unsized());\n-\n-                        let field_align = if packed {\n-                            field.align.min(AbiAndPrefAlign::new(pack))\n-                        } else {\n-                            field.align\n-                        };\n-                        align = align.max(field_align);\n+                        align = align.max(field.align);\n \n                         // If all non-ZST fields have the same ABI, forward this ABI\n                         if optimize && !field.is_zst() {\n@@ -796,6 +781,10 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                         size = cmp::max(size, field.size);\n                     }\n \n+                    if let Some(pack) = def.repr.pack {\n+                        align = align.min(AbiAndPrefAlign::new(pack));\n+                    }\n+\n                     return Ok(tcx.intern_layout(LayoutDetails {\n                         variants: Variants::Single { index },\n                         fields: FieldPlacement::Union(variants[index].len()),\n@@ -1637,7 +1626,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n         };\n \n         let adt_kind = adt_def.adt_kind();\n-        let adt_packed = adt_def.repr.packed();\n+        let adt_packed = adt_def.repr.pack.is_some();\n \n         let build_variant_info = |n: Option<Ident>,\n                                   flds: &[ast::Name],"}, {"sha": "41e4295caeccec00257e5f326c253acc9a6e3904", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 23, "deletions": 20, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -33,6 +33,7 @@ use arena::SyncDroplessArena;\n use crate::session::DataTypeKind;\n \n use rustc_serialize::{self, Encodable, Encoder};\n+use rustc_target::abi::Align;\n use std::cell::RefCell;\n use std::cmp::{self, Ordering};\n use std::fmt;\n@@ -45,7 +46,7 @@ use std::ops::Range;\n use syntax::ast::{self, Name, Ident, NodeId};\n use syntax::attr;\n use syntax::ext::hygiene::ExpnId;\n-use syntax::symbol::{kw, sym, Symbol, LocalInternedString, InternedString};\n+use syntax::symbol::{kw, sym, Symbol, InternedString};\n use syntax_pos::Span;\n \n use smallvec;\n@@ -580,6 +581,7 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for ty::TyS<'tcx> {\n     }\n }\n \n+#[cfg_attr(not(bootstrap), rustc_diagnostic_item = \"Ty\")]\n pub type Ty<'tcx> = &'tcx TyS<'tcx>;\n \n impl<'tcx> rustc_serialize::UseSpecializedEncodable for Ty<'tcx> {}\n@@ -588,7 +590,7 @@ impl<'tcx> rustc_serialize::UseSpecializedDecodable for Ty<'tcx> {}\n pub type CanonicalTy<'tcx> = Canonical<'tcx, Ty<'tcx>>;\n \n extern {\n-    /// A dummy type used to force List to by unsized without requiring fat pointers\n+    /// A dummy type used to force `List` to by unsized without requiring fat pointers.\n     type OpaqueListContents;\n }\n \n@@ -2057,8 +2059,8 @@ impl_stable_hash_for!(struct ReprFlags {\n #[derive(Copy, Clone, Debug, Eq, PartialEq, RustcEncodable, RustcDecodable, Default)]\n pub struct ReprOptions {\n     pub int: Option<attr::IntType>,\n-    pub align: u32,\n-    pub pack: u32,\n+    pub align: Option<Align>,\n+    pub pack: Option<Align>,\n     pub flags: ReprFlags,\n }\n \n@@ -2073,18 +2075,19 @@ impl ReprOptions {\n     pub fn new(tcx: TyCtxt<'_>, did: DefId) -> ReprOptions {\n         let mut flags = ReprFlags::empty();\n         let mut size = None;\n-        let mut max_align = 0;\n-        let mut min_pack = 0;\n+        let mut max_align: Option<Align> = None;\n+        let mut min_pack: Option<Align> = None;\n         for attr in tcx.get_attrs(did).iter() {\n             for r in attr::find_repr_attrs(&tcx.sess.parse_sess, attr) {\n                 flags.insert(match r {\n                     attr::ReprC => ReprFlags::IS_C,\n                     attr::ReprPacked(pack) => {\n-                        min_pack = if min_pack > 0 {\n-                            cmp::min(pack, min_pack)\n+                        let pack = Align::from_bytes(pack as u64).unwrap();\n+                        min_pack = Some(if let Some(min_pack) = min_pack {\n+                            min_pack.min(pack)\n                         } else {\n                             pack\n-                        };\n+                        });\n                         ReprFlags::empty()\n                     },\n                     attr::ReprTransparent => ReprFlags::IS_TRANSPARENT,\n@@ -2094,7 +2097,7 @@ impl ReprOptions {\n                         ReprFlags::empty()\n                     },\n                     attr::ReprAlign(align) => {\n-                        max_align = cmp::max(align, max_align);\n+                        max_align = max_align.max(Some(Align::from_bytes(align as u64).unwrap()));\n                         ReprFlags::empty()\n                     },\n                 });\n@@ -2113,7 +2116,7 @@ impl ReprOptions {\n     #[inline]\n     pub fn c(&self) -> bool { self.flags.contains(ReprFlags::IS_C) }\n     #[inline]\n-    pub fn packed(&self) -> bool { self.pack > 0 }\n+    pub fn packed(&self) -> bool { self.pack.is_some() }\n     #[inline]\n     pub fn transparent(&self) -> bool { self.flags.contains(ReprFlags::IS_TRANSPARENT) }\n     #[inline]\n@@ -2133,8 +2136,12 @@ impl ReprOptions {\n     /// Returns `true` if this `#[repr()]` should inhibit struct field reordering\n     /// optimizations, such as with `repr(C)`, `repr(packed(1))`, or `repr(<int>)`.\n     pub fn inhibit_struct_field_reordering_opt(&self) -> bool {\n-        self.flags.intersects(ReprFlags::IS_UNOPTIMISABLE) || self.pack == 1 ||\n-            self.int.is_some()\n+        if let Some(pack) = self.pack {\n+            if pack.bytes() == 1 {\n+                return true;\n+            }\n+        }\n+        self.flags.intersects(ReprFlags::IS_UNOPTIMISABLE) || self.int.is_some()\n     }\n \n     /// Returns `true` if this `#[repr()]` should inhibit union ABI optimisations.\n@@ -2588,12 +2595,12 @@ impl<'tcx> ClosureKind {\n \n     pub fn trait_did(&self, tcx: TyCtxt<'tcx>) -> DefId {\n         match *self {\n-            ClosureKind::Fn => tcx.require_lang_item(FnTraitLangItem),\n+            ClosureKind::Fn => tcx.require_lang_item(FnTraitLangItem, None),\n             ClosureKind::FnMut => {\n-                tcx.require_lang_item(FnMutTraitLangItem)\n+                tcx.require_lang_item(FnMutTraitLangItem, None)\n             }\n             ClosureKind::FnOnce => {\n-                tcx.require_lang_item(FnOnceTraitLangItem)\n+                tcx.require_lang_item(FnOnceTraitLangItem, None)\n             }\n         }\n     }\n@@ -3379,10 +3386,6 @@ impl SymbolName {\n             name: InternedString::intern(name)\n         }\n     }\n-\n-    pub fn as_str(&self) -> LocalInternedString {\n-        self.name.as_str()\n-    }\n }\n \n impl fmt::Display for SymbolName {"}, {"sha": "50789bf6213b6ffd23d1e8a93e18b0a93e89d46e", "filename": "src/librustc/ty/print/mod.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Fty%2Fprint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Fty%2Fprint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint%2Fmod.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -27,7 +27,8 @@ pub trait Print<'tcx, P> {\n /// which the associated types allow passing through the methods.\n ///\n /// For pretty-printing/formatting in particular, see `PrettyPrinter`.\n-// FIXME(eddyb) find a better name, this is more general than \"printing\".\n+//\n+// FIXME(eddyb) find a better name; this is more general than \"printing\".\n pub trait Printer<'tcx>: Sized {\n     type Error;\n \n@@ -46,6 +47,7 @@ pub trait Printer<'tcx>: Sized {\n     ) -> Result<Self::Path, Self::Error> {\n         self.default_print_def_path(def_id, substs)\n     }\n+\n     fn print_impl_path(\n         self,\n         impl_def_id: DefId,\n@@ -80,6 +82,7 @@ pub trait Printer<'tcx>: Sized {\n         self,\n         cnum: CrateNum,\n     ) -> Result<Self::Path, Self::Error>;\n+\n     fn path_qualified(\n         self,\n         self_ty: Ty<'tcx>,\n@@ -93,11 +96,13 @@ pub trait Printer<'tcx>: Sized {\n         self_ty: Ty<'tcx>,\n         trait_ref: Option<ty::TraitRef<'tcx>>,\n     ) -> Result<Self::Path, Self::Error>;\n+\n     fn path_append(\n         self,\n         print_prefix: impl FnOnce(Self) -> Result<Self::Path, Self::Error>,\n         disambiguated_data: &DisambiguatedDefPathData,\n     ) -> Result<Self::Path, Self::Error>;\n+\n     fn path_generic_args(\n         self,\n         print_prefix: impl FnOnce(Self) -> Result<Self::Path, Self::Error>,"}, {"sha": "d99580116e4ae30fe0394c12a012a0566c581d39", "filename": "src/librustc/ty/print/pretty.rs", "status": "modified", "additions": 24, "deletions": 14, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -8,10 +8,11 @@ use crate::ty::{self, DefIdTree, ParamConst, Ty, TyCtxt, TypeFoldable};\n use crate::ty::subst::{Kind, Subst, UnpackedKind};\n use crate::ty::layout::{Integer, IntegerExt, Size};\n use crate::mir::interpret::{ConstValue, sign_extend, Scalar, truncate};\n-use syntax::ast;\n+\n use rustc_apfloat::ieee::{Double, Single};\n use rustc_apfloat::Float;\n use rustc_target::spec::abi::Abi;\n+use syntax::ast;\n use syntax::attr::{SignedInt, UnsignedInt};\n use syntax::symbol::{kw, InternedString};\n \n@@ -194,7 +195,7 @@ pub trait PrettyPrinter<'tcx>:\n         value.skip_binder().print(self)\n     }\n \n-    /// Print comma-separated elements.\n+    /// Prints comma-separated elements.\n     fn comma_sep<T>(mut self, mut elems: impl Iterator<Item = T>) -> Result<Self, Self::Error>\n     where\n         T: Print<'tcx, Self, Output = Self, Error = Self::Error>,\n@@ -209,14 +210,14 @@ pub trait PrettyPrinter<'tcx>:\n         Ok(self)\n     }\n \n-    /// Print `<...>` around what `f` prints.\n+    /// Prints `<...>` around what `f` prints.\n     fn generic_delimiters(\n         self,\n         f: impl FnOnce(Self) -> Result<Self, Self::Error>,\n     ) -> Result<Self, Self::Error>;\n \n-    /// Return `true` if the region should be printed in\n-    /// optional positions, e.g. `&'a T` or `dyn Tr + 'b`.\n+    /// Returns `true` if the region should be printed in\n+    /// optional positions, e.g., `&'a T` or `dyn Tr + 'b`.\n     /// This is typically the case for all non-`'_` regions.\n     fn region_should_not_be_omitted(\n         &self,\n@@ -226,7 +227,7 @@ pub trait PrettyPrinter<'tcx>:\n     // Defaults (should not be overriden):\n \n     /// If possible, this returns a global path resolving to `def_id` that is visible\n-    /// from at least one local module and returns true. If the crate defining `def_id` is\n+    /// from at least one local module, and returns `true`. If the crate defining `def_id` is\n     /// declared with an `extern crate`, the path is guaranteed to use the `extern crate`.\n     fn try_print_visible_def_path(\n         self,\n@@ -267,11 +268,11 @@ pub trait PrettyPrinter<'tcx>:\n             // In local mode, when we encounter a crate other than\n             // LOCAL_CRATE, execution proceeds in one of two ways:\n             //\n-            // 1. for a direct dependency, where user added an\n+            // 1. For a direct dependency, where user added an\n             //    `extern crate` manually, we put the `extern\n             //    crate` as the parent. So you wind up with\n             //    something relative to the current crate.\n-            // 2. for an extern inferred from a path or an indirect crate,\n+            // 2. For an extern inferred from a path or an indirect crate,\n             //    where there is no explicit `extern crate`, we just prepend\n             //    the crate name.\n             match self.tcx().extern_crate(def_id) {\n@@ -304,13 +305,13 @@ pub trait PrettyPrinter<'tcx>:\n         let mut cur_def_key = self.tcx().def_key(def_id);\n         debug!(\"try_print_visible_def_path: cur_def_key={:?}\", cur_def_key);\n \n-        // For a constructor we want the name of its parent rather than <unnamed>.\n+        // For a constructor, we want the name of its parent rather than <unnamed>.\n         match cur_def_key.disambiguated_data.data {\n             DefPathData::Ctor => {\n                 let parent = DefId {\n                     krate: def_id.krate,\n                     index: cur_def_key.parent\n-                        .expect(\"DefPathData::Ctor/VariantData missing a parent\"),\n+                        .expect(\"`DefPathData::Ctor` / `VariantData` missing a parent\"),\n                 };\n \n                 cur_def_key = self.tcx().def_key(parent);\n@@ -630,7 +631,7 @@ pub trait PrettyPrinter<'tcx>:\n                         sep = \", \";\n                     }\n                 } else {\n-                    // cross-crate closure types should only be\n+                    // Cross-crate closure types should only be\n                     // visible in codegen bug reports, I imagine.\n                     p!(write(\"@{:?}\", did));\n                     let mut sep = \" \";\n@@ -673,7 +674,7 @@ pub trait PrettyPrinter<'tcx>:\n                         sep = \", \";\n                     }\n                 } else {\n-                    // cross-crate closure types should only be\n+                    // Cross-crate closure types should only be\n                     // visible in codegen bug reports, I imagine.\n                     p!(write(\"@{:?}\", did));\n                     let mut sep = \" \";\n@@ -944,10 +945,16 @@ pub trait PrettyPrinter<'tcx>:\n                         .get_bytes(&self.tcx(), ptr, Size::from_bytes(n)).unwrap())\n                 },\n                 (ConstValue::Slice { data, start, end }, ty::Slice(t)) if *t == u8 => {\n-                    Some(&data.bytes[start..end])\n+                    // The `inspect` here is okay since we checked the bounds, and there are no\n+                    // relocations (we have an active slice reference here). We don't use this\n+                    // result to affect interpreter execution.\n+                    Some(data.inspect_with_undef_and_ptr_outside_interpreter(start..end))\n                 },\n                 (ConstValue::Slice { data, start, end }, ty::Str) => {\n-                    let slice = &data.bytes[start..end];\n+                    // The `inspect` here is okay since we checked the bounds, and there are no\n+                    // relocations (we have an active `str` reference here). We don't use this\n+                    // result to affect interpreter execution.\n+                    let slice = data.inspect_with_undef_and_ptr_outside_interpreter(start..end);\n                     let s = ::std::str::from_utf8(slice)\n                         .expect(\"non utf8 str from miri\");\n                     p!(write(\"{:?}\", s));\n@@ -1167,6 +1174,7 @@ impl<F: fmt::Write> Printer<'tcx> for FmtPrinter<'_, 'tcx, F> {\n         }\n         Ok(self)\n     }\n+\n     fn path_qualified(\n         mut self,\n         self_ty: Ty<'tcx>,\n@@ -1195,6 +1203,7 @@ impl<F: fmt::Write> Printer<'tcx> for FmtPrinter<'_, 'tcx, F> {\n         self.empty_path = false;\n         Ok(self)\n     }\n+\n     fn path_append(\n         mut self,\n         print_prefix: impl FnOnce(Self) -> Result<Self::Path, Self::Error>,\n@@ -1232,6 +1241,7 @@ impl<F: fmt::Write> Printer<'tcx> for FmtPrinter<'_, 'tcx, F> {\n \n         Ok(self)\n     }\n+\n     fn path_generic_args(\n         mut self,\n         print_prefix: impl FnOnce(Self) -> Result<Self::Path, Self::Error>,"}, {"sha": "4cef6a09925addb6b3365440cd48e59245c6595f", "filename": "src/librustc/ty/query/on_disk_cache.rs", "status": "modified", "additions": 135, "deletions": 117, "changes": 252, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -5,9 +5,6 @@ use crate::hir::map::definitions::DefPathHash;\n use crate::ich::{CachingSourceMapView, Fingerprint};\n use crate::mir::{self, interpret};\n use crate::mir::interpret::{AllocDecodingSession, AllocDecodingState};\n-use rustc_serialize::{Decodable, Decoder, Encodable, Encoder, opaque,\n-                      SpecializedDecoder, SpecializedEncoder,\n-                      UseSpecializedDecodable, UseSpecializedEncodable};\n use crate::session::{CrateDisambiguator, Session};\n use crate::ty::{self, Ty};\n use crate::ty::codec::{self as ty_codec, TyDecoder, TyEncoder};\n@@ -19,11 +16,15 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::thin_vec::ThinVec;\n use rustc_data_structures::sync::{Lrc, Lock, HashMapExt, Once};\n use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n+use rustc_serialize::{\n+    Decodable, Decoder, Encodable, Encoder, SpecializedDecoder, SpecializedEncoder,\n+    UseSpecializedDecodable, UseSpecializedEncodable, opaque,\n+};\n use std::mem;\n-use syntax::ast::NodeId;\n+use syntax::ast::{Ident, NodeId};\n use syntax::source_map::{SourceMap, StableSourceFileId};\n use syntax_pos::{BytePos, Span, DUMMY_SP, SourceFile};\n-use syntax_pos::hygiene::{ExpnId, SyntaxContext, ExpnData};\n+use syntax_pos::hygiene::{ExpnId, SyntaxContext};\n \n const TAG_FILE_FOOTER: u128 = 0xC0FFEE_C0FFEE_C0FFEE_C0FFEE_C0FFEE;\n \n@@ -37,17 +38,16 @@ const TAG_EXPN_DATA_INLINE: u8 = 2;\n const TAG_VALID_SPAN: u8 = 0;\n const TAG_INVALID_SPAN: u8 = 1;\n \n-/// `OnDiskCache` provides an interface to incr. comp. data cached from the\n+/// Provides an interface to incremental compilation data cached from the\n /// previous compilation session. This data will eventually include the results\n /// of a few selected queries (like `typeck_tables_of` and `mir_optimized`) and\n /// any diagnostics that have been emitted during a query.\n pub struct OnDiskCache<'sess> {\n-\n     // The complete cache data in serialized form.\n     serialized_data: Vec<u8>,\n \n-    // This field collects all Diagnostics emitted during the current\n-    // compilation session.\n+    // Collects all `Diagnostic`s emitted during the current compilation\n+    // session.\n     current_diagnostics: Lock<FxHashMap<DepNodeIndex, Vec<Diagnostic>>>,\n \n     prev_cnums: Vec<(u32, String, CrateDisambiguator)>,\n@@ -56,7 +56,7 @@ pub struct OnDiskCache<'sess> {\n     source_map: &'sess SourceMap,\n     file_index_to_stable_id: FxHashMap<SourceFileIndex, StableSourceFileId>,\n \n-    // These two fields caches that are populated lazily during decoding.\n+    // Caches that are populated lazily during decoding.\n     file_index_to_file: Lock<FxHashMap<SourceFileIndex, Lrc<SourceFile>>>,\n     synthetic_syntax_contexts: Lock<FxHashMap<AbsoluteBytePos, SyntaxContext>>,\n \n@@ -78,7 +78,7 @@ struct Footer {\n     prev_cnums: Vec<(u32, String, CrateDisambiguator)>,\n     query_result_index: EncodedQueryResultIndex,\n     diagnostics_index: EncodedQueryResultIndex,\n-    // the location of all allocations\n+    // The location of all allocations.\n     interpret_alloc_index: Vec<u32>,\n }\n \n@@ -104,28 +104,28 @@ impl AbsoluteBytePos {\n }\n \n impl<'sess> OnDiskCache<'sess> {\n-    /// Creates a new OnDiskCache instance from the serialized data in `data`.\n-    pub fn new(sess: &'sess Session, data: Vec<u8>, start_pos: usize) -> OnDiskCache<'sess> {\n+    /// Creates a new `OnDiskCache` instance from the serialized data in `data`.\n+    pub fn new(sess: &'sess Session, data: Vec<u8>, start_pos: usize) -> Self {\n         debug_assert!(sess.opts.incremental.is_some());\n \n-        // Wrapping in a scope so we can borrow `data`\n+        // Wrap in a scope so we can borrow `data`.\n         let footer: Footer = {\n             let mut decoder = opaque::Decoder::new(&data[..], start_pos);\n \n-            // Decode the *position* of the footer which can be found in the\n+            // Decode the *position* of the footer, which can be found in the\n             // last 8 bytes of the file.\n             decoder.set_position(data.len() - IntEncodedWithFixedSize::ENCODED_SIZE);\n-            let query_result_index_pos = IntEncodedWithFixedSize::decode(&mut decoder)\n-                .expect(\"Error while trying to decode query result index position.\")\n+            let footer_pos = IntEncodedWithFixedSize::decode(&mut decoder)\n+                .expect(\"error while trying to decode footer position\")\n                 .0 as usize;\n \n-            // Decoder the file footer which contains all the lookup tables, etc.\n-            decoder.set_position(query_result_index_pos);\n+            // Decode the file footer, which contains all the lookup tables, etc.\n+            decoder.set_position(footer_pos);\n             decode_tagged(&mut decoder, TAG_FILE_FOOTER)\n-                .expect(\"Error while trying to decode query result index position.\")\n+                .expect(\"error while trying to decode footer position\")\n         };\n \n-        OnDiskCache {\n+        Self {\n             serialized_data: data,\n             file_index_to_stable_id: footer.file_index_to_stable_id,\n             file_index_to_file: Default::default(),\n@@ -140,8 +140,8 @@ impl<'sess> OnDiskCache<'sess> {\n         }\n     }\n \n-    pub fn new_empty(source_map: &'sess SourceMap) -> OnDiskCache<'sess> {\n-        OnDiskCache {\n+    pub fn new_empty(source_map: &'sess SourceMap) -> Self {\n+        Self {\n             serialized_data: Vec::new(),\n             file_index_to_stable_id: Default::default(),\n             file_index_to_file: Default::default(),\n@@ -158,11 +158,11 @@ impl<'sess> OnDiskCache<'sess> {\n \n     pub fn serialize<'tcx, E>(&self, tcx: TyCtxt<'tcx>, encoder: &mut E) -> Result<(), E::Error>\n     where\n-        E: ty_codec::TyEncoder,\n+        E: TyEncoder,\n     {\n-        // Serializing the DepGraph should not modify it:\n+        // Serializing the `DepGraph` should not modify it.\n         tcx.dep_graph.with_ignore(|| {\n-            // Allocate SourceFileIndices\n+            // Allocate `SourceFileIndex`es.\n             let (file_to_file_index, file_index_to_stable_id) = {\n                 let files = tcx.sess.source_map().files();\n                 let mut file_to_file_index = FxHashMap::with_capacity_and_hasher(\n@@ -197,7 +197,7 @@ impl<'sess> OnDiskCache<'sess> {\n             // be in memory, so this should be a cheap operation.\n             tcx.dep_graph.exec_cache_promotions(tcx);\n \n-            // Encode query results\n+            // Encode query results.\n             let mut query_result_index = EncodedQueryResultIndex::new();\n \n             time(tcx.sess, \"encode query results\", || {\n@@ -221,29 +221,28 @@ impl<'sess> OnDiskCache<'sess> {\n                 Ok(())\n             })?;\n \n-            // Encode diagnostics\n+            // Encode diagnostics.\n             let diagnostics_index: EncodedDiagnosticsIndex = self.current_diagnostics.borrow()\n                 .iter()\n-                .map(|(dep_node_index, diagnostics)|\n-            {\n-                let pos = AbsoluteBytePos::new(encoder.position());\n-                // Let's make sure we get the expected type here:\n-                let diagnostics: &EncodedDiagnostics = diagnostics;\n-                let dep_node_index = SerializedDepNodeIndex::new(dep_node_index.index());\n-                encoder.encode_tagged(dep_node_index, diagnostics)?;\n-\n-                Ok((dep_node_index, pos))\n-            })\n-            .collect::<Result<_, _>>()?;\n+                .map(|(dep_node_index, diagnostics)| {\n+                    let pos = AbsoluteBytePos::new(encoder.position());\n+                    // Let's make sure we get the expected type here.\n+                    let diagnostics: &EncodedDiagnostics = diagnostics;\n+                    let dep_node_index = SerializedDepNodeIndex::new(dep_node_index.index());\n+                    encoder.encode_tagged(dep_node_index, diagnostics)?;\n+\n+                    Ok((dep_node_index, pos))\n+                })\n+                .collect::<Result<_, _>>()?;\n \n             let interpret_alloc_index = {\n                 let mut interpret_alloc_index = Vec::new();\n                 let mut n = 0;\n                 loop {\n                     let new_n = encoder.interpret_allocs_inverse.len();\n-                    // if we have found new ids, serialize those, too\n+                    // If we have found new IDs, serialize those too.\n                     if n == new_n {\n-                        // otherwise, abort\n+                        // Otherwise, abort.\n                         break;\n                     }\n                     interpret_alloc_index.reserve(new_n - n);\n@@ -263,13 +262,15 @@ impl<'sess> OnDiskCache<'sess> {\n             };\n \n             let sorted_cnums = sorted_cnums_including_local_crate(tcx);\n-            let prev_cnums: Vec<_> = sorted_cnums.iter().map(|&cnum| {\n-                let crate_name = tcx.original_crate_name(cnum).as_str().to_string();\n-                let crate_disambiguator = tcx.crate_disambiguator(cnum);\n-                (cnum.as_u32(), crate_name, crate_disambiguator)\n-            }).collect();\n-\n-            // Encode the file footer\n+            let prev_cnums: Vec<_> = sorted_cnums.iter()\n+                .map(|&cnum| {\n+                    let crate_name = tcx.original_crate_name(cnum).as_str().to_string();\n+                    let crate_disambiguator = tcx.crate_disambiguator(cnum);\n+                    (cnum.as_u32(), crate_name, crate_disambiguator)\n+                })\n+                .collect();\n+\n+            // Encode the file footer.\n             let footer_pos = encoder.position() as u64;\n             encoder.encode_tagged(TAG_FILE_FOOTER, &Footer {\n                 file_index_to_stable_id,\n@@ -371,7 +372,7 @@ impl<'sess> OnDiskCache<'sess> {\n     {\n         let pos = index.get(&dep_node_index).cloned()?;\n \n-        // Initialize the cnum_map using the value from the thread which finishes the closure first\n+        // Initialize `cnum_map` using the value from the thread that finishes the closure first.\n         self.cnum_map.init_nonlocking_same(|| {\n             Self::compute_cnum_map(tcx, &self.prev_cnums[..])\n         });\n@@ -381,25 +382,21 @@ impl<'sess> OnDiskCache<'sess> {\n             opaque: opaque::Decoder::new(&self.serialized_data[..], pos.to_usize()),\n             source_map: self.source_map,\n             cnum_map: self.cnum_map.get(),\n+            synthetic_syntax_contexts: &self.synthetic_syntax_contexts,\n             file_index_to_file: &self.file_index_to_file,\n             file_index_to_stable_id: &self.file_index_to_stable_id,\n-            synthetic_syntax_contexts: &self.synthetic_syntax_contexts,\n             alloc_decoding_session: self.alloc_decoding_state.new_decoding_session(),\n         };\n \n         match decode_tagged(&mut decoder, dep_node_index) {\n-            Ok(value) => {\n-                Some(value)\n-            }\n-            Err(e) => {\n-                bug!(\"Could not decode cached {}: {}\", debug_tag, e)\n-            }\n+            Ok(v) => Some(v),\n+            Err(e) => bug!(\"could not decode cached {}: {}\", debug_tag, e),\n         }\n     }\n \n-    // This function builds mapping from previous-session-CrateNum to\n-    // current-session-CrateNum. There might be CrateNums from the previous\n-    // Session that don't occur in the current one. For these, the mapping\n+    // This function builds mapping from previous-session-`CrateNum` to\n+    // current-session-`CrateNum`. There might be `CrateNum`s from the previous\n+    // `Session` that don't occur in the current one. For these, the mapping\n     // maps to None.\n     fn compute_cnum_map(\n         tcx: TyCtxt<'_>,\n@@ -432,9 +429,9 @@ impl<'sess> OnDiskCache<'sess> {\n \n //- DECODING -------------------------------------------------------------------\n \n-/// A decoder that can read the incr. comp. cache. It is similar to the one\n-/// we use for crate metadata decoding in that it can rebase spans and\n-/// eventually will also handle things that contain `Ty` instances.\n+/// A decoder that can read fro the incr. comp. cache. It is similar to the one\n+/// we use for crate metadata decoding in that it can rebase spans and eventually\n+/// will also handle things that contain `Ty` instances.\n struct CacheDecoder<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n     opaque: opaque::Decoder<'a>,\n@@ -458,7 +455,7 @@ impl<'a, 'tcx> CacheDecoder<'a, 'tcx> {\n         file_index_to_file.borrow_mut().entry(index).or_insert_with(|| {\n             let stable_id = file_index_to_stable_id[&index];\n             source_map.source_file_by_stable_id(stable_id)\n-                .expect(\"Failed to lookup SourceFile in new context.\")\n+                .expect(\"failed to lookup `SourceFile` in new context\")\n         }).clone()\n     }\n }\n@@ -479,7 +476,7 @@ impl<'a, 'tcx> DecoderWithPosition for CacheDecoder<'a, 'tcx> {\n     }\n }\n \n-// Decode something that was encoded with encode_tagged() and verify that the\n+// Decodes something that was encoded with `encode_tagged()` and verify that the\n // tag matches and the correct amount of bytes was read.\n fn decode_tagged<D, T, V>(decoder: &mut D, expected_tag: T) -> Result<V, D::Error>\n where\n@@ -500,7 +497,7 @@ where\n     Ok(value)\n }\n \n-impl<'a, 'tcx> ty_codec::TyDecoder<'tcx> for CacheDecoder<'a, 'tcx> {\n+impl<'a, 'tcx> TyDecoder<'tcx> for CacheDecoder<'a, 'tcx> {\n     #[inline]\n     fn tcx(&self) -> TyCtxt<'tcx> {\n         self.tcx\n@@ -534,7 +531,7 @@ impl<'a, 'tcx> ty_codec::TyDecoder<'tcx> for CacheDecoder<'a, 'tcx> {\n         }\n \n         let ty = or_insert_with(self)?;\n-        // This may overwrite the entry, but it should overwrite with the same value\n+        // This may overwrite the entry, but it should overwrite with the same value.\n         tcx.rcache.borrow_mut().insert_same(cache_key, ty);\n         Ok(ty)\n     }\n@@ -553,7 +550,7 @@ impl<'a, 'tcx> ty_codec::TyDecoder<'tcx> for CacheDecoder<'a, 'tcx> {\n \n     fn map_encoded_cnum_to_current(&self, cnum: CrateNum) -> CrateNum {\n         self.cnum_map[cnum].unwrap_or_else(|| {\n-            bug!(\"Could not find new CrateNum for {:?}\", cnum)\n+            bug!(\"could not find new `CrateNum` for {:?}\", cnum)\n         })\n     }\n }\n@@ -591,10 +588,11 @@ impl<'a, 'tcx> SpecializedDecoder<Span> for CacheDecoder<'a, 'tcx> {\n         // FIXME(mw): This method does not restore `ExpnData::parent` or\n         // `SyntaxContextData::prev_ctxt` or `SyntaxContextData::opaque`. These things\n         // don't seem to be used after HIR lowering, so everything should be fine\n-        // as long as incremental compilation does not kick in before that.\n+        // until we want incremental compilation to serialize Spans that we need\n+        // full hygiene information for.\n         let location = || Span::with_root_ctxt(lo, hi);\n-        let recover_from_expn_data = |this: &Self, expn_data, pos| {\n-            let span = location().fresh_expansion(expn_data);\n+        let recover_from_expn_data = |this: &Self, expn_data, transparency, pos| {\n+            let span = location().fresh_expansion_with_transparency(expn_data, transparency);\n             this.synthetic_syntax_contexts.borrow_mut().insert(pos, span.ctxt());\n             span\n         };\n@@ -603,9 +601,9 @@ impl<'a, 'tcx> SpecializedDecoder<Span> for CacheDecoder<'a, 'tcx> {\n                 location()\n             }\n             TAG_EXPN_DATA_INLINE => {\n-                let expn_data = Decodable::decode(self)?;\n+                let (expn_data, transparency) = Decodable::decode(self)?;\n                 recover_from_expn_data(\n-                    self, expn_data, AbsoluteBytePos::new(self.opaque.position())\n+                    self, expn_data, transparency, AbsoluteBytePos::new(self.opaque.position())\n                 )\n             }\n             TAG_EXPN_DATA_SHORTHAND => {\n@@ -614,9 +612,9 @@ impl<'a, 'tcx> SpecializedDecoder<Span> for CacheDecoder<'a, 'tcx> {\n                 if let Some(ctxt) = cached_ctxt {\n                     Span::new(lo, hi, ctxt)\n                 } else {\n-                    let expn_data =\n-                        self.with_position(pos.to_usize(), |this| ExpnData::decode(this))?;\n-                    recover_from_expn_data(self, expn_data, pos)\n+                    let (expn_data, transparency) =\n+                        self.with_position(pos.to_usize(), |this| Decodable::decode(this))?;\n+                    recover_from_expn_data(self, expn_data, transparency, pos)\n                 }\n             }\n             _ => {\n@@ -626,26 +624,33 @@ impl<'a, 'tcx> SpecializedDecoder<Span> for CacheDecoder<'a, 'tcx> {\n     }\n }\n \n+impl<'a, 'tcx> SpecializedDecoder<Ident> for CacheDecoder<'a, 'tcx> {\n+    fn specialized_decode(&mut self) -> Result<Ident, Self::Error> {\n+        // FIXME: Handle hygiene in incremental\n+        bug!(\"Trying to decode Ident for incremental\");\n+    }\n+}\n+\n // This impl makes sure that we get a runtime error when we try decode a\n-// DefIndex that is not contained in a DefId. Such a case would be problematic\n-// because we would not know how to transform the DefIndex to the current\n+// `DefIndex` that is not contained in a `DefId`. Such a case would be problematic\n+// because we would not know how to transform the `DefIndex` to the current\n // context.\n impl<'a, 'tcx> SpecializedDecoder<DefIndex> for CacheDecoder<'a, 'tcx> {\n     fn specialized_decode(&mut self) -> Result<DefIndex, Self::Error> {\n-        bug!(\"Trying to decode DefIndex outside the context of a DefId\")\n+        bug!(\"trying to decode `DefIndex` outside the context of a `DefId`\")\n     }\n }\n \n-// Both the CrateNum and the DefIndex of a DefId can change in between two\n-// compilation sessions. We use the DefPathHash, which is stable across\n-// sessions, to map the old DefId to the new one.\n+// Both the `CrateNum` and the `DefIndex` of a `DefId` can change in between two\n+// compilation sessions. We use the `DefPathHash`, which is stable across\n+// sessions, to map the old DefId`` to the new one.\n impl<'a, 'tcx> SpecializedDecoder<DefId> for CacheDecoder<'a, 'tcx> {\n     #[inline]\n     fn specialized_decode(&mut self) -> Result<DefId, Self::Error> {\n-        // Load the DefPathHash which is was we encoded the DefId as.\n+        // Load the `DefPathHash` which is was we encoded the `DefId` as.\n         let def_path_hash = DefPathHash::decode(self)?;\n \n-        // Using the DefPathHash, we can lookup the new DefId\n+        // Using the `DefPathHash`, we can lookup the new `DefId`.\n         Ok(self.tcx().def_path_hash_to_def_id.as_ref().unwrap()[&def_path_hash])\n     }\n }\n@@ -659,21 +664,21 @@ impl<'a, 'tcx> SpecializedDecoder<LocalDefId> for CacheDecoder<'a, 'tcx> {\n \n impl<'a, 'tcx> SpecializedDecoder<hir::HirId> for CacheDecoder<'a, 'tcx> {\n     fn specialized_decode(&mut self) -> Result<hir::HirId, Self::Error> {\n-        // Load the DefPathHash which is was we encoded the DefIndex as.\n+        // Load the `DefPathHash` which is what we encoded the `DefIndex` as.\n         let def_path_hash = DefPathHash::decode(self)?;\n \n-        // Use the DefPathHash to map to the current DefId.\n+        // Use the `DefPathHash` to map to the current `DefId`.\n         let def_id = self.tcx()\n                          .def_path_hash_to_def_id\n                          .as_ref()\n                          .unwrap()[&def_path_hash];\n \n         debug_assert!(def_id.is_local());\n \n-        // The ItemLocalId needs no remapping.\n+        // The `ItemLocalId` needs no remapping.\n         let local_id = hir::ItemLocalId::decode(self)?;\n \n-        // Reconstruct the HirId and look up the corresponding NodeId in the\n+        // Reconstruct the `HirId` and look up the corresponding `NodeId` in the\n         // context of the current session.\n         Ok(hir::HirId {\n             owner: def_id.index,\n@@ -682,8 +687,8 @@ impl<'a, 'tcx> SpecializedDecoder<hir::HirId> for CacheDecoder<'a, 'tcx> {\n     }\n }\n \n-// NodeIds are not stable across compilation sessions, so we store them in their\n-// HirId representation. This allows use to map them to the current NodeId.\n+// `NodeId`s are not stable across compilation sessions, so we store them in their\n+// `HirId` representation. This allows use to map them to the current `NodeId`.\n impl<'a, 'tcx> SpecializedDecoder<NodeId> for CacheDecoder<'a, 'tcx> {\n     #[inline]\n     fn specialized_decode(&mut self) -> Result<NodeId, Self::Error> {\n@@ -720,6 +725,7 @@ impl<'a, 'tcx, T: Decodable> SpecializedDecoder<mir::ClearCrossCrate<T>>\n \n //- ENCODING -------------------------------------------------------------------\n \n+/// An encoder that can write the incr. comp. cache.\n struct CacheEncoder<'a, 'tcx, E: ty_codec::TyEncoder> {\n     tcx: TyCtxt<'tcx>,\n     encoder: &'a mut E,\n@@ -734,7 +740,7 @@ struct CacheEncoder<'a, 'tcx, E: ty_codec::TyEncoder> {\n \n impl<'a, 'tcx, E> CacheEncoder<'a, 'tcx, E>\n where\n-    E: 'a + ty_codec::TyEncoder,\n+    E: 'a + TyEncoder,\n {\n     fn source_file_index(&mut self, source_file: Lrc<SourceFile>) -> SourceFileIndex {\n         self.file_to_file_index[&(&*source_file as *const SourceFile)]\n@@ -745,11 +751,11 @@ where\n     /// encode the specified tag, then the given value, then the number of\n     /// bytes taken up by tag and value. On decoding, we can then verify that\n     /// we get the expected tag and read the expected number of bytes.\n-    fn encode_tagged<T: Encodable, V: Encodable>(&mut self,\n-                                                 tag: T,\n-                                                 value: &V)\n-                                                 -> Result<(), E::Error>\n-    {\n+    fn encode_tagged<T: Encodable, V: Encodable>(\n+        &mut self,\n+        tag: T,\n+        value: &V\n+    ) -> Result<(), E::Error> {\n         let start_pos = self.position();\n \n         tag.encode(self)?;\n@@ -762,7 +768,7 @@ where\n \n impl<'a, 'tcx, E> SpecializedEncoder<interpret::AllocId> for CacheEncoder<'a, 'tcx, E>\n where\n-    E: 'a + ty_codec::TyEncoder,\n+    E: 'a + TyEncoder,\n {\n     fn specialized_encode(&mut self, alloc_id: &interpret::AllocId) -> Result<(), Self::Error> {\n         use std::collections::hash_map::Entry;\n@@ -782,10 +788,9 @@ where\n \n impl<'a, 'tcx, E> SpecializedEncoder<Span> for CacheEncoder<'a, 'tcx, E>\n where\n-    E: 'a + ty_codec::TyEncoder,\n+    E: 'a + TyEncoder,\n {\n     fn specialized_encode(&mut self, span: &Span) -> Result<(), Self::Error> {\n-\n         if *span == DUMMY_SP {\n             return TAG_INVALID_SPAN.encode(self);\n         }\n@@ -819,23 +824,36 @@ where\n         if span_data.ctxt == SyntaxContext::root() {\n             TAG_NO_EXPN_DATA.encode(self)\n         } else {\n-            let (expn_id, expn_data) = span_data.ctxt.outer_expn_with_data();\n+            let (expn_id, transparency, expn_data) = span_data.ctxt.outer_mark_with_data();\n             if let Some(pos) = self.expn_data_shorthands.get(&expn_id).cloned() {\n                 TAG_EXPN_DATA_SHORTHAND.encode(self)?;\n                 pos.encode(self)\n             } else {\n                 TAG_EXPN_DATA_INLINE.encode(self)?;\n                 let pos = AbsoluteBytePos::new(self.position());\n                 self.expn_data_shorthands.insert(expn_id, pos);\n-                expn_data.encode(self)\n+                (expn_data, transparency).encode(self)\n             }\n         }\n     }\n }\n \n-impl<'a, 'tcx, E> ty_codec::TyEncoder for CacheEncoder<'a, 'tcx, E>\n+impl<'a, 'tcx, E> SpecializedEncoder<Ident> for CacheEncoder<'a, 'tcx, E>\n where\n     E: 'a + ty_codec::TyEncoder,\n+{\n+    fn specialized_encode(&mut self, _: &Ident) -> Result<(), Self::Error> {\n+        // We don't currently encode enough information to ensure hygiene works\n+        // with incremental, so panic rather than risk incremental bugs.\n+\n+        // FIXME: handle hygiene in incremental.\n+        bug!(\"trying to encode `Ident` for incremental\");\n+    }\n+}\n+\n+impl<'a, 'tcx, E> ty_codec::TyEncoder for CacheEncoder<'a, 'tcx, E>\n+where\n+    E: 'a + TyEncoder,\n {\n     #[inline]\n     fn position(&self) -> usize {\n@@ -845,7 +863,7 @@ where\n \n impl<'a, 'tcx, E> SpecializedEncoder<CrateNum> for CacheEncoder<'a, 'tcx, E>\n where\n-    E: 'a + ty_codec::TyEncoder,\n+    E: 'a + TyEncoder,\n {\n     #[inline]\n     fn specialized_encode(&mut self, cnum: &CrateNum) -> Result<(), Self::Error> {\n@@ -855,7 +873,7 @@ where\n \n impl<'a, 'tcx, E> SpecializedEncoder<Ty<'tcx>> for CacheEncoder<'a, 'tcx, E>\n where\n-    E: 'a + ty_codec::TyEncoder,\n+    E: 'a + TyEncoder,\n {\n     #[inline]\n     fn specialized_encode(&mut self, ty: &Ty<'tcx>) -> Result<(), Self::Error> {\n@@ -866,7 +884,7 @@ where\n \n impl<'a, 'tcx, E> SpecializedEncoder<ty::GenericPredicates<'tcx>> for CacheEncoder<'a, 'tcx, E>\n where\n-    E: 'a + ty_codec::TyEncoder,\n+    E: 'a + TyEncoder,\n {\n     #[inline]\n     fn specialized_encode(&mut self,\n@@ -879,7 +897,7 @@ where\n \n impl<'a, 'tcx, E> SpecializedEncoder<hir::HirId> for CacheEncoder<'a, 'tcx, E>\n where\n-    E: 'a + ty_codec::TyEncoder,\n+    E: 'a + TyEncoder,\n {\n     #[inline]\n     fn specialized_encode(&mut self, id: &hir::HirId) -> Result<(), Self::Error> {\n@@ -897,7 +915,7 @@ where\n \n impl<'a, 'tcx, E> SpecializedEncoder<DefId> for CacheEncoder<'a, 'tcx, E>\n where\n-    E: 'a + ty_codec::TyEncoder,\n+    E: 'a + TyEncoder,\n {\n     #[inline]\n     fn specialized_encode(&mut self, id: &DefId) -> Result<(), Self::Error> {\n@@ -908,7 +926,7 @@ where\n \n impl<'a, 'tcx, E> SpecializedEncoder<LocalDefId> for CacheEncoder<'a, 'tcx, E>\n where\n-    E: 'a + ty_codec::TyEncoder,\n+    E: 'a + TyEncoder,\n {\n     #[inline]\n     fn specialized_encode(&mut self, id: &LocalDefId) -> Result<(), Self::Error> {\n@@ -918,18 +936,18 @@ where\n \n impl<'a, 'tcx, E> SpecializedEncoder<DefIndex> for CacheEncoder<'a, 'tcx, E>\n where\n-    E: 'a + ty_codec::TyEncoder,\n+    E: 'a + TyEncoder,\n {\n     fn specialized_encode(&mut self, _: &DefIndex) -> Result<(), Self::Error> {\n-        bug!(\"Encoding DefIndex without context.\")\n+        bug!(\"encoding `DefIndex` without context\");\n     }\n }\n \n-// NodeIds are not stable across compilation sessions, so we store them in their\n-// HirId representation. This allows use to map them to the current NodeId.\n+// `NodeId`s are not stable across compilation sessions, so we store them in their\n+// `HirId` representation. This allows use to map them to the current `NodeId`.\n impl<'a, 'tcx, E> SpecializedEncoder<NodeId> for CacheEncoder<'a, 'tcx, E>\n where\n-    E: 'a + ty_codec::TyEncoder,\n+    E: 'a + TyEncoder,\n {\n     #[inline]\n     fn specialized_encode(&mut self, node_id: &NodeId) -> Result<(), Self::Error> {\n@@ -946,7 +964,7 @@ impl<'a, 'tcx> SpecializedEncoder<Fingerprint> for CacheEncoder<'a, 'tcx, opaque\n \n impl<'a, 'tcx, E, T> SpecializedEncoder<mir::ClearCrossCrate<T>> for CacheEncoder<'a, 'tcx, E>\n where\n-    E: 'a + ty_codec::TyEncoder,\n+    E: 'a + TyEncoder,\n     T: Encodable,\n {\n     #[inline]\n@@ -975,7 +993,7 @@ macro_rules! encoder_methods {\n \n impl<'a, 'tcx, E> Encoder for CacheEncoder<'a, 'tcx, E>\n where\n-    E: 'a + ty_codec::TyEncoder,\n+    E: 'a + TyEncoder,\n {\n     type Error = E::Error;\n \n@@ -1019,7 +1037,7 @@ impl UseSpecializedDecodable for IntEncodedWithFixedSize {}\n impl SpecializedEncoder<IntEncodedWithFixedSize> for opaque::Encoder {\n     fn specialized_encode(&mut self, x: &IntEncodedWithFixedSize) -> Result<(), Self::Error> {\n         let start_pos = self.position();\n-        for i in 0 .. IntEncodedWithFixedSize::ENCODED_SIZE {\n+        for i in 0..IntEncodedWithFixedSize::ENCODED_SIZE {\n             ((x.0 >> i * 8) as u8).encode(self)?;\n         }\n         let end_pos = self.position();\n@@ -1064,10 +1082,10 @@ where\n             if Q::cache_on_disk(tcx, key.clone(), Some(&entry.value)) {\n                 let dep_node = SerializedDepNodeIndex::new(entry.index.index());\n \n-                // Record position of the cache entry\n+                // Record position of the cache entry.\n                 query_result_index.push((dep_node, AbsoluteBytePos::new(encoder.position())));\n \n-                // Encode the type check tables with the SerializedDepNodeIndex\n+                // Encode the type check tables with the `SerializedDepNodeIndex`\n                 // as tag.\n                 encoder.encode_tagged(dep_node, &entry.value)?;\n             }"}, {"sha": "d199a26475be706b891010fe7100d95ae0aeae40", "filename": "src/librustc/ty/query/plumbing.rs", "status": "modified", "additions": 55, "deletions": 51, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -61,7 +61,7 @@ impl<'tcx, M: QueryConfig<'tcx>> Default for QueryCache<'tcx, M> {\n     }\n }\n \n-// If enabled, send a message to the profile-queries thread\n+// If enabled, sends a message to the profile-queries thread.\n macro_rules! profq_msg {\n     ($tcx:expr, $msg:expr) => {\n         if cfg!(debug_assertions) {\n@@ -72,7 +72,7 @@ macro_rules! profq_msg {\n     }\n }\n \n-// If enabled, format a key using its debug string, which can be\n+// If enabled, formats a key using its debug string, which can be\n // expensive to compute (in terms of time).\n macro_rules! profq_query_msg {\n     ($query:expr, $tcx:expr, $key:expr) => {{\n@@ -98,7 +98,7 @@ pub(super) struct JobOwner<'a, 'tcx, Q: QueryDescription<'tcx>> {\n \n impl<'a, 'tcx, Q: QueryDescription<'tcx>> JobOwner<'a, 'tcx, Q> {\n     /// Either gets a `JobOwner` corresponding the query, allowing us to\n-    /// start executing the query, or it returns with the result of the query.\n+    /// start executing the query, or returns with the result of the query.\n     /// If the query is executing elsewhere, this will wait for it.\n     /// If the query panicked, this will silently panic.\n     ///\n@@ -215,38 +215,38 @@ impl<'a, 'tcx, Q: QueryDescription<'tcx>> Drop for JobOwner<'a, 'tcx, Q> {\n     #[inline(never)]\n     #[cold]\n     fn drop(&mut self) {\n-        // Poison the query so jobs waiting on it panic\n+        // Poison the query so jobs waiting on it panic.\n         let shard = self.cache.get_shard_by_value(&self.key);\n         shard.lock().active.insert(self.key.clone(), QueryResult::Poisoned);\n         // Also signal the completion of the job, so waiters\n-        // will continue execution\n+        // will continue execution.\n         self.job.signal_complete();\n     }\n }\n \n #[derive(Clone)]\n pub struct CycleError<'tcx> {\n-    /// The query and related span which uses the cycle\n+    /// The query and related span that uses the cycle.\n     pub(super) usage: Option<(Span, Query<'tcx>)>,\n     pub(super) cycle: Vec<QueryInfo<'tcx>>,\n }\n \n-/// The result of `try_get_lock`\n+/// The result of `try_get_lock`.\n pub(super) enum TryGetJob<'a, 'tcx, D: QueryDescription<'tcx>> {\n     /// The query is not yet started. Contains a guard to the cache eventually used to start it.\n     NotYetStarted(JobOwner<'a, 'tcx, D>),\n \n     /// The query was already completed.\n-    /// Returns the result of the query and its dep node index\n-    /// if it succeeded or a cycle error if it failed\n+    /// Returns the result of the query and its dep-node index\n+    /// if it succeeded or a cycle error if it failed.\n     JobCompleted((D::Value, DepNodeIndex)),\n \n     /// Trying to execute the query resulted in a cycle.\n     Cycle(D::Value),\n }\n \n impl<'tcx> TyCtxt<'tcx> {\n-    /// Executes a job by changing the ImplicitCtxt to point to the\n+    /// Executes a job by changing the `ImplicitCtxt` to point to the\n     /// new query job while it executes. It returns the diagnostics\n     /// captured during execution and the actual result.\n     #[inline(always)]\n@@ -259,11 +259,11 @@ impl<'tcx> TyCtxt<'tcx> {\n     where\n         F: FnOnce(TyCtxt<'tcx>) -> R,\n     {\n-        // The TyCtxt stored in TLS has the same global interner lifetime\n+        // The `TyCtxt` stored in TLS has the same global interner lifetime\n         // as `self`, so we use `with_related_context` to relate the 'tcx lifetimes\n-        // when accessing the ImplicitCtxt\n+        // when accessing the `ImplicitCtxt`.\n         tls::with_related_context(self, move |current_icx| {\n-            // Update the ImplicitCtxt to point to our new query job\n+            // Update the `ImplicitCtxt` to point to our new query job.\n             let new_icx = tls::ImplicitCtxt {\n                 tcx: self.global_tcx(),\n                 query: Some(job),\n@@ -272,7 +272,7 @@ impl<'tcx> TyCtxt<'tcx> {\n                 task_deps: current_icx.task_deps,\n             };\n \n-            // Use the ImplicitCtxt while we execute the query\n+            // Use the `ImplicitCtxt` while we execute the query.\n             tls::enter_context(&new_icx, |_| {\n                 compute(self.global_tcx())\n             })\n@@ -372,7 +372,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         };\n \n         // Fast path for when incr. comp. is off. `to_dep_node` is\n-        // expensive for some DepKinds.\n+        // expensive for some `DepKind`s.\n         if !self.dep_graph.is_fully_enabled() {\n             let null_dep_node = DepNode::new_no_params(crate::dep_graph::DepKind::Null);\n             return self.force_query_with_job::<Q>(key, job, null_dep_node).0;\n@@ -410,7 +410,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         if !Q::EVAL_ALWAYS {\n             // The diagnostics for this query will be\n             // promoted to the current session during\n-            // try_mark_green(), so we can ignore them here.\n+            // `try_mark_green()`, so we can ignore them here.\n             let loaded = self.start_query(job.job.clone(), None, |tcx| {\n                 let marked = tcx.dep_graph.try_mark_green_and_read(tcx, &dep_node);\n                 marked.map(|(prev_dep_node_index, dep_node_index)| {\n@@ -441,22 +441,22 @@ impl<'tcx> TyCtxt<'tcx> {\n         dep_node: &DepNode,\n     ) -> Q::Value {\n         // Note this function can be called concurrently from the same query\n-        // We must ensure that this is handled correctly\n+        // We must ensure that this is handled correctly.\n \n         debug_assert!(self.dep_graph.is_green(dep_node));\n \n-        // First we try to load the result from the on-disk cache\n+        // First we try to load the result from the on-disk cache.\n         let result = if Q::cache_on_disk(self.global_tcx(), key.clone(), None) &&\n                         self.sess.opts.debugging_opts.incremental_queries {\n             self.sess.profiler(|p| p.incremental_load_result_start(Q::NAME));\n             let result = Q::try_load_from_disk(self.global_tcx(), prev_dep_node_index);\n             self.sess.profiler(|p| p.incremental_load_result_end(Q::NAME));\n \n             // We always expect to find a cached result for things that\n-            // can be forced from DepNode.\n+            // can be forced from `DepNode`.\n             debug_assert!(!dep_node.kind.can_reconstruct_query_key() ||\n                           result.is_some(),\n-                          \"Missing on-disk cache entry for {:?}\",\n+                          \"missing on-disk cache entry for {:?}\",\n                           dep_node);\n             result\n         } else {\n@@ -475,8 +475,7 @@ impl<'tcx> TyCtxt<'tcx> {\n \n             self.sess.profiler(|p| p.start_query(Q::NAME));\n \n-            // The dep-graph for this computation is already in\n-            // place\n+            // The dep-graph for this computation is already in-place.\n             let result = self.dep_graph.with_ignore(|| {\n                 Q::compute(self, key)\n             });\n@@ -485,7 +484,7 @@ impl<'tcx> TyCtxt<'tcx> {\n             result\n         };\n \n-        // If -Zincremental-verify-ich is specified, re-hash results from\n+        // If `-Zincremental-verify-ich` is specified, re-hash results from\n         // the cache and make sure that they have the expected fingerprint.\n         if unlikely!(self.sess.opts.debugging_opts.incremental_verify_ich) {\n             self.incremental_verify_ich::<Q>(&result, dep_node, dep_node_index);\n@@ -508,10 +507,12 @@ impl<'tcx> TyCtxt<'tcx> {\n     ) {\n         use crate::ich::Fingerprint;\n \n-        assert!(Some(self.dep_graph.fingerprint_of(dep_node_index)) ==\n+        assert!(\n+            Some(self.dep_graph.fingerprint_of(dep_node_index)) ==\n                 self.dep_graph.prev_fingerprint_of(dep_node),\n-                \"Fingerprint for green query instance not loaded \\\n-                    from cache: {:?}\", dep_node);\n+            \"fingerprint for green query instance not loaded from cache: {:?}\",\n+            dep_node,\n+        );\n \n         debug!(\"BEGIN verify_ich({:?})\", dep_node);\n         let mut hcx = self.create_stable_hashing_context();\n@@ -521,8 +522,11 @@ impl<'tcx> TyCtxt<'tcx> {\n \n         let old_hash = self.dep_graph.fingerprint_of(dep_node_index);\n \n-        assert!(new_hash == old_hash, \"Found unstable fingerprints \\\n-            for {:?}\", dep_node);\n+        assert!(\n+            new_hash == old_hash,\n+            \"found unstable fingerprints for {:?}\",\n+            dep_node,\n+        );\n     }\n \n     #[inline(always)]\n@@ -534,11 +538,11 @@ impl<'tcx> TyCtxt<'tcx> {\n     ) -> (Q::Value, DepNodeIndex) {\n         // If the following assertion triggers, it can have two reasons:\n         // 1. Something is wrong with DepNode creation, either here or\n-        //    in DepGraph::try_mark_green()\n-        // 2. Two distinct query keys get mapped to the same DepNode\n-        //    (see for example #48923)\n+        //    in `DepGraph::try_mark_green()`.\n+        // 2. Two distinct query keys get mapped to the same `DepNode`\n+        //    (see for example #48923).\n         assert!(!self.dep_graph.dep_node_exists(&dep_node),\n-                \"Forcing query with already existing DepNode.\\n\\\n+                \"forcing query with already existing `DepNode`\\n\\\n                  - query-key: {:?}\\n\\\n                  - dep-node: {:?}\",\n                 key, dep_node);\n@@ -584,7 +588,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n \n     /// Ensure that either this query has all green inputs or been executed.\n-    /// Executing query::ensure(D) is considered a read of the dep-node D.\n+    /// Executing `query::ensure(D)` is considered a read of the dep-node `D`.\n     ///\n     /// This function is particularly useful when executing passes for their\n     /// side-effects -- e.g., in order to report errors for erroneous programs.\n@@ -899,13 +903,13 @@ macro_rules! define_queries_inner {\n                 }\n             }\n \n-            // FIXME(eddyb) Get more valid Span's on queries.\n+            // FIXME(eddyb) Get more valid `Span`s on queries.\n             pub fn default_span(&self, tcx: TyCtxt<$tcx>, span: Span) -> Span {\n                 if !span.is_dummy() {\n                     return span;\n                 }\n-                // The def_span query is used to calculate default_span,\n-                // so exit to avoid infinite recursion\n+                // The `def_span` query is used to calculate `default_span`,\n+                // so exit to avoid infinite recursion.\n                 if let Query::def_span(..) = *self {\n                     return span\n                 }\n@@ -1116,7 +1120,7 @@ macro_rules! define_provider_struct {\n         impl<$tcx> Default for Providers<$tcx> {\n             fn default() -> Self {\n                 $(fn $name<$tcx>(_: TyCtxt<$tcx>, key: $K) -> $R {\n-                    bug!(\"tcx.{}({:?}) unsupported by its crate\",\n+                    bug!(\"`tcx.{}({:?})` unsupported by its crate\",\n                          stringify!($name), key);\n                 })*\n                 Providers { $($name),* }\n@@ -1128,26 +1132,26 @@ macro_rules! define_provider_struct {\n \n /// The red/green evaluation system will try to mark a specific DepNode in the\n /// dependency graph as green by recursively trying to mark the dependencies of\n-/// that DepNode as green. While doing so, it will sometimes encounter a DepNode\n+/// that `DepNode` as green. While doing so, it will sometimes encounter a `DepNode`\n /// where we don't know if it is red or green and we therefore actually have\n /// to recompute its value in order to find out. Since the only piece of\n-/// information that we have at that point is the DepNode we are trying to\n+/// information that we have at that point is the `DepNode` we are trying to\n /// re-evaluate, we need some way to re-run a query from just that. This is what\n /// `force_from_dep_node()` implements.\n ///\n-/// In the general case, a DepNode consists of a DepKind and an opaque\n+/// In the general case, a `DepNode` consists of a `DepKind` and an opaque\n /// GUID/fingerprint that will uniquely identify the node. This GUID/fingerprint\n /// is usually constructed by computing a stable hash of the query-key that the\n-/// DepNode corresponds to. Consequently, it is not in general possible to go\n+/// `DepNode` corresponds to. Consequently, it is not in general possible to go\n /// back from hash to query-key (since hash functions are not reversible). For\n /// this reason `force_from_dep_node()` is expected to fail from time to time\n-/// because we just cannot find out, from the DepNode alone, what the\n+/// because we just cannot find out, from the `DepNode` alone, what the\n /// corresponding query-key is and therefore cannot re-run the query.\n ///\n /// The system deals with this case letting `try_mark_green` fail which forces\n /// the root query to be re-evaluated.\n ///\n-/// Now, if force_from_dep_node() would always fail, it would be pretty useless.\n+/// Now, if `force_from_dep_node()` would always fail, it would be pretty useless.\n /// Fortunately, we can use some contextual information that will allow us to\n /// reconstruct query-keys for certain kinds of `DepNode`s. In particular, we\n /// enforce by construction that the GUID/fingerprint of certain `DepNode`s is a\n@@ -1171,9 +1175,9 @@ macro_rules! define_provider_struct {\n pub fn force_from_dep_node(tcx: TyCtxt<'_>, dep_node: &DepNode) -> bool {\n     use crate::dep_graph::RecoverKey;\n \n-    // We must avoid ever having to call force_from_dep_node() for a\n-    // DepNode::codegen_unit:\n-    // Since we cannot reconstruct the query key of a DepNode::codegen_unit, we\n+    // We must avoid ever having to call `force_from_dep_node()` for a\n+    // `DepNode::codegen_unit`:\n+    // Since we cannot reconstruct the query key of a `DepNode::codegen_unit`, we\n     // would always end up having to evaluate the first caller of the\n     // `codegen_unit` query that *is* reconstructible. This might very well be\n     // the `compile_codegen_unit` query, thus re-codegenning the whole CGU just\n@@ -1196,7 +1200,7 @@ pub fn force_from_dep_node(tcx: TyCtxt<'_>, dep_node: &DepNode) -> bool {\n             if let Some(def_id) = dep_node.extract_def_id(tcx) {\n                 def_id\n             } else {\n-                // return from the whole function\n+                // Return from the whole function.\n                 return false\n             }\n         }\n@@ -1224,20 +1228,20 @@ pub fn force_from_dep_node(tcx: TyCtxt<'_>, dep_node: &DepNode) -> bool {\n \n     rustc_dep_node_force!([dep_node, tcx]\n         // These are inputs that are expected to be pre-allocated and that\n-        // should therefore always be red or green already\n+        // should therefore always be red or green already.\n         DepKind::AllLocalTraitImpls |\n         DepKind::Krate |\n         DepKind::CrateMetadata |\n         DepKind::HirBody |\n         DepKind::Hir |\n \n-        // This are anonymous nodes\n+        // These are anonymous nodes.\n         DepKind::TraitSelect |\n \n         // We don't have enough information to reconstruct the query key of\n-        // these\n+        // these.\n         DepKind::CompileCodegenUnit => {\n-            bug!(\"force_from_dep_node() - Encountered {:?}\", dep_node)\n+            bug!(\"force_from_dep_node: encountered {:?}\", dep_node)\n         }\n \n         DepKind::Analysis => { force!(analysis, krate!()); }"}, {"sha": "565447dd7e1afd7fc0fc63aff0b9e401383b70b3", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 3, "deletions": 21, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -8,7 +8,7 @@ use crate::hir::def_id::DefId;\n use crate::ty::subst::{Kind, UnpackedKind, SubstsRef};\n use crate::ty::{self, Ty, TyCtxt, TypeFoldable};\n use crate::ty::error::{ExpectedFound, TypeError};\n-use crate::mir::interpret::{ConstValue, Scalar, GlobalId};\n+use crate::mir::interpret::{ConstValue, Scalar};\n use std::rc::Rc;\n use std::iter;\n use rustc_target::spec::abi;\n@@ -551,26 +551,8 @@ pub fn super_relate_consts<R: TypeRelation<'tcx>>(\n     let tcx = relation.tcx();\n \n     let eagerly_eval = |x: &'tcx ty::Const<'tcx>| {\n-        if let ConstValue::Unevaluated(def_id, substs) = x.val {\n-            // FIXME(eddyb) get the right param_env.\n-            let param_env = ty::ParamEnv::empty();\n-            if !substs.has_local_value() {\n-                let instance = ty::Instance::resolve(\n-                    tcx.global_tcx(),\n-                    param_env,\n-                    def_id,\n-                    substs,\n-                );\n-                if let Some(instance) = instance {\n-                    let cid = GlobalId {\n-                        instance,\n-                        promoted: None,\n-                    };\n-                    if let Ok(ct) = tcx.const_eval(param_env.and(cid)) {\n-                        return ct.val;\n-                    }\n-                }\n-            }\n+        if !x.val.has_local_value() {\n+            return x.eval(tcx, relation.param_env()).val;\n         }\n         x.val\n     };"}, {"sha": "ec7cf1a13c5964f81b47fa94aff9e807a12db82c", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -748,6 +748,7 @@ impl<'a, 'tcx> Lift<'tcx> for ty::error::TypeError<'a> {\n             Sorts(ref x) => return tcx.lift(x).map(Sorts),\n             ExistentialMismatch(ref x) => return tcx.lift(x).map(ExistentialMismatch),\n             ConstMismatch(ref x) => return tcx.lift(x).map(ConstMismatch),\n+            IntrinsicCast => IntrinsicCast,\n         })\n     }\n }\n@@ -1338,6 +1339,7 @@ EnumTypeFoldableImpl! {\n         (ty::error::TypeError::Sorts)(x),\n         (ty::error::TypeError::ExistentialMismatch)(x),\n         (ty::error::TypeError::ConstMismatch)(x),\n+        (ty::error::TypeError::IntrinsicCast),\n     }\n }\n "}, {"sha": "e73a51e6f78e5272eee86659d566340f87a7567d", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 23, "deletions": 12, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -86,6 +86,7 @@ impl BoundRegion {\n /// AST structure in `libsyntax/ast.rs` as well.\n #[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash,\n          RustcEncodable, RustcDecodable, HashStable, Debug)]\n+#[cfg_attr(not(bootstrap), rustc_diagnostic_item = \"TyKind\")]\n pub enum TyKind<'tcx> {\n     /// The primitive boolean type. Written as `bool`.\n     Bool,\n@@ -385,7 +386,7 @@ impl<'tcx> ClosureSubsts<'tcx> {\n         let ty = self.closure_sig_ty(def_id, tcx);\n         match ty.sty {\n             ty::FnPtr(sig) => sig,\n-            _ => bug!(\"closure_sig_ty is not a fn-ptr: {:?}\", ty),\n+            _ => bug!(\"closure_sig_ty is not a fn-ptr: {:?}\", ty.sty),\n         }\n     }\n }\n@@ -643,7 +644,7 @@ impl<'tcx> Binder<ExistentialPredicate<'tcx>> {\n impl<'tcx> rustc_serialize::UseSpecializedDecodable for &'tcx List<ExistentialPredicate<'tcx>> {}\n \n impl<'tcx> List<ExistentialPredicate<'tcx>> {\n-    /// Returns the \"principal def id\" of this set of existential predicates.\n+    /// Returns the \"principal `DefId`\" of this set of existential predicates.\n     ///\n     /// A Rust trait object type consists (in addition to a lifetime bound)\n     /// of a set of trait bounds, which are separated into any number\n@@ -1051,7 +1052,7 @@ impl<'tcx> PolyGenSig<'tcx> {\n     }\n }\n \n-/// Signature of a function type, which I have arbitrarily\n+/// Signature of a function type, which we have arbitrarily\n /// decided to use to refer to the input/output types.\n ///\n /// - `inputs`: is the list of arguments and their modes.\n@@ -1075,7 +1076,8 @@ impl<'tcx> FnSig<'tcx> {\n         self.inputs_and_output[self.inputs_and_output.len() - 1]\n     }\n \n-    // Create a minimal `FnSig` to be used when encountering a `TyKind::Error` in a fallible method\n+    // Creates a minimal `FnSig` to be used when encountering a `TyKind::Error` in a fallible\n+    // method.\n     fn fake() -> FnSig<'tcx> {\n         FnSig {\n             inputs_and_output: List::empty(),\n@@ -1117,7 +1119,6 @@ impl<'tcx> PolyFnSig<'tcx> {\n \n pub type CanonicalPolyFnSig<'tcx> = Canonical<'tcx, Binder<FnSig<'tcx>>>;\n \n-\n #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord,\n          Hash, RustcEncodable, RustcDecodable, HashStable)]\n pub struct ParamTy {\n@@ -2299,23 +2300,33 @@ impl<'tcx> Const<'tcx> {\n         assert_eq!(self.ty, ty);\n         // if `ty` does not depend on generic parameters, use an empty param_env\n         let size = tcx.layout_of(param_env.with_reveal_all().and(ty)).ok()?.size;\n+        self.eval(tcx, param_env).val.try_to_bits(size)\n+    }\n+\n+    #[inline]\n+    pub fn eval(\n+        &self,\n+        tcx: TyCtxt<'tcx>,\n+        param_env: ParamEnv<'tcx>,\n+    ) -> &Const<'tcx> {\n+        // FIXME(const_generics): this doesn't work right now,\n+        // because it tries to relate an `Infer` to a `Param`.\n         match self.val {\n-            // FIXME(const_generics): this doesn't work right now,\n-            // because it tries to relate an `Infer` to a `Param`.\n             ConstValue::Unevaluated(did, substs) => {\n                 // if `substs` has no unresolved components, use and empty param_env\n                 let (param_env, substs) = param_env.with_reveal_all().and(substs).into_parts();\n                 // try to resolve e.g. associated constants to their definition on an impl\n-                let instance = ty::Instance::resolve(tcx, param_env, did, substs)?;\n+                let instance = match ty::Instance::resolve(tcx, param_env, did, substs) {\n+                    Some(instance) => instance,\n+                    None => return self,\n+                };\n                 let gid = GlobalId {\n                     instance,\n                     promoted: None,\n                 };\n-                let evaluated = tcx.const_eval(param_env.and(gid)).ok()?;\n-                evaluated.val.try_to_bits(size)\n+                tcx.const_eval(param_env.and(gid)).unwrap_or(self)\n             },\n-            // otherwise just extract a `ConstValue`'s bits if possible\n-            _ => self.val.try_to_bits(size),\n+            _ => self,\n         }\n     }\n "}, {"sha": "a08c82a0ae82fdd7a559b14a7520d1f7dacd1263", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -709,8 +709,10 @@ impl<'tcx> TyCtxt<'tcx> {\n                 substs: SubstsRef<'tcx>,\n             ) -> Option<Ty<'tcx>> {\n                 if self.found_recursion {\n-                    None\n-                } else if self.seen_opaque_tys.insert(def_id) {\n+                    return None;\n+                }\n+                let substs = substs.fold_with(self);\n+                if self.seen_opaque_tys.insert(def_id) {\n                     let generic_ty = self.tcx.type_of(def_id);\n                     let concrete_ty = generic_ty.subst(self.tcx, substs);\n                     let expanded_ty = self.fold_ty(concrete_ty);\n@@ -998,7 +1000,7 @@ impl<'tcx> ty::TyS<'tcx> {\n \n fn is_copy_raw<'tcx>(tcx: TyCtxt<'tcx>, query: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool {\n     let (param_env, ty) = query.into_parts();\n-    let trait_def_id = tcx.require_lang_item(lang_items::CopyTraitLangItem);\n+    let trait_def_id = tcx.require_lang_item(lang_items::CopyTraitLangItem, None);\n     tcx.infer_ctxt()\n         .enter(|infcx| traits::type_known_to_meet_bound_modulo_regions(\n             &infcx,\n@@ -1011,7 +1013,7 @@ fn is_copy_raw<'tcx>(tcx: TyCtxt<'tcx>, query: ty::ParamEnvAnd<'tcx, Ty<'tcx>>)\n \n fn is_sized_raw<'tcx>(tcx: TyCtxt<'tcx>, query: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool {\n     let (param_env, ty) = query.into_parts();\n-    let trait_def_id = tcx.require_lang_item(lang_items::SizedTraitLangItem);\n+    let trait_def_id = tcx.require_lang_item(lang_items::SizedTraitLangItem, None);\n     tcx.infer_ctxt()\n         .enter(|infcx| traits::type_known_to_meet_bound_modulo_regions(\n             &infcx,\n@@ -1024,7 +1026,7 @@ fn is_sized_raw<'tcx>(tcx: TyCtxt<'tcx>, query: ty::ParamEnvAnd<'tcx, Ty<'tcx>>)\n \n fn is_freeze_raw<'tcx>(tcx: TyCtxt<'tcx>, query: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool {\n     let (param_env, ty) = query.into_parts();\n-    let trait_def_id = tcx.require_lang_item(lang_items::FreezeTraitLangItem);\n+    let trait_def_id = tcx.require_lang_item(lang_items::FreezeTraitLangItem, None);\n     tcx.infer_ctxt()\n         .enter(|infcx| traits::type_known_to_meet_bound_modulo_regions(\n             &infcx,"}, {"sha": "d6de217f79c29c7086a8dc86d6140ddd1122dcef", "filename": "src/librustc/ty/wf.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Fty%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc%2Fty%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwf.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -221,7 +221,7 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n         if !subty.has_escaping_bound_vars() {\n             let cause = self.cause(cause);\n             let trait_ref = ty::TraitRef {\n-                def_id: self.infcx.tcx.require_lang_item(lang_items::SizedTraitLangItem),\n+                def_id: self.infcx.tcx.require_lang_item(lang_items::SizedTraitLangItem, None),\n                 substs: self.infcx.tcx.mk_substs_trait(subty, &[]),\n             };\n             self.out.push(traits::Obligation::new(cause, self.param_env, trait_ref.to_predicate()));"}, {"sha": "18d968fbddd9b6b319798a369251ec85bab2bce0", "filename": "src/librustc_apfloat/ieee.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_apfloat%2Fieee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_apfloat%2Fieee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_apfloat%2Fieee.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -1,13 +1,13 @@\n use crate::{Category, ExpInt, IEK_INF, IEK_NAN, IEK_ZERO};\n use crate::{Float, FloatConvert, ParseError, Round, Status, StatusAnd};\n \n+use core::cmp::{self, Ordering};\n+use core::convert::TryFrom;\n+use core::fmt::{self, Write};\n+use core::marker::PhantomData;\n+use core::mem;\n+use core::ops::Neg;\n use smallvec::{SmallVec, smallvec};\n-use std::cmp::{self, Ordering};\n-use std::convert::TryFrom;\n-use std::fmt::{self, Write};\n-use std::marker::PhantomData;\n-use std::mem;\n-use std::ops::Neg;\n \n #[must_use]\n pub struct IeeeFloat<S> {\n@@ -2287,8 +2287,8 @@ impl Loss {\n /// Implementation details of IeeeFloat significands, such as big integer arithmetic.\n /// As a rule of thumb, no functions in this module should dynamically allocate.\n mod sig {\n-    use std::cmp::Ordering;\n-    use std::mem;\n+    use core::cmp::Ordering;\n+    use core::mem;\n     use super::{ExpInt, Limb, LIMB_BITS, limbs_for_bits, Loss};\n \n     pub(super) fn is_all_zeros(limbs: &[Limb]) -> bool {"}, {"sha": "1190cea21acc3cf364b89018d7798462f9b7c4b2", "filename": "src/librustc_apfloat/lib.rs", "status": "modified", "additions": 20, "deletions": 16, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_apfloat%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_apfloat%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_apfloat%2Flib.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -31,15 +31,19 @@\n //! This API is completely unstable and subject to change.\n \n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n+#![no_std]\n #![forbid(unsafe_code)]\n \n #![feature(nll)]\n \n-use std::cmp::Ordering;\n-use std::fmt;\n-use std::ops::{Neg, Add, Sub, Mul, Div, Rem};\n-use std::ops::{AddAssign, SubAssign, MulAssign, DivAssign, RemAssign};\n-use std::str::FromStr;\n+#[macro_use]\n+extern crate alloc;\n+\n+use core::cmp::Ordering;\n+use core::fmt;\n+use core::ops::{Neg, Add, Sub, Mul, Div, Rem};\n+use core::ops::{AddAssign, SubAssign, MulAssign, DivAssign, RemAssign};\n+use core::str::FromStr;\n \n bitflags::bitflags! {\n     /// IEEE-754R 7: Default exception handling.\n@@ -587,7 +591,7 @@ macro_rules! float_common_impls {\n             }\n         }\n \n-        impl<$t> ::std::str::FromStr for $ty<$t> where Self: Float {\n+        impl<$t> ::core::str::FromStr for $ty<$t> where Self: Float {\n             type Err = ParseError;\n             fn from_str(s: &str) -> Result<Self, ParseError> {\n                 Self::from_str_r(s, Round::NearestTiesToEven).map(|x| x.value)\n@@ -596,66 +600,66 @@ macro_rules! float_common_impls {\n \n         // Rounding ties to the nearest even, by default.\n \n-        impl<$t> ::std::ops::Add for $ty<$t> where Self: Float {\n+        impl<$t> ::core::ops::Add for $ty<$t> where Self: Float {\n             type Output = StatusAnd<Self>;\n             fn add(self, rhs: Self) -> StatusAnd<Self> {\n                 self.add_r(rhs, Round::NearestTiesToEven)\n             }\n         }\n \n-        impl<$t> ::std::ops::Sub for $ty<$t> where Self: Float {\n+        impl<$t> ::core::ops::Sub for $ty<$t> where Self: Float {\n             type Output = StatusAnd<Self>;\n             fn sub(self, rhs: Self) -> StatusAnd<Self> {\n                 self.sub_r(rhs, Round::NearestTiesToEven)\n             }\n         }\n \n-        impl<$t> ::std::ops::Mul for $ty<$t> where Self: Float {\n+        impl<$t> ::core::ops::Mul for $ty<$t> where Self: Float {\n             type Output = StatusAnd<Self>;\n             fn mul(self, rhs: Self) -> StatusAnd<Self> {\n                 self.mul_r(rhs, Round::NearestTiesToEven)\n             }\n         }\n \n-        impl<$t> ::std::ops::Div for $ty<$t> where Self: Float {\n+        impl<$t> ::core::ops::Div for $ty<$t> where Self: Float {\n             type Output = StatusAnd<Self>;\n             fn div(self, rhs: Self) -> StatusAnd<Self> {\n                 self.div_r(rhs, Round::NearestTiesToEven)\n             }\n         }\n \n-        impl<$t> ::std::ops::Rem for $ty<$t> where Self: Float {\n+        impl<$t> ::core::ops::Rem for $ty<$t> where Self: Float {\n             type Output = StatusAnd<Self>;\n             fn rem(self, rhs: Self) -> StatusAnd<Self> {\n                 self.c_fmod(rhs)\n             }\n         }\n \n-        impl<$t> ::std::ops::AddAssign for $ty<$t> where Self: Float {\n+        impl<$t> ::core::ops::AddAssign for $ty<$t> where Self: Float {\n             fn add_assign(&mut self, rhs: Self) {\n                 *self = (*self + rhs).value;\n             }\n         }\n \n-        impl<$t> ::std::ops::SubAssign for $ty<$t> where Self: Float {\n+        impl<$t> ::core::ops::SubAssign for $ty<$t> where Self: Float {\n             fn sub_assign(&mut self, rhs: Self) {\n                 *self = (*self - rhs).value;\n             }\n         }\n \n-        impl<$t> ::std::ops::MulAssign for $ty<$t> where Self: Float {\n+        impl<$t> ::core::ops::MulAssign for $ty<$t> where Self: Float {\n             fn mul_assign(&mut self, rhs: Self) {\n                 *self = (*self * rhs).value;\n             }\n         }\n \n-        impl<$t> ::std::ops::DivAssign for $ty<$t> where Self: Float {\n+        impl<$t> ::core::ops::DivAssign for $ty<$t> where Self: Float {\n             fn div_assign(&mut self, rhs: Self) {\n                 *self = (*self / rhs).value;\n             }\n         }\n \n-        impl<$t> ::std::ops::RemAssign for $ty<$t> where Self: Float {\n+        impl<$t> ::core::ops::RemAssign for $ty<$t> where Self: Float {\n             fn rem_assign(&mut self, rhs: Self) {\n                 *self = (*self % rhs).value;\n             }"}, {"sha": "8e2e390568e48261e5e0ea262dfd89a64ad07bc4", "filename": "src/librustc_apfloat/ppc.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_apfloat%2Fppc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_apfloat%2Fppc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_apfloat%2Fppc.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -1,9 +1,9 @@\n use crate::{Category, ExpInt, Float, FloatConvert, Round, ParseError, Status, StatusAnd};\n use crate::ieee;\n \n-use std::cmp::Ordering;\n-use std::fmt;\n-use std::ops::Neg;\n+use core::cmp::Ordering;\n+use core::fmt;\n+use core::ops::Neg;\n \n #[must_use]\n #[derive(Copy, Clone, PartialEq, PartialOrd, Debug)]"}, {"sha": "cc856ba68fbb7f1e86053adc8f8818f6e8237ef7", "filename": "src/librustc_asan/build.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_asan%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_asan%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_asan%2Fbuild.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -4,6 +4,9 @@ use build_helper::sanitizer_lib_boilerplate;\n use cmake::Config;\n \n fn main() {\n+    if env::var(\"RUSTC_BUILD_SANITIZERS\") != Ok(\"1\".to_string()) {\n+        return;\n+    }\n     if let Some(llvm_config) = env::var_os(\"LLVM_CONFIG\") {\n         build_helper::restore_library_path();\n "}, {"sha": "23d5480c60562b5811acf8baff6d091a1fea1fa8", "filename": "src/librustc_ast_borrowck/borrowck/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_ast_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_ast_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_borrowck%2Fborrowck%2Fmod.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -9,7 +9,6 @@ use InteriorKind::*;\n \n use rustc::hir::HirId;\n use rustc::hir::Node;\n-use rustc::cfg;\n use rustc::middle::borrowck::{BorrowCheckResult, SignalledError};\n use rustc::hir::def_id::{DefId, LocalDefId};\n use rustc::middle::mem_categorization as mc;\n@@ -28,6 +27,7 @@ use log::debug;\n \n use rustc::hir;\n \n+use crate::cfg;\n use crate::dataflow::{DataFlowContext, BitwiseOperator, DataFlowOperator, KillFrom};\n \n pub mod check_loans;"}, {"sha": "67d818161b1b5d2a6cde7ba12356049b46ebed02", "filename": "src/librustc_ast_borrowck/borrowck/move_data.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_ast_borrowck%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_ast_borrowck%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_borrowck%2Fborrowck%2Fmove_data.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -4,7 +4,7 @@\n use crate::dataflow::{DataFlowContext, BitwiseOperator, DataFlowOperator, KillFrom};\n \n use crate::borrowck::*;\n-use rustc::cfg;\n+use crate::cfg;\n use rustc::ty::{self, TyCtxt};\n use rustc::util::nodemap::FxHashMap;\n "}, {"sha": "0dc999083a91a93c88ffcf3f0419657ad0ddc408", "filename": "src/librustc_ast_borrowck/cfg/construct.rs", "status": "renamed", "additions": 83, "deletions": 71, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_ast_borrowck%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_ast_borrowck%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_borrowck%2Fcfg%2Fconstruct.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -1,11 +1,12 @@\n use crate::cfg::*;\n-use crate::middle::region;\n-use rustc_data_structures::graph::implementation as graph;\n-use crate::ty::{self, TyCtxt};\n \n-use crate::hir::{self, PatKind};\n-use crate::hir::def_id::DefId;\n-use crate::hir::ptr::P;\n+use rustc::hir::{self, PatKind};\n+use rustc::hir::def_id::DefId;\n+use rustc::hir::ptr::P;\n+use rustc::middle::region;\n+use rustc::ty::{self, TyCtxt};\n+\n+use rustc_data_structures::graph::implementation as graph;\n \n struct CFGBuilder<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n@@ -19,18 +20,18 @@ struct CFGBuilder<'a, 'tcx> {\n \n #[derive(Copy, Clone)]\n struct BlockScope {\n-    block_expr_id: hir::ItemLocalId, // id of breakable block expr node\n+    block_expr_id: hir::ItemLocalId, // ID of breakable block expr node\n     break_index: CFGIndex, // where to go on `break`\n }\n \n #[derive(Copy, Clone)]\n struct LoopScope {\n-    loop_id: hir::ItemLocalId,     // id of loop/while node\n+    loop_id: hir::ItemLocalId, // ID of `loop`/`while` node\n     continue_index: CFGIndex, // where to go on a `loop`\n-    break_index: CFGIndex,    // where to go on a `break`\n+    break_index: CFGIndex, // where to go on a `break`\n }\n \n-pub fn construct(tcx: TyCtxt<'_>, body: &hir::Body) -> CFG {\n+pub(super) fn construct(tcx: TyCtxt<'_>, body: &hir::Body) -> CFG {\n     let mut graph = graph::Graph::new();\n     let entry = graph.add_node(CFGNodeData::Entry);\n \n@@ -103,9 +104,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 let init_exit = self.opt_expr(&local.init, pred);\n                 self.pat(&local.pat, init_exit)\n             }\n-            hir::StmtKind::Item(_) => {\n-                pred\n-            }\n+            hir::StmtKind::Item(_) => pred,\n             hir::StmtKind::Expr(ref expr) |\n             hir::StmtKind::Semi(ref expr) => {\n                 self.expr(&expr, pred)\n@@ -154,12 +153,12 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n         }\n     }\n \n-    fn pats_all<'b, I: Iterator<Item=&'b P<hir::Pat>>>(\n+    /// Handles case where all of the patterns must match.\n+    fn pats_all<'b, I: Iterator<Item = &'b P<hir::Pat>>>(\n         &mut self,\n         pats: I,\n-        pred: CFGIndex\n+        pred: CFGIndex,\n     ) -> CFGIndex {\n-        //! Handles case where all of the patterns must match.\n         pats.fold(pred, |pred, pat| self.pat(&pat, pred))\n     }\n \n@@ -185,15 +184,15 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 // Note that `break` and `loop` statements\n                 // may cause additional edges.\n \n-                let loopback = self.add_dummy_node(&[pred]);              // 1\n-                let expr_exit = self.add_ast_node(expr.hir_id.local_id, &[]);          // 2\n+                let loopback = self.add_dummy_node(&[pred]); // 1\n+                let expr_exit = self.add_ast_node(expr.hir_id.local_id, &[]); // 2\n                 self.loop_scopes.push(LoopScope {\n                     loop_id: expr.hir_id.local_id,\n                     continue_index: loopback,\n                     break_index: expr_exit,\n                 });\n-                let body_exit = self.block(&body, loopback);           // 3\n-                self.add_contained_edge(body_exit, loopback);            // 4\n+                let body_exit = self.block(&body, loopback); // 3\n+                self.add_contained_edge(body_exit, loopback); // 4\n                 self.loop_scopes.pop();\n                 expr_exit\n             }\n@@ -217,9 +216,9 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 //    v 3  v 4\n                 //   [..exit..]\n                 //\n-                let l_exit = self.expr(&l, pred);                      // 1\n-                let r_exit = self.expr(&r, l_exit);                    // 2\n-                self.add_ast_node(expr.hir_id.local_id, &[l_exit, r_exit])            // 3,4\n+                let l_exit = self.expr(&l, pred); // 1\n+                let r_exit = self.expr(&r, l_exit); // 2\n+                self.add_ast_node(expr.hir_id.local_id, &[l_exit, r_exit]) // 3,4\n             }\n \n             hir::ExprKind::Ret(ref v) => {\n@@ -313,11 +312,13 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n         }\n     }\n \n-    fn call<'b, I: Iterator<Item=&'b hir::Expr>>(&mut self,\n-            call_expr: &hir::Expr,\n-            pred: CFGIndex,\n-            func_or_rcvr: &hir::Expr,\n-            args: I) -> CFGIndex {\n+    fn call<'b, I: Iterator<Item = &'b hir::Expr>>(\n+        &mut self,\n+        call_expr: &hir::Expr,\n+        pred: CFGIndex,\n+        func_or_rcvr: &hir::Expr,\n+        args: I,\n+    ) -> CFGIndex {\n         let func_or_rcvr_exit = self.expr(func_or_rcvr, pred);\n         let ret = self.straightline(call_expr, func_or_rcvr_exit, args);\n         let m = self.tcx.hir().get_module_parent(call_expr.hir_id);\n@@ -328,33 +329,38 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n         }\n     }\n \n-    fn exprs<'b, I: Iterator<Item=&'b hir::Expr>>(&mut self,\n-                                             exprs: I,\n-                                             pred: CFGIndex) -> CFGIndex {\n-        //! Constructs graph for `exprs` evaluated in order\n+    /// Constructs graph for `exprs` evaluated in order.\n+    fn exprs<'b, I: Iterator<Item = &'b hir::Expr>>(\n+        &mut self,\n+        exprs: I,\n+        pred: CFGIndex,\n+    ) -> CFGIndex {\n         exprs.fold(pred, |p, e| self.expr(e, p))\n     }\n \n-    fn opt_expr(&mut self,\n-                opt_expr: &Option<P<hir::Expr>>,\n-                pred: CFGIndex) -> CFGIndex {\n-        //! Constructs graph for `opt_expr` evaluated, if Some\n+    /// Constructs graph for `opt_expr` evaluated, if `Some`.\n+    fn opt_expr(\n+        &mut self,\n+        opt_expr: &Option<P<hir::Expr>>,\n+        pred: CFGIndex,\n+    ) -> CFGIndex {\n         opt_expr.iter().fold(pred, |p, e| self.expr(&e, p))\n     }\n \n-    fn straightline<'b, I: Iterator<Item=&'b hir::Expr>>(&mut self,\n-                    expr: &hir::Expr,\n-                    pred: CFGIndex,\n-                    subexprs: I) -> CFGIndex {\n-        //! Handles case of an expression that evaluates `subexprs` in order\n-\n+    /// Handles case of an expression that evaluates `subexprs` in order.\n+    fn straightline<'b, I: Iterator<Item = &'b hir::Expr>>(\n+        &mut self,\n+        expr: &hir::Expr,\n+        pred: CFGIndex,\n+        subexprs: I,\n+    ) -> CFGIndex {\n         let subexprs_exit = self.exprs(subexprs, pred);\n         self.add_ast_node(expr.hir_id.local_id, &[subexprs_exit])\n     }\n \n     fn match_(&mut self, id: hir::ItemLocalId, discr: &hir::Expr,\n               arms: &[hir::Arm], pred: CFGIndex) -> CFGIndex {\n-        // The CFG for match expression is quite complex, so no ASCII\n+        // The CFG for match expressions is quite complex, so no ASCII\n         // art for it (yet).\n         //\n         // The CFG generated below matches roughly what MIR contains.\n@@ -369,13 +375,13 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n         //\n         // What is going on is explained in further comments.\n \n-        // Visit the discriminant expression\n+        // Visit the discriminant expression.\n         let discr_exit = self.expr(discr, pred);\n \n         // Add a node for the exit of the match expression as a whole.\n         let expr_exit = self.add_ast_node(id, &[]);\n \n-        // Keep track of the previous guard expressions\n+        // Keep track of the previous guard expressions.\n         let mut prev_guard = None;\n         let match_scope = region::Scope { id, data: region::ScopeData::Node };\n \n@@ -388,12 +394,12 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 // Visit the pattern, coming from the discriminant exit\n                 let mut pat_exit = self.pat(&pat, discr_exit);\n \n-                // If there is a guard expression, handle it here\n+                // If there is a guard expression, handle it here.\n                 if let Some(ref guard) = arm.guard {\n                     // Add a dummy node for the previous guard\n-                    // expression to target\n+                    // expression to target.\n                     let guard_start = self.add_dummy_node(&[pat_exit]);\n-                    // Visit the guard expression\n+                    // Visit the guard expression.\n                     let guard_exit = match guard {\n                         hir::Guard::If(ref e) => (&**e, self.expr(e, guard_start)),\n                     };\n@@ -407,24 +413,23 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                         self.add_exiting_edge(prev_guard, prev_index, match_scope, guard_start);\n                     }\n \n-                    // Push the guard onto the list of previous guards\n+                    // Push the guard onto the list of previous guards.\n                     prev_guard = Some(guard_exit);\n \n-                    // Update the exit node for the pattern\n+                    // Update the exit node for the pattern.\n                     pat_exit = guard_exit.1;\n                 }\n \n-                // Add an edge from the exit of this pattern to the\n-                // exit of the arm\n+                // Add an edge from the exit of this pattern to the exit of the arm.\n                 self.add_contained_edge(pat_exit, bindings_exit);\n             }\n \n-            // Visit the body of this arm\n+            // Visit the body of this arm.\n             let body_exit = self.expr(&arm.body, bindings_exit);\n \n             let arm_exit = self.add_ast_node(arm.hir_id.local_id, &[body_exit]);\n \n-            // Link the body to the exit of the expression\n+            // Link the body to the exit of the expression.\n             self.add_contained_edge(arm_exit, expr_exit);\n         }\n \n@@ -451,18 +456,22 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n         node\n     }\n \n-    fn add_contained_edge(&mut self,\n-                          source: CFGIndex,\n-                          target: CFGIndex) {\n+    fn add_contained_edge(\n+        &mut self,\n+        source: CFGIndex,\n+        target: CFGIndex,\n+    ) {\n         let data = CFGEdgeData {exiting_scopes: vec![] };\n         self.graph.add_edge(source, target, data);\n     }\n \n-    fn add_exiting_edge(&mut self,\n-                        from_expr: &hir::Expr,\n-                        from_index: CFGIndex,\n-                        target_scope: region::Scope,\n-                        to_index: CFGIndex) {\n+    fn add_exiting_edge(\n+        &mut self,\n+        from_expr: &hir::Expr,\n+        from_index: CFGIndex,\n+        target_scope: region::Scope,\n+        to_index: CFGIndex,\n+    ) {\n         let mut data = CFGEdgeData { exiting_scopes: vec![] };\n         let mut scope = region::Scope {\n             id: from_expr.hir_id.local_id,\n@@ -476,9 +485,11 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n         self.graph.add_edge(from_index, to_index, data);\n     }\n \n-    fn add_returning_edge(&mut self,\n-                          _from_expr: &hir::Expr,\n-                          from_index: CFGIndex) {\n+    fn add_returning_edge(\n+        &mut self,\n+        _from_expr: &hir::Expr,\n+        from_index: CFGIndex,\n+    ) {\n         let data = CFGEdgeData {\n             exiting_scopes: self.loop_scopes.iter()\n                                             .rev()\n@@ -488,11 +499,12 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n         self.graph.add_edge(from_index, self.fn_exit, data);\n     }\n \n-    fn find_scope_edge(&self,\n-                  expr: &hir::Expr,\n-                  destination: hir::Destination,\n-                  scope_cf_kind: ScopeCfKind) -> (region::Scope, CFGIndex) {\n-\n+    fn find_scope_edge(\n+        &self,\n+        expr: &hir::Expr,\n+        destination: hir::Destination,\n+        scope_cf_kind: ScopeCfKind,\n+    ) -> (region::Scope, CFGIndex) {\n         match destination.target_id {\n             Ok(loop_id) => {\n                 for b in &self.breakable_block_scopes {\n@@ -519,7 +531,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                         });\n                     }\n                 }\n-                span_bug!(expr.span, \"no scope for id {}\", loop_id);\n+                span_bug!(expr.span, \"no scope for ID {}\", loop_id);\n             }\n             Err(err) => span_bug!(expr.span, \"scope error: {}\",  err),\n         }", "previous_filename": "src/librustc/cfg/construct.rs"}, {"sha": "99c6b49cad5d908f9529d0a5737016a9b8e3a23f", "filename": "src/librustc_ast_borrowck/cfg/graphviz.rs", "status": "renamed", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_ast_borrowck%2Fcfg%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_ast_borrowck%2Fcfg%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_borrowck%2Fcfg%2Fgraphviz.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -1,21 +1,18 @@\n-/// This module provides linkage between rustc::middle::graph and\n+/// This module provides linkage between `rustc::middle::graph` and\n /// libgraphviz traits.\n \n-// For clarity, rename the graphviz crate locally to dot.\n-use graphviz as dot;\n-\n use crate::cfg;\n-use crate::hir;\n-use crate::ty::TyCtxt;\n+use rustc::hir;\n+use rustc::ty::TyCtxt;\n \n-pub type Node<'a> = (cfg::CFGIndex, &'a cfg::CFGNode);\n-pub type Edge<'a> = &'a cfg::CFGEdge;\n+pub(crate) type Node<'a> = (cfg::CFGIndex, &'a cfg::CFGNode);\n+pub(crate) type Edge<'a> = &'a cfg::CFGEdge;\n \n pub struct LabelledCFG<'a, 'tcx> {\n     pub tcx: TyCtxt<'tcx>,\n     pub cfg: &'a cfg::CFG,\n     pub name: String,\n-    /// `labelled_edges` controls whether we emit labels on the edges\n+    /// `labelled_edges` controls whether we emit labels on the edges.\n     pub labelled_edges: bool,\n }\n \n@@ -28,12 +25,12 @@ impl<'a, 'tcx> LabelledCFG<'a, 'tcx> {\n         };\n         let s = self.tcx.hir().node_to_string(hir_id);\n \n-        // Replacing newlines with \\\\l causes each line to be left-aligned,\n+        // Replacing newlines with `\\\\l` causes each line to be left-aligned,\n         // improving presentation of (long) pretty-printed expressions.\n         if s.contains(\"\\n\") {\n             let mut s = s.replace(\"\\n\", \"\\\\l\");\n             // Apparently left-alignment applies to the line that precedes\n-            // \\l, not the line that follows; so, add \\l at end of string\n+            // `\\l`, not the line that follows; so, add `\\l` at end of string\n             // if not already present, ensuring last line gets left-aligned\n             // as well.\n             let mut last_two: Vec<_> =\n@@ -112,8 +109,7 @@ impl<'a> dot::GraphWalk<'a> for &'a cfg::CFG {\n     }\n }\n \n-impl<'a, 'hir> dot::GraphWalk<'a> for LabelledCFG<'a, 'hir>\n-{\n+impl<'a, 'hir> dot::GraphWalk<'a> for LabelledCFG<'a, 'hir> {\n     type Node = Node<'a>;\n     type Edge = Edge<'a>;\n     fn nodes(&'a self) -> dot::Nodes<'a, Node<'a>> { self.cfg.nodes() }", "previous_filename": "src/librustc/cfg/graphviz.rs"}, {"sha": "981199c91d513effe18b18fb911c4ecf593b9728", "filename": "src/librustc_ast_borrowck/cfg/mod.rs", "status": "renamed", "additions": 13, "deletions": 18, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_ast_borrowck%2Fcfg%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_ast_borrowck%2Fcfg%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_borrowck%2Fcfg%2Fmod.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -2,18 +2,18 @@\n //! Uses `Graph` as the underlying representation.\n \n use rustc_data_structures::graph::implementation as graph;\n-use crate::ty::TyCtxt;\n-use crate::hir;\n-use crate::hir::def_id::DefId;\n+use rustc::ty::TyCtxt;\n+use rustc::hir;\n+use rustc::hir::def_id::DefId;\n \n mod construct;\n pub mod graphviz;\n \n pub struct CFG {\n-    pub owner_def_id: DefId,\n-    pub graph: CFGGraph,\n-    pub entry: CFGIndex,\n-    pub exit: CFGIndex,\n+    owner_def_id: DefId,\n+    pub(crate) graph: CFGGraph,\n+    pub(crate) entry: CFGIndex,\n+    exit: CFGIndex,\n }\n \n #[derive(Copy, Clone, Debug, PartialEq)]\n@@ -26,7 +26,7 @@ pub enum CFGNodeData {\n }\n \n impl CFGNodeData {\n-    pub fn id(&self) -> hir::ItemLocalId {\n+    pub(crate) fn id(&self) -> hir::ItemLocalId {\n         if let CFGNodeData::AST(id) = *self {\n             id\n         } else {\n@@ -37,24 +37,19 @@ impl CFGNodeData {\n \n #[derive(Debug)]\n pub struct CFGEdgeData {\n-    pub exiting_scopes: Vec<hir::ItemLocalId>\n+    pub(crate) exiting_scopes: Vec<hir::ItemLocalId>\n }\n \n-pub type CFGIndex = graph::NodeIndex;\n+pub(crate) type CFGIndex = graph::NodeIndex;\n \n-pub type CFGGraph = graph::Graph<CFGNodeData, CFGEdgeData>;\n+pub(crate) type CFGGraph = graph::Graph<CFGNodeData, CFGEdgeData>;\n \n-pub type CFGNode = graph::Node<CFGNodeData>;\n+pub(crate) type CFGNode = graph::Node<CFGNodeData>;\n \n-pub type CFGEdge = graph::Edge<CFGEdgeData>;\n+pub(crate) type CFGEdge = graph::Edge<CFGEdgeData>;\n \n impl CFG {\n     pub fn new(tcx: TyCtxt<'_>, body: &hir::Body) -> CFG {\n         construct::construct(tcx, body)\n     }\n-\n-    pub fn node_is_reachable(&self, id: hir::ItemLocalId) -> bool {\n-        self.graph.depth_traverse(self.entry, graph::OUTGOING)\n-                  .any(|idx| self.graph.node_data(idx).id() == id)\n-    }\n }", "previous_filename": "src/librustc/cfg/mod.rs"}, {"sha": "a8562901d99c5f3c0443db6b6dc6980580533998", "filename": "src/librustc_ast_borrowck/dataflow.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_ast_borrowck%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_ast_borrowck%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_borrowck%2Fdataflow.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -3,9 +3,7 @@\n //! and thus uses bitvectors. Your job is simply to specify the so-called\n //! GEN and KILL bits for each expression.\n \n-use rustc::cfg;\n-use rustc::cfg::CFGIndex;\n-use rustc::ty::TyCtxt;\n+use crate::cfg::{self, CFGIndex};\n use std::mem;\n use std::usize;\n use log::debug;\n@@ -16,6 +14,7 @@ use rustc::util::nodemap::FxHashMap;\n use rustc::hir;\n use rustc::hir::intravisit;\n use rustc::hir::print as pprust;\n+use rustc::ty::TyCtxt;\n \n #[derive(Copy, Clone, Debug)]\n pub enum EntryOrExit {\n@@ -186,8 +185,8 @@ fn build_local_id_to_index(body: Option<&hir::Body>,\n             index: &'a mut FxHashMap<hir::ItemLocalId, Vec<CFGIndex>>,\n         }\n         let mut formals = Formals { entry: entry, index: index };\n-        for arg in &body.arguments {\n-            formals.visit_pat(&arg.pat);\n+        for param in &body.params {\n+            formals.visit_pat(&param.pat);\n         }\n         impl<'a, 'v> Visitor<'v> for Formals<'a> {\n             fn nested_visit_map<'this>(&'this mut self) -> intravisit::NestedVisitorMap<'this, 'v> {"}, {"sha": "c077dc828aba22b98fe898fee4bd92039bef9832", "filename": "src/librustc_ast_borrowck/graphviz.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_ast_borrowck%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_ast_borrowck%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_borrowck%2Fgraphviz.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -4,13 +4,12 @@\n \n pub use Variant::*;\n \n-pub use rustc::cfg::graphviz::{Node, Edge};\n-use rustc::cfg::graphviz as cfg_dot;\n-\n+pub(crate) use crate::cfg::graphviz::{Node, Edge};\n+use crate::cfg::graphviz as cfg_dot;\n+use crate::cfg::CFGIndex;\n use crate::borrowck::{self, BorrowckCtxt, LoanPath};\n use crate::dataflow::{DataFlowOperator, DataFlowContext, EntryOrExit};\n use log::debug;\n-use rustc::cfg::CFGIndex;\n use std::rc::Rc;\n \n #[derive(Debug, Copy, Clone)]"}, {"sha": "aea97fea1a9fd67d5aeec911beb59e6775e17f5b", "filename": "src/librustc_ast_borrowck/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_ast_borrowck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_ast_borrowck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_borrowck%2Flib.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -18,5 +18,6 @@ mod borrowck;\n pub mod graphviz;\n \n mod dataflow;\n+pub mod cfg;\n \n pub use borrowck::provide;"}, {"sha": "98efa6a5804bd352d4617912ecdaaf58f099df4a", "filename": "src/librustc_codegen_llvm/Cargo.toml", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_codegen_llvm%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_codegen_llvm%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2FCargo.toml?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -11,11 +11,7 @@ crate-type = [\"dylib\"]\n test = false\n \n [dependencies]\n-cc = \"1.0.1\" # Used to locate MSVC\n-num_cpus = \"1.0\"\n-tempfile = \"3.0\"\n rustc_llvm = { path = \"../librustc_llvm\" }\n-memmap = \"0.6\"\n \n [features]\n # This is used to convince Cargo to separately cache builds of `rustc_codegen_llvm`"}, {"sha": "a43fbb68dbaed76d7d5d3d858c8c591fee5f50f7", "filename": "src/librustc_codegen_llvm/back/lto.rs", "status": "modified", "additions": 41, "deletions": 45, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -183,14 +183,40 @@ pub(crate) fn prepare_thin(\n \n fn fat_lto(cgcx: &CodegenContext<LlvmCodegenBackend>,\n            diag_handler: &Handler,\n-           mut modules: Vec<FatLTOInput<LlvmCodegenBackend>>,\n+           modules: Vec<FatLTOInput<LlvmCodegenBackend>>,\n            cached_modules: Vec<(SerializedModule<ModuleBuffer>, WorkProduct)>,\n            mut serialized_modules: Vec<(SerializedModule<ModuleBuffer>, CString)>,\n            symbol_white_list: &[*const libc::c_char])\n     -> Result<LtoModuleCodegen<LlvmCodegenBackend>, FatalError>\n {\n     info!(\"going for a fat lto\");\n \n+    // Sort out all our lists of incoming modules into two lists.\n+    //\n+    // * `serialized_modules` (also and argument to this function) contains all\n+    //   modules that are serialized in-memory.\n+    // * `in_memory` contains modules which are already parsed and in-memory,\n+    //   such as from multi-CGU builds.\n+    //\n+    // All of `cached_modules` (cached from previous incremental builds) can\n+    // immediately go onto the `serialized_modules` modules list and then we can\n+    // split the `modules` array into these two lists.\n+    let mut in_memory = Vec::new();\n+    serialized_modules.extend(cached_modules.into_iter().map(|(buffer, wp)| {\n+        info!(\"pushing cached module {:?}\", wp.cgu_name);\n+        (buffer, CString::new(wp.cgu_name).unwrap())\n+    }));\n+    for module in modules {\n+        match module {\n+            FatLTOInput::InMemory(m) => in_memory.push(m),\n+            FatLTOInput::Serialized { name, buffer } => {\n+                info!(\"pushing serialized module {:?}\", name);\n+                let buffer = SerializedModule::Local(buffer);\n+                serialized_modules.push((buffer, CString::new(name).unwrap()));\n+            }\n+        }\n+    }\n+\n     // Find the \"costliest\" module and merge everything into that codegen unit.\n     // All the other modules will be serialized and reparsed into the new\n     // context, so this hopefully avoids serializing and parsing the largest\n@@ -200,14 +226,8 @@ fn fat_lto(cgcx: &CodegenContext<LlvmCodegenBackend>,\n     // file copy operations in the backend work correctly. The only other kind\n     // of module here should be an allocator one, and if your crate is smaller\n     // than the allocator module then the size doesn't really matter anyway.\n-    let costliest_module = modules.iter()\n+    let costliest_module = in_memory.iter()\n         .enumerate()\n-        .filter_map(|(i, module)| {\n-            match module {\n-                FatLTOInput::InMemory(m) => Some((i, m)),\n-                FatLTOInput::Serialized { .. } => None,\n-            }\n-        })\n         .filter(|&(_, module)| module.kind == ModuleKind::Regular)\n         .map(|(i, module)| {\n             let cost = unsafe {\n@@ -223,26 +243,14 @@ fn fat_lto(cgcx: &CodegenContext<LlvmCodegenBackend>,\n     // re-executing the LTO passes. If that's the case deserialize the first\n     // module and create a linker with it.\n     let module: ModuleCodegen<ModuleLlvm> = match costliest_module {\n-        Some((_cost, i)) => {\n-            match modules.remove(i) {\n-                FatLTOInput::InMemory(m) => m,\n-                FatLTOInput::Serialized { .. } => unreachable!(),\n-            }\n-        }\n+        Some((_cost, i)) => in_memory.remove(i),\n         None => {\n-            let pos = modules.iter().position(|m| {\n-                match m {\n-                    FatLTOInput::InMemory(_) => false,\n-                    FatLTOInput::Serialized { .. } => true,\n-                }\n-            }).expect(\"must have at least one serialized module\");\n-            let (name, buffer) = match modules.remove(pos) {\n-                FatLTOInput::Serialized { name, buffer } => (name, buffer),\n-                FatLTOInput::InMemory(_) => unreachable!(),\n-            };\n+            assert!(serialized_modules.len() > 0, \"must have at least one serialized module\");\n+            let (buffer, name) = serialized_modules.remove(0);\n+            info!(\"no in-memory regular modules to choose from, parsing {:?}\", name);\n             ModuleCodegen {\n-                module_llvm: ModuleLlvm::parse(cgcx, &name, &buffer, diag_handler)?,\n-                name,\n+                module_llvm: ModuleLlvm::parse(cgcx, &name, buffer.data(), diag_handler)?,\n+                name: name.into_string().unwrap(),\n                 kind: ModuleKind::Regular,\n             }\n         }\n@@ -265,25 +273,13 @@ fn fat_lto(cgcx: &CodegenContext<LlvmCodegenBackend>,\n         // and we want to move everything to the same LLVM context. Currently the\n         // way we know of to do that is to serialize them to a string and them parse\n         // them later. Not great but hey, that's why it's \"fat\" LTO, right?\n-        let mut new_modules = modules.into_iter().map(|module| {\n-            match module {\n-                FatLTOInput::InMemory(module) => {\n-                    let buffer = ModuleBuffer::new(module.module_llvm.llmod());\n-                    let llmod_id = CString::new(&module.name[..]).unwrap();\n-                    (SerializedModule::Local(buffer), llmod_id)\n-                }\n-                FatLTOInput::Serialized { name, buffer } => {\n-                    let llmod_id = CString::new(name).unwrap();\n-                    (SerializedModule::Local(buffer), llmod_id)\n-                }\n-            }\n-        }).collect::<Vec<_>>();\n+        for module in in_memory {\n+            let buffer = ModuleBuffer::new(module.module_llvm.llmod());\n+            let llmod_id = CString::new(&module.name[..]).unwrap();\n+            serialized_modules.push((SerializedModule::Local(buffer), llmod_id));\n+        }\n         // Sort the modules to ensure we produce deterministic results.\n-        new_modules.sort_by(|module1, module2| module1.1.partial_cmp(&module2.1).unwrap());\n-        serialized_modules.extend(new_modules);\n-        serialized_modules.extend(cached_modules.into_iter().map(|(buffer, wp)| {\n-            (buffer, CString::new(wp.cgu_name).unwrap())\n-        }));\n+        serialized_modules.sort_by(|module1, module2| module1.1.cmp(&module2.1));\n \n         // For all serialized bitcode files we parse them and link them in as we did\n         // above, this is all mostly handled in C++. Like above, though, we don't\n@@ -850,7 +846,7 @@ fn module_name_to_str(c_str: &CStr) -> &str {\n         bug!(\"Encountered non-utf8 LLVM module name `{}`: {}\", c_str.to_string_lossy(), e))\n }\n \n-fn parse_module<'a>(\n+pub fn parse_module<'a>(\n     cx: &'a llvm::Context,\n     name: &CStr,\n     data: &[u8],"}, {"sha": "e13a5ecc2ebfdf3c8549ffd404d52db3b99a5991", "filename": "src/librustc_codegen_llvm/builder.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbuilder.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -5,7 +5,6 @@ use crate::context::CodegenCx;\n use crate::type_::Type;\n use crate::type_of::LayoutLlvmExt;\n use crate::value::Value;\n-use syntax::symbol::LocalInternedString;\n use rustc_codegen_ssa::common::{IntPredicate, TypeKind, RealPredicate};\n use rustc_codegen_ssa::MemFlags;\n use libc::{c_uint, c_char};\n@@ -24,6 +23,7 @@ use std::ffi::CStr;\n use std::ops::{Deref, Range};\n use std::ptr;\n use std::iter::TrustedLen;\n+use syntax::symbol::Symbol;\n \n // All Builders must have an llfn associated with them\n #[must_use]\n@@ -561,7 +561,7 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n \n         let align = dest.align.restrict_for_offset(dest.layout.field(self.cx(), 0).size);\n         cg_elem.val.store(&mut body_bx,\n-            PlaceRef::new_sized(current, cg_elem.layout, align));\n+            PlaceRef::new_sized_aligned(current, cg_elem.layout, align));\n \n         let next = body_bx.inbounds_gep(current, &[self.const_usize(1)]);\n         body_bx.br(header_bx.llbb());\n@@ -1082,8 +1082,8 @@ impl StaticBuilderMethods for Builder<'a, 'll, 'tcx> {\n \n     fn static_panic_msg(\n         &mut self,\n-        msg: Option<LocalInternedString>,\n-        filename: LocalInternedString,\n+        msg: Option<Symbol>,\n+        filename: Symbol,\n         line: Self::Value,\n         col: Self::Value,\n         kind: &str,"}, {"sha": "35d5107842d5b3464b2d7b6f8a86b6bffdb62f12", "filename": "src/librustc_codegen_llvm/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_codegen_llvm%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_codegen_llvm%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcallee.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -37,7 +37,7 @@ pub fn get_fn(\n         return llfn;\n     }\n \n-    let sym = tcx.symbol_name(instance).as_str();\n+    let sym = tcx.symbol_name(instance).name.as_str();\n     debug!(\"get_fn({:?}: {:?}) => {}\", instance, sig, sym);\n \n     // Create a fn pointer with the substituted signature."}, {"sha": "6fbea9646b8a9fe524514000c23c70a6f3ee8f17", "filename": "src/librustc_codegen_llvm/common.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_codegen_llvm%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_codegen_llvm%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcommon.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -17,7 +17,7 @@ use rustc_codegen_ssa::mir::place::PlaceRef;\n \n use libc::{c_uint, c_char};\n \n-use syntax::symbol::LocalInternedString;\n+use syntax::symbol::Symbol;\n use syntax::ast::Mutability;\n \n pub use crate::context::CodegenCx;\n@@ -122,17 +122,18 @@ impl CodegenCx<'ll, 'tcx> {\n \n     fn const_cstr(\n         &self,\n-        s: LocalInternedString,\n+        s: Symbol,\n         null_terminated: bool,\n     ) -> &'ll Value {\n         unsafe {\n             if let Some(&llval) = self.const_cstr_cache.borrow().get(&s) {\n                 return llval;\n             }\n \n+            let s_str = s.as_str();\n             let sc = llvm::LLVMConstStringInContext(self.llcx,\n-                                                    s.as_ptr() as *const c_char,\n-                                                    s.len() as c_uint,\n+                                                    s_str.as_ptr() as *const c_char,\n+                                                    s_str.len() as c_uint,\n                                                     !null_terminated as Bool);\n             let sym = self.generate_local_symbol_name(\"str\");\n             let g = self.define_global(&sym[..], self.val_ty(sc)).unwrap_or_else(||{\n@@ -147,8 +148,8 @@ impl CodegenCx<'ll, 'tcx> {\n         }\n     }\n \n-    pub fn const_str_slice(&self, s: LocalInternedString) -> &'ll Value {\n-        let len = s.len();\n+    pub fn const_str_slice(&self, s: Symbol) -> &'ll Value {\n+        let len = s.as_str().len();\n         let cs = consts::ptrcast(self.const_cstr(s, false),\n             self.type_ptr_to(self.layout_of(self.tcx.mk_str()).llvm_type(self)));\n         self.const_fat_ptr(cs, self.const_usize(len as u64))\n@@ -348,7 +349,7 @@ impl ConstMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n             )};\n             self.const_bitcast(llval, llty)\n         };\n-        PlaceRef::new_sized(llval, layout, alloc.align)\n+        PlaceRef::new_sized(llval, layout)\n     }\n \n     fn const_ptrcast(&self, val: &'ll Value, ty: &'ll Type) -> &'ll Value {"}, {"sha": "e71d1fc16924bb1ed966d99935c2b3114aa63059", "filename": "src/librustc_codegen_llvm/consts.rs", "status": "modified", "additions": 58, "deletions": 16, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fconsts.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -11,12 +11,11 @@ use rustc::mir::interpret::{ConstValue, Allocation, read_target_uint,\n     Pointer, ErrorHandled, GlobalId};\n use rustc::mir::mono::MonoItem;\n use rustc::hir::Node;\n-use syntax_pos::Span;\n use rustc_target::abi::HasDataLayout;\n-use syntax::symbol::sym;\n-use syntax_pos::symbol::LocalInternedString;\n use rustc::ty::{self, Ty, Instance};\n use rustc_codegen_ssa::traits::*;\n+use syntax::symbol::{Symbol, sym};\n+use syntax_pos::Span;\n \n use rustc::ty::layout::{self, Size, Align, LayoutOf};\n \n@@ -25,21 +24,31 @@ use rustc::hir::{self, CodegenFnAttrs, CodegenFnAttrFlags};\n use std::ffi::{CStr, CString};\n \n pub fn const_alloc_to_llvm(cx: &CodegenCx<'ll, '_>, alloc: &Allocation) -> &'ll Value {\n-    let mut llvals = Vec::with_capacity(alloc.relocations.len() + 1);\n+    let mut llvals = Vec::with_capacity(alloc.relocations().len() + 1);\n     let dl = cx.data_layout();\n     let pointer_size = dl.pointer_size.bytes() as usize;\n \n     let mut next_offset = 0;\n-    for &(offset, ((), alloc_id)) in alloc.relocations.iter() {\n+    for &(offset, ((), alloc_id)) in alloc.relocations().iter() {\n         let offset = offset.bytes();\n         assert_eq!(offset as usize as u64, offset);\n         let offset = offset as usize;\n         if offset > next_offset {\n-            llvals.push(cx.const_bytes(&alloc.bytes[next_offset..offset]));\n+            // This `inspect` is okay since we have checked that it is not within a relocation, it\n+            // is within the bounds of the allocation, and it doesn't affect interpreter execution\n+            // (we inspect the result after interpreter execution). Any undef byte is replaced with\n+            // some arbitrary byte value.\n+            //\n+            // FIXME: relay undef bytes to codegen as undef const bytes\n+            let bytes = alloc.inspect_with_undef_and_ptr_outside_interpreter(next_offset..offset);\n+            llvals.push(cx.const_bytes(bytes));\n         }\n         let ptr_offset = read_target_uint(\n             dl.endian,\n-            &alloc.bytes[offset..(offset + pointer_size)],\n+            // This `inspect` is okay since it is within the bounds of the allocation, it doesn't\n+            // affect interpreter execution (we inspect the result after interpreter execution),\n+            // and we properly interpret the relocation as a relocation pointer offset.\n+            alloc.inspect_with_undef_and_ptr_outside_interpreter(offset..(offset + pointer_size)),\n         ).expect(\"const_alloc_to_llvm: could not read relocation pointer\") as u64;\n         llvals.push(cx.scalar_to_backend(\n             Pointer::new(alloc_id, Size::from_bytes(ptr_offset)).into(),\n@@ -51,8 +60,16 @@ pub fn const_alloc_to_llvm(cx: &CodegenCx<'ll, '_>, alloc: &Allocation) -> &'ll\n         ));\n         next_offset = offset + pointer_size;\n     }\n-    if alloc.bytes.len() >= next_offset {\n-        llvals.push(cx.const_bytes(&alloc.bytes[next_offset ..]));\n+    if alloc.len() >= next_offset {\n+        let range = next_offset..alloc.len();\n+        // This `inspect` is okay since we have check that it is after all relocations, it is\n+        // within the bounds of the allocation, and it doesn't affect interpreter execution (we\n+        // inspect the result after interpreter execution). Any undef byte is replaced with some\n+        // arbitrary byte value.\n+        //\n+        // FIXME: relay undef bytes to codegen as undef const bytes\n+        let bytes = alloc.inspect_with_undef_and_ptr_outside_interpreter(range);\n+        llvals.push(cx.const_bytes(bytes));\n     }\n \n     cx.const_struct(&llvals, true)\n@@ -104,10 +121,11 @@ fn check_and_apply_linkage(\n     cx: &CodegenCx<'ll, 'tcx>,\n     attrs: &CodegenFnAttrs,\n     ty: Ty<'tcx>,\n-    sym: LocalInternedString,\n+    sym: Symbol,\n     span: Span\n ) -> &'ll Value {\n     let llty = cx.layout_of(ty).llvm_type(cx);\n+    let sym = sym.as_str();\n     if let Some(linkage) = attrs.linkage {\n         debug!(\"get_static: sym={} linkage={:?}\", sym, linkage);\n \n@@ -203,7 +221,7 @@ impl CodegenCx<'ll, 'tcx> {\n                  def_id);\n \n         let ty = instance.ty(self.tcx);\n-        let sym = self.tcx.symbol_name(instance).as_str();\n+        let sym = self.tcx.symbol_name(instance).name.as_symbol();\n \n         debug!(\"get_static: sym={} instance={:?}\", sym, instance);\n \n@@ -214,11 +232,12 @@ impl CodegenCx<'ll, 'tcx> {\n                 Node::Item(&hir::Item {\n                     ref attrs, span, node: hir::ItemKind::Static(..), ..\n                 }) => {\n-                    if self.get_declared_value(&sym[..]).is_some() {\n+                    let sym_str = sym.as_str();\n+                    if self.get_declared_value(&sym_str).is_some() {\n                         span_bug!(span, \"Conflicting symbol names for static?\");\n                     }\n \n-                    let g = self.define_global(&sym[..], llty).unwrap();\n+                    let g = self.define_global(&sym_str, llty).unwrap();\n \n                     if !self.tcx.is_reachable_non_generic(def_id) {\n                         unsafe {\n@@ -437,7 +456,23 @@ impl StaticMethods for CodegenCx<'ll, 'tcx> {\n                 //\n                 // We could remove this hack whenever we decide to drop macOS 10.10 support.\n                 if self.tcx.sess.target.target.options.is_like_osx {\n-                    let sect_name = if alloc.bytes.iter().all(|b| *b == 0) {\n+                    assert_eq!(alloc.relocations().len(), 0);\n+\n+                    let is_zeroed = {\n+                        // Treats undefined bytes as if they were defined with the byte value that\n+                        // happens to be currently assigned in mir. This is valid since reading\n+                        // undef bytes may yield arbitrary values.\n+                        //\n+                        // FIXME: ignore undef bytes even with representation `!= 0`.\n+                        //\n+                        // The `inspect` method is okay here because we checked relocations, and\n+                        // because we are doing this access to inspect the final interpreter state\n+                        // (not as part of the interpreter execution).\n+                        alloc.inspect_with_undef_and_ptr_outside_interpreter(0..alloc.len())\n+                            .iter()\n+                            .all(|b| *b == 0)\n+                    };\n+                    let sect_name = if is_zeroed {\n                         CStr::from_bytes_with_nul_unchecked(b\"__DATA,__thread_bss\\0\")\n                     } else {\n                         CStr::from_bytes_with_nul_unchecked(b\"__DATA,__thread_data\\0\")\n@@ -456,10 +491,17 @@ impl StaticMethods for CodegenCx<'ll, 'tcx> {\n                         section.as_str().as_ptr() as *const _,\n                         section.as_str().len() as c_uint,\n                     );\n+                    assert!(alloc.relocations().is_empty());\n+\n+                    // The `inspect` method is okay here because we checked relocations, and\n+                    // because we are doing this access to inspect the final interpreter state (not\n+                    // as part of the interpreter execution).\n+                    let bytes = alloc.inspect_with_undef_and_ptr_outside_interpreter(\n+                        0..alloc.len());\n                     let alloc = llvm::LLVMMDStringInContext(\n                         self.llcx,\n-                        alloc.bytes.as_ptr() as *const _,\n-                        alloc.bytes.len() as c_uint,\n+                        bytes.as_ptr() as *const _,\n+                        bytes.len() as c_uint,\n                     );\n                     let data = [section, alloc];\n                     let meta = llvm::LLVMMDNodeInContext(self.llcx, data.as_ptr(), 2);"}, {"sha": "58ce97039099e7bc7dc0477a84e483d82ac6d268", "filename": "src/librustc_codegen_llvm/context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcontext.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -29,7 +29,7 @@ use std::cell::{Cell, RefCell};\n use std::iter;\n use std::str;\n use std::sync::Arc;\n-use syntax::symbol::LocalInternedString;\n+use syntax::symbol::Symbol;\n use syntax::source_map::{DUMMY_SP, Span};\n use crate::abi::Abi;\n \n@@ -52,7 +52,7 @@ pub struct CodegenCx<'ll, 'tcx> {\n     pub vtables:\n         RefCell<FxHashMap<(Ty<'tcx>, Option<ty::PolyExistentialTraitRef<'tcx>>), &'ll Value>>,\n     /// Cache of constant strings,\n-    pub const_cstr_cache: RefCell<FxHashMap<LocalInternedString, &'ll Value>>,\n+    pub const_cstr_cache: RefCell<FxHashMap<Symbol, &'ll Value>>,\n \n     /// Reverse-direction for const ptrs cast from globals.\n     /// Key is a Value holding a *T,"}, {"sha": "d0b607bd88ee4f9d5023b8d653d5b80b6768c694", "filename": "src/librustc_codegen_llvm/debuginfo/metadata.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -683,11 +683,13 @@ pub fn type_metadata(\n         }\n         ty::Closure(def_id, substs) => {\n             let upvar_tys : Vec<_> = substs.upvar_tys(def_id, cx.tcx).collect();\n+            let containing_scope = get_namespace_for_item(cx, def_id);\n             prepare_tuple_metadata(cx,\n                                    t,\n                                    &upvar_tys,\n                                    unique_type_id,\n-                                   usage_site_span).finalize(cx)\n+                                   usage_site_span,\n+                                   Some(containing_scope)).finalize(cx)\n         }\n         ty::Generator(def_id, substs,  _) => {\n             let upvar_tys : Vec<_> = substs.prefix_tys(def_id, cx.tcx).map(|t| {\n@@ -728,7 +730,8 @@ pub fn type_metadata(\n                                    t,\n                                    &tys,\n                                    unique_type_id,\n-                                   usage_site_span).finalize(cx)\n+                                   usage_site_span,\n+                                   NO_SCOPE_METADATA).finalize(cx)\n         }\n         _ => {\n             bug!(\"debuginfo: unexpected type in type_metadata: {:?}\", t)\n@@ -1205,14 +1208,15 @@ fn prepare_tuple_metadata(\n     component_types: &[Ty<'tcx>],\n     unique_type_id: UniqueTypeId,\n     span: Span,\n+    containing_scope: Option<&'ll DIScope>,\n ) -> RecursiveTypeDescription<'ll, 'tcx> {\n     let tuple_name = compute_debuginfo_type_name(cx.tcx, tuple_type, false);\n \n     let struct_stub = create_struct_stub(cx,\n                                          tuple_type,\n                                          &tuple_name[..],\n                                          unique_type_id,\n-                                         NO_SCOPE_METADATA);\n+                                         containing_scope);\n \n     create_and_register_recursive_type_forward_declaration(\n         cx,\n@@ -2247,7 +2251,7 @@ pub fn create_global_var_metadata(\n         None\n     } else {\n         let linkage_name = mangled_name_of_instance(cx, Instance::mono(tcx, def_id));\n-        Some(SmallCStr::new(&linkage_name.as_str()))\n+        Some(SmallCStr::new(&linkage_name.name.as_str()))\n     };\n \n     let global_align = cx.align_of(variable_type);"}, {"sha": "6dedf10f0ab837e41fb5f3094e02c757df62868a", "filename": "src/librustc_codegen_llvm/debuginfo/mod.rs", "status": "modified", "additions": 33, "deletions": 4, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -32,7 +32,7 @@ use rustc_codegen_ssa::debuginfo::{FunctionDebugContext, MirDebugScope, Variable\n \n use libc::c_uint;\n use std::cell::RefCell;\n-use std::ffi::CString;\n+use std::ffi::{CStr, CString};\n \n use syntax_pos::{self, Span, Pos};\n use syntax::ast;\n@@ -224,8 +224,37 @@ impl DebugInfoBuilderMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n         gdb::insert_reference_to_gdb_debug_scripts_section_global(self)\n     }\n \n-    fn set_value_name(&mut self, value: &'ll Value, name: &str) {\n-        let cname = SmallCStr::new(name);\n+    fn set_var_name(&mut self, value: &'ll Value, name: impl ToString) {\n+        // Avoid wasting time if LLVM value names aren't even enabled.\n+        if self.sess().fewer_names() {\n+            return;\n+        }\n+\n+        // Only function parameters and instructions are local to a function,\n+        // don't change the name of anything else (e.g. globals).\n+        let param_or_inst = unsafe {\n+            llvm::LLVMIsAArgument(value).is_some() ||\n+            llvm::LLVMIsAInstruction(value).is_some()\n+        };\n+        if !param_or_inst {\n+            return;\n+        }\n+\n+        let old_name = unsafe {\n+            CStr::from_ptr(llvm::LLVMGetValueName(value))\n+        };\n+        match old_name.to_str() {\n+            Ok(\"\") => {}\n+            Ok(_) => {\n+                // Avoid replacing the name if it already exists.\n+                // While we could combine the names somehow, it'd\n+                // get noisy quick, and the usefulness is dubious.\n+                return;\n+            }\n+            Err(_) => return,\n+        }\n+\n+        let cname = CString::new(name.to_string()).unwrap();\n         unsafe {\n             llvm::LLVMSetValueName(value, cname.as_ptr());\n         }\n@@ -290,7 +319,7 @@ impl DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n         let scope_line = span_start(self, span).line;\n \n         let function_name = CString::new(name).unwrap();\n-        let linkage_name = SmallCStr::new(&linkage_name.as_str());\n+        let linkage_name = SmallCStr::new(&linkage_name.name.as_str());\n \n         let mut flags = DIFlags::FlagPrototyped;\n "}, {"sha": "042e51ed2ba7a4e95e0f4bacd7e16142947df71c", "filename": "src/librustc_codegen_llvm/error_codes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_codegen_llvm%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_codegen_llvm%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Ferror_codes.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -1,4 +1,4 @@\n-register_long_diagnostics! {\n+register_diagnostics! {\n \n E0511: r##\"\n Invalid monomorphization of an intrinsic function was used. Erroneous code"}, {"sha": "fc0b9ffd11d8389a1a4394c654af7bf1d14d93cb", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -101,7 +101,7 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n         let name = &*tcx.item_name(def_id).as_str();\n \n         let llret_ty = self.layout_of(ret_ty).llvm_type(self);\n-        let result = PlaceRef::new_sized(llresult, fn_ty.ret.layout, fn_ty.ret.layout.align.abi);\n+        let result = PlaceRef::new_sized(llresult, fn_ty.ret.layout);\n \n         let simple = get_simple_intrinsic(self, name);\n         let llval = match name {"}, {"sha": "9f2c303145dc8e28eba27d63b60ad603d2fc6cf1", "filename": "src/librustc_codegen_llvm/lib.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_codegen_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_codegen_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Flib.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -14,7 +14,6 @@\n #![feature(in_band_lifetimes)]\n #![feature(libc)]\n #![feature(nll)]\n-#![feature(rustc_diagnostic_macros)]\n #![feature(optin_builtin_traits)]\n #![feature(concat_idents)]\n #![feature(link_args)]\n@@ -54,6 +53,7 @@ use syntax_pos::symbol::InternedString;\n pub use llvm_util::target_features;\n use std::any::Any;\n use std::sync::{mpsc, Arc};\n+use std::ffi::CStr;\n \n use rustc::dep_graph::DepGraph;\n use rustc::middle::cstore::{EncodedMetadata, MetadataLoader};\n@@ -255,7 +255,7 @@ impl CodegenBackend for LlvmCodegenBackend {\n     }\n \n     fn diagnostics(&self) -> &[(&'static str, &'static str)] {\n-        &DIAGNOSTICS\n+        &error_codes::DIAGNOSTICS\n     }\n \n     fn target_features(&self, sess: &Session) -> Vec<Symbol> {\n@@ -386,13 +386,13 @@ impl ModuleLlvm {\n \n     fn parse(\n         cgcx: &CodegenContext<LlvmCodegenBackend>,\n-        name: &str,\n-        buffer: &back::lto::ModuleBuffer,\n+        name: &CStr,\n+        buffer: &[u8],\n         handler: &Handler,\n     ) -> Result<Self, FatalError> {\n         unsafe {\n             let llcx = llvm::LLVMRustContextCreate(cgcx.fewer_names);\n-            let llmod_raw = buffer.parse(name, llcx, handler)?;\n+            let llmod_raw = back::lto::parse_module(llcx, name, buffer, handler)?;\n             let tm = match (cgcx.tm_factory.0)() {\n                 Ok(m) => m,\n                 Err(e) => {\n@@ -424,5 +424,3 @@ impl Drop for ModuleLlvm {\n         }\n     }\n }\n-\n-__build_diagnostic_array! { librustc_codegen_llvm, DIAGNOSTICS }"}, {"sha": "b07214fdc03f3c22b4f93d2e462369ca87cd1bff", "filename": "src/librustc_codegen_llvm/llvm/ffi.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -806,6 +806,7 @@ extern \"C\" {\n     pub fn LLVMRustRemoveFunctionAttributes(Fn: &Value, index: c_uint, attr: Attribute);\n \n     // Operations on parameters\n+    pub fn LLVMIsAArgument(Val: &Value) -> Option<&Value>;\n     pub fn LLVMCountParams(Fn: &Value) -> c_uint;\n     pub fn LLVMGetParam(Fn: &Value, Index: c_uint) -> &Value;\n \n@@ -818,6 +819,7 @@ extern \"C\" {\n     pub fn LLVMDeleteBasicBlock(BB: &BasicBlock);\n \n     // Operations on instructions\n+    pub fn LLVMIsAInstruction(Val: &Value) -> Option<&Value>;\n     pub fn LLVMGetFirstBasicBlock(Fn: &Value) -> &BasicBlock;\n \n     // Operations on call sites"}, {"sha": "de481d2262478630d74266e20b1e1342678d048e", "filename": "src/librustc_codegen_ssa/back/linker.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -430,10 +430,13 @@ impl<'a> Linker for GccLinker<'a> {\n             // Write an LD version script\n             let res: io::Result<()> = try {\n                 let mut f = BufWriter::new(File::create(&path)?);\n-                writeln!(f, \"{{\\n  global:\")?;\n-                for sym in self.info.exports[&crate_type].iter() {\n-                    debug!(\"    {};\", sym);\n-                    writeln!(f, \"    {};\", sym)?;\n+                writeln!(f, \"{{\")?;\n+                if !self.info.exports[&crate_type].is_empty() {\n+                    writeln!(f, \"  global:\")?;\n+                    for sym in self.info.exports[&crate_type].iter() {\n+                        debug!(\"    {};\", sym);\n+                        writeln!(f, \"    {};\", sym)?;\n+                    }\n                 }\n                 writeln!(f, \"\\n  local:\\n    *;\\n}};\")?;\n             };"}, {"sha": "7e700e6819426c2ba29170df616edd1dd6be74fb", "filename": "src/librustc_codegen_ssa/back/symbol_export.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -121,7 +121,7 @@ fn reachable_non_generics_provider(\n         })\n         .map(|def_id| {\n             let export_level = if special_runtime_crate {\n-                let name = tcx.symbol_name(Instance::mono(tcx, def_id)).as_str();\n+                let name = tcx.symbol_name(Instance::mono(tcx, def_id)).name.as_str();\n                 // We can probably do better here by just ensuring that\n                 // it has hidden visibility rather than public\n                 // visibility, as this is primarily here to ensure it's"}, {"sha": "4acbe0356b47cb174cdbe581ce83071af9de4e86", "filename": "src/librustc_codegen_ssa/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_codegen_ssa%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_codegen_ssa%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fbase.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -456,7 +456,7 @@ pub fn maybe_create_entry_wrapper<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(cx: &'\n         let arg_argv = param_argv;\n \n         let (start_fn, args) = if use_start_lang_item {\n-            let start_def_id = cx.tcx().require_lang_item(StartFnLangItem);\n+            let start_def_id = cx.tcx().require_lang_item(StartFnLangItem, None);\n             let start_fn = callee::resolve_and_get_fn(\n                 cx,\n                 start_def_id,"}, {"sha": "9b5ad94ecd7cbbc145f9f31b8ab405752c7a98e4", "filename": "src/librustc_codegen_ssa/debuginfo/type_names.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_codegen_ssa%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_codegen_ssa%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fdebuginfo%2Ftype_names.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -190,11 +190,17 @@ pub fn push_debuginfo_type_name<'tcx>(\n             // processing\n             visited.remove(t);\n         },\n-        ty::Closure(..) => {\n-            output.push_str(\"closure\");\n+        ty::Closure(def_id, ..) => {\n+            output.push_str(&format!(\n+                \"closure-{}\",\n+                tcx.def_key(def_id).disambiguated_data.disambiguator\n+            ));\n         }\n-        ty::Generator(..) => {\n-            output.push_str(\"generator\");\n+        ty::Generator(def_id, ..) => {\n+            output.push_str(&format!(\n+                \"generator-{}\",\n+                tcx.def_key(def_id).disambiguated_data.disambiguator\n+            ));\n         }\n         ty::Error |\n         ty::Infer(_) |"}, {"sha": "8ff41c275a8f45283e387847e7d5861dd3abd94b", "filename": "src/librustc_codegen_ssa/error_codes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_codegen_ssa%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_codegen_ssa%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ferror_codes.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -1,4 +1,4 @@\n-register_long_diagnostics! {\n+syntax::register_diagnostics! {\n \n E0668: r##\"\n Malformed inline assembly rejected by LLVM."}, {"sha": "90bf964ceaa1302e3494894f0cf3373227fd033d", "filename": "src/librustc_codegen_ssa/lib.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_codegen_ssa%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_codegen_ssa%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Flib.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -4,7 +4,6 @@\n #![feature(box_syntax)]\n #![feature(core_intrinsics)]\n #![feature(libc)]\n-#![feature(rustc_diagnostic_macros)]\n #![feature(stmt_expr_attributes)]\n #![feature(try_blocks)]\n #![feature(in_band_lifetimes)]\n@@ -35,8 +34,6 @@ use rustc_data_structures::svh::Svh;\n use rustc::middle::cstore::{LibSource, CrateSource, NativeLibrary};\n use syntax_pos::symbol::Symbol;\n \n-// N.B., this module needs to be declared first so diagnostics are\n-// registered before they are used.\n mod error_codes;\n \n pub mod common;\n@@ -158,5 +155,3 @@ pub struct CodegenResults {\n     pub linker_info: back::linker::LinkerInfo,\n     pub crate_info: CrateInfo,\n }\n-\n-__build_diagnostic_array! { librustc_codegen_ssa, DIAGNOSTICS }"}, {"sha": "c41e46398467a7e37d4becd8edde36a8731705d2", "filename": "src/librustc_codegen_ssa/mir/block.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -14,7 +14,7 @@ use crate::traits::*;\n \n use std::borrow::Cow;\n \n-use syntax::symbol::LocalInternedString;\n+use syntax::symbol::Symbol;\n use syntax_pos::Pos;\n \n use super::{FunctionCx, LocalRef};\n@@ -397,7 +397,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n \n         // Get the location information.\n         let loc = bx.sess().source_map().lookup_char_pos(span.lo());\n-        let filename = LocalInternedString::intern(&loc.file.name.to_string());\n+        let filename = Symbol::intern(&loc.file.name.to_string());\n         let line = bx.const_u32(loc.line as u32);\n         let col = bx.const_u32(loc.col.to_usize() as u32 + 1);\n \n@@ -418,8 +418,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     vec![file_line_col, index, len])\n             }\n             _ => {\n-                let str = msg.description();\n-                let msg_str = LocalInternedString::intern(str);\n+                let msg_str = Symbol::intern(msg.description());\n                 let msg_file_line_col = bx.static_panic_msg(\n                     Some(msg_str),\n                     filename,\n@@ -531,15 +530,15 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             let layout = bx.layout_of(ty);\n             if layout.abi.is_uninhabited() {\n                 let loc = bx.sess().source_map().lookup_char_pos(span.lo());\n-                let filename = LocalInternedString::intern(&loc.file.name.to_string());\n+                let filename = Symbol::intern(&loc.file.name.to_string());\n                 let line = bx.const_u32(loc.line as u32);\n                 let col = bx.const_u32(loc.col.to_usize() as u32 + 1);\n \n                 let str = format!(\n                     \"Attempted to instantiate uninhabited type {}\",\n                     ty\n                 );\n-                let msg_str = LocalInternedString::intern(&str);\n+                let msg_str = Symbol::intern(&str);\n                 let msg_file_line_col = bx.static_panic_msg(\n                     Some(msg_str),\n                     filename,\n@@ -609,17 +608,19 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                         mir::Operand::Copy(\n                             Place {\n                                 base: PlaceBase::Static(box Static {\n-                                    kind: StaticKind::Promoted(promoted),\n+                                    kind: StaticKind::Promoted(promoted, _),\n                                     ty,\n+                                    def_id: _,\n                                 }),\n                                 projection: None,\n                             }\n                         ) |\n                         mir::Operand::Move(\n                             Place {\n                                 base: PlaceBase::Static(box Static {\n-                                    kind: StaticKind::Promoted(promoted),\n+                                    kind: StaticKind::Promoted(promoted, _),\n                                     ty,\n+                                    def_id: _,\n                                 }),\n                                 projection: None,\n                             }\n@@ -987,7 +988,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n \n         // Handle both by-ref and immediate tuples.\n         if let Ref(llval, None, align) = tuple.val {\n-            let tuple_ptr = PlaceRef::new_sized(llval, tuple.layout, align);\n+            let tuple_ptr = PlaceRef::new_sized_aligned(llval, tuple.layout, align);\n             for i in 0..tuple.layout.fields.count() {\n                 let field_ptr = tuple_ptr.project_field(bx, i);\n                 let field = bx.load_operand(field_ptr);\n@@ -1201,7 +1202,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         let llty = bx.backend_type(src.layout);\n         let cast_ptr = bx.pointercast(dst.llval, bx.type_ptr_to(llty));\n         let align = src.layout.align.abi.min(dst.align);\n-        src.val.store(bx, PlaceRef::new_sized(cast_ptr, src.layout, align));\n+        src.val.store(bx, PlaceRef::new_sized_aligned(cast_ptr, src.layout, align));\n     }\n \n "}, {"sha": "00e9ca01f4dd257c6a78d5eb6229da08e3bd8f2a", "filename": "src/librustc_codegen_ssa/mir/mod.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -289,7 +289,7 @@ pub fn codegen_mir<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n                 if local == mir::RETURN_PLACE && fx.fn_ty.ret.is_indirect() {\n                     debug!(\"alloc: {:?} (return place) -> place\", local);\n                     let llretptr = bx.get_param(0);\n-                    LocalRef::Place(PlaceRef::new_sized(llretptr, layout, layout.align.abi))\n+                    LocalRef::Place(PlaceRef::new_sized(llretptr, layout))\n                 } else if memory_locals.contains(local) {\n                     debug!(\"alloc: {:?} -> place\", local);\n                     if layout.is_unsized() {\n@@ -518,19 +518,19 @@ fn arg_local_refs<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n                 PassMode::Ignore(IgnoreMode::CVarArgs) => {}\n                 PassMode::Direct(_) => {\n                     let llarg = bx.get_param(llarg_idx);\n-                    bx.set_value_name(llarg, &name);\n+                    bx.set_var_name(llarg, &name);\n                     llarg_idx += 1;\n                     return local(\n                         OperandRef::from_immediate_or_packed_pair(bx, llarg, arg.layout));\n                 }\n                 PassMode::Pair(..) => {\n-                    let a = bx.get_param(llarg_idx);\n-                    bx.set_value_name(a, &(name.clone() + \".0\"));\n-                    llarg_idx += 1;\n+                    let (a, b) = (bx.get_param(llarg_idx), bx.get_param(llarg_idx + 1));\n+                    llarg_idx += 2;\n \n-                    let b = bx.get_param(llarg_idx);\n-                    bx.set_value_name(b, &(name + \".1\"));\n-                    llarg_idx += 1;\n+                    // FIXME(eddyb) these are scalar components,\n+                    // maybe extract the high-level fields?\n+                    bx.set_var_name(a, format_args!(\"{}.0\", name));\n+                    bx.set_var_name(b, format_args!(\"{}.1\", name));\n \n                     return local(OperandRef {\n                         val: OperandValue::Pair(a, b),\n@@ -546,9 +546,9 @@ fn arg_local_refs<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n             // already put it in a temporary alloca and gave it up.\n             // FIXME: lifetimes\n             let llarg = bx.get_param(llarg_idx);\n-            bx.set_value_name(llarg, &name);\n+            bx.set_var_name(llarg, &name);\n             llarg_idx += 1;\n-            PlaceRef::new_sized(llarg, arg.layout, arg.layout.align.abi)\n+            PlaceRef::new_sized(llarg, arg.layout)\n         } else if arg.is_unsized_indirect() {\n             // As the storage for the indirect argument lives during\n             // the whole function call, we just copy the fat pointer."}, {"sha": "a8ab3ea10ed166b363ff1c200e5c834f1e9f1f53", "filename": "src/librustc_codegen_ssa/mir/operand.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -485,7 +485,6 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                         bx.load_operand(PlaceRef::new_sized(\n                             bx.cx().const_undef(bx.cx().type_ptr_to(bx.cx().backend_type(layout))),\n                             layout,\n-                            layout.align.abi,\n                         ))\n                     })\n             }"}, {"sha": "b8e10d34302920bf146d76469c3d97827e91da80", "filename": "src/librustc_codegen_ssa/mir/place.rs", "status": "modified", "additions": 24, "deletions": 9, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -1,4 +1,4 @@\n-use rustc::ty::{self, Ty};\n+use rustc::ty::{self, Instance, Ty};\n use rustc::ty::layout::{self, Align, TyLayout, LayoutOf, VariantIdx, HasTyCtxt};\n use rustc::mir;\n use rustc::mir::tcx::PlaceTy;\n@@ -30,6 +30,19 @@ impl<'a, 'tcx, V: CodegenObject> PlaceRef<'tcx, V> {\n     pub fn new_sized(\n         llval: V,\n         layout: TyLayout<'tcx>,\n+    ) -> PlaceRef<'tcx, V> {\n+        assert!(!layout.is_unsized());\n+        PlaceRef {\n+            llval,\n+            llextra: None,\n+            layout,\n+            align: layout.align.abi\n+        }\n+    }\n+\n+    pub fn new_sized_aligned(\n+        llval: V,\n+        layout: TyLayout<'tcx>,\n         align: Align,\n     ) -> PlaceRef<'tcx, V> {\n         assert!(!layout.is_unsized());\n@@ -45,14 +58,13 @@ impl<'a, 'tcx, V: CodegenObject> PlaceRef<'tcx, V> {\n         bx: &mut Bx,\n         llval: V,\n         layout: TyLayout<'tcx>,\n-        align: Align,\n     ) -> PlaceRef<'tcx, V> {\n         assert!(!bx.cx().type_has_metadata(layout.ty));\n         PlaceRef {\n             llval,\n             llextra: None,\n             layout,\n-            align\n+            align: layout.align.abi\n         }\n     }\n \n@@ -64,7 +76,7 @@ impl<'a, 'tcx, V: CodegenObject> PlaceRef<'tcx, V> {\n         debug!(\"alloca({:?}: {:?})\", name, layout);\n         assert!(!layout.is_unsized(), \"tried to statically allocate unsized place\");\n         let tmp = bx.alloca(bx.cx().backend_type(layout), name, layout.align.abi);\n-        Self::new_sized(tmp, layout, layout.align.abi)\n+        Self::new_sized(tmp, layout)\n     }\n \n     /// Returns a place for an indirect reference to an unsized place.\n@@ -454,13 +466,15 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             mir::PlaceRef {\n                 base: mir::PlaceBase::Static(box mir::Static {\n                     ty,\n-                    kind: mir::StaticKind::Promoted(promoted),\n+                    kind: mir::StaticKind::Promoted(promoted, substs),\n+                    def_id,\n                 }),\n                 projection: None,\n             } => {\n                 let param_env = ty::ParamEnv::reveal_all();\n+                let instance = Instance::new(*def_id, self.monomorphize(substs));\n                 let cid = mir::interpret::GlobalId {\n-                    instance: self.instance,\n+                    instance: instance,\n                     promoted: Some(*promoted),\n                 };\n                 let layout = cx.layout_of(self.monomorphize(&ty));\n@@ -480,22 +494,23 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                         let llval = bx.cx().const_undef(\n                             bx.cx().type_ptr_to(bx.cx().backend_type(layout))\n                         );\n-                        PlaceRef::new_sized(llval, layout, layout.align.abi)\n+                        PlaceRef::new_sized(llval, layout)\n                     }\n                 }\n             }\n             mir::PlaceRef {\n                 base: mir::PlaceBase::Static(box mir::Static {\n                     ty,\n-                    kind: mir::StaticKind::Static(def_id),\n+                    kind: mir::StaticKind::Static,\n+                    def_id,\n                 }),\n                 projection: None,\n             } => {\n                 // NB: The layout of a static may be unsized as is the case when working\n                 // with a static that is an extern_type.\n                 let layout = cx.layout_of(self.monomorphize(&ty));\n                 let static_ = bx.get_static(*def_id);\n-                PlaceRef::new_thin_place(bx, static_, layout, layout.align.abi)\n+                PlaceRef::new_thin_place(bx, static_, layout)\n             },\n             mir::PlaceRef {\n                 base,"}, {"sha": "e0ad2527229badb3eaa4df852f26db1084c07e11", "filename": "src/librustc_codegen_ssa/mir/rvalue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -71,7 +71,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                         scratch.storage_dead(&mut bx);\n                     }\n                     OperandValue::Ref(llref, None, align) => {\n-                        let source = PlaceRef::new_sized(llref, operand.layout, align);\n+                        let source = PlaceRef::new_sized_aligned(llref, operand.layout, align);\n                         base::coerce_unsized_into(&mut bx, source, dest);\n                     }\n                     OperandValue::Ref(_, Some(_), _) => {"}, {"sha": "594f45c833758874caf2d4220bdc9cfe1784f35a", "filename": "src/librustc_codegen_ssa/mir/statement.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_codegen_ssa%2Fmir%2Fstatement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_codegen_ssa%2Fmir%2Fstatement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fstatement.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -29,7 +29,21 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                             self.codegen_rvalue_unsized(bx, cg_indirect_dest, rvalue)\n                         }\n                         LocalRef::Operand(None) => {\n-                            let (bx, operand) = self.codegen_rvalue_operand(bx, rvalue);\n+                            let (mut bx, operand) = self.codegen_rvalue_operand(bx, rvalue);\n+                            if let Some(name) = self.mir.local_decls[index].name {\n+                                match operand.val {\n+                                    OperandValue::Ref(x, ..) |\n+                                    OperandValue::Immediate(x) => {\n+                                        bx.set_var_name(x, name);\n+                                    }\n+                                    OperandValue::Pair(a, b) => {\n+                                        // FIXME(eddyb) these are scalar components,\n+                                        // maybe extract the high-level fields?\n+                                        bx.set_var_name(a, format_args!(\"{}.0\", name));\n+                                        bx.set_var_name(b, format_args!(\"{}.1\", name));\n+                                    }\n+                                }\n+                            }\n                             self.locals[index] = LocalRef::Operand(Some(operand));\n                             bx\n                         }"}, {"sha": "5801963c101ef1079dc773e837b7ca58c50fa656", "filename": "src/librustc_codegen_ssa/mono_item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_codegen_ssa%2Fmono_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_codegen_ssa%2Fmono_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmono_item.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -58,7 +58,7 @@ impl<'a, 'tcx: 'a> MonoItemExt<'a, 'tcx> for MonoItem<'tcx> {\n                self.to_raw_string(),\n                cx.codegen_unit().name());\n \n-        let symbol_name = self.symbol_name(cx.tcx()).as_str();\n+        let symbol_name = self.symbol_name(cx.tcx()).name.as_str();\n \n         debug!(\"symbol {}\", &symbol_name);\n "}, {"sha": "9c16b864ef21dce3b48d1c017b16cb8b885848ac", "filename": "src/librustc_codegen_ssa/traits/debuginfo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_codegen_ssa%2Ftraits%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_codegen_ssa%2Ftraits%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fdebuginfo.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -57,5 +57,5 @@ pub trait DebugInfoBuilderMethods<'tcx>: BackendTypes {\n         span: Span,\n     );\n     fn insert_reference_to_gdb_debug_scripts_section_global(&mut self);\n-    fn set_value_name(&mut self, value: Self::Value, name: &str);\n+    fn set_var_name(&mut self, value: Self::Value, name: impl ToString);\n }"}, {"sha": "73c4c053979173449661ba4e0714b330f2d2ed4f", "filename": "src/librustc_codegen_ssa/traits/statics.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_codegen_ssa%2Ftraits%2Fstatics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_codegen_ssa%2Ftraits%2Fstatics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fstatics.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -1,5 +1,5 @@\n use super::BackendTypes;\n-use syntax_pos::symbol::LocalInternedString;\n+use syntax_pos::symbol::Symbol;\n use rustc::hir::def_id::DefId;\n use rustc::ty::layout::Align;\n \n@@ -12,8 +12,8 @@ pub trait StaticBuilderMethods: BackendTypes {\n     fn get_static(&mut self, def_id: DefId) -> Self::Value;\n     fn static_panic_msg(\n         &mut self,\n-        msg: Option<LocalInternedString>,\n-        filename: LocalInternedString,\n+        msg: Option<Symbol>,\n+        filename: Symbol,\n         line: Self::Value,\n         col: Self::Value,\n         kind: &str,"}, {"sha": "1201446afb53128dddbd1b0a52134801ae72d6ff", "filename": "src/librustc_codegen_utils/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_codegen_utils%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_codegen_utils%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Flib.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -10,7 +10,6 @@\n #![feature(core_intrinsics)]\n #![feature(never_type)]\n #![feature(nll)]\n-#![feature(rustc_diagnostic_macros)]\n #![feature(in_band_lifetimes)]\n \n #![recursion_limit=\"256\"]"}, {"sha": "51269be4e9f409f25f5165939b858adb677a894a", "filename": "src/librustc_codegen_utils/symbol_names_test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_codegen_utils%2Fsymbol_names_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_codegen_utils%2Fsymbol_names_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fsymbol_names_test.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -40,7 +40,7 @@ impl SymbolNamesTest<'tcx> {\n                 let instance = Instance::mono(tcx, def_id);\n                 let mangled = self.tcx.symbol_name(instance);\n                 tcx.sess.span_err(attr.span, &format!(\"symbol-name({})\", mangled));\n-                if let Ok(demangling) = rustc_demangle::try_demangle(&mangled.as_str()) {\n+                if let Ok(demangling) = rustc_demangle::try_demangle(&mangled.name.as_str()) {\n                     tcx.sess.span_err(attr.span, &format!(\"demangling({})\", demangling));\n                     tcx.sess.span_err(attr.span, &format!(\"demangling-alt({:#})\", demangling));\n                 }"}, {"sha": "ea771d9f20f8b69a60068870ba93060854736233", "filename": "src/librustc_data_structures/tiny_list.rs", "status": "modified", "additions": 16, "deletions": 40, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_data_structures%2Ftiny_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_data_structures%2Ftiny_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Ftiny_list.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -20,7 +20,6 @@ pub struct TinyList<T: PartialEq> {\n }\n \n impl<T: PartialEq> TinyList<T> {\n-\n     #[inline]\n     pub fn new() -> TinyList<T> {\n         TinyList {\n@@ -60,20 +59,24 @@ impl<T: PartialEq> TinyList<T> {\n \n     #[inline]\n     pub fn contains(&self, data: &T) -> bool {\n-        if let Some(ref head) = self.head {\n-            head.contains(data)\n-        } else {\n-            false\n+        let mut elem = self.head.as_ref();\n+        while let Some(ref e) = elem {\n+            if &e.data == data {\n+                return true;\n+            }\n+            elem = e.next.as_ref().map(|e| &**e);\n         }\n+        false\n     }\n \n     #[inline]\n     pub fn len(&self) -> usize {\n-        if let Some(ref head) = self.head {\n-            head.len()\n-        } else {\n-            0\n+        let (mut elem, mut count) = (self.head.as_ref(), 0);\n+        while let Some(ref e) = elem {\n+            count += 1;\n+            elem = e.next.as_ref().map(|e| &**e);\n         }\n+        count\n     }\n }\n \n@@ -84,40 +87,13 @@ struct Element<T: PartialEq> {\n }\n \n impl<T: PartialEq> Element<T> {\n-\n     fn remove_next(&mut self, data: &T) -> bool {\n-        let new_next = if let Some(ref mut next) = self.next {\n-            if next.data != *data {\n-                return next.remove_next(data)\n-            } else {\n-                next.next.take()\n-            }\n-        } else {\n-            return false\n+        let new_next = match self.next {\n+            Some(ref mut next) if next.data == *data => next.next.take(),\n+            Some(ref mut next) => return next.remove_next(data),\n+            None => return false,\n         };\n-\n         self.next = new_next;\n-\n         true\n     }\n-\n-    fn len(&self) -> usize {\n-        if let Some(ref next) = self.next {\n-            1 + next.len()\n-        } else {\n-            1\n-        }\n-    }\n-\n-    fn contains(&self, data: &T) -> bool {\n-        if self.data == *data {\n-            return true\n-        }\n-\n-        if let Some(ref next) = self.next {\n-            next.contains(data)\n-        } else {\n-            false\n-        }\n-    }\n }"}, {"sha": "0142631590cc9af411574dbf2ab8835b47852754", "filename": "src/librustc_data_structures/tiny_list/tests.rs", "status": "modified", "additions": 29, "deletions": 6, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_data_structures%2Ftiny_list%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_data_structures%2Ftiny_list%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Ftiny_list%2Ftests.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -1,7 +1,7 @@\n use super::*;\n \n extern crate test;\n-use test::Bencher;\n+use test::{Bencher, black_box};\n \n #[test]\n fn test_contains_and_insert() {\n@@ -98,36 +98,59 @@ fn test_remove_single() {\n #[bench]\n fn bench_insert_empty(b: &mut Bencher) {\n     b.iter(|| {\n-        let mut list = TinyList::new();\n+        let mut list = black_box(TinyList::new());\n         list.insert(1);\n+        list\n     })\n }\n \n #[bench]\n fn bench_insert_one(b: &mut Bencher) {\n     b.iter(|| {\n-        let mut list = TinyList::new_single(0);\n+        let mut list = black_box(TinyList::new_single(0));\n         list.insert(1);\n+        list\n     })\n }\n \n+#[bench]\n+fn bench_contains_empty(b: &mut Bencher) {\n+    b.iter(|| {\n+        black_box(TinyList::new()).contains(&1)\n+    });\n+}\n+\n+#[bench]\n+fn bench_contains_unknown(b: &mut Bencher) {\n+    b.iter(|| {\n+        black_box(TinyList::new_single(0)).contains(&1)\n+    });\n+}\n+\n+#[bench]\n+fn bench_contains_one(b: &mut Bencher) {\n+    b.iter(|| {\n+        black_box(TinyList::new_single(1)).contains(&1)\n+    });\n+}\n+\n #[bench]\n fn bench_remove_empty(b: &mut Bencher) {\n     b.iter(|| {\n-        TinyList::new().remove(&1)\n+        black_box(TinyList::new()).remove(&1)\n     });\n }\n \n #[bench]\n fn bench_remove_unknown(b: &mut Bencher) {\n     b.iter(|| {\n-        TinyList::new_single(0).remove(&1)\n+        black_box(TinyList::new_single(0)).remove(&1)\n     });\n }\n \n #[bench]\n fn bench_remove_one(b: &mut Bencher) {\n     b.iter(|| {\n-        TinyList::new_single(1).remove(&1)\n+        black_box(TinyList::new_single(1)).remove(&1)\n     });\n }"}, {"sha": "a839ee56b2b6e9a3cda5ff776d66556abf92dc0a", "filename": "src/librustc_driver/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_driver%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_driver%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2FCargo.toml?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -12,7 +12,7 @@ crate-type = [\"dylib\"]\n [dependencies]\n graphviz = { path = \"../libgraphviz\" }\n log = \"0.4\"\n-env_logger = { version = \"0.5\", default-features = false }\n+env_logger = { version = \"0.6\", default-features = false }\n rustc = { path = \"../librustc\" }\n rustc_target = { path = \"../librustc_target\" }\n rustc_ast_borrowck = { path = \"../librustc_ast_borrowck\" }"}, {"sha": "0906d358badd49dcbd940e5fc6e2f59ccd817756", "filename": "src/librustc_driver/args.rs", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_driver%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_driver%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fargs.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -0,0 +1,53 @@\n+use std::error;\n+use std::fmt;\n+use std::fs;\n+use std::io;\n+use std::str;\n+use std::sync::atomic::{AtomicBool, Ordering};\n+\n+static USED_ARGSFILE_FEATURE: AtomicBool = AtomicBool::new(false);\n+\n+pub fn used_unstable_argsfile() -> bool {\n+    USED_ARGSFILE_FEATURE.load(Ordering::Relaxed)\n+}\n+\n+pub fn arg_expand(arg: String) -> Result<Vec<String>, Error> {\n+    if arg.starts_with(\"@\") {\n+        let path = &arg[1..];\n+        let file = match fs::read_to_string(path) {\n+            Ok(file) => {\n+                USED_ARGSFILE_FEATURE.store(true, Ordering::Relaxed);\n+                file\n+            }\n+            Err(ref err) if err.kind() == io::ErrorKind::InvalidData => {\n+                return Err(Error::Utf8Error(Some(path.to_string())));\n+            }\n+            Err(err) => return Err(Error::IOError(path.to_string(), err)),\n+        };\n+        Ok(file.lines().map(ToString::to_string).collect())\n+    } else {\n+        Ok(vec![arg])\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub enum Error {\n+    Utf8Error(Option<String>),\n+    IOError(String, io::Error),\n+}\n+\n+impl fmt::Display for Error {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match self {\n+            Error::Utf8Error(None) => write!(fmt, \"Utf8 error\"),\n+            Error::Utf8Error(Some(path)) => write!(fmt, \"Utf8 error in {}\", path),\n+            Error::IOError(path, err) => write!(fmt, \"IO Error: {}: {}\", path, err),\n+        }\n+    }\n+}\n+\n+impl error::Error for Error {\n+    fn description(&self) -> &'static str {\n+        \"argument error\"\n+    }\n+}"}, {"sha": "a912ea3c358215cae6f9f49788b6bf535579a71b", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 45, "deletions": 14, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -9,7 +9,6 @@\n #![feature(box_syntax)]\n #![cfg_attr(unix, feature(libc))]\n #![feature(nll)]\n-#![feature(rustc_diagnostic_macros)]\n #![feature(set_stdio)]\n #![feature(no_debug)]\n #![feature(integer_atomics)]\n@@ -68,6 +67,7 @@ use syntax::symbol::sym;\n use syntax_pos::{DUMMY_SP, MultiSpan, FileName};\n \n pub mod pretty;\n+mod args;\n \n /// Exit status code used for successful compilation and help output.\n pub const EXIT_SUCCESS: i32 = 0;\n@@ -141,14 +141,22 @@ impl Callbacks for TimePassesCallbacks {\n // See comments on CompilerCalls below for details about the callbacks argument.\n // The FileLoader provides a way to load files from sources other than the file system.\n pub fn run_compiler(\n-    args: &[String],\n+    at_args: &[String],\n     callbacks: &mut (dyn Callbacks + Send),\n     file_loader: Option<Box<dyn FileLoader + Send + Sync>>,\n     emitter: Option<Box<dyn Write + Send>>\n ) -> interface::Result<()> {\n+    let mut args = Vec::new();\n+    for arg in at_args {\n+        match args::arg_expand(arg.clone()) {\n+            Ok(arg) => args.extend(arg),\n+            Err(err) => early_error(ErrorOutputType::default(),\n+                &format!(\"Failed to load argument file: {}\", err)),\n+        }\n+    }\n     let diagnostic_output = emitter.map(|emitter| DiagnosticOutput::Raw(emitter))\n                                    .unwrap_or(DiagnosticOutput::Default);\n-    let matches = match handle_options(args) {\n+    let matches = match handle_options(&args) {\n         Some(matches) => matches,\n         None => return Ok(()),\n     };\n@@ -430,6 +438,15 @@ fn make_input(free_matches: &[String]) -> Option<(Input, Option<PathBuf>, Option\n             } else {\n                 None\n             };\n+            if let Ok(path) = env::var(\"UNSTABLE_RUSTDOC_TEST_PATH\") {\n+                let line = env::var(\"UNSTABLE_RUSTDOC_TEST_LINE\").\n+                            expect(\"when UNSTABLE_RUSTDOC_TEST_PATH is set \\\n+                                    UNSTABLE_RUSTDOC_TEST_LINE also needs to be set\");\n+                let line = isize::from_str_radix(&line, 10).\n+                            expect(\"UNSTABLE_RUSTDOC_TEST_LINE needs to be an number\");\n+                let file_name = FileName::doc_test_source_code(PathBuf::from(path), line);\n+                return Some((Input::Str { name: file_name, input: src }, None, err));\n+            }\n             Some((Input::Str { name: FileName::anon_source_code(&src), input: src },\n                   None, err))\n         } else {\n@@ -779,13 +796,19 @@ fn usage(verbose: bool, include_unstable_options: bool) {\n     } else {\n         \"\\n    --help -v           Print the full set of options rustc accepts\"\n     };\n-    println!(\"{}\\nAdditional help:\n+    let at_path = if verbose && nightly_options::is_nightly_build() {\n+        \"    @path               Read newline separated options from `path`\\n\"\n+    } else {\n+        \"\"\n+    };\n+    println!(\"{options}{at_path}\\nAdditional help:\n     -C help             Print codegen options\n     -W help             \\\n-              Print 'lint' options and default settings{}{}\\n\",\n-             options.usage(message),\n-             nightly_help,\n-             verbose_help);\n+              Print 'lint' options and default settings{nightly}{verbose}\\n\",\n+             options = options.usage(message),\n+             at_path = at_path,\n+             nightly = nightly_help,\n+             verbose = verbose_help);\n }\n \n fn print_wall_help() {\n@@ -1010,6 +1033,12 @@ pub fn handle_options(args: &[String]) -> Option<getopts::Matches> {\n     //   (unstable option being used on stable)\n     nightly_options::check_nightly_options(&matches, &config::rustc_optgroups());\n \n+    // Late check to see if @file was used without unstable options enabled\n+    if crate::args::used_unstable_argsfile() && !nightly_options::is_unstable_enabled(&matches) {\n+        early_error(ErrorOutputType::default(),\n+            \"@path is unstable - use -Z unstable-options to enable its use\");\n+    }\n+\n     if matches.opt_present(\"h\") || matches.opt_present(\"help\") {\n         // Only show unstable options in --help if we accept unstable options.\n         usage(matches.opt_present(\"verbose\"), nightly_options::is_unstable_enabled(&matches));\n@@ -1135,11 +1164,13 @@ pub fn report_ices_to_stderr_if_any<F: FnOnce() -> R, R>(f: F) -> Result<R, Erro\n             // Thread panicked without emitting a fatal diagnostic\n             eprintln!(\"\");\n \n-            let emitter =\n-                Box::new(errors::emitter::EmitterWriter::stderr(errors::ColorConfig::Auto,\n-                                                                None,\n-                                                                false,\n-                                                                false));\n+            let emitter = Box::new(errors::emitter::EmitterWriter::stderr(\n+                errors::ColorConfig::Auto,\n+                None,\n+                false,\n+                false,\n+                None,\n+            ));\n             let handler = errors::Handler::with_emitter(true, None, emitter);\n \n             // a .span_bug or .bug call has already printed what\n@@ -1190,7 +1221,7 @@ pub fn main() {\n     let result = report_ices_to_stderr_if_any(|| {\n         let args = env::args_os().enumerate()\n             .map(|(i, arg)| arg.into_string().unwrap_or_else(|arg| {\n-                early_error(ErrorOutputType::default(),\n+                    early_error(ErrorOutputType::default(),\n                             &format!(\"Argument {} is not valid Unicode: {:?}\", i, arg))\n             }))\n             .collect::<Vec<_>>();"}, {"sha": "c4d3ad946f9f6ffe5481ff6999f61fe29e2bb49c", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -1,7 +1,5 @@\n //! The various pretty-printing routines.\n \n-use rustc::cfg;\n-use rustc::cfg::graphviz::LabelledCFG;\n use rustc::hir;\n use rustc::hir::map as hir_map;\n use rustc::hir::map::blocks;\n@@ -14,6 +12,7 @@ use rustc::util::common::ErrorReported;\n use rustc_interface::util::ReplaceBodyWithLoop;\n use rustc_ast_borrowck as borrowck;\n use rustc_ast_borrowck::graphviz as borrowck_dot;\n+use rustc_ast_borrowck::cfg::{self, graphviz::LabelledCFG};\n use rustc_mir::util::{write_mir_pretty, write_mir_graphviz};\n \n use syntax::ast;"}, {"sha": "1541845bb55f62f5a39a577e34e053967bee8d53", "filename": "src/librustc_errors/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_errors%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_errors%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2FCargo.toml?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -18,3 +18,4 @@ unicode-width = \"0.1.4\"\n atty = \"0.2\"\n termcolor = \"1.0\"\n annotate-snippets = \"0.6.1\"\n+term_size = \"0.3.1\""}, {"sha": "39b906141f74c2bc5ba633a3003b0ab7f4f735be", "filename": "src/librustc_errors/annotate_snippet_emitter_writer.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_errors%2Fannotate_snippet_emitter_writer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_errors%2Fannotate_snippet_emitter_writer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fannotate_snippet_emitter_writer.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -30,12 +30,14 @@ pub struct AnnotateSnippetEmitterWriter {\n impl Emitter for AnnotateSnippetEmitterWriter {\n     /// The entry point for the diagnostics generation\n     fn emit_diagnostic(&mut self, db: &DiagnosticBuilder<'_>) {\n-        let primary_span = db.span.clone();\n-        let children = db.children.clone();\n-        // FIXME(#59346): Collect suggestions (see emitter.rs)\n-        let suggestions: &[_] = &[];\n+        let mut children = db.children.clone();\n+        let (mut primary_span, suggestions) = self.primary_span_formatted(&db);\n \n-        // FIXME(#59346): Add `fix_multispans_in_std_macros` function from emitter.rs\n+        self.fix_multispans_in_std_macros(&self.source_map,\n+                                          &mut primary_span,\n+                                          &mut children,\n+                                          &db.level,\n+                                          db.handler.flags.external_macro_backtrace);\n \n         self.emit_messages_default(&db.level,\n                                    db.message(),\n@@ -107,7 +109,7 @@ impl<'a>  DiagnosticConverter<'a> {\n         annotated_files: Vec<FileWithAnnotatedLines>,\n         primary_lo: Loc\n     ) -> Vec<Slice> {\n-        // FIXME(#59346): Provide a test case where `annotated_files` is > 1\n+        // FIXME(#64205): Provide a test case where `annotated_files` is > 1\n         annotated_files.iter().flat_map(|annotated_file| {\n             annotated_file.lines.iter().map(|line| {\n                 let line_source = Self::source_string(annotated_file.file.clone(), &line);"}, {"sha": "0ce69eecc6b1ead2068c18a7c9e6805a45282649", "filename": "src/librustc_errors/emitter.rs", "status": "modified", "additions": 532, "deletions": 223, "changes": 755, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_errors%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_errors%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Femitter.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -24,7 +24,7 @@ use rustc_data_structures::sync::Lrc;\n use std::borrow::Cow;\n use std::io::prelude::*;\n use std::io;\n-use std::cmp::{min, Reverse};\n+use std::cmp::{min, max, Reverse};\n use std::path::Path;\n use termcolor::{StandardStream, ColorChoice, ColorSpec, BufferWriter, Ansi};\n use termcolor::{WriteColor, Color, Buffer};\n@@ -51,9 +51,127 @@ impl HumanReadableErrorType {\n         dst: Box<dyn Write + Send>,\n         source_map: Option<Lrc<SourceMapperDyn>>,\n         teach: bool,\n+        terminal_width: Option<usize>,\n     ) -> EmitterWriter {\n         let (short, color_config) = self.unzip();\n-        EmitterWriter::new(dst, source_map, short, teach, color_config.suggests_using_colors())\n+        let color = color_config.suggests_using_colors();\n+        EmitterWriter::new(dst, source_map, short, teach, color, terminal_width)\n+    }\n+}\n+\n+#[derive(Clone, Copy, Debug)]\n+struct Margin {\n+    /// The available whitespace in the left that can be consumed when centering.\n+    pub whitespace_left: usize,\n+    /// The column of the beginning of left-most span.\n+    pub span_left: usize,\n+    /// The column of the end of right-most span.\n+    pub span_right: usize,\n+    /// The beginning of the line to be displayed.\n+    pub computed_left: usize,\n+    /// The end of the line to be displayed.\n+    pub computed_right: usize,\n+    /// The current width of the terminal. 140 by default and in tests.\n+    pub column_width: usize,\n+    /// The end column of a span label, including the span. Doesn't account for labels not in the\n+    /// same line as the span.\n+    pub label_right: usize,\n+}\n+\n+impl Margin {\n+    fn new(\n+        whitespace_left: usize,\n+        span_left: usize,\n+        span_right: usize,\n+        label_right: usize,\n+        column_width: usize,\n+        max_line_len: usize,\n+    ) -> Self {\n+        // The 6 is padding to give a bit of room for `...` when displaying:\n+        // ```\n+        // error: message\n+        //   --> file.rs:16:58\n+        //    |\n+        // 16 | ... fn foo(self) -> Self::Bar {\n+        //    |                     ^^^^^^^^^\n+        // ```\n+\n+        let mut m = Margin {\n+            whitespace_left: if whitespace_left >= 6 { whitespace_left - 6 } else { 0 },\n+            span_left: if span_left >= 6 { span_left - 6 } else { 0 },\n+            span_right: span_right + 6,\n+            computed_left: 0,\n+            computed_right: 0,\n+            column_width,\n+            label_right: label_right + 6,\n+        };\n+        m.compute(max_line_len);\n+        m\n+    }\n+\n+    fn was_cut_left(&self) -> bool {\n+        self.computed_left > 0\n+    }\n+\n+    fn was_cut_right(&self, line_len: usize) -> bool {\n+        let right = if self.computed_right == self.span_right ||\n+            self.computed_right == self.label_right\n+        {\n+            // Account for the \"...\" padding given above. Otherwise we end up with code lines that\n+            // do fit but end in \"...\" as if they were trimmed.\n+            self.computed_right - 6\n+        } else {\n+            self.computed_right\n+        };\n+        right < line_len && line_len > self.computed_left + self.column_width\n+    }\n+\n+    fn compute(&mut self, max_line_len: usize) {\n+        // When there's a lot of whitespace (>20), we want to trim it as it is useless.\n+        self.computed_left = if self.whitespace_left > 20 {\n+            self.whitespace_left - 16 // We want some padding.\n+        } else {\n+            0\n+        };\n+        // We want to show as much as possible, max_line_len is the right-most boundary for the\n+        // relevant code.\n+        self.computed_right = max(max_line_len, self.computed_left);\n+\n+        if self.computed_right - self.computed_left > self.column_width {\n+            // Trimming only whitespace isn't enough, let's get craftier.\n+            if self.label_right - self.whitespace_left <= self.column_width {\n+                // Attempt to fit the code window only trimming whitespace.\n+                self.computed_left = self.whitespace_left;\n+                self.computed_right = self.computed_left + self.column_width;\n+            } else if self.label_right - self.span_left <= self.column_width {\n+                // Attempt to fit the code window considering only the spans and labels.\n+                let padding_left = (self.column_width - (self.label_right - self.span_left)) / 2;\n+                self.computed_left = self.span_left.saturating_sub(padding_left);\n+                self.computed_right = self.computed_left + self.column_width;\n+            } else if self.span_right - self.span_left <= self.column_width {\n+                // Attempt to fit the code window considering the spans and labels plus padding.\n+                let padding_left = (self.column_width - (self.span_right - self.span_left)) / 5 * 2;\n+                self.computed_left = self.span_left.saturating_sub(padding_left);\n+                self.computed_right = self.computed_left + self.column_width;\n+            } else { // Mostly give up but still don't show the full line.\n+                self.computed_left = self.span_left;\n+                self.computed_right = self.span_right;\n+            }\n+        }\n+    }\n+\n+    fn left(&self, line_len: usize) -> usize {\n+        min(self.computed_left, line_len)\n+    }\n+\n+    fn right(&self, line_len: usize) -> usize {\n+        if max(line_len, self.computed_left) - self.computed_left <= self.column_width {\n+            line_len\n+        } else if self.computed_right > line_len {\n+            line_len\n+        } else {\n+            self.computed_right\n+        }\n     }\n }\n \n@@ -73,16 +191,25 @@ pub trait Emitter {\n     fn should_show_explain(&self) -> bool {\n         true\n     }\n-}\n \n-impl Emitter for EmitterWriter {\n-    fn emit_diagnostic(&mut self, db: &DiagnosticBuilder<'_>) {\n+    /// Formats the substitutions of the primary_span\n+    ///\n+    /// The are a lot of conditions to this method, but in short:\n+    ///\n+    /// * If the current `Diagnostic` has only one visible `CodeSuggestion`,\n+    ///   we format the `help` suggestion depending on the content of the\n+    ///   substitutions. In that case, we return the modified span only.\n+    ///\n+    /// * If the current `Diagnostic` has multiple suggestions,\n+    ///   we return the original `primary_span` and the original suggestions.\n+    fn primary_span_formatted<'a>(\n+        &mut self,\n+        db: &'a DiagnosticBuilder<'_>\n+    ) -> (MultiSpan, &'a [CodeSuggestion]) {\n         let mut primary_span = db.span.clone();\n-        let mut children = db.children.clone();\n-        let mut suggestions: &[_] = &[];\n-\n         if let Some((sugg, rest)) = db.suggestions.split_first() {\n             if rest.is_empty() &&\n+               // ^ if there is only one suggestion\n                // don't display multi-suggestions as labels\n                sugg.substitutions.len() == 1 &&\n                // don't display multipart suggestions as labels\n@@ -98,23 +225,164 @@ impl Emitter for EmitterWriter {\n             {\n                 let substitution = &sugg.substitutions[0].parts[0].snippet.trim();\n                 let msg = if substitution.len() == 0 || sugg.style.hide_inline() {\n-                    // This substitution is only removal or we explicitly don't want to show the\n-                    // code inline, don't show it\n+                    // This substitution is only removal OR we explicitly don't want to show the\n+                    // code inline (`hide_inline`). Therefore, we don't show the substitution.\n                     format!(\"help: {}\", sugg.msg)\n                 } else {\n+                    // Show the default suggestion text with the substitution\n                     format!(\"help: {}: `{}`\", sugg.msg, substitution)\n                 };\n                 primary_span.push_span_label(sugg.substitutions[0].parts[0].span, msg);\n+\n+                // We return only the modified primary_span\n+                (primary_span, &[])\n             } else {\n                 // if there are multiple suggestions, print them all in full\n                 // to be consistent. We could try to figure out if we can\n                 // make one (or the first one) inline, but that would give\n                 // undue importance to a semi-random suggestion\n-                suggestions = &db.suggestions;\n+                (primary_span, &db.suggestions)\n             }\n+        } else {\n+            (primary_span, &db.suggestions)\n         }\n+    }\n \n-        self.fix_multispans_in_std_macros(&mut primary_span,\n+    // This does a small \"fix\" for multispans by looking to see if it can find any that\n+    // point directly at <*macros>. Since these are often difficult to read, this\n+    // will change the span to point at the use site.\n+    fn fix_multispans_in_std_macros(&self,\n+                                    source_map: &Option<Lrc<SourceMapperDyn>>,\n+                                    span: &mut MultiSpan,\n+                                    children: &mut Vec<SubDiagnostic>,\n+                                    level: &Level,\n+                                    backtrace: bool) {\n+        let mut spans_updated = self.fix_multispan_in_std_macros(source_map, span, backtrace);\n+        for child in children.iter_mut() {\n+            spans_updated |= self.fix_multispan_in_std_macros(\n+                                 source_map,\n+                                 &mut child.span,\n+                                 backtrace\n+                             );\n+        }\n+        let msg = if level == &Error {\n+            \"this error originates in a macro outside of the current crate \\\n+             (in Nightly builds, run with -Z external-macro-backtrace \\\n+              for more info)\".to_string()\n+        } else {\n+            \"this warning originates in a macro outside of the current crate \\\n+             (in Nightly builds, run with -Z external-macro-backtrace \\\n+              for more info)\".to_string()\n+        };\n+\n+        if spans_updated {\n+            children.push(SubDiagnostic {\n+                level: Level::Note,\n+                message: vec![\n+                    (msg,\n+                     Style::NoStyle),\n+                ],\n+                span: MultiSpan::new(),\n+                render_span: None,\n+            });\n+        }\n+    }\n+\n+    // This \"fixes\" MultiSpans that contain Spans that are pointing to locations inside of\n+    // <*macros>. Since these locations are often difficult to read, we move these Spans from\n+    // <*macros> to their corresponding use site.\n+    fn fix_multispan_in_std_macros(&self,\n+                                   source_map: &Option<Lrc<SourceMapperDyn>>,\n+                                   span: &mut MultiSpan,\n+                                   always_backtrace: bool) -> bool {\n+        let mut spans_updated = false;\n+\n+        if let Some(ref sm) = source_map {\n+            let mut before_after: Vec<(Span, Span)> = vec![];\n+            let mut new_labels: Vec<(Span, String)> = vec![];\n+\n+            // First, find all the spans in <*macros> and point instead at their use site\n+            for sp in span.primary_spans() {\n+                if sp.is_dummy() {\n+                    continue;\n+                }\n+                let call_sp = sm.call_span_if_macro(*sp);\n+                if call_sp != *sp && !always_backtrace {\n+                    before_after.push((*sp, call_sp));\n+                }\n+                let backtrace_len = sp.macro_backtrace().len();\n+                for (i, trace) in sp.macro_backtrace().iter().rev().enumerate() {\n+                    // Only show macro locations that are local\n+                    // and display them like a span_note\n+                    if trace.def_site_span.is_dummy() {\n+                        continue;\n+                    }\n+                    if always_backtrace {\n+                        new_labels.push((trace.def_site_span,\n+                                            format!(\"in this expansion of `{}`{}\",\n+                                                    trace.macro_decl_name,\n+                                                    if backtrace_len > 2 {\n+                                                        // if backtrace_len == 1 it'll be pointed\n+                                                        // at by \"in this macro invocation\"\n+                                                        format!(\" (#{})\", i + 1)\n+                                                    } else {\n+                                                        String::new()\n+                                                    })));\n+                    }\n+                    // Check to make sure we're not in any <*macros>\n+                    if !sm.span_to_filename(trace.def_site_span).is_macros() &&\n+                        !trace.macro_decl_name.starts_with(\"desugaring of \") &&\n+                        !trace.macro_decl_name.starts_with(\"#[\") ||\n+                        always_backtrace {\n+                        new_labels.push((trace.call_site,\n+                                            format!(\"in this macro invocation{}\",\n+                                                    if backtrace_len > 2 && always_backtrace {\n+                                                        // only specify order when the macro\n+                                                        // backtrace is multiple levels deep\n+                                                        format!(\" (#{})\", i + 1)\n+                                                    } else {\n+                                                        String::new()\n+                                                    })));\n+                        if !always_backtrace {\n+                            break;\n+                        }\n+                    }\n+                }\n+            }\n+            for (label_span, label_text) in new_labels {\n+                span.push_span_label(label_span, label_text);\n+            }\n+            for sp_label in span.span_labels() {\n+                if sp_label.span.is_dummy() {\n+                    continue;\n+                }\n+                if sm.span_to_filename(sp_label.span.clone()).is_macros() &&\n+                    !always_backtrace\n+                {\n+                    let v = sp_label.span.macro_backtrace();\n+                    if let Some(use_site) = v.last() {\n+                        before_after.push((sp_label.span.clone(), use_site.call_site.clone()));\n+                    }\n+                }\n+            }\n+            // After we have them, make sure we replace these 'bad' def sites with their use sites\n+            for (before, after) in before_after {\n+                span.replace(before, after);\n+                spans_updated = true;\n+            }\n+        }\n+\n+        spans_updated\n+    }\n+}\n+\n+impl Emitter for EmitterWriter {\n+    fn emit_diagnostic(&mut self, db: &DiagnosticBuilder<'_>) {\n+        let mut children = db.children.clone();\n+        let (mut primary_span, suggestions) = self.primary_span_formatted(&db);\n+\n+        self.fix_multispans_in_std_macros(&self.sm,\n+                                          &mut primary_span,\n                                           &mut children,\n                                           &db.level,\n                                           db.handler.flags.external_macro_backtrace);\n@@ -180,6 +448,7 @@ pub struct EmitterWriter {\n     short_message: bool,\n     teach: bool,\n     ui_testing: bool,\n+    terminal_width: Option<usize>,\n }\n \n #[derive(Debug)]\n@@ -190,18 +459,21 @@ pub struct FileWithAnnotatedLines {\n }\n \n impl EmitterWriter {\n-    pub fn stderr(color_config: ColorConfig,\n-                  source_map: Option<Lrc<SourceMapperDyn>>,\n-                  short_message: bool,\n-                  teach: bool)\n-                  -> EmitterWriter {\n+    pub fn stderr(\n+        color_config: ColorConfig,\n+        source_map: Option<Lrc<SourceMapperDyn>>,\n+        short_message: bool,\n+        teach: bool,\n+        terminal_width: Option<usize>,\n+    ) -> EmitterWriter {\n         let dst = Destination::from_stderr(color_config);\n         EmitterWriter {\n             dst,\n             sm: source_map,\n             short_message,\n             teach,\n             ui_testing: false,\n+            terminal_width,\n         }\n     }\n \n@@ -211,13 +483,15 @@ impl EmitterWriter {\n         short_message: bool,\n         teach: bool,\n         colored: bool,\n+        terminal_width: Option<usize>,\n     ) -> EmitterWriter {\n         EmitterWriter {\n             dst: Raw(dst, colored),\n             sm: source_map,\n             short_message,\n             teach,\n             ui_testing: false,\n+            terminal_width,\n         }\n     }\n \n@@ -234,12 +508,70 @@ impl EmitterWriter {\n         }\n     }\n \n-    fn render_source_line(&self,\n-                          buffer: &mut StyledBuffer,\n-                          file: Lrc<SourceFile>,\n-                          line: &Line,\n-                          width_offset: usize,\n-                          code_offset: usize) -> Vec<(usize, Style)> {\n+    fn draw_line(\n+        &self,\n+        buffer: &mut StyledBuffer,\n+        source_string: &str,\n+        line_index: usize,\n+        line_offset: usize,\n+        width_offset: usize,\n+        code_offset: usize,\n+        margin: Margin,\n+    ) {\n+        let line_len = source_string.len();\n+        // Create the source line we will highlight.\n+        let left = margin.left(line_len);\n+        let right = margin.right(line_len);\n+        // On long lines, we strip the source line, accounting for unicode.\n+        let mut taken = 0;\n+        let code: String = source_string.chars().skip(left).take_while(|ch| {\n+            // Make sure that the trimming on the right will fall within the terminal width.\n+            // FIXME: `unicode_width` sometimes disagrees with terminals on how wide a `char` is.\n+            // For now, just accept that sometimes the code line will be longer than desired.\n+            let next = unicode_width::UnicodeWidthChar::width(*ch).unwrap_or(1);\n+            if taken + next > right - left {\n+                return false;\n+            }\n+            taken += next;\n+            true\n+        }).collect();\n+        buffer.puts(line_offset, code_offset, &code, Style::Quotation);\n+        if margin.was_cut_left() {\n+            // We have stripped some code/whitespace from the beginning, make it clear.\n+            buffer.puts(line_offset, code_offset, \"...\", Style::LineNumber);\n+        }\n+        if margin.was_cut_right(line_len) {\n+            // We have stripped some code after the right-most span end, make it clear we did so.\n+            buffer.puts(line_offset, code_offset + taken - 3, \"...\", Style::LineNumber);\n+        }\n+        buffer.puts(line_offset, 0, &self.maybe_anonymized(line_index), Style::LineNumber);\n+\n+        draw_col_separator(buffer, line_offset, width_offset - 2);\n+    }\n+\n+    fn render_source_line(\n+        &self,\n+        buffer: &mut StyledBuffer,\n+        file: Lrc<SourceFile>,\n+        line: &Line,\n+        width_offset: usize,\n+        code_offset: usize,\n+        margin: Margin,\n+    ) -> Vec<(usize, Style)> {\n+        // Draw:\n+        //\n+        //   LL | ... code ...\n+        //      |     ^^-^ span label\n+        //      |       |\n+        //      |       secondary span label\n+        //\n+        //   ^^ ^ ^^^ ^^^^ ^^^ we don't care about code too far to the right of a span, we trim it\n+        //   |  | |   |\n+        //   |  | |   actual code found in your source code and the spans we use to mark it\n+        //   |  | when there's too much wasted space to the left, trim it\n+        //   |  vertical divider between the column number and the code\n+        //   column number\n+\n         if line.line_index == 0 {\n             return Vec::new();\n         }\n@@ -251,14 +583,21 @@ impl EmitterWriter {\n \n         let line_offset = buffer.num_lines();\n \n-        // First create the source line we will highlight.\n-        buffer.puts(line_offset, code_offset, &source_string, Style::Quotation);\n-        buffer.puts(line_offset,\n-                    0,\n-                    &self.maybe_anonymized(line.line_index),\n-                    Style::LineNumber);\n+        let left = margin.left(source_string.len()); // Left trim\n+        // Account for unicode characters of width !=0 that were removed.\n+        let left = source_string.chars().take(left).fold(0, |acc, ch| {\n+            acc + unicode_width::UnicodeWidthChar::width(ch).unwrap_or(1)\n+        });\n \n-        draw_col_separator(buffer, line_offset, width_offset - 2);\n+        self.draw_line(\n+            buffer,\n+            &source_string,\n+            line.line_index,\n+            line_offset,\n+            width_offset,\n+            code_offset,\n+            margin,\n+        );\n \n         // Special case when there's only one annotation involved, it is the start of a multiline\n         // span and there's no text at the beginning of the code line. Instead of doing the whole\n@@ -279,18 +618,13 @@ impl EmitterWriter {\n         if line.annotations.len() == 1 {\n             if let Some(ref ann) = line.annotations.get(0) {\n                 if let AnnotationType::MultilineStart(depth) = ann.annotation_type {\n-                    if source_string.chars()\n-                                    .take(ann.start_col)\n-                                    .all(|c| c.is_whitespace()) {\n+                    if source_string.chars().take(ann.start_col).all(|c| c.is_whitespace()) {\n                         let style = if ann.is_primary {\n                             Style::UnderlinePrimary\n                         } else {\n                             Style::UnderlineSecondary\n                         };\n-                        buffer.putc(line_offset,\n-                                    width_offset + depth - 1,\n-                                    '/',\n-                                    style);\n+                        buffer.putc(line_offset, width_offset + depth - 1, '/', style);\n                         return vec![(depth, style)];\n                     }\n                 }\n@@ -511,19 +845,23 @@ impl EmitterWriter {\n             match annotation.annotation_type {\n                 AnnotationType::MultilineStart(depth) |\n                 AnnotationType::MultilineEnd(depth) => {\n-                    draw_range(buffer,\n-                               '_',\n-                               line_offset + pos,\n-                               width_offset + depth,\n-                               code_offset + annotation.start_col,\n-                               style);\n+                    draw_range(\n+                        buffer,\n+                        '_',\n+                        line_offset + pos,\n+                        width_offset + depth,\n+                        code_offset + annotation.start_col - left,\n+                        style,\n+                    );\n                 }\n                 _ if self.teach => {\n-                    buffer.set_style_range(line_offset,\n-                                           code_offset + annotation.start_col,\n-                                           code_offset + annotation.end_col,\n-                                           style,\n-                                           annotation.is_primary);\n+                    buffer.set_style_range(\n+                        line_offset,\n+                        code_offset + annotation.start_col - left,\n+                        code_offset + annotation.end_col - left,\n+                        style,\n+                        annotation.is_primary,\n+                    );\n                 }\n                 _ => {}\n             }\n@@ -551,7 +889,7 @@ impl EmitterWriter {\n             if pos > 1 && (annotation.has_label() || annotation.takes_space()) {\n                 for p in line_offset + 1..=line_offset + pos {\n                     buffer.putc(p,\n-                                code_offset + annotation.start_col,\n+                                code_offset + annotation.start_col - margin.computed_left,\n                                 '|',\n                                 style);\n                 }\n@@ -595,15 +933,20 @@ impl EmitterWriter {\n                 Style::LabelSecondary\n             };\n             let (pos, col) = if pos == 0 {\n-                (pos + 1, annotation.end_col + 1)\n+                (pos + 1, if annotation.end_col + 1 > left {\n+                    annotation.end_col + 1 - left\n+                } else {\n+                    0\n+                })\n             } else {\n-                (pos + 2, annotation.start_col)\n+                (pos + 2, if annotation.start_col > left {\n+                    annotation.start_col - left\n+                } else {\n+                    0\n+                })\n             };\n             if let Some(ref label) = annotation.label {\n-                buffer.puts(line_offset + pos,\n-                            code_offset + col,\n-                            &label,\n-                            style);\n+                buffer.puts(line_offset + pos, code_offset + col, &label, style);\n             }\n         }\n \n@@ -638,10 +981,16 @@ impl EmitterWriter {\n                 ('-', Style::UnderlineSecondary)\n             };\n             for p in annotation.start_col..annotation.end_col {\n-                buffer.putc(line_offset + 1,\n-                            code_offset + p,\n-                            underline,\n-                            style);\n+                buffer.putc(\n+                    line_offset + 1,\n+                    if code_offset + p > left {\n+                        code_offset + p - left\n+                    } else {\n+                        0\n+                    },\n+                    underline,\n+                    style,\n+                );\n             }\n         }\n         annotations_position.iter().filter_map(|&(_, annotation)| {\n@@ -698,127 +1047,6 @@ impl EmitterWriter {\n         max\n     }\n \n-    // This \"fixes\" MultiSpans that contain Spans that are pointing to locations inside of\n-    // <*macros>. Since these locations are often difficult to read, we move these Spans from\n-    // <*macros> to their corresponding use site.\n-    fn fix_multispan_in_std_macros(&mut self,\n-                                   span: &mut MultiSpan,\n-                                   always_backtrace: bool) -> bool {\n-        let mut spans_updated = false;\n-\n-        if let Some(ref sm) = self.sm {\n-            let mut before_after: Vec<(Span, Span)> = vec![];\n-            let mut new_labels: Vec<(Span, String)> = vec![];\n-\n-            // First, find all the spans in <*macros> and point instead at their use site\n-            for sp in span.primary_spans() {\n-                if sp.is_dummy() {\n-                    continue;\n-                }\n-                let call_sp = sm.call_span_if_macro(*sp);\n-                if call_sp != *sp && !always_backtrace {\n-                    before_after.push((*sp, call_sp));\n-                }\n-                let backtrace_len = sp.macro_backtrace().len();\n-                for (i, trace) in sp.macro_backtrace().iter().rev().enumerate() {\n-                    // Only show macro locations that are local\n-                    // and display them like a span_note\n-                    if trace.def_site_span.is_dummy() {\n-                        continue;\n-                    }\n-                    if always_backtrace {\n-                        new_labels.push((trace.def_site_span,\n-                                            format!(\"in this expansion of `{}`{}\",\n-                                                    trace.macro_decl_name,\n-                                                    if backtrace_len > 2 {\n-                                                        // if backtrace_len == 1 it'll be pointed\n-                                                        // at by \"in this macro invocation\"\n-                                                        format!(\" (#{})\", i + 1)\n-                                                    } else {\n-                                                        String::new()\n-                                                    })));\n-                    }\n-                    // Check to make sure we're not in any <*macros>\n-                    if !sm.span_to_filename(trace.def_site_span).is_macros() &&\n-                        !trace.macro_decl_name.starts_with(\"desugaring of \") &&\n-                        !trace.macro_decl_name.starts_with(\"#[\") ||\n-                        always_backtrace {\n-                        new_labels.push((trace.call_site,\n-                                            format!(\"in this macro invocation{}\",\n-                                                    if backtrace_len > 2 && always_backtrace {\n-                                                        // only specify order when the macro\n-                                                        // backtrace is multiple levels deep\n-                                                        format!(\" (#{})\", i + 1)\n-                                                    } else {\n-                                                        String::new()\n-                                                    })));\n-                        if !always_backtrace {\n-                            break;\n-                        }\n-                    }\n-                }\n-            }\n-            for (label_span, label_text) in new_labels {\n-                span.push_span_label(label_span, label_text);\n-            }\n-            for sp_label in span.span_labels() {\n-                if sp_label.span.is_dummy() {\n-                    continue;\n-                }\n-                if sm.span_to_filename(sp_label.span.clone()).is_macros() &&\n-                    !always_backtrace\n-                {\n-                    let v = sp_label.span.macro_backtrace();\n-                    if let Some(use_site) = v.last() {\n-                        before_after.push((sp_label.span.clone(), use_site.call_site.clone()));\n-                    }\n-                }\n-            }\n-            // After we have them, make sure we replace these 'bad' def sites with their use sites\n-            for (before, after) in before_after {\n-                span.replace(before, after);\n-                spans_updated = true;\n-            }\n-        }\n-\n-        spans_updated\n-    }\n-\n-    // This does a small \"fix\" for multispans by looking to see if it can find any that\n-    // point directly at <*macros>. Since these are often difficult to read, this\n-    // will change the span to point at the use site.\n-    fn fix_multispans_in_std_macros(&mut self,\n-                                    span: &mut MultiSpan,\n-                                    children: &mut Vec<SubDiagnostic>,\n-                                    level: &Level,\n-                                    backtrace: bool) {\n-        let mut spans_updated = self.fix_multispan_in_std_macros(span, backtrace);\n-        for child in children.iter_mut() {\n-            spans_updated |= self.fix_multispan_in_std_macros(&mut child.span, backtrace);\n-        }\n-        let msg = if level == &Error {\n-            \"this error originates in a macro outside of the current crate \\\n-             (in Nightly builds, run with -Z external-macro-backtrace \\\n-              for more info)\".to_string()\n-        } else {\n-            \"this warning originates in a macro outside of the current crate \\\n-             (in Nightly builds, run with -Z external-macro-backtrace \\\n-              for more info)\".to_string()\n-        };\n-\n-        if spans_updated {\n-            children.push(SubDiagnostic {\n-                level: Level::Note,\n-                message: vec![\n-                    (msg,\n-                     Style::NoStyle),\n-                ],\n-                span: MultiSpan::new(),\n-                render_span: None,\n-            });\n-        }\n-    }\n-\n     /// Adds a left margin to every line but the first, given a padding length and the label being\n     /// displayed, keeping the provided highlighting.\n     fn msg_to_buffer(&self,\n@@ -979,22 +1207,30 @@ impl EmitterWriter {\n                     let buffer_msg_line_offset = buffer.num_lines();\n \n                     buffer.prepend(buffer_msg_line_offset, \"--> \", Style::LineNumber);\n-                    buffer.append(buffer_msg_line_offset,\n-                                  &format!(\"{}:{}:{}\",\n-                                           loc.file.name,\n-                                           sm.doctest_offset_line(&loc.file.name, loc.line),\n-                                           loc.col.0 + 1),\n-                                  Style::LineAndColumn);\n+                    buffer.append(\n+                        buffer_msg_line_offset,\n+                        &format!(\n+                            \"{}:{}:{}\",\n+                            loc.file.name,\n+                            sm.doctest_offset_line(&loc.file.name, loc.line),\n+                            loc.col.0 + 1,\n+                        ),\n+                        Style::LineAndColumn,\n+                    );\n                     for _ in 0..max_line_num_len {\n                         buffer.prepend(buffer_msg_line_offset, \" \", Style::NoStyle);\n                     }\n                 } else {\n-                    buffer.prepend(0,\n-                                   &format!(\"{}:{}:{}: \",\n-                                            loc.file.name,\n-                                            sm.doctest_offset_line(&loc.file.name, loc.line),\n-                                            loc.col.0 + 1),\n-                                   Style::LineAndColumn);\n+                    buffer.prepend(\n+                        0,\n+                        &format!(\n+                            \"{}:{}:{}: \",\n+                            loc.file.name,\n+                            sm.doctest_offset_line(&loc.file.name, loc.line),\n+                            loc.col.0 + 1,\n+                        ),\n+                        Style::LineAndColumn,\n+                    );\n                 }\n             } else if !self.short_message {\n                 // remember where we are in the output buffer for easy reference\n@@ -1037,22 +1273,96 @@ impl EmitterWriter {\n                 // Contains the vertical lines' positions for active multiline annotations\n                 let mut multilines = FxHashMap::default();\n \n+                // Get the left-side margin to remove it\n+                let mut whitespace_margin = std::usize::MAX;\n+                for line_idx in 0..annotated_file.lines.len() {\n+                    let file = annotated_file.file.clone();\n+                    let line = &annotated_file.lines[line_idx];\n+                    if let Some(source_string) = file.get_line(line.line_index - 1) {\n+                        let leading_whitespace = source_string\n+                            .chars()\n+                            .take_while(|c| c.is_whitespace())\n+                            .count();\n+                        if source_string.chars().any(|c| !c.is_whitespace()) {\n+                            whitespace_margin = min(\n+                                whitespace_margin,\n+                                leading_whitespace,\n+                            );\n+                        }\n+                    }\n+                }\n+                if whitespace_margin == std::usize::MAX {\n+                    whitespace_margin = 0;\n+                }\n+\n+                // Left-most column any visible span points at.\n+                let mut span_left_margin = std::usize::MAX;\n+                for line in &annotated_file.lines {\n+                    for ann in &line.annotations {\n+                        span_left_margin = min(span_left_margin, ann.start_col);\n+                        span_left_margin = min(span_left_margin, ann.end_col);\n+                    }\n+                }\n+                if span_left_margin == std::usize::MAX {\n+                    span_left_margin = 0;\n+                }\n+\n+                // Right-most column any visible span points at.\n+                let mut span_right_margin = 0;\n+                let mut label_right_margin = 0;\n+                let mut max_line_len = 0;\n+                for line in &annotated_file.lines {\n+                    max_line_len = max(max_line_len, annotated_file.file\n+                        .get_line(line.line_index - 1)\n+                        .map(|s| s.len())\n+                        .unwrap_or(0));\n+                    for ann in &line.annotations {\n+                        span_right_margin = max(span_right_margin, ann.start_col);\n+                        span_right_margin = max(span_right_margin, ann.end_col);\n+                        // FIXME: account for labels not in the same line\n+                        let label_right = ann.label.as_ref().map(|l| l.len() + 1).unwrap_or(0);\n+                        label_right_margin = max(label_right_margin, ann.end_col + label_right);\n+                    }\n+                }\n+\n+                let width_offset = 3 + max_line_num_len;\n+                let code_offset = if annotated_file.multiline_depth == 0 {\n+                    width_offset\n+                } else {\n+                    width_offset + annotated_file.multiline_depth + 1\n+                };\n+\n+                let column_width = if let Some(width) = self.terminal_width {\n+                    width.saturating_sub(code_offset)\n+                } else if self.ui_testing {\n+                    140\n+                } else {\n+                    term_size::dimensions()\n+                        .map(|(w, _)| w.saturating_sub(code_offset))\n+                        .unwrap_or(std::usize::MAX)\n+                };\n+\n+                let margin = Margin::new(\n+                    whitespace_margin,\n+                    span_left_margin,\n+                    span_right_margin,\n+                    label_right_margin,\n+                    column_width,\n+                    max_line_len,\n+                );\n+\n                 // Next, output the annotate source for this file\n                 for line_idx in 0..annotated_file.lines.len() {\n                     let previous_buffer_line = buffer.num_lines();\n \n-                    let width_offset = 3 + max_line_num_len;\n-                    let code_offset = if annotated_file.multiline_depth == 0 {\n-                        width_offset\n-                    } else {\n-                        width_offset + annotated_file.multiline_depth + 1\n-                    };\n-\n-                    let depths = self.render_source_line(&mut buffer,\n-                                                         annotated_file.file.clone(),\n-                                                         &annotated_file.lines[line_idx],\n-                                                         width_offset,\n-                                                         code_offset);\n+                    let depths = self.render_source_line(\n+                        &mut buffer,\n+                        annotated_file.file.clone(),\n+                        &annotated_file.lines[line_idx],\n+                        width_offset,\n+                        code_offset,\n+                        margin,\n+                    );\n \n                     let mut to_add = FxHashMap::default();\n \n@@ -1099,25 +1409,24 @@ impl EmitterWriter {\n \n                             let last_buffer_line_num = buffer.num_lines();\n \n-                            buffer.puts(last_buffer_line_num,\n-                                        0,\n-                                        &self.maybe_anonymized(annotated_file.lines[line_idx + 1]\n-                                                                             .line_index - 1),\n-                                        Style::LineNumber);\n-                            draw_col_separator(&mut buffer,\n-                                               last_buffer_line_num,\n-                                               1 + max_line_num_len);\n-                            buffer.puts(last_buffer_line_num,\n-                                        code_offset,\n-                                        &unannotated_line,\n-                                        Style::Quotation);\n+                            self.draw_line(\n+                                &mut buffer,\n+                                &unannotated_line,\n+                                annotated_file.lines[line_idx + 1].line_index - 1,\n+                                last_buffer_line_num,\n+                                width_offset,\n+                                code_offset,\n+                                margin,\n+                            );\n \n                             for (depth, style) in &multilines {\n-                                draw_multiline_line(&mut buffer,\n-                                                    last_buffer_line_num,\n-                                                    width_offset,\n-                                                    *depth,\n-                                                    *style);\n+                                draw_multiline_line(\n+                                    &mut buffer,\n+                                    last_buffer_line_num,\n+                                    width_offset,\n+                                    *depth,\n+                                    *style,\n+                                );\n                             }\n                         }\n                     }\n@@ -1207,7 +1516,7 @@ impl EmitterWriter {\n                         // ...or trailing spaces. Account for substitutions containing unicode\n                         // characters.\n                         let sub_len = part.snippet.trim().chars().fold(0, |acc, ch| {\n-                            acc + unicode_width::UnicodeWidthChar::width(ch).unwrap_or(0)\n+                            acc + unicode_width::UnicodeWidthChar::width(ch).unwrap_or(1)\n                         });\n \n                         let underline_start = (span_start_pos + start) as isize + offset;\n@@ -1230,7 +1539,7 @@ impl EmitterWriter {\n \n                         // length of the code after substitution\n                         let full_sub_len = part.snippet.chars().fold(0, |acc, ch| {\n-                            acc + unicode_width::UnicodeWidthChar::width(ch).unwrap_or(0) as isize\n+                            acc + unicode_width::UnicodeWidthChar::width(ch).unwrap_or(1) as isize\n                         });\n \n                         // length of the code to be substituted"}, {"sha": "c1fba416d64334653cf2c59783fd7d9df7115761", "filename": "src/librustc_errors/lib.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_errors%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_errors%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Flib.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -383,7 +383,7 @@ impl Handler {\n                                       cm: Option<Lrc<SourceMapperDyn>>,\n                                       flags: HandlerFlags)\n                                       -> Handler {\n-        let emitter = Box::new(EmitterWriter::stderr(color_config, cm, false, false));\n+        let emitter = Box::new(EmitterWriter::stderr(color_config, cm, false, false, None));\n         Handler::with_emitter_and_flags(emitter, flags)\n     }\n \n@@ -845,3 +845,10 @@ impl Level {\n         }\n     }\n }\n+\n+#[macro_export]\n+macro_rules! pluralise {\n+    ($x:expr) => {\n+        if $x != 1 { \"s\" } else { \"\" }\n+    };\n+}"}, {"sha": "659c4c89fe33c41272a68b3e073eb1b1abfe7413", "filename": "src/librustc_incremental/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_incremental%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_incremental%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2FCargo.toml?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -12,7 +12,7 @@ doctest = false\n [dependencies]\n graphviz = { path = \"../libgraphviz\" }\n log = \"0.4\"\n-rand = \"0.6\"\n+rand = \"0.7\"\n rustc = { path = \"../librustc\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_serialize = { path = \"../libserialize\", package = \"serialize\" }"}, {"sha": "837aa9360c8953fcf8506987317740a987f486aa", "filename": "src/librustc_incremental/persist/dirty_clean.rs", "status": "modified", "additions": 21, "deletions": 6, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -24,6 +24,7 @@ use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use rustc::hir::intravisit;\n use rustc::ich::{ATTR_DIRTY, ATTR_CLEAN};\n use rustc::ty::TyCtxt;\n+use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::fx::FxHashSet;\n use syntax::ast::{self, Attribute, NestedMetaItem};\n use syntax::symbol::{Symbol, sym};\n@@ -71,6 +72,7 @@ const BASE_IMPL: &[&str] = &[\n /// code, i.e., functions+methods\n const BASE_MIR: &[&str] = &[\n     label_strs::optimized_mir,\n+    label_strs::promoted_mir,\n     label_strs::mir_built,\n ];\n \n@@ -472,26 +474,39 @@ impl DirtyCleanVisitor<'tcx> {\n     fn assert_dirty(&self, item_span: Span, dep_node: DepNode) {\n         debug!(\"assert_dirty({:?})\", dep_node);\n \n-        let dep_node_index = self.tcx.dep_graph.dep_node_index_of(&dep_node);\n-        let current_fingerprint = self.tcx.dep_graph.fingerprint_of(dep_node_index);\n+        let current_fingerprint = self.get_fingerprint(&dep_node);\n         let prev_fingerprint = self.tcx.dep_graph.prev_fingerprint_of(&dep_node);\n \n-        if Some(current_fingerprint) == prev_fingerprint {\n+        if current_fingerprint == prev_fingerprint {\n             let dep_node_str = self.dep_node_str(&dep_node);\n             self.tcx.sess.span_err(\n                 item_span,\n                 &format!(\"`{}` should be dirty but is not\", dep_node_str));\n         }\n     }\n \n+    fn get_fingerprint(&self, dep_node: &DepNode) -> Option<Fingerprint> {\n+        if self.tcx.dep_graph.dep_node_exists(dep_node) {\n+            let dep_node_index = self.tcx.dep_graph.dep_node_index_of(dep_node);\n+            Some(self.tcx.dep_graph.fingerprint_of(dep_node_index))\n+        } else {\n+            None\n+        }\n+    }\n+\n     fn assert_clean(&self, item_span: Span, dep_node: DepNode) {\n         debug!(\"assert_clean({:?})\", dep_node);\n \n-        let dep_node_index = self.tcx.dep_graph.dep_node_index_of(&dep_node);\n-        let current_fingerprint = self.tcx.dep_graph.fingerprint_of(dep_node_index);\n+        let current_fingerprint = self.get_fingerprint(&dep_node);\n         let prev_fingerprint = self.tcx.dep_graph.prev_fingerprint_of(&dep_node);\n \n-        if Some(current_fingerprint) != prev_fingerprint {\n+        // if the node wasn't previously evaluated and now is (or vice versa),\n+        // then the node isn't actually clean or dirty.\n+        if (current_fingerprint == None) ^ (prev_fingerprint == None) {\n+            return;\n+        }\n+\n+        if current_fingerprint != prev_fingerprint {\n             let dep_node_str = self.dep_node_str(&dep_node);\n             self.tcx.sess.span_err(\n                 item_span,"}, {"sha": "3cfae1686dfdf911761869c25c49b0f7646bacf8", "filename": "src/librustc_interface/passes.rs", "status": "modified", "additions": 37, "deletions": 34, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_interface%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_interface%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fpasses.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -34,7 +34,7 @@ use rustc_privacy;\n use rustc_resolve::{Resolver, ResolverArenas};\n use rustc_traits;\n use rustc_typeck as typeck;\n-use syntax::{self, ast, diagnostics, visit};\n+use syntax::{self, ast, visit};\n use syntax::early_buffered_lints::BufferedEarlyLint;\n use syntax::ext::base::{NamedSyntaxExtension, ExtCtxt};\n use syntax::mut_visit::MutVisitor;\n@@ -230,10 +230,12 @@ pub fn register_plugins<'a>(\n     crate_name: &str,\n ) -> Result<(ast::Crate, PluginInfo)> {\n     krate = time(sess, \"attributes injection\", || {\n-        syntax::attr::inject(krate, &sess.parse_sess, &sess.opts.debugging_opts.crate_attr)\n+        syntax_ext::cmdline_attrs::inject(\n+            krate, &sess.parse_sess, &sess.opts.debugging_opts.crate_attr\n+        )\n     });\n \n-    let (mut krate, features) = syntax::config::features(\n+    let (krate, features) = syntax::config::features(\n         krate,\n         &sess.parse_sess,\n         sess.edition(),\n@@ -268,16 +270,6 @@ pub fn register_plugins<'a>(\n         middle::recursion_limit::update_limits(sess, &krate);\n     });\n \n-    krate = time(sess, \"crate injection\", || {\n-        let alt_std_name = sess.opts.alt_std_name.as_ref().map(|s| &**s);\n-        let (krate, name) =\n-            syntax_ext::standard_library_imports::inject(krate, alt_std_name, sess.edition());\n-        if let Some(name) = name {\n-            sess.parse_sess.injected_crate_name.set(name);\n-        }\n-        krate\n-    });\n-\n     let registrars = time(sess, \"plugin loading\", || {\n         plugin::load::load_plugins(\n             sess,\n@@ -291,21 +283,6 @@ pub fn register_plugins<'a>(\n     let mut registry = Registry::new(sess, krate.span);\n \n     time(sess, \"plugin registration\", || {\n-        if sess.features_untracked().rustc_diagnostic_macros {\n-            registry.register_macro(\n-                \"__diagnostic_used\",\n-                diagnostics::plugin::expand_diagnostic_used,\n-            );\n-            registry.register_macro(\n-                \"__register_diagnostic\",\n-                diagnostics::plugin::expand_register_diagnostic,\n-            );\n-            registry.register_macro(\n-                \"__build_diagnostic_array\",\n-                diagnostics::plugin::expand_build_diagnostic_array,\n-            );\n-        }\n-\n         for registrar in registrars {\n             registry.args_hidden = Some(registrar.args);\n             (registrar.fun)(&mut registry);\n@@ -370,6 +347,21 @@ fn configure_and_expand_inner<'a>(\n         &resolver_arenas,\n     );\n     syntax_ext::register_builtin_macros(&mut resolver, sess.edition());\n+\n+    krate = time(sess, \"crate injection\", || {\n+        let alt_std_name = sess.opts.alt_std_name.as_ref().map(|s| Symbol::intern(s));\n+        let (krate, name) = syntax_ext::standard_library_imports::inject(\n+            krate,\n+            &mut resolver,\n+            &sess.parse_sess,\n+            alt_std_name,\n+        );\n+        if let Some(name) = name {\n+            sess.parse_sess.injected_crate_name.set(name);\n+        }\n+        krate\n+    });\n+\n     syntax_ext::plugin_macro_defs::inject(\n         &mut krate, &mut resolver, plugin_info.syntax_exts, sess.edition()\n     );\n@@ -473,14 +465,25 @@ fn configure_and_expand_inner<'a>(\n         ast_validation::check_crate(sess, &krate)\n     });\n \n-    // If we're in rustdoc we're always compiling as an rlib, but that'll trip a\n-    // bunch of checks in the `modify` function below. For now just skip this\n-    // step entirely if we're rustdoc as it's not too useful anyway.\n-    if !sess.opts.actually_rustdoc {\n+\n+    let crate_types = sess.crate_types.borrow();\n+    let is_proc_macro_crate = crate_types.contains(&config::CrateType::ProcMacro);\n+\n+    // For backwards compatibility, we don't try to run proc macro injection\n+    // if rustdoc is run on a proc macro crate without '--crate-type proc-macro' being\n+    // specified. This should only affect users who manually invoke 'rustdoc', as\n+    // 'cargo doc' will automatically pass the proper '--crate-type' flags.\n+    // However, we do emit a warning, to let such users know that they should\n+    // start passing '--crate-type proc-macro'\n+    if has_proc_macro_decls && sess.opts.actually_rustdoc && !is_proc_macro_crate {\n+        let mut msg = sess.diagnostic().struct_warn(&\"Trying to document proc macro crate \\\n+            without passing '--crate-type proc-macro to rustdoc\");\n+\n+        msg.warn(\"The generated documentation may be incorrect\");\n+        msg.emit()\n+    } else {\n         krate = time(sess, \"maybe creating a macro crate\", || {\n-            let crate_types = sess.crate_types.borrow();\n             let num_crate_types = crate_types.len();\n-            let is_proc_macro_crate = crate_types.contains(&config::CrateType::ProcMacro);\n             let is_test_crate = sess.opts.test;\n             syntax_ext::proc_macro_harness::inject(\n                 &sess.parse_sess,"}, {"sha": "9eaf7b77716f3f0d62c25d3d4e2f6c54839de019", "filename": "src/librustc_interface/util.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_interface%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_interface%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Futil.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -43,17 +43,17 @@ use std::{thread, panic};\n \n pub fn diagnostics_registry() -> Registry {\n     let mut all_errors = Vec::new();\n-    all_errors.extend_from_slice(&rustc::DIAGNOSTICS);\n-    all_errors.extend_from_slice(&rustc_typeck::DIAGNOSTICS);\n-    all_errors.extend_from_slice(&rustc_resolve::DIAGNOSTICS);\n-    all_errors.extend_from_slice(&rustc_privacy::DIAGNOSTICS);\n+    all_errors.extend_from_slice(&rustc::error_codes::DIAGNOSTICS);\n+    all_errors.extend_from_slice(&rustc_typeck::error_codes::DIAGNOSTICS);\n+    all_errors.extend_from_slice(&rustc_resolve::error_codes::DIAGNOSTICS);\n+    all_errors.extend_from_slice(&rustc_privacy::error_codes::DIAGNOSTICS);\n     // FIXME: need to figure out a way to get these back in here\n     // all_errors.extend_from_slice(get_codegen_backend(sess).diagnostics());\n-    all_errors.extend_from_slice(&rustc_metadata::DIAGNOSTICS);\n-    all_errors.extend_from_slice(&rustc_passes::DIAGNOSTICS);\n-    all_errors.extend_from_slice(&rustc_plugin::DIAGNOSTICS);\n-    all_errors.extend_from_slice(&rustc_mir::DIAGNOSTICS);\n-    all_errors.extend_from_slice(&syntax::DIAGNOSTICS);\n+    all_errors.extend_from_slice(&rustc_metadata::error_codes::DIAGNOSTICS);\n+    all_errors.extend_from_slice(&rustc_passes::error_codes::DIAGNOSTICS);\n+    all_errors.extend_from_slice(&rustc_plugin::error_codes::DIAGNOSTICS);\n+    all_errors.extend_from_slice(&rustc_mir::error_codes::DIAGNOSTICS);\n+    all_errors.extend_from_slice(&syntax::error_codes::DIAGNOSTICS);\n \n     Registry::new(&all_errors)\n }"}, {"sha": "950771f0a692710021dc7e29c18736fdbbe3ea0b", "filename": "src/librustc_lexer/Cargo.toml", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_lexer%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_lexer%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lexer%2FCargo.toml?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -2,14 +2,20 @@\n authors = [\"The Rust Project Developers\"]\n name = \"rustc_lexer\"\n version = \"0.1.0\"\n+license = \"MIT OR Apache-2.0\"\n edition = \"2018\"\n \n-# Note that this crate purposefully does not depend on other rustc crates\n-[dependencies]\n-unicode-xid = { version = \"0.1.0\", optional = true }\n+repository = \"https://github.com/rust-lang/rust/\"\n+description = \"\"\"\n+Rust lexer used by rustc. No stability guarantees are provided.\n+\"\"\"\n \n # Note: do not remove this blank `[lib]` section.\n # This will be used when publishing this crate as `rustc-ap-rustc_lexer`.\n [lib]\n doctest = false\n name = \"rustc_lexer\"\n+\n+# Note that this crate purposefully does not depend on other rustc crates\n+[dependencies]\n+unicode-xid = \"0.2.0\""}, {"sha": "30a5175d8cdb092d59dc19e16080f48e15df19f9", "filename": "src/librustc_lexer/src/lib.rs", "status": "modified", "additions": 72, "deletions": 70, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_lexer%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_lexer%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lexer%2Fsrc%2Flib.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -1,6 +1,5 @@\n-// We want to be able to build this crate with a stable compiler, so feature\n-// flags should be optional.\n-#![cfg_attr(not(feature = \"unicode-xid\"), feature(unicode_internals))]\n+// We want to be able to build this crate with a stable compiler, so no\n+// `#![feature]` attributes should be added.\n \n mod cursor;\n pub mod unescape;\n@@ -103,6 +102,62 @@ pub fn tokenize(mut input: &str) -> impl Iterator<Item = Token> + '_ {\n     })\n }\n \n+// See [UAX #31](http://unicode.org/reports/tr31) for definitions of these\n+// classes.\n+\n+/// True if `c` is considered a whitespace according to Rust language definition.\n+pub fn is_whitespace(c: char) -> bool {\n+    // This is Pattern_White_Space.\n+    //\n+    // Note that this set is stable (ie, it doesn't change with different\n+    // Unicode versions), so it's ok to just hard-code the values.\n+\n+    match c {\n+        // Usual ASCII suspects\n+        | '\\u{0009}' // \\t\n+        | '\\u{000A}' // \\n\n+        | '\\u{000B}' // vertical tab\n+        | '\\u{000C}' // form feed\n+        | '\\u{000D}' // \\r\n+        | '\\u{0020}' // space\n+\n+        // NEXT LINE from latin1\n+        | '\\u{0085}'\n+\n+        // Bidi markers\n+        | '\\u{200E}' // LEFT-TO-RIGHT MARK\n+        | '\\u{200F}' // RIGHT-TO-LEFT MARK\n+\n+        // Dedicated whitespace characters from Unicode\n+        | '\\u{2028}' // LINE SEPARATOR\n+        | '\\u{2029}' // PARAGRAPH SEPARATOR\n+            => true,\n+        _ => false,\n+    }\n+}\n+\n+/// True if `c` is valid as a first character of an identifier.\n+pub fn is_id_start(c: char) -> bool {\n+    // This is XID_Start OR '_' (which formally is not a XID_Start).\n+    // We also add fast-path for ascii idents\n+    ('a' <= c && c <= 'z')\n+        || ('A' <= c && c <= 'Z')\n+        || c == '_'\n+        || (c > '\\x7f' && unicode_xid::UnicodeXID::is_xid_start(c))\n+}\n+\n+/// True if `c` is valid as a non-first character of an identifier.\n+pub fn is_id_continue(c: char) -> bool {\n+    // This is exactly XID_Continue.\n+    // We also add fast-path for ascii idents\n+    ('a' <= c && c <= 'z')\n+        || ('A' <= c && c <= 'Z')\n+        || ('0' <= c && c <= '9')\n+        || c == '_'\n+        || (c > '\\x7f' && unicode_xid::UnicodeXID::is_xid_continue(c))\n+}\n+\n+\n impl Cursor<'_> {\n     fn advance_token(&mut self) -> Token {\n         let first_char = self.bump().unwrap();\n@@ -112,9 +167,9 @@ impl Cursor<'_> {\n                 '*' => self.block_comment(),\n                 _ => Slash,\n             },\n-            c if character_properties::is_whitespace(c) => self.whitespace(),\n+            c if is_whitespace(c) => self.whitespace(),\n             'r' => match (self.nth_char(0), self.nth_char(1)) {\n-                ('#', c1) if character_properties::is_id_start(c1) => self.raw_ident(),\n+                ('#', c1) if is_id_start(c1) => self.raw_ident(),\n                 ('#', _) | ('\"', _) => {\n                     let (n_hashes, started, terminated) = self.raw_double_quoted_string();\n                     let suffix_start = self.len_consumed();\n@@ -159,7 +214,7 @@ impl Cursor<'_> {\n                 }\n                 _ => self.ident(),\n             },\n-            c if character_properties::is_id_start(c) => self.ident(),\n+            c if is_id_start(c) => self.ident(),\n             c @ '0'..='9' => {\n                 let literal_kind = self.number(c);\n                 let suffix_start = self.len_consumed();\n@@ -247,8 +302,8 @@ impl Cursor<'_> {\n     }\n \n     fn whitespace(&mut self) -> TokenKind {\n-        debug_assert!(character_properties::is_whitespace(self.prev()));\n-        while character_properties::is_whitespace(self.nth_char(0)) {\n+        debug_assert!(is_whitespace(self.prev()));\n+        while is_whitespace(self.nth_char(0)) {\n             self.bump();\n         }\n         Whitespace\n@@ -258,19 +313,19 @@ impl Cursor<'_> {\n         debug_assert!(\n             self.prev() == 'r'\n                 && self.nth_char(0) == '#'\n-                && character_properties::is_id_start(self.nth_char(1))\n+                && is_id_start(self.nth_char(1))\n         );\n         self.bump();\n         self.bump();\n-        while character_properties::is_id_continue(self.nth_char(0)) {\n+        while is_id_continue(self.nth_char(0)) {\n             self.bump();\n         }\n         RawIdent\n     }\n \n     fn ident(&mut self) -> TokenKind {\n-        debug_assert!(character_properties::is_id_start(self.prev()));\n-        while character_properties::is_id_continue(self.nth_char(0)) {\n+        debug_assert!(is_id_start(self.prev()));\n+        while is_id_continue(self.nth_char(0)) {\n             self.bump();\n         }\n         Ident\n@@ -315,7 +370,7 @@ impl Cursor<'_> {\n             // integer literal followed by field/method access or a range pattern\n             // (`0..2` and `12.foo()`)\n             '.' if self.nth_char(1) != '.'\n-                && !character_properties::is_id_start(self.nth_char(1)) =>\n+                && !is_id_start(self.nth_char(1)) =>\n             {\n                 // might have stuff after the ., and if it does, it needs to start\n                 // with a number\n@@ -345,15 +400,15 @@ impl Cursor<'_> {\n     fn lifetime_or_char(&mut self) -> TokenKind {\n         debug_assert!(self.prev() == '\\'');\n         let mut starts_with_number = false;\n-        if (character_properties::is_id_start(self.nth_char(0))\n+        if (is_id_start(self.nth_char(0))\n             || self.nth_char(0).is_digit(10) && {\n                 starts_with_number = true;\n                 true\n             })\n             && self.nth_char(1) != '\\''\n         {\n             self.bump();\n-            while character_properties::is_id_continue(self.nth_char(0)) {\n+            while is_id_continue(self.nth_char(0)) {\n                 self.bump();\n             }\n \n@@ -495,66 +550,13 @@ impl Cursor<'_> {\n     }\n \n     fn eat_literal_suffix(&mut self) {\n-        if !character_properties::is_id_start(self.nth_char(0)) {\n+        if !is_id_start(self.nth_char(0)) {\n             return;\n         }\n         self.bump();\n \n-        while character_properties::is_id_continue(self.nth_char(0)) {\n+        while is_id_continue(self.nth_char(0)) {\n             self.bump();\n         }\n     }\n }\n-\n-pub mod character_properties {\n-    // this is Pattern_White_Space\n-    #[cfg(feature = \"unicode-xid\")]\n-    pub fn is_whitespace(c: char) -> bool {\n-        match c {\n-            '\\u{0009}' | '\\u{000A}' | '\\u{000B}' | '\\u{000C}' | '\\u{000D}' | '\\u{0020}'\n-            | '\\u{0085}' | '\\u{200E}' | '\\u{200F}' | '\\u{2028}' | '\\u{2029}' => true,\n-            _ => false,\n-        }\n-    }\n-\n-    #[cfg(not(feature = \"unicode-xid\"))]\n-    pub fn is_whitespace(c: char) -> bool {\n-        core::unicode::property::Pattern_White_Space(c)\n-    }\n-\n-    // this is XID_Start OR '_' (which formally is not a XID_Start)\n-    #[cfg(feature = \"unicode-xid\")]\n-    pub fn is_id_start(c: char) -> bool {\n-        ('a' <= c && c <= 'z')\n-            || ('A' <= c && c <= 'Z')\n-            || c == '_'\n-            || (c > '\\x7f' && unicode_xid::UnicodeXID::is_xid_start(c))\n-    }\n-\n-    #[cfg(not(feature = \"unicode-xid\"))]\n-    pub fn is_id_start(c: char) -> bool {\n-        ('a' <= c && c <= 'z')\n-            || ('A' <= c && c <= 'Z')\n-            || c == '_'\n-            || (c > '\\x7f' && c.is_xid_start())\n-    }\n-\n-    // this is XID_Continue\n-    #[cfg(feature = \"unicode-xid\")]\n-    pub fn is_id_continue(c: char) -> bool {\n-        ('a' <= c && c <= 'z')\n-            || ('A' <= c && c <= 'Z')\n-            || ('0' <= c && c <= '9')\n-            || c == '_'\n-            || (c > '\\x7f' && unicode_xid::UnicodeXID::is_xid_continue(c))\n-    }\n-\n-    #[cfg(not(feature = \"unicode-xid\"))]\n-    pub fn is_id_continue(c: char) -> bool {\n-        ('a' <= c && c <= 'z')\n-            || ('A' <= c && c <= 'Z')\n-            || ('0' <= c && c <= '9')\n-            || c == '_'\n-            || (c > '\\x7f' && c.is_xid_continue())\n-    }\n-}"}, {"sha": "aecf5c5b52dba5996deb93661ba54091435b4fb2", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -482,7 +482,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n         }\n     }\n \n-    fn check_variant(&mut self, cx: &LateContext<'_, '_>, v: &hir::Variant, _: &hir::Generics) {\n+    fn check_variant(&mut self, cx: &LateContext<'_, '_>, v: &hir::Variant) {\n         self.check_missing_docs_attrs(cx,\n                                       Some(v.id),\n                                       &v.attrs,\n@@ -570,7 +570,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDebugImplementations {\n             _ => return,\n         }\n \n-        let debug = match cx.tcx.lang_items().debug_trait() {\n+        let debug = match cx.tcx.get_diagnostic_item(sym::debug_trait) {\n             Some(debug) => debug,\n             None => return,\n         };\n@@ -772,7 +772,7 @@ impl EarlyLintPass for UnusedDocComment {\n     }\n \n     fn check_arm(&mut self, cx: &EarlyContext<'_>, arm: &ast::Arm) {\n-        let arm_span = arm.pats[0].span.with_hi(arm.body.span.hi());\n+        let arm_span = arm.pat.span.with_hi(arm.body.span.hi());\n         self.warn_if_doc(cx, arm_span, \"match arms\", false, &arm.attrs);\n     }\n "}, {"sha": "ea2e1d9ecc53f46553207c643ec5eed7c560de96", "filename": "src/librustc_lint/error_codes.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_lint%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_lint%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ferror_codes.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -1,5 +1,4 @@\n-use syntax::register_diagnostics;\n-\n-register_diagnostics! {\n+syntax::register_diagnostics! {\n+;\n     E0721, // `await` keyword\n }"}, {"sha": "0e054013cd779ed30eab29353d0dd4c1c7cc9b33", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -15,7 +15,6 @@\n #![feature(box_patterns)]\n #![feature(box_syntax)]\n #![feature(nll)]\n-#![feature(rustc_diagnostic_macros)]\n \n #![recursion_limit=\"256\"]\n \n@@ -436,7 +435,12 @@ pub fn register_builtins(store: &mut lint::LintStore, sess: Option<&Session>) {\n             id: LintId::of(INDIRECT_STRUCTURAL_MATCH),\n             reference: \"issue #62411 <https://github.com/rust-lang/rust/issues/62411>\",\n             edition: None,\n-        }\n+        },\n+        FutureIncompatibleInfo {\n+            id: LintId::of(SOFT_UNSTABLE),\n+            reference: \"issue #64266 <https://github.com/rust-lang/rust/issues/64266>\",\n+            edition: None,\n+        },\n         ]);\n \n     // Register renamed and removed lints."}, {"sha": "bb6119d0ff2aa0fbdb7eb701ebb148ea6d592456", "filename": "src/librustc_lint/nonstandard_style.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_lint%2Fnonstandard_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_lint%2Fnonstandard_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fnonstandard_style.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -146,7 +146,7 @@ impl EarlyLintPass for NonCamelCaseTypes {\n         }\n     }\n \n-    fn check_variant(&mut self, cx: &EarlyContext<'_>, v: &ast::Variant, _: &ast::Generics) {\n+    fn check_variant(&mut self, cx: &EarlyContext<'_>, v: &ast::Variant) {\n         self.check_case(cx, \"variant\", &v.ident);\n     }\n \n@@ -350,9 +350,6 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonSnakeCase {\n         &mut self,\n         cx: &LateContext<'_, '_>,\n         s: &hir::VariantData,\n-        _: ast::Name,\n-        _: &hir::Generics,\n-        _: hir::HirId,\n     ) {\n         for sf in s.fields() {\n             self.check_snake_case(cx, \"structure field\", &sf.ident);"}, {"sha": "561bf202dfeff07f7b6813aedd97050a4fcbacf4", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 60, "deletions": 17, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -398,18 +398,37 @@ impl UnusedParens {\n         }\n     }\n \n-    fn check_unused_parens_pat(&self,\n-                                cx: &EarlyContext<'_>,\n-                                value: &ast::Pat,\n-                                msg: &str) {\n-        if let ast::PatKind::Paren(_) = value.node {\n+    fn check_unused_parens_pat(\n+        &self,\n+        cx: &EarlyContext<'_>,\n+        value: &ast::Pat,\n+        avoid_or: bool,\n+        avoid_mut: bool,\n+    ) {\n+        use ast::{PatKind, BindingMode::ByValue, Mutability::Mutable};\n+\n+        if let PatKind::Paren(inner) = &value.node {\n+            match inner.node {\n+                // The lint visitor will visit each subpattern of `p`. We do not want to lint\n+                // any range pattern no matter where it occurs in the pattern. For something like\n+                // `&(a..=b)`, there is a recursive `check_pat` on `a` and `b`, but we will assume\n+                // that if there are unnecessary parens they serve a purpose of readability.\n+                PatKind::Range(..) => return,\n+                // Avoid `p0 | .. | pn` if we should.\n+                PatKind::Or(..) if avoid_or => return,\n+                // Avoid `mut x` and `mut x @ p` if we should:\n+                PatKind::Ident(ByValue(Mutable), ..) if avoid_mut => return,\n+                // Otherwise proceed with linting.\n+                _ => {}\n+            }\n+\n             let pattern_text = if let Ok(snippet) = cx.sess().source_map()\n                 .span_to_snippet(value.span) {\n                     snippet\n                 } else {\n                     pprust::pat_to_string(value)\n                 };\n-            Self::remove_outer_parens(cx, value.span, &pattern_text, msg, (false, false));\n+            Self::remove_outer_parens(cx, value.span, &pattern_text, \"pattern\", (false, false));\n         }\n     }\n \n@@ -474,6 +493,11 @@ impl EarlyLintPass for UnusedParens {\n     fn check_expr(&mut self, cx: &EarlyContext<'_>, e: &ast::Expr) {\n         use syntax::ast::ExprKind::*;\n         let (value, msg, followed_by_block, left_pos, right_pos) = match e.node {\n+            Let(ref pat, ..) => {\n+                self.check_unused_parens_pat(cx, pat, false, false);\n+                return;\n+            }\n+\n             If(ref cond, ref block, ..) => {\n                 let left = e.span.lo() + syntax_pos::BytePos(2);\n                 let right = block.span.lo();\n@@ -486,7 +510,8 @@ impl EarlyLintPass for UnusedParens {\n                 (cond, \"`while` condition\", true, Some(left), Some(right))\n             },\n \n-            ForLoop(_, ref cond, ref block, ..) => {\n+            ForLoop(ref pat, ref cond, ref block, ..) => {\n+                self.check_unused_parens_pat(cx, pat, false, false);\n                 (cond, \"`for` head expression\", true, None, Some(block.span.lo()))\n             }\n \n@@ -531,26 +556,44 @@ impl EarlyLintPass for UnusedParens {\n     }\n \n     fn check_pat(&mut self, cx: &EarlyContext<'_>, p: &ast::Pat) {\n-        use ast::PatKind::{Paren, Range};\n-        // The lint visitor will visit each subpattern of `p`. We do not want to lint any range\n-        // pattern no matter where it occurs in the pattern. For something like `&(a..=b)`, there\n-        // is a recursive `check_pat` on `a` and `b`, but we will assume that if there are\n-        // unnecessary parens they serve a purpose of readability.\n-        if let Paren(ref pat) = p.node {\n-            match pat.node {\n-                Range(..) => {}\n-                _ => self.check_unused_parens_pat(cx, &p, \"pattern\")\n-            }\n+        use ast::{PatKind::*, Mutability};\n+        match &p.node {\n+            // Do not lint on `(..)` as that will result in the other arms being useless.\n+            Paren(_)\n+            // The other cases do not contain sub-patterns.\n+            | Wild | Rest | Lit(..) | Mac(..) | Range(..) | Ident(.., None) | Path(..) => return,\n+            // These are list-like patterns; parens can always be removed.\n+            TupleStruct(_, ps) | Tuple(ps) | Slice(ps) | Or(ps) => for p in ps {\n+                self.check_unused_parens_pat(cx, p, false, false);\n+            },\n+            Struct(_, fps, _) => for f in fps {\n+                self.check_unused_parens_pat(cx, &f.pat, false, false);\n+            },\n+            // Avoid linting on `i @ (p0 | .. | pn)` and `box (p0 | .. | pn)`, #64106.\n+            Ident(.., Some(p)) | Box(p) => self.check_unused_parens_pat(cx, p, true, false),\n+            // Avoid linting on `&(mut x)` as `&mut x` has a different meaning, #55342.\n+            // Also avoid linting on `& mut? (p0 | .. | pn)`, #64106.\n+            Ref(p, m) => self.check_unused_parens_pat(cx, p, true, *m == Mutability::Immutable),\n         }\n     }\n \n     fn check_stmt(&mut self, cx: &EarlyContext<'_>, s: &ast::Stmt) {\n         if let ast::StmtKind::Local(ref local) = s.node {\n+            self.check_unused_parens_pat(cx, &local.pat, false, false);\n+\n             if let Some(ref value) = local.init {\n                 self.check_unused_parens_expr(cx, &value, \"assigned value\", false, None, None);\n             }\n         }\n     }\n+\n+    fn check_param(&mut self, cx: &EarlyContext<'_>, param: &ast::Param) {\n+        self.check_unused_parens_pat(cx, &param.pat, true, false);\n+    }\n+\n+    fn check_arm(&mut self, cx: &EarlyContext<'_>, arm: &ast::Arm) {\n+        self.check_unused_parens_pat(cx, &arm.pat, false, false);\n+    }\n }\n \n declare_lint! {"}, {"sha": "62a3757757b800f9ca77d60cdbe1ed62d7aba071", "filename": "src/librustc_llvm/build.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_llvm%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_llvm%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Fbuild.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -54,15 +54,15 @@ fn main() {\n     // LLVM are compiled the same way, but for us that's typically the case.\n     //\n     // We *want* detect this cross compiling situation by asking llvm-config\n-    // what it's host-target is. If that's not the TARGET, then we're cross\n+    // what its host-target is. If that's not the TARGET, then we're cross\n     // compiling. Unfortunately `llvm-config` seems either be buggy, or we're\n     // misconfiguring it, because the `i686-pc-windows-gnu` build of LLVM will\n     // report itself with a `--host-target` of `x86_64-pc-windows-gnu`. This\n     // tricks us into thinking we're doing a cross build when we aren't, so\n     // havoc ensues.\n     //\n     // In any case, if we're cross compiling, this generally just means that we\n-    // can't trust all the output of llvm-config becaues it might be targeted\n+    // can't trust all the output of llvm-config because it might be targeted\n     // for the host rather than the target. As a result a bunch of blocks below\n     // are gated on `if !is_crossed`\n     let target = env::var(\"TARGET\").expect(\"TARGET was not set\");\n@@ -166,7 +166,7 @@ fn main() {\n \n     let (llvm_kind, llvm_link_arg) = detect_llvm_link();\n \n-    // Link in all LLVM libraries, if we're uwring the \"wrong\" llvm-config then\n+    // Link in all LLVM libraries, if we're using the \"wrong\" llvm-config then\n     // we don't pick up system libs because unfortunately they're for the host\n     // of llvm-config, not the target that we're attempting to link.\n     let mut cmd = Command::new(&llvm_config);"}, {"sha": "d5f3e37dea51cc42e6f0cc4cf7512ee01821a449", "filename": "src/librustc_lsan/build.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_lsan%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_lsan%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lsan%2Fbuild.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -4,6 +4,9 @@ use build_helper::sanitizer_lib_boilerplate;\n use cmake::Config;\n \n fn main() {\n+    if env::var(\"RUSTC_BUILD_SANITIZERS\") != Ok(\"1\".to_string()) {\n+        return;\n+    }\n     if let Some(llvm_config) = env::var_os(\"LLVM_CONFIG\") {\n         build_helper::restore_library_path();\n "}, {"sha": "5bf4067431f24a6b73a8e08ee4c2df3895377021", "filename": "src/librustc_metadata/cstore.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_metadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_metadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -95,11 +95,6 @@ pub struct CrateMetadata {\n     pub raw_proc_macros: Option<&'static [ProcMacro]>,\n }\n \n-pub struct FullProcMacro {\n-    pub name: ast::Name,\n-    pub ext: Lrc<SyntaxExtension>\n-}\n-\n pub struct CStore {\n     metas: RwLock<IndexVec<CrateNum, Option<Lrc<CrateMetadata>>>>,\n     /// Map from NodeId's of local extern crate statements to crate numbers\n@@ -109,7 +104,7 @@ pub struct CStore {\n \n pub enum LoadedMacro {\n     MacroDef(ast::Item),\n-    ProcMacro(Lrc<SyntaxExtension>),\n+    ProcMacro(SyntaxExtension),\n }\n \n impl CStore {"}, {"sha": "d6450f00c8b6a47ca66265365d2d425010d6830b", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 6, "deletions": 22, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -30,11 +30,9 @@ use syntax::ast;\n use syntax::attr;\n use syntax::source_map;\n use syntax::edition::Edition;\n-use syntax::ext::base::{SyntaxExtension, SyntaxExtensionKind};\n-use syntax::ext::proc_macro::BangProcMacro;\n use syntax::parse::source_file_to_stream;\n use syntax::parse::parser::emit_unclosed_delims;\n-use syntax::symbol::{Symbol, sym};\n+use syntax::symbol::Symbol;\n use syntax_pos::{Span, FileName};\n use rustc_data_structures::bit_set::BitSet;\n \n@@ -127,15 +125,8 @@ provide! { <'tcx> tcx, def_id, other, cdata,\n             bug!(\"coerce_unsized_info: `{:?}` is missing its info\", def_id);\n         })\n     }\n-    optimized_mir => {\n-        let mir = cdata.maybe_get_optimized_mir(tcx, def_id.index).unwrap_or_else(|| {\n-            bug!(\"get_optimized_mir: missing MIR for `{:?}`\", def_id)\n-        });\n-\n-        let mir = tcx.arena.alloc(mir);\n-\n-        mir\n-    }\n+    optimized_mir => { tcx.arena.alloc(cdata.get_optimized_mir(tcx, def_id.index)) }\n+    promoted_mir => { tcx.arena.alloc(cdata.get_promoted_mir(tcx, def_id.index)) }\n     mir_const_qualif => {\n         (cdata.mir_const_qualif(def_id.index), tcx.arena.alloc(BitSet::new_empty(0)))\n     }\n@@ -157,7 +148,7 @@ provide! { <'tcx> tcx, def_id, other, cdata,\n     // a `fn` when encoding, so the dep-tracking wouldn't work.\n     // This is only used by rustdoc anyway, which shouldn't have\n     // incremental recompilation ever enabled.\n-    fn_arg_names => { cdata.get_fn_arg_names(def_id.index) }\n+    fn_arg_names => { cdata.get_fn_param_names(def_id.index) }\n     rendered_const => { cdata.get_rendered_const(def_id.index) }\n     impl_parent => { cdata.get_parent_impl(def_id.index) }\n     trait_of_item => { cdata.get_trait_of_item(def_id.index) }\n@@ -235,6 +226,7 @@ provide! { <'tcx> tcx, def_id, other, cdata,\n     }\n     defined_lib_features => { cdata.get_lib_features(tcx) }\n     defined_lang_items => { cdata.get_lang_items(tcx) }\n+    diagnostic_items => { cdata.get_diagnostic_items(tcx) }\n     missing_lang_items => { cdata.get_missing_lang_items(tcx) }\n \n     missing_extern_crate_item => {\n@@ -427,15 +419,7 @@ impl cstore::CStore {\n     pub fn load_macro_untracked(&self, id: DefId, sess: &Session) -> LoadedMacro {\n         let data = self.get_crate_data(id.krate);\n         if data.is_proc_macro_crate() {\n-            return LoadedMacro::ProcMacro(data.get_proc_macro(id.index, sess).ext);\n-        } else if data.name == sym::proc_macro && data.item_name(id.index) == sym::quote {\n-            let client = proc_macro::bridge::client::Client::expand1(proc_macro::quote);\n-            let kind = SyntaxExtensionKind::Bang(Box::new(BangProcMacro { client }));\n-            let ext = SyntaxExtension {\n-                allow_internal_unstable: Some([sym::proc_macro_def_site][..].into()),\n-                ..SyntaxExtension::default(kind, data.root.edition)\n-            };\n-            return LoadedMacro::ProcMacro(Lrc::new(ext));\n+            return LoadedMacro::ProcMacro(data.load_proc_macro(id.index, sess));\n         }\n \n         let def = data.get_macro(id.index);"}, {"sha": "75d7261704722bf6d9bb999df140d14eb10c6b24", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 71, "deletions": 50, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -1,8 +1,9 @@\n // Decoding metadata from a single crate's metadata\n \n-use crate::cstore::{self, CrateMetadata, MetadataBlob, NativeLibrary, ForeignModule, FullProcMacro};\n+use crate::cstore::{self, CrateMetadata, MetadataBlob, NativeLibrary, ForeignModule};\n use crate::schema::*;\n \n+use rustc_data_structures::indexed_vec::IndexVec;\n use rustc_data_structures::sync::{Lrc, ReadGuard};\n use rustc::hir::map::{DefKey, DefPath, DefPathData, DefPathHash};\n use rustc::hir;\n@@ -11,13 +12,14 @@ use rustc::middle::exported_symbols::{ExportedSymbol, SymbolExportLevel};\n use rustc::hir::def::{self, Res, DefKind, CtorOf, CtorKind};\n use rustc::hir::def_id::{CrateNum, DefId, DefIndex, LocalDefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n use rustc_data_structures::fingerprint::Fingerprint;\n+use rustc_data_structures::fx::FxHashMap;\n use rustc::middle::lang_items;\n use rustc::mir::{self, interpret};\n use rustc::mir::interpret::AllocDecodingSession;\n use rustc::session::Session;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::codec::TyDecoder;\n-use rustc::mir::Body;\n+use rustc::mir::{Body, Promoted};\n use rustc::util::captures::Captures;\n \n use std::io;\n@@ -449,11 +451,19 @@ impl<'a, 'tcx> CrateMetadata {\n     pub fn is_proc_macro_crate(&self) -> bool {\n         self.root.proc_macro_decls_static.is_some()\n     }\n+\n     fn is_proc_macro(&self, id: DefIndex) -> bool {\n         self.is_proc_macro_crate() &&\n             self.root.proc_macro_data.unwrap().decode(self).find(|x| *x == id).is_some()\n     }\n \n+    fn entry_unless_proc_macro(&self, id: DefIndex) -> Option<Entry<'tcx>> {\n+        match self.is_proc_macro(id) {\n+            true => None,\n+            false => Some(self.entry(id)),\n+        }\n+    }\n+\n     fn maybe_entry(&self, item_id: DefIndex) -> Option<Lazy<Entry<'tcx>>> {\n         self.root.entries_index.lookup(self.blob.raw_bytes(), item_id)\n     }\n@@ -511,35 +521,14 @@ impl<'a, 'tcx> CrateMetadata {\n         self.entry(index).span.decode((self, sess))\n     }\n \n-\n-    pub fn get_proc_macro(&self, id: DefIndex, sess: &Session) -> FullProcMacro {\n-        if sess.opts.debugging_opts.dual_proc_macros {\n-            let host_lib = self.host_lib.as_ref().unwrap();\n-            self.load_proc_macro(\n-                &host_lib.metadata.get_root(),\n-                id,\n-                sess\n-            )\n-        } else {\n-            self.load_proc_macro(&self.root, id, sess)\n-        }\n-    }\n-\n-    fn load_proc_macro(&self, root: &CrateRoot<'_>,\n-                        id: DefIndex,\n-                        sess: &Session)\n-                        -> FullProcMacro {\n-\n-        let raw_macro = self.raw_proc_macro(id);\n-        let (name, kind, helper_attrs) = match *raw_macro {\n+    crate fn load_proc_macro(&self, id: DefIndex, sess: &Session) -> SyntaxExtension {\n+        let (name, kind, helper_attrs) = match *self.raw_proc_macro(id) {\n             ProcMacro::CustomDerive { trait_name, attributes, client } => {\n                 let helper_attrs =\n                     attributes.iter().cloned().map(Symbol::intern).collect::<Vec<_>>();\n                 (\n                     trait_name,\n-                    SyntaxExtensionKind::Derive(Box::new(ProcMacroDerive {\n-                        client, attrs: helper_attrs.clone()\n-                    })),\n+                    SyntaxExtensionKind::Derive(Box::new(ProcMacroDerive { client })),\n                     helper_attrs,\n                 )\n             }\n@@ -550,17 +539,21 @@ impl<'a, 'tcx> CrateMetadata {\n                 name, SyntaxExtensionKind::Bang(Box::new(BangProcMacro { client })), Vec::new()\n             )\n         };\n+        let edition = if sess.opts.debugging_opts.dual_proc_macros {\n+            self.host_lib.as_ref().unwrap().metadata.get_root().edition\n+        } else {\n+            self.root.edition\n+        };\n \n-        let span = self.get_span(id, sess);\n-\n-        FullProcMacro {\n-            name: Symbol::intern(name),\n-            ext: Lrc::new(SyntaxExtension {\n-                span,\n-                helper_attrs,\n-                ..SyntaxExtension::default(kind, root.edition)\n-            })\n-        }\n+        SyntaxExtension::new(\n+            &sess.parse_sess,\n+            kind,\n+            self.get_span(id, sess),\n+            helper_attrs,\n+            edition,\n+            Symbol::intern(name),\n+            &self.get_attributes(&self.entry(id), sess),\n+        )\n     }\n \n     pub fn get_trait_def(&self, item_id: DefIndex, sess: &Session) -> ty::TraitDef {\n@@ -703,10 +696,8 @@ impl<'a, 'tcx> CrateMetadata {\n     }\n \n     pub fn get_deprecation(&self, id: DefIndex) -> Option<attr::Deprecation> {\n-        match self.is_proc_macro(id) {\n-            true => None,\n-            false => self.entry(id).deprecation.map(|depr| depr.decode(self)),\n-        }\n+        self.entry_unless_proc_macro(id)\n+            .and_then(|entry| entry.deprecation.map(|depr| depr.decode(self)))\n     }\n \n     pub fn get_visibility(&self, id: DefIndex) -> ty::Visibility {\n@@ -767,6 +758,23 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n+    /// Iterates over the diagnostic items in the given crate.\n+    pub fn get_diagnostic_items(\n+        &self,\n+        tcx: TyCtxt<'tcx>,\n+    ) -> &'tcx FxHashMap<Symbol, DefId> {\n+        tcx.arena.alloc(if self.is_proc_macro_crate() {\n+            // Proc macro crates do not export any diagnostic-items to the target.\n+            Default::default()\n+        } else {\n+            self.root\n+                .diagnostic_items\n+                .decode(self)\n+                .map(|(name, def_index)| (name, self.local_def_id(def_index)))\n+                .collect()\n+        })\n+    }\n+\n     /// Iterates over each child of the given item.\n     pub fn each_child_of_item<F>(&self, id: DefIndex, mut callback: F, sess: &Session)\n         where F: FnMut(def::Export<hir::HirId>)\n@@ -916,11 +924,24 @@ impl<'a, 'tcx> CrateMetadata {\n         self.maybe_entry(id).and_then(|item| item.decode(self).mir).is_some()\n     }\n \n-    pub fn maybe_get_optimized_mir(&self, tcx: TyCtxt<'tcx>, id: DefIndex) -> Option<Body<'tcx>> {\n-        match self.is_proc_macro(id) {\n-            true => None,\n-            false => self.entry(id).mir.map(|mir| mir.decode((self, tcx))),\n-        }\n+    pub fn get_optimized_mir(&self, tcx: TyCtxt<'tcx>, id: DefIndex) -> Body<'tcx> {\n+        self.entry_unless_proc_macro(id)\n+            .and_then(|entry| entry.mir.map(|mir| mir.decode((self, tcx))))\n+            .unwrap_or_else(|| {\n+                bug!(\"get_optimized_mir: missing MIR for `{:?}\", self.local_def_id(id))\n+            })\n+    }\n+\n+    pub fn get_promoted_mir(\n+        &self,\n+        tcx: TyCtxt<'tcx>,\n+        id: DefIndex,\n+    ) -> IndexVec<Promoted, Body<'tcx>> {\n+        self.entry_unless_proc_macro(id)\n+            .and_then(|entry| entry.promoted_mir.map(|promoted| promoted.decode((self, tcx))))\n+            .unwrap_or_else(|| {\n+                bug!(\"get_promoted_mir: missing MIR for `{:?}`\", self.local_def_id(id))\n+            })\n     }\n \n     pub fn mir_const_qualif(&self, id: DefIndex) -> u8 {\n@@ -1138,14 +1159,14 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    pub fn get_fn_arg_names(&self, id: DefIndex) -> Vec<ast::Name> {\n-        let arg_names = match self.entry(id).kind {\n+    pub fn get_fn_param_names(&self, id: DefIndex) -> Vec<ast::Name> {\n+        let param_names = match self.entry(id).kind {\n             EntryKind::Fn(data) |\n-            EntryKind::ForeignFn(data) => data.decode(self).arg_names,\n-            EntryKind::Method(data) => data.decode(self).fn_data.arg_names,\n+            EntryKind::ForeignFn(data) => data.decode(self).param_names,\n+            EntryKind::Method(data) => data.decode(self).fn_data.param_names,\n             _ => Lazy::empty(),\n         };\n-        arg_names.decode(self).collect()\n+        param_names.decode(self).collect()\n     }\n \n     pub fn exported_symbols("}, {"sha": "f430f01542efe4f23fadf7677ec5dbeba013abb1", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 70, "deletions": 38, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -8,6 +8,7 @@ use rustc::hir::def_id::{CrateNum, CRATE_DEF_INDEX, DefIndex, DefId, LocalDefId,\n use rustc::hir::GenericParamKind;\n use rustc::hir::map::definitions::DefPathTable;\n use rustc_data_structures::fingerprint::Fingerprint;\n+use rustc_data_structures::indexed_vec::IndexVec;\n use rustc::middle::dependency_format::Linkage;\n use rustc::middle::exported_symbols::{ExportedSymbol, SymbolExportLevel,\n                                       metadata_symbol_name};\n@@ -32,7 +33,7 @@ use syntax::ast;\n use syntax::attr;\n use syntax::ext::proc_macro::is_proc_macro_attr;\n use syntax::source_map::Spanned;\n-use syntax::symbol::{kw, sym, Ident};\n+use syntax::symbol::{kw, sym, Ident, Symbol};\n use syntax_pos::{self, FileName, SourceFile, Span};\n use log::{debug, trace};\n \n@@ -403,6 +404,11 @@ impl<'tcx> EncodeContext<'tcx> {\n         let lang_items_missing = self.encode_lang_items_missing();\n         let lang_item_bytes = self.position() - i;\n \n+        // Encode the diagnostic items.\n+        i = self.position();\n+        let diagnostic_items = self.encode_diagnostic_items();\n+        let diagnostic_item_bytes = self.position() - i;\n+\n         // Encode the native libraries used\n         i = self.position();\n         let native_libraries = self.encode_native_libraries();\n@@ -519,6 +525,7 @@ impl<'tcx> EncodeContext<'tcx> {\n             dylib_dependency_formats,\n             lib_features,\n             lang_items,\n+            diagnostic_items,\n             lang_items_missing,\n             native_libraries,\n             foreign_modules,\n@@ -544,6 +551,7 @@ impl<'tcx> EncodeContext<'tcx> {\n             println!(\"             dep bytes: {}\", dep_bytes);\n             println!(\"     lib feature bytes: {}\", lib_feature_bytes);\n             println!(\"       lang item bytes: {}\", lang_item_bytes);\n+            println!(\" diagnostic item bytes: {}\", diagnostic_item_bytes);\n             println!(\"          native bytes: {}\", native_lib_bytes);\n             println!(\"         source_map bytes: {}\", source_map_bytes);\n             println!(\"            impl bytes: {}\", impl_bytes);\n@@ -623,6 +631,7 @@ impl EncodeContext<'tcx> {\n             predicates_defined_on: None,\n \n             mir: self.encode_optimized_mir(def_id),\n+            promoted_mir: self.encode_promoted_mir(def_id),\n         }\n     }\n \n@@ -677,6 +686,7 @@ impl EncodeContext<'tcx> {\n             predicates_defined_on: None,\n \n             mir: self.encode_optimized_mir(def_id),\n+            promoted_mir: self.encode_promoted_mir(def_id),\n         }\n     }\n \n@@ -713,7 +723,8 @@ impl EncodeContext<'tcx> {\n             predicates: None,\n             predicates_defined_on: None,\n \n-            mir: None\n+            mir: None,\n+            promoted_mir: None,\n         }\n     }\n \n@@ -748,6 +759,7 @@ impl EncodeContext<'tcx> {\n             predicates_defined_on: None,\n \n             mir: None,\n+            promoted_mir: None,\n         }\n     }\n \n@@ -808,6 +820,7 @@ impl EncodeContext<'tcx> {\n             predicates_defined_on: None,\n \n             mir: self.encode_optimized_mir(def_id),\n+            promoted_mir: self.encode_promoted_mir(def_id),\n         }\n     }\n \n@@ -863,18 +876,18 @@ impl EncodeContext<'tcx> {\n             }\n             ty::AssocKind::Method => {\n                 let fn_data = if let hir::TraitItemKind::Method(_, ref m) = ast_item.node {\n-                    let arg_names = match *m {\n+                    let param_names = match *m {\n                         hir::TraitMethod::Required(ref names) => {\n-                            self.encode_fn_arg_names(names)\n+                            self.encode_fn_param_names(names)\n                         }\n                         hir::TraitMethod::Provided(body) => {\n-                            self.encode_fn_arg_names_for_body(body)\n+                            self.encode_fn_param_names_for_body(body)\n                         }\n                     };\n                     FnData {\n                         constness: hir::Constness::NotConst,\n-                        arg_names,\n-                        sig: self.lazy(tcx.fn_sig(def_id)),\n+                        param_names,\n+                        sig: self.lazy(&tcx.fn_sig(def_id)),\n                     }\n                 } else {\n                     bug!()\n@@ -923,6 +936,7 @@ impl EncodeContext<'tcx> {\n             predicates_defined_on: None,\n \n             mir: self.encode_optimized_mir(def_id),\n+            promoted_mir: self.encode_promoted_mir(def_id),\n         }\n     }\n \n@@ -969,8 +983,8 @@ impl EncodeContext<'tcx> {\n                 let fn_data = if let hir::ImplItemKind::Method(ref sig, body) = ast_item.node {\n                     FnData {\n                         constness: sig.header.constness,\n-                        arg_names: self.encode_fn_arg_names_for_body(body),\n-                        sig: self.lazy(tcx.fn_sig(def_id)),\n+                        param_names: self.encode_fn_param_names_for_body(body),\n+                        sig: self.lazy(&tcx.fn_sig(def_id)),\n                     }\n                 } else {\n                     bug!()\n@@ -1022,14 +1036,15 @@ impl EncodeContext<'tcx> {\n             predicates_defined_on: None,\n \n             mir: if mir { self.encode_optimized_mir(def_id) } else { None },\n+            promoted_mir: if mir { self.encode_promoted_mir(def_id) } else { None },\n         }\n     }\n \n-    fn encode_fn_arg_names_for_body(&mut self, body_id: hir::BodyId)\n+    fn encode_fn_param_names_for_body(&mut self, body_id: hir::BodyId)\n                                     -> Lazy<[ast::Name]> {\n         self.tcx.dep_graph.with_ignore(|| {\n             let body = self.tcx.hir().body(body_id);\n-            self.lazy(body.arguments.iter().map(|arg| {\n+            self.lazy(body.params.iter().map(|arg| {\n                 match arg.pat.node {\n                     PatKind::Binding(_, _, ident, _) => ident.name,\n                     _ => kw::Invalid,\n@@ -1038,7 +1053,7 @@ impl EncodeContext<'tcx> {\n         })\n     }\n \n-    fn encode_fn_arg_names(&mut self, param_names: &[ast::Ident]) -> Lazy<[ast::Name]> {\n+    fn encode_fn_param_names(&mut self, param_names: &[ast::Ident]) -> Lazy<[ast::Name]> {\n         self.lazy(param_names.iter().map(|ident| ident.name))\n     }\n \n@@ -1052,6 +1067,19 @@ impl EncodeContext<'tcx> {\n         }\n     }\n \n+    fn encode_promoted_mir(\n+        &mut self,\n+        def_id: DefId,\n+    ) -> Option<Lazy<IndexVec<mir::Promoted, mir::Body<'tcx>>>> {\n+        debug!(\"EncodeContext::encode_promoted_mir({:?})\", def_id);\n+        if self.tcx.mir_keys(LOCAL_CRATE).contains(&def_id) {\n+            let promoted = self.tcx.promoted_mir(def_id);\n+            Some(self.lazy(promoted))\n+        } else {\n+            None\n+        }\n+    }\n+\n     // Encodes the inherent implementations of a structure, enumeration, or trait.\n     fn encode_inherent_implementations(&mut self, def_id: DefId) -> Lazy<[DefIndex]> {\n         debug!(\"EncodeContext::encode_inherent_implementations({:?})\", def_id);\n@@ -1101,7 +1129,7 @@ impl EncodeContext<'tcx> {\n             hir::ItemKind::Fn(_, header, .., body) => {\n                 let data = FnData {\n                     constness: header.constness,\n-                    arg_names: self.encode_fn_arg_names_for_body(body),\n+                    param_names: self.encode_fn_param_names_for_body(body),\n                     sig: self.lazy(tcx.fn_sig(def_id)),\n                 };\n \n@@ -1202,6 +1230,20 @@ impl EncodeContext<'tcx> {\n             hir::ItemKind::Use(..) => bug!(\"cannot encode info for item {:?}\", item),\n         };\n \n+        let mir = match item.node {\n+            hir::ItemKind::Static(..) | hir::ItemKind::Const(..) => true,\n+            hir::ItemKind::Fn(_, header, ..) => {\n+                let generics = tcx.generics_of(def_id);\n+                let needs_inline =\n+                    (generics.requires_monomorphization(tcx) ||\n+                        tcx.codegen_fn_attrs(def_id).requests_inline()) &&\n+                        !self.metadata_output_only();\n+                let always_encode_mir = self.tcx.sess.opts.debugging_opts.always_encode_mir;\n+                needs_inline || header.constness == hir::Constness::Const || always_encode_mir\n+            }\n+            _ => false,\n+        };\n+\n         Entry {\n             kind,\n             visibility: self.lazy(ty::Visibility::from_hir(&item.vis, item.hir_id, tcx)),\n@@ -1301,29 +1343,8 @@ impl EncodeContext<'tcx> {\n                 _ => None, // not *wrong* for other kinds of items, but not needed\n             },\n \n-            mir: match item.node {\n-                hir::ItemKind::Static(..) => {\n-                    self.encode_optimized_mir(def_id)\n-                }\n-                hir::ItemKind::Const(..) => self.encode_optimized_mir(def_id),\n-                hir::ItemKind::Fn(_, header, ..) => {\n-                    let generics = tcx.generics_of(def_id);\n-                    let needs_inline =\n-                        (generics.requires_monomorphization(tcx) ||\n-                         tcx.codegen_fn_attrs(def_id).requests_inline()) &&\n-                            !self.metadata_output_only();\n-                    let always_encode_mir = self.tcx.sess.opts.debugging_opts.always_encode_mir;\n-                    if needs_inline\n-                        || header.constness == hir::Constness::Const\n-                        || always_encode_mir\n-                    {\n-                        self.encode_optimized_mir(def_id)\n-                    } else {\n-                        None\n-                    }\n-                }\n-                _ => None,\n-            },\n+            mir: if mir { self.encode_optimized_mir(def_id) } else { None },\n+            promoted_mir: if mir { self.encode_promoted_mir(def_id) } else { None },\n         }\n     }\n \n@@ -1333,7 +1354,7 @@ impl EncodeContext<'tcx> {\n         let def_id = self.tcx.hir().local_def_id(macro_def.hir_id);\n         Entry {\n             kind: EntryKind::MacroDef(self.lazy(MacroDef {\n-                body: pprust::tokens_to_string(macro_def.body.clone()),\n+                body: pprust::tts_to_string(macro_def.body.clone()),\n                 legacy: macro_def.legacy,\n             })),\n             visibility: self.lazy(ty::Visibility::Public),\n@@ -1350,6 +1371,7 @@ impl EncodeContext<'tcx> {\n             predicates: None,\n             predicates_defined_on: None,\n             mir: None,\n+            promoted_mir: None,\n         }\n     }\n \n@@ -1376,6 +1398,7 @@ impl EncodeContext<'tcx> {\n             predicates_defined_on: None,\n \n             mir: None,\n+            promoted_mir: None,\n         }\n     }\n \n@@ -1436,6 +1459,7 @@ impl EncodeContext<'tcx> {\n             predicates_defined_on: None,\n \n             mir: self.encode_optimized_mir(def_id),\n+            promoted_mir: self.encode_promoted_mir(def_id),\n         }\n     }\n \n@@ -1464,6 +1488,7 @@ impl EncodeContext<'tcx> {\n             predicates_defined_on: None,\n \n             mir: self.encode_optimized_mir(def_id),\n+            promoted_mir: self.encode_promoted_mir(def_id),\n         }\n     }\n \n@@ -1537,6 +1562,12 @@ impl EncodeContext<'tcx> {\n         self.lazy(lib_features.to_vec())\n     }\n \n+    fn encode_diagnostic_items(&mut self) -> Lazy<[(Symbol, DefIndex)]> {\n+        let tcx = self.tcx;\n+        let diagnostic_items = tcx.diagnostic_items(LOCAL_CRATE);\n+        self.lazy(diagnostic_items.iter().map(|(&name, def_id)| (name, def_id.index)))\n+    }\n+\n     fn encode_lang_items(&mut self) -> Lazy<[(DefIndex, usize)]> {\n         let tcx = self.tcx;\n         let lang_items = tcx.lang_items();\n@@ -1645,7 +1676,7 @@ impl EncodeContext<'tcx> {\n             hir::ForeignItemKind::Fn(_, ref names, _) => {\n                 let data = FnData {\n                     constness: hir::Constness::NotConst,\n-                    arg_names: self.encode_fn_arg_names(names),\n+                    param_names: self.encode_fn_param_names(names),\n                     sig: self.lazy(tcx.fn_sig(def_id)),\n                 };\n                 EntryKind::ForeignFn(self.lazy(data))\n@@ -1675,6 +1706,7 @@ impl EncodeContext<'tcx> {\n             predicates_defined_on: None,\n \n             mir: None,\n+            promoted_mir: None,\n         }\n     }\n }"}, {"sha": "cd8e95e6c3a1101786cd08bc55fba6b8bc0c7a37", "filename": "src/librustc_metadata/error_codes.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_metadata%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_metadata%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Ferror_codes.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -1,6 +1,4 @@\n-use syntax::{register_diagnostics, register_long_diagnostics};\n-\n-register_long_diagnostics! {\n+syntax::register_diagnostics! {\n E0454: r##\"\n A link name was given with an empty name. Erroneous code example:\n \n@@ -84,10 +82,7 @@ You need to link your code to the relevant crate in order to be able to use it\n (through Cargo or the `-L` option of rustc example). Plugins are crates as\n well, and you link to them the same way.\n \"##,\n-\n-}\n-\n-register_diagnostics! {\n+;\n     E0456, // plugin `..` is not available for triple `..`\n     E0457, // plugin `..` only found in rlib format, but must be available...\n     E0514, // metadata version mismatch\n@@ -97,5 +92,6 @@ register_diagnostics! {\n     E0464, // multiple matching crates for `..`\n     E0465, // multiple .. candidates for `..` found\n     E0519, // local crate and dependency have same (crate-name, disambiguator)\n-    E0523, // two dependencies have same (crate-name, disambiguator) but different SVH\n+    // two dependencies have same (crate-name, disambiguator) but different SVH\n+    E0523,\n }"}, {"sha": "e6104e629e9fbfefbec87db6c2dc3a602e2137e9", "filename": "src/librustc_metadata/lib.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_metadata%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_metadata%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flib.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -8,7 +8,6 @@\n #![feature(nll)]\n #![feature(proc_macro_internals)]\n #![feature(proc_macro_quote)]\n-#![feature(rustc_diagnostic_macros)]\n #![feature(rustc_private)]\n #![feature(slice_patterns)]\n #![feature(specialization)]\n@@ -23,7 +22,7 @@ extern crate rustc;\n #[macro_use]\n extern crate rustc_data_structures;\n \n-mod error_codes;\n+pub mod error_codes;\n \n mod index;\n mod encoder;\n@@ -68,5 +67,3 @@ pub fn validate_crate_name(\n         sess.unwrap().abort_if_errors();\n     }\n }\n-\n-__build_diagnostic_array! { librustc_metadata, DIAGNOSTICS }"}, {"sha": "66d676b7747d0bb26f67377be543192aff38a492", "filename": "src/librustc_metadata/native_libs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_metadata%2Fnative_libs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_metadata%2Fnative_libs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fnative_libs.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -159,15 +159,15 @@ impl Collector<'tcx> {\n                                            sym::link_cfg,\n                                            span.unwrap(),\n                                            GateIssue::Language,\n-                                           \"is feature gated\");\n+                                           \"is unstable\");\n         }\n         if lib.kind == cstore::NativeStaticNobundle &&\n            !self.tcx.features().static_nobundle {\n             feature_gate::emit_feature_err(&self.tcx.sess.parse_sess,\n                                            sym::static_nobundle,\n                                            span.unwrap_or_else(|| syntax_pos::DUMMY_SP),\n                                            GateIssue::Language,\n-                                           \"kind=\\\"static-nobundle\\\" is feature gated\");\n+                                           \"kind=\\\"static-nobundle\\\" is unstable\");\n         }\n         self.libs.push(lib);\n     }"}, {"sha": "1a5f0e17ba7ceebdd110b95321808718b9a6e004", "filename": "src/librustc_metadata/schema.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_metadata%2Fschema.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_metadata%2Fschema.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fschema.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -11,6 +11,7 @@ use rustc::session::CrateDisambiguator;\n use rustc::session::config::SymbolManglingVersion;\n use rustc::ty::{self, Ty, ReprOptions};\n use rustc_target::spec::{PanicStrategy, TargetTriple};\n+use rustc_data_structures::indexed_vec::IndexVec;\n use rustc_data_structures::svh::Svh;\n \n use syntax::{ast, attr};\n@@ -175,6 +176,7 @@ pub struct CrateRoot<'tcx> {\n     pub lib_features: Lazy<[(Symbol, Option<Symbol>)]>,\n     pub lang_items: Lazy<[(DefIndex, usize)]>,\n     pub lang_items_missing: Lazy<[lang_items::LangItem]>,\n+    pub diagnostic_items: Lazy<[(Symbol, DefIndex)]>,\n     pub native_libraries: Lazy<[NativeLibrary]>,\n     pub foreign_modules: Lazy<[ForeignModule]>,\n     pub source_map: Lazy<[syntax_pos::SourceFile]>,\n@@ -231,6 +233,7 @@ pub struct Entry<'tcx> {\n     pub predicates_defined_on: Option<Lazy<ty::GenericPredicates<'tcx>>>,\n \n     pub mir: Option<Lazy<mir::Body<'tcx>>>,\n+    pub promoted_mir: Option<Lazy<IndexVec<mir::Promoted, mir::Body<'tcx>>>>,\n }\n \n #[derive(Copy, Clone, RustcEncodable, RustcDecodable)]\n@@ -293,7 +296,7 @@ pub struct MacroDef {\n #[derive(RustcEncodable, RustcDecodable)]\n pub struct FnData<'tcx> {\n     pub constness: hir::Constness,\n-    pub arg_names: Lazy<[ast::Name]>,\n+    pub param_names: Lazy<[ast::Name]>,\n     pub sig: Lazy<ty::PolyFnSig<'tcx>>,\n }\n "}, {"sha": "e02736078b5711d0e7e66e8b9d5857b0834d2234", "filename": "src/librustc_mir/Cargo.toml", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2FCargo.toml?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -15,11 +15,12 @@ either = \"1.5.0\"\n dot = { path = \"../libgraphviz\", package = \"graphviz\" }\n log = \"0.4\"\n log_settings = \"0.1.1\"\n-polonius-engine  = \"0.9.0\"\n+polonius-engine  = \"0.10.0\"\n rustc = { path = \"../librustc\" }\n rustc_target = { path = \"../librustc_target\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_errors = { path = \"../librustc_errors\" }\n+rustc_lexer = { path = \"../librustc_lexer\" }\n rustc_serialize = { path = \"../libserialize\", package = \"serialize\" }\n syntax = { path = \"../libsyntax\" }\n syntax_pos = { path = \"../libsyntax_pos\" }"}, {"sha": "bfc7050ebf71cbf15d5b5d8991a80020a6edc7d0", "filename": "src/librustc_mir/borrow_check/conflict_errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Fborrow_check%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Fborrow_check%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fconflict_errors.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -98,7 +98,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 &self.describe_place_with_options(moved_place, IncludingDowncast(true))\n                     .unwrap_or_else(|| \"_\".to_owned()),\n             );\n-            err.span_label(span, format!(\"use of possibly uninitialized {}\", item_msg));\n+            err.span_label(span, format!(\"use of possibly-uninitialized {}\", item_msg));\n \n             use_spans.var_span_label(\n                 &mut err,"}, {"sha": "9f25e98052ec49934581b628002fc66d2a64fe17", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -159,7 +159,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             PlaceRef {\n                 base:\n                     PlaceBase::Static(box Static {\n-                        kind: StaticKind::Promoted(_),\n+                        kind: StaticKind::Promoted(..),\n                         ..\n                     }),\n                 projection: None,\n@@ -169,7 +169,8 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             PlaceRef {\n                 base:\n                     PlaceBase::Static(box Static {\n-                        kind: StaticKind::Static(def_id),\n+                        kind: StaticKind::Static,\n+                        def_id,\n                         ..\n                     }),\n                 projection: None,\n@@ -335,7 +336,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         let local = &self.body.local_decls[local_index];\n         match local.name {\n             Some(name) if !local.from_compiler_desugaring() => {\n-                buf.push_str(name.as_str().get());\n+                buf.push_str(&name.as_str());\n                 Ok(())\n             }\n             _ => Err(()),\n@@ -440,7 +441,8 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     pub fn is_place_thread_local(&self, place_ref: PlaceRef<'cx, 'tcx>) -> bool {\n         if let PlaceRef {\n             base: PlaceBase::Static(box Static {\n-                kind: StaticKind::Static(def_id),\n+                kind: StaticKind::Static,\n+                def_id,\n                 ..\n             }),\n             projection: None,"}, {"sha": "4400e0c8395a205b82ffa0ac4c00212b39eb938b", "filename": "src/librustc_mir/borrow_check/flows.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Fborrow_check%2Fflows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Fborrow_check%2Fflows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fflows.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -12,7 +12,7 @@ use crate::borrow_check::location::LocationIndex;\n use polonius_engine::Output;\n \n use crate::dataflow::indexes::BorrowIndex;\n-use crate::dataflow::move_paths::HasMoveData;\n+use crate::dataflow::move_paths::{HasMoveData, MovePathIndex};\n use crate::dataflow::Borrows;\n use crate::dataflow::EverInitializedPlaces;\n use crate::dataflow::MaybeUninitializedPlaces;\n@@ -21,7 +21,7 @@ use either::Either;\n use std::fmt;\n use std::rc::Rc;\n \n-crate type PoloniusOutput = Output<RegionVid, BorrowIndex, LocationIndex, Local>;\n+crate type PoloniusOutput = Output<RegionVid, BorrowIndex, LocationIndex, Local, MovePathIndex>;\n \n // (forced to be `pub` due to its use as an associated type below.)\n crate struct Flows<'b, 'tcx> {"}, {"sha": "9ad7cbc478bb0644f61d0b76b22eb0e3b05d7abf", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 21, "deletions": 11, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -13,7 +13,7 @@ use rustc::mir::{\n     ClearCrossCrate, Local, Location, Body, Mutability, Operand, Place, PlaceBase, PlaceRef,\n     Static, StaticKind\n };\n-use rustc::mir::{Field, Projection, ProjectionElem, Rvalue, Statement, StatementKind};\n+use rustc::mir::{Field, Projection, ProjectionElem, Promoted, Rvalue, Statement, StatementKind};\n use rustc::mir::{Terminator, TerminatorKind};\n use rustc::ty::query::Providers;\n use rustc::ty::{self, TyCtxt};\n@@ -22,6 +22,7 @@ use rustc_errors::{Applicability, Diagnostic, DiagnosticBuilder, Level};\n use rustc_data_structures::bit_set::BitSet;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::graph::dominators::Dominators;\n+use rustc_data_structures::indexed_vec::IndexVec;\n use smallvec::SmallVec;\n \n use std::collections::BTreeMap;\n@@ -86,12 +87,13 @@ pub fn provide(providers: &mut Providers<'_>) {\n }\n \n fn mir_borrowck(tcx: TyCtxt<'_>, def_id: DefId) -> BorrowCheckResult<'_> {\n-    let input_body = tcx.mir_validated(def_id);\n+    let (input_body, promoted) = tcx.mir_validated(def_id);\n     debug!(\"run query mir_borrowck: {}\", tcx.def_path_str(def_id));\n \n     let opt_closure_req = tcx.infer_ctxt().enter(|infcx| {\n         let input_body: &Body<'_> = &input_body.borrow();\n-        do_mir_borrowck(&infcx, input_body, def_id)\n+        let promoted: &IndexVec<_, _> = &promoted.borrow();\n+        do_mir_borrowck(&infcx, input_body, promoted, def_id)\n     });\n     debug!(\"mir_borrowck done\");\n \n@@ -101,6 +103,7 @@ fn mir_borrowck(tcx: TyCtxt<'_>, def_id: DefId) -> BorrowCheckResult<'_> {\n fn do_mir_borrowck<'a, 'tcx>(\n     infcx: &InferCtxt<'a, 'tcx>,\n     input_body: &Body<'tcx>,\n+    input_promoted: &IndexVec<Promoted, Body<'tcx>>,\n     def_id: DefId,\n ) -> BorrowCheckResult<'tcx> {\n     debug!(\"do_mir_borrowck(def_id = {:?})\", def_id);\n@@ -147,7 +150,9 @@ fn do_mir_borrowck<'a, 'tcx>(\n     // be modified (in place) to contain non-lexical lifetimes. It\n     // will have a lifetime tied to the inference context.\n     let mut body: Body<'tcx> = input_body.clone();\n-    let free_regions = nll::replace_regions_in_mir(infcx, def_id, param_env, &mut body);\n+    let mut promoted: IndexVec<Promoted, Body<'tcx>> = input_promoted.clone();\n+    let free_regions =\n+        nll::replace_regions_in_mir(infcx, def_id, param_env, &mut body, &mut promoted);\n     let body = &body; // no further changes\n     let location_table = &LocationTable::new(body);\n \n@@ -159,8 +164,8 @@ fn do_mir_borrowck<'a, 'tcx>(\n         };\n \n     let mdpe = MoveDataParamEnv {\n-        move_data: move_data,\n-        param_env: param_env,\n+        move_data,\n+        param_env,\n     };\n \n     let dead_unwinds = BitSet::new_empty(body.basic_blocks().len());\n@@ -184,6 +189,7 @@ fn do_mir_borrowck<'a, 'tcx>(\n         def_id,\n         free_regions,\n         body,\n+        &promoted,\n         &upvars,\n         location_table,\n         param_env,\n@@ -253,7 +259,10 @@ fn do_mir_borrowck<'a, 'tcx>(\n         move_error_reported: BTreeMap::new(),\n         uninitialized_error_reported: Default::default(),\n         errors_buffer,\n-        disable_error_downgrading: false,\n+        // Only downgrade errors on Rust 2015 and refuse to do so on Rust 2018.\n+        // FIXME(Centril): In Rust 1.40.0, refuse doing so on 2015 as well and\n+        // proceed to throwing out the migration infrastructure.\n+        disable_error_downgrading: body.span.rust_2018(),\n         nonlexical_regioncx: regioncx,\n         used_mut: Default::default(),\n         used_mut_upvars: SmallVec::new(),\n@@ -1462,13 +1471,13 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         assert!(root_place.projection.is_none());\n         let (might_be_alive, will_be_dropped) = match root_place.base {\n             PlaceBase::Static(box Static {\n-                kind: StaticKind::Promoted(_),\n+                kind: StaticKind::Promoted(..),\n                 ..\n             }) => {\n                 (true, false)\n             }\n             PlaceBase::Static(box Static {\n-                kind: StaticKind::Static(_),\n+                kind: StaticKind::Static,\n                 ..\n             }) => {\n                 // Thread-locals might be dropped after the function exits, but\n@@ -2150,7 +2159,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             // `Place::Promoted` if the promotion weren't 100% legal. So we just forward this\n             PlaceRef {\n                 base: PlaceBase::Static(box Static {\n-                    kind: StaticKind::Promoted(_),\n+                    kind: StaticKind::Promoted(..),\n                     ..\n                 }),\n                 projection: None,\n@@ -2162,7 +2171,8 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 }),\n             PlaceRef {\n                 base: PlaceBase::Static(box Static {\n-                    kind: StaticKind::Static(def_id),\n+                    kind: StaticKind::Static,\n+                    def_id,\n                     ..\n                 }),\n                 projection: None,"}, {"sha": "0d13db2f5a413a9d0b9084bff7d0727e4ebabebd", "filename": "src/librustc_mir/borrow_check/move_errors.rs", "status": "modified", "additions": 43, "deletions": 43, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -1,5 +1,3 @@\n-use core::unicode::property::Pattern_White_Space;\n-\n use rustc::mir::*;\n use rustc::ty;\n use rustc_errors::{DiagnosticBuilder,Applicability};\n@@ -415,20 +413,21 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             \"{:?}\",\n             move_place.ty(self.body, self.infcx.tcx).ty,\n         );\n-        let snippet = self.infcx.tcx.sess.source_map().span_to_snippet(span).unwrap();\n-        let is_option = move_ty.starts_with(\"std::option::Option\");\n-        let is_result = move_ty.starts_with(\"std::result::Result\");\n-        if  is_option || is_result {\n-            err.span_suggestion(\n-                span,\n-                &format!(\"consider borrowing the `{}`'s content\", if is_option {\n-                    \"Option\"\n-                } else {\n-                    \"Result\"\n-                }),\n-                format!(\"{}.as_ref()\", snippet),\n-                Applicability::MaybeIncorrect,\n-            );\n+        if let Ok(snippet) = self.infcx.tcx.sess.source_map().span_to_snippet(span) {\n+            let is_option = move_ty.starts_with(\"std::option::Option\");\n+            let is_result = move_ty.starts_with(\"std::result::Result\");\n+            if is_option || is_result {\n+                err.span_suggestion(\n+                    span,\n+                    &format!(\"consider borrowing the `{}`'s content\", if is_option {\n+                        \"Option\"\n+                    } else {\n+                        \"Result\"\n+                    }),\n+                    format!(\"{}.as_ref()\", snippet),\n+                    Applicability::MaybeIncorrect,\n+                );\n+            }\n         }\n         err\n     }\n@@ -439,19 +438,20 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         err: &mut DiagnosticBuilder<'a>,\n         span: Span,\n     ) {\n-        let snippet = self.infcx.tcx.sess.source_map().span_to_snippet(span).unwrap();\n         match error {\n             GroupedMoveError::MovesFromPlace {\n                 mut binds_to,\n                 move_from,\n                 ..\n             } => {\n-                err.span_suggestion(\n-                    span,\n-                    \"consider borrowing here\",\n-                    format!(\"&{}\", snippet),\n-                    Applicability::Unspecified,\n-                );\n+                if let Ok(snippet) = self.infcx.tcx.sess.source_map().span_to_snippet(span) {\n+                    err.span_suggestion(\n+                        span,\n+                        \"consider borrowing here\",\n+                        format!(\"&{}\", snippet),\n+                        Applicability::Unspecified,\n+                    );\n+                }\n \n                 if binds_to.is_empty() {\n                     let place_ty = move_from.ty(self.body, self.infcx.tcx).ty;\n@@ -517,27 +517,27 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                     ..\n                 }))\n             ) = bind_to.is_user_variable {\n-                let pat_snippet = self.infcx.tcx.sess.source_map()\n-                    .span_to_snippet(pat_span)\n-                    .unwrap();\n-                if pat_snippet.starts_with('&') {\n-                    let pat_snippet = pat_snippet[1..].trim_start();\n-                    let suggestion;\n-                    let to_remove;\n-                    if pat_snippet.starts_with(\"mut\")\n-                        && pat_snippet[\"mut\".len()..].starts_with(Pattern_White_Space)\n-                    {\n-                        suggestion = pat_snippet[\"mut\".len()..].trim_start();\n-                        to_remove = \"&mut\";\n-                    } else {\n-                        suggestion = pat_snippet;\n-                        to_remove = \"&\";\n+                if let Ok(pat_snippet) = self.infcx.tcx.sess.source_map().span_to_snippet(pat_span)\n+                {\n+                    if pat_snippet.starts_with('&') {\n+                        let pat_snippet = pat_snippet[1..].trim_start();\n+                        let suggestion;\n+                        let to_remove;\n+                        if pat_snippet.starts_with(\"mut\")\n+                            && pat_snippet[\"mut\".len()..].starts_with(rustc_lexer::is_whitespace)\n+                        {\n+                            suggestion = pat_snippet[\"mut\".len()..].trim_start();\n+                            to_remove = \"&mut\";\n+                        } else {\n+                            suggestion = pat_snippet;\n+                            to_remove = \"&\";\n+                        }\n+                        suggestions.push((\n+                            pat_span,\n+                            to_remove,\n+                            suggestion.to_owned(),\n+                        ));\n                     }\n-                    suggestions.push((\n-                        pat_span,\n-                        to_remove,\n-                        suggestion.to_owned(),\n-                    ));\n                 }\n             }\n         }"}, {"sha": "8f2ce80aafa22de5ec997a495a963933c8464e4f", "filename": "src/librustc_mir/borrow_check/mutability_errors.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -1,4 +1,3 @@\n-use core::unicode::property::Pattern_White_Space;\n use rustc::hir;\n use rustc::hir::Node;\n use rustc::mir::{self, BindingForm, ClearCrossCrate, Local, Location, Body};\n@@ -149,7 +148,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             PlaceRef {\n                 base:\n                     PlaceBase::Static(box Static {\n-                        kind: StaticKind::Promoted(_),\n+                        kind: StaticKind::Promoted(..),\n                         ..\n                     }),\n                 projection: None,\n@@ -158,7 +157,8 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             PlaceRef {\n                 base:\n                     PlaceBase::Static(box Static {\n-                        kind: StaticKind::Static(def_id),\n+                        kind: StaticKind::Static,\n+                        def_id,\n                         ..\n                     }),\n                 projection: None,\n@@ -711,10 +711,10 @@ fn annotate_struct_field(\n }\n \n /// If possible, suggest replacing `ref` with `ref mut`.\n-fn suggest_ref_mut(tcx: TyCtxt<'_>, binding_span: Span) -> Option<(String)> {\n-    let hi_src = tcx.sess.source_map().span_to_snippet(binding_span).unwrap();\n+fn suggest_ref_mut(tcx: TyCtxt<'_>, binding_span: Span) -> Option<String> {\n+    let hi_src = tcx.sess.source_map().span_to_snippet(binding_span).ok()?;\n     if hi_src.starts_with(\"ref\")\n-        && hi_src[\"ref\".len()..].starts_with(Pattern_White_Space)\n+        && hi_src[\"ref\".len()..].starts_with(rustc_lexer::is_whitespace)\n     {\n         let replacement = format!(\"ref mut{}\", &hi_src[\"ref\".len()..]);\n         Some(replacement)"}, {"sha": "f0beb4d3ae32d773e4afc09aa9a6a07b02f5c589", "filename": "src/librustc_mir/borrow_check/nll/facts.rs", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ffacts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ffacts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ffacts.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -1,5 +1,5 @@\n use crate::borrow_check::location::{LocationIndex, LocationTable};\n-use crate::dataflow::indexes::BorrowIndex;\n+use crate::dataflow::indexes::{BorrowIndex, MovePathIndex};\n use polonius_engine::AllFacts as PoloniusAllFacts;\n use polonius_engine::Atom;\n use rustc::mir::Local;\n@@ -11,7 +11,7 @@ use std::fs::{self, File};\n use std::io::Write;\n use std::path::Path;\n \n-crate type AllFacts = PoloniusAllFacts<RegionVid, BorrowIndex, LocationIndex, Local>;\n+crate type AllFacts = PoloniusAllFacts<RegionVid, BorrowIndex, LocationIndex, Local, MovePathIndex>;\n \n crate trait AllFactsExt {\n     /// Returns `true` if there is a need to gather `AllFacts` given the\n@@ -58,14 +58,17 @@ impl AllFactsExt for AllFacts {\n                 cfg_edge,\n                 killed,\n                 outlives,\n-                region_live_at,\n                 invalidates,\n                 var_used,\n                 var_defined,\n                 var_drop_used,\n                 var_uses_region,\n                 var_drops_region,\n-                var_initialized_on_exit,\n+                child,\n+                path_belongs_to_var,\n+                initialized_at,\n+                moved_out_at,\n+                path_accessed_at,\n             ])\n         }\n         Ok(())\n@@ -84,6 +87,12 @@ impl Atom for LocationIndex {\n     }\n }\n \n+impl Atom for MovePathIndex {\n+    fn index(self) -> usize {\n+        Idx::index(self)\n+    }\n+}\n+\n struct FactWriter<'w> {\n     location_table: &'w LocationTable,\n     dir: &'w Path,"}, {"sha": "1ff3228afa376fc198b77732948152ac56b65b2c", "filename": "src/librustc_mir/borrow_check/nll/mod.rs", "status": "modified", "additions": 89, "deletions": 4, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -4,15 +4,17 @@ use crate::borrow_check::nll::facts::AllFactsExt;\n use crate::borrow_check::nll::type_check::{MirTypeckResults, MirTypeckRegionConstraints};\n use crate::borrow_check::nll::region_infer::values::RegionValueElements;\n use crate::dataflow::indexes::BorrowIndex;\n-use crate::dataflow::move_paths::MoveData;\n+use crate::dataflow::move_paths::{InitLocation, MoveData, MovePathIndex, InitKind};\n use crate::dataflow::FlowAtLocation;\n use crate::dataflow::MaybeInitializedPlaces;\n use crate::transform::MirSource;\n use crate::borrow_check::Upvar;\n use rustc::hir::def_id::DefId;\n use rustc::infer::InferCtxt;\n-use rustc::mir::{ClosureOutlivesSubject, ClosureRegionRequirements, Local, Body};\n+use rustc::mir::{ClosureOutlivesSubject, ClosureRegionRequirements,\n+                 Local, Location, Body, LocalKind, BasicBlock, Promoted};\n use rustc::ty::{self, RegionKind, RegionVid};\n+use rustc_data_structures::indexed_vec::IndexVec;\n use rustc_errors::Diagnostic;\n use std::fmt::Debug;\n use std::env;\n@@ -52,21 +54,101 @@ pub(in crate::borrow_check) fn replace_regions_in_mir<'cx, 'tcx>(\n     def_id: DefId,\n     param_env: ty::ParamEnv<'tcx>,\n     body: &mut Body<'tcx>,\n+    promoted: &mut IndexVec<Promoted, Body<'tcx>>,\n ) -> UniversalRegions<'tcx> {\n     debug!(\"replace_regions_in_mir(def_id={:?})\", def_id);\n \n     // Compute named region information. This also renumbers the inputs/outputs.\n     let universal_regions = UniversalRegions::new(infcx, def_id, param_env);\n \n     // Replace all remaining regions with fresh inference variables.\n-    renumber::renumber_mir(infcx, body);\n+    renumber::renumber_mir(infcx, body, promoted);\n \n     let source = MirSource::item(def_id);\n     mir_util::dump_mir(infcx.tcx, None, \"renumber\", &0, source, body, |_, _| Ok(()));\n \n     universal_regions\n }\n \n+\n+// This function populates an AllFacts instance with base facts related to\n+// MovePaths and needed for the move analysis.\n+fn populate_polonius_move_facts(\n+    all_facts: &mut AllFacts,\n+    move_data: &MoveData<'_>,\n+    location_table: &LocationTable,\n+    body: &Body<'_>) {\n+    all_facts\n+        .path_belongs_to_var\n+        .extend(\n+            move_data\n+                .rev_lookup\n+                .iter_locals_enumerated()\n+                .map(|(v, &m)| (m, v)));\n+\n+    for (child, move_path) in move_data.move_paths.iter_enumerated() {\n+        all_facts\n+            .child\n+            .extend(\n+                move_path\n+                    .parents(&move_data.move_paths)\n+                    .iter()\n+                    .map(|&parent| (child, parent)));\n+    }\n+\n+    // initialized_at\n+    for init in move_data.inits.iter() {\n+\n+        match init.location {\n+            InitLocation::Statement(location) => {\n+                let block_data = &body[location.block];\n+                let is_terminator = location.statement_index == block_data.statements.len();\n+\n+                if is_terminator && init.kind == InitKind::NonPanicPathOnly {\n+                    // We are at the terminator of an init that has a panic path,\n+                    // and where the init should not happen on panic\n+\n+                    for &successor in block_data.terminator().successors() {\n+                        if body[successor].is_cleanup {\n+                            continue;\n+                        }\n+\n+                        // The initialization happened in (or rather, when arriving at)\n+                        // the successors, but not in the unwind block.\n+                        let first_statement = Location { block: successor, statement_index: 0};\n+                        all_facts\n+                            .initialized_at\n+                            .push((init.path, location_table.start_index(first_statement)));\n+                    }\n+\n+                } else {\n+                    // In all other cases, the initialization just happens at the\n+                    // midpoint, like any other effect.\n+                    all_facts.initialized_at.push((init.path, location_table.mid_index(location)));\n+                }\n+            },\n+            // Arguments are initialized on function entry\n+            InitLocation::Argument(local) => {\n+                assert!(body.local_kind(local) == LocalKind::Arg);\n+                let fn_entry = Location {block: BasicBlock::from_u32(0u32), statement_index: 0 };\n+                all_facts.initialized_at.push((init.path, location_table.start_index(fn_entry)));\n+\n+            }\n+        }\n+    }\n+\n+\n+    // moved_out_at\n+    // deinitialisation is assumed to always happen!\n+    all_facts\n+        .moved_out_at\n+        .extend(\n+            move_data\n+                .moves\n+                .iter()\n+                .map(|mo| (mo.path, location_table.mid_index(mo.source))));\n+}\n+\n /// Computes the (non-lexical) regions from the input MIR.\n ///\n /// This may result in errors being reported.\n@@ -75,6 +157,7 @@ pub(in crate::borrow_check) fn compute_regions<'cx, 'tcx>(\n     def_id: DefId,\n     universal_regions: UniversalRegions<'tcx>,\n     body: &Body<'tcx>,\n+    promoted: &IndexVec<Promoted, Body<'tcx>>,\n     upvars: &[Upvar],\n     location_table: &LocationTable,\n     param_env: ty::ParamEnv<'tcx>,\n@@ -84,7 +167,7 @@ pub(in crate::borrow_check) fn compute_regions<'cx, 'tcx>(\n     errors_buffer: &mut Vec<Diagnostic>,\n ) -> (\n     RegionInferenceContext<'tcx>,\n-    Option<Rc<Output<RegionVid, BorrowIndex, LocationIndex, Local>>>,\n+    Option<Rc<Output<RegionVid, BorrowIndex, LocationIndex, Local, MovePathIndex>>>,\n     Option<ClosureRegionRequirements<'tcx>>,\n ) {\n     let mut all_facts = if AllFacts::enabled(infcx.tcx) {\n@@ -105,6 +188,7 @@ pub(in crate::borrow_check) fn compute_regions<'cx, 'tcx>(\n         infcx,\n         param_env,\n         body,\n+        promoted,\n         def_id,\n         &universal_regions,\n         location_table,\n@@ -119,6 +203,7 @@ pub(in crate::borrow_check) fn compute_regions<'cx, 'tcx>(\n         all_facts\n             .universal_region\n             .extend(universal_regions.universal_regions());\n+        populate_polonius_move_facts(all_facts, move_data, location_table, body);\n     }\n \n     // Create the region inference context, taking ownership of the"}, {"sha": "75a31628a54b6771bfbad90e5843132a23ea285b", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/region_name.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -413,7 +413,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     ) -> Option<RegionName> {\n         let mut highlight = RegionHighlightMode::default();\n         highlight.highlighting_region_vid(needle_fr, *counter);\n-        let type_name = infcx.extract_type_name(&argument_ty, Some(highlight));\n+        let type_name = infcx.extract_type_name(&argument_ty, Some(highlight)).0;\n \n         debug!(\n             \"give_name_if_we_cannot_match_hir_ty: type_name={:?} needle_fr={:?}\",\n@@ -695,7 +695,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n         let mut highlight = RegionHighlightMode::default();\n         highlight.highlighting_region_vid(fr, *counter);\n-        let type_name = infcx.extract_type_name(&return_ty, Some(highlight));\n+        let type_name = infcx.extract_type_name(&return_ty, Some(highlight)).0;\n \n         let mir_hir_id = tcx.hir().as_local_hir_id(mir_def_id).expect(\"non-local mir\");\n \n@@ -758,7 +758,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n         let mut highlight = RegionHighlightMode::default();\n         highlight.highlighting_region_vid(fr, *counter);\n-        let type_name = infcx.extract_type_name(&yield_ty, Some(highlight));\n+        let type_name = infcx.extract_type_name(&yield_ty, Some(highlight)).0;\n \n         let mir_hir_id = tcx.hir().as_local_hir_id(mir_def_id).expect(\"non-local mir\");\n "}, {"sha": "c479c38f30c7ea9dcfe23bad512e991804854266", "filename": "src/librustc_mir/borrow_check/nll/renumber.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Frenumber.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Frenumber.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Frenumber.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -1,16 +1,26 @@\n use rustc::ty::subst::SubstsRef;\n use rustc::ty::{self, ClosureSubsts, GeneratorSubsts, Ty, TypeFoldable};\n-use rustc::mir::{Location, Body};\n+use rustc::mir::{Location, Body, Promoted};\n use rustc::mir::visit::{MutVisitor, TyContext};\n use rustc::infer::{InferCtxt, NLLRegionVariableOrigin};\n+use rustc_data_structures::indexed_vec::IndexVec;\n \n /// Replaces all free regions appearing in the MIR with fresh\n /// inference variables, returning the number of variables created.\n-pub fn renumber_mir<'tcx>(infcx: &InferCtxt<'_, 'tcx>, body: &mut Body<'tcx>) {\n+pub fn renumber_mir<'tcx>(\n+    infcx: &InferCtxt<'_, 'tcx>,\n+    body: &mut Body<'tcx>,\n+    promoted: &mut IndexVec<Promoted, Body<'tcx>>,\n+) {\n     debug!(\"renumber_mir()\");\n     debug!(\"renumber_mir: body.arg_count={:?}\", body.arg_count);\n \n     let mut visitor = NLLVisitor { infcx };\n+\n+    for body in promoted.iter_mut() {\n+        visitor.visit_body(body);\n+    }\n+\n     visitor.visit_body(body);\n }\n \n@@ -44,14 +54,6 @@ impl<'a, 'tcx> NLLVisitor<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> MutVisitor<'tcx> for NLLVisitor<'a, 'tcx> {\n-    fn visit_body(&mut self, body: &mut Body<'tcx>) {\n-        for promoted in body.promoted.iter_mut() {\n-            self.visit_body(promoted);\n-        }\n-\n-        self.super_body(body);\n-    }\n-\n     fn visit_ty(&mut self, ty: &mut Ty<'tcx>, ty_context: TyContext) {\n         debug!(\"visit_ty(ty={:?}, ty_context={:?})\", ty, ty_context);\n "}, {"sha": "049d83bb22f1bc9cf48a56606bca4fdfb93adc02", "filename": "src/librustc_mir/borrow_check/nll/type_check/liveness/local_use_map.rs", "status": "modified", "additions": 7, "deletions": 15, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Flocal_use_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Flocal_use_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Flocal_use_map.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -1,7 +1,7 @@\n use crate::borrow_check::nll::region_infer::values::{PointIndex, RegionValueElements};\n use crate::util::liveness::{categorize, DefUse};\n use rustc::mir::visit::{PlaceContext, Visitor};\n-use rustc::mir::{Local, Location, Body};\n+use rustc::mir::{Body, Local, Location};\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n use rustc_data_structures::vec_linked_list as vll;\n \n@@ -72,16 +72,10 @@ impl LocalUseMap {\n \n         let mut locals_with_use_data: IndexVec<Local, bool> =\n             IndexVec::from_elem_n(false, body.local_decls.len());\n-        live_locals\n-            .iter()\n-            .for_each(|&local| locals_with_use_data[local] = true);\n-\n-        LocalUseMapBuild {\n-            local_use_map: &mut local_use_map,\n-            elements,\n-            locals_with_use_data,\n-        }\n-        .visit_body(body);\n+        live_locals.iter().for_each(|&local| locals_with_use_data[local] = true);\n+\n+        LocalUseMapBuild { local_use_map: &mut local_use_map, elements, locals_with_use_data }\n+            .visit_body(body);\n \n         local_use_map\n     }\n@@ -151,10 +145,8 @@ impl LocalUseMapBuild<'_> {\n         location: Location,\n     ) {\n         let point_index = elements.point_from_location(location);\n-        let appearance_index = appearances.push(Appearance {\n-            point_index,\n-            next: *first_appearance,\n-        });\n+        let appearance_index =\n+            appearances.push(Appearance { point_index, next: *first_appearance });\n         *first_appearance = Some(appearance_index);\n     }\n }"}, {"sha": "3f2ec1ba970173910e7ac85ffbc574afad7952fc", "filename": "src/librustc_mir/borrow_check/nll/type_check/liveness/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Fmod.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -58,9 +58,9 @@ pub(super) fn generate<'tcx>(\n     };\n \n     if !live_locals.is_empty() {\n-        trace::trace(typeck, body, elements, flow_inits, move_data, live_locals, location_table);\n+        trace::trace(typeck, body, elements, flow_inits, move_data, live_locals);\n \n-        polonius::populate_var_liveness_facts(typeck, body, location_table);\n+        polonius::populate_access_facts(typeck, body, location_table, move_data);\n     }\n }\n "}, {"sha": "d61464b3f387d52d84f904a0592994d419f03326", "filename": "src/librustc_mir/borrow_check/nll/type_check/liveness/polonius.rs", "status": "modified", "additions": 56, "deletions": 11, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Fpolonius.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Fpolonius.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Fpolonius.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -1,22 +1,28 @@\n use crate::borrow_check::location::{LocationIndex, LocationTable};\n+use crate::dataflow::indexes::MovePathIndex;\n+use crate::dataflow::move_paths::{LookupResult, MoveData};\n use crate::util::liveness::{categorize, DefUse};\n-use rustc::mir::visit::{PlaceContext, Visitor};\n-use rustc::mir::{Body, Local, Location};\n+use rustc::mir::visit::{MutatingUseContext, PlaceContext, Visitor};\n+use rustc::mir::{Body, Local, Location, Place};\n use rustc::ty::subst::Kind;\n use rustc::ty::Ty;\n \n use super::TypeChecker;\n \n type VarPointRelations = Vec<(Local, LocationIndex)>;\n+type MovePathPointRelations = Vec<(MovePathIndex, LocationIndex)>;\n \n-struct LivenessPointFactsExtractor<'me> {\n+struct UseFactsExtractor<'me> {\n     var_defined: &'me mut VarPointRelations,\n     var_used: &'me mut VarPointRelations,\n     location_table: &'me LocationTable,\n+    var_drop_used: &'me mut VarPointRelations,\n+    move_data: &'me MoveData<'me>,\n+    path_accessed_at: &'me mut MovePathPointRelations,\n }\n \n // A Visitor to walk through the MIR and extract point-wise facts\n-impl LivenessPointFactsExtractor<'_> {\n+impl UseFactsExtractor<'_> {\n     fn location_to_index(&self, location: Location) -> LocationIndex {\n         self.location_table.mid_index(location)\n     }\n@@ -30,15 +36,50 @@ impl LivenessPointFactsExtractor<'_> {\n         debug!(\"LivenessFactsExtractor::insert_use()\");\n         self.var_used.push((local, self.location_to_index(location)));\n     }\n+\n+    fn insert_drop_use(&mut self, local: Local, location: Location) {\n+        debug!(\"LivenessFactsExtractor::insert_drop_use()\");\n+        self.var_drop_used.push((local, self.location_to_index(location)));\n+    }\n+\n+    fn insert_path_access(&mut self, path: MovePathIndex, location: Location) {\n+        debug!(\"LivenessFactsExtractor::insert_path_access({:?}, {:?})\", path, location);\n+        self.path_accessed_at.push((path, self.location_to_index(location)));\n+    }\n+\n+    fn place_to_mpi(&self, place: &Place<'_>) -> Option<MovePathIndex> {\n+        match self.move_data.rev_lookup.find(place.as_ref()) {\n+            LookupResult::Exact(mpi) => Some(mpi),\n+            LookupResult::Parent(mmpi) => mmpi,\n+        }\n+    }\n }\n \n-impl Visitor<'tcx> for LivenessPointFactsExtractor<'_> {\n+impl Visitor<'tcx> for UseFactsExtractor<'_> {\n     fn visit_local(&mut self, &local: &Local, context: PlaceContext, location: Location) {\n         match categorize(context) {\n             Some(DefUse::Def) => self.insert_def(local, location),\n             Some(DefUse::Use) => self.insert_use(local, location),\n+            Some(DefUse::Drop) => self.insert_drop_use(local, location),\n+            _ => (),\n+        }\n+    }\n+\n+    fn visit_place(&mut self, place: &Place<'tcx>, context: PlaceContext, location: Location) {\n+        self.super_place(place, context, location);\n+        match context {\n+            PlaceContext::NonMutatingUse(_) => {\n+                if let Some(mpi) = self.place_to_mpi(place) {\n+                    self.insert_path_access(mpi, location);\n+                }\n+            }\n+\n+            PlaceContext::MutatingUse(MutatingUseContext::Borrow) => {\n+                if let Some(mpi) = self.place_to_mpi(place) {\n+                    self.insert_path_access(mpi, location);\n+                }\n+            }\n             _ => (),\n-            // NOTE: Drop handling is now done in trace()\n         }\n     }\n }\n@@ -54,23 +95,27 @@ fn add_var_uses_regions(typeck: &mut TypeChecker<'_, 'tcx>, local: Local, ty: Ty\n     });\n }\n \n-pub(super) fn populate_var_liveness_facts(\n+pub(super) fn populate_access_facts(\n     typeck: &mut TypeChecker<'_, 'tcx>,\n-    mir: &Body<'tcx>,\n+    body: &Body<'tcx>,\n     location_table: &LocationTable,\n+    move_data: &MoveData<'_>,\n ) {\n     debug!(\"populate_var_liveness_facts()\");\n \n     if let Some(facts) = typeck.borrowck_context.all_facts.as_mut() {\n-        LivenessPointFactsExtractor {\n+        UseFactsExtractor {\n             var_defined: &mut facts.var_defined,\n             var_used: &mut facts.var_used,\n+            var_drop_used: &mut facts.var_drop_used,\n+            path_accessed_at: &mut facts.path_accessed_at,\n             location_table,\n+            move_data,\n         }\n-        .visit_body(mir);\n+        .visit_body(body);\n     }\n \n-    for (local, local_decl) in mir.local_decls.iter_enumerated() {\n+    for (local, local_decl) in body.local_decls.iter_enumerated() {\n         add_var_uses_regions(typeck, local, local_decl.ty);\n     }\n }"}, {"sha": "9b55881cb1b10162a4e24b3d7657748b043e90b5", "filename": "src/librustc_mir/borrow_check/nll/type_check/liveness/trace.rs", "status": "modified", "additions": 2, "deletions": 98, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Ftrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Ftrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Ftrace.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179", "patch": "@@ -1,4 +1,3 @@\n-use crate::borrow_check::location::LocationTable;\n use crate::borrow_check::nll::region_infer::values::{self, PointIndex, RegionValueElements};\n use crate::borrow_check::nll::type_check::liveness::local_use_map::LocalUseMap;\n use crate::borrow_check::nll::type_check::liveness::polonius;\n@@ -38,7 +37,6 @@ pub(super) fn trace(\n     flow_inits: &mut FlowAtLocation<'tcx, MaybeInitializedPlaces<'_, 'tcx>>,\n     move_data: &MoveData<'tcx>,\n     live_locals: Vec<Local>,\n-    location_table: &LocationTable,\n ) {\n     debug!(\"trace()\");\n \n@@ -52,7 +50,6 @@ pub(super) fn trace(\n         local_use_map,\n         move_data,\n         drop_data: FxHashMap::default(),\n-        location_table,\n     };\n \n     LivenessResults::new(cx).compute_for_all_locals(live_locals);\n@@ -82,9 +79,6 @@ struct LivenessContext<'me, 'typeck, 'flow, 'tcx> {\n     /// Index indicating where each variable is assigned, used, or\n     /// dropped.\n     local_use_map: &'me LocalUseMap,\n-\n-    /// Maps between a MIR Location and a LocationIndex\n-    location_table: &'me LocationTable,\n }\n \n struct DropData<'tcx> {\n@@ -131,12 +125,6 @@ impl LivenessResults<'me, 'typeck, 'flow, 'tcx> {\n         for local in live_locals {\n             self.reset_local_state();\n             self.add_defs_for(local);\n-\n-            // FIXME: this is temporary until we can generate our own initialization\n-            if self.cx.typeck.borrowck_context.all_facts.is_some() {\n-                self.add_polonius_var_initialized_on_exit_for(local)\n-            }\n-\n             self.compute_use_live_points_for(local);\n             self.compute_drop_live_points_for(local);\n \n@@ -157,63 +145,6 @@ impl LivenessResults<'me, 'typeck, 'flow, 'tcx> {\n         }\n     }\n \n-    // WARNING: panics if self.cx.typeck.borrowck_context.all_facts != None\n-    //\n-    // FIXME: this analysis (the initialization tracking) should be\n-    // done in Polonius, but isn't yet.\n-    fn add_polonius_var_initialized_on_exit_for(&mut self, local: Local) {\n-        let move_path = self.cx.move_data.rev_lookup.find_local(local);\n-        let facts = self.cx.typeck.borrowck_context.all_facts.as_mut().unwrap();\n-        for block in self.cx.body.basic_blocks().indices() {\n-            debug!(\"polonius: generating initialization facts for {:?} in {:?}\", local, block);\n-\n-            // iterate through the block, applying the effects of each statement\n-            // up to and including location, and populate `var_initialized_on_exit`\n-            self.cx.flow_inits.reset_to_entry_of(block);\n-            let start_location = Location { block, statement_index: 0 };\n-            self.cx.flow_inits.apply_local_effect(start_location);\n-\n-            for statement_index in 0..self.cx.body[block].statements.len() {\n-                let current_location = Location { block, statement_index };\n-\n-                self.cx.flow_inits.reconstruct_statement_effect(current_location);\n-\n-                // statement has not yet taken effect:\n-                if self.cx.flow_inits.has_any_child_of(move_path).is_some() {\n-                    facts\n-                        .var_initialized_on_exit\n-                        .push((local, self.cx.location_table.start_index(current_location)));\n-                }\n-\n-                // statement has now taken effect\n-                self.cx.flow_inits.apply_local_effect(current_location);\n-\n-                if self.cx.flow_inits.has_any_child_of(move_path).is_some() {\n-                    facts\n-                        .var_initialized_on_exit\n-                        .push((local, self.cx.location_table.mid_index(current_location)));\n-                }\n-            }\n-\n-            let terminator_location = self.cx.body.terminator_loc(block);\n-\n-            if self.cx.flow_inits.has_any_child_of(move_path).is_some() {\n-                facts\n-                    .var_initialized_on_exit\n-                    .push((local, self.cx.location_table.start_index(terminator_location)));\n-            }\n-\n-            // apply the effects of the terminator and push it if needed\n-            self.cx.flow_inits.reset_to_exit_of(block);\n-\n-            if self.cx.flow_inits.has_any_child_of(move_path).is_some() {\n-                facts\n-                    .var_initialized_on_exit\n-                    .push((local, self.cx.location_table.mid_index(terminator_location)));\n-            }\n-        }\n-    }\n-\n     /// Clear the value of fields that are \"per local variable\".\n     fn reset_local_state(&mut self) {\n         self.defs.clear();\n@@ -273,11 +204,6 @@ impl LivenessResults<'me, 'typeck, 'flow, 'tcx> {\n             debug_assert_eq!(self.cx.body.terminator_loc(location.block), location,);\n \n             if self.cx.initialized_at_terminator(location.block, mpi) {\n-                // FIXME: this analysis (the initialization tracking) should be\n-                // done in Polonius, but isn't yet.\n-                if let Some(facts) = self.cx.typeck.borrowck_context.all_facts {\n-                    facts.var_drop_used.push((local, self.cx.location_table.mid_index(location)));\n-                }\n                 if self.drop_live_at.insert(drop_point) {\n                     self.drop_locations.push(location);\n                     self.stack.push(drop_point);\n@@ -468,13 +394,7 @@ impl LivenessContext<'_, '_, '_, 'tcx> {\n     ) {\n         debug!(\"add_use_live_facts_for(value={:?})\", value);\n \n-        Self::make_all_regions_live(\n-            self.elements,\n-            &mut self.typeck,\n-            value,\n-            live_at,\n-            self.location_table,\n-        )\n+        Self::make_all_regions_live(self.elements, &mut self.typeck, value, live_at)\n     }\n \n     /// Some variable with type `live_ty` is \"drop live\" at `location`\n@@ -525,13 +445,7 @@ impl LivenessContext<'_, '_, '_, 'tcx> {\n         // All things in the `outlives` array may be touched by\n         // the destructor and must be live at this point.\n         for &kind in &drop_data.dropck_result.kinds {\n-            Self::make_all_regions_live(\n-                self.elements,\n-                &mut self.typeck,\n-                kind,\n-                live_at,\n-                self.location_table,\n-            );\n+            Self::make_all_regions_live(self.elements, &mut self.typeck, kind, live_at);\n \n             polonius::add_var_drops_regions(&mut self.typeck, dropped_local, &kind);\n         }\n@@ -542,7 +456,6 @@ impl LivenessContext<'_, '_, '_, 'tcx> {\n         typeck: &mut TypeChecker<'_, 'tcx>,\n         value: impl TypeFoldable<'tcx>,\n         live_at: &HybridBitSet<PointIndex>,\n-        location_table: &LocationTable,\n     ) {\n         debug!(\"make_all_regions_live(value={:?})\", value);\n         debug!(\n@@ -559,15 +472,6 @@ impl LivenessContext<'_, '_, '_, 'tcx> {\n                 .constraints\n                 .liveness_constraints\n                 .add_elements(live_region_vid, live_at);\n-\n-            // FIXME: remove this when we can generate our own region-live-at reliably\n-            if let Some(facts) = typeck.borrowck_context.all_facts {\n-                for point in live_at.iter() {\n-                    let loc = elements.to_location(point);\n-                    facts.region_live_at.push((live_region_vid, location_table.start_index(loc)));\n-                    facts.region_live_at.push((live_region_vid, location_table.mid_index(loc)));\n-                }\n-            }\n         });\n     }\n "}, {"sha": "da1f64b05151bc310c9e9eaefe1a80a343666ee8", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179"}, {"sha": "bac08090817d952d98ca59d7be60294a8d3f343c", "filename": "src/librustc_mir/borrow_check/path_utils.rs", "status": "modified", "additions": 7, "deletions": 16, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Fborrow_check%2Fpath_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Fborrow_check%2Fpath_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fpath_utils.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179"}, {"sha": "5caba637ccc4abf1b7473d32e478d0da0d69daca", "filename": "src/librustc_mir/borrow_check/place_ext.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179"}, {"sha": "4f469174b392d04df81651befb6a542d0c45d507", "filename": "src/librustc_mir/borrow_check/places_conflict.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179"}, {"sha": "4c6be23de28be5746f0bfef3ae0fae88c26c2a43", "filename": "src/librustc_mir/borrow_check/prefixes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179"}, {"sha": "98cf4bba1c75fc68713441bd871dd0d88457804b", "filename": "src/librustc_mir/build/expr/as_place.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179"}, {"sha": "f949b529e9762bba756ab988c3c62bdc5b6f7948", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179"}, {"sha": "d5890d00ea80fb8384c8e5fd7803377eae9c557b", "filename": "src/librustc_mir/build/matches/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179"}, {"sha": "7ab0bf7d66a64a7850f3a46e8db1b3f112b876ea", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179"}, {"sha": "db679024dc5a292f4d3a475d3218e3165599d4e2", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 8, "deletions": 22, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179"}, {"sha": "1c43a553cc3c9edc681224df761c7f19f1cabe24", "filename": "src/librustc_mir/dataflow/impls/borrowed_locals.rs", "status": "modified", "additions": 4, "deletions": 13, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrowed_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrowed_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrowed_locals.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179"}, {"sha": "2ea6c4ae10fdc8f84682950a38f8ae232b8896fd", "filename": "src/librustc_mir/dataflow/impls/borrows.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179"}, {"sha": "d97f3b7417286806ca73f824fdacffb39988b660", "filename": "src/librustc_mir/dataflow/move_paths/abs_domain.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fabs_domain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fabs_domain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fabs_domain.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179"}, {"sha": "81451c2500c471bd1f9ca7bb7c9993a8f2fa420c", "filename": "src/librustc_mir/dataflow/move_paths/builder.rs", "status": "modified", "additions": 102, "deletions": 98, "changes": 200, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179"}, {"sha": "5028e9650918c5d55a3e01ca0fc2ea53f07dbe47", "filename": "src/librustc_mir/dataflow/move_paths/mod.rs", "status": "modified", "additions": 32, "deletions": 17, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179"}, {"sha": "ba299e9463b8d90af04308adba8b5953ca654ce1", "filename": "src/librustc_mir/error_codes.rs", "status": "modified", "additions": 19, "deletions": 83, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ferror_codes.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179"}, {"sha": "1b4b56082a696ba4d13707463a87db08ffc719f8", "filename": "src/librustc_mir/hair/pattern/check_match.rs", "status": "modified", "additions": 7, "deletions": 89, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179"}, {"sha": "054b65f0e1a9edc0c8ba0da1a17b391bf895b396", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 20, "deletions": 13, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179"}, {"sha": "4cbbc0ffe17cc4262462a27d977307710f0b64a1", "filename": "src/librustc_mir/interpret/intern.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintern.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179"}, {"sha": "0f2305e03ff33e74d4ff24a7aad639fb28662a1d", "filename": "src/librustc_mir/interpret/intrinsics.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179"}, {"sha": "032d16a49db4baa3d0f181e85c96292bbefa4f3c", "filename": "src/librustc_mir/interpret/intrinsics/type_name.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Ftype_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Ftype_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Ftype_name.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179"}, {"sha": "62b1760508b4cd0d00bcb4214a5e5fa3b813e2ca", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 23, "deletions": 94, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179"}, {"sha": "b5aab992e3adb6f4e84750ea34987cd38bcdef3a", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179"}, {"sha": "f358bb00f4d12a744d5969a00d25572ef18b3c00", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179"}, {"sha": "2cac8bb0c517e49b99a8a20390689f4e61266dd2", "filename": "src/librustc_mir/interpret/snapshot.rs", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179"}, {"sha": "10b767ebba191174fa663f9192a8f9c980641646", "filename": "src/librustc_mir/interpret/traits.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179"}, {"sha": "3e14ba3efcc584d51267ef462e4dc7f29b37ec3a", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 60, "deletions": 35, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179"}, {"sha": "f27db351b74dbbf124eba38a733e2ec85f00e9b8", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179"}, {"sha": "1f7efebfda819950f2f54deb3400400e8d212f36", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 24, "deletions": 23, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179"}, {"sha": "c193911247e2bea5bb4219c1461214ab7476bf5d", "filename": "src/librustc_mir/monomorphize/partitioning.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179"}, {"sha": "aa83255bf62f45a541ceb239173041a17a43b8c3", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179"}, {"sha": "15ecc6c37920b5c87f6eee616ed3540001326505", "filename": "src/librustc_mir/transform/add_call_guards.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Ftransform%2Fadd_call_guards.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Ftransform%2Fadd_call_guards.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fadd_call_guards.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179"}, {"sha": "052631ddff37125df0e6429759b32effbb1c1d4b", "filename": "src/librustc_mir/transform/add_moves_for_packed_drops.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Ftransform%2Fadd_moves_for_packed_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Ftransform%2Fadd_moves_for_packed_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fadd_moves_for_packed_drops.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179"}, {"sha": "0fd75cd57b2ac31856938a2707fa59b1274ea986", "filename": "src/librustc_mir/transform/add_retag.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Ftransform%2Fadd_retag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Ftransform%2Fadd_retag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fadd_retag.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179"}, {"sha": "539922c54d12d9530b49e755f2d6d93bf34266ce", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179"}, {"sha": "ede1cb62f9451475583c390ec82bf5aea48014fd", "filename": "src/librustc_mir/transform/cleanup_post_borrowck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Ftransform%2Fcleanup_post_borrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Ftransform%2Fcleanup_post_borrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcleanup_post_borrowck.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179"}, {"sha": "e4b186736e2a199e822868d3519abab101e553bc", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 20, "deletions": 36, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179"}, {"sha": "f3a523a813413e8abfe31a651fa965dc11e7a16a", "filename": "src/librustc_mir/transform/copy_prop.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179"}, {"sha": "1fc7ce09aa647db7a2d2229f3956578a79ba5794", "filename": "src/librustc_mir/transform/deaggregator.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Ftransform%2Fdeaggregator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Ftransform%2Fdeaggregator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fdeaggregator.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179"}, {"sha": "ed0eff943a165d86408dbf4d3295a8bec690dad7", "filename": "src/librustc_mir/transform/dump_mir.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Ftransform%2Fdump_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Ftransform%2Fdump_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fdump_mir.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179"}, {"sha": "7a5c00c85962946cec88c94dbbf4312af32be100", "filename": "src/librustc_mir/transform/elaborate_drops.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179"}, {"sha": "21ca339eb968bdfb6f644a14011725a021daee75", "filename": "src/librustc_mir/transform/erase_regions.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179"}, {"sha": "d87331195dd2402ef380075a4a0ae7e1aaae8058", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179"}, {"sha": "f31303c642faa1ec34523b5ae3b87a6bb5645428", "filename": "src/librustc_mir/transform/inline.rs", "status": "modified", "additions": 3, "deletions": 23, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179"}, {"sha": "abe41606e80794a76ce3de1375ae218d2b37ff96", "filename": "src/librustc_mir/transform/instcombine.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179"}, {"sha": "ac291c2996d065afc7140d92dc366141a8b59cf8", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 76, "deletions": 60, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179"}, {"sha": "762bb5d44839f096c06ee216889d3310bec56ed0", "filename": "src/librustc_mir/transform/no_landing_pads.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Ftransform%2Fno_landing_pads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Ftransform%2Fno_landing_pads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fno_landing_pads.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179"}, {"sha": "cdccdfea3994342dddcf72a66e65c04688c250e2", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 38, "deletions": 11, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179"}, {"sha": "32b49ee942300290d29b3a6b2830cc918f74b2f4", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 137, "deletions": 134, "changes": 271, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179"}, {"sha": "56093527aee249c3301af89bcc46922b4d1055ed", "filename": "src/librustc_mir/transform/qualify_min_const_fn.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179"}, {"sha": "73089a2106f6b4f46885d7ea607dbf227e39ad4b", "filename": "src/librustc_mir/transform/remove_noop_landing_pads.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Ftransform%2Fremove_noop_landing_pads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Ftransform%2Fremove_noop_landing_pads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fremove_noop_landing_pads.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179"}, {"sha": "1d3bf247387a74ea588264a9679267b35bc4000c", "filename": "src/librustc_mir/transform/rustc_peek.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179"}, {"sha": "d4599ee08aa4614f43c8db3c37b3808bdeb95e83", "filename": "src/librustc_mir/transform/simplify.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179"}, {"sha": "0a509666d34aedb76ffd0711af52c4562db8fc8f", "filename": "src/librustc_mir/transform/simplify_branches.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Ftransform%2Fsimplify_branches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Ftransform%2Fsimplify_branches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fsimplify_branches.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179"}, {"sha": "8199a252e78b06c877774a4fe4e80d119037e388", "filename": "src/librustc_mir/transform/uniform_array_move_out.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Ftransform%2Funiform_array_move_out.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Ftransform%2Funiform_array_move_out.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Funiform_array_move_out.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179"}, {"sha": "cf9ef55c17b3464422f7c83988e278605361178c", "filename": "src/librustc_mir/util/borrowck_errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179"}, {"sha": "f3e03e7f81daa89c9f5c09bfeb8135c85e92403c", "filename": "src/librustc_mir/util/elaborate_drops.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179"}, {"sha": "c35c9e4da9f4846be217a9cabc0ed3205f56d0c9", "filename": "src/librustc_mir/util/pretty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fpretty.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179"}, {"sha": "de1676f489a467c087b86da26b93ff51a7adcd0f", "filename": "src/librustc_msan/build.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_msan%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_msan%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_msan%2Fbuild.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179"}, {"sha": "5b78727fdd5ad133fff2905eee7a35a299a63053", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8bf872f6adf145b75610dc216e942a84343179/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=5e8bf872f6adf145b75610dc216e942a84343179"}]}