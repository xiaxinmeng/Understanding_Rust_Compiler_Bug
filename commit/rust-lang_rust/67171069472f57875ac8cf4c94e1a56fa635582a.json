{"sha": "67171069472f57875ac8cf4c94e1a56fa635582a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY3MTcxMDY5NDcyZjU3ODc1YWM4Y2Y0Yzk0ZTFhNTZmYTYzNTU4MmE=", "commit": {"author": {"name": "James Miller", "email": "james@aatch.net", "date": "2016-05-13T17:41:42Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@posteo.net", "date": "2016-07-08T14:42:38Z"}, "message": "Drive function item translation from collector\n\nFunctions and method are declared ahead-of-time, including generic ones.\n\nClosures are not considered trans items anymore, instead they are\ntranslated on demands.", "tree": {"sha": "7d27fc98d1a84e78074f846215760140a6995f11", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7d27fc98d1a84e78074f846215760140a6995f11"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/67171069472f57875ac8cf4c94e1a56fa635582a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/67171069472f57875ac8cf4c94e1a56fa635582a", "html_url": "https://github.com/rust-lang/rust/commit/67171069472f57875ac8cf4c94e1a56fa635582a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/67171069472f57875ac8cf4c94e1a56fa635582a/comments", "author": {"login": "Aatch", "id": 342416, "node_id": "MDQ6VXNlcjM0MjQxNg==", "avatar_url": "https://avatars.githubusercontent.com/u/342416?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aatch", "html_url": "https://github.com/Aatch", "followers_url": "https://api.github.com/users/Aatch/followers", "following_url": "https://api.github.com/users/Aatch/following{/other_user}", "gists_url": "https://api.github.com/users/Aatch/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aatch/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aatch/subscriptions", "organizations_url": "https://api.github.com/users/Aatch/orgs", "repos_url": "https://api.github.com/users/Aatch/repos", "events_url": "https://api.github.com/users/Aatch/events{/privacy}", "received_events_url": "https://api.github.com/users/Aatch/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "891c2a082fd562744b4495ed7bd0602414e93f2b", "url": "https://api.github.com/repos/rust-lang/rust/commits/891c2a082fd562744b4495ed7bd0602414e93f2b", "html_url": "https://github.com/rust-lang/rust/commit/891c2a082fd562744b4495ed7bd0602414e93f2b"}], "stats": {"total": 386, "additions": 211, "deletions": 175}, "files": [{"sha": "05ae347b534ab2f3bb116df35dd34c79fed42e4a", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 90, "deletions": 83, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/67171069472f57875ac8cf4c94e1a56fa635582a/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67171069472f57875ac8cf4c94e1a56fa635582a/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=67171069472f57875ac8cf4c94e1a56fa635582a", "patch": "@@ -75,6 +75,7 @@ use debuginfo::{self, DebugLoc, ToDebugLoc};\n use declare;\n use expr;\n use glue;\n+use inline;\n use machine;\n use machine::{llalign_of_min, llsize_of, llsize_of_real};\n use meth;\n@@ -1948,6 +1949,49 @@ pub fn trans_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                   closure::ClosureEnv::NotClosure);\n }\n \n+pub fn trans_instance<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, instance: Instance<'tcx>) {\n+    let instance = inline::maybe_inline_instance(ccx, instance);\n+\n+    let fn_node_id = ccx.tcx().map.as_local_node_id(instance.def).unwrap();\n+\n+    let _s = StatRecorder::new(ccx, ccx.tcx().node_path_str(fn_node_id));\n+    debug!(\"trans_instance(instance={:?})\", instance);\n+    let _icx = push_ctxt(\"trans_instance\");\n+\n+    let item = ccx.tcx().map.find(fn_node_id).unwrap();\n+\n+    let fn_ty = ccx.tcx().lookup_item_type(instance.def).ty;\n+    let fn_ty = ccx.tcx().erase_regions(&fn_ty);\n+    let fn_ty = monomorphize::apply_param_substs(ccx.tcx(), instance.substs, &fn_ty);\n+\n+    let sig = ccx.tcx().erase_late_bound_regions(fn_ty.fn_sig());\n+    let sig = ccx.tcx().normalize_associated_type(&sig);\n+    let abi = fn_ty.fn_abi();\n+\n+    let lldecl = match ccx.instances().borrow().get(&instance) {\n+        Some(&val) => val,\n+        None => bug!(\"Instance `{:?}` not already declared\", instance)\n+    };\n+\n+    match item {\n+        hir_map::NodeItem(&hir::Item {\n+            node: hir::ItemFn(ref decl, _, _, _, _, ref body), ..\n+        }) |\n+        hir_map::NodeTraitItem(&hir::TraitItem {\n+            node: hir::MethodTraitItem(\n+                hir::MethodSig { ref decl, .. }, Some(ref body)), ..\n+        }) |\n+        hir_map::NodeImplItem(&hir::ImplItem {\n+            node: hir::ImplItemKind::Method(\n+                hir::MethodSig { ref decl, .. }, ref body), ..\n+        }) => {\n+            trans_closure(ccx, decl, body, lldecl, instance,\n+                          fn_node_id, &sig, abi, closure::ClosureEnv::NotClosure);\n+        }\n+        _ => bug!(\"Instance is a {:?}?\", item)\n+    }\n+}\n+\n pub fn trans_named_tuple_constructor<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                                                  ctor_ty: Ty<'tcx>,\n                                                  disr: Disr,\n@@ -2267,79 +2311,33 @@ pub fn trans_item(ccx: &CrateContext, item: &hir::Item) {\n     let _icx = push_ctxt(\"trans_item\");\n \n     let tcx = ccx.tcx();\n-    let from_external = ccx.external_srcs().borrow().contains_key(&item.id);\n-\n     match item.node {\n-        hir::ItemFn(ref decl, _, _, _, ref generics, ref body) => {\n-            if !generics.is_type_parameterized() {\n-                let trans_everywhere = attr::requests_inline(&item.attrs);\n-                // Ignore `trans_everywhere` for cross-crate inlined items\n-                // (`from_external`).  `trans_item` will be called once for each\n-                // compilation unit that references the item, so it will still get\n-                // translated everywhere it's needed.\n-                for (ref ccx, is_origin) in ccx.maybe_iter(!from_external && trans_everywhere) {\n-                    let def_id = tcx.map.local_def_id(item.id);\n-                    let empty_substs = ccx.empty_substs_for_def_id(def_id);\n-                    let llfn = Callee::def(ccx, def_id, empty_substs).reify(ccx).val;\n-                    trans_fn(ccx, &decl, &body, llfn, empty_substs, item.id);\n-                    set_link_section(ccx, llfn, &item.attrs);\n-                    update_linkage(ccx,\n-                                   llfn,\n-                                   Some(item.id),\n-                                   if is_origin {\n-                                       OriginalTranslation\n-                                   } else {\n-                                       InlinedCopy\n-                                   });\n-\n-                    if is_entry_fn(ccx.sess(), item.id) {\n-                        create_entry_wrapper(ccx, item.span, llfn);\n-                        // check for the #[rustc_error] annotation, which forces an\n-                        // error in trans. This is used to write compile-fail tests\n-                        // that actually test that compilation succeeds without\n-                        // reporting an error.\n-                        if tcx.has_attr(def_id, \"rustc_error\") {\n-                            tcx.sess.span_fatal(item.span, \"compilation successful\");\n-                        }\n-                    }\n+        hir::ItemFn(_, _, _, _, _, _) => {\n+            let def_id = tcx.map.local_def_id(item.id);\n+            // check for the #[rustc_error] annotation, which forces an\n+            // error in trans. This is used to write compile-fail tests\n+            // that actually test that compilation succeeds without\n+            // reporting an error.\n+            if is_entry_fn(ccx.sess(), item.id) {\n+                let empty_substs = ccx.empty_substs_for_def_id(def_id);\n+                let llfn = Callee::def(ccx, def_id, empty_substs).reify(ccx).val;\n+                create_entry_wrapper(ccx, item.span, llfn);\n+                if tcx.has_attr(def_id, \"rustc_error\") {\n+                    tcx.sess.span_fatal(item.span, \"compilation successful\");\n                 }\n             }\n-        }\n-        hir::ItemImpl(_, _, ref generics, _, _, ref impl_items) => {\n-            // Both here and below with generic methods, be sure to recurse and look for\n-            // items that we need to translate.\n-            if !generics.ty_params.is_empty() {\n-                return;\n-            }\n \n-            for impl_item in impl_items {\n-                if let hir::ImplItemKind::Method(ref sig, ref body) = impl_item.node {\n-                    if sig.generics.ty_params.is_empty() {\n-                        let trans_everywhere = attr::requests_inline(&impl_item.attrs);\n-                        for (ref ccx, is_origin) in ccx.maybe_iter(trans_everywhere) {\n-                            let def_id = tcx.map.local_def_id(impl_item.id);\n-                            let empty_substs = ccx.empty_substs_for_def_id(def_id);\n-                            let llfn = Callee::def(ccx, def_id, empty_substs).reify(ccx).val;\n-                            trans_fn(ccx, &sig.decl, body, llfn, empty_substs, impl_item.id);\n-                            update_linkage(ccx, llfn, Some(impl_item.id),\n-                                if is_origin {\n-                                    OriginalTranslation\n-                                } else {\n-                                    InlinedCopy\n-                                });\n-                        }\n-                    }\n-                }\n-            }\n+            // Function is actually translated in trans_instance\n         }\n         hir::ItemEnum(ref enum_definition, ref gens) => {\n             if gens.ty_params.is_empty() {\n                 // sizes only make sense for non-generic types\n                 enum_variant_size_lint(ccx, enum_definition, item.span, item.id);\n             }\n         }\n+        hir::ItemImpl(..) |\n         hir::ItemStatic(..) => {\n-            // Don't do anything here. Translation of statics has been moved to\n+            // Don't do anything here. Translation has been moved to\n             // being \"collector-driven\".\n         }\n         _ => {}\n@@ -2482,16 +2480,16 @@ fn internalize_symbols(cx: &CrateContextList, reachable: &HashSet<&str>) {\n                 let linkage = llvm::LLVMGetLinkage(val);\n                 // We only care about external declarations (not definitions)\n                 // and available_externally definitions.\n-                if !(linkage == llvm::ExternalLinkage as c_uint &&\n-                     llvm::LLVMIsDeclaration(val) != 0) &&\n-                   !(linkage == llvm::AvailableExternallyLinkage as c_uint) {\n-                    continue;\n+                let is_available_externally = linkage == llvm::AvailableExternallyLinkage as c_uint;\n+                let is_decl = llvm::LLVMIsDeclaration(val) != 0;\n+\n+                if is_decl || is_available_externally {\n+                    let name = CStr::from_ptr(llvm::LLVMGetValueName(val))\n+                        .to_bytes()\n+                        .to_vec();\n+                    declared.insert(name);\n                 }\n \n-                let name = CStr::from_ptr(llvm::LLVMGetValueName(val))\n-                               .to_bytes()\n-                               .to_vec();\n-                declared.insert(name);\n             }\n         }\n \n@@ -2501,21 +2499,27 @@ fn internalize_symbols(cx: &CrateContextList, reachable: &HashSet<&str>) {\n         for ccx in cx.iter() {\n             for val in iter_globals(ccx.llmod()).chain(iter_functions(ccx.llmod())) {\n                 let linkage = llvm::LLVMGetLinkage(val);\n+\n+                let is_external = linkage == llvm::ExternalLinkage as c_uint;\n+                let is_weak_odr = linkage == llvm::WeakODRLinkage as c_uint;\n+                let is_decl = llvm::LLVMIsDeclaration(val) != 0;\n+\n                 // We only care about external definitions.\n-                if !((linkage == llvm::ExternalLinkage as c_uint ||\n-                      linkage == llvm::WeakODRLinkage as c_uint) &&\n-                     llvm::LLVMIsDeclaration(val) == 0) {\n-                    continue;\n-                }\n+                if (is_external || is_weak_odr) && !is_decl {\n+\n+                    let name = CStr::from_ptr(llvm::LLVMGetValueName(val))\n+                                .to_bytes()\n+                                .to_vec();\n+\n+                    let is_declared = declared.contains(&name);\n+                    let reachable = reachable.contains(str::from_utf8(&name).unwrap());\n+\n+                    if !is_declared && !reachable {\n+                        llvm::SetLinkage(val, llvm::InternalLinkage);\n+                        llvm::SetDLLStorageClass(val, llvm::DefaultStorageClass);\n+                        llvm::UnsetComdat(val);\n+                    }\n \n-                let name = CStr::from_ptr(llvm::LLVMGetValueName(val))\n-                               .to_bytes()\n-                               .to_vec();\n-                if !declared.contains(&name) &&\n-                   !reachable.contains(str::from_utf8(&name).unwrap()) {\n-                    llvm::SetLinkage(val, llvm::InternalLinkage);\n-                    llvm::SetDLLStorageClass(val, llvm::DefaultStorageClass);\n-                    llvm::UnsetComdat(val);\n                 }\n             }\n         }\n@@ -2744,6 +2748,9 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                         span_bug!(item.span, \"Mismatch between hir::Item type and TransItem type\")\n                     }\n                 }\n+                TransItem::Fn(instance) => {\n+                    trans_instance(&ccx, instance);\n+                }\n                 _ => { }\n             }\n         }\n@@ -2980,7 +2987,7 @@ fn collect_and_partition_translation_items<'a, 'tcx>(scx: &SharedCrateContext<'a\n         let mut item_keys: Vec<_> = items\n             .iter()\n             .map(|i| {\n-                let mut output = i.to_string(scx.tcx());\n+                let mut output = i.to_string(scx);\n                 output.push_str(\" @@\");\n                 let mut empty = Vec::new();\n                 let mut cgus = item_to_cgus.get_mut(i).unwrap_or(&mut empty);"}, {"sha": "bf9cde9a44166de1a9e55b046aee29a21b906c49", "filename": "src/librustc_trans/closure.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/67171069472f57875ac8cf4c94e1a56fa635582a/src%2Flibrustc_trans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67171069472f57875ac8cf4c94e1a56fa635582a/src%2Flibrustc_trans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fclosure.rs?ref=67171069472f57875ac8cf4c94e1a56fa635582a", "patch": "@@ -10,7 +10,7 @@\n \n use arena::TypedArena;\n use back::symbol_names;\n-use llvm::{ValueRef, get_param, get_params};\n+use llvm::{self, ValueRef, get_param, get_params};\n use rustc::hir::def_id::DefId;\n use abi::{Abi, FnType};\n use adt;\n@@ -167,7 +167,7 @@ fn get_or_create_closure_declaration<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             variadic: false\n         })\n     }));\n-    let llfn = declare::define_internal_fn(ccx, &symbol, function_type);\n+    let llfn = declare::declare_fn(ccx, &symbol, function_type);\n \n     // set an inline hint for all closures\n     attributes::inline(llfn, attributes::InlineAttr::Hint);\n@@ -211,6 +211,7 @@ pub fn trans_closure_expr<'a, 'tcx>(dest: Dest<'a, 'tcx>,\n            id, closure_def_id, closure_substs);\n \n     let llfn = get_or_create_closure_declaration(ccx, closure_def_id, closure_substs);\n+    llvm::SetLinkage(llfn, llvm::WeakODRLinkage);\n \n     // Get the type of this closure. Use the current `param_substs` as\n     // the closure substitutions. This makes sense because the closure\n@@ -377,7 +378,7 @@ fn trans_fn_once_adapter_shim<'a, 'tcx>(\n     // Create the by-value helper.\n     let function_name =\n         symbol_names::internal_name_from_type_and_suffix(ccx, llonce_fn_ty, \"once_shim\");\n-    let lloncefn = declare::define_internal_fn(ccx, &function_name, llonce_fn_ty);\n+    let lloncefn = declare::declare_fn(ccx, &function_name, llonce_fn_ty);\n     attributes::set_frame_pointer_elimination(ccx, lloncefn);\n \n     let (block_arena, fcx): (TypedArena<_>, FunctionContext);"}, {"sha": "8cb9fd23e49204188a6b976097bc86475ef787e5", "filename": "src/librustc_trans/collector.rs", "status": "modified", "additions": 26, "deletions": 15, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/67171069472f57875ac8cf4c94e1a56fa635582a/src%2Flibrustc_trans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67171069472f57875ac8cf4c94e1a56fa635582a/src%2Flibrustc_trans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcollector.rs?ref=67171069472f57875ac8cf4c94e1a56fa635582a", "patch": "@@ -325,7 +325,7 @@ fn collect_items_rec<'a, 'tcx: 'a>(scx: &SharedCrateContext<'a, 'tcx>,\n         // We've been here already, no need to search again.\n         return;\n     }\n-    debug!(\"BEGIN collect_items_rec({})\", starting_point.to_string(scx.tcx()));\n+    debug!(\"BEGIN collect_items_rec({})\", starting_point.to_string(scx));\n \n     let mut neighbors = Vec::new();\n     let recursion_depth_reset;\n@@ -396,7 +396,7 @@ fn collect_items_rec<'a, 'tcx: 'a>(scx: &SharedCrateContext<'a, 'tcx>,\n         recursion_depths.insert(def_id, depth);\n     }\n \n-    debug!(\"END collect_items_rec({})\", starting_point.to_string(scx.tcx()));\n+    debug!(\"END collect_items_rec({})\", starting_point.to_string(scx));\n }\n \n fn record_inlining_canditates<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -456,12 +456,25 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n         match *rvalue {\n             mir::Rvalue::Aggregate(mir::AggregateKind::Closure(def_id,\n                                                                ref substs), _) => {\n-                assert!(can_have_local_instance(self.scx.tcx(), def_id));\n-                let trans_item = create_fn_trans_item(self.scx.tcx(),\n-                                                      def_id,\n-                                                      substs.func_substs,\n-                                                      self.param_substs);\n-                self.output.push(trans_item);\n+                let mir = errors::expect(self.scx.sess().diagnostic(), self.scx.get_mir(def_id),\n+                                         || format!(\"Could not find MIR for closure: {:?}\", def_id));\n+\n+                let concrete_substs = monomorphize::apply_param_substs(self.scx.tcx(),\n+                                                                       self.param_substs,\n+                                                                       &substs.func_substs);\n+                let concrete_substs = self.scx.tcx().erase_regions(&concrete_substs);\n+\n+                let mut visitor = MirNeighborCollector {\n+                    scx: self.scx,\n+                    mir: &mir,\n+                    output: self.output,\n+                    param_substs: concrete_substs\n+                };\n+\n+                visitor.visit_mir(&mir);\n+                for promoted in &mir.promoted {\n+                    visitor.visit_mir(promoted);\n+                }\n             }\n             // When doing an cast from a regular pointer to a fat pointer, we\n             // have to instantiate all methods of the trait being cast to, so we\n@@ -1107,9 +1120,8 @@ impl<'b, 'a, 'v> hir_visit::Visitor<'v> for RootCollector<'b, 'a, 'v> {\n                                         self.scx.tcx().map.local_def_id(item.id)));\n                 self.output.push(TransItem::Static(item.id));\n             }\n-            hir::ItemFn(_, _, constness, _, ref generics, _) => {\n-                if !generics.is_type_parameterized() &&\n-                   constness == hir::Constness::NotConst {\n+            hir::ItemFn(_, _, _, _, ref generics, _) => {\n+                if !generics.is_type_parameterized() {\n                     let def_id = self.scx.tcx().map.local_def_id(item.id);\n \n                     debug!(\"RootCollector: ItemFn({})\",\n@@ -1129,9 +1141,8 @@ impl<'b, 'a, 'v> hir_visit::Visitor<'v> for RootCollector<'b, 'a, 'v> {\n         match ii.node {\n             hir::ImplItemKind::Method(hir::MethodSig {\n                 ref generics,\n-                constness,\n                 ..\n-            }, _) if constness == hir::Constness::NotConst => {\n+            }, _) => {\n                 let hir_map = &self.scx.tcx().map;\n                 let parent_node_id = hir_map.get_parent_node(ii.id);\n                 let is_impl_generic = match hir_map.expect_item(parent_node_id) {\n@@ -1260,7 +1271,7 @@ pub fn print_collection_results<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>) {\n         let mut item_keys = FnvHashMap();\n \n         for (item, item_state) in trans_items.iter() {\n-            let k = item.to_string(scx.tcx());\n+            let k = item.to_string(scx);\n \n             if item_keys.contains_key(&k) {\n                 let prev: (TransItem, TransItemState) = item_keys[&k];\n@@ -1288,7 +1299,7 @@ pub fn print_collection_results<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>) {\n     let mut generated = FnvHashSet();\n \n     for (item, item_state) in trans_items.iter() {\n-        let item_key = item.to_string(scx.tcx());\n+        let item_key = item.to_string(scx);\n \n         match *item_state {\n             TransItemState::PredictedAndGenerated => {"}, {"sha": "4077b894d62d4456a76dc16f1baf83ab83b78f16", "filename": "src/librustc_trans/inline.rs", "status": "modified", "additions": 12, "deletions": 52, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/67171069472f57875ac8cf4c94e1a56fa635582a/src%2Flibrustc_trans%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67171069472f57875ac8cf4c94e1a56fa635582a/src%2Flibrustc_trans%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Finline.rs?ref=67171069472f57875ac8cf4c94e1a56fa635582a", "patch": "@@ -8,13 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use llvm::{AvailableExternallyLinkage, InternalLinkage, SetLinkage};\n use middle::cstore::{FoundAst, InlinedItem};\n use rustc::hir::def_id::DefId;\n-use rustc::ty::subst::Substs;\n-use base::{push_ctxt, trans_item, trans_fn};\n-use callee::Callee;\n+use base::push_ctxt;\n use common::*;\n+use monomorphize::Instance;\n \n use rustc::dep_graph::DepNode;\n use rustc::hir;\n@@ -52,30 +50,6 @@ fn instantiate_inline(ccx: &CrateContext, fn_id: DefId) -> Option<DefId> {\n             ccx.external_srcs().borrow_mut().insert(item.id, fn_id);\n \n             ccx.stats().n_inlines.set(ccx.stats().n_inlines.get() + 1);\n-            trans_item(ccx, item);\n-\n-            if let hir::ItemFn(_, _, _, _, ref generics, _) = item.node {\n-                // Generics have no symbol, so they can't be given any linkage.\n-                if !generics.is_type_parameterized() {\n-                    let linkage = if ccx.sess().opts.cg.codegen_units == 1 {\n-                        // We could use AvailableExternallyLinkage here,\n-                        // but InternalLinkage allows LLVM to optimize more\n-                        // aggressively (at the cost of sometimes\n-                        // duplicating code).\n-                        InternalLinkage\n-                    } else {\n-                        // With multiple compilation units, duplicated code\n-                        // is more of a problem.  Also, `codegen_units > 1`\n-                        // means the user is okay with losing some\n-                        // performance.\n-                        AvailableExternallyLinkage\n-                    };\n-                    let empty_substs = tcx.mk_substs(Substs::empty());\n-                    let def_id = tcx.map.local_def_id(item.id);\n-                    let llfn = Callee::def(ccx, def_id, empty_substs).reify(ccx).val;\n-                    SetLinkage(llfn, linkage);\n-                }\n-            }\n \n             item.id\n         }\n@@ -135,35 +109,12 @@ fn instantiate_inline(ccx: &CrateContext, fn_id: DefId) -> Option<DefId> {\n             // don't.\n             trait_item.id\n         }\n-        FoundAst::Found(&InlinedItem::ImplItem(impl_did, ref impl_item)) => {\n+        FoundAst::Found(&InlinedItem::ImplItem(_, ref impl_item)) => {\n             ccx.external().borrow_mut().insert(fn_id, Some(impl_item.id));\n             ccx.external_srcs().borrow_mut().insert(impl_item.id, fn_id);\n \n             ccx.stats().n_inlines.set(ccx.stats().n_inlines.get() + 1);\n \n-            // Translate monomorphic impl methods immediately.\n-            if let hir::ImplItemKind::Method(ref sig, ref body) = impl_item.node {\n-                let impl_tpt = tcx.lookup_item_type(impl_did);\n-                if impl_tpt.generics.types.is_empty() &&\n-                        sig.generics.ty_params.is_empty() {\n-                    let def_id = tcx.map.local_def_id(impl_item.id);\n-                    let empty_substs = ccx.empty_substs_for_def_id(def_id);\n-                    let llfn = Callee::def(ccx, def_id, empty_substs).reify(ccx).val;\n-                    trans_fn(ccx,\n-                             &sig.decl,\n-                             body,\n-                             llfn,\n-                             empty_substs,\n-                             impl_item.id);\n-                    // See linkage comments on items.\n-                    if ccx.sess().opts.cg.codegen_units == 1 {\n-                        SetLinkage(llfn, InternalLinkage);\n-                    } else {\n-                        SetLinkage(llfn, AvailableExternallyLinkage);\n-                    }\n-                }\n-            }\n-\n             impl_item.id\n         }\n     };\n@@ -184,3 +135,12 @@ pub fn get_local_instance(ccx: &CrateContext, fn_id: DefId)\n pub fn maybe_instantiate_inline(ccx: &CrateContext, fn_id: DefId) -> DefId {\n     get_local_instance(ccx, fn_id).unwrap_or(fn_id)\n }\n+\n+pub fn maybe_inline_instance<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                                       instance: Instance<'tcx>) -> Instance<'tcx> {\n+    let def_id = maybe_instantiate_inline(ccx, instance.def);\n+    Instance {\n+        def: def_id,\n+        substs: instance.substs\n+    }\n+}"}, {"sha": "13d6d432422948db7c96d1f1962e0cb12f0cb00b", "filename": "src/librustc_trans/monomorphize.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/67171069472f57875ac8cf4c94e1a56fa635582a/src%2Flibrustc_trans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67171069472f57875ac8cf4c94e1a56fa635582a/src%2Flibrustc_trans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmonomorphize.rs?ref=67171069472f57875ac8cf4c94e1a56fa635582a", "patch": "@@ -109,15 +109,16 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         });\n     match map_node {\n         hir_map::NodeItem(&hir::Item {\n-            ref attrs, node: hir::ItemFn(ref decl, _, _, _, _, ref body), ..\n-        }) |\n-        hir_map::NodeTraitItem(&hir::TraitItem {\n-            ref attrs, node: hir::MethodTraitItem(\n-                hir::MethodSig { ref decl, .. }, Some(ref body)), ..\n+            ref attrs,\n+            node: hir::ItemFn(ref decl, _, _, _, _, ref body), ..\n         }) |\n         hir_map::NodeImplItem(&hir::ImplItem {\n             ref attrs, node: hir::ImplItemKind::Method(\n                 hir::MethodSig { ref decl, .. }, ref body), ..\n+        }) |\n+        hir_map::NodeTraitItem(&hir::TraitItem {\n+            ref attrs, node: hir::MethodTraitItem(\n+                hir::MethodSig { ref decl, .. }, Some(ref body)), ..\n         }) => {\n             attributes::from_fn_attrs(ccx, attrs, lldecl);\n "}, {"sha": "f3c0ddfaf73a91bf1a22c909dfde2700c84457c9", "filename": "src/librustc_trans/trans_item.rs", "status": "modified", "additions": 73, "deletions": 17, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/67171069472f57875ac8cf4c94e1a56fa635582a/src%2Flibrustc_trans%2Ftrans_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67171069472f57875ac8cf4c94e1a56fa635582a/src%2Flibrustc_trans%2Ftrans_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans_item.rs?ref=67171069472f57875ac8cf4c94e1a56fa635582a", "patch": "@@ -14,19 +14,22 @@\n //! item-path. This is used for unit testing the code that generates\n //! paths etc in all kinds of annoying scenarios.\n \n+use attributes;\n use base;\n-use context::CrateContext;\n+use context::{SharedCrateContext, CrateContext};\n use declare;\n use glue::DropGlueKind;\n use llvm;\n-use monomorphize::Instance;\n+use monomorphize::{self, Instance};\n+use inline;\n use rustc::hir;\n+use rustc::hir::map as hir_map;\n use rustc::hir::def_id::DefId;\n-use rustc::ty::{self, Ty, TyCtxt};\n+use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n use rustc::ty::subst;\n use std::hash::{Hash, Hasher};\n use syntax::ast::{self, NodeId};\n-use syntax::attr;\n+use syntax::{attr,errors};\n use syntax::parse::token;\n use type_of;\n \n@@ -59,24 +62,27 @@ impl<'tcx> Hash for TransItem<'tcx> {\n }\n \n \n-impl<'tcx> TransItem<'tcx> {\n+impl<'a, 'tcx> TransItem<'tcx> {\n \n-    pub fn predefine<'ccx>(&self,\n-                           ccx: &CrateContext<'ccx, 'tcx>,\n-                           linkage: llvm::Linkage) {\n+    pub fn predefine(&self,\n+                     ccx: &CrateContext<'a, 'tcx>,\n+                     linkage: llvm::Linkage) {\n         match *self {\n             TransItem::Static(node_id) => {\n                 TransItem::predefine_static(ccx, node_id, linkage);\n             }\n+            TransItem::Fn(instance) => {\n+                TransItem::predefine_fn(ccx, instance, linkage);\n+            }\n             _ => {\n                 // Not yet implemented\n             }\n         }\n     }\n \n-    fn predefine_static<'a>(ccx: &CrateContext<'a, 'tcx>,\n-                            node_id: ast::NodeId,\n-                            linkage: llvm::Linkage) {\n+    fn predefine_static(ccx: &CrateContext<'a, 'tcx>,\n+                        node_id: ast::NodeId,\n+                        linkage: llvm::Linkage) {\n         let def_id = ccx.tcx().map.local_def_id(node_id);\n         let ty = ccx.tcx().lookup_item_type(def_id).ty;\n         let llty = type_of::type_of(ccx, ty);\n@@ -101,7 +107,57 @@ impl<'tcx> TransItem<'tcx> {\n         }\n     }\n \n-    pub fn requests_inline<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> bool {\n+    fn predefine_fn(ccx: &CrateContext<'a, 'tcx>,\n+                    instance: Instance<'tcx>,\n+                    linkage: llvm::Linkage) {\n+        let unit = ccx.codegen_unit();\n+        debug!(\"predefine_fn[cg={}](instance={:?})\", &unit.name[..], instance);\n+        assert!(!instance.substs.types.needs_infer() &&\n+                !instance.substs.types.has_param_types());\n+\n+        let instance = inline::maybe_inline_instance(ccx, instance);\n+\n+        let item_ty = ccx.tcx().lookup_item_type(instance.def).ty;\n+        let item_ty = ccx.tcx().erase_regions(&item_ty);\n+        let mono_ty = monomorphize::apply_param_substs(ccx.tcx(), instance.substs, &item_ty);\n+\n+        let fn_node_id = ccx.tcx().map.as_local_node_id(instance.def).unwrap();\n+        let map_node = errors::expect(\n+            ccx.sess().diagnostic(),\n+            ccx.tcx().map.find(fn_node_id),\n+            || {\n+                format!(\"while instantiating `{}`, couldn't find it in \\\n+                     the item map (may have attempted to monomorphize \\\n+                     an item defined in a different crate?)\",\n+                    instance)\n+            });\n+\n+        match map_node {\n+            hir_map::NodeItem(&hir::Item {\n+                ref attrs, node: hir::ItemFn(..), ..\n+            }) |\n+            hir_map::NodeTraitItem(&hir::TraitItem {\n+                ref attrs, node: hir::MethodTraitItem(..), ..\n+            }) |\n+            hir_map::NodeImplItem(&hir::ImplItem {\n+                ref attrs, node: hir::ImplItemKind::Method(..), ..\n+            }) => {\n+                let symbol = instance.symbol_name(ccx.shared());\n+                let lldecl = declare::declare_fn(ccx, &symbol, mono_ty);\n+\n+                attributes::from_fn_attrs(ccx, attrs, lldecl);\n+                llvm::SetLinkage(lldecl, linkage);\n+                base::set_link_section(ccx, lldecl, attrs);\n+\n+                ccx.instances().borrow_mut().insert(instance, lldecl);\n+            }\n+            _ => bug!(\"Invalid item for TransItem::Fn: `{:?}`\", map_node)\n+        };\n+\n+    }\n+\n+\n+    pub fn requests_inline(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> bool {\n         match *self {\n             TransItem::Fn(ref instance) => {\n                 let attributes = tcx.get_attrs(instance.def);\n@@ -128,7 +184,7 @@ impl<'tcx> TransItem<'tcx> {\n         }\n     }\n \n-    pub fn explicit_linkage<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Option<llvm::Linkage> {\n+    pub fn explicit_linkage(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Option<llvm::Linkage> {\n         let def_id = match *self {\n             TransItem::Fn(ref instance) => instance.def,\n             TransItem::Static(node_id) => tcx.map.local_def_id(node_id),\n@@ -152,7 +208,8 @@ impl<'tcx> TransItem<'tcx> {\n         }\n     }\n \n-    pub fn to_string<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> String {\n+    pub fn to_string(&self, scx: &SharedCrateContext<'a, 'tcx>) -> String {\n+        let tcx = scx.tcx();\n         let hir_map = &tcx.map;\n \n         return match *self {\n@@ -170,13 +227,12 @@ impl<'tcx> TransItem<'tcx> {\n             },\n             TransItem::Static(node_id) => {\n                 let def_id = hir_map.local_def_id(node_id);\n-                let instance = Instance::new(def_id,\n-                                             tcx.mk_substs(subst::Substs::empty()));\n+                let instance = Instance::mono(scx, def_id);\n                 to_string_internal(tcx, \"static \", instance)\n             },\n         };\n \n-        fn to_string_internal<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx,'tcx>,\n+        fn to_string_internal<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                         prefix: &str,\n                                         instance: Instance<'tcx>)\n                                         -> String {"}]}