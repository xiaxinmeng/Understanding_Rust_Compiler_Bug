{"sha": "f238513efac3193ed7d05222d03b8052690de0a3", "node_id": "C_kwDOAAsO6NoAKGYyMzg1MTNlZmFjMzE5M2VkN2QwNTIyMmQwM2I4MDUyNjkwZGUwYTM", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-07-01T20:21:46Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-07-01T20:21:48Z"}, "message": "rename some data_race types for more clarity", "tree": {"sha": "f256aebd335da72ffb6d74cfce1ac21c329032e7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f256aebd335da72ffb6d74cfce1ac21c329032e7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f238513efac3193ed7d05222d03b8052690de0a3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f238513efac3193ed7d05222d03b8052690de0a3", "html_url": "https://github.com/rust-lang/rust/commit/f238513efac3193ed7d05222d03b8052690de0a3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f238513efac3193ed7d05222d03b8052690de0a3/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "70b97a5d7b9931a731d12f427855b9090620bf69", "url": "https://api.github.com/repos/rust-lang/rust/commits/70b97a5d7b9931a731d12f427855b9090620bf69", "html_url": "https://github.com/rust-lang/rust/commit/70b97a5d7b9931a731d12f427855b9090620bf69"}], "stats": {"total": 318, "additions": 159, "deletions": 159}, "files": [{"sha": "ef0920d9698dfd187b1e55866db055a046e89df3", "filename": "src/concurrency/data_race.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/f238513efac3193ed7d05222d03b8052690de0a3/src%2Fconcurrency%2Fdata_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f238513efac3193ed7d05222d03b8052690de0a3/src%2Fconcurrency%2Fdata_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconcurrency%2Fdata_race.rs?ref=f238513efac3193ed7d05222d03b8052690de0a3", "patch": "@@ -62,35 +62,35 @@ use super::weak_memory::EvalContextExt as _;\n \n pub type AllocExtra = VClockAlloc;\n \n-/// Valid atomic read-write operations, alias of atomic::Ordering (not non-exhaustive).\n+/// Valid atomic read-write orderings, alias of atomic::Ordering (not non-exhaustive).\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n-pub enum AtomicRwOp {\n+pub enum AtomicRwOrd {\n     Relaxed,\n     Acquire,\n     Release,\n     AcqRel,\n     SeqCst,\n }\n \n-/// Valid atomic read operations, subset of atomic::Ordering.\n+/// Valid atomic read orderings, subset of atomic::Ordering.\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n-pub enum AtomicReadOp {\n+pub enum AtomicReadOrd {\n     Relaxed,\n     Acquire,\n     SeqCst,\n }\n \n-/// Valid atomic write operations, subset of atomic::Ordering.\n+/// Valid atomic write orderings, subset of atomic::Ordering.\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n-pub enum AtomicWriteOp {\n+pub enum AtomicWriteOrd {\n     Relaxed,\n     Release,\n     SeqCst,\n }\n \n-/// Valid atomic fence operations, subset of atomic::Ordering.\n+/// Valid atomic fence orderings, subset of atomic::Ordering.\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n-pub enum AtomicFenceOp {\n+pub enum AtomicFenceOrd {\n     Acquire,\n     Release,\n     AcqRel,\n@@ -486,7 +486,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n         op: &OpTy<'tcx, Tag>,\n         offset: u64,\n         layout: TyAndLayout<'tcx>,\n-        atomic: AtomicReadOp,\n+        atomic: AtomicReadOrd,\n     ) -> InterpResult<'tcx, ScalarMaybeUninit<Tag>> {\n         let this = self.eval_context_ref();\n         let value_place = this.deref_operand_and_offset(op, offset, layout)?;\n@@ -500,7 +500,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n         offset: u64,\n         value: impl Into<ScalarMaybeUninit<Tag>>,\n         layout: TyAndLayout<'tcx>,\n-        atomic: AtomicWriteOp,\n+        atomic: AtomicWriteOrd,\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n         let value_place = this.deref_operand_and_offset(op, offset, layout)?;\n@@ -511,7 +511,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n     fn read_scalar_atomic(\n         &self,\n         place: &MPlaceTy<'tcx, Tag>,\n-        atomic: AtomicReadOp,\n+        atomic: AtomicReadOrd,\n     ) -> InterpResult<'tcx, ScalarMaybeUninit<Tag>> {\n         let this = self.eval_context_ref();\n         // This will read from the last store in the modification order of this location. In case\n@@ -531,7 +531,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n         &mut self,\n         val: ScalarMaybeUninit<Tag>,\n         dest: &MPlaceTy<'tcx, Tag>,\n-        atomic: AtomicWriteOp,\n+        atomic: AtomicWriteOrd,\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n         this.validate_overlapping_atomic(dest)?;\n@@ -552,7 +552,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n         rhs: &ImmTy<'tcx, Tag>,\n         op: mir::BinOp,\n         neg: bool,\n-        atomic: AtomicRwOp,\n+        atomic: AtomicRwOrd,\n     ) -> InterpResult<'tcx, ImmTy<'tcx, Tag>> {\n         let this = self.eval_context_mut();\n \n@@ -581,7 +581,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n         &mut self,\n         place: &MPlaceTy<'tcx, Tag>,\n         new: ScalarMaybeUninit<Tag>,\n-        atomic: AtomicRwOp,\n+        atomic: AtomicRwOrd,\n     ) -> InterpResult<'tcx, ScalarMaybeUninit<Tag>> {\n         let this = self.eval_context_mut();\n \n@@ -602,7 +602,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n         place: &MPlaceTy<'tcx, Tag>,\n         rhs: ImmTy<'tcx, Tag>,\n         min: bool,\n-        atomic: AtomicRwOp,\n+        atomic: AtomicRwOrd,\n     ) -> InterpResult<'tcx, ImmTy<'tcx, Tag>> {\n         let this = self.eval_context_mut();\n \n@@ -642,8 +642,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n         place: &MPlaceTy<'tcx, Tag>,\n         expect_old: &ImmTy<'tcx, Tag>,\n         new: ScalarMaybeUninit<Tag>,\n-        success: AtomicRwOp,\n-        fail: AtomicReadOp,\n+        success: AtomicRwOrd,\n+        fail: AtomicReadOrd,\n         can_fail_spuriously: bool,\n     ) -> InterpResult<'tcx, Immediate<Tag>> {\n         use rand::Rng as _;\n@@ -696,7 +696,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n     fn validate_atomic_load(\n         &self,\n         place: &MPlaceTy<'tcx, Tag>,\n-        atomic: AtomicReadOp,\n+        atomic: AtomicReadOrd,\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_ref();\n         this.validate_overlapping_atomic(place)?;\n@@ -705,7 +705,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n             atomic,\n             \"Atomic Load\",\n             move |memory, clocks, index, atomic| {\n-                if atomic == AtomicReadOp::Relaxed {\n+                if atomic == AtomicReadOrd::Relaxed {\n                     memory.load_relaxed(&mut *clocks, index)\n                 } else {\n                     memory.load_acquire(&mut *clocks, index)\n@@ -719,7 +719,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n     fn validate_atomic_store(\n         &mut self,\n         place: &MPlaceTy<'tcx, Tag>,\n-        atomic: AtomicWriteOp,\n+        atomic: AtomicWriteOrd,\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n         this.validate_overlapping_atomic(place)?;\n@@ -728,7 +728,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n             atomic,\n             \"Atomic Store\",\n             move |memory, clocks, index, atomic| {\n-                if atomic == AtomicWriteOp::Relaxed {\n+                if atomic == AtomicWriteOrd::Relaxed {\n                     memory.store_relaxed(clocks, index)\n                 } else {\n                     memory.store_release(clocks, index)\n@@ -742,9 +742,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n     fn validate_atomic_rmw(\n         &mut self,\n         place: &MPlaceTy<'tcx, Tag>,\n-        atomic: AtomicRwOp,\n+        atomic: AtomicRwOrd,\n     ) -> InterpResult<'tcx> {\n-        use AtomicRwOp::*;\n+        use AtomicRwOrd::*;\n         let acquire = matches!(atomic, Acquire | AcqRel | SeqCst);\n         let release = matches!(atomic, Release | AcqRel | SeqCst);\n         let this = self.eval_context_mut();\n@@ -764,7 +764,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n     }\n \n     /// Update the data-race detector for an atomic fence on the current thread.\n-    fn validate_atomic_fence(&mut self, atomic: AtomicFenceOp) -> InterpResult<'tcx> {\n+    fn validate_atomic_fence(&mut self, atomic: AtomicFenceOrd) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n         if let Some(data_race) = &mut this.machine.data_race {\n             data_race.maybe_perform_sync_operation(|index, mut clocks| {\n@@ -773,22 +773,22 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n                 // Apply data-race detection for the current fences\n                 // this treats AcqRel and SeqCst as the same as an acquire\n                 // and release fence applied in the same timestamp.\n-                if atomic != AtomicFenceOp::Release {\n+                if atomic != AtomicFenceOrd::Release {\n                     // Either Acquire | AcqRel | SeqCst\n                     clocks.apply_acquire_fence();\n                 }\n-                if atomic != AtomicFenceOp::Acquire {\n+                if atomic != AtomicFenceOrd::Acquire {\n                     // Either Release | AcqRel | SeqCst\n                     clocks.apply_release_fence();\n                 }\n-                if atomic == AtomicFenceOp::SeqCst {\n+                if atomic == AtomicFenceOrd::SeqCst {\n                     data_race.last_sc_fence.borrow_mut().set_at_index(&clocks.clock, index);\n                     clocks.fence_seqcst.join(&data_race.last_sc_fence.borrow());\n                     clocks.write_seqcst.join(&data_race.last_sc_write.borrow());\n                 }\n \n                 // Increment timestamp in case of release semantics.\n-                Ok(atomic != AtomicFenceOp::Acquire)\n+                Ok(atomic != AtomicFenceOrd::Acquire)\n             })\n         } else {\n             Ok(())"}, {"sha": "28a54c2e3b6c17f832d3936461c19e559d029650", "filename": "src/concurrency/weak_memory.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f238513efac3193ed7d05222d03b8052690de0a3/src%2Fconcurrency%2Fweak_memory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f238513efac3193ed7d05222d03b8052690de0a3/src%2Fconcurrency%2Fweak_memory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconcurrency%2Fweak_memory.rs?ref=f238513efac3193ed7d05222d03b8052690de0a3", "patch": "@@ -82,7 +82,7 @@ use rustc_const_eval::interpret::{\n };\n use rustc_data_structures::fx::FxHashMap;\n \n-use crate::{AtomicReadOp, AtomicRwOp, AtomicWriteOp, Tag, VClock, VTimestamp, VectorIdx};\n+use crate::{AtomicReadOrd, AtomicRwOrd, AtomicWriteOrd, Tag, VClock, VTimestamp, VectorIdx};\n \n use super::{\n     data_race::{GlobalState, ThreadClockSet},\n@@ -443,7 +443,7 @@ pub(super) trait EvalContextExt<'mir, 'tcx: 'mir>:\n         &mut self,\n         new_val: ScalarMaybeUninit<Tag>,\n         place: &MPlaceTy<'tcx, Tag>,\n-        atomic: AtomicRwOp,\n+        atomic: AtomicRwOrd,\n         init: ScalarMaybeUninit<Tag>,\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n@@ -453,30 +453,30 @@ pub(super) trait EvalContextExt<'mir, 'tcx: 'mir>:\n             crate::Evaluator { data_race: Some(global), .. },\n         ) = this.get_alloc_extra_mut(alloc_id)?\n         {\n-            if atomic == AtomicRwOp::SeqCst {\n+            if atomic == AtomicRwOrd::SeqCst {\n                 global.sc_read();\n                 global.sc_write();\n             }\n             let range = alloc_range(base_offset, place.layout.size);\n             let buffer = alloc_buffers.get_or_create_store_buffer_mut(range, init)?;\n             buffer.read_from_last_store(global);\n-            buffer.buffered_write(new_val, global, atomic == AtomicRwOp::SeqCst)?;\n+            buffer.buffered_write(new_val, global, atomic == AtomicRwOrd::SeqCst)?;\n         }\n         Ok(())\n     }\n \n     fn buffered_atomic_read(\n         &self,\n         place: &MPlaceTy<'tcx, Tag>,\n-        atomic: AtomicReadOp,\n+        atomic: AtomicReadOrd,\n         latest_in_mo: ScalarMaybeUninit<Tag>,\n         validate: impl FnOnce() -> InterpResult<'tcx>,\n     ) -> InterpResult<'tcx, ScalarMaybeUninit<Tag>> {\n         let this = self.eval_context_ref();\n         if let Some(global) = &this.machine.data_race {\n             let (alloc_id, base_offset, ..) = this.ptr_get_alloc_id(place.ptr)?;\n             if let Some(alloc_buffers) = this.get_alloc_extra(alloc_id)?.weak_memory.as_ref() {\n-                if atomic == AtomicReadOp::SeqCst {\n+                if atomic == AtomicReadOrd::SeqCst {\n                     global.sc_read();\n                 }\n                 let mut rng = this.machine.rng.borrow_mut();\n@@ -486,7 +486,7 @@ pub(super) trait EvalContextExt<'mir, 'tcx: 'mir>:\n                 )?;\n                 let loaded = buffer.buffered_read(\n                     global,\n-                    atomic == AtomicReadOp::SeqCst,\n+                    atomic == AtomicReadOrd::SeqCst,\n                     &mut *rng,\n                     validate,\n                 )?;\n@@ -504,7 +504,7 @@ pub(super) trait EvalContextExt<'mir, 'tcx: 'mir>:\n         &mut self,\n         val: ScalarMaybeUninit<Tag>,\n         dest: &MPlaceTy<'tcx, Tag>,\n-        atomic: AtomicWriteOp,\n+        atomic: AtomicWriteOrd,\n         init: ScalarMaybeUninit<Tag>,\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n@@ -514,7 +514,7 @@ pub(super) trait EvalContextExt<'mir, 'tcx: 'mir>:\n             crate::Evaluator { data_race: Some(global), .. },\n         ) = this.get_alloc_extra_mut(alloc_id)?\n         {\n-            if atomic == AtomicWriteOp::SeqCst {\n+            if atomic == AtomicWriteOrd::SeqCst {\n                 global.sc_write();\n             }\n \n@@ -535,7 +535,7 @@ pub(super) trait EvalContextExt<'mir, 'tcx: 'mir>:\n                 buffer.buffer.pop_front();\n             }\n \n-            buffer.buffered_write(val, global, atomic == AtomicWriteOp::SeqCst)?;\n+            buffer.buffered_write(val, global, atomic == AtomicWriteOrd::SeqCst)?;\n         }\n \n         // Caller should've written to dest with the vanilla scalar write, we do nothing here\n@@ -548,13 +548,13 @@ pub(super) trait EvalContextExt<'mir, 'tcx: 'mir>:\n     fn perform_read_on_buffered_latest(\n         &self,\n         place: &MPlaceTy<'tcx, Tag>,\n-        atomic: AtomicReadOp,\n+        atomic: AtomicReadOrd,\n         init: ScalarMaybeUninit<Tag>,\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_ref();\n \n         if let Some(global) = &this.machine.data_race {\n-            if atomic == AtomicReadOp::SeqCst {\n+            if atomic == AtomicReadOrd::SeqCst {\n                 global.sc_read();\n             }\n             let size = place.layout.size;"}, {"sha": "b3d408a6dc07244945073a84014a923dd2d350e4", "filename": "src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f238513efac3193ed7d05222d03b8052690de0a3/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f238513efac3193ed7d05222d03b8052690de0a3/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=f238513efac3193ed7d05222d03b8052690de0a3", "patch": "@@ -70,7 +70,7 @@ pub use crate::shims::tls::{EvalContextExt as _, TlsData};\n pub use crate::shims::EvalContextExt as _;\n \n pub use crate::concurrency::data_race::{\n-    AtomicFenceOp, AtomicReadOp, AtomicRwOp, AtomicWriteOp,\n+    AtomicFenceOrd, AtomicReadOrd, AtomicRwOrd, AtomicWriteOrd,\n     EvalContextExt as DataRaceEvalContextExt,\n };\n pub use crate::diagnostics::{"}, {"sha": "9705f56cd107784c1aafcf7c32dbf175904e0552", "filename": "src/shims/intrinsics.rs", "status": "modified", "additions": 99, "deletions": 99, "changes": 198, "blob_url": "https://github.com/rust-lang/rust/blob/f238513efac3193ed7d05222d03b8052690de0a3/src%2Fshims%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f238513efac3193ed7d05222d03b8052690de0a3/src%2Fshims%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fintrinsics.rs?ref=f238513efac3193ed7d05222d03b8052690de0a3", "patch": "@@ -864,216 +864,216 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             }\n \n             // Atomic operations\n-            \"atomic_load_seqcst\" => this.atomic_load(args, dest, AtomicReadOp::SeqCst)?,\n-            \"atomic_load_relaxed\" => this.atomic_load(args, dest, AtomicReadOp::Relaxed)?,\n-            \"atomic_load_acquire\" => this.atomic_load(args, dest, AtomicReadOp::Acquire)?,\n+            \"atomic_load_seqcst\" => this.atomic_load(args, dest, AtomicReadOrd::SeqCst)?,\n+            \"atomic_load_relaxed\" => this.atomic_load(args, dest, AtomicReadOrd::Relaxed)?,\n+            \"atomic_load_acquire\" => this.atomic_load(args, dest, AtomicReadOrd::Acquire)?,\n \n-            \"atomic_store_seqcst\" => this.atomic_store(args, AtomicWriteOp::SeqCst)?,\n-            \"atomic_store_relaxed\" => this.atomic_store(args, AtomicWriteOp::Relaxed)?,\n-            \"atomic_store_release\" => this.atomic_store(args, AtomicWriteOp::Release)?,\n+            \"atomic_store_seqcst\" => this.atomic_store(args, AtomicWriteOrd::SeqCst)?,\n+            \"atomic_store_relaxed\" => this.atomic_store(args, AtomicWriteOrd::Relaxed)?,\n+            \"atomic_store_release\" => this.atomic_store(args, AtomicWriteOrd::Release)?,\n \n-            \"atomic_fence_acquire\" => this.atomic_fence(args, AtomicFenceOp::Acquire)?,\n-            \"atomic_fence_release\" => this.atomic_fence(args, AtomicFenceOp::Release)?,\n-            \"atomic_fence_acqrel\" => this.atomic_fence(args, AtomicFenceOp::AcqRel)?,\n-            \"atomic_fence_seqcst\" => this.atomic_fence(args, AtomicFenceOp::SeqCst)?,\n+            \"atomic_fence_acquire\" => this.atomic_fence(args, AtomicFenceOrd::Acquire)?,\n+            \"atomic_fence_release\" => this.atomic_fence(args, AtomicFenceOrd::Release)?,\n+            \"atomic_fence_acqrel\" => this.atomic_fence(args, AtomicFenceOrd::AcqRel)?,\n+            \"atomic_fence_seqcst\" => this.atomic_fence(args, AtomicFenceOrd::SeqCst)?,\n \n             \"atomic_singlethreadfence_acquire\" =>\n-                this.compiler_fence(args, AtomicFenceOp::Acquire)?,\n+                this.compiler_fence(args, AtomicFenceOrd::Acquire)?,\n             \"atomic_singlethreadfence_release\" =>\n-                this.compiler_fence(args, AtomicFenceOp::Release)?,\n+                this.compiler_fence(args, AtomicFenceOrd::Release)?,\n             \"atomic_singlethreadfence_acqrel\" =>\n-                this.compiler_fence(args, AtomicFenceOp::AcqRel)?,\n+                this.compiler_fence(args, AtomicFenceOrd::AcqRel)?,\n             \"atomic_singlethreadfence_seqcst\" =>\n-                this.compiler_fence(args, AtomicFenceOp::SeqCst)?,\n+                this.compiler_fence(args, AtomicFenceOrd::SeqCst)?,\n \n-            \"atomic_xchg_seqcst\" => this.atomic_exchange(args, dest, AtomicRwOp::SeqCst)?,\n-            \"atomic_xchg_acquire\" => this.atomic_exchange(args, dest, AtomicRwOp::Acquire)?,\n-            \"atomic_xchg_release\" => this.atomic_exchange(args, dest, AtomicRwOp::Release)?,\n-            \"atomic_xchg_acqrel\" => this.atomic_exchange(args, dest, AtomicRwOp::AcqRel)?,\n-            \"atomic_xchg_relaxed\" => this.atomic_exchange(args, dest, AtomicRwOp::Relaxed)?,\n+            \"atomic_xchg_seqcst\" => this.atomic_exchange(args, dest, AtomicRwOrd::SeqCst)?,\n+            \"atomic_xchg_acquire\" => this.atomic_exchange(args, dest, AtomicRwOrd::Acquire)?,\n+            \"atomic_xchg_release\" => this.atomic_exchange(args, dest, AtomicRwOrd::Release)?,\n+            \"atomic_xchg_acqrel\" => this.atomic_exchange(args, dest, AtomicRwOrd::AcqRel)?,\n+            \"atomic_xchg_relaxed\" => this.atomic_exchange(args, dest, AtomicRwOrd::Relaxed)?,\n \n             #[rustfmt::skip]\n             \"atomic_cxchg_seqcst_seqcst\" =>\n-                this.atomic_compare_exchange(args, dest, AtomicRwOp::SeqCst, AtomicReadOp::SeqCst)?,\n+                this.atomic_compare_exchange(args, dest, AtomicRwOrd::SeqCst, AtomicReadOrd::SeqCst)?,\n             #[rustfmt::skip]\n             \"atomic_cxchg_acquire_acquire\" =>\n-                this.atomic_compare_exchange(args, dest, AtomicRwOp::Acquire, AtomicReadOp::Acquire)?,\n+                this.atomic_compare_exchange(args, dest, AtomicRwOrd::Acquire, AtomicReadOrd::Acquire)?,\n             #[rustfmt::skip]\n             \"atomic_cxchg_release_relaxed\" =>\n-                this.atomic_compare_exchange(args, dest, AtomicRwOp::Release, AtomicReadOp::Relaxed)?,\n+                this.atomic_compare_exchange(args, dest, AtomicRwOrd::Release, AtomicReadOrd::Relaxed)?,\n             #[rustfmt::skip]\n             \"atomic_cxchg_acqrel_acquire\" =>\n-                this.atomic_compare_exchange(args, dest, AtomicRwOp::AcqRel, AtomicReadOp::Acquire)?,\n+                this.atomic_compare_exchange(args, dest, AtomicRwOrd::AcqRel, AtomicReadOrd::Acquire)?,\n             #[rustfmt::skip]\n             \"atomic_cxchg_relaxed_relaxed\" =>\n-                this.atomic_compare_exchange(args, dest, AtomicRwOp::Relaxed, AtomicReadOp::Relaxed)?,\n+                this.atomic_compare_exchange(args, dest, AtomicRwOrd::Relaxed, AtomicReadOrd::Relaxed)?,\n             #[rustfmt::skip]\n             \"atomic_cxchg_acquire_relaxed\" =>\n-                this.atomic_compare_exchange(args, dest, AtomicRwOp::Acquire, AtomicReadOp::Relaxed)?,\n+                this.atomic_compare_exchange(args, dest, AtomicRwOrd::Acquire, AtomicReadOrd::Relaxed)?,\n             #[rustfmt::skip]\n             \"atomic_cxchg_acqrel_relaxed\" =>\n-                this.atomic_compare_exchange(args, dest, AtomicRwOp::AcqRel, AtomicReadOp::Relaxed)?,\n+                this.atomic_compare_exchange(args, dest, AtomicRwOrd::AcqRel, AtomicReadOrd::Relaxed)?,\n             #[rustfmt::skip]\n             \"atomic_cxchg_seqcst_relaxed\" =>\n-                this.atomic_compare_exchange(args, dest, AtomicRwOp::SeqCst, AtomicReadOp::Relaxed)?,\n+                this.atomic_compare_exchange(args, dest, AtomicRwOrd::SeqCst, AtomicReadOrd::Relaxed)?,\n             #[rustfmt::skip]\n             \"atomic_cxchg_seqcst_acquire\" =>\n-                this.atomic_compare_exchange(args, dest, AtomicRwOp::SeqCst, AtomicReadOp::Acquire)?,\n+                this.atomic_compare_exchange(args, dest, AtomicRwOrd::SeqCst, AtomicReadOrd::Acquire)?,\n \n             #[rustfmt::skip]\n             \"atomic_cxchgweak_seqcst_seqcst\" =>\n-                this.atomic_compare_exchange_weak(args, dest, AtomicRwOp::SeqCst, AtomicReadOp::SeqCst)?,\n+                this.atomic_compare_exchange_weak(args, dest, AtomicRwOrd::SeqCst, AtomicReadOrd::SeqCst)?,\n             #[rustfmt::skip]\n             \"atomic_cxchgweak_acquire_acquire\" =>\n-                this.atomic_compare_exchange_weak(args, dest, AtomicRwOp::Acquire, AtomicReadOp::Acquire)?,\n+                this.atomic_compare_exchange_weak(args, dest, AtomicRwOrd::Acquire, AtomicReadOrd::Acquire)?,\n             #[rustfmt::skip]\n             \"atomic_cxchgweak_release_relaxed\" =>\n-                this.atomic_compare_exchange_weak(args, dest, AtomicRwOp::Release, AtomicReadOp::Relaxed)?,\n+                this.atomic_compare_exchange_weak(args, dest, AtomicRwOrd::Release, AtomicReadOrd::Relaxed)?,\n             #[rustfmt::skip]\n             \"atomic_cxchgweak_acqrel_acquire\" =>\n-                this.atomic_compare_exchange_weak(args, dest, AtomicRwOp::AcqRel, AtomicReadOp::Acquire)?,\n+                this.atomic_compare_exchange_weak(args, dest, AtomicRwOrd::AcqRel, AtomicReadOrd::Acquire)?,\n             #[rustfmt::skip]\n             \"atomic_cxchgweak_relaxed_relaxed\" =>\n-                this.atomic_compare_exchange_weak(args, dest, AtomicRwOp::Relaxed, AtomicReadOp::Relaxed)?,\n+                this.atomic_compare_exchange_weak(args, dest, AtomicRwOrd::Relaxed, AtomicReadOrd::Relaxed)?,\n             #[rustfmt::skip]\n             \"atomic_cxchgweak_acquire_relaxed\" =>\n-                this.atomic_compare_exchange_weak(args, dest, AtomicRwOp::Acquire, AtomicReadOp::Relaxed)?,\n+                this.atomic_compare_exchange_weak(args, dest, AtomicRwOrd::Acquire, AtomicReadOrd::Relaxed)?,\n             #[rustfmt::skip]\n             \"atomic_cxchgweak_acqrel_relaxed\" =>\n-                this.atomic_compare_exchange_weak(args, dest, AtomicRwOp::AcqRel, AtomicReadOp::Relaxed)?,\n+                this.atomic_compare_exchange_weak(args, dest, AtomicRwOrd::AcqRel, AtomicReadOrd::Relaxed)?,\n             #[rustfmt::skip]\n             \"atomic_cxchgweak_seqcst_relaxed\" =>\n-                this.atomic_compare_exchange_weak(args, dest, AtomicRwOp::SeqCst, AtomicReadOp::Relaxed)?,\n+                this.atomic_compare_exchange_weak(args, dest, AtomicRwOrd::SeqCst, AtomicReadOrd::Relaxed)?,\n             #[rustfmt::skip]\n             \"atomic_cxchgweak_seqcst_acquire\" =>\n-                this.atomic_compare_exchange_weak(args, dest, AtomicRwOp::SeqCst, AtomicReadOp::Acquire)?,\n+                this.atomic_compare_exchange_weak(args, dest, AtomicRwOrd::SeqCst, AtomicReadOrd::Acquire)?,\n \n             #[rustfmt::skip]\n             \"atomic_or_seqcst\" =>\n-                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::BitOr, false), AtomicRwOp::SeqCst)?,\n+                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::BitOr, false), AtomicRwOrd::SeqCst)?,\n             #[rustfmt::skip]\n             \"atomic_or_acquire\" =>\n-                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::BitOr, false), AtomicRwOp::Acquire)?,\n+                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::BitOr, false), AtomicRwOrd::Acquire)?,\n             #[rustfmt::skip]\n             \"atomic_or_release\" =>\n-                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::BitOr, false), AtomicRwOp::Release)?,\n+                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::BitOr, false), AtomicRwOrd::Release)?,\n             #[rustfmt::skip]\n             \"atomic_or_acqrel\" =>\n-                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::BitOr, false), AtomicRwOp::AcqRel)?,\n+                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::BitOr, false), AtomicRwOrd::AcqRel)?,\n             #[rustfmt::skip]\n             \"atomic_or_relaxed\" =>\n-                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::BitOr, false), AtomicRwOp::Relaxed)?,\n+                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::BitOr, false), AtomicRwOrd::Relaxed)?,\n             #[rustfmt::skip]\n             \"atomic_xor_seqcst\" =>\n-                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::BitXor, false), AtomicRwOp::SeqCst)?,\n+                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::BitXor, false), AtomicRwOrd::SeqCst)?,\n             #[rustfmt::skip]\n             \"atomic_xor_acquire\" =>\n-                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::BitXor, false), AtomicRwOp::Acquire)?,\n+                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::BitXor, false), AtomicRwOrd::Acquire)?,\n             #[rustfmt::skip]\n             \"atomic_xor_release\" =>\n-                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::BitXor, false), AtomicRwOp::Release)?,\n+                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::BitXor, false), AtomicRwOrd::Release)?,\n             #[rustfmt::skip]\n             \"atomic_xor_acqrel\" =>\n-                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::BitXor, false), AtomicRwOp::AcqRel)?,\n+                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::BitXor, false), AtomicRwOrd::AcqRel)?,\n             #[rustfmt::skip]\n             \"atomic_xor_relaxed\" =>\n-                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::BitXor, false), AtomicRwOp::Relaxed)?,\n+                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::BitXor, false), AtomicRwOrd::Relaxed)?,\n             #[rustfmt::skip]\n             \"atomic_and_seqcst\" =>\n-                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::BitAnd, false), AtomicRwOp::SeqCst)?,\n+                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::BitAnd, false), AtomicRwOrd::SeqCst)?,\n             #[rustfmt::skip]\n             \"atomic_and_acquire\" =>\n-                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::BitAnd, false), AtomicRwOp::Acquire)?,\n+                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::BitAnd, false), AtomicRwOrd::Acquire)?,\n             #[rustfmt::skip]\n             \"atomic_and_release\" =>\n-                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::BitAnd, false), AtomicRwOp::Release)?,\n+                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::BitAnd, false), AtomicRwOrd::Release)?,\n             #[rustfmt::skip]\n             \"atomic_and_acqrel\" =>\n-                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::BitAnd, false), AtomicRwOp::AcqRel)?,\n+                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::BitAnd, false), AtomicRwOrd::AcqRel)?,\n             #[rustfmt::skip]\n             \"atomic_and_relaxed\" =>\n-                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::BitAnd, false), AtomicRwOp::Relaxed)?,\n+                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::BitAnd, false), AtomicRwOrd::Relaxed)?,\n             #[rustfmt::skip]\n             \"atomic_nand_seqcst\" =>\n-                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::BitAnd, true), AtomicRwOp::SeqCst)?,\n+                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::BitAnd, true), AtomicRwOrd::SeqCst)?,\n             #[rustfmt::skip]\n             \"atomic_nand_acquire\" =>\n-                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::BitAnd, true), AtomicRwOp::Acquire)?,\n+                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::BitAnd, true), AtomicRwOrd::Acquire)?,\n             #[rustfmt::skip]\n             \"atomic_nand_release\" =>\n-                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::BitAnd, true), AtomicRwOp::Release)?,\n+                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::BitAnd, true), AtomicRwOrd::Release)?,\n             #[rustfmt::skip]\n             \"atomic_nand_acqrel\" =>\n-                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::BitAnd, true), AtomicRwOp::AcqRel)?,\n+                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::BitAnd, true), AtomicRwOrd::AcqRel)?,\n             #[rustfmt::skip]\n             \"atomic_nand_relaxed\" =>\n-                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::BitAnd, true), AtomicRwOp::Relaxed)?,\n+                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::BitAnd, true), AtomicRwOrd::Relaxed)?,\n             #[rustfmt::skip]\n             \"atomic_xadd_seqcst\" =>\n-                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::Add, false), AtomicRwOp::SeqCst)?,\n+                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::Add, false), AtomicRwOrd::SeqCst)?,\n             #[rustfmt::skip]\n             \"atomic_xadd_acquire\" =>\n-                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::Add, false), AtomicRwOp::Acquire)?,\n+                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::Add, false), AtomicRwOrd::Acquire)?,\n             #[rustfmt::skip]\n             \"atomic_xadd_release\" =>\n-                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::Add, false), AtomicRwOp::Release)?,\n+                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::Add, false), AtomicRwOrd::Release)?,\n             #[rustfmt::skip]\n             \"atomic_xadd_acqrel\" =>\n-                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::Add, false), AtomicRwOp::AcqRel)?,\n+                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::Add, false), AtomicRwOrd::AcqRel)?,\n             #[rustfmt::skip]\n             \"atomic_xadd_relaxed\" =>\n-                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::Add, false), AtomicRwOp::Relaxed)?,\n+                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::Add, false), AtomicRwOrd::Relaxed)?,\n             #[rustfmt::skip]\n             \"atomic_xsub_seqcst\" =>\n-                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::Sub, false), AtomicRwOp::SeqCst)?,\n+                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::Sub, false), AtomicRwOrd::SeqCst)?,\n             #[rustfmt::skip]\n             \"atomic_xsub_acquire\" =>\n-                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::Sub, false), AtomicRwOp::Acquire)?,\n+                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::Sub, false), AtomicRwOrd::Acquire)?,\n             #[rustfmt::skip]\n             \"atomic_xsub_release\" =>\n-                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::Sub, false), AtomicRwOp::Release)?,\n+                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::Sub, false), AtomicRwOrd::Release)?,\n             #[rustfmt::skip]\n             \"atomic_xsub_acqrel\" =>\n-                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::Sub, false), AtomicRwOp::AcqRel)?,\n+                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::Sub, false), AtomicRwOrd::AcqRel)?,\n             #[rustfmt::skip]\n             \"atomic_xsub_relaxed\" =>\n-                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::Sub, false), AtomicRwOp::Relaxed)?,\n-            \"atomic_min_seqcst\" => this.atomic_op(args, dest, AtomicOp::Min, AtomicRwOp::SeqCst)?,\n+                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::Sub, false), AtomicRwOrd::Relaxed)?,\n+            \"atomic_min_seqcst\" => this.atomic_op(args, dest, AtomicOp::Min, AtomicRwOrd::SeqCst)?,\n             \"atomic_min_acquire\" =>\n-                this.atomic_op(args, dest, AtomicOp::Min, AtomicRwOp::Acquire)?,\n+                this.atomic_op(args, dest, AtomicOp::Min, AtomicRwOrd::Acquire)?,\n             \"atomic_min_release\" =>\n-                this.atomic_op(args, dest, AtomicOp::Min, AtomicRwOp::Release)?,\n-            \"atomic_min_acqrel\" => this.atomic_op(args, dest, AtomicOp::Min, AtomicRwOp::AcqRel)?,\n+                this.atomic_op(args, dest, AtomicOp::Min, AtomicRwOrd::Release)?,\n+            \"atomic_min_acqrel\" => this.atomic_op(args, dest, AtomicOp::Min, AtomicRwOrd::AcqRel)?,\n             \"atomic_min_relaxed\" =>\n-                this.atomic_op(args, dest, AtomicOp::Min, AtomicRwOp::Relaxed)?,\n-            \"atomic_max_seqcst\" => this.atomic_op(args, dest, AtomicOp::Max, AtomicRwOp::SeqCst)?,\n+                this.atomic_op(args, dest, AtomicOp::Min, AtomicRwOrd::Relaxed)?,\n+            \"atomic_max_seqcst\" => this.atomic_op(args, dest, AtomicOp::Max, AtomicRwOrd::SeqCst)?,\n             \"atomic_max_acquire\" =>\n-                this.atomic_op(args, dest, AtomicOp::Max, AtomicRwOp::Acquire)?,\n+                this.atomic_op(args, dest, AtomicOp::Max, AtomicRwOrd::Acquire)?,\n             \"atomic_max_release\" =>\n-                this.atomic_op(args, dest, AtomicOp::Max, AtomicRwOp::Release)?,\n-            \"atomic_max_acqrel\" => this.atomic_op(args, dest, AtomicOp::Max, AtomicRwOp::AcqRel)?,\n+                this.atomic_op(args, dest, AtomicOp::Max, AtomicRwOrd::Release)?,\n+            \"atomic_max_acqrel\" => this.atomic_op(args, dest, AtomicOp::Max, AtomicRwOrd::AcqRel)?,\n             \"atomic_max_relaxed\" =>\n-                this.atomic_op(args, dest, AtomicOp::Max, AtomicRwOp::Relaxed)?,\n+                this.atomic_op(args, dest, AtomicOp::Max, AtomicRwOrd::Relaxed)?,\n             \"atomic_umin_seqcst\" =>\n-                this.atomic_op(args, dest, AtomicOp::Min, AtomicRwOp::SeqCst)?,\n+                this.atomic_op(args, dest, AtomicOp::Min, AtomicRwOrd::SeqCst)?,\n             \"atomic_umin_acquire\" =>\n-                this.atomic_op(args, dest, AtomicOp::Min, AtomicRwOp::Acquire)?,\n+                this.atomic_op(args, dest, AtomicOp::Min, AtomicRwOrd::Acquire)?,\n             \"atomic_umin_release\" =>\n-                this.atomic_op(args, dest, AtomicOp::Min, AtomicRwOp::Release)?,\n+                this.atomic_op(args, dest, AtomicOp::Min, AtomicRwOrd::Release)?,\n             \"atomic_umin_acqrel\" =>\n-                this.atomic_op(args, dest, AtomicOp::Min, AtomicRwOp::AcqRel)?,\n+                this.atomic_op(args, dest, AtomicOp::Min, AtomicRwOrd::AcqRel)?,\n             \"atomic_umin_relaxed\" =>\n-                this.atomic_op(args, dest, AtomicOp::Min, AtomicRwOp::Relaxed)?,\n+                this.atomic_op(args, dest, AtomicOp::Min, AtomicRwOrd::Relaxed)?,\n             \"atomic_umax_seqcst\" =>\n-                this.atomic_op(args, dest, AtomicOp::Max, AtomicRwOp::SeqCst)?,\n+                this.atomic_op(args, dest, AtomicOp::Max, AtomicRwOrd::SeqCst)?,\n             \"atomic_umax_acquire\" =>\n-                this.atomic_op(args, dest, AtomicOp::Max, AtomicRwOp::Acquire)?,\n+                this.atomic_op(args, dest, AtomicOp::Max, AtomicRwOrd::Acquire)?,\n             \"atomic_umax_release\" =>\n-                this.atomic_op(args, dest, AtomicOp::Max, AtomicRwOp::Release)?,\n+                this.atomic_op(args, dest, AtomicOp::Max, AtomicRwOrd::Release)?,\n             \"atomic_umax_acqrel\" =>\n-                this.atomic_op(args, dest, AtomicOp::Max, AtomicRwOp::AcqRel)?,\n+                this.atomic_op(args, dest, AtomicOp::Max, AtomicRwOrd::AcqRel)?,\n             \"atomic_umax_relaxed\" =>\n-                this.atomic_op(args, dest, AtomicOp::Max, AtomicRwOp::Relaxed)?,\n+                this.atomic_op(args, dest, AtomicOp::Max, AtomicRwOrd::Relaxed)?,\n \n             // Other\n             \"exact_div\" => {\n@@ -1101,7 +1101,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         &mut self,\n         args: &[OpTy<'tcx, Tag>],\n         dest: &PlaceTy<'tcx, Tag>,\n-        atomic: AtomicReadOp,\n+        atomic: AtomicReadOrd,\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n \n@@ -1129,7 +1129,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     fn atomic_store(\n         &mut self,\n         args: &[OpTy<'tcx, Tag>],\n-        atomic: AtomicWriteOp,\n+        atomic: AtomicWriteOrd,\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n \n@@ -1156,7 +1156,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     fn compiler_fence(\n         &mut self,\n         args: &[OpTy<'tcx, Tag>],\n-        atomic: AtomicFenceOp,\n+        atomic: AtomicFenceOrd,\n     ) -> InterpResult<'tcx> {\n         let [] = check_arg_count(args)?;\n         let _ = atomic;\n@@ -1167,7 +1167,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     fn atomic_fence(\n         &mut self,\n         args: &[OpTy<'tcx, Tag>],\n-        atomic: AtomicFenceOp,\n+        atomic: AtomicFenceOrd,\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n         let [] = check_arg_count(args)?;\n@@ -1180,7 +1180,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         args: &[OpTy<'tcx, Tag>],\n         dest: &PlaceTy<'tcx, Tag>,\n         atomic_op: AtomicOp,\n-        atomic: AtomicRwOp,\n+        atomic: AtomicRwOrd,\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n \n@@ -1226,7 +1226,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         &mut self,\n         args: &[OpTy<'tcx, Tag>],\n         dest: &PlaceTy<'tcx, Tag>,\n-        atomic: AtomicRwOp,\n+        atomic: AtomicRwOrd,\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n \n@@ -1254,8 +1254,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         &mut self,\n         args: &[OpTy<'tcx, Tag>],\n         dest: &PlaceTy<'tcx, Tag>,\n-        success: AtomicRwOp,\n-        fail: AtomicReadOp,\n+        success: AtomicRwOrd,\n+        fail: AtomicReadOrd,\n         can_fail_spuriously: bool,\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n@@ -1294,8 +1294,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         &mut self,\n         args: &[OpTy<'tcx, Tag>],\n         dest: &PlaceTy<'tcx, Tag>,\n-        success: AtomicRwOp,\n-        fail: AtomicReadOp,\n+        success: AtomicRwOrd,\n+        fail: AtomicReadOrd,\n     ) -> InterpResult<'tcx> {\n         self.atomic_compare_exchange_impl(args, dest, success, fail, false)\n     }\n@@ -1304,8 +1304,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         &mut self,\n         args: &[OpTy<'tcx, Tag>],\n         dest: &PlaceTy<'tcx, Tag>,\n-        success: AtomicRwOp,\n-        fail: AtomicReadOp,\n+        success: AtomicRwOrd,\n+        fail: AtomicReadOrd,\n     ) -> InterpResult<'tcx> {\n         self.atomic_compare_exchange_impl(args, dest, success, fail, true)\n     }"}, {"sha": "a0e35c730c3d6ead7e70da6b492be7efe422fe89", "filename": "src/shims/unix/linux/sync.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f238513efac3193ed7d05222d03b8052690de0a3/src%2Fshims%2Funix%2Flinux%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f238513efac3193ed7d05222d03b8052690de0a3/src%2Fshims%2Funix%2Flinux%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Funix%2Flinux%2Fsync.rs?ref=f238513efac3193ed7d05222d03b8052690de0a3", "patch": "@@ -169,15 +169,15 @@ pub fn futex<'tcx>(\n             //\n             // Thankfully, preemptions cannot happen inside a Miri shim, so we do not need to\n             // do anything special to guarantee fence-load-comparison atomicity.\n-            this.atomic_fence(&[], AtomicFenceOp::SeqCst)?;\n+            this.atomic_fence(&[], AtomicFenceOrd::SeqCst)?;\n             // Read an `i32` through the pointer, regardless of any wrapper types.\n             // It's not uncommon for `addr` to be passed as another type than `*mut i32`, such as `*const AtomicI32`.\n             let futex_val = this\n                 .read_scalar_at_offset_atomic(\n                     &addr.into(),\n                     0,\n                     this.machine.layouts.i32,\n-                    AtomicReadOp::Relaxed,\n+                    AtomicReadOrd::Relaxed,\n                 )?\n                 .to_i32()?;\n             if val == futex_val {\n@@ -240,7 +240,7 @@ pub fn futex<'tcx>(\n             // Together with the SeqCst fence in futex_wait, this makes sure that futex_wait\n             // will see the latest value on addr which could be changed by our caller\n             // before doing the syscall.\n-            this.atomic_fence(&[], AtomicFenceOp::SeqCst)?;\n+            this.atomic_fence(&[], AtomicFenceOrd::SeqCst)?;\n             let mut n = 0;\n             for _ in 0..val {\n                 if let Some(thread) = this.futex_wake(addr_usize, bitset) {"}, {"sha": "ae63907c2c86577f5cc08fe72c5fadc0f584a808", "filename": "src/shims/unix/sync.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/f238513efac3193ed7d05222d03b8052690de0a3/src%2Fshims%2Funix%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f238513efac3193ed7d05222d03b8052690de0a3/src%2Fshims%2Funix%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Funix%2Fsync.rs?ref=f238513efac3193ed7d05222d03b8052690de0a3", "patch": "@@ -68,7 +68,7 @@ fn mutex_get_kind<'mir, 'tcx: 'mir>(\n         mutex_op,\n         offset,\n         ecx.machine.layouts.i32,\n-        AtomicReadOp::Relaxed,\n+        AtomicReadOrd::Relaxed,\n     )\n }\n \n@@ -83,15 +83,15 @@ fn mutex_set_kind<'mir, 'tcx: 'mir>(\n         offset,\n         kind,\n         layout_of_maybe_uninit(ecx.tcx, ecx.tcx.types.i32),\n-        AtomicWriteOp::Relaxed,\n+        AtomicWriteOrd::Relaxed,\n     )\n }\n \n fn mutex_get_id<'mir, 'tcx: 'mir>(\n     ecx: &MiriEvalContext<'mir, 'tcx>,\n     mutex_op: &OpTy<'tcx, Tag>,\n ) -> InterpResult<'tcx, ScalarMaybeUninit<Tag>> {\n-    ecx.read_scalar_at_offset_atomic(mutex_op, 4, ecx.machine.layouts.u32, AtomicReadOp::Relaxed)\n+    ecx.read_scalar_at_offset_atomic(mutex_op, 4, ecx.machine.layouts.u32, AtomicReadOrd::Relaxed)\n }\n \n fn mutex_set_id<'mir, 'tcx: 'mir>(\n@@ -104,7 +104,7 @@ fn mutex_set_id<'mir, 'tcx: 'mir>(\n         4,\n         id,\n         layout_of_maybe_uninit(ecx.tcx, ecx.tcx.types.u32),\n-        AtomicWriteOp::Relaxed,\n+        AtomicWriteOrd::Relaxed,\n     )\n }\n \n@@ -120,8 +120,8 @@ fn mutex_get_or_create_id<'mir, 'tcx: 'mir>(\n                 &value_place,\n                 &ImmTy::from_uint(0u32, ecx.machine.layouts.u32),\n                 next_id.to_u32_scalar().into(),\n-                AtomicRwOp::Relaxed,\n-                AtomicReadOp::Relaxed,\n+                AtomicRwOrd::Relaxed,\n+                AtomicReadOrd::Relaxed,\n                 false,\n             )?\n             .to_scalar_pair()\n@@ -147,7 +147,7 @@ fn rwlock_get_id<'mir, 'tcx: 'mir>(\n     ecx: &MiriEvalContext<'mir, 'tcx>,\n     rwlock_op: &OpTy<'tcx, Tag>,\n ) -> InterpResult<'tcx, ScalarMaybeUninit<Tag>> {\n-    ecx.read_scalar_at_offset_atomic(rwlock_op, 4, ecx.machine.layouts.u32, AtomicReadOp::Relaxed)\n+    ecx.read_scalar_at_offset_atomic(rwlock_op, 4, ecx.machine.layouts.u32, AtomicReadOrd::Relaxed)\n }\n \n fn rwlock_set_id<'mir, 'tcx: 'mir>(\n@@ -160,7 +160,7 @@ fn rwlock_set_id<'mir, 'tcx: 'mir>(\n         4,\n         id,\n         layout_of_maybe_uninit(ecx.tcx, ecx.tcx.types.u32),\n-        AtomicWriteOp::Relaxed,\n+        AtomicWriteOrd::Relaxed,\n     )\n }\n \n@@ -176,8 +176,8 @@ fn rwlock_get_or_create_id<'mir, 'tcx: 'mir>(\n                 &value_place,\n                 &ImmTy::from_uint(0u32, ecx.machine.layouts.u32),\n                 next_id.to_u32_scalar().into(),\n-                AtomicRwOp::Relaxed,\n-                AtomicReadOp::Relaxed,\n+                AtomicRwOrd::Relaxed,\n+                AtomicReadOrd::Relaxed,\n                 false,\n             )?\n             .to_scalar_pair()\n@@ -231,7 +231,7 @@ fn cond_get_id<'mir, 'tcx: 'mir>(\n     ecx: &MiriEvalContext<'mir, 'tcx>,\n     cond_op: &OpTy<'tcx, Tag>,\n ) -> InterpResult<'tcx, ScalarMaybeUninit<Tag>> {\n-    ecx.read_scalar_at_offset_atomic(cond_op, 4, ecx.machine.layouts.u32, AtomicReadOp::Relaxed)\n+    ecx.read_scalar_at_offset_atomic(cond_op, 4, ecx.machine.layouts.u32, AtomicReadOrd::Relaxed)\n }\n \n fn cond_set_id<'mir, 'tcx: 'mir>(\n@@ -244,7 +244,7 @@ fn cond_set_id<'mir, 'tcx: 'mir>(\n         4,\n         id,\n         layout_of_maybe_uninit(ecx.tcx, ecx.tcx.types.u32),\n-        AtomicWriteOp::Relaxed,\n+        AtomicWriteOrd::Relaxed,\n     )\n }\n \n@@ -260,8 +260,8 @@ fn cond_get_or_create_id<'mir, 'tcx: 'mir>(\n                 &value_place,\n                 &ImmTy::from_uint(0u32, ecx.machine.layouts.u32),\n                 next_id.to_u32_scalar().into(),\n-                AtomicRwOp::Relaxed,\n-                AtomicReadOp::Relaxed,\n+                AtomicRwOrd::Relaxed,\n+                AtomicReadOrd::Relaxed,\n                 false,\n             )?\n             .to_scalar_pair()"}, {"sha": "35603f7f38632053049bd22a0e21037921664bf8", "filename": "src/shims/windows/sync.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f238513efac3193ed7d05222d03b8052690de0a3/src%2Fshims%2Fwindows%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f238513efac3193ed7d05222d03b8052690de0a3/src%2Fshims%2Fwindows%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fwindows%2Fsync.rs?ref=f238513efac3193ed7d05222d03b8052690de0a3", "patch": "@@ -15,8 +15,8 @@ fn srwlock_get_or_create_id<'mir, 'tcx: 'mir>(\n                 &value_place,\n                 &ImmTy::from_uint(0u32, ecx.machine.layouts.u32),\n                 next_id.to_u32_scalar().into(),\n-                AtomicRwOp::Relaxed,\n-                AtomicReadOp::Relaxed,\n+                AtomicRwOrd::Relaxed,\n+                AtomicReadOrd::Relaxed,\n                 false,\n             )?\n             .to_scalar_pair()"}]}