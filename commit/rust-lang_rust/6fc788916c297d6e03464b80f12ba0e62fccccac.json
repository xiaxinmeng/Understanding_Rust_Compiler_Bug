{"sha": "6fc788916c297d6e03464b80f12ba0e62fccccac", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZmYzc4ODkxNmMyOTdkNmUwMzQ2NGI4MGYxMmJhMGU2MmZjY2NjYWM=", "commit": {"author": {"name": "Cameron Zwarich", "email": "zwarich@mozilla.com", "date": "2014-06-14T03:48:10Z"}, "committer": {"name": "Cameron Zwarich", "email": "zwarich@mozilla.com", "date": "2014-06-14T03:48:10Z"}, "message": "Reorganize code in check_loans\n\nMove analyze_restrictions_on_use and check_if_path_is_moved so that all\nof the code related to assignments is in a contiguous block at the end\nof the file.", "tree": {"sha": "f7dbcc8a483136c2ca6c95cbbd7dbe15df4d9ca8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f7dbcc8a483136c2ca6c95cbbd7dbe15df4d9ca8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6fc788916c297d6e03464b80f12ba0e62fccccac", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6fc788916c297d6e03464b80f12ba0e62fccccac", "html_url": "https://github.com/rust-lang/rust/commit/6fc788916c297d6e03464b80f12ba0e62fccccac", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6fc788916c297d6e03464b80f12ba0e62fccccac/comments", "author": null, "committer": null, "parents": [{"sha": "5878b5edb0036312ffee12fc730e69d57df31a66", "url": "https://api.github.com/repos/rust-lang/rust/commits/5878b5edb0036312ffee12fc730e69d57df31a66", "html_url": "https://github.com/rust-lang/rust/commit/5878b5edb0036312ffee12fc730e69d57df31a66"}], "stats": {"total": 186, "additions": 93, "deletions": 93}, "files": [{"sha": "111441180475e9a03d4fac38d3086ebd6833ceda", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 93, "deletions": 93, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/6fc788916c297d6e03464b80f12ba0e62fccccac/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fc788916c297d6e03464b80f12ba0e62fccccac/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=6fc788916c297d6e03464b80f12ba0e62fccccac", "patch": "@@ -523,6 +523,99 @@ impl<'a> CheckLoanCtxt<'a> {\n         }\n     }\n \n+    pub fn analyze_restrictions_on_use(&self,\n+                                       expr_id: ast::NodeId,\n+                                       use_path: &LoanPath,\n+                                       borrow_kind: ty::BorrowKind)\n+                                       -> UseError {\n+        debug!(\"analyze_restrictions_on_use(expr_id={:?}, use_path={})\",\n+               self.tcx().map.node_to_str(expr_id),\n+               use_path.repr(self.tcx()));\n+\n+        let mut ret = UseOk;\n+\n+        // First, we check for a restriction on the path P being used. This\n+        // accounts for borrows of P but also borrows of subpaths, like P.a.b.\n+        // Consider the following example:\n+        //\n+        //     let x = &mut a.b.c; // Restricts a, a.b, and a.b.c\n+        //     let y = a;          // Conflicts with restriction\n+\n+        self.each_in_scope_restriction(expr_id, use_path, |loan, _restr| {\n+            if incompatible(loan.kind, borrow_kind) {\n+                ret = UseWhileBorrowed(loan.loan_path.clone(), loan.span);\n+                false\n+            } else {\n+                true\n+            }\n+        });\n+\n+        // Next, we must check for *loans* (not restrictions) on the path P or\n+        // any base path. This rejects examples like the following:\n+        //\n+        //     let x = &mut a.b;\n+        //     let y = a.b.c;\n+        //\n+        // Limiting this search to *loans* and not *restrictions* means that\n+        // examples like the following continue to work:\n+        //\n+        //     let x = &mut a.b;\n+        //     let y = a.c;\n+\n+        let mut loan_path = use_path;\n+        loop {\n+            self.each_in_scope_loan(expr_id, |loan| {\n+                if *loan.loan_path == *loan_path &&\n+                   incompatible(loan.kind, borrow_kind) {\n+                    ret = UseWhileBorrowed(loan.loan_path.clone(), loan.span);\n+                    false\n+                } else {\n+                    true\n+                }\n+            });\n+\n+            match *loan_path {\n+                LpVar(_) => {\n+                    break;\n+                }\n+                LpExtend(ref lp_base, _, _) => {\n+                    loan_path = &**lp_base;\n+                }\n+            }\n+        }\n+\n+        return ret;\n+\n+        fn incompatible(borrow_kind1: ty::BorrowKind,\n+                        borrow_kind2: ty::BorrowKind)\n+                        -> bool {\n+            borrow_kind1 != ty::ImmBorrow || borrow_kind2 != ty::ImmBorrow\n+        }\n+    }\n+\n+    fn check_if_path_is_moved(&self,\n+                              id: ast::NodeId,\n+                              span: Span,\n+                              use_kind: MovedValueUseKind,\n+                              lp: &Rc<LoanPath>) {\n+        /*!\n+         * Reports an error if `expr` (which should be a path)\n+         * is using a moved/uninitialized value\n+         */\n+\n+        debug!(\"check_if_path_is_moved(id={:?}, use_kind={:?}, lp={})\",\n+               id, use_kind, lp.repr(self.bccx.tcx));\n+        self.move_data.each_move_of(id, lp, |move, moved_lp| {\n+            self.bccx.report_use_of_moved_value(\n+                span,\n+                use_kind,\n+                &**lp,\n+                move,\n+                moved_lp);\n+            false\n+        });\n+    }\n+\n     fn check_if_assigned_path_is_moved(&self,\n                                        id: ast::NodeId,\n                                        span: Span,\n@@ -564,29 +657,6 @@ impl<'a> CheckLoanCtxt<'a> {\n         }\n     }\n \n-    fn check_if_path_is_moved(&self,\n-                              id: ast::NodeId,\n-                              span: Span,\n-                              use_kind: MovedValueUseKind,\n-                              lp: &Rc<LoanPath>) {\n-        /*!\n-         * Reports an error if `expr` (which should be a path)\n-         * is using a moved/uninitialized value\n-         */\n-\n-        debug!(\"check_if_path_is_moved(id={:?}, use_kind={:?}, lp={})\",\n-               id, use_kind, lp.repr(self.bccx.tcx));\n-        self.move_data.each_move_of(id, lp, |move, moved_lp| {\n-            self.bccx.report_use_of_moved_value(\n-                span,\n-                use_kind,\n-                &**lp,\n-                move,\n-                moved_lp);\n-            false\n-        });\n-    }\n-\n     fn check_assignment(&self,\n                         assignment_id: ast::NodeId,\n                         assignment_span: Span,\n@@ -885,74 +955,4 @@ impl<'a> CheckLoanCtxt<'a> {\n             format!(\"borrow of `{}` occurs here\",\n                     self.bccx.loan_path_to_str(loan_path)).as_slice());\n     }\n-\n-    pub fn analyze_restrictions_on_use(&self,\n-                                       expr_id: ast::NodeId,\n-                                       use_path: &LoanPath,\n-                                       borrow_kind: ty::BorrowKind)\n-                                       -> UseError {\n-        debug!(\"analyze_restrictions_on_use(expr_id={:?}, use_path={})\",\n-               self.tcx().map.node_to_str(expr_id),\n-               use_path.repr(self.tcx()));\n-\n-        let mut ret = UseOk;\n-\n-        // First, we check for a restriction on the path P being used. This\n-        // accounts for borrows of P but also borrows of subpaths, like P.a.b.\n-        // Consider the following example:\n-        //\n-        //     let x = &mut a.b.c; // Restricts a, a.b, and a.b.c\n-        //     let y = a;          // Conflicts with restriction\n-\n-        self.each_in_scope_restriction(expr_id, use_path, |loan, _restr| {\n-            if incompatible(loan.kind, borrow_kind) {\n-                ret = UseWhileBorrowed(loan.loan_path.clone(), loan.span);\n-                false\n-            } else {\n-                true\n-            }\n-        });\n-\n-        // Next, we must check for *loans* (not restrictions) on the path P or\n-        // any base path. This rejects examples like the following:\n-        //\n-        //     let x = &mut a.b;\n-        //     let y = a.b.c;\n-        //\n-        // Limiting this search to *loans* and not *restrictions* means that\n-        // examples like the following continue to work:\n-        //\n-        //     let x = &mut a.b;\n-        //     let y = a.c;\n-\n-        let mut loan_path = use_path;\n-        loop {\n-            self.each_in_scope_loan(expr_id, |loan| {\n-                if *loan.loan_path == *loan_path &&\n-                   incompatible(loan.kind, borrow_kind) {\n-                    ret = UseWhileBorrowed(loan.loan_path.clone(), loan.span);\n-                    false\n-                } else {\n-                    true\n-                }\n-            });\n-\n-            match *loan_path {\n-                LpVar(_) => {\n-                    break;\n-                }\n-                LpExtend(ref lp_base, _, _) => {\n-                    loan_path = &**lp_base;\n-                }\n-            }\n-        }\n-\n-        return ret;\n-\n-        fn incompatible(borrow_kind1: ty::BorrowKind,\n-                        borrow_kind2: ty::BorrowKind)\n-                        -> bool {\n-            borrow_kind1 != ty::ImmBorrow || borrow_kind2 != ty::ImmBorrow\n-        }\n-    }\n }"}]}