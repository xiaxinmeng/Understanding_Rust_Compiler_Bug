{"sha": "bff69c9525b8c498fb6485ac38b4b3497bb37c1a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJmZjY5Yzk1MjViOGM0OThmYjY0ODVhYzM4YjRiMzQ5N2JiMzdjMWE=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-08-09T13:37:32Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-08-09T13:37:32Z"}, "message": "move const_eval error reporting logic into rustc_mir::const_eval::error", "tree": {"sha": "6a59424509313e09ae954af073be59df4380ab95", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6a59424509313e09ae954af073be59df4380ab95"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bff69c9525b8c498fb6485ac38b4b3497bb37c1a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bff69c9525b8c498fb6485ac38b4b3497bb37c1a", "html_url": "https://github.com/rust-lang/rust/commit/bff69c9525b8c498fb6485ac38b4b3497bb37c1a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bff69c9525b8c498fb6485ac38b4b3497bb37c1a/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8e738539be23a62120059b5b4443f6c235f932b4", "url": "https://api.github.com/repos/rust-lang/rust/commits/8e738539be23a62120059b5b4443f6c235f932b4", "html_url": "https://github.com/rust-lang/rust/commit/8e738539be23a62120059b5b4443f6c235f932b4"}], "stats": {"total": 395, "additions": 201, "deletions": 194}, "files": [{"sha": "5be09c0e9bc2bcaef3eda598d7438b76ee119b5e", "filename": "src/librustc_middle/mir/interpret/error.rs", "status": "modified", "additions": 2, "deletions": 167, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/bff69c9525b8c498fb6485ac38b4b3497bb37c1a/src%2Flibrustc_middle%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bff69c9525b8c498fb6485ac38b4b3497bb37c1a/src%2Flibrustc_middle%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Finterpret%2Ferror.rs?ref=bff69c9525b8c498fb6485ac38b4b3497bb37c1a", "patch": "@@ -1,17 +1,13 @@\n use super::{AllocId, Pointer, RawConst, Scalar};\n \n use crate::mir::interpret::ConstValue;\n-use crate::ty::layout::LayoutError;\n-use crate::ty::query::TyCtxtAt;\n-use crate::ty::{self, layout, tls, FnSig, Ty};\n+use crate::ty::{layout, query::TyCtxtAt, tls, FnSig, Ty};\n \n use rustc_data_structures::sync::Lock;\n use rustc_errors::{pluralize, struct_span_err, DiagnosticBuilder, ErrorReported};\n-use rustc_hir as hir;\n-use rustc_hir::definitions::DefPathData;\n use rustc_macros::HashStable;\n use rustc_session::CtfeBacktrace;\n-use rustc_span::{def_id::DefId, Pos, Span};\n+use rustc_span::def_id::DefId;\n use rustc_target::abi::{Align, Size};\n use std::{any::Any, backtrace::Backtrace, fmt, mem};\n \n@@ -34,167 +30,6 @@ CloneTypeFoldableAndLiftImpls! {\n pub type ConstEvalRawResult<'tcx> = Result<RawConst<'tcx>, ErrorHandled>;\n pub type ConstEvalResult<'tcx> = Result<ConstValue<'tcx>, ErrorHandled>;\n \n-#[derive(Debug)]\n-pub struct ConstEvalErr<'tcx> {\n-    pub span: Span,\n-    pub error: crate::mir::interpret::InterpError<'tcx>,\n-    pub stacktrace: Vec<FrameInfo<'tcx>>,\n-}\n-\n-#[derive(Debug)]\n-pub struct FrameInfo<'tcx> {\n-    pub instance: ty::Instance<'tcx>,\n-    pub span: Span,\n-    pub lint_root: Option<hir::HirId>,\n-}\n-\n-impl<'tcx> fmt::Display for FrameInfo<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        ty::tls::with(|tcx| {\n-            if tcx.def_key(self.instance.def_id()).disambiguated_data.data\n-                == DefPathData::ClosureExpr\n-            {\n-                write!(f, \"inside closure\")?;\n-            } else {\n-                write!(f, \"inside `{}`\", self.instance)?;\n-            }\n-            if !self.span.is_dummy() {\n-                let lo = tcx.sess.source_map().lookup_char_pos(self.span.lo());\n-                write!(f, \" at {}:{}:{}\", lo.file.name, lo.line, lo.col.to_usize() + 1)?;\n-            }\n-            Ok(())\n-        })\n-    }\n-}\n-\n-impl<'tcx> ConstEvalErr<'tcx> {\n-    pub fn struct_error(\n-        &self,\n-        tcx: TyCtxtAt<'tcx>,\n-        message: &str,\n-        emit: impl FnOnce(DiagnosticBuilder<'_>),\n-    ) -> ErrorHandled {\n-        self.struct_generic(tcx, message, emit, None)\n-    }\n-\n-    pub fn report_as_error(&self, tcx: TyCtxtAt<'tcx>, message: &str) -> ErrorHandled {\n-        self.struct_error(tcx, message, |mut e| e.emit())\n-    }\n-\n-    pub fn report_as_lint(\n-        &self,\n-        tcx: TyCtxtAt<'tcx>,\n-        message: &str,\n-        lint_root: hir::HirId,\n-        span: Option<Span>,\n-    ) -> ErrorHandled {\n-        self.struct_generic(\n-            tcx,\n-            message,\n-            |mut lint: DiagnosticBuilder<'_>| {\n-                // Apply the span.\n-                if let Some(span) = span {\n-                    let primary_spans = lint.span.primary_spans().to_vec();\n-                    // point at the actual error as the primary span\n-                    lint.replace_span_with(span);\n-                    // point to the `const` statement as a secondary span\n-                    // they don't have any label\n-                    for sp in primary_spans {\n-                        if sp != span {\n-                            lint.span_label(sp, \"\");\n-                        }\n-                    }\n-                }\n-                lint.emit();\n-            },\n-            Some(lint_root),\n-        )\n-    }\n-\n-    /// Create a diagnostic for this const eval error.\n-    ///\n-    /// Sets the message passed in via `message` and adds span labels with detailed error\n-    /// information before handing control back to `emit` to do any final processing.\n-    /// It's the caller's responsibility to call emit(), stash(), etc. within the `emit`\n-    /// function to dispose of the diagnostic properly.\n-    ///\n-    /// If `lint_root.is_some()` report it as a lint, else report it as a hard error.\n-    /// (Except that for some errors, we ignore all that -- see `must_error` below.)\n-    fn struct_generic(\n-        &self,\n-        tcx: TyCtxtAt<'tcx>,\n-        message: &str,\n-        emit: impl FnOnce(DiagnosticBuilder<'_>),\n-        lint_root: Option<hir::HirId>,\n-    ) -> ErrorHandled {\n-        let must_error = match self.error {\n-            err_inval!(Layout(LayoutError::Unknown(_))) | err_inval!(TooGeneric) => {\n-                return ErrorHandled::TooGeneric;\n-            }\n-            err_inval!(TypeckError(error_reported)) => {\n-                return ErrorHandled::Reported(error_reported);\n-            }\n-            // We must *always* hard error on these, even if the caller wants just a lint.\n-            err_inval!(Layout(LayoutError::SizeOverflow(_))) => true,\n-            _ => false,\n-        };\n-        trace!(\"reporting const eval failure at {:?}\", self.span);\n-\n-        let err_msg = match &self.error {\n-            InterpError::MachineStop(msg) => {\n-                // A custom error (`ConstEvalErrKind` in `librustc_mir/interp/const_eval/error.rs`).\n-                // Should be turned into a string by now.\n-                msg.downcast_ref::<String>().expect(\"invalid MachineStop payload\").clone()\n-            }\n-            err => err.to_string(),\n-        };\n-\n-        let finish = |mut err: DiagnosticBuilder<'_>, span_msg: Option<String>| {\n-            if let Some(span_msg) = span_msg {\n-                err.span_label(self.span, span_msg);\n-            }\n-            // Add spans for the stacktrace. Don't print a single-line backtrace though.\n-            if self.stacktrace.len() > 1 {\n-                for frame_info in &self.stacktrace {\n-                    err.span_label(frame_info.span, frame_info.to_string());\n-                }\n-            }\n-            // Let the caller finish the job.\n-            emit(err)\n-        };\n-\n-        if must_error {\n-            // The `message` makes little sense here, this is a more serious error than the\n-            // caller thinks anyway.\n-            // See <https://github.com/rust-lang/rust/pull/63152>.\n-            finish(struct_error(tcx, &err_msg), None);\n-            ErrorHandled::Reported(ErrorReported)\n-        } else {\n-            // Regular case.\n-            if let Some(lint_root) = lint_root {\n-                // Report as lint.\n-                let hir_id = self\n-                    .stacktrace\n-                    .iter()\n-                    .rev()\n-                    .find_map(|frame| frame.lint_root)\n-                    .unwrap_or(lint_root);\n-                tcx.struct_span_lint_hir(\n-                    rustc_session::lint::builtin::CONST_ERR,\n-                    hir_id,\n-                    tcx.span,\n-                    |lint| finish(lint.build(message), Some(err_msg)),\n-                );\n-                ErrorHandled::Linted\n-            } else {\n-                // Report as hard error.\n-                finish(struct_error(tcx, message), Some(err_msg));\n-                ErrorHandled::Reported(ErrorReported)\n-            }\n-        }\n-    }\n-}\n-\n pub fn struct_error<'tcx>(tcx: TyCtxtAt<'tcx>, msg: &str) -> DiagnosticBuilder<'tcx> {\n     struct_span_err!(tcx.sess, tcx.span, E0080, \"{}\", msg)\n }"}, {"sha": "2507f2184fff1026c54437d9e9a6d5dce1cf31b9", "filename": "src/librustc_middle/mir/interpret/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bff69c9525b8c498fb6485ac38b4b3497bb37c1a/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bff69c9525b8c498fb6485ac38b4b3497bb37c1a/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fmod.rs?ref=bff69c9525b8c498fb6485ac38b4b3497bb37c1a", "patch": "@@ -117,9 +117,9 @@ use crate::ty::subst::GenericArgKind;\n use crate::ty::{self, Instance, Ty, TyCtxt};\n \n pub use self::error::{\n-    struct_error, CheckInAllocMsg, ConstEvalErr, ConstEvalRawResult, ConstEvalResult, ErrorHandled,\n-    FrameInfo, InterpError, InterpErrorInfo, InterpResult, InvalidProgramInfo, MachineStopType,\n-    ResourceExhaustionInfo, UndefinedBehaviorInfo, UninitBytesAccess, UnsupportedOpInfo,\n+    struct_error, CheckInAllocMsg, ConstEvalRawResult, ConstEvalResult, ErrorHandled, InterpError,\n+    InterpErrorInfo, InterpResult, InvalidProgramInfo, MachineStopType, ResourceExhaustionInfo,\n+    UndefinedBehaviorInfo, UninitBytesAccess, UnsupportedOpInfo,\n };\n \n pub use self::value::{get_slice_bytes, ConstValue, RawConst, Scalar, ScalarMaybeUninit};"}, {"sha": "044d27a6a9dc3d0dd21aeb8bf708cc01e933cdcb", "filename": "src/librustc_mir/const_eval/error.rs", "status": "modified", "additions": 157, "deletions": 13, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/bff69c9525b8c498fb6485ac38b4b3497bb37c1a/src%2Flibrustc_mir%2Fconst_eval%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bff69c9525b8c498fb6485ac38b4b3497bb37c1a/src%2Flibrustc_mir%2Fconst_eval%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Ferror.rs?ref=bff69c9525b8c498fb6485ac38b4b3497bb37c1a", "patch": "@@ -1,12 +1,16 @@\n use std::error::Error;\n use std::fmt;\n \n+use rustc_errors::{DiagnosticBuilder, ErrorReported};\n+use rustc_hir as hir;\n use rustc_middle::mir::AssertKind;\n-use rustc_middle::ty::ConstInt;\n+use rustc_middle::ty::{layout::LayoutError, query::TyCtxtAt, ConstInt};\n use rustc_span::{Span, Symbol};\n \n use super::InterpCx;\n-use crate::interpret::{ConstEvalErr, InterpErrorInfo, Machine};\n+use crate::interpret::{\n+    struct_error, ErrorHandled, FrameInfo, InterpError, InterpErrorInfo, Machine,\n+};\n \n /// The CTFE machine has some custom error kinds.\n #[derive(Clone, Debug)]\n@@ -48,15 +52,155 @@ impl fmt::Display for ConstEvalErrKind {\n \n impl Error for ConstEvalErrKind {}\n \n-/// Turn an interpreter error into something to report to the user.\n-/// As a side-effect, if RUSTC_CTFE_BACKTRACE is set, this prints the backtrace.\n-/// Should be called only if the error is actually going to to be reported!\n-pub fn error_to_const_error<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>>(\n-    ecx: &InterpCx<'mir, 'tcx, M>,\n-    error: InterpErrorInfo<'tcx>,\n-    span: Option<Span>,\n-) -> ConstEvalErr<'tcx> {\n-    error.print_backtrace();\n-    let stacktrace = ecx.generate_stacktrace();\n-    ConstEvalErr { error: error.kind, stacktrace, span: span.unwrap_or_else(|| ecx.cur_span()) }\n+/// When const-evaluation errors, this type is constructed with the resulting information,\n+/// and then used to emit the error as a lint or hard error.\n+#[derive(Debug)]\n+pub struct ConstEvalErr<'tcx> {\n+    pub span: Span,\n+    pub error: InterpError<'tcx>,\n+    pub stacktrace: Vec<FrameInfo<'tcx>>,\n+}\n+\n+impl<'tcx> ConstEvalErr<'tcx> {\n+    /// Turn an interpreter error into something to report to the user.\n+    /// As a side-effect, if RUSTC_CTFE_BACKTRACE is set, this prints the backtrace.\n+    /// Should be called only if the error is actually going to to be reported!\n+    pub fn new<'mir, M: Machine<'mir, 'tcx>>(\n+        ecx: &InterpCx<'mir, 'tcx, M>,\n+        error: InterpErrorInfo<'tcx>,\n+        span: Option<Span>,\n+    ) -> ConstEvalErr<'tcx>\n+    where\n+        'tcx: 'mir,\n+    {\n+        error.print_backtrace();\n+        let stacktrace = ecx.generate_stacktrace();\n+        ConstEvalErr { error: error.kind, stacktrace, span: span.unwrap_or_else(|| ecx.cur_span()) }\n+    }\n+\n+    pub fn struct_error(\n+        &self,\n+        tcx: TyCtxtAt<'tcx>,\n+        message: &str,\n+        emit: impl FnOnce(DiagnosticBuilder<'_>),\n+    ) -> ErrorHandled {\n+        self.struct_generic(tcx, message, emit, None)\n+    }\n+\n+    pub fn report_as_error(&self, tcx: TyCtxtAt<'tcx>, message: &str) -> ErrorHandled {\n+        self.struct_error(tcx, message, |mut e| e.emit())\n+    }\n+\n+    pub fn report_as_lint(\n+        &self,\n+        tcx: TyCtxtAt<'tcx>,\n+        message: &str,\n+        lint_root: hir::HirId,\n+        span: Option<Span>,\n+    ) -> ErrorHandled {\n+        self.struct_generic(\n+            tcx,\n+            message,\n+            |mut lint: DiagnosticBuilder<'_>| {\n+                // Apply the span.\n+                if let Some(span) = span {\n+                    let primary_spans = lint.span.primary_spans().to_vec();\n+                    // point at the actual error as the primary span\n+                    lint.replace_span_with(span);\n+                    // point to the `const` statement as a secondary span\n+                    // they don't have any label\n+                    for sp in primary_spans {\n+                        if sp != span {\n+                            lint.span_label(sp, \"\");\n+                        }\n+                    }\n+                }\n+                lint.emit();\n+            },\n+            Some(lint_root),\n+        )\n+    }\n+\n+    /// Create a diagnostic for this const eval error.\n+    ///\n+    /// Sets the message passed in via `message` and adds span labels with detailed error\n+    /// information before handing control back to `emit` to do any final processing.\n+    /// It's the caller's responsibility to call emit(), stash(), etc. within the `emit`\n+    /// function to dispose of the diagnostic properly.\n+    ///\n+    /// If `lint_root.is_some()` report it as a lint, else report it as a hard error.\n+    /// (Except that for some errors, we ignore all that -- see `must_error` below.)\n+    fn struct_generic(\n+        &self,\n+        tcx: TyCtxtAt<'tcx>,\n+        message: &str,\n+        emit: impl FnOnce(DiagnosticBuilder<'_>),\n+        lint_root: Option<hir::HirId>,\n+    ) -> ErrorHandled {\n+        let must_error = match self.error {\n+            err_inval!(Layout(LayoutError::Unknown(_))) | err_inval!(TooGeneric) => {\n+                return ErrorHandled::TooGeneric;\n+            }\n+            err_inval!(TypeckError(error_reported)) => {\n+                return ErrorHandled::Reported(error_reported);\n+            }\n+            // We must *always* hard error on these, even if the caller wants just a lint.\n+            err_inval!(Layout(LayoutError::SizeOverflow(_))) => true,\n+            _ => false,\n+        };\n+        trace!(\"reporting const eval failure at {:?}\", self.span);\n+\n+        let err_msg = match &self.error {\n+            InterpError::MachineStop(msg) => {\n+                // A custom error (`ConstEvalErrKind` in `librustc_mir/interp/const_eval/error.rs`).\n+                // Should be turned into a string by now.\n+                msg.downcast_ref::<String>().expect(\"invalid MachineStop payload\").clone()\n+            }\n+            err => err.to_string(),\n+        };\n+\n+        let finish = |mut err: DiagnosticBuilder<'_>, span_msg: Option<String>| {\n+            if let Some(span_msg) = span_msg {\n+                err.span_label(self.span, span_msg);\n+            }\n+            // Add spans for the stacktrace. Don't print a single-line backtrace though.\n+            if self.stacktrace.len() > 1 {\n+                for frame_info in &self.stacktrace {\n+                    err.span_label(frame_info.span, frame_info.to_string());\n+                }\n+            }\n+            // Let the caller finish the job.\n+            emit(err)\n+        };\n+\n+        if must_error {\n+            // The `message` makes little sense here, this is a more serious error than the\n+            // caller thinks anyway.\n+            // See <https://github.com/rust-lang/rust/pull/63152>.\n+            finish(struct_error(tcx, &err_msg), None);\n+            ErrorHandled::Reported(ErrorReported)\n+        } else {\n+            // Regular case.\n+            if let Some(lint_root) = lint_root {\n+                // Report as lint.\n+                let hir_id = self\n+                    .stacktrace\n+                    .iter()\n+                    .rev()\n+                    .find_map(|frame| frame.lint_root)\n+                    .unwrap_or(lint_root);\n+                tcx.struct_span_lint_hir(\n+                    rustc_session::lint::builtin::CONST_ERR,\n+                    hir_id,\n+                    tcx.span,\n+                    |lint| finish(lint.build(message), Some(err_msg)),\n+                );\n+                ErrorHandled::Linted\n+            } else {\n+                // Report as hard error.\n+                finish(struct_error(tcx, message), Some(err_msg));\n+                ErrorHandled::Reported(ErrorReported)\n+            }\n+        }\n+    }\n }"}, {"sha": "7fbe5c409d3ce283f0a694a86a9f4d4551c21130", "filename": "src/librustc_mir/const_eval/eval_queries.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/bff69c9525b8c498fb6485ac38b4b3497bb37c1a/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bff69c9525b8c498fb6485ac38b4b3497bb37c1a/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs?ref=bff69c9525b8c498fb6485ac38b4b3497bb37c1a", "patch": "@@ -1,13 +1,14 @@\n-use super::{error_to_const_error, CompileTimeEvalContext, CompileTimeInterpreter, MemoryExtra};\n+use super::{CompileTimeEvalContext, CompileTimeInterpreter, ConstEvalErr, MemoryExtra};\n use crate::interpret::eval_nullary_intrinsic;\n use crate::interpret::{\n     intern_const_alloc_recursive, Allocation, ConstValue, GlobalId, Immediate, InternKind,\n     InterpCx, InterpResult, MPlaceTy, MemoryKind, OpTy, RawConst, RefTracking, Scalar,\n     ScalarMaybeUninit, StackPopCleanup,\n };\n+\n use rustc_hir::def::DefKind;\n use rustc_middle::mir;\n-use rustc_middle::mir::interpret::{ConstEvalErr, ErrorHandled};\n+use rustc_middle::mir::interpret::ErrorHandled;\n use rustc_middle::traits::Reveal;\n use rustc_middle::ty::{self, subst::Subst, TyCtxt};\n use rustc_span::source_map::Span;\n@@ -213,7 +214,7 @@ fn validate_and_turn_into_const<'tcx>(\n     })();\n \n     val.map_err(|error| {\n-        let err = error_to_const_error(&ecx, error, None);\n+        let err = ConstEvalErr::new(&ecx, error, None);\n         err.struct_error(ecx.tcx, \"it is undefined behavior to use this value\", |mut diag| {\n             diag.note(note_on_undefined_behavior_error());\n             diag.emit();\n@@ -312,7 +313,7 @@ pub fn const_eval_raw_provider<'tcx>(\n     res.and_then(|body| eval_body_using_ecx(&mut ecx, cid, &body))\n         .map(|place| RawConst { alloc_id: place.ptr.assert_ptr().alloc_id, ty: place.layout.ty })\n         .map_err(|error| {\n-            let err = error_to_const_error(&ecx, error, None);\n+            let err = ConstEvalErr::new(&ecx, error, None);\n             // errors in statics are always emitted as fatal errors\n             if is_static {\n                 // Ensure that if the above error was either `TooGeneric` or `Reported`"}, {"sha": "fc192cd9b3cb24a49ac974406958be447d6865cd", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 31, "deletions": 4, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/bff69c9525b8c498fb6485ac38b4b3497bb37c1a/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bff69c9525b8c498fb6485ac38b4b3497bb37c1a/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=bff69c9525b8c498fb6485ac38b4b3497bb37c1a", "patch": "@@ -1,22 +1,22 @@\n use std::cell::Cell;\n+use std::fmt;\n use std::mem;\n \n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n-use rustc_hir::def::DefKind;\n-use rustc_hir::def_id::DefId;\n+use rustc_hir::{self as hir, def::DefKind, def_id::DefId, definitions::DefPathData};\n use rustc_index::vec::IndexVec;\n use rustc_macros::HashStable;\n use rustc_middle::ich::StableHashingContext;\n use rustc_middle::mir;\n use rustc_middle::mir::interpret::{\n-    sign_extend, truncate, FrameInfo, GlobalId, InterpResult, Pointer, Scalar,\n+    sign_extend, truncate, GlobalId, InterpResult, Pointer, Scalar,\n };\n use rustc_middle::ty::layout::{self, TyAndLayout};\n use rustc_middle::ty::{\n     self, query::TyCtxtAt, subst::SubstsRef, ParamEnv, Ty, TyCtxt, TypeFoldable,\n };\n-use rustc_span::{source_map::DUMMY_SP, Span};\n+use rustc_span::{source_map::DUMMY_SP, Pos, Span};\n use rustc_target::abi::{Align, HasDataLayout, LayoutOf, Size, TargetDataLayout};\n \n use super::{\n@@ -88,6 +88,14 @@ pub struct Frame<'mir, 'tcx, Tag = (), Extra = ()> {\n     pub loc: Option<mir::Location>,\n }\n \n+/// What we store about a frame in an interpreter backtrace.\n+#[derive(Debug)]\n+pub struct FrameInfo<'tcx> {\n+    pub instance: ty::Instance<'tcx>,\n+    pub span: Span,\n+    pub lint_root: Option<hir::HirId>,\n+}\n+\n #[derive(Clone, Eq, PartialEq, Debug, HashStable)] // Miri debug-prints these\n pub enum StackPopCleanup {\n     /// Jump to the next block in the caller, or cause UB if None (that's a function\n@@ -185,6 +193,25 @@ impl<'mir, 'tcx, Tag, Extra> Frame<'mir, 'tcx, Tag, Extra> {\n     }\n }\n \n+impl<'tcx> fmt::Display for FrameInfo<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        ty::tls::with(|tcx| {\n+            if tcx.def_key(self.instance.def_id()).disambiguated_data.data\n+                == DefPathData::ClosureExpr\n+            {\n+                write!(f, \"inside closure\")?;\n+            } else {\n+                write!(f, \"inside `{}`\", self.instance)?;\n+            }\n+            if !self.span.is_dummy() {\n+                let lo = tcx.sess.source_map().lookup_char_pos(self.span.lo());\n+                write!(f, \" at {}:{}:{}\", lo.file.name, lo.line, lo.col.to_usize() + 1)?;\n+            }\n+            Ok(())\n+        })\n+    }\n+}\n+\n impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> HasDataLayout for InterpCx<'mir, 'tcx, M> {\n     #[inline]\n     fn data_layout(&self) -> &TargetDataLayout {"}, {"sha": "5218b03d65ecc995b859b53c89ae21583238c4c3", "filename": "src/librustc_mir/interpret/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bff69c9525b8c498fb6485ac38b4b3497bb37c1a/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bff69c9525b8c498fb6485ac38b4b3497bb37c1a/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmod.rs?ref=bff69c9525b8c498fb6485ac38b4b3497bb37c1a", "patch": "@@ -18,7 +18,7 @@ mod visitor;\n \n pub use rustc_middle::mir::interpret::*; // have all the `interpret` symbols in one place: here\n \n-pub use self::eval_context::{Frame, InterpCx, LocalState, LocalValue, StackPopCleanup};\n+pub use self::eval_context::{Frame, FrameInfo, InterpCx, LocalState, LocalValue, StackPopCleanup};\n pub use self::intern::{intern_const_alloc_recursive, InternKind};\n pub use self::machine::{compile_time_machine, AllocMap, Machine, MayLeak, StackPopJump};\n pub use self::memory::{get_static, AllocCheck, FnVal, Memory, MemoryKind};"}, {"sha": "bff83b3c6db745d9d6ae8624e52374c7e8cdf142", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bff69c9525b8c498fb6485ac38b4b3497bb37c1a/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bff69c9525b8c498fb6485ac38b4b3497bb37c1a/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=bff69c9525b8c498fb6485ac38b4b3497bb37c1a", "patch": "@@ -26,7 +26,7 @@ use rustc_span::{def_id::DefId, Span};\n use rustc_target::abi::{HasDataLayout, LayoutOf, Size, TargetDataLayout};\n use rustc_trait_selection::traits;\n \n-use crate::const_eval::error_to_const_error;\n+use crate::const_eval::ConstEvalErr;\n use crate::interpret::{\n     self, compile_time_machine, truncate, AllocId, Allocation, Frame, ImmTy, Immediate, InterpCx,\n     LocalState, LocalValue, MemPlace, Memory, MemoryKind, OpTy, Operand as InterpOperand, PlaceTy,\n@@ -451,7 +451,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n             Ok(op) => Some(op),\n             Err(error) => {\n                 let tcx = self.ecx.tcx.at(c.span);\n-                let err = error_to_const_error(&self.ecx, error, Some(c.span));\n+                let err = ConstEvalErr::new(&self.ecx, error, Some(c.span));\n                 if let Some(lint_root) = self.lint_root(source_info) {\n                     let lint_only = match c.literal.val {\n                         // Promoteds must lint and not error as the user didn't ask for them"}]}