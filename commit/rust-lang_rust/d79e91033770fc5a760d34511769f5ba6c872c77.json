{"sha": "d79e91033770fc5a760d34511769f5ba6c872c77", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ3OWU5MTAzMzc3MGZjNWE3NjBkMzQ1MTE3NjlmNWJhNmM4NzJjNzc=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-02-27T23:46:02Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-02-28T00:26:33Z"}, "message": "std: Deprecated the `old_io::extensions` module\n\nThe `u64_from_be_bytes` and `u64_to_be_bytes` functions are being deprecated\nwith no replacement for now.\n\n[breaking-change]", "tree": {"sha": "60ef39b796d50c156148af7d7d5e466c87c6424c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/60ef39b796d50c156148af7d7d5e466c87c6424c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d79e91033770fc5a760d34511769f5ba6c872c77", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d79e91033770fc5a760d34511769f5ba6c872c77", "html_url": "https://github.com/rust-lang/rust/commit/d79e91033770fc5a760d34511769f5ba6c872c77", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d79e91033770fc5a760d34511769f5ba6c872c77/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bd0d8e47e53f25bbd50418a0f117973c366c1b08", "url": "https://api.github.com/repos/rust-lang/rust/commits/bd0d8e47e53f25bbd50418a0f117973c366c1b08", "html_url": "https://github.com/rust-lang/rust/commit/bd0d8e47e53f25bbd50418a0f117973c366c1b08"}], "stats": {"total": 99, "additions": 53, "deletions": 46}, "files": [{"sha": "05cd24de7368c6a831597d8e9aa4e096c916adf8", "filename": "src/librbml/lib.rs", "status": "modified", "additions": 37, "deletions": 39, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/d79e91033770fc5a760d34511769f5ba6c872c77/src%2Flibrbml%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d79e91033770fc5a760d34511769f5ba6c872c77/src%2Flibrbml%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrbml%2Flib.rs?ref=d79e91033770fc5a760d34511769f5ba6c872c77", "patch": "@@ -132,11 +132,9 @@ pub mod reader {\n     use std::char;\n \n     use std::isize;\n-    use std::old_io::extensions::u64_from_be_bytes;\n     use std::mem::transmute;\n     use std::num::Int;\n-    use std::option::Option;\n-    use std::option::Option::{None, Some};\n+    use std::slice::bytes;\n \n     use serialize;\n \n@@ -199,20 +197,24 @@ pub mod reader {\n             return vuint_at_slow(data, start);\n         }\n \n-        // Lookup table for parsing EBML Element IDs as per http://ebml.sourceforge.net/specs/\n-        // The Element IDs are parsed by reading a big endian u32 positioned at data[start].\n-        // Using the four most significant bits of the u32 we lookup in the table below how the\n-        // element ID should be derived from it.\n+        // Lookup table for parsing EBML Element IDs as per\n+        // http://ebml.sourceforge.net/specs/ The Element IDs are parsed by\n+        // reading a big endian u32 positioned at data[start].  Using the four\n+        // most significant bits of the u32 we lookup in the table below how\n+        // the element ID should be derived from it.\n         //\n-        // The table stores tuples (shift, mask) where shift is the number the u32 should be right\n-        // shifted with and mask is the value the right shifted value should be masked with.\n-        // If for example the most significant bit is set this means it's a class A ID and the u32\n-        // should be right shifted with 24 and masked with 0x7f. Therefore we store (24, 0x7f) at\n-        // index 0x8 - 0xF (four bit numbers where the most significant bit is set).\n+        // The table stores tuples (shift, mask) where shift is the number the\n+        // u32 should be right shifted with and mask is the value the right\n+        // shifted value should be masked with.  If for example the most\n+        // significant bit is set this means it's a class A ID and the u32\n+        // should be right shifted with 24 and masked with 0x7f. Therefore we\n+        // store (24, 0x7f) at index 0x8 - 0xF (four bit numbers where the most\n+        // significant bit is set).\n         //\n-        // By storing the number of shifts and masks in a table instead of checking in order if\n-        // the most significant bit is set, the second most significant bit is set etc. we can\n-        // replace up to three \"and+branch\" with a single table lookup which gives us a measured\n+        // By storing the number of shifts and masks in a table instead of\n+        // checking in order if the most significant bit is set, the second\n+        // most significant bit is set etc. we can replace up to three\n+        // \"and+branch\" with a single table lookup which gives us a measured\n         // speedup of around 2x on x86_64.\n         static SHIFT_MASK_TABLE: [(uint, u32); 16] = [\n             (0, 0x0), (0, 0x0fffffff),\n@@ -318,17 +320,23 @@ pub mod reader {\n \n     pub fn doc_as_u16(d: Doc) -> u16 {\n         assert_eq!(d.end, d.start + 2);\n-        u64_from_be_bytes(d.data, d.start, 2) as u16\n+        let mut b = [0; 2];\n+        bytes::copy_memory(&mut b, &d.data[d.start..d.end]);\n+        unsafe { (*(b.as_ptr() as *const u16)).to_be() }\n     }\n \n     pub fn doc_as_u32(d: Doc) -> u32 {\n         assert_eq!(d.end, d.start + 4);\n-        u64_from_be_bytes(d.data, d.start, 4) as u32\n+        let mut b = [0; 4];\n+        bytes::copy_memory(&mut b, &d.data[d.start..d.end]);\n+        unsafe { (*(b.as_ptr() as *const u32)).to_be() }\n     }\n \n     pub fn doc_as_u64(d: Doc) -> u64 {\n         assert_eq!(d.end, d.start + 8);\n-        u64_from_be_bytes(d.data, d.start, 8)\n+        let mut b = [0; 8];\n+        bytes::copy_memory(&mut b, &d.data[d.start..d.end]);\n+        unsafe { (*(b.as_ptr() as *const u64)).to_be() }\n     }\n \n     pub fn doc_as_i8(d: Doc) -> i8 { doc_as_u8(d) as i8 }\n@@ -689,11 +697,10 @@ pub mod reader {\n }\n \n pub mod writer {\n-    use std::clone::Clone;\n-    use std::old_io::extensions::u64_to_be_bytes;\n+    use std::mem;\n+    use std::num::Int;\n     use std::old_io::{Writer, Seek};\n     use std::old_io;\n-    use std::mem;\n \n     use super::{ EsVec, EsMap, EsEnum, EsVecLen, EsVecElt, EsMapLen, EsMapKey,\n         EsEnumVid, EsU64, EsU32, EsU16, EsU8, EsInt, EsI64, EsI32, EsI16, EsI8,\n@@ -794,43 +801,34 @@ pub mod writer {\n         }\n \n         pub fn wr_tagged_u64(&mut self, tag_id: uint, v: u64) -> EncodeResult {\n-            u64_to_be_bytes(v, 8, |v| {\n-                self.wr_tagged_bytes(tag_id, v)\n-            })\n+            let bytes: [u8; 8] = unsafe { mem::transmute(v.to_be()) };\n+            self.wr_tagged_bytes(tag_id, &bytes)\n         }\n \n         pub fn wr_tagged_u32(&mut self, tag_id: uint, v: u32)  -> EncodeResult{\n-            u64_to_be_bytes(v as u64, 4, |v| {\n-                self.wr_tagged_bytes(tag_id, v)\n-            })\n+            let bytes: [u8; 4] = unsafe { mem::transmute(v.to_be()) };\n+            self.wr_tagged_bytes(tag_id, &bytes)\n         }\n \n         pub fn wr_tagged_u16(&mut self, tag_id: uint, v: u16) -> EncodeResult {\n-            u64_to_be_bytes(v as u64, 2, |v| {\n-                self.wr_tagged_bytes(tag_id, v)\n-            })\n+            let bytes: [u8; 2] = unsafe { mem::transmute(v.to_be()) };\n+            self.wr_tagged_bytes(tag_id, &bytes)\n         }\n \n         pub fn wr_tagged_u8(&mut self, tag_id: uint, v: u8) -> EncodeResult {\n             self.wr_tagged_bytes(tag_id, &[v])\n         }\n \n         pub fn wr_tagged_i64(&mut self, tag_id: uint, v: i64) -> EncodeResult {\n-            u64_to_be_bytes(v as u64, 8, |v| {\n-                self.wr_tagged_bytes(tag_id, v)\n-            })\n+            self.wr_tagged_u64(tag_id, v as u64)\n         }\n \n         pub fn wr_tagged_i32(&mut self, tag_id: uint, v: i32) -> EncodeResult {\n-            u64_to_be_bytes(v as u64, 4, |v| {\n-                self.wr_tagged_bytes(tag_id, v)\n-            })\n+            self.wr_tagged_u32(tag_id, v as u32)\n         }\n \n         pub fn wr_tagged_i16(&mut self, tag_id: uint, v: i16) -> EncodeResult {\n-            u64_to_be_bytes(v as u64, 2, |v| {\n-                self.wr_tagged_bytes(tag_id, v)\n-            })\n+            self.wr_tagged_u16(tag_id, v as u16)\n         }\n \n         pub fn wr_tagged_i8(&mut self, tag_id: uint, v: i8) -> EncodeResult {"}, {"sha": "251c5e6eac70ebe7df5530dca754089ebb442a0b", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/d79e91033770fc5a760d34511769f5ba6c872c77/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d79e91033770fc5a760d34511769f5ba6c872c77/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=d79e91033770fc5a760d34511769f5ba6c872c77", "patch": "@@ -34,10 +34,11 @@ use middle::astencode::vtable_decoder_helpers;\n \n use std::collections::HashMap;\n use std::hash::{self, Hash, SipHasher};\n-use std::old_io::extensions::u64_from_be_bytes;\n-use std::old_io;\n use std::num::FromPrimitive;\n+use std::num::Int;\n+use std::old_io;\n use std::rc::Rc;\n+use std::slice::bytes;\n use std::str;\n \n use rbml::reader;\n@@ -60,20 +61,26 @@ pub type Cmd<'a> = &'a crate_metadata;\n // what crate that's in and give us a def_id that makes sense for the current\n // build.\n \n+fn u32_from_be_bytes(bytes: &[u8]) -> u32 {\n+    let mut b = [0; 4];\n+    bytes::copy_memory(&mut b, &bytes[..4]);\n+    unsafe { (*(b.as_ptr() as *const u32)).to_be() }\n+}\n+\n fn lookup_hash<'a, F>(d: rbml::Doc<'a>, mut eq_fn: F, hash: u64) -> Option<rbml::Doc<'a>> where\n     F: FnMut(&[u8]) -> bool,\n {\n     let index = reader::get_doc(d, tag_index);\n     let table = reader::get_doc(index, tag_index_table);\n     let hash_pos = table.start + (hash % 256 * 4) as uint;\n-    let pos = u64_from_be_bytes(d.data, hash_pos, 4) as uint;\n+    let pos = u32_from_be_bytes(&d.data[hash_pos..]) as uint;\n     let tagged_doc = reader::doc_at(d.data, pos).unwrap();\n \n     let belt = tag_index_buckets_bucket_elt;\n \n     let mut ret = None;\n     reader::tagged_docs(tagged_doc.doc, belt, |elt| {\n-        let pos = u64_from_be_bytes(elt.data, elt.start, 4) as uint;\n+        let pos = u32_from_be_bytes(&elt.data[elt.start..]) as uint;\n         if eq_fn(&elt.data[elt.start + 4 .. elt.end]) {\n             ret = Some(reader::doc_at(d.data, pos).unwrap().doc);\n             false\n@@ -87,9 +94,7 @@ fn lookup_hash<'a, F>(d: rbml::Doc<'a>, mut eq_fn: F, hash: u64) -> Option<rbml:\n pub fn maybe_find_item<'a>(item_id: ast::NodeId,\n                            items: rbml::Doc<'a>) -> Option<rbml::Doc<'a>> {\n     fn eq_item(bytes: &[u8], item_id: ast::NodeId) -> bool {\n-        return u64_from_be_bytes(\n-            &bytes[0..4], 0, 4) as ast::NodeId\n-            == item_id;\n+        u32_from_be_bytes(bytes) == item_id\n     }\n     lookup_hash(items,\n                 |a| eq_item(a, item_id),"}, {"sha": "45a86a9fde72c4322eb32eddd73f2a1b04e21451", "filename": "src/libstd/old_io/extensions.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d79e91033770fc5a760d34511769f5ba6c872c77/src%2Flibstd%2Fold_io%2Fextensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d79e91033770fc5a760d34511769f5ba6c872c77/src%2Flibstd%2Fold_io%2Fextensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fextensions.rs?ref=d79e91033770fc5a760d34511769f5ba6c872c77", "patch": "@@ -11,6 +11,10 @@\n //! Utility mixins that apply to all Readers and Writers\n \n #![allow(missing_docs)]\n+#![unstable(feature = \"old_io\")]\n+#![deprecated(since = \"1.0.0\",\n+              reason = \"functionality will be removed with no immediate \\\n+                        replacement\")]\n \n // FIXME: Not sure how this should be structured\n // FIXME: Iteration should probably be considered separately"}]}