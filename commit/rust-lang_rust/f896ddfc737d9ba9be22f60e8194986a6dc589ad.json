{"sha": "f896ddfc737d9ba9be22f60e8194986a6dc589ad", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY4OTZkZGZjNzM3ZDliYTliZTIyZjYwZTgxOTQ5ODZhNmRjNTg5YWQ=", "commit": {"author": {"name": "Nicholas-Baron", "email": "nicholas.baron.ten@gmail.com", "date": "2020-09-19T20:00:39Z"}, "committer": {"name": "Nicholas-Baron", "email": "nicholas.baron.ten@gmail.com", "date": "2020-09-21T01:58:32Z"}, "message": "Moved the Expectation enum to its own file", "tree": {"sha": "69b9e967a9888ffbd761758c695ca46b86809c70", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/69b9e967a9888ffbd761758c695ca46b86809c70"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f896ddfc737d9ba9be22f60e8194986a6dc589ad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f896ddfc737d9ba9be22f60e8194986a6dc589ad", "html_url": "https://github.com/rust-lang/rust/commit/f896ddfc737d9ba9be22f60e8194986a6dc589ad", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f896ddfc737d9ba9be22f60e8194986a6dc589ad/comments", "author": {"login": "Nicholas-Baron", "id": 35079404, "node_id": "MDQ6VXNlcjM1MDc5NDA0", "avatar_url": "https://avatars.githubusercontent.com/u/35079404?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nicholas-Baron", "html_url": "https://github.com/Nicholas-Baron", "followers_url": "https://api.github.com/users/Nicholas-Baron/followers", "following_url": "https://api.github.com/users/Nicholas-Baron/following{/other_user}", "gists_url": "https://api.github.com/users/Nicholas-Baron/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nicholas-Baron/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nicholas-Baron/subscriptions", "organizations_url": "https://api.github.com/users/Nicholas-Baron/orgs", "repos_url": "https://api.github.com/users/Nicholas-Baron/repos", "events_url": "https://api.github.com/users/Nicholas-Baron/events{/privacy}", "received_events_url": "https://api.github.com/users/Nicholas-Baron/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nicholas-Baron", "id": 35079404, "node_id": "MDQ6VXNlcjM1MDc5NDA0", "avatar_url": "https://avatars.githubusercontent.com/u/35079404?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nicholas-Baron", "html_url": "https://github.com/Nicholas-Baron", "followers_url": "https://api.github.com/users/Nicholas-Baron/followers", "following_url": "https://api.github.com/users/Nicholas-Baron/following{/other_user}", "gists_url": "https://api.github.com/users/Nicholas-Baron/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nicholas-Baron/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nicholas-Baron/subscriptions", "organizations_url": "https://api.github.com/users/Nicholas-Baron/orgs", "repos_url": "https://api.github.com/users/Nicholas-Baron/repos", "events_url": "https://api.github.com/users/Nicholas-Baron/events{/privacy}", "received_events_url": "https://api.github.com/users/Nicholas-Baron/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "428a8c6eae7eadc08e8048929050818829ea7b4d", "url": "https://api.github.com/repos/rust-lang/rust/commits/428a8c6eae7eadc08e8048929050818829ea7b4d", "html_url": "https://github.com/rust-lang/rust/commit/428a8c6eae7eadc08e8048929050818829ea7b4d"}], "stats": {"total": 230, "additions": 119, "deletions": 111}, "files": [{"sha": "fd6fe1406c8406d2d9f15c95184163845ea452a1", "filename": "compiler/rustc_typeck/src/check/expectation.rs", "status": "added", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/f896ddfc737d9ba9be22f60e8194986a6dc589ad/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpectation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f896ddfc737d9ba9be22f60e8194986a6dc589ad/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpectation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpectation.rs?ref=f896ddfc737d9ba9be22f60e8194986a6dc589ad", "patch": "@@ -0,0 +1,117 @@\n+use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n+use rustc_middle::ty::{self, Ty};\n+use rustc_span::{self, Span};\n+\n+use super::Expectation::*;\n+use super::FnCtxt;\n+\n+/// When type-checking an expression, we propagate downward\n+/// whatever type hint we are able in the form of an `Expectation`.\n+#[derive(Copy, Clone, Debug)]\n+pub enum Expectation<'tcx> {\n+    /// We know nothing about what type this expression should have.\n+    NoExpectation,\n+\n+    /// This expression should have the type given (or some subtype).\n+    ExpectHasType(Ty<'tcx>),\n+\n+    /// This expression will be cast to the `Ty`.\n+    ExpectCastableToType(Ty<'tcx>),\n+\n+    /// This rvalue expression will be wrapped in `&` or `Box` and coerced\n+    /// to `&Ty` or `Box<Ty>`, respectively. `Ty` is `[A]` or `Trait`.\n+    ExpectRvalueLikeUnsized(Ty<'tcx>),\n+}\n+\n+impl<'a, 'tcx> Expectation<'tcx> {\n+    // Disregard \"castable to\" expectations because they\n+    // can lead us astray. Consider for example `if cond\n+    // {22} else {c} as u8` -- if we propagate the\n+    // \"castable to u8\" constraint to 22, it will pick the\n+    // type 22u8, which is overly constrained (c might not\n+    // be a u8). In effect, the problem is that the\n+    // \"castable to\" expectation is not the tightest thing\n+    // we can say, so we want to drop it in this case.\n+    // The tightest thing we can say is \"must unify with\n+    // else branch\". Note that in the case of a \"has type\"\n+    // constraint, this limitation does not hold.\n+\n+    // If the expected type is just a type variable, then don't use\n+    // an expected type. Otherwise, we might write parts of the type\n+    // when checking the 'then' block which are incompatible with the\n+    // 'else' branch.\n+    pub(super) fn adjust_for_branches(&self, fcx: &FnCtxt<'a, 'tcx>) -> Expectation<'tcx> {\n+        match *self {\n+            ExpectHasType(ety) => {\n+                let ety = fcx.shallow_resolve(ety);\n+                if !ety.is_ty_var() { ExpectHasType(ety) } else { NoExpectation }\n+            }\n+            ExpectRvalueLikeUnsized(ety) => ExpectRvalueLikeUnsized(ety),\n+            _ => NoExpectation,\n+        }\n+    }\n+\n+    /// Provides an expectation for an rvalue expression given an *optional*\n+    /// hint, which is not required for type safety (the resulting type might\n+    /// be checked higher up, as is the case with `&expr` and `box expr`), but\n+    /// is useful in determining the concrete type.\n+    ///\n+    /// The primary use case is where the expected type is a fat pointer,\n+    /// like `&[isize]`. For example, consider the following statement:\n+    ///\n+    ///    let x: &[isize] = &[1, 2, 3];\n+    ///\n+    /// In this case, the expected type for the `&[1, 2, 3]` expression is\n+    /// `&[isize]`. If however we were to say that `[1, 2, 3]` has the\n+    /// expectation `ExpectHasType([isize])`, that would be too strong --\n+    /// `[1, 2, 3]` does not have the type `[isize]` but rather `[isize; 3]`.\n+    /// It is only the `&[1, 2, 3]` expression as a whole that can be coerced\n+    /// to the type `&[isize]`. Therefore, we propagate this more limited hint,\n+    /// which still is useful, because it informs integer literals and the like.\n+    /// See the test case `test/ui/coerce-expect-unsized.rs` and #20169\n+    /// for examples of where this comes up,.\n+    pub(super) fn rvalue_hint(fcx: &FnCtxt<'a, 'tcx>, ty: Ty<'tcx>) -> Expectation<'tcx> {\n+        match fcx.tcx.struct_tail_without_normalization(ty).kind() {\n+            ty::Slice(_) | ty::Str | ty::Dynamic(..) => ExpectRvalueLikeUnsized(ty),\n+            _ => ExpectHasType(ty),\n+        }\n+    }\n+\n+    // Resolves `expected` by a single level if it is a variable. If\n+    // there is no expected type or resolution is not possible (e.g.,\n+    // no constraints yet present), just returns `None`.\n+    fn resolve(self, fcx: &FnCtxt<'a, 'tcx>) -> Expectation<'tcx> {\n+        match self {\n+            NoExpectation => NoExpectation,\n+            ExpectCastableToType(t) => ExpectCastableToType(fcx.resolve_vars_if_possible(&t)),\n+            ExpectHasType(t) => ExpectHasType(fcx.resolve_vars_if_possible(&t)),\n+            ExpectRvalueLikeUnsized(t) => ExpectRvalueLikeUnsized(fcx.resolve_vars_if_possible(&t)),\n+        }\n+    }\n+\n+    pub(super) fn to_option(self, fcx: &FnCtxt<'a, 'tcx>) -> Option<Ty<'tcx>> {\n+        match self.resolve(fcx) {\n+            NoExpectation => None,\n+            ExpectCastableToType(ty) | ExpectHasType(ty) | ExpectRvalueLikeUnsized(ty) => Some(ty),\n+        }\n+    }\n+\n+    /// It sometimes happens that we want to turn an expectation into\n+    /// a **hard constraint** (i.e., something that must be satisfied\n+    /// for the program to type-check). `only_has_type` will return\n+    /// such a constraint, if it exists.\n+    pub(super) fn only_has_type(self, fcx: &FnCtxt<'a, 'tcx>) -> Option<Ty<'tcx>> {\n+        match self.resolve(fcx) {\n+            ExpectHasType(ty) => Some(ty),\n+            NoExpectation | ExpectCastableToType(_) | ExpectRvalueLikeUnsized(_) => None,\n+        }\n+    }\n+\n+    /// Like `only_has_type`, but instead of returning `None` if no\n+    /// hard constraint exists, creates a fresh type variable.\n+    pub(super) fn coercion_target_type(self, fcx: &FnCtxt<'a, 'tcx>, span: Span) -> Ty<'tcx> {\n+        self.only_has_type(fcx).unwrap_or_else(|| {\n+            fcx.next_ty_var(TypeVariableOrigin { kind: TypeVariableOriginKind::MiscVariable, span })\n+        })\n+    }\n+}"}, {"sha": "d45b51c42eae2353b88985a00db4a76bc80535f6", "filename": "compiler/rustc_typeck/src/check/mod.rs", "status": "modified", "additions": 2, "deletions": 111, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/f896ddfc737d9ba9be22f60e8194986a6dc589ad/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f896ddfc737d9ba9be22f60e8194986a6dc589ad/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs?ref=f896ddfc737d9ba9be22f60e8194986a6dc589ad", "patch": "@@ -72,6 +72,7 @@ mod compare_method;\n pub mod demand;\n mod diverges;\n pub mod dropck;\n+mod expectation;\n mod expr;\n mod fn_ctxt;\n mod gather_locals;\n@@ -88,6 +89,7 @@ mod wfcheck;\n pub mod writeback;\n \n pub use diverges::Diverges;\n+pub use expectation::Expectation;\n pub use fn_ctxt::FnCtxt;\n pub use inherited::{Inherited, InheritedBuilder};\n \n@@ -153,117 +155,6 @@ pub struct LocalTy<'tcx> {\n     revealed_ty: Ty<'tcx>,\n }\n \n-/// When type-checking an expression, we propagate downward\n-/// whatever type hint we are able in the form of an `Expectation`.\n-#[derive(Copy, Clone, Debug)]\n-pub enum Expectation<'tcx> {\n-    /// We know nothing about what type this expression should have.\n-    NoExpectation,\n-\n-    /// This expression should have the type given (or some subtype).\n-    ExpectHasType(Ty<'tcx>),\n-\n-    /// This expression will be cast to the `Ty`.\n-    ExpectCastableToType(Ty<'tcx>),\n-\n-    /// This rvalue expression will be wrapped in `&` or `Box` and coerced\n-    /// to `&Ty` or `Box<Ty>`, respectively. `Ty` is `[A]` or `Trait`.\n-    ExpectRvalueLikeUnsized(Ty<'tcx>),\n-}\n-\n-impl<'a, 'tcx> Expectation<'tcx> {\n-    // Disregard \"castable to\" expectations because they\n-    // can lead us astray. Consider for example `if cond\n-    // {22} else {c} as u8` -- if we propagate the\n-    // \"castable to u8\" constraint to 22, it will pick the\n-    // type 22u8, which is overly constrained (c might not\n-    // be a u8). In effect, the problem is that the\n-    // \"castable to\" expectation is not the tightest thing\n-    // we can say, so we want to drop it in this case.\n-    // The tightest thing we can say is \"must unify with\n-    // else branch\". Note that in the case of a \"has type\"\n-    // constraint, this limitation does not hold.\n-\n-    // If the expected type is just a type variable, then don't use\n-    // an expected type. Otherwise, we might write parts of the type\n-    // when checking the 'then' block which are incompatible with the\n-    // 'else' branch.\n-    fn adjust_for_branches(&self, fcx: &FnCtxt<'a, 'tcx>) -> Expectation<'tcx> {\n-        match *self {\n-            ExpectHasType(ety) => {\n-                let ety = fcx.shallow_resolve(ety);\n-                if !ety.is_ty_var() { ExpectHasType(ety) } else { NoExpectation }\n-            }\n-            ExpectRvalueLikeUnsized(ety) => ExpectRvalueLikeUnsized(ety),\n-            _ => NoExpectation,\n-        }\n-    }\n-\n-    /// Provides an expectation for an rvalue expression given an *optional*\n-    /// hint, which is not required for type safety (the resulting type might\n-    /// be checked higher up, as is the case with `&expr` and `box expr`), but\n-    /// is useful in determining the concrete type.\n-    ///\n-    /// The primary use case is where the expected type is a fat pointer,\n-    /// like `&[isize]`. For example, consider the following statement:\n-    ///\n-    ///    let x: &[isize] = &[1, 2, 3];\n-    ///\n-    /// In this case, the expected type for the `&[1, 2, 3]` expression is\n-    /// `&[isize]`. If however we were to say that `[1, 2, 3]` has the\n-    /// expectation `ExpectHasType([isize])`, that would be too strong --\n-    /// `[1, 2, 3]` does not have the type `[isize]` but rather `[isize; 3]`.\n-    /// It is only the `&[1, 2, 3]` expression as a whole that can be coerced\n-    /// to the type `&[isize]`. Therefore, we propagate this more limited hint,\n-    /// which still is useful, because it informs integer literals and the like.\n-    /// See the test case `test/ui/coerce-expect-unsized.rs` and #20169\n-    /// for examples of where this comes up,.\n-    fn rvalue_hint(fcx: &FnCtxt<'a, 'tcx>, ty: Ty<'tcx>) -> Expectation<'tcx> {\n-        match fcx.tcx.struct_tail_without_normalization(ty).kind() {\n-            ty::Slice(_) | ty::Str | ty::Dynamic(..) => ExpectRvalueLikeUnsized(ty),\n-            _ => ExpectHasType(ty),\n-        }\n-    }\n-\n-    // Resolves `expected` by a single level if it is a variable. If\n-    // there is no expected type or resolution is not possible (e.g.,\n-    // no constraints yet present), just returns `None`.\n-    fn resolve(self, fcx: &FnCtxt<'a, 'tcx>) -> Expectation<'tcx> {\n-        match self {\n-            NoExpectation => NoExpectation,\n-            ExpectCastableToType(t) => ExpectCastableToType(fcx.resolve_vars_if_possible(&t)),\n-            ExpectHasType(t) => ExpectHasType(fcx.resolve_vars_if_possible(&t)),\n-            ExpectRvalueLikeUnsized(t) => ExpectRvalueLikeUnsized(fcx.resolve_vars_if_possible(&t)),\n-        }\n-    }\n-\n-    fn to_option(self, fcx: &FnCtxt<'a, 'tcx>) -> Option<Ty<'tcx>> {\n-        match self.resolve(fcx) {\n-            NoExpectation => None,\n-            ExpectCastableToType(ty) | ExpectHasType(ty) | ExpectRvalueLikeUnsized(ty) => Some(ty),\n-        }\n-    }\n-\n-    /// It sometimes happens that we want to turn an expectation into\n-    /// a **hard constraint** (i.e., something that must be satisfied\n-    /// for the program to type-check). `only_has_type` will return\n-    /// such a constraint, if it exists.\n-    fn only_has_type(self, fcx: &FnCtxt<'a, 'tcx>) -> Option<Ty<'tcx>> {\n-        match self.resolve(fcx) {\n-            ExpectHasType(ty) => Some(ty),\n-            NoExpectation | ExpectCastableToType(_) | ExpectRvalueLikeUnsized(_) => None,\n-        }\n-    }\n-\n-    /// Like `only_has_type`, but instead of returning `None` if no\n-    /// hard constraint exists, creates a fresh type variable.\n-    fn coercion_target_type(self, fcx: &FnCtxt<'a, 'tcx>, span: Span) -> Ty<'tcx> {\n-        self.only_has_type(fcx).unwrap_or_else(|| {\n-            fcx.next_ty_var(TypeVariableOrigin { kind: TypeVariableOriginKind::MiscVariable, span })\n-        })\n-    }\n-}\n-\n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n pub enum Needs {\n     MutPlace,"}]}