{"sha": "d5c3808545e26d246d75e0754e81de803f9e53e6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ1YzM4MDg1NDVlMjZkMjQ2ZDc1ZTA3NTRlODFkZTgwM2Y5ZTUzZTY=", "commit": {"author": {"name": "Kirill Bulatov", "email": "mail4score@gmail.com", "date": "2020-02-11T16:24:43Z"}, "committer": {"name": "Kirill Bulatov", "email": "mail4score@gmail.com", "date": "2020-02-12T15:18:42Z"}, "message": "Support trait method call autoimports", "tree": {"sha": "caf2376b06ace612efb274312825251a2c2ab53c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/caf2376b06ace612efb274312825251a2c2ab53c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d5c3808545e26d246d75e0754e81de803f9e53e6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d5c3808545e26d246d75e0754e81de803f9e53e6", "html_url": "https://github.com/rust-lang/rust/commit/d5c3808545e26d246d75e0754e81de803f9e53e6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d5c3808545e26d246d75e0754e81de803f9e53e6/comments", "author": {"login": "SomeoneToIgnore", "id": 2690773, "node_id": "MDQ6VXNlcjI2OTA3NzM=", "avatar_url": "https://avatars.githubusercontent.com/u/2690773?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SomeoneToIgnore", "html_url": "https://github.com/SomeoneToIgnore", "followers_url": "https://api.github.com/users/SomeoneToIgnore/followers", "following_url": "https://api.github.com/users/SomeoneToIgnore/following{/other_user}", "gists_url": "https://api.github.com/users/SomeoneToIgnore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SomeoneToIgnore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SomeoneToIgnore/subscriptions", "organizations_url": "https://api.github.com/users/SomeoneToIgnore/orgs", "repos_url": "https://api.github.com/users/SomeoneToIgnore/repos", "events_url": "https://api.github.com/users/SomeoneToIgnore/events{/privacy}", "received_events_url": "https://api.github.com/users/SomeoneToIgnore/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SomeoneToIgnore", "id": 2690773, "node_id": "MDQ6VXNlcjI2OTA3NzM=", "avatar_url": "https://avatars.githubusercontent.com/u/2690773?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SomeoneToIgnore", "html_url": "https://github.com/SomeoneToIgnore", "followers_url": "https://api.github.com/users/SomeoneToIgnore/followers", "following_url": "https://api.github.com/users/SomeoneToIgnore/following{/other_user}", "gists_url": "https://api.github.com/users/SomeoneToIgnore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SomeoneToIgnore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SomeoneToIgnore/subscriptions", "organizations_url": "https://api.github.com/users/SomeoneToIgnore/orgs", "repos_url": "https://api.github.com/users/SomeoneToIgnore/repos", "events_url": "https://api.github.com/users/SomeoneToIgnore/events{/privacy}", "received_events_url": "https://api.github.com/users/SomeoneToIgnore/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8f959f20ee0fecd644054ffed334c378f9ae20f5", "url": "https://api.github.com/repos/rust-lang/rust/commits/8f959f20ee0fecd644054ffed334c378f9ae20f5", "html_url": "https://github.com/rust-lang/rust/commit/8f959f20ee0fecd644054ffed334c378f9ae20f5"}], "stats": {"total": 312, "additions": 211, "deletions": 101}, "files": [{"sha": "9a366414cabf3c6592e28c0a3ab4501928e982c8", "filename": "crates/ra_assists/src/handlers/auto_import.rs", "status": "modified", "additions": 206, "deletions": 100, "changes": 306, "blob_url": "https://github.com/rust-lang/rust/blob/d5c3808545e26d246d75e0754e81de803f9e53e6/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fauto_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5c3808545e26d246d75e0754e81de803f9e53e6/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fauto_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fauto_import.rs?ref=d5c3808545e26d246d75e0754e81de803f9e53e6", "patch": "@@ -1,15 +1,17 @@\n use ra_ide_db::{imports_locator::ImportsLocator, RootDatabase};\n-use ra_syntax::ast::{self, AstNode};\n+use ra_syntax::{\n+    ast::{self, AstNode},\n+    SyntaxNode,\n+};\n \n use crate::{\n     assist_ctx::{Assist, AssistCtx},\n     insert_use_statement, AssistId,\n };\n-use ast::{FnDefOwner, ModuleItem, ModuleItemOwner};\n use hir::{\n     db::{DefDatabase, HirDatabase},\n-    Adt, AssocContainerId, Crate, Function, HasSource, InFile, ModPath, Module, ModuleDef,\n-    PathResolution, SourceAnalyzer, SourceBinder, Trait,\n+    AssocContainerId, AssocItem, Crate, Function, ModPath, Module, ModuleDef, PathResolution,\n+    SourceAnalyzer, Trait, Type,\n };\n use rustc_hash::FxHashSet;\n use std::collections::BTreeSet;\n@@ -34,36 +36,28 @@ use std::collections::BTreeSet;\n // # pub mod std { pub mod collections { pub struct HashMap { } } }\n // ```\n pub(crate) fn auto_import(ctx: AssistCtx) -> Option<Assist> {\n-    let path_under_caret: ast::Path = ctx.find_node_at_offset()?;\n-    if path_under_caret.syntax().ancestors().find_map(ast::UseItem::cast).is_some() {\n-        return None;\n-    }\n-\n-    let module = path_under_caret.syntax().ancestors().find_map(ast::Module::cast);\n-    let position = match module.and_then(|it| it.item_list()) {\n-        Some(item_list) => item_list.syntax().clone(),\n-        None => {\n-            let current_file =\n-                path_under_caret.syntax().ancestors().find_map(ast::SourceFile::cast)?;\n-            current_file.syntax().clone()\n-        }\n+    let auto_import_assets = if let Some(path_under_caret) = ctx.find_node_at_offset::<ast::Path>()\n+    {\n+        AutoImportAssets::for_regular_path(path_under_caret, &ctx)?\n+    } else {\n+        AutoImportAssets::for_method_call(ctx.find_node_at_offset()?, &ctx)?\n     };\n-    let source_analyzer = ctx.source_analyzer(&position, None);\n-    let module_with_name_to_import = source_analyzer.module()?;\n \n-    let import_candidate = ImportCandidate::new(&path_under_caret, &source_analyzer, ctx.db)?;\n-    let proposed_imports = import_candidate.search_for_imports(ctx.db, module_with_name_to_import);\n+    let proposed_imports = auto_import_assets\n+        .search_for_imports(ctx.db, auto_import_assets.module_with_name_to_import);\n     if proposed_imports.is_empty() {\n         return None;\n     }\n \n-    let mut group = ctx.add_assist_group(format!(\"Import {}\", import_candidate.get_search_query()));\n+    let mut group =\n+        // TODO kb create another method and add something about traits there\n+        ctx.add_assist_group(format!(\"Import {}\", auto_import_assets.get_search_query()));\n     for import in proposed_imports {\n         group.add_assist(AssistId(\"auto_import\"), format!(\"Import `{}`\", &import), |edit| {\n-            edit.target(path_under_caret.syntax().text_range());\n+            edit.target(auto_import_assets.syntax_under_caret.text_range());\n             insert_use_statement(\n-                &position,\n-                path_under_caret.syntax(),\n+                &auto_import_assets.syntax_under_caret,\n+                &auto_import_assets.syntax_under_caret,\n                 &import,\n                 edit.text_edit_builder(),\n             );\n@@ -72,64 +66,55 @@ pub(crate) fn auto_import(ctx: AssistCtx) -> Option<Assist> {\n     group.finish()\n }\n \n-#[derive(Debug)]\n-// TODO kb rustdocs\n-enum ImportCandidate {\n-    UnqualifiedName(ast::NameRef),\n-    QualifierStart(ast::NameRef),\n-    TraitFunction(Adt, ast::PathSegment),\n+struct AutoImportAssets {\n+    import_candidate: ImportCandidate,\n+    module_with_name_to_import: Module,\n+    syntax_under_caret: SyntaxNode,\n }\n \n-impl ImportCandidate {\n-    // TODO kb refactor this mess\n-    fn new(\n-        path_under_caret: &ast::Path,\n-        source_analyzer: &SourceAnalyzer,\n-        db: &impl HirDatabase,\n-    ) -> Option<Self> {\n-        if source_analyzer.resolve_path(db, path_under_caret).is_some() {\n+impl AutoImportAssets {\n+    fn for_method_call(method_call: ast::MethodCallExpr, ctx: &AssistCtx) -> Option<Self> {\n+        let syntax_under_caret = method_call.syntax().to_owned();\n+        let source_analyzer = ctx.source_analyzer(&syntax_under_caret, None);\n+        let module_with_name_to_import = source_analyzer.module()?;\n+        Some(Self {\n+            import_candidate: ImportCandidate::for_method_call(\n+                &method_call,\n+                &source_analyzer,\n+                ctx.db,\n+            )?,\n+            module_with_name_to_import,\n+            syntax_under_caret,\n+        })\n+    }\n+\n+    fn for_regular_path(path_under_caret: ast::Path, ctx: &AssistCtx) -> Option<Self> {\n+        let syntax_under_caret = path_under_caret.syntax().to_owned();\n+        if syntax_under_caret.ancestors().find_map(ast::UseItem::cast).is_some() {\n             return None;\n         }\n \n-        let segment = path_under_caret.segment()?;\n-        if let Some(qualifier) = path_under_caret.qualifier() {\n-            let qualifier_start = qualifier.syntax().descendants().find_map(ast::NameRef::cast)?;\n-            let qualifier_start_path =\n-                qualifier_start.syntax().ancestors().find_map(ast::Path::cast)?;\n-            if let Some(qualifier_start_resolution) =\n-                source_analyzer.resolve_path(db, &qualifier_start_path)\n-            {\n-                let qualifier_resolution = if &qualifier_start_path == path_under_caret {\n-                    qualifier_start_resolution\n-                } else {\n-                    source_analyzer.resolve_path(db, &qualifier)?\n-                };\n-                if let PathResolution::Def(ModuleDef::Adt(function_callee)) = qualifier_resolution {\n-                    Some(ImportCandidate::TraitFunction(function_callee, segment))\n-                } else {\n-                    None\n-                }\n-            } else {\n-                Some(ImportCandidate::QualifierStart(qualifier_start))\n-            }\n-        } else {\n-            if source_analyzer.resolve_path(db, path_under_caret).is_none() {\n-                Some(ImportCandidate::UnqualifiedName(\n-                    segment.syntax().descendants().find_map(ast::NameRef::cast)?,\n-                ))\n-            } else {\n-                None\n-            }\n-        }\n+        let source_analyzer = ctx.source_analyzer(&syntax_under_caret, None);\n+        let module_with_name_to_import = source_analyzer.module()?;\n+        Some(Self {\n+            import_candidate: ImportCandidate::for_regular_path(\n+                &path_under_caret,\n+                &source_analyzer,\n+                ctx.db,\n+            )?,\n+            module_with_name_to_import,\n+            syntax_under_caret,\n+        })\n     }\n \n     fn get_search_query(&self) -> String {\n-        match self {\n+        match &self.import_candidate {\n             ImportCandidate::UnqualifiedName(name_ref)\n             | ImportCandidate::QualifierStart(name_ref) => name_ref.syntax().to_string(),\n             ImportCandidate::TraitFunction(_, trait_function) => {\n                 trait_function.syntax().to_string()\n             }\n+            ImportCandidate::TraitMethod(_, trait_method) => trait_method.syntax().to_string(),\n         }\n     }\n \n@@ -141,7 +126,7 @@ impl ImportCandidate {\n         ImportsLocator::new(db)\n             .find_imports(&self.get_search_query())\n             .into_iter()\n-            .map(|module_def| match self {\n+            .map(|module_def| match &self.import_candidate {\n                 ImportCandidate::TraitFunction(function_callee, _) => {\n                     let mut applicable_traits = Vec::new();\n                     if let ModuleDef::Function(located_function) = module_def {\n@@ -154,7 +139,7 @@ impl ImportCandidate {\n                         .map(|trait_candidate| trait_candidate.into())\n                         .collect();\n \n-                        function_callee.ty(db).iterate_path_candidates(\n+                        function_callee.iterate_path_candidates(\n                             db,\n                             module_with_name_to_import.krate(),\n                             &trait_candidates,\n@@ -172,6 +157,42 @@ impl ImportCandidate {\n                     }\n                     applicable_traits\n                 }\n+                ImportCandidate::TraitMethod(function_callee, _) => {\n+                    let mut applicable_traits = Vec::new();\n+                    if let ModuleDef::Function(located_function) = module_def {\n+                        let trait_candidates: FxHashSet<_> = Self::get_trait_candidates(\n+                            db,\n+                            located_function,\n+                            module_with_name_to_import.krate(),\n+                        )\n+                        .into_iter()\n+                        .map(|trait_candidate| trait_candidate.into())\n+                        .collect();\n+\n+                        if !trait_candidates.is_empty() {\n+                            function_callee.iterate_method_candidates(\n+                                db,\n+                                module_with_name_to_import.krate(),\n+                                &trait_candidates,\n+                                None,\n+                                |_, funciton| {\n+                                    if let AssocContainerId::TraitId(trait_id) =\n+                                        funciton.container(db)\n+                                    {\n+                                        applicable_traits.push(\n+                                            module_with_name_to_import.find_use_path(\n+                                                db,\n+                                                ModuleDef::Trait(trait_id.into()),\n+                                            ),\n+                                        );\n+                                    };\n+                                    None::<()>\n+                                },\n+                            );\n+                        }\n+                    }\n+                    applicable_traits\n+                }\n                 _ => vec![module_with_name_to_import.find_use_path(db, module_def)],\n             })\n             .flatten()\n@@ -186,7 +207,6 @@ impl ImportCandidate {\n         called_function: Function,\n         root_crate: Crate,\n     ) -> FxHashSet<Trait> {\n-        let mut source_binder = SourceBinder::new(db);\n         root_crate\n             .dependencies(db)\n             .into_iter()\n@@ -196,35 +216,95 @@ impl ImportCandidate {\n                 crate_def_map\n                     .modules\n                     .iter()\n-                    .filter_map(|(_, module_data)| module_data.declaration_source(db))\n-                    .filter_map(|in_file_module| {\n-                        Some((in_file_module.file_id, in_file_module.value.item_list()?.items()))\n-                    })\n-                    .map(|(file_id, item_list)| {\n-                        let mut if_file_trait_defs = Vec::new();\n-                        for module_item in item_list {\n-                            if let ModuleItem::TraitDef(trait_def) = module_item {\n-                                if let Some(item_list) = trait_def.item_list() {\n-                                    if item_list\n-                                        .functions()\n-                                        .any(|fn_def| fn_def == called_function.source(db).value)\n-                                    {\n-                                        if_file_trait_defs.push(InFile::new(file_id, trait_def))\n-                                    }\n+                    .map(|(_, module_data)| {\n+                        let mut traits = Vec::new();\n+                        for module_def_id in module_data.scope.declarations() {\n+                            if let ModuleDef::Trait(trait_candidate) = module_def_id.into() {\n+                                if trait_candidate\n+                                    .items(db)\n+                                    .into_iter()\n+                                    .any(|item| item == AssocItem::Function(called_function))\n+                                {\n+                                    traits.push(trait_candidate)\n                                 }\n                             }\n                         }\n-                        if_file_trait_defs\n+                        traits\n                     })\n                     .flatten()\n-                    .filter_map(|in_file_trait_def| source_binder.to_def(in_file_trait_def))\n                     .collect::<FxHashSet<_>>()\n             })\n             .flatten()\n             .collect()\n     }\n }\n \n+#[derive(Debug)]\n+// TODO kb rustdocs\n+enum ImportCandidate {\n+    UnqualifiedName(ast::NameRef),\n+    QualifierStart(ast::NameRef),\n+    TraitFunction(Type, ast::PathSegment),\n+    TraitMethod(Type, ast::NameRef),\n+}\n+\n+impl ImportCandidate {\n+    fn for_method_call(\n+        method_call: &ast::MethodCallExpr,\n+        source_analyzer: &SourceAnalyzer,\n+        db: &impl HirDatabase,\n+    ) -> Option<Self> {\n+        if source_analyzer.resolve_method_call(method_call).is_some() {\n+            return None;\n+        }\n+        Some(Self::TraitMethod(\n+            source_analyzer.type_of(db, &method_call.expr()?)?,\n+            method_call.name_ref()?,\n+        ))\n+    }\n+\n+    fn for_regular_path(\n+        path_under_caret: &ast::Path,\n+        source_analyzer: &SourceAnalyzer,\n+        db: &impl HirDatabase,\n+    ) -> Option<Self> {\n+        if source_analyzer.resolve_path(db, path_under_caret).is_some() {\n+            return None;\n+        }\n+\n+        let segment = path_under_caret.segment()?;\n+        if let Some(qualifier) = path_under_caret.qualifier() {\n+            let qualifier_start = qualifier.syntax().descendants().find_map(ast::NameRef::cast)?;\n+            let qualifier_start_path =\n+                qualifier_start.syntax().ancestors().find_map(ast::Path::cast)?;\n+            if let Some(qualifier_start_resolution) =\n+                source_analyzer.resolve_path(db, &qualifier_start_path)\n+            {\n+                let qualifier_resolution = if &qualifier_start_path == path_under_caret {\n+                    qualifier_start_resolution\n+                } else {\n+                    source_analyzer.resolve_path(db, &qualifier)?\n+                };\n+                if let PathResolution::Def(ModuleDef::Adt(function_callee)) = qualifier_resolution {\n+                    Some(ImportCandidate::TraitFunction(function_callee.ty(db), segment))\n+                } else {\n+                    None\n+                }\n+            } else {\n+                Some(ImportCandidate::QualifierStart(qualifier_start))\n+            }\n+        } else {\n+            if source_analyzer.resolve_path(db, path_under_caret).is_none() {\n+                Some(ImportCandidate::UnqualifiedName(\n+                    segment.syntax().descendants().find_map(ast::NameRef::cast)?,\n+                ))\n+            } else {\n+                None\n+            }\n+        }\n+    }\n+}\n+\n #[cfg(test)]\n mod tests {\n     use crate::helpers::{check_assist, check_assist_not_applicable, check_assist_target};\n@@ -525,32 +605,25 @@ mod tests {\n     }\n \n     #[test]\n-    fn not_applicable_for_imported_trait() {\n+    fn not_applicable_for_imported_trait_for_function() {\n         check_assist_not_applicable(\n             auto_import,\n             r\"\n             mod test_mod {\n                 pub trait TestTrait {\n-                    fn test_method(&self);\n                     fn test_function();\n                 }\n-\n                 pub trait TestTrait2 {\n-                    fn test_method(&self);\n                     fn test_function();\n                 }\n                 pub enum TestEnum {\n                     One,\n                     Two,\n                 }\n-\n                 impl TestTrait2 for TestEnum {\n-                    fn test_method(&self) {}\n                     fn test_function() {}\n                 }\n-\n                 impl TestTrait for TestEnum {\n-                    fn test_method(&self) {}\n                     fn test_function() {}\n                 }\n             }\n@@ -580,7 +653,7 @@ mod tests {\n \n             fn main() {\n                 let test_struct = test_mod::TestStruct {};\n-                test_struct.test_method<|>\n+                test_struct.test_meth<|>od()\n             }\n             \",\n             r\"\n@@ -598,9 +671,42 @@ mod tests {\n \n             fn main() {\n                 let test_struct = test_mod::TestStruct {};\n-                test_struct.test_method<|>\n+                test_struct.test_meth<|>od()\n             }\n             \",\n         );\n     }\n+\n+    #[test]\n+    fn not_applicable_for_imported_trait_for_method() {\n+        check_assist_not_applicable(\n+            auto_import,\n+            r\"\n+            mod test_mod {\n+                pub trait TestTrait {\n+                    fn test_method(&self);\n+                }\n+                pub trait TestTrait2 {\n+                    fn test_method(&self);\n+                }\n+                pub enum TestEnum {\n+                    One,\n+                    Two,\n+                }\n+                impl TestTrait2 for TestEnum {\n+                    fn test_method(&self) {}\n+                }\n+                impl TestTrait for TestEnum {\n+                    fn test_method(&self) {}\n+                }\n+            }\n+\n+            use test_mod::TestTrait2;\n+            fn main() {\n+                let one = test_mod::TestEnum::One;\n+                one.test<|>_method();\n+            }\n+            \",\n+        )\n+    }\n }"}, {"sha": "140b3a87f1cfcbe2aa21f3a0c718ed8639cc0ef2", "filename": "crates/ra_hir/src/code_model.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d5c3808545e26d246d75e0754e81de803f9e53e6/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5c3808545e26d246d75e0754e81de803f9e53e6/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model.rs?ref=d5c3808545e26d246d75e0754e81de803f9e53e6", "patch": "@@ -548,6 +548,10 @@ impl Function {\n         let mut validator = ExprValidator::new(self.id, infer, sink);\n         validator.validate_body(db);\n     }\n+\n+    pub fn container(self, db: &impl DefDatabase) -> AssocContainerId {\n+        self.id.lookup(db).container\n+    }\n }\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n@@ -699,7 +703,7 @@ impl AssocItem {\n \n     pub fn container(self, db: &impl DefDatabase) -> AssocContainerId {\n         match self {\n-            AssocItem::Function(f) => f.id.lookup(db).container,\n+            AssocItem::Function(f) => f.container(db),\n             AssocItem::Const(c) => c.id.lookup(db).container,\n             AssocItem::TypeAlias(t) => t.id.lookup(db).container,\n         }"}]}