{"sha": "ef9ae8581ff17dd88eb0260076bfe80d8d9c4aba", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVmOWFlODU4MWZmMTdkZDg4ZWIwMjYwMDc2YmZlODBkOGQ5YzRhYmE=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-02-03T11:08:16Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-02-03T11:08:27Z"}, "message": "make dirty process O(dirty)\n\nThe old algorithm was O(graph)", "tree": {"sha": "fd1a042c8f82aa093811051fbde48136723516a2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fd1a042c8f82aa093811051fbde48136723516a2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ef9ae8581ff17dd88eb0260076bfe80d8d9c4aba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ef9ae8581ff17dd88eb0260076bfe80d8d9c4aba", "html_url": "https://github.com/rust-lang/rust/commit/ef9ae8581ff17dd88eb0260076bfe80d8d9c4aba", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ef9ae8581ff17dd88eb0260076bfe80d8d9c4aba/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d848f1d7821a22ec2462e08401f966074041c324", "url": "https://api.github.com/repos/rust-lang/rust/commits/d848f1d7821a22ec2462e08401f966074041c324", "html_url": "https://github.com/rust-lang/rust/commit/d848f1d7821a22ec2462e08401f966074041c324"}], "stats": {"total": 116, "additions": 66, "deletions": 50}, "files": [{"sha": "60f24b71de2452eb3660dfcb9f743153837d6e7f", "filename": "src/librustc_incremental/persist/data.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ef9ae8581ff17dd88eb0260076bfe80d8d9c4aba/src%2Flibrustc_incremental%2Fpersist%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef9ae8581ff17dd88eb0260076bfe80d8d9c4aba/src%2Flibrustc_incremental%2Fpersist%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdata.rs?ref=ef9ae8581ff17dd88eb0260076bfe80d8d9c4aba", "patch": "@@ -21,7 +21,7 @@ use super::directory::DefPathIndex;\n /// Data for use when recompiling the **current crate**.\n #[derive(Debug, RustcEncodable, RustcDecodable)]\n pub struct SerializedDepGraph {\n-    pub edges: Vec<SerializedEdge>,\n+    pub edges: Vec<SerializedEdgeSet>,\n \n     /// These are hashes of two things:\n     /// - the HIR nodes in this crate\n@@ -45,14 +45,13 @@ pub struct SerializedDepGraph {\n     pub hashes: Vec<SerializedHash>,\n }\n \n-/// Represents a \"reduced\" dependency edge. Unlike the full dep-graph,\n-/// the dep-graph we serialize contains only edges `S -> T` where the\n-/// source `S` is something hashable (a HIR node or foreign metadata)\n-/// and the target `T` is something significant, like a work-product.\n-/// Normally, significant nodes are only those that have saved data on\n-/// disk, but in unit-testing the set of significant nodes can be\n-/// increased.\n-pub type SerializedEdge = (DepNode<DefPathIndex>, DepNode<DefPathIndex>);\n+/// Represents a set of \"reduced\" dependency edge. We group the\n+/// outgoing edges from a single source together.\n+#[derive(Debug, RustcEncodable, RustcDecodable)]\n+pub struct SerializedEdgeSet {\n+    pub source: DepNode<DefPathIndex>,\n+    pub targets: Vec<DepNode<DefPathIndex>>\n+}\n \n #[derive(Debug, RustcEncodable, RustcDecodable)]\n pub struct SerializedHash {"}, {"sha": "b371ab6aa31bc1ac05080e4e52f4fb6c0758df1e", "filename": "src/librustc_incremental/persist/load.rs", "status": "modified", "additions": 53, "deletions": 39, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/ef9ae8581ff17dd88eb0260076bfe80d8d9c4aba/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef9ae8581ff17dd88eb0260076bfe80d8d9c4aba/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fload.rs?ref=ef9ae8581ff17dd88eb0260076bfe80d8d9c4aba", "patch": "@@ -152,6 +152,11 @@ pub fn decode_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let directory = DefIdDirectory::decode(&mut dep_graph_decoder)?;\n     let serialized_dep_graph = SerializedDepGraph::decode(&mut dep_graph_decoder)?;\n \n+    let edge_map: FxHashMap<_, _> = serialized_dep_graph.edges\n+                                                        .into_iter()\n+                                                        .map(|s| (s.source, s.targets))\n+                                                        .collect();\n+\n     // Retrace the paths in the directory to find their current location (if any).\n     let retraced = directory.retrace(tcx);\n \n@@ -166,46 +171,48 @@ pub fn decode_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                               incremental_hashes_map,\n                                               &serialized_dep_graph.hashes,\n                                               &retraced);\n-    let dirty_raw_nodes = transitive_dirty_nodes(&serialized_dep_graph.edges, dirty_raw_nodes);\n+    let dirty_raw_nodes = transitive_dirty_nodes(&edge_map, dirty_raw_nodes);\n \n     // Recreate the edges in the graph that are still clean.\n     let mut clean_work_products = FxHashSet();\n     let mut dirty_work_products = FxHashSet(); // incomplete; just used to suppress debug output\n-    for edge in &serialized_dep_graph.edges {\n-        // If the target is dirty, skip the edge. If this is an edge\n-        // that targets a work-product, we can print the blame\n-        // information now.\n-        if let Some(blame) = dirty_raw_nodes.get(&edge.1) {\n-            if let DepNode::WorkProduct(ref wp) = edge.1 {\n-                if tcx.sess.opts.debugging_opts.incremental_info {\n-                    if dirty_work_products.insert(wp.clone()) {\n-                        // It'd be nice to pretty-print these paths better than just\n-                        // using the `Debug` impls, but wev.\n-                        println!(\"incremental: module {:?} is dirty because {:?} \\\n-                                  changed or was removed\",\n-                                 wp,\n-                                 blame.map_def(|&index| {\n-                                     Some(directory.def_path_string(tcx, index))\n-                                 }).unwrap());\n+    for (source, targets) in &edge_map {\n+        for target in targets {\n+            // If the target is dirty, skip the edge. If this is an edge\n+            // that targets a work-product, we can print the blame\n+            // information now.\n+            if let Some(blame) = dirty_raw_nodes.get(target) {\n+                if let DepNode::WorkProduct(ref wp) = *target {\n+                    if tcx.sess.opts.debugging_opts.incremental_info {\n+                        if dirty_work_products.insert(wp.clone()) {\n+                            // It'd be nice to pretty-print these paths better than just\n+                            // using the `Debug` impls, but wev.\n+                            println!(\"incremental: module {:?} is dirty because {:?} \\\n+                                      changed or was removed\",\n+                                     wp,\n+                                     blame.map_def(|&index| {\n+                                         Some(directory.def_path_string(tcx, index))\n+                                     }).unwrap());\n+                        }\n                     }\n                 }\n+                continue;\n             }\n-            continue;\n-        }\n \n-        // If the source is dirty, the target will be dirty.\n-        assert!(!dirty_raw_nodes.contains_key(&edge.0));\n-\n-        // Retrace the source -> target edges to def-ids and then\n-        // create an edge in the graph. Retracing may yield none if\n-        // some of the data happens to have been removed; this ought\n-        // to be impossible unless it is dirty, so we can unwrap.\n-        let source_node = retraced.map(&edge.0).unwrap();\n-        let target_node = retraced.map(&edge.1).unwrap();\n-        let _task = tcx.dep_graph.in_task(target_node);\n-        tcx.dep_graph.read(source_node);\n-        if let DepNode::WorkProduct(ref wp) = edge.1 {\n-            clean_work_products.insert(wp.clone());\n+            // If the source is dirty, the target will be dirty.\n+            assert!(!dirty_raw_nodes.contains_key(source));\n+\n+            // Retrace the source -> target edges to def-ids and then\n+            // create an edge in the graph. Retracing may yield none if\n+            // some of the data happens to have been removed; this ought\n+            // to be impossible unless it is dirty, so we can unwrap.\n+            let source_node = retraced.map(source).unwrap();\n+            let target_node = retraced.map(target).unwrap();\n+            let _task = tcx.dep_graph.in_task(target_node);\n+            tcx.dep_graph.read(source_node);\n+            if let DepNode::WorkProduct(ref wp) = *target {\n+                clean_work_products.insert(wp.clone());\n+            }\n         }\n     }\n \n@@ -268,16 +275,23 @@ fn initial_dirty_nodes<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     dirty_nodes\n }\n \n-fn transitive_dirty_nodes(edges: &[SerializedEdge],\n+fn transitive_dirty_nodes(edge_map: &FxHashMap<DepNode<DefPathIndex>, Vec<DepNode<DefPathIndex>>>,\n                           mut dirty_nodes: DirtyNodes)\n                           -> DirtyNodes\n {\n-    let mut len = 0;\n-    while len != dirty_nodes.len() {\n-        len = dirty_nodes.len();\n-        for edge in edges {\n-            if let Some(n) = dirty_nodes.get(&edge.0).cloned() {\n-                dirty_nodes.insert(edge.1.clone(), n);\n+    let mut stack: Vec<(DepNode<DefPathIndex>, DepNode<DefPathIndex>)> = vec![];\n+    stack.extend(dirty_nodes.iter().map(|(s, b)| (s.clone(), b.clone())));\n+    while let Some((source, blame)) = stack.pop() {\n+        // we know the source is dirty (because of the node `blame`)...\n+        assert!(dirty_nodes.contains_key(&source));\n+\n+        // ...so we dirty all the targets (with the same blame)\n+        if let Some(targets) = edge_map.get(&source) {\n+            for target in targets {\n+                if !dirty_nodes.contains_key(target) {\n+                    dirty_nodes.insert(target.clone(), blame.clone());\n+                    stack.push((target.clone(), blame.clone()));\n+                }\n             }\n         }\n     }"}, {"sha": "93600631b8d3ef743f9212ddf859f35aa3f2343d", "filename": "src/librustc_incremental/persist/save.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ef9ae8581ff17dd88eb0260076bfe80d8d9c4aba/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef9ae8581ff17dd88eb0260076bfe80d8d9c4aba/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs?ref=ef9ae8581ff17dd88eb0260076bfe80d8d9c4aba", "patch": "@@ -178,7 +178,7 @@ pub fn encode_dep_graph(preds: &Predecessors,\n \n     // Create a flat list of (Input, WorkProduct) edges for\n     // serialization.\n-    let mut edges = vec![];\n+    let mut edges = FxHashMap();\n     for edge in preds.reduced_graph.all_edges() {\n         let source = *preds.reduced_graph.node_data(edge.source());\n         let target = *preds.reduced_graph.node_data(edge.target());\n@@ -194,7 +194,7 @@ pub fn encode_dep_graph(preds: &Predecessors,\n         debug!(\"serialize edge: {:?} -> {:?}\", source, target);\n         let source = builder.map(source);\n         let target = builder.map(target);\n-        edges.push((source, target));\n+        edges.entry(source).or_insert(vec![]).push(target);\n     }\n \n     if tcx.sess.opts.debugging_opts.incremental_dump_hash {\n@@ -204,6 +204,9 @@ pub fn encode_dep_graph(preds: &Predecessors,\n     }\n \n     // Create the serialized dep-graph.\n+    let edges = edges.into_iter()\n+                     .map(|(k, v)| SerializedEdgeSet { source: k, targets: v })\n+                     .collect();\n     let graph = SerializedDepGraph {\n         edges: edges,\n         hashes: preds.hashes"}]}