{"sha": "4aba7de2a77a95e2032eaf438e2e11b8e1a5eb82", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRhYmE3ZGUyYTc3YTk1ZTIwMzJlYWY0MzhlMmUxMWI4ZTFhNWViODI=", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2018-07-29T13:39:51Z"}, "committer": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2018-08-04T09:02:00Z"}, "message": "Clean generic impls code", "tree": {"sha": "bad80df10e56aed6e6a6ee07335fa3b47a043b5e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bad80df10e56aed6e6a6ee07335fa3b47a043b5e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4aba7de2a77a95e2032eaf438e2e11b8e1a5eb82", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4aba7de2a77a95e2032eaf438e2e11b8e1a5eb82", "html_url": "https://github.com/rust-lang/rust/commit/4aba7de2a77a95e2032eaf438e2e11b8e1a5eb82", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4aba7de2a77a95e2032eaf438e2e11b8e1a5eb82/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "579adf8c727861841b4819b4913385c2782977fb", "url": "https://api.github.com/repos/rust-lang/rust/commits/579adf8c727861841b4819b4913385c2782977fb", "html_url": "https://github.com/rust-lang/rust/commit/579adf8c727861841b4819b4913385c2782977fb"}], "stats": {"total": 943, "additions": 508, "deletions": 435}, "files": [{"sha": "61fd5eefa8cb1dbbd7532d18c3012a84bd9926c0", "filename": "src/Cargo.lock", "status": "modified", "additions": 41, "deletions": 122, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/4aba7de2a77a95e2032eaf438e2e11b8e1a5eb82/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/4aba7de2a77a95e2032eaf438e2e11b8e1a5eb82/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=4aba7de2a77a95e2032eaf438e2e11b8e1a5eb82", "patch": "@@ -226,7 +226,7 @@ dependencies = [\n  \"clap 2.32.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"core-foundation 0.6.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"crates-io 0.18.0\",\n- \"crossbeam-utils 0.5.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"crossbeam 0.3.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"crypto-hash 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"curl 0.4.13 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"env_logger 0.5.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -247,8 +247,8 @@ dependencies = [\n  \"libgit2-sys 0.7.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"miow 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"num-traits 0.2.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"num_cpus 1.8.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-workspace-hack 1.0.0\",\n  \"rustfix 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"same-file 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"semver 0.9.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -351,18 +351,20 @@ name = \"clippy\"\n version = \"0.0.212\"\n dependencies = [\n  \"ansi_term 0.11.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"backtrace 0.3.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"cargo_metadata 0.5.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"clippy-mini-macro-test 0.2.0\",\n  \"clippy_lints 0.0.212\",\n  \"compiletest_rs 0.3.13 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"derive-new 0.5.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"lazy_static 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"num-traits 0.2.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"regex 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-workspace-hack 1.0.0\",\n  \"rustc_version 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"semver 0.9.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde 1.0.70 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_derive 1.0.70 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"winapi 0.3.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -604,11 +606,6 @@ name = \"crossbeam-utils\"\n version = \"0.4.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n-[[package]]\n-name = \"crossbeam-utils\"\n-version = \"0.5.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-\n [[package]]\n name = \"crypto-hash\"\n version = \"0.3.1\"\n@@ -1794,8 +1791,7 @@ dependencies = [\n  \"rls-rustc 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rls-span 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rls-vfs 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-workspace-hack 1.0.0\",\n- \"rustfmt-nightly 0.9.0\",\n+ \"rustfmt-nightly 0.9.0 (git+https://github.com/rust-lang-nursery/rustfmt?rev=7e3dc8fae7ed84cc1879ef4e0bc6f00dfe059e1b)\",\n  \"serde 1.0.70 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_derive 1.0.70 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_json 1.0.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1853,6 +1849,7 @@ name = \"rls-vfs\"\n version = \"0.4.6\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n+ \"racer 2.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rls-span 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -1903,14 +1900,6 @@ dependencies = [\n  \"rustc-ap-rustc_data_structures 209.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n-[[package]]\n-name = \"rustc-ap-arena\"\n-version = \"211.0.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-dependencies = [\n- \"rustc-ap-rustc_data_structures 211.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n-\n [[package]]\n name = \"rustc-ap-rustc_cratesio_shim\"\n version = \"209.0.0\"\n@@ -1920,15 +1909,6 @@ dependencies = [\n  \"log 0.4.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n-[[package]]\n-name = \"rustc-ap-rustc_cratesio_shim\"\n-version = \"211.0.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-dependencies = [\n- \"bitflags 1.0.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"log 0.4.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n-\n [[package]]\n name = \"rustc-ap-rustc_data_structures\"\n version = \"209.0.0\"\n@@ -1947,24 +1927,6 @@ dependencies = [\n  \"stable_deref_trait 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n-[[package]]\n-name = \"rustc-ap-rustc_data_structures\"\n-version = \"211.0.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-dependencies = [\n- \"cfg-if 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"ena 0.9.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"log 0.4.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"parking_lot 0.5.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"parking_lot_core 0.2.14 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-rustc_cratesio_shim 211.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-serialize 211.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-hash 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-rayon 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-rayon-core 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"stable_deref_trait 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n-\n [[package]]\n name = \"rustc-ap-rustc_errors\"\n version = \"209.0.0\"\n@@ -1978,19 +1940,6 @@ dependencies = [\n  \"unicode-width 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n-[[package]]\n-name = \"rustc-ap-rustc_errors\"\n-version = \"211.0.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-dependencies = [\n- \"atty 0.2.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-rustc_data_structures 211.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-serialize 211.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-syntax_pos 211.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"termcolor 0.3.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"unicode-width 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n-\n [[package]]\n name = \"rustc-ap-rustc_target\"\n version = \"209.0.0\"\n@@ -2002,27 +1951,11 @@ dependencies = [\n  \"rustc-ap-serialize 209.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n-[[package]]\n-name = \"rustc-ap-rustc_target\"\n-version = \"211.0.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-dependencies = [\n- \"bitflags 1.0.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"log 0.4.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-rustc_cratesio_shim 211.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-serialize 211.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n-\n [[package]]\n name = \"rustc-ap-serialize\"\n version = \"209.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n-[[package]]\n-name = \"rustc-ap-serialize\"\n-version = \"211.0.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-\n [[package]]\n name = \"rustc-ap-syntax\"\n version = \"209.0.0\"\n@@ -2038,21 +1971,6 @@ dependencies = [\n  \"scoped-tls 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n-[[package]]\n-name = \"rustc-ap-syntax\"\n-version = \"211.0.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-dependencies = [\n- \"bitflags 1.0.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"log 0.4.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-rustc_data_structures 211.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-rustc_errors 211.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-rustc_target 211.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-serialize 211.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-syntax_pos 211.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"scoped-tls 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n-\n [[package]]\n name = \"rustc-ap-syntax_pos\"\n version = \"209.0.0\"\n@@ -2066,19 +1984,6 @@ dependencies = [\n  \"unicode-width 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n-[[package]]\n-name = \"rustc-ap-syntax_pos\"\n-version = \"211.0.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-dependencies = [\n- \"cfg-if 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-arena 211.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-rustc_data_structures 211.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-serialize 211.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"scoped-tls 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"unicode-width 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n-\n [[package]]\n name = \"rustc-demangle\"\n version = \"0.1.8\"\n@@ -2126,14 +2031,6 @@ name = \"rustc-serialize\"\n version = \"0.3.24\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n-[[package]]\n-name = \"rustc-workspace-hack\"\n-version = \"1.0.0\"\n-dependencies = [\n- \"syn 0.14.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"winapi 0.3.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n-\n [[package]]\n name = \"rustc_allocator\"\n version = \"0.0.0\"\n@@ -2564,6 +2461,32 @@ dependencies = [\n  \"serde_json 1.0.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"rustfmt-nightly\"\n+version = \"0.9.0\"\n+source = \"git+https://github.com/rust-lang-nursery/rustfmt?rev=7e3dc8fae7ed84cc1879ef4e0bc6f00dfe059e1b#7e3dc8fae7ed84cc1879ef4e0bc6f00dfe059e1b\"\n+dependencies = [\n+ \"cargo_metadata 0.6.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"derive-new 0.5.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"diff 0.1.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"env_logger 0.5.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"failure 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"getopts 0.2.17 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"isatty 0.1.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"itertools 0.7.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"log 0.4.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"regex 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-rustc_target 209.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-syntax 209.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-syntax_pos 209.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.70 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_derive 1.0.70 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_json 1.0.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"term 0.5.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"toml 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"unicode-segmentation 1.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"rustfmt-nightly\"\n version = \"0.9.0\"\n@@ -2580,9 +2503,9 @@ dependencies = [\n  \"lazy_static 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"regex 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-rustc_target 211.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-syntax 211.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-syntax_pos 211.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-rustc_target 209.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-syntax 209.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-syntax_pos 209.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde 1.0.70 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_derive 1.0.70 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_json 1.0.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -3197,6 +3120,10 @@ name = \"yaml-rust\"\n version = \"0.3.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n+[[patch.unused]]\n+name = \"rustc-workspace-hack\"\n+version = \"1.0.0\"\n+\n [metadata]\n \"checksum aho-corasick 0.6.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"c1c6d463cbe7ed28720b5b489e7c083eeb8f90d08be2a0d6bb9e1ffea9ce1afa\"\n \"checksum ammonia 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"fd4c682378117e4186a492b2252b9537990e1617f44aed9788b9a1149de45477\"\n@@ -3237,7 +3164,6 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum crossbeam-epoch 0.5.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"285987a59c4d91388e749850e3cb7b3a92299668528caaacd08005b8f238c0ea\"\n \"checksum crossbeam-utils 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"2760899e32a1d58d5abb31129f8fae5de75220bc2176e77ff7c627ae45c918d9\"\n \"checksum crossbeam-utils 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ea52fab26a99d96cdff39d0ca75c9716125937f5dba2ab83923aaaf5928f684a\"\n-\"checksum crossbeam-utils 0.5.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"677d453a17e8bd2b913fa38e8b9cf04bcdbb5be790aa294f2389661d72036015\"\n \"checksum crypto-hash 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"09de9ee0fc255ace04c7fa0763c9395a945c37c8292bb554f8d48361d1dcf1b4\"\n \"checksum curl 0.4.13 (registry+https://github.com/rust-lang/crates.io-index)\" = \"893713db705eab9847e050268507b0e2a2aad64e90a831874bd4e8e0d67f9523\"\n \"checksum curl-sys 0.4.7 (registry+https://github.com/rust-lang/crates.io-index)\" = \"de9cf174efdf90b5887c4e2e900769373c89c5e18152e8f3ed75b501a6f1c0fb\"\n@@ -3367,28 +3293,21 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum rls-span 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"5d7c7046dc6a92f2ae02ed302746db4382e75131b9ce20ce967259f6b5867a6a\"\n \"checksum rls-vfs 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ecbc8541b4c341d6271eae10f869dd9d36db871afe184f5b6f9bffbd6ed0373f\"\n \"checksum rustc-ap-arena 209.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"b098827864368459cbc7a79fbc54eafb92df7e00a46c0cda352b5a21583ee436\"\n-\"checksum rustc-ap-arena 211.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"eec75ed880706dd9a05bc770c327ed142fa7d4b648d9757fbc71d821d68448a5\"\n \"checksum rustc-ap-rustc_cratesio_shim 209.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ef4d923dea14fb085bca743fb982f6a3bc11c0d5d30b822bcf6fa16e9464a56c\"\n-\"checksum rustc-ap-rustc_cratesio_shim 211.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0f5d54615bedbae65a976e0835edf0de90dd962ec818c0149fe181d5cd81da9e\"\n \"checksum rustc-ap-rustc_data_structures 209.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"18c6a5c9edc6b4ae035cdc03af7d8662d39fad7879c5501d103e7087dfaebc80\"\n-\"checksum rustc-ap-rustc_data_structures 211.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e7c51cc6e79eab25c7ea84a7e104e81e6f44cca32709df54c2cdb4e7059d7843\"\n \"checksum rustc-ap-rustc_errors 209.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"9a1e9bdc597abd95cebce0c14c1da58943a9e5b8255530a0fec30659d144eb0b\"\n-\"checksum rustc-ap-rustc_errors 211.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ff050095b7afb254506591ee7d3a5d0fb9c03c16f8c2741b588178085e563d49\"\n \"checksum rustc-ap-rustc_target 209.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"142ddef3dc12dda2bcd3412f0d96d3745413a8fbc2f224f0cc97afa04c071d89\"\n-\"checksum rustc-ap-rustc_target 211.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"53c7a8c21c3b05f24998fa6ab9ded6269810a2f3ae12ff301c432c1e9fa8e111\"\n \"checksum rustc-ap-serialize 209.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8b08f8f175b038a82caa7e51fc52b72ff96cfe8c1429755da30380dbd4199c7f\"\n-\"checksum rustc-ap-serialize 211.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ad4713c2c0c26a45ead8fb16fee88e16fecf999588ae6920847cbaeb19565b7f\"\n \"checksum rustc-ap-syntax 209.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4c802e0e1fbc64eddc21e0798527eb1f5fdbd5781d119bd2c44b6130afdc81cc\"\n-\"checksum rustc-ap-syntax 211.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"768e2698f912913be2ccd355b2dea62c978efc356f75db1400605f3642905d53\"\n \"checksum rustc-ap-syntax_pos 209.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"008d47cc54ed12a2784217b9e6630a7fa1c8dc3591a283f65ad4b7fa307d49d5\"\n-\"checksum rustc-ap-syntax_pos 211.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a280dc8919aa7f684832ba3eeab2f6c96dbe2e2e4f6a922f7f0bdb3a9dd9e641\"\n \"checksum rustc-demangle 0.1.8 (registry+https://github.com/rust-lang/crates.io-index)\" = \"76d7ba1feafada44f2d38eed812bd2489a03c0f5abb975799251518b68848649\"\n \"checksum rustc-hash 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7540fc8b0c49f096ee9c961cda096467dce8084bec6bdca2fc83895fd9b28cb8\"\n \"checksum rustc-rayon 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8c6d5a683c6ba4ed37959097e88d71c9e8e26659a3cb5be8b389078e7ad45306\"\n \"checksum rustc-rayon-core 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"40f06724db71e18d68b3b946fdf890ca8c921d9edccc1404fdfdb537b0d12649\"\n \"checksum rustc-serialize 0.3.24 (registry+https://github.com/rust-lang/crates.io-index)\" = \"dcf128d1287d2ea9d80910b5f1120d0b8eede3fbf1abe91c40d39ea7d51e6fda\"\n \"checksum rustc_version 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a54aa04a10c68c1c4eacb4337fd883b435997ede17a9385784b990777686b09a\"\n \"checksum rustfix 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"756567f00f7d89c9f89a5c401b8b1caaa122e27240b9eaadd0bb52ee0b680b1b\"\n+\"checksum rustfmt-nightly 0.9.0 (git+https://github.com/rust-lang-nursery/rustfmt?rev=7e3dc8fae7ed84cc1879ef4e0bc6f00dfe059e1b)\" = \"<none>\"\n \"checksum same-file 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"cfb6eded0b06a0b512c8ddbcf04089138c9b4362c2f696f3c3d76039d68f3637\"\n \"checksum schannel 0.1.13 (registry+https://github.com/rust-lang/crates.io-index)\" = \"dc1fabf2a7b6483a141426e1afd09ad543520a77ac49bd03c286e7696ccfd77f\"\n \"checksum scoped-tls 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"332ffa32bf586782a3efaeb58f127980944bbc8c4d6913a86107ac2a5ab24b28\""}, {"sha": "67f3d6217b60c05d3c11727ceec570f7be3dd564", "filename": "src/librustdoc/clean/auto_trait.rs", "status": "modified", "additions": 24, "deletions": 290, "changes": 314, "blob_url": "https://github.com/rust-lang/rust/blob/4aba7de2a77a95e2032eaf438e2e11b8e1a5eb82/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4aba7de2a77a95e2032eaf438e2e11b8e1a5eb82/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs?ref=4aba7de2a77a95e2032eaf438e2e11b8e1a5eb82", "patch": "@@ -15,9 +15,9 @@ use rustc::ty::subst::Subst;\n use rustc::infer::InferOk;\n use rustc::middle::cstore::CrateStore;\n use std::fmt::Debug;\n-use syntax_pos::DUMMY_SP;\n \n-use core::DocAccessLevels;\n+use self::def_ctor::{get_def_ctor_from_def_id, get_def_ctor_from_node_id};\n+use self::finder_trait::Finder;\n \n use super::*;\n \n@@ -34,186 +34,16 @@ impl<'a, 'tcx, 'rcx, 'cstore> AutoTraitFinder<'a, 'tcx, 'rcx, 'cstore> {\n     }\n \n     pub fn get_with_def_id(&self, def_id: DefId) -> Vec<Item> {\n-        let ty = self.cx.tcx.type_of(def_id);\n-\n-        let def_ctor: fn(DefId) -> Def = match ty.sty {\n-            ty::TyAdt(adt, _) => match adt.adt_kind() {\n-                AdtKind::Struct => Def::Struct,\n-                AdtKind::Enum => Def::Enum,\n-                AdtKind::Union => Def::Union,\n-            }\n-            ty::TyInt(_) |\n-            ty::TyUint(_) |\n-            ty::TyFloat(_) |\n-            ty::TyStr |\n-            ty::TyBool |\n-            ty::TyChar => return self.get_auto_trait_impls(def_id, &move |_: DefId| {\n-                match ty.sty {\n-                    ty::TyInt(x) => Def::PrimTy(hir::TyInt(x)),\n-                    ty::TyUint(x) => Def::PrimTy(hir::TyUint(x)),\n-                    ty::TyFloat(x) => Def::PrimTy(hir::TyFloat(x)),\n-                    ty::TyStr => Def::PrimTy(hir::TyStr),\n-                    ty::TyBool => Def::PrimTy(hir::TyBool),\n-                    ty::TyChar => Def::PrimTy(hir::TyChar),\n-                    _ => unreachable!(),\n-                }\n-            }, None),\n-            _ => {\n-                debug!(\"Unexpected type {:?}\", def_id);\n-                return Vec::new()\n-            }\n-        };\n-\n-        self.get_auto_trait_impls(def_id, &def_ctor, None)\n+        get_def_ctor_from_def_id(&self.cx, def_id, &|def_ctor| {\n+            self.get_auto_trait_impls(def_id, &def_ctor, None)\n+        })\n     }\n \n     pub fn get_with_node_id(&self, id: ast::NodeId, name: String) -> Vec<Item> {\n-        let item = &self.cx.tcx.hir.expect_item(id).node;\n-        let did = self.cx.tcx.hir.local_def_id(id);\n-\n-        let def_ctor = match *item {\n-            hir::ItemKind::Struct(_, _) => Def::Struct,\n-            hir::ItemKind::Union(_, _) => Def::Union,\n-            hir::ItemKind::Enum(_, _) => Def::Enum,\n-            _ => panic!(\"Unexpected type {:?} {:?}\", item, id),\n-        };\n-\n-        self.get_auto_trait_impls(did, &def_ctor, Some(name))\n-    }\n-\n-    fn get_real_ty<F>(&self,\n-                      def_id: DefId,\n-                      def_ctor: &F,\n-                      real_name: &Option<Ident>,\n-                      generics: &ty::Generics,\n-    ) -> hir::Ty\n-    where F: Fn(DefId) -> Def {\n-        let path = get_path_for_type(self.cx.tcx, def_id, def_ctor);\n-        let mut segments = path.segments.into_vec();\n-        let last = segments.pop().unwrap();\n-\n-        segments.push(hir::PathSegment::new(\n-            real_name.unwrap_or(last.ident),\n-            self.generics_to_path_params(generics.clone()),\n-            false,\n-        ));\n-\n-        let new_path = hir::Path {\n-            span: path.span,\n-            def: path.def,\n-            segments: HirVec::from_vec(segments),\n-        };\n-\n-        hir::Ty {\n-            id: ast::DUMMY_NODE_ID,\n-            node: hir::TyKind::Path(hir::QPath::Resolved(None, P(new_path))),\n-            span: DUMMY_SP,\n-            hir_id: hir::DUMMY_HIR_ID,\n-        }\n-    }\n-\n-    pub fn get_blanket_impls<F>(\n-        &self,\n-        def_id: DefId,\n-        def_ctor: &F,\n-        name: Option<String>,\n-        generics: &ty::Generics,\n-    ) -> Vec<Item>\n-    where F: Fn(DefId) -> Def {\n-        let ty = self.cx.tcx.type_of(def_id);\n-        let mut traits = Vec::new();\n-        if self.cx.access_levels.borrow().is_doc_reachable(def_id) {\n-            let real_name = name.clone().map(|name| Ident::from_str(&name));\n-            let param_env = self.cx.tcx.param_env(def_id);\n-            for &trait_def_id in self.cx.all_traits.iter() {\n-                if !self.cx.access_levels.borrow().is_doc_reachable(trait_def_id) ||\n-                   self.cx.generated_synthetics\n-                          .borrow_mut()\n-                          .get(&(def_id, trait_def_id))\n-                          .is_some() {\n-                    continue\n-                }\n-                self.cx.tcx.for_each_relevant_impl(trait_def_id, ty, |impl_def_id| {\n-                    self.cx.tcx.infer_ctxt().enter(|infcx| {\n-                        let t_generics = infcx.tcx.generics_of(impl_def_id);\n-                        let trait_ref = infcx.tcx.impl_trait_ref(impl_def_id).unwrap();\n-\n-                        match infcx.tcx.type_of(impl_def_id).sty {\n-                            ::rustc::ty::TypeVariants::TyParam(_) => {},\n-                            _ => return,\n-                        }\n-\n-                        let substs = infcx.fresh_substs_for_item(DUMMY_SP, def_id);\n-                        let ty = ty.subst(infcx.tcx, substs);\n-                        let param_env = param_env.subst(infcx.tcx, substs);\n-\n-                        let impl_substs = infcx.fresh_substs_for_item(DUMMY_SP, impl_def_id);\n-                        let trait_ref = trait_ref.subst(infcx.tcx, impl_substs);\n-\n-                        // Require the type the impl is implemented on to match\n-                        // our type, and ignore the impl if there was a mismatch.\n-                        let cause = traits::ObligationCause::dummy();\n-                        let eq_result = infcx.at(&cause, param_env)\n-                                             .eq(trait_ref.self_ty(), ty);\n-                        if let Ok(InferOk { value: (), obligations }) = eq_result {\n-                            // FIXME(eddyb) ignoring `obligations` might cause false positives.\n-                            drop(obligations);\n-\n-                            let may_apply = infcx.predicate_may_hold(&traits::Obligation::new(\n-                                cause.clone(),\n-                                param_env,\n-                                trait_ref.to_predicate(),\n-                            ));\n-                            if !may_apply {\n-                                return\n-                            }\n-                            self.cx.generated_synthetics.borrow_mut()\n-                                                        .insert((def_id, trait_def_id));\n-                            let trait_ = hir::TraitRef {\n-                                path: get_path_for_type(infcx.tcx,\n-                                                        trait_def_id,\n-                                                        hir::def::Def::Trait),\n-                                ref_id: ast::DUMMY_NODE_ID,\n-                            };\n-                            let provided_trait_methods =\n-                                infcx.tcx.provided_trait_methods(trait_def_id)\n-                                         .into_iter()\n-                                         .map(|meth| meth.ident.to_string())\n-                                         .collect();\n-\n-                            let ty = self.get_real_ty(def_id, def_ctor, &real_name, generics);\n-                            let predicates = infcx.tcx.predicates_of(impl_def_id);\n-\n-                            traits.push(Item {\n-                                source: infcx.tcx.def_span(impl_def_id).clean(self.cx),\n-                                name: None,\n-                                attrs: Default::default(),\n-                                visibility: None,\n-                                def_id: self.next_def_id(impl_def_id.krate),\n-                                stability: None,\n-                                deprecation: None,\n-                                inner: ImplItem(Impl {\n-                                    unsafety: hir::Unsafety::Normal,\n-                                    generics: (t_generics, &predicates).clean(self.cx),\n-                                    provided_trait_methods,\n-                                    trait_: Some(trait_.clean(self.cx)),\n-                                    for_: ty.clean(self.cx),\n-                                    items: infcx.tcx.associated_items(impl_def_id)\n-                                                    .collect::<Vec<_>>()\n-                                                    .clean(self.cx),\n-                                    polarity: None,\n-                                    synthetic: false,\n-                                    blanket_impl: Some(infcx.tcx.type_of(impl_def_id)\n-                                                                .clean(self.cx)),\n-                                }),\n-                            });\n-                            debug!(\"{:?} => {}\", trait_ref, may_apply);\n-                        }\n-                    });\n-                });\n-            }\n-        }\n-        traits\n+        get_def_ctor_from_node_id(&self.cx, id, name, &|def_ctor, name| {\n+            let did = self.cx.tcx.hir.local_def_id(id);\n+            self.get_auto_trait_impls(did, &def_ctor, Some(name))\n+        })\n     }\n \n     pub fn get_auto_trait_impls<F>(\n@@ -263,7 +93,6 @@ impl<'a, 'tcx, 'rcx, 'cstore> AutoTraitFinder<'a, 'tcx, 'rcx, 'cstore> {\n                 def_ctor,\n                 tcx.require_lang_item(lang_items::SyncTraitLangItem),\n             ).into_iter())\n-            .chain(self.get_blanket_impls(def_id, def_ctor, name, &generics).into_iter())\n             .collect();\n \n         debug!(\n@@ -365,56 +194,6 @@ impl<'a, 'tcx, 'rcx, 'cstore> AutoTraitFinder<'a, 'tcx, 'rcx, 'cstore> {\n         None\n     }\n \n-    fn generics_to_path_params(&self, generics: ty::Generics) -> hir::GenericArgs {\n-        let mut args = vec![];\n-\n-        for param in generics.params.iter() {\n-            match param.kind {\n-                ty::GenericParamDefKind::Lifetime => {\n-                    let name = if param.name == \"\" {\n-                        hir::ParamName::Plain(keywords::StaticLifetime.ident())\n-                    } else {\n-                        hir::ParamName::Plain(ast::Ident::from_interned_str(param.name))\n-                    };\n-\n-                    args.push(hir::GenericArg::Lifetime(hir::Lifetime {\n-                        id: ast::DUMMY_NODE_ID,\n-                        span: DUMMY_SP,\n-                        name: hir::LifetimeName::Param(name),\n-                    }));\n-                }\n-                ty::GenericParamDefKind::Type {..} => {\n-                    args.push(hir::GenericArg::Type(self.ty_param_to_ty(param.clone())));\n-                }\n-            }\n-        }\n-\n-        hir::GenericArgs {\n-            args: HirVec::from_vec(args),\n-            bindings: HirVec::new(),\n-            parenthesized: false,\n-        }\n-    }\n-\n-    fn ty_param_to_ty(&self, param: ty::GenericParamDef) -> hir::Ty {\n-        debug!(\"ty_param_to_ty({:?}) {:?}\", param, param.def_id);\n-        hir::Ty {\n-            id: ast::DUMMY_NODE_ID,\n-            node: hir::TyKind::Path(hir::QPath::Resolved(\n-                None,\n-                P(hir::Path {\n-                    span: DUMMY_SP,\n-                    def: Def::TyParam(param.def_id),\n-                    segments: HirVec::from_vec(vec![\n-                        hir::PathSegment::from_ident(Ident::from_interned_str(param.name))\n-                    ]),\n-                }),\n-            )),\n-            span: DUMMY_SP,\n-            hir_id: hir::DUMMY_HIR_ID,\n-        }\n-    }\n-\n     fn find_auto_trait_generics(\n         &self,\n         did: DefId,\n@@ -531,7 +310,7 @@ impl<'a, 'tcx, 'rcx, 'cstore> AutoTraitFinder<'a, 'tcx, 'rcx, 'cstore> {\n                     // Desired order is 'larger, smaller', so flip then\n                     if self.region_name(r1) != self.region_name(r2) {\n                         finished\n-                            .entry(self.region_name(r2).unwrap())\n+                            .entry(self.region_name(r2).expect(\"no region_name found\"))\n                             .or_insert_with(|| Vec::new())\n                             .push(r1);\n                     }\n@@ -566,7 +345,7 @@ impl<'a, 'tcx, 'rcx, 'cstore> AutoTraitFinder<'a, 'tcx, 'rcx, 'cstore> {\n                         (&RegionTarget::Region(r1), &RegionTarget::Region(r2)) => {\n                             if self.region_name(r1) != self.region_name(r2) {\n                                 finished\n-                                    .entry(self.region_name(r2).unwrap())\n+                                    .entry(self.region_name(r2).expect(\"no region name found\"))\n                                     .or_insert_with(|| Vec::new())\n                                     .push(r1) // Larger, smaller\n                             }\n@@ -663,7 +442,7 @@ impl<'a, 'tcx, 'rcx, 'cstore> AutoTraitFinder<'a, 'tcx, 'rcx, 'cstore> {\n             .flat_map(|(ty, mut bounds)| {\n                 if let Some(data) = ty_to_fn.get(&ty) {\n                     let (poly_trait, output) =\n-                        (data.0.as_ref().unwrap().clone(), data.1.as_ref().cloned());\n+                        (data.0.as_ref().expect(\"as_ref failed\").clone(), data.1.as_ref().cloned());\n                     let new_ty = match &poly_trait.trait_ {\n                         &Type::ResolvedPath {\n                             ref path,\n@@ -672,7 +451,8 @@ impl<'a, 'tcx, 'rcx, 'cstore> AutoTraitFinder<'a, 'tcx, 'rcx, 'cstore> {\n                             ref is_generic,\n                         } => {\n                             let mut new_path = path.clone();\n-                            let last_segment = new_path.segments.pop().unwrap();\n+                            let last_segment = new_path.segments.pop()\n+                                                                .expect(\"segments were empty\");\n \n                             let (old_input, old_output) = match last_segment.args {\n                                 GenericArgs::AngleBracketed { types, .. } => (types, None),\n@@ -830,7 +610,7 @@ impl<'a, 'tcx, 'rcx, 'cstore> AutoTraitFinder<'a, 'tcx, 'rcx, 'cstore> {\n                     let mut for_generics = self.extract_for_generics(tcx, orig_p.clone());\n \n                     assert!(bounds.len() == 1);\n-                    let mut b = bounds.pop().unwrap();\n+                    let mut b = bounds.pop().expect(\"bounds were empty\");\n \n                     if b.is_sized_bound(self.cx) {\n                         has_sized.insert(ty.clone());\n@@ -860,7 +640,7 @@ impl<'a, 'tcx, 'rcx, 'cstore> AutoTraitFinder<'a, 'tcx, 'rcx, 'cstore> {\n                             _ => false,\n                         };\n \n-                        let poly_trait = b.get_poly_trait().unwrap();\n+                        let poly_trait = b.get_poly_trait().expect(\"Cannot get poly trait\");\n \n                         if is_fn {\n                             ty_to_fn\n@@ -913,7 +693,10 @@ impl<'a, 'tcx, 'rcx, 'cstore> AutoTraitFinder<'a, 'tcx, 'rcx, 'cstore> {\n                                     // FIXME: Remove this scope when NLL lands\n                                     {\n                                         let args =\n-                                            &mut new_trait_path.segments.last_mut().unwrap().args;\n+                                            &mut new_trait_path.segments\n+                                                .last_mut()\n+                                                .expect(\"segments were empty\")\n+                                                .args;\n \n                                         match args {\n                                             // Convert somethiung like '<T as Iterator::Item> = u8'\n@@ -1077,60 +860,11 @@ impl<'a, 'tcx, 'rcx, 'cstore> AutoTraitFinder<'a, 'tcx, 'rcx, 'cstore> {\n             _ => false,\n         }\n     }\n+}\n \n-    // This is an ugly hack, but it's the simplest way to handle synthetic impls without greatly\n-    // refactoring either librustdoc or librustc. In particular, allowing new DefIds to be\n-    // registered after the AST is constructed would require storing the defid mapping in a\n-    // RefCell, decreasing the performance for normal compilation for very little gain.\n-    //\n-    // Instead, we construct 'fake' def ids, which start immediately after the last DefId in\n-    // DefIndexAddressSpace::Low. In the Debug impl for clean::Item, we explicitly check for fake\n-    // def ids, as we'll end up with a panic if we use the DefId Debug impl for fake DefIds\n-    fn next_def_id(&self, crate_num: CrateNum) -> DefId {\n-        let start_def_id = {\n-            let next_id = if crate_num == LOCAL_CRATE {\n-                self.cx\n-                    .tcx\n-                    .hir\n-                    .definitions()\n-                    .def_path_table()\n-                    .next_id(DefIndexAddressSpace::Low)\n-            } else {\n-                self.cx\n-                    .cstore\n-                    .def_path_table(crate_num)\n-                    .next_id(DefIndexAddressSpace::Low)\n-            };\n-\n-            DefId {\n-                krate: crate_num,\n-                index: next_id,\n-            }\n-        };\n-\n-        let mut fake_ids = self.cx.fake_def_ids.borrow_mut();\n-\n-        let def_id = fake_ids.entry(crate_num).or_insert(start_def_id).clone();\n-        fake_ids.insert(\n-            crate_num,\n-            DefId {\n-                krate: crate_num,\n-                index: DefIndex::from_array_index(\n-                    def_id.index.as_array_index() + 1,\n-                    def_id.index.address_space(),\n-                ),\n-            },\n-        );\n-\n-        MAX_DEF_ID.with(|m| {\n-            m.borrow_mut()\n-                .entry(def_id.krate.clone())\n-                .or_insert(start_def_id);\n-        });\n-\n-        self.cx.all_fake_def_ids.borrow_mut().insert(def_id);\n-\n-        def_id.clone()\n+impl<'a, 'tcx: 'a, 'rcx: 'a> Finder<'a, 'tcx, 'rcx> for AutoTraitFinder<'a, 'tcx, 'rcx> {\n+    fn get_cx(&self) -> &DocContext<'a, 'tcx, 'rcx> {\n+        &self.cx\n     }\n }\n "}, {"sha": "bb86688447e1e55031f2cf28cd1010fa18048ab9", "filename": "src/librustdoc/clean/blanket_impl.rs", "status": "added", "additions": 170, "deletions": 0, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/4aba7de2a77a95e2032eaf438e2e11b8e1a5eb82/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4aba7de2a77a95e2032eaf438e2e11b8e1a5eb82/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs?ref=4aba7de2a77a95e2032eaf438e2e11b8e1a5eb82", "patch": "@@ -0,0 +1,170 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use rustc::hir;\n+use rustc::traits;\n+use rustc::ty::ToPredicate;\n+use rustc::ty::subst::Subst;\n+use rustc::infer::InferOk;\n+use syntax_pos::DUMMY_SP;\n+\n+use core::DocAccessLevels;\n+\n+use super::*;\n+\n+use self::def_ctor::{get_def_ctor_from_def_id, get_def_ctor_from_node_id};\n+use self::finder_trait::Finder;\n+\n+pub struct BlanketImplFinder<'a, 'tcx: 'a, 'rcx: 'a> {\n+    pub cx: &'a core::DocContext<'a, 'tcx, 'rcx>,\n+}\n+\n+impl<'a, 'tcx, 'rcx> BlanketImplFinder <'a, 'tcx, 'rcx> {\n+    pub fn new(cx: &'a core::DocContext<'a, 'tcx, 'rcx>) -> Self {\n+        BlanketImplFinder { cx }\n+    }\n+\n+    pub fn get_with_def_id(&self, def_id: DefId) -> Vec<Item> {\n+        get_def_ctor_from_def_id(&self.cx, def_id, &|def_ctor| {\n+            self.get_blanket_impls(def_id, &def_ctor, None)\n+        })\n+    }\n+\n+    pub fn get_with_node_id(&self, id: ast::NodeId, name: String) -> Vec<Item> {\n+        get_def_ctor_from_node_id(&self.cx, id, name, &|def_ctor, name| {\n+            let did = self.cx.tcx.hir.local_def_id(id);\n+            self.get_blanket_impls(did, &def_ctor, Some(name))\n+        })\n+    }\n+\n+    pub fn get_blanket_impls<F>(\n+        &self,\n+        def_id: DefId,\n+        def_ctor: &F,\n+        name: Option<String>,\n+    ) -> Vec<Item>\n+    where F: Fn(DefId) -> Def {\n+        let mut impls = Vec::new();\n+        if self.cx\n+            .tcx\n+            .get_attrs(def_id)\n+            .lists(\"doc\")\n+            .has_word(\"hidden\")\n+        {\n+            debug!(\n+                \"get_blanket_impls(def_id={:?}, def_ctor=...): item has doc('hidden'), \\\n+                 aborting\",\n+                def_id\n+            );\n+            return impls;\n+        }\n+        if self.cx.access_levels.borrow().is_doc_reachable(def_id) {\n+            let generics = self.cx.tcx.generics_of(def_id);\n+            let ty = self.cx.tcx.type_of(def_id);\n+            let real_name = name.clone().map(|name| Ident::from_str(&name));\n+            let param_env = self.cx.tcx.param_env(def_id);\n+            for &trait_def_id in self.cx.all_traits.iter() {\n+                if !self.cx.access_levels.borrow().is_doc_reachable(trait_def_id) ||\n+                   self.cx.generated_synthetics\n+                          .borrow_mut()\n+                          .get(&(def_id, trait_def_id))\n+                          .is_some() {\n+                    continue\n+                }\n+                self.cx.tcx.for_each_relevant_impl(trait_def_id, ty, |impl_def_id| {\n+                    self.cx.tcx.infer_ctxt().enter(|infcx| {\n+                        let t_generics = infcx.tcx.generics_of(impl_def_id);\n+                        let trait_ref = infcx.tcx.impl_trait_ref(impl_def_id)\n+                                                 .expect(\"Cannot get impl trait\");\n+\n+                        match infcx.tcx.type_of(impl_def_id).sty {\n+                            ::rustc::ty::TypeVariants::TyParam(_) => {},\n+                            _ => return,\n+                        }\n+\n+                        let substs = infcx.fresh_substs_for_item(DUMMY_SP, def_id);\n+                        let ty = ty.subst(infcx.tcx, substs);\n+                        let param_env = param_env.subst(infcx.tcx, substs);\n+\n+                        let impl_substs = infcx.fresh_substs_for_item(DUMMY_SP, impl_def_id);\n+                        let trait_ref = trait_ref.subst(infcx.tcx, impl_substs);\n+\n+                        // Require the type the impl is implemented on to match\n+                        // our type, and ignore the impl if there was a mismatch.\n+                        let cause = traits::ObligationCause::dummy();\n+                        let eq_result = infcx.at(&cause, param_env)\n+                                             .eq(trait_ref.self_ty(), ty);\n+                        if let Ok(InferOk { value: (), obligations }) = eq_result {\n+                            // FIXME(eddyb) ignoring `obligations` might cause false positives.\n+                            drop(obligations);\n+\n+                            let may_apply = infcx.predicate_may_hold(&traits::Obligation::new(\n+                                cause.clone(),\n+                                param_env,\n+                                trait_ref.to_predicate(),\n+                            ));\n+                            if !may_apply {\n+                                return\n+                            }\n+                            self.cx.generated_synthetics.borrow_mut()\n+                                                        .insert((def_id, trait_def_id));\n+                            let trait_ = hir::TraitRef {\n+                                path: get_path_for_type(infcx.tcx,\n+                                                        trait_def_id,\n+                                                        hir::def::Def::Trait),\n+                                ref_id: ast::DUMMY_NODE_ID,\n+                            };\n+                            let provided_trait_methods =\n+                                infcx.tcx.provided_trait_methods(trait_def_id)\n+                                         .into_iter()\n+                                         .map(|meth| meth.ident.to_string())\n+                                         .collect();\n+\n+                            let ty = self.get_real_ty(def_id, def_ctor, &real_name, generics);\n+                            let predicates = infcx.tcx.predicates_of(impl_def_id);\n+\n+                            impls.push(Item {\n+                                source: infcx.tcx.def_span(impl_def_id).clean(self.cx),\n+                                name: None,\n+                                attrs: Default::default(),\n+                                visibility: None,\n+                                def_id: self.next_def_id(impl_def_id.krate),\n+                                stability: None,\n+                                deprecation: None,\n+                                inner: ImplItem(Impl {\n+                                    unsafety: hir::Unsafety::Normal,\n+                                    generics: (t_generics, &predicates).clean(self.cx),\n+                                    provided_trait_methods,\n+                                    trait_: Some(trait_.clean(self.cx)),\n+                                    for_: ty.clean(self.cx),\n+                                    items: infcx.tcx.associated_items(impl_def_id)\n+                                                    .collect::<Vec<_>>()\n+                                                    .clean(self.cx),\n+                                    polarity: None,\n+                                    synthetic: false,\n+                                    blanket_impl: Some(infcx.tcx.type_of(impl_def_id)\n+                                                                .clean(self.cx)),\n+                                }),\n+                            });\n+                            debug!(\"{:?} => {}\", trait_ref, may_apply);\n+                        }\n+                    });\n+                });\n+            }\n+        }\n+        impls\n+    }\n+}\n+\n+impl<'a, 'tcx: 'a, 'rcx: 'a> Finder<'a, 'tcx, 'rcx> for BlanketImplFinder<'a, 'tcx, 'rcx> {\n+    fn get_cx(&self) -> &DocContext<'a, 'tcx, 'rcx> {\n+        &self.cx\n+    }\n+}"}, {"sha": "cb91f0d0be67d665e87eff5a9008b50d5758ce14", "filename": "src/librustdoc/clean/def_ctor.rs", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/4aba7de2a77a95e2032eaf438e2e11b8e1a5eb82/src%2Flibrustdoc%2Fclean%2Fdef_ctor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4aba7de2a77a95e2032eaf438e2e11b8e1a5eb82/src%2Flibrustdoc%2Fclean%2Fdef_ctor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fdef_ctor.rs?ref=4aba7de2a77a95e2032eaf438e2e11b8e1a5eb82", "patch": "@@ -0,0 +1,65 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use core::DocContext;\n+\n+use super::*;\n+\n+pub fn get_def_ctor_from_def_id<F>(cx: &DocContext,\n+                                   def_id: DefId,\n+                                   callback: &F,\n+) -> Vec<Item>\n+where F: Fn(&Fn(DefId) -> Def) -> Vec<Item> {\n+    let ty = cx.tcx.type_of(def_id);\n+\n+    match ty.sty {\n+        ty::TyAdt(adt, _) => callback(&match adt.adt_kind() {\n+            AdtKind::Struct => Def::Struct,\n+            AdtKind::Enum => Def::Enum,\n+            AdtKind::Union => Def::Union,\n+        }),\n+        ty::TyInt(_) |\n+        ty::TyUint(_) |\n+        ty::TyFloat(_) |\n+        ty::TyStr |\n+        ty::TyBool |\n+        ty::TyChar => callback(&move |_: DefId| {\n+            match ty.sty {\n+                ty::TyInt(x) => Def::PrimTy(hir::TyInt(x)),\n+                ty::TyUint(x) => Def::PrimTy(hir::TyUint(x)),\n+                ty::TyFloat(x) => Def::PrimTy(hir::TyFloat(x)),\n+                ty::TyStr => Def::PrimTy(hir::TyStr),\n+                ty::TyBool => Def::PrimTy(hir::TyBool),\n+                ty::TyChar => Def::PrimTy(hir::TyChar),\n+                _ => unreachable!(),\n+            }\n+        }),\n+        _ => {\n+            debug!(\"Unexpected type {:?}\", def_id);\n+            Vec::new()\n+        }\n+    }\n+}\n+\n+pub fn get_def_ctor_from_node_id<F>(cx: &DocContext,\n+                                    id: ast::NodeId,\n+                                    name: String,\n+                                    callback: &F,\n+) -> Vec<Item>\n+where F: Fn(&Fn(DefId) -> Def, String) -> Vec<Item> {\n+    let item = &cx.tcx.hir.expect_item(id).node;\n+\n+    callback(&match *item {\n+        hir::ItemKind::Struct(_, _) => Def::Struct,\n+        hir::ItemKind::Union(_, _) => Def::Union,\n+        hir::ItemKind::Enum(_, _) => Def::Enum,\n+        _ => panic!(\"Unexpected type {:?} {:?}\", item, id),\n+    }, name)\n+}"}, {"sha": "cc0f3c49d16fb20cda2ef729099d7fd17e891866", "filename": "src/librustdoc/clean/finder_trait.rs", "status": "added", "additions": 154, "deletions": 0, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/4aba7de2a77a95e2032eaf438e2e11b8e1a5eb82/src%2Flibrustdoc%2Fclean%2Ffinder_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4aba7de2a77a95e2032eaf438e2e11b8e1a5eb82/src%2Flibrustdoc%2Fclean%2Ffinder_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ffinder_trait.rs?ref=4aba7de2a77a95e2032eaf438e2e11b8e1a5eb82", "patch": "@@ -0,0 +1,154 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use rustc::hir;\n+use syntax_pos::DUMMY_SP;\n+\n+use super::*;\n+\n+pub trait Finder<'a, 'tcx: 'a, 'rcx: 'a> {\n+    fn get_cx(&self) -> &DocContext<'a, 'tcx, 'rcx>;\n+\n+    // This is an ugly hack, but it's the simplest way to handle synthetic impls without greatly\n+    // refactoring either librustdoc or librustc. In particular, allowing new DefIds to be\n+    // registered after the AST is constructed would require storing the defid mapping in a\n+    // RefCell, decreasing the performance for normal compilation for very little gain.\n+    //\n+    // Instead, we construct 'fake' def ids, which start immediately after the last DefId in\n+    // DefIndexAddressSpace::Low. In the Debug impl for clean::Item, we explicitly check for fake\n+    // def ids, as we'll end up with a panic if we use the DefId Debug impl for fake DefIds\n+    fn next_def_id(&self, crate_num: CrateNum) -> DefId {\n+        let start_def_id = {\n+            let next_id = if crate_num == LOCAL_CRATE {\n+                self.get_cx()\n+                    .tcx\n+                    .hir\n+                    .definitions()\n+                    .def_path_table()\n+                    .next_id(DefIndexAddressSpace::Low)\n+            } else {\n+                self.get_cx()\n+                    .cstore\n+                    .def_path_table(crate_num)\n+                    .next_id(DefIndexAddressSpace::Low)\n+            };\n+\n+            DefId {\n+                krate: crate_num,\n+                index: next_id,\n+            }\n+        };\n+\n+        let mut fake_ids = self.get_cx().fake_def_ids.borrow_mut();\n+\n+        let def_id = fake_ids.entry(crate_num).or_insert(start_def_id).clone();\n+        fake_ids.insert(\n+            crate_num,\n+            DefId {\n+                krate: crate_num,\n+                index: DefIndex::from_array_index(\n+                    def_id.index.as_array_index() + 1,\n+                    def_id.index.address_space(),\n+                ),\n+            },\n+        );\n+\n+        MAX_DEF_ID.with(|m| {\n+            m.borrow_mut()\n+                .entry(def_id.krate.clone())\n+                .or_insert(start_def_id);\n+        });\n+\n+        self.get_cx().all_fake_def_ids.borrow_mut().insert(def_id);\n+\n+        def_id.clone()\n+    }\n+\n+    fn get_real_ty<F>(&self,\n+                      def_id: DefId,\n+                      def_ctor: &F,\n+                      real_name: &Option<Ident>,\n+                      generics: &ty::Generics,\n+    ) -> hir::Ty\n+    where F: Fn(DefId) -> Def {\n+        let path = get_path_for_type(self.get_cx().tcx, def_id, def_ctor);\n+        let mut segments = path.segments.into_vec();\n+        let last = segments.pop().expect(\"segments were empty\");\n+\n+        segments.push(hir::PathSegment::new(\n+            real_name.unwrap_or(last.ident),\n+            self.generics_to_path_params(generics.clone()),\n+            false,\n+        ));\n+\n+        let new_path = hir::Path {\n+            span: path.span,\n+            def: path.def,\n+            segments: HirVec::from_vec(segments),\n+        };\n+\n+        hir::Ty {\n+            id: ast::DUMMY_NODE_ID,\n+            node: hir::TyKind::Path(hir::QPath::Resolved(None, P(new_path))),\n+            span: DUMMY_SP,\n+            hir_id: hir::DUMMY_HIR_ID,\n+        }\n+    }\n+\n+    fn generics_to_path_params(&self, generics: ty::Generics) -> hir::GenericArgs {\n+        let mut args = vec![];\n+\n+        for param in generics.params.iter() {\n+            match param.kind {\n+                ty::GenericParamDefKind::Lifetime => {\n+                    let name = if param.name == \"\" {\n+                        hir::ParamName::Plain(keywords::StaticLifetime.ident())\n+                    } else {\n+                        hir::ParamName::Plain(ast::Ident::from_interned_str(param.name))\n+                    };\n+\n+                    args.push(hir::GenericArg::Lifetime(hir::Lifetime {\n+                        id: ast::DUMMY_NODE_ID,\n+                        span: DUMMY_SP,\n+                        name: hir::LifetimeName::Param(name),\n+                    }));\n+                }\n+                ty::GenericParamDefKind::Type {..} => {\n+                    args.push(hir::GenericArg::Type(self.ty_param_to_ty(param.clone())));\n+                }\n+            }\n+        }\n+\n+        hir::GenericArgs {\n+            args: HirVec::from_vec(args),\n+            bindings: HirVec::new(),\n+            parenthesized: false,\n+        }\n+    }\n+\n+    fn ty_param_to_ty(&self, param: ty::GenericParamDef) -> hir::Ty {\n+        debug!(\"ty_param_to_ty({:?}) {:?}\", param, param.def_id);\n+        hir::Ty {\n+            id: ast::DUMMY_NODE_ID,\n+            node: hir::TyKind::Path(hir::QPath::Resolved(\n+                None,\n+                P(hir::Path {\n+                    span: DUMMY_SP,\n+                    def: Def::TyParam(param.def_id),\n+                    segments: HirVec::from_vec(vec![\n+                        hir::PathSegment::from_ident(Ident::from_interned_str(param.name))\n+                    ]),\n+                }),\n+            )),\n+            span: DUMMY_SP,\n+            hir_id: hir::DUMMY_HIR_ID,\n+        }\n+    }\n+}"}, {"sha": "1c66c39b660b246cc5f32fab320488718139d8e5", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 19, "deletions": 7, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/4aba7de2a77a95e2032eaf438e2e11b8e1a5eb82/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4aba7de2a77a95e2032eaf438e2e11b8e1a5eb82/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=4aba7de2a77a95e2032eaf438e2e11b8e1a5eb82", "patch": "@@ -25,7 +25,13 @@ use rustc::util::nodemap::FxHashSet;\n \n use core::{DocContext, DocAccessLevels};\n use doctree;\n-use clean::{self, GetDefId, ToSource, get_auto_traits_with_def_id};\n+use clean::{\n+    self,\n+    GetDefId,\n+    ToSource,\n+    get_auto_traits_with_def_id,\n+    get_blanket_impls_with_def_id,\n+};\n \n use super::Clean;\n \n@@ -168,7 +174,7 @@ pub fn record_extern_fqn(cx: &DocContext, did: DefId, kind: clean::TypeKind) {\n         }\n     });\n     let fqn = if let clean::TypeKind::Macro = kind {\n-        vec![crate_name, relative.last().unwrap()]\n+        vec![crate_name, relative.last().expect(\"relative was empty\")]\n     } else {\n         once(crate_name).chain(relative).collect()\n     };\n@@ -274,11 +280,14 @@ pub fn build_impls(cx: &DocContext, did: DefId, auto_traits: bool) -> Vec<clean:\n \n     if auto_traits {\n         let auto_impls = get_auto_traits_with_def_id(cx, did);\n-        let mut renderinfo = cx.renderinfo.borrow_mut();\n-        let new_impls: Vec<clean::Item> = auto_impls.into_iter()\n-            .filter(|i| renderinfo.inlined.insert(i.def_id)).collect();\n+        {\n+            let mut renderinfo = cx.renderinfo.borrow_mut();\n+            let new_impls: Vec<clean::Item> = auto_impls.into_iter()\n+                .filter(|i| renderinfo.inlined.insert(i.def_id)).collect();\n \n-        impls.extend(new_impls);\n+            impls.extend(new_impls);\n+        }\n+        impls.extend(get_blanket_impls_with_def_id(cx, did));\n     }\n \n     // If this is the first time we've inlined something from another crate, then\n@@ -336,10 +345,13 @@ pub fn build_impls(cx: &DocContext, did: DefId, auto_traits: bool) -> Vec<clean:\n             build_impl(cx, def_id, &mut impls);\n \n             let auto_impls = get_auto_traits_with_def_id(cx, def_id);\n+            let blanket_impls = get_blanket_impls_with_def_id(cx, def_id);\n             let mut renderinfo = cx.renderinfo.borrow_mut();\n \n             let new_impls: Vec<clean::Item> = auto_impls.into_iter()\n-                .filter(|i| renderinfo.inlined.insert(i.def_id)).collect();\n+                .chain(blanket_impls.into_iter())\n+                .filter(|i| renderinfo.inlined.insert(i.def_id))\n+                .collect();\n \n             impls.extend(new_impls);\n         }"}, {"sha": "8e70aaf2d312413690f95674f284cae3c715885e", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 34, "deletions": 15, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/4aba7de2a77a95e2032eaf438e2e11b8e1a5eb82/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4aba7de2a77a95e2032eaf438e2e11b8e1a5eb82/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=4aba7de2a77a95e2032eaf438e2e11b8e1a5eb82", "patch": "@@ -73,9 +73,13 @@ pub mod inline;\n pub mod cfg;\n mod simplify;\n mod auto_trait;\n+mod blanket_impl;\n+pub mod def_ctor;\n+mod finder_trait;\n \n use self::cfg::Cfg;\n use self::auto_trait::AutoTraitFinder;\n+use self::blanket_impl::BlanketImplFinder;\n \n thread_local!(static MAX_DEF_ID: RefCell<FxHashMap<CrateNum, DefId>> = RefCell::new(FxHashMap()));\n \n@@ -569,7 +573,7 @@ pub struct Module {\n impl Clean<Item> for doctree::Module {\n     fn clean(&self, cx: &DocContext) -> Item {\n         let name = if self.name.is_some() {\n-            self.name.unwrap().clean(cx)\n+            self.name.expect(\"No name provided\").clean(cx)\n         } else {\n             \"\".to_string()\n         };\n@@ -1064,7 +1068,7 @@ fn span_of_attrs(attrs: &Attributes) -> syntax_pos::Span {\n         return DUMMY_SP;\n     }\n     let start = attrs.doc_strings[0].span();\n-    let end = attrs.doc_strings.last().unwrap().span();\n+    let end = attrs.doc_strings.last().expect(\"No doc strings provided\").span();\n     start.to(end)\n }\n \n@@ -1728,7 +1732,7 @@ impl Clean<Lifetime> for hir::GenericParam {\n                         hir::GenericBound::Outlives(lt) => lt,\n                         _ => panic!(),\n                     });\n-                    let name = bounds.next().unwrap().name.ident();\n+                    let name = bounds.next().expect(\"no more bounds\").name.ident();\n                     let mut s = format!(\"{}: {}\", self.name.ident(), name);\n                     for bound in bounds {\n                         s.push_str(&format!(\" + {}\", bound.name.ident()));\n@@ -1841,8 +1845,8 @@ impl<'tcx> Clean<WherePredicate> for ty::OutlivesPredicate<ty::Region<'tcx>, ty:\n     fn clean(&self, cx: &DocContext) -> WherePredicate {\n         let ty::OutlivesPredicate(ref a, ref b) = *self;\n         WherePredicate::RegionPredicate {\n-            lifetime: a.clean(cx).unwrap(),\n-            bounds: vec![GenericBound::Outlives(b.clean(cx).unwrap())]\n+            lifetime: a.clean(cx).expect(\"failed to clean lifetime\"),\n+            bounds: vec![GenericBound::Outlives(b.clean(cx).expect(\"failed to clean bounds\"))]\n         }\n     }\n }\n@@ -1853,7 +1857,7 @@ impl<'tcx> Clean<WherePredicate> for ty::OutlivesPredicate<Ty<'tcx>, ty::Region<\n \n         WherePredicate::BoundPredicate {\n             ty: ty.clean(cx),\n-            bounds: vec![GenericBound::Outlives(lt.clean(cx).unwrap())]\n+            bounds: vec![GenericBound::Outlives(lt.clean(cx).expect(\"failed to clean lifetimes\"))]\n         }\n     }\n }\n@@ -1947,7 +1951,7 @@ impl Clean<GenericParamDef> for hir::GenericParam {\n                         hir::GenericBound::Outlives(lt) => lt,\n                         _ => panic!(),\n                     });\n-                    let name = bounds.next().unwrap().name.ident();\n+                    let name = bounds.next().expect(\"no more bounds\").name.ident();\n                     let mut s = format!(\"{}: {}\", self.name.ident(), name);\n                     for bound in bounds {\n                         s.push_str(&format!(\" + {}\", bound.name.ident()));\n@@ -2933,7 +2937,7 @@ impl Clean<Type> for hir::Ty {\n                 };\n \n                 if let Some(&hir::ItemKind::Ty(ref ty, ref generics)) = alias {\n-                    let provided_params = &path.segments.last().unwrap();\n+                    let provided_params = &path.segments.last().expect(\"segments were empty\");\n                     let mut ty_substs = FxHashMap();\n                     let mut lt_substs = FxHashMap();\n                     provided_params.with_generic_args(|generic_args| {\n@@ -3006,7 +3010,7 @@ impl Clean<Type> for hir::Ty {\n                     segments: segments.into(),\n                 };\n                 Type::QPath {\n-                    name: p.segments.last().unwrap().ident.name.clean(cx),\n+                    name: p.segments.last().expect(\"segments were empty\").ident.name.clean(cx),\n                     self_type: box qself.clean(cx),\n                     trait_: box resolve_type(cx, trait_path.clean(cx), self.id)\n                 }\n@@ -3062,7 +3066,7 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n             ty::TyStr => Primitive(PrimitiveType::Str),\n             ty::TySlice(ty) => Slice(box ty.clean(cx)),\n             ty::TyArray(ty, n) => {\n-                let mut n = cx.tcx.lift(&n).unwrap();\n+                let mut n = cx.tcx.lift(&n).expect(\"array lift failed\");\n                 if let ConstValue::Unevaluated(def_id, substs) = n.val {\n                     let param_env = cx.tcx.param_env(def_id);\n                     let cid = GlobalId {\n@@ -3084,7 +3088,7 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n             },\n             ty::TyFnDef(..) |\n             ty::TyFnPtr(_) => {\n-                let ty = cx.tcx.lift(self).unwrap();\n+                let ty = cx.tcx.lift(self).expect(\"TyFnPtr lift failed\");\n                 let sig = ty.fn_sig(cx.tcx);\n                 BareFunction(box BareFunctionDecl {\n                     unsafety: sig.unsafety(),\n@@ -3175,7 +3179,7 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n                 // Grab the \"TraitA + TraitB\" from `impl TraitA + TraitB`,\n                 // by looking up the projections associated with the def_id.\n                 let predicates_of = cx.tcx.predicates_of(def_id);\n-                let substs = cx.tcx.lift(&substs).unwrap();\n+                let substs = cx.tcx.lift(&substs).expect(\"TyAnon lift failed\");\n                 let bounds = predicates_of.instantiate(cx.tcx, substs);\n                 let mut regions = vec![];\n                 let mut has_sized = false;\n@@ -3314,6 +3318,7 @@ impl Clean<Vec<Item>> for doctree::Struct {\n     fn clean(&self, cx: &DocContext) -> Vec<Item> {\n         let name = self.name.clean(cx);\n         let mut ret = get_auto_traits_with_node_id(cx, self.id, name.clone());\n+        ret.extend(get_blanket_impls_with_node_id(cx, self.id, name.clone()));\n \n         *cx.current_item_name.borrow_mut() = Some(self.name);\n         ret.push(Item {\n@@ -3340,6 +3345,7 @@ impl Clean<Vec<Item>> for doctree::Union {\n     fn clean(&self, cx: &DocContext) -> Vec<Item> {\n         let name = self.name.clean(cx);\n         let mut ret = get_auto_traits_with_node_id(cx, self.id, name.clone());\n+        ret.extend(get_blanket_impls_with_node_id(cx, self.id, name.clone()));\n \n         *cx.current_item_name.borrow_mut() = Some(self.name);\n         ret.push(Item {\n@@ -3393,6 +3399,7 @@ impl Clean<Vec<Item>> for doctree::Enum {\n     fn clean(&self, cx: &DocContext) -> Vec<Item> {\n         let name = self.name.clean(cx);\n         let mut ret = get_auto_traits_with_node_id(cx, self.id, name.clone());\n+        ret.extend(get_blanket_impls_with_node_id(cx, self.id, name.clone()));\n \n         *cx.current_item_name.borrow_mut() = Some(self.name);\n         ret.push(Item {\n@@ -3545,7 +3552,7 @@ pub struct Path {\n \n impl Path {\n     pub fn last_name(&self) -> &str {\n-        self.segments.last().unwrap().name.as_str()\n+        self.segments.last().expect(\"segments were empty\").name.as_str()\n     }\n }\n \n@@ -3875,6 +3882,17 @@ pub fn get_auto_traits_with_def_id(cx: &DocContext, id: DefId) -> Vec<Item> {\n     finder.get_with_def_id(id)\n }\n \n+pub fn get_blanket_impls_with_node_id(cx: &DocContext, id: ast::NodeId, name: String) -> Vec<Item> {\n+    let finder = BlanketImplFinder::new(cx);\n+    finder.get_with_node_id(id, name)\n+}\n+\n+pub fn get_blanket_impls_with_def_id(cx: &DocContext, id: DefId) -> Vec<Item> {\n+    let finder = BlanketImplFinder::new(cx);\n+\n+    finder.get_with_def_id(id)\n+}\n+\n fn get_name_if_possible(cx: &DocContext, node: NodeId) -> Option<Name> {\n     match cx.tcx.hir.get(node) {\n         Node::NodeItem(_) |\n@@ -4196,7 +4214,7 @@ fn print_const(cx: &DocContext, n: &ty::Const) -> String {\n         },\n         _ => {\n             let mut s = String::new();\n-            ::rustc::mir::fmt_const_val(&mut s, n).unwrap();\n+            ::rustc::mir::fmt_const_val(&mut s, n).expect(\"fmt_const_val failed\");\n             // array lengths are obviously usize\n             if s.ends_with(\"usize\") {\n                 let n = s.len() - \"usize\".len();\n@@ -4257,7 +4275,8 @@ fn register_def(cx: &DocContext, def: Def) -> DefId {\n         Def::TyForeign(i) => (i, TypeKind::Foreign),\n         Def::Const(i) => (i, TypeKind::Const),\n         Def::Static(i, _) => (i, TypeKind::Static),\n-        Def::Variant(i) => (cx.tcx.parent_def_id(i).unwrap(), TypeKind::Enum),\n+        Def::Variant(i) => (cx.tcx.parent_def_id(i).expect(\"cannot get parent def id\"),\n+                            TypeKind::Enum),\n         Def::Macro(i, _) => (i, TypeKind::Macro),\n         Def::SelfTy(Some(def_id), _) => (def_id, TypeKind::Trait),\n         Def::SelfTy(_, Some(impl_def_id)) => {"}, {"sha": "9ea8bc536352a2d61d8458f7ec4cca7e042a811d", "filename": "src/librustdoc/clean/simplify.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4aba7de2a77a95e2032eaf438e2e11b8e1a5eb82/src%2Flibrustdoc%2Fclean%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4aba7de2a77a95e2032eaf438e2e11b8e1a5eb82/src%2Flibrustdoc%2Fclean%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fsimplify.rs?ref=4aba7de2a77a95e2032eaf438e2e11b8e1a5eb82", "patch": "@@ -96,7 +96,7 @@ pub fn where_clauses(cx: &DocContext, clauses: Vec<WP>) -> Vec<WP> {\n             if !trait_is_same_or_supertrait(cx, did, trait_did) {\n                 return false\n             }\n-            let last = path.segments.last_mut().unwrap();\n+            let last = path.segments.last_mut().expect(\"segments were empty\");\n             match last.args {\n                 PP::AngleBracketed { ref mut bindings, .. } => {\n                     bindings.push(clean::TypeBinding {"}]}