{"sha": "62220abfa65b9d961f23da998ec94d3727477957", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYyMjIwYWJmYTY1YjlkOTYxZjIzZGE5OThlYzk0ZDM3Mjc0Nzc5NTc=", "commit": {"author": {"name": "Michael Recachinas", "email": "mgr3yp@virginia.edu", "date": "2018-04-01T18:28:07Z"}, "committer": {"name": "Michael Recachinas", "email": "mgr3yp@virginia.edu", "date": "2018-04-01T22:19:53Z"}, "message": "Add implementation and tests for literal checking in print/println format args", "tree": {"sha": "4e62843614a1f35ea073e316c691983d8bb2c433", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4e62843614a1f35ea073e316c691983d8bb2c433"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/62220abfa65b9d961f23da998ec94d3727477957", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/62220abfa65b9d961f23da998ec94d3727477957", "html_url": "https://github.com/rust-lang/rust/commit/62220abfa65b9d961f23da998ec94d3727477957", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/62220abfa65b9d961f23da998ec94d3727477957/comments", "author": null, "committer": null, "parents": [{"sha": "83e210935dcddb20d2dbaacd9db6e05bd9bd6bca", "url": "https://api.github.com/repos/rust-lang/rust/commits/83e210935dcddb20d2dbaacd9db6e05bd9bd6bca", "html_url": "https://github.com/rust-lang/rust/commit/83e210935dcddb20d2dbaacd9db6e05bd9bd6bca"}], "stats": {"total": 197, "additions": 196, "deletions": 1}, "files": [{"sha": "a52d76e81da9e297eb4bfb7c2638e0b8a17cf083", "filename": "clippy_lints/src/print.rs", "status": "modified", "additions": 64, "deletions": 1, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/62220abfa65b9d961f23da998ec94d3727477957/clippy_lints%2Fsrc%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62220abfa65b9d961f23da998ec94d3727477957/clippy_lints%2Fsrc%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fprint.rs?ref=62220abfa65b9d961f23da998ec94d3727477957", "patch": "@@ -78,12 +78,28 @@ declare_clippy_lint! {\n     \"use of `Debug`-based formatting\"\n }\n \n+/// **What it does:** This lint warns about the use of literals as `print!`/`println!` args.\n+///\n+/// **Why is this bad?** Using literals as `println!` args is inefficient\n+/// (c.f., https://github.com/matthiaskrgr/rust-str-bench) and unnecessary\n+/// (i.e., just put the literal in the format string)\n+///\n+/// **Example:**\n+/// ```rust\n+/// println!(\"{}\", \"foo\");\n+/// ```\n+declare_lint! {\n+    pub PRINT_LITERAL,\n+    Allow,\n+    \"printing a literal with a format string\"\n+}\n+\n #[derive(Copy, Clone, Debug)]\n pub struct Pass;\n \n impl LintPass for Pass {\n     fn get_lints(&self) -> LintArray {\n-        lint_array!(PRINT_WITH_NEWLINE, PRINTLN_EMPTY_STRING, PRINT_STDOUT, USE_DEBUG)\n+        lint_array!(PRINT_WITH_NEWLINE, PRINTLN_EMPTY_STRING, PRINT_STDOUT, USE_DEBUG, PRINT_LITERAL)\n     }\n }\n \n@@ -107,6 +123,10 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n \n                         span_lint(cx, PRINT_STDOUT, span, &format!(\"use of `{}!`\", name));\n \n+                        // Check for literals in the print!/println! args\n+                        // Also, ensure the format string is `{}` with no special options, like `{:X}`\n+                        check_print_args_for_literal(cx, args);\n+\n                         if_chain! {\n                             // ensure we're calling Arguments::new_v1\n                             if args.len() == 1;\n@@ -146,6 +166,49 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     }\n }\n \n+// Check for literals in print!/println! args\n+// ensuring the format string for the literal is `DISPLAY_FMT_METHOD`\n+// e.g., `println!(\"... {} ...\", \"foo\")`\n+//                                ^ literal in `println!`\n+fn check_print_args_for_literal<'a, 'tcx>(\n+    cx: &LateContext<'a, 'tcx>,\n+    args: &HirVec<Expr>\n+) {\n+    if_chain! {\n+        if args.len() == 1;\n+        if let ExprCall(_, ref args_args) = args[0].node;\n+        if args_args.len() > 1;\n+        if let ExprAddrOf(_, ref match_expr) = args_args[1].node;\n+        if let ExprMatch(ref matchee, ref arms, _) = match_expr.node;\n+        if let ExprTup(ref tup) = matchee.node;\n+        if arms.len() == 1;\n+        if let ExprArray(ref arm_body_exprs) = arms[0].body.node;\n+        then {\n+            // it doesn't matter how many args there are in the `print!`/`println!`,\n+            // if there's one literal, we should warn the user\n+            for (idx, tup_arg) in tup.iter().enumerate() {\n+                if_chain! {\n+                    // first, make sure we're dealing with a literal (i.e., an ExprLit)\n+                    if let ExprAddrOf(_, ref tup_val) = tup_arg.node;\n+                    if let ExprLit(_) = tup_val.node;\n+\n+                    // next, check the corresponding match arm body to ensure\n+                    // this is \"{}\", or DISPLAY_FMT_METHOD\n+                    if let ExprCall(_, ref body_args) = arm_body_exprs[idx].node;\n+                    if body_args.len() == 2;\n+                    if let ExprPath(ref body_qpath) = body_args[1].node;\n+                    if let Some(fun_def_id) = opt_def_id(resolve_node(cx, body_qpath, body_args[1].hir_id));\n+                    if match_def_path(cx.tcx, fun_def_id, &paths::DISPLAY_FMT_METHOD) ||\n+                       match_def_path(cx.tcx, fun_def_id, &paths::DEBUG_FMT_METHOD);\n+                    then {\n+                        span_lint(cx, PRINT_LITERAL, tup_val.span, \"printing a literal with an empty format string\");\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n // Check for print!(\"... \\n\", ...).\n fn check_print<'a, 'tcx>(\n     cx: &LateContext<'a, 'tcx>,"}, {"sha": "c803294ab0ada31dce75fd4bde196802f0a8fd2a", "filename": "tests/ui/print_literal.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/62220abfa65b9d961f23da998ec94d3727477957/tests%2Fui%2Fprint_literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62220abfa65b9d961f23da998ec94d3727477957/tests%2Fui%2Fprint_literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fprint_literal.rs?ref=62220abfa65b9d961f23da998ec94d3727477957", "patch": "@@ -0,0 +1,32 @@\n+\n+\n+#![warn(print_literal)]\n+\n+fn main() {\n+    // these should be fine\n+    print!(\"Hello\");\n+    println!(\"Hello\");\n+    let world = \"world\";\n+    println!(\"Hello {}\", world);\n+    println!(\"3 in hex is {:X}\", 3);\n+\n+    // these should throw warnings\n+    print!(\"Hello {}\", \"world\");\n+    println!(\"Hello {} {}\", world, \"world\");\n+    println!(\"Hello {}\", \"world\");\n+    println!(\"10 / 4 is {}\", 2.5);\n+    println!(\"2 + 1 = {}\", 3);\n+    println!(\"2 + 1 = {:.4}\", 3);\n+    println!(\"2 + 1 = {:5.4}\", 3);\n+    println!(\"Debug test {:?}\", \"hello, world\");\n+\n+    // positional args don't change the fact\n+    // that we're using a literal -- this should\n+    // throw a warning\n+    println!(\"{0} {1}\", \"hello\", \"world\");\n+    println!(\"{1} {0}\", \"hello\", \"world\");\n+\n+    // named args shouldn't change anything either\n+    println!(\"{foo} {bar}\", foo=\"hello\", bar=\"world\");\n+    println!(\"{bar} {foo}\", foo=\"hello\", bar=\"world\");\n+}"}, {"sha": "982be7dc5373ea5591cc5dc71af8cab21f119471", "filename": "tests/ui/print_literal.stderr", "status": "added", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/62220abfa65b9d961f23da998ec94d3727477957/tests%2Fui%2Fprint_literal.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/62220abfa65b9d961f23da998ec94d3727477957/tests%2Fui%2Fprint_literal.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fprint_literal.stderr?ref=62220abfa65b9d961f23da998ec94d3727477957", "patch": "@@ -0,0 +1,100 @@\n+error: printing a literal with an empty format string\n+  --> $DIR/print_literal.rs:14:24\n+   |\n+14 |     print!(\"Hello {}\", \"world\");\n+   |                        ^^^^^^^\n+   |\n+   = note: `-D print-literal` implied by `-D warnings`\n+\n+error: printing a literal with an empty format string\n+  --> $DIR/print_literal.rs:15:36\n+   |\n+15 |     println!(\"Hello {} {}\", world, \"world\");\n+   |                                    ^^^^^^^\n+\n+error: printing a literal with an empty format string\n+  --> $DIR/print_literal.rs:16:26\n+   |\n+16 |     println!(\"Hello {}\", \"world\");\n+   |                          ^^^^^^^\n+\n+error: printing a literal with an empty format string\n+  --> $DIR/print_literal.rs:17:30\n+   |\n+17 |     println!(\"10 / 4 is {}\", 2.5);\n+   |                              ^^^\n+\n+error: printing a literal with an empty format string\n+  --> $DIR/print_literal.rs:18:28\n+   |\n+18 |     println!(\"2 + 1 = {}\", 3);\n+   |                            ^\n+\n+error: printing a literal with an empty format string\n+  --> $DIR/print_literal.rs:19:31\n+   |\n+19 |     println!(\"2 + 1 = {:.4}\", 3);\n+   |                               ^\n+\n+error: printing a literal with an empty format string\n+  --> $DIR/print_literal.rs:20:32\n+   |\n+20 |     println!(\"2 + 1 = {:5.4}\", 3);\n+   |                                ^\n+\n+error: printing a literal with an empty format string\n+  --> $DIR/print_literal.rs:21:33\n+   |\n+21 |     println!(\"Debug test {:?}\", \"hello, world\");\n+   |                                 ^^^^^^^^^^^^^^\n+\n+error: printing a literal with an empty format string\n+  --> $DIR/print_literal.rs:26:25\n+   |\n+26 |     println!(\"{0} {1}\", \"hello\", \"world\");\n+   |                         ^^^^^^^\n+\n+error: printing a literal with an empty format string\n+  --> $DIR/print_literal.rs:26:34\n+   |\n+26 |     println!(\"{0} {1}\", \"hello\", \"world\");\n+   |                                  ^^^^^^^\n+\n+error: printing a literal with an empty format string\n+  --> $DIR/print_literal.rs:27:25\n+   |\n+27 |     println!(\"{1} {0}\", \"hello\", \"world\");\n+   |                         ^^^^^^^\n+\n+error: printing a literal with an empty format string\n+  --> $DIR/print_literal.rs:27:34\n+   |\n+27 |     println!(\"{1} {0}\", \"hello\", \"world\");\n+   |                                  ^^^^^^^\n+\n+error: printing a literal with an empty format string\n+  --> $DIR/print_literal.rs:30:33\n+   |\n+30 |     println!(\"{foo} {bar}\", foo=\"hello\", bar=\"world\");\n+   |                                 ^^^^^^^\n+\n+error: printing a literal with an empty format string\n+  --> $DIR/print_literal.rs:30:46\n+   |\n+30 |     println!(\"{foo} {bar}\", foo=\"hello\", bar=\"world\");\n+   |                                              ^^^^^^^\n+\n+error: printing a literal with an empty format string\n+  --> $DIR/print_literal.rs:31:33\n+   |\n+31 |     println!(\"{bar} {foo}\", foo=\"hello\", bar=\"world\");\n+   |                                 ^^^^^^^\n+\n+error: printing a literal with an empty format string\n+  --> $DIR/print_literal.rs:31:46\n+   |\n+31 |     println!(\"{bar} {foo}\", foo=\"hello\", bar=\"world\");\n+   |                                              ^^^^^^^\n+\n+error: aborting due to 16 previous errors\n+"}]}