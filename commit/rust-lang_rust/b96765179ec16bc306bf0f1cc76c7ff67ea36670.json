{"sha": "b96765179ec16bc306bf0f1cc76c7ff67ea36670", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI5Njc2NTE3OWVjMTZiYzMwNmJmMGYxY2M3NmM3ZmY2N2VhMzY2NzA=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-03-27T22:24:50Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-04-19T19:05:18Z"}, "message": "core: Add rt::context for figuring out what runtime services are available\n\nConflicts:\n\tsrc/libcore/rt/sched/mod.rs", "tree": {"sha": "62e40dee11caf34bc9a3c4c829a933411b900ea1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/62e40dee11caf34bc9a3c4c829a933411b900ea1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b96765179ec16bc306bf0f1cc76c7ff67ea36670", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b96765179ec16bc306bf0f1cc76c7ff67ea36670", "html_url": "https://github.com/rust-lang/rust/commit/b96765179ec16bc306bf0f1cc76c7ff67ea36670", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b96765179ec16bc306bf0f1cc76c7ff67ea36670/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c44d7a64865c5aa9507351be881e4c18ef38e4b0", "url": "https://api.github.com/repos/rust-lang/rust/commits/c44d7a64865c5aa9507351be881e4c18ef38e4b0", "html_url": "https://github.com/rust-lang/rust/commit/c44d7a64865c5aa9507351be881e4c18ef38e4b0"}], "stats": {"total": 117, "additions": 116, "deletions": 1}, "files": [{"sha": "ba61b49d14a4e8bcd3310d619a72899c32a90079", "filename": "src/libcore/rt/mod.rs", "status": "modified", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/b96765179ec16bc306bf0f1cc76c7ff67ea36670/src%2Flibcore%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b96765179ec16bc306bf0f1cc76c7ff67ea36670/src%2Flibcore%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fmod.rs?ref=b96765179ec16bc306bf0f1cc76c7ff67ea36670", "patch": "@@ -88,3 +88,75 @@ pub fn start(main: *u8, _argc: int, _argv: **c_char, _crate_map: *u8) -> int {\n         fn rust_call_nullary_fn(f: *u8);\n     }\n }\n+\n+/// Possible contexts in which Rust code may be executing.\n+/// Different runtime services are available depending on context.\n+#[deriving(Eq)]\n+pub enum RuntimeContext {\n+    // Only default services, e.g. exchange heap\n+    GlobalContext,\n+    // The scheduler may be accessed\n+    SchedulerContext,\n+    // Full task services, e.g. local heap, unwinding\n+    TaskContext,\n+    // Running in an old-style task\n+    OldTaskContext\n+}\n+\n+pub fn context() -> RuntimeContext {\n+\n+    use task::rt::rust_task;\n+    use self::sched::Scheduler;\n+\n+    // XXX: Hitting TLS twice to check if the scheduler exists\n+    // then to check for the task is not good for perf\n+    if unsafe { rust_try_get_task().is_not_null() } {\n+        return OldTaskContext;\n+    } else {\n+        if Scheduler::have_local() {\n+            let context = ::cell::empty_cell();\n+            do Scheduler::borrow_local |sched| {\n+                if sched.in_task_context() {\n+                    context.put_back(TaskContext);\n+                } else {\n+                    context.put_back(SchedulerContext);\n+                }\n+            }\n+            return context.take();\n+        } else {\n+            return GlobalContext;\n+        }\n+    }\n+\n+    pub extern {\n+        #[rust_stack]\n+        fn rust_try_get_task() -> *rust_task;\n+    }\n+}\n+\n+#[test]\n+fn test_context() {\n+    use unstable::run_in_bare_thread;\n+    use self::sched::{Scheduler, Task};\n+    use self::uvio::UvEventLoop;\n+    use cell::Cell;\n+\n+    assert!(context() == OldTaskContext);\n+    do run_in_bare_thread {\n+        assert!(context() == GlobalContext);\n+        let mut sched = ~UvEventLoop::new_scheduler();\n+        let task = ~do Task::new(&mut sched.stack_pool) {\n+            assert!(context() == TaskContext);\n+            let sched = Scheduler::take_local();\n+            do sched.deschedule_running_task_and_then() |task| {\n+                assert!(context() == SchedulerContext);\n+                let task = Cell(task);\n+                do Scheduler::borrow_local |sched| {\n+                    sched.task_queue.push_back(task.take());\n+                }\n+            }\n+        };\n+        sched.task_queue.push_back(task);\n+        sched.run();\n+    }\n+}"}, {"sha": "0eb97ee67ec8a4431150dcd63991575a928bde2b", "filename": "src/libcore/rt/sched/local.rs", "status": "modified", "additions": 33, "deletions": 1, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/b96765179ec16bc306bf0f1cc76c7ff67ea36670/src%2Flibcore%2Frt%2Fsched%2Flocal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b96765179ec16bc306bf0f1cc76c7ff67ea36670/src%2Flibcore%2Frt%2Fsched%2Flocal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fsched%2Flocal.rs?ref=b96765179ec16bc306bf0f1cc76c7ff67ea36670", "patch": "@@ -10,6 +10,7 @@\n \n //! Access to the thread-local Scheduler\n \n+use prelude::*;\n use ptr::mut_null;\n use libc::c_void;\n use cast::transmute;\n@@ -39,6 +40,16 @@ pub fn take() -> ~Scheduler {\n     }\n }\n \n+/// Check whether there is a thread-local Scheduler attached to the running thread\n+pub fn exists() -> bool {\n+    unsafe {\n+        match maybe_tls_key() {\n+            Some(key) => tls::get(key).is_not_null(),\n+            None => false\n+        }\n+    }\n+}\n+\n /// Borrow a mutable reference to the thread-local Scheduler\n /// # Safety Note\n /// Because this leaves the Scheduler in thread-local storage it is possible\n@@ -60,10 +71,31 @@ pub unsafe fn borrow() -> &mut Scheduler {\n }\n \n fn tls_key() -> tls::Key {\n+    maybe_tls_key().get()\n+}\n+\n+fn maybe_tls_key() -> Option<tls::Key> {\n     unsafe {\n         let key: *mut c_void = rust_get_sched_tls_key();\n         let key: &mut tls::Key = transmute(key);\n-        return *key;\n+        let key = *key;\n+        // Check that the key has been initialized.\n+\n+        // NB: This is a little racy because, while the key is\n+        // initalized under a mutex and it's assumed to be initalized\n+        // in the Scheduler ctor by any thread that needs to use it,\n+        // we are not accessing the key under a mutex.  Threads that\n+        // are not using the new Scheduler but still *want to check*\n+        // whether they are running under a new Scheduler may see a 0\n+        // value here that is in the process of being initialized in\n+        // another thread. I think this is fine since the only action\n+        // they could take if it was initialized would be to check the\n+        // thread-local value and see that it's not set.\n+        if key != 0 {\n+            return Some(key);\n+        } else {\n+            return None;\n+        }\n     }\n }\n "}, {"sha": "1141ea480c959364ce60ba1ec3df5186669a1e20", "filename": "src/libcore/rt/sched/mod.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b96765179ec16bc306bf0f1cc76c7ff67ea36670/src%2Flibcore%2Frt%2Fsched%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b96765179ec16bc306bf0f1cc76c7ff67ea36670/src%2Flibcore%2Frt%2Fsched%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fsched%2Fmod.rs?ref=b96765179ec16bc306bf0f1cc76c7ff67ea36670", "patch": "@@ -133,6 +133,11 @@ pub impl Scheduler {\n         local::take()\n     }\n \n+    /// Just check whether there is a local scheduler\n+    fn have_local() -> bool {\n+        local::exists()\n+    }\n+\n     // * Scheduler-context operations\n \n     fn resume_task_from_queue(~self) -> bool {"}, {"sha": "a0db6f64f69fcd349122d9321df5b17ecb4b9284", "filename": "src/rt/rust_builtin.cpp", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b96765179ec16bc306bf0f1cc76c7ff67ea36670/src%2Frt%2Frust_builtin.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/b96765179ec16bc306bf0f1cc76c7ff67ea36670/src%2Frt%2Frust_builtin.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_builtin.cpp?ref=b96765179ec16bc306bf0f1cc76c7ff67ea36670", "patch": "@@ -539,6 +539,11 @@ rust_get_task() {\n     return rust_get_current_task();\n }\n \n+extern \"C\" rust_task *\n+rust_try_get_task() {\n+    return rust_try_get_current_task();\n+}\n+\n extern \"C\" CDECL stk_seg *\n rust_get_stack_segment() {\n     return rust_get_current_task()->stk;"}, {"sha": "5a556ed2107dfdc45a82b28ff219ce164b2a2ce5", "filename": "src/rt/rustrt.def.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b96765179ec16bc306bf0f1cc76c7ff67ea36670/src%2Frt%2Frustrt.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/b96765179ec16bc306bf0f1cc76c7ff67ea36670/src%2Frt%2Frustrt.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frustrt.def.in?ref=b96765179ec16bc306bf0f1cc76c7ff67ea36670", "patch": "@@ -47,6 +47,7 @@ rust_env_pairs\n rust_task_yield\n rust_task_is_unwinding\n rust_get_task\n+rust_try_get_task\n rust_get_stack_segment\n rust_log_str\n start_task"}]}