{"sha": "7e2c41dbd68014acbf91c2657a975c5a4b486da9", "node_id": "C_kwDOAAsO6NoAKDdlMmM0MWRiZDY4MDE0YWNiZjkxYzI2NTdhOTc1YzVhNGI0ODZkYTk", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-08-27T16:28:09Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-10-19T21:21:29Z"}, "message": "Implement invocation strategy config for build scripts", "tree": {"sha": "62f814c69442d2f5a9fe47bf22e818f935958bf5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/62f814c69442d2f5a9fe47bf22e818f935958bf5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7e2c41dbd68014acbf91c2657a975c5a4b486da9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7e2c41dbd68014acbf91c2657a975c5a4b486da9", "html_url": "https://github.com/rust-lang/rust/commit/7e2c41dbd68014acbf91c2657a975c5a4b486da9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7e2c41dbd68014acbf91c2657a975c5a4b486da9/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "40cbeb5b3d1ec37e8857844e43c75b6980f588e3", "url": "https://api.github.com/repos/rust-lang/rust/commits/40cbeb5b3d1ec37e8857844e43c75b6980f588e3", "html_url": "https://github.com/rust-lang/rust/commit/40cbeb5b3d1ec37e8857844e43c75b6980f588e3"}], "stats": {"total": 485, "additions": 348, "deletions": 137}, "files": [{"sha": "6e6654e74e1a10492c1b1975c72a3422e4166dcc", "filename": "crates/project-model/src/build_scripts.rs", "status": "modified", "additions": 224, "deletions": 126, "changes": 350, "blob_url": "https://github.com/rust-lang/rust/blob/7e2c41dbd68014acbf91c2657a975c5a4b486da9/crates%2Fproject-model%2Fsrc%2Fbuild_scripts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e2c41dbd68014acbf91c2657a975c5a4b486da9/crates%2Fproject-model%2Fsrc%2Fbuild_scripts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproject-model%2Fsrc%2Fbuild_scripts.rs?ref=7e2c41dbd68014acbf91c2657a975c5a4b486da9", "patch": "@@ -6,7 +6,12 @@\n //! This module implements this second part. We use \"build script\" terminology\n //! here, but it covers procedural macros as well.\n \n-use std::{cell::RefCell, io, path::PathBuf, process::Command};\n+use std::{\n+    cell::RefCell,\n+    io, mem,\n+    path::{self, PathBuf},\n+    process::Command,\n+};\n \n use cargo_metadata::{camino::Utf8Path, Message};\n use la_arena::ArenaMap;\n@@ -15,11 +20,13 @@ use rustc_hash::FxHashMap;\n use semver::Version;\n use serde::Deserialize;\n \n-use crate::{cfg_flag::CfgFlag, CargoConfig, CargoFeatures, CargoWorkspace, Package};\n+use crate::{\n+    cfg_flag::CfgFlag, CargoConfig, CargoFeatures, CargoWorkspace, InvocationStrategy, Package,\n+};\n \n #[derive(Debug, Default, Clone, PartialEq, Eq)]\n pub struct WorkspaceBuildScripts {\n-    outputs: ArenaMap<Package, Option<BuildScriptOutput>>,\n+    outputs: ArenaMap<Package, BuildScriptOutput>,\n     error: Option<String>,\n }\n \n@@ -38,86 +45,165 @@ pub(crate) struct BuildScriptOutput {\n     pub(crate) proc_macro_dylib_path: Option<AbsPathBuf>,\n }\n \n-impl WorkspaceBuildScripts {\n-    fn build_command(config: &CargoConfig) -> Command {\n-        if let Some([program, args @ ..]) = config.run_build_script_command.as_deref() {\n-            let mut cmd = Command::new(program);\n-            cmd.args(args);\n-            cmd.envs(&config.extra_env);\n-            return cmd;\n-        }\n+impl BuildScriptOutput {\n+    fn is_unchanged(&self) -> bool {\n+        self.cfgs.is_empty()\n+            && self.envs.is_empty()\n+            && self.out_dir.is_none()\n+            && self.proc_macro_dylib_path.is_none()\n+    }\n+}\n \n-        let mut cmd = Command::new(toolchain::cargo());\n-        cmd.envs(&config.extra_env);\n-        cmd.args(&[\"check\", \"--quiet\", \"--workspace\", \"--message-format=json\"]);\n+impl WorkspaceBuildScripts {\n+    fn build_command(config: &CargoConfig) -> io::Result<Command> {\n+        let mut cmd = match config.run_build_script_command.as_deref() {\n+            Some([program, args @ ..]) => {\n+                let mut cmd = Command::new(program);\n+                cmd.args(args);\n+                cmd\n+            }\n+            _ => {\n+                let mut cmd = Command::new(toolchain::cargo());\n \n-        // --all-targets includes tests, benches and examples in addition to the\n-        // default lib and bins. This is an independent concept from the --targets\n-        // flag below.\n-        cmd.arg(\"--all-targets\");\n+                cmd.args(&[\"check\", \"--quiet\", \"--workspace\", \"--message-format=json\"]);\n \n-        if let Some(target) = &config.target {\n-            cmd.args(&[\"--target\", target]);\n-        }\n+                // --all-targets includes tests, benches and examples in addition to the\n+                // default lib and bins. This is an independent concept from the --targets\n+                // flag below.\n+                cmd.arg(\"--all-targets\");\n \n-        match &config.features {\n-            CargoFeatures::All => {\n-                cmd.arg(\"--all-features\");\n-            }\n-            CargoFeatures::Selected { features, no_default_features } => {\n-                if *no_default_features {\n-                    cmd.arg(\"--no-default-features\");\n+                if let Some(target) = &config.target {\n+                    cmd.args(&[\"--target\", target]);\n                 }\n-                if !features.is_empty() {\n-                    cmd.arg(\"--features\");\n-                    cmd.arg(features.join(\" \"));\n+\n+                match &config.features {\n+                    CargoFeatures::All => {\n+                        cmd.arg(\"--all-features\");\n+                    }\n+                    CargoFeatures::Selected { features, no_default_features } => {\n+                        if *no_default_features {\n+                            cmd.arg(\"--no-default-features\");\n+                        }\n+                        if !features.is_empty() {\n+                            cmd.arg(\"--features\");\n+                            cmd.arg(features.join(\" \"));\n+                        }\n+                    }\n                 }\n+                cmd\n             }\n+        };\n+        cmd.envs(&config.extra_env);\n+        if config.wrap_rustc_in_build_scripts {\n+            // Setup RUSTC_WRAPPER to point to `rust-analyzer` binary itself. We use\n+            // that to compile only proc macros and build scripts during the initial\n+            // `cargo check`.\n+            let myself = std::env::current_exe()?;\n+            cmd.env(\"RUSTC_WRAPPER\", myself);\n+            cmd.env(\"RA_RUSTC_WRAPPER\", \"1\");\n         }\n \n-        cmd\n+        Ok(cmd)\n     }\n \n-    pub(crate) fn run(\n+    /// Runs the build scripts for the given workspace\n+    pub(crate) fn run_for_workspace(\n         config: &CargoConfig,\n         workspace: &CargoWorkspace,\n         progress: &dyn Fn(String),\n         toolchain: &Option<Version>,\n     ) -> io::Result<WorkspaceBuildScripts> {\n         const RUST_1_62: Version = Version::new(1, 62, 0);\n \n-        match Self::run_(Self::build_command(config), config, workspace, progress) {\n+        match Self::run_per_ws(Self::build_command(config)?, config, workspace, progress) {\n             Ok(WorkspaceBuildScripts { error: Some(error), .. })\n                 if toolchain.as_ref().map_or(false, |it| *it >= RUST_1_62) =>\n             {\n                 // building build scripts failed, attempt to build with --keep-going so\n                 // that we potentially get more build data\n-                let mut cmd = Self::build_command(config);\n+                let mut cmd = Self::build_command(config)?;\n                 cmd.args(&[\"-Z\", \"unstable-options\", \"--keep-going\"]).env(\"RUSTC_BOOTSTRAP\", \"1\");\n-                let mut res = Self::run_(cmd, config, workspace, progress)?;\n+                let mut res = Self::run_per_ws(cmd, config, workspace, progress)?;\n                 res.error = Some(error);\n                 Ok(res)\n             }\n             res => res,\n         }\n     }\n \n-    fn run_(\n+    /// Runs the build scripts by invoking the configured command *once*.\n+    /// This populates the outputs for all passed in workspaces.\n+    pub(crate) fn run_once(\n+        config: &CargoConfig,\n+        workspaces: &[&CargoWorkspace],\n+        progress: &dyn Fn(String),\n+    ) -> io::Result<Vec<WorkspaceBuildScripts>> {\n+        assert_eq!(config.invocation_strategy, InvocationStrategy::OnceInRoot);\n+        let cmd = Self::build_command(config)?;\n+        // NB: Cargo.toml could have been modified between `cargo metadata` and\n+        // `cargo check`. We shouldn't assume that package ids we see here are\n+        // exactly those from `config`.\n+        let mut by_id = FxHashMap::default();\n+        let mut res: Vec<_> = workspaces\n+            .iter()\n+            .enumerate()\n+            .map(|(idx, workspace)| {\n+                let mut res = WorkspaceBuildScripts::default();\n+                for package in workspace.packages() {\n+                    res.outputs.insert(package, BuildScriptOutput::default());\n+                    by_id.insert(workspace[package].id.clone(), (package, idx));\n+                }\n+                res\n+            })\n+            .collect();\n+\n+        let errors = Self::run_command(\n+            cmd,\n+            |package, cb| {\n+                if let Some(&(package, workspace)) = by_id.get(package) {\n+                    cb(&workspaces[workspace][package].name, &mut res[workspace].outputs[package]);\n+                }\n+            },\n+            progress,\n+        )?;\n+        res.iter_mut().for_each(|it| it.error = errors.clone());\n+\n+        if tracing::enabled!(tracing::Level::INFO) {\n+            for (idx, workspace) in workspaces.iter().enumerate() {\n+                for package in workspace.packages() {\n+                    let package_build_data = &mut res[idx].outputs[package];\n+                    if !package_build_data.is_unchanged() {\n+                        tracing::info!(\n+                            \"{}: {:?}\",\n+                            workspace[package].manifest.parent().display(),\n+                            package_build_data,\n+                        );\n+                    }\n+                }\n+            }\n+        }\n+\n+        Ok(res)\n+    }\n+\n+    fn run_per_ws(\n         mut cmd: Command,\n         config: &CargoConfig,\n         workspace: &CargoWorkspace,\n         progress: &dyn Fn(String),\n     ) -> io::Result<WorkspaceBuildScripts> {\n-        if config.wrap_rustc_in_build_scripts {\n-            // Setup RUSTC_WRAPPER to point to `rust-analyzer` binary itself. We use\n-            // that to compile only proc macros and build scripts during the initial\n-            // `cargo check`.\n-            let myself = std::env::current_exe()?;\n-            cmd.env(\"RUSTC_WRAPPER\", myself);\n-            cmd.env(\"RA_RUSTC_WRAPPER\", \"1\");\n-        }\n+        let workspace_root: &path::Path = &workspace.workspace_root().as_ref();\n \n-        cmd.current_dir(workspace.workspace_root());\n+        match config.invocation_strategy {\n+            InvocationStrategy::OnceInRoot => (),\n+            InvocationStrategy::PerWorkspaceWithManifestPath => {\n+                cmd.arg(\"--manifest-path\");\n+                cmd.arg(workspace_root.join(\"Cargo.toml\"));\n+            }\n+            InvocationStrategy::PerWorkspace => {\n+                cmd.current_dir(workspace_root);\n+            }\n+        }\n \n         let mut res = WorkspaceBuildScripts::default();\n         let outputs = &mut res.outputs;\n@@ -126,10 +212,44 @@ impl WorkspaceBuildScripts {\n         // exactly those from `config`.\n         let mut by_id: FxHashMap<String, Package> = FxHashMap::default();\n         for package in workspace.packages() {\n-            outputs.insert(package, None);\n+            outputs.insert(package, BuildScriptOutput::default());\n             by_id.insert(workspace[package].id.clone(), package);\n         }\n \n+        res.error = Self::run_command(\n+            cmd,\n+            |package, cb| {\n+                if let Some(&package) = by_id.get(package) {\n+                    cb(&workspace[package].name, &mut outputs[package]);\n+                }\n+            },\n+            progress,\n+        )?;\n+\n+        if tracing::enabled!(tracing::Level::INFO) {\n+            for package in workspace.packages() {\n+                let package_build_data = &mut outputs[package];\n+                if !package_build_data.is_unchanged() {\n+                    tracing::info!(\n+                        \"{}: {:?}\",\n+                        workspace[package].manifest.parent().display(),\n+                        package_build_data,\n+                    );\n+                }\n+            }\n+        }\n+\n+        Ok(res)\n+    }\n+\n+    fn run_command(\n+        cmd: Command,\n+        // ideally this would be something like:\n+        // with_output_for: impl FnMut(&str, dyn FnOnce(&mut BuildScriptOutput)),\n+        // but owned trait objects aren't a thing\n+        mut with_output_for: impl FnMut(&str, &mut dyn FnMut(&str, &mut BuildScriptOutput)),\n+        progress: &dyn Fn(String),\n+    ) -> io::Result<Option<String>> {\n         let errors = RefCell::new(String::new());\n         let push_err = |err: &str| {\n             let mut e = errors.borrow_mut();\n@@ -149,61 +269,58 @@ impl WorkspaceBuildScripts {\n                     .unwrap_or_else(|_| Message::TextLine(line.to_string()));\n \n                 match message {\n-                    Message::BuildScriptExecuted(message) => {\n-                        let package = match by_id.get(&message.package_id.repr) {\n-                            Some(&it) => it,\n-                            None => return,\n-                        };\n-                        progress(format!(\"running build-script: {}\", workspace[package].name));\n-\n-                        let cfgs = {\n-                            let mut acc = Vec::new();\n-                            for cfg in message.cfgs {\n-                                match cfg.parse::<CfgFlag>() {\n-                                    Ok(it) => acc.push(it),\n-                                    Err(err) => {\n-                                        push_err(&format!(\n-                                            \"invalid cfg from cargo-metadata: {}\",\n-                                            err\n-                                        ));\n-                                        return;\n-                                    }\n-                                };\n+                    Message::BuildScriptExecuted(mut message) => {\n+                        with_output_for(&message.package_id.repr, &mut |name, data| {\n+                            progress(format!(\"running build-script: {}\", name));\n+                            let cfgs = {\n+                                let mut acc = Vec::new();\n+                                for cfg in &message.cfgs {\n+                                    match cfg.parse::<CfgFlag>() {\n+                                        Ok(it) => acc.push(it),\n+                                        Err(err) => {\n+                                            push_err(&format!(\n+                                                \"invalid cfg from cargo-metadata: {}\",\n+                                                err\n+                                            ));\n+                                            return;\n+                                        }\n+                                    };\n+                                }\n+                                acc\n+                            };\n+                            if !message.env.is_empty() {\n+                                data.envs = mem::take(&mut message.env);\n                             }\n-                            acc\n-                        };\n-                        // cargo_metadata crate returns default (empty) path for\n-                        // older cargos, which is not absolute, so work around that.\n-                        let out_dir = message.out_dir.into_os_string();\n-                        if !out_dir.is_empty() {\n-                            let data = outputs[package].get_or_insert_with(Default::default);\n-                            data.out_dir = Some(AbsPathBuf::assert(PathBuf::from(out_dir)));\n-                            data.cfgs = cfgs;\n-                        }\n-                        if !message.env.is_empty() {\n-                            outputs[package].get_or_insert_with(Default::default).envs =\n-                                message.env;\n-                        }\n+                            // cargo_metadata crate returns default (empty) path for\n+                            // older cargos, which is not absolute, so work around that.\n+                            let out_dir = mem::take(&mut message.out_dir).into_os_string();\n+                            if !out_dir.is_empty() {\n+                                let out_dir = AbsPathBuf::assert(PathBuf::from(out_dir));\n+                                // inject_cargo_env(package, package_build_data);\n+                                // NOTE: cargo and rustc seem to hide non-UTF-8 strings from env! and option_env!()\n+                                if let Some(out_dir) =\n+                                    out_dir.as_os_str().to_str().map(|s| s.to_owned())\n+                                {\n+                                    data.envs.push((\"OUT_DIR\".to_string(), out_dir));\n+                                }\n+                                data.out_dir = Some(out_dir);\n+                                data.cfgs = cfgs;\n+                            }\n+                        });\n                     }\n                     Message::CompilerArtifact(message) => {\n-                        let package = match by_id.get(&message.package_id.repr) {\n-                            Some(it) => *it,\n-                            None => return,\n-                        };\n-\n-                        progress(format!(\"building proc-macros: {}\", message.target.name));\n-\n-                        if message.target.kind.iter().any(|k| k == \"proc-macro\") {\n-                            // Skip rmeta file\n-                            if let Some(filename) =\n-                                message.filenames.iter().find(|name| is_dylib(name))\n-                            {\n-                                let filename = AbsPathBuf::assert(PathBuf::from(&filename));\n-                                outputs[package]\n-                                    .get_or_insert_with(Default::default)\n-                                    .proc_macro_dylib_path = Some(filename);\n+                        with_output_for(&message.package_id.repr, &mut |name, data| {\n+                            progress(format!(\"building proc-macros: {}\", name));\n+                            if message.target.kind.iter().any(|k| k == \"proc-macro\") {\n+                                // Skip rmeta file\n+                                if let Some(filename) =\n+                                    message.filenames.iter().find(|name| is_dylib(name))\n+                                {\n+                                    let filename = AbsPathBuf::assert(PathBuf::from(&filename));\n+                                    data.proc_macro_dylib_path = Some(filename);\n+                                }\n                             }\n-                        }\n+                        });\n                     }\n                     Message::CompilerMessage(message) => {\n                         progress(message.target.name);\n@@ -222,44 +339,25 @@ impl WorkspaceBuildScripts {\n             },\n         )?;\n \n-        for package in workspace.packages() {\n-            if let Some(package_build_data) = &mut outputs[package] {\n-                tracing::info!(\n-                    \"{}: {:?}\",\n-                    workspace[package].manifest.parent().display(),\n-                    package_build_data,\n-                );\n-                // inject_cargo_env(package, package_build_data);\n-                if let Some(out_dir) = &package_build_data.out_dir {\n-                    // NOTE: cargo and rustc seem to hide non-UTF-8 strings from env! and option_env!()\n-                    if let Some(out_dir) = out_dir.as_os_str().to_str().map(|s| s.to_owned()) {\n-                        package_build_data.envs.push((\"OUT_DIR\".to_string(), out_dir));\n-                    }\n-                }\n-            }\n-        }\n-\n-        let mut errors = errors.into_inner();\n-        if !output.status.success() {\n-            if errors.is_empty() {\n-                errors = \"cargo check failed\".to_string();\n-            }\n-            res.error = Some(errors);\n-        }\n-\n-        Ok(res)\n+        let errors = if !output.status.success() {\n+            let errors = errors.into_inner();\n+            Some(if errors.is_empty() { \"cargo check failed\".to_string() } else { errors })\n+        } else {\n+            None\n+        };\n+        Ok(errors)\n     }\n \n     pub fn error(&self) -> Option<&str> {\n         self.error.as_deref()\n     }\n \n     pub(crate) fn get_output(&self, idx: Package) -> Option<&BuildScriptOutput> {\n-        self.outputs.get(idx)?.as_ref()\n+        self.outputs.get(idx)\n     }\n }\n \n-// FIXME: File a better way to know if it is a dylib.\n+// FIXME: Find a better way to know if it is a dylib.\n fn is_dylib(path: &Utf8Path) -> bool {\n     match path.extension().map(|e| e.to_string().to_lowercase()) {\n         None => false,"}, {"sha": "79b56815c021623a8c20c4e1472b714a61485304", "filename": "crates/project-model/src/cargo_workspace.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7e2c41dbd68014acbf91c2657a975c5a4b486da9/crates%2Fproject-model%2Fsrc%2Fcargo_workspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e2c41dbd68014acbf91c2657a975c5a4b486da9/crates%2Fproject-model%2Fsrc%2Fcargo_workspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproject-model%2Fsrc%2Fcargo_workspace.rs?ref=7e2c41dbd68014acbf91c2657a975c5a4b486da9", "patch": "@@ -14,8 +14,8 @@ use rustc_hash::FxHashMap;\n use serde::Deserialize;\n use serde_json::from_value;\n \n-use crate::CfgOverrides;\n use crate::{utf8_stdout, ManifestPath};\n+use crate::{CfgOverrides, InvocationStrategy};\n \n /// [`CargoWorkspace`] represents the logical structure of, well, a Cargo\n /// workspace. It pretty closely mirrors `cargo metadata` output.\n@@ -106,6 +106,7 @@ pub struct CargoConfig {\n     pub run_build_script_command: Option<Vec<String>>,\n     /// Extra env vars to set when invoking the cargo command\n     pub extra_env: FxHashMap<String, String>,\n+    pub invocation_strategy: InvocationStrategy,\n }\n \n impl CargoConfig {"}, {"sha": "13a86901f71c0a039c6640ab207037c6a6604246", "filename": "crates/project-model/src/lib.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7e2c41dbd68014acbf91c2657a975c5a4b486da9/crates%2Fproject-model%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e2c41dbd68014acbf91c2657a975c5a4b486da9/crates%2Fproject-model%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproject-model%2Fsrc%2Flib.rs?ref=7e2c41dbd68014acbf91c2657a975c5a4b486da9", "patch": "@@ -157,3 +157,11 @@ fn utf8_stdout(mut cmd: Command) -> Result<String> {\n     let stdout = String::from_utf8(output.stdout)?;\n     Ok(stdout.trim().to_string())\n }\n+\n+#[derive(Clone, Debug, Default, PartialEq, Eq)]\n+pub enum InvocationStrategy {\n+    OnceInRoot,\n+    PerWorkspaceWithManifestPath,\n+    #[default]\n+    PerWorkspace,\n+}"}, {"sha": "01f5157093ad95ded47d2b804d436471c152ab6c", "filename": "crates/project-model/src/workspace.rs", "status": "modified", "additions": 54, "deletions": 6, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/7e2c41dbd68014acbf91c2657a975c5a4b486da9/crates%2Fproject-model%2Fsrc%2Fworkspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e2c41dbd68014acbf91c2657a975c5a4b486da9/crates%2Fproject-model%2Fsrc%2Fworkspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproject-model%2Fsrc%2Fworkspace.rs?ref=7e2c41dbd68014acbf91c2657a975c5a4b486da9", "patch": "@@ -2,7 +2,7 @@\n //! metadata` or `rust-project.json`) into representation stored in the salsa\n //! database -- `CrateGraph`.\n \n-use std::{collections::VecDeque, fmt, fs, process::Command};\n+use std::{collections::VecDeque, fmt, fs, process::Command, sync::Arc};\n \n use anyhow::{format_err, Context, Result};\n use base_db::{\n@@ -21,8 +21,8 @@ use crate::{\n     cfg_flag::CfgFlag,\n     rustc_cfg,\n     sysroot::SysrootCrate,\n-    utf8_stdout, CargoConfig, CargoWorkspace, ManifestPath, Package, ProjectJson, ProjectManifest,\n-    Sysroot, TargetKind, WorkspaceBuildScripts,\n+    utf8_stdout, CargoConfig, CargoWorkspace, InvocationStrategy, ManifestPath, Package,\n+    ProjectJson, ProjectManifest, Sysroot, TargetKind, WorkspaceBuildScripts,\n };\n \n /// A set of cfg-overrides per crate.\n@@ -294,23 +294,71 @@ impl ProjectWorkspace {\n         Ok(ProjectWorkspace::DetachedFiles { files: detached_files, sysroot, rustc_cfg })\n     }\n \n+    /// Runs the build scripts for this [`ProjectWorkspace`].\n     pub fn run_build_scripts(\n         &self,\n         config: &CargoConfig,\n         progress: &dyn Fn(String),\n     ) -> Result<WorkspaceBuildScripts> {\n         match self {\n             ProjectWorkspace::Cargo { cargo, toolchain, .. } => {\n-                WorkspaceBuildScripts::run(config, cargo, progress, toolchain).with_context(|| {\n-                    format!(\"Failed to run build scripts for {}\", &cargo.workspace_root().display())\n-                })\n+                WorkspaceBuildScripts::run_for_workspace(config, cargo, progress, toolchain)\n+                    .with_context(|| {\n+                        format!(\n+                            \"Failed to run build scripts for {}\",\n+                            &cargo.workspace_root().display()\n+                        )\n+                    })\n             }\n             ProjectWorkspace::Json { .. } | ProjectWorkspace::DetachedFiles { .. } => {\n                 Ok(WorkspaceBuildScripts::default())\n             }\n         }\n     }\n \n+    /// Runs the build scripts for the given [`ProjectWorkspace`]s. Depending on the invocation\n+    /// strategy this may run a single build process for all project workspaces.\n+    pub fn run_all_build_scripts(\n+        workspaces: &[ProjectWorkspace],\n+        config: &CargoConfig,\n+        progress: &dyn Fn(String),\n+    ) -> Vec<Result<WorkspaceBuildScripts>> {\n+        if let InvocationStrategy::PerWorkspaceWithManifestPath | InvocationStrategy::PerWorkspace =\n+            config.invocation_strategy\n+        {\n+            return workspaces.iter().map(|it| it.run_build_scripts(config, progress)).collect();\n+        }\n+\n+        let cargo_ws: Vec<_> = workspaces\n+            .iter()\n+            .filter_map(|it| match it {\n+                ProjectWorkspace::Cargo { cargo, .. } => Some(cargo),\n+                _ => None,\n+            })\n+            .collect();\n+        let ref mut outputs = match WorkspaceBuildScripts::run_once(config, &cargo_ws, progress) {\n+            Ok(it) => Ok(it.into_iter()),\n+            // io::Error is not Clone?\n+            Err(e) => Err(Arc::new(e)),\n+        };\n+\n+        workspaces\n+            .iter()\n+            .map(|it| match it {\n+                ProjectWorkspace::Cargo { cargo, .. } => match outputs {\n+                    Ok(outputs) => Ok(outputs.next().unwrap()),\n+                    Err(e) => Err(e.clone()).with_context(|| {\n+                        format!(\n+                            \"Failed to run build scripts for {}\",\n+                            &cargo.workspace_root().display()\n+                        )\n+                    }),\n+                },\n+                _ => Ok(WorkspaceBuildScripts::default()),\n+            })\n+            .collect()\n+    }\n+\n     pub fn set_build_scripts(&mut self, bs: WorkspaceBuildScripts) {\n         match self {\n             ProjectWorkspace::Cargo { build_scripts, .. } => *build_scripts = bs,"}, {"sha": "79f6ded4899ee4e5b948e2b25b7990ffabb3691a", "filename": "crates/rust-analyzer/src/config.rs", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/7e2c41dbd68014acbf91c2657a975c5a4b486da9/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e2c41dbd68014acbf91c2657a975c5a4b486da9/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs?ref=7e2c41dbd68014acbf91c2657a975c5a4b486da9", "patch": "@@ -69,6 +69,14 @@ config_data! {\n         cargo_autoreload: bool           = \"true\",\n         /// Run build scripts (`build.rs`) for more precise code analysis.\n         cargo_buildScripts_enable: bool  = \"true\",\n+        /// Specifies the invocation strategy to use when running the build scripts command.\n+        /// If `per_workspace_with_manifest_path` is set, the command will be executed for each\n+        /// workspace, `--manifest-path {workspace-dir}` will be passed to the invoked command and\n+        /// the command will be executed from the project root.\n+        /// If `per_workspace` is set, the command will be executed for each workspace and the\n+        /// command will be executed from the corresponding workspace root.\n+        /// If `once_in_root` is set, the command will be executed once in the project root.\n+        cargo_buildScripts_invocationStrategy: InvocationStrategy = \"\\\"per_workspace\\\"\",\n         /// Override the command rust-analyzer uses to run build scripts and\n         /// build procedural macros. The command is required to output json\n         /// and should therefore include `--message-format=json` or a similar\n@@ -1056,6 +1064,13 @@ impl Config {\n             rustc_source,\n             unset_test_crates: UnsetTestCrates::Only(self.data.cargo_unsetTest.clone()),\n             wrap_rustc_in_build_scripts: self.data.cargo_buildScripts_useRustcWrapper,\n+            invocation_strategy: match self.data.cargo_buildScripts_invocationStrategy {\n+                InvocationStrategy::OnceInRoot => project_model::InvocationStrategy::OnceInRoot,\n+                InvocationStrategy::PerWorkspaceWithManifestPath => {\n+                    project_model::InvocationStrategy::PerWorkspaceWithManifestPath\n+                }\n+                InvocationStrategy::PerWorkspace => project_model::InvocationStrategy::PerWorkspace,\n+            },\n             run_build_script_command: self.data.cargo_buildScripts_overrideCommand.clone(),\n             extra_env: self.data.cargo_extraEnv.clone(),\n         }\n@@ -1587,6 +1602,14 @@ enum CargoFeaturesDef {\n     Selected(Vec<String>),\n }\n \n+#[derive(Deserialize, Debug, Clone)]\n+#[serde(rename_all = \"snake_case\")]\n+enum InvocationStrategy {\n+    OnceInRoot,\n+    PerWorkspaceWithManifestPath,\n+    PerWorkspace,\n+}\n+\n #[derive(Deserialize, Debug, Clone)]\n #[serde(untagged)]\n enum LifetimeElisionDef {\n@@ -2001,6 +2024,15 @@ fn field_props(field: &str, ty: &str, doc: &[&str], default: &str) -> serde_json\n                 \"Render annotations above the whole item, including documentation comments and attributes.\"\n             ],\n         },\n+        \"InvocationStrategy\" => set! {\n+            \"type\": \"string\",\n+            \"enum\": [\"per_workspace\", \"per_workspace_with_manifest_path\", \"once_in_root\"],\n+            \"enumDescriptions\": [\n+                \"The command will be executed for each workspace, `--manifest-path {workspace-dir}` will be passed to the invoked command and the command will be executed from the project root.\",\n+                \"The command will be executed for each workspace and the command will be executed from the corresponding workspace root.\",\n+                \"The command will be executed once in the project root.\"\n+            ],\n+        },\n         _ => panic!(\"missing entry for {}: {}\", ty, default),\n     }\n "}, {"sha": "bd5741f615907fce1980dc663725188224bba719", "filename": "crates/rust-analyzer/src/reload.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7e2c41dbd68014acbf91c2657a975c5a4b486da9/crates%2Frust-analyzer%2Fsrc%2Freload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e2c41dbd68014acbf91c2657a975c5a4b486da9/crates%2Frust-analyzer%2Fsrc%2Freload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Freload.rs?ref=7e2c41dbd68014acbf91c2657a975c5a4b486da9", "patch": "@@ -175,10 +175,8 @@ impl GlobalState {\n                     sender.send(Task::FetchBuildData(BuildDataProgress::Report(msg))).unwrap()\n                 }\n             };\n-            let mut res = Vec::new();\n-            for ws in workspaces.iter() {\n-                res.push(ws.run_build_scripts(&config, &progress));\n-            }\n+            let res = ProjectWorkspace::run_all_build_scripts(&workspaces, &config, &progress);\n+\n             sender.send(Task::FetchBuildData(BuildDataProgress::End((workspaces, res)))).unwrap();\n         });\n     }"}, {"sha": "a5307b63151296986604987047e84b1963781631", "filename": "docs/user/generated_config.adoc", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7e2c41dbd68014acbf91c2657a975c5a4b486da9/docs%2Fuser%2Fgenerated_config.adoc", "raw_url": "https://github.com/rust-lang/rust/raw/7e2c41dbd68014acbf91c2657a975c5a4b486da9/docs%2Fuser%2Fgenerated_config.adoc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fuser%2Fgenerated_config.adoc?ref=7e2c41dbd68014acbf91c2657a975c5a4b486da9", "patch": "@@ -24,6 +24,17 @@ Automatically refresh project info via `cargo metadata` on\n --\n Run build scripts (`build.rs`) for more precise code analysis.\n --\n+[[rust-analyzer.cargo.buildScripts.invocationStrategy]]rust-analyzer.cargo.buildScripts.invocationStrategy (default: `\"per_workspace\"`)::\n++\n+--\n+Specifies the invocation strategy to use when running the build scripts command.\n+If `per_workspace_with_manifest_path` is set, the command will be executed for each\n+workspace, `--manifest-path {workspace-dir}` will be passed to the invoked command and\n+the command will be executed from the project root.\n+If `per_workspace` is set, the command will be executed for each workspace and the\n+command will be executed from the corresponding workspace root.\n+If `once_in_root` is set, the command will be executed once in the project root.\n+--\n [[rust-analyzer.cargo.buildScripts.overrideCommand]]rust-analyzer.cargo.buildScripts.overrideCommand (default: `null`)::\n +\n --"}, {"sha": "b1b565106a37f2ca1e3138e514be819a14823fcd", "filename": "editors/code/package.json", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7e2c41dbd68014acbf91c2657a975c5a4b486da9/editors%2Fcode%2Fpackage.json", "raw_url": "https://github.com/rust-lang/rust/raw/7e2c41dbd68014acbf91c2657a975c5a4b486da9/editors%2Fcode%2Fpackage.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fpackage.json?ref=7e2c41dbd68014acbf91c2657a975c5a4b486da9", "patch": "@@ -421,6 +421,21 @@\n                     \"default\": true,\n                     \"type\": \"boolean\"\n                 },\n+                \"rust-analyzer.cargo.buildScripts.invocationStrategy\": {\n+                    \"markdownDescription\": \"Specifies the invocation strategy to use when running the build scripts command.\\nIf `per_workspace_with_manifest_path` is set, the command will be executed for each\\nworkspace, `--manifest-path {workspace-dir}` will be passed to the invoked command and\\nthe command will be executed from the project root.\\nIf `per_workspace` is set, the command will be executed for each workspace and the\\ncommand will be executed from the corresponding workspace root.\\nIf `once_in_root` is set, the command will be executed once in the project root.\",\n+                    \"default\": \"per_workspace\",\n+                    \"type\": \"string\",\n+                    \"enum\": [\n+                        \"per_workspace\",\n+                        \"per_workspace_with_manifest_path\",\n+                        \"once_in_root\"\n+                    ],\n+                    \"enumDescriptions\": [\n+                        \"The command will be executed for each workspace, `--manifest-path {workspace-dir}` will be passed to the invoked command and the command will be executed from the project root.\",\n+                        \"The command will be executed for each workspace and the command will be executed from the corresponding workspace root.\",\n+                        \"The command will be executed once in the project root.\"\n+                    ]\n+                },\n                 \"rust-analyzer.cargo.buildScripts.overrideCommand\": {\n                     \"markdownDescription\": \"Override the command rust-analyzer uses to run build scripts and\\nbuild procedural macros. The command is required to output json\\nand should therefore include `--message-format=json` or a similar\\noption.\\n\\nBy default, a cargo invocation will be constructed for the configured\\ntargets and features, with the following base command line:\\n\\n```bash\\ncargo check --quiet --workspace --message-format=json --all-targets\\n```\\n.\",\n                     \"default\": null,"}]}