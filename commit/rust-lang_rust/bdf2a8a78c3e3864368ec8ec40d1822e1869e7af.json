{"sha": "bdf2a8a78c3e3864368ec8ec40d1822e1869e7af", "node_id": "C_kwDOAAsO6NoAKGJkZjJhOGE3OGMzZTM4NjQzNjhlYzhlYzQwZDE4MjJlMTg2OWU3YWY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-21T04:12:42Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-21T04:12:42Z"}, "message": "Auto merge of #2247 - dtolnay-contrib:rustfmt2, r=RalfJung\n\nFormat tests with rustfmt (101-150 of 300)\n\nExtracted from #2097.\n\nLike https://github.com/rust-lang/miri/pull/2244, these are \"easy\" cases that do not involve moving around comments.", "tree": {"sha": "a58e37ac4ee9a72064d00ef74390f7405056266b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a58e37ac4ee9a72064d00ef74390f7405056266b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bdf2a8a78c3e3864368ec8ec40d1822e1869e7af", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bdf2a8a78c3e3864368ec8ec40d1822e1869e7af", "html_url": "https://github.com/rust-lang/rust/commit/bdf2a8a78c3e3864368ec8ec40d1822e1869e7af", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bdf2a8a78c3e3864368ec8ec40d1822e1869e7af/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4d712a327f222991c71939f9a8454610924a443c", "url": "https://api.github.com/repos/rust-lang/rust/commits/4d712a327f222991c71939f9a8454610924a443c", "html_url": "https://github.com/rust-lang/rust/commit/4d712a327f222991c71939f9a8454610924a443c"}, {"sha": "6b8c371f068ef83fbb11c0829c5c21965eef4aa2", "url": "https://api.github.com/repos/rust-lang/rust/commits/6b8c371f068ef83fbb11c0829c5c21965eef4aa2", "html_url": "https://github.com/rust-lang/rust/commit/6b8c371f068ef83fbb11c0829c5c21965eef4aa2"}], "stats": {"total": 668, "additions": 395, "deletions": 273}, "files": [{"sha": "06f48666c557f3a7ae2ff3ec06bc857958357f64", "filename": "tests/pass/generator.rs", "status": "modified", "additions": 21, "deletions": 9, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/bdf2a8a78c3e3864368ec8ec40d1822e1869e7af/tests%2Fpass%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdf2a8a78c3e3864368ec8ec40d1822e1869e7af/tests%2Fpass%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fgenerator.rs?ref=bdf2a8a78c3e3864368ec8ec40d1822e1869e7af", "patch": "@@ -1,15 +1,19 @@\n #![feature(generators, generator_trait, never_type)]\n \n-use std::ops::{GeneratorState::{self, *}, Generator};\n-use std::pin::Pin;\n-use std::sync::atomic::{AtomicUsize, Ordering};\n use std::fmt::Debug;\n use std::mem::ManuallyDrop;\n+use std::ops::{\n+    Generator,\n+    GeneratorState::{self, *},\n+};\n+use std::pin::Pin;\n use std::ptr;\n+use std::sync::atomic::{AtomicUsize, Ordering};\n \n fn basic() {\n     fn finish<T>(mut amt: usize, mut t: T) -> T::Return\n-        where T: Generator<Yield = usize>\n+    where\n+        T: Generator<Yield = usize>,\n     {\n         // We are not moving the `t` around until it gets dropped, so this is okay.\n         let mut t = unsafe { Pin::new_unchecked(&mut t) };\n@@ -23,7 +27,7 @@ fn basic() {\n                 }\n                 GeneratorState::Complete(ret) => {\n                     assert_eq!(amt, 0);\n-                    return ret\n+                    return ret;\n                 }\n             }\n         }\n@@ -46,7 +50,7 @@ fn basic() {\n         assert_eq!(x, 2);\n     });\n \n-    finish(7*8/2, || {\n+    finish(7 * 8 / 2, || {\n         for i in 0..8 {\n             yield i;\n         }\n@@ -67,7 +71,10 @@ fn basic() {\n     });\n \n     finish(2, || {\n-        if { yield 1; false } {\n+        if {\n+            yield 1;\n+            false\n+        } {\n             yield 1;\n             panic!()\n         }\n@@ -90,7 +97,9 @@ fn basic() {\n     let b = true;\n     finish(1, || {\n         yield 1;\n-        if b { return; }\n+        if b {\n+            return;\n+        }\n         #[allow(unused)]\n         let x = never();\n         #[allow(unreachable_code)]\n@@ -101,7 +110,10 @@ fn basic() {\n     finish(3, || {\n         yield 1;\n         #[allow(unreachable_code)]\n-        let _x: (String, !) = (String::new(), { yield 2; return });\n+        let _x: (String, !) = (String::new(), {\n+            yield 2;\n+            return;\n+        });\n     });\n }\n "}, {"sha": "29ddd6c59a1a6af125f5393c19892bf1455f00e3", "filename": "tests/pass/hashmap.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bdf2a8a78c3e3864368ec8ec40d1822e1869e7af/tests%2Fpass%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdf2a8a78c3e3864368ec8ec40d1822e1869e7af/tests%2Fpass%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fhashmap.rs?ref=bdf2a8a78c3e3864368ec8ec40d1822e1869e7af", "patch": "@@ -17,19 +17,19 @@ fn test_all_refs<'a, T: 'a>(dummy: &mut T, iter: impl Iterator<Item = &'a mut T>\n \n fn smoketest_map<S: BuildHasher>(mut map: HashMap<i32, i32, S>) {\n     map.insert(0, 0);\n-    assert_eq!(map.values().fold(0, |x, y| x+y), 0);\n+    assert_eq!(map.values().fold(0, |x, y| x + y), 0);\n \n     let num = 25;\n     for i in 1..num {\n         map.insert(i, i);\n     }\n-    assert_eq!(map.values().fold(0, |x, y| x+y), num*(num-1)/2); // check the right things are in the table now\n+    assert_eq!(map.values().fold(0, |x, y| x + y), num * (num - 1) / 2); // check the right things are in the table now\n \n     // Inserting again replaces the existing entries\n     for i in 0..num {\n-        map.insert(i, num-1-i);\n+        map.insert(i, num - 1 - i);\n     }\n-    assert_eq!(map.values().fold(0, |x, y| x+y), num*(num-1)/2);\n+    assert_eq!(map.values().fold(0, |x, y| x + y), num * (num - 1) / 2);\n \n     test_all_refs(&mut 13, map.values_mut());\n }"}, {"sha": "8e2799d689056d7e3eb3b5a5a8365f68ccf57b21", "filename": "tests/pass/integer-ops.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bdf2a8a78c3e3864368ec8ec40d1822e1869e7af/tests%2Fpass%2Finteger-ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdf2a8a78c3e3864368ec8ec40d1822e1869e7af/tests%2Fpass%2Finteger-ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Finteger-ops.rs?ref=bdf2a8a78c3e3864368ec8ec40d1822e1869e7af", "patch": "@@ -42,7 +42,7 @@ pub fn main() {\n     let m = -0xFEDCBA987654322i64;\n     assert_eq!(n.rotate_right(4), m);\n \n-    let n =  0x0123456789ABCDEFi64;\n+    let n = 0x0123456789ABCDEFi64;\n     let m = -0x1032547698BADCFFi64;\n     assert_eq!(n.swap_bytes(), m);\n \n@@ -169,9 +169,9 @@ pub fn main() {\n     assert_eq!(0x10i32.overflowing_shr(4), (0x1, false));\n     assert_eq!(0x10i32.overflowing_shr(36), (0x1, true));\n \n-    assert_eq!(10i8.overflowing_abs(), (10,false));\n-    assert_eq!((-10i8).overflowing_abs(), (10,false));\n-    assert_eq!((-128i8).overflowing_abs(), (-128,true));\n+    assert_eq!(10i8.overflowing_abs(), (10, false));\n+    assert_eq!((-10i8).overflowing_abs(), (10, false));\n+    assert_eq!((-128i8).overflowing_abs(), (-128, true));\n \n     // Logarithms\n     macro_rules! test_log {\n@@ -180,7 +180,7 @@ pub fn main() {\n             assert_eq!($type::MIN.checked_log10(), None);\n             assert_eq!($type::MAX.checked_log2(), Some($max_log2));\n             assert_eq!($type::MAX.checked_log10(), Some($max_log10));\n-        }\n+        };\n     }\n \n     test_log!(i8, 6, 2);"}, {"sha": "0cb42580fcb2cbcfc91e57a3a777f535304026ab", "filename": "tests/pass/intrinsics-math.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/bdf2a8a78c3e3864368ec8ec40d1822e1869e7af/tests%2Fpass%2Fintrinsics-math.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdf2a8a78c3e3864368ec8ec40d1822e1869e7af/tests%2Fpass%2Fintrinsics-math.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fintrinsics-math.rs?ref=bdf2a8a78c3e3864368ec8ec40d1822e1869e7af", "patch": "@@ -9,15 +9,14 @@\n // except according to those terms.\n \n macro_rules! assert_approx_eq {\n-    ($a:expr, $b:expr) => ({\n+    ($a:expr, $b:expr) => {{\n         let (a, b) = (&$a, &$b);\n-        assert!((*a - *b).abs() < 1.0e-6,\n-                \"{} is not approximately equal to {}\", *a, *b);\n-    })\n+        assert!((*a - *b).abs() < 1.0e-6, \"{} is not approximately equal to {}\", *a, *b);\n+    }};\n }\n \n fn ldexp(a: f64, b: i32) -> f64 {\n-    extern {\n+    extern \"C\" {\n         fn ldexp(x: f64, n: i32) -> f64;\n     }\n     unsafe { ldexp(a, b) }"}, {"sha": "9e310082f3590a733128ee24da0bb08a90070756", "filename": "tests/pass/intrinsics.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bdf2a8a78c3e3864368ec8ec40d1822e1869e7af/tests%2Fpass%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdf2a8a78c3e3864368ec8ec40d1822e1869e7af/tests%2Fpass%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fintrinsics.rs?ref=bdf2a8a78c3e3864368ec8ec40d1822e1869e7af", "patch": "@@ -20,8 +20,12 @@ fn main() {\n     assert_eq!(size_of_val(&[1, 2, 3] as &[i32]), 12);\n     assert_eq!(size_of_val(\"foobar\"), 6);\n \n-    unsafe { assert_eq!(size_of_val_raw(&[1] as &[i32] as *const [i32]), 4); }\n-    unsafe { assert_eq!(size_of_val_raw(0x100 as *const i32), 4); }\n+    unsafe {\n+        assert_eq!(size_of_val_raw(&[1] as &[i32] as *const [i32]), 4);\n+    }\n+    unsafe {\n+        assert_eq!(size_of_val_raw(0x100 as *const i32), 4);\n+    }\n \n     assert_eq!(intrinsics::type_name::<Option<i32>>(), \"core::option::Option<i32>\");\n \n@@ -33,7 +37,7 @@ fn main() {\n     let _v = intrinsics::discriminant_value(&Some(()));\n     let _v = intrinsics::discriminant_value(&0);\n     let _v = intrinsics::discriminant_value(&true);\n-    let _v = intrinsics::discriminant_value(&vec![1,2,3]);\n+    let _v = intrinsics::discriminant_value(&vec![1, 2, 3]);\n \n     let addr = &13 as *const i32;\n     let addr2 = (addr as usize).wrapping_add(usize::MAX).wrapping_add(1);"}, {"sha": "c04c6921f3c429087f8cd5571f53e1cdd9bebb4b", "filename": "tests/pass/ints.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bdf2a8a78c3e3864368ec8ec40d1822e1869e7af/tests%2Fpass%2Fints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdf2a8a78c3e3864368ec8ec40d1822e1869e7af/tests%2Fpass%2Fints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fints.rs?ref=bdf2a8a78c3e3864368ec8ec40d1822e1869e7af", "patch": "@@ -17,7 +17,7 @@ fn indirect_add() -> i64 {\n }\n \n fn arith() -> i32 {\n-    3*3 + 4*4\n+    3 * 3 + 4 * 4\n }\n \n fn match_int() -> i16 {\n@@ -48,7 +48,7 @@ fn main() {\n     assert_eq!(neg(), -1);\n     assert_eq!(add(), 3);\n     assert_eq!(indirect_add(), 3);\n-    assert_eq!(arith(), 5*5);\n+    assert_eq!(arith(), 5 * 5);\n     assert_eq!(match_int(), 20);\n     assert_eq!(match_int_range(), 4);\n     assert_eq!(i64::MIN.overflowing_mul(-1), (i64::MIN, true));"}, {"sha": "cbb1b90f686291f6de1d564fb5a4718aa4bed961", "filename": "tests/pass/issues/issue-15063.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bdf2a8a78c3e3864368ec8ec40d1822e1869e7af/tests%2Fpass%2Fissues%2Fissue-15063.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdf2a8a78c3e3864368ec8ec40d1822e1869e7af/tests%2Fpass%2Fissues%2Fissue-15063.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fissues%2Fissue-15063.rs?ref=bdf2a8a78c3e3864368ec8ec40d1822e1869e7af", "patch": "@@ -1,8 +1,10 @@\n #[allow(dead_code)]\n-enum Two { A, B }\n+enum Two {\n+    A,\n+    B,\n+}\n impl Drop for Two {\n-    fn drop(&mut self) {\n-    }\n+    fn drop(&mut self) {}\n }\n fn main() {\n     let _k = Two::A;"}, {"sha": "4a360993116c3787fd48a946e51df2eb8467158f", "filename": "tests/pass/issues/issue-15080.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bdf2a8a78c3e3864368ec8ec40d1822e1869e7af/tests%2Fpass%2Fissues%2Fissue-15080.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdf2a8a78c3e3864368ec8ec40d1822e1869e7af/tests%2Fpass%2Fissues%2Fissue-15080.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fissues%2Fissue-15080.rs?ref=bdf2a8a78c3e3864368ec8ec40d1822e1869e7af", "patch": "@@ -1,7 +1,7 @@\n fn main() {\n     let mut x: &[_] = &[1, 2, 3, 4];\n \n-    let mut result = vec!();\n+    let mut result = vec![];\n     loop {\n         x = match *x {\n             [1, n, 3, ref rest @ ..] => {\n@@ -12,8 +12,7 @@ fn main() {\n                 result.push(n);\n                 rest\n             }\n-            [] =>\n-                break\n+            [] => break,\n         }\n     }\n     assert_eq!(result, [2, 4]);"}, {"sha": "7c9fec3ab04b0987ff2264f1a6dd1205f3d74b23", "filename": "tests/pass/issues/issue-15523-big.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bdf2a8a78c3e3864368ec8ec40d1822e1869e7af/tests%2Fpass%2Fissues%2Fissue-15523-big.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdf2a8a78c3e3864368ec8ec40d1822e1869e7af/tests%2Fpass%2Fissues%2Fissue-15523-big.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fissues%2Fissue-15523-big.rs?ref=bdf2a8a78c3e3864368ec8ec40d1822e1869e7af", "patch": "@@ -27,7 +27,6 @@ fn main() {\n     assert!(Eu64::Pos2 < Eu64::PosMax);\n     assert!(Eu64::Pos1 < Eu64::PosMax);\n \n-\n     assert!(Ei64::Pos2 > Ei64::Pos1);\n     assert!(Ei64::Pos2 > Ei64::Neg1);\n     assert!(Ei64::Pos1 > Ei64::Neg1);"}, {"sha": "64d397f91aeec49254ae355eaeff49cf50653e5f", "filename": "tests/pass/issues/issue-17877.rs", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/bdf2a8a78c3e3864368ec8ec40d1822e1869e7af/tests%2Fpass%2Fissues%2Fissue-17877.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdf2a8a78c3e3864368ec8ec40d1822e1869e7af/tests%2Fpass%2Fissues%2Fissue-17877.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fissues%2Fissue-17877.rs?ref=bdf2a8a78c3e3864368ec8ec40d1822e1869e7af", "patch": "@@ -1,11 +1,17 @@\n fn main() {\n-    assert_eq!(match [0u8; 16*1024] {\n-        _ => 42_usize,\n-    }, 42_usize);\n+    assert_eq!(\n+        match [0u8; 16 * 1024] {\n+            _ => 42_usize,\n+        },\n+        42_usize,\n+    );\n \n-    assert_eq!(match [0u8; 16*1024] {\n-        [1, ..] => 0_usize,\n-        [0, ..] => 1_usize,\n-        _ => 2_usize\n-    }, 1_usize);\n+    assert_eq!(\n+        match [0u8; 16 * 1024] {\n+            [1, ..] => 0_usize,\n+            [0, ..] => 1_usize,\n+            _ => 2_usize,\n+        },\n+        1_usize,\n+    );\n }"}, {"sha": "f98252c18bf5c0209ae512eb19e8cbdfa48ca52f", "filename": "tests/pass/issues/issue-23261.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bdf2a8a78c3e3864368ec8ec40d1822e1869e7af/tests%2Fpass%2Fissues%2Fissue-23261.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdf2a8a78c3e3864368ec8ec40d1822e1869e7af/tests%2Fpass%2Fissues%2Fissue-23261.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fissues%2Fissue-23261.rs?ref=bdf2a8a78c3e3864368ec8ec40d1822e1869e7af", "patch": "@@ -2,7 +2,7 @@\n \n struct Foo<T: ?Sized> {\n     a: i32,\n-    inner: T\n+    inner: T,\n }\n \n trait Get {"}, {"sha": "a9f5dc98720fcf97a9a68ba80973a4de4863a760", "filename": "tests/pass/issues/issue-27901.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bdf2a8a78c3e3864368ec8ec40d1822e1869e7af/tests%2Fpass%2Fissues%2Fissue-27901.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdf2a8a78c3e3864368ec8ec40d1822e1869e7af/tests%2Fpass%2Fissues%2Fissue-27901.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fissues%2Fissue-27901.rs?ref=bdf2a8a78c3e3864368ec8ec40d1822e1869e7af", "patch": "@@ -1,5 +1,9 @@\n-trait Stream { type Item; }\n-impl<'a> Stream for &'a str { type Item = u8; }\n+trait Stream {\n+    type Item;\n+}\n+impl<'a> Stream for &'a str {\n+    type Item = u8;\n+}\n fn f<'s>(s: &'s str) -> (&'s str, <&'s str as Stream>::Item) {\n     (s, 42)\n }"}, {"sha": "43bed4464b9c8091466c3c53dee09750de78057b", "filename": "tests/pass/issues/issue-29746.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bdf2a8a78c3e3864368ec8ec40d1822e1869e7af/tests%2Fpass%2Fissues%2Fissue-29746.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdf2a8a78c3e3864368ec8ec40d1822e1869e7af/tests%2Fpass%2Fissues%2Fissue-29746.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fissues%2Fissue-29746.rs?ref=bdf2a8a78c3e3864368ec8ec40d1822e1869e7af", "patch": "@@ -25,11 +25,11 @@ macro_rules! zip {\n }\n \n fn main() {\n-    let p1 = vec![1i32,    2].into_iter();\n-    let p2 = vec![\"10\",    \"20\"].into_iter();\n-    let p3 = vec![100u16,  200].into_iter();\n+    let p1 = vec![1i32, 2].into_iter();\n+    let p2 = vec![\"10\", \"20\"].into_iter();\n+    let p3 = vec![100u16, 200].into_iter();\n     let p4 = vec![1000i64, 2000].into_iter();\n \n-    let e = zip!([p1,p2,p3,p4]).collect::<Vec<_>>();\n-    assert_eq!(e[0], (1i32,\"10\",100u16,1000i64));\n+    let e = zip!([p1, p2, p3, p4]).collect::<Vec<_>>();\n+    assert_eq!(e[0], (1i32, \"10\", 100u16, 1000i64));\n }"}, {"sha": "472b42adaac85d1378aead924bc6948ddc4a5310", "filename": "tests/pass/issues/issue-30530.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bdf2a8a78c3e3864368ec8ec40d1822e1869e7af/tests%2Fpass%2Fissues%2Fissue-30530.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdf2a8a78c3e3864368ec8ec40d1822e1869e7af/tests%2Fpass%2Fissues%2Fissue-30530.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fissues%2Fissue-30530.rs?ref=bdf2a8a78c3e3864368ec8ec40d1822e1869e7af", "patch": "@@ -21,7 +21,8 @@ pub enum Handler {\n }\n \n fn main() {\n-    #[allow(unused_must_use)] {\n+    #[allow(unused_must_use)]\n+    {\n         take(Handler::Default, Box::new(main));\n     }\n }"}, {"sha": "e1ed8d19e4ea61c2f800cbc337a934fe4f7e9004", "filename": "tests/pass/issues/issue-34571.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bdf2a8a78c3e3864368ec8ec40d1822e1869e7af/tests%2Fpass%2Fissues%2Fissue-34571.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdf2a8a78c3e3864368ec8ec40d1822e1869e7af/tests%2Fpass%2Fissues%2Fissue-34571.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fissues%2Fissue-34571.rs?ref=bdf2a8a78c3e3864368ec8ec40d1822e1869e7af", "patch": "@@ -5,6 +5,6 @@ enum Foo {\n \n fn main() {\n     match Foo::Foo(1) {\n-        _ => ()\n+        _ => (),\n     }\n }"}, {"sha": "6bc8f02c3bafb5216bbd03d5f265c891a577b823", "filename": "tests/pass/issues/issue-36278-prefix-nesting.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bdf2a8a78c3e3864368ec8ec40d1822e1869e7af/tests%2Fpass%2Fissues%2Fissue-36278-prefix-nesting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdf2a8a78c3e3864368ec8ec40d1822e1869e7af/tests%2Fpass%2Fissues%2Fissue-36278-prefix-nesting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fissues%2Fissue-36278-prefix-nesting.rs?ref=bdf2a8a78c3e3864368ec8ec40d1822e1869e7af", "patch": "@@ -9,11 +9,12 @@ struct P<T: ?Sized>([u8; SZ], T);\n type Ack<T> = P<P<T>>;\n \n fn main() {\n-    let size_of_sized; let size_of_unsized;\n+    let size_of_sized;\n+    let size_of_unsized;\n     let x: Box<Ack<[u8; 0]>> = Box::new(P([0; SZ], P([0; SZ], [0; 0])));\n     size_of_sized = mem::size_of_val::<Ack<_>>(&x);\n     let align_of_sized = mem::align_of_val::<Ack<_>>(&x);\n-    let y: Box<Ack<[u8   ]>> = x;\n+    let y: Box<Ack<[u8]>> = x;\n     size_of_unsized = mem::size_of_val::<Ack<_>>(&y);\n     assert_eq!(size_of_sized, size_of_unsized);\n     assert_eq!(align_of_sized, 1);"}, {"sha": "f7bbb4350e2bebd2daf13896147e91f7e1e914d5", "filename": "tests/pass/issues/issue-5917.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bdf2a8a78c3e3864368ec8ec40d1822e1869e7af/tests%2Fpass%2Fissues%2Fissue-5917.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdf2a8a78c3e3864368ec8ec40d1822e1869e7af/tests%2Fpass%2Fissues%2Fissue-5917.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fissues%2Fissue-5917.rs?ref=bdf2a8a78c3e3864368ec8ec40d1822e1869e7af", "patch": "@@ -1,7 +1,6 @@\n-\n-struct T (&'static [isize]);\n-static STATIC : T = T (&[5, 4, 3]);\n-pub fn main () {\n+struct T(&'static [isize]);\n+static STATIC: T = T(&[5, 4, 3]);\n+pub fn main() {\n     let T(ref v) = STATIC;\n     assert_eq!(v[0], 5);\n }"}, {"sha": "02c97325713305ed2704dbf5b53000e946bee63a", "filename": "tests/pass/issues/issue-miri-133.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/bdf2a8a78c3e3864368ec8ec40d1822e1869e7af/tests%2Fpass%2Fissues%2Fissue-miri-133.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdf2a8a78c3e3864368ec8ec40d1822e1869e7af/tests%2Fpass%2Fissues%2Fissue-miri-133.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fissues%2Fissue-miri-133.rs?ref=bdf2a8a78c3e3864368ec8ec40d1822e1869e7af", "patch": "@@ -4,17 +4,12 @@ struct S<U, V> {\n     _u: U,\n     size_of_u: usize,\n     _v: V,\n-    size_of_v: usize\n+    size_of_v: usize,\n }\n \n impl<U, V> S<U, V> {\n     fn new(u: U, v: V) -> Self {\n-        S {\n-            _u: u,\n-            size_of_u: size_of::<U>(),\n-            _v: v,\n-            size_of_v: size_of::<V>()\n-        }\n+        S { _u: u, size_of_u: size_of::<U>(), _v: v, size_of_v: size_of::<V>() }\n     }\n }\n "}, {"sha": "204a4dd05642d874d3b9df8c09029ee69bdf1d1d", "filename": "tests/pass/issues/issue-miri-2068-2.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/bdf2a8a78c3e3864368ec8ec40d1822e1869e7af/tests%2Fpass%2Fissues%2Fissue-miri-2068-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdf2a8a78c3e3864368ec8ec40d1822e1869e7af/tests%2Fpass%2Fissues%2Fissue-miri-2068-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fissues%2Fissue-miri-2068-2.rs?ref=bdf2a8a78c3e3864368ec8ec40d1822e1869e7af", "patch": "@@ -2,13 +2,15 @@\n \n use std::mem::MaybeUninit;\n \n-fn main() { unsafe {\n-    let mut x = MaybeUninit::<i64>::uninit();\n-    // Put in a ptr.\n-    x.as_mut_ptr().cast::<&i32>().write_unaligned(&0);\n-    // Overwrite parts of that pointer with 'uninit' through a Scalar.\n-    let ptr = x.as_mut_ptr().cast::<i32>();\n-    *ptr = MaybeUninit::uninit().assume_init();\n-    // Reading this back should hence work fine.\n-    let _c = *ptr;\n-} }\n+fn main() {\n+    unsafe {\n+        let mut x = MaybeUninit::<i64>::uninit();\n+        // Put in a ptr.\n+        x.as_mut_ptr().cast::<&i32>().write_unaligned(&0);\n+        // Overwrite parts of that pointer with 'uninit' through a Scalar.\n+        let ptr = x.as_mut_ptr().cast::<i32>();\n+        *ptr = MaybeUninit::uninit().assume_init();\n+        // Reading this back should hence work fine.\n+        let _c = *ptr;\n+    }\n+}"}, {"sha": "2160aea16346fd631974cc2f2983a3c95b25d7bc", "filename": "tests/pass/last-use-in-cap-clause.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bdf2a8a78c3e3864368ec8ec40d1822e1869e7af/tests%2Fpass%2Flast-use-in-cap-clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdf2a8a78c3e3864368ec8ec40d1822e1869e7af/tests%2Fpass%2Flast-use-in-cap-clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Flast-use-in-cap-clause.rs?ref=bdf2a8a78c3e3864368ec8ec40d1822e1869e7af", "patch": "@@ -1,12 +1,14 @@\n // Make sure #1399 stays fixed\n \n #[allow(dead_code)]\n-struct A { a: Box<isize> }\n+struct A {\n+    a: Box<isize>,\n+}\n \n fn foo() -> Box<dyn FnMut() -> isize + 'static> {\n     let k: Box<_> = Box::new(22);\n-    let _u = A {a: k.clone()};\n-    let result  = || 22;\n+    let _u = A { a: k.clone() };\n+    let result = || 22;\n     Box::new(result)\n }\n "}, {"sha": "9523394408806491ca6fae26bb05768b472a4202", "filename": "tests/pass/leak-in-static.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bdf2a8a78c3e3864368ec8ec40d1822e1869e7af/tests%2Fpass%2Fleak-in-static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdf2a8a78c3e3864368ec8ec40d1822e1869e7af/tests%2Fpass%2Fleak-in-static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fleak-in-static.rs?ref=bdf2a8a78c3e3864368ec8ec40d1822e1869e7af", "patch": "@@ -1,4 +1,7 @@\n-use std::{ptr, sync::atomic::{AtomicPtr, Ordering}};\n+use std::{\n+    ptr,\n+    sync::atomic::{AtomicPtr, Ordering},\n+};\n \n static mut LEAKER: Option<Box<Vec<i32>>> = None;\n "}, {"sha": "f97b9dd2b9eaa2ca50b502418626967c0e6a88ff", "filename": "tests/pass/libc.rs", "status": "modified", "additions": 62, "deletions": 24, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/bdf2a8a78c3e3864368ec8ec40d1822e1869e7af/tests%2Fpass%2Flibc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdf2a8a78c3e3864368ec8ec40d1822e1869e7af/tests%2Fpass%2Flibc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Flibc.rs?ref=bdf2a8a78c3e3864368ec8ec40d1822e1869e7af", "patch": "@@ -7,7 +7,9 @@ extern crate libc;\n \n #[cfg(target_os = \"linux\")]\n fn tmp() -> std::path::PathBuf {\n-    std::env::var(\"MIRI_TEMP\").map(std::path::PathBuf::from).unwrap_or_else(|_| std::env::temp_dir())\n+    std::env::var(\"MIRI_TEMP\")\n+        .map(std::path::PathBuf::from)\n+        .unwrap_or_else(|_| std::env::temp_dir())\n }\n \n #[cfg(target_os = \"linux\")]\n@@ -91,7 +93,10 @@ fn test_mutex_libc_init_recursive() {\n     unsafe {\n         let mut attr: libc::pthread_mutexattr_t = std::mem::zeroed();\n         assert_eq!(libc::pthread_mutexattr_init(&mut attr as *mut _), 0);\n-        assert_eq!(libc::pthread_mutexattr_settype(&mut attr as *mut _, libc::PTHREAD_MUTEX_RECURSIVE), 0);\n+        assert_eq!(\n+            libc::pthread_mutexattr_settype(&mut attr as *mut _, libc::PTHREAD_MUTEX_RECURSIVE),\n+            0,\n+        );\n         let mut mutex: libc::pthread_mutex_t = std::mem::zeroed();\n         assert_eq!(libc::pthread_mutex_init(&mut mutex as *mut _, &mut attr as *mut _), 0);\n         assert_eq!(libc::pthread_mutex_lock(&mut mutex as *mut _), 0);\n@@ -111,8 +116,14 @@ fn test_mutex_libc_init_recursive() {\n fn test_mutex_libc_init_normal() {\n     unsafe {\n         let mut mutexattr: libc::pthread_mutexattr_t = std::mem::zeroed();\n-        assert_eq!(libc::pthread_mutexattr_settype(&mut mutexattr as *mut _, 0x12345678), libc::EINVAL);\n-        assert_eq!(libc::pthread_mutexattr_settype(&mut mutexattr as *mut _, libc::PTHREAD_MUTEX_NORMAL), 0);\n+        assert_eq!(\n+            libc::pthread_mutexattr_settype(&mut mutexattr as *mut _, 0x12345678),\n+            libc::EINVAL,\n+        );\n+        assert_eq!(\n+            libc::pthread_mutexattr_settype(&mut mutexattr as *mut _, libc::PTHREAD_MUTEX_NORMAL),\n+            0,\n+        );\n         let mut mutex: libc::pthread_mutex_t = std::mem::zeroed();\n         assert_eq!(libc::pthread_mutex_init(&mut mutex as *mut _, &mutexattr as *const _), 0);\n         assert_eq!(libc::pthread_mutex_lock(&mut mutex as *mut _), 0);\n@@ -127,7 +138,13 @@ fn test_mutex_libc_init_normal() {\n fn test_mutex_libc_init_errorcheck() {\n     unsafe {\n         let mut mutexattr: libc::pthread_mutexattr_t = std::mem::zeroed();\n-        assert_eq!(libc::pthread_mutexattr_settype(&mut mutexattr as *mut _, libc::PTHREAD_MUTEX_ERRORCHECK), 0);\n+        assert_eq!(\n+            libc::pthread_mutexattr_settype(\n+                &mut mutexattr as *mut _,\n+                libc::PTHREAD_MUTEX_ERRORCHECK,\n+            ),\n+            0,\n+        );\n         let mut mutex: libc::pthread_mutex_t = std::mem::zeroed();\n         assert_eq!(libc::pthread_mutex_init(&mut mutex as *mut _, &mutexattr as *const _), 0);\n         assert_eq!(libc::pthread_mutex_lock(&mut mutex as *mut _), 0);\n@@ -193,21 +210,48 @@ fn test_rwlock_libc_static_initializer() {\n /// Note: `prctl` exists only on Linux.\n #[cfg(target_os = \"linux\")]\n fn test_prctl_thread_name() {\n-    use std::ffi::CString;\n     use libc::c_long;\n+    use std::ffi::CString;\n     unsafe {\n         let mut buf = [255; 10];\n-        assert_eq!(libc::prctl(libc::PR_GET_NAME, buf.as_mut_ptr(), 0 as c_long, 0 as c_long, 0 as c_long), 0);\n+        assert_eq!(\n+            libc::prctl(libc::PR_GET_NAME, buf.as_mut_ptr(), 0 as c_long, 0 as c_long, 0 as c_long),\n+            0,\n+        );\n         assert_eq!(b\"<unnamed>\\0\", &buf);\n         let thread_name = CString::new(\"hello\").expect(\"CString::new failed\");\n-        assert_eq!(libc::prctl(libc::PR_SET_NAME, thread_name.as_ptr(), 0 as c_long, 0 as c_long, 0 as c_long), 0);\n+        assert_eq!(\n+            libc::prctl(\n+                libc::PR_SET_NAME,\n+                thread_name.as_ptr(),\n+                0 as c_long,\n+                0 as c_long,\n+                0 as c_long,\n+            ),\n+            0,\n+        );\n         let mut buf = [255; 6];\n-        assert_eq!(libc::prctl(libc::PR_GET_NAME, buf.as_mut_ptr(), 0 as c_long, 0 as c_long, 0 as c_long), 0);\n+        assert_eq!(\n+            libc::prctl(libc::PR_GET_NAME, buf.as_mut_ptr(), 0 as c_long, 0 as c_long, 0 as c_long),\n+            0,\n+        );\n         assert_eq!(b\"hello\\0\", &buf);\n         let long_thread_name = CString::new(\"01234567890123456789\").expect(\"CString::new failed\");\n-        assert_eq!(libc::prctl(libc::PR_SET_NAME, long_thread_name.as_ptr(), 0 as c_long, 0 as c_long, 0 as c_long), 0);\n+        assert_eq!(\n+            libc::prctl(\n+                libc::PR_SET_NAME,\n+                long_thread_name.as_ptr(),\n+                0 as c_long,\n+                0 as c_long,\n+                0 as c_long,\n+            ),\n+            0,\n+        );\n         let mut buf = [255; 16];\n-        assert_eq!(libc::prctl(libc::PR_GET_NAME, buf.as_mut_ptr(), 0 as c_long, 0 as c_long, 0 as c_long), 0);\n+        assert_eq!(\n+            libc::prctl(libc::PR_GET_NAME, buf.as_mut_ptr(), 0 as c_long, 0 as c_long, 0 as c_long),\n+            0,\n+        );\n         assert_eq!(b\"012345678901234\\0\", &buf);\n     }\n }\n@@ -225,7 +269,9 @@ fn test_thread_local_errno() {\n             assert_eq!(*__errno_location(), 0);\n             *__errno_location() = 0xBAD1DEA;\n             assert_eq!(*__errno_location(), 0xBAD1DEA);\n-        }).join().unwrap();\n+        })\n+        .join()\n+        .unwrap();\n         assert_eq!(*__errno_location(), 0xBEEF);\n     }\n }\n@@ -234,21 +280,13 @@ fn test_thread_local_errno() {\n #[cfg(target_os = \"linux\")]\n fn test_clocks() {\n     let mut tp = std::mem::MaybeUninit::<libc::timespec>::uninit();\n-    let is_error = unsafe {\n-        libc::clock_gettime(libc::CLOCK_REALTIME, tp.as_mut_ptr())\n-    };\n+    let is_error = unsafe { libc::clock_gettime(libc::CLOCK_REALTIME, tp.as_mut_ptr()) };\n     assert_eq!(is_error, 0);\n-    let is_error = unsafe {\n-        libc::clock_gettime(libc::CLOCK_REALTIME_COARSE, tp.as_mut_ptr())\n-    };\n+    let is_error = unsafe { libc::clock_gettime(libc::CLOCK_REALTIME_COARSE, tp.as_mut_ptr()) };\n     assert_eq!(is_error, 0);\n-     let is_error = unsafe {\n-        libc::clock_gettime(libc::CLOCK_MONOTONIC, tp.as_mut_ptr())\n-    };\n+    let is_error = unsafe { libc::clock_gettime(libc::CLOCK_MONOTONIC, tp.as_mut_ptr()) };\n     assert_eq!(is_error, 0);\n-    let is_error = unsafe {\n-        libc::clock_gettime(libc::CLOCK_MONOTONIC_COARSE, tp.as_mut_ptr())\n-    };\n+    let is_error = unsafe { libc::clock_gettime(libc::CLOCK_MONOTONIC_COARSE, tp.as_mut_ptr()) };\n     assert_eq!(is_error, 0);\n }\n "}, {"sha": "7377f9f60b01e96aa91530d641a98801f6e66118", "filename": "tests/pass/linked-list.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bdf2a8a78c3e3864368ec8ec40d1822e1869e7af/tests%2Fpass%2Flinked-list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdf2a8a78c3e3864368ec8ec40d1822e1869e7af/tests%2Fpass%2Flinked-list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Flinked-list.rs?ref=bdf2a8a78c3e3864368ec8ec40d1822e1869e7af", "patch": "@@ -45,8 +45,7 @@ fn main() {\n \n     assert_eq!(m.len(), 3 + len * 2);\n     let mut m2 = m.clone();\n-    assert_eq!(m.into_iter().collect::<Vec<_>>(),\n-               [-10, -2, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 99]);\n+    assert_eq!(m.into_iter().collect::<Vec<_>>(), [-10, -2, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 99]);\n \n     test_all_refs(&mut 13, m2.iter_mut());\n }"}, {"sha": "ad1a1f27c7713e5f5c71724876fe4f047dc84672", "filename": "tests/pass/linux-getrandom-without-isolation.rs", "status": "modified", "additions": 30, "deletions": 4, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/bdf2a8a78c3e3864368ec8ec40d1822e1869e7af/tests%2Fpass%2Flinux-getrandom-without-isolation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdf2a8a78c3e3864368ec8ec40d1822e1869e7af/tests%2Fpass%2Flinux-getrandom-without-isolation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Flinux-getrandom-without-isolation.rs?ref=bdf2a8a78c3e3864368ec8ec40d1822e1869e7af", "patch": "@@ -6,10 +6,36 @@ extern crate libc;\n fn main() {\n     let mut buf = [0u8; 5];\n     unsafe {\n-        assert_eq!(libc::syscall(libc::SYS_getrandom, 0 as *mut libc::c_void, 0 as libc::size_t, 0 as libc::c_uint), 0);\n-        assert_eq!(libc::syscall(libc::SYS_getrandom, buf.as_mut_ptr() as *mut libc::c_void, 5 as libc::size_t, 0 as libc::c_uint), 5);\n+        assert_eq!(\n+            libc::syscall(\n+                libc::SYS_getrandom,\n+                0 as *mut libc::c_void,\n+                0 as libc::size_t,\n+                0 as libc::c_uint,\n+            ),\n+            0,\n+        );\n+        assert_eq!(\n+            libc::syscall(\n+                libc::SYS_getrandom,\n+                buf.as_mut_ptr() as *mut libc::c_void,\n+                5 as libc::size_t,\n+                0 as libc::c_uint,\n+            ),\n+            5,\n+        );\n \n-        assert_eq!(libc::getrandom(0 as *mut libc::c_void, 0 as libc::size_t, 0 as libc::c_uint), 0);\n-        assert_eq!(libc::getrandom(buf.as_mut_ptr() as *mut libc::c_void, 5 as libc::size_t, 0 as libc::c_uint), 5);\n+        assert_eq!(\n+            libc::getrandom(0 as *mut libc::c_void, 0 as libc::size_t, 0 as libc::c_uint),\n+            0,\n+        );\n+        assert_eq!(\n+            libc::getrandom(\n+                buf.as_mut_ptr() as *mut libc::c_void,\n+                5 as libc::size_t,\n+                0 as libc::c_uint,\n+            ),\n+            5,\n+        );\n     }\n }"}, {"sha": "7d3f899f4408a3ba1ad18aa3f7ea19237a5a3f92", "filename": "tests/pass/linux-getrandom.rs", "status": "modified", "additions": 30, "deletions": 4, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/bdf2a8a78c3e3864368ec8ec40d1822e1869e7af/tests%2Fpass%2Flinux-getrandom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdf2a8a78c3e3864368ec8ec40d1822e1869e7af/tests%2Fpass%2Flinux-getrandom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Flinux-getrandom.rs?ref=bdf2a8a78c3e3864368ec8ec40d1822e1869e7af", "patch": "@@ -5,10 +5,36 @@ extern crate libc;\n fn main() {\n     let mut buf = [0u8; 5];\n     unsafe {\n-        assert_eq!(libc::syscall(libc::SYS_getrandom, 0 as *mut libc::c_void, 0 as libc::size_t, 0 as libc::c_uint), 0);\n-        assert_eq!(libc::syscall(libc::SYS_getrandom, buf.as_mut_ptr() as *mut libc::c_void, 5 as libc::size_t, 0 as libc::c_uint), 5);\n+        assert_eq!(\n+            libc::syscall(\n+                libc::SYS_getrandom,\n+                0 as *mut libc::c_void,\n+                0 as libc::size_t,\n+                0 as libc::c_uint,\n+            ),\n+            0,\n+        );\n+        assert_eq!(\n+            libc::syscall(\n+                libc::SYS_getrandom,\n+                buf.as_mut_ptr() as *mut libc::c_void,\n+                5 as libc::size_t,\n+                0 as libc::c_uint,\n+            ),\n+            5,\n+        );\n \n-        assert_eq!(libc::getrandom(0 as *mut libc::c_void, 0 as libc::size_t, 0 as libc::c_uint), 0);\n-        assert_eq!(libc::getrandom(buf.as_mut_ptr() as *mut libc::c_void, 5 as libc::size_t, 0 as libc::c_uint), 5);\n+        assert_eq!(\n+            libc::getrandom(0 as *mut libc::c_void, 0 as libc::size_t, 0 as libc::c_uint),\n+            0,\n+        );\n+        assert_eq!(\n+            libc::getrandom(\n+                buf.as_mut_ptr() as *mut libc::c_void,\n+                5 as libc::size_t,\n+                0 as libc::c_uint,\n+            ),\n+            5,\n+        );\n     }\n }"}, {"sha": "bc4c967d26a5b064d59363722d7189f75ebe72f5", "filename": "tests/pass/loop-break-value.rs", "status": "modified", "additions": 6, "deletions": 14, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/bdf2a8a78c3e3864368ec8ec40d1822e1869e7af/tests%2Fpass%2Floop-break-value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdf2a8a78c3e3864368ec8ec40d1822e1869e7af/tests%2Fpass%2Floop-break-value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Floop-break-value.rs?ref=bdf2a8a78c3e3864368ec8ec40d1822e1869e7af", "patch": "@@ -16,7 +16,7 @@ pub fn main() {\n             let _never: ! = loop {\n                 break loop {\n                     break 'outer panic!();\n-                }\n+                };\n             };\n         }\n     };\n@@ -36,31 +36,23 @@ pub fn main() {\n     assert_eq!(coerced, &[17u32]);\n \n     let trait_unified = loop {\n-        break if true {\n-            break Default::default()\n-        } else {\n-            break [13, 14]\n-        };\n+        break if true { break Default::default() } else { break [13, 14] };\n     };\n     assert_eq!(trait_unified, [0, 0]);\n \n     let trait_unified_2 = loop {\n         if false {\n-            break [String::from(\"Hello\")]\n+            break [String::from(\"Hello\")];\n         } else {\n-            break Default::default()\n+            break Default::default();\n         };\n     };\n     // compare lengths; ptr comparison is not deterministic\n     assert_eq!(trait_unified_2.len(), 1);\n     assert_eq!(trait_unified_2[0].len(), 0);\n \n     let trait_unified_3 = loop {\n-        break if false {\n-            break [String::from(\"Hello\")]\n-        } else {\n-            [\"Yes\".into()]\n-        };\n+        break if false { break [String::from(\"Hello\")] } else { [\"Yes\".into()] };\n     };\n     assert_eq!(trait_unified_3, [\"Yes\"]);\n \n@@ -87,7 +79,7 @@ pub fn main() {\n             Default::default()\n         } else {\n             break;\n-        }\n+        };\n     };\n     assert_eq!(regular_break_3, ());\n "}, {"sha": "72abc68bb96b195b7afb7d8598188507767ec5bf", "filename": "tests/pass/malloc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bdf2a8a78c3e3864368ec8ec40d1822e1869e7af/tests%2Fpass%2Fmalloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdf2a8a78c3e3864368ec8ec40d1822e1869e7af/tests%2Fpass%2Fmalloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fmalloc.rs?ref=bdf2a8a78c3e3864368ec8ec40d1822e1869e7af", "patch": "@@ -4,7 +4,7 @@\n \n extern crate libc;\n \n-use core::{slice, ptr};\n+use core::{ptr, slice};\n \n fn main() {\n     // Test that small allocations sometimes *are* not very aligned."}, {"sha": "376b41dd6e2094e26499416b338197b0a4d4975c", "filename": "tests/pass/many_shr_bor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bdf2a8a78c3e3864368ec8ec40d1822e1869e7af/tests%2Fpass%2Fmany_shr_bor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdf2a8a78c3e3864368ec8ec40d1822e1869e7af/tests%2Fpass%2Fmany_shr_bor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fmany_shr_bor.rs?ref=bdf2a8a78c3e3864368ec8ec40d1822e1869e7af", "patch": "@@ -24,7 +24,7 @@ fn test1() {\n fn test2(r: &mut RefCell<i32>) {\n     let x = &*r; // releasing write lock, first suspension recorded\n     let mut x_ref = x.borrow_mut();\n-    let x_inner : &mut i32 = &mut *x_ref; // new inner write lock, with same lifetime as outer lock\n+    let x_inner: &mut i32 = &mut *x_ref; // new inner write lock, with same lifetime as outer lock\n     let _x_inner_shr = &*x_inner; // releasing inner write lock, recording suspension\n     let _y = &*r; // second suspension for the outer write lock\n     let _x_inner_shr2 = &*x_inner; // 2nd suspension for inner write lock"}, {"sha": "e40a63ef2003be05d957701bb79645cc8b1ea608", "filename": "tests/pass/match_slice.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bdf2a8a78c3e3864368ec8ec40d1822e1869e7af/tests%2Fpass%2Fmatch_slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdf2a8a78c3e3864368ec8ec40d1822e1869e7af/tests%2Fpass%2Fmatch_slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fmatch_slice.rs?ref=bdf2a8a78c3e3864368ec8ec40d1822e1869e7af", "patch": "@@ -1,8 +1,8 @@\n fn main() {\n     let x = \"hello\";\n     match x {\n-        \"foo\" => {},\n-        \"bar\" => {},\n-        _ => {},\n+        \"foo\" => {}\n+        \"bar\" => {}\n+        _ => {}\n     }\n }"}, {"sha": "669602ac70436704cddd99a15be9d475240f2fb9", "filename": "tests/pass/move-arg-2-unique.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bdf2a8a78c3e3864368ec8ec40d1822e1869e7af/tests%2Fpass%2Fmove-arg-2-unique.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdf2a8a78c3e3864368ec8ec40d1822e1869e7af/tests%2Fpass%2Fmove-arg-2-unique.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fmove-arg-2-unique.rs?ref=bdf2a8a78c3e3864368ec8ec40d1822e1869e7af", "patch": "@@ -1,6 +1,8 @@\n #![feature(box_syntax)]\n \n-fn test(foo: Box<Vec<isize>> ) { assert_eq!((*foo)[0], 10); }\n+fn test(foo: Box<Vec<isize>>) {\n+    assert_eq!((*foo)[0], 10);\n+}\n \n pub fn main() {\n     let x = box vec![10];"}, {"sha": "1ca3873d1d3684b9b8b72b4308bdfa5e9d35cea0", "filename": "tests/pass/move-uninit-primval.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bdf2a8a78c3e3864368ec8ec40d1822e1869e7af/tests%2Fpass%2Fmove-uninit-primval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdf2a8a78c3e3864368ec8ec40d1822e1869e7af/tests%2Fpass%2Fmove-uninit-primval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fmove-uninit-primval.rs?ref=bdf2a8a78c3e3864368ec8ec40d1822e1869e7af", "patch": "@@ -7,9 +7,7 @@ struct Foo {\n \n fn main() {\n     unsafe {\n-        let foo = Foo {\n-            _inner: std::mem::uninitialized(),\n-        };\n+        let foo = Foo { _inner: std::mem::uninitialized() };\n         let _bar = foo;\n     }\n }"}, {"sha": "5a58deeac0f318b402f912f0137b4850acbbd2a5", "filename": "tests/pass/negative_discriminant.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bdf2a8a78c3e3864368ec8ec40d1822e1869e7af/tests%2Fpass%2Fnegative_discriminant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdf2a8a78c3e3864368ec8ec40d1822e1869e7af/tests%2Fpass%2Fnegative_discriminant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fnegative_discriminant.rs?ref=bdf2a8a78c3e3864368ec8ec40d1822e1869e7af", "patch": "@@ -1,4 +1,7 @@\n-enum AB { A = -1, B = 1 }\n+enum AB {\n+    A = -1,\n+    B = 1,\n+}\n \n fn main() {\n     match AB::A {"}, {"sha": "2896d3161f7636ba36fb9c462d6c173f538c46a3", "filename": "tests/pass/overflow_checks_off.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bdf2a8a78c3e3864368ec8ec40d1822e1869e7af/tests%2Fpass%2Foverflow_checks_off.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdf2a8a78c3e3864368ec8ec40d1822e1869e7af/tests%2Fpass%2Foverflow_checks_off.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Foverflow_checks_off.rs?ref=bdf2a8a78c3e3864368ec8ec40d1822e1869e7af", "patch": "@@ -8,7 +8,7 @@\n // use std::ops::*;\n \n fn main() {\n-    assert_eq!(-{-0x80i8}, -0x80);\n+    assert_eq!(-{ -0x80i8 }, -0x80);\n \n     assert_eq!(0xffu8 + 1, 0_u8);\n     assert_eq!(0u8 - 1, 0xff_u8);"}, {"sha": "9fcf7d4a819a51861b3293c2fab09ad79d6042a3", "filename": "tests/pass/overloaded-calls-simple.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bdf2a8a78c3e3864368ec8ec40d1822e1869e7af/tests%2Fpass%2Foverloaded-calls-simple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdf2a8a78c3e3864368ec8ec40d1822e1869e7af/tests%2Fpass%2Foverloaded-calls-simple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Foverloaded-calls-simple.rs?ref=bdf2a8a78c3e3864368ec8ec40d1822e1869e7af", "patch": "@@ -1,23 +1,19 @@\n-\n #![feature(lang_items, unboxed_closures, fn_traits)]\n \n struct S3 {\n     x: i32,\n     y: i32,\n }\n \n-impl FnOnce<(i32,i32)> for S3 {\n+impl FnOnce<(i32, i32)> for S3 {\n     type Output = i32;\n-    extern \"rust-call\" fn call_once(self, (z,zz): (i32,i32)) -> i32 {\n+    extern \"rust-call\" fn call_once(self, (z, zz): (i32, i32)) -> i32 {\n         self.x * self.y * z * zz\n     }\n }\n \n fn main() {\n-    let s = S3 {\n-        x: 3,\n-        y: 3,\n-    };\n+    let s = S3 { x: 3, y: 3 };\n     let ans = s(3, 1);\n     assert_eq!(ans, 27);\n }"}, {"sha": "85acab858aab9352cba4389188e1f400839a248b", "filename": "tests/pass/packed_struct.rs", "status": "modified", "additions": 16, "deletions": 18, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/bdf2a8a78c3e3864368ec8ec40d1822e1869e7af/tests%2Fpass%2Fpacked_struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdf2a8a78c3e3864368ec8ec40d1822e1869e7af/tests%2Fpass%2Fpacked_struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fpacked_struct.rs?ref=bdf2a8a78c3e3864368ec8ec40d1822e1869e7af", "patch": "@@ -31,34 +31,31 @@ fn test_basic() {\n         assert_eq!(x, 42);\n     }\n \n-    let mut x = S {\n-        fill: 0,\n-        a: 42,\n-        b: 99,\n-    };\n+    let mut x = S { fill: 0, a: 42, b: 99 };\n     let a = x.a;\n     let b = x.b;\n     assert_eq!(a, 42);\n     assert_eq!(b, 99);\n     assert_eq!(&x.fill, &0); // `fill` just requirs 1-byte-align, so this is fine\n     // can't do `assert_eq!(x.a, 42)`, because `assert_eq!` takes a reference\n-    assert_eq!({x.a}, 42);\n-    assert_eq!({x.b}, 99);\n+    assert_eq!({ x.a }, 42);\n+    assert_eq!({ x.b }, 99);\n     // but we *can* take a raw pointer!\n     assert_eq!(unsafe { ptr::addr_of!(x.a).read_unaligned() }, 42);\n     assert_eq!(unsafe { ptr::addr_of!(x.b).read_unaligned() }, 99);\n \n     x.b = 77;\n-    assert_eq!({x.b}, 77);\n+    assert_eq!({ x.b }, 77);\n \n-    test(Test2 { x: 0, other: &Test1 { x: 0, other: &42 }});\n+    test(Test2 { x: 0, other: &Test1 { x: 0, other: &42 } });\n }\n \n fn test_unsizing() {\n     #[repr(packed)]\n     #[allow(dead_code)]\n     struct UnalignedPtr<'a, T: ?Sized>\n-    where T: 'a,\n+    where\n+        T: 'a,\n     {\n         data: &'a T,\n     }\n@@ -67,7 +64,8 @@ fn test_unsizing() {\n     where\n         T: std::marker::Unsize<U> + ?Sized,\n         U: ?Sized,\n-    { }\n+    {\n+    }\n \n     let arr = [1, 2, 3];\n     let arr_unaligned: UnalignedPtr<[i32; 3]> = UnalignedPtr { data: &arr };\n@@ -86,7 +84,7 @@ fn test_drop() {\n         }\n     }\n \n-    #[repr(packed,C)]\n+    #[repr(packed, C)]\n     struct Packed<T> {\n         f1: u8, // this should move the second field to something not very aligned\n         f2: T,\n@@ -100,10 +98,10 @@ fn test_inner_packed() {\n     // Even if just the inner struct is packed, accesses to the outer field can get unaligned.\n     // Make sure that works.\n     #[repr(packed)]\n-    #[derive(Clone,Copy)]\n+    #[derive(Clone, Copy)]\n     struct Inner(u32);\n \n-    #[derive(Clone,Copy)]\n+    #[derive(Clone, Copy)]\n     struct Outer(u8, Inner);\n \n     let o = Outer(0, Inner(42));\n@@ -115,12 +113,12 @@ fn test_inner_packed() {\n fn test_static() {\n     #[repr(packed)]\n     struct Foo {\n-        i: i32\n+        i: i32,\n     }\n \n     static FOO: Foo = Foo { i: 42 };\n \n-    assert_eq!({FOO.i}, 42);\n+    assert_eq!({ FOO.i }, 42);\n }\n \n fn test_derive() {\n@@ -132,8 +130,8 @@ fn test_derive() {\n         c: usize,\n     }\n \n-    let x = P {a: 1usize, b: 2u8, c: 3usize};\n-    let y = P {a: 1usize, b: 2u8, c: 4usize};\n+    let x = P { a: 1usize, b: 2u8, c: 3usize };\n+    let y = P { a: 1usize, b: 2u8, c: 4usize };\n \n     let _clone = x.clone();\n     assert!(x != y);"}, {"sha": "db26a2084b1c0cba4e30de72bc72e06cdc89ea4f", "filename": "tests/pass/partially-uninit.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/bdf2a8a78c3e3864368ec8ec40d1822e1869e7af/tests%2Fpass%2Fpartially-uninit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdf2a8a78c3e3864368ec8ec40d1822e1869e7af/tests%2Fpass%2Fpartially-uninit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fpartially-uninit.rs?ref=bdf2a8a78c3e3864368ec8ec40d1822e1869e7af", "patch": "@@ -4,10 +4,12 @@ use std::mem::{self, MaybeUninit};\n #[derive(Copy, Clone, Debug, PartialEq)]\n struct Demo(bool, u16);\n \n-fn main() { unsafe {\n-    // Transmute-round-trip through a type with Scalar layout is lossless.\n-    // This is tricky because that 'scalar' is *partially* uninitialized.\n-    let x = Demo(true, 3);\n-    let y: MaybeUninit<u32> = mem::transmute(x);\n-    assert_eq!(x, mem::transmute(y));\n-} }\n+fn main() {\n+    unsafe {\n+        // Transmute-round-trip through a type with Scalar layout is lossless.\n+        // This is tricky because that 'scalar' is *partially* uninitialized.\n+        let x = Demo(true, 3);\n+        let y: MaybeUninit<u32> = mem::transmute(x);\n+        assert_eq!(x, mem::transmute(y));\n+    }\n+}"}, {"sha": "898ecc0faf7559124b6a77b68509620f36b3fd23", "filename": "tests/pass/pointers.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bdf2a8a78c3e3864368ec8ec40d1822e1869e7af/tests%2Fpass%2Fpointers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdf2a8a78c3e3864368ec8ec40d1822e1869e7af/tests%2Fpass%2Fpointers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fpointers.rs?ref=bdf2a8a78c3e3864368ec8ec40d1822e1869e7af", "patch": "@@ -37,7 +37,7 @@ fn match_ref_mut() -> i8 {\n         let opt = Some(&mut t);\n         match opt {\n             Some(&mut (ref mut x, ref mut y)) => *x += *y,\n-            None => {},\n+            None => {}\n         }\n     }\n     t.0\n@@ -59,7 +59,10 @@ fn main() {\n     // Compare even dangling pointers with NULL, and with others in the same allocation, including\n     // out-of-bounds.\n     assert!(dangling_pointer() != std::ptr::null());\n-    assert!(match dangling_pointer() as usize { 0 => false, _ => true });\n+    assert!(match dangling_pointer() as usize {\n+        0 => false,\n+        _ => true,\n+    });\n     let dangling = dangling_pointer();\n     assert!(dangling == dangling);\n     assert!(dangling.wrapping_add(1) != dangling);"}, {"sha": "ffbaa1832ecbad10453df57dabbba17e73f5b468", "filename": "tests/pass/portable-simd.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/bdf2a8a78c3e3864368ec8ec40d1822e1869e7af/tests%2Fpass%2Fportable-simd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdf2a8a78c3e3864368ec8ec40d1822e1869e7af/tests%2Fpass%2Fportable-simd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fportable-simd.rs?ref=bdf2a8a78c3e3864368ec8ec40d1822e1869e7af", "patch": "@@ -16,10 +16,10 @@ fn simd_ops_f32() {\n     assert_eq!(a.max(b * f32x4::splat(4.0)), f32x4::from_array([10.0, 10.0, 12.0, 10.0]));\n     assert_eq!(a.min(b * f32x4::splat(4.0)), f32x4::from_array([4.0, 8.0, 10.0, -16.0]));\n \n-    assert_eq!(a.mul_add(b, a), (a*b)+a);\n-    assert_eq!(b.mul_add(b, a), (b*b)+a);\n-    assert_eq!((a*a).sqrt(), a);\n-    assert_eq!((b*b).sqrt(), b.abs());\n+    assert_eq!(a.mul_add(b, a), (a * b) + a);\n+    assert_eq!(b.mul_add(b, a), (b * b) + a);\n+    assert_eq!((a * a).sqrt(), a);\n+    assert_eq!((b * b).sqrt(), b.abs());\n \n     assert_eq!(a.lanes_eq(f32x4::splat(5.0) * b), Mask::from_array([false, true, false, false]));\n     assert_eq!(a.lanes_ne(f32x4::splat(5.0) * b), Mask::from_array([true, false, true, true]));\n@@ -65,10 +65,10 @@ fn simd_ops_f64() {\n     assert_eq!(a.max(b * f64x4::splat(4.0)), f64x4::from_array([10.0, 10.0, 12.0, 10.0]));\n     assert_eq!(a.min(b * f64x4::splat(4.0)), f64x4::from_array([4.0, 8.0, 10.0, -16.0]));\n \n-    assert_eq!(a.mul_add(b, a), (a*b)+a);\n-    assert_eq!(b.mul_add(b, a), (b*b)+a);\n-    assert_eq!((a*a).sqrt(), a);\n-    assert_eq!((b*b).sqrt(), b.abs());\n+    assert_eq!(a.mul_add(b, a), (a * b) + a);\n+    assert_eq!(b.mul_add(b, a), (b * b) + a);\n+    assert_eq!((a * a).sqrt(), a);\n+    assert_eq!((b * b).sqrt(), b.abs());\n \n     assert_eq!(a.lanes_eq(f64x4::splat(5.0) * b), Mask::from_array([false, true, false, false]));\n     assert_eq!(a.lanes_ne(f64x4::splat(5.0) * b), Mask::from_array([true, false, true, true]));"}, {"sha": "767d756e5ae1850bf89fde520f5d00068e35a1ca", "filename": "tests/pass/products.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bdf2a8a78c3e3864368ec8ec40d1822e1869e7af/tests%2Fpass%2Fproducts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdf2a8a78c3e3864368ec8ec40d1822e1869e7af/tests%2Fpass%2Fproducts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fproducts.rs?ref=bdf2a8a78c3e3864368ec8ec40d1822e1869e7af", "patch": "@@ -11,7 +11,10 @@ fn tuple_5() -> (i16, i16, i16, i16, i16) {\n }\n \n #[derive(Debug, PartialEq)]\n-struct Pair { x: i8, y: i8 }\n+struct Pair {\n+    x: i8,\n+    y: i8,\n+}\n \n fn pair() -> Pair {\n     Pair { x: 10, y: 20 }\n@@ -27,6 +30,6 @@ fn main() {\n     assert_eq!(tuple(), (1,));\n     assert_eq!(tuple_2(), (1, 2));\n     assert_eq!(tuple_5(), (1, 2, 3, 4, 5));\n-    assert_eq!(pair(), Pair { x: 10, y: 20} );\n+    assert_eq!(pair(), Pair { x: 10, y: 20 });\n     assert_eq!(field_access(), (15, 20));\n }"}, {"sha": "1b25df721452fef8be88b6acb0e073619ec16b06", "filename": "tests/pass/ptr_offset.rs", "status": "modified", "additions": 17, "deletions": 13, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/bdf2a8a78c3e3864368ec8ec40d1822e1869e7af/tests%2Fpass%2Fptr_offset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdf2a8a78c3e3864368ec8ec40d1822e1869e7af/tests%2Fpass%2Fptr_offset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fptr_offset.rs?ref=bdf2a8a78c3e3864368ec8ec40d1822e1869e7af", "patch": "@@ -8,21 +8,23 @@ fn main() {\n     ptr_offset();\n }\n \n-fn test_offset_from() { unsafe {\n-    let buf = [0u32; 4];\n+fn test_offset_from() {\n+    unsafe {\n+        let buf = [0u32; 4];\n \n-    let x = buf.as_ptr() as *const u8;\n-    let y = x.offset(12);\n+        let x = buf.as_ptr() as *const u8;\n+        let y = x.offset(12);\n \n-    assert_eq!(y.offset_from(x), 12);\n-    assert_eq!(x.offset_from(y), -12);\n-    assert_eq!((y as *const u32).offset_from(x as *const u32), 12/4);\n-    assert_eq!((x as *const u32).offset_from(y as *const u32), -12/4);\n+        assert_eq!(y.offset_from(x), 12);\n+        assert_eq!(x.offset_from(y), -12);\n+        assert_eq!((y as *const u32).offset_from(x as *const u32), 12 / 4);\n+        assert_eq!((x as *const u32).offset_from(y as *const u32), -12 / 4);\n \n-    let x = (((x as usize) * 2) / 2) as *const u8;\n-    assert_eq!(y.offset_from(x), 12);\n-    assert_eq!(x.offset_from(y), -12);\n-} }\n+        let x = (((x as usize) * 2) / 2) as *const u8;\n+        assert_eq!(y.offset_from(x), 12);\n+        assert_eq!(x.offset_from(y), -12);\n+    }\n+}\n \n // This also internally uses offset_from.\n fn test_vec_into_iter() {\n@@ -50,7 +52,9 @@ fn ptr_arith_offset_overflow() {\n }\n \n fn ptr_offset() {\n-    fn f() -> i32 { 42 }\n+    fn f() -> i32 {\n+        42\n+    }\n \n     let v = [1i16, 2];\n     let x = &v as *const [i16; 2] as *const i16;"}, {"sha": "3ba0fba9a94123de93c5601cd5e335c680b5e736", "filename": "tests/pass/ptr_raw.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bdf2a8a78c3e3864368ec8ec40d1822e1869e7af/tests%2Fpass%2Fptr_raw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdf2a8a78c3e3864368ec8ec40d1822e1869e7af/tests%2Fpass%2Fptr_raw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fptr_raw.rs?ref=bdf2a8a78c3e3864368ec8ec40d1822e1869e7af", "patch": "@@ -5,12 +5,16 @@ fn basic_raw() {\n     assert_eq!(*x, 12);\n \n     let raw = x as *mut i32;\n-    unsafe { *raw = 42; }\n+    unsafe {\n+        *raw = 42;\n+    }\n \n     assert_eq!(*x, 42);\n \n     let raw = x as *mut i32;\n-    unsafe { *raw = 12; }\n+    unsafe {\n+        *raw = 12;\n+    }\n     *x = 23;\n \n     assert_eq!(*x, 23);"}, {"sha": "260e350f27ac253a5b6d9d6ac6928e683f023958", "filename": "tests/pass/rc.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bdf2a8a78c3e3864368ec8ec40d1822e1869e7af/tests%2Fpass%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdf2a8a78c3e3864368ec8ec40d1822e1869e7af/tests%2Fpass%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Frc.rs?ref=bdf2a8a78c3e3864368ec8ec40d1822e1869e7af", "patch": "@@ -3,9 +3,9 @@\n #![feature(get_mut_unchecked)]\n \n use std::cell::{Cell, RefCell};\n+use std::fmt::Debug;\n use std::rc::{Rc, Weak};\n use std::sync::{Arc, Weak as ArcWeak};\n-use std::fmt::Debug;\n \n fn rc_refcell() {\n     let r = Rc::new(RefCell::new(42));\n@@ -30,7 +30,7 @@ fn rc_refcell2() {\n     let x = r2.borrow();\n     let r3 = r.clone();\n     let y = r3.borrow();\n-    assert_eq!((*x + *y)/2, 52);\n+    assert_eq!((*x + *y) / 2, 52);\n }\n \n fn rc_raw() {\n@@ -62,9 +62,9 @@ fn check_unique_rc<T: ?Sized>(mut r: Rc<T>) {\n }\n \n fn rc_from() {\n-    check_unique_rc::<[_]>(Rc::from(&[1,2,3] as &[_]));\n-    check_unique_rc::<[_]>(Rc::from(vec![1,2,3]));\n-    check_unique_rc::<[_]>(Rc::from(Box::new([1,2,3]) as Box<[_]>));\n+    check_unique_rc::<[_]>(Rc::from(&[1, 2, 3] as &[_]));\n+    check_unique_rc::<[_]>(Rc::from(vec![1, 2, 3]));\n+    check_unique_rc::<[_]>(Rc::from(Box::new([1, 2, 3]) as Box<[_]>));\n     check_unique_rc::<str>(Rc::from(\"Hello, World!\"));\n }\n "}, {"sha": "5dafc88756f119ff5296de5641b30cef40d496b9", "filename": "tests/pass/regions-mock-trans.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/bdf2a8a78c3e3864368ec8ec40d1822e1869e7af/tests%2Fpass%2Fregions-mock-trans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdf2a8a78c3e3864368ec8ec40d1822e1869e7af/tests%2Fpass%2Fregions-mock-trans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fregions-mock-trans.rs?ref=bdf2a8a78c3e3864368ec8ec40d1822e1869e7af", "patch": "@@ -9,40 +9,37 @@ use std::mem;\n struct Arena(());\n \n struct Bcx<'a> {\n-    fcx: &'a Fcx<'a>\n+    fcx: &'a Fcx<'a>,\n }\n \n #[allow(dead_code)]\n struct Fcx<'a> {\n     arena: &'a Arena,\n-    ccx: &'a Ccx\n+    ccx: &'a Ccx,\n }\n \n #[allow(dead_code)]\n struct Ccx {\n-    x: isize\n+    x: isize,\n }\n \n-fn alloc<'a>(_bcx : &'a Arena) -> &'a mut Bcx<'a> {\n-    unsafe {\n-        mem::transmute(libc::malloc(mem::size_of::<Bcx<'a>>()\n-            as libc::size_t))\n-    }\n+fn alloc<'a>(_bcx: &'a Arena) -> &'a mut Bcx<'a> {\n+    unsafe { mem::transmute(libc::malloc(mem::size_of::<Bcx<'a>>() as libc::size_t)) }\n }\n \n-fn h<'a>(bcx : &'a Bcx<'a>) -> &'a mut Bcx<'a> {\n+fn h<'a>(bcx: &'a Bcx<'a>) -> &'a mut Bcx<'a> {\n     return alloc(bcx.fcx.arena);\n }\n \n-fn g(fcx : &Fcx) {\n+fn g(fcx: &Fcx) {\n     let bcx = Bcx { fcx: fcx };\n     let bcx2 = h(&bcx);\n     unsafe {\n         libc::free(mem::transmute(bcx2));\n     }\n }\n \n-fn f(ccx : &Ccx) {\n+fn f(ccx: &Ccx) {\n     let a = Arena(());\n     let fcx = Fcx { arena: &a, ccx: ccx };\n     return g(&fcx);"}, {"sha": "642f75ecc09bf5c0863bd3f6883136599c10c6b5", "filename": "tests/pass/send-is-not-static-par-for.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/bdf2a8a78c3e3864368ec8ec40d1822e1869e7af/tests%2Fpass%2Fsend-is-not-static-par-for.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdf2a8a78c3e3864368ec8ec40d1822e1869e7af/tests%2Fpass%2Fsend-is-not-static-par-for.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fsend-is-not-static-par-for.rs?ref=bdf2a8a78c3e3864368ec8ec40d1822e1869e7af", "patch": "@@ -1,9 +1,10 @@\n use std::sync::Mutex;\n \n fn par_for<I, F>(iter: I, f: F)\n-    where I: Iterator,\n-          I::Item: Send,\n-          F: Fn(I::Item) + Sync\n+where\n+    I: Iterator,\n+    I::Item: Send,\n+    F: Fn(I::Item) + Sync,\n {\n     for item in iter {\n         f(item)\n@@ -12,9 +13,7 @@ fn par_for<I, F>(iter: I, f: F)\n \n fn sum(x: &[i32]) {\n     let sum_lengths = Mutex::new(0);\n-    par_for(x.windows(4), |x| {\n-        *sum_lengths.lock().unwrap() += x.len()\n-    });\n+    par_for(x.windows(4), |x| *sum_lengths.lock().unwrap() += x.len());\n \n     assert_eq!(*sum_lengths.lock().unwrap(), (x.len() - 3) * 4);\n }\n@@ -23,9 +22,7 @@ fn main() {\n     let mut elements = [0; 20];\n \n     // iterators over references into this stack frame\n-    par_for(elements.iter_mut().enumerate(), |(i, x)| {\n-        *x = i as i32\n-    });\n+    par_for(elements.iter_mut().enumerate(), |(i, x)| *x = i as i32);\n \n     sum(&elements)\n }"}, {"sha": "a05278f1855a2b33a90c1dc0961616cc02ba673e", "filename": "tests/pass/sendable-class.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bdf2a8a78c3e3864368ec8ec40d1822e1869e7af/tests%2Fpass%2Fsendable-class.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdf2a8a78c3e3864368ec8ec40d1822e1869e7af/tests%2Fpass%2Fsendable-class.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fsendable-class.rs?ref=bdf2a8a78c3e3864368ec8ec40d1822e1869e7af", "patch": "@@ -8,11 +8,8 @@ struct Foo {\n     j: char,\n }\n \n-fn foo(i:isize, j: char) -> Foo {\n-    Foo {\n-        i: i,\n-        j: j\n-    }\n+fn foo(i: isize, j: char) -> Foo {\n+    Foo { i: i, j: j }\n }\n \n pub fn main() {"}, {"sha": "5958357c8b7b169badb6a5d966948fc3abe097af", "filename": "tests/pass/simd-intrinsic-generic-elements.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bdf2a8a78c3e3864368ec8ec40d1822e1869e7af/tests%2Fpass%2Fsimd-intrinsic-generic-elements.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdf2a8a78c3e3864368ec8ec40d1822e1869e7af/tests%2Fpass%2Fsimd-intrinsic-generic-elements.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fsimd-intrinsic-generic-elements.rs?ref=bdf2a8a78c3e3864368ec8ec40d1822e1869e7af", "patch": "@@ -11,8 +11,7 @@ struct i32x4(i32, i32, i32, i32);\n #[repr(simd)]\n #[derive(Copy, Clone, Debug, PartialEq)]\n #[allow(non_camel_case_types)]\n-struct i32x8(i32, i32, i32, i32,\n-             i32, i32, i32, i32);\n+struct i32x8(i32, i32, i32, i32, i32, i32, i32, i32);\n \n fn main() {\n     let _x2 = i32x2(20, 21);\n@@ -22,5 +21,4 @@ fn main() {\n     let _y2 = i32x2(120, 121);\n     let _y4 = i32x4(140, 141, 142, 143);\n     let _y8 = i32x8(180, 181, 182, 183, 184, 185, 186, 187);\n-\n }"}, {"sha": "3a13ec59a02ea0123ed4f8165ea6645d64450d6f", "filename": "tests/pass/slices.rs", "status": "modified", "additions": 20, "deletions": 15, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/bdf2a8a78c3e3864368ec8ec40d1822e1869e7af/tests%2Fpass%2Fslices.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdf2a8a78c3e3864368ec8ec40d1822e1869e7af/tests%2Fpass%2Fslices.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fslices.rs?ref=bdf2a8a78c3e3864368ec8ec40d1822e1869e7af", "patch": "@@ -5,8 +5,8 @@\n #![feature(layout_for_ptr)]\n #![feature(strict_provenance)]\n \n-use std::slice;\n use std::ptr;\n+use std::slice;\n \n fn slice_of_zst() {\n     fn foo<T>(v: &[T]) -> Option<&[T]> {\n@@ -40,7 +40,8 @@ fn slice_of_zst() {\n     assert!(foo(slice).is_some());\n \n     // Test mutable iterators as well\n-    let slice: &mut [()] = unsafe { slice::from_raw_parts_mut(ptr::invalid_mut(-5isize as usize), 10) };\n+    let slice: &mut [()] =\n+        unsafe { slice::from_raw_parts_mut(ptr::invalid_mut(-5isize as usize), 10) };\n     assert_eq!(slice.len(), 10);\n     assert_eq!(slice.iter_mut().count(), 10);\n \n@@ -56,11 +57,11 @@ fn slice_of_zst() {\n fn test_iter_ref_consistency() {\n     use std::fmt::Debug;\n \n-    fn test<T : Copy + Debug + PartialEq>(x : T) {\n-        let v : &[T] = &[x, x, x];\n-        let v_ptrs : [*const T; 3] = match v {\n+    fn test<T: Copy + Debug + PartialEq>(x: T) {\n+        let v: &[T] = &[x, x, x];\n+        let v_ptrs: [*const T; 3] = match v {\n             [ref v1, ref v2, ref v3] => [v1 as *const _, v2 as *const _, v3 as *const _],\n-            _ => unreachable!()\n+            _ => unreachable!(),\n         };\n         let len = v.len();\n \n@@ -104,19 +105,19 @@ fn test_iter_ref_consistency() {\n                 assert_eq!(it.size_hint(), (remaining, Some(remaining)));\n \n                 let prev = it.next_back().unwrap();\n-                assert_eq!(prev as *const _, v_ptrs[remaining-1]);\n+                assert_eq!(prev as *const _, v_ptrs[remaining - 1]);\n             }\n             assert_eq!(it.size_hint(), (0, Some(0)));\n             assert_eq!(it.next_back(), None, \"The final call to next_back() should return None\");\n         }\n     }\n \n-    fn test_mut<T : Copy + Debug + PartialEq>(x : T) {\n-        let v : &mut [T] = &mut [x, x, x];\n-        let v_ptrs : [*mut T; 3] = match v {\n+    fn test_mut<T: Copy + Debug + PartialEq>(x: T) {\n+        let v: &mut [T] = &mut [x, x, x];\n+        let v_ptrs: [*mut T; 3] = match v {\n             [ref v1, ref v2, ref v3] =>\n-              [v1 as *const _ as *mut _, v2 as *const _ as *mut _, v3 as *const _ as *mut _],\n-            _ => unreachable!()\n+                [v1 as *const _ as *mut _, v2 as *const _ as *mut _, v3 as *const _ as *mut _],\n+            _ => unreachable!(),\n         };\n         let len = v.len();\n \n@@ -160,7 +161,7 @@ fn test_iter_ref_consistency() {\n                 assert_eq!(it.size_hint(), (remaining, Some(remaining)));\n \n                 let prev = it.next_back().unwrap();\n-                assert_eq!(prev as *mut _, v_ptrs[remaining-1]);\n+                assert_eq!(prev as *mut _, v_ptrs[remaining - 1]);\n             }\n             assert_eq!(it.size_hint(), (0, Some(0)));\n             assert_eq!(it.next_back(), None, \"The final call to next_back() should return None\");\n@@ -215,10 +216,14 @@ fn test_for_invalidated_pointers() {\n     // The invalidated `*const` pointer (the first argument to `core::ptr::copy`) is then used\n     // after the fact when `core::ptr::copy` is called, which triggers undefined behavior.\n \n-    unsafe { assert_eq!(0, *buffer.as_mut_ptr_range().start ); }\n+    unsafe {\n+        assert_eq!(0, *buffer.as_mut_ptr_range().start);\n+    }\n     // Check that the pointer range is in-bounds, while we're at it\n     let range = buffer.as_mut_ptr_range();\n-    unsafe { assert_eq!(*range.start, *range.end.sub(len)); }\n+    unsafe {\n+        assert_eq!(*range.start, *range.end.sub(len));\n+    }\n \n     buffer.reverse();\n "}, {"sha": "428dea073eb53c5af24c2ec7cec0ed41af7cd0d5", "filename": "tests/pass/specialization.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bdf2a8a78c3e3864368ec8ec40d1822e1869e7af/tests%2Fpass%2Fspecialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdf2a8a78c3e3864368ec8ec40d1822e1869e7af/tests%2Fpass%2Fspecialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fspecialization.rs?ref=bdf2a8a78c3e3864368ec8ec40d1822e1869e7af", "patch": "@@ -6,11 +6,15 @@ trait IsUnit {\n }\n \n impl<T> IsUnit for T {\n-    default fn is_unit() -> bool { false }\n+    default fn is_unit() -> bool {\n+        false\n+    }\n }\n \n impl IsUnit for () {\n-    fn is_unit() -> bool { true }\n+    fn is_unit() -> bool {\n+        true\n+    }\n }\n \n fn specialization() -> (bool, bool) {"}, {"sha": "345cb64ccf713d677fd4dddb7418941602deabaa", "filename": "tests/pass/stacked-borrows/2phase.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/bdf2a8a78c3e3864368ec8ec40d1822e1869e7af/tests%2Fpass%2Fstacked-borrows%2F2phase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdf2a8a78c3e3864368ec8ec40d1822e1869e7af/tests%2Fpass%2Fstacked-borrows%2F2phase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fstacked-borrows%2F2phase.rs?ref=bdf2a8a78c3e3864368ec8ec40d1822e1869e7af", "patch": "@@ -21,7 +21,9 @@ fn two_phase3(b: bool) {\n     let mut y = vec![];\n     x.push((\n         {\n-            if b { x = &mut y };\n+            if b {\n+                x = &mut y;\n+            }\n             22\n         },\n         x.len(),\n@@ -31,16 +33,16 @@ fn two_phase3(b: bool) {\n #[allow(unreachable_code)]\n fn two_phase_raw() {\n     let x: &mut Vec<i32> = &mut vec![];\n-    x.push(\n-        {\n-            // Unfortunately this does not trigger the problem of creating a\n-            // raw ponter from a pointer that had a two-phase borrow derived from\n-            // it because of the implicit &mut reborrow.\n-            let raw = x as *mut _;\n-            unsafe { *raw = vec![1]; }\n-            return\n+    x.push({\n+        // Unfortunately this does not trigger the problem of creating a\n+        // raw ponter from a pointer that had a two-phase borrow derived from\n+        // it because of the implicit &mut reborrow.\n+        let raw = x as *mut _;\n+        unsafe {\n+            *raw = vec![1];\n         }\n-    );\n+        return;\n+    });\n }\n \n fn two_phase_overlapping1() {\n@@ -68,13 +70,11 @@ fn with_interior_mutability() {\n     let mut x = Cell::new(1);\n     let l = &x;\n \n-    x\n-        .do_the_thing({\n-            x.set(3);\n-            l.set(4);\n-            x.get() + l.get()\n-        })\n-    ;\n+    x.do_the_thing({\n+        x.set(3);\n+        l.set(4);\n+        x.get() + l.get()\n+    });\n }\n \n fn main() {"}, {"sha": "1ac9706b525f1c1611a4123ea5b1a73f386050d4", "filename": "tests/pass/stacked-borrows/interior_mutability.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/bdf2a8a78c3e3864368ec8ec40d1822e1869e7af/tests%2Fpass%2Fstacked-borrows%2Finterior_mutability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdf2a8a78c3e3864368ec8ec40d1822e1869e7af/tests%2Fpass%2Fstacked-borrows%2Finterior_mutability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fstacked-borrows%2Finterior_mutability.rs?ref=bdf2a8a78c3e3864368ec8ec40d1822e1869e7af", "patch": "@@ -1,5 +1,5 @@\n-use std::mem::MaybeUninit;\n use std::cell::{Cell, RefCell, UnsafeCell};\n+use std::mem::MaybeUninit;\n \n fn main() {\n     aliasing_mut_and_shr();\n@@ -28,7 +28,7 @@ fn aliasing_mut_and_shr() {\n     let mut bmut = rc.borrow_mut();\n     inner(&rc, &mut *bmut);\n     drop(bmut);\n-    assert_eq!(*rc.borrow(), 23+12);\n+    assert_eq!(*rc.borrow(), 23 + 12);\n }\n \n fn aliasing_frz_and_shr() {\n@@ -59,9 +59,11 @@ fn into_interior_mutability() {\n \n // Two-phase borrows of the pointer returned by UnsafeCell::get() should not\n // invalidate aliases.\n-fn unsafe_cell_2phase() { unsafe {\n-    let x = &UnsafeCell::new(vec![]);\n-    let x2 = &*x;\n-    (*x.get()).push(0);\n-    let _val = (*x2.get()).get(0);\n-} }\n+fn unsafe_cell_2phase() {\n+    unsafe {\n+        let x = &UnsafeCell::new(vec![]);\n+        let x2 = &*x;\n+        (*x.get()).push(0);\n+        let _val = (*x2.get()).get(0);\n+    }\n+}"}]}