{"sha": "871be2a4690cb9624d63cedd1095943776e6b902", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg3MWJlMmE0NjkwY2I5NjI0ZDYzY2VkZDEwOTU5NDM3NzZlNmI5MDI=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2018-08-17T11:21:03Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2018-08-17T11:21:03Z"}, "message": "Codegen entry wrapper (fixes #13)", "tree": {"sha": "a74eb2cc1bd9a021065ec03f076856ed58a5f644", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a74eb2cc1bd9a021065ec03f076856ed58a5f644"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/871be2a4690cb9624d63cedd1095943776e6b902", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/871be2a4690cb9624d63cedd1095943776e6b902", "html_url": "https://github.com/rust-lang/rust/commit/871be2a4690cb9624d63cedd1095943776e6b902", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/871be2a4690cb9624d63cedd1095943776e6b902/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7a3ba963e1fd3f986a66437bef3aba4bbf71afdf", "url": "https://api.github.com/repos/rust-lang/rust/commits/7a3ba963e1fd3f986a66437bef3aba4bbf71afdf", "html_url": "https://github.com/rust-lang/rust/commit/7a3ba963e1fd3f986a66437bef3aba4bbf71afdf"}], "stats": {"total": 166, "additions": 147, "deletions": 19}, "files": [{"sha": "ce8359698f0d0b37a97a48fa9d02867979c3d564", "filename": "build.sh", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/871be2a4690cb9624d63cedd1095943776e6b902/build.sh", "raw_url": "https://github.com/rust-lang/rust/raw/871be2a4690cb9624d63cedd1095943776e6b902/build.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/build.sh?ref=871be2a4690cb9624d63cedd1095943776e6b902", "patch": "@@ -31,7 +31,8 @@ extract_data libmini_core.rlib mini_core.o &&\n \n $RUSTC examples/example.rs --crate-type lib &&\n \n-SHOULD_RUN=1 $RUSTC examples/mini_core_hello_world.rs --crate-type bin &&\n+# SimpleJIT is broken\n+#SHOULD_RUN=1 $RUSTC examples/mini_core_hello_world.rs --crate-type bin &&\n \n $RUSTC examples/mini_core_hello_world.rs --crate-type bin &&\n extract_data mini_core_hello_world mini_core_hello_world.o &&\n@@ -40,4 +41,4 @@ gcc target/out/mini_core.o target/out/mini_core_hello_world.o -o target/out/mini\n ./target/out/mini_core_hello_world\n \n $RUSTC target/libcore/src/libcore/lib.rs --color=always --crate-type lib -Cincremental=target/incremental 2>&1 | (head -n 20; echo \"====\"; tail -n 1000)\n-cat target/libcore/log.txt | sort | uniq -c | grep -v \"rval unsize move\" | grep -v \"rval len\"\n+cat target/out/log.txt | sort | uniq -c | grep -v \"rval unsize move\" | grep -v \"rval len\""}, {"sha": "19cc727fb55eebcb0aa8800a01d90dc29f3be826", "filename": "examples/mini_core_hello_world.rs", "status": "modified", "additions": 24, "deletions": 8, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/871be2a4690cb9624d63cedd1095943776e6b902/examples%2Fmini_core_hello_world.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871be2a4690cb9624d63cedd1095943776e6b902/examples%2Fmini_core_hello_world.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/examples%2Fmini_core_hello_world.rs?ref=871be2a4690cb9624d63cedd1095943776e6b902", "patch": "@@ -2,7 +2,6 @@\n \n #![feature(no_core, unboxed_closures, start, lang_items)]\n #![no_core]\n-#![no_main]\n #![allow(dead_code)]\n \n extern crate mini_core;\n@@ -16,20 +15,37 @@ extern \"C\" {\n     fn puts(s: *const u8);\n }\n \n+#[lang = \"termination\"]\n+trait Termination {\n+    fn report(self) -> i32;\n+}\n+\n+impl Termination for () {\n+    fn report(self) -> i32 {\n+        unsafe {\n+            NUM = 6 * 7 + 1 + (1u8 == 1u8) as u8; // 44\n+            *NUM_REF as i32\n+        }\n+    }\n+}\n+\n+#[lang = \"start\"]\n+fn start<T: Termination + 'static>(\n+    main: fn() -> T,\n+    _argc: isize,\n+    _argv: *const *const u8,\n+) -> isize {\n+    main().report() as isize\n+}\n+\n static mut NUM: u8 = 6 * 7;\n static NUM_REF: &'static u8 = unsafe { &NUM };\n \n-#[lang = \"start\"]\n-fn start(_main: *const u8, i: isize, _: *const *const u8) -> isize {\n+fn main() {\n     unsafe {\n         let (ptr, _): (*const u8, usize) = intrinsics::transmute(\"Hello!\\0\");\n         puts(ptr);\n     }\n \n     //panic(&(\"panic msg\", \"abc.rs\", 0, 43));\n-\n-    unsafe {\n-        NUM = 6 * 7 + 1 + (1u8 == 1u8) as u8; // 44\n-        *NUM_REF as isize\n-    }\n }"}, {"sha": "e056ada0260e93b1facd7183bbf52a9b8e3d8c3b", "filename": "src/lib.rs", "status": "modified", "additions": 120, "deletions": 9, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/871be2a4690cb9624d63cedd1095943776e6b902/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871be2a4690cb9624d63cedd1095943776e6b902/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=871be2a4690cb9624d63cedd1095943776e6b902", "patch": "@@ -113,6 +113,7 @@ pub struct CodegenCx<'a, 'tcx: 'a, B: Backend + 'static> {\n }\n \n pub struct ModuleTup<T> {\n+    #[allow(dead_code)]\n     jit: Option<T>,\n     #[allow(dead_code)]\n     faerie: Option<T>,\n@@ -234,21 +235,27 @@ impl CodegenBackend for CraneliftCodegenBackend {\n             tcx.sess.warn(\"Compiled everything\");\n \n             tcx.sess.warn(\"Rustc codegen cranelift will JIT run the executable, because the SHOULD_RUN env var is set\");\n-            let start_wrapper = tcx.lang_items().start_fn().expect(\"no start lang item\");\n \n-            let (name, sig) =\n-                crate::abi::get_function_name_and_sig(tcx, Instance::mono(tcx, start_wrapper));\n-            let called_func_id = jit_module\n-                .declare_function(&name, Linkage::Import, &sig)\n+            let sig = Signature {\n+                params: vec![\n+                    AbiParam::new(types::I64 /*usize*/),\n+                    AbiParam::new(types::I64 /* *const _*/),\n+                ],\n+                returns: vec![AbiParam::new(types::I64 /*isize*/)],\n+                call_conv: CallConv::SystemV,\n+                argument_bytes: None,\n+            };\n+            let main_func_id = jit_module\n+                .declare_function(\"main\", Linkage::Import, &sig)\n                 .unwrap();\n \n-            let finalized_function: *const u8 = jit_module.finalize_function(called_func_id);\n+            let finalized_main: *const u8 = jit_module.finalize_function(main_func_id);\n             jit_module.finalize_all();\n             tcx.sess.warn(\"Finalized everything\");\n \n-            let f: extern \"C\" fn(*const u8, isize, *const *const u8) -> isize =\n-                unsafe { ::std::mem::transmute(finalized_function) };\n-            let res = f(0 as *const u8, 0, 0 as *const _);\n+            let f: extern \"C\" fn(isize, *const *const u8) -> isize =\n+                unsafe { ::std::mem::transmute(finalized_main) };\n+            let res = f(0, 0 as *const _);\n             tcx.sess.warn(&format!(\"main returned {}\", res));\n \n             jit_module.finish();\n@@ -379,6 +386,8 @@ fn codegen_mono_items<'a, 'tcx: 'a>(\n         }\n     }\n \n+    maybe_create_entry_wrapper(&mut cx);\n+\n     cx.ccx.finalize(tcx, cx.module);\n \n     let after = ::std::time::Instant::now();\n@@ -396,3 +405,105 @@ fn save_incremental<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n pub fn __rustc_codegen_backend() -> Box<CodegenBackend> {\n     Box::new(CraneliftCodegenBackend)\n }\n+\n+/// Create the `main` function which will initialize the rust runtime and call\n+/// users main function.\n+fn maybe_create_entry_wrapper(cx: &mut CodegenCx<impl Backend + 'static>) {\n+    use rustc::middle::lang_items::StartFnLangItem;\n+    use rustc::session::config::EntryFnType;\n+\n+    let tcx = cx.tcx;\n+\n+    let (main_def_id, use_start_lang_item) = match *tcx.sess.entry_fn.borrow() {\n+        Some((id, _, entry_ty)) => (\n+            tcx.hir.local_def_id(id),\n+            match entry_ty {\n+                EntryFnType::Main => true,\n+                EntryFnType::Start => false,\n+            },\n+        ),\n+        None => return,\n+    };\n+\n+    create_entry_fn(tcx, cx.module, main_def_id, use_start_lang_item);;\n+\n+    fn create_entry_fn<'a, 'tcx: 'a>(\n+        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+        m: &mut Module<impl Backend + 'static>,\n+        rust_main_def_id: DefId,\n+        use_start_lang_item: bool,\n+    ) {\n+        let main_ret_ty = tcx.fn_sig(rust_main_def_id).output();\n+        // Given that `main()` has no arguments,\n+        // then its return type cannot have\n+        // late-bound regions, since late-bound\n+        // regions must appear in the argument\n+        // listing.\n+        let main_ret_ty = tcx.erase_regions(&main_ret_ty.no_late_bound_regions().unwrap());\n+\n+        let cmain_sig = Signature {\n+            params: vec![\n+                AbiParam::new(types::I64 /*usize*/),\n+                AbiParam::new(types::I64 /* *const _*/),\n+            ],\n+            returns: vec![AbiParam::new(types::I64 /*isize*/)],\n+            call_conv: CallConv::SystemV,\n+            argument_bytes: None,\n+        };\n+\n+        let cmain_func_id = m\n+            .declare_function(\"main\", Linkage::Export, &cmain_sig)\n+            .unwrap();\n+\n+        let instance = Instance::mono(tcx, rust_main_def_id);\n+\n+        let (main_name, main_sig) = get_function_name_and_sig(tcx, instance);\n+\n+        let main_func_id = m\n+            .declare_function(&main_name, Linkage::Import, &main_sig)\n+            .unwrap();\n+\n+        let mut ctx = Context::new();\n+        ctx.func = Function::with_name_signature(ExternalName::user(0, 0), cmain_sig.clone());\n+        {\n+            let mut func_ctx = FunctionBuilderContext::new();\n+            let mut bcx: FunctionBuilder = FunctionBuilder::new(&mut ctx.func, &mut func_ctx);\n+\n+            let ebb = bcx.create_ebb();\n+            bcx.switch_to_block(ebb);\n+            let arg_argc = bcx.append_ebb_param(ebb, types::I64 /*usize*/);\n+            let arg_argv = bcx.append_ebb_param(ebb, types::I64 /* *const _*/);\n+\n+            let main_func_ref = m.declare_func_in_func(main_func_id, &mut bcx.func);\n+\n+            let call_inst = if use_start_lang_item {\n+                let start_def_id = tcx.require_lang_item(StartFnLangItem);\n+                let start_instance = Instance::resolve(\n+                    tcx,\n+                    ParamEnv::reveal_all(),\n+                    start_def_id,\n+                    tcx.intern_substs(&[main_ret_ty.into()]),\n+                ).unwrap();\n+\n+                let (start_name, start_sig) = get_function_name_and_sig(tcx, start_instance);\n+                let start_func_id = m\n+                    .declare_function(&start_name, Linkage::Import, &start_sig)\n+                    .unwrap();\n+\n+                let main_val = bcx.ins().func_addr(types::I64, main_func_ref);\n+\n+                let func_ref = m.declare_func_in_func(start_func_id, &mut bcx.func);\n+                bcx.ins().call(func_ref, &[main_val, arg_argc, arg_argv])\n+            } else {\n+                // using user-defined start fn\n+                bcx.ins().call(main_func_ref, &[arg_argc, arg_argv])\n+            };\n+\n+            let result = bcx.inst_results(call_inst)[0];\n+            bcx.ins().return_(&[result]);\n+            bcx.seal_all_blocks();\n+            bcx.finalize();\n+        }\n+        m.define_function(cmain_func_id, &mut ctx).unwrap();\n+    }\n+}"}]}