{"sha": "8467ba8cdb565d865e14e2115cde98cd7692719d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg0NjdiYThjZGI1NjVkODY1ZTE0ZTIxMTVjZGU5OGNkNzY5MjcxOWQ=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-07-19T17:29:59Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-07-19T17:29:59Z"}, "message": "flip syntax text to use internal iteration", "tree": {"sha": "0a38aeef5b06d7f05186e6927a4dd1280fd35396", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0a38aeef5b06d7f05186e6927a4dd1280fd35396"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8467ba8cdb565d865e14e2115cde98cd7692719d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8467ba8cdb565d865e14e2115cde98cd7692719d", "html_url": "https://github.com/rust-lang/rust/commit/8467ba8cdb565d865e14e2115cde98cd7692719d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8467ba8cdb565d865e14e2115cde98cd7692719d/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8f032d6a585d59a9d2e57beeaca903a4fb5eb57b", "url": "https://api.github.com/repos/rust-lang/rust/commits/8f032d6a585d59a9d2e57beeaca903a4fb5eb57b", "html_url": "https://github.com/rust-lang/rust/commit/8f032d6a585d59a9d2e57beeaca903a4fb5eb57b"}], "stats": {"total": 116, "additions": 78, "deletions": 38}, "files": [{"sha": "ec756f2c36f386cd2611405d032f09c7ed82e607", "filename": "crates/ra_hir/src/ids.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8467ba8cdb565d865e14e2115cde98cd7692719d/crates%2Fra_hir%2Fsrc%2Fids.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8467ba8cdb565d865e14e2115cde98cd7692719d/crates%2Fra_hir%2Fsrc%2Fids.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fids.rs?ref=8467ba8cdb565d865e14e2115cde98cd7692719d", "patch": "@@ -362,7 +362,16 @@ impl MacroCallId {\n     pub fn debug_dump(self, db: &impl AstDatabase) -> String {\n         let loc = self.loc(db);\n         let node = loc.ast_id.to_node(db);\n-        let syntax_str = node.syntax().text().chunks().collect::<Vec<_>>().join(\" \");\n+        let syntax_str = {\n+            let mut res = String::new();\n+            node.syntax().text().for_each_chunk(|chunk| {\n+                if !res.is_empty() {\n+                    res.push(' ')\n+                }\n+                res.push_str(chunk)\n+            });\n+            res\n+        };\n \n         // dump the file name\n         let file_id: HirFileId = self.loc(db).ast_id.file_id();"}, {"sha": "0b1a8b6e6f075a96f0f2bf0363ac5c383e8de78c", "filename": "crates/ra_ide_api/src/display/structure.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8467ba8cdb565d865e14e2115cde98cd7692719d/crates%2Fra_ide_api%2Fsrc%2Fdisplay%2Fstructure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8467ba8cdb565d865e14e2115cde98cd7692719d/crates%2Fra_ide_api%2Fsrc%2Fdisplay%2Fstructure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fdisplay%2Fstructure.rs?ref=8467ba8cdb565d865e14e2115cde98cd7692719d", "patch": "@@ -83,20 +83,20 @@ fn structure_node(node: &SyntaxNode) -> Option<StructureNode> {\n \n     fn collapse_ws(node: &SyntaxNode, output: &mut String) {\n         let mut can_insert_ws = false;\n-        for chunk in node.text().chunks() {\n+        node.text().for_each_chunk(|chunk| {\n             for line in chunk.lines() {\n                 let line = line.trim();\n                 if line.is_empty() {\n                     if can_insert_ws {\n-                        output.push_str(\" \");\n+                        output.push(' ');\n                         can_insert_ws = false;\n                     }\n                 } else {\n                     output.push_str(line);\n                     can_insert_ws = true;\n                 }\n             }\n-        }\n+        })\n     }\n \n     visitor()"}, {"sha": "8fe9e5b4e14d80eb0b812e4507f70098819c7eb9", "filename": "crates/ra_syntax/src/syntax_node.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8467ba8cdb565d865e14e2115cde98cd7692719d/crates%2Fra_syntax%2Fsrc%2Fsyntax_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8467ba8cdb565d865e14e2115cde98cd7692719d/crates%2Fra_syntax%2Fsrc%2Fsyntax_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fsyntax_node.rs?ref=8467ba8cdb565d865e14e2115cde98cd7692719d", "patch": "@@ -297,7 +297,6 @@ fn to_green_element(element: SyntaxElement) -> rowan::GreenElement {\n #[derive(Clone, PartialEq, Eq, Hash)]\n pub struct SyntaxToken(pub(crate) rowan::cursor::SyntaxToken);\n \n-//FIXME: always output text\n impl fmt::Debug for SyntaxToken {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         write!(fmt, \"{:?}@{:?}\", self.kind(), self.range())?;"}, {"sha": "6f15e3b35abeec3db8b5220adfd94fbd1678057d", "filename": "crates/ra_syntax/src/syntax_text.rs", "status": "modified", "additions": 65, "deletions": 33, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/8467ba8cdb565d865e14e2115cde98cd7692719d/crates%2Fra_syntax%2Fsrc%2Fsyntax_text.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8467ba8cdb565d865e14e2115cde98cd7692719d/crates%2Fra_syntax%2Fsrc%2Fsyntax_text.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fsyntax_text.rs?ref=8467ba8cdb565d865e14e2115cde98cd7692719d", "patch": "@@ -16,26 +16,48 @@ impl<'a> SyntaxText<'a> {\n         SyntaxText { node, range: node.range() }\n     }\n \n-    pub fn chunks(&self) -> impl Iterator<Item = SmolStr> {\n-        let range = self.range;\n-        self.node.descendants_with_tokens().filter_map(move |el| match el {\n-            SyntaxElement::Token(t) => {\n-                let text = t.text();\n-                let range = range.intersection(&t.range())?;\n-                let res = if range == t.range() {\n-                    t.text().clone()\n-                } else {\n-                    let range = range - t.range().start();\n-                    text[range].into()\n-                };\n-                Some(res)\n-            }\n-            SyntaxElement::Node(_) => None,\n+    pub fn try_fold_chunks<T, F, E>(&self, init: T, mut f: F) -> Result<T, E>\n+    where\n+        F: FnMut(T, &str) -> Result<T, E>,\n+    {\n+        self.node.descendants_with_tokens().try_fold(init, move |acc, element| {\n+            let res = match element {\n+                SyntaxElement::Token(token) => {\n+                    let range = match self.range.intersection(&token.range()) {\n+                        None => return Ok(acc),\n+                        Some(it) => it,\n+                    };\n+                    let slice = if range == token.range() {\n+                        token.text()\n+                    } else {\n+                        let range = range - token.range().start();\n+                        &token.text()[range]\n+                    };\n+                    f(acc, slice)?\n+                }\n+                SyntaxElement::Node(_) => acc,\n+            };\n+            Ok(res)\n         })\n     }\n \n+    pub fn try_for_each_chunk<F: FnMut(&str) -> Result<(), E>, E>(\n+        &self,\n+        mut f: F,\n+    ) -> Result<(), E> {\n+        self.try_fold_chunks((), move |(), chunk| f(chunk))\n+    }\n+\n+    pub fn for_each_chunk<F: FnMut(&str)>(&self, mut f: F) {\n+        enum Void {}\n+        match self.try_for_each_chunk(|chunk| Ok::<(), Void>(f(chunk))) {\n+            Ok(()) => (),\n+            Err(void) => match void {},\n+        }\n+    }\n+\n     pub fn push_to(&self, buf: &mut String) {\n-        self.chunks().for_each(|it| buf.push_str(it.as_str()));\n+        self.for_each_chunk(|chunk| buf.push_str(chunk))\n     }\n \n     pub fn to_string(&self) -> String {\n@@ -49,19 +71,20 @@ impl<'a> SyntaxText<'a> {\n     }\n \n     pub fn contains(&self, c: char) -> bool {\n-        self.chunks().any(|it| it.contains(c))\n+        self.try_for_each_chunk(|chunk| if chunk.contains(c) { Err(()) } else { Ok(()) }).is_err()\n     }\n \n     pub fn find(&self, c: char) -> Option<TextUnit> {\n         let mut acc: TextUnit = 0.into();\n-        for chunk in self.chunks() {\n+        let res = self.try_for_each_chunk(|chunk| {\n             if let Some(pos) = chunk.find(c) {\n                 let pos: TextUnit = (pos as u32).into();\n-                return Some(acc + pos);\n+                return Err(acc + pos);\n             }\n-            acc += TextUnit::of_str(chunk.as_str());\n-        }\n-        None\n+            acc += TextUnit::of_str(chunk);\n+            Ok(())\n+        });\n+        found(res)\n     }\n \n     pub fn len(&self) -> TextUnit {\n@@ -101,17 +124,25 @@ impl<'a> SyntaxText<'a> {\n     }\n \n     pub fn char_at(&self, offset: impl Into<TextUnit>) -> Option<char> {\n-        let mut start: TextUnit = 0.into();\n         let offset = offset.into();\n-        for chunk in self.chunks() {\n-            let end = start + TextUnit::of_str(chunk.as_str());\n+        let mut start: TextUnit = 0.into();\n+        let res = self.try_for_each_chunk(|chunk| {\n+            let end = start + TextUnit::of_str(chunk);\n             if start <= offset && offset < end {\n                 let off: usize = u32::from(offset - start) as usize;\n-                return Some(chunk[off..].chars().next().unwrap());\n+                return Err(chunk[off..].chars().next().unwrap());\n             }\n             start = end;\n-        }\n-        None\n+            Ok(())\n+        });\n+        found(res)\n+    }\n+}\n+\n+fn found<T>(res: Result<(), T>) -> Option<T> {\n+    match res {\n+        Ok(()) => None,\n+        Err(it) => Some(it),\n     }\n }\n \n@@ -135,13 +166,14 @@ impl From<SyntaxText<'_>> for String {\n \n impl PartialEq<str> for SyntaxText<'_> {\n     fn eq(&self, mut rhs: &str) -> bool {\n-        for chunk in self.chunks() {\n-            if !rhs.starts_with(chunk.as_str()) {\n-                return false;\n+        self.try_for_each_chunk(|chunk| {\n+            if !rhs.starts_with(chunk) {\n+                return Err(());\n             }\n             rhs = &rhs[chunk.len()..];\n-        }\n-        rhs.is_empty()\n+            Ok(())\n+        })\n+        .is_ok()\n     }\n }\n "}]}