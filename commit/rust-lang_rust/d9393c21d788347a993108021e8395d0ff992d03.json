{"sha": "d9393c21d788347a993108021e8395d0ff992d03", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ5MzkzYzIxZDc4ODM0N2E5OTMxMDgwMjFlODM5NWQwZmY5OTJkMDM=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2015-02-06T16:59:56Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2015-02-09T18:55:59Z"}, "message": "Given `<expr> as Box<Trait>`, infer that `Box<_>` is expected type for `<expr>`.", "tree": {"sha": "fdaf6e2d0fc2746f844e44eee65c4e16db4c18eb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fdaf6e2d0fc2746f844e44eee65c4e16db4c18eb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d9393c21d788347a993108021e8395d0ff992d03", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d9393c21d788347a993108021e8395d0ff992d03", "html_url": "https://github.com/rust-lang/rust/commit/d9393c21d788347a993108021e8395d0ff992d03", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d9393c21d788347a993108021e8395d0ff992d03/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0ba9e1fa52627404a1e5b90f745f96a872a0c564", "url": "https://api.github.com/repos/rust-lang/rust/commits/0ba9e1fa52627404a1e5b90f745f96a872a0c564", "html_url": "https://github.com/rust-lang/rust/commit/0ba9e1fa52627404a1e5b90f745f96a872a0c564"}], "stats": {"total": 109, "additions": 47, "deletions": 62}, "files": [{"sha": "00f6c6109faeff664728612ccd04a309d3de1fd6", "filename": "src/librustc_typeck/check/vtable.rs", "status": "modified", "additions": 47, "deletions": 62, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/d9393c21d788347a993108021e8395d0ff992d03/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9393c21d788347a993108021e8395d0ff992d03/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs?ref=d9393c21d788347a993108021e8395d0ff992d03", "patch": "@@ -9,11 +9,11 @@\n // except according to those terms.\n \n use check::{FnCtxt, structurally_resolved_type};\n+use check::demand;\n use middle::traits::{self, ObjectSafetyViolation, MethodViolationCode};\n use middle::traits::{Obligation, ObligationCause};\n use middle::traits::report_fulfillment_errors;\n use middle::ty::{self, Ty, AsPredicate};\n-use middle::infer;\n use syntax::ast;\n use syntax::codemap::Span;\n use util::nodemap::FnvHashSet;\n@@ -24,71 +24,63 @@ pub fn check_object_cast<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                    source_expr: &ast::Expr,\n                                    target_object_ty: Ty<'tcx>)\n {\n+    let tcx = fcx.tcx();\n     debug!(\"check_object_cast(cast_expr={}, target_object_ty={})\",\n-           cast_expr.repr(fcx.tcx()),\n-           target_object_ty.repr(fcx.tcx()));\n+           cast_expr.repr(tcx),\n+           target_object_ty.repr(tcx));\n \n     // Look up vtables for the type we're casting to,\n     // passing in the source and target type.  The source\n     // must be a pointer type suitable to the object sigil,\n     // e.g.: `&x as &Trait` or `box x as Box<Trait>`\n-    let source_ty = fcx.expr_ty(source_expr);\n-    let source_ty = structurally_resolved_type(fcx, source_expr.span, source_ty);\n-    debug!(\"source_ty={}\", source_ty.repr(fcx.tcx()));\n-    match (&source_ty.sty, &target_object_ty.sty) {\n-        (&ty::ty_uniq(referent_ty), &ty::ty_uniq(object_trait_ty)) => {\n-            let object_trait = object_trait(&object_trait_ty);\n-\n-            // Ensure that if ~T is cast to ~Trait, then T : Trait\n-            push_cast_obligation(fcx, cast_expr, object_trait, referent_ty);\n-            check_object_safety(fcx.tcx(), object_trait, source_expr.span);\n-        }\n-\n-        (&ty::ty_rptr(referent_region, ty::mt { ty: referent_ty,\n-                                                mutbl: referent_mutbl }),\n-         &ty::ty_rptr(target_region, ty::mt { ty: object_trait_ty,\n-                                              mutbl: target_mutbl })) =>\n-        {\n-            let object_trait = object_trait(&object_trait_ty);\n-            if !mutability_allowed(referent_mutbl, target_mutbl) {\n-                span_err!(fcx.tcx().sess, source_expr.span, E0188,\n-                                        \"types differ in mutability\");\n-            } else {\n-                // Ensure that if &'a T is cast to &'b Trait, then T : Trait\n-                push_cast_obligation(fcx, cast_expr,\n-                                     object_trait,\n-                                     referent_ty);\n-\n-                // Ensure that if &'a T is cast to &'b Trait, then 'b <= 'a\n-                infer::mk_subr(fcx.infcx(),\n-                               infer::RelateObjectBound(source_expr.span),\n-                               *target_region,\n-                               *referent_region);\n-\n-                check_object_safety(fcx.tcx(), object_trait, source_expr.span);\n-            }\n-        }\n \n-        (_, &ty::ty_uniq(..)) => {\n-            span_err!(fcx.ccx.tcx.sess, source_expr.span, E0189,\n-                \"can only cast a boxed pointer \\\n-                         to a boxed object, not a {}\",\n-                      ty::ty_sort_string(fcx.tcx(), source_ty));\n+    // First, construct a fresh type that we can feed into `<expr>`\n+    // within `<expr> as <type>` to inform type inference (e.g. to\n+    // tell it that we are expecting a `Box<_>` or an `&_`).\n+    let fresh_ty = fcx.infcx().next_ty_var();\n+    let (object_trait_ty, source_expected_ty) = match target_object_ty.sty {\n+        ty::ty_uniq(object_trait_ty) => {\n+            (object_trait_ty, ty::mk_uniq(fcx.tcx(), fresh_ty))\n         }\n-\n-        (_, &ty::ty_rptr(..)) => {\n-            span_err!(fcx.ccx.tcx.sess, source_expr.span, E0190,\n-                \"can only cast a &-pointer \\\n-                         to an &-object, not a {}\",\n-                        ty::ty_sort_string(fcx.tcx(), source_ty));\n+        ty::ty_rptr(target_region, ty::mt { ty: object_trait_ty,\n+                                            mutbl: target_mutbl }) => {\n+            (object_trait_ty,\n+             ty::mk_rptr(fcx.tcx(),\n+                         target_region, ty::mt { ty: fresh_ty,\n+                                                 mutbl: target_mutbl }))\n         }\n-\n         _ => {\n-            fcx.tcx().sess.span_bug(\n-                source_expr.span,\n-                \"expected object type\");\n+            fcx.tcx().sess.span_bug(source_expr.span, \"expected object type\");\n         }\n-    }\n+    };\n+\n+    let source_ty = fcx.expr_ty(source_expr);\n+    debug!(\"check_object_cast pre unify source_ty={}\", source_ty.repr(tcx));\n+\n+    // This ensures that the source_ty <: source_expected_ty, which\n+    // will ensure e.g. that &'a T <: &'b T when doing `&'a T as &'b Trait`\n+    //\n+    // FIXME (pnkfelix): do we need to use suptype_with_fn in order to\n+    // override the error message emitted when the types do not work\n+    // out in the manner desired?\n+    demand::suptype(fcx, source_expr.span, source_expected_ty, source_ty);\n+\n+    debug!(\"check_object_cast postunify source_ty={}\", source_ty.repr(tcx));\n+    let source_ty = structurally_resolved_type(fcx, source_expr.span, source_ty);\n+    debug!(\"check_object_cast resolveto source_ty={}\", source_ty.repr(tcx));\n+\n+    let object_trait = object_trait(&object_trait_ty);\n+\n+    let referent_ty = match source_ty.sty {\n+        ty::ty_uniq(ty) => ty,\n+        ty::ty_rptr(_, ty::mt { ty, mutbl: _ }) => ty,\n+        _ => fcx.tcx().sess.span_bug(source_expr.span,\n+                                     \"expected appropriate reference type\"),\n+    };\n+\n+    // Ensure that if Ptr<T> is cast to Ptr<Trait>, then T : Trait.\n+    push_cast_obligation(fcx, cast_expr, object_trait, referent_ty);\n+    check_object_safety(tcx, object_trait, source_expr.span);\n \n     fn object_trait<'a, 'tcx>(t: &'a Ty<'tcx>) -> &'a ty::TyTrait<'tcx> {\n         match t.sty {\n@@ -97,13 +89,6 @@ pub fn check_object_cast<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         }\n     }\n \n-    fn mutability_allowed(a_mutbl: ast::Mutability,\n-                          b_mutbl: ast::Mutability)\n-                          -> bool {\n-        a_mutbl == b_mutbl ||\n-            (a_mutbl == ast::MutMutable && b_mutbl == ast::MutImmutable)\n-    }\n-\n     fn push_cast_obligation<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                       cast_expr: &ast::Expr,\n                                       object_trait: &ty::TyTrait<'tcx>,"}]}