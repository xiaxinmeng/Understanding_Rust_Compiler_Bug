{"sha": "f89817997ac0aa100bf91997194ad85a7e59f743", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY4OTgxNzk5N2FjMGFhMTAwYmY5MTk5NzE5NGFkODVhN2U1OWY3NDM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-07-31T13:32:32Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-07-31T13:32:32Z"}, "message": "Auto merge of #52461 - irinagpopa:safe-llvm, r=nikomatsakis\n\n rustc_codegen_llvm: use safe references for LLVM FFI types.\n\nPart of #45274.", "tree": {"sha": "53fdd03057783bec2884b091f5d02bce10313894", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/53fdd03057783bec2884b091f5d02bce10313894"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f89817997ac0aa100bf91997194ad85a7e59f743", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f89817997ac0aa100bf91997194ad85a7e59f743", "html_url": "https://github.com/rust-lang/rust/commit/f89817997ac0aa100bf91997194ad85a7e59f743", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f89817997ac0aa100bf91997194ad85a7e59f743/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ed8d14db99fc79909274454c02073bc5bd0c0df2", "url": "https://api.github.com/repos/rust-lang/rust/commits/ed8d14db99fc79909274454c02073bc5bd0c0df2", "html_url": "https://github.com/rust-lang/rust/commit/ed8d14db99fc79909274454c02073bc5bd0c0df2"}, {"sha": "baff67d51f691734ecee0faa83acee91ec16cc5d", "url": "https://api.github.com/repos/rust-lang/rust/commits/baff67d51f691734ecee0faa83acee91ec16cc5d", "html_url": "https://github.com/rust-lang/rust/commit/baff67d51f691734ecee0faa83acee91ec16cc5d"}], "stats": {"total": 8303, "additions": 3982, "deletions": 4321}, "files": [{"sha": "be32872dad80a23f769d1bcc96e05b0de3d94f43", "filename": "src/Cargo.lock", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f89817997ac0aa100bf91997194ad85a7e59f743/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/f89817997ac0aa100bf91997194ad85a7e59f743/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=f89817997ac0aa100bf91997194ad85a7e59f743", "patch": "@@ -2222,11 +2222,8 @@ dependencies = [\n name = \"rustc_llvm\"\n version = \"0.0.0\"\n dependencies = [\n- \"bitflags 1.0.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"build_helper 0.1.0\",\n  \"cc 1.0.18 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.42 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc_cratesio_shim 0.0.0\",\n ]\n \n [[package]]"}, {"sha": "44982eee86b3cec02e2e4163b950233c8d8892fa", "filename": "src/librustc_codegen_llvm/abi.rs", "status": "modified", "additions": 39, "deletions": 38, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/f89817997ac0aa100bf91997194ad85a7e59f743/src%2Flibrustc_codegen_llvm%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f89817997ac0aa100bf91997194ad85a7e59f743/src%2Flibrustc_codegen_llvm%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fabi.rs?ref=f89817997ac0aa100bf91997194ad85a7e59f743", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use llvm::{self, ValueRef, AttributePlace};\n+use llvm::{self, AttributePlace};\n use base;\n use builder::{Builder, MemFlags};\n use common::{ty_fn_sig, C_usize};\n@@ -17,6 +17,7 @@ use mir::place::PlaceRef;\n use mir::operand::OperandValue;\n use type_::Type;\n use type_of::{LayoutLlvmExt, PointerKind};\n+use value::Value;\n \n use rustc_target::abi::{LayoutOf, Size, TyLayout};\n use rustc::ty::{self, Ty};\n@@ -46,12 +47,12 @@ impl ArgAttributeExt for ArgAttribute {\n }\n \n pub trait ArgAttributesExt {\n-    fn apply_llfn(&self, idx: AttributePlace, llfn: ValueRef);\n-    fn apply_callsite(&self, idx: AttributePlace, callsite: ValueRef);\n+    fn apply_llfn(&self, idx: AttributePlace, llfn: &Value);\n+    fn apply_callsite(&self, idx: AttributePlace, callsite: &Value);\n }\n \n impl ArgAttributesExt for ArgAttributes {\n-    fn apply_llfn(&self, idx: AttributePlace, llfn: ValueRef) {\n+    fn apply_llfn(&self, idx: AttributePlace, llfn: &Value) {\n         let mut regular = self.regular;\n         unsafe {\n             let deref = self.pointee_size.bytes();\n@@ -76,7 +77,7 @@ impl ArgAttributesExt for ArgAttributes {\n         }\n     }\n \n-    fn apply_callsite(&self, idx: AttributePlace, callsite: ValueRef) {\n+    fn apply_callsite(&self, idx: AttributePlace, callsite: &Value) {\n         let mut regular = self.regular;\n         unsafe {\n             let deref = self.pointee_size.bytes();\n@@ -103,11 +104,11 @@ impl ArgAttributesExt for ArgAttributes {\n }\n \n pub trait LlvmType {\n-    fn llvm_type(&self, cx: &CodegenCx) -> Type;\n+    fn llvm_type(&self, cx: &CodegenCx<'ll, '_>) -> &'ll Type;\n }\n \n impl LlvmType for Reg {\n-    fn llvm_type(&self, cx: &CodegenCx) -> Type {\n+    fn llvm_type(&self, cx: &CodegenCx<'ll, '_>) -> &'ll Type {\n         match self.kind {\n             RegKind::Integer => Type::ix(cx, self.size.bits()),\n             RegKind::Float => {\n@@ -118,14 +119,14 @@ impl LlvmType for Reg {\n                 }\n             }\n             RegKind::Vector => {\n-                Type::vector(&Type::i8(cx), self.size.bytes())\n+                Type::vector(Type::i8(cx), self.size.bytes())\n             }\n         }\n     }\n }\n \n impl LlvmType for CastTarget {\n-    fn llvm_type(&self, cx: &CodegenCx) -> Type {\n+    fn llvm_type(&self, cx: &CodegenCx<'ll, '_>) -> &'ll Type {\n         let rest_ll_unit = self.rest.unit.llvm_type(cx);\n         let (rest_count, rem_bytes) = if self.rest.unit.size.bytes() == 0 {\n             (0, 0)\n@@ -142,7 +143,7 @@ impl LlvmType for CastTarget {\n \n             // Simplify to array when all chunks are the same size and type\n             if rem_bytes == 0 {\n-                return Type::array(&rest_ll_unit, rest_count);\n+                return Type::array(rest_ll_unit, rest_count);\n             }\n         }\n \n@@ -164,24 +165,24 @@ impl LlvmType for CastTarget {\n     }\n }\n \n-pub trait ArgTypeExt<'a, 'tcx> {\n-    fn memory_ty(&self, cx: &CodegenCx<'a, 'tcx>) -> Type;\n-    fn store(&self, bx: &Builder<'a, 'tcx>, val: ValueRef, dst: PlaceRef<'tcx>);\n-    fn store_fn_arg(&self, bx: &Builder<'a, 'tcx>, idx: &mut usize, dst: PlaceRef<'tcx>);\n+pub trait ArgTypeExt<'ll, 'tcx> {\n+    fn memory_ty(&self, cx: &CodegenCx<'ll, 'tcx>) -> &'ll Type;\n+    fn store(&self, bx: &Builder<'_, 'll, 'tcx>, val: &'ll Value, dst: PlaceRef<'ll, 'tcx>);\n+    fn store_fn_arg(&self, bx: &Builder<'_, 'll, 'tcx>, idx: &mut usize, dst: PlaceRef<'ll, 'tcx>);\n }\n \n-impl<'a, 'tcx> ArgTypeExt<'a, 'tcx> for ArgType<'tcx, Ty<'tcx>> {\n+impl ArgTypeExt<'ll, 'tcx> for ArgType<'tcx, Ty<'tcx>> {\n     /// Get the LLVM type for a place of the original Rust type of\n     /// this argument/return, i.e. the result of `type_of::type_of`.\n-    fn memory_ty(&self, cx: &CodegenCx<'a, 'tcx>) -> Type {\n+    fn memory_ty(&self, cx: &CodegenCx<'ll, 'tcx>) -> &'ll Type {\n         self.layout.llvm_type(cx)\n     }\n \n     /// Store a direct/indirect value described by this ArgType into a\n     /// place for the original Rust type of this argument/return.\n     /// Can be used for both storing formal arguments into Rust variables\n     /// or results of call/invoke instructions into their destinations.\n-    fn store(&self, bx: &Builder<'a, 'tcx>, val: ValueRef, dst: PlaceRef<'tcx>) {\n+    fn store(&self, bx: &Builder<'_, 'll, 'tcx>, val: &'ll Value, dst: PlaceRef<'ll, 'tcx>) {\n         if self.is_ignore() {\n             return;\n         }\n@@ -234,7 +235,7 @@ impl<'a, 'tcx> ArgTypeExt<'a, 'tcx> for ArgType<'tcx, Ty<'tcx>> {\n         }\n     }\n \n-    fn store_fn_arg(&self, bx: &Builder<'a, 'tcx>, idx: &mut usize, dst: PlaceRef<'tcx>) {\n+    fn store_fn_arg(&self, bx: &Builder<'a, 'll, 'tcx>, idx: &mut usize, dst: PlaceRef<'ll, 'tcx>) {\n         let mut next = || {\n             let val = llvm::get_param(bx.llfn(), *idx as c_uint);\n             *idx += 1;\n@@ -252,48 +253,48 @@ impl<'a, 'tcx> ArgTypeExt<'a, 'tcx> for ArgType<'tcx, Ty<'tcx>> {\n     }\n }\n \n-pub trait FnTypeExt<'a, 'tcx> {\n-    fn of_instance(cx: &CodegenCx<'a, 'tcx>, instance: &ty::Instance<'tcx>)\n+pub trait FnTypeExt<'tcx> {\n+    fn of_instance(cx: &CodegenCx<'ll, 'tcx>, instance: &ty::Instance<'tcx>)\n                    -> Self;\n-    fn new(cx: &CodegenCx<'a, 'tcx>,\n+    fn new(cx: &CodegenCx<'ll, 'tcx>,\n            sig: ty::FnSig<'tcx>,\n            extra_args: &[Ty<'tcx>]) -> Self;\n-    fn new_vtable(cx: &CodegenCx<'a, 'tcx>,\n+    fn new_vtable(cx: &CodegenCx<'ll, 'tcx>,\n                   sig: ty::FnSig<'tcx>,\n                   extra_args: &[Ty<'tcx>]) -> Self;\n     fn new_internal(\n-        cx: &CodegenCx<'a, 'tcx>,\n+        cx: &CodegenCx<'ll, 'tcx>,\n         sig: ty::FnSig<'tcx>,\n         extra_args: &[Ty<'tcx>],\n         mk_arg_type: impl Fn(Ty<'tcx>, Option<usize>) -> ArgType<'tcx, Ty<'tcx>>,\n     ) -> Self;\n     fn adjust_for_abi(&mut self,\n-                      cx: &CodegenCx<'a, 'tcx>,\n+                      cx: &CodegenCx<'ll, 'tcx>,\n                       abi: Abi);\n-    fn llvm_type(&self, cx: &CodegenCx<'a, 'tcx>) -> Type;\n+    fn llvm_type(&self, cx: &CodegenCx<'ll, 'tcx>) -> &'ll Type;\n     fn llvm_cconv(&self) -> llvm::CallConv;\n-    fn apply_attrs_llfn(&self, llfn: ValueRef);\n-    fn apply_attrs_callsite(&self, bx: &Builder<'a, 'tcx>, callsite: ValueRef);\n+    fn apply_attrs_llfn(&self, llfn: &'ll Value);\n+    fn apply_attrs_callsite(&self, bx: &Builder<'a, 'll, 'tcx>, callsite: &'ll Value);\n }\n \n-impl<'a, 'tcx> FnTypeExt<'a, 'tcx> for FnType<'tcx, Ty<'tcx>> {\n-    fn of_instance(cx: &CodegenCx<'a, 'tcx>, instance: &ty::Instance<'tcx>)\n+impl<'tcx> FnTypeExt<'tcx> for FnType<'tcx, Ty<'tcx>> {\n+    fn of_instance(cx: &CodegenCx<'ll, 'tcx>, instance: &ty::Instance<'tcx>)\n                        -> Self {\n         let fn_ty = instance.ty(cx.tcx);\n         let sig = ty_fn_sig(cx, fn_ty);\n         let sig = cx.tcx.normalize_erasing_late_bound_regions(ty::ParamEnv::reveal_all(), &sig);\n         FnType::new(cx, sig, &[])\n     }\n \n-    fn new(cx: &CodegenCx<'a, 'tcx>,\n+    fn new(cx: &CodegenCx<'ll, 'tcx>,\n                sig: ty::FnSig<'tcx>,\n                extra_args: &[Ty<'tcx>]) -> Self {\n         FnType::new_internal(cx, sig, extra_args, |ty, _| {\n             ArgType::new(cx.layout_of(ty))\n         })\n     }\n \n-    fn new_vtable(cx: &CodegenCx<'a, 'tcx>,\n+    fn new_vtable(cx: &CodegenCx<'ll, 'tcx>,\n                       sig: ty::FnSig<'tcx>,\n                       extra_args: &[Ty<'tcx>]) -> Self {\n         FnType::new_internal(cx, sig, extra_args, |ty, arg_idx| {\n@@ -316,7 +317,7 @@ impl<'a, 'tcx> FnTypeExt<'a, 'tcx> for FnType<'tcx, Ty<'tcx>> {\n     }\n \n     fn new_internal(\n-        cx: &CodegenCx<'a, 'tcx>,\n+        cx: &CodegenCx<'ll, 'tcx>,\n         sig: ty::FnSig<'tcx>,\n         extra_args: &[Ty<'tcx>],\n         mk_arg_type: impl Fn(Ty<'tcx>, Option<usize>) -> ArgType<'tcx, Ty<'tcx>>,\n@@ -497,7 +498,7 @@ impl<'a, 'tcx> FnTypeExt<'a, 'tcx> for FnType<'tcx, Ty<'tcx>> {\n     }\n \n     fn adjust_for_abi(&mut self,\n-                      cx: &CodegenCx<'a, 'tcx>,\n+                      cx: &CodegenCx<'ll, 'tcx>,\n                       abi: Abi) {\n         if abi == Abi::Unadjusted { return }\n \n@@ -564,7 +565,7 @@ impl<'a, 'tcx> FnTypeExt<'a, 'tcx> for FnType<'tcx, Ty<'tcx>> {\n         }\n     }\n \n-    fn llvm_type(&self, cx: &CodegenCx<'a, 'tcx>) -> Type {\n+    fn llvm_type(&self, cx: &CodegenCx<'ll, 'tcx>) -> &'ll Type {\n         let args_capacity: usize = self.args.iter().map(|arg|\n             if arg.pad.is_some() { 1 } else { 0 } +\n             if let PassMode::Pair(_, _) = arg.mode { 2 } else { 1 }\n@@ -606,9 +607,9 @@ impl<'a, 'tcx> FnTypeExt<'a, 'tcx> for FnType<'tcx, Ty<'tcx>> {\n         }\n \n         if self.variadic {\n-            Type::variadic_func(&llargument_tys, &llreturn_ty)\n+            Type::variadic_func(&llargument_tys, llreturn_ty)\n         } else {\n-            Type::func(&llargument_tys, &llreturn_ty)\n+            Type::func(&llargument_tys, llreturn_ty)\n         }\n     }\n \n@@ -629,7 +630,7 @@ impl<'a, 'tcx> FnTypeExt<'a, 'tcx> for FnType<'tcx, Ty<'tcx>> {\n         }\n     }\n \n-    fn apply_attrs_llfn(&self, llfn: ValueRef) {\n+    fn apply_attrs_llfn(&self, llfn: &'ll Value) {\n         let mut i = 0;\n         let mut apply = |attrs: &ArgAttributes| {\n             attrs.apply_llfn(llvm::AttributePlace::Argument(i), llfn);\n@@ -659,7 +660,7 @@ impl<'a, 'tcx> FnTypeExt<'a, 'tcx> for FnType<'tcx, Ty<'tcx>> {\n         }\n     }\n \n-    fn apply_attrs_callsite(&self, bx: &Builder<'a, 'tcx>, callsite: ValueRef) {\n+    fn apply_attrs_callsite(&self, bx: &Builder<'a, 'll, 'tcx>, callsite: &'ll Value) {\n         let mut i = 0;\n         let mut apply = |attrs: &ArgAttributes| {\n             attrs.apply_callsite(llvm::AttributePlace::Argument(i), callsite);"}, {"sha": "2d401da958b13fa6465af1612a64b95774198862", "filename": "src/librustc_codegen_llvm/allocator.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f89817997ac0aa100bf91997194ad85a7e59f743/src%2Flibrustc_codegen_llvm%2Fallocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f89817997ac0aa100bf91997194ad85a7e59f743/src%2Flibrustc_codegen_llvm%2Fallocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fallocator.rs?ref=f89817997ac0aa100bf91997194ad85a7e59f743", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n use std::ffi::CString;\n-use std::ptr;\n \n use attributes;\n use libc::c_uint;\n@@ -21,8 +20,8 @@ use ModuleLlvm;\n use llvm::{self, False, True};\n \n pub(crate) unsafe fn codegen(tcx: TyCtxt, mods: &ModuleLlvm, kind: AllocatorKind) {\n-    let llcx = mods.llcx;\n-    let llmod = mods.llmod;\n+    let llcx = &*mods.llcx;\n+    let llmod = mods.llmod();\n     let usize = match &tcx.sess.target.target.target_pointer_width[..] {\n         \"16\" => llvm::LLVMInt16TypeInContext(llcx),\n         \"32\" => llvm::LLVMInt32TypeInContext(llcx),\n@@ -90,7 +89,7 @@ pub(crate) unsafe fn codegen(tcx: TyCtxt, mods: &ModuleLlvm, kind: AllocatorKind\n                                           callee,\n                                           args.as_ptr(),\n                                           args.len() as c_uint,\n-                                          ptr::null_mut(),\n+                                          None,\n                                           \"\\0\".as_ptr() as *const _);\n         llvm::LLVMSetTailCall(ret, True);\n         if output.is_some() {"}, {"sha": "5d27f8eab3ecea095fc275fca1cb473ede236181", "filename": "src/librustc_codegen_llvm/asm.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f89817997ac0aa100bf91997194ad85a7e59f743/src%2Flibrustc_codegen_llvm%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f89817997ac0aa100bf91997194ad85a7e59f743/src%2Flibrustc_codegen_llvm%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fasm.rs?ref=f89817997ac0aa100bf91997194ad85a7e59f743", "patch": "@@ -8,11 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use llvm::{self, ValueRef};\n+use llvm;\n use common::*;\n use type_::Type;\n use type_of::LayoutLlvmExt;\n use builder::Builder;\n+use value::Value;\n \n use rustc::hir;\n \n@@ -24,11 +25,11 @@ use syntax::ast::AsmDialect;\n use libc::{c_uint, c_char};\n \n // Take an inline assembly expression and splat it out via LLVM\n-pub fn codegen_inline_asm<'a, 'tcx>(\n-    bx: &Builder<'a, 'tcx>,\n+pub fn codegen_inline_asm(\n+    bx: &Builder<'a, 'll, 'tcx>,\n     ia: &hir::InlineAsm,\n-    outputs: Vec<PlaceRef<'tcx>>,\n-    mut inputs: Vec<ValueRef>\n+    outputs: Vec<PlaceRef<'ll, 'tcx>>,\n+    mut inputs: Vec<&'ll Value>\n ) {\n     let mut ext_constraints = vec![];\n     let mut output_types = vec![];\n@@ -111,7 +112,7 @@ pub fn codegen_inline_asm<'a, 'tcx>(\n         let kind = llvm::LLVMGetMDKindIDInContext(bx.cx.llcx,\n             key.as_ptr() as *const c_char, key.len() as c_uint);\n \n-        let val: llvm::ValueRef = C_i32(bx.cx, ia.ctxt.outer().as_u32() as i32);\n+        let val: &'ll Value = C_i32(bx.cx, ia.ctxt.outer().as_u32() as i32);\n \n         llvm::LLVMSetMetadata(r, kind,\n             llvm::LLVMMDNodeInContext(bx.cx.llcx, &val, 1));"}, {"sha": "c52f894410899bf26578f0a214fcfb48a08e32f6", "filename": "src/librustc_codegen_llvm/attributes.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f89817997ac0aa100bf91997194ad85a7e59f743/src%2Flibrustc_codegen_llvm%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f89817997ac0aa100bf91997194ad85a7e59f743/src%2Flibrustc_codegen_llvm%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fattributes.rs?ref=f89817997ac0aa100bf91997194ad85a7e59f743", "patch": "@@ -22,15 +22,17 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_target::spec::PanicStrategy;\n \n use attributes;\n-use llvm::{self, Attribute, ValueRef};\n+use llvm::{self, Attribute};\n use llvm::AttributePlace::Function;\n use llvm_util;\n pub use syntax::attr::{self, InlineAttr};\n+\n use context::CodegenCx;\n+use value::Value;\n \n /// Mark LLVM function to use provided inline heuristic.\n #[inline]\n-pub fn inline(val: ValueRef, inline: InlineAttr) {\n+pub fn inline(val: &'ll Value, inline: InlineAttr) {\n     use self::InlineAttr::*;\n     match inline {\n         Hint   => Attribute::InlineHint.apply_llfn(Function, val),\n@@ -46,38 +48,38 @@ pub fn inline(val: ValueRef, inline: InlineAttr) {\n \n /// Tell LLVM to emit or not emit the information necessary to unwind the stack for the function.\n #[inline]\n-pub fn emit_uwtable(val: ValueRef, emit: bool) {\n+pub fn emit_uwtable(val: &'ll Value, emit: bool) {\n     Attribute::UWTable.toggle_llfn(Function, val, emit);\n }\n \n /// Tell LLVM whether the function can or cannot unwind.\n #[inline]\n-pub fn unwind(val: ValueRef, can_unwind: bool) {\n+pub fn unwind(val: &'ll Value, can_unwind: bool) {\n     Attribute::NoUnwind.toggle_llfn(Function, val, !can_unwind);\n }\n \n /// Tell LLVM whether it should optimize function for size.\n #[inline]\n #[allow(dead_code)] // possibly useful function\n-pub fn set_optimize_for_size(val: ValueRef, optimize: bool) {\n+pub fn set_optimize_for_size(val: &'ll Value, optimize: bool) {\n     Attribute::OptimizeForSize.toggle_llfn(Function, val, optimize);\n }\n \n /// Tell LLVM if this function should be 'naked', i.e. skip the epilogue and prologue.\n #[inline]\n-pub fn naked(val: ValueRef, is_naked: bool) {\n+pub fn naked(val: &'ll Value, is_naked: bool) {\n     Attribute::Naked.toggle_llfn(Function, val, is_naked);\n }\n \n-pub fn set_frame_pointer_elimination(cx: &CodegenCx, llfn: ValueRef) {\n+pub fn set_frame_pointer_elimination(cx: &CodegenCx<'ll, '_>, llfn: &'ll Value) {\n     if cx.sess().must_not_eliminate_frame_pointers() {\n         llvm::AddFunctionAttrStringValue(\n             llfn, llvm::AttributePlace::Function,\n             cstr(\"no-frame-pointer-elim\\0\"), cstr(\"true\\0\"));\n     }\n }\n \n-pub fn set_probestack(cx: &CodegenCx, llfn: ValueRef) {\n+pub fn set_probestack(cx: &CodegenCx<'ll, '_>, llfn: &'ll Value) {\n     // Only use stack probes if the target specification indicates that we\n     // should be using stack probes\n     if !cx.sess().target.target.options.stack_probes {\n@@ -123,7 +125,7 @@ pub fn llvm_target_features(sess: &Session) -> impl Iterator<Item = &str> {\n \n /// Composite function which sets LLVM attributes for function depending on its AST (#[attribute])\n /// attributes.\n-pub fn from_fn_attrs(cx: &CodegenCx, llfn: ValueRef, id: DefId) {\n+pub fn from_fn_attrs(cx: &CodegenCx<'ll, '_>, llfn: &'ll Value, id: DefId) {\n     let codegen_fn_attrs = cx.tcx.codegen_fn_attrs(id);\n \n     inline(llfn, codegen_fn_attrs.inline);"}, {"sha": "af9efc6d7c4173f905254795be1d431a9255258e", "filename": "src/librustc_codegen_llvm/back/archive.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/f89817997ac0aa100bf91997194ad85a7e59f743/src%2Flibrustc_codegen_llvm%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f89817997ac0aa100bf91997194ad85a7e59f743/src%2Flibrustc_codegen_llvm%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Farchive.rs?ref=f89817997ac0aa100bf91997194ad85a7e59f743", "patch": "@@ -226,10 +226,13 @@ impl<'a> ArchiveBuilder<'a> {\n     }\n \n     fn build_with_llvm(&mut self, kind: ArchiveKind) -> io::Result<()> {\n-        let mut archives = Vec::new();\n+        let removals = mem::replace(&mut self.removals, Vec::new());\n+        let mut additions = mem::replace(&mut self.additions, Vec::new());\n         let mut strings = Vec::new();\n         let mut members = Vec::new();\n-        let removals = mem::replace(&mut self.removals, Vec::new());\n+\n+        let dst = CString::new(self.config.dst.to_str().unwrap())?;\n+        let should_update_symbols = self.should_update_symbols;\n \n         unsafe {\n             if let Some(archive) = self.src_archive() {\n@@ -246,22 +249,22 @@ impl<'a> ArchiveBuilder<'a> {\n                     let name = CString::new(child_name)?;\n                     members.push(llvm::LLVMRustArchiveMemberNew(ptr::null(),\n                                                                 name.as_ptr(),\n-                                                                child.raw()));\n+                                                                Some(child.raw)));\n                     strings.push(name);\n                 }\n             }\n-            for addition in mem::replace(&mut self.additions, Vec::new()) {\n+            for addition in &mut additions {\n                 match addition {\n                     Addition::File { path, name_in_archive } => {\n                         let path = CString::new(path.to_str().unwrap())?;\n-                        let name = CString::new(name_in_archive)?;\n+                        let name = CString::new(name_in_archive.clone())?;\n                         members.push(llvm::LLVMRustArchiveMemberNew(path.as_ptr(),\n                                                                     name.as_ptr(),\n-                                                                    ptr::null_mut()));\n+                                                                    None));\n                         strings.push(path);\n                         strings.push(name);\n                     }\n-                    Addition::Archive { archive, mut skip } => {\n+                    Addition::Archive { archive, skip } => {\n                         for child in archive.iter() {\n                             let child = child.map_err(string_to_io_error)?;\n                             if !is_relevant_child(&child) {\n@@ -284,21 +287,18 @@ impl<'a> ArchiveBuilder<'a> {\n                             let name = CString::new(child_name)?;\n                             let m = llvm::LLVMRustArchiveMemberNew(ptr::null(),\n                                                                    name.as_ptr(),\n-                                                                   child.raw());\n+                                                                   Some(child.raw));\n                             members.push(m);\n                             strings.push(name);\n                         }\n-                        archives.push(archive);\n                     }\n                 }\n             }\n \n-            let dst = self.config.dst.to_str().unwrap().as_bytes();\n-            let dst = CString::new(dst)?;\n             let r = llvm::LLVMRustWriteArchive(dst.as_ptr(),\n                                                members.len() as libc::size_t,\n-                                               members.as_ptr(),\n-                                               self.should_update_symbols,\n+                                               members.as_ptr() as *const &_,\n+                                               should_update_symbols,\n                                                kind);\n             let ret = if r.into_result().is_err() {\n                 let err = llvm::LLVMRustGetLastError();"}, {"sha": "daa2fb05280649793a50ac3831c7352cd8b1f5df", "filename": "src/librustc_codegen_llvm/back/lto.rs", "status": "modified", "additions": 183, "deletions": 180, "changes": 363, "blob_url": "https://github.com/rust-lang/rust/blob/f89817997ac0aa100bf91997194ad85a7e59f743/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f89817997ac0aa100bf91997194ad85a7e59f743/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs?ref=f89817997ac0aa100bf91997194ad85a7e59f743", "patch": "@@ -14,7 +14,7 @@ use back::write::{ModuleConfig, with_llvm_pmb, CodegenContext};\n use back::write;\n use errors::{FatalError, Handler};\n use llvm::archive_ro::ArchiveRO;\n-use llvm::{ModuleRef, TargetMachineRef, True, False};\n+use llvm::{True, False};\n use llvm;\n use rustc::hir::def_id::LOCAL_CRATE;\n use rustc::middle::exported_symbols::SymbolExportLevel;\n@@ -73,11 +73,13 @@ impl LtoModuleCodegen {\n         match *self {\n             LtoModuleCodegen::Fat { ref mut module, .. } => {\n                 let module = module.take().unwrap();\n-                let config = cgcx.config(module.kind);\n-                let llmod = module.llvm().unwrap().llmod;\n-                let tm = module.llvm().unwrap().tm;\n-                run_pass_manager(cgcx, tm, llmod, config, false);\n-                timeline.record(\"fat-done\");\n+                {\n+                    let config = cgcx.config(module.kind);\n+                    let llmod = module.llvm().unwrap().llmod();\n+                    let tm = &*module.llvm().unwrap().tm;\n+                    run_pass_manager(cgcx, tm, llmod, config, false);\n+                    timeline.record(\"fat-done\");\n+                }\n                 Ok(module)\n             }\n             LtoModuleCodegen::Thin(ref mut thin) => thin.optimize(cgcx, timeline),\n@@ -223,77 +225,79 @@ fn fat_lto(cgcx: &CodegenContext,\n         .filter(|&(_, module)| module.kind == ModuleKind::Regular)\n         .map(|(i, module)| {\n             let cost = unsafe {\n-                llvm::LLVMRustModuleCost(module.llvm().unwrap().llmod)\n+                llvm::LLVMRustModuleCost(module.llvm().unwrap().llmod())\n             };\n             (cost, i)\n         })\n         .max()\n         .expect(\"must be codegen'ing at least one module\");\n     let module = modules.remove(costliest_module);\n-    let llmod = module.llvm().expect(\"can't lto pre-codegened modules\").llmod;\n-    info!(\"using {:?} as a base module\", module.llmod_id);\n-\n-    // For all other modules we codegened we'll need to link them into our own\n-    // bitcode. All modules were codegened in their own LLVM context, however,\n-    // and we want to move everything to the same LLVM context. Currently the\n-    // way we know of to do that is to serialize them to a string and them parse\n-    // them later. Not great but hey, that's why it's \"fat\" LTO, right?\n-    for module in modules {\n-        let llvm = module.llvm().expect(\"can't lto pre-codegened modules\");\n-        let buffer = ModuleBuffer::new(llvm.llmod);\n-        let llmod_id = CString::new(&module.llmod_id[..]).unwrap();\n-        serialized_modules.push((SerializedModule::Local(buffer), llmod_id));\n-    }\n-\n-    // For all serialized bitcode files we parse them and link them in as we did\n-    // above, this is all mostly handled in C++. Like above, though, we don't\n-    // know much about the memory management here so we err on the side of being\n-    // save and persist everything with the original module.\n     let mut serialized_bitcode = Vec::new();\n-    let mut linker = Linker::new(llmod);\n-    for (bc_decoded, name) in serialized_modules {\n-        info!(\"linking {:?}\", name);\n-        time_ext(cgcx.time_passes, None, &format!(\"ll link {:?}\", name), || {\n-            let data = bc_decoded.data();\n-            linker.add(&data).map_err(|()| {\n-                let msg = format!(\"failed to load bc of {:?}\", name);\n-                write::llvm_err(&diag_handler, msg)\n-            })\n-        })?;\n-        timeline.record(&format!(\"link {:?}\", name));\n-        serialized_bitcode.push(bc_decoded);\n-    }\n-    drop(linker);\n-    cgcx.save_temp_bitcode(&module, \"lto.input\");\n+    {\n+        let llmod = module.llvm().expect(\"can't lto pre-codegened modules\").llmod();\n+        info!(\"using {:?} as a base module\", module.llmod_id);\n+\n+        // For all other modules we codegened we'll need to link them into our own\n+        // bitcode. All modules were codegened in their own LLVM context, however,\n+        // and we want to move everything to the same LLVM context. Currently the\n+        // way we know of to do that is to serialize them to a string and them parse\n+        // them later. Not great but hey, that's why it's \"fat\" LTO, right?\n+        for module in modules {\n+            let llvm = module.llvm().expect(\"can't lto pre-codegened modules\");\n+            let buffer = ModuleBuffer::new(llvm.llmod());\n+            let llmod_id = CString::new(&module.llmod_id[..]).unwrap();\n+            serialized_modules.push((SerializedModule::Local(buffer), llmod_id));\n+        }\n \n-    // Internalize everything that *isn't* in our whitelist to help strip out\n-    // more modules and such\n-    unsafe {\n-        let ptr = symbol_white_list.as_ptr();\n-        llvm::LLVMRustRunRestrictionPass(llmod,\n-                                         ptr as *const *const libc::c_char,\n-                                         symbol_white_list.len() as libc::size_t);\n-        cgcx.save_temp_bitcode(&module, \"lto.after-restriction\");\n-    }\n+        // For all serialized bitcode files we parse them and link them in as we did\n+        // above, this is all mostly handled in C++. Like above, though, we don't\n+        // know much about the memory management here so we err on the side of being\n+        // save and persist everything with the original module.\n+        let mut linker = Linker::new(llmod);\n+        for (bc_decoded, name) in serialized_modules {\n+            info!(\"linking {:?}\", name);\n+            time_ext(cgcx.time_passes, None, &format!(\"ll link {:?}\", name), || {\n+                let data = bc_decoded.data();\n+                linker.add(&data).map_err(|()| {\n+                    let msg = format!(\"failed to load bc of {:?}\", name);\n+                    write::llvm_err(&diag_handler, msg)\n+                })\n+            })?;\n+            timeline.record(&format!(\"link {:?}\", name));\n+            serialized_bitcode.push(bc_decoded);\n+        }\n+        drop(linker);\n+        cgcx.save_temp_bitcode(&module, \"lto.input\");\n \n-    if cgcx.no_landing_pads {\n+        // Internalize everything that *isn't* in our whitelist to help strip out\n+        // more modules and such\n         unsafe {\n-            llvm::LLVMRustMarkAllFunctionsNounwind(llmod);\n+            let ptr = symbol_white_list.as_ptr();\n+            llvm::LLVMRustRunRestrictionPass(llmod,\n+                                            ptr as *const *const libc::c_char,\n+                                            symbol_white_list.len() as libc::size_t);\n+            cgcx.save_temp_bitcode(&module, \"lto.after-restriction\");\n+        }\n+\n+        if cgcx.no_landing_pads {\n+            unsafe {\n+                llvm::LLVMRustMarkAllFunctionsNounwind(llmod);\n+            }\n+            cgcx.save_temp_bitcode(&module, \"lto.after-nounwind\");\n         }\n-        cgcx.save_temp_bitcode(&module, \"lto.after-nounwind\");\n+        timeline.record(\"passes\");\n     }\n-    timeline.record(\"passes\");\n \n     Ok(vec![LtoModuleCodegen::Fat {\n         module: Some(module),\n         _serialized_bitcode: serialized_bitcode,\n     }])\n }\n \n-struct Linker(llvm::LinkerRef);\n+struct Linker<'a>(&'a mut llvm::Linker<'a>);\n \n-impl Linker {\n-    fn new(llmod: ModuleRef) -> Linker {\n+impl Linker<'a> {\n+    fn new(llmod: &'a llvm::Module) -> Self {\n         unsafe { Linker(llvm::LLVMRustLinkerNew(llmod)) }\n     }\n \n@@ -310,9 +314,9 @@ impl Linker {\n     }\n }\n \n-impl Drop for Linker {\n+impl Drop for Linker<'a> {\n     fn drop(&mut self) {\n-        unsafe { llvm::LLVMRustLinkerFree(self.0); }\n+        unsafe { llvm::LLVMRustLinkerFree(&mut *(self.0 as *mut _)); }\n     }\n }\n \n@@ -371,7 +375,7 @@ fn thin_lto(diag_handler: &Handler,\n             info!(\"local module: {} - {}\", i, module.llmod_id);\n             let llvm = module.llvm().expect(\"can't lto precodegened module\");\n             let name = CString::new(module.llmod_id.clone()).unwrap();\n-            let buffer = ThinBuffer::new(llvm.llmod);\n+            let buffer = ThinBuffer::new(llvm.llmod());\n             thin_modules.push(llvm::ThinLTOModule {\n                 identifier: name.as_ptr(),\n                 data: buffer.data().as_ptr(),\n@@ -419,11 +423,10 @@ fn thin_lto(diag_handler: &Handler,\n             thin_modules.len() as u32,\n             symbol_white_list.as_ptr(),\n             symbol_white_list.len() as u32,\n-        );\n-        if data.is_null() {\n-            let msg = \"failed to prepare thin LTO context\".to_string();\n-            return Err(write::llvm_err(&diag_handler, msg))\n-        }\n+        ).ok_or_else(|| {\n+            write::llvm_err(&diag_handler, \"failed to prepare thin LTO context\".to_string())\n+        })?;\n+\n         let data = ThinData(data);\n         info!(\"thin LTO data created\");\n         timeline.record(\"data\");\n@@ -448,8 +451,8 @@ fn thin_lto(diag_handler: &Handler,\n }\n \n fn run_pass_manager(cgcx: &CodegenContext,\n-                    tm: TargetMachineRef,\n-                    llmod: ModuleRef,\n+                    tm: &llvm::TargetMachine,\n+                    llmod: &llvm::Module,\n                     config: &ModuleConfig,\n                     thin: bool) {\n     // Now we have one massive module inside of llmod. Time to run the\n@@ -464,8 +467,7 @@ fn run_pass_manager(cgcx: &CodegenContext,\n \n         if config.verify_llvm_ir {\n             let pass = llvm::LLVMRustFindAndCreatePass(\"verify\\0\".as_ptr() as *const _);\n-            assert!(!pass.is_null());\n-            llvm::LLVMRustAddPass(pm, pass);\n+            llvm::LLVMRustAddPass(pm, pass.unwrap());\n         }\n \n         // When optimizing for LTO we don't actually pass in `-O0`, but we force\n@@ -499,8 +501,7 @@ fn run_pass_manager(cgcx: &CodegenContext,\n \n         if config.verify_llvm_ir {\n             let pass = llvm::LLVMRustFindAndCreatePass(\"verify\\0\".as_ptr() as *const _);\n-            assert!(!pass.is_null());\n-            llvm::LLVMRustAddPass(pm, pass);\n+            llvm::LLVMRustAddPass(pm, pass.unwrap());\n         }\n \n         time_ext(cgcx.time_passes, None, \"LTO passes\", ||\n@@ -525,13 +526,13 @@ impl SerializedModule {\n     }\n }\n \n-pub struct ModuleBuffer(*mut llvm::ModuleBuffer);\n+pub struct ModuleBuffer(&'static mut llvm::ModuleBuffer);\n \n unsafe impl Send for ModuleBuffer {}\n unsafe impl Sync for ModuleBuffer {}\n \n impl ModuleBuffer {\n-    pub fn new(m: ModuleRef) -> ModuleBuffer {\n+    pub fn new(m: &llvm::Module) -> ModuleBuffer {\n         ModuleBuffer(unsafe {\n             llvm::LLVMRustModuleBufferCreate(m)\n         })\n@@ -548,7 +549,7 @@ impl ModuleBuffer {\n \n impl Drop for ModuleBuffer {\n     fn drop(&mut self) {\n-        unsafe { llvm::LLVMRustModuleBufferFree(self.0); }\n+        unsafe { llvm::LLVMRustModuleBufferFree(&mut *(self.0 as *mut _)); }\n     }\n }\n \n@@ -564,26 +565,26 @@ struct ThinShared {\n     module_names: Vec<CString>,\n }\n \n-struct ThinData(*mut llvm::ThinLTOData);\n+struct ThinData(&'static mut llvm::ThinLTOData);\n \n unsafe impl Send for ThinData {}\n unsafe impl Sync for ThinData {}\n \n impl Drop for ThinData {\n     fn drop(&mut self) {\n         unsafe {\n-            llvm::LLVMRustFreeThinLTOData(self.0);\n+            llvm::LLVMRustFreeThinLTOData(&mut *(self.0 as *mut _));\n         }\n     }\n }\n \n-pub struct ThinBuffer(*mut llvm::ThinLTOBuffer);\n+pub struct ThinBuffer(&'static mut llvm::ThinLTOBuffer);\n \n unsafe impl Send for ThinBuffer {}\n unsafe impl Sync for ThinBuffer {}\n \n impl ThinBuffer {\n-    pub fn new(m: ModuleRef) -> ThinBuffer {\n+    pub fn new(m: &llvm::Module) -> ThinBuffer {\n         unsafe {\n             let buffer = llvm::LLVMRustThinLTOBufferCreate(m);\n             ThinBuffer(buffer)\n@@ -602,7 +603,7 @@ impl ThinBuffer {\n impl Drop for ThinBuffer {\n     fn drop(&mut self) {\n         unsafe {\n-            llvm::LLVMRustThinLTOBufferFree(self.0);\n+            llvm::LLVMRustThinLTOBufferFree(&mut *(self.0 as *mut _));\n         }\n     }\n }\n@@ -640,124 +641,126 @@ impl ThinModule {\n         // crates but for locally codegened modules we may be able to reuse\n         // that LLVM Context and Module.\n         let llcx = llvm::LLVMRustContextCreate(cgcx.fewer_names);\n-        let llmod = llvm::LLVMRustParseBitcodeForThinLTO(\n+        let llmod_raw = llvm::LLVMRustParseBitcodeForThinLTO(\n             llcx,\n             self.data().as_ptr(),\n             self.data().len(),\n             self.shared.module_names[self.idx].as_ptr(),\n-        );\n-        if llmod.is_null() {\n+        ).ok_or_else(|| {\n             let msg = \"failed to parse bitcode for thin LTO module\".to_string();\n-            return Err(write::llvm_err(&diag_handler, msg));\n-        }\n+            write::llvm_err(&diag_handler, msg)\n+        })? as *const _;\n         let module = ModuleCodegen {\n             source: ModuleSource::Codegened(ModuleLlvm {\n-                llmod,\n+                llmod_raw,\n                 llcx,\n                 tm,\n             }),\n             llmod_id: self.name().to_string(),\n             name: self.name().to_string(),\n             kind: ModuleKind::Regular,\n         };\n-        cgcx.save_temp_bitcode(&module, \"thin-lto-input\");\n-\n-        // Before we do much else find the \"main\" `DICompileUnit` that we'll be\n-        // using below. If we find more than one though then rustc has changed\n-        // in a way we're not ready for, so generate an ICE by returning\n-        // an error.\n-        let mut cu1 = ptr::null_mut();\n-        let mut cu2 = ptr::null_mut();\n-        llvm::LLVMRustThinLTOGetDICompileUnit(llmod, &mut cu1, &mut cu2);\n-        if !cu2.is_null() {\n-            let msg = \"multiple source DICompileUnits found\".to_string();\n-            return Err(write::llvm_err(&diag_handler, msg))\n-        }\n+        {\n+            let llmod = module.llvm().unwrap().llmod();\n+            cgcx.save_temp_bitcode(&module, \"thin-lto-input\");\n+\n+            // Before we do much else find the \"main\" `DICompileUnit` that we'll be\n+            // using below. If we find more than one though then rustc has changed\n+            // in a way we're not ready for, so generate an ICE by returning\n+            // an error.\n+            let mut cu1 = ptr::null_mut();\n+            let mut cu2 = ptr::null_mut();\n+            llvm::LLVMRustThinLTOGetDICompileUnit(llmod, &mut cu1, &mut cu2);\n+            if !cu2.is_null() {\n+                let msg = \"multiple source DICompileUnits found\".to_string();\n+                return Err(write::llvm_err(&diag_handler, msg))\n+            }\n \n-        // Like with \"fat\" LTO, get some better optimizations if landing pads\n-        // are disabled by removing all landing pads.\n-        if cgcx.no_landing_pads {\n-            llvm::LLVMRustMarkAllFunctionsNounwind(llmod);\n-            cgcx.save_temp_bitcode(&module, \"thin-lto-after-nounwind\");\n-            timeline.record(\"nounwind\");\n-        }\n+            // Like with \"fat\" LTO, get some better optimizations if landing pads\n+            // are disabled by removing all landing pads.\n+            if cgcx.no_landing_pads {\n+                llvm::LLVMRustMarkAllFunctionsNounwind(llmod);\n+                cgcx.save_temp_bitcode(&module, \"thin-lto-after-nounwind\");\n+                timeline.record(\"nounwind\");\n+            }\n \n-        // Up next comes the per-module local analyses that we do for Thin LTO.\n-        // Each of these functions is basically copied from the LLVM\n-        // implementation and then tailored to suit this implementation. Ideally\n-        // each of these would be supported by upstream LLVM but that's perhaps\n-        // a patch for another day!\n-        //\n-        // You can find some more comments about these functions in the LLVM\n-        // bindings we've got (currently `PassWrapper.cpp`)\n-        if !llvm::LLVMRustPrepareThinLTORename(self.shared.data.0, llmod) {\n-            let msg = \"failed to prepare thin LTO module\".to_string();\n-            return Err(write::llvm_err(&diag_handler, msg))\n-        }\n-        cgcx.save_temp_bitcode(&module, \"thin-lto-after-rename\");\n-        timeline.record(\"rename\");\n-        if !llvm::LLVMRustPrepareThinLTOResolveWeak(self.shared.data.0, llmod) {\n-            let msg = \"failed to prepare thin LTO module\".to_string();\n-            return Err(write::llvm_err(&diag_handler, msg))\n-        }\n-        cgcx.save_temp_bitcode(&module, \"thin-lto-after-resolve\");\n-        timeline.record(\"resolve\");\n-        if !llvm::LLVMRustPrepareThinLTOInternalize(self.shared.data.0, llmod) {\n-            let msg = \"failed to prepare thin LTO module\".to_string();\n-            return Err(write::llvm_err(&diag_handler, msg))\n-        }\n-        cgcx.save_temp_bitcode(&module, \"thin-lto-after-internalize\");\n-        timeline.record(\"internalize\");\n-        if !llvm::LLVMRustPrepareThinLTOImport(self.shared.data.0, llmod) {\n-            let msg = \"failed to prepare thin LTO module\".to_string();\n-            return Err(write::llvm_err(&diag_handler, msg))\n+            // Up next comes the per-module local analyses that we do for Thin LTO.\n+            // Each of these functions is basically copied from the LLVM\n+            // implementation and then tailored to suit this implementation. Ideally\n+            // each of these would be supported by upstream LLVM but that's perhaps\n+            // a patch for another day!\n+            //\n+            // You can find some more comments about these functions in the LLVM\n+            // bindings we've got (currently `PassWrapper.cpp`)\n+            if !llvm::LLVMRustPrepareThinLTORename(self.shared.data.0, llmod) {\n+                let msg = \"failed to prepare thin LTO module\".to_string();\n+                return Err(write::llvm_err(&diag_handler, msg))\n+            }\n+            cgcx.save_temp_bitcode(&module, \"thin-lto-after-rename\");\n+            timeline.record(\"rename\");\n+            if !llvm::LLVMRustPrepareThinLTOResolveWeak(self.shared.data.0, llmod) {\n+                let msg = \"failed to prepare thin LTO module\".to_string();\n+                return Err(write::llvm_err(&diag_handler, msg))\n+            }\n+            cgcx.save_temp_bitcode(&module, \"thin-lto-after-resolve\");\n+            timeline.record(\"resolve\");\n+            if !llvm::LLVMRustPrepareThinLTOInternalize(self.shared.data.0, llmod) {\n+                let msg = \"failed to prepare thin LTO module\".to_string();\n+                return Err(write::llvm_err(&diag_handler, msg))\n+            }\n+            cgcx.save_temp_bitcode(&module, \"thin-lto-after-internalize\");\n+            timeline.record(\"internalize\");\n+            if !llvm::LLVMRustPrepareThinLTOImport(self.shared.data.0, llmod) {\n+                let msg = \"failed to prepare thin LTO module\".to_string();\n+                return Err(write::llvm_err(&diag_handler, msg))\n+            }\n+            cgcx.save_temp_bitcode(&module, \"thin-lto-after-import\");\n+            timeline.record(\"import\");\n+\n+            // Ok now this is a bit unfortunate. This is also something you won't\n+            // find upstream in LLVM's ThinLTO passes! This is a hack for now to\n+            // work around bugs in LLVM.\n+            //\n+            // First discovered in #45511 it was found that as part of ThinLTO\n+            // importing passes LLVM will import `DICompileUnit` metadata\n+            // information across modules. This means that we'll be working with one\n+            // LLVM module that has multiple `DICompileUnit` instances in it (a\n+            // bunch of `llvm.dbg.cu` members). Unfortunately there's a number of\n+            // bugs in LLVM's backend which generates invalid DWARF in a situation\n+            // like this:\n+            //\n+            //  https://bugs.llvm.org/show_bug.cgi?id=35212\n+            //  https://bugs.llvm.org/show_bug.cgi?id=35562\n+            //\n+            // While the first bug there is fixed the second ended up causing #46346\n+            // which was basically a resurgence of #45511 after LLVM's bug 35212 was\n+            // fixed.\n+            //\n+            // This function below is a huge hack around this problem. The function\n+            // below is defined in `PassWrapper.cpp` and will basically \"merge\"\n+            // all `DICompileUnit` instances in a module. Basically it'll take all\n+            // the objects, rewrite all pointers of `DISubprogram` to point to the\n+            // first `DICompileUnit`, and then delete all the other units.\n+            //\n+            // This is probably mangling to the debug info slightly (but hopefully\n+            // not too much) but for now at least gets LLVM to emit valid DWARF (or\n+            // so it appears). Hopefully we can remove this once upstream bugs are\n+            // fixed in LLVM.\n+            llvm::LLVMRustThinLTOPatchDICompileUnit(llmod, cu1);\n+            cgcx.save_temp_bitcode(&module, \"thin-lto-after-patch\");\n+            timeline.record(\"patch\");\n+\n+            // Alright now that we've done everything related to the ThinLTO\n+            // analysis it's time to run some optimizations! Here we use the same\n+            // `run_pass_manager` as the \"fat\" LTO above except that we tell it to\n+            // populate a thin-specific pass manager, which presumably LLVM treats a\n+            // little differently.\n+            info!(\"running thin lto passes over {}\", module.name);\n+            let config = cgcx.config(module.kind);\n+            run_pass_manager(cgcx, module.llvm().unwrap().tm, llmod, config, true);\n+            cgcx.save_temp_bitcode(&module, \"thin-lto-after-pm\");\n+            timeline.record(\"thin-done\");\n         }\n-        cgcx.save_temp_bitcode(&module, \"thin-lto-after-import\");\n-        timeline.record(\"import\");\n-\n-        // Ok now this is a bit unfortunate. This is also something you won't\n-        // find upstream in LLVM's ThinLTO passes! This is a hack for now to\n-        // work around bugs in LLVM.\n-        //\n-        // First discovered in #45511 it was found that as part of ThinLTO\n-        // importing passes LLVM will import `DICompileUnit` metadata\n-        // information across modules. This means that we'll be working with one\n-        // LLVM module that has multiple `DICompileUnit` instances in it (a\n-        // bunch of `llvm.dbg.cu` members). Unfortunately there's a number of\n-        // bugs in LLVM's backend which generates invalid DWARF in a situation\n-        // like this:\n-        //\n-        //  https://bugs.llvm.org/show_bug.cgi?id=35212\n-        //  https://bugs.llvm.org/show_bug.cgi?id=35562\n-        //\n-        // While the first bug there is fixed the second ended up causing #46346\n-        // which was basically a resurgence of #45511 after LLVM's bug 35212 was\n-        // fixed.\n-        //\n-        // This function below is a huge hack around this problem. The function\n-        // below is defined in `PassWrapper.cpp` and will basically \"merge\"\n-        // all `DICompileUnit` instances in a module. Basically it'll take all\n-        // the objects, rewrite all pointers of `DISubprogram` to point to the\n-        // first `DICompileUnit`, and then delete all the other units.\n-        //\n-        // This is probably mangling to the debug info slightly (but hopefully\n-        // not too much) but for now at least gets LLVM to emit valid DWARF (or\n-        // so it appears). Hopefully we can remove this once upstream bugs are\n-        // fixed in LLVM.\n-        llvm::LLVMRustThinLTOPatchDICompileUnit(llmod, cu1);\n-        cgcx.save_temp_bitcode(&module, \"thin-lto-after-patch\");\n-        timeline.record(\"patch\");\n-\n-        // Alright now that we've done everything related to the ThinLTO\n-        // analysis it's time to run some optimizations! Here we use the same\n-        // `run_pass_manager` as the \"fat\" LTO above except that we tell it to\n-        // populate a thin-specific pass manager, which presumably LLVM treats a\n-        // little differently.\n-        info!(\"running thin lto passes over {}\", module.name);\n-        let config = cgcx.config(module.kind);\n-        run_pass_manager(cgcx, tm, llmod, config, true);\n-        cgcx.save_temp_bitcode(&module, \"thin-lto-after-pm\");\n-        timeline.record(\"thin-done\");\n \n         Ok(module)\n     }"}, {"sha": "db044878fe745e194b12d215cc0adc1453337e53", "filename": "src/librustc_codegen_llvm/back/write.rs", "status": "modified", "additions": 228, "deletions": 228, "changes": 456, "blob_url": "https://github.com/rust-lang/rust/blob/f89817997ac0aa100bf91997194ad85a7e59f743/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f89817997ac0aa100bf91997194ad85a7e59f743/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs?ref=f89817997ac0aa100bf91997194ad85a7e59f743", "patch": "@@ -25,9 +25,7 @@ use rustc::session::config::{self, OutputFilenames, OutputType, Passes, SomePass\n use rustc::session::Session;\n use rustc::util::nodemap::FxHashMap;\n use time_graph::{self, TimeGraph, Timeline};\n-use llvm;\n-use llvm::{ModuleRef, TargetMachineRef, PassManagerRef, DiagnosticInfoRef};\n-use llvm::{SMDiagnosticRef, ContextRef};\n+use llvm::{self, DiagnosticInfo, PassManager, SMDiagnostic};\n use {CodegenResults, ModuleSource, ModuleCodegen, CompiledModule, ModuleKind};\n use CrateInfo;\n use rustc::hir::def_id::{CrateNum, LOCAL_CRATE};\n@@ -94,9 +92,9 @@ pub fn llvm_err(handler: &errors::Handler, msg: String) -> FatalError {\n \n pub fn write_output_file(\n         handler: &errors::Handler,\n-        target: llvm::TargetMachineRef,\n-        pm: llvm::PassManagerRef,\n-        m: ModuleRef,\n+        target: &'ll llvm::TargetMachine,\n+        pm: &llvm::PassManager<'ll>,\n+        m: &'ll llvm::Module,\n         output: &Path,\n         file_type: llvm::FileType) -> Result<(), FatalError> {\n     unsafe {\n@@ -130,7 +128,10 @@ fn get_llvm_opt_size(optimize: config::OptLevel) -> llvm::CodeGenOptSize {\n     }\n }\n \n-pub fn create_target_machine(sess: &Session, find_features: bool) -> TargetMachineRef {\n+pub fn create_target_machine(\n+    sess: &Session,\n+    find_features: bool,\n+) -> &'static mut llvm::TargetMachine {\n     target_machine_factory(sess, find_features)().unwrap_or_else(|err| {\n         llvm_err(sess.diagnostic(), err).raise()\n     })\n@@ -140,7 +141,7 @@ pub fn create_target_machine(sess: &Session, find_features: bool) -> TargetMachi\n // that `is_pie_binary` is false. When we discover LLVM target features\n // `sess.crate_types` is uninitialized so we cannot access it.\n pub fn target_machine_factory(sess: &Session, find_features: bool)\n-    -> Arc<dyn Fn() -> Result<TargetMachineRef, String> + Send + Sync>\n+    -> Arc<dyn Fn() -> Result<&'static mut llvm::TargetMachine, String> + Send + Sync>\n {\n     let reloc_model = get_reloc_model(sess);\n \n@@ -199,12 +200,10 @@ pub fn target_machine_factory(sess: &Session, find_features: bool)\n             )\n         };\n \n-        if tm.is_null() {\n-            Err(format!(\"Could not create LLVM TargetMachine for triple: {}\",\n-                        triple.to_str().unwrap()))\n-        } else {\n-            Ok(tm)\n-        }\n+        tm.ok_or_else(|| {\n+            format!(\"Could not create LLVM TargetMachine for triple: {}\",\n+                    triple.to_str().unwrap())\n+        })\n     })\n }\n \n@@ -343,7 +342,7 @@ pub struct CodegenContext {\n     regular_module_config: Arc<ModuleConfig>,\n     metadata_module_config: Arc<ModuleConfig>,\n     allocator_module_config: Arc<ModuleConfig>,\n-    pub tm_factory: Arc<dyn Fn() -> Result<TargetMachineRef, String> + Send + Sync>,\n+    pub tm_factory: Arc<dyn Fn() -> Result<&'static mut llvm::TargetMachine, String> + Send + Sync>,\n     pub msvc_imps_needed: bool,\n     pub target_pointer_width: String,\n     debuginfo: config::DebugInfoLevel,\n@@ -392,21 +391,21 @@ impl CodegenContext {\n             let cgu = Some(&module.name[..]);\n             let path = self.output_filenames.temp_path_ext(&ext, cgu);\n             let cstr = path2cstr(&path);\n-            let llmod = module.llvm().unwrap().llmod;\n+            let llmod = module.llvm().unwrap().llmod();\n             llvm::LLVMWriteBitcodeToFile(llmod, cstr.as_ptr());\n         }\n     }\n }\n \n struct DiagnosticHandlers<'a> {\n     data: *mut (&'a CodegenContext, &'a Handler),\n-    llcx: ContextRef,\n+    llcx: &'a llvm::Context,\n }\n \n impl<'a> DiagnosticHandlers<'a> {\n     fn new(cgcx: &'a CodegenContext,\n            handler: &'a Handler,\n-           llcx: ContextRef) -> DiagnosticHandlers<'a> {\n+           llcx: &'a llvm::Context) -> Self {\n         let data = Box::into_raw(Box::new((cgcx, handler)));\n         unsafe {\n             llvm::LLVMRustSetInlineAsmDiagnosticHandler(llcx, inline_asm_handler, data as *mut _);\n@@ -433,7 +432,7 @@ unsafe extern \"C\" fn report_inline_asm<'a, 'b>(cgcx: &'a CodegenContext,\n     cgcx.diag_emitter.inline_asm_error(cookie as u32, msg.to_string());\n }\n \n-unsafe extern \"C\" fn inline_asm_handler(diag: SMDiagnosticRef,\n+unsafe extern \"C\" fn inline_asm_handler(diag: &SMDiagnostic,\n                                         user: *const c_void,\n                                         cookie: c_uint) {\n     if user.is_null() {\n@@ -447,7 +446,7 @@ unsafe extern \"C\" fn inline_asm_handler(diag: SMDiagnosticRef,\n     report_inline_asm(cgcx, &msg, cookie);\n }\n \n-unsafe extern \"C\" fn diagnostic_handler(info: DiagnosticInfoRef, user: *mut c_void) {\n+unsafe extern \"C\" fn diagnostic_handler(info: &DiagnosticInfo, user: *mut c_void) {\n     if user.is_null() {\n         return\n     }\n@@ -495,7 +494,7 @@ unsafe fn optimize(cgcx: &CodegenContext,\n     -> Result<(), FatalError>\n {\n     let (llmod, llcx, tm) = match module.source {\n-        ModuleSource::Codegened(ref llvm) => (llvm.llmod, llvm.llcx, llvm.tm),\n+        ModuleSource::Codegened(ref llvm) => (llvm.llmod(), &*llvm.llcx, &*llvm.tm),\n         ModuleSource::Preexisting(_) => {\n             bug!(\"optimize_and_codegen: called with ModuleSource::Preexisting\")\n         }\n@@ -520,50 +519,52 @@ unsafe fn optimize(cgcx: &CodegenContext,\n         let fpm = llvm::LLVMCreateFunctionPassManagerForModule(llmod);\n         let mpm = llvm::LLVMCreatePassManager();\n \n-        // If we're verifying or linting, add them to the function pass\n-        // manager.\n-        let addpass = |pass_name: &str| {\n-            let pass_name = CString::new(pass_name).unwrap();\n-            let pass = llvm::LLVMRustFindAndCreatePass(pass_name.as_ptr());\n-            if pass.is_null() {\n-                return false;\n-            }\n-            let pass_manager = match llvm::LLVMRustPassKind(pass) {\n-                llvm::PassKind::Function => fpm,\n-                llvm::PassKind::Module => mpm,\n-                llvm::PassKind::Other => {\n-                    diag_handler.err(\"Encountered LLVM pass kind we can't handle\");\n-                    return true\n-                },\n+        {\n+            // If we're verifying or linting, add them to the function pass\n+            // manager.\n+            let addpass = |pass_name: &str| {\n+                let pass_name = CString::new(pass_name).unwrap();\n+                let pass = match llvm::LLVMRustFindAndCreatePass(pass_name.as_ptr()) {\n+                    Some(pass) => pass,\n+                    None => return false,\n+                };\n+                let pass_manager = match llvm::LLVMRustPassKind(pass) {\n+                    llvm::PassKind::Function => &*fpm,\n+                    llvm::PassKind::Module => &*mpm,\n+                    llvm::PassKind::Other => {\n+                        diag_handler.err(\"Encountered LLVM pass kind we can't handle\");\n+                        return true\n+                    },\n+                };\n+                llvm::LLVMRustAddPass(pass_manager, pass);\n+                true\n             };\n-            llvm::LLVMRustAddPass(pass_manager, pass);\n-            true\n-        };\n \n-        if config.verify_llvm_ir { assert!(addpass(\"verify\")); }\n-        if !config.no_prepopulate_passes {\n-            llvm::LLVMRustAddAnalysisPasses(tm, fpm, llmod);\n-            llvm::LLVMRustAddAnalysisPasses(tm, mpm, llmod);\n-            let opt_level = config.opt_level.unwrap_or(llvm::CodeGenOptLevel::None);\n-            let prepare_for_thin_lto = cgcx.lto == Lto::Thin || cgcx.lto == Lto::ThinLocal;\n-            with_llvm_pmb(llmod, &config, opt_level, prepare_for_thin_lto, &mut |b| {\n-                llvm::LLVMPassManagerBuilderPopulateFunctionPassManager(b, fpm);\n-                llvm::LLVMPassManagerBuilderPopulateModulePassManager(b, mpm);\n-            })\n-        }\n+            if config.verify_llvm_ir { assert!(addpass(\"verify\")); }\n+            if !config.no_prepopulate_passes {\n+                llvm::LLVMRustAddAnalysisPasses(tm, fpm, llmod);\n+                llvm::LLVMRustAddAnalysisPasses(tm, mpm, llmod);\n+                let opt_level = config.opt_level.unwrap_or(llvm::CodeGenOptLevel::None);\n+                let prepare_for_thin_lto = cgcx.lto == Lto::Thin || cgcx.lto == Lto::ThinLocal;\n+                with_llvm_pmb(llmod, &config, opt_level, prepare_for_thin_lto, &mut |b| {\n+                    llvm::LLVMPassManagerBuilderPopulateFunctionPassManager(b, fpm);\n+                    llvm::LLVMPassManagerBuilderPopulateModulePassManager(b, mpm);\n+                })\n+            }\n \n-        for pass in &config.passes {\n-            if !addpass(pass) {\n-                diag_handler.warn(&format!(\"unknown pass `{}`, ignoring\",\n-                                           pass));\n+            for pass in &config.passes {\n+                if !addpass(pass) {\n+                    diag_handler.warn(&format!(\"unknown pass `{}`, ignoring\",\n+                                            pass));\n+                }\n             }\n-        }\n \n-        for pass in &cgcx.plugin_passes {\n-            if !addpass(pass) {\n-                diag_handler.err(&format!(\"a plugin asked for LLVM pass \\\n-                                           `{}` but LLVM does not \\\n-                                           recognize it\", pass));\n+            for pass in &cgcx.plugin_passes {\n+                if !addpass(pass) {\n+                    diag_handler.err(&format!(\"a plugin asked for LLVM pass \\\n+                                            `{}` but LLVM does not \\\n+                                            recognize it\", pass));\n+                }\n             }\n         }\n \n@@ -617,192 +618,191 @@ unsafe fn codegen(cgcx: &CodegenContext,\n     -> Result<CompiledModule, FatalError>\n {\n     timeline.record(\"codegen\");\n-    let (llmod, llcx, tm) = match module.source {\n-        ModuleSource::Codegened(ref llvm) => (llvm.llmod, llvm.llcx, llvm.tm),\n-        ModuleSource::Preexisting(_) => {\n-            bug!(\"codegen: called with ModuleSource::Preexisting\")\n-        }\n-    };\n-    let module_name = module.name.clone();\n-    let module_name = Some(&module_name[..]);\n-    let handlers = DiagnosticHandlers::new(cgcx, diag_handler, llcx);\n-\n-    if cgcx.msvc_imps_needed {\n-        create_msvc_imps(cgcx, llcx, llmod);\n-    }\n-\n-    // A codegen-specific pass manager is used to generate object\n-    // files for an LLVM module.\n-    //\n-    // Apparently each of these pass managers is a one-shot kind of\n-    // thing, so we create a new one for each type of output. The\n-    // pass manager passed to the closure should be ensured to not\n-    // escape the closure itself, and the manager should only be\n-    // used once.\n-    unsafe fn with_codegen<F, R>(tm: TargetMachineRef,\n-                                 llmod: ModuleRef,\n-                                 no_builtins: bool,\n-                                 f: F) -> R\n-        where F: FnOnce(PassManagerRef) -> R,\n     {\n-        let cpm = llvm::LLVMCreatePassManager();\n-        llvm::LLVMRustAddAnalysisPasses(tm, cpm, llmod);\n-        llvm::LLVMRustAddLibraryInfo(cpm, llmod, no_builtins);\n-        f(cpm)\n-    }\n-\n-    // If we don't have the integrated assembler, then we need to emit asm\n-    // from LLVM and use `gcc` to create the object file.\n-    let asm_to_obj = config.emit_obj && config.no_integrated_as;\n-\n-    // Change what we write and cleanup based on whether obj files are\n-    // just llvm bitcode. In that case write bitcode, and possibly\n-    // delete the bitcode if it wasn't requested. Don't generate the\n-    // machine code, instead copy the .o file from the .bc\n-    let write_bc = config.emit_bc || config.obj_is_bitcode;\n-    let rm_bc = !config.emit_bc && config.obj_is_bitcode;\n-    let write_obj = config.emit_obj && !config.obj_is_bitcode && !asm_to_obj;\n-    let copy_bc_to_obj = config.emit_obj && config.obj_is_bitcode;\n-\n-    let bc_out = cgcx.output_filenames.temp_path(OutputType::Bitcode, module_name);\n-    let obj_out = cgcx.output_filenames.temp_path(OutputType::Object, module_name);\n-\n-\n-    if write_bc || config.emit_bc_compressed || config.embed_bitcode {\n-        let thin;\n-        let old;\n-        let data = if llvm::LLVMRustThinLTOAvailable() {\n-            thin = ThinBuffer::new(llmod);\n-            thin.data()\n-        } else {\n-            old = ModuleBuffer::new(llmod);\n-            old.data()\n+        let (llmod, llcx, tm) = match module.source {\n+            ModuleSource::Codegened(ref llvm) => (llvm.llmod(), &*llvm.llcx, &*llvm.tm),\n+            ModuleSource::Preexisting(_) => {\n+                bug!(\"codegen: called with ModuleSource::Preexisting\")\n+            }\n         };\n-        timeline.record(\"make-bc\");\n+        let module_name = module.name.clone();\n+        let module_name = Some(&module_name[..]);\n+        let handlers = DiagnosticHandlers::new(cgcx, diag_handler, llcx);\n \n-        if write_bc {\n-            if let Err(e) = fs::write(&bc_out, data) {\n-                diag_handler.err(&format!(\"failed to write bytecode: {}\", e));\n-            }\n-            timeline.record(\"write-bc\");\n+        if cgcx.msvc_imps_needed {\n+            create_msvc_imps(cgcx, llcx, llmod);\n         }\n \n-        if config.embed_bitcode {\n-            embed_bitcode(cgcx, llcx, llmod, Some(data));\n-            timeline.record(\"embed-bc\");\n-        }\n+        // A codegen-specific pass manager is used to generate object\n+        // files for an LLVM module.\n+        //\n+        // Apparently each of these pass managers is a one-shot kind of\n+        // thing, so we create a new one for each type of output. The\n+        // pass manager passed to the closure should be ensured to not\n+        // escape the closure itself, and the manager should only be\n+        // used once.\n+        unsafe fn with_codegen<'ll, F, R>(tm: &'ll llvm::TargetMachine,\n+                                    llmod: &'ll llvm::Module,\n+                                    no_builtins: bool,\n+                                    f: F) -> R\n+            where F: FnOnce(&'ll mut PassManager<'ll>) -> R,\n+        {\n+            let cpm = llvm::LLVMCreatePassManager();\n+            llvm::LLVMRustAddAnalysisPasses(tm, cpm, llmod);\n+            llvm::LLVMRustAddLibraryInfo(cpm, llmod, no_builtins);\n+            f(cpm)\n+        }\n+\n+        // If we don't have the integrated assembler, then we need to emit asm\n+        // from LLVM and use `gcc` to create the object file.\n+        let asm_to_obj = config.emit_obj && config.no_integrated_as;\n+\n+        // Change what we write and cleanup based on whether obj files are\n+        // just llvm bitcode. In that case write bitcode, and possibly\n+        // delete the bitcode if it wasn't requested. Don't generate the\n+        // machine code, instead copy the .o file from the .bc\n+        let write_bc = config.emit_bc || config.obj_is_bitcode;\n+        let rm_bc = !config.emit_bc && config.obj_is_bitcode;\n+        let write_obj = config.emit_obj && !config.obj_is_bitcode && !asm_to_obj;\n+        let copy_bc_to_obj = config.emit_obj && config.obj_is_bitcode;\n+\n+        let bc_out = cgcx.output_filenames.temp_path(OutputType::Bitcode, module_name);\n+        let obj_out = cgcx.output_filenames.temp_path(OutputType::Object, module_name);\n+\n+\n+        if write_bc || config.emit_bc_compressed || config.embed_bitcode {\n+            let thin;\n+            let old;\n+            let data = if llvm::LLVMRustThinLTOAvailable() {\n+                thin = ThinBuffer::new(llmod);\n+                thin.data()\n+            } else {\n+                old = ModuleBuffer::new(llmod);\n+                old.data()\n+            };\n+            timeline.record(\"make-bc\");\n \n-        if config.emit_bc_compressed {\n-            let dst = bc_out.with_extension(RLIB_BYTECODE_EXTENSION);\n-            let data = bytecode::encode(&module.llmod_id, data);\n-            if let Err(e) = fs::write(&dst, data) {\n-                diag_handler.err(&format!(\"failed to write bytecode: {}\", e));\n+            if write_bc {\n+                if let Err(e) = fs::write(&bc_out, data) {\n+                    diag_handler.err(&format!(\"failed to write bytecode: {}\", e));\n+                }\n+                timeline.record(\"write-bc\");\n             }\n-            timeline.record(\"compress-bc\");\n-        }\n-    } else if config.embed_bitcode_marker {\n-        embed_bitcode(cgcx, llcx, llmod, None);\n-    }\n \n-    time_ext(config.time_passes, None, &format!(\"codegen passes [{}]\", module_name.unwrap()),\n-         || -> Result<(), FatalError> {\n-        if config.emit_ir {\n-            let out = cgcx.output_filenames.temp_path(OutputType::LlvmAssembly, module_name);\n-            let out = path2cstr(&out);\n-\n-            extern \"C\" fn demangle_callback(input_ptr: *const c_char,\n-                                            input_len: size_t,\n-                                            output_ptr: *mut c_char,\n-                                            output_len: size_t) -> size_t {\n-                let input = unsafe {\n-                    slice::from_raw_parts(input_ptr as *const u8, input_len as usize)\n-                };\n+            if config.embed_bitcode {\n+                embed_bitcode(cgcx, llcx, llmod, Some(data));\n+                timeline.record(\"embed-bc\");\n+            }\n \n-                let input = match str::from_utf8(input) {\n-                    Ok(s) => s,\n-                    Err(_) => return 0,\n-                };\n+            if config.emit_bc_compressed {\n+                let dst = bc_out.with_extension(RLIB_BYTECODE_EXTENSION);\n+                let data = bytecode::encode(&module.llmod_id, data);\n+                if let Err(e) = fs::write(&dst, data) {\n+                    diag_handler.err(&format!(\"failed to write bytecode: {}\", e));\n+                }\n+                timeline.record(\"compress-bc\");\n+            }\n+        } else if config.embed_bitcode_marker {\n+            embed_bitcode(cgcx, llcx, llmod, None);\n+        }\n+\n+        time_ext(config.time_passes, None, &format!(\"codegen passes [{}]\", module_name.unwrap()),\n+            || -> Result<(), FatalError> {\n+            if config.emit_ir {\n+                let out = cgcx.output_filenames.temp_path(OutputType::LlvmAssembly, module_name);\n+                let out = path2cstr(&out);\n+\n+                extern \"C\" fn demangle_callback(input_ptr: *const c_char,\n+                                                input_len: size_t,\n+                                                output_ptr: *mut c_char,\n+                                                output_len: size_t) -> size_t {\n+                    let input = unsafe {\n+                        slice::from_raw_parts(input_ptr as *const u8, input_len as usize)\n+                    };\n \n-                let output = unsafe {\n-                    slice::from_raw_parts_mut(output_ptr as *mut u8, output_len as usize)\n-                };\n-                let mut cursor = io::Cursor::new(output);\n+                    let input = match str::from_utf8(input) {\n+                        Ok(s) => s,\n+                        Err(_) => return 0,\n+                    };\n \n-                let demangled = match rustc_demangle::try_demangle(input) {\n-                    Ok(d) => d,\n-                    Err(_) => return 0,\n-                };\n+                    let output = unsafe {\n+                        slice::from_raw_parts_mut(output_ptr as *mut u8, output_len as usize)\n+                    };\n+                    let mut cursor = io::Cursor::new(output);\n+\n+                    let demangled = match rustc_demangle::try_demangle(input) {\n+                        Ok(d) => d,\n+                        Err(_) => return 0,\n+                    };\n+\n+                    if let Err(_) = write!(cursor, \"{:#}\", demangled) {\n+                        // Possible only if provided buffer is not big enough\n+                        return 0;\n+                    }\n \n-                if let Err(_) = write!(cursor, \"{:#}\", demangled) {\n-                    // Possible only if provided buffer is not big enough\n-                    return 0;\n+                    cursor.position() as size_t\n                 }\n \n-                cursor.position() as size_t\n+                with_codegen(tm, llmod, config.no_builtins, |cpm| {\n+                    llvm::LLVMRustPrintModule(cpm, llmod, out.as_ptr(), demangle_callback);\n+                    llvm::LLVMDisposePassManager(cpm);\n+                });\n+                timeline.record(\"ir\");\n             }\n \n-            with_codegen(tm, llmod, config.no_builtins, |cpm| {\n-                llvm::LLVMRustPrintModule(cpm, llmod, out.as_ptr(), demangle_callback);\n-                llvm::LLVMDisposePassManager(cpm);\n-            });\n-            timeline.record(\"ir\");\n-        }\n-\n-        if config.emit_asm || asm_to_obj {\n-            let path = cgcx.output_filenames.temp_path(OutputType::Assembly, module_name);\n+            if config.emit_asm || asm_to_obj {\n+                let path = cgcx.output_filenames.temp_path(OutputType::Assembly, module_name);\n \n-            // We can't use the same module for asm and binary output, because that triggers\n-            // various errors like invalid IR or broken binaries, so we might have to clone the\n-            // module to produce the asm output\n-            let llmod = if config.emit_obj {\n-                llvm::LLVMCloneModule(llmod)\n-            } else {\n-                llmod\n-            };\n-            with_codegen(tm, llmod, config.no_builtins, |cpm| {\n-                write_output_file(diag_handler, tm, cpm, llmod, &path,\n-                                  llvm::FileType::AssemblyFile)\n-            })?;\n-            if config.emit_obj {\n-                llvm::LLVMDisposeModule(llmod);\n+                // We can't use the same module for asm and binary output, because that triggers\n+                // various errors like invalid IR or broken binaries, so we might have to clone the\n+                // module to produce the asm output\n+                let llmod = if config.emit_obj {\n+                    llvm::LLVMCloneModule(llmod)\n+                } else {\n+                    llmod\n+                };\n+                with_codegen(tm, llmod, config.no_builtins, |cpm| {\n+                    write_output_file(diag_handler, tm, cpm, llmod, &path,\n+                                    llvm::FileType::AssemblyFile)\n+                })?;\n+                timeline.record(\"asm\");\n             }\n-            timeline.record(\"asm\");\n-        }\n \n-        if write_obj {\n-            with_codegen(tm, llmod, config.no_builtins, |cpm| {\n-                write_output_file(diag_handler, tm, cpm, llmod, &obj_out,\n-                                  llvm::FileType::ObjectFile)\n-            })?;\n-            timeline.record(\"obj\");\n-        } else if asm_to_obj {\n-            let assembly = cgcx.output_filenames.temp_path(OutputType::Assembly, module_name);\n-            run_assembler(cgcx, diag_handler, &assembly, &obj_out);\n-            timeline.record(\"asm_to_obj\");\n-\n-            if !config.emit_asm && !cgcx.save_temps {\n-                drop(fs::remove_file(&assembly));\n+            if write_obj {\n+                with_codegen(tm, llmod, config.no_builtins, |cpm| {\n+                    write_output_file(diag_handler, tm, cpm, llmod, &obj_out,\n+                                    llvm::FileType::ObjectFile)\n+                })?;\n+                timeline.record(\"obj\");\n+            } else if asm_to_obj {\n+                let assembly = cgcx.output_filenames.temp_path(OutputType::Assembly, module_name);\n+                run_assembler(cgcx, diag_handler, &assembly, &obj_out);\n+                timeline.record(\"asm_to_obj\");\n+\n+                if !config.emit_asm && !cgcx.save_temps {\n+                    drop(fs::remove_file(&assembly));\n+                }\n             }\n-        }\n \n-        Ok(())\n-    })?;\n+            Ok(())\n+        })?;\n \n-    if copy_bc_to_obj {\n-        debug!(\"copying bitcode {:?} to obj {:?}\", bc_out, obj_out);\n-        if let Err(e) = link_or_copy(&bc_out, &obj_out) {\n-            diag_handler.err(&format!(\"failed to copy bitcode to object file: {}\", e));\n+        if copy_bc_to_obj {\n+            debug!(\"copying bitcode {:?} to obj {:?}\", bc_out, obj_out);\n+            if let Err(e) = link_or_copy(&bc_out, &obj_out) {\n+                diag_handler.err(&format!(\"failed to copy bitcode to object file: {}\", e));\n+            }\n         }\n-    }\n \n-    if rm_bc {\n-        debug!(\"removing_bitcode {:?}\", bc_out);\n-        if let Err(e) = fs::remove_file(&bc_out) {\n-            diag_handler.err(&format!(\"failed to remove bitcode: {}\", e));\n+        if rm_bc {\n+            debug!(\"removing_bitcode {:?}\", bc_out);\n+            if let Err(e) = fs::remove_file(&bc_out) {\n+                diag_handler.err(&format!(\"failed to remove bitcode: {}\", e));\n+            }\n         }\n-    }\n \n-    drop(handlers);\n+        drop(handlers);\n+    }\n     Ok(module.into_compiled_module(config.emit_obj,\n                                    config.emit_bc,\n                                    config.emit_bc_compressed,\n@@ -828,13 +828,13 @@ unsafe fn codegen(cgcx: &CodegenContext,\n /// Basically all of this is us attempting to follow in the footsteps of clang\n /// on iOS. See #35968 for lots more info.\n unsafe fn embed_bitcode(cgcx: &CodegenContext,\n-                        llcx: ContextRef,\n-                        llmod: ModuleRef,\n+                        llcx: &llvm::Context,\n+                        llmod: &llvm::Module,\n                         bitcode: Option<&[u8]>) {\n     let llconst = C_bytes_in_context(llcx, bitcode.unwrap_or(&[]));\n     let llglobal = llvm::LLVMAddGlobal(\n         llmod,\n-        val_ty(llconst).to_ref(),\n+        val_ty(llconst),\n         \"rustc.embedded.module\\0\".as_ptr() as *const _,\n     );\n     llvm::LLVMSetInitializer(llglobal, llconst);\n@@ -854,7 +854,7 @@ unsafe fn embed_bitcode(cgcx: &CodegenContext,\n     let llconst = C_bytes_in_context(llcx, &[]);\n     let llglobal = llvm::LLVMAddGlobal(\n         llmod,\n-        val_ty(llconst).to_ref(),\n+        val_ty(llconst),\n         \"rustc.embedded.cmdline\\0\".as_ptr() as *const _,\n     );\n     llvm::LLVMSetInitializer(llglobal, llconst);\n@@ -2050,11 +2050,11 @@ pub fn run_assembler(cgcx: &CodegenContext, handler: &Handler, assembly: &Path,\n     }\n }\n \n-pub unsafe fn with_llvm_pmb(llmod: ModuleRef,\n+pub unsafe fn with_llvm_pmb(llmod: &llvm::Module,\n                             config: &ModuleConfig,\n                             opt_level: llvm::CodeGenOptLevel,\n                             prepare_for_thin_lto: bool,\n-                            f: &mut dyn FnMut(llvm::PassManagerBuilderRef)) {\n+                            f: &mut dyn FnMut(&llvm::PassManagerBuilder)) {\n     use std::ptr;\n \n     // Create the PassManagerBuilder for LLVM. We configure it with\n@@ -2353,7 +2353,7 @@ fn msvc_imps_needed(tcx: TyCtxt) -> bool {\n // when using MSVC linker.  We do this only for data, as linker can fix up\n // code references on its own.\n // See #26591, #27438\n-fn create_msvc_imps(cgcx: &CodegenContext, llcx: ContextRef, llmod: ModuleRef) {\n+fn create_msvc_imps(cgcx: &CodegenContext, llcx: &llvm::Context, llmod: &llvm::Module) {\n     if !cgcx.msvc_imps_needed {\n         return\n     }\n@@ -2383,7 +2383,7 @@ fn create_msvc_imps(cgcx: &CodegenContext, llcx: ContextRef, llmod: ModuleRef) {\n             .collect::<Vec<_>>();\n         for (imp_name, val) in globals {\n             let imp = llvm::LLVMAddGlobal(llmod,\n-                                          i8p_ty.to_ref(),\n+                                          i8p_ty,\n                                           imp_name.as_ptr() as *const _);\n             llvm::LLVMSetInitializer(imp, consts::ptrcast(val, i8p_ty));\n             llvm::LLVMRustSetLinkage(imp, llvm::Linkage::ExternalLinkage);"}, {"sha": "8278b443a4c83a9e1394f16783b44ee00ca42e1c", "filename": "src/librustc_codegen_llvm/base.rs", "status": "modified", "additions": 120, "deletions": 124, "changes": 244, "blob_url": "https://github.com/rust-lang/rust/blob/f89817997ac0aa100bf91997194ad85a7e59f743/src%2Flibrustc_codegen_llvm%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f89817997ac0aa100bf91997194ad85a7e59f743/src%2Flibrustc_codegen_llvm%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbase.rs?ref=f89817997ac0aa100bf91997194ad85a7e59f743", "patch": "@@ -17,11 +17,11 @@\n //!\n //! Hopefully useful general knowledge about codegen:\n //!\n-//!   * There's no way to find out the Ty type of a ValueRef.  Doing so\n+//!   * There's no way to find out the Ty type of a Value.  Doing so\n //!     would be \"trying to get the eggs out of an omelette\" (credit:\n-//!     pcwalton).  You can, instead, find out its TypeRef by calling val_ty,\n-//!     but one TypeRef corresponds to many `Ty`s; for instance, tup(int, int,\n-//!     int) and rec(x=int, y=int, z=int) will have the same TypeRef.\n+//!     pcwalton).  You can, instead, find out its llvm::Type by calling val_ty,\n+//!     but one llvm::Type corresponds to many `Ty`s; for instance, tup(int, int,\n+//!     int) and rec(x=int, y=int, z=int) will have the same llvm::Type.\n \n use super::ModuleLlvm;\n use super::ModuleSource;\n@@ -30,9 +30,8 @@ use super::ModuleKind;\n \n use abi;\n use back::link;\n-use back::write::{self, OngoingCodegen, create_target_machine};\n-use llvm::{ContextRef, ModuleRef, ValueRef, Vector, get_param};\n-use llvm;\n+use back::write::{self, OngoingCodegen};\n+use llvm::{self, TypeKind, get_param};\n use metadata;\n use rustc::hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use rustc::middle::lang_items::StartFnLangItem;\n@@ -59,7 +58,7 @@ use rustc_mir::monomorphize::collector::{self, MonoItemCollectionMode};\n use rustc_mir::monomorphize::item::DefPathBasedNames;\n use common::{self, C_struct_in_context, C_array, val_ty};\n use consts;\n-use context::{self, CodegenCx};\n+use context::CodegenCx;\n use debuginfo;\n use declare;\n use meth;\n@@ -77,7 +76,6 @@ use rustc_data_structures::sync::Lrc;\n \n use std::any::Any;\n use std::ffi::CString;\n-use std::str;\n use std::sync::Arc;\n use std::time::{Instant, Duration};\n use std::i32;\n@@ -88,18 +86,20 @@ use syntax_pos::symbol::InternedString;\n use syntax::attr;\n use rustc::hir::{self, CodegenFnAttrs};\n \n+use value::Value;\n+\n use mir::operand::OperandValue;\n \n use rustc_codegen_utils::check_for_rustc_errors_attr;\n \n-pub struct StatRecorder<'a, 'tcx: 'a> {\n-    cx: &'a CodegenCx<'a, 'tcx>,\n+pub struct StatRecorder<'a, 'll: 'a, 'tcx: 'll> {\n+    cx: &'a CodegenCx<'ll, 'tcx>,\n     name: Option<String>,\n     istart: usize,\n }\n \n-impl<'a, 'tcx> StatRecorder<'a, 'tcx> {\n-    pub fn new(cx: &'a CodegenCx<'a, 'tcx>, name: String) -> StatRecorder<'a, 'tcx> {\n+impl StatRecorder<'a, 'll, 'tcx> {\n+    pub fn new(cx: &'a CodegenCx<'ll, 'tcx>, name: String) -> Self {\n         let istart = cx.stats.borrow().n_llvm_insns;\n         StatRecorder {\n             cx,\n@@ -109,7 +109,7 @@ impl<'a, 'tcx> StatRecorder<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> Drop for StatRecorder<'a, 'tcx> {\n+impl Drop for StatRecorder<'a, 'll, 'tcx> {\n     fn drop(&mut self) {\n         if self.cx.sess().codegen_stats() {\n             let mut stats = self.cx.stats.borrow_mut();\n@@ -156,14 +156,14 @@ pub fn bin_op_to_fcmp_predicate(op: hir::BinOpKind) -> llvm::RealPredicate {\n     }\n }\n \n-pub fn compare_simd_types<'a, 'tcx>(\n-    bx: &Builder<'a, 'tcx>,\n-    lhs: ValueRef,\n-    rhs: ValueRef,\n+pub fn compare_simd_types(\n+    bx: &Builder<'a, 'll, 'tcx>,\n+    lhs: &'ll Value,\n+    rhs: &'ll Value,\n     t: Ty<'tcx>,\n-    ret_ty: Type,\n+    ret_ty: &'ll Type,\n     op: hir::BinOpKind\n-) -> ValueRef {\n+) -> &'ll Value {\n     let signed = match t.sty {\n         ty::TyFloat(_) => {\n             let cmp = bin_op_to_fcmp_predicate(op);\n@@ -188,11 +188,12 @@ pub fn compare_simd_types<'a, 'tcx>(\n /// The `old_info` argument is a bit funny. It is intended for use\n /// in an upcast, where the new vtable for an object will be derived\n /// from the old one.\n-pub fn unsized_info<'cx, 'tcx>(cx: &CodegenCx<'cx, 'tcx>,\n-                                source: Ty<'tcx>,\n-                                target: Ty<'tcx>,\n-                                old_info: Option<ValueRef>)\n-                                -> ValueRef {\n+pub fn unsized_info(\n+    cx: &CodegenCx<'ll, 'tcx>,\n+    source: Ty<'tcx>,\n+    target: Ty<'tcx>,\n+    old_info: Option<&'ll Value>,\n+) -> &'ll Value {\n     let (source, target) = cx.tcx.struct_lockstep_tails(source, target);\n     match (&source.sty, &target.sty) {\n         (&ty::TyArray(_, len), &ty::TySlice(_)) => {\n@@ -217,12 +218,12 @@ pub fn unsized_info<'cx, 'tcx>(cx: &CodegenCx<'cx, 'tcx>,\n }\n \n /// Coerce `src` to `dst_ty`. `src_ty` must be a thin pointer.\n-pub fn unsize_thin_ptr<'a, 'tcx>(\n-    bx: &Builder<'a, 'tcx>,\n-    src: ValueRef,\n+pub fn unsize_thin_ptr(\n+    bx: &Builder<'a, 'll, 'tcx>,\n+    src: &'ll Value,\n     src_ty: Ty<'tcx>,\n     dst_ty: Ty<'tcx>\n-) -> (ValueRef, ValueRef) {\n+) -> (&'ll Value, &'ll Value) {\n     debug!(\"unsize_thin_ptr: {:?} => {:?}\", src_ty, dst_ty);\n     match (&src_ty.sty, &dst_ty.sty) {\n         (&ty::TyRef(_, a, _),\n@@ -272,9 +273,11 @@ pub fn unsize_thin_ptr<'a, 'tcx>(\n \n /// Coerce `src`, which is a reference to a value of type `src_ty`,\n /// to a value of type `dst_ty` and store the result in `dst`\n-pub fn coerce_unsized_into<'a, 'tcx>(bx: &Builder<'a, 'tcx>,\n-                                     src: PlaceRef<'tcx>,\n-                                     dst: PlaceRef<'tcx>) {\n+pub fn coerce_unsized_into(\n+    bx: &Builder<'a, 'll, 'tcx>,\n+    src: PlaceRef<'ll, 'tcx>,\n+    dst: PlaceRef<'ll, 'tcx>\n+) {\n     let src_ty = src.layout.ty;\n     let dst_ty = dst.layout.ty;\n     let coerce_ptr = || {\n@@ -330,28 +333,28 @@ pub fn coerce_unsized_into<'a, 'tcx>(bx: &Builder<'a, 'tcx>,\n }\n \n pub fn cast_shift_expr_rhs(\n-    cx: &Builder, op: hir::BinOpKind, lhs: ValueRef, rhs: ValueRef\n-) -> ValueRef {\n+    cx: &Builder<'_, 'll, '_>, op: hir::BinOpKind, lhs: &'ll Value, rhs: &'ll Value\n+) -> &'ll Value {\n     cast_shift_rhs(op, lhs, rhs, |a, b| cx.trunc(a, b), |a, b| cx.zext(a, b))\n }\n \n-fn cast_shift_rhs<F, G>(op: hir::BinOpKind,\n-                        lhs: ValueRef,\n-                        rhs: ValueRef,\n+fn cast_shift_rhs<'ll, F, G>(op: hir::BinOpKind,\n+                        lhs: &'ll Value,\n+                        rhs: &'ll Value,\n                         trunc: F,\n                         zext: G)\n-                        -> ValueRef\n-    where F: FnOnce(ValueRef, Type) -> ValueRef,\n-          G: FnOnce(ValueRef, Type) -> ValueRef\n+                        -> &'ll Value\n+    where F: FnOnce(&'ll Value, &'ll Type) -> &'ll Value,\n+          G: FnOnce(&'ll Value, &'ll Type) -> &'ll Value\n {\n     // Shifts may have any size int on the rhs\n     if op.is_shift() {\n         let mut rhs_llty = val_ty(rhs);\n         let mut lhs_llty = val_ty(lhs);\n-        if rhs_llty.kind() == Vector {\n+        if rhs_llty.kind() == TypeKind::Vector {\n             rhs_llty = rhs_llty.element_type()\n         }\n-        if lhs_llty.kind() == Vector {\n+        if lhs_llty.kind() == TypeKind::Vector {\n             lhs_llty = lhs_llty.element_type()\n         }\n         let rhs_sz = rhs_llty.int_width();\n@@ -379,39 +382,49 @@ pub fn wants_msvc_seh(sess: &Session) -> bool {\n     sess.target.target.options.is_like_msvc\n }\n \n-pub fn call_assume<'a, 'tcx>(bx: &Builder<'a, 'tcx>, val: ValueRef) {\n+pub fn call_assume(bx: &Builder<'_, 'll, '_>, val: &'ll Value) {\n     let assume_intrinsic = bx.cx.get_intrinsic(\"llvm.assume\");\n     bx.call(assume_intrinsic, &[val], None);\n }\n \n-pub fn from_immediate(bx: &Builder, val: ValueRef) -> ValueRef {\n+pub fn from_immediate(bx: &Builder<'_, 'll, '_>, val: &'ll Value) -> &'ll Value {\n     if val_ty(val) == Type::i1(bx.cx) {\n         bx.zext(val, Type::i8(bx.cx))\n     } else {\n         val\n     }\n }\n \n-pub fn to_immediate(bx: &Builder, val: ValueRef, layout: layout::TyLayout) -> ValueRef {\n+pub fn to_immediate(\n+    bx: &Builder<'_, 'll, '_>,\n+    val: &'ll Value,\n+    layout: layout::TyLayout,\n+) -> &'ll Value {\n     if let layout::Abi::Scalar(ref scalar) = layout.abi {\n         return to_immediate_scalar(bx, val, scalar);\n     }\n     val\n }\n \n-pub fn to_immediate_scalar(bx: &Builder, val: ValueRef, scalar: &layout::Scalar) -> ValueRef {\n+pub fn to_immediate_scalar(\n+    bx: &Builder<'_, 'll, '_>,\n+    val: &'ll Value,\n+    scalar: &layout::Scalar,\n+) -> &'ll Value {\n     if scalar.is_bool() {\n         return bx.trunc(val, Type::i1(bx.cx));\n     }\n     val\n }\n \n-pub fn call_memcpy(bx: &Builder,\n-                   dst: ValueRef,\n-                   src: ValueRef,\n-                   n_bytes: ValueRef,\n-                   align: Align,\n-                   flags: MemFlags) {\n+pub fn call_memcpy(\n+    bx: &Builder<'_, 'll, '_>,\n+    dst: &'ll Value,\n+    src: &'ll Value,\n+    n_bytes: &'ll Value,\n+    align: Align,\n+    flags: MemFlags,\n+) {\n     if flags.contains(MemFlags::NONTEMPORAL) {\n         // HACK(nox): This is inefficient but there is no nontemporal memcpy.\n         let val = bx.load(src, align);\n@@ -431,10 +444,10 @@ pub fn call_memcpy(bx: &Builder,\n     bx.call(memcpy, &[dst_ptr, src_ptr, size, align, volatile], None);\n }\n \n-pub fn memcpy_ty<'a, 'tcx>(\n-    bx: &Builder<'a, 'tcx>,\n-    dst: ValueRef,\n-    src: ValueRef,\n+pub fn memcpy_ty(\n+    bx: &Builder<'_, 'll, 'tcx>,\n+    dst: &'ll Value,\n+    src: &'ll Value,\n     layout: TyLayout<'tcx>,\n     align: Align,\n     flags: MemFlags,\n@@ -447,12 +460,14 @@ pub fn memcpy_ty<'a, 'tcx>(\n     call_memcpy(bx, dst, src, C_usize(bx.cx, size), align, flags);\n }\n \n-pub fn call_memset<'a, 'tcx>(bx: &Builder<'a, 'tcx>,\n-                             ptr: ValueRef,\n-                             fill_byte: ValueRef,\n-                             size: ValueRef,\n-                             align: ValueRef,\n-                             volatile: bool) -> ValueRef {\n+pub fn call_memset(\n+    bx: &Builder<'_, 'll, '_>,\n+    ptr: &'ll Value,\n+    fill_byte: &'ll Value,\n+    size: &'ll Value,\n+    align: &'ll Value,\n+    volatile: bool,\n+) -> &'ll Value {\n     let ptr_width = &bx.cx.sess().target.target.target_pointer_width;\n     let intrinsic_key = format!(\"llvm.memset.p0i8.i{}\", ptr_width);\n     let llintrinsicfn = bx.cx.get_intrinsic(&intrinsic_key);\n@@ -511,7 +526,7 @@ pub fn codegen_instance<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, instance: Instance<'\n     mir::codegen_mir(cx, lldecl, &mir, instance, sig);\n }\n \n-pub fn set_link_section(llval: ValueRef, attrs: &CodegenFnAttrs) {\n+pub fn set_link_section(llval: &Value, attrs: &CodegenFnAttrs) {\n     let sect = match attrs.link_section {\n         Some(name) => name,\n         None => return,\n@@ -549,12 +564,14 @@ fn maybe_create_entry_wrapper(cx: &CodegenCx) {\n         None => {}    // Do nothing.\n     }\n \n-    fn create_entry_fn<'cx>(cx: &'cx CodegenCx,\n-                       sp: Span,\n-                       rust_main: ValueRef,\n-                       rust_main_def_id: DefId,\n-                       use_start_lang_item: bool) {\n-        let llfty = Type::func(&[Type::c_int(cx), Type::i8p(cx).ptr_to()], &Type::c_int(cx));\n+    fn create_entry_fn(\n+        cx: &CodegenCx<'ll, '_>,\n+        sp: Span,\n+        rust_main: &'ll Value,\n+        rust_main_def_id: DefId,\n+        use_start_lang_item: bool,\n+    ) {\n+        let llfty = Type::func(&[Type::c_int(cx), Type::i8p(cx).ptr_to()], Type::c_int(cx));\n \n         let main_ret_ty = cx.tcx.fn_sig(rust_main_def_id).output();\n         // Given that `main()` has no arguments,\n@@ -609,16 +626,14 @@ fn maybe_create_entry_wrapper(cx: &CodegenCx) {\n }\n \n fn write_metadata<'a, 'gcx>(tcx: TyCtxt<'a, 'gcx, 'gcx>,\n-                            llmod_id: &str,\n+                            llvm_module: &ModuleLlvm,\n                             link_meta: &LinkMeta)\n-                            -> (ContextRef, ModuleRef, EncodedMetadata) {\n+                            -> EncodedMetadata {\n     use std::io::Write;\n     use flate2::Compression;\n     use flate2::write::DeflateEncoder;\n \n-    let (metadata_llcx, metadata_llmod) = unsafe {\n-        context::create_context_and_module(tcx.sess, llmod_id)\n-    };\n+    let (metadata_llcx, metadata_llmod) = (&*llvm_module.llcx, llvm_module.llmod());\n \n     #[derive(PartialEq, Eq, PartialOrd, Ord)]\n     enum MetadataKind {\n@@ -641,14 +656,12 @@ fn write_metadata<'a, 'gcx>(tcx: TyCtxt<'a, 'gcx, 'gcx>,\n     }).max().unwrap_or(MetadataKind::None);\n \n     if kind == MetadataKind::None {\n-        return (metadata_llcx,\n-                metadata_llmod,\n-                EncodedMetadata::new());\n+        return EncodedMetadata::new();\n     }\n \n     let metadata = tcx.encode_metadata(link_meta);\n     if kind == MetadataKind::Uncompressed {\n-        return (metadata_llcx, metadata_llmod, metadata);\n+        return metadata;\n     }\n \n     assert!(kind == MetadataKind::Compressed);\n@@ -661,7 +674,7 @@ fn write_metadata<'a, 'gcx>(tcx: TyCtxt<'a, 'gcx, 'gcx>,\n     let name = exported_symbols::metadata_symbol_name(tcx);\n     let buf = CString::new(name).unwrap();\n     let llglobal = unsafe {\n-        llvm::LLVMAddGlobal(metadata_llmod, val_ty(llconst).to_ref(), buf.as_ptr())\n+        llvm::LLVMAddGlobal(metadata_llmod, val_ty(llconst), buf.as_ptr())\n     };\n     unsafe {\n         llvm::LLVMSetInitializer(llglobal, llconst);\n@@ -676,29 +689,27 @@ fn write_metadata<'a, 'gcx>(tcx: TyCtxt<'a, 'gcx, 'gcx>,\n         let directive = CString::new(directive).unwrap();\n         llvm::LLVMSetModuleInlineAsm(metadata_llmod, directive.as_ptr())\n     }\n-    return (metadata_llcx, metadata_llmod, metadata);\n+    return metadata;\n }\n \n-pub struct ValueIter {\n-    cur: ValueRef,\n-    step: unsafe extern \"C\" fn(ValueRef) -> ValueRef,\n+pub struct ValueIter<'ll> {\n+    cur: Option<&'ll Value>,\n+    step: unsafe extern \"C\" fn(&'ll Value) -> Option<&'ll Value>,\n }\n \n-impl Iterator for ValueIter {\n-    type Item = ValueRef;\n+impl Iterator for ValueIter<'ll> {\n+    type Item = &'ll Value;\n \n-    fn next(&mut self) -> Option<ValueRef> {\n+    fn next(&mut self) -> Option<&'ll Value> {\n         let old = self.cur;\n-        if !old.is_null() {\n+        if let Some(old) = old {\n             self.cur = unsafe { (self.step)(old) };\n-            Some(old)\n-        } else {\n-            None\n         }\n+        old\n     }\n }\n \n-pub fn iter_globals(llmod: llvm::ModuleRef) -> ValueIter {\n+pub fn iter_globals(llmod: &'ll llvm::Module) -> ValueIter<'ll> {\n     unsafe {\n         ValueIter {\n             cur: llvm::LLVMGetFirstGlobal(llmod),\n@@ -731,19 +742,15 @@ pub fn codegen_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     // Codegen the metadata.\n     let llmod_id = \"metadata\";\n-    let (metadata_llcx, metadata_llmod, metadata) =\n-        time(tcx.sess, \"write metadata\", || {\n-            write_metadata(tcx, llmod_id, &link_meta)\n-        });\n+    let metadata_llvm_module = ModuleLlvm::new(tcx.sess, llmod_id);\n+    let metadata = time(tcx.sess, \"write metadata\", || {\n+        write_metadata(tcx, &metadata_llvm_module, &link_meta)\n+    });\n \n     let metadata_module = ModuleCodegen {\n         name: link::METADATA_MODULE_NAME.to_string(),\n         llmod_id: llmod_id.to_string(),\n-        source: ModuleSource::Codegened(ModuleLlvm {\n-            llcx: metadata_llcx,\n-            llmod: metadata_llmod,\n-            tm: create_target_machine(tcx.sess, false),\n-        }),\n+        source: ModuleSource::Codegened(metadata_llvm_module),\n         kind: ModuleKind::Metadata,\n     };\n \n@@ -803,13 +810,7 @@ pub fn codegen_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let allocator_module = if let Some(kind) = *tcx.sess.allocator_kind.get() {\n         unsafe {\n             let llmod_id = \"allocator\";\n-            let (llcx, llmod) =\n-                context::create_context_and_module(tcx.sess, llmod_id);\n-            let modules = ModuleLlvm {\n-                llmod,\n-                llcx,\n-                tm: create_target_machine(tcx.sess, false),\n-            };\n+            let modules = ModuleLlvm::new(tcx.sess, llmod_id);\n             time(tcx.sess, \"write allocator module\", || {\n                 allocator::codegen(tcx, &modules, kind)\n             });\n@@ -1200,8 +1201,9 @@ fn compile_codegen_unit<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                    .to_fingerprint().to_hex());\n \n         // Instantiate monomorphizations without filling out definitions yet...\n-        let cx = CodegenCx::new(tcx, cgu, &llmod_id);\n-        let module = {\n+        let llvm_module = ModuleLlvm::new(tcx.sess, &llmod_id);\n+        let stats = {\n+            let cx = CodegenCx::new(tcx, cgu, &llvm_module);\n             let mono_items = cx.codegen_unit\n                                  .items_in_deterministic_order(cx.tcx);\n             for &(mono_item, (linkage, visibility)) in &mono_items {\n@@ -1220,7 +1222,7 @@ fn compile_codegen_unit<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             // Run replace-all-uses-with for statics that need it\n             for &(old_g, new_g) in cx.statics_to_rauw.borrow().iter() {\n                 unsafe {\n-                    let bitcast = llvm::LLVMConstPointerCast(new_g, llvm::LLVMTypeOf(old_g));\n+                    let bitcast = llvm::LLVMConstPointerCast(new_g, val_ty(old_g));\n                     llvm::LLVMReplaceAllUsesWith(old_g, bitcast);\n                     llvm::LLVMDeleteGlobal(old_g);\n                 }\n@@ -1235,7 +1237,7 @@ fn compile_codegen_unit<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n                 unsafe {\n                     let g = llvm::LLVMAddGlobal(cx.llmod,\n-                                                val_ty(array).to_ref(),\n+                                                val_ty(array),\n                                                 name.as_ptr());\n                     llvm::LLVMSetInitializer(g, array);\n                     llvm::LLVMRustSetLinkage(g, llvm::Linkage::AppendingLinkage);\n@@ -1248,21 +1250,15 @@ fn compile_codegen_unit<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 debuginfo::finalize(&cx);\n             }\n \n-            let llvm_module = ModuleLlvm {\n-                llcx: cx.llcx,\n-                llmod: cx.llmod,\n-                tm: create_target_machine(cx.sess(), false),\n-            };\n-\n-            ModuleCodegen {\n-                name: cgu_name,\n-                source: ModuleSource::Codegened(llvm_module),\n-                kind: ModuleKind::Regular,\n-                llmod_id,\n-            }\n+            cx.stats.into_inner()\n         };\n \n-        (cx.into_stats(), module)\n+        (stats, ModuleCodegen {\n+            name: cgu_name,\n+            source: ModuleSource::Codegened(llvm_module),\n+            kind: ModuleKind::Regular,\n+            llmod_id,\n+        })\n     }\n }\n "}, {"sha": "b174cd8c7ac764d9832858e0dfaf08853afea631", "filename": "src/librustc_codegen_llvm/builder.rs", "status": "modified", "additions": 240, "deletions": 459, "changes": 699, "blob_url": "https://github.com/rust-lang/rust/blob/f89817997ac0aa100bf91997194ad85a7e59f743/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f89817997ac0aa100bf91997194ad85a7e59f743/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbuilder.rs?ref=f89817997ac0aa100bf91997194ad85a7e59f743", "patch": "@@ -8,12 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![allow(dead_code)] // FFI wrappers\n-\n-use llvm;\n use llvm::{AtomicRmwBinOp, AtomicOrdering, SynchronizationScope, AsmDialect};\n-use llvm::{Opcode, IntPredicate, RealPredicate, False, OperandBundleDef};\n-use llvm::{ValueRef, BasicBlockRef, BuilderRef};\n+use llvm::{IntPredicate, RealPredicate, False, OperandBundleDef};\n+use llvm::{self, BasicBlock};\n use common::*;\n use type_::Type;\n use value::Value;\n@@ -26,19 +23,18 @@ use std::borrow::Cow;\n use std::ffi::CString;\n use std::ops::Range;\n use std::ptr;\n-use syntax_pos::Span;\n \n // All Builders must have an llfn associated with them\n #[must_use]\n-pub struct Builder<'a, 'tcx: 'a> {\n-    pub llbuilder: BuilderRef,\n-    pub cx: &'a CodegenCx<'a, 'tcx>,\n+pub struct Builder<'a, 'll: 'a, 'tcx: 'll> {\n+    pub llbuilder: &'ll mut llvm::Builder<'ll>,\n+    pub cx: &'a CodegenCx<'ll, 'tcx>,\n }\n \n-impl<'a, 'tcx> Drop for Builder<'a, 'tcx> {\n+impl Drop for Builder<'a, 'll, 'tcx> {\n     fn drop(&mut self) {\n         unsafe {\n-            llvm::LLVMDisposeBuilder(self.llbuilder);\n+            llvm::LLVMDisposeBuilder(&mut *(self.llbuilder as *mut _));\n         }\n     }\n }\n@@ -58,8 +54,8 @@ bitflags! {\n     }\n }\n \n-impl<'a, 'tcx> Builder<'a, 'tcx> {\n-    pub fn new_block<'b>(cx: &'a CodegenCx<'a, 'tcx>, llfn: ValueRef, name: &'b str) -> Self {\n+impl Builder<'a, 'll, 'tcx> {\n+    pub fn new_block<'b>(cx: &'a CodegenCx<'ll, 'tcx>, llfn: &'ll Value, name: &'b str) -> Self {\n         let bx = Builder::with_cx(cx);\n         let llbb = unsafe {\n             let name = CString::new(name).unwrap();\n@@ -73,7 +69,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         bx\n     }\n \n-    pub fn with_cx(cx: &'a CodegenCx<'a, 'tcx>) -> Self {\n+    pub fn with_cx(cx: &'a CodegenCx<'ll, 'tcx>) -> Self {\n         // Create a fresh builder from the crate context.\n         let llbuilder = unsafe {\n             llvm::LLVMCreateBuilderInContext(cx.llcx)\n@@ -84,7 +80,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n     }\n \n-    pub fn build_sibling_block<'b>(&self, name: &'b str) -> Builder<'a, 'tcx> {\n+    pub fn build_sibling_block<'b>(&self, name: &'b str) -> Builder<'a, 'll, 'tcx> {\n         Builder::new_block(self.cx, self.llfn(), name)\n     }\n \n@@ -96,13 +92,13 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         self.cx.tcx\n     }\n \n-    pub fn llfn(&self) -> ValueRef {\n+    pub fn llfn(&self) -> &'ll Value {\n         unsafe {\n             llvm::LLVMGetBasicBlockParent(self.llbb())\n         }\n     }\n \n-    pub fn llbb(&self) -> BasicBlockRef {\n+    pub fn llbb(&self) -> &'ll BasicBlock {\n         unsafe {\n             llvm::LLVMGetInsertBlock(self.llbuilder)\n         }\n@@ -121,26 +117,20 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n     }\n \n-    pub fn set_value_name(&self, value: ValueRef, name: &str) {\n+    pub fn set_value_name(&self, value: &'ll Value, name: &str) {\n         let cname = CString::new(name.as_bytes()).unwrap();\n         unsafe {\n             llvm::LLVMSetValueName(value, cname.as_ptr());\n         }\n     }\n \n-    pub fn position_before(&self, insn: ValueRef) {\n-        unsafe {\n-            llvm::LLVMPositionBuilderBefore(self.llbuilder, insn);\n-        }\n-    }\n-\n-    pub fn position_at_end(&self, llbb: BasicBlockRef) {\n+    pub fn position_at_end(&self, llbb: &'ll BasicBlock) {\n         unsafe {\n             llvm::LLVMPositionBuilderAtEnd(self.llbuilder, llbb);\n         }\n     }\n \n-    pub fn position_at_start(&self, llbb: BasicBlockRef) {\n+    pub fn position_at_start(&self, llbb: &'ll BasicBlock) {\n         unsafe {\n             llvm::LLVMRustPositionBuilderAtStart(self.llbuilder, llbb);\n         }\n@@ -153,65 +143,57 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n     }\n \n-    pub fn ret(&self, v: ValueRef) {\n+    pub fn ret(&self, v: &'ll Value) {\n         self.count_insn(\"ret\");\n         unsafe {\n             llvm::LLVMBuildRet(self.llbuilder, v);\n         }\n     }\n \n-    pub fn aggregate_ret(&self, ret_vals: &[ValueRef]) {\n-        unsafe {\n-            llvm::LLVMBuildAggregateRet(self.llbuilder,\n-                                        ret_vals.as_ptr(),\n-                                        ret_vals.len() as c_uint);\n-        }\n-    }\n-\n-    pub fn br(&self, dest: BasicBlockRef) {\n+    pub fn br(&self, dest: &'ll BasicBlock) {\n         self.count_insn(\"br\");\n         unsafe {\n             llvm::LLVMBuildBr(self.llbuilder, dest);\n         }\n     }\n \n-    pub fn cond_br(&self, cond: ValueRef, then_llbb: BasicBlockRef, else_llbb: BasicBlockRef) {\n+    pub fn cond_br(\n+        &self,\n+        cond: &'ll Value,\n+        then_llbb: &'ll BasicBlock,\n+        else_llbb: &'ll BasicBlock,\n+    ) {\n         self.count_insn(\"condbr\");\n         unsafe {\n             llvm::LLVMBuildCondBr(self.llbuilder, cond, then_llbb, else_llbb);\n         }\n     }\n \n-    pub fn switch(&self, v: ValueRef, else_llbb: BasicBlockRef, num_cases: usize) -> ValueRef {\n+    pub fn switch(\n+        &self,\n+        v: &'ll Value,\n+        else_llbb: &'ll BasicBlock,\n+        num_cases: usize,\n+    ) -> &'ll Value {\n         unsafe {\n             llvm::LLVMBuildSwitch(self.llbuilder, v, else_llbb, num_cases as c_uint)\n         }\n     }\n \n-    pub fn indirect_br(&self, addr: ValueRef, num_dests: usize) {\n-        self.count_insn(\"indirectbr\");\n-        unsafe {\n-            llvm::LLVMBuildIndirectBr(self.llbuilder, addr, num_dests as c_uint);\n-        }\n-    }\n-\n     pub fn invoke(&self,\n-                  llfn: ValueRef,\n-                  args: &[ValueRef],\n-                  then: BasicBlockRef,\n-                  catch: BasicBlockRef,\n-                  bundle: Option<&OperandBundleDef>) -> ValueRef {\n+                  llfn: &'ll Value,\n+                  args: &[&'ll Value],\n+                  then: &'ll BasicBlock,\n+                  catch: &'ll BasicBlock,\n+                  bundle: Option<&OperandBundleDef<'ll>>) -> &'ll Value {\n         self.count_insn(\"invoke\");\n \n-        debug!(\"Invoke {:?} with args ({})\",\n-               Value(llfn),\n-               args.iter()\n-                   .map(|&v| format!(\"{:?}\", Value(v)))\n-                   .collect::<Vec<String>>()\n-                   .join(\", \"));\n+        debug!(\"Invoke {:?} with args ({:?})\",\n+               llfn,\n+               args);\n \n         let args = self.check_call(\"invoke\", llfn, args);\n-        let bundle = bundle.as_ref().map(|b| b.raw()).unwrap_or(ptr::null_mut());\n+        let bundle = bundle.map(|b| &*b.raw);\n \n         unsafe {\n             llvm::LLVMRustBuildInvoke(self.llbuilder,\n@@ -233,35 +215,21 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     }\n \n     /* Arithmetic */\n-    pub fn add(&self, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+    pub fn add(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"add\");\n         unsafe {\n             llvm::LLVMBuildAdd(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n-    pub fn nswadd(&self, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n-        self.count_insn(\"nswadd\");\n-        unsafe {\n-            llvm::LLVMBuildNSWAdd(self.llbuilder, lhs, rhs, noname())\n-        }\n-    }\n-\n-    pub fn nuwadd(&self, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n-        self.count_insn(\"nuwadd\");\n-        unsafe {\n-            llvm::LLVMBuildNUWAdd(self.llbuilder, lhs, rhs, noname())\n-        }\n-    }\n-\n-    pub fn fadd(&self, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+    pub fn fadd(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"fadd\");\n         unsafe {\n             llvm::LLVMBuildFAdd(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n-    pub fn fadd_fast(&self, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+    pub fn fadd_fast(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"fadd\");\n         unsafe {\n             let instr = llvm::LLVMBuildFAdd(self.llbuilder, lhs, rhs, noname());\n@@ -270,35 +238,21 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n     }\n \n-    pub fn sub(&self, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+    pub fn sub(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"sub\");\n         unsafe {\n             llvm::LLVMBuildSub(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n-    pub fn nswsub(&self, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n-        self.count_insn(\"nswsub\");\n-        unsafe {\n-            llvm::LLVMBuildNSWSub(self.llbuilder, lhs, rhs, noname())\n-        }\n-    }\n-\n-    pub fn nuwsub(&self, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n-        self.count_insn(\"nuwsub\");\n-        unsafe {\n-            llvm::LLVMBuildNUWSub(self.llbuilder, lhs, rhs, noname())\n-        }\n-    }\n-\n-    pub fn fsub(&self, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+    pub fn fsub(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"fsub\");\n         unsafe {\n             llvm::LLVMBuildFSub(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n-    pub fn fsub_fast(&self, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+    pub fn fsub_fast(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"fsub\");\n         unsafe {\n             let instr = llvm::LLVMBuildFSub(self.llbuilder, lhs, rhs, noname());\n@@ -307,35 +261,21 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n     }\n \n-    pub fn mul(&self, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+    pub fn mul(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"mul\");\n         unsafe {\n             llvm::LLVMBuildMul(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n-    pub fn nswmul(&self, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n-        self.count_insn(\"nswmul\");\n-        unsafe {\n-            llvm::LLVMBuildNSWMul(self.llbuilder, lhs, rhs, noname())\n-        }\n-    }\n-\n-    pub fn nuwmul(&self, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n-        self.count_insn(\"nuwmul\");\n-        unsafe {\n-            llvm::LLVMBuildNUWMul(self.llbuilder, lhs, rhs, noname())\n-        }\n-    }\n-\n-    pub fn fmul(&self, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+    pub fn fmul(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"fmul\");\n         unsafe {\n             llvm::LLVMBuildFMul(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n-    pub fn fmul_fast(&self, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+    pub fn fmul_fast(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"fmul\");\n         unsafe {\n             let instr = llvm::LLVMBuildFMul(self.llbuilder, lhs, rhs, noname());\n@@ -345,42 +285,42 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     }\n \n \n-    pub fn udiv(&self, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+    pub fn udiv(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"udiv\");\n         unsafe {\n             llvm::LLVMBuildUDiv(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n-    pub fn exactudiv(&self, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+    pub fn exactudiv(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"exactudiv\");\n         unsafe {\n             llvm::LLVMBuildExactUDiv(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n-    pub fn sdiv(&self, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+    pub fn sdiv(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"sdiv\");\n         unsafe {\n             llvm::LLVMBuildSDiv(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n-    pub fn exactsdiv(&self, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+    pub fn exactsdiv(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"exactsdiv\");\n         unsafe {\n             llvm::LLVMBuildExactSDiv(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n-    pub fn fdiv(&self, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+    pub fn fdiv(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"fdiv\");\n         unsafe {\n             llvm::LLVMBuildFDiv(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n-    pub fn fdiv_fast(&self, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+    pub fn fdiv_fast(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"fdiv\");\n         unsafe {\n             let instr = llvm::LLVMBuildFDiv(self.llbuilder, lhs, rhs, noname());\n@@ -389,28 +329,28 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n     }\n \n-    pub fn urem(&self, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+    pub fn urem(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"urem\");\n         unsafe {\n             llvm::LLVMBuildURem(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n-    pub fn srem(&self, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+    pub fn srem(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"srem\");\n         unsafe {\n             llvm::LLVMBuildSRem(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n-    pub fn frem(&self, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+    pub fn frem(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"frem\");\n         unsafe {\n             llvm::LLVMBuildFRem(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n-    pub fn frem_fast(&self, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+    pub fn frem_fast(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"frem\");\n         unsafe {\n             let instr = llvm::LLVMBuildFRem(self.llbuilder, lhs, rhs, noname());\n@@ -419,121 +359,93 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n     }\n \n-    pub fn shl(&self, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+    pub fn shl(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"shl\");\n         unsafe {\n             llvm::LLVMBuildShl(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n-    pub fn lshr(&self, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+    pub fn lshr(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"lshr\");\n         unsafe {\n             llvm::LLVMBuildLShr(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n-    pub fn ashr(&self, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+    pub fn ashr(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"ashr\");\n         unsafe {\n             llvm::LLVMBuildAShr(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n-    pub fn and(&self, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+    pub fn and(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"and\");\n         unsafe {\n             llvm::LLVMBuildAnd(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n-    pub fn or(&self, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+    pub fn or(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"or\");\n         unsafe {\n             llvm::LLVMBuildOr(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n-    pub fn xor(&self, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+    pub fn xor(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"xor\");\n         unsafe {\n             llvm::LLVMBuildXor(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n-    pub fn binop(&self, op: Opcode, lhs: ValueRef, rhs: ValueRef)\n-              -> ValueRef {\n-        self.count_insn(\"binop\");\n-        unsafe {\n-            llvm::LLVMBuildBinOp(self.llbuilder, op, lhs, rhs, noname())\n-        }\n-    }\n-\n-    pub fn neg(&self, v: ValueRef) -> ValueRef {\n+    pub fn neg(&self, v: &'ll Value) -> &'ll Value {\n         self.count_insn(\"neg\");\n         unsafe {\n             llvm::LLVMBuildNeg(self.llbuilder, v, noname())\n         }\n     }\n \n-    pub fn nswneg(&self, v: ValueRef) -> ValueRef {\n-        self.count_insn(\"nswneg\");\n-        unsafe {\n-            llvm::LLVMBuildNSWNeg(self.llbuilder, v, noname())\n-        }\n-    }\n-\n-    pub fn nuwneg(&self, v: ValueRef) -> ValueRef {\n-        self.count_insn(\"nuwneg\");\n-        unsafe {\n-            llvm::LLVMBuildNUWNeg(self.llbuilder, v, noname())\n-        }\n-    }\n-    pub fn fneg(&self, v: ValueRef) -> ValueRef {\n+    pub fn fneg(&self, v: &'ll Value) -> &'ll Value {\n         self.count_insn(\"fneg\");\n         unsafe {\n             llvm::LLVMBuildFNeg(self.llbuilder, v, noname())\n         }\n     }\n \n-    pub fn not(&self, v: ValueRef) -> ValueRef {\n+    pub fn not(&self, v: &'ll Value) -> &'ll Value {\n         self.count_insn(\"not\");\n         unsafe {\n             llvm::LLVMBuildNot(self.llbuilder, v, noname())\n         }\n     }\n \n-    pub fn alloca(&self, ty: Type, name: &str, align: Align) -> ValueRef {\n+    pub fn alloca(&self, ty: &'ll Type, name: &str, align: Align) -> &'ll Value {\n         let bx = Builder::with_cx(self.cx);\n         bx.position_at_start(unsafe {\n             llvm::LLVMGetFirstBasicBlock(self.llfn())\n         });\n         bx.dynamic_alloca(ty, name, align)\n     }\n \n-    pub fn dynamic_alloca(&self, ty: Type, name: &str, align: Align) -> ValueRef {\n+    pub fn dynamic_alloca(&self, ty: &'ll Type, name: &str, align: Align) -> &'ll Value {\n         self.count_insn(\"alloca\");\n         unsafe {\n             let alloca = if name.is_empty() {\n-                llvm::LLVMBuildAlloca(self.llbuilder, ty.to_ref(), noname())\n+                llvm::LLVMBuildAlloca(self.llbuilder, ty, noname())\n             } else {\n                 let name = CString::new(name).unwrap();\n-                llvm::LLVMBuildAlloca(self.llbuilder, ty.to_ref(),\n+                llvm::LLVMBuildAlloca(self.llbuilder, ty,\n                                       name.as_ptr())\n             };\n             llvm::LLVMSetAlignment(alloca, align.abi() as c_uint);\n             alloca\n         }\n     }\n \n-    pub fn free(&self, ptr: ValueRef) {\n-        self.count_insn(\"free\");\n-        unsafe {\n-            llvm::LLVMBuildFree(self.llbuilder, ptr);\n-        }\n-    }\n-\n-    pub fn load(&self, ptr: ValueRef, align: Align) -> ValueRef {\n+    pub fn load(&self, ptr: &'ll Value, align: Align) -> &'ll Value {\n         self.count_insn(\"load\");\n         unsafe {\n             let load = llvm::LLVMBuildLoad(self.llbuilder, ptr, noname());\n@@ -542,7 +454,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n     }\n \n-    pub fn volatile_load(&self, ptr: ValueRef) -> ValueRef {\n+    pub fn volatile_load(&self, ptr: &'ll Value) -> &'ll Value {\n         self.count_insn(\"load.volatile\");\n         unsafe {\n             let insn = llvm::LLVMBuildLoad(self.llbuilder, ptr, noname());\n@@ -551,7 +463,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n     }\n \n-    pub fn atomic_load(&self, ptr: ValueRef, order: AtomicOrdering, align: Align) -> ValueRef {\n+    pub fn atomic_load(&self, ptr: &'ll Value, order: AtomicOrdering, align: Align) -> &'ll Value {\n         self.count_insn(\"load.atomic\");\n         unsafe {\n             let load = llvm::LLVMRustBuildAtomicLoad(self.llbuilder, ptr, noname(), order);\n@@ -564,7 +476,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     }\n \n \n-    pub fn range_metadata(&self, load: ValueRef, range: Range<u128>) {\n+    pub fn range_metadata(&self, load: &'ll Value, range: Range<u128>) {\n         unsafe {\n             let llty = val_ty(load);\n             let v = [\n@@ -579,26 +491,25 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n     }\n \n-    pub fn nonnull_metadata(&self, load: ValueRef) {\n+    pub fn nonnull_metadata(&self, load: &'ll Value) {\n         unsafe {\n             llvm::LLVMSetMetadata(load, llvm::MD_nonnull as c_uint,\n                                   llvm::LLVMMDNodeInContext(self.cx.llcx, ptr::null(), 0));\n         }\n     }\n \n-    pub fn store(&self, val: ValueRef, ptr: ValueRef, align: Align) -> ValueRef {\n+    pub fn store(&self, val: &'ll Value, ptr: &'ll Value, align: Align) -> &'ll Value {\n         self.store_with_flags(val, ptr, align, MemFlags::empty())\n     }\n \n     pub fn store_with_flags(\n         &self,\n-        val: ValueRef,\n-        ptr: ValueRef,\n+        val: &'ll Value,\n+        ptr: &'ll Value,\n         align: Align,\n         flags: MemFlags,\n-    ) -> ValueRef {\n-        debug!(\"Store {:?} -> {:?} ({:?})\", Value(val), Value(ptr), flags);\n-        assert!(!self.llbuilder.is_null());\n+    ) -> &'ll Value {\n+        debug!(\"Store {:?} -> {:?} ({:?})\", val, ptr, flags);\n         self.count_insn(\"store\");\n         let ptr = self.check_store(val, ptr);\n         unsafe {\n@@ -625,9 +536,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n     }\n \n-    pub fn atomic_store(&self, val: ValueRef, ptr: ValueRef,\n+    pub fn atomic_store(&self, val: &'ll Value, ptr: &'ll Value,\n                         order: AtomicOrdering, align: Align) {\n-        debug!(\"Store {:?} -> {:?}\", Value(val), Value(ptr));\n+        debug!(\"Store {:?} -> {:?}\", val, ptr);\n         self.count_insn(\"store.atomic\");\n         let ptr = self.check_store(val, ptr);\n         unsafe {\n@@ -638,203 +549,153 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n     }\n \n-    pub fn gep(&self, ptr: ValueRef, indices: &[ValueRef]) -> ValueRef {\n+    pub fn gep(&self, ptr: &'ll Value, indices: &[&'ll Value]) -> &'ll Value {\n         self.count_insn(\"gep\");\n         unsafe {\n             llvm::LLVMBuildGEP(self.llbuilder, ptr, indices.as_ptr(),\n                                indices.len() as c_uint, noname())\n         }\n     }\n \n-    pub fn inbounds_gep(&self, ptr: ValueRef, indices: &[ValueRef]) -> ValueRef {\n+    pub fn inbounds_gep(&self, ptr: &'ll Value, indices: &[&'ll Value]) -> &'ll Value {\n         self.count_insn(\"inboundsgep\");\n         unsafe {\n             llvm::LLVMBuildInBoundsGEP(\n                 self.llbuilder, ptr, indices.as_ptr(), indices.len() as c_uint, noname())\n         }\n     }\n \n-    pub fn struct_gep(&self, ptr: ValueRef, idx: u64) -> ValueRef {\n+    pub fn struct_gep(&self, ptr: &'ll Value, idx: u64) -> &'ll Value {\n         self.count_insn(\"structgep\");\n         assert_eq!(idx as c_uint as u64, idx);\n         unsafe {\n             llvm::LLVMBuildStructGEP(self.llbuilder, ptr, idx as c_uint, noname())\n         }\n     }\n \n-    pub fn global_string(&self, _str: *const c_char) -> ValueRef {\n-        self.count_insn(\"globalstring\");\n-        unsafe {\n-            llvm::LLVMBuildGlobalString(self.llbuilder, _str, noname())\n-        }\n-    }\n-\n-    pub fn global_string_ptr(&self, _str: *const c_char) -> ValueRef {\n-        self.count_insn(\"globalstringptr\");\n-        unsafe {\n-            llvm::LLVMBuildGlobalStringPtr(self.llbuilder, _str, noname())\n-        }\n-    }\n-\n     /* Casts */\n-    pub fn trunc(&self, val: ValueRef, dest_ty: Type) -> ValueRef {\n+    pub fn trunc(&self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n         self.count_insn(\"trunc\");\n         unsafe {\n-            llvm::LLVMBuildTrunc(self.llbuilder, val, dest_ty.to_ref(), noname())\n+            llvm::LLVMBuildTrunc(self.llbuilder, val, dest_ty, noname())\n         }\n     }\n \n-    pub fn zext(&self, val: ValueRef, dest_ty: Type) -> ValueRef {\n+    pub fn zext(&self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n         self.count_insn(\"zext\");\n         unsafe {\n-            llvm::LLVMBuildZExt(self.llbuilder, val, dest_ty.to_ref(), noname())\n+            llvm::LLVMBuildZExt(self.llbuilder, val, dest_ty, noname())\n         }\n     }\n \n-    pub fn sext(&self, val: ValueRef, dest_ty: Type) -> ValueRef {\n+    pub fn sext(&self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n         self.count_insn(\"sext\");\n         unsafe {\n-            llvm::LLVMBuildSExt(self.llbuilder, val, dest_ty.to_ref(), noname())\n+            llvm::LLVMBuildSExt(self.llbuilder, val, dest_ty, noname())\n         }\n     }\n \n-    pub fn fptoui(&self, val: ValueRef, dest_ty: Type) -> ValueRef {\n+    pub fn fptoui(&self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n         self.count_insn(\"fptoui\");\n         unsafe {\n-            llvm::LLVMBuildFPToUI(self.llbuilder, val, dest_ty.to_ref(), noname())\n+            llvm::LLVMBuildFPToUI(self.llbuilder, val, dest_ty, noname())\n         }\n     }\n \n-    pub fn fptosi(&self, val: ValueRef, dest_ty: Type) -> ValueRef {\n+    pub fn fptosi(&self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n         self.count_insn(\"fptosi\");\n         unsafe {\n-            llvm::LLVMBuildFPToSI(self.llbuilder, val, dest_ty.to_ref(),noname())\n+            llvm::LLVMBuildFPToSI(self.llbuilder, val, dest_ty,noname())\n         }\n     }\n \n-    pub fn uitofp(&self, val: ValueRef, dest_ty: Type) -> ValueRef {\n+    pub fn uitofp(&self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n         self.count_insn(\"uitofp\");\n         unsafe {\n-            llvm::LLVMBuildUIToFP(self.llbuilder, val, dest_ty.to_ref(), noname())\n+            llvm::LLVMBuildUIToFP(self.llbuilder, val, dest_ty, noname())\n         }\n     }\n \n-    pub fn sitofp(&self, val: ValueRef, dest_ty: Type) -> ValueRef {\n+    pub fn sitofp(&self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n         self.count_insn(\"sitofp\");\n         unsafe {\n-            llvm::LLVMBuildSIToFP(self.llbuilder, val, dest_ty.to_ref(), noname())\n+            llvm::LLVMBuildSIToFP(self.llbuilder, val, dest_ty, noname())\n         }\n     }\n \n-    pub fn fptrunc(&self, val: ValueRef, dest_ty: Type) -> ValueRef {\n+    pub fn fptrunc(&self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n         self.count_insn(\"fptrunc\");\n         unsafe {\n-            llvm::LLVMBuildFPTrunc(self.llbuilder, val, dest_ty.to_ref(), noname())\n+            llvm::LLVMBuildFPTrunc(self.llbuilder, val, dest_ty, noname())\n         }\n     }\n \n-    pub fn fpext(&self, val: ValueRef, dest_ty: Type) -> ValueRef {\n+    pub fn fpext(&self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n         self.count_insn(\"fpext\");\n         unsafe {\n-            llvm::LLVMBuildFPExt(self.llbuilder, val, dest_ty.to_ref(), noname())\n+            llvm::LLVMBuildFPExt(self.llbuilder, val, dest_ty, noname())\n         }\n     }\n \n-    pub fn ptrtoint(&self, val: ValueRef, dest_ty: Type) -> ValueRef {\n+    pub fn ptrtoint(&self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n         self.count_insn(\"ptrtoint\");\n         unsafe {\n-            llvm::LLVMBuildPtrToInt(self.llbuilder, val, dest_ty.to_ref(), noname())\n+            llvm::LLVMBuildPtrToInt(self.llbuilder, val, dest_ty, noname())\n         }\n     }\n \n-    pub fn inttoptr(&self, val: ValueRef, dest_ty: Type) -> ValueRef {\n+    pub fn inttoptr(&self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n         self.count_insn(\"inttoptr\");\n         unsafe {\n-            llvm::LLVMBuildIntToPtr(self.llbuilder, val, dest_ty.to_ref(), noname())\n+            llvm::LLVMBuildIntToPtr(self.llbuilder, val, dest_ty, noname())\n         }\n     }\n \n-    pub fn bitcast(&self, val: ValueRef, dest_ty: Type) -> ValueRef {\n+    pub fn bitcast(&self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n         self.count_insn(\"bitcast\");\n         unsafe {\n-            llvm::LLVMBuildBitCast(self.llbuilder, val, dest_ty.to_ref(), noname())\n-        }\n-    }\n-\n-    pub fn zext_or_bitcast(&self, val: ValueRef, dest_ty: Type) -> ValueRef {\n-        self.count_insn(\"zextorbitcast\");\n-        unsafe {\n-            llvm::LLVMBuildZExtOrBitCast(self.llbuilder, val, dest_ty.to_ref(), noname())\n+            llvm::LLVMBuildBitCast(self.llbuilder, val, dest_ty, noname())\n         }\n     }\n \n-    pub fn sext_or_bitcast(&self, val: ValueRef, dest_ty: Type) -> ValueRef {\n-        self.count_insn(\"sextorbitcast\");\n-        unsafe {\n-            llvm::LLVMBuildSExtOrBitCast(self.llbuilder, val, dest_ty.to_ref(), noname())\n-        }\n-    }\n-\n-    pub fn trunc_or_bitcast(&self, val: ValueRef, dest_ty: Type) -> ValueRef {\n-        self.count_insn(\"truncorbitcast\");\n-        unsafe {\n-            llvm::LLVMBuildTruncOrBitCast(self.llbuilder, val, dest_ty.to_ref(), noname())\n-        }\n-    }\n-\n-    pub fn cast(&self, op: Opcode, val: ValueRef, dest_ty: Type) -> ValueRef {\n-        self.count_insn(\"cast\");\n-        unsafe {\n-            llvm::LLVMBuildCast(self.llbuilder, op, val, dest_ty.to_ref(), noname())\n-        }\n-    }\n-\n-    pub fn pointercast(&self, val: ValueRef, dest_ty: Type) -> ValueRef {\n+    pub fn pointercast(&self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n         self.count_insn(\"pointercast\");\n         unsafe {\n-            llvm::LLVMBuildPointerCast(self.llbuilder, val, dest_ty.to_ref(), noname())\n+            llvm::LLVMBuildPointerCast(self.llbuilder, val, dest_ty, noname())\n         }\n     }\n \n-    pub fn intcast(&self, val: ValueRef, dest_ty: Type, is_signed: bool) -> ValueRef {\n+    pub fn intcast(&self, val: &'ll Value, dest_ty: &'ll Type, is_signed: bool) -> &'ll Value {\n         self.count_insn(\"intcast\");\n         unsafe {\n-            llvm::LLVMRustBuildIntCast(self.llbuilder, val, dest_ty.to_ref(), is_signed)\n-        }\n-    }\n-\n-    pub fn fpcast(&self, val: ValueRef, dest_ty: Type) -> ValueRef {\n-        self.count_insn(\"fpcast\");\n-        unsafe {\n-            llvm::LLVMBuildFPCast(self.llbuilder, val, dest_ty.to_ref(), noname())\n+            llvm::LLVMRustBuildIntCast(self.llbuilder, val, dest_ty, is_signed)\n         }\n     }\n \n-\n     /* Comparisons */\n-    pub fn icmp(&self, op: IntPredicate, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+    pub fn icmp(&self, op: IntPredicate, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"icmp\");\n         unsafe {\n             llvm::LLVMBuildICmp(self.llbuilder, op as c_uint, lhs, rhs, noname())\n         }\n     }\n \n-    pub fn fcmp(&self, op: RealPredicate, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+    pub fn fcmp(&self, op: RealPredicate, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"fcmp\");\n         unsafe {\n             llvm::LLVMBuildFCmp(self.llbuilder, op as c_uint, lhs, rhs, noname())\n         }\n     }\n \n     /* Miscellaneous instructions */\n-    pub fn empty_phi(&self, ty: Type) -> ValueRef {\n+    pub fn empty_phi(&self, ty: &'ll Type) -> &'ll Value {\n         self.count_insn(\"emptyphi\");\n         unsafe {\n-            llvm::LLVMBuildPhi(self.llbuilder, ty.to_ref(), noname())\n+            llvm::LLVMBuildPhi(self.llbuilder, ty, noname())\n         }\n     }\n \n-    pub fn phi(&self, ty: Type, vals: &[ValueRef], bbs: &[BasicBlockRef]) -> ValueRef {\n+    pub fn phi(&self, ty: &'ll Type, vals: &[&'ll Value], bbs: &[&'ll BasicBlock]) -> &'ll Value {\n         assert_eq!(vals.len(), bbs.len());\n         let phi = self.empty_phi(ty);\n         self.count_insn(\"addincoming\");\n@@ -846,36 +707,10 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n     }\n \n-    pub fn add_span_comment(&self, sp: Span, text: &str) {\n-        if self.cx.sess().asm_comments() {\n-            let s = format!(\"{} ({})\",\n-                            text,\n-                            self.cx.sess().codemap().span_to_string(sp));\n-            debug!(\"{}\", s);\n-            self.add_comment(&s);\n-        }\n-    }\n-\n-    pub fn add_comment(&self, text: &str) {\n-        if self.cx.sess().asm_comments() {\n-            let sanitized = text.replace(\"$\", \"\");\n-            let comment_text = format!(\"{} {}\", \"#\",\n-                                       sanitized.replace(\"\\n\", \"\\n\\t# \"));\n-            self.count_insn(\"inlineasm\");\n-            let comment_text = CString::new(comment_text).unwrap();\n-            let asm = unsafe {\n-                llvm::LLVMConstInlineAsm(Type::func(&[], &Type::void(self.cx)).to_ref(),\n-                                         comment_text.as_ptr(), noname(), False,\n-                                         False)\n-            };\n-            self.call(asm, &[], None);\n-        }\n-    }\n-\n     pub fn inline_asm_call(&self, asm: *const c_char, cons: *const c_char,\n-                         inputs: &[ValueRef], output: Type,\n+                         inputs: &[&'ll Value], output: &'ll Type,\n                          volatile: bool, alignstack: bool,\n-                         dia: AsmDialect) -> ValueRef {\n+                         dia: AsmDialect) -> &'ll Value {\n         self.count_insn(\"inlineasm\");\n \n         let volatile = if volatile { llvm::True }\n@@ -884,256 +719,221 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                          else          { llvm::False };\n \n         let argtys = inputs.iter().map(|v| {\n-            debug!(\"Asm Input Type: {:?}\", Value(*v));\n+            debug!(\"Asm Input Type: {:?}\", *v);\n             val_ty(*v)\n         }).collect::<Vec<_>>();\n \n         debug!(\"Asm Output Type: {:?}\", output);\n-        let fty = Type::func(&argtys[..], &output);\n+        let fty = Type::func(&argtys[..], output);\n         unsafe {\n             let v = llvm::LLVMRustInlineAsm(\n-                fty.to_ref(), asm, cons, volatile, alignstack, dia);\n+                fty, asm, cons, volatile, alignstack, dia);\n             self.call(v, inputs, None)\n         }\n     }\n \n-    pub fn call(&self, llfn: ValueRef, args: &[ValueRef],\n-                bundle: Option<&OperandBundleDef>) -> ValueRef {\n+    pub fn call(&self, llfn: &'ll Value, args: &[&'ll Value],\n+                bundle: Option<&OperandBundleDef<'ll>>) -> &'ll Value {\n         self.count_insn(\"call\");\n \n-        debug!(\"Call {:?} with args ({})\",\n-               Value(llfn),\n-               args.iter()\n-                   .map(|&v| format!(\"{:?}\", Value(v)))\n-                   .collect::<Vec<String>>()\n-                   .join(\", \"));\n+        debug!(\"Call {:?} with args ({:?})\",\n+               llfn,\n+               args);\n \n         let args = self.check_call(\"call\", llfn, args);\n-        let bundle = bundle.as_ref().map(|b| b.raw()).unwrap_or(ptr::null_mut());\n+        let bundle = bundle.map(|b| &*b.raw);\n \n         unsafe {\n             llvm::LLVMRustBuildCall(self.llbuilder, llfn, args.as_ptr(),\n                                     args.len() as c_uint, bundle, noname())\n         }\n     }\n \n-    pub fn minnum(&self, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+    pub fn minnum(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"minnum\");\n         unsafe {\n             let instr = llvm::LLVMRustBuildMinNum(self.llbuilder, lhs, rhs);\n-            if instr.is_null() {\n-                bug!(\"LLVMRustBuildMinNum is not available in LLVM version < 6.0\");\n-            }\n-            instr\n+            instr.expect(\"LLVMRustBuildMinNum is not available in LLVM version < 6.0\")\n         }\n     }\n-    pub fn maxnum(&self, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+    pub fn maxnum(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"maxnum\");\n         unsafe {\n             let instr = llvm::LLVMRustBuildMaxNum(self.llbuilder, lhs, rhs);\n-            if instr.is_null() {\n-                bug!(\"LLVMRustBuildMaxNum is not available in LLVM version < 6.0\");\n-            }\n-            instr\n+            instr.expect(\"LLVMRustBuildMaxNum is not available in LLVM version < 6.0\")\n         }\n     }\n \n-    pub fn select(&self, cond: ValueRef, then_val: ValueRef, else_val: ValueRef) -> ValueRef {\n+    pub fn select(\n+        &self, cond: &'ll Value,\n+        then_val: &'ll Value,\n+        else_val: &'ll Value,\n+    ) -> &'ll Value {\n         self.count_insn(\"select\");\n         unsafe {\n             llvm::LLVMBuildSelect(self.llbuilder, cond, then_val, else_val, noname())\n         }\n     }\n \n-    pub fn va_arg(&self, list: ValueRef, ty: Type) -> ValueRef {\n+    #[allow(dead_code)]\n+    pub fn va_arg(&self, list: &'ll Value, ty: &'ll Type) -> &'ll Value {\n         self.count_insn(\"vaarg\");\n         unsafe {\n-            llvm::LLVMBuildVAArg(self.llbuilder, list, ty.to_ref(), noname())\n+            llvm::LLVMBuildVAArg(self.llbuilder, list, ty, noname())\n         }\n     }\n \n-    pub fn extract_element(&self, vec: ValueRef, idx: ValueRef) -> ValueRef {\n+    pub fn extract_element(&self, vec: &'ll Value, idx: &'ll Value) -> &'ll Value {\n         self.count_insn(\"extractelement\");\n         unsafe {\n             llvm::LLVMBuildExtractElement(self.llbuilder, vec, idx, noname())\n         }\n     }\n \n-    pub fn insert_element(&self, vec: ValueRef, elt: ValueRef, idx: ValueRef) -> ValueRef {\n+    pub fn insert_element(\n+        &self, vec: &'ll Value,\n+        elt: &'ll Value,\n+        idx: &'ll Value,\n+    ) -> &'ll Value {\n         self.count_insn(\"insertelement\");\n         unsafe {\n             llvm::LLVMBuildInsertElement(self.llbuilder, vec, elt, idx, noname())\n         }\n     }\n \n-    pub fn shuffle_vector(&self, v1: ValueRef, v2: ValueRef, mask: ValueRef) -> ValueRef {\n+    pub fn shuffle_vector(&self, v1: &'ll Value, v2: &'ll Value, mask: &'ll Value) -> &'ll Value {\n         self.count_insn(\"shufflevector\");\n         unsafe {\n             llvm::LLVMBuildShuffleVector(self.llbuilder, v1, v2, mask, noname())\n         }\n     }\n \n-    pub fn vector_splat(&self, num_elts: usize, elt: ValueRef) -> ValueRef {\n+    pub fn vector_splat(&self, num_elts: usize, elt: &'ll Value) -> &'ll Value {\n         unsafe {\n             let elt_ty = val_ty(elt);\n-            let undef = llvm::LLVMGetUndef(Type::vector(&elt_ty, num_elts as u64).to_ref());\n+            let undef = llvm::LLVMGetUndef(Type::vector(elt_ty, num_elts as u64));\n             let vec = self.insert_element(undef, elt, C_i32(self.cx, 0));\n-            let vec_i32_ty = Type::vector(&Type::i32(self.cx), num_elts as u64);\n+            let vec_i32_ty = Type::vector(Type::i32(self.cx), num_elts as u64);\n             self.shuffle_vector(vec, undef, C_null(vec_i32_ty))\n         }\n     }\n \n-    pub fn vector_reduce_fadd_fast(&self, acc: ValueRef, src: ValueRef) -> ValueRef {\n+    pub fn vector_reduce_fadd_fast(&self, acc: &'ll Value, src: &'ll Value) -> &'ll Value {\n         self.count_insn(\"vector.reduce.fadd_fast\");\n         unsafe {\n             // FIXME: add a non-fast math version once\n             // https://bugs.llvm.org/show_bug.cgi?id=36732\n             // is fixed.\n-            let instr = llvm::LLVMRustBuildVectorReduceFAdd(self.llbuilder, acc, src);\n-            if instr.is_null() {\n-                bug!(\"LLVMRustBuildVectorReduceFAdd is not available in LLVM version < 5.0\");\n-            }\n+            let instr = llvm::LLVMRustBuildVectorReduceFAdd(self.llbuilder, acc, src)\n+                .expect(\"LLVMRustBuildVectorReduceFAdd is not available in LLVM version < 5.0\");\n             llvm::LLVMRustSetHasUnsafeAlgebra(instr);\n             instr\n         }\n     }\n-    pub fn vector_reduce_fmul_fast(&self, acc: ValueRef, src: ValueRef) -> ValueRef {\n+    pub fn vector_reduce_fmul_fast(&self, acc: &'ll Value, src: &'ll Value) -> &'ll Value {\n         self.count_insn(\"vector.reduce.fmul_fast\");\n         unsafe {\n             // FIXME: add a non-fast math version once\n             // https://bugs.llvm.org/show_bug.cgi?id=36732\n             // is fixed.\n-            let instr = llvm::LLVMRustBuildVectorReduceFMul(self.llbuilder, acc, src);\n-            if instr.is_null() {\n-                bug!(\"LLVMRustBuildVectorReduceFMul is not available in LLVM version < 5.0\");\n-            }\n+            let instr = llvm::LLVMRustBuildVectorReduceFMul(self.llbuilder, acc, src)\n+                .expect(\"LLVMRustBuildVectorReduceFMul is not available in LLVM version < 5.0\");\n             llvm::LLVMRustSetHasUnsafeAlgebra(instr);\n             instr\n         }\n     }\n-    pub fn vector_reduce_add(&self, src: ValueRef) -> ValueRef {\n+    pub fn vector_reduce_add(&self, src: &'ll Value) -> &'ll Value {\n         self.count_insn(\"vector.reduce.add\");\n         unsafe {\n             let instr = llvm::LLVMRustBuildVectorReduceAdd(self.llbuilder, src);\n-            if instr.is_null() {\n-                bug!(\"LLVMRustBuildVectorReduceAdd is not available in LLVM version < 5.0\");\n-            }\n-            instr\n+            instr.expect(\"LLVMRustBuildVectorReduceAdd is not available in LLVM version < 5.0\")\n         }\n     }\n-    pub fn vector_reduce_mul(&self, src: ValueRef) -> ValueRef {\n+    pub fn vector_reduce_mul(&self, src: &'ll Value) -> &'ll Value {\n         self.count_insn(\"vector.reduce.mul\");\n         unsafe {\n             let instr = llvm::LLVMRustBuildVectorReduceMul(self.llbuilder, src);\n-            if instr.is_null() {\n-                bug!(\"LLVMRustBuildVectorReduceMul is not available in LLVM version < 5.0\");\n-            }\n-            instr\n+            instr.expect(\"LLVMRustBuildVectorReduceMul is not available in LLVM version < 5.0\")\n         }\n     }\n-    pub fn vector_reduce_and(&self, src: ValueRef) -> ValueRef {\n+    pub fn vector_reduce_and(&self, src: &'ll Value) -> &'ll Value {\n         self.count_insn(\"vector.reduce.and\");\n         unsafe {\n             let instr = llvm::LLVMRustBuildVectorReduceAnd(self.llbuilder, src);\n-            if instr.is_null() {\n-                bug!(\"LLVMRustBuildVectorReduceAnd is not available in LLVM version < 5.0\");\n-            }\n-            instr\n+            instr.expect(\"LLVMRustBuildVectorReduceAnd is not available in LLVM version < 5.0\")\n         }\n     }\n-    pub fn vector_reduce_or(&self, src: ValueRef) -> ValueRef {\n+    pub fn vector_reduce_or(&self, src: &'ll Value) -> &'ll Value {\n         self.count_insn(\"vector.reduce.or\");\n         unsafe {\n             let instr = llvm::LLVMRustBuildVectorReduceOr(self.llbuilder, src);\n-            if instr.is_null() {\n-                bug!(\"LLVMRustBuildVectorReduceOr is not available in LLVM version < 5.0\");\n-            }\n-            instr\n+            instr.expect(\"LLVMRustBuildVectorReduceOr is not available in LLVM version < 5.0\")\n         }\n     }\n-    pub fn vector_reduce_xor(&self, src: ValueRef) -> ValueRef {\n+    pub fn vector_reduce_xor(&self, src: &'ll Value) -> &'ll Value {\n         self.count_insn(\"vector.reduce.xor\");\n         unsafe {\n             let instr = llvm::LLVMRustBuildVectorReduceXor(self.llbuilder, src);\n-            if instr.is_null() {\n-                bug!(\"LLVMRustBuildVectorReduceXor is not available in LLVM version < 5.0\");\n-            }\n-            instr\n+            instr.expect(\"LLVMRustBuildVectorReduceXor is not available in LLVM version < 5.0\")\n         }\n     }\n-    pub fn vector_reduce_fmin(&self, src: ValueRef) -> ValueRef {\n+    pub fn vector_reduce_fmin(&self, src: &'ll Value) -> &'ll Value {\n         self.count_insn(\"vector.reduce.fmin\");\n         unsafe {\n             let instr = llvm::LLVMRustBuildVectorReduceFMin(self.llbuilder, src, /*NoNaNs:*/ false);\n-            if instr.is_null() {\n-                bug!(\"LLVMRustBuildVectorReduceFMin is not available in LLVM version < 5.0\");\n-            }\n-            instr\n+            instr.expect(\"LLVMRustBuildVectorReduceFMin is not available in LLVM version < 5.0\")\n         }\n     }\n-    pub fn vector_reduce_fmax(&self, src: ValueRef) -> ValueRef {\n+    pub fn vector_reduce_fmax(&self, src: &'ll Value) -> &'ll Value {\n         self.count_insn(\"vector.reduce.fmax\");\n         unsafe {\n             let instr = llvm::LLVMRustBuildVectorReduceFMax(self.llbuilder, src, /*NoNaNs:*/ false);\n-            if instr.is_null() {\n-                bug!(\"LLVMRustBuildVectorReduceFMax is not available in LLVM version < 5.0\");\n-            }\n-            instr\n+            instr.expect(\"LLVMRustBuildVectorReduceFMax is not available in LLVM version < 5.0\")\n         }\n     }\n-    pub fn vector_reduce_fmin_fast(&self, src: ValueRef) -> ValueRef {\n+    pub fn vector_reduce_fmin_fast(&self, src: &'ll Value) -> &'ll Value {\n         self.count_insn(\"vector.reduce.fmin_fast\");\n         unsafe {\n-            let instr = llvm::LLVMRustBuildVectorReduceFMin(self.llbuilder, src, /*NoNaNs:*/ true);\n-            if instr.is_null() {\n-                bug!(\"LLVMRustBuildVectorReduceFMin is not available in LLVM version < 5.0\");\n-            }\n+            let instr = llvm::LLVMRustBuildVectorReduceFMin(self.llbuilder, src, /*NoNaNs:*/ true)\n+                .expect(\"LLVMRustBuildVectorReduceFMin is not available in LLVM version < 5.0\");\n             llvm::LLVMRustSetHasUnsafeAlgebra(instr);\n             instr\n         }\n     }\n-    pub fn vector_reduce_fmax_fast(&self, src: ValueRef) -> ValueRef {\n+    pub fn vector_reduce_fmax_fast(&self, src: &'ll Value) -> &'ll Value {\n         self.count_insn(\"vector.reduce.fmax_fast\");\n         unsafe {\n-            let instr = llvm::LLVMRustBuildVectorReduceFMax(self.llbuilder, src, /*NoNaNs:*/ true);\n-            if instr.is_null() {\n-                bug!(\"LLVMRustBuildVectorReduceFMax is not available in LLVM version < 5.0\");\n-            }\n+            let instr = llvm::LLVMRustBuildVectorReduceFMax(self.llbuilder, src, /*NoNaNs:*/ true)\n+                .expect(\"LLVMRustBuildVectorReduceFMax is not available in LLVM version < 5.0\");\n             llvm::LLVMRustSetHasUnsafeAlgebra(instr);\n             instr\n         }\n     }\n-    pub fn vector_reduce_min(&self, src: ValueRef, is_signed: bool) -> ValueRef {\n+    pub fn vector_reduce_min(&self, src: &'ll Value, is_signed: bool) -> &'ll Value {\n         self.count_insn(\"vector.reduce.min\");\n         unsafe {\n             let instr = llvm::LLVMRustBuildVectorReduceMin(self.llbuilder, src, is_signed);\n-            if instr.is_null() {\n-                bug!(\"LLVMRustBuildVectorReduceMin is not available in LLVM version < 5.0\");\n-            }\n-            instr\n+            instr.expect(\"LLVMRustBuildVectorReduceMin is not available in LLVM version < 5.0\")\n         }\n     }\n-    pub fn vector_reduce_max(&self, src: ValueRef, is_signed: bool) -> ValueRef {\n+    pub fn vector_reduce_max(&self, src: &'ll Value, is_signed: bool) -> &'ll Value {\n         self.count_insn(\"vector.reduce.max\");\n         unsafe {\n             let instr = llvm::LLVMRustBuildVectorReduceMax(self.llbuilder, src, is_signed);\n-            if instr.is_null() {\n-                bug!(\"LLVMRustBuildVectorReduceMax is not available in LLVM version < 5.0\");\n-            }\n-            instr\n+            instr.expect(\"LLVMRustBuildVectorReduceMax is not available in LLVM version < 5.0\")\n         }\n     }\n \n-    pub fn extract_value(&self, agg_val: ValueRef, idx: u64) -> ValueRef {\n+    pub fn extract_value(&self, agg_val: &'ll Value, idx: u64) -> &'ll Value {\n         self.count_insn(\"extractvalue\");\n         assert_eq!(idx as c_uint as u64, idx);\n         unsafe {\n             llvm::LLVMBuildExtractValue(self.llbuilder, agg_val, idx as c_uint, noname())\n         }\n     }\n \n-    pub fn insert_value(&self, agg_val: ValueRef, elt: ValueRef,\n-                       idx: u64) -> ValueRef {\n+    pub fn insert_value(&self, agg_val: &'ll Value, elt: &'ll Value,\n+                       idx: u64) -> &'ll Value {\n         self.count_insn(\"insertvalue\");\n         assert_eq!(idx as c_uint as u64, idx);\n         unsafe {\n@@ -1142,61 +942,39 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n     }\n \n-    pub fn is_null(&self, val: ValueRef) -> ValueRef {\n-        self.count_insn(\"isnull\");\n-        unsafe {\n-            llvm::LLVMBuildIsNull(self.llbuilder, val, noname())\n-        }\n-    }\n-\n-    pub fn is_not_null(&self, val: ValueRef) -> ValueRef {\n-        self.count_insn(\"isnotnull\");\n-        unsafe {\n-            llvm::LLVMBuildIsNotNull(self.llbuilder, val, noname())\n-        }\n-    }\n-\n-    pub fn ptrdiff(&self, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n-        self.count_insn(\"ptrdiff\");\n-        unsafe {\n-            llvm::LLVMBuildPtrDiff(self.llbuilder, lhs, rhs, noname())\n-        }\n-    }\n-\n-    pub fn landing_pad(&self, ty: Type, pers_fn: ValueRef,\n-                       num_clauses: usize) -> ValueRef {\n+    pub fn landing_pad(&self, ty: &'ll Type, pers_fn: &'ll Value,\n+                       num_clauses: usize) -> &'ll Value {\n         self.count_insn(\"landingpad\");\n         unsafe {\n-            llvm::LLVMBuildLandingPad(self.llbuilder, ty.to_ref(), pers_fn,\n+            llvm::LLVMBuildLandingPad(self.llbuilder, ty, pers_fn,\n                                       num_clauses as c_uint, noname())\n         }\n     }\n \n-    pub fn add_clause(&self, landing_pad: ValueRef, clause: ValueRef) {\n+    pub fn add_clause(&self, landing_pad: &'ll Value, clause: &'ll Value) {\n         unsafe {\n             llvm::LLVMAddClause(landing_pad, clause);\n         }\n     }\n \n-    pub fn set_cleanup(&self, landing_pad: ValueRef) {\n+    pub fn set_cleanup(&self, landing_pad: &'ll Value) {\n         self.count_insn(\"setcleanup\");\n         unsafe {\n             llvm::LLVMSetCleanup(landing_pad, llvm::True);\n         }\n     }\n \n-    pub fn resume(&self, exn: ValueRef) -> ValueRef {\n+    pub fn resume(&self, exn: &'ll Value) -> &'ll Value {\n         self.count_insn(\"resume\");\n         unsafe {\n             llvm::LLVMBuildResume(self.llbuilder, exn)\n         }\n     }\n \n     pub fn cleanup_pad(&self,\n-                       parent: Option<ValueRef>,\n-                       args: &[ValueRef]) -> ValueRef {\n+                       parent: Option<&'ll Value>,\n+                       args: &[&'ll Value]) -> &'ll Value {\n         self.count_insn(\"cleanuppad\");\n-        let parent = parent.unwrap_or(ptr::null_mut());\n         let name = CString::new(\"cleanuppad\").unwrap();\n         let ret = unsafe {\n             llvm::LLVMRustBuildCleanupPad(self.llbuilder,\n@@ -1205,87 +983,91 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                                           args.as_ptr(),\n                                           name.as_ptr())\n         };\n-        assert!(!ret.is_null(), \"LLVM does not have support for cleanuppad\");\n-        return ret\n+        ret.expect(\"LLVM does not have support for cleanuppad\")\n     }\n \n-    pub fn cleanup_ret(&self, cleanup: ValueRef,\n-                       unwind: Option<BasicBlockRef>) -> ValueRef {\n+    pub fn cleanup_ret(\n+        &self, cleanup: &'ll Value,\n+        unwind: Option<&'ll BasicBlock>,\n+    ) -> &'ll Value {\n         self.count_insn(\"cleanupret\");\n-        let unwind = unwind.unwrap_or(ptr::null_mut());\n         let ret = unsafe {\n             llvm::LLVMRustBuildCleanupRet(self.llbuilder, cleanup, unwind)\n         };\n-        assert!(!ret.is_null(), \"LLVM does not have support for cleanupret\");\n-        return ret\n+        ret.expect(\"LLVM does not have support for cleanupret\")\n     }\n \n     pub fn catch_pad(&self,\n-                     parent: ValueRef,\n-                     args: &[ValueRef]) -> ValueRef {\n+                     parent: &'ll Value,\n+                     args: &[&'ll Value]) -> &'ll Value {\n         self.count_insn(\"catchpad\");\n         let name = CString::new(\"catchpad\").unwrap();\n         let ret = unsafe {\n             llvm::LLVMRustBuildCatchPad(self.llbuilder, parent,\n                                         args.len() as c_uint, args.as_ptr(),\n                                         name.as_ptr())\n         };\n-        assert!(!ret.is_null(), \"LLVM does not have support for catchpad\");\n-        return ret\n+        ret.expect(\"LLVM does not have support for catchpad\")\n     }\n \n-    pub fn catch_ret(&self, pad: ValueRef, unwind: BasicBlockRef) -> ValueRef {\n+    pub fn catch_ret(&self, pad: &'ll Value, unwind: &'ll BasicBlock) -> &'ll Value {\n         self.count_insn(\"catchret\");\n         let ret = unsafe {\n             llvm::LLVMRustBuildCatchRet(self.llbuilder, pad, unwind)\n         };\n-        assert!(!ret.is_null(), \"LLVM does not have support for catchret\");\n-        return ret\n+        ret.expect(\"LLVM does not have support for catchret\")\n     }\n \n-    pub fn catch_switch(&self,\n-                        parent: Option<ValueRef>,\n-                        unwind: Option<BasicBlockRef>,\n-                        num_handlers: usize) -> ValueRef {\n+    pub fn catch_switch(\n+        &self,\n+        parent: Option<&'ll Value>,\n+        unwind: Option<&'ll BasicBlock>,\n+        num_handlers: usize,\n+    ) -> &'ll Value {\n         self.count_insn(\"catchswitch\");\n-        let parent = parent.unwrap_or(ptr::null_mut());\n-        let unwind = unwind.unwrap_or(ptr::null_mut());\n         let name = CString::new(\"catchswitch\").unwrap();\n         let ret = unsafe {\n             llvm::LLVMRustBuildCatchSwitch(self.llbuilder, parent, unwind,\n                                            num_handlers as c_uint,\n                                            name.as_ptr())\n         };\n-        assert!(!ret.is_null(), \"LLVM does not have support for catchswitch\");\n-        return ret\n+        ret.expect(\"LLVM does not have support for catchswitch\")\n     }\n \n-    pub fn add_handler(&self, catch_switch: ValueRef, handler: BasicBlockRef) {\n+    pub fn add_handler(&self, catch_switch: &'ll Value, handler: &'ll BasicBlock) {\n         unsafe {\n             llvm::LLVMRustAddHandler(catch_switch, handler);\n         }\n     }\n \n-    pub fn set_personality_fn(&self, personality: ValueRef) {\n+    pub fn set_personality_fn(&self, personality: &'ll Value) {\n         unsafe {\n             llvm::LLVMSetPersonalityFn(self.llfn(), personality);\n         }\n     }\n \n     // Atomic Operations\n-    pub fn atomic_cmpxchg(&self, dst: ValueRef,\n-                         cmp: ValueRef, src: ValueRef,\n-                         order: AtomicOrdering,\n-                         failure_order: AtomicOrdering,\n-                         weak: llvm::Bool) -> ValueRef {\n+    pub fn atomic_cmpxchg(\n+        &self,\n+        dst: &'ll Value,\n+        cmp: &'ll Value,\n+        src: &'ll Value,\n+        order: AtomicOrdering,\n+        failure_order: AtomicOrdering,\n+        weak: llvm::Bool,\n+    ) -> &'ll Value {\n         unsafe {\n             llvm::LLVMRustBuildAtomicCmpXchg(self.llbuilder, dst, cmp, src,\n                                          order, failure_order, weak)\n         }\n     }\n-    pub fn atomic_rmw(&self, op: AtomicRmwBinOp,\n-                     dst: ValueRef, src: ValueRef,\n-                     order: AtomicOrdering) -> ValueRef {\n+    pub fn atomic_rmw(\n+        &self,\n+        op: AtomicRmwBinOp,\n+        dst: &'ll Value,\n+        src: &'ll Value,\n+        order: AtomicOrdering,\n+    ) -> &'ll Value {\n         unsafe {\n             llvm::LLVMBuildAtomicRMW(self.llbuilder, op, dst, src, order, False)\n         }\n@@ -1297,20 +1079,20 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n     }\n \n-    pub fn add_case(&self, s: ValueRef, on_val: ValueRef, dest: BasicBlockRef) {\n+    pub fn add_case(&self, s: &'ll Value, on_val: &'ll Value, dest: &'ll BasicBlock) {\n         unsafe {\n             llvm::LLVMAddCase(s, on_val, dest)\n         }\n     }\n \n-    pub fn add_incoming_to_phi(&self, phi: ValueRef, val: ValueRef, bb: BasicBlockRef) {\n+    pub fn add_incoming_to_phi(&self, phi: &'ll Value, val: &'ll Value, bb: &'ll BasicBlock) {\n         self.count_insn(\"addincoming\");\n         unsafe {\n             llvm::LLVMAddIncoming(phi, &val, &bb, 1 as c_uint);\n         }\n     }\n \n-    pub fn set_invariant_load(&self, load: ValueRef) {\n+    pub fn set_invariant_load(&self, load: &'ll Value) {\n         unsafe {\n             llvm::LLVMSetMetadata(load, llvm::MD_invariant_load as c_uint,\n                                   llvm::LLVMMDNodeInContext(self.cx.llcx, ptr::null(), 0));\n@@ -1319,8 +1101,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n     /// Returns the ptr value that should be used for storing `val`.\n     fn check_store<'b>(&self,\n-                       val: ValueRef,\n-                       ptr: ValueRef) -> ValueRef {\n+                       val: &'ll Value,\n+                       ptr: &'ll Value) -> &'ll Value {\n         let dest_ptr_ty = val_ty(ptr);\n         let stored_ty = val_ty(val);\n         let stored_ptr_ty = stored_ty.ptr_to();\n@@ -1340,8 +1122,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// Returns the args that should be used for a call to `llfn`.\n     fn check_call<'b>(&self,\n                       typ: &str,\n-                      llfn: ValueRef,\n-                      args: &'b [ValueRef]) -> Cow<'b, [ValueRef]> {\n+                      llfn: &'ll Value,\n+                      args: &'b [&'ll Value]) -> Cow<'b, [&'ll Value]> {\n         let mut fn_ty = val_ty(llfn);\n         // Strip off pointers\n         while fn_ty.kind() == llvm::TypeKind::Pointer {\n@@ -1369,8 +1151,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 if expected_ty != actual_ty {\n                     debug!(\"Type mismatch in function call of {:?}. \\\n                             Expected {:?} for param {}, got {:?}; injecting bitcast\",\n-                           Value(llfn),\n-                           expected_ty, i, actual_ty);\n+                           llfn, expected_ty, i, actual_ty);\n                     self.bitcast(actual_val, expected_ty)\n                 } else {\n                     actual_val\n@@ -1381,11 +1162,11 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         return Cow::Owned(casted_args);\n     }\n \n-    pub fn lifetime_start(&self, ptr: ValueRef, size: Size) {\n+    pub fn lifetime_start(&self, ptr: &'ll Value, size: Size) {\n         self.call_lifetime_intrinsic(\"llvm.lifetime.start\", ptr, size);\n     }\n \n-    pub fn lifetime_end(&self, ptr: ValueRef, size: Size) {\n+    pub fn lifetime_end(&self, ptr: &'ll Value, size: Size) {\n         self.call_lifetime_intrinsic(\"llvm.lifetime.end\", ptr, size);\n     }\n \n@@ -1397,7 +1178,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     ///\n     /// If LLVM lifetime intrinsic support is disabled (i.e.  optimizations\n     /// off) or `ptr` is zero-sized, then no-op (does not call `emit`).\n-    fn call_lifetime_intrinsic(&self, intrinsic: &str, ptr: ValueRef, size: Size) {\n+    fn call_lifetime_intrinsic(&self, intrinsic: &str, ptr: &'ll Value, size: Size) {\n         if self.cx.sess().opts.optimize == config::OptLevel::No {\n             return;\n         }"}, {"sha": "e64dedac55a247e343d0c86f5962bd104c323301", "filename": "src/librustc_codegen_llvm/callee.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/f89817997ac0aa100bf91997194ad85a7e59f743/src%2Flibrustc_codegen_llvm%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f89817997ac0aa100bf91997194ad85a7e59f743/src%2Flibrustc_codegen_llvm%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcallee.rs?ref=f89817997ac0aa100bf91997194ad85a7e59f743", "patch": "@@ -18,9 +18,10 @@ use attributes;\n use common::{self, CodegenCx};\n use consts;\n use declare;\n-use llvm::{self, ValueRef};\n+use llvm;\n use monomorphize::Instance;\n use type_of::LayoutLlvmExt;\n+use value::Value;\n \n use rustc::hir::def_id::DefId;\n use rustc::ty::{self, TypeFoldable};\n@@ -34,10 +35,10 @@ use rustc::ty::subst::Substs;\n ///\n /// - `cx`: the crate context\n /// - `instance`: the instance to be instantiated\n-pub fn get_fn<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n-                        instance: Instance<'tcx>)\n-                        -> ValueRef\n-{\n+pub fn get_fn(\n+    cx: &CodegenCx<'ll, 'tcx>,\n+    instance: Instance<'tcx>,\n+) -> &'ll Value {\n     let tcx = cx.tcx;\n \n     debug!(\"get_fn(instance={:?})\", instance);\n@@ -204,11 +205,11 @@ pub fn get_fn<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n     llfn\n }\n \n-pub fn resolve_and_get_fn<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n-                                    def_id: DefId,\n-                                    substs: &'tcx Substs<'tcx>)\n-                                    -> ValueRef\n-{\n+pub fn resolve_and_get_fn(\n+    cx: &CodegenCx<'ll, 'tcx>,\n+    def_id: DefId,\n+    substs: &'tcx Substs<'tcx>,\n+) -> &'ll Value {\n     get_fn(\n         cx,\n         ty::Instance::resolve("}, {"sha": "51fc610408b5213538dc7f2ce8c6fa5aa6df8ff5", "filename": "src/librustc_codegen_llvm/common.rs", "status": "modified", "additions": 70, "deletions": 62, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/f89817997ac0aa100bf91997194ad85a7e59f743/src%2Flibrustc_codegen_llvm%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f89817997ac0aa100bf91997194ad85a7e59f743/src%2Flibrustc_codegen_llvm%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcommon.rs?ref=f89817997ac0aa100bf91997194ad85a7e59f743", "patch": "@@ -12,8 +12,7 @@\n \n //! Code that is useful in various codegen modules.\n \n-use llvm;\n-use llvm::{ValueRef, ContextRef, TypeKind};\n+use llvm::{self, TypeKind};\n use llvm::{True, False, Bool, OperandBundleDef};\n use rustc::hir::def_id::DefId;\n use rustc::middle::lang_items::LangItem;\n@@ -25,6 +24,7 @@ use declare;\n use type_::Type;\n use type_of::LayoutLlvmExt;\n use value::Value;\n+\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::layout::{HasDataLayout, LayoutOf};\n use rustc::hir;\n@@ -90,83 +90,83 @@ pub fn type_is_freeze<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, ty: Ty<'tcx>) -> bo\n /// When inside of a landing pad, each function call in LLVM IR needs to be\n /// annotated with which landing pad it's a part of. This is accomplished via\n /// the `OperandBundleDef` value created for MSVC landing pads.\n-pub struct Funclet {\n-    cleanuppad: ValueRef,\n-    operand: OperandBundleDef,\n+pub struct Funclet<'ll> {\n+    cleanuppad: &'ll Value,\n+    operand: OperandBundleDef<'ll>,\n }\n \n-impl Funclet {\n-    pub fn new(cleanuppad: ValueRef) -> Funclet {\n+impl Funclet<'ll> {\n+    pub fn new(cleanuppad: &'ll Value) -> Self {\n         Funclet {\n             cleanuppad,\n             operand: OperandBundleDef::new(\"funclet\", &[cleanuppad]),\n         }\n     }\n \n-    pub fn cleanuppad(&self) -> ValueRef {\n+    pub fn cleanuppad(&self) -> &'ll Value {\n         self.cleanuppad\n     }\n \n-    pub fn bundle(&self) -> &OperandBundleDef {\n+    pub fn bundle(&self) -> &OperandBundleDef<'ll> {\n         &self.operand\n     }\n }\n \n-pub fn val_ty(v: ValueRef) -> Type {\n+pub fn val_ty(v: &'ll Value) -> &'ll Type {\n     unsafe {\n-        Type::from_ref(llvm::LLVMTypeOf(v))\n+        llvm::LLVMTypeOf(v)\n     }\n }\n \n // LLVM constant constructors.\n-pub fn C_null(t: Type) -> ValueRef {\n+pub fn C_null(t: &'ll Type) -> &'ll Value {\n     unsafe {\n-        llvm::LLVMConstNull(t.to_ref())\n+        llvm::LLVMConstNull(t)\n     }\n }\n \n-pub fn C_undef(t: Type) -> ValueRef {\n+pub fn C_undef(t: &'ll Type) -> &'ll Value {\n     unsafe {\n-        llvm::LLVMGetUndef(t.to_ref())\n+        llvm::LLVMGetUndef(t)\n     }\n }\n \n-pub fn C_int(t: Type, i: i64) -> ValueRef {\n+pub fn C_int(t: &'ll Type, i: i64) -> &'ll Value {\n     unsafe {\n-        llvm::LLVMConstInt(t.to_ref(), i as u64, True)\n+        llvm::LLVMConstInt(t, i as u64, True)\n     }\n }\n \n-pub fn C_uint(t: Type, i: u64) -> ValueRef {\n+pub fn C_uint(t: &'ll Type, i: u64) -> &'ll Value {\n     unsafe {\n-        llvm::LLVMConstInt(t.to_ref(), i, False)\n+        llvm::LLVMConstInt(t, i, False)\n     }\n }\n \n-pub fn C_uint_big(t: Type, u: u128) -> ValueRef {\n+pub fn C_uint_big(t: &'ll Type, u: u128) -> &'ll Value {\n     unsafe {\n         let words = [u as u64, (u >> 64) as u64];\n-        llvm::LLVMConstIntOfArbitraryPrecision(t.to_ref(), 2, words.as_ptr())\n+        llvm::LLVMConstIntOfArbitraryPrecision(t, 2, words.as_ptr())\n     }\n }\n \n-pub fn C_bool(cx: &CodegenCx, val: bool) -> ValueRef {\n+pub fn C_bool(cx: &CodegenCx<'ll, '_>, val: bool) -> &'ll Value {\n     C_uint(Type::i1(cx), val as u64)\n }\n \n-pub fn C_i32(cx: &CodegenCx, i: i32) -> ValueRef {\n+pub fn C_i32(cx: &CodegenCx<'ll, '_>, i: i32) -> &'ll Value {\n     C_int(Type::i32(cx), i as i64)\n }\n \n-pub fn C_u32(cx: &CodegenCx, i: u32) -> ValueRef {\n+pub fn C_u32(cx: &CodegenCx<'ll, '_>, i: u32) -> &'ll Value {\n     C_uint(Type::i32(cx), i as u64)\n }\n \n-pub fn C_u64(cx: &CodegenCx, i: u64) -> ValueRef {\n+pub fn C_u64(cx: &CodegenCx<'ll, '_>, i: u64) -> &'ll Value {\n     C_uint(Type::i64(cx), i)\n }\n \n-pub fn C_usize(cx: &CodegenCx, i: u64) -> ValueRef {\n+pub fn C_usize(cx: &CodegenCx<'ll, '_>, i: u64) -> &'ll Value {\n     let bit_size = cx.data_layout().pointer_size.bits();\n     if bit_size < 64 {\n         // make sure it doesn't overflow\n@@ -176,14 +176,18 @@ pub fn C_usize(cx: &CodegenCx, i: u64) -> ValueRef {\n     C_uint(cx.isize_ty, i)\n }\n \n-pub fn C_u8(cx: &CodegenCx, i: u8) -> ValueRef {\n+pub fn C_u8(cx: &CodegenCx<'ll, '_>, i: u8) -> &'ll Value {\n     C_uint(Type::i8(cx), i as u64)\n }\n \n \n // This is a 'c-like' raw string, which differs from\n // our boxed-and-length-annotated strings.\n-pub fn C_cstr(cx: &CodegenCx, s: LocalInternedString, null_terminated: bool) -> ValueRef {\n+pub fn C_cstr(\n+    cx: &CodegenCx<'ll, '_>,\n+    s: LocalInternedString,\n+    null_terminated: bool,\n+) -> &'ll Value {\n     unsafe {\n         if let Some(&llval) = cx.const_cstr_cache.borrow().get(&s) {\n             return llval;\n@@ -208,72 +212,76 @@ pub fn C_cstr(cx: &CodegenCx, s: LocalInternedString, null_terminated: bool) ->\n \n // NB: Do not use `do_spill_noroot` to make this into a constant string, or\n // you will be kicked off fast isel. See issue #4352 for an example of this.\n-pub fn C_str_slice(cx: &CodegenCx, s: LocalInternedString) -> ValueRef {\n+pub fn C_str_slice(cx: &CodegenCx<'ll, '_>, s: LocalInternedString) -> &'ll Value {\n     let len = s.len();\n     let cs = consts::ptrcast(C_cstr(cx, s, false),\n         cx.layout_of(cx.tcx.mk_str()).llvm_type(cx).ptr_to());\n     C_fat_ptr(cx, cs, C_usize(cx, len as u64))\n }\n \n-pub fn C_fat_ptr(cx: &CodegenCx, ptr: ValueRef, meta: ValueRef) -> ValueRef {\n+pub fn C_fat_ptr(cx: &CodegenCx<'ll, '_>, ptr: &'ll Value, meta: &'ll Value) -> &'ll Value {\n     assert_eq!(abi::FAT_PTR_ADDR, 0);\n     assert_eq!(abi::FAT_PTR_EXTRA, 1);\n     C_struct(cx, &[ptr, meta], false)\n }\n \n-pub fn C_struct(cx: &CodegenCx, elts: &[ValueRef], packed: bool) -> ValueRef {\n+pub fn C_struct(cx: &CodegenCx<'ll, '_>, elts: &[&'ll Value], packed: bool) -> &'ll Value {\n     C_struct_in_context(cx.llcx, elts, packed)\n }\n \n-pub fn C_struct_in_context(llcx: ContextRef, elts: &[ValueRef], packed: bool) -> ValueRef {\n+pub fn C_struct_in_context(\n+    llcx: &'ll llvm::Context,\n+    elts: &[&'ll Value],\n+    packed: bool,\n+) -> &'ll Value {\n     unsafe {\n         llvm::LLVMConstStructInContext(llcx,\n                                        elts.as_ptr(), elts.len() as c_uint,\n                                        packed as Bool)\n     }\n }\n \n-pub fn C_array(ty: Type, elts: &[ValueRef]) -> ValueRef {\n+pub fn C_array(ty: &'ll Type, elts: &[&'ll Value]) -> &'ll Value {\n     unsafe {\n-        return llvm::LLVMConstArray(ty.to_ref(), elts.as_ptr(), elts.len() as c_uint);\n+        return llvm::LLVMConstArray(ty, elts.as_ptr(), elts.len() as c_uint);\n     }\n }\n \n-pub fn C_vector(elts: &[ValueRef]) -> ValueRef {\n+pub fn C_vector(elts: &[&'ll Value]) -> &'ll Value {\n     unsafe {\n         return llvm::LLVMConstVector(elts.as_ptr(), elts.len() as c_uint);\n     }\n }\n \n-pub fn C_bytes(cx: &CodegenCx, bytes: &[u8]) -> ValueRef {\n+pub fn C_bytes(cx: &CodegenCx<'ll, '_>, bytes: &[u8]) -> &'ll Value {\n     C_bytes_in_context(cx.llcx, bytes)\n }\n \n-pub fn C_bytes_in_context(llcx: ContextRef, bytes: &[u8]) -> ValueRef {\n+pub fn C_bytes_in_context(llcx: &'ll llvm::Context, bytes: &[u8]) -> &'ll Value {\n     unsafe {\n         let ptr = bytes.as_ptr() as *const c_char;\n         return llvm::LLVMConstStringInContext(llcx, ptr, bytes.len() as c_uint, True);\n     }\n }\n \n-pub fn const_get_elt(v: ValueRef, idx: u64) -> ValueRef {\n+pub fn const_get_elt(v: &'ll Value, idx: u64) -> &'ll Value {\n     unsafe {\n         assert_eq!(idx as c_uint as u64, idx);\n         let us = &[idx as c_uint];\n         let r = llvm::LLVMConstExtractValue(v, us.as_ptr(), us.len() as c_uint);\n \n         debug!(\"const_get_elt(v={:?}, idx={}, r={:?})\",\n-               Value(v), idx, Value(r));\n+               v, idx, r);\n \n         r\n     }\n }\n \n-pub fn const_get_real(v: ValueRef) -> Option<(f64, bool)> {\n+pub fn const_get_real(v: &'ll Value) -> Option<(f64, bool)> {\n     unsafe {\n         if is_const_real(v) {\n             let mut loses_info: llvm::Bool = ::std::mem::uninitialized();\n-            let r = llvm::LLVMConstRealGetDouble(v, &mut loses_info as *mut llvm::Bool);\n+            let r = llvm::LLVMConstRealGetDouble(v, &mut loses_info);\n             let loses_info = if loses_info == 1 { true } else { false };\n             Some((r, loses_info))\n         } else {\n@@ -282,21 +290,21 @@ pub fn const_get_real(v: ValueRef) -> Option<(f64, bool)> {\n     }\n }\n \n-pub fn const_to_uint(v: ValueRef) -> u64 {\n+pub fn const_to_uint(v: &'ll Value) -> u64 {\n     unsafe {\n         llvm::LLVMConstIntGetZExtValue(v)\n     }\n }\n \n-pub fn is_const_integral(v: ValueRef) -> bool {\n+pub fn is_const_integral(v: &'ll Value) -> bool {\n     unsafe {\n-        !llvm::LLVMIsAConstantInt(v).is_null()\n+        llvm::LLVMIsAConstantInt(v).is_some()\n     }\n }\n \n-pub fn is_const_real(v: ValueRef) -> bool {\n+pub fn is_const_real(v: &'ll Value) -> bool {\n     unsafe {\n-        !llvm::LLVMIsAConstantFP(v).is_null()\n+        llvm::LLVMIsAConstantFP(v).is_some()\n     }\n }\n \n@@ -306,12 +314,12 @@ fn hi_lo_to_u128(lo: u64, hi: u64) -> u128 {\n     ((hi as u128) << 64) | (lo as u128)\n }\n \n-pub fn const_to_opt_u128(v: ValueRef, sign_ext: bool) -> Option<u128> {\n+pub fn const_to_opt_u128(v: &'ll Value, sign_ext: bool) -> Option<u128> {\n     unsafe {\n         if is_const_integral(v) {\n             let (mut lo, mut hi) = (0u64, 0u64);\n             let success = llvm::LLVMRustConstInt128Get(v, sign_ext,\n-                                                       &mut hi as *mut u64, &mut lo as *mut u64);\n+                                                       &mut hi, &mut lo);\n             if success {\n                 Some(hi_lo_to_u128(lo, hi))\n             } else {\n@@ -345,20 +353,20 @@ pub fn langcall(tcx: TyCtxt,\n // all shifts). For 32- and 64-bit types, this matches the semantics\n // of Java. (See related discussion on #1877 and #10183.)\n \n-pub fn build_unchecked_lshift<'a, 'tcx>(\n-    bx: &Builder<'a, 'tcx>,\n-    lhs: ValueRef,\n-    rhs: ValueRef\n-) -> ValueRef {\n+pub fn build_unchecked_lshift(\n+    bx: &Builder<'a, 'll, 'tcx>,\n+    lhs: &'ll Value,\n+    rhs: &'ll Value\n+) -> &'ll Value {\n     let rhs = base::cast_shift_expr_rhs(bx, hir::BinOpKind::Shl, lhs, rhs);\n     // #1877, #10183: Ensure that input is always valid\n     let rhs = shift_mask_rhs(bx, rhs);\n     bx.shl(lhs, rhs)\n }\n \n-pub fn build_unchecked_rshift<'a, 'tcx>(\n-    bx: &Builder<'a, 'tcx>, lhs_t: Ty<'tcx>, lhs: ValueRef, rhs: ValueRef\n-) -> ValueRef {\n+pub fn build_unchecked_rshift(\n+    bx: &Builder<'a, 'll, 'tcx>, lhs_t: Ty<'tcx>, lhs: &'ll Value, rhs: &'ll Value\n+) -> &'ll Value {\n     let rhs = base::cast_shift_expr_rhs(bx, hir::BinOpKind::Shr, lhs, rhs);\n     // #1877, #10183: Ensure that input is always valid\n     let rhs = shift_mask_rhs(bx, rhs);\n@@ -370,17 +378,17 @@ pub fn build_unchecked_rshift<'a, 'tcx>(\n     }\n }\n \n-fn shift_mask_rhs<'a, 'tcx>(bx: &Builder<'a, 'tcx>, rhs: ValueRef) -> ValueRef {\n+fn shift_mask_rhs(bx: &Builder<'a, 'll, 'tcx>, rhs: &'ll Value) -> &'ll Value {\n     let rhs_llty = val_ty(rhs);\n     bx.and(rhs, shift_mask_val(bx, rhs_llty, rhs_llty, false))\n }\n \n-pub fn shift_mask_val<'a, 'tcx>(\n-    bx: &Builder<'a, 'tcx>,\n-    llty: Type,\n-    mask_llty: Type,\n+pub fn shift_mask_val(\n+    bx: &Builder<'a, 'll, 'tcx>,\n+    llty: &'ll Type,\n+    mask_llty: &'ll Type,\n     invert: bool\n-) -> ValueRef {\n+) -> &'ll Value {\n     let kind = llty.kind();\n     match kind {\n         TypeKind::Integer => {"}, {"sha": "72ff65361cada9d3e6974d100f27f1a61f2f76fe", "filename": "src/librustc_codegen_llvm/consts.rs", "status": "modified", "additions": 28, "deletions": 26, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/f89817997ac0aa100bf91997194ad85a7e59f743/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f89817997ac0aa100bf91997194ad85a7e59f743/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fconsts.rs?ref=f89817997ac0aa100bf91997194ad85a7e59f743", "patch": "@@ -9,9 +9,7 @@\n // except according to those terms.\n \n use libc::c_uint;\n-use llvm;\n-use llvm::{SetUnnamedAddr};\n-use llvm::{ValueRef, True};\n+use llvm::{self, SetUnnamedAddr, True};\n use rustc::hir::def_id::DefId;\n use rustc::hir::map as hir_map;\n use debuginfo;\n@@ -24,27 +22,29 @@ use syntax_pos::Span;\n use syntax_pos::symbol::LocalInternedString;\n use type_::Type;\n use type_of::LayoutLlvmExt;\n+use value::Value;\n use rustc::ty::{self, Ty};\n+\n use rustc::ty::layout::{Align, LayoutOf};\n \n use rustc::hir::{self, CodegenFnAttrs, CodegenFnAttrFlags};\n \n use std::ffi::{CStr, CString};\n \n-pub fn ptrcast(val: ValueRef, ty: Type) -> ValueRef {\n+pub fn ptrcast(val: &'ll Value, ty: &'ll Type) -> &'ll Value {\n     unsafe {\n-        llvm::LLVMConstPointerCast(val, ty.to_ref())\n+        llvm::LLVMConstPointerCast(val, ty)\n     }\n }\n \n-pub fn bitcast(val: ValueRef, ty: Type) -> ValueRef {\n+pub fn bitcast(val: &'ll Value, ty: &'ll Type) -> &'ll Value {\n     unsafe {\n-        llvm::LLVMConstBitCast(val, ty.to_ref())\n+        llvm::LLVMConstBitCast(val, ty)\n     }\n }\n \n-fn set_global_alignment(cx: &CodegenCx,\n-                        gv: ValueRef,\n+fn set_global_alignment(cx: &CodegenCx<'ll, '_>,\n+                        gv: &'ll Value,\n                         mut align: Align) {\n     // The target may require greater alignment for globals than the type does.\n     // Note: GCC and Clang also allow `__attribute__((aligned))` on variables,\n@@ -62,11 +62,12 @@ fn set_global_alignment(cx: &CodegenCx,\n     }\n }\n \n-pub fn addr_of_mut(cx: &CodegenCx,\n-                   cv: ValueRef,\n-                   align: Align,\n-                   kind: &str)\n-                    -> ValueRef {\n+pub fn addr_of_mut(\n+    cx: &CodegenCx<'ll, '_>,\n+    cv: &'ll Value,\n+    align: Align,\n+    kind: &str,\n+) -> &'ll Value {\n     unsafe {\n         let name = cx.generate_local_symbol_name(kind);\n         let gv = declare::define_global(cx, &name[..], val_ty(cv)).unwrap_or_else(||{\n@@ -80,11 +81,12 @@ pub fn addr_of_mut(cx: &CodegenCx,\n     }\n }\n \n-pub fn addr_of(cx: &CodegenCx,\n-               cv: ValueRef,\n-               align: Align,\n-               kind: &str)\n-               -> ValueRef {\n+pub fn addr_of(\n+    cx: &CodegenCx<'ll, '_>,\n+    cv: &'ll Value,\n+    align: Align,\n+    kind: &str,\n+) -> &'ll Value {\n     if let Some(&gv) = cx.const_globals.borrow().get(&cv) {\n         unsafe {\n             // Upgrade the alignment in cases where the same constant is used with different\n@@ -104,7 +106,7 @@ pub fn addr_of(cx: &CodegenCx,\n     gv\n }\n \n-pub fn get_static(cx: &CodegenCx, def_id: DefId) -> ValueRef {\n+pub fn get_static(cx: &CodegenCx<'ll, '_>, def_id: DefId) -> &'ll Value {\n     let instance = Instance::mono(cx.tcx, def_id);\n     if let Some(&g) = cx.instances.borrow().get(&instance) {\n         return g;\n@@ -213,13 +215,13 @@ pub fn get_static(cx: &CodegenCx, def_id: DefId) -> ValueRef {\n     g\n }\n \n-fn check_and_apply_linkage<'tcx>(\n-    cx: &CodegenCx<'_, 'tcx>,\n+fn check_and_apply_linkage(\n+    cx: &CodegenCx<'ll, 'tcx>,\n     attrs: &CodegenFnAttrs,\n     ty: Ty<'tcx>,\n     sym: LocalInternedString,\n     span: Option<Span>\n-) -> ValueRef {\n+) -> &'ll Value {\n     let llty = cx.layout_of(ty).llvm_type(cx);\n     if let Some(linkage) = attrs.linkage {\n         debug!(\"get_static: sym={} linkage={:?}\", sym, linkage);\n@@ -294,7 +296,7 @@ pub fn codegen_static<'a, 'tcx>(\n         let mut val_llty = val_ty(v);\n         let v = if val_llty == Type::i1(cx) {\n             val_llty = Type::i8(cx);\n-            llvm::LLVMConstZExt(v, val_llty.to_ref())\n+            llvm::LLVMConstZExt(v, val_llty)\n         } else {\n             v\n         };\n@@ -316,7 +318,7 @@ pub fn codegen_static<'a, 'tcx>(\n             let visibility = llvm::LLVMRustGetVisibility(g);\n \n             let new_g = llvm::LLVMRustGetOrInsertGlobal(\n-                cx.llmod, name_string.as_ptr(), val_llty.to_ref());\n+                cx.llmod, name_string.as_ptr(), val_llty);\n \n             llvm::LLVMRustSetLinkage(new_g, linkage);\n             llvm::LLVMRustSetVisibility(new_g, visibility);\n@@ -411,7 +413,7 @@ pub fn codegen_static<'a, 'tcx>(\n \n         if attrs.flags.contains(CodegenFnAttrFlags::USED) {\n             // This static will be stored in the llvm.used variable which is an array of i8*\n-            let cast = llvm::LLVMConstPointerCast(g, Type::i8p(cx).to_ref());\n+            let cast = llvm::LLVMConstPointerCast(g, Type::i8p(cx));\n             cx.used_statics.borrow_mut().push(cast);\n         }\n     }"}, {"sha": "11f8e75831eedfa0c5d4d30cd11d4a06edba13a5", "filename": "src/librustc_codegen_llvm/context.rs", "status": "modified", "additions": 93, "deletions": 98, "changes": 191, "blob_url": "https://github.com/rust-lang/rust/blob/f89817997ac0aa100bf91997194ad85a7e59f743/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f89817997ac0aa100bf91997194ad85a7e59f743/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcontext.rs?ref=f89817997ac0aa100bf91997194ad85a7e59f743", "patch": "@@ -10,7 +10,6 @@\n \n use common;\n use llvm;\n-use llvm::{ContextRef, ModuleRef, ValueRef};\n use rustc::dep_graph::DepGraphSafe;\n use rustc::hir;\n use rustc::hir::def_id::DefId;\n@@ -19,6 +18,7 @@ use callee;\n use base;\n use declare;\n use monomorphize::Instance;\n+use value::Value;\n \n use monomorphize::partitioning::CodegenUnit;\n use type_::Type;\n@@ -35,73 +35,72 @@ use rustc_target::spec::{HasTargetSpec, Target};\n \n use std::ffi::{CStr, CString};\n use std::cell::{Cell, RefCell};\n-use std::ptr;\n use std::iter;\n use std::str;\n use std::sync::Arc;\n use syntax::symbol::LocalInternedString;\n use abi::Abi;\n \n /// There is one `CodegenCx` per compilation unit. Each one has its own LLVM\n-/// `ContextRef` so that several compilation units may be optimized in parallel.\n-/// All other LLVM data structures in the `CodegenCx` are tied to that `ContextRef`.\n+/// `llvm::Context` so that several compilation units may be optimized in parallel.\n+/// All other LLVM data structures in the `CodegenCx` are tied to that `llvm::Context`.\n pub struct CodegenCx<'a, 'tcx: 'a> {\n     pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     pub check_overflow: bool,\n     pub use_dll_storage_attrs: bool,\n     pub tls_model: llvm::ThreadLocalMode,\n \n-    pub llmod: ModuleRef,\n-    pub llcx: ContextRef,\n+    pub llmod: &'a llvm::Module,\n+    pub llcx: &'a llvm::Context,\n     pub stats: RefCell<Stats>,\n     pub codegen_unit: Arc<CodegenUnit<'tcx>>,\n \n     /// Cache instances of monomorphic and polymorphic items\n-    pub instances: RefCell<FxHashMap<Instance<'tcx>, ValueRef>>,\n+    pub instances: RefCell<FxHashMap<Instance<'tcx>, &'a Value>>,\n     /// Cache generated vtables\n     pub vtables: RefCell<FxHashMap<(Ty<'tcx>,\n-                                Option<ty::PolyExistentialTraitRef<'tcx>>), ValueRef>>,\n+                                Option<ty::PolyExistentialTraitRef<'tcx>>), &'a Value>>,\n     /// Cache of constant strings,\n-    pub const_cstr_cache: RefCell<FxHashMap<LocalInternedString, ValueRef>>,\n+    pub const_cstr_cache: RefCell<FxHashMap<LocalInternedString, &'a Value>>,\n \n     /// Reverse-direction for const ptrs cast from globals.\n-    /// Key is a ValueRef holding a *T,\n-    /// Val is a ValueRef holding a *[T].\n+    /// Key is a Value holding a *T,\n+    /// Val is a Value holding a *[T].\n     ///\n     /// Needed because LLVM loses pointer->pointee association\n     /// when we ptrcast, and we have to ptrcast during codegen\n     /// of a [T] const because we form a slice, a (*T,usize) pair, not\n     /// a pointer to an LLVM array type. Similar for trait objects.\n-    pub const_unsized: RefCell<FxHashMap<ValueRef, ValueRef>>,\n+    pub const_unsized: RefCell<FxHashMap<&'a Value, &'a Value>>,\n \n     /// Cache of emitted const globals (value -> global)\n-    pub const_globals: RefCell<FxHashMap<ValueRef, ValueRef>>,\n+    pub const_globals: RefCell<FxHashMap<&'a Value, &'a Value>>,\n \n     /// Mapping from static definitions to their DefId's.\n-    pub statics: RefCell<FxHashMap<ValueRef, DefId>>,\n+    pub statics: RefCell<FxHashMap<&'a Value, DefId>>,\n \n     /// List of globals for static variables which need to be passed to the\n     /// LLVM function ReplaceAllUsesWith (RAUW) when codegen is complete.\n-    /// (We have to make sure we don't invalidate any ValueRefs referring\n+    /// (We have to make sure we don't invalidate any Values referring\n     /// to constants.)\n-    pub statics_to_rauw: RefCell<Vec<(ValueRef, ValueRef)>>,\n+    pub statics_to_rauw: RefCell<Vec<(&'a Value, &'a Value)>>,\n \n     /// Statics that will be placed in the llvm.used variable\n     /// See http://llvm.org/docs/LangRef.html#the-llvm-used-global-variable for details\n-    pub used_statics: RefCell<Vec<ValueRef>>,\n+    pub used_statics: RefCell<Vec<&'a Value>>,\n \n-    pub lltypes: RefCell<FxHashMap<(Ty<'tcx>, Option<usize>), Type>>,\n-    pub scalar_lltypes: RefCell<FxHashMap<Ty<'tcx>, Type>>,\n+    pub lltypes: RefCell<FxHashMap<(Ty<'tcx>, Option<usize>), &'a Type>>,\n+    pub scalar_lltypes: RefCell<FxHashMap<Ty<'tcx>, &'a Type>>,\n     pub pointee_infos: RefCell<FxHashMap<(Ty<'tcx>, Size), Option<PointeeInfo>>>,\n-    pub isize_ty: Type,\n+    pub isize_ty: &'a Type,\n \n-    pub dbg_cx: Option<debuginfo::CrateDebugContext<'tcx>>,\n+    pub dbg_cx: Option<debuginfo::CrateDebugContext<'a, 'tcx>>,\n \n-    eh_personality: Cell<Option<ValueRef>>,\n-    eh_unwind_resume: Cell<Option<ValueRef>>,\n-    pub rust_try_fn: Cell<Option<ValueRef>>,\n+    eh_personality: Cell<Option<&'a Value>>,\n+    eh_unwind_resume: Cell<Option<&'a Value>>,\n+    pub rust_try_fn: Cell<Option<&'a Value>>,\n \n-    intrinsics: RefCell<FxHashMap<&'static str, ValueRef>>,\n+    intrinsics: RefCell<FxHashMap<&'static str, &'a Value>>,\n \n     /// A counter that is used for generating local symbol names\n     local_gen_sym_counter: Cell<usize>,\n@@ -156,8 +155,11 @@ pub fn is_pie_binary(sess: &Session) -> bool {\n     !is_any_library(sess) && get_reloc_model(sess) == llvm::RelocMode::PIC\n }\n \n-pub unsafe fn create_context_and_module(sess: &Session, mod_name: &str) -> (ContextRef, ModuleRef) {\n-    let llcx = llvm::LLVMRustContextCreate(sess.fewer_names());\n+pub unsafe fn create_module(\n+    sess: &Session,\n+    llcx: &'ll llvm::Context,\n+    mod_name: &str,\n+) -> &'ll llvm::Module {\n     let mod_name = CString::new(mod_name).unwrap();\n     let llmod = llvm::LLVMModuleCreateWithNameInContext(mod_name.as_ptr(), llcx);\n \n@@ -209,13 +211,13 @@ pub unsafe fn create_context_and_module(sess: &Session, mod_name: &str) -> (Cont\n         llvm::LLVMRustSetModulePIELevel(llmod);\n     }\n \n-    (llcx, llmod)\n+    llmod\n }\n \n impl<'a, 'tcx> CodegenCx<'a, 'tcx> {\n-    pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    crate fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                codegen_unit: Arc<CodegenUnit<'tcx>>,\n-               llmod_id: &str)\n+               llvm_module: &'a ::ModuleLlvm)\n                -> CodegenCx<'a, 'tcx> {\n         // An interesting part of Windows which MSVC forces our hand on (and\n         // apparently MinGW didn't) is the usage of `dllimport` and `dllexport`\n@@ -266,55 +268,48 @@ impl<'a, 'tcx> CodegenCx<'a, 'tcx> {\n \n         let tls_model = get_tls_model(&tcx.sess);\n \n-        unsafe {\n-            let (llcx, llmod) = create_context_and_module(&tcx.sess,\n-                                                          &llmod_id[..]);\n-\n-            let dbg_cx = if tcx.sess.opts.debuginfo != NoDebugInfo {\n-                let dctx = debuginfo::CrateDebugContext::new(llmod);\n-                debuginfo::metadata::compile_unit_metadata(tcx,\n-                                                           &codegen_unit.name().as_str(),\n-                                                           &dctx);\n-                Some(dctx)\n-            } else {\n-                None\n-            };\n-\n-            let mut cx = CodegenCx {\n-                tcx,\n-                check_overflow,\n-                use_dll_storage_attrs,\n-                tls_model,\n-                llmod,\n-                llcx,\n-                stats: RefCell::new(Stats::default()),\n-                codegen_unit,\n-                instances: RefCell::new(FxHashMap()),\n-                vtables: RefCell::new(FxHashMap()),\n-                const_cstr_cache: RefCell::new(FxHashMap()),\n-                const_unsized: RefCell::new(FxHashMap()),\n-                const_globals: RefCell::new(FxHashMap()),\n-                statics: RefCell::new(FxHashMap()),\n-                statics_to_rauw: RefCell::new(Vec::new()),\n-                used_statics: RefCell::new(Vec::new()),\n-                lltypes: RefCell::new(FxHashMap()),\n-                scalar_lltypes: RefCell::new(FxHashMap()),\n-                pointee_infos: RefCell::new(FxHashMap()),\n-                isize_ty: Type::from_ref(ptr::null_mut()),\n-                dbg_cx,\n-                eh_personality: Cell::new(None),\n-                eh_unwind_resume: Cell::new(None),\n-                rust_try_fn: Cell::new(None),\n-                intrinsics: RefCell::new(FxHashMap()),\n-                local_gen_sym_counter: Cell::new(0),\n-            };\n-            cx.isize_ty = Type::isize(&cx);\n-            cx\n-        }\n-    }\n+        let (llcx, llmod) = (&*llvm_module.llcx, llvm_module.llmod());\n \n-    pub fn into_stats(self) -> Stats {\n-        self.stats.into_inner()\n+        let dbg_cx = if tcx.sess.opts.debuginfo != NoDebugInfo {\n+            let dctx = debuginfo::CrateDebugContext::new(llmod);\n+            debuginfo::metadata::compile_unit_metadata(tcx,\n+                                                        &codegen_unit.name().as_str(),\n+                                                        &dctx);\n+            Some(dctx)\n+        } else {\n+            None\n+        };\n+\n+        let isize_ty = Type::ix_llcx(llcx, tcx.data_layout.pointer_size.bits());\n+\n+        CodegenCx {\n+            tcx,\n+            check_overflow,\n+            use_dll_storage_attrs,\n+            tls_model,\n+            llmod,\n+            llcx,\n+            stats: RefCell::new(Stats::default()),\n+            codegen_unit,\n+            instances: RefCell::new(FxHashMap()),\n+            vtables: RefCell::new(FxHashMap()),\n+            const_cstr_cache: RefCell::new(FxHashMap()),\n+            const_unsized: RefCell::new(FxHashMap()),\n+            const_globals: RefCell::new(FxHashMap()),\n+            statics: RefCell::new(FxHashMap()),\n+            statics_to_rauw: RefCell::new(Vec::new()),\n+            used_statics: RefCell::new(Vec::new()),\n+            lltypes: RefCell::new(FxHashMap()),\n+            scalar_lltypes: RefCell::new(FxHashMap()),\n+            pointee_infos: RefCell::new(FxHashMap()),\n+            isize_ty,\n+            dbg_cx,\n+            eh_personality: Cell::new(None),\n+            eh_unwind_resume: Cell::new(None),\n+            rust_try_fn: Cell::new(None),\n+            intrinsics: RefCell::new(FxHashMap()),\n+            local_gen_sym_counter: Cell::new(0),\n+        }\n     }\n }\n \n@@ -323,7 +318,7 @@ impl<'b, 'tcx> CodegenCx<'b, 'tcx> {\n         &self.tcx.sess\n     }\n \n-    pub fn get_intrinsic(&self, key: &str) -> ValueRef {\n+    pub fn get_intrinsic(&self, key: &str) -> &'b Value {\n         if let Some(v) = self.intrinsics.borrow().get(key).cloned() {\n             return v;\n         }\n@@ -347,7 +342,7 @@ impl<'b, 'tcx> CodegenCx<'b, 'tcx> {\n         name\n     }\n \n-    pub fn eh_personality(&self) -> ValueRef {\n+    pub fn eh_personality(&self) -> &'b Value {\n         // The exception handling personality function.\n         //\n         // If our compilation unit has the `eh_personality` lang item somewhere\n@@ -382,17 +377,17 @@ impl<'b, 'tcx> CodegenCx<'b, 'tcx> {\n                 } else {\n                     \"rust_eh_personality\"\n                 };\n-                let fty = Type::variadic_func(&[], &Type::i32(self));\n+                let fty = Type::variadic_func(&[], Type::i32(self));\n                 declare::declare_cfn(self, name, fty)\n             }\n         };\n         self.eh_personality.set(Some(llfn));\n         llfn\n     }\n \n-    // Returns a ValueRef of the \"eh_unwind_resume\" lang item if one is defined,\n+    // Returns a Value of the \"eh_unwind_resume\" lang item if one is defined,\n     // otherwise declares it as an external function.\n-    pub fn eh_unwind_resume(&self) -> ValueRef {\n+    pub fn eh_unwind_resume(&self) -> &'b Value {\n         use attributes;\n         let unwresume = &self.eh_unwind_resume;\n         if let Some(llfn) = unwresume.get() {\n@@ -448,25 +443,25 @@ impl<'b, 'tcx> CodegenCx<'b, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> ty::layout::HasDataLayout for &'a CodegenCx<'a, 'tcx> {\n+impl ty::layout::HasDataLayout for &'a CodegenCx<'ll, 'tcx> {\n     fn data_layout(&self) -> &ty::layout::TargetDataLayout {\n         &self.tcx.data_layout\n     }\n }\n \n-impl<'a, 'tcx> HasTargetSpec for &'a CodegenCx<'a, 'tcx> {\n+impl HasTargetSpec for &'a CodegenCx<'ll, 'tcx> {\n     fn target_spec(&self) -> &Target {\n         &self.tcx.sess.target.target\n     }\n }\n \n-impl<'a, 'tcx> ty::layout::HasTyCtxt<'tcx> for &'a CodegenCx<'a, 'tcx> {\n+impl ty::layout::HasTyCtxt<'tcx> for &'a CodegenCx<'ll, 'tcx> {\n     fn tcx<'b>(&'b self) -> TyCtxt<'b, 'tcx, 'tcx> {\n         self.tcx\n     }\n }\n \n-impl<'a, 'tcx> LayoutOf for &'a CodegenCx<'a, 'tcx> {\n+impl LayoutOf for &'a CodegenCx<'ll, 'tcx> {\n     type Ty = Ty<'tcx>;\n     type TyLayout = TyLayout<'tcx>;\n \n@@ -480,27 +475,27 @@ impl<'a, 'tcx> LayoutOf for &'a CodegenCx<'a, 'tcx> {\n }\n \n /// Declare any llvm intrinsics that you might need\n-fn declare_intrinsic(cx: &CodegenCx, key: &str) -> Option<ValueRef> {\n+fn declare_intrinsic(cx: &CodegenCx<'ll, '_>, key: &str) -> Option<&'ll Value> {\n     macro_rules! ifn {\n         ($name:expr, fn() -> $ret:expr) => (\n             if key == $name {\n-                let f = declare::declare_cfn(cx, $name, Type::func(&[], &$ret));\n+                let f = declare::declare_cfn(cx, $name, Type::func(&[], $ret));\n                 llvm::SetUnnamedAddr(f, false);\n                 cx.intrinsics.borrow_mut().insert($name, f.clone());\n                 return Some(f);\n             }\n         );\n         ($name:expr, fn(...) -> $ret:expr) => (\n             if key == $name {\n-                let f = declare::declare_cfn(cx, $name, Type::variadic_func(&[], &$ret));\n+                let f = declare::declare_cfn(cx, $name, Type::variadic_func(&[], $ret));\n                 llvm::SetUnnamedAddr(f, false);\n                 cx.intrinsics.borrow_mut().insert($name, f.clone());\n                 return Some(f);\n             }\n         );\n         ($name:expr, fn($($arg:expr),*) -> $ret:expr) => (\n             if key == $name {\n-                let f = declare::declare_cfn(cx, $name, Type::func(&[$($arg),*], &$ret));\n+                let f = declare::declare_cfn(cx, $name, Type::func(&[$($arg),*], $ret));\n                 llvm::SetUnnamedAddr(f, false);\n                 cx.intrinsics.borrow_mut().insert($name, f.clone());\n                 return Some(f);\n@@ -522,14 +517,14 @@ fn declare_intrinsic(cx: &CodegenCx, key: &str) -> Option<ValueRef> {\n     let t_f32 = Type::f32(cx);\n     let t_f64 = Type::f64(cx);\n \n-    let t_v2f32 = Type::vector(&t_f32, 2);\n-    let t_v4f32 = Type::vector(&t_f32, 4);\n-    let t_v8f32 = Type::vector(&t_f32, 8);\n-    let t_v16f32 = Type::vector(&t_f32, 16);\n+    let t_v2f32 = Type::vector(t_f32, 2);\n+    let t_v4f32 = Type::vector(t_f32, 4);\n+    let t_v8f32 = Type::vector(t_f32, 8);\n+    let t_v16f32 = Type::vector(t_f32, 16);\n \n-    let t_v2f64 = Type::vector(&t_f64, 2);\n-    let t_v4f64 = Type::vector(&t_f64, 4);\n-    let t_v8f64 = Type::vector(&t_f64, 8);\n+    let t_v2f64 = Type::vector(t_f64, 2);\n+    let t_v4f64 = Type::vector(t_f64, 4);\n+    let t_v8f64 = Type::vector(t_f64, 8);\n \n     ifn!(\"llvm.memcpy.p0i8.p0i8.i16\", fn(i8p, i8p, t_i16, t_i32, i1) -> void);\n     ifn!(\"llvm.memcpy.p0i8.p0i8.i32\", fn(i8p, i8p, t_i32, t_i32, i1) -> void);"}, {"sha": "5273032f2d7f5fd8d68a4f760b4a19fbbcb1a216", "filename": "src/librustc_codegen_llvm/debuginfo/create_scope_map.rs", "status": "modified", "additions": 18, "deletions": 16, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/f89817997ac0aa100bf91997194ad85a7e59f743/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fcreate_scope_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f89817997ac0aa100bf91997194ad85a7e59f743/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fcreate_scope_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fcreate_scope_map.rs?ref=f89817997ac0aa100bf91997194ad85a7e59f743", "patch": "@@ -18,7 +18,6 @@ use common::CodegenCx;\n use rustc::mir::{Mir, SourceScope};\n \n use libc::c_uint;\n-use std::ptr;\n \n use syntax_pos::Pos;\n \n@@ -28,26 +27,29 @@ use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n use syntax_pos::BytePos;\n \n #[derive(Clone, Copy, Debug)]\n-pub struct MirDebugScope {\n-    pub scope_metadata: DIScope,\n+pub struct MirDebugScope<'ll> {\n+    pub scope_metadata: Option<&'ll DIScope>,\n     // Start and end offsets of the file to which this DIScope belongs.\n     // These are used to quickly determine whether some span refers to the same file.\n     pub file_start_pos: BytePos,\n     pub file_end_pos: BytePos,\n }\n \n-impl MirDebugScope {\n+impl MirDebugScope<'ll> {\n     pub fn is_valid(&self) -> bool {\n-        !self.scope_metadata.is_null()\n+        !self.scope_metadata.is_none()\n     }\n }\n \n /// Produce DIScope DIEs for each MIR Scope which has variables defined in it.\n /// If debuginfo is disabled, the returned vector is empty.\n-pub fn create_mir_scopes(cx: &CodegenCx, mir: &Mir, debug_context: &FunctionDebugContext)\n-    -> IndexVec<SourceScope, MirDebugScope> {\n+pub fn create_mir_scopes(\n+    cx: &CodegenCx<'ll, '_>,\n+    mir: &Mir,\n+    debug_context: &FunctionDebugContext<'ll>,\n+) -> IndexVec<SourceScope, MirDebugScope<'ll>> {\n     let null_scope = MirDebugScope {\n-        scope_metadata: ptr::null_mut(),\n+        scope_metadata: None,\n         file_start_pos: BytePos(0),\n         file_end_pos: BytePos(0)\n     };\n@@ -77,12 +79,12 @@ pub fn create_mir_scopes(cx: &CodegenCx, mir: &Mir, debug_context: &FunctionDebu\n     scopes\n }\n \n-fn make_mir_scope(cx: &CodegenCx,\n+fn make_mir_scope(cx: &CodegenCx<'ll, '_>,\n                   mir: &Mir,\n                   has_variables: &BitVector<SourceScope>,\n-                  debug_context: &FunctionDebugContextData,\n+                  debug_context: &FunctionDebugContextData<'ll>,\n                   scope: SourceScope,\n-                  scopes: &mut IndexVec<SourceScope, MirDebugScope>) {\n+                  scopes: &mut IndexVec<SourceScope, MirDebugScope<'ll>>) {\n     if scopes[scope].is_valid() {\n         return;\n     }\n@@ -95,7 +97,7 @@ fn make_mir_scope(cx: &CodegenCx,\n         // The root is the function itself.\n         let loc = span_start(cx, mir.span);\n         scopes[scope] = MirDebugScope {\n-            scope_metadata: debug_context.fn_metadata,\n+            scope_metadata: Some(debug_context.fn_metadata),\n             file_start_pos: loc.file.start_pos,\n             file_end_pos: loc.file.end_pos,\n         };\n@@ -109,7 +111,7 @@ fn make_mir_scope(cx: &CodegenCx,\n         // However, we don't skip creating a nested scope if\n         // our parent is the root, because we might want to\n         // put arguments in the root and not have shadowing.\n-        if parent_scope.scope_metadata != debug_context.fn_metadata {\n+        if parent_scope.scope_metadata.unwrap() != debug_context.fn_metadata {\n             scopes[scope] = parent_scope;\n             return;\n         }\n@@ -121,12 +123,12 @@ fn make_mir_scope(cx: &CodegenCx,\n                                       debug_context.defining_crate);\n \n     let scope_metadata = unsafe {\n-        llvm::LLVMRustDIBuilderCreateLexicalBlock(\n+        Some(llvm::LLVMRustDIBuilderCreateLexicalBlock(\n             DIB(cx),\n-            parent_scope.scope_metadata,\n+            parent_scope.scope_metadata.unwrap(),\n             file_metadata,\n             loc.line as c_uint,\n-            loc.col.to_usize() as c_uint)\n+            loc.col.to_usize() as c_uint))\n     };\n     scopes[scope] = MirDebugScope {\n         scope_metadata,"}, {"sha": "08128a729b5f0ca02dc8bcc31e4ac929a2cdac2c", "filename": "src/librustc_codegen_llvm/debuginfo/gdb.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f89817997ac0aa100bf91997194ad85a7e59f743/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fgdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f89817997ac0aa100bf91997194ad85a7e59f743/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fgdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fgdb.rs?ref=f89817997ac0aa100bf91997194ad85a7e59f743", "patch": "@@ -15,10 +15,10 @@ use llvm;\n use common::{C_bytes, CodegenCx, C_i32};\n use builder::Builder;\n use declare;\n-use type_::Type;\n use rustc::session::config::NoDebugInfo;\n+use type_::Type;\n+use value::Value;\n \n-use std::ptr;\n use syntax::attr;\n \n \n@@ -40,8 +40,8 @@ pub fn insert_reference_to_gdb_debug_scripts_section_global(bx: &Builder) {\n \n /// Allocates the global variable responsible for the .debug_gdb_scripts binary\n /// section.\n-pub fn get_or_insert_gdb_debug_scripts_section_global(cx: &CodegenCx)\n-                                                  -> llvm::ValueRef {\n+pub fn get_or_insert_gdb_debug_scripts_section_global(cx: &CodegenCx<'ll, '_>)\n+                                                  -> &'ll Value {\n     let c_section_var_name = \"__rustc_debug_gdb_scripts_section__\\0\";\n     let section_var_name = &c_section_var_name[..c_section_var_name.len()-1];\n \n@@ -50,12 +50,12 @@ pub fn get_or_insert_gdb_debug_scripts_section_global(cx: &CodegenCx)\n                                  c_section_var_name.as_ptr() as *const _)\n     };\n \n-    if section_var == ptr::null_mut() {\n+    section_var.unwrap_or_else(|| {\n         let section_name = b\".debug_gdb_scripts\\0\";\n         let section_contents = b\"\\x01gdb_load_rust_pretty_printers.py\\0\";\n \n         unsafe {\n-            let llvm_type = Type::array(&Type::i8(cx),\n+            let llvm_type = Type::array(Type::i8(cx),\n                                         section_contents.len() as u64);\n \n             let section_var = declare::define_global(cx, section_var_name,\n@@ -72,9 +72,7 @@ pub fn get_or_insert_gdb_debug_scripts_section_global(cx: &CodegenCx)\n             llvm::LLVMSetAlignment(section_var, 1);\n             section_var\n         }\n-    } else {\n-        section_var\n-    }\n+    })\n }\n \n pub fn needs_gdb_debug_scripts_section(cx: &CodegenCx) -> bool {"}, {"sha": "69ef92ed98e52d51112f59381e14efc8828a3393", "filename": "src/librustc_codegen_llvm/debuginfo/metadata.rs", "status": "modified", "additions": 238, "deletions": 194, "changes": 432, "blob_url": "https://github.com/rust-lang/rust/blob/f89817997ac0aa100bf91997194ad85a7e59f743/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f89817997ac0aa100bf91997194ad85a7e59f743/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs?ref=f89817997ac0aa100bf91997194ad85a7e59f743", "patch": "@@ -18,8 +18,9 @@ use super::namespace::mangled_name_of_instance;\n use super::type_names::compute_debuginfo_type_name;\n use super::{CrateDebugContext};\n use abi;\n+use value::Value;\n \n-use llvm::{self, ValueRef};\n+use llvm;\n use llvm::debuginfo::{DIType, DIFile, DIScope, DIDescriptor,\n                       DICompositeType, DILexicalBlock, DIFlags};\n \n@@ -38,14 +39,34 @@ use rustc::util::common::path2cstr;\n \n use libc::{c_uint, c_longlong};\n use std::ffi::CString;\n-use std::fmt::Write;\n+use std::fmt::{self, Write};\n+use std::hash::{Hash, Hasher};\n use std::iter;\n use std::ptr;\n use std::path::{Path, PathBuf};\n use syntax::ast;\n use syntax::symbol::{Interner, InternedString, Symbol};\n use syntax_pos::{self, Span, FileName};\n \n+impl PartialEq for llvm::Metadata {\n+    fn eq(&self, other: &Self) -> bool {\n+        self as *const _ == other as *const _\n+    }\n+}\n+\n+impl Eq for llvm::Metadata {}\n+\n+impl Hash for llvm::Metadata {\n+    fn hash<H: Hasher>(&self, hasher: &mut H) {\n+        (self as *const Self).hash(hasher);\n+    }\n+}\n+\n+impl fmt::Debug for llvm::Metadata {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        (self as *const Self).fmt(f)\n+    }\n+}\n \n // From DWARF 5.\n // See http://www.dwarfstd.org/ShowIssue.php?issue=140129.1\n@@ -64,8 +85,7 @@ const DW_ATE_unsigned_char: c_uint = 0x08;\n pub const UNKNOWN_LINE_NUMBER: c_uint = 0;\n pub const UNKNOWN_COLUMN_NUMBER: c_uint = 0;\n \n-// ptr::null() doesn't work :(\n-pub const NO_SCOPE_METADATA: DIScope = (0 as DIScope);\n+pub const NO_SCOPE_METADATA: Option<&DIScope> = None;\n \n #[derive(Copy, Debug, Hash, Eq, PartialEq, Clone)]\n pub struct UniqueTypeId(ast::Name);\n@@ -74,19 +94,19 @@ pub struct UniqueTypeId(ast::Name);\n // created so far. The metadata nodes are indexed by UniqueTypeId, and, for\n // faster lookup, also by Ty. The TypeMap is responsible for creating\n // UniqueTypeIds.\n-pub struct TypeMap<'tcx> {\n+pub struct TypeMap<'ll, 'tcx> {\n     // The UniqueTypeIds created so far\n     unique_id_interner: Interner,\n     // A map from UniqueTypeId to debuginfo metadata for that type. This is a 1:1 mapping.\n-    unique_id_to_metadata: FxHashMap<UniqueTypeId, DIType>,\n+    unique_id_to_metadata: FxHashMap<UniqueTypeId, &'ll DIType>,\n     // A map from types to debuginfo metadata. This is a N:1 mapping.\n-    type_to_metadata: FxHashMap<Ty<'tcx>, DIType>,\n+    type_to_metadata: FxHashMap<Ty<'tcx>, &'ll DIType>,\n     // A map from types to UniqueTypeId. This is a N:1 mapping.\n     type_to_unique_id: FxHashMap<Ty<'tcx>, UniqueTypeId>\n }\n \n-impl<'tcx> TypeMap<'tcx> {\n-    pub fn new() -> TypeMap<'tcx> {\n+impl TypeMap<'ll, 'tcx> {\n+    pub fn new() -> Self {\n         TypeMap {\n             unique_id_interner: Interner::new(),\n             type_to_metadata: FxHashMap(),\n@@ -97,30 +117,34 @@ impl<'tcx> TypeMap<'tcx> {\n \n     // Adds a Ty to metadata mapping to the TypeMap. The method will fail if\n     // the mapping already exists.\n-    fn register_type_with_metadata<'a>(&mut self,\n-                                       type_: Ty<'tcx>,\n-                                       metadata: DIType) {\n+    fn register_type_with_metadata(\n+        &mut self,\n+        type_: Ty<'tcx>,\n+        metadata: &'ll DIType,\n+    ) {\n         if self.type_to_metadata.insert(type_, metadata).is_some() {\n             bug!(\"Type metadata for Ty '{}' is already in the TypeMap!\", type_);\n         }\n     }\n \n     // Adds a UniqueTypeId to metadata mapping to the TypeMap. The method will\n     // fail if the mapping already exists.\n-    fn register_unique_id_with_metadata(&mut self,\n-                                        unique_type_id: UniqueTypeId,\n-                                        metadata: DIType) {\n+    fn register_unique_id_with_metadata(\n+        &mut self,\n+        unique_type_id: UniqueTypeId,\n+        metadata: &'ll DIType,\n+    ) {\n         if self.unique_id_to_metadata.insert(unique_type_id, metadata).is_some() {\n             bug!(\"Type metadata for unique id '{}' is already in the TypeMap!\",\n                  self.get_unique_type_id_as_string(unique_type_id));\n         }\n     }\n \n-    fn find_metadata_for_type(&self, type_: Ty<'tcx>) -> Option<DIType> {\n+    fn find_metadata_for_type(&self, type_: Ty<'tcx>) -> Option<&'ll DIType> {\n         self.type_to_metadata.get(&type_).cloned()\n     }\n \n-    fn find_metadata_for_unique_id(&self, unique_type_id: UniqueTypeId) -> Option<DIType> {\n+    fn find_metadata_for_unique_id(&self, unique_type_id: UniqueTypeId) -> Option<&'ll DIType> {\n         self.unique_id_to_metadata.get(&unique_type_id).cloned()\n     }\n \n@@ -182,23 +206,23 @@ impl<'tcx> TypeMap<'tcx> {\n // needed to generate the missing parts of the description. See the\n // documentation section on Recursive Types at the top of this file for more\n // information.\n-enum RecursiveTypeDescription<'tcx> {\n+enum RecursiveTypeDescription<'ll, 'tcx> {\n     UnfinishedMetadata {\n         unfinished_type: Ty<'tcx>,\n         unique_type_id: UniqueTypeId,\n-        metadata_stub: DICompositeType,\n-        member_description_factory: MemberDescriptionFactory<'tcx>,\n+        metadata_stub: &'ll DICompositeType,\n+        member_description_factory: MemberDescriptionFactory<'ll, 'tcx>,\n     },\n-    FinalMetadata(DICompositeType)\n+    FinalMetadata(&'ll DICompositeType)\n }\n \n-fn create_and_register_recursive_type_forward_declaration<'a, 'tcx>(\n-    cx: &CodegenCx<'a, 'tcx>,\n+fn create_and_register_recursive_type_forward_declaration(\n+    cx: &CodegenCx<'ll, 'tcx>,\n     unfinished_type: Ty<'tcx>,\n     unique_type_id: UniqueTypeId,\n-    metadata_stub: DICompositeType,\n-    member_description_factory: MemberDescriptionFactory<'tcx>)\n- -> RecursiveTypeDescription<'tcx> {\n+    metadata_stub: &'ll DICompositeType,\n+    member_description_factory: MemberDescriptionFactory<'ll, 'tcx>,\n+) -> RecursiveTypeDescription<'ll, 'tcx> {\n \n     // Insert the stub into the TypeMap in order to allow for recursive references\n     let mut type_map = debug_context(cx).type_map.borrow_mut();\n@@ -213,11 +237,11 @@ fn create_and_register_recursive_type_forward_declaration<'a, 'tcx>(\n     }\n }\n \n-impl<'tcx> RecursiveTypeDescription<'tcx> {\n+impl RecursiveTypeDescription<'ll, 'tcx> {\n     // Finishes up the description of the type in question (mostly by providing\n     // descriptions of the fields of the given type) and returns the final type\n     // metadata.\n-    fn finalize<'a>(&self, cx: &CodegenCx<'a, 'tcx>) -> MetadataCreationResult {\n+    fn finalize(&self, cx: &CodegenCx<'ll, 'tcx>) -> MetadataCreationResult<'ll> {\n         match *self {\n             FinalMetadata(metadata) => MetadataCreationResult::new(metadata, false),\n             UnfinishedMetadata {\n@@ -269,12 +293,13 @@ macro_rules! return_if_metadata_created_in_meantime {\n     )\n }\n \n-fn fixed_vec_metadata<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n-                                unique_type_id: UniqueTypeId,\n-                                array_or_slice_type: Ty<'tcx>,\n-                                element_type: Ty<'tcx>,\n-                                span: Span)\n-                                -> MetadataCreationResult {\n+fn fixed_vec_metadata(\n+    cx: &CodegenCx<'ll, 'tcx>,\n+    unique_type_id: UniqueTypeId,\n+    array_or_slice_type: Ty<'tcx>,\n+    element_type: Ty<'tcx>,\n+    span: Span,\n+) -> MetadataCreationResult<'ll> {\n     let element_type_metadata = type_metadata(cx, element_type, span);\n \n     return_if_metadata_created_in_meantime!(cx, unique_type_id);\n@@ -289,7 +314,7 @@ fn fixed_vec_metadata<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n     };\n \n     let subrange = unsafe {\n-        llvm::LLVMRustDIBuilderGetOrCreateSubrange(DIB(cx), 0, upper_bound)\n+        Some(llvm::LLVMRustDIBuilderGetOrCreateSubrange(DIB(cx), 0, upper_bound))\n     };\n \n     let subscripts = create_DIArray(DIB(cx), &[subrange]);\n@@ -305,12 +330,13 @@ fn fixed_vec_metadata<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n     return MetadataCreationResult::new(metadata, false);\n }\n \n-fn vec_slice_metadata<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n-                                slice_ptr_type: Ty<'tcx>,\n-                                element_type: Ty<'tcx>,\n-                                unique_type_id: UniqueTypeId,\n-                                span: Span)\n-                                -> MetadataCreationResult {\n+fn vec_slice_metadata(\n+    cx: &CodegenCx<'ll, 'tcx>,\n+    slice_ptr_type: Ty<'tcx>,\n+    element_type: Ty<'tcx>,\n+    unique_type_id: UniqueTypeId,\n+    span: Span,\n+) -> MetadataCreationResult<'ll> {\n     let data_ptr_type = cx.tcx.mk_imm_ptr(element_type);\n \n     let data_ptr_metadata = type_metadata(cx, data_ptr_type, span);\n@@ -354,26 +380,28 @@ fn vec_slice_metadata<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n     MetadataCreationResult::new(metadata, false)\n }\n \n-fn subroutine_type_metadata<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n-                                      unique_type_id: UniqueTypeId,\n-                                      signature: ty::PolyFnSig<'tcx>,\n-                                      span: Span)\n-                                      -> MetadataCreationResult\n-{\n+fn subroutine_type_metadata(\n+    cx: &CodegenCx<'ll, 'tcx>,\n+    unique_type_id: UniqueTypeId,\n+    signature: ty::PolyFnSig<'tcx>,\n+    span: Span,\n+) -> MetadataCreationResult<'ll> {\n     let signature = cx.tcx.normalize_erasing_late_bound_regions(\n         ty::ParamEnv::reveal_all(),\n         &signature,\n     );\n \n-    let signature_metadata: Vec<DIType> = iter::once(\n+    let signature_metadata: Vec<_> = iter::once(\n         // return type\n         match signature.output().sty {\n-            ty::TyTuple(ref tys) if tys.is_empty() => ptr::null_mut(),\n-            _ => type_metadata(cx, signature.output(), span)\n+            ty::TyTuple(ref tys) if tys.is_empty() => None,\n+            _ => Some(type_metadata(cx, signature.output(), span))\n         }\n     ).chain(\n         // regular arguments\n-        signature.inputs().iter().map(|argument_type| type_metadata(cx, argument_type, span))\n+        signature.inputs().iter().map(|argument_type| {\n+            Some(type_metadata(cx, argument_type, span))\n+        })\n     ).collect();\n \n     return_if_metadata_created_in_meantime!(cx, unique_type_id);\n@@ -394,19 +422,20 @@ fn subroutine_type_metadata<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n // trait_type should be the actual trait (e.g., Trait). Where the trait is part\n // of a DST struct, there is no trait_object_type and the results of this\n // function will be a little bit weird.\n-fn trait_pointer_metadata<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n-                                    trait_type: Ty<'tcx>,\n-                                    trait_object_type: Option<Ty<'tcx>>,\n-                                    unique_type_id: UniqueTypeId)\n-                                    -> DIType {\n+fn trait_pointer_metadata(\n+    cx: &CodegenCx<'ll, 'tcx>,\n+    trait_type: Ty<'tcx>,\n+    trait_object_type: Option<Ty<'tcx>>,\n+    unique_type_id: UniqueTypeId,\n+) -> &'ll DIType {\n     // The implementation provided here is a stub. It makes sure that the trait\n     // type is assigned the correct name, size, namespace, and source location.\n     // But it does not describe the trait's methods.\n \n     let containing_scope = match trait_type.sty {\n         ty::TyDynamic(ref data, ..) => if let Some(principal) = data.principal() {\n             let def_id = principal.def_id();\n-            get_namespace_for_item(cx, def_id)\n+            Some(get_namespace_for_item(cx, def_id))\n         } else {\n             NO_SCOPE_METADATA\n         },\n@@ -461,10 +490,11 @@ fn trait_pointer_metadata<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                             syntax_pos::DUMMY_SP)\n }\n \n-pub fn type_metadata<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n-                               t: Ty<'tcx>,\n-                               usage_site_span: Span)\n-                               -> DIType {\n+pub fn type_metadata(\n+    cx: &CodegenCx<'ll, 'tcx>,\n+    t: Ty<'tcx>,\n+    usage_site_span: Span,\n+) -> &'ll DIType {\n     // Get the unique type id of this type.\n     let unique_type_id = {\n         let mut type_map = debug_context(cx).type_map.borrow_mut();\n@@ -681,9 +711,9 @@ pub fn type_metadata<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n     metadata\n }\n \n-pub fn file_metadata(cx: &CodegenCx,\n+pub fn file_metadata(cx: &CodegenCx<'ll, '_>,\n                      file_name: &FileName,\n-                     defining_crate: CrateNum) -> DIFile {\n+                     defining_crate: CrateNum) -> &'ll DIFile {\n     debug!(\"file_metadata: file_name: {}, defining_crate: {}\",\n            file_name,\n            defining_crate);\n@@ -699,14 +729,14 @@ pub fn file_metadata(cx: &CodegenCx,\n     file_metadata_raw(cx, &file_name.to_string(), &directory.to_string_lossy())\n }\n \n-pub fn unknown_file_metadata(cx: &CodegenCx) -> DIFile {\n+pub fn unknown_file_metadata(cx: &CodegenCx<'ll, '_>) -> &'ll DIFile {\n     file_metadata_raw(cx, \"<unknown>\", \"\")\n }\n \n-fn file_metadata_raw(cx: &CodegenCx,\n+fn file_metadata_raw(cx: &CodegenCx<'ll, '_>,\n                      file_name: &str,\n                      directory: &str)\n-                     -> DIFile {\n+                     -> &'ll DIFile {\n     let key = (Symbol::intern(file_name), Symbol::intern(directory));\n \n     if let Some(file_metadata) = debug_context(cx).created_files.borrow().get(&key) {\n@@ -729,9 +759,7 @@ fn file_metadata_raw(cx: &CodegenCx,\n     file_metadata\n }\n \n-fn basic_type_metadata<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n-                                 t: Ty<'tcx>) -> DIType {\n-\n+fn basic_type_metadata(cx: &CodegenCx<'ll, 'tcx>, t: Ty<'tcx>) -> &'ll DIType {\n     debug!(\"basic_type_metadata: {:?}\", t);\n \n     let (name, encoding) = match t.sty {\n@@ -766,19 +794,22 @@ fn basic_type_metadata<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n     return ty_metadata;\n }\n \n-fn foreign_type_metadata<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n-                                   t: Ty<'tcx>,\n-                                   unique_type_id: UniqueTypeId) -> DIType {\n+fn foreign_type_metadata(\n+    cx: &CodegenCx<'ll, 'tcx>,\n+    t: Ty<'tcx>,\n+    unique_type_id: UniqueTypeId,\n+) -> &'ll DIType {\n     debug!(\"foreign_type_metadata: {:?}\", t);\n \n     let name = compute_debuginfo_type_name(cx, t, false);\n     create_struct_stub(cx, t, &name, unique_type_id, NO_SCOPE_METADATA)\n }\n \n-fn pointer_type_metadata<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n-                                   pointer_type: Ty<'tcx>,\n-                                   pointee_type_metadata: DIType)\n-                                   -> DIType {\n+fn pointer_type_metadata(\n+    cx: &CodegenCx<'ll, 'tcx>,\n+    pointer_type: Ty<'tcx>,\n+    pointee_type_metadata: &'ll DIType,\n+) -> &'ll DIType {\n     let (pointer_size, pointer_align) = cx.size_and_align_of(pointer_type);\n     let name = compute_debuginfo_type_name(cx, pointer_type, false);\n     let name = CString::new(name).unwrap();\n@@ -794,8 +825,8 @@ fn pointer_type_metadata<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n \n pub fn compile_unit_metadata(tcx: TyCtxt,\n                              codegen_unit_name: &str,\n-                             debug_context: &CrateDebugContext)\n-                             -> DIDescriptor {\n+                             debug_context: &CrateDebugContext<'ll, '_>)\n+                             -> &'ll DIDescriptor {\n     let mut name_in_debuginfo = match tcx.sess.local_crate_source_file {\n         Some(ref path) => path.clone(),\n         None => PathBuf::from(&*tcx.crate_name(LOCAL_CRATE).as_str()),\n@@ -860,7 +891,7 @@ pub fn compile_unit_metadata(tcx: TyCtxt,\n         return unit_metadata;\n     };\n \n-    fn path_to_mdstring(llcx: llvm::ContextRef, path: &Path) -> llvm::ValueRef {\n+    fn path_to_mdstring(llcx: &'ll llvm::Context, path: &Path) -> &'ll Value {\n         let path_str = path2cstr(path);\n         unsafe {\n             llvm::LLVMMDStringInContext(llcx,\n@@ -870,13 +901,13 @@ pub fn compile_unit_metadata(tcx: TyCtxt,\n     }\n }\n \n-struct MetadataCreationResult {\n-    metadata: DIType,\n+struct MetadataCreationResult<'ll> {\n+    metadata: &'ll DIType,\n     already_stored_in_typemap: bool\n }\n \n-impl MetadataCreationResult {\n-    fn new(metadata: DIType, already_stored_in_typemap: bool) -> MetadataCreationResult {\n+impl MetadataCreationResult<'ll> {\n+    fn new(metadata: &'ll DIType, already_stored_in_typemap: bool) -> Self {\n         MetadataCreationResult {\n             metadata,\n             already_stored_in_typemap,\n@@ -887,9 +918,9 @@ impl MetadataCreationResult {\n // Description of a type member, which can either be a regular field (as in\n // structs or tuples) or an enum variant.\n #[derive(Debug)]\n-struct MemberDescription {\n+struct MemberDescription<'ll> {\n     name: String,\n-    type_metadata: DIType,\n+    type_metadata: &'ll DIType,\n     offset: Size,\n     size: Size,\n     align: Align,\n@@ -900,17 +931,17 @@ struct MemberDescription {\n // for some record-like type. MemberDescriptionFactories are used to defer the\n // creation of type member descriptions in order to break cycles arising from\n // recursive type definitions.\n-enum MemberDescriptionFactory<'tcx> {\n+enum MemberDescriptionFactory<'ll, 'tcx> {\n     StructMDF(StructMemberDescriptionFactory<'tcx>),\n     TupleMDF(TupleMemberDescriptionFactory<'tcx>),\n-    EnumMDF(EnumMemberDescriptionFactory<'tcx>),\n+    EnumMDF(EnumMemberDescriptionFactory<'ll, 'tcx>),\n     UnionMDF(UnionMemberDescriptionFactory<'tcx>),\n-    VariantMDF(VariantMemberDescriptionFactory<'tcx>)\n+    VariantMDF(VariantMemberDescriptionFactory<'ll, 'tcx>)\n }\n \n-impl<'tcx> MemberDescriptionFactory<'tcx> {\n-    fn create_member_descriptions<'a>(&self, cx: &CodegenCx<'a, 'tcx>)\n-                                      -> Vec<MemberDescription> {\n+impl MemberDescriptionFactory<'ll, 'tcx> {\n+    fn create_member_descriptions(&self, cx: &CodegenCx<'ll, 'tcx>)\n+                                      -> Vec<MemberDescription<'ll>> {\n         match *self {\n             StructMDF(ref this) => {\n                 this.create_member_descriptions(cx)\n@@ -943,8 +974,8 @@ struct StructMemberDescriptionFactory<'tcx> {\n }\n \n impl<'tcx> StructMemberDescriptionFactory<'tcx> {\n-    fn create_member_descriptions<'a>(&self, cx: &CodegenCx<'a, 'tcx>)\n-                                      -> Vec<MemberDescription> {\n+    fn create_member_descriptions(&self, cx: &CodegenCx<'ll, 'tcx>)\n+                                      -> Vec<MemberDescription<'ll>> {\n         let layout = cx.layout_of(self.ty);\n         self.variant.fields.iter().enumerate().map(|(i, f)| {\n             let name = if self.variant.ctor_kind == CtorKind::Fn {\n@@ -967,11 +998,12 @@ impl<'tcx> StructMemberDescriptionFactory<'tcx> {\n }\n \n \n-fn prepare_struct_metadata<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n-                                     struct_type: Ty<'tcx>,\n-                                     unique_type_id: UniqueTypeId,\n-                                     span: Span)\n-                                     -> RecursiveTypeDescription<'tcx> {\n+fn prepare_struct_metadata(\n+    cx: &CodegenCx<'ll, 'tcx>,\n+    struct_type: Ty<'tcx>,\n+    unique_type_id: UniqueTypeId,\n+    span: Span,\n+) -> RecursiveTypeDescription<'ll, 'tcx> {\n     let struct_name = compute_debuginfo_type_name(cx, struct_type, false);\n \n     let (struct_def_id, variant) = match struct_type.sty {\n@@ -985,7 +1017,7 @@ fn prepare_struct_metadata<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                                                   struct_type,\n                                                   &struct_name,\n                                                   unique_type_id,\n-                                                  containing_scope);\n+                                                  Some(containing_scope));\n \n     create_and_register_recursive_type_forward_declaration(\n         cx,\n@@ -1012,8 +1044,8 @@ struct TupleMemberDescriptionFactory<'tcx> {\n }\n \n impl<'tcx> TupleMemberDescriptionFactory<'tcx> {\n-    fn create_member_descriptions<'a>(&self, cx: &CodegenCx<'a, 'tcx>)\n-                                      -> Vec<MemberDescription> {\n+    fn create_member_descriptions(&self, cx: &CodegenCx<'ll, 'tcx>)\n+                                      -> Vec<MemberDescription<'ll>> {\n         let layout = cx.layout_of(self.ty);\n         self.component_types.iter().enumerate().map(|(i, &component_type)| {\n             let (size, align) = cx.size_and_align_of(component_type);\n@@ -1029,12 +1061,13 @@ impl<'tcx> TupleMemberDescriptionFactory<'tcx> {\n     }\n }\n \n-fn prepare_tuple_metadata<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n-                                    tuple_type: Ty<'tcx>,\n-                                    component_types: &[Ty<'tcx>],\n-                                    unique_type_id: UniqueTypeId,\n-                                    span: Span)\n-                                    -> RecursiveTypeDescription<'tcx> {\n+fn prepare_tuple_metadata(\n+    cx: &CodegenCx<'ll, 'tcx>,\n+    tuple_type: Ty<'tcx>,\n+    component_types: &[Ty<'tcx>],\n+    unique_type_id: UniqueTypeId,\n+    span: Span,\n+) -> RecursiveTypeDescription<'ll, 'tcx> {\n     let tuple_name = compute_debuginfo_type_name(cx, tuple_type, false);\n \n     create_and_register_recursive_type_forward_declaration(\n@@ -1065,8 +1098,8 @@ struct UnionMemberDescriptionFactory<'tcx> {\n }\n \n impl<'tcx> UnionMemberDescriptionFactory<'tcx> {\n-    fn create_member_descriptions<'a>(&self, cx: &CodegenCx<'a, 'tcx>)\n-                                      -> Vec<MemberDescription> {\n+    fn create_member_descriptions(&self, cx: &CodegenCx<'ll, 'tcx>)\n+                                      -> Vec<MemberDescription<'ll>> {\n         self.variant.fields.iter().enumerate().map(|(i, f)| {\n             let field = self.layout.field(cx, i);\n             let (size, align) = field.size_and_align();\n@@ -1082,11 +1115,12 @@ impl<'tcx> UnionMemberDescriptionFactory<'tcx> {\n     }\n }\n \n-fn prepare_union_metadata<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n-                                    union_type: Ty<'tcx>,\n-                                    unique_type_id: UniqueTypeId,\n-                                    span: Span)\n-                                    -> RecursiveTypeDescription<'tcx> {\n+fn prepare_union_metadata(\n+    cx: &CodegenCx<'ll, 'tcx>,\n+    union_type: Ty<'tcx>,\n+    unique_type_id: UniqueTypeId,\n+    span: Span,\n+) -> RecursiveTypeDescription<'ll, 'tcx> {\n     let union_name = compute_debuginfo_type_name(cx, union_type, false);\n \n     let (union_def_id, variant) = match union_type.sty {\n@@ -1124,17 +1158,17 @@ fn prepare_union_metadata<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n // the members of this union; so for every variant of the given enum, this\n // factory will produce one MemberDescription (all with no name and a fixed\n // offset of zero bytes).\n-struct EnumMemberDescriptionFactory<'tcx> {\n+struct EnumMemberDescriptionFactory<'ll, 'tcx> {\n     enum_type: Ty<'tcx>,\n     layout: TyLayout<'tcx>,\n-    discriminant_type_metadata: Option<DIType>,\n-    containing_scope: DIScope,\n+    discriminant_type_metadata: Option<&'ll DIType>,\n+    containing_scope: &'ll DIScope,\n     span: Span,\n }\n \n-impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n-    fn create_member_descriptions<'a>(&self, cx: &CodegenCx<'a, 'tcx>)\n-                                      -> Vec<MemberDescription> {\n+impl EnumMemberDescriptionFactory<'ll, 'tcx> {\n+    fn create_member_descriptions(&self, cx: &CodegenCx<'ll, 'tcx>)\n+                                      -> Vec<MemberDescription<'ll>> {\n         let adt = &self.enum_type.ty_adt_def().unwrap();\n         match self.layout.variants {\n             layout::Variants::Single { .. } if adt.variants.is_empty() => vec![],\n@@ -1259,17 +1293,17 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n }\n \n // Creates MemberDescriptions for the fields of a single enum variant.\n-struct VariantMemberDescriptionFactory<'tcx> {\n+struct VariantMemberDescriptionFactory<'ll, 'tcx> {\n     // Cloned from the layout::Struct describing the variant.\n     offsets: Vec<layout::Size>,\n     args: Vec<(String, Ty<'tcx>)>,\n-    discriminant_type_metadata: Option<DIType>,\n+    discriminant_type_metadata: Option<&'ll DIType>,\n     span: Span,\n }\n \n-impl<'tcx> VariantMemberDescriptionFactory<'tcx> {\n-    fn create_member_descriptions<'a>(&self, cx: &CodegenCx<'a, 'tcx>)\n-                                      -> Vec<MemberDescription> {\n+impl VariantMemberDescriptionFactory<'ll, 'tcx> {\n+    fn create_member_descriptions(&self, cx: &CodegenCx<'ll, 'tcx>)\n+                                      -> Vec<MemberDescription<'ll>> {\n         self.args.iter().enumerate().map(|(i, &(ref name, ty))| {\n             let (size, align) = cx.size_and_align_of(ty);\n             MemberDescription {\n@@ -1288,8 +1322,8 @@ impl<'tcx> VariantMemberDescriptionFactory<'tcx> {\n }\n \n #[derive(Copy, Clone)]\n-enum EnumDiscriminantInfo {\n-    RegularDiscriminant(DIType),\n+enum EnumDiscriminantInfo<'ll> {\n+    RegularDiscriminant(&'ll DIType),\n     OptimizedDiscriminant,\n     NoDiscriminant\n }\n@@ -1298,13 +1332,14 @@ enum EnumDiscriminantInfo {\n // of the variant, and (3) a MemberDescriptionFactory for producing the\n // descriptions of the fields of the variant. This is a rudimentary version of a\n // full RecursiveTypeDescription.\n-fn describe_enum_variant<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n-                                   layout: layout::TyLayout<'tcx>,\n-                                   variant: &'tcx ty::VariantDef,\n-                                   discriminant_info: EnumDiscriminantInfo,\n-                                   containing_scope: DIScope,\n-                                   span: Span)\n-                                   -> (DICompositeType, MemberDescriptionFactory<'tcx>) {\n+fn describe_enum_variant(\n+    cx: &CodegenCx<'ll, 'tcx>,\n+    layout: layout::TyLayout<'tcx>,\n+    variant: &'tcx ty::VariantDef,\n+    discriminant_info: EnumDiscriminantInfo<'ll>,\n+    containing_scope: &'ll DIScope,\n+    span: Span,\n+) -> (&'ll DICompositeType, MemberDescriptionFactory<'ll, 'tcx>) {\n     let variant_name = variant.name.as_str();\n     let unique_type_id = debug_context(cx).type_map\n                                           .borrow_mut()\n@@ -1317,7 +1352,7 @@ fn describe_enum_variant<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                                            layout.ty,\n                                            &variant_name,\n                                            unique_type_id,\n-                                           containing_scope);\n+                                           Some(containing_scope));\n \n     // If this is not a univariant enum, there is also the discriminant field.\n     let (discr_offset, discr_arg) = match discriminant_info {\n@@ -1358,12 +1393,13 @@ fn describe_enum_variant<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n     (metadata_stub, member_description_factory)\n }\n \n-fn prepare_enum_metadata<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n-                                   enum_type: Ty<'tcx>,\n-                                   enum_def_id: DefId,\n-                                   unique_type_id: UniqueTypeId,\n-                                   span: Span)\n-                                   -> RecursiveTypeDescription<'tcx> {\n+fn prepare_enum_metadata(\n+    cx: &CodegenCx<'ll, 'tcx>,\n+    enum_type: Ty<'tcx>,\n+    enum_def_id: DefId,\n+    unique_type_id: UniqueTypeId,\n+    span: Span,\n+) -> RecursiveTypeDescription<'ll, 'tcx> {\n     let enum_name = compute_debuginfo_type_name(cx, enum_type, false);\n \n     let containing_scope = get_namespace_for_item(cx, enum_def_id);\n@@ -1376,17 +1412,17 @@ fn prepare_enum_metadata<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n     let file_metadata = unknown_file_metadata(cx);\n \n     let def = enum_type.ty_adt_def().unwrap();\n-    let enumerators_metadata: Vec<DIDescriptor> = def.discriminants(cx.tcx)\n+    let enumerators_metadata: Vec<_> = def.discriminants(cx.tcx)\n         .zip(&def.variants)\n         .map(|(discr, v)| {\n             let token = v.name.as_str();\n             let name = CString::new(token.as_bytes()).unwrap();\n             unsafe {\n-                llvm::LLVMRustDIBuilderCreateEnumerator(\n+                Some(llvm::LLVMRustDIBuilderCreateEnumerator(\n                     DIB(cx),\n                     name.as_ptr(),\n                     // FIXME: what if enumeration has i128 discriminant?\n-                    discr.val as u64)\n+                    discr.val as u64))\n             }\n         })\n         .collect();\n@@ -1459,7 +1495,7 @@ fn prepare_enum_metadata<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n         enum_type_size.bits(),\n         enum_type_align.abi_bits() as u32,\n         DIFlags::FlagZero,\n-        ptr::null_mut(),\n+        None,\n         0, // RuntimeLang\n         unique_type_id_str.as_ptr())\n     };\n@@ -1489,18 +1525,19 @@ fn prepare_enum_metadata<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n /// results in a LLVM struct.\n ///\n /// Examples of Rust types to use this are: structs, tuples, boxes, vecs, and enums.\n-fn composite_type_metadata<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n-                                     composite_type: Ty<'tcx>,\n-                                     composite_type_name: &str,\n-                                     composite_type_unique_id: UniqueTypeId,\n-                                     member_descriptions: &[MemberDescription],\n-                                     containing_scope: DIScope,\n-\n-                                     // Ignore source location information as long as it\n-                                     // can't be reconstructed for non-local crates.\n-                                     _file_metadata: DIFile,\n-                                     _definition_span: Span)\n-                                     -> DICompositeType {\n+fn composite_type_metadata(\n+    cx: &CodegenCx<'ll, 'tcx>,\n+    composite_type: Ty<'tcx>,\n+    composite_type_name: &str,\n+    composite_type_unique_id: UniqueTypeId,\n+    member_descriptions: &[MemberDescription<'ll>],\n+    containing_scope: Option<&'ll DIScope>,\n+\n+    // Ignore source location information as long as it\n+    // can't be reconstructed for non-local crates.\n+    _file_metadata: &'ll DIFile,\n+    _definition_span: Span,\n+) -> &'ll DICompositeType {\n     // Create the (empty) struct metadata node ...\n     let composite_type_metadata = create_struct_stub(cx,\n                                                      composite_type,\n@@ -1515,9 +1552,9 @@ fn composite_type_metadata<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n     return composite_type_metadata;\n }\n \n-fn set_members_of_composite_type(cx: &CodegenCx,\n-                                 composite_type_metadata: DICompositeType,\n-                                 member_descriptions: &[MemberDescription]) {\n+fn set_members_of_composite_type(cx: &CodegenCx<'ll, '_>,\n+                                 composite_type_metadata: &'ll DICompositeType,\n+                                 member_descriptions: &[MemberDescription<'ll>]) {\n     // In some rare cases LLVM metadata uniquing would lead to an existing type\n     // description being used instead of a new one created in\n     // create_struct_stub. This would cause a hard to trace assertion in\n@@ -1535,13 +1572,13 @@ fn set_members_of_composite_type(cx: &CodegenCx,\n         }\n     }\n \n-    let member_metadata: Vec<DIDescriptor> = member_descriptions\n+    let member_metadata: Vec<_> = member_descriptions\n         .iter()\n         .map(|member_description| {\n             let member_name = member_description.name.as_bytes();\n             let member_name = CString::new(member_name).unwrap();\n             unsafe {\n-                llvm::LLVMRustDIBuilderCreateMemberType(\n+                Some(llvm::LLVMRustDIBuilderCreateMemberType(\n                     DIB(cx),\n                     composite_type_metadata,\n                     member_name.as_ptr(),\n@@ -1551,7 +1588,7 @@ fn set_members_of_composite_type(cx: &CodegenCx,\n                     member_description.align.abi_bits() as u32,\n                     member_description.offset.bits(),\n                     member_description.flags,\n-                    member_description.type_metadata)\n+                    member_description.type_metadata))\n             }\n         })\n         .collect();\n@@ -1566,12 +1603,13 @@ fn set_members_of_composite_type(cx: &CodegenCx,\n // A convenience wrapper around LLVMRustDIBuilderCreateStructType(). Does not do\n // any caching, does not add any fields to the struct. This can be done later\n // with set_members_of_composite_type().\n-fn create_struct_stub<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n-                                struct_type: Ty<'tcx>,\n-                                struct_type_name: &str,\n-                                unique_type_id: UniqueTypeId,\n-                                containing_scope: DIScope)\n-                                -> DICompositeType {\n+fn create_struct_stub(\n+    cx: &CodegenCx<'ll, 'tcx>,\n+    struct_type: Ty<'tcx>,\n+    struct_type_name: &str,\n+    unique_type_id: UniqueTypeId,\n+    containing_scope: Option<&'ll DIScope>,\n+) -> &'ll DICompositeType {\n     let (struct_size, struct_align) = cx.size_and_align_of(struct_type);\n \n     let name = CString::new(struct_type_name).unwrap();\n@@ -1593,22 +1631,23 @@ fn create_struct_stub<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n             struct_size.bits(),\n             struct_align.abi_bits() as u32,\n             DIFlags::FlagZero,\n-            ptr::null_mut(),\n+            None,\n             empty_array,\n             0,\n-            ptr::null_mut(),\n+            None,\n             unique_type_id.as_ptr())\n     };\n \n     return metadata_stub;\n }\n \n-fn create_union_stub<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n-                               union_type: Ty<'tcx>,\n-                               union_type_name: &str,\n-                               unique_type_id: UniqueTypeId,\n-                               containing_scope: DIScope)\n-                               -> DICompositeType {\n+fn create_union_stub(\n+    cx: &CodegenCx<'ll, 'tcx>,\n+    union_type: Ty<'tcx>,\n+    union_type_name: &str,\n+    unique_type_id: UniqueTypeId,\n+    containing_scope: &'ll DIScope,\n+) -> &'ll DICompositeType {\n     let (union_size, union_align) = cx.size_and_align_of(union_type);\n \n     let name = CString::new(union_type_name).unwrap();\n@@ -1630,7 +1669,7 @@ fn create_union_stub<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n             union_size.bits(),\n             union_align.abi_bits() as u32,\n             DIFlags::FlagZero,\n-            empty_array,\n+            Some(empty_array),\n             0, // RuntimeLang\n             unique_type_id.as_ptr())\n     };\n@@ -1641,9 +1680,11 @@ fn create_union_stub<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n /// Creates debug information for the given global variable.\n ///\n /// Adds the created metadata nodes directly to the crate's IR.\n-pub fn create_global_var_metadata(cx: &CodegenCx,\n-                                  def_id: DefId,\n-                                  global: ValueRef) {\n+pub fn create_global_var_metadata(\n+    cx: &CodegenCx<'ll, '_>,\n+    def_id: DefId,\n+    global: &'ll Value,\n+) {\n     if cx.dbg_cx.is_none() {\n         return;\n     }\n@@ -1684,7 +1725,7 @@ pub fn create_global_var_metadata(cx: &CodegenCx,\n \n     unsafe {\n         llvm::LLVMRustDIBuilderCreateStaticVariable(DIB(cx),\n-                                                    var_scope,\n+                                                    Some(var_scope),\n                                                     var_name.as_ptr(),\n                                                     // If null, linkage_name field is omitted,\n                                                     // which is what we want for no_mangle statics\n@@ -1695,18 +1736,19 @@ pub fn create_global_var_metadata(cx: &CodegenCx,\n                                                     type_metadata,\n                                                     is_local_to_unit,\n                                                     global,\n-                                                    ptr::null_mut(),\n+                                                    None,\n                                                     global_align.abi() as u32,\n         );\n     }\n }\n \n // Creates an \"extension\" of an existing DIScope into another file.\n-pub fn extend_scope_to_file(cx: &CodegenCx,\n-                            scope_metadata: DIScope,\n-                            file: &syntax_pos::FileMap,\n-                            defining_crate: CrateNum)\n-                            -> DILexicalBlock {\n+pub fn extend_scope_to_file(\n+    cx: &CodegenCx<'ll, '_>,\n+    scope_metadata: &'ll DIScope,\n+    file: &syntax_pos::FileMap,\n+    defining_crate: CrateNum,\n+) -> &'ll DILexicalBlock {\n     let file_metadata = file_metadata(cx, &file.name, defining_crate);\n     unsafe {\n         llvm::LLVMRustDIBuilderCreateLexicalBlockFile(\n@@ -1720,9 +1762,11 @@ pub fn extend_scope_to_file(cx: &CodegenCx,\n /// given type.\n ///\n /// Adds the created metadata nodes directly to the crate's IR.\n-pub fn create_vtable_metadata<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n-                                        ty: ty::Ty<'tcx>,\n-                                        vtable: ValueRef) {\n+pub fn create_vtable_metadata(\n+    cx: &CodegenCx<'ll, 'tcx>,\n+    ty: ty::Ty<'tcx>,\n+    vtable: &'ll Value,\n+) {\n     if cx.dbg_cx.is_none() {\n         return;\n     }\n@@ -1749,10 +1793,10 @@ pub fn create_vtable_metadata<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n             Size::ZERO.bits(),\n             cx.tcx.data_layout.pointer_align.abi_bits() as u32,\n             DIFlags::FlagArtificial,\n-            ptr::null_mut(),\n+            None,\n             empty_array,\n             0,\n-            type_metadata,\n+            Some(type_metadata),\n             name.as_ptr()\n         );\n \n@@ -1771,7 +1815,7 @@ pub fn create_vtable_metadata<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                                                     vtable_type,\n                                                     true,\n                                                     vtable,\n-                                                    ptr::null_mut(),\n+                                                    None,\n                                                     0);\n     }\n }"}, {"sha": "143b122a5a172e1098c4da91a9f190082dcd9f73", "filename": "src/librustc_codegen_llvm/debuginfo/mod.rs", "status": "modified", "additions": 74, "deletions": 59, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/f89817997ac0aa100bf91997194ad85a7e59f743/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f89817997ac0aa100bf91997194ad85a7e59f743/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs?ref=f89817997ac0aa100bf91997194ad85a7e59f743", "patch": "@@ -21,8 +21,7 @@ use self::metadata::{type_metadata, file_metadata, TypeMap};\n use self::source_loc::InternalDebugLocation::{self, UnknownLocation};\n \n use llvm;\n-use llvm::{ModuleRef, ContextRef, ValueRef};\n-use llvm::debuginfo::{DIFile, DIType, DIScope, DIBuilderRef, DISubprogram, DIArray, DIFlags};\n+use llvm::debuginfo::{DIFile, DIType, DIScope, DIBuilder, DISubprogram, DIArray, DIFlags};\n use rustc::hir::CodegenFnAttrFlags;\n use rustc::hir::def_id::{DefId, CrateNum};\n use rustc::ty::subst::{Substs, UnpackedKind};\n@@ -35,11 +34,11 @@ use rustc::ty::{self, ParamEnv, Ty, InstanceDef};\n use rustc::mir;\n use rustc::session::config::{self, FullDebugInfo, LimitedDebugInfo, NoDebugInfo};\n use rustc::util::nodemap::{DefIdMap, FxHashMap, FxHashSet};\n+use value::Value;\n \n use libc::c_uint;\n use std::cell::{Cell, RefCell};\n use std::ffi::CString;\n-use std::ptr;\n \n use syntax_pos::{self, Span, Pos};\n use syntax::ast;\n@@ -67,23 +66,31 @@ const DW_TAG_auto_variable: c_uint = 0x100;\n const DW_TAG_arg_variable: c_uint = 0x101;\n \n /// A context object for maintaining all state needed by the debuginfo module.\n-pub struct CrateDebugContext<'tcx> {\n-    llcontext: ContextRef,\n-    llmod: ModuleRef,\n-    builder: DIBuilderRef,\n-    created_files: RefCell<FxHashMap<(Symbol, Symbol), DIFile>>,\n-    created_enum_disr_types: RefCell<FxHashMap<(DefId, layout::Primitive), DIType>>,\n+pub struct CrateDebugContext<'a, 'tcx> {\n+    llcontext: &'a llvm::Context,\n+    llmod: &'a llvm::Module,\n+    builder: &'a mut DIBuilder<'a>,\n+    created_files: RefCell<FxHashMap<(Symbol, Symbol), &'a DIFile>>,\n+    created_enum_disr_types: RefCell<FxHashMap<(DefId, layout::Primitive), &'a DIType>>,\n \n-    type_map: RefCell<TypeMap<'tcx>>,\n-    namespace_map: RefCell<DefIdMap<DIScope>>,\n+    type_map: RefCell<TypeMap<'a, 'tcx>>,\n+    namespace_map: RefCell<DefIdMap<&'a DIScope>>,\n \n     // This collection is used to assert that composite types (structs, enums,\n     // ...) have their members only set once:\n-    composite_types_completed: RefCell<FxHashSet<DIType>>,\n+    composite_types_completed: RefCell<FxHashSet<&'a DIType>>,\n }\n \n-impl<'tcx> CrateDebugContext<'tcx> {\n-    pub fn new(llmod: ModuleRef) -> CrateDebugContext<'tcx> {\n+impl Drop for CrateDebugContext<'a, 'tcx> {\n+    fn drop(&mut self) {\n+        unsafe {\n+            llvm::LLVMRustDIBuilderDispose(&mut *(self.builder as *mut _));\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> CrateDebugContext<'a, 'tcx> {\n+    pub fn new(llmod: &'a llvm::Module) -> Self {\n         debug!(\"CrateDebugContext::new\");\n         let builder = unsafe { llvm::LLVMRustDIBuilderCreate(llmod) };\n         // DIBuilder inherits context from the module, so we'd better use the same one\n@@ -101,14 +108,14 @@ impl<'tcx> CrateDebugContext<'tcx> {\n     }\n }\n \n-pub enum FunctionDebugContext {\n-    RegularContext(FunctionDebugContextData),\n+pub enum FunctionDebugContext<'ll> {\n+    RegularContext(FunctionDebugContextData<'ll>),\n     DebugInfoDisabled,\n     FunctionWithoutDebugInfo,\n }\n \n-impl FunctionDebugContext {\n-    pub fn get_ref<'a>(&'a self, span: Span) -> &'a FunctionDebugContextData {\n+impl FunctionDebugContext<'ll> {\n+    pub fn get_ref<'a>(&'a self, span: Span) -> &'a FunctionDebugContextData<'ll> {\n         match *self {\n             FunctionDebugContext::RegularContext(ref data) => data,\n             FunctionDebugContext::DebugInfoDisabled => {\n@@ -130,18 +137,18 @@ impl FunctionDebugContext {\n     }\n }\n \n-pub struct FunctionDebugContextData {\n-    fn_metadata: DISubprogram,\n+pub struct FunctionDebugContextData<'ll> {\n+    fn_metadata: &'ll DISubprogram,\n     source_locations_enabled: Cell<bool>,\n     pub defining_crate: CrateNum,\n }\n \n-pub enum VariableAccess<'a> {\n+pub enum VariableAccess<'a, 'll> {\n     // The llptr given is an alloca containing the variable's value\n-    DirectVariable { alloca: ValueRef },\n+    DirectVariable { alloca: &'ll Value },\n     // The llptr given is an alloca containing the start of some pointer chain\n     // leading to the variable's content.\n-    IndirectVariable { alloca: ValueRef, address_operations: &'a [i64] }\n+    IndirectVariable { alloca: &'ll Value, address_operations: &'a [i64] }\n }\n \n pub enum VariableKind {\n@@ -167,7 +174,6 @@ pub fn finalize(cx: &CodegenCx) {\n \n     unsafe {\n         llvm::LLVMRustDIBuilderFinalize(DIB(cx));\n-        llvm::LLVMRustDIBuilderDispose(DIB(cx));\n         // Debuginfo generation in LLVM by default uses a higher\n         // version of dwarf than macOS currently understands. We can\n         // instruct LLVM to emit an older version of dwarf, however,\n@@ -201,11 +207,13 @@ pub fn finalize(cx: &CodegenCx) {\n /// for debug info creation. The function may also return another variant of the\n /// FunctionDebugContext enum which indicates why no debuginfo should be created\n /// for the function.\n-pub fn create_function_debug_context<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n-                                               instance: Instance<'tcx>,\n-                                               sig: ty::FnSig<'tcx>,\n-                                               llfn: ValueRef,\n-                                               mir: &mir::Mir) -> FunctionDebugContext {\n+pub fn create_function_debug_context(\n+    cx: &CodegenCx<'ll, 'tcx>,\n+    instance: Instance<'tcx>,\n+    sig: ty::FnSig<'tcx>,\n+    llfn: &'ll Value,\n+    mir: &mir::Mir,\n+) -> FunctionDebugContext<'ll> {\n     if cx.sess().opts.debuginfo == NoDebugInfo {\n         return FunctionDebugContext::DebugInfoDisabled;\n     }\n@@ -290,7 +298,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n             cx.sess().opts.optimize != config::OptLevel::No,\n             llfn,\n             template_parameters,\n-            ptr::null_mut())\n+            None)\n     };\n \n     // Initialize fn debug context (including scope map and namespace map)\n@@ -302,8 +310,10 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n \n     return FunctionDebugContext::RegularContext(fn_debug_context);\n \n-    fn get_function_signature<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n-                                        sig: ty::FnSig<'tcx>) -> DIArray {\n+    fn get_function_signature(\n+        cx: &CodegenCx<'ll, 'tcx>,\n+        sig: ty::FnSig<'tcx>,\n+    ) -> &'ll DIArray {\n         if cx.sess().opts.debuginfo == LimitedDebugInfo {\n             return create_DIArray(DIB(cx), &[]);\n         }\n@@ -312,8 +322,8 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n \n         // Return type -- llvm::DIBuilder wants this at index 0\n         signature.push(match sig.output().sty {\n-            ty::TyTuple(ref tys) if tys.is_empty() => ptr::null_mut(),\n-            _ => type_metadata(cx, sig.output(), syntax_pos::DUMMY_SP)\n+            ty::TyTuple(ref tys) if tys.is_empty() => None,\n+            _ => Some(type_metadata(cx, sig.output(), syntax_pos::DUMMY_SP))\n         });\n \n         let inputs = if sig.abi == Abi::RustCall {\n@@ -342,33 +352,34 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                     }\n                     _ => t\n                 };\n-                type_metadata(cx, t, syntax_pos::DUMMY_SP)\n+                Some(type_metadata(cx, t, syntax_pos::DUMMY_SP))\n             }));\n         } else {\n             signature.extend(inputs.iter().map(|t| {\n-                type_metadata(cx, t, syntax_pos::DUMMY_SP)\n+                Some(type_metadata(cx, t, syntax_pos::DUMMY_SP))\n             }));\n         }\n \n         if sig.abi == Abi::RustCall && !sig.inputs().is_empty() {\n             if let ty::TyTuple(args) = sig.inputs()[sig.inputs().len() - 1].sty {\n                 signature.extend(\n-                    args.iter().map(|argument_type|\n-                        type_metadata(cx, argument_type, syntax_pos::DUMMY_SP))\n+                    args.iter().map(|argument_type| {\n+                        Some(type_metadata(cx, argument_type, syntax_pos::DUMMY_SP))\n+                    })\n                 );\n             }\n         }\n \n         return create_DIArray(DIB(cx), &signature[..]);\n     }\n \n-    fn get_template_parameters<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n-                                         generics: &ty::Generics,\n-                                         substs: &Substs<'tcx>,\n-                                         file_metadata: DIFile,\n-                                         name_to_append_suffix_to: &mut String)\n-                                         -> DIArray\n-    {\n+    fn get_template_parameters(\n+        cx: &CodegenCx<'ll, 'tcx>,\n+        generics: &ty::Generics,\n+        substs: &Substs<'tcx>,\n+        file_metadata: &'ll DIFile,\n+        name_to_append_suffix_to: &mut String,\n+    ) -> &'ll DIArray {\n         if substs.types().next().is_none() {\n             return create_DIArray(DIB(cx), &[]);\n         }\n@@ -398,14 +409,15 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                         type_metadata(cx, actual_type, syntax_pos::DUMMY_SP);\n                     let name = CString::new(name.as_str().as_bytes()).unwrap();\n                     Some(unsafe {\n-                        llvm::LLVMRustDIBuilderCreateTemplateTypeParameter(\n+                        Some(llvm::LLVMRustDIBuilderCreateTemplateTypeParameter(\n                             DIB(cx),\n-                            ptr::null_mut(),\n+                            None,\n                             name.as_ptr(),\n                             actual_type_metadata,\n                             file_metadata,\n                             0,\n-                            0)\n+                            0,\n+                        ))\n                     })\n                 } else {\n                     None\n@@ -428,9 +440,10 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n         names\n     }\n \n-    fn get_containing_scope<'cx, 'tcx>(cx: &CodegenCx<'cx, 'tcx>,\n-                                        instance: Instance<'tcx>)\n-                                        -> DIScope {\n+    fn get_containing_scope(\n+        cx: &CodegenCx<'ll, 'tcx>,\n+        instance: Instance<'tcx>,\n+    ) -> &'ll DIScope {\n         // First, let's see if this is a method within an inherent impl. Because\n         // if yes, we want to make the result subroutine DIE a child of the\n         // subroutine's self-type.\n@@ -470,14 +483,16 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n     }\n }\n \n-pub fn declare_local<'a, 'tcx>(bx: &Builder<'a, 'tcx>,\n-                               dbg_context: &FunctionDebugContext,\n-                               variable_name: ast::Name,\n-                               variable_type: Ty<'tcx>,\n-                               scope_metadata: DIScope,\n-                               variable_access: VariableAccess,\n-                               variable_kind: VariableKind,\n-                               span: Span) {\n+pub fn declare_local(\n+    bx: &Builder<'a, 'll, 'tcx>,\n+    dbg_context: &FunctionDebugContext<'ll>,\n+    variable_name: ast::Name,\n+    variable_type: Ty<'tcx>,\n+    scope_metadata: &'ll DIScope,\n+    variable_access: VariableAccess<'_, 'll>,\n+    variable_kind: VariableKind,\n+    span: Span,\n+) {\n     assert!(!dbg_context.get_ref(span).source_locations_enabled.get());\n     let cx = bx.cx;\n "}, {"sha": "9f1141a7e7db06cacf8d8f88472e5527cd6d587c", "filename": "src/librustc_codegen_llvm/debuginfo/namespace.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f89817997ac0aa100bf91997194ad85a7e59f743/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fnamespace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f89817997ac0aa100bf91997194ad85a7e59f743/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fnamespace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fnamespace.rs?ref=f89817997ac0aa100bf91997194ad85a7e59f743", "patch": "@@ -22,7 +22,6 @@ use rustc::hir::map::DefPathData;\n use common::CodegenCx;\n \n use std::ffi::CString;\n-use std::ptr;\n \n pub fn mangled_name_of_instance<'a, 'tcx>(\n     cx: &CodegenCx<'a, 'tcx>,\n@@ -32,13 +31,13 @@ pub fn mangled_name_of_instance<'a, 'tcx>(\n      tcx.symbol_name(instance)\n }\n \n-pub fn item_namespace(cx: &CodegenCx, def_id: DefId) -> DIScope {\n+pub fn item_namespace(cx: &CodegenCx<'ll, '_>, def_id: DefId) -> &'ll DIScope {\n     if let Some(&scope) = debug_context(cx).namespace_map.borrow().get(&def_id) {\n         return scope;\n     }\n \n     let def_key = cx.tcx.def_key(def_id);\n-    let parent_scope = def_key.parent.map_or(ptr::null_mut(), |parent| {\n+    let parent_scope = def_key.parent.map(|parent| {\n         item_namespace(cx, DefId {\n             krate: def_id.krate,\n             index: parent"}, {"sha": "55cf139394344d0e9a53f18467cca59ef9754e61", "filename": "src/librustc_codegen_llvm/debuginfo/source_loc.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/f89817997ac0aa100bf91997194ad85a7e59f743/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fsource_loc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f89817997ac0aa100bf91997194ad85a7e59f743/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fsource_loc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fsource_loc.rs?ref=f89817997ac0aa100bf91997194ad85a7e59f743", "patch": "@@ -19,14 +19,16 @@ use llvm::debuginfo::DIScope;\n use builder::Builder;\n \n use libc::c_uint;\n-use std::ptr;\n use syntax_pos::{Span, Pos};\n \n /// Sets the current debug location at the beginning of the span.\n ///\n /// Maps to a call to llvm::LLVMSetCurrentDebugLocation(...).\n pub fn set_source_location(\n-    debug_context: &FunctionDebugContext, bx: &Builder, scope: DIScope, span: Span\n+    debug_context: &FunctionDebugContext<'ll>,\n+    bx: &Builder<'_, 'll, '_>,\n+    scope: Option<&'ll DIScope>,\n+    span: Span,\n ) {\n     let function_debug_context = match *debug_context {\n         FunctionDebugContext::DebugInfoDisabled => return,\n@@ -40,7 +42,7 @@ pub fn set_source_location(\n     let dbg_loc = if function_debug_context.source_locations_enabled.get() {\n         debug!(\"set_source_location: {}\", bx.sess().codemap().span_to_string(span));\n         let loc = span_start(bx.cx, span);\n-        InternalDebugLocation::new(scope, loc.line, loc.col.to_usize())\n+        InternalDebugLocation::new(scope.unwrap(), loc.line, loc.col.to_usize())\n     } else {\n         UnknownLocation\n     };\n@@ -53,7 +55,7 @@ pub fn set_source_location(\n /// they are disabled when beginning to codegen a new function. This functions\n /// switches source location emitting on and must therefore be called before the\n /// first real statement/expression of the function is codegened.\n-pub fn start_emitting_source_locations(dbg_context: &FunctionDebugContext) {\n+pub fn start_emitting_source_locations(dbg_context: &FunctionDebugContext<'ll>) {\n     match *dbg_context {\n         FunctionDebugContext::RegularContext(ref data) => {\n             data.source_locations_enabled.set(true)\n@@ -64,13 +66,13 @@ pub fn start_emitting_source_locations(dbg_context: &FunctionDebugContext) {\n \n \n #[derive(Copy, Clone, PartialEq)]\n-pub enum InternalDebugLocation {\n-    KnownLocation { scope: DIScope, line: usize, col: usize },\n+pub enum InternalDebugLocation<'ll> {\n+    KnownLocation { scope: &'ll DIScope, line: usize, col: usize },\n     UnknownLocation\n }\n \n-impl InternalDebugLocation {\n-    pub fn new(scope: DIScope, line: usize, col: usize) -> InternalDebugLocation {\n+impl InternalDebugLocation<'ll> {\n+    pub fn new(scope: &'ll DIScope, line: usize, col: usize) -> Self {\n         KnownLocation {\n             scope,\n             line,\n@@ -79,7 +81,7 @@ impl InternalDebugLocation {\n     }\n }\n \n-pub fn set_debug_location(bx: &Builder, debug_location: InternalDebugLocation) {\n+pub fn set_debug_location(bx: &Builder<'_, 'll, '_>, debug_location: InternalDebugLocation<'ll>) {\n     let metadata_node = match debug_location {\n         KnownLocation { scope, line, col } => {\n             // For MSVC, set the column number to zero.\n@@ -93,17 +95,17 @@ pub fn set_debug_location(bx: &Builder, debug_location: InternalDebugLocation) {\n             debug!(\"setting debug location to {} {}\", line, col);\n \n             unsafe {\n-                llvm::LLVMRustDIBuilderCreateDebugLocation(\n+                Some(llvm::LLVMRustDIBuilderCreateDebugLocation(\n                     debug_context(bx.cx).llcontext,\n                     line as c_uint,\n                     col_used,\n                     scope,\n-                    ptr::null_mut())\n+                    None))\n             }\n         }\n         UnknownLocation => {\n             debug!(\"clearing debug location \");\n-            ptr::null_mut()\n+            None\n         }\n     };\n "}, {"sha": "9f4a555082ad48452edb94b9ae68b80e5378a966", "filename": "src/librustc_codegen_llvm/debuginfo/utils.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f89817997ac0aa100bf91997194ad85a7e59f743/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f89817997ac0aa100bf91997194ad85a7e59f743/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Futils.rs?ref=f89817997ac0aa100bf91997194ad85a7e59f743", "patch": "@@ -17,7 +17,7 @@ use rustc::hir::def_id::DefId;\n use rustc::ty::DefIdTree;\n \n use llvm;\n-use llvm::debuginfo::{DIScope, DIBuilderRef, DIDescriptor, DIArray};\n+use llvm::debuginfo::{DIScope, DIBuilder, DIDescriptor, DIArray};\n use common::{CodegenCx};\n \n use syntax_pos::{self, Span};\n@@ -36,7 +36,10 @@ pub fn is_node_local_to_unit(cx: &CodegenCx, def_id: DefId) -> bool\n }\n \n #[allow(non_snake_case)]\n-pub fn create_DIArray(builder: DIBuilderRef, arr: &[DIDescriptor]) -> DIArray {\n+pub fn create_DIArray(\n+    builder: &DIBuilder<'ll>,\n+    arr: &[Option<&'ll DIDescriptor>],\n+) -> &'ll DIArray {\n     return unsafe {\n         llvm::LLVMRustDIBuilderGetOrCreateArray(builder, arr.as_ptr(), arr.len() as u32)\n     };\n@@ -48,18 +51,17 @@ pub fn span_start(cx: &CodegenCx, span: Span) -> syntax_pos::Loc {\n }\n \n #[inline]\n-pub fn debug_context<'a, 'tcx>(cx: &'a CodegenCx<'a, 'tcx>)\n-                           -> &'a CrateDebugContext<'tcx> {\n+pub fn debug_context(cx: &'a CodegenCx<'ll, 'tcx>) -> &'a CrateDebugContext<'ll, 'tcx> {\n     cx.dbg_cx.as_ref().unwrap()\n }\n \n #[inline]\n #[allow(non_snake_case)]\n-pub fn DIB(cx: &CodegenCx) -> DIBuilderRef {\n+pub fn DIB(cx: &'a CodegenCx<'ll, '_>) -> &'a DIBuilder<'ll> {\n     cx.dbg_cx.as_ref().unwrap().builder\n }\n \n-pub fn get_namespace_for_item(cx: &CodegenCx, def_id: DefId) -> DIScope {\n+pub fn get_namespace_for_item(cx: &CodegenCx<'ll, '_>, def_id: DefId) -> &'ll DIScope {\n     item_namespace(cx, cx.tcx.parent(def_id)\n         .expect(\"get_namespace_for_item: missing parent?\"))\n }"}, {"sha": "9812d7f9a41a21cc81ad0642606fa13e700b4505", "filename": "src/librustc_codegen_llvm/declare.rs", "status": "modified", "additions": 36, "deletions": 31, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/f89817997ac0aa100bf91997194ad85a7e59f743/src%2Flibrustc_codegen_llvm%2Fdeclare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f89817997ac0aa100bf91997194ad85a7e59f743/src%2Flibrustc_codegen_llvm%2Fdeclare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdeclare.rs?ref=f89817997ac0aa100bf91997194ad85a7e59f743", "patch": "@@ -16,11 +16,11 @@\n //! Some useful guidelines:\n //!\n //! * Use declare_* family of methods if you are declaring, but are not\n-//!   interested in defining the ValueRef they return.\n-//! * Use define_* family of methods when you might be defining the ValueRef.\n+//!   interested in defining the Value they return.\n+//! * Use define_* family of methods when you might be defining the Value.\n //! * When in doubt, define.\n \n-use llvm::{self, ValueRef};\n+use llvm;\n use llvm::AttributePlace::Function;\n use rustc::ty::{self, Ty};\n use rustc::ty::layout::{self, LayoutOf};\n@@ -39,29 +39,34 @@ use std::ffi::CString;\n /// Declare a global value.\n ///\n /// If there\u2019s a value with the same name already declared, the function will\n-/// return its ValueRef instead.\n-pub fn declare_global(cx: &CodegenCx, name: &str, ty: Type) -> llvm::ValueRef {\n+/// return its Value instead.\n+pub fn declare_global(cx: &CodegenCx<'ll, '_>, name: &str, ty: &'ll Type) -> &'ll Value {\n     debug!(\"declare_global(name={:?})\", name);\n     let namebuf = CString::new(name).unwrap_or_else(|_|{\n         bug!(\"name {:?} contains an interior null byte\", name)\n     });\n     unsafe {\n-        llvm::LLVMRustGetOrInsertGlobal(cx.llmod, namebuf.as_ptr(), ty.to_ref())\n+        llvm::LLVMRustGetOrInsertGlobal(cx.llmod, namebuf.as_ptr(), ty)\n     }\n }\n \n \n /// Declare a function.\n ///\n /// If there\u2019s a value with the same name already declared, the function will\n-/// update the declaration and return existing ValueRef instead.\n-fn declare_raw_fn(cx: &CodegenCx, name: &str, callconv: llvm::CallConv, ty: Type) -> ValueRef {\n+/// update the declaration and return existing Value instead.\n+fn declare_raw_fn(\n+    cx: &CodegenCx<'ll, '_>,\n+    name: &str,\n+    callconv: llvm::CallConv,\n+    ty: &'ll Type,\n+) -> &'ll Value {\n     debug!(\"declare_raw_fn(name={:?}, ty={:?})\", name, ty);\n     let namebuf = CString::new(name).unwrap_or_else(|_|{\n         bug!(\"name {:?} contains an interior null byte\", name)\n     });\n     let llfn = unsafe {\n-        llvm::LLVMRustGetOrInsertFunction(cx.llmod, namebuf.as_ptr(), ty.to_ref())\n+        llvm::LLVMRustGetOrInsertFunction(cx.llmod, namebuf.as_ptr(), ty)\n     };\n \n     llvm::SetFunctionCallConv(llfn, callconv);\n@@ -114,18 +119,21 @@ fn declare_raw_fn(cx: &CodegenCx, name: &str, callconv: llvm::CallConv, ty: Type\n /// `declare_fn` instead.\n ///\n /// If there\u2019s a value with the same name already declared, the function will\n-/// update the declaration and return existing ValueRef instead.\n-pub fn declare_cfn(cx: &CodegenCx, name: &str, fn_type: Type) -> ValueRef {\n+/// update the declaration and return existing Value instead.\n+pub fn declare_cfn(cx: &CodegenCx<'ll, '_>, name: &str, fn_type: &'ll Type) -> &'ll Value {\n     declare_raw_fn(cx, name, llvm::CCallConv, fn_type)\n }\n \n \n /// Declare a Rust function.\n ///\n /// If there\u2019s a value with the same name already declared, the function will\n-/// update the declaration and return existing ValueRef instead.\n-pub fn declare_fn<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, name: &str,\n-                            fn_type: Ty<'tcx>) -> ValueRef {\n+/// update the declaration and return existing Value instead.\n+pub fn declare_fn(\n+    cx: &CodegenCx<'ll, 'tcx>,\n+    name: &str,\n+    fn_type: Ty<'tcx>,\n+) -> &'ll Value {\n     debug!(\"declare_rust_fn(name={:?}, fn_type={:?})\", name, fn_type);\n     let sig = common::ty_fn_sig(cx, fn_type);\n     let sig = cx.tcx.normalize_erasing_late_bound_regions(ty::ParamEnv::reveal_all(), &sig);\n@@ -154,7 +162,7 @@ pub fn declare_fn<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, name: &str,\n /// return None if the name already has a definition associated with it. In that\n /// case an error should be reported to the user, because it usually happens due\n /// to user\u2019s fault (e.g. misuse of #[no_mangle] or #[export_name] attributes).\n-pub fn define_global(cx: &CodegenCx, name: &str, ty: Type) -> Option<ValueRef> {\n+pub fn define_global(cx: &CodegenCx<'ll, '_>, name: &str, ty: &'ll Type) -> Option<&'ll Value> {\n     if get_defined_value(cx, name).is_some() {\n         None\n     } else {\n@@ -167,9 +175,11 @@ pub fn define_global(cx: &CodegenCx, name: &str, ty: Type) -> Option<ValueRef> {\n /// Use this function when you intend to define a function. This function will\n /// return panic if the name already has a definition associated with it. This\n /// can happen with #[no_mangle] or #[export_name], for example.\n-pub fn define_fn<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n-                           name: &str,\n-                           fn_type: Ty<'tcx>) -> ValueRef {\n+pub fn define_fn(\n+    cx: &CodegenCx<'ll, 'tcx>,\n+    name: &str,\n+    fn_type: Ty<'tcx>,\n+) -> &'ll Value {\n     if get_defined_value(cx, name).is_some() {\n         cx.sess().fatal(&format!(\"symbol `{}` already defined\", name))\n     } else {\n@@ -182,34 +192,29 @@ pub fn define_fn<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n /// Use this function when you intend to define a function. This function will\n /// return panic if the name already has a definition associated with it. This\n /// can happen with #[no_mangle] or #[export_name], for example.\n-pub fn define_internal_fn<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n-                                    name: &str,\n-                                    fn_type: Ty<'tcx>) -> ValueRef {\n+pub fn define_internal_fn(\n+    cx: &CodegenCx<'ll, 'tcx>,\n+    name: &str,\n+    fn_type: Ty<'tcx>,\n+) -> &'ll Value {\n     let llfn = define_fn(cx, name, fn_type);\n     unsafe { llvm::LLVMRustSetLinkage(llfn, llvm::Linkage::InternalLinkage) };\n     llfn\n }\n \n \n /// Get declared value by name.\n-pub fn get_declared_value(cx: &CodegenCx, name: &str) -> Option<ValueRef> {\n+pub fn get_declared_value(cx: &CodegenCx<'ll, '_>, name: &str) -> Option<&'ll Value> {\n     debug!(\"get_declared_value(name={:?})\", name);\n     let namebuf = CString::new(name).unwrap_or_else(|_|{\n         bug!(\"name {:?} contains an interior null byte\", name)\n     });\n-    let val = unsafe { llvm::LLVMRustGetNamedValue(cx.llmod, namebuf.as_ptr()) };\n-    if val.is_null() {\n-        debug!(\"get_declared_value: {:?} value is null\", name);\n-        None\n-    } else {\n-        debug!(\"get_declared_value: {:?} => {:?}\", name, Value(val));\n-        Some(val)\n-    }\n+    unsafe { llvm::LLVMRustGetNamedValue(cx.llmod, namebuf.as_ptr()) }\n }\n \n /// Get defined or externally defined (AvailableExternally linkage) value by\n /// name.\n-pub fn get_defined_value(cx: &CodegenCx, name: &str) -> Option<ValueRef> {\n+pub fn get_defined_value(cx: &CodegenCx<'ll, '_>, name: &str) -> Option<&'ll Value> {\n     get_declared_value(cx, name).and_then(|val|{\n         let declaration = unsafe {\n             llvm::LLVMIsDeclaration(val) != 0"}, {"sha": "37ce51da778235f7e58a4a83ef7dcf52c0477126", "filename": "src/librustc_codegen_llvm/glue.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f89817997ac0aa100bf91997194ad85a7e59f743/src%2Flibrustc_codegen_llvm%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f89817997ac0aa100bf91997194ad85a7e59f743/src%2Flibrustc_codegen_llvm%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fglue.rs?ref=f89817997ac0aa100bf91997194ad85a7e59f743", "patch": "@@ -16,37 +16,36 @@ use std;\n \n use builder::Builder;\n use common::*;\n-use llvm::{ValueRef};\n use llvm;\n use meth;\n use rustc::ty::layout::LayoutOf;\n use rustc::ty::{self, Ty};\n use value::Value;\n \n-pub fn size_and_align_of_dst<'a, 'tcx>(bx: &Builder<'a, 'tcx>, t: Ty<'tcx>, info: ValueRef)\n-                                       -> (ValueRef, ValueRef) {\n+pub fn size_and_align_of_dst(bx: &Builder<'_, 'll, 'tcx>, t: Ty<'tcx>, info: Option<&'ll Value>)\n+                                       -> (&'ll Value, &'ll Value) {\n     debug!(\"calculate size of DST: {}; with lost info: {:?}\",\n-           t, Value(info));\n+           t, info);\n     if bx.cx.type_is_sized(t) {\n         let (size, align) = bx.cx.size_and_align_of(t);\n         debug!(\"size_and_align_of_dst t={} info={:?} size: {:?} align: {:?}\",\n-               t, Value(info), size, align);\n+               t, info, size, align);\n         let size = C_usize(bx.cx, size.bytes());\n         let align = C_usize(bx.cx, align.abi());\n         return (size, align);\n     }\n-    assert!(!info.is_null());\n     match t.sty {\n         ty::TyDynamic(..) => {\n             // load size/align from vtable\n-            (meth::SIZE.get_usize(bx, info), meth::ALIGN.get_usize(bx, info))\n+            let vtable = info.unwrap();\n+            (meth::SIZE.get_usize(bx, vtable), meth::ALIGN.get_usize(bx, vtable))\n         }\n         ty::TySlice(_) | ty::TyStr => {\n             let unit = t.sequence_element_type(bx.tcx());\n             // The info in this case is the length of the str, so the size is that\n             // times the unit size.\n             let (size, align) = bx.cx.size_and_align_of(unit);\n-            (bx.mul(info, C_usize(bx.cx, size.bytes())),\n+            (bx.mul(info.unwrap(), C_usize(bx.cx, size.bytes())),\n              C_usize(bx.cx, align.abi()))\n         }\n         _ => {"}, {"sha": "06a5c34a4cae058ce7c9b94431fb8120543b7ba6", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 95, "deletions": 85, "changes": 180, "blob_url": "https://github.com/rust-lang/rust/blob/f89817997ac0aa100bf91997194ad85a7e59f743/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f89817997ac0aa100bf91997194ad85a7e59f743/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=f89817997ac0aa100bf91997194ad85a7e59f743", "patch": "@@ -11,8 +11,7 @@\n #![allow(non_upper_case_globals)]\n \n use intrinsics::{self, Intrinsic};\n-use llvm;\n-use llvm::{ValueRef};\n+use llvm::{self, TypeKind};\n use abi::{Abi, FnType, LlvmType, PassMode};\n use mir::place::PlaceRef;\n use mir::operand::{OperandRef, OperandValue};\n@@ -28,14 +27,15 @@ use rustc::hir;\n use syntax::ast;\n use syntax::symbol::Symbol;\n use builder::Builder;\n+use value::Value;\n \n use rustc::session::Session;\n use syntax_pos::Span;\n \n use std::cmp::Ordering;\n use std::iter;\n \n-fn get_simple_intrinsic(cx: &CodegenCx, name: &str) -> Option<ValueRef> {\n+fn get_simple_intrinsic(cx: &CodegenCx<'ll, '_>, name: &str) -> Option<&'ll Value> {\n     let llvm_name = match name {\n         \"sqrtf32\" => \"llvm.sqrt.f32\",\n         \"sqrtf64\" => \"llvm.sqrt.f64\",\n@@ -85,12 +85,14 @@ fn get_simple_intrinsic(cx: &CodegenCx, name: &str) -> Option<ValueRef> {\n /// Remember to add all intrinsics here, in librustc_typeck/check/mod.rs,\n /// and in libcore/intrinsics.rs; if you need access to any llvm intrinsics,\n /// add them to librustc_codegen_llvm/context.rs\n-pub fn codegen_intrinsic_call<'a, 'tcx>(bx: &Builder<'a, 'tcx>,\n-                                      callee_ty: Ty<'tcx>,\n-                                      fn_ty: &FnType<'tcx, Ty<'tcx>>,\n-                                      args: &[OperandRef<'tcx>],\n-                                      llresult: ValueRef,\n-                                      span: Span) {\n+pub fn codegen_intrinsic_call(\n+    bx: &Builder<'a, 'll, 'tcx>,\n+    callee_ty: Ty<'tcx>,\n+    fn_ty: &FnType<'tcx, Ty<'tcx>>,\n+    args: &[OperandRef<'ll, 'tcx>],\n+    llresult: &'ll Value,\n+    span: Span,\n+) {\n     let cx = bx.cx;\n     let tcx = cx.tcx;\n \n@@ -146,7 +148,7 @@ pub fn codegen_intrinsic_call<'a, 'tcx>(bx: &Builder<'a, 'tcx>,\n             let tp_ty = substs.type_at(0);\n             if let OperandValue::Pair(_, meta) = args[0].val {\n                 let (llsize, _) =\n-                    glue::size_and_align_of_dst(bx, tp_ty, meta);\n+                    glue::size_and_align_of_dst(bx, tp_ty, Some(meta));\n                 llsize\n             } else {\n                 C_usize(cx, cx.size_of(tp_ty).bytes())\n@@ -160,7 +162,7 @@ pub fn codegen_intrinsic_call<'a, 'tcx>(bx: &Builder<'a, 'tcx>,\n             let tp_ty = substs.type_at(0);\n             if let OperandValue::Pair(_, meta) = args[0].val {\n                 let (_, llalign) =\n-                    glue::size_and_align_of_dst(bx, tp_ty, meta);\n+                    glue::size_and_align_of_dst(bx, tp_ty, Some(meta));\n                 llalign\n             } else {\n                 C_usize(cx, cx.align_of(tp_ty).abi())\n@@ -545,7 +547,7 @@ pub fn codegen_intrinsic_call<'a, 'tcx>(bx: &Builder<'a, 'tcx>,\n                 assert_eq!(x.len(), 1);\n                 x.into_iter().next().unwrap()\n             }\n-            fn ty_to_type(cx: &CodegenCx, t: &intrinsics::Type) -> Vec<Type> {\n+            fn ty_to_type(cx: &CodegenCx<'ll, '_>, t: &intrinsics::Type) -> Vec<&'ll Type> {\n                 use intrinsics::Type::*;\n                 match *t {\n                     Void => vec![Type::void(cx)],\n@@ -567,7 +569,7 @@ pub fn codegen_intrinsic_call<'a, 'tcx>(bx: &Builder<'a, 'tcx>,\n                     Vector(ref t, ref llvm_elem, length) => {\n                         let t = llvm_elem.as_ref().unwrap_or(t);\n                         let elem = one(ty_to_type(cx, t));\n-                        vec![Type::vector(&elem, length as u64)]\n+                        vec![Type::vector(elem, length as u64)]\n                     }\n                     Aggregate(false, ref contents) => {\n                         let elems = contents.iter()\n@@ -587,11 +589,11 @@ pub fn codegen_intrinsic_call<'a, 'tcx>(bx: &Builder<'a, 'tcx>,\n             // qux` to be converted into `foo, bar, baz, qux`, integer\n             // arguments to be truncated as needed and pointers to be\n             // cast.\n-            fn modify_as_needed<'a, 'tcx>(bx: &Builder<'a, 'tcx>,\n-                                          t: &intrinsics::Type,\n-                                          arg: &OperandRef<'tcx>)\n-                                          -> Vec<ValueRef>\n-            {\n+            fn modify_as_needed(\n+                bx: &Builder<'a, 'll, 'tcx>,\n+                t: &intrinsics::Type,\n+                arg: &OperandRef<'ll, 'tcx>,\n+            ) -> Vec<&'ll Value> {\n                 match *t {\n                     intrinsics::Type::Aggregate(true, ref contents) => {\n                         // We found a tuple that needs squishing! So\n@@ -616,7 +618,7 @@ pub fn codegen_intrinsic_call<'a, 'tcx>(bx: &Builder<'a, 'tcx>,\n                     }\n                     intrinsics::Type::Vector(_, Some(ref llvm_elem), length) => {\n                         let llvm_elem = one(ty_to_type(bx.cx, llvm_elem));\n-                        vec![bx.bitcast(arg.immediate(), Type::vector(&llvm_elem, length as u64))]\n+                        vec![bx.bitcast(arg.immediate(), Type::vector(llvm_elem, length as u64))]\n                     }\n                     intrinsics::Type::Integer(_, width, llvm_width) if width != llvm_width => {\n                         // the LLVM intrinsic uses a smaller integer\n@@ -644,7 +646,7 @@ pub fn codegen_intrinsic_call<'a, 'tcx>(bx: &Builder<'a, 'tcx>,\n                 intrinsics::IntrinsicDef::Named(name) => {\n                     let f = declare::declare_cfn(cx,\n                                                  name,\n-                                                 Type::func(&inputs, &outputs));\n+                                                 Type::func(&inputs, outputs));\n                     bx.call(f, &llargs, None)\n                 }\n             };\n@@ -677,14 +679,15 @@ pub fn codegen_intrinsic_call<'a, 'tcx>(bx: &Builder<'a, 'tcx>,\n     }\n }\n \n-fn copy_intrinsic<'a, 'tcx>(bx: &Builder<'a, 'tcx>,\n-                            allow_overlap: bool,\n-                            volatile: bool,\n-                            ty: Ty<'tcx>,\n-                            dst: ValueRef,\n-                            src: ValueRef,\n-                            count: ValueRef)\n-                            -> ValueRef {\n+fn copy_intrinsic(\n+    bx: &Builder<'a, 'll, 'tcx>,\n+    allow_overlap: bool,\n+    volatile: bool,\n+    ty: Ty<'tcx>,\n+    dst: &'ll Value,\n+    src: &'ll Value,\n+    count: &'ll Value,\n+) -> &'ll Value {\n     let cx = bx.cx;\n     let (size, align) = cx.size_and_align_of(ty);\n     let size = C_usize(cx, size.bytes());\n@@ -712,14 +715,14 @@ fn copy_intrinsic<'a, 'tcx>(bx: &Builder<'a, 'tcx>,\n         None)\n }\n \n-fn memset_intrinsic<'a, 'tcx>(\n-    bx: &Builder<'a, 'tcx>,\n+fn memset_intrinsic(\n+    bx: &Builder<'a, 'll, 'tcx>,\n     volatile: bool,\n     ty: Ty<'tcx>,\n-    dst: ValueRef,\n-    val: ValueRef,\n-    count: ValueRef\n-) -> ValueRef {\n+    dst: &'ll Value,\n+    val: &'ll Value,\n+    count: &'ll Value\n+) -> &'ll Value {\n     let cx = bx.cx;\n     let (size, align) = cx.size_and_align_of(ty);\n     let size = C_usize(cx, size.bytes());\n@@ -728,13 +731,13 @@ fn memset_intrinsic<'a, 'tcx>(\n     call_memset(bx, dst, val, bx.mul(size, count), align, volatile)\n }\n \n-fn try_intrinsic<'a, 'tcx>(\n-    bx: &Builder<'a, 'tcx>,\n-    cx: &CodegenCx,\n-    func: ValueRef,\n-    data: ValueRef,\n-    local_ptr: ValueRef,\n-    dest: ValueRef,\n+fn try_intrinsic(\n+    bx: &Builder<'a, 'll, 'tcx>,\n+    cx: &CodegenCx<'ll, 'tcx>,\n+    func: &'ll Value,\n+    data: &'ll Value,\n+    local_ptr: &'ll Value,\n+    dest: &'ll Value,\n ) {\n     if bx.sess().no_landing_pads() {\n         bx.call(func, &[data], None);\n@@ -754,12 +757,14 @@ fn try_intrinsic<'a, 'tcx>(\n // instructions are meant to work for all targets, as of the time of this\n // writing, however, LLVM does not recommend the usage of these new instructions\n // as the old ones are still more optimized.\n-fn codegen_msvc_try<'a, 'tcx>(bx: &Builder<'a, 'tcx>,\n-                            cx: &CodegenCx,\n-                            func: ValueRef,\n-                            data: ValueRef,\n-                            local_ptr: ValueRef,\n-                            dest: ValueRef) {\n+fn codegen_msvc_try(\n+    bx: &Builder<'a, 'll, 'tcx>,\n+    cx: &CodegenCx<'ll, 'tcx>,\n+    func: &'ll Value,\n+    data: &'ll Value,\n+    local_ptr: &'ll Value,\n+    dest: &'ll Value,\n+) {\n     let llfn = get_rust_try_fn(cx, &mut |bx| {\n         let cx = bx.cx;\n \n@@ -862,12 +867,14 @@ fn codegen_msvc_try<'a, 'tcx>(bx: &Builder<'a, 'tcx>,\n // function calling it, and that function may already have other personality\n // functions in play. By calling a shim we're guaranteed that our shim will have\n // the right personality function.\n-fn codegen_gnu_try<'a, 'tcx>(bx: &Builder<'a, 'tcx>,\n-                           cx: &CodegenCx,\n-                           func: ValueRef,\n-                           data: ValueRef,\n-                           local_ptr: ValueRef,\n-                           dest: ValueRef) {\n+fn codegen_gnu_try(\n+    bx: &Builder<'a, 'll, 'tcx>,\n+    cx: &CodegenCx<'ll, 'tcx>,\n+    func: &'ll Value,\n+    data: &'ll Value,\n+    local_ptr: &'ll Value,\n+    dest: &'ll Value,\n+) {\n     let llfn = get_rust_try_fn(cx, &mut |bx| {\n         let cx = bx.cx;\n \n@@ -922,12 +929,13 @@ fn codegen_gnu_try<'a, 'tcx>(bx: &Builder<'a, 'tcx>,\n \n // Helper function to give a Block to a closure to codegen a shim function.\n // This is currently primarily used for the `try` intrinsic functions above.\n-fn gen_fn<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n-                    name: &str,\n-                    inputs: Vec<Ty<'tcx>>,\n-                    output: Ty<'tcx>,\n-                    codegen: &mut dyn for<'b> FnMut(Builder<'b, 'tcx>))\n-                    -> ValueRef {\n+fn gen_fn<'ll, 'tcx>(\n+    cx: &CodegenCx<'ll, 'tcx>,\n+    name: &str,\n+    inputs: Vec<Ty<'tcx>>,\n+    output: Ty<'tcx>,\n+    codegen: &mut dyn FnMut(Builder<'_, 'll, 'tcx>),\n+) -> &'ll Value {\n     let rust_fn_ty = cx.tcx.mk_fn_ptr(ty::Binder::bind(cx.tcx.mk_fn_sig(\n         inputs.into_iter(),\n         output,\n@@ -945,9 +953,10 @@ fn gen_fn<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n // catch exceptions.\n //\n // This function is only generated once and is then cached.\n-fn get_rust_try_fn<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n-                             codegen: &mut dyn for<'b> FnMut(Builder<'b, 'tcx>))\n-                             -> ValueRef {\n+fn get_rust_try_fn<'ll, 'tcx>(\n+    cx: &CodegenCx<'ll, 'tcx>,\n+    codegen: &mut dyn FnMut(Builder<'_, 'll, 'tcx>),\n+) -> &'ll Value {\n     if let Some(llfn) = cx.rust_try_fn.get() {\n         return llfn;\n     }\n@@ -972,15 +981,15 @@ fn span_invalid_monomorphization_error(a: &Session, b: Span, c: &str) {\n     span_err!(a, b, E0511, \"{}\", c);\n }\n \n-fn generic_simd_intrinsic<'a, 'tcx>(\n-    bx: &Builder<'a, 'tcx>,\n+fn generic_simd_intrinsic(\n+    bx: &Builder<'a, 'll, 'tcx>,\n     name: &str,\n     callee_ty: Ty<'tcx>,\n-    args: &[OperandRef<'tcx>],\n+    args: &[OperandRef<'ll, 'tcx>],\n     ret_ty: Ty<'tcx>,\n-    llret_ty: Type,\n+    llret_ty: &'ll Type,\n     span: Span\n-) -> Result<ValueRef, ()> {\n+) -> Result<&'ll Value, ()> {\n     // macros for error handling:\n     macro_rules! emit_error {\n         ($msg: tt) => {\n@@ -1050,7 +1059,7 @@ fn generic_simd_intrinsic<'a, 'tcx>(\n                   found `{}` with length {}\",\n                  in_len, in_ty,\n                  ret_ty, out_len);\n-        require!(llret_ty.element_type().kind() == llvm::Integer,\n+        require!(llret_ty.element_type().kind() == TypeKind::Integer,\n                  \"expected return type with integer elements, found `{}` with non-integer `{}`\",\n                  ret_ty,\n                  ret_ty.simd_type(tcx));\n@@ -1145,19 +1154,20 @@ fn generic_simd_intrinsic<'a, 'tcx>(\n         }\n         // truncate the mask to a vector of i1s\n         let i1 = Type::i1(bx.cx);\n-        let i1xn = Type::vector(&i1, m_len as u64);\n+        let i1xn = Type::vector(i1, m_len as u64);\n         let m_i1s = bx.trunc(args[0].immediate(), i1xn);\n         return Ok(bx.select(m_i1s, args[1].immediate(), args[2].immediate()));\n     }\n \n-    fn simd_simple_float_intrinsic<'a, 'tcx>(name: &str,\n-                                             in_elem: &::rustc::ty::TyS,\n-                                             in_ty: &::rustc::ty::TyS,\n-                                             in_len: usize,\n-                                             bx: &Builder<'a, 'tcx>,\n-                                             span: Span,\n-                                             args: &[OperandRef<'tcx>])\n-                                             -> Result<ValueRef, ()> {\n+    fn simd_simple_float_intrinsic(\n+        name: &str,\n+        in_elem: &::rustc::ty::TyS,\n+        in_ty: &::rustc::ty::TyS,\n+        in_len: usize,\n+        bx: &Builder<'a, 'll, 'tcx>,\n+        span: Span,\n+        args: &[OperandRef<'ll, 'tcx>],\n+    ) -> Result<&'ll Value, ()> {\n         macro_rules! emit_error {\n             ($msg: tt) => {\n                 emit_error!($msg, )\n@@ -1283,8 +1293,8 @@ fn generic_simd_intrinsic<'a, 'tcx>(\n         }\n     }\n \n-    fn llvm_vector_ty(cx: &CodegenCx, elem_ty: ty::Ty, vec_len: usize,\n-                      mut no_pointers: usize) -> Type {\n+    fn llvm_vector_ty(cx: &CodegenCx<'ll, '_>, elem_ty: ty::Ty, vec_len: usize,\n+                      mut no_pointers: usize) -> &'ll Type {\n         // FIXME: use cx.layout_of(ty).llvm_type() ?\n         let mut elem_ty = match elem_ty.sty {\n             ty::TyInt(v) => Type::int_from_ty(cx, v),\n@@ -1296,7 +1306,7 @@ fn generic_simd_intrinsic<'a, 'tcx>(\n             elem_ty = elem_ty.ptr_to();\n             no_pointers -= 1;\n         }\n-        Type::vector(&elem_ty, vec_len as u64)\n+        Type::vector(elem_ty, vec_len as u64)\n     }\n \n \n@@ -1379,7 +1389,7 @@ fn generic_simd_intrinsic<'a, 'tcx>(\n         // Truncate the mask vector to a vector of i1s:\n         let (mask, mask_ty) = {\n             let i1 = Type::i1(bx.cx);\n-            let i1xn = Type::vector(&i1, in_len as u64);\n+            let i1xn = Type::vector(i1, in_len as u64);\n             (bx.trunc(args[2].immediate(), i1xn), i1xn)\n         };\n \n@@ -1395,7 +1405,7 @@ fn generic_simd_intrinsic<'a, 'tcx>(\n                                      llvm_elem_vec_str, llvm_pointer_vec_str);\n         let f = declare::declare_cfn(bx.cx, &llvm_intrinsic,\n                                      Type::func(&[llvm_pointer_vec_ty, alignment_ty, mask_ty,\n-                                                  llvm_elem_vec_ty], &llvm_elem_vec_ty));\n+                                                  llvm_elem_vec_ty], llvm_elem_vec_ty));\n         llvm::SetUnnamedAddr(f, false);\n         let v = bx.call(f, &[args[1].immediate(), alignment, mask, args[0].immediate()],\n                         None);\n@@ -1476,7 +1486,7 @@ fn generic_simd_intrinsic<'a, 'tcx>(\n         // Truncate the mask vector to a vector of i1s:\n         let (mask, mask_ty) = {\n             let i1 = Type::i1(bx.cx);\n-            let i1xn = Type::vector(&i1, in_len as u64);\n+            let i1xn = Type::vector(i1, in_len as u64);\n             (bx.trunc(args[2].immediate(), i1xn), i1xn)\n         };\n \n@@ -1496,7 +1506,7 @@ fn generic_simd_intrinsic<'a, 'tcx>(\n                                      Type::func(&[llvm_elem_vec_ty,\n                                                   llvm_pointer_vec_ty,\n                                                   alignment_ty,\n-                                                  mask_ty], &ret_t));\n+                                                  mask_ty], ret_t));\n         llvm::SetUnnamedAddr(f, false);\n         let v = bx.call(f, &[args[0].immediate(), args[1].immediate(), alignment, mask],\n                         None);\n@@ -1629,7 +1639,7 @@ unsupported {} from `{}` with element `{}` of size `{}` to `{}`\"#,\n \n                     // boolean reductions operate on vectors of i1s:\n                     let i1 = Type::i1(bx.cx);\n-                    let i1xn = Type::vector(&i1, in_len as u64);\n+                    let i1xn = Type::vector(i1, in_len as u64);\n                     bx.trunc(args[0].immediate(), i1xn)\n                 };\n                 return match in_elem.sty {"}, {"sha": "724a2e3e65f4247a7a12c6936af79e58638fb46c", "filename": "src/librustc_codegen_llvm/lib.rs", "status": "modified", "additions": 35, "deletions": 8, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/f89817997ac0aa100bf91997194ad85a7e59f743/src%2Flibrustc_codegen_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f89817997ac0aa100bf91997194ad85a7e59f743/src%2Flibrustc_codegen_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Flib.rs?ref=f89817997ac0aa100bf91997194ad85a7e59f743", "patch": "@@ -20,16 +20,23 @@\n \n #![feature(box_patterns)]\n #![feature(box_syntax)]\n+#![feature(crate_visibility_modifier)]\n #![feature(custom_attribute)]\n+#![feature(extern_types)]\n #![feature(fs_read_write)]\n+#![feature(in_band_lifetimes)]\n #![allow(unused_attributes)]\n #![feature(libc)]\n #![feature(quote)]\n #![feature(range_contains)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(slice_sort_by_cached_key)]\n #![feature(optin_builtin_traits)]\n+#![feature(concat_idents)]\n+#![feature(link_args)]\n+#![feature(static_nobundle)]\n \n+use back::write::create_target_machine;\n use rustc::dep_graph::WorkProduct;\n use syntax_pos::symbol::Symbol;\n \n@@ -46,7 +53,7 @@ extern crate rustc_target;\n #[macro_use] extern crate rustc_data_structures;\n extern crate rustc_demangle;\n extern crate rustc_incremental;\n-extern crate rustc_llvm as llvm;\n+extern crate rustc_llvm;\n extern crate rustc_platform_intrinsics as intrinsics;\n extern crate rustc_codegen_utils;\n \n@@ -110,6 +117,7 @@ mod debuginfo;\n mod declare;\n mod glue;\n mod intrinsic;\n+pub mod llvm;\n mod llvm_util;\n mod metadata;\n mod meth;\n@@ -335,22 +343,41 @@ enum ModuleSource {\n     Codegened(ModuleLlvm),\n }\n \n-#[derive(Debug)]\n struct ModuleLlvm {\n-    llcx: llvm::ContextRef,\n-    llmod: llvm::ModuleRef,\n-    tm: llvm::TargetMachineRef,\n+    llcx: &'static mut llvm::Context,\n+    llmod_raw: *const llvm::Module,\n+    tm: &'static mut llvm::TargetMachine,\n }\n \n unsafe impl Send for ModuleLlvm { }\n unsafe impl Sync for ModuleLlvm { }\n \n+impl ModuleLlvm {\n+    fn new(sess: &Session, mod_name: &str) -> Self {\n+        unsafe {\n+            let llcx = llvm::LLVMRustContextCreate(sess.fewer_names());\n+            let llmod_raw = context::create_module(sess, llcx, mod_name) as *const _;\n+\n+            ModuleLlvm {\n+                llmod_raw,\n+                llcx,\n+                tm: create_target_machine(sess, false),\n+            }\n+        }\n+    }\n+\n+    fn llmod(&self) -> &llvm::Module {\n+        unsafe {\n+            &*self.llmod_raw\n+        }\n+    }\n+}\n+\n impl Drop for ModuleLlvm {\n     fn drop(&mut self) {\n         unsafe {\n-            llvm::LLVMDisposeModule(self.llmod);\n-            llvm::LLVMContextDispose(self.llcx);\n-            llvm::LLVMRustDisposeTargetMachine(self.tm);\n+            llvm::LLVMContextDispose(&mut *(self.llcx as *mut _));\n+            llvm::LLVMRustDisposeTargetMachine(&mut *(self.tm as *mut _));\n         }\n     }\n }"}, {"sha": "4cbf0d92d7b99d810812a0d46f34e3f8ee145896", "filename": "src/librustc_codegen_llvm/llvm/archive_ro.rs", "status": "renamed", "additions": 18, "deletions": 37, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/f89817997ac0aa100bf91997194ad85a7e59f743/src%2Flibrustc_codegen_llvm%2Fllvm%2Farchive_ro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f89817997ac0aa100bf91997194ad85a7e59f743/src%2Flibrustc_codegen_llvm%2Fllvm%2Farchive_ro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fllvm%2Farchive_ro.rs?ref=f89817997ac0aa100bf91997194ad85a7e59f743", "patch": "@@ -10,28 +10,23 @@\n \n //! A wrapper around LLVM's archive (.a) code\n \n-use ArchiveRef;\n-\n use std::ffi::CString;\n-use std::marker;\n use std::path::Path;\n use std::slice;\n use std::str;\n \n pub struct ArchiveRO {\n-    ptr: ArchiveRef,\n+    pub raw: &'static mut super::Archive,\n }\n \n unsafe impl Send for ArchiveRO {}\n \n pub struct Iter<'a> {\n-    archive: &'a ArchiveRO,\n-    ptr: ::ArchiveIteratorRef,\n+    raw: &'a mut super::ArchiveIterator<'a>,\n }\n \n pub struct Child<'a> {\n-    ptr: ::ArchiveChildRef,\n-    _data: marker::PhantomData<&'a ArchiveRO>,\n+    pub raw: &'a mut super::ArchiveChild<'a>,\n }\n \n impl ArchiveRO {\n@@ -44,12 +39,10 @@ impl ArchiveRO {\n     pub fn open(dst: &Path) -> Result<ArchiveRO, String> {\n         return unsafe {\n             let s = path2cstr(dst);\n-            let ar = ::LLVMRustOpenArchive(s.as_ptr());\n-            if ar.is_null() {\n-                Err(::last_error().unwrap_or(\"failed to open archive\".to_string()))\n-            } else {\n-                Ok(ArchiveRO { ptr: ar })\n-            }\n+            let ar = super::LLVMRustOpenArchive(s.as_ptr()).ok_or_else(|| {\n+                super::last_error().unwrap_or(\"failed to open archive\".to_string())\n+            })?;\n+            Ok(ArchiveRO { raw: ar })\n         };\n \n         #[cfg(unix)]\n@@ -65,15 +58,10 @@ impl ArchiveRO {\n         }\n     }\n \n-    pub fn raw(&self) -> ArchiveRef {\n-        self.ptr\n-    }\n-\n     pub fn iter(&self) -> Iter {\n         unsafe {\n             Iter {\n-                ptr: ::LLVMRustArchiveIteratorNew(self.ptr),\n-                archive: self,\n+                raw: super::LLVMRustArchiveIteratorNew(self.raw),\n             }\n         }\n     }\n@@ -82,7 +70,7 @@ impl ArchiveRO {\n impl Drop for ArchiveRO {\n     fn drop(&mut self) {\n         unsafe {\n-            ::LLVMRustDestroyArchive(self.ptr);\n+            super::LLVMRustDestroyArchive(&mut *(self.raw as *mut _));\n         }\n     }\n }\n@@ -91,22 +79,19 @@ impl<'a> Iterator for Iter<'a> {\n     type Item = Result<Child<'a>, String>;\n \n     fn next(&mut self) -> Option<Result<Child<'a>, String>> {\n-        let ptr = unsafe { ::LLVMRustArchiveIteratorNext(self.ptr) };\n-        if ptr.is_null() {\n-            ::last_error().map(Err)\n-        } else {\n-            Some(Ok(Child {\n-                ptr,\n-                _data: marker::PhantomData,\n-            }))\n+        unsafe {\n+            match super::LLVMRustArchiveIteratorNext(self.raw) {\n+                Some(raw) => Some(Ok(Child { raw })),\n+                None => super::last_error().map(Err),\n+            }\n         }\n     }\n }\n \n impl<'a> Drop for Iter<'a> {\n     fn drop(&mut self) {\n         unsafe {\n-            ::LLVMRustArchiveIteratorFree(self.ptr);\n+            super::LLVMRustArchiveIteratorFree(&mut *(self.raw as *mut _));\n         }\n     }\n }\n@@ -115,7 +100,7 @@ impl<'a> Child<'a> {\n     pub fn name(&self) -> Option<&'a str> {\n         unsafe {\n             let mut name_len = 0;\n-            let name_ptr = ::LLVMRustArchiveChildName(self.ptr, &mut name_len);\n+            let name_ptr = super::LLVMRustArchiveChildName(self.raw, &mut name_len);\n             if name_ptr.is_null() {\n                 None\n             } else {\n@@ -128,23 +113,19 @@ impl<'a> Child<'a> {\n     pub fn data(&self) -> &'a [u8] {\n         unsafe {\n             let mut data_len = 0;\n-            let data_ptr = ::LLVMRustArchiveChildData(self.ptr, &mut data_len);\n+            let data_ptr = super::LLVMRustArchiveChildData(self.raw, &mut data_len);\n             if data_ptr.is_null() {\n                 panic!(\"failed to read data from archive child\");\n             }\n             slice::from_raw_parts(data_ptr as *const u8, data_len as usize)\n         }\n     }\n-\n-    pub fn raw(&self) -> ::ArchiveChildRef {\n-        self.ptr\n-    }\n }\n \n impl<'a> Drop for Child<'a> {\n     fn drop(&mut self) {\n         unsafe {\n-            ::LLVMRustArchiveChildFree(self.ptr);\n+            super::LLVMRustArchiveChildFree(&mut *(self.raw as *mut _));\n         }\n     }\n }", "previous_filename": "src/librustc_llvm/archive_ro.rs"}, {"sha": "7f2a9d6984a1577fbca34234f932f2b250e253d7", "filename": "src/librustc_codegen_llvm/llvm/diagnostic.rs", "status": "renamed", "additions": 40, "deletions": 36, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/f89817997ac0aa100bf91997194ad85a7e59f743/src%2Flibrustc_codegen_llvm%2Fllvm%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f89817997ac0aa100bf91997194ad85a7e59f743/src%2Flibrustc_codegen_llvm%2Fllvm%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fllvm%2Fdiagnostic.rs?ref=f89817997ac0aa100bf91997194ad85a7e59f743", "patch": "@@ -14,9 +14,9 @@ pub use self::OptimizationDiagnosticKind::*;\n pub use self::Diagnostic::*;\n \n use libc::c_uint;\n-use std::ptr;\n+use value::Value;\n \n-use {DiagnosticInfoRef, TwineRef, ValueRef};\n+use super::{DiagnosticInfo, Twine};\n \n #[derive(Copy, Clone)]\n pub enum OptimizationDiagnosticKind {\n@@ -42,21 +42,22 @@ impl OptimizationDiagnosticKind {\n     }\n }\n \n-pub struct OptimizationDiagnostic {\n+pub struct OptimizationDiagnostic<'ll> {\n     pub kind: OptimizationDiagnosticKind,\n     pub pass_name: String,\n-    pub function: ValueRef,\n+    pub function: &'ll Value,\n     pub line: c_uint,\n     pub column: c_uint,\n     pub filename: String,\n     pub message: String,\n }\n \n-impl OptimizationDiagnostic {\n-    unsafe fn unpack(kind: OptimizationDiagnosticKind,\n-                     di: DiagnosticInfoRef)\n-                     -> OptimizationDiagnostic {\n-        let mut function = ptr::null_mut();\n+impl OptimizationDiagnostic<'ll> {\n+    unsafe fn unpack(\n+        kind: OptimizationDiagnosticKind,\n+        di: &'ll DiagnosticInfo,\n+    ) -> Self {\n+        let mut function = None;\n         let mut line = 0;\n         let mut column = 0;\n \n@@ -72,9 +73,9 @@ impl OptimizationDiagnostic {\n                                                                 &mut column,\n                                                                 filename,\n                                                                 message)\n-                )\n-            )\n-        );\n+                ).ok()\n+            ).ok()\n+        ).ok();\n \n         let mut filename = filename.unwrap_or(String::new());\n         if filename.is_empty() {\n@@ -84,7 +85,7 @@ impl OptimizationDiagnostic {\n         OptimizationDiagnostic {\n             kind,\n             pass_name: pass_name.expect(\"got a non-UTF8 pass name from LLVM\"),\n-            function,\n+            function: function.unwrap(),\n             line,\n             column,\n             filename,\n@@ -94,41 +95,44 @@ impl OptimizationDiagnostic {\n }\n \n #[derive(Copy, Clone)]\n-pub struct InlineAsmDiagnostic {\n+pub struct InlineAsmDiagnostic<'ll> {\n     pub cookie: c_uint,\n-    pub message: TwineRef,\n-    pub instruction: ValueRef,\n+    pub message: &'ll Twine,\n+    pub instruction: &'ll Value,\n }\n \n-impl InlineAsmDiagnostic {\n-    unsafe fn unpack(di: DiagnosticInfoRef) -> InlineAsmDiagnostic {\n-\n-        let mut opt = InlineAsmDiagnostic {\n-            cookie: 0,\n-            message: ptr::null_mut(),\n-            instruction: ptr::null_mut(),\n-        };\n+impl InlineAsmDiagnostic<'ll> {\n+    unsafe fn unpack(di: &'ll DiagnosticInfo) -> Self {\n+        let mut cookie = 0;\n+        let mut message = None;\n+        let mut instruction = None;\n \n-        super::LLVMRustUnpackInlineAsmDiagnostic(di,\n-                                                 &mut opt.cookie,\n-                                                 &mut opt.message,\n-                                                 &mut opt.instruction);\n+        super::LLVMRustUnpackInlineAsmDiagnostic(\n+            di,\n+            &mut cookie,\n+            &mut message,\n+            &mut instruction,\n+        );\n \n-        opt\n+        InlineAsmDiagnostic {\n+            cookie,\n+            message: message.unwrap(),\n+            instruction: instruction.unwrap(),\n+        }\n     }\n }\n \n-pub enum Diagnostic {\n-    Optimization(OptimizationDiagnostic),\n-    InlineAsm(InlineAsmDiagnostic),\n-    PGO(DiagnosticInfoRef),\n+pub enum Diagnostic<'ll> {\n+    Optimization(OptimizationDiagnostic<'ll>),\n+    InlineAsm(InlineAsmDiagnostic<'ll>),\n+    PGO(&'ll DiagnosticInfo),\n \n     /// LLVM has other types that we do not wrap here.\n-    UnknownDiagnostic(DiagnosticInfoRef),\n+    UnknownDiagnostic(&'ll DiagnosticInfo),\n }\n \n-impl Diagnostic {\n-    pub unsafe fn unpack(di: DiagnosticInfoRef) -> Diagnostic {\n+impl Diagnostic<'ll> {\n+    pub unsafe fn unpack(di: &'ll DiagnosticInfo) -> Self {\n         use super::DiagnosticKind as Dk;\n         let kind = super::LLVMRustGetDiagInfoKind(di);\n ", "previous_filename": "src/librustc_llvm/diagnostic.rs"}, {"sha": "898d3d67353634b1ece65bfd1e2dd74fea44f9c8", "filename": "src/librustc_codegen_llvm/llvm/ffi.rs", "status": "added", "additions": 1633, "deletions": 0, "changes": 1633, "blob_url": "https://github.com/rust-lang/rust/blob/f89817997ac0aa100bf91997194ad85a7e59f743/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f89817997ac0aa100bf91997194ad85a7e59f743/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs?ref=f89817997ac0aa100bf91997194ad85a7e59f743", "patch": "@@ -0,0 +1,1633 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// FIXME: Rename 'DIGlobalVariable' to 'DIGlobalVariableExpression'\n+// once support for LLVM 3.9 is dropped.\n+//\n+// This method was changed in this LLVM patch:\n+// https://reviews.llvm.org/D26769\n+\n+use super::debuginfo::{\n+    DIBuilder, DIDescriptor, DIFile, DILexicalBlock, DISubprogram, DIType,\n+    DIBasicType, DIDerivedType, DICompositeType, DIScope, DIVariable,\n+    DIGlobalVariable, DIArray, DISubrange, DITemplateTypeParameter, DIEnumerator,\n+    DINameSpace, DIFlags,\n+};\n+\n+use libc::{c_uint, c_int, size_t, c_char};\n+use libc::{c_ulonglong, c_void};\n+\n+use std::marker::PhantomData;\n+\n+use super::RustString;\n+\n+pub type Bool = c_uint;\n+\n+pub const True: Bool = 1 as Bool;\n+pub const False: Bool = 0 as Bool;\n+\n+#[derive(Copy, Clone, PartialEq)]\n+#[repr(C)]\n+#[allow(dead_code)] // Variants constructed by C++.\n+pub enum LLVMRustResult {\n+    Success,\n+    Failure,\n+}\n+// Consts for the LLVM CallConv type, pre-cast to usize.\n+\n+/// LLVM CallingConv::ID. Should we wrap this?\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+#[repr(C)]\n+pub enum CallConv {\n+    CCallConv = 0,\n+    FastCallConv = 8,\n+    ColdCallConv = 9,\n+    X86StdcallCallConv = 64,\n+    X86FastcallCallConv = 65,\n+    ArmAapcsCallConv = 67,\n+    Msp430Intr = 69,\n+    X86_ThisCall = 70,\n+    PtxKernel = 71,\n+    X86_64_SysV = 78,\n+    X86_64_Win64 = 79,\n+    X86_VectorCall = 80,\n+    X86_Intr = 83,\n+    AmdGpuKernel = 91,\n+}\n+\n+/// LLVMRustLinkage\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n+#[repr(C)]\n+pub enum Linkage {\n+    ExternalLinkage = 0,\n+    AvailableExternallyLinkage = 1,\n+    LinkOnceAnyLinkage = 2,\n+    LinkOnceODRLinkage = 3,\n+    WeakAnyLinkage = 4,\n+    WeakODRLinkage = 5,\n+    AppendingLinkage = 6,\n+    InternalLinkage = 7,\n+    PrivateLinkage = 8,\n+    ExternalWeakLinkage = 9,\n+    CommonLinkage = 10,\n+}\n+\n+// LLVMRustVisibility\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n+#[repr(C)]\n+pub enum Visibility {\n+    Default = 0,\n+    Hidden = 1,\n+    Protected = 2,\n+}\n+\n+/// LLVMDLLStorageClass\n+#[derive(Copy, Clone)]\n+#[repr(C)]\n+pub enum DLLStorageClass {\n+    #[allow(dead_code)]\n+    Default = 0,\n+    DllImport = 1, // Function to be imported from DLL.\n+    #[allow(dead_code)]\n+    DllExport = 2, // Function to be accessible from DLL.\n+}\n+\n+/// Matches LLVMRustAttribute in rustllvm.h\n+/// Semantically a subset of the C++ enum llvm::Attribute::AttrKind,\n+/// though it is not ABI compatible (since it's a C++ enum)\n+#[repr(C)]\n+#[derive(Copy, Clone, Debug)]\n+pub enum Attribute {\n+    AlwaysInline    = 0,\n+    ByVal           = 1,\n+    Cold            = 2,\n+    InlineHint      = 3,\n+    MinSize         = 4,\n+    Naked           = 5,\n+    NoAlias         = 6,\n+    NoCapture       = 7,\n+    NoInline        = 8,\n+    NonNull         = 9,\n+    NoRedZone       = 10,\n+    NoReturn        = 11,\n+    NoUnwind        = 12,\n+    OptimizeForSize = 13,\n+    ReadOnly        = 14,\n+    SExt            = 15,\n+    StructRet       = 16,\n+    UWTable         = 17,\n+    ZExt            = 18,\n+    InReg           = 19,\n+    SanitizeThread  = 20,\n+    SanitizeAddress = 21,\n+    SanitizeMemory  = 22,\n+}\n+\n+/// LLVMIntPredicate\n+#[derive(Copy, Clone)]\n+#[repr(C)]\n+pub enum IntPredicate {\n+    IntEQ = 32,\n+    IntNE = 33,\n+    IntUGT = 34,\n+    IntUGE = 35,\n+    IntULT = 36,\n+    IntULE = 37,\n+    IntSGT = 38,\n+    IntSGE = 39,\n+    IntSLT = 40,\n+    IntSLE = 41,\n+}\n+\n+/// LLVMRealPredicate\n+#[derive(Copy, Clone)]\n+#[repr(C)]\n+pub enum RealPredicate {\n+    RealPredicateFalse = 0,\n+    RealOEQ = 1,\n+    RealOGT = 2,\n+    RealOGE = 3,\n+    RealOLT = 4,\n+    RealOLE = 5,\n+    RealONE = 6,\n+    RealORD = 7,\n+    RealUNO = 8,\n+    RealUEQ = 9,\n+    RealUGT = 10,\n+    RealUGE = 11,\n+    RealULT = 12,\n+    RealULE = 13,\n+    RealUNE = 14,\n+    RealPredicateTrue = 15,\n+}\n+\n+/// LLVMTypeKind\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+#[repr(C)]\n+pub enum TypeKind {\n+    Void = 0,\n+    Half = 1,\n+    Float = 2,\n+    Double = 3,\n+    X86_FP80 = 4,\n+    FP128 = 5,\n+    PPC_FP128 = 6,\n+    Label = 7,\n+    Integer = 8,\n+    Function = 9,\n+    Struct = 10,\n+    Array = 11,\n+    Pointer = 12,\n+    Vector = 13,\n+    Metadata = 14,\n+    X86_MMX = 15,\n+    Token = 16,\n+}\n+\n+/// LLVMAtomicRmwBinOp\n+#[derive(Copy, Clone)]\n+#[repr(C)]\n+pub enum AtomicRmwBinOp {\n+    AtomicXchg = 0,\n+    AtomicAdd = 1,\n+    AtomicSub = 2,\n+    AtomicAnd = 3,\n+    AtomicNand = 4,\n+    AtomicOr = 5,\n+    AtomicXor = 6,\n+    AtomicMax = 7,\n+    AtomicMin = 8,\n+    AtomicUMax = 9,\n+    AtomicUMin = 10,\n+}\n+\n+/// LLVMAtomicOrdering\n+#[derive(Copy, Clone)]\n+#[repr(C)]\n+pub enum AtomicOrdering {\n+    #[allow(dead_code)]\n+    NotAtomic = 0,\n+    Unordered = 1,\n+    Monotonic = 2,\n+    // Consume = 3,  // Not specified yet.\n+    Acquire = 4,\n+    Release = 5,\n+    AcquireRelease = 6,\n+    SequentiallyConsistent = 7,\n+}\n+\n+/// LLVMRustSynchronizationScope\n+#[derive(Copy, Clone)]\n+#[repr(C)]\n+pub enum SynchronizationScope {\n+    // FIXME: figure out if this variant is needed at all.\n+    #[allow(dead_code)]\n+    Other,\n+    SingleThread,\n+    CrossThread,\n+}\n+\n+/// LLVMRustFileType\n+#[derive(Copy, Clone)]\n+#[repr(C)]\n+pub enum FileType {\n+    // FIXME: figure out if this variant is needed at all.\n+    #[allow(dead_code)]\n+    Other,\n+    AssemblyFile,\n+    ObjectFile,\n+}\n+\n+/// LLVMMetadataType\n+#[derive(Copy, Clone)]\n+#[repr(C)]\n+pub enum MetadataType {\n+    MD_dbg = 0,\n+    MD_tbaa = 1,\n+    MD_prof = 2,\n+    MD_fpmath = 3,\n+    MD_range = 4,\n+    MD_tbaa_struct = 5,\n+    MD_invariant_load = 6,\n+    MD_alias_scope = 7,\n+    MD_noalias = 8,\n+    MD_nontemporal = 9,\n+    MD_mem_parallel_loop_access = 10,\n+    MD_nonnull = 11,\n+}\n+\n+/// LLVMRustAsmDialect\n+#[derive(Copy, Clone)]\n+#[repr(C)]\n+pub enum AsmDialect {\n+    // FIXME: figure out if this variant is needed at all.\n+    #[allow(dead_code)]\n+    Other,\n+    Att,\n+    Intel,\n+}\n+\n+/// LLVMRustCodeGenOptLevel\n+#[derive(Copy, Clone, PartialEq)]\n+#[repr(C)]\n+pub enum CodeGenOptLevel {\n+    // FIXME: figure out if this variant is needed at all.\n+    #[allow(dead_code)]\n+    Other,\n+    None,\n+    Less,\n+    Default,\n+    Aggressive,\n+}\n+\n+/// LLVMRelocMode\n+#[derive(Copy, Clone, PartialEq)]\n+#[repr(C)]\n+pub enum RelocMode {\n+    Default,\n+    Static,\n+    PIC,\n+    DynamicNoPic,\n+    ROPI,\n+    RWPI,\n+    ROPI_RWPI,\n+}\n+\n+/// LLVMRustCodeModel\n+#[derive(Copy, Clone)]\n+#[repr(C)]\n+pub enum CodeModel {\n+    // FIXME: figure out if this variant is needed at all.\n+    #[allow(dead_code)]\n+    Other,\n+    Small,\n+    Kernel,\n+    Medium,\n+    Large,\n+    None,\n+}\n+\n+/// LLVMRustDiagnosticKind\n+#[derive(Copy, Clone)]\n+#[repr(C)]\n+#[allow(dead_code)] // Variants constructed by C++.\n+pub enum DiagnosticKind {\n+    Other,\n+    InlineAsm,\n+    StackSize,\n+    DebugMetadataVersion,\n+    SampleProfile,\n+    OptimizationRemark,\n+    OptimizationRemarkMissed,\n+    OptimizationRemarkAnalysis,\n+    OptimizationRemarkAnalysisFPCommute,\n+    OptimizationRemarkAnalysisAliasing,\n+    OptimizationRemarkOther,\n+    OptimizationFailure,\n+    PGOProfile,\n+}\n+\n+/// LLVMRustArchiveKind\n+#[derive(Copy, Clone)]\n+#[repr(C)]\n+pub enum ArchiveKind {\n+    // FIXME: figure out if this variant is needed at all.\n+    #[allow(dead_code)]\n+    Other,\n+    K_GNU,\n+    K_BSD,\n+    K_COFF,\n+}\n+\n+/// LLVMRustPassKind\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+#[repr(C)]\n+#[allow(dead_code)] // Variants constructed by C++.\n+pub enum PassKind {\n+    Other,\n+    Function,\n+    Module,\n+}\n+\n+/// LLVMRustThinLTOData\n+extern { pub type ThinLTOData; }\n+\n+/// LLVMRustThinLTOBuffer\n+extern { pub type ThinLTOBuffer; }\n+\n+/// LLVMRustThinLTOModule\n+#[repr(C)]\n+pub struct ThinLTOModule {\n+    pub identifier: *const c_char,\n+    pub data: *const u8,\n+    pub len: usize,\n+}\n+\n+/// LLVMThreadLocalMode\n+#[derive(Copy, Clone)]\n+#[repr(C)]\n+pub enum ThreadLocalMode {\n+  NotThreadLocal,\n+  GeneralDynamic,\n+  LocalDynamic,\n+  InitialExec,\n+  LocalExec\n+}\n+\n+extern { type Opaque; }\n+#[repr(C)]\n+struct InvariantOpaque<'a> {\n+    _marker: PhantomData<&'a mut &'a ()>,\n+    _opaque: Opaque,\n+}\n+\n+// Opaque pointer types\n+extern { pub type Module; }\n+extern { pub type Context; }\n+extern { pub type Type; }\n+extern { pub type Value; }\n+extern { pub type Metadata; }\n+extern { pub type BasicBlock; }\n+#[repr(C)]\n+pub struct Builder<'a>(InvariantOpaque<'a>);\n+extern { pub type MemoryBuffer; }\n+#[repr(C)]\n+pub struct PassManager<'a>(InvariantOpaque<'a>);\n+extern { pub type PassManagerBuilder; }\n+extern { pub type ObjectFile; }\n+#[repr(C)]\n+pub struct SectionIterator<'a>(InvariantOpaque<'a>);\n+extern { pub type Pass; }\n+extern { pub type TargetMachine; }\n+extern { pub type Archive; }\n+#[repr(C)]\n+pub struct ArchiveIterator<'a>(InvariantOpaque<'a>);\n+#[repr(C)]\n+pub struct ArchiveChild<'a>(InvariantOpaque<'a>);\n+extern { pub type Twine; }\n+extern { pub type DiagnosticInfo; }\n+extern { pub type SMDiagnostic; }\n+#[repr(C)]\n+pub struct RustArchiveMember<'a>(InvariantOpaque<'a>);\n+#[repr(C)]\n+pub struct OperandBundleDef<'a>(InvariantOpaque<'a>);\n+#[repr(C)]\n+pub struct Linker<'a>(InvariantOpaque<'a>);\n+\n+pub type DiagnosticHandler = unsafe extern \"C\" fn(&DiagnosticInfo, *mut c_void);\n+pub type InlineAsmDiagHandler = unsafe extern \"C\" fn(&SMDiagnostic, *const c_void, c_uint);\n+\n+\n+pub mod debuginfo {\n+    use super::{InvariantOpaque, Metadata};\n+\n+    #[repr(C)]\n+    pub struct DIBuilder<'a>(InvariantOpaque<'a>);\n+\n+    pub type DIDescriptor = Metadata;\n+    pub type DIScope = DIDescriptor;\n+    pub type DIFile = DIScope;\n+    pub type DILexicalBlock = DIScope;\n+    pub type DISubprogram = DIScope;\n+    pub type DINameSpace = DIScope;\n+    pub type DIType = DIDescriptor;\n+    pub type DIBasicType = DIType;\n+    pub type DIDerivedType = DIType;\n+    pub type DICompositeType = DIDerivedType;\n+    pub type DIVariable = DIDescriptor;\n+    pub type DIGlobalVariable = DIDescriptor;\n+    pub type DIArray = DIDescriptor;\n+    pub type DISubrange = DIDescriptor;\n+    pub type DIEnumerator = DIDescriptor;\n+    pub type DITemplateTypeParameter = DIDescriptor;\n+\n+    // These values **must** match with LLVMRustDIFlags!!\n+    bitflags! {\n+        #[repr(C)]\n+        #[derive(Default)]\n+        pub struct DIFlags: ::libc::uint32_t {\n+            const FlagZero                = 0;\n+            const FlagPrivate             = 1;\n+            const FlagProtected           = 2;\n+            const FlagPublic              = 3;\n+            const FlagFwdDecl             = (1 << 2);\n+            const FlagAppleBlock          = (1 << 3);\n+            const FlagBlockByrefStruct    = (1 << 4);\n+            const FlagVirtual             = (1 << 5);\n+            const FlagArtificial          = (1 << 6);\n+            const FlagExplicit            = (1 << 7);\n+            const FlagPrototyped          = (1 << 8);\n+            const FlagObjcClassComplete   = (1 << 9);\n+            const FlagObjectPointer       = (1 << 10);\n+            const FlagVector              = (1 << 11);\n+            const FlagStaticMember        = (1 << 12);\n+            const FlagLValueReference     = (1 << 13);\n+            const FlagRValueReference     = (1 << 14);\n+            const FlagExternalTypeRef     = (1 << 15);\n+            const FlagIntroducedVirtual   = (1 << 18);\n+            const FlagBitField            = (1 << 19);\n+            const FlagNoReturn            = (1 << 20);\n+            const FlagMainSubprogram      = (1 << 21);\n+        }\n+    }\n+}\n+\n+extern { pub type ModuleBuffer; }\n+\n+extern \"C\" {\n+    // Create and destroy contexts.\n+    pub fn LLVMRustContextCreate(shouldDiscardNames: bool) -> &'static mut Context;\n+    pub fn LLVMContextDispose(C: &'static mut Context);\n+    pub fn LLVMGetMDKindIDInContext(C: &Context, Name: *const c_char, SLen: c_uint) -> c_uint;\n+\n+    // Create modules.\n+    pub fn LLVMModuleCreateWithNameInContext(ModuleID: *const c_char, C: &Context) -> &Module;\n+    pub fn LLVMGetModuleContext(M: &Module) -> &Context;\n+    pub fn LLVMCloneModule(M: &Module) -> &Module;\n+\n+    /// Data layout. See Module::getDataLayout.\n+    pub fn LLVMGetDataLayout(M: &Module) -> *const c_char;\n+    pub fn LLVMSetDataLayout(M: &Module, Triple: *const c_char);\n+\n+    /// See Module::setModuleInlineAsm.\n+    pub fn LLVMSetModuleInlineAsm(M: &Module, Asm: *const c_char);\n+    pub fn LLVMRustAppendModuleInlineAsm(M: &Module, Asm: *const c_char);\n+\n+    /// See llvm::LLVMTypeKind::getTypeID.\n+    pub fn LLVMRustGetTypeKind(Ty: &Type) -> TypeKind;\n+\n+    // Operations on integer types\n+    pub fn LLVMInt1TypeInContext(C: &Context) -> &Type;\n+    pub fn LLVMInt8TypeInContext(C: &Context) -> &Type;\n+    pub fn LLVMInt16TypeInContext(C: &Context) -> &Type;\n+    pub fn LLVMInt32TypeInContext(C: &Context) -> &Type;\n+    pub fn LLVMInt64TypeInContext(C: &Context) -> &Type;\n+    pub fn LLVMIntTypeInContext(C: &Context, NumBits: c_uint) -> &Type;\n+\n+    pub fn LLVMGetIntTypeWidth(IntegerTy: &Type) -> c_uint;\n+\n+    // Operations on real types\n+    pub fn LLVMFloatTypeInContext(C: &Context) -> &Type;\n+    pub fn LLVMDoubleTypeInContext(C: &Context) -> &Type;\n+\n+    // Operations on function types\n+    pub fn LLVMFunctionType(ReturnType: &'a Type,\n+                            ParamTypes: *const &'a Type,\n+                            ParamCount: c_uint,\n+                            IsVarArg: Bool)\n+                            -> &'a Type;\n+    pub fn LLVMCountParamTypes(FunctionTy: &Type) -> c_uint;\n+    pub fn LLVMGetParamTypes(FunctionTy: &'a Type, Dest: *mut &'a Type);\n+\n+    // Operations on struct types\n+    pub fn LLVMStructTypeInContext(C: &'a Context,\n+                                   ElementTypes: *const &'a Type,\n+                                   ElementCount: c_uint,\n+                                   Packed: Bool)\n+                                   -> &'a Type;\n+\n+    // Operations on array, pointer, and vector types (sequence types)\n+    pub fn LLVMRustArrayType(ElementType: &Type, ElementCount: u64) -> &Type;\n+    pub fn LLVMPointerType(ElementType: &Type, AddressSpace: c_uint) -> &Type;\n+    pub fn LLVMVectorType(ElementType: &Type, ElementCount: c_uint) -> &Type;\n+\n+    pub fn LLVMGetElementType(Ty: &Type) -> &Type;\n+    pub fn LLVMGetVectorSize(VectorTy: &Type) -> c_uint;\n+\n+    // Operations on other types\n+    pub fn LLVMVoidTypeInContext(C: &Context) -> &Type;\n+    pub fn LLVMX86MMXTypeInContext(C: &Context) -> &Type;\n+    pub fn LLVMRustMetadataTypeInContext(C: &Context) -> &Type;\n+\n+    // Operations on all values\n+    pub fn LLVMTypeOf(Val: &Value) -> &Type;\n+    pub fn LLVMGetValueName(Val: &Value) -> *const c_char;\n+    pub fn LLVMSetValueName(Val: &Value, Name: *const c_char);\n+    pub fn LLVMReplaceAllUsesWith(OldVal: &'a Value, NewVal: &'a Value);\n+    pub fn LLVMSetMetadata(Val: &'a Value, KindID: c_uint, Node: &'a Value);\n+\n+    // Operations on constants of any type\n+    pub fn LLVMConstNull(Ty: &Type) -> &Value;\n+    pub fn LLVMGetUndef(Ty: &Type) -> &Value;\n+\n+    // Operations on metadata\n+    pub fn LLVMMDStringInContext(C: &Context, Str: *const c_char, SLen: c_uint) -> &Value;\n+    pub fn LLVMMDNodeInContext(C: &'a Context, Vals: *const &'a Value, Count: c_uint) -> &'a Value;\n+    pub fn LLVMAddNamedMetadataOperand(M: &'a Module, Name: *const c_char, Val: &'a Value);\n+\n+    // Operations on scalar constants\n+    pub fn LLVMConstInt(IntTy: &Type, N: c_ulonglong, SignExtend: Bool) -> &Value;\n+    pub fn LLVMConstIntOfArbitraryPrecision(IntTy: &Type, Wn: c_uint, Ws: *const u64) -> &Value;\n+    pub fn LLVMConstIntGetZExtValue(ConstantVal: &Value) -> c_ulonglong;\n+    pub fn LLVMRustConstInt128Get(ConstantVal: &Value, SExt: bool,\n+                                  high: &mut u64, low: &mut u64) -> bool;\n+    pub fn LLVMConstRealGetDouble (ConstantVal: &Value, losesInfo: &mut Bool) -> f64;\n+\n+\n+    // Operations on composite constants\n+    pub fn LLVMConstStringInContext(C: &Context,\n+                                    Str: *const c_char,\n+                                    Length: c_uint,\n+                                    DontNullTerminate: Bool)\n+                                    -> &Value;\n+    pub fn LLVMConstStructInContext(C: &'a Context,\n+                                    ConstantVals: *const &'a Value,\n+                                    Count: c_uint,\n+                                    Packed: Bool)\n+                                    -> &'a Value;\n+\n+    pub fn LLVMConstArray(ElementTy: &'a Type,\n+                          ConstantVals: *const &'a Value,\n+                          Length: c_uint)\n+                          -> &'a Value;\n+    pub fn LLVMConstVector(ScalarConstantVals: *const &Value, Size: c_uint) -> &Value;\n+\n+    // Constant expressions\n+    pub fn LLVMConstInBoundsGEP(\n+        ConstantVal: &'a Value,\n+        ConstantIndices: *const &'a Value,\n+        NumIndices: c_uint,\n+    ) -> &'a Value;\n+    pub fn LLVMConstZExt(ConstantVal: &'a Value, ToType: &'a Type) -> &'a Value;\n+    pub fn LLVMConstPtrToInt(ConstantVal: &'a Value, ToType: &'a Type) -> &'a Value;\n+    pub fn LLVMConstIntToPtr(ConstantVal: &'a Value, ToType: &'a Type) -> &'a Value;\n+    pub fn LLVMConstBitCast(ConstantVal: &'a Value, ToType: &'a Type) -> &'a Value;\n+    pub fn LLVMConstPointerCast(ConstantVal: &'a Value, ToType: &'a Type) -> &'a Value;\n+    pub fn LLVMConstExtractValue(AggConstant: &Value,\n+                                 IdxList: *const c_uint,\n+                                 NumIdx: c_uint)\n+                                 -> &Value;\n+\n+    // Operations on global variables, functions, and aliases (globals)\n+    pub fn LLVMIsDeclaration(Global: &Value) -> Bool;\n+    pub fn LLVMRustGetLinkage(Global: &Value) -> Linkage;\n+    pub fn LLVMRustSetLinkage(Global: &Value, RustLinkage: Linkage);\n+    pub fn LLVMSetSection(Global: &Value, Section: *const c_char);\n+    pub fn LLVMRustGetVisibility(Global: &Value) -> Visibility;\n+    pub fn LLVMRustSetVisibility(Global: &Value, Viz: Visibility);\n+    pub fn LLVMGetAlignment(Global: &Value) -> c_uint;\n+    pub fn LLVMSetAlignment(Global: &Value, Bytes: c_uint);\n+    pub fn LLVMSetDLLStorageClass(V: &Value, C: DLLStorageClass);\n+\n+\n+    // Operations on global variables\n+    pub fn LLVMIsAGlobalVariable(GlobalVar: &Value) -> Option<&Value>;\n+    pub fn LLVMAddGlobal(M: &'a Module, Ty: &'a Type, Name: *const c_char) -> &'a Value;\n+    pub fn LLVMGetNamedGlobal(M: &Module, Name: *const c_char) -> Option<&Value>;\n+    pub fn LLVMRustGetOrInsertGlobal(M: &'a Module, Name: *const c_char, T: &'a Type) -> &'a Value;\n+    pub fn LLVMGetFirstGlobal(M: &Module) -> Option<&Value>;\n+    pub fn LLVMGetNextGlobal(GlobalVar: &Value) -> Option<&Value>;\n+    pub fn LLVMDeleteGlobal(GlobalVar: &Value);\n+    pub fn LLVMGetInitializer(GlobalVar: &Value) -> Option<&Value>;\n+    pub fn LLVMSetInitializer(GlobalVar: &'a Value, ConstantVal: &'a Value);\n+    pub fn LLVMSetThreadLocal(GlobalVar: &Value, IsThreadLocal: Bool);\n+    pub fn LLVMSetThreadLocalMode(GlobalVar: &Value, Mode: ThreadLocalMode);\n+    pub fn LLVMIsGlobalConstant(GlobalVar: &Value) -> Bool;\n+    pub fn LLVMSetGlobalConstant(GlobalVar: &Value, IsConstant: Bool);\n+    pub fn LLVMRustGetNamedValue(M: &Module, Name: *const c_char) -> Option<&Value>;\n+    pub fn LLVMSetTailCall(CallInst: &Value, IsTailCall: Bool);\n+\n+    // Operations on functions\n+    pub fn LLVMRustGetOrInsertFunction(M: &'a Module,\n+                                       Name: *const c_char,\n+                                       FunctionTy: &'a Type)\n+                                       -> &'a Value;\n+    pub fn LLVMSetFunctionCallConv(Fn: &Value, CC: c_uint);\n+    pub fn LLVMRustAddAlignmentAttr(Fn: &Value, index: c_uint, bytes: u32);\n+    pub fn LLVMRustAddDereferenceableAttr(Fn: &Value, index: c_uint, bytes: u64);\n+    pub fn LLVMRustAddDereferenceableOrNullAttr(Fn: &Value, index: c_uint, bytes: u64);\n+    pub fn LLVMRustAddFunctionAttribute(Fn: &Value, index: c_uint, attr: Attribute);\n+    pub fn LLVMRustAddFunctionAttrStringValue(Fn: &Value,\n+                                              index: c_uint,\n+                                              Name: *const c_char,\n+                                              Value: *const c_char);\n+    pub fn LLVMRustRemoveFunctionAttributes(Fn: &Value, index: c_uint, attr: Attribute);\n+\n+    // Operations on parameters\n+    pub fn LLVMCountParams(Fn: &Value) -> c_uint;\n+    pub fn LLVMGetParam(Fn: &Value, Index: c_uint) -> &Value;\n+\n+    // Operations on basic blocks\n+    pub fn LLVMGetBasicBlockParent(BB: &BasicBlock) -> &Value;\n+    pub fn LLVMAppendBasicBlockInContext(C: &'a Context,\n+                                         Fn: &'a Value,\n+                                         Name: *const c_char)\n+                                         -> &'a BasicBlock;\n+    pub fn LLVMDeleteBasicBlock(BB: &BasicBlock);\n+\n+    // Operations on instructions\n+    pub fn LLVMGetFirstBasicBlock(Fn: &Value) -> &BasicBlock;\n+\n+    // Operations on call sites\n+    pub fn LLVMSetInstructionCallConv(Instr: &Value, CC: c_uint);\n+    pub fn LLVMRustAddCallSiteAttribute(Instr: &Value, index: c_uint, attr: Attribute);\n+    pub fn LLVMRustAddAlignmentCallSiteAttr(Instr: &Value, index: c_uint, bytes: u32);\n+    pub fn LLVMRustAddDereferenceableCallSiteAttr(Instr: &Value, index: c_uint, bytes: u64);\n+    pub fn LLVMRustAddDereferenceableOrNullCallSiteAttr(Instr: &Value,\n+                                                        index: c_uint,\n+                                                        bytes: u64);\n+\n+    // Operations on load/store instructions (only)\n+    pub fn LLVMSetVolatile(MemoryAccessInst: &Value, volatile: Bool);\n+\n+    // Operations on phi nodes\n+    pub fn LLVMAddIncoming(PhiNode: &'a Value,\n+                           IncomingValues: *const &'a Value,\n+                           IncomingBlocks: *const &'a BasicBlock,\n+                           Count: c_uint);\n+\n+    // Instruction builders\n+    pub fn LLVMCreateBuilderInContext(C: &'a Context) -> &'a mut Builder<'a>;\n+    pub fn LLVMPositionBuilderAtEnd(Builder: &Builder<'a>, Block: &'a BasicBlock);\n+    pub fn LLVMGetInsertBlock(Builder: &Builder<'a>) -> &'a BasicBlock;\n+    pub fn LLVMDisposeBuilder(Builder: &'a mut Builder<'a>);\n+\n+    // Metadata\n+    pub fn LLVMSetCurrentDebugLocation(Builder: &Builder<'a>, L: Option<&'a Value>);\n+    pub fn LLVMGetCurrentDebugLocation(Builder: &Builder<'a>) -> &'a Value;\n+    pub fn LLVMSetInstDebugLocation(Builder: &Builder<'a>, Inst: &'a Value);\n+\n+    // Terminators\n+    pub fn LLVMBuildRetVoid(B: &Builder<'a>) -> &'a Value;\n+    pub fn LLVMBuildRet(B: &Builder<'a>, V: &'a Value) -> &'a Value;\n+    pub fn LLVMBuildBr(B: &Builder<'a>, Dest: &'a BasicBlock) -> &'a Value;\n+    pub fn LLVMBuildCondBr(B: &Builder<'a>,\n+                           If: &'a Value,\n+                           Then: &'a BasicBlock,\n+                           Else: &'a BasicBlock)\n+                           -> &'a Value;\n+    pub fn LLVMBuildSwitch(B: &Builder<'a>,\n+                           V: &'a Value,\n+                           Else: &'a BasicBlock,\n+                           NumCases: c_uint)\n+                           -> &'a Value;\n+    pub fn LLVMRustBuildInvoke(B: &Builder<'a>,\n+                               Fn: &'a Value,\n+                               Args: *const &'a Value,\n+                               NumArgs: c_uint,\n+                               Then: &'a BasicBlock,\n+                               Catch: &'a BasicBlock,\n+                               Bundle: Option<&OperandBundleDef<'a>>,\n+                               Name: *const c_char)\n+                               -> &'a Value;\n+    pub fn LLVMBuildLandingPad(B: &Builder<'a>,\n+                               Ty: &'a Type,\n+                               PersFn: &'a Value,\n+                               NumClauses: c_uint,\n+                               Name: *const c_char)\n+                               -> &'a Value;\n+    pub fn LLVMBuildResume(B: &Builder<'a>, Exn: &'a Value) -> &'a Value;\n+    pub fn LLVMBuildUnreachable(B: &Builder<'a>) -> &'a Value;\n+\n+    pub fn LLVMRustBuildCleanupPad(B: &Builder<'a>,\n+                                   ParentPad: Option<&'a Value>,\n+                                   ArgCnt: c_uint,\n+                                   Args: *const &'a Value,\n+                                   Name: *const c_char)\n+                                   -> Option<&'a Value>;\n+    pub fn LLVMRustBuildCleanupRet(B: &Builder<'a>,\n+                                   CleanupPad: &'a Value,\n+                                   UnwindBB: Option<&'a BasicBlock>)\n+                                   -> Option<&'a Value>;\n+    pub fn LLVMRustBuildCatchPad(B: &Builder<'a>,\n+                                 ParentPad: &'a Value,\n+                                 ArgCnt: c_uint,\n+                                 Args: *const &'a Value,\n+                                 Name: *const c_char)\n+                                 -> Option<&'a Value>;\n+    pub fn LLVMRustBuildCatchRet(\n+        B: &Builder<'a>,\n+        Pad: &'a Value,\n+        BB: &'a BasicBlock,\n+    ) -> Option<&'a Value>;\n+    pub fn LLVMRustBuildCatchSwitch(Builder: &Builder<'a>,\n+                                    ParentPad: Option<&'a Value>,\n+                                    BB: Option<&'a BasicBlock>,\n+                                    NumHandlers: c_uint,\n+                                    Name: *const c_char)\n+                                    -> Option<&'a Value>;\n+    pub fn LLVMRustAddHandler(CatchSwitch: &'a Value, Handler: &'a BasicBlock);\n+    pub fn LLVMSetPersonalityFn(Func: &'a Value, Pers: &'a Value);\n+\n+    // Add a case to the switch instruction\n+    pub fn LLVMAddCase(Switch: &'a Value, OnVal: &'a Value, Dest: &'a BasicBlock);\n+\n+    // Add a clause to the landing pad instruction\n+    pub fn LLVMAddClause(LandingPad: &'a Value, ClauseVal: &'a Value);\n+\n+    // Set the cleanup on a landing pad instruction\n+    pub fn LLVMSetCleanup(LandingPad: &Value, Val: Bool);\n+\n+    // Arithmetic\n+    pub fn LLVMBuildAdd(B: &Builder<'a>,\n+                        LHS: &'a Value,\n+                        RHS: &'a Value,\n+                        Name: *const c_char)\n+                        -> &'a Value;\n+    pub fn LLVMBuildFAdd(B: &Builder<'a>,\n+                         LHS: &'a Value,\n+                         RHS: &'a Value,\n+                         Name: *const c_char)\n+                         -> &'a Value;\n+    pub fn LLVMBuildSub(B: &Builder<'a>,\n+                        LHS: &'a Value,\n+                        RHS: &'a Value,\n+                        Name: *const c_char)\n+                        -> &'a Value;\n+    pub fn LLVMBuildFSub(B: &Builder<'a>,\n+                         LHS: &'a Value,\n+                         RHS: &'a Value,\n+                         Name: *const c_char)\n+                         -> &'a Value;\n+    pub fn LLVMBuildMul(B: &Builder<'a>,\n+                        LHS: &'a Value,\n+                        RHS: &'a Value,\n+                        Name: *const c_char)\n+                        -> &'a Value;\n+    pub fn LLVMBuildFMul(B: &Builder<'a>,\n+                         LHS: &'a Value,\n+                         RHS: &'a Value,\n+                         Name: *const c_char)\n+                         -> &'a Value;\n+    pub fn LLVMBuildUDiv(B: &Builder<'a>,\n+                         LHS: &'a Value,\n+                         RHS: &'a Value,\n+                         Name: *const c_char)\n+                         -> &'a Value;\n+    pub fn LLVMBuildExactUDiv(B: &Builder<'a>,\n+                              LHS: &'a Value,\n+                              RHS: &'a Value,\n+                              Name: *const c_char)\n+                              -> &'a Value;\n+    pub fn LLVMBuildSDiv(B: &Builder<'a>,\n+                         LHS: &'a Value,\n+                         RHS: &'a Value,\n+                         Name: *const c_char)\n+                         -> &'a Value;\n+    pub fn LLVMBuildExactSDiv(B: &Builder<'a>,\n+                              LHS: &'a Value,\n+                              RHS: &'a Value,\n+                              Name: *const c_char)\n+                              -> &'a Value;\n+    pub fn LLVMBuildFDiv(B: &Builder<'a>,\n+                         LHS: &'a Value,\n+                         RHS: &'a Value,\n+                         Name: *const c_char)\n+                         -> &'a Value;\n+    pub fn LLVMBuildURem(B: &Builder<'a>,\n+                         LHS: &'a Value,\n+                         RHS: &'a Value,\n+                         Name: *const c_char)\n+                         -> &'a Value;\n+    pub fn LLVMBuildSRem(B: &Builder<'a>,\n+                         LHS: &'a Value,\n+                         RHS: &'a Value,\n+                         Name: *const c_char)\n+                         -> &'a Value;\n+    pub fn LLVMBuildFRem(B: &Builder<'a>,\n+                         LHS: &'a Value,\n+                         RHS: &'a Value,\n+                         Name: *const c_char)\n+                         -> &'a Value;\n+    pub fn LLVMBuildShl(B: &Builder<'a>,\n+                        LHS: &'a Value,\n+                        RHS: &'a Value,\n+                        Name: *const c_char)\n+                        -> &'a Value;\n+    pub fn LLVMBuildLShr(B: &Builder<'a>,\n+                         LHS: &'a Value,\n+                         RHS: &'a Value,\n+                         Name: *const c_char)\n+                         -> &'a Value;\n+    pub fn LLVMBuildAShr(B: &Builder<'a>,\n+                         LHS: &'a Value,\n+                         RHS: &'a Value,\n+                         Name: *const c_char)\n+                         -> &'a Value;\n+    pub fn LLVMBuildAnd(B: &Builder<'a>,\n+                        LHS: &'a Value,\n+                        RHS: &'a Value,\n+                        Name: *const c_char)\n+                        -> &'a Value;\n+    pub fn LLVMBuildOr(B: &Builder<'a>,\n+                       LHS: &'a Value,\n+                       RHS: &'a Value,\n+                       Name: *const c_char)\n+                       -> &'a Value;\n+    pub fn LLVMBuildXor(B: &Builder<'a>,\n+                        LHS: &'a Value,\n+                        RHS: &'a Value,\n+                        Name: *const c_char)\n+                        -> &'a Value;\n+    pub fn LLVMBuildNeg(B: &Builder<'a>, V: &'a Value, Name: *const c_char) -> &'a Value;\n+    pub fn LLVMBuildFNeg(B: &Builder<'a>, V: &'a Value, Name: *const c_char) -> &'a Value;\n+    pub fn LLVMBuildNot(B: &Builder<'a>, V: &'a Value, Name: *const c_char) -> &'a Value;\n+    pub fn LLVMRustSetHasUnsafeAlgebra(Instr: &Value);\n+\n+    // Memory\n+    pub fn LLVMBuildAlloca(B: &Builder<'a>, Ty: &'a Type, Name: *const c_char) -> &'a Value;\n+    pub fn LLVMBuildLoad(B: &Builder<'a>, PointerVal: &'a Value, Name: *const c_char) -> &'a Value;\n+\n+    pub fn LLVMBuildStore(B: &Builder<'a>, Val: &'a Value, Ptr: &'a Value) -> &'a Value;\n+\n+    pub fn LLVMBuildGEP(B: &Builder<'a>,\n+                        Pointer: &'a Value,\n+                        Indices: *const &'a Value,\n+                        NumIndices: c_uint,\n+                        Name: *const c_char)\n+                        -> &'a Value;\n+    pub fn LLVMBuildInBoundsGEP(B: &Builder<'a>,\n+                                Pointer: &'a Value,\n+                                Indices: *const &'a Value,\n+                                NumIndices: c_uint,\n+                                Name: *const c_char)\n+                                -> &'a Value;\n+    pub fn LLVMBuildStructGEP(B: &Builder<'a>,\n+                              Pointer: &'a Value,\n+                              Idx: c_uint,\n+                              Name: *const c_char)\n+                              -> &'a Value;\n+\n+    // Casts\n+    pub fn LLVMBuildTrunc(B: &Builder<'a>,\n+                          Val: &'a Value,\n+                          DestTy: &'a Type,\n+                          Name: *const c_char)\n+                          -> &'a Value;\n+    pub fn LLVMBuildZExt(B: &Builder<'a>,\n+                         Val: &'a Value,\n+                         DestTy: &'a Type,\n+                         Name: *const c_char)\n+                         -> &'a Value;\n+    pub fn LLVMBuildSExt(B: &Builder<'a>,\n+                         Val: &'a Value,\n+                         DestTy: &'a Type,\n+                         Name: *const c_char)\n+                         -> &'a Value;\n+    pub fn LLVMBuildFPToUI(B: &Builder<'a>,\n+                           Val: &'a Value,\n+                           DestTy: &'a Type,\n+                           Name: *const c_char)\n+                           -> &'a Value;\n+    pub fn LLVMBuildFPToSI(B: &Builder<'a>,\n+                           Val: &'a Value,\n+                           DestTy: &'a Type,\n+                           Name: *const c_char)\n+                           -> &'a Value;\n+    pub fn LLVMBuildUIToFP(B: &Builder<'a>,\n+                           Val: &'a Value,\n+                           DestTy: &'a Type,\n+                           Name: *const c_char)\n+                           -> &'a Value;\n+    pub fn LLVMBuildSIToFP(B: &Builder<'a>,\n+                           Val: &'a Value,\n+                           DestTy: &'a Type,\n+                           Name: *const c_char)\n+                           -> &'a Value;\n+    pub fn LLVMBuildFPTrunc(B: &Builder<'a>,\n+                            Val: &'a Value,\n+                            DestTy: &'a Type,\n+                            Name: *const c_char)\n+                            -> &'a Value;\n+    pub fn LLVMBuildFPExt(B: &Builder<'a>,\n+                          Val: &'a Value,\n+                          DestTy: &'a Type,\n+                          Name: *const c_char)\n+                          -> &'a Value;\n+    pub fn LLVMBuildPtrToInt(B: &Builder<'a>,\n+                             Val: &'a Value,\n+                             DestTy: &'a Type,\n+                             Name: *const c_char)\n+                             -> &'a Value;\n+    pub fn LLVMBuildIntToPtr(B: &Builder<'a>,\n+                             Val: &'a Value,\n+                             DestTy: &'a Type,\n+                             Name: *const c_char)\n+                             -> &'a Value;\n+    pub fn LLVMBuildBitCast(B: &Builder<'a>,\n+                            Val: &'a Value,\n+                            DestTy: &'a Type,\n+                            Name: *const c_char)\n+                            -> &'a Value;\n+    pub fn LLVMBuildPointerCast(B: &Builder<'a>,\n+                                Val: &'a Value,\n+                                DestTy: &'a Type,\n+                                Name: *const c_char)\n+                                -> &'a Value;\n+    pub fn LLVMRustBuildIntCast(B: &Builder<'a>,\n+                                Val: &'a Value,\n+                                DestTy: &'a Type,\n+                                IsSized: bool)\n+                                -> &'a Value;\n+\n+    // Comparisons\n+    pub fn LLVMBuildICmp(B: &Builder<'a>,\n+                         Op: c_uint,\n+                         LHS: &'a Value,\n+                         RHS: &'a Value,\n+                         Name: *const c_char)\n+                         -> &'a Value;\n+    pub fn LLVMBuildFCmp(B: &Builder<'a>,\n+                         Op: c_uint,\n+                         LHS: &'a Value,\n+                         RHS: &'a Value,\n+                         Name: *const c_char)\n+                         -> &'a Value;\n+\n+    // Miscellaneous instructions\n+    pub fn LLVMBuildPhi(B: &Builder<'a>, Ty: &'a Type, Name: *const c_char) -> &'a Value;\n+    pub fn LLVMRustBuildCall(B: &Builder<'a>,\n+                             Fn: &'a Value,\n+                             Args: *const &'a Value,\n+                             NumArgs: c_uint,\n+                             Bundle: Option<&OperandBundleDef<'a>>,\n+                             Name: *const c_char)\n+                             -> &'a Value;\n+    pub fn LLVMBuildSelect(B: &Builder<'a>,\n+                           If: &'a Value,\n+                           Then: &'a Value,\n+                           Else: &'a Value,\n+                           Name: *const c_char)\n+                           -> &'a Value;\n+    pub fn LLVMBuildVAArg(B: &Builder<'a>,\n+                          list: &'a Value,\n+                          Ty: &'a Type,\n+                          Name: *const c_char)\n+                          -> &'a Value;\n+    pub fn LLVMBuildExtractElement(B: &Builder<'a>,\n+                                   VecVal: &'a Value,\n+                                   Index: &'a Value,\n+                                   Name: *const c_char)\n+                                   -> &'a Value;\n+    pub fn LLVMBuildInsertElement(B: &Builder<'a>,\n+                                  VecVal: &'a Value,\n+                                  EltVal: &'a Value,\n+                                  Index: &'a Value,\n+                                  Name: *const c_char)\n+                                  -> &'a Value;\n+    pub fn LLVMBuildShuffleVector(B: &Builder<'a>,\n+                                  V1: &'a Value,\n+                                  V2: &'a Value,\n+                                  Mask: &'a Value,\n+                                  Name: *const c_char)\n+                                  -> &'a Value;\n+    pub fn LLVMBuildExtractValue(B: &Builder<'a>,\n+                                 AggVal: &'a Value,\n+                                 Index: c_uint,\n+                                 Name: *const c_char)\n+                                 -> &'a Value;\n+    pub fn LLVMBuildInsertValue(B: &Builder<'a>,\n+                                AggVal: &'a Value,\n+                                EltVal: &'a Value,\n+                                Index: c_uint,\n+                                Name: *const c_char)\n+                                -> &'a Value;\n+\n+    pub fn LLVMRustBuildVectorReduceFAdd(B: &Builder<'a>,\n+                                         Acc: &'a Value,\n+                                         Src: &'a Value)\n+                                         -> Option<&'a Value>;\n+    pub fn LLVMRustBuildVectorReduceFMul(B: &Builder<'a>,\n+                                         Acc: &'a Value,\n+                                         Src: &'a Value)\n+                                         -> Option<&'a Value>;\n+    pub fn LLVMRustBuildVectorReduceAdd(B: &Builder<'a>,\n+                                        Src: &'a Value)\n+                                        -> Option<&'a Value>;\n+    pub fn LLVMRustBuildVectorReduceMul(B: &Builder<'a>,\n+                                        Src: &'a Value)\n+                                        -> Option<&'a Value>;\n+    pub fn LLVMRustBuildVectorReduceAnd(B: &Builder<'a>,\n+                                        Src: &'a Value)\n+                                        -> Option<&'a Value>;\n+    pub fn LLVMRustBuildVectorReduceOr(B: &Builder<'a>,\n+                                       Src: &'a Value)\n+                                       -> Option<&'a Value>;\n+    pub fn LLVMRustBuildVectorReduceXor(B: &Builder<'a>,\n+                                        Src: &'a Value)\n+                                        -> Option<&'a Value>;\n+    pub fn LLVMRustBuildVectorReduceMin(B: &Builder<'a>,\n+                                        Src: &'a Value,\n+                                        IsSigned: bool)\n+                                        -> Option<&'a Value>;\n+    pub fn LLVMRustBuildVectorReduceMax(B: &Builder<'a>,\n+                                        Src: &'a Value,\n+                                        IsSigned: bool)\n+                                        -> Option<&'a Value>;\n+    pub fn LLVMRustBuildVectorReduceFMin(B: &Builder<'a>,\n+                                         Src: &'a Value,\n+                                         IsNaN: bool)\n+                                         -> Option<&'a Value>;\n+    pub fn LLVMRustBuildVectorReduceFMax(B: &Builder<'a>,\n+                                         Src: &'a Value,\n+                                         IsNaN: bool)\n+                                         -> Option<&'a Value>;\n+\n+    pub fn LLVMRustBuildMinNum(\n+        B: &Builder<'a>,\n+        LHS: &'a Value,\n+        LHS: &'a Value,\n+    ) -> Option<&'a Value>;\n+    pub fn LLVMRustBuildMaxNum(\n+        B: &Builder<'a>,\n+        LHS: &'a Value,\n+        LHS: &'a Value,\n+    ) -> Option<&'a Value>;\n+\n+    // Atomic Operations\n+    pub fn LLVMRustBuildAtomicLoad(B: &Builder<'a>,\n+                                   PointerVal: &'a Value,\n+                                   Name: *const c_char,\n+                                   Order: AtomicOrdering)\n+                                   -> &'a Value;\n+\n+    pub fn LLVMRustBuildAtomicStore(B: &Builder<'a>,\n+                                    Val: &'a Value,\n+                                    Ptr: &'a Value,\n+                                    Order: AtomicOrdering)\n+                                    -> &'a Value;\n+\n+    pub fn LLVMRustBuildAtomicCmpXchg(B: &Builder<'a>,\n+                                      LHS: &'a Value,\n+                                      CMP: &'a Value,\n+                                      RHS: &'a Value,\n+                                      Order: AtomicOrdering,\n+                                      FailureOrder: AtomicOrdering,\n+                                      Weak: Bool)\n+                                      -> &'a Value;\n+\n+    pub fn LLVMBuildAtomicRMW(B: &Builder<'a>,\n+                              Op: AtomicRmwBinOp,\n+                              LHS: &'a Value,\n+                              RHS: &'a Value,\n+                              Order: AtomicOrdering,\n+                              SingleThreaded: Bool)\n+                              -> &'a Value;\n+\n+    pub fn LLVMRustBuildAtomicFence(B: &Builder,\n+                                    Order: AtomicOrdering,\n+                                    Scope: SynchronizationScope);\n+\n+    /// Writes a module to the specified path. Returns 0 on success.\n+    pub fn LLVMWriteBitcodeToFile(M: &Module, Path: *const c_char) -> c_int;\n+\n+    /// Creates a pass manager.\n+    pub fn LLVMCreatePassManager() -> &'a mut PassManager<'a>;\n+\n+    /// Creates a function-by-function pass manager\n+    pub fn LLVMCreateFunctionPassManagerForModule(M: &'a Module) -> &'a mut PassManager<'a>;\n+\n+    /// Disposes a pass manager.\n+    pub fn LLVMDisposePassManager(PM: &'a mut PassManager<'a>);\n+\n+    /// Runs a pass manager on a module.\n+    pub fn LLVMRunPassManager(PM: &PassManager<'a>, M: &'a Module) -> Bool;\n+\n+    pub fn LLVMInitializePasses();\n+\n+    pub fn LLVMPassManagerBuilderCreate() -> &'static mut PassManagerBuilder;\n+    pub fn LLVMPassManagerBuilderDispose(PMB: &'static mut PassManagerBuilder);\n+    pub fn LLVMPassManagerBuilderSetSizeLevel(PMB: &PassManagerBuilder, Value: Bool);\n+    pub fn LLVMPassManagerBuilderSetDisableUnrollLoops(PMB: &PassManagerBuilder, Value: Bool);\n+    pub fn LLVMPassManagerBuilderUseInlinerWithThreshold(PMB: &PassManagerBuilder,\n+                                                         threshold: c_uint);\n+    pub fn LLVMPassManagerBuilderPopulateModulePassManager(PMB: &PassManagerBuilder,\n+                                                           PM: &PassManager);\n+\n+    pub fn LLVMPassManagerBuilderPopulateFunctionPassManager(PMB: &PassManagerBuilder,\n+                                                             PM: &PassManager);\n+    pub fn LLVMPassManagerBuilderPopulateLTOPassManager(PMB: &PassManagerBuilder,\n+                                                        PM: &PassManager,\n+                                                        Internalize: Bool,\n+                                                        RunInliner: Bool);\n+    pub fn LLVMRustPassManagerBuilderPopulateThinLTOPassManager(\n+        PMB: &PassManagerBuilder,\n+        PM: &PassManager) -> bool;\n+\n+    // Stuff that's in rustllvm/ because it's not upstream yet.\n+\n+    /// Opens an object file.\n+    pub fn LLVMCreateObjectFile(\n+        MemBuf: &'static mut MemoryBuffer,\n+    ) -> Option<&'static mut ObjectFile>;\n+    /// Closes an object file.\n+    pub fn LLVMDisposeObjectFile(ObjFile: &'static mut ObjectFile);\n+\n+    /// Enumerates the sections in an object file.\n+    pub fn LLVMGetSections(ObjFile: &'a ObjectFile) -> &'a mut SectionIterator<'a>;\n+    /// Destroys a section iterator.\n+    pub fn LLVMDisposeSectionIterator(SI: &'a mut SectionIterator<'a>);\n+    /// Returns true if the section iterator is at the end of the section\n+    /// list:\n+    pub fn LLVMIsSectionIteratorAtEnd(ObjFile: &'a ObjectFile, SI: &SectionIterator<'a>) -> Bool;\n+    /// Moves the section iterator to point to the next section.\n+    pub fn LLVMMoveToNextSection(SI: &SectionIterator);\n+    /// Returns the current section size.\n+    pub fn LLVMGetSectionSize(SI: &SectionIterator) -> c_ulonglong;\n+    /// Returns the current section contents as a string buffer.\n+    pub fn LLVMGetSectionContents(SI: &SectionIterator) -> *const c_char;\n+\n+    /// Reads the given file and returns it as a memory buffer. Use\n+    /// LLVMDisposeMemoryBuffer() to get rid of it.\n+    pub fn LLVMRustCreateMemoryBufferWithContentsOfFile(\n+        Path: *const c_char,\n+    ) -> Option<&'static mut MemoryBuffer>;\n+\n+    pub fn LLVMStartMultithreaded() -> Bool;\n+\n+    /// Returns a string describing the last error caused by an LLVMRust* call.\n+    pub fn LLVMRustGetLastError() -> *const c_char;\n+\n+    /// Print the pass timings since static dtors aren't picking them up.\n+    pub fn LLVMRustPrintPassTimings();\n+\n+    pub fn LLVMStructCreateNamed(C: &Context, Name: *const c_char) -> &Type;\n+\n+    pub fn LLVMStructSetBody(StructTy: &'a Type,\n+                             ElementTypes: *const &'a Type,\n+                             ElementCount: c_uint,\n+                             Packed: Bool);\n+\n+    /// Prepares inline assembly.\n+    pub fn LLVMRustInlineAsm(Ty: &Type,\n+                             AsmString: *const c_char,\n+                             Constraints: *const c_char,\n+                             SideEffects: Bool,\n+                             AlignStack: Bool,\n+                             Dialect: AsmDialect)\n+                             -> &Value;\n+\n+    pub fn LLVMRustDebugMetadataVersion() -> u32;\n+    pub fn LLVMRustVersionMajor() -> u32;\n+    pub fn LLVMRustVersionMinor() -> u32;\n+\n+    pub fn LLVMRustAddModuleFlag(M: &Module, name: *const c_char, value: u32);\n+\n+    pub fn LLVMRustMetadataAsValue(C: &'a Context, MD: &'a Metadata) -> &'a Value;\n+\n+    pub fn LLVMRustDIBuilderCreate(M: &'a Module) -> &'a mut DIBuilder<'a>;\n+\n+    pub fn LLVMRustDIBuilderDispose(Builder: &'a mut DIBuilder<'a>);\n+\n+    pub fn LLVMRustDIBuilderFinalize(Builder: &DIBuilder);\n+\n+    pub fn LLVMRustDIBuilderCreateCompileUnit(Builder: &DIBuilder<'a>,\n+                                              Lang: c_uint,\n+                                              File: &'a DIFile,\n+                                              Producer: *const c_char,\n+                                              isOptimized: bool,\n+                                              Flags: *const c_char,\n+                                              RuntimeVer: c_uint,\n+                                              SplitName: *const c_char)\n+                                              -> &'a DIDescriptor;\n+\n+    pub fn LLVMRustDIBuilderCreateFile(Builder: &DIBuilder<'a>,\n+                                       Filename: *const c_char,\n+                                       Directory: *const c_char)\n+                                       -> &'a DIFile;\n+\n+    pub fn LLVMRustDIBuilderCreateSubroutineType(Builder: &DIBuilder<'a>,\n+                                                 File: &'a DIFile,\n+                                                 ParameterTypes: &'a DIArray)\n+                                                 -> &'a DICompositeType;\n+\n+    pub fn LLVMRustDIBuilderCreateFunction(Builder: &DIBuilder<'a>,\n+                                           Scope: &'a DIDescriptor,\n+                                           Name: *const c_char,\n+                                           LinkageName: *const c_char,\n+                                           File: &'a DIFile,\n+                                           LineNo: c_uint,\n+                                           Ty: &'a DIType,\n+                                           isLocalToUnit: bool,\n+                                           isDefinition: bool,\n+                                           ScopeLine: c_uint,\n+                                           Flags: DIFlags,\n+                                           isOptimized: bool,\n+                                           Fn: &'a Value,\n+                                           TParam: &'a DIArray,\n+                                           Decl: Option<&'a DIDescriptor>)\n+                                           -> &'a DISubprogram;\n+\n+    pub fn LLVMRustDIBuilderCreateBasicType(Builder: &DIBuilder<'a>,\n+                                            Name: *const c_char,\n+                                            SizeInBits: u64,\n+                                            AlignInBits: u32,\n+                                            Encoding: c_uint)\n+                                            -> &'a DIBasicType;\n+\n+    pub fn LLVMRustDIBuilderCreatePointerType(Builder: &DIBuilder<'a>,\n+                                              PointeeTy: &'a DIType,\n+                                              SizeInBits: u64,\n+                                              AlignInBits: u32,\n+                                              Name: *const c_char)\n+                                              -> &'a DIDerivedType;\n+\n+    pub fn LLVMRustDIBuilderCreateStructType(Builder: &DIBuilder<'a>,\n+                                             Scope: Option<&'a DIDescriptor>,\n+                                             Name: *const c_char,\n+                                             File: &'a DIFile,\n+                                             LineNumber: c_uint,\n+                                             SizeInBits: u64,\n+                                             AlignInBits: u32,\n+                                             Flags: DIFlags,\n+                                             DerivedFrom: Option<&'a DIType>,\n+                                             Elements: &'a DIArray,\n+                                             RunTimeLang: c_uint,\n+                                             VTableHolder: Option<&'a DIType>,\n+                                             UniqueId: *const c_char)\n+                                             -> &'a DICompositeType;\n+\n+    pub fn LLVMRustDIBuilderCreateMemberType(Builder: &DIBuilder<'a>,\n+                                             Scope: &'a DIDescriptor,\n+                                             Name: *const c_char,\n+                                             File: &'a DIFile,\n+                                             LineNo: c_uint,\n+                                             SizeInBits: u64,\n+                                             AlignInBits: u32,\n+                                             OffsetInBits: u64,\n+                                             Flags: DIFlags,\n+                                             Ty: &'a DIType)\n+                                             -> &'a DIDerivedType;\n+\n+    pub fn LLVMRustDIBuilderCreateLexicalBlock(Builder: &DIBuilder<'a>,\n+                                               Scope: &'a DIScope,\n+                                               File: &'a DIFile,\n+                                               Line: c_uint,\n+                                               Col: c_uint)\n+                                               -> &'a DILexicalBlock;\n+\n+    pub fn LLVMRustDIBuilderCreateLexicalBlockFile(Builder: &DIBuilder<'a>,\n+                                                   Scope: &'a DIScope,\n+                                                   File: &'a DIFile)\n+                                                   -> &'a DILexicalBlock;\n+\n+    pub fn LLVMRustDIBuilderCreateStaticVariable(Builder: &DIBuilder<'a>,\n+                                                 Context: Option<&'a DIScope>,\n+                                                 Name: *const c_char,\n+                                                 LinkageName: *const c_char,\n+                                                 File: &'a DIFile,\n+                                                 LineNo: c_uint,\n+                                                 Ty: &'a DIType,\n+                                                 isLocalToUnit: bool,\n+                                                 Val: &'a Value,\n+                                                 Decl: Option<&'a DIDescriptor>,\n+                                                 AlignInBits: u32)\n+                                                 -> &'a DIGlobalVariable;\n+\n+    pub fn LLVMRustDIBuilderCreateVariable(Builder: &DIBuilder<'a>,\n+                                           Tag: c_uint,\n+                                           Scope: &'a DIDescriptor,\n+                                           Name: *const c_char,\n+                                           File: &'a DIFile,\n+                                           LineNo: c_uint,\n+                                           Ty: &'a DIType,\n+                                           AlwaysPreserve: bool,\n+                                           Flags: DIFlags,\n+                                           ArgNo: c_uint,\n+                                           AlignInBits: u32)\n+                                           -> &'a DIVariable;\n+\n+    pub fn LLVMRustDIBuilderCreateArrayType(Builder: &DIBuilder<'a>,\n+                                            Size: u64,\n+                                            AlignInBits: u32,\n+                                            Ty: &'a DIType,\n+                                            Subscripts: &'a DIArray)\n+                                            -> &'a DIType;\n+\n+    pub fn LLVMRustDIBuilderGetOrCreateSubrange(Builder: &DIBuilder<'a>,\n+                                                Lo: i64,\n+                                                Count: i64)\n+                                                -> &'a DISubrange;\n+\n+    pub fn LLVMRustDIBuilderGetOrCreateArray(Builder: &DIBuilder<'a>,\n+                                             Ptr: *const Option<&'a DIDescriptor>,\n+                                             Count: c_uint)\n+                                             -> &'a DIArray;\n+\n+    pub fn LLVMRustDIBuilderInsertDeclareAtEnd(Builder: &DIBuilder<'a>,\n+                                               Val: &'a Value,\n+                                               VarInfo: &'a DIVariable,\n+                                               AddrOps: *const i64,\n+                                               AddrOpsCount: c_uint,\n+                                               DL: &'a Value,\n+                                               InsertAtEnd: &'a BasicBlock)\n+                                               -> &'a Value;\n+\n+    pub fn LLVMRustDIBuilderCreateEnumerator(Builder: &DIBuilder<'a>,\n+                                             Name: *const c_char,\n+                                             Val: u64)\n+                                             -> &'a DIEnumerator;\n+\n+    pub fn LLVMRustDIBuilderCreateEnumerationType(Builder: &DIBuilder<'a>,\n+                                                  Scope: &'a DIScope,\n+                                                  Name: *const c_char,\n+                                                  File: &'a DIFile,\n+                                                  LineNumber: c_uint,\n+                                                  SizeInBits: u64,\n+                                                  AlignInBits: u32,\n+                                                  Elements: &'a DIArray,\n+                                                  ClassType: &'a DIType)\n+                                                  -> &'a DIType;\n+\n+    pub fn LLVMRustDIBuilderCreateUnionType(Builder: &DIBuilder<'a>,\n+                                            Scope: &'a DIScope,\n+                                            Name: *const c_char,\n+                                            File: &'a DIFile,\n+                                            LineNumber: c_uint,\n+                                            SizeInBits: u64,\n+                                            AlignInBits: u32,\n+                                            Flags: DIFlags,\n+                                            Elements: Option<&'a DIArray>,\n+                                            RunTimeLang: c_uint,\n+                                            UniqueId: *const c_char)\n+                                            -> &'a DIType;\n+\n+    pub fn LLVMSetUnnamedAddr(GlobalVar: &Value, UnnamedAddr: Bool);\n+\n+    pub fn LLVMRustDIBuilderCreateTemplateTypeParameter(Builder: &DIBuilder<'a>,\n+                                                        Scope: Option<&'a DIScope>,\n+                                                        Name: *const c_char,\n+                                                        Ty: &'a DIType,\n+                                                        File: &'a DIFile,\n+                                                        LineNo: c_uint,\n+                                                        ColumnNo: c_uint)\n+                                                        -> &'a DITemplateTypeParameter;\n+\n+\n+    pub fn LLVMRustDIBuilderCreateNameSpace(Builder: &DIBuilder<'a>,\n+                                            Scope: Option<&'a DIScope>,\n+                                            Name: *const c_char,\n+                                            File: &'a DIFile,\n+                                            LineNo: c_uint)\n+                                            -> &'a DINameSpace;\n+\n+    pub fn LLVMRustDICompositeTypeSetTypeArray(Builder: &DIBuilder<'a>,\n+                                               CompositeType: &'a DIType,\n+                                               TypeArray: &'a DIArray);\n+\n+\n+    pub fn LLVMRustDIBuilderCreateDebugLocation(Context: &'a Context,\n+                                                Line: c_uint,\n+                                                Column: c_uint,\n+                                                Scope: &'a DIScope,\n+                                                InlinedAt: Option<&'a Metadata>)\n+                                                -> &'a Value;\n+    pub fn LLVMRustDIBuilderCreateOpDeref() -> i64;\n+    pub fn LLVMRustDIBuilderCreateOpPlusUconst() -> i64;\n+}\n+\n+#[allow(improper_ctypes)] // FIXME(#52456) needed for RustString.\n+extern \"C\" {\n+    pub fn LLVMRustWriteTypeToString(Type: &Type, s: &RustString);\n+    pub fn LLVMRustWriteValueToString(value_ref: &Value, s: &RustString);\n+}\n+\n+extern \"C\" {\n+    pub fn LLVMIsAConstantInt(value_ref: &Value) -> Option<&Value>;\n+    pub fn LLVMIsAConstantFP(value_ref: &Value) -> Option<&Value>;\n+\n+    pub fn LLVMRustPassKind(Pass: &Pass) -> PassKind;\n+    pub fn LLVMRustFindAndCreatePass(Pass: *const c_char) -> Option<&'static mut Pass>;\n+    pub fn LLVMRustAddPass(PM: &PassManager, Pass: &'static mut Pass);\n+\n+    pub fn LLVMRustHasFeature(T: &TargetMachine, s: *const c_char) -> bool;\n+\n+    pub fn LLVMRustPrintTargetCPUs(T: &TargetMachine);\n+    pub fn LLVMRustPrintTargetFeatures(T: &TargetMachine);\n+\n+    pub fn LLVMRustCreateTargetMachine(Triple: *const c_char,\n+                                       CPU: *const c_char,\n+                                       Features: *const c_char,\n+                                       Model: CodeModel,\n+                                       Reloc: RelocMode,\n+                                       Level: CodeGenOptLevel,\n+                                       UseSoftFP: bool,\n+                                       PositionIndependentExecutable: bool,\n+                                       FunctionSections: bool,\n+                                       DataSections: bool,\n+                                       TrapUnreachable: bool,\n+                                       Singlethread: bool)\n+                                       -> Option<&'static mut TargetMachine>;\n+    pub fn LLVMRustDisposeTargetMachine(T: &'static mut TargetMachine);\n+    pub fn LLVMRustAddAnalysisPasses(T: &'a TargetMachine, PM: &PassManager<'a>, M: &'a Module);\n+    pub fn LLVMRustAddBuilderLibraryInfo(PMB: &'a PassManagerBuilder,\n+                                         M: &'a Module,\n+                                         DisableSimplifyLibCalls: bool);\n+    pub fn LLVMRustConfigurePassManagerBuilder(PMB: &PassManagerBuilder,\n+                                               OptLevel: CodeGenOptLevel,\n+                                               MergeFunctions: bool,\n+                                               SLPVectorize: bool,\n+                                               LoopVectorize: bool,\n+                                               PrepareForThinLTO: bool,\n+                                               PGOGenPath: *const c_char,\n+                                               PGOUsePath: *const c_char);\n+    pub fn LLVMRustAddLibraryInfo(PM: &PassManager<'a>,\n+                                  M: &'a Module,\n+                                  DisableSimplifyLibCalls: bool);\n+    pub fn LLVMRustRunFunctionPassManager(PM: &PassManager<'a>, M: &'a Module);\n+    pub fn LLVMRustWriteOutputFile(T: &'a TargetMachine,\n+                                   PM: &PassManager<'a>,\n+                                   M: &'a Module,\n+                                   Output: *const c_char,\n+                                   FileType: FileType)\n+                                   -> LLVMRustResult;\n+    pub fn LLVMRustPrintModule(PM: &PassManager<'a>,\n+                               M: &'a Module,\n+                               Output: *const c_char,\n+                               Demangle: extern fn(*const c_char,\n+                                                   size_t,\n+                                                   *mut c_char,\n+                                                   size_t) -> size_t);\n+    pub fn LLVMRustSetLLVMOptions(Argc: c_int, Argv: *const *const c_char);\n+    pub fn LLVMRustPrintPasses();\n+    pub fn LLVMRustSetNormalizedTarget(M: &Module, triple: *const c_char);\n+    pub fn LLVMRustAddAlwaysInlinePass(P: &PassManagerBuilder, AddLifetimes: bool);\n+    pub fn LLVMRustRunRestrictionPass(M: &Module, syms: *const *const c_char, len: size_t);\n+    pub fn LLVMRustMarkAllFunctionsNounwind(M: &Module);\n+\n+    pub fn LLVMRustOpenArchive(path: *const c_char) -> Option<&'static mut Archive>;\n+    pub fn LLVMRustArchiveIteratorNew(AR: &'a Archive) -> &'a mut ArchiveIterator<'a>;\n+    pub fn LLVMRustArchiveIteratorNext(\n+        AIR: &ArchiveIterator<'a>,\n+    ) -> Option<&'a mut ArchiveChild<'a>>;\n+    pub fn LLVMRustArchiveChildName(ACR: &ArchiveChild, size: &mut size_t) -> *const c_char;\n+    pub fn LLVMRustArchiveChildData(ACR: &ArchiveChild, size: &mut size_t) -> *const c_char;\n+    pub fn LLVMRustArchiveChildFree(ACR: &'a mut ArchiveChild<'a>);\n+    pub fn LLVMRustArchiveIteratorFree(AIR: &'a mut ArchiveIterator<'a>);\n+    pub fn LLVMRustDestroyArchive(AR: &'static mut Archive);\n+\n+    pub fn LLVMRustGetSectionName(SI: &SectionIterator, data: &mut *const c_char) -> size_t;\n+}\n+\n+#[allow(improper_ctypes)] // FIXME(#52456) needed for RustString.\n+extern \"C\" {\n+    pub fn LLVMRustWriteTwineToString(T: &Twine, s: &RustString);\n+}\n+\n+extern \"C\" {\n+    pub fn LLVMContextSetDiagnosticHandler(C: &Context,\n+                                           Handler: DiagnosticHandler,\n+                                           DiagnosticContext: *mut c_void);\n+}\n+\n+#[allow(improper_ctypes)] // FIXME(#52456) needed for RustString.\n+extern \"C\" {\n+    pub fn LLVMRustUnpackOptimizationDiagnostic(DI: &'a DiagnosticInfo,\n+                                                pass_name_out: &RustString,\n+                                                function_out: &mut Option<&'a Value>,\n+                                                loc_line_out: &mut c_uint,\n+                                                loc_column_out: &mut c_uint,\n+                                                loc_filename_out: &RustString,\n+                                                message_out: &RustString);\n+}\n+\n+extern \"C\" {\n+    pub fn LLVMRustUnpackInlineAsmDiagnostic(DI: &'a DiagnosticInfo,\n+                                             cookie_out: &mut c_uint,\n+                                             message_out: &mut Option<&'a Twine>,\n+                                             instruction_out: &mut Option<&'a Value>);\n+}\n+\n+#[allow(improper_ctypes)] // FIXME(#52456) needed for RustString.\n+extern \"C\" {\n+    pub fn LLVMRustWriteDiagnosticInfoToString(DI: &DiagnosticInfo, s: &RustString);\n+}\n+\n+extern \"C\" {\n+    pub fn LLVMRustGetDiagInfoKind(DI: &DiagnosticInfo) -> DiagnosticKind;\n+\n+    pub fn LLVMRustSetInlineAsmDiagnosticHandler(C: &Context,\n+                                                 H: InlineAsmDiagHandler,\n+                                                 CX: *mut c_void);\n+}\n+\n+#[allow(improper_ctypes)] // FIXME(#52456) needed for RustString.\n+extern \"C\" {\n+    pub fn LLVMRustWriteSMDiagnosticToString(d: &SMDiagnostic, s: &RustString);\n+}\n+\n+extern \"C\" {\n+    pub fn LLVMRustWriteArchive(Dst: *const c_char,\n+                                NumMembers: size_t,\n+                                Members: *const &RustArchiveMember,\n+                                WriteSymbtab: bool,\n+                                Kind: ArchiveKind)\n+                                -> LLVMRustResult;\n+    pub fn LLVMRustArchiveMemberNew(Filename: *const c_char,\n+                                    Name: *const c_char,\n+                                    Child: Option<&'a ArchiveChild>)\n+                                    -> &'a mut RustArchiveMember<'a>;\n+    pub fn LLVMRustArchiveMemberFree(Member: &'a mut RustArchiveMember<'a>);\n+\n+    pub fn LLVMRustSetDataLayoutFromTargetMachine(M: &'a Module, TM: &'a TargetMachine);\n+\n+    pub fn LLVMRustBuildOperandBundleDef(Name: *const c_char,\n+                                         Inputs: *const &'a Value,\n+                                         NumInputs: c_uint)\n+                                         -> &'a mut OperandBundleDef<'a>;\n+    pub fn LLVMRustFreeOperandBundleDef(Bundle: &'a mut OperandBundleDef<'a>);\n+\n+    pub fn LLVMRustPositionBuilderAtStart(B: &Builder<'a>, BB: &'a BasicBlock);\n+\n+    pub fn LLVMRustSetComdat(M: &'a Module, V: &'a Value, Name: *const c_char);\n+    pub fn LLVMRustUnsetComdat(V: &Value);\n+    pub fn LLVMRustSetModulePIELevel(M: &Module);\n+    pub fn LLVMRustModuleBufferCreate(M: &Module) -> &'static mut ModuleBuffer;\n+    pub fn LLVMRustModuleBufferPtr(p: &ModuleBuffer) -> *const u8;\n+    pub fn LLVMRustModuleBufferLen(p: &ModuleBuffer) -> usize;\n+    pub fn LLVMRustModuleBufferFree(p: &'static mut ModuleBuffer);\n+    pub fn LLVMRustModuleCost(M: &Module) -> u64;\n+\n+    pub fn LLVMRustThinLTOAvailable() -> bool;\n+    pub fn LLVMRustPGOAvailable() -> bool;\n+    pub fn LLVMRustThinLTOBufferCreate(M: &Module) -> &'static mut ThinLTOBuffer;\n+    pub fn LLVMRustThinLTOBufferFree(M: &'static mut ThinLTOBuffer);\n+    pub fn LLVMRustThinLTOBufferPtr(M: &ThinLTOBuffer) -> *const c_char;\n+    pub fn LLVMRustThinLTOBufferLen(M: &ThinLTOBuffer) -> size_t;\n+    pub fn LLVMRustCreateThinLTOData(\n+        Modules: *const ThinLTOModule,\n+        NumModules: c_uint,\n+        PreservedSymbols: *const *const c_char,\n+        PreservedSymbolsLen: c_uint,\n+    ) -> Option<&'static mut ThinLTOData>;\n+    pub fn LLVMRustPrepareThinLTORename(\n+        Data: &ThinLTOData,\n+        Module: &Module,\n+    ) -> bool;\n+    pub fn LLVMRustPrepareThinLTOResolveWeak(\n+        Data: &ThinLTOData,\n+        Module: &Module,\n+    ) -> bool;\n+    pub fn LLVMRustPrepareThinLTOInternalize(\n+        Data: &ThinLTOData,\n+        Module: &Module,\n+    ) -> bool;\n+    pub fn LLVMRustPrepareThinLTOImport(\n+        Data: &ThinLTOData,\n+        Module: &Module,\n+    ) -> bool;\n+    pub fn LLVMRustFreeThinLTOData(Data: &'static mut ThinLTOData);\n+    pub fn LLVMRustParseBitcodeForThinLTO(\n+        Context: &Context,\n+        Data: *const u8,\n+        len: usize,\n+        Identifier: *const c_char,\n+    ) -> Option<&Module>;\n+    pub fn LLVMRustThinLTOGetDICompileUnit(M: &Module,\n+                                           CU1: &mut *mut c_void,\n+                                           CU2: &mut *mut c_void);\n+    pub fn LLVMRustThinLTOPatchDICompileUnit(M: &Module, CU: *mut c_void);\n+\n+    pub fn LLVMRustLinkerNew(M: &'a Module) -> &'a mut Linker<'a>;\n+    pub fn LLVMRustLinkerAdd(linker: &Linker,\n+                             bytecode: *const c_char,\n+                             bytecode_len: usize) -> bool;\n+    pub fn LLVMRustLinkerFree(linker: &'a mut Linker<'a>);\n+}"}, {"sha": "558d2a2bc87b363f634ccca1b2744f5709d42d4f", "filename": "src/librustc_codegen_llvm/llvm/mod.rs", "status": "added", "additions": 281, "deletions": 0, "changes": 281, "blob_url": "https://github.com/rust-lang/rust/blob/f89817997ac0aa100bf91997194ad85a7e59f743/src%2Flibrustc_codegen_llvm%2Fllvm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f89817997ac0aa100bf91997194ad85a7e59f743/src%2Flibrustc_codegen_llvm%2Fllvm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fllvm%2Fmod.rs?ref=f89817997ac0aa100bf91997194ad85a7e59f743", "patch": "@@ -0,0 +1,281 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(non_upper_case_globals)]\n+#![allow(non_camel_case_types)]\n+#![allow(non_snake_case)]\n+#![deny(bare_trait_objects)]\n+\n+pub use self::IntPredicate::*;\n+pub use self::RealPredicate::*;\n+pub use self::AtomicRmwBinOp::*;\n+pub use self::MetadataType::*;\n+pub use self::CodeGenOptSize::*;\n+pub use self::CallConv::*;\n+pub use self::Linkage::*;\n+\n+use std::str::FromStr;\n+use std::string::FromUtf8Error;\n+use std::slice;\n+use std::ffi::{CString, CStr};\n+use std::cell::RefCell;\n+use libc::{self, c_uint, c_char, size_t};\n+\n+pub mod archive_ro;\n+pub mod diagnostic;\n+mod ffi;\n+\n+pub use self::ffi::*;\n+\n+impl LLVMRustResult {\n+    pub fn into_result(self) -> Result<(), ()> {\n+        match self {\n+            LLVMRustResult::Success => Ok(()),\n+            LLVMRustResult::Failure => Err(()),\n+        }\n+    }\n+}\n+\n+pub fn AddFunctionAttrStringValue(llfn: &'a Value,\n+                                  idx: AttributePlace,\n+                                  attr: &CStr,\n+                                  value: &CStr) {\n+    unsafe {\n+        LLVMRustAddFunctionAttrStringValue(llfn,\n+                                           idx.as_uint(),\n+                                           attr.as_ptr(),\n+                                           value.as_ptr())\n+    }\n+}\n+\n+#[derive(Copy, Clone)]\n+pub enum AttributePlace {\n+    ReturnValue,\n+    Argument(u32),\n+    Function,\n+}\n+\n+impl AttributePlace {\n+    pub fn as_uint(self) -> c_uint {\n+        match self {\n+            AttributePlace::ReturnValue => 0,\n+            AttributePlace::Argument(i) => 1 + i,\n+            AttributePlace::Function => !0,\n+        }\n+    }\n+}\n+\n+#[derive(Copy, Clone, PartialEq)]\n+#[repr(C)]\n+pub enum CodeGenOptSize {\n+    CodeGenOptSizeNone = 0,\n+    CodeGenOptSizeDefault = 1,\n+    CodeGenOptSizeAggressive = 2,\n+}\n+\n+impl FromStr for ArchiveKind {\n+    type Err = ();\n+\n+    fn from_str(s: &str) -> Result<Self, Self::Err> {\n+        match s {\n+            \"gnu\" => Ok(ArchiveKind::K_GNU),\n+            \"bsd\" => Ok(ArchiveKind::K_BSD),\n+            \"coff\" => Ok(ArchiveKind::K_COFF),\n+            _ => Err(()),\n+        }\n+    }\n+}\n+\n+#[repr(C)]\n+pub struct RustString {\n+    bytes: RefCell<Vec<u8>>,\n+}\n+\n+/// Appending to a Rust string -- used by RawRustStringOstream.\n+#[no_mangle]\n+pub unsafe extern \"C\" fn LLVMRustStringWriteImpl(sr: &RustString,\n+                                                 ptr: *const c_char,\n+                                                 size: size_t) {\n+    let slice = slice::from_raw_parts(ptr as *const u8, size as usize);\n+\n+    sr.bytes.borrow_mut().extend_from_slice(slice);\n+}\n+\n+pub fn SetInstructionCallConv(instr: &'a Value, cc: CallConv) {\n+    unsafe {\n+        LLVMSetInstructionCallConv(instr, cc as c_uint);\n+    }\n+}\n+pub fn SetFunctionCallConv(fn_: &'a Value, cc: CallConv) {\n+    unsafe {\n+        LLVMSetFunctionCallConv(fn_, cc as c_uint);\n+    }\n+}\n+\n+// Externally visible symbols that might appear in multiple codegen units need to appear in\n+// their own comdat section so that the duplicates can be discarded at link time. This can for\n+// example happen for generics when using multiple codegen units. This function simply uses the\n+// value's name as the comdat value to make sure that it is in a 1-to-1 relationship to the\n+// function.\n+// For more details on COMDAT sections see e.g. http://www.airs.com/blog/archives/52\n+pub fn SetUniqueComdat(llmod: &Module, val: &'a Value) {\n+    unsafe {\n+        LLVMRustSetComdat(llmod, val, LLVMGetValueName(val));\n+    }\n+}\n+\n+pub fn UnsetComdat(val: &'a Value) {\n+    unsafe {\n+        LLVMRustUnsetComdat(val);\n+    }\n+}\n+\n+pub fn SetUnnamedAddr(global: &'a Value, unnamed: bool) {\n+    unsafe {\n+        LLVMSetUnnamedAddr(global, unnamed as Bool);\n+    }\n+}\n+\n+pub fn set_thread_local(global: &'a Value, is_thread_local: bool) {\n+    unsafe {\n+        LLVMSetThreadLocal(global, is_thread_local as Bool);\n+    }\n+}\n+pub fn set_thread_local_mode(global: &'a Value, mode: ThreadLocalMode) {\n+    unsafe {\n+        LLVMSetThreadLocalMode(global, mode);\n+    }\n+}\n+\n+impl Attribute {\n+    pub fn apply_llfn(&self, idx: AttributePlace, llfn: &Value) {\n+        unsafe { LLVMRustAddFunctionAttribute(llfn, idx.as_uint(), *self) }\n+    }\n+\n+    pub fn apply_callsite(&self, idx: AttributePlace, callsite: &Value) {\n+        unsafe { LLVMRustAddCallSiteAttribute(callsite, idx.as_uint(), *self) }\n+    }\n+\n+    pub fn unapply_llfn(&self, idx: AttributePlace, llfn: &Value) {\n+        unsafe { LLVMRustRemoveFunctionAttributes(llfn, idx.as_uint(), *self) }\n+    }\n+\n+    pub fn toggle_llfn(&self, idx: AttributePlace, llfn: &Value, set: bool) {\n+        if set {\n+            self.apply_llfn(idx, llfn);\n+        } else {\n+            self.unapply_llfn(idx, llfn);\n+        }\n+    }\n+}\n+\n+// Memory-managed interface to object files.\n+\n+pub struct ObjectFile {\n+    pub llof: &'static mut ffi::ObjectFile,\n+}\n+\n+unsafe impl Send for ObjectFile {}\n+\n+impl ObjectFile {\n+    // This will take ownership of llmb\n+    pub fn new(llmb: &'static mut MemoryBuffer) -> Option<ObjectFile> {\n+        unsafe {\n+            let llof = LLVMCreateObjectFile(llmb)?;\n+            Some(ObjectFile { llof: llof })\n+        }\n+    }\n+}\n+\n+impl Drop for ObjectFile {\n+    fn drop(&mut self) {\n+        unsafe {\n+            LLVMDisposeObjectFile(&mut *(self.llof as *mut _));\n+        }\n+    }\n+}\n+\n+// Memory-managed interface to section iterators.\n+\n+pub struct SectionIter<'a> {\n+    pub llsi: &'a mut SectionIterator<'a>,\n+}\n+\n+impl Drop for SectionIter<'a> {\n+    fn drop(&mut self) {\n+        unsafe {\n+            LLVMDisposeSectionIterator(&mut *(self.llsi as *mut _));\n+        }\n+    }\n+}\n+\n+pub fn mk_section_iter(llof: &'a ffi::ObjectFile) -> SectionIter<'a> {\n+    unsafe { SectionIter { llsi: LLVMGetSections(llof) } }\n+}\n+\n+/// Safe wrapper around `LLVMGetParam`, because segfaults are no fun.\n+pub fn get_param(llfn: &'a Value, index: c_uint) -> &'a Value {\n+    unsafe {\n+        assert!(index < LLVMCountParams(llfn),\n+            \"out of bounds argument access: {} out of {} arguments\", index, LLVMCountParams(llfn));\n+        LLVMGetParam(llfn, index)\n+    }\n+}\n+\n+pub fn build_string(f: impl FnOnce(&RustString)) -> Result<String, FromUtf8Error> {\n+    let sr = RustString {\n+        bytes: RefCell::new(Vec::new()),\n+    };\n+    f(&sr);\n+    String::from_utf8(sr.bytes.into_inner())\n+}\n+\n+pub fn twine_to_string(tr: &Twine) -> String {\n+    unsafe {\n+        build_string(|s| LLVMRustWriteTwineToString(tr, s))\n+            .expect(\"got a non-UTF8 Twine from LLVM\")\n+    }\n+}\n+\n+pub fn last_error() -> Option<String> {\n+    unsafe {\n+        let cstr = LLVMRustGetLastError();\n+        if cstr.is_null() {\n+            None\n+        } else {\n+            let err = CStr::from_ptr(cstr).to_bytes();\n+            let err = String::from_utf8_lossy(err).to_string();\n+            libc::free(cstr as *mut _);\n+            Some(err)\n+        }\n+    }\n+}\n+\n+pub struct OperandBundleDef<'a> {\n+    pub raw: &'a mut ffi::OperandBundleDef<'a>,\n+}\n+\n+impl OperandBundleDef<'a> {\n+    pub fn new(name: &str, vals: &[&'a Value]) -> Self {\n+        let name = CString::new(name).unwrap();\n+        let def = unsafe {\n+            LLVMRustBuildOperandBundleDef(name.as_ptr(), vals.as_ptr(), vals.len() as c_uint)\n+        };\n+        OperandBundleDef { raw: def }\n+    }\n+}\n+\n+impl Drop for OperandBundleDef<'a> {\n+    fn drop(&mut self) {\n+        unsafe {\n+            LLVMRustFreeOperandBundleDef(&mut *(self.raw as *mut _));\n+        }\n+    }\n+}"}, {"sha": "441fff5f08c8fddb258923616b2726fda2b00f5e", "filename": "src/librustc_codegen_llvm/llvm_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f89817997ac0aa100bf91997194ad85a7e59f743/src%2Flibrustc_codegen_llvm%2Fllvm_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f89817997ac0aa100bf91997194ad85a7e59f743/src%2Flibrustc_codegen_llvm%2Fllvm_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fllvm_util.rs?ref=f89817997ac0aa100bf91997194ad85a7e59f743", "patch": "@@ -73,7 +73,7 @@ unsafe fn configure_llvm(sess: &Session) {\n \n     llvm::LLVMInitializePasses();\n \n-    llvm::initialize_available_targets();\n+    ::rustc_llvm::initialize_available_targets();\n \n     llvm::LLVMRustSetLLVMOptions(llvm_args.len() as c_int,\n                                  llvm_args.as_ptr());"}, {"sha": "fcb704413ef116c1944e486083f4a995dcbffaba", "filename": "src/librustc_codegen_llvm/metadata.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f89817997ac0aa100bf91997194ad85a7e59f743/src%2Flibrustc_codegen_llvm%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f89817997ac0aa100bf91997194ad85a7e59f743/src%2Flibrustc_codegen_llvm%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmetadata.rs?ref=f89817997ac0aa100bf91997194ad85a7e59f743", "patch": "@@ -58,10 +58,8 @@ impl MetadataLoader for LlvmMetadataLoader {\n                           -> Result<MetadataRef, String> {\n         unsafe {\n             let buf = common::path2cstr(filename);\n-            let mb = llvm::LLVMRustCreateMemoryBufferWithContentsOfFile(buf.as_ptr());\n-            if mb as isize == 0 {\n-                return Err(format!(\"error reading library: '{}'\", filename.display()));\n-            }\n+            let mb = llvm::LLVMRustCreateMemoryBufferWithContentsOfFile(buf.as_ptr())\n+                .ok_or_else(|| format!(\"error reading library: '{}'\", filename.display()))?;\n             let of = ObjectFile::new(mb)\n                 .map(|of| OwningRef::new(box of))\n                 .ok_or_else(|| format!(\"provided path not an object file: '{}'\","}, {"sha": "9c0dd0dc3d8b54f54e5409c381c7cdeb3d68467e", "filename": "src/librustc_codegen_llvm/meth.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f89817997ac0aa100bf91997194ad85a7e59f743/src%2Flibrustc_codegen_llvm%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f89817997ac0aa100bf91997194ad85a7e59f743/src%2Flibrustc_codegen_llvm%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmeth.rs?ref=f89817997ac0aa100bf91997194ad85a7e59f743", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use llvm::ValueRef;\n use abi::{FnType, FnTypeExt};\n use callee;\n use common::*;\n@@ -17,6 +16,7 @@ use consts;\n use monomorphize;\n use type_::Type;\n use value::Value;\n+\n use rustc::ty::{self, Ty};\n use rustc::ty::layout::HasDataLayout;\n use debuginfo;\n@@ -33,11 +33,11 @@ impl<'a, 'tcx> VirtualIndex {\n         VirtualIndex(index as u64 + 3)\n     }\n \n-    pub fn get_fn(self, bx: &Builder<'a, 'tcx>,\n-                  llvtable: ValueRef,\n-                  fn_ty: &FnType<'tcx, Ty<'tcx>>) -> ValueRef {\n+    pub fn get_fn(self, bx: &Builder<'a, 'll, 'tcx>,\n+                  llvtable: &'ll Value,\n+                  fn_ty: &FnType<'tcx, Ty<'tcx>>) -> &'ll Value {\n         // Load the data pointer from the object.\n-        debug!(\"get_fn({:?}, {:?})\", Value(llvtable), self);\n+        debug!(\"get_fn({:?}, {:?})\", llvtable, self);\n \n         let llvtable = bx.pointercast(llvtable, fn_ty.llvm_type(bx.cx).ptr_to().ptr_to());\n         let ptr_align = bx.tcx().data_layout.pointer_align;\n@@ -48,9 +48,9 @@ impl<'a, 'tcx> VirtualIndex {\n         ptr\n     }\n \n-    pub fn get_usize(self, bx: &Builder<'a, 'tcx>, llvtable: ValueRef) -> ValueRef {\n+    pub fn get_usize(self, bx: &Builder<'a, 'll, 'tcx>, llvtable: &'ll Value) -> &'ll Value {\n         // Load the data pointer from the object.\n-        debug!(\"get_int({:?}, {:?})\", Value(llvtable), self);\n+        debug!(\"get_int({:?}, {:?})\", llvtable, self);\n \n         let llvtable = bx.pointercast(llvtable, Type::isize(bx.cx).ptr_to());\n         let usize_align = bx.tcx().data_layout.pointer_align;\n@@ -69,11 +69,11 @@ impl<'a, 'tcx> VirtualIndex {\n /// The `trait_ref` encodes the erased self type. Hence if we are\n /// making an object `Foo<Trait>` from a value of type `Foo<T>`, then\n /// `trait_ref` would map `T:Trait`.\n-pub fn get_vtable<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n-                            ty: Ty<'tcx>,\n-                            trait_ref: Option<ty::PolyExistentialTraitRef<'tcx>>)\n-                            -> ValueRef\n-{\n+pub fn get_vtable(\n+    cx: &CodegenCx<'ll, 'tcx>,\n+    ty: Ty<'tcx>,\n+    trait_ref: Option<ty::PolyExistentialTraitRef<'tcx>>,\n+) -> &'ll Value {\n     let tcx = cx.tcx;\n \n     debug!(\"get_vtable(ty={:?}, trait_ref={:?})\", ty, trait_ref);"}, {"sha": "2c2058035241f5207b6ade9a111ec33005195e9b", "filename": "src/librustc_codegen_llvm/mir/analyze.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f89817997ac0aa100bf91997194ad85a7e59f743/src%2Flibrustc_codegen_llvm%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f89817997ac0aa100bf91997194ad85a7e59f743/src%2Flibrustc_codegen_llvm%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fanalyze.rs?ref=f89817997ac0aa100bf91997194ad85a7e59f743", "patch": "@@ -22,7 +22,7 @@ use rustc::ty::layout::LayoutOf;\n use type_of::LayoutLlvmExt;\n use super::FunctionCx;\n \n-pub fn non_ssa_locals<'a, 'tcx>(fx: &FunctionCx<'a, 'tcx>) -> BitVector<mir::Local> {\n+pub fn non_ssa_locals(fx: &FunctionCx<'a, 'll, 'tcx>) -> BitVector<mir::Local> {\n     let mir = fx.mir;\n     let mut analyzer = LocalAnalyzer::new(fx);\n \n@@ -34,7 +34,7 @@ pub fn non_ssa_locals<'a, 'tcx>(fx: &FunctionCx<'a, 'tcx>) -> BitVector<mir::Loc\n         let layout = fx.cx.layout_of(ty);\n         if layout.is_llvm_immediate() {\n             // These sorts of types are immediates that we can store\n-            // in an ValueRef without an alloca.\n+            // in an Value without an alloca.\n         } else if layout.is_llvm_scalar_pair() {\n             // We allow pairs and uses of any of their 2 fields.\n         } else {\n@@ -51,17 +51,17 @@ pub fn non_ssa_locals<'a, 'tcx>(fx: &FunctionCx<'a, 'tcx>) -> BitVector<mir::Loc\n     analyzer.non_ssa_locals\n }\n \n-struct LocalAnalyzer<'mir, 'a: 'mir, 'tcx: 'a> {\n-    fx: &'mir FunctionCx<'a, 'tcx>,\n+struct LocalAnalyzer<'mir, 'a: 'mir, 'll: 'a, 'tcx: 'll> {\n+    fx: &'mir FunctionCx<'a, 'll, 'tcx>,\n     dominators: Dominators<mir::BasicBlock>,\n     non_ssa_locals: BitVector<mir::Local>,\n     // The location of the first visited direct assignment to each\n     // local, or an invalid location (out of bounds `block` index).\n     first_assignment: IndexVec<mir::Local, Location>\n }\n \n-impl<'mir, 'a, 'tcx> LocalAnalyzer<'mir, 'a, 'tcx> {\n-    fn new(fx: &'mir FunctionCx<'a, 'tcx>) -> LocalAnalyzer<'mir, 'a, 'tcx> {\n+impl LocalAnalyzer<'mir, 'a, 'll, 'tcx> {\n+    fn new(fx: &'mir FunctionCx<'a, 'll, 'tcx>) -> Self {\n         let invalid_location =\n             mir::BasicBlock::new(fx.mir.basic_blocks().len()).start_location();\n         let mut analyzer = LocalAnalyzer {\n@@ -102,7 +102,7 @@ impl<'mir, 'a, 'tcx> LocalAnalyzer<'mir, 'a, 'tcx> {\n     }\n }\n \n-impl<'mir, 'a, 'tcx> Visitor<'tcx> for LocalAnalyzer<'mir, 'a, 'tcx> {\n+impl Visitor<'tcx> for LocalAnalyzer<'mir, 'a, 'll, 'tcx> {\n     fn visit_assign(&mut self,\n                     block: mir::BasicBlock,\n                     place: &mir::Place<'tcx>,"}, {"sha": "684ecfaeec8f159d858f736e22b2d45b6a6699cd", "filename": "src/librustc_codegen_llvm/mir/block.rs", "status": "modified", "additions": 43, "deletions": 35, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/f89817997ac0aa100bf91997194ad85a7e59f743/src%2Flibrustc_codegen_llvm%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f89817997ac0aa100bf91997194ad85a7e59f743/src%2Flibrustc_codegen_llvm%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fblock.rs?ref=f89817997ac0aa100bf91997194ad85a7e59f743", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use llvm::{self, ValueRef, BasicBlockRef};\n+use llvm::{self, BasicBlock};\n use rustc::middle::lang_items;\n use rustc::ty::{self, Ty, TypeFoldable};\n use rustc::ty::layout::{self, LayoutOf};\n@@ -24,6 +24,7 @@ use meth;\n use monomorphize;\n use type_of::LayoutLlvmExt;\n use type_::Type;\n+use value::Value;\n \n use syntax::symbol::Symbol;\n use syntax_pos::Pos;\n@@ -33,7 +34,7 @@ use super::place::PlaceRef;\n use super::operand::OperandRef;\n use super::operand::OperandValue::{Pair, Ref, Immediate};\n \n-impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n+impl FunctionCx<'a, 'll, 'tcx> {\n     pub fn codegen_block(&mut self, bb: mir::BasicBlock) {\n         let mut bx = self.build_block(bb);\n         let data = &self.mir[bb];\n@@ -48,7 +49,7 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n     }\n \n     fn codegen_terminator(&mut self,\n-                        mut bx: Builder<'a, 'tcx>,\n+                        mut bx: Builder<'a, 'll, 'tcx>,\n                         bb: mir::BasicBlock,\n                         terminator: &mir::Terminator<'tcx>)\n     {\n@@ -97,7 +98,7 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n             }\n         };\n \n-        let funclet_br = |this: &mut Self, bx: Builder, target: mir::BasicBlock| {\n+        let funclet_br = |this: &mut Self, bx: Builder<'_, 'll, '_>, target: mir::BasicBlock| {\n             let (lltarget, is_cleanupret) = lltarget(this, target);\n             if is_cleanupret {\n                 // micro-optimization: generate a `ret` rather than a jump\n@@ -110,11 +111,11 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n \n         let do_call = |\n             this: &mut Self,\n-            bx: Builder<'a, 'tcx>,\n+            bx: Builder<'a, 'll, 'tcx>,\n             fn_ty: FnType<'tcx, Ty<'tcx>>,\n-            fn_ptr: ValueRef,\n-            llargs: &[ValueRef],\n-            destination: Option<(ReturnDest<'tcx>, mir::BasicBlock)>,\n+            fn_ptr: &'ll Value,\n+            llargs: &[&'ll Value],\n+            destination: Option<(ReturnDest<'ll, 'tcx>, mir::BasicBlock)>,\n             cleanup: Option<mir::BasicBlock>\n         | {\n             if let Some(cleanup) = cleanup {\n@@ -285,8 +286,14 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n                 }\n \n                 let place = self.codegen_place(&bx, location);\n-                let mut args: &[_] = &[place.llval, place.llextra];\n-                args = &args[..1 + place.has_extra() as usize];\n+                let (args1, args2);\n+                let mut args = if let Some(llextra) = place.llextra {\n+                    args2 = [place.llval, llextra];\n+                    &args2[..]\n+                } else {\n+                    args1 = [place.llval];\n+                    &args1[..]\n+                };\n                 let (drop_fn, fn_ty) = match ty.sty {\n                     ty::TyDynamic(..) => {\n                         let fn_ty = drop_fn.ty(bx.cx.tcx);\n@@ -296,8 +303,9 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n                             &sig,\n                         );\n                         let fn_ty = FnType::new_vtable(bx.cx, sig, &[]);\n+                        let vtable = args[1];\n                         args = &args[..1];\n-                        (meth::DESTRUCTOR.get_fn(&bx, place.llextra, &fn_ty), fn_ty)\n+                        (meth::DESTRUCTOR.get_fn(&bx, vtable, &fn_ty), fn_ty)\n                     }\n                     _ => {\n                         (callee::get_fn(bx.cx, drop_fn),\n@@ -627,9 +635,9 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n     }\n \n     fn codegen_argument(&mut self,\n-                      bx: &Builder<'a, 'tcx>,\n-                      op: OperandRef<'tcx>,\n-                      llargs: &mut Vec<ValueRef>,\n+                      bx: &Builder<'a, 'll, 'tcx>,\n+                      op: OperandRef<'ll, 'tcx>,\n+                      llargs: &mut Vec<&'ll Value>,\n                       arg: &ArgType<'tcx, Ty<'tcx>>) {\n         // Fill padding with undef value, where applicable.\n         if let Some(ty) = arg.pad {\n@@ -706,9 +714,9 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n     }\n \n     fn codegen_arguments_untupled(&mut self,\n-                                bx: &Builder<'a, 'tcx>,\n+                                bx: &Builder<'a, 'll, 'tcx>,\n                                 operand: &mir::Operand<'tcx>,\n-                                llargs: &mut Vec<ValueRef>,\n+                                llargs: &mut Vec<&'ll Value>,\n                                 args: &[ArgType<'tcx, Ty<'tcx>>]) {\n         let tuple = self.codegen_operand(bx, operand);\n \n@@ -728,7 +736,7 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n         }\n     }\n \n-    fn get_personality_slot(&mut self, bx: &Builder<'a, 'tcx>) -> PlaceRef<'tcx> {\n+    fn get_personality_slot(&mut self, bx: &Builder<'a, 'll, 'tcx>) -> PlaceRef<'ll, 'tcx> {\n         let cx = bx.cx;\n         if let Some(slot) = self.personality_slot {\n             slot\n@@ -746,7 +754,7 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n     /// Return the landingpad wrapper around the given basic block\n     ///\n     /// No-op in MSVC SEH scheme.\n-    fn landing_pad_to(&mut self, target_bb: mir::BasicBlock) -> BasicBlockRef {\n+    fn landing_pad_to(&mut self, target_bb: mir::BasicBlock) -> &'ll BasicBlock {\n         if let Some(block) = self.landing_pads[target_bb] {\n             return block;\n         }\n@@ -757,7 +765,7 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n         landing_pad\n     }\n \n-    fn landing_pad_uncached(&mut self, target_bb: BasicBlockRef) -> BasicBlockRef {\n+    fn landing_pad_uncached(&mut self, target_bb: &'ll BasicBlock) -> &'ll BasicBlock {\n         if base::wants_msvc_seh(self.cx.sess()) {\n             span_bug!(self.mir.span, \"landing pad was not inserted?\")\n         }\n@@ -777,12 +785,12 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n         bx.llbb()\n     }\n \n-    fn landing_pad_type(&self) -> Type {\n+    fn landing_pad_type(&self) -> &'ll Type {\n         let cx = self.cx;\n         Type::struct_(cx, &[Type::i8p(cx), Type::i32(cx)], false)\n     }\n \n-    fn unreachable_block(&mut self) -> BasicBlockRef {\n+    fn unreachable_block(&mut self) -> &'ll BasicBlock {\n         self.unreachable_block.unwrap_or_else(|| {\n             let bl = self.new_block(\"unreachable\");\n             bl.unreachable();\n@@ -791,20 +799,20 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n         })\n     }\n \n-    pub fn new_block(&self, name: &str) -> Builder<'a, 'tcx> {\n+    pub fn new_block(&self, name: &str) -> Builder<'a, 'll, 'tcx> {\n         Builder::new_block(self.cx, self.llfn, name)\n     }\n \n-    pub fn build_block(&self, bb: mir::BasicBlock) -> Builder<'a, 'tcx> {\n+    pub fn build_block(&self, bb: mir::BasicBlock) -> Builder<'a, 'll, 'tcx> {\n         let bx = Builder::with_cx(self.cx);\n         bx.position_at_end(self.blocks[bb]);\n         bx\n     }\n \n-    fn make_return_dest(&mut self, bx: &Builder<'a, 'tcx>,\n+    fn make_return_dest(&mut self, bx: &Builder<'a, 'll, 'tcx>,\n                         dest: &mir::Place<'tcx>, fn_ret: &ArgType<'tcx, Ty<'tcx>>,\n-                        llargs: &mut Vec<ValueRef>, is_intrinsic: bool)\n-                        -> ReturnDest<'tcx> {\n+                        llargs: &mut Vec<&'ll Value>, is_intrinsic: bool)\n+                        -> ReturnDest<'ll, 'tcx> {\n         // If the return is ignored, we can just return a do-nothing ReturnDest\n         if fn_ret.is_ignore() {\n             return ReturnDest::Nothing;\n@@ -857,7 +865,7 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n         }\n     }\n \n-    fn codegen_transmute(&mut self, bx: &Builder<'a, 'tcx>,\n+    fn codegen_transmute(&mut self, bx: &Builder<'a, 'll, 'tcx>,\n                        src: &mir::Operand<'tcx>,\n                        dst: &mir::Place<'tcx>) {\n         if let mir::Place::Local(index) = *dst {\n@@ -884,9 +892,9 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n         }\n     }\n \n-    fn codegen_transmute_into(&mut self, bx: &Builder<'a, 'tcx>,\n+    fn codegen_transmute_into(&mut self, bx: &Builder<'a, 'll, 'tcx>,\n                             src: &mir::Operand<'tcx>,\n-                            dst: PlaceRef<'tcx>) {\n+                            dst: PlaceRef<'ll, 'tcx>) {\n         let src = self.codegen_operand(bx, src);\n         let llty = src.layout.llvm_type(bx.cx);\n         let cast_ptr = bx.pointercast(dst.llval, llty.ptr_to());\n@@ -897,10 +905,10 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n \n     // Stores the return value of a function call into it's final location.\n     fn store_return(&mut self,\n-                    bx: &Builder<'a, 'tcx>,\n-                    dest: ReturnDest<'tcx>,\n+                    bx: &Builder<'a, 'll, 'tcx>,\n+                    dest: ReturnDest<'ll, 'tcx>,\n                     ret_ty: &ArgType<'tcx, Ty<'tcx>>,\n-                    llval: ValueRef) {\n+                    llval: &'ll Value) {\n         use self::ReturnDest::*;\n \n         match dest {\n@@ -929,13 +937,13 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n     }\n }\n \n-enum ReturnDest<'tcx> {\n+enum ReturnDest<'ll, 'tcx> {\n     // Do nothing, the return value is indirect or ignored\n     Nothing,\n     // Store the return value to the pointer\n-    Store(PlaceRef<'tcx>),\n+    Store(PlaceRef<'ll, 'tcx>),\n     // Stores an indirect return value to an operand local place\n-    IndirectOperand(PlaceRef<'tcx>, mir::Local),\n+    IndirectOperand(PlaceRef<'ll, 'tcx>, mir::Local),\n     // Stores a direct return value to an operand local place\n     DirectOperand(mir::Local)\n }"}, {"sha": "341ed9df64b5927c1df9250ffb7b5386f4483cd6", "filename": "src/librustc_codegen_llvm/mir/constant.rs", "status": "modified", "additions": 20, "deletions": 17, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/f89817997ac0aa100bf91997194ad85a7e59f743/src%2Flibrustc_codegen_llvm%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f89817997ac0aa100bf91997194ad85a7e59f743/src%2Flibrustc_codegen_llvm%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fconstant.rs?ref=f89817997ac0aa100bf91997194ad85a7e59f743", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use llvm::{self, ValueRef};\n+use llvm;\n use rustc::mir::interpret::ConstEvalErr;\n use rustc_mir::interpret::{read_target_uint, const_val_field};\n use rustc::hir::def_id::DefId;\n@@ -26,14 +26,17 @@ use type_of::LayoutLlvmExt;\n use type_::Type;\n use syntax::ast::Mutability;\n use syntax::codemap::Span;\n+use value::Value;\n \n use super::super::callee;\n use super::FunctionCx;\n \n-pub fn scalar_to_llvm(cx: &CodegenCx,\n-                       cv: Scalar,\n-                       layout: &layout::Scalar,\n-                       llty: Type) -> ValueRef {\n+pub fn scalar_to_llvm(\n+    cx: &CodegenCx<'ll, '_>,\n+    cv: Scalar,\n+    layout: &layout::Scalar,\n+    llty: &'ll Type,\n+) -> &'ll Value {\n     let bitsize = if layout.is_bool() { 1 } else { layout.value.size(cx).bits() };\n     match cv {\n         Scalar::Bits { defined, .. } if (defined as u64) < bitsize || defined == 0 => {\n@@ -42,7 +45,7 @@ pub fn scalar_to_llvm(cx: &CodegenCx,\n         Scalar::Bits { bits, .. } => {\n             let llval = C_uint_big(Type::ix(cx, bitsize), bits);\n             if layout.value == layout::Pointer {\n-                unsafe { llvm::LLVMConstIntToPtr(llval, llty.to_ref()) }\n+                unsafe { llvm::LLVMConstIntToPtr(llval, llty) }\n             } else {\n                 consts::bitcast(llval, llty)\n             }\n@@ -73,15 +76,15 @@ pub fn scalar_to_llvm(cx: &CodegenCx,\n                 1,\n             ) };\n             if layout.value != layout::Pointer {\n-                unsafe { llvm::LLVMConstPtrToInt(llval, llty.to_ref()) }\n+                unsafe { llvm::LLVMConstPtrToInt(llval, llty) }\n             } else {\n                 consts::bitcast(llval, llty)\n             }\n         }\n     }\n }\n \n-pub fn const_alloc_to_llvm(cx: &CodegenCx, alloc: &Allocation) -> ValueRef {\n+pub fn const_alloc_to_llvm(cx: &CodegenCx<'ll, '_>, alloc: &Allocation) -> &'ll Value {\n     let mut llvals = Vec::with_capacity(alloc.relocations.len() + 1);\n     let layout = cx.data_layout();\n     let pointer_size = layout.pointer_size.bytes() as usize;\n@@ -116,10 +119,10 @@ pub fn const_alloc_to_llvm(cx: &CodegenCx, alloc: &Allocation) -> ValueRef {\n     C_struct(cx, &llvals, true)\n }\n \n-pub fn codegen_static_initializer<'a, 'tcx>(\n-    cx: &CodegenCx<'a, 'tcx>,\n+pub fn codegen_static_initializer(\n+    cx: &CodegenCx<'ll, 'tcx>,\n     def_id: DefId,\n-) -> Result<(ValueRef, &'tcx Allocation), Lrc<ConstEvalErr<'tcx>>> {\n+) -> Result<(&'ll Value, &'tcx Allocation), Lrc<ConstEvalErr<'tcx>>> {\n     let instance = ty::Instance::mono(cx.tcx, def_id);\n     let cid = GlobalId {\n         instance,\n@@ -135,10 +138,10 @@ pub fn codegen_static_initializer<'a, 'tcx>(\n     Ok((const_alloc_to_llvm(cx, alloc), alloc))\n }\n \n-impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n+impl FunctionCx<'a, 'll, 'tcx> {\n     fn fully_evaluate(\n         &mut self,\n-        bx: &Builder<'a, 'tcx>,\n+        bx: &Builder<'a, 'll, 'tcx>,\n         constant: &'tcx ty::Const<'tcx>,\n     ) -> Result<&'tcx ty::Const<'tcx>, Lrc<ConstEvalErr<'tcx>>> {\n         match constant.val {\n@@ -158,7 +161,7 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n \n     pub fn eval_mir_constant(\n         &mut self,\n-        bx: &Builder<'a, 'tcx>,\n+        bx: &Builder<'a, 'll, 'tcx>,\n         constant: &mir::Constant<'tcx>,\n     ) -> Result<&'tcx ty::Const<'tcx>, Lrc<ConstEvalErr<'tcx>>> {\n         let c = self.monomorphize(&constant.literal);\n@@ -168,19 +171,19 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n     /// process constant containing SIMD shuffle indices\n     pub fn simd_shuffle_indices(\n         &mut self,\n-        bx: &Builder<'a, 'tcx>,\n+        bx: &Builder<'a, 'll, 'tcx>,\n         span: Span,\n         ty: Ty<'tcx>,\n         constant: Result<&'tcx ty::Const<'tcx>, Lrc<ConstEvalErr<'tcx>>>,\n-    ) -> (ValueRef, Ty<'tcx>) {\n+    ) -> (&'ll Value, Ty<'tcx>) {\n         constant\n             .and_then(|c| {\n                 let field_ty = c.ty.builtin_index().unwrap();\n                 let fields = match c.ty.sty {\n                     ty::TyArray(_, n) => n.unwrap_usize(bx.tcx()),\n                     ref other => bug!(\"invalid simd shuffle type: {}\", other),\n                 };\n-                let values: Result<Vec<ValueRef>, Lrc<_>> = (0..fields).map(|field| {\n+                let values: Result<Vec<_>, Lrc<_>> = (0..fields).map(|field| {\n                     let field = const_val_field(\n                         bx.tcx(),\n                         ty::ParamEnv::reveal_all(),"}, {"sha": "8cdd0398eff96d02e28dfea807c8523429dc968b", "filename": "src/librustc_codegen_llvm/mir/mod.rs", "status": "modified", "additions": 44, "deletions": 42, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/f89817997ac0aa100bf91997194ad85a7e59f743/src%2Flibrustc_codegen_llvm%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f89817997ac0aa100bf91997194ad85a7e59f743/src%2Flibrustc_codegen_llvm%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fmod.rs?ref=f89817997ac0aa100bf91997194ad85a7e59f743", "patch": "@@ -10,7 +10,7 @@\n \n use common::{C_i32, C_null};\n use libc::c_uint;\n-use llvm::{self, ValueRef, BasicBlockRef};\n+use llvm::{self, BasicBlock};\n use llvm::debuginfo::DIScope;\n use rustc::ty::{self, Ty, TypeFoldable, UpvarSubsts};\n use rustc::ty::layout::{LayoutOf, TyLayout};\n@@ -24,6 +24,7 @@ use debuginfo::{self, declare_local, VariableAccess, VariableKind, FunctionDebug\n use monomorphize::Instance;\n use abi::{ArgTypeExt, FnType, FnTypeExt, PassMode};\n use type_::Type;\n+use value::Value;\n \n use syntax_pos::{DUMMY_SP, NO_EXPANSION, BytePos, Span};\n use syntax::symbol::keywords;\n@@ -42,16 +43,16 @@ use rustc::mir::traversal;\n use self::operand::{OperandRef, OperandValue};\n \n /// Master context for codegenning from MIR.\n-pub struct FunctionCx<'a, 'tcx:'a> {\n+pub struct FunctionCx<'a, 'll: 'a, 'tcx: 'll> {\n     instance: Instance<'tcx>,\n \n     mir: &'a mir::Mir<'tcx>,\n \n-    debug_context: debuginfo::FunctionDebugContext,\n+    debug_context: FunctionDebugContext<'ll>,\n \n-    llfn: ValueRef,\n+    llfn: &'ll Value,\n \n-    cx: &'a CodegenCx<'a, 'tcx>,\n+    cx: &'a CodegenCx<'ll, 'tcx>,\n \n     fn_ty: FnType<'tcx, Ty<'tcx>>,\n \n@@ -62,24 +63,24 @@ pub struct FunctionCx<'a, 'tcx:'a> {\n     /// don't really care about it very much. Anyway, this value\n     /// contains an alloca into which the personality is stored and\n     /// then later loaded when generating the DIVERGE_BLOCK.\n-    personality_slot: Option<PlaceRef<'tcx>>,\n+    personality_slot: Option<PlaceRef<'ll, 'tcx>>,\n \n     /// A `Block` for each MIR `BasicBlock`\n-    blocks: IndexVec<mir::BasicBlock, BasicBlockRef>,\n+    blocks: IndexVec<mir::BasicBlock, &'ll BasicBlock>,\n \n     /// The funclet status of each basic block\n     cleanup_kinds: IndexVec<mir::BasicBlock, analyze::CleanupKind>,\n \n     /// When targeting MSVC, this stores the cleanup info for each funclet\n     /// BB. This is initialized as we compute the funclets' head block in RPO.\n-    funclets: &'a IndexVec<mir::BasicBlock, Option<Funclet>>,\n+    funclets: &'a IndexVec<mir::BasicBlock, Option<Funclet<'ll>>>,\n \n     /// This stores the landing-pad block for a given BB, computed lazily on GNU\n     /// and eagerly on MSVC.\n-    landing_pads: IndexVec<mir::BasicBlock, Option<BasicBlockRef>>,\n+    landing_pads: IndexVec<mir::BasicBlock, Option<&'ll BasicBlock>>,\n \n     /// Cached unreachable block\n-    unreachable_block: Option<BasicBlockRef>,\n+    unreachable_block: Option<&'ll BasicBlock>,\n \n     /// The location where each MIR arg/var/tmp/ret is stored. This is\n     /// usually an `PlaceRef` representing an alloca, but not always:\n@@ -96,16 +97,16 @@ pub struct FunctionCx<'a, 'tcx:'a> {\n     ///\n     /// Avoiding allocs can also be important for certain intrinsics,\n     /// notably `expect`.\n-    locals: IndexVec<mir::Local, LocalRef<'tcx>>,\n+    locals: IndexVec<mir::Local, LocalRef<'ll, 'tcx>>,\n \n     /// Debug information for MIR scopes.\n-    scopes: IndexVec<mir::SourceScope, debuginfo::MirDebugScope>,\n+    scopes: IndexVec<mir::SourceScope, debuginfo::MirDebugScope<'ll>>,\n \n     /// If this function is being monomorphized, this contains the type substitutions used.\n     param_substs: &'tcx Substs<'tcx>,\n }\n \n-impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n+impl FunctionCx<'a, 'll, 'tcx> {\n     pub fn monomorphize<T>(&self, value: &T) -> T\n         where T: TypeFoldable<'tcx>\n     {\n@@ -116,12 +117,12 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n         )\n     }\n \n-    pub fn set_debug_loc(&mut self, bx: &Builder, source_info: mir::SourceInfo) {\n+    pub fn set_debug_loc(&mut self, bx: &Builder<'_, 'll, '_>, source_info: mir::SourceInfo) {\n         let (scope, span) = self.debug_loc(source_info);\n         debuginfo::set_source_location(&self.debug_context, bx, scope, span);\n     }\n \n-    pub fn debug_loc(&mut self, source_info: mir::SourceInfo) -> (DIScope, Span) {\n+    pub fn debug_loc(&mut self, source_info: mir::SourceInfo) -> (Option<&'ll DIScope>, Span) {\n         // Bail out if debug info emission is not enabled.\n         match self.debug_context {\n             FunctionDebugContext::DebugInfoDisabled |\n@@ -161,29 +162,29 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n     // corresponding to span's containing source scope.  If so, we need to create a DIScope\n     // \"extension\" into that file.\n     fn scope_metadata_for_loc(&self, scope_id: mir::SourceScope, pos: BytePos)\n-                               -> llvm::debuginfo::DIScope {\n+                               -> Option<&'ll DIScope> {\n         let scope_metadata = self.scopes[scope_id].scope_metadata;\n         if pos < self.scopes[scope_id].file_start_pos ||\n            pos >= self.scopes[scope_id].file_end_pos {\n             let cm = self.cx.sess().codemap();\n             let defining_crate = self.debug_context.get_ref(DUMMY_SP).defining_crate;\n-            debuginfo::extend_scope_to_file(self.cx,\n-                                            scope_metadata,\n+            Some(debuginfo::extend_scope_to_file(self.cx,\n+                                            scope_metadata.unwrap(),\n                                             &cm.lookup_char_pos(pos).file,\n-                                            defining_crate)\n+                                            defining_crate))\n         } else {\n             scope_metadata\n         }\n     }\n }\n \n-enum LocalRef<'tcx> {\n-    Place(PlaceRef<'tcx>),\n-    Operand(Option<OperandRef<'tcx>>),\n+enum LocalRef<'ll, 'tcx> {\n+    Place(PlaceRef<'ll, 'tcx>),\n+    Operand(Option<OperandRef<'ll, 'tcx>>),\n }\n \n-impl<'a, 'tcx> LocalRef<'tcx> {\n-    fn new_operand(cx: &CodegenCx<'a, 'tcx>, layout: TyLayout<'tcx>) -> LocalRef<'tcx> {\n+impl LocalRef<'ll, 'tcx> {\n+    fn new_operand(cx: &CodegenCx<'ll, 'tcx>, layout: TyLayout<'tcx>) -> LocalRef<'ll, 'tcx> {\n         if layout.is_zst() {\n             // Zero-size temporaries aren't always initialized, which\n             // doesn't matter because they don't contain data, but\n@@ -197,9 +198,9 @@ impl<'a, 'tcx> LocalRef<'tcx> {\n \n ///////////////////////////////////////////////////////////////////////////\n \n-pub fn codegen_mir<'a, 'tcx: 'a>(\n-    cx: &'a CodegenCx<'a, 'tcx>,\n-    llfn: ValueRef,\n+pub fn codegen_mir(\n+    cx: &'a CodegenCx<'ll, 'tcx>,\n+    llfn: &'ll Value,\n     mir: &'a Mir<'tcx>,\n     instance: Instance<'tcx>,\n     sig: ty::FnSig<'tcx>,\n@@ -218,7 +219,7 @@ pub fn codegen_mir<'a, 'tcx: 'a>(\n     // Allocate a `Block` for every basic block, except\n     // the start block, if nothing loops back to it.\n     let reentrant_start_block = !mir.predecessors_for(mir::START_BLOCK).is_empty();\n-    let block_bxs: IndexVec<mir::BasicBlock, BasicBlockRef> =\n+    let block_bxs: IndexVec<mir::BasicBlock, &'ll BasicBlock> =\n         mir.basic_blocks().indices().map(|bb| {\n             if bb == mir::START_BLOCK && !reentrant_start_block {\n                 bx.llbb()\n@@ -280,7 +281,7 @@ pub fn codegen_mir<'a, 'tcx: 'a>(\n                         span: decl.source_info.span,\n                         scope: decl.visibility_scope,\n                     });\n-                    declare_local(&bx, &fx.debug_context, name, layout.ty, scope,\n+                    declare_local(&bx, &fx.debug_context, name, layout.ty, scope.unwrap(),\n                         VariableAccess::DirectVariable { alloca: place.llval },\n                         VariableKind::LocalVariable, span);\n                 }\n@@ -343,13 +344,13 @@ pub fn codegen_mir<'a, 'tcx: 'a>(\n     }\n }\n \n-fn create_funclets<'a, 'tcx>(\n+fn create_funclets(\n     mir: &'a Mir<'tcx>,\n-    bx: &Builder<'a, 'tcx>,\n+    bx: &Builder<'a, 'll, 'tcx>,\n     cleanup_kinds: &IndexVec<mir::BasicBlock, CleanupKind>,\n-    block_bxs: &IndexVec<mir::BasicBlock, BasicBlockRef>)\n-    -> (IndexVec<mir::BasicBlock, Option<BasicBlockRef>>,\n-        IndexVec<mir::BasicBlock, Option<Funclet>>)\n+    block_bxs: &IndexVec<mir::BasicBlock, &'ll BasicBlock>)\n+    -> (IndexVec<mir::BasicBlock, Option<&'ll BasicBlock>>,\n+        IndexVec<mir::BasicBlock, Option<Funclet<'ll>>>)\n {\n     block_bxs.iter_enumerated().zip(cleanup_kinds).map(|((bb, &llbb), cleanup_kind)| {\n         match *cleanup_kind {\n@@ -409,23 +410,24 @@ fn create_funclets<'a, 'tcx>(\n     }).unzip()\n }\n \n-/// Produce, for each argument, a `ValueRef` pointing at the\n+/// Produce, for each argument, a `Value` pointing at the\n /// argument's value. As arguments are places, these are always\n /// indirect.\n-fn arg_local_refs<'a, 'tcx>(bx: &Builder<'a, 'tcx>,\n-                            fx: &FunctionCx<'a, 'tcx>,\n-                            scopes: &IndexVec<mir::SourceScope, debuginfo::MirDebugScope>,\n-                            memory_locals: &BitVector<mir::Local>)\n-                            -> Vec<LocalRef<'tcx>> {\n+fn arg_local_refs(\n+    bx: &Builder<'a, 'll, 'tcx>,\n+    fx: &FunctionCx<'a, 'll, 'tcx>,\n+    scopes: &IndexVec<mir::SourceScope, debuginfo::MirDebugScope<'ll>>,\n+    memory_locals: &BitVector<mir::Local>,\n+) -> Vec<LocalRef<'ll, 'tcx>> {\n     let mir = fx.mir;\n     let tcx = bx.tcx();\n     let mut idx = 0;\n     let mut llarg_idx = fx.fn_ty.ret.is_indirect() as usize;\n \n     // Get the argument scope, if it exists and if we need it.\n     let arg_scope = scopes[mir::OUTERMOST_SOURCE_SCOPE];\n-    let arg_scope = if arg_scope.is_valid() && bx.sess().opts.debuginfo == FullDebugInfo {\n-        Some(arg_scope.scope_metadata)\n+    let arg_scope = if bx.sess().opts.debuginfo == FullDebugInfo {\n+        arg_scope.scope_metadata\n     } else {\n         None\n     };"}, {"sha": "1296f5e4b144efd703fce8891ae3c580dbfe7d3e", "filename": "src/librustc_codegen_llvm/mir/operand.rs", "status": "modified", "additions": 40, "deletions": 53, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/f89817997ac0aa100bf91997194ad85a7e59f743/src%2Flibrustc_codegen_llvm%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f89817997ac0aa100bf91997194ad85a7e59f743/src%2Flibrustc_codegen_llvm%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Foperand.rs?ref=f89817997ac0aa100bf91997194ad85a7e59f743", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use llvm::ValueRef;\n use rustc::mir::interpret::ConstEvalErr;\n use rustc::mir;\n use rustc::mir::interpret::ConstValue;\n@@ -24,7 +23,6 @@ use value::Value;\n use type_of::LayoutLlvmExt;\n \n use std::fmt;\n-use std::ptr;\n \n use super::{FunctionCx, LocalRef};\n use super::constant::scalar_to_llvm;\n@@ -33,31 +31,15 @@ use super::place::PlaceRef;\n /// The representation of a Rust value. The enum variant is in fact\n /// uniquely determined by the value's type, but is kept as a\n /// safety check.\n-#[derive(Copy, Clone)]\n-pub enum OperandValue {\n+#[derive(Copy, Clone, Debug)]\n+pub enum OperandValue<'ll> {\n     /// A reference to the actual operand. The data is guaranteed\n     /// to be valid for the operand's lifetime.\n-    Ref(ValueRef, Align),\n+    Ref(&'ll Value, Align),\n     /// A single LLVM value.\n-    Immediate(ValueRef),\n+    Immediate(&'ll Value),\n     /// A pair of immediate LLVM values. Used by fat pointers too.\n-    Pair(ValueRef, ValueRef)\n-}\n-\n-impl fmt::Debug for OperandValue {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        match *self {\n-            OperandValue::Ref(r, align) => {\n-                write!(f, \"Ref({:?}, {:?})\", Value(r), align)\n-            }\n-            OperandValue::Immediate(i) => {\n-                write!(f, \"Immediate({:?})\", Value(i))\n-            }\n-            OperandValue::Pair(a, b) => {\n-                write!(f, \"Pair({:?}, {:?})\", Value(a), Value(b))\n-            }\n-        }\n-    }\n+    Pair(&'ll Value, &'ll Value)\n }\n \n /// An `OperandRef` is an \"SSA\" reference to a Rust value, along with\n@@ -69,33 +51,33 @@ impl fmt::Debug for OperandValue {\n /// directly is sure to cause problems -- use `OperandRef::store`\n /// instead.\n #[derive(Copy, Clone)]\n-pub struct OperandRef<'tcx> {\n+pub struct OperandRef<'ll, 'tcx> {\n     // The value.\n-    pub val: OperandValue,\n+    pub val: OperandValue<'ll>,\n \n     // The layout of value, based on its Rust type.\n     pub layout: TyLayout<'tcx>,\n }\n \n-impl<'tcx> fmt::Debug for OperandRef<'tcx> {\n+impl fmt::Debug for OperandRef<'ll, 'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"OperandRef({:?} @ {:?})\", self.val, self.layout)\n     }\n }\n \n-impl<'a, 'tcx> OperandRef<'tcx> {\n-    pub fn new_zst(cx: &CodegenCx<'a, 'tcx>,\n-                   layout: TyLayout<'tcx>) -> OperandRef<'tcx> {\n+impl OperandRef<'ll, 'tcx> {\n+    pub fn new_zst(cx: &CodegenCx<'ll, 'tcx>,\n+                   layout: TyLayout<'tcx>) -> OperandRef<'ll, 'tcx> {\n         assert!(layout.is_zst());\n         OperandRef {\n             val: OperandValue::Immediate(C_undef(layout.immediate_llvm_type(cx))),\n             layout\n         }\n     }\n \n-    pub fn from_const(bx: &Builder<'a, 'tcx>,\n+    pub fn from_const(bx: &Builder<'a, 'll, 'tcx>,\n                       val: &'tcx ty::Const<'tcx>)\n-                      -> Result<OperandRef<'tcx>, Lrc<ConstEvalErr<'tcx>>> {\n+                      -> Result<OperandRef<'ll, 'tcx>, Lrc<ConstEvalErr<'tcx>>> {\n         let layout = bx.cx.layout_of(val.ty);\n \n         if layout.is_zst() {\n@@ -149,19 +131,19 @@ impl<'a, 'tcx> OperandRef<'tcx> {\n \n     /// Asserts that this operand refers to a scalar and returns\n     /// a reference to its value.\n-    pub fn immediate(self) -> ValueRef {\n+    pub fn immediate(self) -> &'ll Value {\n         match self.val {\n             OperandValue::Immediate(s) => s,\n             _ => bug!(\"not immediate: {:?}\", self)\n         }\n     }\n \n-    pub fn deref(self, cx: &CodegenCx<'a, 'tcx>) -> PlaceRef<'tcx> {\n+    pub fn deref(self, cx: &CodegenCx<'ll, 'tcx>) -> PlaceRef<'ll, 'tcx> {\n         let projected_ty = self.layout.ty.builtin_deref(true)\n             .unwrap_or_else(|| bug!(\"deref of non-pointer {:?}\", self)).ty;\n         let (llptr, llextra) = match self.val {\n-            OperandValue::Immediate(llptr) => (llptr, ptr::null_mut()),\n-            OperandValue::Pair(llptr, llextra) => (llptr, llextra),\n+            OperandValue::Immediate(llptr) => (llptr, None),\n+            OperandValue::Pair(llptr, llextra) => (llptr, Some(llextra)),\n             OperandValue::Ref(..) => bug!(\"Deref of by-Ref operand {:?}\", self)\n         };\n         let layout = cx.layout_of(projected_ty);\n@@ -175,7 +157,7 @@ impl<'a, 'tcx> OperandRef<'tcx> {\n \n     /// If this operand is a `Pair`, we return an aggregate with the two values.\n     /// For other cases, see `immediate`.\n-    pub fn immediate_or_packed_pair(self, bx: &Builder<'a, 'tcx>) -> ValueRef {\n+    pub fn immediate_or_packed_pair(self, bx: &Builder<'a, 'll, 'tcx>) -> &'ll Value {\n         if let OperandValue::Pair(a, b) = self.val {\n             let llty = self.layout.llvm_type(bx.cx);\n             debug!(\"Operand::immediate_or_packed_pair: packing {:?} into {:?}\",\n@@ -191,10 +173,10 @@ impl<'a, 'tcx> OperandRef<'tcx> {\n     }\n \n     /// If the type is a pair, we return a `Pair`, otherwise, an `Immediate`.\n-    pub fn from_immediate_or_packed_pair(bx: &Builder<'a, 'tcx>,\n-                                         llval: ValueRef,\n+    pub fn from_immediate_or_packed_pair(bx: &Builder<'a, 'll, 'tcx>,\n+                                         llval: &'ll Value,\n                                          layout: TyLayout<'tcx>)\n-                                         -> OperandRef<'tcx> {\n+                                         -> OperandRef<'ll, 'tcx> {\n         let val = if let layout::Abi::ScalarPair(ref a, ref b) = layout.abi {\n             debug!(\"Operand::from_immediate_or_packed_pair: unpacking {:?} @ {:?}\",\n                     llval, layout);\n@@ -209,7 +191,7 @@ impl<'a, 'tcx> OperandRef<'tcx> {\n         OperandRef { val, layout }\n     }\n \n-    pub fn extract_field(&self, bx: &Builder<'a, 'tcx>, i: usize) -> OperandRef<'tcx> {\n+    pub fn extract_field(&self, bx: &Builder<'a, 'll, 'tcx>, i: usize) -> OperandRef<'ll, 'tcx> {\n         let field = self.layout.field(bx.cx, i);\n         let offset = self.layout.fields.offset(i);\n \n@@ -267,24 +249,29 @@ impl<'a, 'tcx> OperandRef<'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> OperandValue {\n-    pub fn store(self, bx: &Builder<'a, 'tcx>, dest: PlaceRef<'tcx>) {\n+impl OperandValue<'ll> {\n+    pub fn store(self, bx: &Builder<'a, 'll, 'tcx>, dest: PlaceRef<'ll, 'tcx>) {\n         self.store_with_flags(bx, dest, MemFlags::empty());\n     }\n \n-    pub fn volatile_store(self, bx: &Builder<'a, 'tcx>, dest: PlaceRef<'tcx>) {\n+    pub fn volatile_store(self, bx: &Builder<'a, 'll, 'tcx>, dest: PlaceRef<'ll, 'tcx>) {\n         self.store_with_flags(bx, dest, MemFlags::VOLATILE);\n     }\n \n-    pub fn unaligned_volatile_store(self, bx: &Builder<'a, 'tcx>, dest: PlaceRef<'tcx>) {\n+    pub fn unaligned_volatile_store(self, bx: &Builder<'a, 'll, 'tcx>, dest: PlaceRef<'ll, 'tcx>) {\n         self.store_with_flags(bx, dest, MemFlags::VOLATILE | MemFlags::UNALIGNED);\n     }\n \n-    pub fn nontemporal_store(self, bx: &Builder<'a, 'tcx>, dest: PlaceRef<'tcx>) {\n+    pub fn nontemporal_store(self, bx: &Builder<'a, 'll, 'tcx>, dest: PlaceRef<'ll, 'tcx>) {\n         self.store_with_flags(bx, dest, MemFlags::NONTEMPORAL);\n     }\n \n-    fn store_with_flags(self, bx: &Builder<'a, 'tcx>, dest: PlaceRef<'tcx>, flags: MemFlags) {\n+    fn store_with_flags(\n+        self,\n+        bx: &Builder<'a, 'll, 'tcx>,\n+        dest: PlaceRef<'ll, 'tcx>,\n+        flags: MemFlags,\n+    ) {\n         debug!(\"OperandRef::store: operand={:?}, dest={:?}\", self, dest);\n         // Avoid generating stores of zero-sized values, because the only way to have a zero-sized\n         // value is through `undef`, and store itself is useless.\n@@ -311,11 +298,11 @@ impl<'a, 'tcx> OperandValue {\n     }\n }\n \n-impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n+impl FunctionCx<'a, 'll, 'tcx> {\n     fn maybe_codegen_consume_direct(&mut self,\n-                                  bx: &Builder<'a, 'tcx>,\n+                                  bx: &Builder<'a, 'll, 'tcx>,\n                                   place: &mir::Place<'tcx>)\n-                                   -> Option<OperandRef<'tcx>>\n+                                   -> Option<OperandRef<'ll, 'tcx>>\n     {\n         debug!(\"maybe_codegen_consume_direct(place={:?})\", place);\n \n@@ -361,9 +348,9 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n     }\n \n     pub fn codegen_consume(&mut self,\n-                         bx: &Builder<'a, 'tcx>,\n+                         bx: &Builder<'a, 'll, 'tcx>,\n                          place: &mir::Place<'tcx>)\n-                         -> OperandRef<'tcx>\n+                         -> OperandRef<'ll, 'tcx>\n     {\n         debug!(\"codegen_consume(place={:?})\", place);\n \n@@ -385,9 +372,9 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n     }\n \n     pub fn codegen_operand(&mut self,\n-                         bx: &Builder<'a, 'tcx>,\n+                         bx: &Builder<'a, 'll, 'tcx>,\n                          operand: &mir::Operand<'tcx>)\n-                         -> OperandRef<'tcx>\n+                         -> OperandRef<'ll, 'tcx>\n     {\n         debug!(\"codegen_operand(operand={:?})\", operand);\n "}, {"sha": "abc3dbdab2f5b04d307bfce1424d717814499cf1", "filename": "src/librustc_codegen_llvm/mir/place.rs", "status": "modified", "additions": 45, "deletions": 54, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/f89817997ac0aa100bf91997194ad85a7e59f743/src%2Flibrustc_codegen_llvm%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f89817997ac0aa100bf91997194ad85a7e59f743/src%2Flibrustc_codegen_llvm%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fplace.rs?ref=f89817997ac0aa100bf91997194ad85a7e59f743", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use llvm::{self, ValueRef, LLVMConstInBoundsGEP};\n+use llvm::{self, LLVMConstInBoundsGEP};\n use rustc::ty::{self, Ty};\n use rustc::ty::layout::{self, Align, TyLayout, LayoutOf, Size};\n use rustc::mir;\n@@ -24,18 +24,16 @@ use value::Value;\n use glue;\n use mir::constant::const_alloc_to_llvm;\n \n-use std::ptr;\n-\n use super::{FunctionCx, LocalRef};\n use super::operand::{OperandRef, OperandValue};\n \n #[derive(Copy, Clone, Debug)]\n-pub struct PlaceRef<'tcx> {\n+pub struct PlaceRef<'ll, 'tcx> {\n     /// Pointer to the contents of the place\n-    pub llval: ValueRef,\n+    pub llval: &'ll Value,\n \n     /// This place's extra data if it is unsized, or null\n-    pub llextra: ValueRef,\n+    pub llextra: Option<&'ll Value>,\n \n     /// Monomorphized type of this place, including variant information\n     pub layout: TyLayout<'tcx>,\n@@ -44,25 +42,26 @@ pub struct PlaceRef<'tcx> {\n     pub align: Align,\n }\n \n-impl<'a, 'tcx> PlaceRef<'tcx> {\n-    pub fn new_sized(llval: ValueRef,\n-                     layout: TyLayout<'tcx>,\n-                     align: Align)\n-                     -> PlaceRef<'tcx> {\n+impl PlaceRef<'ll, 'tcx> {\n+    pub fn new_sized(\n+        llval: &'ll Value,\n+        layout: TyLayout<'tcx>,\n+        align: Align,\n+    ) -> PlaceRef<'ll, 'tcx> {\n         PlaceRef {\n             llval,\n-            llextra: ptr::null_mut(),\n+            llextra: None,\n             layout,\n             align\n         }\n     }\n \n     pub fn from_const_alloc(\n-        bx: &Builder<'a, 'tcx>,\n+        bx: &Builder<'a, 'll, 'tcx>,\n         layout: TyLayout<'tcx>,\n         alloc: &mir::interpret::Allocation,\n         offset: Size,\n-    ) -> PlaceRef<'tcx> {\n+    ) -> PlaceRef<'ll, 'tcx> {\n         let init = const_alloc_to_llvm(bx.cx, alloc);\n         let base_addr = consts::addr_of(bx.cx, init, layout.align, \"byte_str\");\n \n@@ -75,19 +74,18 @@ impl<'a, 'tcx> PlaceRef<'tcx> {\n         PlaceRef::new_sized(llval, layout, alloc.align)\n     }\n \n-    pub fn alloca(bx: &Builder<'a, 'tcx>, layout: TyLayout<'tcx>, name: &str)\n-                  -> PlaceRef<'tcx> {\n+    pub fn alloca(bx: &Builder<'a, 'll, 'tcx>, layout: TyLayout<'tcx>, name: &str)\n+                  -> PlaceRef<'ll, 'tcx> {\n         debug!(\"alloca({:?}: {:?})\", name, layout);\n         let tmp = bx.alloca(layout.llvm_type(bx.cx), name, layout.align);\n         Self::new_sized(tmp, layout, layout.align)\n     }\n \n-    pub fn len(&self, cx: &CodegenCx<'a, 'tcx>) -> ValueRef {\n+    pub fn len(&self, cx: &CodegenCx<'ll, 'tcx>) -> &'ll Value {\n         if let layout::FieldPlacement::Array { count, .. } = self.layout.fields {\n             if self.layout.is_unsized() {\n-                assert!(self.has_extra());\n                 assert_eq!(count, 0);\n-                self.llextra\n+                self.llextra.unwrap()\n             } else {\n                 C_usize(cx, count)\n             }\n@@ -96,14 +94,10 @@ impl<'a, 'tcx> PlaceRef<'tcx> {\n         }\n     }\n \n-    pub fn has_extra(&self) -> bool {\n-        !self.llextra.is_null()\n-    }\n-\n-    pub fn load(&self, bx: &Builder<'a, 'tcx>) -> OperandRef<'tcx> {\n+    pub fn load(&self, bx: &Builder<'a, 'll, 'tcx>) -> OperandRef<'ll, 'tcx> {\n         debug!(\"PlaceRef::load: {:?}\", self);\n \n-        assert!(!self.has_extra());\n+        assert_eq!(self.llextra, None);\n \n         if self.layout.is_zst() {\n             return OperandRef::new_zst(bx.cx, self.layout);\n@@ -126,23 +120,21 @@ impl<'a, 'tcx> PlaceRef<'tcx> {\n         };\n \n         let val = if self.layout.is_llvm_immediate() {\n-            let mut const_llval = ptr::null_mut();\n+            let mut const_llval = None;\n             unsafe {\n-                let global = llvm::LLVMIsAGlobalVariable(self.llval);\n-                if !global.is_null() && llvm::LLVMIsGlobalConstant(global) == llvm::True {\n-                    const_llval = llvm::LLVMGetInitializer(global);\n+                if let Some(global) = llvm::LLVMIsAGlobalVariable(self.llval) {\n+                    if llvm::LLVMIsGlobalConstant(global) == llvm::True {\n+                        const_llval = llvm::LLVMGetInitializer(global);\n+                    }\n                 }\n             }\n-\n-            let llval = if !const_llval.is_null() {\n-                const_llval\n-            } else {\n+            let llval = const_llval.unwrap_or_else(|| {\n                 let load = bx.load(self.llval, self.align);\n                 if let layout::Abi::Scalar(ref scalar) = self.layout.abi {\n                     scalar_load_metadata(load, scalar);\n                 }\n                 load\n-            };\n+            });\n             OperandValue::Immediate(base::to_immediate(bx, llval, self.layout))\n         } else if let layout::Abi::ScalarPair(ref a, ref b) = self.layout.abi {\n             let load = |i, scalar: &layout::Scalar| {\n@@ -164,7 +156,7 @@ impl<'a, 'tcx> PlaceRef<'tcx> {\n     }\n \n     /// Access a field, at a point when the value's case is known.\n-    pub fn project_field(self, bx: &Builder<'a, 'tcx>, ix: usize) -> PlaceRef<'tcx> {\n+    pub fn project_field(self, bx: &Builder<'a, 'll, 'tcx>, ix: usize) -> PlaceRef<'ll, 'tcx> {\n         let cx = bx.cx;\n         let field = self.layout.field(cx, ix);\n         let offset = self.layout.fields.offset(ix);\n@@ -187,7 +179,7 @@ impl<'a, 'tcx> PlaceRef<'tcx> {\n                 llextra: if cx.type_has_metadata(field.ty) {\n                     self.llextra\n                 } else {\n-                    ptr::null_mut()\n+                    None\n                 },\n                 layout: field,\n                 align,\n@@ -199,9 +191,9 @@ impl<'a, 'tcx> PlaceRef<'tcx> {\n         //   * known alignment - sized types, [T], str or a foreign type\n         //   * packed struct - there is no alignment padding\n         match field.ty.sty {\n-            _ if !self.has_extra() => {\n+            _ if self.llextra.is_none() => {\n                 debug!(\"Unsized field `{}`, of `{:?}` has no metadata for adjustment\",\n-                    ix, Value(self.llval));\n+                    ix, self.llval);\n                 return simple();\n             }\n             _ if !field.is_unsized() => return simple(),\n@@ -249,7 +241,7 @@ impl<'a, 'tcx> PlaceRef<'tcx> {\n         let offset = bx.and(bx.add(unaligned_offset, align_sub_1),\n         bx.neg(unsized_align));\n \n-        debug!(\"struct_field_ptr: DST field offset: {:?}\", Value(offset));\n+        debug!(\"struct_field_ptr: DST field offset: {:?}\", offset);\n \n         // Cast and adjust pointer\n         let byte_ptr = bx.pointercast(self.llval, Type::i8p(cx));\n@@ -268,7 +260,7 @@ impl<'a, 'tcx> PlaceRef<'tcx> {\n     }\n \n     /// Obtain the actual discriminant of a value.\n-    pub fn codegen_get_discr(self, bx: &Builder<'a, 'tcx>, cast_to: Ty<'tcx>) -> ValueRef {\n+    pub fn codegen_get_discr(self, bx: &Builder<'a, 'll, 'tcx>, cast_to: Ty<'tcx>) -> &'ll Value {\n         let cast_to = bx.cx.layout_of(cast_to).immediate_llvm_type(bx.cx);\n         if self.layout.abi == layout::Abi::Uninhabited {\n             return C_undef(cast_to);\n@@ -332,7 +324,7 @@ impl<'a, 'tcx> PlaceRef<'tcx> {\n \n     /// Set the discriminant for a new value of the given case of the given\n     /// representation.\n-    pub fn codegen_set_discr(&self, bx: &Builder<'a, 'tcx>, variant_index: usize) {\n+    pub fn codegen_set_discr(&self, bx: &Builder<'a, 'll, 'tcx>, variant_index: usize) {\n         if self.layout.for_variant(bx.cx, variant_index).abi == layout::Abi::Uninhabited {\n             return;\n         }\n@@ -386,18 +378,18 @@ impl<'a, 'tcx> PlaceRef<'tcx> {\n         }\n     }\n \n-    pub fn project_index(&self, bx: &Builder<'a, 'tcx>, llindex: ValueRef)\n-                         -> PlaceRef<'tcx> {\n+    pub fn project_index(&self, bx: &Builder<'a, 'll, 'tcx>, llindex: &'ll Value)\n+                         -> PlaceRef<'ll, 'tcx> {\n         PlaceRef {\n             llval: bx.inbounds_gep(self.llval, &[C_usize(bx.cx, 0), llindex]),\n-            llextra: ptr::null_mut(),\n+            llextra: None,\n             layout: self.layout.field(bx.cx, 0),\n             align: self.align\n         }\n     }\n \n-    pub fn project_downcast(&self, bx: &Builder<'a, 'tcx>, variant_index: usize)\n-                            -> PlaceRef<'tcx> {\n+    pub fn project_downcast(&self, bx: &Builder<'a, 'll, 'tcx>, variant_index: usize)\n+                            -> PlaceRef<'ll, 'tcx> {\n         let mut downcast = *self;\n         downcast.layout = self.layout.for_variant(bx.cx, variant_index);\n \n@@ -408,20 +400,20 @@ impl<'a, 'tcx> PlaceRef<'tcx> {\n         downcast\n     }\n \n-    pub fn storage_live(&self, bx: &Builder<'a, 'tcx>) {\n+    pub fn storage_live(&self, bx: &Builder<'a, 'll, 'tcx>) {\n         bx.lifetime_start(self.llval, self.layout.size);\n     }\n \n-    pub fn storage_dead(&self, bx: &Builder<'a, 'tcx>) {\n+    pub fn storage_dead(&self, bx: &Builder<'a, 'll, 'tcx>) {\n         bx.lifetime_end(self.llval, self.layout.size);\n     }\n }\n \n-impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n+impl FunctionCx<'a, 'll, 'tcx> {\n     pub fn codegen_place(&mut self,\n-                        bx: &Builder<'a, 'tcx>,\n+                        bx: &Builder<'a, 'll, 'tcx>,\n                         place: &mir::Place<'tcx>)\n-                        -> PlaceRef<'tcx> {\n+                        -> PlaceRef<'ll, 'tcx> {\n         debug!(\"codegen_place(place={:?})\", place);\n \n         let cx = bx.cx;\n@@ -513,9 +505,8 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n                         subslice.layout = bx.cx.layout_of(self.monomorphize(&projected_ty));\n \n                         if subslice.layout.is_unsized() {\n-                            assert!(cg_base.has_extra());\n-                            subslice.llextra = bx.sub(cg_base.llextra,\n-                                C_usize(bx.cx, (from as u64) + (to as u64)));\n+                            subslice.llextra = Some(bx.sub(cg_base.llextra.unwrap(),\n+                                C_usize(bx.cx, (from as u64) + (to as u64))));\n                         }\n \n                         // Cast the place pointer type to the new"}, {"sha": "02b5c27840eabbcf4461fac8b47187952882accf", "filename": "src/librustc_codegen_llvm/mir/rvalue.rs", "status": "modified", "additions": 48, "deletions": 44, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/f89817997ac0aa100bf91997194ad85a7e59f743/src%2Flibrustc_codegen_llvm%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f89817997ac0aa100bf91997194ad85a7e59f743/src%2Flibrustc_codegen_llvm%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Frvalue.rs?ref=f89817997ac0aa100bf91997194ad85a7e59f743", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use llvm::{self, ValueRef};\n+use llvm;\n use rustc::ty::{self, Ty};\n use rustc::ty::cast::{CastTy, IntTy};\n use rustc::ty::layout::{self, LayoutOf};\n@@ -32,15 +32,15 @@ use super::{FunctionCx, LocalRef};\n use super::operand::{OperandRef, OperandValue};\n use super::place::PlaceRef;\n \n-impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n+impl FunctionCx<'a, 'll, 'tcx> {\n     pub fn codegen_rvalue(&mut self,\n-                        bx: Builder<'a, 'tcx>,\n-                        dest: PlaceRef<'tcx>,\n+                        bx: Builder<'a, 'll, 'tcx>,\n+                        dest: PlaceRef<'ll, 'tcx>,\n                         rvalue: &mir::Rvalue<'tcx>)\n-                        -> Builder<'a, 'tcx>\n+                        -> Builder<'a, 'll, 'tcx>\n     {\n         debug!(\"codegen_rvalue(dest.llval={:?}, rvalue={:?})\",\n-               Value(dest.llval), rvalue);\n+               dest.llval, rvalue);\n \n         match *rvalue {\n            mir::Rvalue::Use(ref operand) => {\n@@ -176,9 +176,9 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n     }\n \n     pub fn codegen_rvalue_operand(&mut self,\n-                                bx: Builder<'a, 'tcx>,\n+                                bx: Builder<'a, 'll, 'tcx>,\n                                 rvalue: &mir::Rvalue<'tcx>)\n-                                -> (Builder<'a, 'tcx>, OperandRef<'tcx>)\n+                                -> (Builder<'a, 'll, 'tcx>, OperandRef<'ll, 'tcx>)\n     {\n         assert!(self.rvalue_creates_operand(rvalue), \"cannot codegen {:?} to operand\", rvalue);\n \n@@ -371,7 +371,7 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n                 let val = if !bx.cx.type_has_metadata(ty) {\n                     OperandValue::Immediate(cg_place.llval)\n                 } else {\n-                    OperandValue::Pair(cg_place.llval, cg_place.llextra)\n+                    OperandValue::Pair(cg_place.llval, cg_place.llextra.unwrap())\n                 };\n                 (bx, OperandRef {\n                     val,\n@@ -511,10 +511,11 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n         }\n     }\n \n-    fn evaluate_array_len(&mut self,\n-                          bx: &Builder<'a, 'tcx>,\n-                          place: &mir::Place<'tcx>) -> ValueRef\n-    {\n+    fn evaluate_array_len(\n+        &mut self,\n+        bx: &Builder<'a, 'll, 'tcx>,\n+        place: &mir::Place<'tcx>,\n+    ) -> &'ll Value {\n         // ZST are passed as operands and require special handling\n         // because codegen_place() panics if Local is operand.\n         if let mir::Place::Local(index) = *place {\n@@ -530,12 +531,14 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n         return cg_value.len(bx.cx);\n     }\n \n-    pub fn codegen_scalar_binop(&mut self,\n-                              bx: &Builder<'a, 'tcx>,\n-                              op: mir::BinOp,\n-                              lhs: ValueRef,\n-                              rhs: ValueRef,\n-                              input_ty: Ty<'tcx>) -> ValueRef {\n+    pub fn codegen_scalar_binop(\n+        &mut self,\n+        bx: &Builder<'a, 'll, 'tcx>,\n+        op: mir::BinOp,\n+        lhs: &'ll Value,\n+        rhs: &'ll Value,\n+        input_ty: Ty<'tcx>,\n+    ) -> &'ll Value {\n         let is_float = input_ty.is_fp();\n         let is_signed = input_ty.is_signed();\n         let is_nil = input_ty.is_nil();\n@@ -596,15 +599,16 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n         }\n     }\n \n-    pub fn codegen_fat_ptr_binop(&mut self,\n-                               bx: &Builder<'a, 'tcx>,\n-                               op: mir::BinOp,\n-                               lhs_addr: ValueRef,\n-                               lhs_extra: ValueRef,\n-                               rhs_addr: ValueRef,\n-                               rhs_extra: ValueRef,\n-                               _input_ty: Ty<'tcx>)\n-                               -> ValueRef {\n+    pub fn codegen_fat_ptr_binop(\n+        &mut self,\n+        bx: &Builder<'a, 'll, 'tcx>,\n+        op: mir::BinOp,\n+        lhs_addr: &'ll Value,\n+        lhs_extra: &'ll Value,\n+        rhs_addr: &'ll Value,\n+        rhs_extra: &'ll Value,\n+        _input_ty: Ty<'tcx>,\n+    ) -> &'ll Value {\n         match op {\n             mir::BinOp::Eq => {\n                 bx.and(\n@@ -644,11 +648,11 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n     }\n \n     pub fn codegen_scalar_checked_binop(&mut self,\n-                                      bx: &Builder<'a, 'tcx>,\n+                                      bx: &Builder<'a, 'll, 'tcx>,\n                                       op: mir::BinOp,\n-                                      lhs: ValueRef,\n-                                      rhs: ValueRef,\n-                                      input_ty: Ty<'tcx>) -> OperandValue {\n+                                      lhs: &'ll Value,\n+                                      rhs: &'ll Value,\n+                                      input_ty: Ty<'tcx>) -> OperandValue<'ll> {\n         // This case can currently arise only from functions marked\n         // with #[rustc_inherit_overflow_checks] and inlined from\n         // another crate (mostly core::num generic/#[inline] fns),\n@@ -721,7 +725,7 @@ enum OverflowOp {\n     Add, Sub, Mul\n }\n \n-fn get_overflow_intrinsic(oop: OverflowOp, bx: &Builder, ty: Ty) -> ValueRef {\n+fn get_overflow_intrinsic(oop: OverflowOp, bx: &Builder<'_, 'll, '_>, ty: Ty) -> &'ll Value {\n     use syntax::ast::IntTy::*;\n     use syntax::ast::UintTy::*;\n     use rustc::ty::{TyInt, TyUint};\n@@ -796,11 +800,11 @@ fn get_overflow_intrinsic(oop: OverflowOp, bx: &Builder, ty: Ty) -> ValueRef {\n     bx.cx.get_intrinsic(&name)\n }\n \n-fn cast_int_to_float(bx: &Builder,\n+fn cast_int_to_float(bx: &Builder<'_, 'll, '_>,\n                      signed: bool,\n-                     x: ValueRef,\n-                     int_ty: Type,\n-                     float_ty: Type) -> ValueRef {\n+                     x: &'ll Value,\n+                     int_ty: &'ll Type,\n+                     float_ty: &'ll Type) -> &'ll Value {\n     // Most integer types, even i128, fit into [-f32::MAX, f32::MAX] after rounding.\n     // It's only u128 -> f32 that can cause overflows (i.e., should yield infinity).\n     // LLVM's uitofp produces undef in those cases, so we manually check for that case.\n@@ -826,11 +830,11 @@ fn cast_int_to_float(bx: &Builder,\n     }\n }\n \n-fn cast_float_to_int(bx: &Builder,\n+fn cast_float_to_int(bx: &Builder<'_, 'll, '_>,\n                      signed: bool,\n-                     x: ValueRef,\n-                     float_ty: Type,\n-                     int_ty: Type) -> ValueRef {\n+                     x: &'ll Value,\n+                     float_ty: &'ll Type,\n+                     int_ty: &'ll Type) -> &'ll Value {\n     let fptosui_result = if signed {\n         bx.fptosi(x, int_ty)\n     } else {\n@@ -859,22 +863,22 @@ fn cast_float_to_int(bx: &Builder,\n     // On the other hand, f_max works even if int_ty::MAX is greater than float_ty::MAX. Because\n     // we're rounding towards zero, we just get float_ty::MAX (which is always an integer).\n     // This already happens today with u128::MAX = 2^128 - 1 > f32::MAX.\n-    fn compute_clamp_bounds<F: Float>(signed: bool, int_ty: Type) -> (u128, u128) {\n+    fn compute_clamp_bounds<F: Float>(signed: bool, int_ty: &Type) -> (u128, u128) {\n         let rounded_min = F::from_i128_r(int_min(signed, int_ty), Round::TowardZero);\n         assert_eq!(rounded_min.status, Status::OK);\n         let rounded_max = F::from_u128_r(int_max(signed, int_ty), Round::TowardZero);\n         assert!(rounded_max.value.is_finite());\n         (rounded_min.value.to_bits(), rounded_max.value.to_bits())\n     }\n-    fn int_max(signed: bool, int_ty: Type) -> u128 {\n+    fn int_max(signed: bool, int_ty: &Type) -> u128 {\n         let shift_amount = 128 - int_ty.int_width();\n         if signed {\n             i128::MAX as u128 >> shift_amount\n         } else {\n             u128::MAX >> shift_amount\n         }\n     }\n-    fn int_min(signed: bool, int_ty: Type) -> i128 {\n+    fn int_min(signed: bool, int_ty: &Type) -> i128 {\n         if signed {\n             i128::MIN >> (128 - int_ty.int_width())\n         } else {"}, {"sha": "06340a3e5d8b43f01e898c16bc782d94c00e7005", "filename": "src/librustc_codegen_llvm/mir/statement.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f89817997ac0aa100bf91997194ad85a7e59f743/src%2Flibrustc_codegen_llvm%2Fmir%2Fstatement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f89817997ac0aa100bf91997194ad85a7e59f743/src%2Flibrustc_codegen_llvm%2Fmir%2Fstatement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fstatement.rs?ref=f89817997ac0aa100bf91997194ad85a7e59f743", "patch": "@@ -16,11 +16,11 @@ use builder::Builder;\n use super::FunctionCx;\n use super::LocalRef;\n \n-impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n+impl FunctionCx<'a, 'll, 'tcx> {\n     pub fn codegen_statement(&mut self,\n-                           bx: Builder<'a, 'tcx>,\n+                           bx: Builder<'a, 'll, 'tcx>,\n                            statement: &mir::Statement<'tcx>)\n-                           -> Builder<'a, 'tcx> {\n+                           -> Builder<'a, 'll, 'tcx> {\n         debug!(\"codegen_statement(statement={:?})\", statement);\n \n         self.set_debug_loc(&bx, statement.source_info);"}, {"sha": "9fa7cc46aee5eb10387549ef5b5ee34194ef308f", "filename": "src/librustc_codegen_llvm/type_.rs", "status": "modified", "additions": 125, "deletions": 109, "changes": 234, "blob_url": "https://github.com/rust-lang/rust/blob/f89817997ac0aa100bf91997194ad85a7e59f743/src%2Flibrustc_codegen_llvm%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f89817997ac0aa100bf91997194ad85a7e59f743/src%2Flibrustc_codegen_llvm%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Ftype_.rs?ref=f89817997ac0aa100bf91997194ad85a7e59f743", "patch": "@@ -10,9 +10,10 @@\n \n #![allow(non_upper_case_globals)]\n \n+pub use llvm::Type;\n+\n use llvm;\n-use llvm::{ContextRef, TypeRef, Bool, False, True, TypeKind};\n-use llvm::{Float, Double, X86_FP80, PPC_FP128, FP128};\n+use llvm::{Bool, False, True, TypeKind};\n \n use context::CodegenCx;\n \n@@ -21,122 +22,125 @@ use rustc::ty::layout::{self, Align, Size};\n \n use std::ffi::CString;\n use std::fmt;\n-use std::mem;\n-use std::ptr;\n \n use libc::c_uint;\n \n-#[derive(Clone, Copy, PartialEq)]\n-#[repr(C)]\n-pub struct Type {\n-    rf: TypeRef\n+impl PartialEq for Type {\n+    fn eq(&self, other: &Self) -> bool {\n+        self as *const _ == other as *const _\n+    }\n }\n \n impl fmt::Debug for Type {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         f.write_str(&llvm::build_string(|s| unsafe {\n-            llvm::LLVMRustWriteTypeToString(self.to_ref(), s);\n+            llvm::LLVMRustWriteTypeToString(self, s);\n         }).expect(\"non-UTF8 type description from LLVM\"))\n     }\n }\n \n-macro_rules! ty {\n-    ($e:expr) => ( Type::from_ref(unsafe { $e }))\n-}\n-\n-/// Wrapper for LLVM TypeRef\n impl Type {\n-    #[inline(always)]\n-    pub fn from_ref(r: TypeRef) -> Type {\n-        Type {\n-            rf: r\n+    pub fn void(cx: &CodegenCx<'ll, '_>) -> &'ll Type {\n+        unsafe {\n+            llvm::LLVMVoidTypeInContext(cx.llcx)\n         }\n     }\n \n-    #[inline(always)] // So it doesn't kill --opt-level=0 builds of the compiler\n-    pub fn to_ref(&self) -> TypeRef {\n-        self.rf\n-    }\n-\n-    pub fn to_ref_slice(slice: &[Type]) -> &[TypeRef] {\n-        unsafe { mem::transmute(slice) }\n-    }\n-\n-    pub fn void(cx: &CodegenCx) -> Type {\n-        ty!(llvm::LLVMVoidTypeInContext(cx.llcx))\n+    pub fn metadata(cx: &CodegenCx<'ll, '_>) -> &'ll Type {\n+        unsafe {\n+            llvm::LLVMRustMetadataTypeInContext(cx.llcx)\n+        }\n     }\n \n-    pub fn metadata(cx: &CodegenCx) -> Type {\n-        ty!(llvm::LLVMRustMetadataTypeInContext(cx.llcx))\n+    pub fn i1(cx: &CodegenCx<'ll, '_>) -> &'ll Type {\n+        unsafe {\n+            llvm::LLVMInt1TypeInContext(cx.llcx)\n+        }\n     }\n \n-    pub fn i1(cx: &CodegenCx) -> Type {\n-        ty!(llvm::LLVMInt1TypeInContext(cx.llcx))\n+    pub fn i8(cx: &CodegenCx<'ll, '_>) -> &'ll Type {\n+        unsafe {\n+            llvm::LLVMInt8TypeInContext(cx.llcx)\n+        }\n     }\n \n-    pub fn i8(cx: &CodegenCx) -> Type {\n-        ty!(llvm::LLVMInt8TypeInContext(cx.llcx))\n+    pub fn i8_llcx(llcx: &llvm::Context) -> &Type {\n+        unsafe {\n+            llvm::LLVMInt8TypeInContext(llcx)\n+        }\n     }\n \n-    pub fn i8_llcx(llcx: ContextRef) -> Type {\n-        ty!(llvm::LLVMInt8TypeInContext(llcx))\n+    pub fn i16(cx: &CodegenCx<'ll, '_>) -> &'ll Type {\n+        unsafe {\n+            llvm::LLVMInt16TypeInContext(cx.llcx)\n+        }\n     }\n \n-    pub fn i16(cx: &CodegenCx) -> Type {\n-        ty!(llvm::LLVMInt16TypeInContext(cx.llcx))\n+    pub fn i32(cx: &CodegenCx<'ll, '_>) -> &'ll Type {\n+        unsafe {\n+            llvm::LLVMInt32TypeInContext(cx.llcx)\n+        }\n     }\n \n-    pub fn i32(cx: &CodegenCx) -> Type {\n-        ty!(llvm::LLVMInt32TypeInContext(cx.llcx))\n+    pub fn i64(cx: &CodegenCx<'ll, '_>) -> &'ll Type {\n+        unsafe {\n+            llvm::LLVMInt64TypeInContext(cx.llcx)\n+        }\n     }\n \n-    pub fn i64(cx: &CodegenCx) -> Type {\n-        ty!(llvm::LLVMInt64TypeInContext(cx.llcx))\n+    pub fn i128(cx: &CodegenCx<'ll, '_>) -> &'ll Type {\n+        unsafe {\n+            llvm::LLVMIntTypeInContext(cx.llcx, 128)\n+        }\n     }\n \n-    pub fn i128(cx: &CodegenCx) -> Type {\n-        ty!(llvm::LLVMIntTypeInContext(cx.llcx, 128))\n+    // Creates an integer type with the given number of bits, e.g. i24\n+    pub fn ix(cx: &CodegenCx<'ll, '_>, num_bits: u64) -> &'ll Type {\n+        unsafe {\n+            llvm::LLVMIntTypeInContext(cx.llcx, num_bits as c_uint)\n+        }\n     }\n \n     // Creates an integer type with the given number of bits, e.g. i24\n-    pub fn ix(cx: &CodegenCx, num_bits: u64) -> Type {\n-        ty!(llvm::LLVMIntTypeInContext(cx.llcx, num_bits as c_uint))\n+    pub fn ix_llcx(llcx: &llvm::Context, num_bits: u64) -> &Type {\n+        unsafe {\n+            llvm::LLVMIntTypeInContext(llcx, num_bits as c_uint)\n+        }\n     }\n \n-    pub fn f32(cx: &CodegenCx) -> Type {\n-        ty!(llvm::LLVMFloatTypeInContext(cx.llcx))\n+    pub fn f32(cx: &CodegenCx<'ll, '_>) -> &'ll Type {\n+        unsafe {\n+            llvm::LLVMFloatTypeInContext(cx.llcx)\n+        }\n     }\n \n-    pub fn f64(cx: &CodegenCx) -> Type {\n-        ty!(llvm::LLVMDoubleTypeInContext(cx.llcx))\n+    pub fn f64(cx: &CodegenCx<'ll, '_>) -> &'ll Type {\n+        unsafe {\n+            llvm::LLVMDoubleTypeInContext(cx.llcx)\n+        }\n     }\n \n-    pub fn bool(cx: &CodegenCx) -> Type {\n+    pub fn bool(cx: &CodegenCx<'ll, '_>) -> &'ll Type {\n         Type::i8(cx)\n     }\n \n-    pub fn char(cx: &CodegenCx) -> Type {\n+    pub fn char(cx: &CodegenCx<'ll, '_>) -> &'ll Type {\n         Type::i32(cx)\n     }\n \n-    pub fn i8p(cx: &CodegenCx) -> Type {\n+    pub fn i8p(cx: &CodegenCx<'ll, '_>) -> &'ll Type {\n         Type::i8(cx).ptr_to()\n     }\n \n-    pub fn i8p_llcx(llcx: ContextRef) -> Type {\n+    pub fn i8p_llcx(llcx: &llvm::Context) -> &Type {\n         Type::i8_llcx(llcx).ptr_to()\n     }\n \n-    pub fn isize(cx: &CodegenCx) -> Type {\n-        match &cx.tcx.sess.target.target.target_pointer_width[..] {\n-            \"16\" => Type::i16(cx),\n-            \"32\" => Type::i32(cx),\n-            \"64\" => Type::i64(cx),\n-            tws => bug!(\"Unsupported target word size for int: {}\", tws),\n-        }\n+    pub fn isize(cx: &CodegenCx<'ll, '_>) -> &'ll Type {\n+        cx.isize_ty\n     }\n \n-    pub fn c_int(cx: &CodegenCx) -> Type {\n+    pub fn c_int(cx: &CodegenCx<'ll, '_>) -> &'ll Type {\n         match &cx.tcx.sess.target.target.target_c_int_width[..] {\n             \"16\" => Type::i16(cx),\n             \"32\" => Type::i32(cx),\n@@ -145,7 +149,7 @@ impl Type {\n         }\n     }\n \n-    pub fn int_from_ty(cx: &CodegenCx, t: ast::IntTy) -> Type {\n+    pub fn int_from_ty(cx: &CodegenCx<'ll, '_>, t: ast::IntTy) -> &'ll Type {\n         match t {\n             ast::IntTy::Isize => cx.isize_ty,\n             ast::IntTy::I8 => Type::i8(cx),\n@@ -156,7 +160,7 @@ impl Type {\n         }\n     }\n \n-    pub fn uint_from_ty(cx: &CodegenCx, t: ast::UintTy) -> Type {\n+    pub fn uint_from_ty(cx: &CodegenCx<'ll, '_>, t: ast::UintTy) -> &'ll Type {\n         match t {\n             ast::UintTy::Usize => cx.isize_ty,\n             ast::UintTy::U8 => Type::i8(cx),\n@@ -167,105 +171,115 @@ impl Type {\n         }\n     }\n \n-    pub fn float_from_ty(cx: &CodegenCx, t: ast::FloatTy) -> Type {\n+    pub fn float_from_ty(cx: &CodegenCx<'ll, '_>, t: ast::FloatTy) -> &'ll Type {\n         match t {\n             ast::FloatTy::F32 => Type::f32(cx),\n             ast::FloatTy::F64 => Type::f64(cx),\n         }\n     }\n \n-    pub fn func(args: &[Type], ret: &Type) -> Type {\n-        let slice: &[TypeRef] = Type::to_ref_slice(args);\n-        ty!(llvm::LLVMFunctionType(ret.to_ref(), slice.as_ptr(),\n-                                   args.len() as c_uint, False))\n+    pub fn func(args: &[&'ll Type], ret: &'ll Type) -> &'ll Type {\n+        unsafe {\n+            llvm::LLVMFunctionType(ret, args.as_ptr(),\n+                                   args.len() as c_uint, False)\n+        }\n     }\n \n-    pub fn variadic_func(args: &[Type], ret: &Type) -> Type {\n-        let slice: &[TypeRef] = Type::to_ref_slice(args);\n-        ty!(llvm::LLVMFunctionType(ret.to_ref(), slice.as_ptr(),\n-                                   args.len() as c_uint, True))\n+    pub fn variadic_func(args: &[&'ll Type], ret: &'ll Type) -> &'ll Type {\n+        unsafe {\n+            llvm::LLVMFunctionType(ret, args.as_ptr(),\n+                                   args.len() as c_uint, True)\n+        }\n     }\n \n-    pub fn struct_(cx: &CodegenCx, els: &[Type], packed: bool) -> Type {\n-        let els: &[TypeRef] = Type::to_ref_slice(els);\n-        ty!(llvm::LLVMStructTypeInContext(cx.llcx, els.as_ptr(),\n+    pub fn struct_(cx: &CodegenCx<'ll, '_>, els: &[&'ll Type], packed: bool) -> &'ll Type {\n+        unsafe {\n+            llvm::LLVMStructTypeInContext(cx.llcx, els.as_ptr(),\n                                           els.len() as c_uint,\n-                                          packed as Bool))\n+                                          packed as Bool)\n+        }\n     }\n \n-    pub fn named_struct(cx: &CodegenCx, name: &str) -> Type {\n+    pub fn named_struct(cx: &CodegenCx<'ll, '_>, name: &str) -> &'ll Type {\n         let name = CString::new(name).unwrap();\n-        ty!(llvm::LLVMStructCreateNamed(cx.llcx, name.as_ptr()))\n+        unsafe {\n+            llvm::LLVMStructCreateNamed(cx.llcx, name.as_ptr())\n+        }\n     }\n \n \n-    pub fn array(ty: &Type, len: u64) -> Type {\n-        ty!(llvm::LLVMRustArrayType(ty.to_ref(), len))\n+    pub fn array(ty: &Type, len: u64) -> &Type {\n+        unsafe {\n+            llvm::LLVMRustArrayType(ty, len)\n+        }\n     }\n \n-    pub fn vector(ty: &Type, len: u64) -> Type {\n-        ty!(llvm::LLVMVectorType(ty.to_ref(), len as c_uint))\n+    pub fn vector(ty: &Type, len: u64) -> &Type {\n+        unsafe {\n+            llvm::LLVMVectorType(ty, len as c_uint)\n+        }\n     }\n \n     pub fn kind(&self) -> TypeKind {\n         unsafe {\n-            llvm::LLVMRustGetTypeKind(self.to_ref())\n+            llvm::LLVMRustGetTypeKind(self)\n         }\n     }\n \n-    pub fn set_struct_body(&mut self, els: &[Type], packed: bool) {\n-        let slice: &[TypeRef] = Type::to_ref_slice(els);\n+    pub fn set_struct_body(&'ll self, els: &[&'ll Type], packed: bool) {\n         unsafe {\n-            llvm::LLVMStructSetBody(self.to_ref(), slice.as_ptr(),\n+            llvm::LLVMStructSetBody(self, els.as_ptr(),\n                                     els.len() as c_uint, packed as Bool)\n         }\n     }\n \n-    pub fn ptr_to(&self) -> Type {\n-        ty!(llvm::LLVMPointerType(self.to_ref(), 0))\n+    pub fn ptr_to(&self) -> &Type {\n+        unsafe {\n+            llvm::LLVMPointerType(self, 0)\n+        }\n     }\n \n-    pub fn element_type(&self) -> Type {\n+    pub fn element_type(&self) -> &Type {\n         unsafe {\n-            Type::from_ref(llvm::LLVMGetElementType(self.to_ref()))\n+            llvm::LLVMGetElementType(self)\n         }\n     }\n \n     /// Return the number of elements in `self` if it is a LLVM vector type.\n     pub fn vector_length(&self) -> usize {\n         unsafe {\n-            llvm::LLVMGetVectorSize(self.to_ref()) as usize\n+            llvm::LLVMGetVectorSize(self) as usize\n         }\n     }\n \n-    pub fn func_params(&self) -> Vec<Type> {\n+    pub fn func_params(&self) -> Vec<&Type> {\n         unsafe {\n-            let n_args = llvm::LLVMCountParamTypes(self.to_ref()) as usize;\n-            let mut args = vec![Type { rf: ptr::null_mut() }; n_args];\n-            llvm::LLVMGetParamTypes(self.to_ref(),\n-                                    args.as_mut_ptr() as *mut TypeRef);\n+            let n_args = llvm::LLVMCountParamTypes(self) as usize;\n+            let mut args = Vec::with_capacity(n_args);\n+            llvm::LLVMGetParamTypes(self, args.as_mut_ptr());\n+            args.set_len(n_args);\n             args\n         }\n     }\n \n     pub fn float_width(&self) -> usize {\n         match self.kind() {\n-            Float => 32,\n-            Double => 64,\n-            X86_FP80 => 80,\n-            FP128 | PPC_FP128 => 128,\n+            TypeKind::Float => 32,\n+            TypeKind::Double => 64,\n+            TypeKind::X86_FP80 => 80,\n+            TypeKind::FP128 | TypeKind::PPC_FP128 => 128,\n             _ => bug!(\"llvm_float_width called on a non-float type\")\n         }\n     }\n \n     /// Retrieve the bit width of the integer type `self`.\n     pub fn int_width(&self) -> u64 {\n         unsafe {\n-            llvm::LLVMGetIntTypeWidth(self.to_ref()) as u64\n+            llvm::LLVMGetIntTypeWidth(self) as u64\n         }\n     }\n \n-    pub fn from_integer(cx: &CodegenCx, i: layout::Integer) -> Type {\n+    pub fn from_integer(cx: &CodegenCx<'ll, '_>, i: layout::Integer) -> &'ll Type {\n         use rustc::ty::layout::Integer::*;\n         match i {\n             I8 => Type::i8(cx),\n@@ -278,23 +292,25 @@ impl Type {\n \n     /// Return a LLVM type that has at most the required alignment,\n     /// as a conservative approximation for unknown pointee types.\n-    pub fn pointee_for_abi_align(cx: &CodegenCx, align: Align) -> Type {\n+    pub fn pointee_for_abi_align(cx: &CodegenCx<'ll, '_>, align: Align) -> &'ll Type {\n         // FIXME(eddyb) We could find a better approximation if ity.align < align.\n         let ity = layout::Integer::approximate_abi_align(cx, align);\n         Type::from_integer(cx, ity)\n     }\n \n     /// Return a LLVM type that has at most the required alignment,\n     /// and exactly the required size, as a best-effort padding array.\n-    pub fn padding_filler(cx: &CodegenCx, size: Size, align: Align) -> Type {\n+    pub fn padding_filler(cx: &CodegenCx<'ll, '_>, size: Size, align: Align) -> &'ll Type {\n         let unit = layout::Integer::approximate_abi_align(cx, align);\n         let size = size.bytes();\n         let unit_size = unit.size().bytes();\n         assert_eq!(size % unit_size, 0);\n-        Type::array(&Type::from_integer(cx, unit), size / unit_size)\n+        Type::array(Type::from_integer(cx, unit), size / unit_size)\n     }\n \n-    pub fn x86_mmx(cx: &CodegenCx) -> Type {\n-        ty!(llvm::LLVMX86MMXTypeInContext(cx.llcx))\n+    pub fn x86_mmx(cx: &CodegenCx<'ll, '_>) -> &'ll Type {\n+        unsafe {\n+            llvm::LLVMX86MMXTypeInContext(cx.llcx)\n+        }\n     }\n }"}, {"sha": "5fd4f15acd1574c719cda4a117994e0c2bd0f3b6", "filename": "src/librustc_codegen_llvm/type_of.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/f89817997ac0aa100bf91997194ad85a7e59f743/src%2Flibrustc_codegen_llvm%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f89817997ac0aa100bf91997194ad85a7e59f743/src%2Flibrustc_codegen_llvm%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Ftype_of.rs?ref=f89817997ac0aa100bf91997194ad85a7e59f743", "patch": "@@ -23,8 +23,8 @@ use std::fmt::Write;\n \n fn uncached_llvm_type<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                                 layout: TyLayout<'tcx>,\n-                                defer: &mut Option<(Type, TyLayout<'tcx>)>)\n-                                -> Type {\n+                                defer: &mut Option<(&'a Type, TyLayout<'tcx>)>)\n+                                -> &'a Type {\n     match layout.abi {\n         layout::Abi::Scalar(_) => bug!(\"handled elsewhere\"),\n         layout::Abi::Vector { ref element, count } => {\n@@ -42,7 +42,7 @@ fn uncached_llvm_type<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                 return Type::x86_mmx(cx)\n             } else {\n                 let element = layout.scalar_llvm_type_at(cx, element, Size::ZERO);\n-                return Type::vector(&element, count);\n+                return Type::vector(element, count);\n             }\n         }\n         layout::Abi::ScalarPair(..) => {\n@@ -96,7 +96,7 @@ fn uncached_llvm_type<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n             }\n         }\n         layout::FieldPlacement::Array { count, .. } => {\n-            Type::array(&layout.field(cx, 0).llvm_type(cx), count)\n+            Type::array(layout.field(cx, 0).llvm_type(cx), count)\n         }\n         layout::FieldPlacement::Arbitrary { .. } => {\n             match name {\n@@ -116,14 +116,14 @@ fn uncached_llvm_type<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n \n fn struct_llfields<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                              layout: TyLayout<'tcx>)\n-                             -> (Vec<Type>, bool) {\n+                             -> (Vec<&'a Type>, bool) {\n     debug!(\"struct_llfields: {:#?}\", layout);\n     let field_count = layout.fields.count();\n \n     let mut packed = false;\n     let mut offset = Size::ZERO;\n     let mut prev_align = layout.align;\n-    let mut result: Vec<Type> = Vec::with_capacity(1 + field_count * 2);\n+    let mut result: Vec<_> = Vec::with_capacity(1 + field_count * 2);\n     for i in layout.fields.index_by_increasing_offset() {\n         let field = layout.field(cx, i);\n         packed |= layout.align.abi() < field.align.abi();\n@@ -201,12 +201,12 @@ pub struct PointeeInfo {\n pub trait LayoutLlvmExt<'tcx> {\n     fn is_llvm_immediate(&self) -> bool;\n     fn is_llvm_scalar_pair<'a>(&self) -> bool;\n-    fn llvm_type<'a>(&self, cx: &CodegenCx<'a, 'tcx>) -> Type;\n-    fn immediate_llvm_type<'a>(&self, cx: &CodegenCx<'a, 'tcx>) -> Type;\n+    fn llvm_type<'a>(&self, cx: &CodegenCx<'a, 'tcx>) -> &'a Type;\n+    fn immediate_llvm_type<'a>(&self, cx: &CodegenCx<'a, 'tcx>) -> &'a Type;\n     fn scalar_llvm_type_at<'a>(&self, cx: &CodegenCx<'a, 'tcx>,\n-                               scalar: &layout::Scalar, offset: Size) -> Type;\n+                               scalar: &layout::Scalar, offset: Size) -> &'a Type;\n     fn scalar_pair_element_llvm_type<'a>(&self, cx: &CodegenCx<'a, 'tcx>,\n-                                         index: usize, immediate: bool) -> Type;\n+                                         index: usize, immediate: bool) -> &'a Type;\n     fn llvm_field_index(&self, index: usize) -> u64;\n     fn pointee_info_at<'a>(&self, cx: &CodegenCx<'a, 'tcx>, offset: Size)\n                            -> Option<PointeeInfo>;\n@@ -244,7 +244,7 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n     /// with the inner-most trailing unsized field using the \"minimal unit\"\n     /// of that field's type - this is useful for taking the address of\n     /// that field and ensuring the struct has the right alignment.\n-    fn llvm_type<'a>(&self, cx: &CodegenCx<'a, 'tcx>) -> Type {\n+    fn llvm_type<'a>(&self, cx: &CodegenCx<'a, 'tcx>) -> &'a Type {\n         if let layout::Abi::Scalar(ref scalar) = self.abi {\n             // Use a different cache for scalars because pointers to DSTs\n             // can be either fat or thin (data pointers of fat pointers).\n@@ -304,15 +304,15 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n \n         cx.lltypes.borrow_mut().insert((self.ty, variant_index), llty);\n \n-        if let Some((mut llty, layout)) = defer {\n+        if let Some((llty, layout)) = defer {\n             let (llfields, packed) = struct_llfields(cx, layout);\n             llty.set_struct_body(&llfields, packed)\n         }\n \n         llty\n     }\n \n-    fn immediate_llvm_type<'a>(&self, cx: &CodegenCx<'a, 'tcx>) -> Type {\n+    fn immediate_llvm_type<'a>(&self, cx: &CodegenCx<'a, 'tcx>) -> &'a Type {\n         if let layout::Abi::Scalar(ref scalar) = self.abi {\n             if scalar.is_bool() {\n                 return Type::i1(cx);\n@@ -322,7 +322,7 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n     }\n \n     fn scalar_llvm_type_at<'a>(&self, cx: &CodegenCx<'a, 'tcx>,\n-                               scalar: &layout::Scalar, offset: Size) -> Type {\n+                               scalar: &layout::Scalar, offset: Size) -> &'a Type {\n         match scalar.value {\n             layout::Int(i, _) => Type::from_integer(cx, i),\n             layout::Float(FloatTy::F32) => Type::f32(cx),\n@@ -340,7 +340,7 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n     }\n \n     fn scalar_pair_element_llvm_type<'a>(&self, cx: &CodegenCx<'a, 'tcx>,\n-                                         index: usize, immediate: bool) -> Type {\n+                                         index: usize, immediate: bool) -> &'a Type {\n         // HACK(eddyb) special-case fat pointers until LLVM removes\n         // pointee types, to avoid bitcasting every `OperandRef::deref`.\n         match self.ty.sty {"}, {"sha": "3328948c2951e5ce18e8b500b4ce9e1189c7f6a9", "filename": "src/librustc_codegen_llvm/value.rs", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/f89817997ac0aa100bf91997194ad85a7e59f743/src%2Flibrustc_codegen_llvm%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f89817997ac0aa100bf91997194ad85a7e59f743/src%2Flibrustc_codegen_llvm%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fvalue.rs?ref=f89817997ac0aa100bf91997194ad85a7e59f743", "patch": "@@ -8,17 +8,32 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+pub use llvm::Value;\n+\n use llvm;\n \n use std::fmt;\n+use std::hash::{Hash, Hasher};\n+\n+impl PartialEq for Value {\n+    fn eq(&self, other: &Self) -> bool {\n+        self as *const _ == other as *const _\n+    }\n+}\n+\n+impl Eq for Value {}\n+\n+impl Hash for Value {\n+    fn hash<H: Hasher>(&self, hasher: &mut H) {\n+        (self as *const Self).hash(hasher);\n+    }\n+}\n \n-#[derive(Copy, Clone, PartialEq)]\n-pub struct Value(pub llvm::ValueRef);\n \n impl fmt::Debug for Value {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         f.write_str(&llvm::build_string(|s| unsafe {\n-            llvm::LLVMRustWriteValueToString(self.0, s);\n+            llvm::LLVMRustWriteValueToString(self, s);\n         }).expect(\"nun-UTF8 value description from LLVM\"))\n     }\n }"}, {"sha": "013badb71cc5ab8d1bfe7a965a639e56e3b906f1", "filename": "src/librustc_llvm/Cargo.toml", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f89817997ac0aa100bf91997194ad85a7e59f743/src%2Flibrustc_llvm%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f89817997ac0aa100bf91997194ad85a7e59f743/src%2Flibrustc_llvm%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2FCargo.toml?ref=f89817997ac0aa100bf91997194ad85a7e59f743", "patch": "@@ -12,11 +12,6 @@ path = \"lib.rs\"\n static-libstdcpp = []\n emscripten = []\n \n-[dependencies]\n-bitflags = \"1.0\"\n-libc = \"0.2\"\n-rustc_cratesio_shim = { path = \"../librustc_cratesio_shim\" }\n-\n [build-dependencies]\n build_helper = { path = \"../build_helper\" }\n cc = \"1.0.1\""}, {"sha": "5910e55def39690c3e6d5b6a19fedd97721d8010", "filename": "src/librustc_llvm/build.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f89817997ac0aa100bf91997194ad85a7e59f743/src%2Flibrustc_llvm%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f89817997ac0aa100bf91997194ad85a7e59f743/src%2Flibrustc_llvm%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Fbuild.rs?ref=f89817997ac0aa100bf91997194ad85a7e59f743", "patch": "@@ -271,5 +271,6 @@ fn main() {\n     if target.contains(\"windows-gnu\") {\n         println!(\"cargo:rustc-link-lib=static-nobundle=gcc_s\");\n         println!(\"cargo:rustc-link-lib=static-nobundle=pthread\");\n+        println!(\"cargo:rustc-link-lib=dylib=uuid\");\n     }\n }"}, {"sha": "8d04438eea29000edf06fbeb0b26af50010d19e2", "filename": "src/librustc_llvm/ffi.rs", "status": "removed", "additions": 0, "deletions": 1800, "changes": 1800, "blob_url": "https://github.com/rust-lang/rust/blob/ed8d14db99fc79909274454c02073bc5bd0c0df2/src%2Flibrustc_llvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed8d14db99fc79909274454c02073bc5bd0c0df2/src%2Flibrustc_llvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Fffi.rs?ref=ed8d14db99fc79909274454c02073bc5bd0c0df2", "patch": "@@ -1,1800 +0,0 @@\n-// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// FIXME: Rename 'DIGlobalVariable' to 'DIGlobalVariableExpression'\n-// once support for LLVM 3.9 is dropped.\n-//\n-// This method was changed in this LLVM patch:\n-// https://reviews.llvm.org/D26769\n-\n-use debuginfo::{DIBuilderRef, DIDescriptor, DIFile, DILexicalBlock, DISubprogram, DIType,\n-                DIBasicType, DIDerivedType, DICompositeType, DIScope, DIVariable,\n-                DIGlobalVariable, DIArray, DISubrange, DITemplateTypeParameter, DIEnumerator,\n-                DINameSpace, DIFlags};\n-\n-use libc::{c_uint, c_int, size_t, c_char};\n-use libc::{c_longlong, c_ulonglong, c_void};\n-\n-use RustStringRef;\n-\n-pub type Opcode = u32;\n-pub type Bool = c_uint;\n-\n-pub const True: Bool = 1 as Bool;\n-pub const False: Bool = 0 as Bool;\n-\n-#[derive(Copy, Clone, PartialEq)]\n-#[repr(C)]\n-pub enum LLVMRustResult {\n-    Success,\n-    Failure,\n-}\n-// Consts for the LLVM CallConv type, pre-cast to usize.\n-\n-/// LLVM CallingConv::ID. Should we wrap this?\n-#[derive(Copy, Clone, PartialEq, Debug)]\n-#[repr(C)]\n-pub enum CallConv {\n-    CCallConv = 0,\n-    FastCallConv = 8,\n-    ColdCallConv = 9,\n-    X86StdcallCallConv = 64,\n-    X86FastcallCallConv = 65,\n-    ArmAapcsCallConv = 67,\n-    Msp430Intr = 69,\n-    X86_ThisCall = 70,\n-    PtxKernel = 71,\n-    X86_64_SysV = 78,\n-    X86_64_Win64 = 79,\n-    X86_VectorCall = 80,\n-    X86_Intr = 83,\n-    AmdGpuKernel = 91,\n-}\n-\n-/// LLVMRustLinkage\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n-#[repr(C)]\n-pub enum Linkage {\n-    ExternalLinkage = 0,\n-    AvailableExternallyLinkage = 1,\n-    LinkOnceAnyLinkage = 2,\n-    LinkOnceODRLinkage = 3,\n-    WeakAnyLinkage = 4,\n-    WeakODRLinkage = 5,\n-    AppendingLinkage = 6,\n-    InternalLinkage = 7,\n-    PrivateLinkage = 8,\n-    ExternalWeakLinkage = 9,\n-    CommonLinkage = 10,\n-}\n-\n-// LLVMRustVisibility\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n-#[repr(C)]\n-pub enum Visibility {\n-    Default = 0,\n-    Hidden = 1,\n-    Protected = 2,\n-}\n-\n-/// LLVMDiagnosticSeverity\n-#[derive(Copy, Clone, Debug)]\n-#[repr(C)]\n-pub enum DiagnosticSeverity {\n-    Error = 0,\n-    Warning = 1,\n-    Remark = 2,\n-    Note = 3,\n-}\n-\n-/// LLVMDLLStorageClass\n-#[derive(Copy, Clone)]\n-#[repr(C)]\n-pub enum DLLStorageClass {\n-    Default = 0,\n-    DllImport = 1, // Function to be imported from DLL.\n-    DllExport = 2, // Function to be accessible from DLL.\n-}\n-\n-/// Matches LLVMRustAttribute in rustllvm.h\n-/// Semantically a subset of the C++ enum llvm::Attribute::AttrKind,\n-/// though it is not ABI compatible (since it's a C++ enum)\n-#[repr(C)]\n-#[derive(Copy, Clone, Debug)]\n-pub enum Attribute {\n-    AlwaysInline    = 0,\n-    ByVal           = 1,\n-    Cold            = 2,\n-    InlineHint      = 3,\n-    MinSize         = 4,\n-    Naked           = 5,\n-    NoAlias         = 6,\n-    NoCapture       = 7,\n-    NoInline        = 8,\n-    NonNull         = 9,\n-    NoRedZone       = 10,\n-    NoReturn        = 11,\n-    NoUnwind        = 12,\n-    OptimizeForSize = 13,\n-    ReadOnly        = 14,\n-    SExt            = 15,\n-    StructRet       = 16,\n-    UWTable         = 17,\n-    ZExt            = 18,\n-    InReg           = 19,\n-    SanitizeThread  = 20,\n-    SanitizeAddress = 21,\n-    SanitizeMemory  = 22,\n-}\n-\n-/// LLVMIntPredicate\n-#[derive(Copy, Clone)]\n-#[repr(C)]\n-pub enum IntPredicate {\n-    IntEQ = 32,\n-    IntNE = 33,\n-    IntUGT = 34,\n-    IntUGE = 35,\n-    IntULT = 36,\n-    IntULE = 37,\n-    IntSGT = 38,\n-    IntSGE = 39,\n-    IntSLT = 40,\n-    IntSLE = 41,\n-}\n-\n-/// LLVMRealPredicate\n-#[derive(Copy, Clone)]\n-#[repr(C)]\n-pub enum RealPredicate {\n-    RealPredicateFalse = 0,\n-    RealOEQ = 1,\n-    RealOGT = 2,\n-    RealOGE = 3,\n-    RealOLT = 4,\n-    RealOLE = 5,\n-    RealONE = 6,\n-    RealORD = 7,\n-    RealUNO = 8,\n-    RealUEQ = 9,\n-    RealUGT = 10,\n-    RealUGE = 11,\n-    RealULT = 12,\n-    RealULE = 13,\n-    RealUNE = 14,\n-    RealPredicateTrue = 15,\n-}\n-\n-/// LLVMTypeKind\n-#[derive(Copy, Clone, PartialEq, Debug)]\n-#[repr(C)]\n-pub enum TypeKind {\n-    Void = 0,\n-    Half = 1,\n-    Float = 2,\n-    Double = 3,\n-    X86_FP80 = 4,\n-    FP128 = 5,\n-    PPC_FP128 = 6,\n-    Label = 7,\n-    Integer = 8,\n-    Function = 9,\n-    Struct = 10,\n-    Array = 11,\n-    Pointer = 12,\n-    Vector = 13,\n-    Metadata = 14,\n-    X86_MMX = 15,\n-    Token = 16,\n-}\n-\n-/// LLVMAtomicRmwBinOp\n-#[derive(Copy, Clone)]\n-#[repr(C)]\n-pub enum AtomicRmwBinOp {\n-    AtomicXchg = 0,\n-    AtomicAdd = 1,\n-    AtomicSub = 2,\n-    AtomicAnd = 3,\n-    AtomicNand = 4,\n-    AtomicOr = 5,\n-    AtomicXor = 6,\n-    AtomicMax = 7,\n-    AtomicMin = 8,\n-    AtomicUMax = 9,\n-    AtomicUMin = 10,\n-}\n-\n-/// LLVMAtomicOrdering\n-#[derive(Copy, Clone)]\n-#[repr(C)]\n-pub enum AtomicOrdering {\n-    NotAtomic = 0,\n-    Unordered = 1,\n-    Monotonic = 2,\n-    // Consume = 3,  // Not specified yet.\n-    Acquire = 4,\n-    Release = 5,\n-    AcquireRelease = 6,\n-    SequentiallyConsistent = 7,\n-}\n-\n-/// LLVMRustSynchronizationScope\n-#[derive(Copy, Clone)]\n-#[repr(C)]\n-pub enum SynchronizationScope {\n-    Other,\n-    SingleThread,\n-    CrossThread,\n-}\n-\n-/// LLVMRustFileType\n-#[derive(Copy, Clone)]\n-#[repr(C)]\n-pub enum FileType {\n-    Other,\n-    AssemblyFile,\n-    ObjectFile,\n-}\n-\n-/// LLVMMetadataType\n-#[derive(Copy, Clone)]\n-#[repr(C)]\n-pub enum MetadataType {\n-    MD_dbg = 0,\n-    MD_tbaa = 1,\n-    MD_prof = 2,\n-    MD_fpmath = 3,\n-    MD_range = 4,\n-    MD_tbaa_struct = 5,\n-    MD_invariant_load = 6,\n-    MD_alias_scope = 7,\n-    MD_noalias = 8,\n-    MD_nontemporal = 9,\n-    MD_mem_parallel_loop_access = 10,\n-    MD_nonnull = 11,\n-}\n-\n-/// LLVMRustAsmDialect\n-#[derive(Copy, Clone)]\n-#[repr(C)]\n-pub enum AsmDialect {\n-    Other,\n-    Att,\n-    Intel,\n-}\n-\n-/// LLVMRustCodeGenOptLevel\n-#[derive(Copy, Clone, PartialEq)]\n-#[repr(C)]\n-pub enum CodeGenOptLevel {\n-    Other,\n-    None,\n-    Less,\n-    Default,\n-    Aggressive,\n-}\n-\n-/// LLVMRelocMode\n-#[derive(Copy, Clone, PartialEq)]\n-#[repr(C)]\n-pub enum RelocMode {\n-    Default,\n-    Static,\n-    PIC,\n-    DynamicNoPic,\n-    ROPI,\n-    RWPI,\n-    ROPI_RWPI,\n-}\n-\n-/// LLVMRustCodeModel\n-#[derive(Copy, Clone)]\n-#[repr(C)]\n-pub enum CodeModel {\n-    Other,\n-    Small,\n-    Kernel,\n-    Medium,\n-    Large,\n-    None,\n-}\n-\n-/// LLVMRustDiagnosticKind\n-#[derive(Copy, Clone)]\n-#[repr(C)]\n-pub enum DiagnosticKind {\n-    Other,\n-    InlineAsm,\n-    StackSize,\n-    DebugMetadataVersion,\n-    SampleProfile,\n-    OptimizationRemark,\n-    OptimizationRemarkMissed,\n-    OptimizationRemarkAnalysis,\n-    OptimizationRemarkAnalysisFPCommute,\n-    OptimizationRemarkAnalysisAliasing,\n-    OptimizationRemarkOther,\n-    OptimizationFailure,\n-    PGOProfile,\n-}\n-\n-/// LLVMRustArchiveKind\n-#[derive(Copy, Clone)]\n-#[repr(C)]\n-pub enum ArchiveKind {\n-    Other,\n-    K_GNU,\n-    K_BSD,\n-    K_COFF,\n-}\n-\n-/// LLVMRustPassKind\n-#[derive(Copy, Clone, PartialEq, Debug)]\n-#[repr(C)]\n-pub enum PassKind {\n-    Other,\n-    Function,\n-    Module,\n-}\n-\n-/// LLVMRustThinLTOData\n-pub enum ThinLTOData {}\n-\n-/// LLVMRustThinLTOBuffer\n-pub enum ThinLTOBuffer {}\n-\n-/// LLVMRustThinLTOModule\n-#[repr(C)]\n-pub struct ThinLTOModule {\n-    pub identifier: *const c_char,\n-    pub data: *const u8,\n-    pub len: usize,\n-}\n-\n-/// LLVMThreadLocalMode\n-#[derive(Copy, Clone)]\n-#[repr(C)]\n-pub enum ThreadLocalMode {\n-  NotThreadLocal,\n-  GeneralDynamic,\n-  LocalDynamic,\n-  InitialExec,\n-  LocalExec\n-}\n-\n-// Opaque pointer types\n-#[allow(missing_copy_implementations)]\n-pub enum Module_opaque {}\n-pub type ModuleRef = *mut Module_opaque;\n-#[allow(missing_copy_implementations)]\n-pub enum Context_opaque {}\n-pub type ContextRef = *mut Context_opaque;\n-#[allow(missing_copy_implementations)]\n-pub enum Type_opaque {}\n-pub type TypeRef = *mut Type_opaque;\n-#[allow(missing_copy_implementations)]\n-pub enum Value_opaque {}\n-pub type ValueRef = *mut Value_opaque;\n-#[allow(missing_copy_implementations)]\n-pub enum Metadata_opaque {}\n-pub type MetadataRef = *mut Metadata_opaque;\n-#[allow(missing_copy_implementations)]\n-pub enum BasicBlock_opaque {}\n-pub type BasicBlockRef = *mut BasicBlock_opaque;\n-#[allow(missing_copy_implementations)]\n-pub enum Builder_opaque {}\n-pub type BuilderRef = *mut Builder_opaque;\n-#[allow(missing_copy_implementations)]\n-pub enum ExecutionEngine_opaque {}\n-pub type ExecutionEngineRef = *mut ExecutionEngine_opaque;\n-#[allow(missing_copy_implementations)]\n-pub enum MemoryBuffer_opaque {}\n-pub type MemoryBufferRef = *mut MemoryBuffer_opaque;\n-#[allow(missing_copy_implementations)]\n-pub enum PassManager_opaque {}\n-pub type PassManagerRef = *mut PassManager_opaque;\n-#[allow(missing_copy_implementations)]\n-pub enum PassManagerBuilder_opaque {}\n-pub type PassManagerBuilderRef = *mut PassManagerBuilder_opaque;\n-#[allow(missing_copy_implementations)]\n-pub enum Use_opaque {}\n-pub type UseRef = *mut Use_opaque;\n-#[allow(missing_copy_implementations)]\n-pub enum TargetData_opaque {}\n-pub type TargetDataRef = *mut TargetData_opaque;\n-#[allow(missing_copy_implementations)]\n-pub enum ObjectFile_opaque {}\n-pub type ObjectFileRef = *mut ObjectFile_opaque;\n-#[allow(missing_copy_implementations)]\n-pub enum SectionIterator_opaque {}\n-pub type SectionIteratorRef = *mut SectionIterator_opaque;\n-#[allow(missing_copy_implementations)]\n-pub enum Pass_opaque {}\n-pub type PassRef = *mut Pass_opaque;\n-#[allow(missing_copy_implementations)]\n-pub enum TargetMachine_opaque {}\n-pub type TargetMachineRef = *mut TargetMachine_opaque;\n-pub enum Archive_opaque {}\n-pub type ArchiveRef = *mut Archive_opaque;\n-pub enum ArchiveIterator_opaque {}\n-pub type ArchiveIteratorRef = *mut ArchiveIterator_opaque;\n-pub enum ArchiveChild_opaque {}\n-pub type ArchiveChildRef = *mut ArchiveChild_opaque;\n-#[allow(missing_copy_implementations)]\n-pub enum Twine_opaque {}\n-pub type TwineRef = *mut Twine_opaque;\n-#[allow(missing_copy_implementations)]\n-pub enum DiagnosticInfo_opaque {}\n-pub type DiagnosticInfoRef = *mut DiagnosticInfo_opaque;\n-#[allow(missing_copy_implementations)]\n-pub enum DebugLoc_opaque {}\n-pub type DebugLocRef = *mut DebugLoc_opaque;\n-#[allow(missing_copy_implementations)]\n-pub enum SMDiagnostic_opaque {}\n-pub type SMDiagnosticRef = *mut SMDiagnostic_opaque;\n-#[allow(missing_copy_implementations)]\n-pub enum RustArchiveMember_opaque {}\n-pub type RustArchiveMemberRef = *mut RustArchiveMember_opaque;\n-#[allow(missing_copy_implementations)]\n-pub enum OperandBundleDef_opaque {}\n-pub type OperandBundleDefRef = *mut OperandBundleDef_opaque;\n-#[allow(missing_copy_implementations)]\n-pub enum Linker_opaque {}\n-pub type LinkerRef = *mut Linker_opaque;\n-\n-pub type DiagnosticHandler = unsafe extern \"C\" fn(DiagnosticInfoRef, *mut c_void);\n-pub type InlineAsmDiagHandler = unsafe extern \"C\" fn(SMDiagnosticRef, *const c_void, c_uint);\n-\n-\n-pub mod debuginfo {\n-    use super::MetadataRef;\n-\n-    #[allow(missing_copy_implementations)]\n-    pub enum DIBuilder_opaque {}\n-    pub type DIBuilderRef = *mut DIBuilder_opaque;\n-\n-    pub type DIDescriptor = MetadataRef;\n-    pub type DIScope = DIDescriptor;\n-    pub type DILocation = DIDescriptor;\n-    pub type DIFile = DIScope;\n-    pub type DILexicalBlock = DIScope;\n-    pub type DISubprogram = DIScope;\n-    pub type DINameSpace = DIScope;\n-    pub type DIType = DIDescriptor;\n-    pub type DIBasicType = DIType;\n-    pub type DIDerivedType = DIType;\n-    pub type DICompositeType = DIDerivedType;\n-    pub type DIVariable = DIDescriptor;\n-    pub type DIGlobalVariable = DIDescriptor;\n-    pub type DIArray = DIDescriptor;\n-    pub type DISubrange = DIDescriptor;\n-    pub type DIEnumerator = DIDescriptor;\n-    pub type DITemplateTypeParameter = DIDescriptor;\n-\n-    // These values **must** match with LLVMRustDIFlags!!\n-    bitflags! {\n-        #[repr(C)]\n-        #[derive(Default)]\n-        pub struct DIFlags: ::libc::uint32_t {\n-            const FlagZero                = 0;\n-            const FlagPrivate             = 1;\n-            const FlagProtected           = 2;\n-            const FlagPublic              = 3;\n-            const FlagFwdDecl             = (1 << 2);\n-            const FlagAppleBlock          = (1 << 3);\n-            const FlagBlockByrefStruct    = (1 << 4);\n-            const FlagVirtual             = (1 << 5);\n-            const FlagArtificial          = (1 << 6);\n-            const FlagExplicit            = (1 << 7);\n-            const FlagPrototyped          = (1 << 8);\n-            const FlagObjcClassComplete   = (1 << 9);\n-            const FlagObjectPointer       = (1 << 10);\n-            const FlagVector              = (1 << 11);\n-            const FlagStaticMember        = (1 << 12);\n-            const FlagLValueReference     = (1 << 13);\n-            const FlagRValueReference     = (1 << 14);\n-            const FlagExternalTypeRef     = (1 << 15);\n-            const FlagIntroducedVirtual   = (1 << 18);\n-            const FlagBitField            = (1 << 19);\n-            const FlagNoReturn            = (1 << 20);\n-            const FlagMainSubprogram      = (1 << 21);\n-        }\n-    }\n-}\n-\n-pub enum ModuleBuffer {}\n-\n-// This annotation is primarily needed for MSVC where attributes like\n-// dllimport/dllexport are applied and need to be correct for everything to\n-// link successfully. The #[link] annotation here says \"these symbols are\n-// included statically\" which means that they're all exported with dllexport\n-// and from the rustc_llvm dynamic library. Otherwise the rustc_codegen_llvm dynamic\n-// library would not be able to access these symbols.\n-#[link(name = \"rustllvm\", kind = \"static\")]\n-extern \"C\" {\n-    // Create and destroy contexts.\n-    pub fn LLVMRustContextCreate(shouldDiscardNames: bool) -> ContextRef;\n-    pub fn LLVMContextDispose(C: ContextRef);\n-    pub fn LLVMGetMDKindIDInContext(C: ContextRef, Name: *const c_char, SLen: c_uint) -> c_uint;\n-\n-    // Create and destroy modules.\n-    pub fn LLVMModuleCreateWithNameInContext(ModuleID: *const c_char, C: ContextRef) -> ModuleRef;\n-    pub fn LLVMGetModuleContext(M: ModuleRef) -> ContextRef;\n-    pub fn LLVMCloneModule(M: ModuleRef) -> ModuleRef;\n-    pub fn LLVMDisposeModule(M: ModuleRef);\n-\n-    /// Data layout. See Module::getDataLayout.\n-    pub fn LLVMGetDataLayout(M: ModuleRef) -> *const c_char;\n-    pub fn LLVMSetDataLayout(M: ModuleRef, Triple: *const c_char);\n-\n-    /// See Module::dump.\n-    pub fn LLVMDumpModule(M: ModuleRef);\n-\n-    /// See Module::setModuleInlineAsm.\n-    pub fn LLVMSetModuleInlineAsm(M: ModuleRef, Asm: *const c_char);\n-    pub fn LLVMRustAppendModuleInlineAsm(M: ModuleRef, Asm: *const c_char);\n-\n-    /// See llvm::LLVMTypeKind::getTypeID.\n-    pub fn LLVMRustGetTypeKind(Ty: TypeRef) -> TypeKind;\n-\n-    // Operations on integer types\n-    pub fn LLVMInt1TypeInContext(C: ContextRef) -> TypeRef;\n-    pub fn LLVMInt8TypeInContext(C: ContextRef) -> TypeRef;\n-    pub fn LLVMInt16TypeInContext(C: ContextRef) -> TypeRef;\n-    pub fn LLVMInt32TypeInContext(C: ContextRef) -> TypeRef;\n-    pub fn LLVMInt64TypeInContext(C: ContextRef) -> TypeRef;\n-    pub fn LLVMIntTypeInContext(C: ContextRef, NumBits: c_uint) -> TypeRef;\n-\n-    pub fn LLVMGetIntTypeWidth(IntegerTy: TypeRef) -> c_uint;\n-\n-    // Operations on real types\n-    pub fn LLVMFloatTypeInContext(C: ContextRef) -> TypeRef;\n-    pub fn LLVMDoubleTypeInContext(C: ContextRef) -> TypeRef;\n-\n-    // Operations on function types\n-    pub fn LLVMFunctionType(ReturnType: TypeRef,\n-                            ParamTypes: *const TypeRef,\n-                            ParamCount: c_uint,\n-                            IsVarArg: Bool)\n-                            -> TypeRef;\n-    pub fn LLVMGetReturnType(FunctionTy: TypeRef) -> TypeRef;\n-    pub fn LLVMCountParamTypes(FunctionTy: TypeRef) -> c_uint;\n-    pub fn LLVMGetParamTypes(FunctionTy: TypeRef, Dest: *mut TypeRef);\n-\n-    // Operations on struct types\n-    pub fn LLVMStructTypeInContext(C: ContextRef,\n-                                   ElementTypes: *const TypeRef,\n-                                   ElementCount: c_uint,\n-                                   Packed: Bool)\n-                                   -> TypeRef;\n-    pub fn LLVMIsPackedStruct(StructTy: TypeRef) -> Bool;\n-\n-    // Operations on array, pointer, and vector types (sequence types)\n-    pub fn LLVMRustArrayType(ElementType: TypeRef, ElementCount: u64) -> TypeRef;\n-    pub fn LLVMPointerType(ElementType: TypeRef, AddressSpace: c_uint) -> TypeRef;\n-    pub fn LLVMVectorType(ElementType: TypeRef, ElementCount: c_uint) -> TypeRef;\n-\n-    pub fn LLVMGetElementType(Ty: TypeRef) -> TypeRef;\n-    pub fn LLVMGetVectorSize(VectorTy: TypeRef) -> c_uint;\n-\n-    // Operations on other types\n-    pub fn LLVMVoidTypeInContext(C: ContextRef) -> TypeRef;\n-    pub fn LLVMX86MMXTypeInContext(C: ContextRef) -> TypeRef;\n-    pub fn LLVMRustMetadataTypeInContext(C: ContextRef) -> TypeRef;\n-\n-    // Operations on all values\n-    pub fn LLVMTypeOf(Val: ValueRef) -> TypeRef;\n-    pub fn LLVMGetValueName(Val: ValueRef) -> *const c_char;\n-    pub fn LLVMSetValueName(Val: ValueRef, Name: *const c_char);\n-    pub fn LLVMReplaceAllUsesWith(OldVal: ValueRef, NewVal: ValueRef);\n-    pub fn LLVMSetMetadata(Val: ValueRef, KindID: c_uint, Node: ValueRef);\n-\n-    // Operations on Uses\n-    pub fn LLVMGetFirstUse(Val: ValueRef) -> UseRef;\n-    pub fn LLVMGetNextUse(U: UseRef) -> UseRef;\n-    pub fn LLVMGetUser(U: UseRef) -> ValueRef;\n-\n-    // Operations on Users\n-    pub fn LLVMGetOperand(Val: ValueRef, Index: c_uint) -> ValueRef;\n-\n-    // Operations on constants of any type\n-    pub fn LLVMConstNull(Ty: TypeRef) -> ValueRef;\n-    pub fn LLVMConstICmp(Pred: IntPredicate, V1: ValueRef, V2: ValueRef) -> ValueRef;\n-    pub fn LLVMConstFCmp(Pred: RealPredicate, V1: ValueRef, V2: ValueRef) -> ValueRef;\n-    pub fn LLVMGetUndef(Ty: TypeRef) -> ValueRef;\n-\n-    // Operations on metadata\n-    pub fn LLVMMDStringInContext(C: ContextRef, Str: *const c_char, SLen: c_uint) -> ValueRef;\n-    pub fn LLVMMDNodeInContext(C: ContextRef, Vals: *const ValueRef, Count: c_uint) -> ValueRef;\n-    pub fn LLVMAddNamedMetadataOperand(M: ModuleRef, Name: *const c_char, Val: ValueRef);\n-\n-    // Operations on scalar constants\n-    pub fn LLVMConstInt(IntTy: TypeRef, N: c_ulonglong, SignExtend: Bool) -> ValueRef;\n-    pub fn LLVMConstIntOfArbitraryPrecision(IntTy: TypeRef, Wn: c_uint, Ws: *const u64) -> ValueRef;\n-    pub fn LLVMConstIntGetZExtValue(ConstantVal: ValueRef) -> c_ulonglong;\n-    pub fn LLVMConstIntGetSExtValue(ConstantVal: ValueRef) -> c_longlong;\n-    pub fn LLVMRustConstInt128Get(ConstantVal: ValueRef, SExt: bool,\n-                                  high: *mut u64, low: *mut u64) -> bool;\n-    pub fn LLVMConstRealGetDouble (ConstantVal: ValueRef, losesInfo: *mut Bool) -> f64;\n-\n-\n-    // Operations on composite constants\n-    pub fn LLVMConstStringInContext(C: ContextRef,\n-                                    Str: *const c_char,\n-                                    Length: c_uint,\n-                                    DontNullTerminate: Bool)\n-                                    -> ValueRef;\n-    pub fn LLVMConstStructInContext(C: ContextRef,\n-                                    ConstantVals: *const ValueRef,\n-                                    Count: c_uint,\n-                                    Packed: Bool)\n-                                    -> ValueRef;\n-\n-    pub fn LLVMConstArray(ElementTy: TypeRef,\n-                          ConstantVals: *const ValueRef,\n-                          Length: c_uint)\n-                          -> ValueRef;\n-    pub fn LLVMConstVector(ScalarConstantVals: *const ValueRef, Size: c_uint) -> ValueRef;\n-\n-    // Constant expressions\n-    pub fn LLVMSizeOf(Ty: TypeRef) -> ValueRef;\n-    pub fn LLVMConstNeg(ConstantVal: ValueRef) -> ValueRef;\n-    pub fn LLVMConstFNeg(ConstantVal: ValueRef) -> ValueRef;\n-    pub fn LLVMConstNot(ConstantVal: ValueRef) -> ValueRef;\n-    pub fn LLVMConstAdd(LHSConstant: ValueRef, RHSConstant: ValueRef) -> ValueRef;\n-    pub fn LLVMConstFAdd(LHSConstant: ValueRef, RHSConstant: ValueRef) -> ValueRef;\n-    pub fn LLVMConstSub(LHSConstant: ValueRef, RHSConstant: ValueRef) -> ValueRef;\n-    pub fn LLVMConstFSub(LHSConstant: ValueRef, RHSConstant: ValueRef) -> ValueRef;\n-    pub fn LLVMConstMul(LHSConstant: ValueRef, RHSConstant: ValueRef) -> ValueRef;\n-    pub fn LLVMConstFMul(LHSConstant: ValueRef, RHSConstant: ValueRef) -> ValueRef;\n-    pub fn LLVMConstUDiv(LHSConstant: ValueRef, RHSConstant: ValueRef) -> ValueRef;\n-    pub fn LLVMConstSDiv(LHSConstant: ValueRef, RHSConstant: ValueRef) -> ValueRef;\n-    pub fn LLVMConstFDiv(LHSConstant: ValueRef, RHSConstant: ValueRef) -> ValueRef;\n-    pub fn LLVMConstURem(LHSConstant: ValueRef, RHSConstant: ValueRef) -> ValueRef;\n-    pub fn LLVMConstSRem(LHSConstant: ValueRef, RHSConstant: ValueRef) -> ValueRef;\n-    pub fn LLVMConstFRem(LHSConstant: ValueRef, RHSConstant: ValueRef) -> ValueRef;\n-    pub fn LLVMConstAnd(LHSConstant: ValueRef, RHSConstant: ValueRef) -> ValueRef;\n-    pub fn LLVMConstOr(LHSConstant: ValueRef, RHSConstant: ValueRef) -> ValueRef;\n-    pub fn LLVMConstXor(LHSConstant: ValueRef, RHSConstant: ValueRef) -> ValueRef;\n-    pub fn LLVMConstShl(LHSConstant: ValueRef, RHSConstant: ValueRef) -> ValueRef;\n-    pub fn LLVMConstLShr(LHSConstant: ValueRef, RHSConstant: ValueRef) -> ValueRef;\n-    pub fn LLVMConstAShr(LHSConstant: ValueRef, RHSConstant: ValueRef) -> ValueRef;\n-    pub fn LLVMConstGEP(\n-        ConstantVal: ValueRef,\n-        ConstantIndices: *const ValueRef,\n-        NumIndices: c_uint,\n-    ) -> ValueRef;\n-    pub fn LLVMConstInBoundsGEP(\n-        ConstantVal: ValueRef,\n-        ConstantIndices: *const ValueRef,\n-        NumIndices: c_uint,\n-    ) -> ValueRef;\n-    pub fn LLVMConstTrunc(ConstantVal: ValueRef, ToType: TypeRef) -> ValueRef;\n-    pub fn LLVMConstZExt(ConstantVal: ValueRef, ToType: TypeRef) -> ValueRef;\n-    pub fn LLVMConstUIToFP(ConstantVal: ValueRef, ToType: TypeRef) -> ValueRef;\n-    pub fn LLVMConstSIToFP(ConstantVal: ValueRef, ToType: TypeRef) -> ValueRef;\n-    pub fn LLVMConstFPToUI(ConstantVal: ValueRef, ToType: TypeRef) -> ValueRef;\n-    pub fn LLVMConstFPToSI(ConstantVal: ValueRef, ToType: TypeRef) -> ValueRef;\n-    pub fn LLVMConstPtrToInt(ConstantVal: ValueRef, ToType: TypeRef) -> ValueRef;\n-    pub fn LLVMConstIntToPtr(ConstantVal: ValueRef, ToType: TypeRef) -> ValueRef;\n-    pub fn LLVMConstBitCast(ConstantVal: ValueRef, ToType: TypeRef) -> ValueRef;\n-    pub fn LLVMConstPointerCast(ConstantVal: ValueRef, ToType: TypeRef) -> ValueRef;\n-    pub fn LLVMConstIntCast(ConstantVal: ValueRef, ToType: TypeRef, isSigned: Bool) -> ValueRef;\n-    pub fn LLVMConstFPCast(ConstantVal: ValueRef, ToType: TypeRef) -> ValueRef;\n-    pub fn LLVMConstExtractValue(AggConstant: ValueRef,\n-                                 IdxList: *const c_uint,\n-                                 NumIdx: c_uint)\n-                                 -> ValueRef;\n-    pub fn LLVMConstInlineAsm(Ty: TypeRef,\n-                              AsmString: *const c_char,\n-                              Constraints: *const c_char,\n-                              HasSideEffects: Bool,\n-                              IsAlignStack: Bool)\n-                              -> ValueRef;\n-\n-\n-    // Operations on global variables, functions, and aliases (globals)\n-    pub fn LLVMGetGlobalParent(Global: ValueRef) -> ModuleRef;\n-    pub fn LLVMIsDeclaration(Global: ValueRef) -> Bool;\n-    pub fn LLVMRustGetLinkage(Global: ValueRef) -> Linkage;\n-    pub fn LLVMRustSetLinkage(Global: ValueRef, RustLinkage: Linkage);\n-    pub fn LLVMGetSection(Global: ValueRef) -> *const c_char;\n-    pub fn LLVMSetSection(Global: ValueRef, Section: *const c_char);\n-    pub fn LLVMRustGetVisibility(Global: ValueRef) -> Visibility;\n-    pub fn LLVMRustSetVisibility(Global: ValueRef, Viz: Visibility);\n-    pub fn LLVMGetAlignment(Global: ValueRef) -> c_uint;\n-    pub fn LLVMSetAlignment(Global: ValueRef, Bytes: c_uint);\n-    pub fn LLVMSetDLLStorageClass(V: ValueRef, C: DLLStorageClass);\n-\n-\n-    // Operations on global variables\n-    pub fn LLVMIsAGlobalVariable(GlobalVar: ValueRef) -> ValueRef;\n-    pub fn LLVMAddGlobal(M: ModuleRef, Ty: TypeRef, Name: *const c_char) -> ValueRef;\n-    pub fn LLVMGetNamedGlobal(M: ModuleRef, Name: *const c_char) -> ValueRef;\n-    pub fn LLVMRustGetOrInsertGlobal(M: ModuleRef, Name: *const c_char, T: TypeRef) -> ValueRef;\n-    pub fn LLVMGetFirstGlobal(M: ModuleRef) -> ValueRef;\n-    pub fn LLVMGetNextGlobal(GlobalVar: ValueRef) -> ValueRef;\n-    pub fn LLVMDeleteGlobal(GlobalVar: ValueRef);\n-    pub fn LLVMGetInitializer(GlobalVar: ValueRef) -> ValueRef;\n-    pub fn LLVMSetInitializer(GlobalVar: ValueRef, ConstantVal: ValueRef);\n-    pub fn LLVMSetThreadLocal(GlobalVar: ValueRef, IsThreadLocal: Bool);\n-    pub fn LLVMSetThreadLocalMode(GlobalVar: ValueRef, Mode: ThreadLocalMode);\n-    pub fn LLVMIsGlobalConstant(GlobalVar: ValueRef) -> Bool;\n-    pub fn LLVMSetGlobalConstant(GlobalVar: ValueRef, IsConstant: Bool);\n-    pub fn LLVMRustGetNamedValue(M: ModuleRef, Name: *const c_char) -> ValueRef;\n-    pub fn LLVMSetTailCall(CallInst: ValueRef, IsTailCall: Bool);\n-\n-    // Operations on functions\n-    pub fn LLVMAddFunction(M: ModuleRef, Name: *const c_char, FunctionTy: TypeRef) -> ValueRef;\n-    pub fn LLVMGetNamedFunction(M: ModuleRef, Name: *const c_char) -> ValueRef;\n-    pub fn LLVMGetFirstFunction(M: ModuleRef) -> ValueRef;\n-    pub fn LLVMGetNextFunction(Fn: ValueRef) -> ValueRef;\n-    pub fn LLVMRustGetOrInsertFunction(M: ModuleRef,\n-                                       Name: *const c_char,\n-                                       FunctionTy: TypeRef)\n-                                       -> ValueRef;\n-    pub fn LLVMSetFunctionCallConv(Fn: ValueRef, CC: c_uint);\n-    pub fn LLVMRustAddAlignmentAttr(Fn: ValueRef, index: c_uint, bytes: u32);\n-    pub fn LLVMRustAddDereferenceableAttr(Fn: ValueRef, index: c_uint, bytes: u64);\n-    pub fn LLVMRustAddDereferenceableOrNullAttr(Fn: ValueRef, index: c_uint, bytes: u64);\n-    pub fn LLVMRustAddFunctionAttribute(Fn: ValueRef, index: c_uint, attr: Attribute);\n-    pub fn LLVMRustAddFunctionAttrStringValue(Fn: ValueRef,\n-                                              index: c_uint,\n-                                              Name: *const c_char,\n-                                              Value: *const c_char);\n-    pub fn LLVMRustRemoveFunctionAttributes(Fn: ValueRef, index: c_uint, attr: Attribute);\n-\n-    // Operations on parameters\n-    pub fn LLVMCountParams(Fn: ValueRef) -> c_uint;\n-    pub fn LLVMGetParam(Fn: ValueRef, Index: c_uint) -> ValueRef;\n-\n-    // Operations on basic blocks\n-    pub fn LLVMBasicBlockAsValue(BB: BasicBlockRef) -> ValueRef;\n-    pub fn LLVMGetBasicBlockParent(BB: BasicBlockRef) -> ValueRef;\n-    pub fn LLVMAppendBasicBlockInContext(C: ContextRef,\n-                                         Fn: ValueRef,\n-                                         Name: *const c_char)\n-                                         -> BasicBlockRef;\n-    pub fn LLVMDeleteBasicBlock(BB: BasicBlockRef);\n-\n-    // Operations on instructions\n-    pub fn LLVMGetInstructionParent(Inst: ValueRef) -> BasicBlockRef;\n-    pub fn LLVMGetFirstBasicBlock(Fn: ValueRef) -> BasicBlockRef;\n-    pub fn LLVMGetFirstInstruction(BB: BasicBlockRef) -> ValueRef;\n-    pub fn LLVMInstructionEraseFromParent(Inst: ValueRef);\n-\n-    // Operations on call sites\n-    pub fn LLVMSetInstructionCallConv(Instr: ValueRef, CC: c_uint);\n-    pub fn LLVMRustAddCallSiteAttribute(Instr: ValueRef, index: c_uint, attr: Attribute);\n-    pub fn LLVMRustAddAlignmentCallSiteAttr(Instr: ValueRef, index: c_uint, bytes: u32);\n-    pub fn LLVMRustAddDereferenceableCallSiteAttr(Instr: ValueRef, index: c_uint, bytes: u64);\n-    pub fn LLVMRustAddDereferenceableOrNullCallSiteAttr(Instr: ValueRef,\n-                                                        index: c_uint,\n-                                                        bytes: u64);\n-\n-    // Operations on load/store instructions (only)\n-    pub fn LLVMSetVolatile(MemoryAccessInst: ValueRef, volatile: Bool);\n-\n-    // Operations on phi nodes\n-    pub fn LLVMAddIncoming(PhiNode: ValueRef,\n-                           IncomingValues: *const ValueRef,\n-                           IncomingBlocks: *const BasicBlockRef,\n-                           Count: c_uint);\n-\n-    // Instruction builders\n-    pub fn LLVMCreateBuilderInContext(C: ContextRef) -> BuilderRef;\n-    pub fn LLVMPositionBuilder(Builder: BuilderRef, Block: BasicBlockRef, Instr: ValueRef);\n-    pub fn LLVMPositionBuilderBefore(Builder: BuilderRef, Instr: ValueRef);\n-    pub fn LLVMPositionBuilderAtEnd(Builder: BuilderRef, Block: BasicBlockRef);\n-    pub fn LLVMGetInsertBlock(Builder: BuilderRef) -> BasicBlockRef;\n-    pub fn LLVMDisposeBuilder(Builder: BuilderRef);\n-\n-    // Metadata\n-    pub fn LLVMSetCurrentDebugLocation(Builder: BuilderRef, L: ValueRef);\n-    pub fn LLVMGetCurrentDebugLocation(Builder: BuilderRef) -> ValueRef;\n-    pub fn LLVMSetInstDebugLocation(Builder: BuilderRef, Inst: ValueRef);\n-\n-    // Terminators\n-    pub fn LLVMBuildRetVoid(B: BuilderRef) -> ValueRef;\n-    pub fn LLVMBuildRet(B: BuilderRef, V: ValueRef) -> ValueRef;\n-    pub fn LLVMBuildAggregateRet(B: BuilderRef, RetVals: *const ValueRef, N: c_uint) -> ValueRef;\n-    pub fn LLVMBuildBr(B: BuilderRef, Dest: BasicBlockRef) -> ValueRef;\n-    pub fn LLVMBuildCondBr(B: BuilderRef,\n-                           If: ValueRef,\n-                           Then: BasicBlockRef,\n-                           Else: BasicBlockRef)\n-                           -> ValueRef;\n-    pub fn LLVMBuildSwitch(B: BuilderRef,\n-                           V: ValueRef,\n-                           Else: BasicBlockRef,\n-                           NumCases: c_uint)\n-                           -> ValueRef;\n-    pub fn LLVMBuildIndirectBr(B: BuilderRef, Addr: ValueRef, NumDests: c_uint) -> ValueRef;\n-    pub fn LLVMRustBuildInvoke(B: BuilderRef,\n-                               Fn: ValueRef,\n-                               Args: *const ValueRef,\n-                               NumArgs: c_uint,\n-                               Then: BasicBlockRef,\n-                               Catch: BasicBlockRef,\n-                               Bundle: OperandBundleDefRef,\n-                               Name: *const c_char)\n-                               -> ValueRef;\n-    pub fn LLVMBuildLandingPad(B: BuilderRef,\n-                               Ty: TypeRef,\n-                               PersFn: ValueRef,\n-                               NumClauses: c_uint,\n-                               Name: *const c_char)\n-                               -> ValueRef;\n-    pub fn LLVMBuildResume(B: BuilderRef, Exn: ValueRef) -> ValueRef;\n-    pub fn LLVMBuildUnreachable(B: BuilderRef) -> ValueRef;\n-\n-    pub fn LLVMRustBuildCleanupPad(B: BuilderRef,\n-                                   ParentPad: ValueRef,\n-                                   ArgCnt: c_uint,\n-                                   Args: *const ValueRef,\n-                                   Name: *const c_char)\n-                                   -> ValueRef;\n-    pub fn LLVMRustBuildCleanupRet(B: BuilderRef,\n-                                   CleanupPad: ValueRef,\n-                                   UnwindBB: BasicBlockRef)\n-                                   -> ValueRef;\n-    pub fn LLVMRustBuildCatchPad(B: BuilderRef,\n-                                 ParentPad: ValueRef,\n-                                 ArgCnt: c_uint,\n-                                 Args: *const ValueRef,\n-                                 Name: *const c_char)\n-                                 -> ValueRef;\n-    pub fn LLVMRustBuildCatchRet(B: BuilderRef, Pad: ValueRef, BB: BasicBlockRef) -> ValueRef;\n-    pub fn LLVMRustBuildCatchSwitch(Builder: BuilderRef,\n-                                    ParentPad: ValueRef,\n-                                    BB: BasicBlockRef,\n-                                    NumHandlers: c_uint,\n-                                    Name: *const c_char)\n-                                    -> ValueRef;\n-    pub fn LLVMRustAddHandler(CatchSwitch: ValueRef, Handler: BasicBlockRef);\n-    pub fn LLVMSetPersonalityFn(Func: ValueRef, Pers: ValueRef);\n-\n-    // Add a case to the switch instruction\n-    pub fn LLVMAddCase(Switch: ValueRef, OnVal: ValueRef, Dest: BasicBlockRef);\n-\n-    // Add a clause to the landing pad instruction\n-    pub fn LLVMAddClause(LandingPad: ValueRef, ClauseVal: ValueRef);\n-\n-    // Set the cleanup on a landing pad instruction\n-    pub fn LLVMSetCleanup(LandingPad: ValueRef, Val: Bool);\n-\n-    // Arithmetic\n-    pub fn LLVMBuildAdd(B: BuilderRef,\n-                        LHS: ValueRef,\n-                        RHS: ValueRef,\n-                        Name: *const c_char)\n-                        -> ValueRef;\n-    pub fn LLVMBuildNSWAdd(B: BuilderRef,\n-                           LHS: ValueRef,\n-                           RHS: ValueRef,\n-                           Name: *const c_char)\n-                           -> ValueRef;\n-    pub fn LLVMBuildNUWAdd(B: BuilderRef,\n-                           LHS: ValueRef,\n-                           RHS: ValueRef,\n-                           Name: *const c_char)\n-                           -> ValueRef;\n-    pub fn LLVMBuildFAdd(B: BuilderRef,\n-                         LHS: ValueRef,\n-                         RHS: ValueRef,\n-                         Name: *const c_char)\n-                         -> ValueRef;\n-    pub fn LLVMBuildSub(B: BuilderRef,\n-                        LHS: ValueRef,\n-                        RHS: ValueRef,\n-                        Name: *const c_char)\n-                        -> ValueRef;\n-    pub fn LLVMBuildNSWSub(B: BuilderRef,\n-                           LHS: ValueRef,\n-                           RHS: ValueRef,\n-                           Name: *const c_char)\n-                           -> ValueRef;\n-    pub fn LLVMBuildNUWSub(B: BuilderRef,\n-                           LHS: ValueRef,\n-                           RHS: ValueRef,\n-                           Name: *const c_char)\n-                           -> ValueRef;\n-    pub fn LLVMBuildFSub(B: BuilderRef,\n-                         LHS: ValueRef,\n-                         RHS: ValueRef,\n-                         Name: *const c_char)\n-                         -> ValueRef;\n-    pub fn LLVMBuildMul(B: BuilderRef,\n-                        LHS: ValueRef,\n-                        RHS: ValueRef,\n-                        Name: *const c_char)\n-                        -> ValueRef;\n-    pub fn LLVMBuildNSWMul(B: BuilderRef,\n-                           LHS: ValueRef,\n-                           RHS: ValueRef,\n-                           Name: *const c_char)\n-                           -> ValueRef;\n-    pub fn LLVMBuildNUWMul(B: BuilderRef,\n-                           LHS: ValueRef,\n-                           RHS: ValueRef,\n-                           Name: *const c_char)\n-                           -> ValueRef;\n-    pub fn LLVMBuildFMul(B: BuilderRef,\n-                         LHS: ValueRef,\n-                         RHS: ValueRef,\n-                         Name: *const c_char)\n-                         -> ValueRef;\n-    pub fn LLVMBuildUDiv(B: BuilderRef,\n-                         LHS: ValueRef,\n-                         RHS: ValueRef,\n-                         Name: *const c_char)\n-                         -> ValueRef;\n-    pub fn LLVMBuildExactUDiv(B: BuilderRef,\n-                              LHS: ValueRef,\n-                              RHS: ValueRef,\n-                              Name: *const c_char)\n-                              -> ValueRef;\n-    pub fn LLVMBuildSDiv(B: BuilderRef,\n-                         LHS: ValueRef,\n-                         RHS: ValueRef,\n-                         Name: *const c_char)\n-                         -> ValueRef;\n-    pub fn LLVMBuildExactSDiv(B: BuilderRef,\n-                              LHS: ValueRef,\n-                              RHS: ValueRef,\n-                              Name: *const c_char)\n-                              -> ValueRef;\n-    pub fn LLVMBuildFDiv(B: BuilderRef,\n-                         LHS: ValueRef,\n-                         RHS: ValueRef,\n-                         Name: *const c_char)\n-                         -> ValueRef;\n-    pub fn LLVMBuildURem(B: BuilderRef,\n-                         LHS: ValueRef,\n-                         RHS: ValueRef,\n-                         Name: *const c_char)\n-                         -> ValueRef;\n-    pub fn LLVMBuildSRem(B: BuilderRef,\n-                         LHS: ValueRef,\n-                         RHS: ValueRef,\n-                         Name: *const c_char)\n-                         -> ValueRef;\n-    pub fn LLVMBuildFRem(B: BuilderRef,\n-                         LHS: ValueRef,\n-                         RHS: ValueRef,\n-                         Name: *const c_char)\n-                         -> ValueRef;\n-    pub fn LLVMBuildShl(B: BuilderRef,\n-                        LHS: ValueRef,\n-                        RHS: ValueRef,\n-                        Name: *const c_char)\n-                        -> ValueRef;\n-    pub fn LLVMBuildLShr(B: BuilderRef,\n-                         LHS: ValueRef,\n-                         RHS: ValueRef,\n-                         Name: *const c_char)\n-                         -> ValueRef;\n-    pub fn LLVMBuildAShr(B: BuilderRef,\n-                         LHS: ValueRef,\n-                         RHS: ValueRef,\n-                         Name: *const c_char)\n-                         -> ValueRef;\n-    pub fn LLVMBuildAnd(B: BuilderRef,\n-                        LHS: ValueRef,\n-                        RHS: ValueRef,\n-                        Name: *const c_char)\n-                        -> ValueRef;\n-    pub fn LLVMBuildOr(B: BuilderRef,\n-                       LHS: ValueRef,\n-                       RHS: ValueRef,\n-                       Name: *const c_char)\n-                       -> ValueRef;\n-    pub fn LLVMBuildXor(B: BuilderRef,\n-                        LHS: ValueRef,\n-                        RHS: ValueRef,\n-                        Name: *const c_char)\n-                        -> ValueRef;\n-    pub fn LLVMBuildBinOp(B: BuilderRef,\n-                          Op: Opcode,\n-                          LHS: ValueRef,\n-                          RHS: ValueRef,\n-                          Name: *const c_char)\n-                          -> ValueRef;\n-    pub fn LLVMBuildNeg(B: BuilderRef, V: ValueRef, Name: *const c_char) -> ValueRef;\n-    pub fn LLVMBuildNSWNeg(B: BuilderRef, V: ValueRef, Name: *const c_char) -> ValueRef;\n-    pub fn LLVMBuildNUWNeg(B: BuilderRef, V: ValueRef, Name: *const c_char) -> ValueRef;\n-    pub fn LLVMBuildFNeg(B: BuilderRef, V: ValueRef, Name: *const c_char) -> ValueRef;\n-    pub fn LLVMBuildNot(B: BuilderRef, V: ValueRef, Name: *const c_char) -> ValueRef;\n-    pub fn LLVMRustSetHasUnsafeAlgebra(Instr: ValueRef);\n-\n-    // Memory\n-    pub fn LLVMBuildAlloca(B: BuilderRef, Ty: TypeRef, Name: *const c_char) -> ValueRef;\n-    pub fn LLVMBuildFree(B: BuilderRef, PointerVal: ValueRef) -> ValueRef;\n-    pub fn LLVMBuildLoad(B: BuilderRef, PointerVal: ValueRef, Name: *const c_char) -> ValueRef;\n-\n-    pub fn LLVMBuildStore(B: BuilderRef, Val: ValueRef, Ptr: ValueRef) -> ValueRef;\n-\n-    pub fn LLVMBuildGEP(B: BuilderRef,\n-                        Pointer: ValueRef,\n-                        Indices: *const ValueRef,\n-                        NumIndices: c_uint,\n-                        Name: *const c_char)\n-                        -> ValueRef;\n-    pub fn LLVMBuildInBoundsGEP(B: BuilderRef,\n-                                Pointer: ValueRef,\n-                                Indices: *const ValueRef,\n-                                NumIndices: c_uint,\n-                                Name: *const c_char)\n-                                -> ValueRef;\n-    pub fn LLVMBuildStructGEP(B: BuilderRef,\n-                              Pointer: ValueRef,\n-                              Idx: c_uint,\n-                              Name: *const c_char)\n-                              -> ValueRef;\n-    pub fn LLVMBuildGlobalString(B: BuilderRef,\n-                                 Str: *const c_char,\n-                                 Name: *const c_char)\n-                                 -> ValueRef;\n-    pub fn LLVMBuildGlobalStringPtr(B: BuilderRef,\n-                                    Str: *const c_char,\n-                                    Name: *const c_char)\n-                                    -> ValueRef;\n-\n-    // Casts\n-    pub fn LLVMBuildTrunc(B: BuilderRef,\n-                          Val: ValueRef,\n-                          DestTy: TypeRef,\n-                          Name: *const c_char)\n-                          -> ValueRef;\n-    pub fn LLVMBuildZExt(B: BuilderRef,\n-                         Val: ValueRef,\n-                         DestTy: TypeRef,\n-                         Name: *const c_char)\n-                         -> ValueRef;\n-    pub fn LLVMBuildSExt(B: BuilderRef,\n-                         Val: ValueRef,\n-                         DestTy: TypeRef,\n-                         Name: *const c_char)\n-                         -> ValueRef;\n-    pub fn LLVMBuildFPToUI(B: BuilderRef,\n-                           Val: ValueRef,\n-                           DestTy: TypeRef,\n-                           Name: *const c_char)\n-                           -> ValueRef;\n-    pub fn LLVMBuildFPToSI(B: BuilderRef,\n-                           Val: ValueRef,\n-                           DestTy: TypeRef,\n-                           Name: *const c_char)\n-                           -> ValueRef;\n-    pub fn LLVMBuildUIToFP(B: BuilderRef,\n-                           Val: ValueRef,\n-                           DestTy: TypeRef,\n-                           Name: *const c_char)\n-                           -> ValueRef;\n-    pub fn LLVMBuildSIToFP(B: BuilderRef,\n-                           Val: ValueRef,\n-                           DestTy: TypeRef,\n-                           Name: *const c_char)\n-                           -> ValueRef;\n-    pub fn LLVMBuildFPTrunc(B: BuilderRef,\n-                            Val: ValueRef,\n-                            DestTy: TypeRef,\n-                            Name: *const c_char)\n-                            -> ValueRef;\n-    pub fn LLVMBuildFPExt(B: BuilderRef,\n-                          Val: ValueRef,\n-                          DestTy: TypeRef,\n-                          Name: *const c_char)\n-                          -> ValueRef;\n-    pub fn LLVMBuildPtrToInt(B: BuilderRef,\n-                             Val: ValueRef,\n-                             DestTy: TypeRef,\n-                             Name: *const c_char)\n-                             -> ValueRef;\n-    pub fn LLVMBuildIntToPtr(B: BuilderRef,\n-                             Val: ValueRef,\n-                             DestTy: TypeRef,\n-                             Name: *const c_char)\n-                             -> ValueRef;\n-    pub fn LLVMBuildBitCast(B: BuilderRef,\n-                            Val: ValueRef,\n-                            DestTy: TypeRef,\n-                            Name: *const c_char)\n-                            -> ValueRef;\n-    pub fn LLVMBuildZExtOrBitCast(B: BuilderRef,\n-                                  Val: ValueRef,\n-                                  DestTy: TypeRef,\n-                                  Name: *const c_char)\n-                                  -> ValueRef;\n-    pub fn LLVMBuildSExtOrBitCast(B: BuilderRef,\n-                                  Val: ValueRef,\n-                                  DestTy: TypeRef,\n-                                  Name: *const c_char)\n-                                  -> ValueRef;\n-    pub fn LLVMBuildTruncOrBitCast(B: BuilderRef,\n-                                   Val: ValueRef,\n-                                   DestTy: TypeRef,\n-                                   Name: *const c_char)\n-                                   -> ValueRef;\n-    pub fn LLVMBuildCast(B: BuilderRef,\n-                         Op: Opcode,\n-                         Val: ValueRef,\n-                         DestTy: TypeRef,\n-                         Name: *const c_char)\n-                         -> ValueRef;\n-    pub fn LLVMBuildPointerCast(B: BuilderRef,\n-                                Val: ValueRef,\n-                                DestTy: TypeRef,\n-                                Name: *const c_char)\n-                                -> ValueRef;\n-    pub fn LLVMRustBuildIntCast(B: BuilderRef,\n-                                Val: ValueRef,\n-                                DestTy: TypeRef,\n-                                IsSized: bool)\n-                                -> ValueRef;\n-    pub fn LLVMBuildFPCast(B: BuilderRef,\n-                           Val: ValueRef,\n-                           DestTy: TypeRef,\n-                           Name: *const c_char)\n-                           -> ValueRef;\n-\n-    // Comparisons\n-    pub fn LLVMBuildICmp(B: BuilderRef,\n-                         Op: c_uint,\n-                         LHS: ValueRef,\n-                         RHS: ValueRef,\n-                         Name: *const c_char)\n-                         -> ValueRef;\n-    pub fn LLVMBuildFCmp(B: BuilderRef,\n-                         Op: c_uint,\n-                         LHS: ValueRef,\n-                         RHS: ValueRef,\n-                         Name: *const c_char)\n-                         -> ValueRef;\n-\n-    // Miscellaneous instructions\n-    pub fn LLVMBuildPhi(B: BuilderRef, Ty: TypeRef, Name: *const c_char) -> ValueRef;\n-    pub fn LLVMRustBuildCall(B: BuilderRef,\n-                             Fn: ValueRef,\n-                             Args: *const ValueRef,\n-                             NumArgs: c_uint,\n-                             Bundle: OperandBundleDefRef,\n-                             Name: *const c_char)\n-                             -> ValueRef;\n-    pub fn LLVMBuildSelect(B: BuilderRef,\n-                           If: ValueRef,\n-                           Then: ValueRef,\n-                           Else: ValueRef,\n-                           Name: *const c_char)\n-                           -> ValueRef;\n-    pub fn LLVMBuildVAArg(B: BuilderRef,\n-                          list: ValueRef,\n-                          Ty: TypeRef,\n-                          Name: *const c_char)\n-                          -> ValueRef;\n-    pub fn LLVMBuildExtractElement(B: BuilderRef,\n-                                   VecVal: ValueRef,\n-                                   Index: ValueRef,\n-                                   Name: *const c_char)\n-                                   -> ValueRef;\n-    pub fn LLVMBuildInsertElement(B: BuilderRef,\n-                                  VecVal: ValueRef,\n-                                  EltVal: ValueRef,\n-                                  Index: ValueRef,\n-                                  Name: *const c_char)\n-                                  -> ValueRef;\n-    pub fn LLVMBuildShuffleVector(B: BuilderRef,\n-                                  V1: ValueRef,\n-                                  V2: ValueRef,\n-                                  Mask: ValueRef,\n-                                  Name: *const c_char)\n-                                  -> ValueRef;\n-    pub fn LLVMBuildExtractValue(B: BuilderRef,\n-                                 AggVal: ValueRef,\n-                                 Index: c_uint,\n-                                 Name: *const c_char)\n-                                 -> ValueRef;\n-    pub fn LLVMBuildInsertValue(B: BuilderRef,\n-                                AggVal: ValueRef,\n-                                EltVal: ValueRef,\n-                                Index: c_uint,\n-                                Name: *const c_char)\n-                                -> ValueRef;\n-\n-    pub fn LLVMRustBuildVectorReduceFAdd(B: BuilderRef,\n-                                         Acc: ValueRef,\n-                                         Src: ValueRef)\n-                                         -> ValueRef;\n-    pub fn LLVMRustBuildVectorReduceFMul(B: BuilderRef,\n-                                         Acc: ValueRef,\n-                                         Src: ValueRef)\n-                                         -> ValueRef;\n-    pub fn LLVMRustBuildVectorReduceAdd(B: BuilderRef,\n-                                        Src: ValueRef)\n-                                        -> ValueRef;\n-    pub fn LLVMRustBuildVectorReduceMul(B: BuilderRef,\n-                                        Src: ValueRef)\n-                                        -> ValueRef;\n-    pub fn LLVMRustBuildVectorReduceAnd(B: BuilderRef,\n-                                        Src: ValueRef)\n-                                        -> ValueRef;\n-    pub fn LLVMRustBuildVectorReduceOr(B: BuilderRef,\n-                                       Src: ValueRef)\n-                                       -> ValueRef;\n-    pub fn LLVMRustBuildVectorReduceXor(B: BuilderRef,\n-                                        Src: ValueRef)\n-                                        -> ValueRef;\n-    pub fn LLVMRustBuildVectorReduceMin(B: BuilderRef,\n-                                        Src: ValueRef,\n-                                        IsSigned: bool)\n-                                        -> ValueRef;\n-    pub fn LLVMRustBuildVectorReduceMax(B: BuilderRef,\n-                                        Src: ValueRef,\n-                                        IsSigned: bool)\n-                                        -> ValueRef;\n-    pub fn LLVMRustBuildVectorReduceFMin(B: BuilderRef,\n-                                         Src: ValueRef,\n-                                         IsNaN: bool)\n-                                         -> ValueRef;\n-    pub fn LLVMRustBuildVectorReduceFMax(B: BuilderRef,\n-                                         Src: ValueRef,\n-                                         IsNaN: bool)\n-                                         -> ValueRef;\n-\n-    pub fn LLVMRustBuildMinNum(B: BuilderRef, LHS: ValueRef, LHS: ValueRef) -> ValueRef;\n-    pub fn LLVMRustBuildMaxNum(B: BuilderRef, LHS: ValueRef, LHS: ValueRef) -> ValueRef;\n-\n-    pub fn LLVMBuildIsNull(B: BuilderRef, Val: ValueRef, Name: *const c_char) -> ValueRef;\n-    pub fn LLVMBuildIsNotNull(B: BuilderRef, Val: ValueRef, Name: *const c_char) -> ValueRef;\n-    pub fn LLVMBuildPtrDiff(B: BuilderRef,\n-                            LHS: ValueRef,\n-                            RHS: ValueRef,\n-                            Name: *const c_char)\n-                            -> ValueRef;\n-\n-    // Atomic Operations\n-    pub fn LLVMRustBuildAtomicLoad(B: BuilderRef,\n-                                   PointerVal: ValueRef,\n-                                   Name: *const c_char,\n-                                   Order: AtomicOrdering)\n-                                   -> ValueRef;\n-\n-    pub fn LLVMRustBuildAtomicStore(B: BuilderRef,\n-                                    Val: ValueRef,\n-                                    Ptr: ValueRef,\n-                                    Order: AtomicOrdering)\n-                                    -> ValueRef;\n-\n-    pub fn LLVMRustBuildAtomicCmpXchg(B: BuilderRef,\n-                                      LHS: ValueRef,\n-                                      CMP: ValueRef,\n-                                      RHS: ValueRef,\n-                                      Order: AtomicOrdering,\n-                                      FailureOrder: AtomicOrdering,\n-                                      Weak: Bool)\n-                                      -> ValueRef;\n-\n-    pub fn LLVMBuildAtomicRMW(B: BuilderRef,\n-                              Op: AtomicRmwBinOp,\n-                              LHS: ValueRef,\n-                              RHS: ValueRef,\n-                              Order: AtomicOrdering,\n-                              SingleThreaded: Bool)\n-                              -> ValueRef;\n-\n-    pub fn LLVMRustBuildAtomicFence(B: BuilderRef,\n-                                    Order: AtomicOrdering,\n-                                    Scope: SynchronizationScope);\n-\n-\n-    // Selected entries from the downcasts.\n-    pub fn LLVMIsATerminatorInst(Inst: ValueRef) -> ValueRef;\n-    pub fn LLVMIsAStoreInst(Inst: ValueRef) -> ValueRef;\n-\n-    /// Writes a module to the specified path. Returns 0 on success.\n-    pub fn LLVMWriteBitcodeToFile(M: ModuleRef, Path: *const c_char) -> c_int;\n-\n-    /// Creates target data from a target layout string.\n-    pub fn LLVMCreateTargetData(StringRep: *const c_char) -> TargetDataRef;\n-\n-    /// Disposes target data.\n-    pub fn LLVMDisposeTargetData(TD: TargetDataRef);\n-\n-    /// Creates a pass manager.\n-    pub fn LLVMCreatePassManager() -> PassManagerRef;\n-\n-    /// Creates a function-by-function pass manager\n-    pub fn LLVMCreateFunctionPassManagerForModule(M: ModuleRef) -> PassManagerRef;\n-\n-    /// Disposes a pass manager.\n-    pub fn LLVMDisposePassManager(PM: PassManagerRef);\n-\n-    /// Runs a pass manager on a module.\n-    pub fn LLVMRunPassManager(PM: PassManagerRef, M: ModuleRef) -> Bool;\n-\n-    pub fn LLVMInitializePasses();\n-\n-    pub fn LLVMPassManagerBuilderCreate() -> PassManagerBuilderRef;\n-    pub fn LLVMPassManagerBuilderDispose(PMB: PassManagerBuilderRef);\n-    pub fn LLVMPassManagerBuilderSetSizeLevel(PMB: PassManagerBuilderRef, Value: Bool);\n-    pub fn LLVMPassManagerBuilderSetDisableUnrollLoops(PMB: PassManagerBuilderRef, Value: Bool);\n-    pub fn LLVMPassManagerBuilderUseInlinerWithThreshold(PMB: PassManagerBuilderRef,\n-                                                         threshold: c_uint);\n-    pub fn LLVMPassManagerBuilderPopulateModulePassManager(PMB: PassManagerBuilderRef,\n-                                                           PM: PassManagerRef);\n-\n-    pub fn LLVMPassManagerBuilderPopulateFunctionPassManager(PMB: PassManagerBuilderRef,\n-                                                             PM: PassManagerRef);\n-    pub fn LLVMPassManagerBuilderPopulateLTOPassManager(PMB: PassManagerBuilderRef,\n-                                                        PM: PassManagerRef,\n-                                                        Internalize: Bool,\n-                                                        RunInliner: Bool);\n-    pub fn LLVMRustPassManagerBuilderPopulateThinLTOPassManager(\n-        PMB: PassManagerBuilderRef,\n-        PM: PassManagerRef) -> bool;\n-\n-    // Stuff that's in rustllvm/ because it's not upstream yet.\n-\n-    /// Opens an object file.\n-    pub fn LLVMCreateObjectFile(MemBuf: MemoryBufferRef) -> ObjectFileRef;\n-    /// Closes an object file.\n-    pub fn LLVMDisposeObjectFile(ObjFile: ObjectFileRef);\n-\n-    /// Enumerates the sections in an object file.\n-    pub fn LLVMGetSections(ObjFile: ObjectFileRef) -> SectionIteratorRef;\n-    /// Destroys a section iterator.\n-    pub fn LLVMDisposeSectionIterator(SI: SectionIteratorRef);\n-    /// Returns true if the section iterator is at the end of the section\n-    /// list:\n-    pub fn LLVMIsSectionIteratorAtEnd(ObjFile: ObjectFileRef, SI: SectionIteratorRef) -> Bool;\n-    /// Moves the section iterator to point to the next section.\n-    pub fn LLVMMoveToNextSection(SI: SectionIteratorRef);\n-    /// Returns the current section size.\n-    pub fn LLVMGetSectionSize(SI: SectionIteratorRef) -> c_ulonglong;\n-    /// Returns the current section contents as a string buffer.\n-    pub fn LLVMGetSectionContents(SI: SectionIteratorRef) -> *const c_char;\n-\n-    /// Reads the given file and returns it as a memory buffer. Use\n-    /// LLVMDisposeMemoryBuffer() to get rid of it.\n-    pub fn LLVMRustCreateMemoryBufferWithContentsOfFile(Path: *const c_char) -> MemoryBufferRef;\n-\n-    pub fn LLVMStartMultithreaded() -> Bool;\n-\n-    /// Returns a string describing the last error caused by an LLVMRust* call.\n-    pub fn LLVMRustGetLastError() -> *const c_char;\n-\n-    /// Print the pass timings since static dtors aren't picking them up.\n-    pub fn LLVMRustPrintPassTimings();\n-\n-    pub fn LLVMStructCreateNamed(C: ContextRef, Name: *const c_char) -> TypeRef;\n-\n-    pub fn LLVMStructSetBody(StructTy: TypeRef,\n-                             ElementTypes: *const TypeRef,\n-                             ElementCount: c_uint,\n-                             Packed: Bool);\n-\n-    /// Prepares inline assembly.\n-    pub fn LLVMRustInlineAsm(Ty: TypeRef,\n-                             AsmString: *const c_char,\n-                             Constraints: *const c_char,\n-                             SideEffects: Bool,\n-                             AlignStack: Bool,\n-                             Dialect: AsmDialect)\n-                             -> ValueRef;\n-\n-    pub fn LLVMRustDebugMetadataVersion() -> u32;\n-    pub fn LLVMRustVersionMajor() -> u32;\n-    pub fn LLVMRustVersionMinor() -> u32;\n-\n-    pub fn LLVMRustAddModuleFlag(M: ModuleRef, name: *const c_char, value: u32);\n-\n-    pub fn LLVMRustMetadataAsValue(C: ContextRef, MD: MetadataRef) -> ValueRef;\n-\n-    pub fn LLVMRustDIBuilderCreate(M: ModuleRef) -> DIBuilderRef;\n-\n-    pub fn LLVMRustDIBuilderDispose(Builder: DIBuilderRef);\n-\n-    pub fn LLVMRustDIBuilderFinalize(Builder: DIBuilderRef);\n-\n-    pub fn LLVMRustDIBuilderCreateCompileUnit(Builder: DIBuilderRef,\n-                                              Lang: c_uint,\n-                                              File: DIFile,\n-                                              Producer: *const c_char,\n-                                              isOptimized: bool,\n-                                              Flags: *const c_char,\n-                                              RuntimeVer: c_uint,\n-                                              SplitName: *const c_char)\n-                                              -> DIDescriptor;\n-\n-    pub fn LLVMRustDIBuilderCreateFile(Builder: DIBuilderRef,\n-                                       Filename: *const c_char,\n-                                       Directory: *const c_char)\n-                                       -> DIFile;\n-\n-    pub fn LLVMRustDIBuilderCreateSubroutineType(Builder: DIBuilderRef,\n-                                                 File: DIFile,\n-                                                 ParameterTypes: DIArray)\n-                                                 -> DICompositeType;\n-\n-    pub fn LLVMRustDIBuilderCreateFunction(Builder: DIBuilderRef,\n-                                           Scope: DIDescriptor,\n-                                           Name: *const c_char,\n-                                           LinkageName: *const c_char,\n-                                           File: DIFile,\n-                                           LineNo: c_uint,\n-                                           Ty: DIType,\n-                                           isLocalToUnit: bool,\n-                                           isDefinition: bool,\n-                                           ScopeLine: c_uint,\n-                                           Flags: DIFlags,\n-                                           isOptimized: bool,\n-                                           Fn: ValueRef,\n-                                           TParam: DIArray,\n-                                           Decl: DIDescriptor)\n-                                           -> DISubprogram;\n-\n-    pub fn LLVMRustDIBuilderCreateBasicType(Builder: DIBuilderRef,\n-                                            Name: *const c_char,\n-                                            SizeInBits: u64,\n-                                            AlignInBits: u32,\n-                                            Encoding: c_uint)\n-                                            -> DIBasicType;\n-\n-    pub fn LLVMRustDIBuilderCreatePointerType(Builder: DIBuilderRef,\n-                                              PointeeTy: DIType,\n-                                              SizeInBits: u64,\n-                                              AlignInBits: u32,\n-                                              Name: *const c_char)\n-                                              -> DIDerivedType;\n-\n-    pub fn LLVMRustDIBuilderCreateStructType(Builder: DIBuilderRef,\n-                                             Scope: DIDescriptor,\n-                                             Name: *const c_char,\n-                                             File: DIFile,\n-                                             LineNumber: c_uint,\n-                                             SizeInBits: u64,\n-                                             AlignInBits: u32,\n-                                             Flags: DIFlags,\n-                                             DerivedFrom: DIType,\n-                                             Elements: DIArray,\n-                                             RunTimeLang: c_uint,\n-                                             VTableHolder: DIType,\n-                                             UniqueId: *const c_char)\n-                                             -> DICompositeType;\n-\n-    pub fn LLVMRustDIBuilderCreateMemberType(Builder: DIBuilderRef,\n-                                             Scope: DIDescriptor,\n-                                             Name: *const c_char,\n-                                             File: DIFile,\n-                                             LineNo: c_uint,\n-                                             SizeInBits: u64,\n-                                             AlignInBits: u32,\n-                                             OffsetInBits: u64,\n-                                             Flags: DIFlags,\n-                                             Ty: DIType)\n-                                             -> DIDerivedType;\n-\n-    pub fn LLVMRustDIBuilderCreateLexicalBlock(Builder: DIBuilderRef,\n-                                               Scope: DIScope,\n-                                               File: DIFile,\n-                                               Line: c_uint,\n-                                               Col: c_uint)\n-                                               -> DILexicalBlock;\n-\n-    pub fn LLVMRustDIBuilderCreateLexicalBlockFile(Builder: DIBuilderRef,\n-                                                   Scope: DIScope,\n-                                                   File: DIFile)\n-                                                   -> DILexicalBlock;\n-\n-    pub fn LLVMRustDIBuilderCreateStaticVariable(Builder: DIBuilderRef,\n-                                                 Context: DIScope,\n-                                                 Name: *const c_char,\n-                                                 LinkageName: *const c_char,\n-                                                 File: DIFile,\n-                                                 LineNo: c_uint,\n-                                                 Ty: DIType,\n-                                                 isLocalToUnit: bool,\n-                                                 Val: ValueRef,\n-                                                 Decl: DIDescriptor,\n-                                                 AlignInBits: u32)\n-                                                 -> DIGlobalVariable;\n-\n-    pub fn LLVMRustDIBuilderCreateVariable(Builder: DIBuilderRef,\n-                                           Tag: c_uint,\n-                                           Scope: DIDescriptor,\n-                                           Name: *const c_char,\n-                                           File: DIFile,\n-                                           LineNo: c_uint,\n-                                           Ty: DIType,\n-                                           AlwaysPreserve: bool,\n-                                           Flags: DIFlags,\n-                                           ArgNo: c_uint,\n-                                           AlignInBits: u32)\n-                                           -> DIVariable;\n-\n-    pub fn LLVMRustDIBuilderCreateArrayType(Builder: DIBuilderRef,\n-                                            Size: u64,\n-                                            AlignInBits: u32,\n-                                            Ty: DIType,\n-                                            Subscripts: DIArray)\n-                                            -> DIType;\n-\n-    pub fn LLVMRustDIBuilderCreateVectorType(Builder: DIBuilderRef,\n-                                             Size: u64,\n-                                             AlignInBits: u32,\n-                                             Ty: DIType,\n-                                             Subscripts: DIArray)\n-                                             -> DIType;\n-\n-    pub fn LLVMRustDIBuilderGetOrCreateSubrange(Builder: DIBuilderRef,\n-                                                Lo: i64,\n-                                                Count: i64)\n-                                                -> DISubrange;\n-\n-    pub fn LLVMRustDIBuilderGetOrCreateArray(Builder: DIBuilderRef,\n-                                             Ptr: *const DIDescriptor,\n-                                             Count: c_uint)\n-                                             -> DIArray;\n-\n-    pub fn LLVMRustDIBuilderInsertDeclareAtEnd(Builder: DIBuilderRef,\n-                                               Val: ValueRef,\n-                                               VarInfo: DIVariable,\n-                                               AddrOps: *const i64,\n-                                               AddrOpsCount: c_uint,\n-                                               DL: ValueRef,\n-                                               InsertAtEnd: BasicBlockRef)\n-                                               -> ValueRef;\n-\n-    pub fn LLVMRustDIBuilderCreateEnumerator(Builder: DIBuilderRef,\n-                                             Name: *const c_char,\n-                                             Val: u64)\n-                                             -> DIEnumerator;\n-\n-    pub fn LLVMRustDIBuilderCreateEnumerationType(Builder: DIBuilderRef,\n-                                                  Scope: DIScope,\n-                                                  Name: *const c_char,\n-                                                  File: DIFile,\n-                                                  LineNumber: c_uint,\n-                                                  SizeInBits: u64,\n-                                                  AlignInBits: u32,\n-                                                  Elements: DIArray,\n-                                                  ClassType: DIType)\n-                                                  -> DIType;\n-\n-    pub fn LLVMRustDIBuilderCreateUnionType(Builder: DIBuilderRef,\n-                                            Scope: DIScope,\n-                                            Name: *const c_char,\n-                                            File: DIFile,\n-                                            LineNumber: c_uint,\n-                                            SizeInBits: u64,\n-                                            AlignInBits: u32,\n-                                            Flags: DIFlags,\n-                                            Elements: DIArray,\n-                                            RunTimeLang: c_uint,\n-                                            UniqueId: *const c_char)\n-                                            -> DIType;\n-\n-    pub fn LLVMSetUnnamedAddr(GlobalVar: ValueRef, UnnamedAddr: Bool);\n-\n-    pub fn LLVMRustDIBuilderCreateTemplateTypeParameter(Builder: DIBuilderRef,\n-                                                        Scope: DIScope,\n-                                                        Name: *const c_char,\n-                                                        Ty: DIType,\n-                                                        File: DIFile,\n-                                                        LineNo: c_uint,\n-                                                        ColumnNo: c_uint)\n-                                                        -> DITemplateTypeParameter;\n-\n-\n-    pub fn LLVMRustDIBuilderCreateNameSpace(Builder: DIBuilderRef,\n-                                            Scope: DIScope,\n-                                            Name: *const c_char,\n-                                            File: DIFile,\n-                                            LineNo: c_uint)\n-                                            -> DINameSpace;\n-    pub fn LLVMRustDICompositeTypeSetTypeArray(Builder: DIBuilderRef,\n-                                               CompositeType: DIType,\n-                                               TypeArray: DIArray);\n-\n-\n-    pub fn LLVMRustDIBuilderCreateDebugLocation(Context: ContextRef,\n-                                                Line: c_uint,\n-                                                Column: c_uint,\n-                                                Scope: DIScope,\n-                                                InlinedAt: MetadataRef)\n-                                                -> ValueRef;\n-    pub fn LLVMRustDIBuilderCreateOpDeref() -> i64;\n-    pub fn LLVMRustDIBuilderCreateOpPlusUconst() -> i64;\n-\n-    pub fn LLVMRustWriteTypeToString(Type: TypeRef, s: RustStringRef);\n-    pub fn LLVMRustWriteValueToString(value_ref: ValueRef, s: RustStringRef);\n-\n-    pub fn LLVMIsAConstantInt(value_ref: ValueRef) -> ValueRef;\n-    pub fn LLVMIsAConstantFP(value_ref: ValueRef) -> ValueRef;\n-\n-    pub fn LLVMRustPassKind(Pass: PassRef) -> PassKind;\n-    pub fn LLVMRustFindAndCreatePass(Pass: *const c_char) -> PassRef;\n-    pub fn LLVMRustAddPass(PM: PassManagerRef, Pass: PassRef);\n-\n-    pub fn LLVMRustHasFeature(T: TargetMachineRef, s: *const c_char) -> bool;\n-\n-    pub fn LLVMRustPrintTargetCPUs(T: TargetMachineRef);\n-    pub fn LLVMRustPrintTargetFeatures(T: TargetMachineRef);\n-\n-    pub fn LLVMRustCreateTargetMachine(Triple: *const c_char,\n-                                       CPU: *const c_char,\n-                                       Features: *const c_char,\n-                                       Model: CodeModel,\n-                                       Reloc: RelocMode,\n-                                       Level: CodeGenOptLevel,\n-                                       UseSoftFP: bool,\n-                                       PositionIndependentExecutable: bool,\n-                                       FunctionSections: bool,\n-                                       DataSections: bool,\n-                                       TrapUnreachable: bool,\n-                                       Singlethread: bool)\n-                                       -> TargetMachineRef;\n-    pub fn LLVMRustDisposeTargetMachine(T: TargetMachineRef);\n-    pub fn LLVMRustAddAnalysisPasses(T: TargetMachineRef, PM: PassManagerRef, M: ModuleRef);\n-    pub fn LLVMRustAddBuilderLibraryInfo(PMB: PassManagerBuilderRef,\n-                                         M: ModuleRef,\n-                                         DisableSimplifyLibCalls: bool);\n-    pub fn LLVMRustConfigurePassManagerBuilder(PMB: PassManagerBuilderRef,\n-                                               OptLevel: CodeGenOptLevel,\n-                                               MergeFunctions: bool,\n-                                               SLPVectorize: bool,\n-                                               LoopVectorize: bool,\n-                                               PrepareForThinLTO: bool,\n-                                               PGOGenPath: *const c_char,\n-                                               PGOUsePath: *const c_char);\n-    pub fn LLVMRustAddLibraryInfo(PM: PassManagerRef,\n-                                  M: ModuleRef,\n-                                  DisableSimplifyLibCalls: bool);\n-    pub fn LLVMRustRunFunctionPassManager(PM: PassManagerRef, M: ModuleRef);\n-    pub fn LLVMRustWriteOutputFile(T: TargetMachineRef,\n-                                   PM: PassManagerRef,\n-                                   M: ModuleRef,\n-                                   Output: *const c_char,\n-                                   FileType: FileType)\n-                                   -> LLVMRustResult;\n-    pub fn LLVMRustPrintModule(PM: PassManagerRef,\n-                               M: ModuleRef,\n-                               Output: *const c_char,\n-                               Demangle: extern fn(*const c_char,\n-                                                   size_t,\n-                                                   *mut c_char,\n-                                                   size_t) -> size_t);\n-    pub fn LLVMRustSetLLVMOptions(Argc: c_int, Argv: *const *const c_char);\n-    pub fn LLVMRustPrintPasses();\n-    pub fn LLVMRustSetNormalizedTarget(M: ModuleRef, triple: *const c_char);\n-    pub fn LLVMRustAddAlwaysInlinePass(P: PassManagerBuilderRef, AddLifetimes: bool);\n-    pub fn LLVMRustRunRestrictionPass(M: ModuleRef, syms: *const *const c_char, len: size_t);\n-    pub fn LLVMRustMarkAllFunctionsNounwind(M: ModuleRef);\n-\n-    pub fn LLVMRustOpenArchive(path: *const c_char) -> ArchiveRef;\n-    pub fn LLVMRustArchiveIteratorNew(AR: ArchiveRef) -> ArchiveIteratorRef;\n-    pub fn LLVMRustArchiveIteratorNext(AIR: ArchiveIteratorRef) -> ArchiveChildRef;\n-    pub fn LLVMRustArchiveChildName(ACR: ArchiveChildRef, size: *mut size_t) -> *const c_char;\n-    pub fn LLVMRustArchiveChildData(ACR: ArchiveChildRef, size: *mut size_t) -> *const c_char;\n-    pub fn LLVMRustArchiveChildFree(ACR: ArchiveChildRef);\n-    pub fn LLVMRustArchiveIteratorFree(AIR: ArchiveIteratorRef);\n-    pub fn LLVMRustDestroyArchive(AR: ArchiveRef);\n-\n-    pub fn LLVMRustGetSectionName(SI: SectionIteratorRef, data: *mut *const c_char) -> size_t;\n-\n-    pub fn LLVMRustWriteTwineToString(T: TwineRef, s: RustStringRef);\n-\n-    pub fn LLVMContextSetDiagnosticHandler(C: ContextRef,\n-                                           Handler: DiagnosticHandler,\n-                                           DiagnosticContext: *mut c_void);\n-\n-    pub fn LLVMRustUnpackOptimizationDiagnostic(DI: DiagnosticInfoRef,\n-                                                pass_name_out: RustStringRef,\n-                                                function_out: *mut ValueRef,\n-                                                loc_line_out: *mut c_uint,\n-                                                loc_column_out: *mut c_uint,\n-                                                loc_filename_out: RustStringRef,\n-                                                message_out: RustStringRef);\n-    pub fn LLVMRustUnpackInlineAsmDiagnostic(DI: DiagnosticInfoRef,\n-                                             cookie_out: *mut c_uint,\n-                                             message_out: *mut TwineRef,\n-                                             instruction_out: *mut ValueRef);\n-\n-    pub fn LLVMRustWriteDiagnosticInfoToString(DI: DiagnosticInfoRef, s: RustStringRef);\n-    pub fn LLVMRustGetDiagInfoKind(DI: DiagnosticInfoRef) -> DiagnosticKind;\n-\n-    pub fn LLVMRustSetInlineAsmDiagnosticHandler(C: ContextRef,\n-                                                 H: InlineAsmDiagHandler,\n-                                                 CX: *mut c_void);\n-\n-    pub fn LLVMRustWriteSMDiagnosticToString(d: SMDiagnosticRef, s: RustStringRef);\n-\n-    pub fn LLVMRustWriteArchive(Dst: *const c_char,\n-                                NumMembers: size_t,\n-                                Members: *const RustArchiveMemberRef,\n-                                WriteSymbtab: bool,\n-                                Kind: ArchiveKind)\n-                                -> LLVMRustResult;\n-    pub fn LLVMRustArchiveMemberNew(Filename: *const c_char,\n-                                    Name: *const c_char,\n-                                    Child: ArchiveChildRef)\n-                                    -> RustArchiveMemberRef;\n-    pub fn LLVMRustArchiveMemberFree(Member: RustArchiveMemberRef);\n-\n-    pub fn LLVMRustSetDataLayoutFromTargetMachine(M: ModuleRef, TM: TargetMachineRef);\n-\n-    pub fn LLVMRustBuildOperandBundleDef(Name: *const c_char,\n-                                         Inputs: *const ValueRef,\n-                                         NumInputs: c_uint)\n-                                         -> OperandBundleDefRef;\n-    pub fn LLVMRustFreeOperandBundleDef(Bundle: OperandBundleDefRef);\n-\n-    pub fn LLVMRustPositionBuilderAtStart(B: BuilderRef, BB: BasicBlockRef);\n-\n-    pub fn LLVMRustSetComdat(M: ModuleRef, V: ValueRef, Name: *const c_char);\n-    pub fn LLVMRustUnsetComdat(V: ValueRef);\n-    pub fn LLVMRustSetModulePIELevel(M: ModuleRef);\n-    pub fn LLVMRustModuleBufferCreate(M: ModuleRef) -> *mut ModuleBuffer;\n-    pub fn LLVMRustModuleBufferPtr(p: *const ModuleBuffer) -> *const u8;\n-    pub fn LLVMRustModuleBufferLen(p: *const ModuleBuffer) -> usize;\n-    pub fn LLVMRustModuleBufferFree(p: *mut ModuleBuffer);\n-    pub fn LLVMRustModuleCost(M: ModuleRef) -> u64;\n-\n-    pub fn LLVMRustThinLTOAvailable() -> bool;\n-    pub fn LLVMRustPGOAvailable() -> bool;\n-    pub fn LLVMRustWriteThinBitcodeToFile(PMR: PassManagerRef,\n-                                          M: ModuleRef,\n-                                          BC: *const c_char) -> bool;\n-    pub fn LLVMRustThinLTOBufferCreate(M: ModuleRef) -> *mut ThinLTOBuffer;\n-    pub fn LLVMRustThinLTOBufferFree(M: *mut ThinLTOBuffer);\n-    pub fn LLVMRustThinLTOBufferPtr(M: *const ThinLTOBuffer) -> *const c_char;\n-    pub fn LLVMRustThinLTOBufferLen(M: *const ThinLTOBuffer) -> size_t;\n-    pub fn LLVMRustCreateThinLTOData(\n-        Modules: *const ThinLTOModule,\n-        NumModules: c_uint,\n-        PreservedSymbols: *const *const c_char,\n-        PreservedSymbolsLen: c_uint,\n-    ) -> *mut ThinLTOData;\n-    pub fn LLVMRustPrepareThinLTORename(\n-        Data: *const ThinLTOData,\n-        Module: ModuleRef,\n-    ) -> bool;\n-    pub fn LLVMRustPrepareThinLTOResolveWeak(\n-        Data: *const ThinLTOData,\n-        Module: ModuleRef,\n-    ) -> bool;\n-    pub fn LLVMRustPrepareThinLTOInternalize(\n-        Data: *const ThinLTOData,\n-        Module: ModuleRef,\n-    ) -> bool;\n-    pub fn LLVMRustPrepareThinLTOImport(\n-        Data: *const ThinLTOData,\n-        Module: ModuleRef,\n-    ) -> bool;\n-    pub fn LLVMRustFreeThinLTOData(Data: *mut ThinLTOData);\n-    pub fn LLVMRustParseBitcodeForThinLTO(\n-        Context: ContextRef,\n-        Data: *const u8,\n-        len: usize,\n-        Identifier: *const c_char,\n-    ) -> ModuleRef;\n-    pub fn LLVMGetModuleIdentifier(M: ModuleRef, size: *mut usize) -> *const c_char;\n-    pub fn LLVMRustThinLTOGetDICompileUnit(M: ModuleRef,\n-                                           CU1: *mut *mut c_void,\n-                                           CU2: *mut *mut c_void);\n-    pub fn LLVMRustThinLTOPatchDICompileUnit(M: ModuleRef, CU: *mut c_void);\n-\n-    pub fn LLVMRustLinkerNew(M: ModuleRef) -> LinkerRef;\n-    pub fn LLVMRustLinkerAdd(linker: LinkerRef,\n-                             bytecode: *const c_char,\n-                             bytecode_len: usize) -> bool;\n-    pub fn LLVMRustLinkerFree(linker: LinkerRef);\n-}"}, {"sha": "05f6b5b5fbd289fc60c4f7cdf6408f7d7c16c4fa", "filename": "src/librustc_llvm/lib.rs", "status": "modified", "additions": 4, "deletions": 314, "changes": 318, "blob_url": "https://github.com/rust-lang/rust/blob/f89817997ac0aa100bf91997194ad85a7e59f743/src%2Flibrustc_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f89817997ac0aa100bf91997194ad85a7e59f743/src%2Flibrustc_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Flib.rs?ref=f89817997ac0aa100bf91997194ad85a7e59f743", "patch": "@@ -8,290 +8,20 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![allow(non_upper_case_globals)]\n-#![allow(non_camel_case_types)]\n-#![allow(non_snake_case)]\n-#![allow(dead_code)]\n+#![feature(static_nobundle)]\n \n #![doc(html_logo_url = \"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n        html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n        html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n \n-#![feature(box_syntax)]\n-#![feature(concat_idents)]\n-#![feature(libc)]\n-#![feature(link_args)]\n-#![feature(static_nobundle)]\n-\n // See librustc_cratesio_shim/Cargo.toml for a comment explaining this.\n #[allow(unused_extern_crates)]\n extern crate rustc_cratesio_shim;\n \n-#[macro_use]\n-extern crate bitflags;\n-extern crate libc;\n-\n-pub use self::IntPredicate::*;\n-pub use self::RealPredicate::*;\n-pub use self::TypeKind::*;\n-pub use self::AtomicRmwBinOp::*;\n-pub use self::MetadataType::*;\n-pub use self::CodeGenOptSize::*;\n-pub use self::CallConv::*;\n-pub use self::Linkage::*;\n-\n-use std::str::FromStr;\n-use std::slice;\n-use std::ffi::{CString, CStr};\n-use std::cell::RefCell;\n-use libc::{c_uint, c_char, size_t};\n-\n-pub mod archive_ro;\n-pub mod diagnostic;\n-mod ffi;\n-\n-pub use ffi::*;\n-\n-impl LLVMRustResult {\n-    pub fn into_result(self) -> Result<(), ()> {\n-        match self {\n-            LLVMRustResult::Success => Ok(()),\n-            LLVMRustResult::Failure => Err(()),\n-        }\n-    }\n-}\n-\n-pub fn AddFunctionAttrStringValue(llfn: ValueRef,\n-                                  idx: AttributePlace,\n-                                  attr: &CStr,\n-                                  value: &CStr) {\n-    unsafe {\n-        LLVMRustAddFunctionAttrStringValue(llfn,\n-                                           idx.as_uint(),\n-                                           attr.as_ptr(),\n-                                           value.as_ptr())\n-    }\n-}\n-\n-#[derive(Copy, Clone)]\n-pub enum AttributePlace {\n-    ReturnValue,\n-    Argument(u32),\n-    Function,\n-}\n-\n-impl AttributePlace {\n-    pub fn as_uint(self) -> c_uint {\n-        match self {\n-            AttributePlace::ReturnValue => 0,\n-            AttributePlace::Argument(i) => 1 + i,\n-            AttributePlace::Function => !0,\n-        }\n-    }\n-}\n-\n-#[derive(Copy, Clone, PartialEq)]\n-#[repr(C)]\n-pub enum CodeGenOptSize {\n-    CodeGenOptSizeNone = 0,\n-    CodeGenOptSizeDefault = 1,\n-    CodeGenOptSizeAggressive = 2,\n-}\n-\n-impl FromStr for ArchiveKind {\n-    type Err = ();\n-\n-    fn from_str(s: &str) -> Result<Self, Self::Err> {\n-        match s {\n-            \"gnu\" => Ok(ArchiveKind::K_GNU),\n-            \"bsd\" => Ok(ArchiveKind::K_BSD),\n-            \"coff\" => Ok(ArchiveKind::K_COFF),\n-            _ => Err(()),\n-        }\n-    }\n-}\n-\n-#[allow(missing_copy_implementations)]\n-pub enum RustString_opaque {}\n-type RustStringRef = *mut RustString_opaque;\n-type RustStringRepr = *mut RefCell<Vec<u8>>;\n-\n-/// Appending to a Rust string -- used by RawRustStringOstream.\n-#[no_mangle]\n-pub unsafe extern \"C\" fn LLVMRustStringWriteImpl(sr: RustStringRef,\n-                                                 ptr: *const c_char,\n-                                                 size: size_t) {\n-    let slice = slice::from_raw_parts(ptr as *const u8, size as usize);\n-\n-    let sr = sr as RustStringRepr;\n-    (*sr).borrow_mut().extend_from_slice(slice);\n-}\n-\n-pub fn SetInstructionCallConv(instr: ValueRef, cc: CallConv) {\n-    unsafe {\n-        LLVMSetInstructionCallConv(instr, cc as c_uint);\n-    }\n-}\n-pub fn SetFunctionCallConv(fn_: ValueRef, cc: CallConv) {\n-    unsafe {\n-        LLVMSetFunctionCallConv(fn_, cc as c_uint);\n-    }\n-}\n-\n-// Externally visible symbols that might appear in multiple codegen units need to appear in\n-// their own comdat section so that the duplicates can be discarded at link time. This can for\n-// example happen for generics when using multiple codegen units. This function simply uses the\n-// value's name as the comdat value to make sure that it is in a 1-to-1 relationship to the\n-// function.\n-// For more details on COMDAT sections see e.g. http://www.airs.com/blog/archives/52\n-pub fn SetUniqueComdat(llmod: ModuleRef, val: ValueRef) {\n-    unsafe {\n-        LLVMRustSetComdat(llmod, val, LLVMGetValueName(val));\n-    }\n-}\n-\n-pub fn UnsetComdat(val: ValueRef) {\n-    unsafe {\n-        LLVMRustUnsetComdat(val);\n-    }\n-}\n-\n-pub fn SetUnnamedAddr(global: ValueRef, unnamed: bool) {\n-    unsafe {\n-        LLVMSetUnnamedAddr(global, unnamed as Bool);\n-    }\n-}\n-\n-pub fn set_thread_local(global: ValueRef, is_thread_local: bool) {\n-    unsafe {\n-        LLVMSetThreadLocal(global, is_thread_local as Bool);\n-    }\n-}\n-pub fn set_thread_local_mode(global: ValueRef, mode: ThreadLocalMode) {\n-    unsafe {\n-        LLVMSetThreadLocalMode(global, mode);\n-    }\n-}\n-\n-impl Attribute {\n-    pub fn apply_llfn(&self, idx: AttributePlace, llfn: ValueRef) {\n-        unsafe { LLVMRustAddFunctionAttribute(llfn, idx.as_uint(), *self) }\n-    }\n-\n-    pub fn apply_callsite(&self, idx: AttributePlace, callsite: ValueRef) {\n-        unsafe { LLVMRustAddCallSiteAttribute(callsite, idx.as_uint(), *self) }\n-    }\n-\n-    pub fn unapply_llfn(&self, idx: AttributePlace, llfn: ValueRef) {\n-        unsafe { LLVMRustRemoveFunctionAttributes(llfn, idx.as_uint(), *self) }\n-    }\n-\n-    pub fn toggle_llfn(&self, idx: AttributePlace, llfn: ValueRef, set: bool) {\n-        if set {\n-            self.apply_llfn(idx, llfn);\n-        } else {\n-            self.unapply_llfn(idx, llfn);\n-        }\n-    }\n-}\n-\n-// Memory-managed interface to target data.\n-\n-struct TargetData {\n-    lltd: TargetDataRef,\n-}\n-\n-impl Drop for TargetData {\n-    fn drop(&mut self) {\n-        unsafe {\n-            LLVMDisposeTargetData(self.lltd);\n-        }\n-    }\n-}\n-\n-fn mk_target_data(string_rep: &str) -> TargetData {\n-    let string_rep = CString::new(string_rep).unwrap();\n-    TargetData { lltd: unsafe { LLVMCreateTargetData(string_rep.as_ptr()) } }\n-}\n-\n-// Memory-managed interface to object files.\n-\n-pub struct ObjectFile {\n-    pub llof: ObjectFileRef,\n-}\n-\n-unsafe impl Send for ObjectFile {}\n-\n-impl ObjectFile {\n-    // This will take ownership of llmb\n-    pub fn new(llmb: MemoryBufferRef) -> Option<ObjectFile> {\n-        unsafe {\n-            let llof = LLVMCreateObjectFile(llmb);\n-            if llof as isize == 0 {\n-                // LLVMCreateObjectFile took ownership of llmb\n-                return None;\n-            }\n-\n-            Some(ObjectFile { llof: llof })\n-        }\n-    }\n-}\n-\n-impl Drop for ObjectFile {\n-    fn drop(&mut self) {\n-        unsafe {\n-            LLVMDisposeObjectFile(self.llof);\n-        }\n-    }\n-}\n-\n-// Memory-managed interface to section iterators.\n-\n-pub struct SectionIter {\n-    pub llsi: SectionIteratorRef,\n-}\n-\n-impl Drop for SectionIter {\n-    fn drop(&mut self) {\n-        unsafe {\n-            LLVMDisposeSectionIterator(self.llsi);\n-        }\n-    }\n-}\n-\n-pub fn mk_section_iter(llof: ObjectFileRef) -> SectionIter {\n-    unsafe { SectionIter { llsi: LLVMGetSections(llof) } }\n-}\n-\n-/// Safe wrapper around `LLVMGetParam`, because segfaults are no fun.\n-pub fn get_param(llfn: ValueRef, index: c_uint) -> ValueRef {\n-    unsafe {\n-        assert!(index < LLVMCountParams(llfn),\n-            \"out of bounds argument access: {} out of {} arguments\", index, LLVMCountParams(llfn));\n-        LLVMGetParam(llfn, index)\n-    }\n-}\n-\n-fn get_params(llfn: ValueRef) -> Vec<ValueRef> {\n-    unsafe {\n-        let num_params = LLVMCountParams(llfn);\n-\n-        (0..num_params).map(|idx| LLVMGetParam(llfn, idx)).collect()\n-    }\n-}\n-\n-pub fn build_string<F>(f: F) -> Option<String>\n-    where F: FnOnce(RustStringRef)\n-{\n-    let mut buf = RefCell::new(Vec::new());\n-    f(&mut buf as RustStringRepr as RustStringRef);\n-    String::from_utf8(buf.into_inner()).ok()\n-}\n-\n-pub unsafe fn twine_to_string(tr: TwineRef) -> String {\n-    build_string(|s| LLVMRustWriteTwineToString(tr, s)).expect(\"got a non-UTF8 Twine from LLVM\")\n-}\n+// NOTE: This crate only exists to allow linking on mingw targets.\n \n+/// Initialize targets enabled by the build script via `cfg(llvm_component = \"...\")`.\n+/// NB: this function can't be moved to `rustc_codegen_llvm` because of the `cfg`s.\n pub fn initialize_available_targets() {\n     macro_rules! init_target(\n         ($cfg:meta, $($method:ident),*) => { {\n@@ -383,43 +113,3 @@ pub fn initialize_available_targets() {\n                  LLVMInitializeWebAssemblyTargetMC,\n                  LLVMInitializeWebAssemblyAsmPrinter);\n }\n-\n-pub fn last_error() -> Option<String> {\n-    unsafe {\n-        let cstr = LLVMRustGetLastError();\n-        if cstr.is_null() {\n-            None\n-        } else {\n-            let err = CStr::from_ptr(cstr).to_bytes();\n-            let err = String::from_utf8_lossy(err).to_string();\n-            libc::free(cstr as *mut _);\n-            Some(err)\n-        }\n-    }\n-}\n-\n-pub struct OperandBundleDef {\n-    inner: OperandBundleDefRef,\n-}\n-\n-impl OperandBundleDef {\n-    pub fn new(name: &str, vals: &[ValueRef]) -> OperandBundleDef {\n-        let name = CString::new(name).unwrap();\n-        let def = unsafe {\n-            LLVMRustBuildOperandBundleDef(name.as_ptr(), vals.as_ptr(), vals.len() as c_uint)\n-        };\n-        OperandBundleDef { inner: def }\n-    }\n-\n-    pub fn raw(&self) -> OperandBundleDefRef {\n-        self.inner\n-    }\n-}\n-\n-impl Drop for OperandBundleDef {\n-    fn drop(&mut self) {\n-        unsafe {\n-            LLVMRustFreeOperandBundleDef(self.inner);\n-        }\n-    }\n-}"}, {"sha": "a50a5a2d1cbe711014b1587563da7b3782177a81", "filename": "src/librustc_target/lib.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f89817997ac0aa100bf91997194ad85a7e59f743/src%2Flibrustc_target%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f89817997ac0aa100bf91997194ad85a7e59f743/src%2Flibrustc_target%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Flib.rs?ref=f89817997ac0aa100bf91997194ad85a7e59f743", "patch": "@@ -15,11 +15,7 @@\n //! is really just odds-and-ends relating to code gen and linking.\n //! This crate mostly exists to make rustc smaller, so we might put\n //! more 'stuff' here in the future.  It does not have a dependency on\n-//! rustc_llvm.\n-//!\n-//! FIXME: Split this into two crates: one that has deps on syntax, and\n-//! one that doesn't; the one that doesn't might get decent parallel\n-//! build speedups.\n+//! LLVM.\n \n #![doc(html_logo_url = \"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n       html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\","}, {"sha": "49a4962858ca733d0a65ddd8ad376a25798e1512", "filename": "src/rustllvm/ArchiveWrapper.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f89817997ac0aa100bf91997194ad85a7e59f743/src%2Frustllvm%2FArchiveWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/f89817997ac0aa100bf91997194ad85a7e59f743/src%2Frustllvm%2FArchiveWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FArchiveWrapper.cpp?ref=f89817997ac0aa100bf91997194ad85a7e59f743", "patch": "@@ -148,7 +148,7 @@ LLVMRustArchiveChildName(LLVMRustArchiveChildConstRef Child, size_t *Size) {\n #if LLVM_VERSION_GE(4, 0)\n   Expected<StringRef> NameOrErr = Child->getName();\n   if (!NameOrErr) {\n-    // rustc_llvm currently doesn't use this error string, but it might be\n+    // rustc_codegen_llvm currently doesn't use this error string, but it might be\n     // useful in the future, and in the mean time this tells LLVM that the\n     // error was not ignored and that it shouldn't abort the process.\n     LLVMRustSetLastError(toString(NameOrErr.takeError()).c_str());"}, {"sha": "3f5550bf95fd234e8587590260fc833190d5b9fc", "filename": "src/rustllvm/PassWrapper.cpp", "status": "modified", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f89817997ac0aa100bf91997194ad85a7e59f743/src%2Frustllvm%2FPassWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/f89817997ac0aa100bf91997194ad85a7e59f743/src%2Frustllvm%2FPassWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FPassWrapper.cpp?ref=f89817997ac0aa100bf91997194ad85a7e59f743", "patch": "@@ -828,23 +828,6 @@ LLVMRustPGOAvailable() {\n // and various online resources about ThinLTO to make heads or tails of all\n // this.\n \n-extern \"C\" bool\n-LLVMRustWriteThinBitcodeToFile(LLVMPassManagerRef PMR,\n-                               LLVMModuleRef M,\n-                               const char *BcFile) {\n-  llvm::legacy::PassManager *PM = unwrap<llvm::legacy::PassManager>(PMR);\n-  std::error_code EC;\n-  llvm::raw_fd_ostream bc(BcFile, EC, llvm::sys::fs::F_None);\n-  if (EC) {\n-    LLVMRustSetLastError(EC.message().c_str());\n-    return false;\n-  }\n-  PM->add(createWriteThinLTOBitcodePass(bc));\n-  PM->run(*unwrap(M));\n-  delete PM;\n-  return true;\n-}\n-\n // This is a shared data structure which *must* be threadsafe to share\n // read-only amongst threads. This also corresponds basically to the arguments\n // of the `ProcessThinLTOModule` function in the LLVM source.\n@@ -1259,13 +1242,6 @@ LLVMRustThinLTOPatchDICompileUnit(LLVMModuleRef Mod, DICompileUnit *Unit) {\n \n #else\n \n-extern \"C\" bool\n-LLVMRustWriteThinBitcodeToFile(LLVMPassManagerRef PMR,\n-                               LLVMModuleRef M,\n-                               const char *BcFile) {\n-  report_fatal_error(\"ThinLTO not available\");\n-}\n-\n struct LLVMRustThinLTOData {\n };\n "}, {"sha": "f2b5297285ca79623d4ccad6e3b13d69625dda09", "filename": "src/rustllvm/RustWrapper.cpp", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f89817997ac0aa100bf91997194ad85a7e59f743/src%2Frustllvm%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/f89817997ac0aa100bf91997194ad85a7e59f743/src%2Frustllvm%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FRustWrapper.cpp?ref=f89817997ac0aa100bf91997194ad85a7e59f743", "patch": "@@ -750,15 +750,6 @@ LLVMRustDIBuilderCreateArrayType(LLVMRustDIBuilderRef Builder, uint64_t Size,\n                                DINodeArray(unwrapDI<MDTuple>(Subscripts))));\n }\n \n-extern \"C\" LLVMMetadataRef\n-LLVMRustDIBuilderCreateVectorType(LLVMRustDIBuilderRef Builder, uint64_t Size,\n-                                  uint32_t AlignInBits, LLVMMetadataRef Ty,\n-                                  LLVMMetadataRef Subscripts) {\n-  return wrap(\n-      Builder->createVectorType(Size, AlignInBits, unwrapDI<DIType>(Ty),\n-                                DINodeArray(unwrapDI<MDTuple>(Subscripts))));\n-}\n-\n extern \"C\" LLVMMetadataRef\n LLVMRustDIBuilderGetOrCreateSubrange(LLVMRustDIBuilderRef Builder, int64_t Lo,\n                                      int64_t Count) {"}]}