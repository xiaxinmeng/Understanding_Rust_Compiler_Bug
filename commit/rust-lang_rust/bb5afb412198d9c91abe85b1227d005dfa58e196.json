{"sha": "bb5afb412198d9c91abe85b1227d005dfa58e196", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJiNWFmYjQxMjE5OGQ5YzkxYWJlODViMTIyN2QwMDVkZmE1OGUxOTY=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2016-09-24T13:49:51Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2016-10-26T19:41:16Z"}, "message": "use a struct abstraction in check_match", "tree": {"sha": "9425d5e584315e739756e6dd2442eba49e75c2b5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9425d5e584315e739756e6dd2442eba49e75c2b5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bb5afb412198d9c91abe85b1227d005dfa58e196", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bb5afb412198d9c91abe85b1227d005dfa58e196", "html_url": "https://github.com/rust-lang/rust/commit/bb5afb412198d9c91abe85b1227d005dfa58e196", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bb5afb412198d9c91abe85b1227d005dfa58e196/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b69cca6da49b2cbb1d6346b5280c464847e2fe20", "url": "https://api.github.com/repos/rust-lang/rust/commits/b69cca6da49b2cbb1d6346b5280c464847e2fe20", "html_url": "https://github.com/rust-lang/rust/commit/b69cca6da49b2cbb1d6346b5280c464847e2fe20"}], "stats": {"total": 154, "additions": 94, "deletions": 60}, "files": [{"sha": "f8ac841a0a265c7b919eb0abcc11565de8a50ec1", "filename": "src/librustc_const_eval/check_match.rs", "status": "modified", "additions": 94, "deletions": 60, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/bb5afb412198d9c91abe85b1227d005dfa58e196/src%2Flibrustc_const_eval%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb5afb412198d9c91abe85b1227d005dfa58e196/src%2Flibrustc_const_eval%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fcheck_match.rs?ref=bb5afb412198d9c91abe85b1227d005dfa58e196", "patch": "@@ -52,7 +52,55 @@ pub const DUMMY_WILD_PAT: &'static Pat = &Pat {\n     span: DUMMY_SP\n };\n \n-struct Matrix<'a, 'tcx>(Vec<Vec<(&'a Pat, Option<Ty<'tcx>>)>>);\n+pub const DUMMY_WILD_PATTERN : Pattern<'static, 'static> = Pattern {\n+    pat: DUMMY_WILD_PAT,\n+    pattern_ty: None\n+};\n+\n+#[derive(Copy, Clone)]\n+pub struct Pattern<'a, 'tcx> {\n+    pat: &'a Pat,\n+    pattern_ty: Option<Ty<'tcx>>\n+}\n+\n+impl<'a, 'tcx> Pattern<'a, 'tcx> {\n+    fn as_raw(self) -> &'a Pat {\n+        let mut pat = self.pat;\n+\n+        while let PatKind::Binding(.., Some(ref s)) = pat.node {\n+            pat = s;\n+        }\n+\n+        return pat;\n+    }\n+\n+\n+    /// Checks for common cases of \"catchall\" patterns that may not be intended as such.\n+    fn is_catchall(self, dm: &DefMap) -> bool {\n+        fn is_catchall(dm: &DefMap, pat: &Pat) -> bool {\n+            match pat.node {\n+                PatKind::Binding(.., None) => true,\n+                PatKind::Binding(.., Some(ref s)) => is_catchall(dm, s),\n+                PatKind::Ref(ref s, _) => is_catchall(dm, s),\n+                PatKind::Tuple(ref v, _) => v.iter().all(|p|is_catchall(dm, &p)),\n+                _ => false\n+            }\n+        }\n+        is_catchall(dm, self.pat)\n+    }\n+\n+    fn span(self) -> Span {\n+        self.pat.span\n+    }\n+}\n+\n+struct Matrix<'a, 'tcx>(Vec<Vec<Pattern<'a, 'tcx>>>);\n+\n+impl<'a, 'tcx> fmt::Debug for Pattern<'a, 'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"{}: {:?}\", pat_to_string(self.pat), self.pattern_ty)\n+    }\n+}\n \n /// Pretty-printer for matrices of patterns, example:\n /// ++++++++++++++++++++++++++\n@@ -72,9 +120,7 @@ impl<'a, 'tcx> fmt::Debug for Matrix<'a, 'tcx> {\n \n         let &Matrix(ref m) = self;\n         let pretty_printed_matrix: Vec<Vec<String>> = m.iter().map(|row| {\n-            row.iter()\n-               .map(|&(pat,ty)| format!(\"{}: {:?}\", pat_to_string(&pat), ty))\n-               .collect::<Vec<String>>()\n+            row.iter().map(|pat| format!(\"{:?}\", pat)).collect()\n         }).collect();\n \n         let column_count = m.iter().map(|row| row.len()).max().unwrap_or(0);\n@@ -100,9 +146,8 @@ impl<'a, 'tcx> fmt::Debug for Matrix<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> FromIterator<Vec<(&'a Pat, Option<Ty<'tcx>>)>> for Matrix<'a, 'tcx> {\n-    fn from_iter<T: IntoIterator<Item=Vec<(&'a Pat, Option<Ty<'tcx>>)>>>(iter: T)\n-                                                                         -> Self\n+impl<'a, 'tcx> FromIterator<Vec<Pattern<'a, 'tcx>>> for Matrix<'a, 'tcx> {\n+    fn from_iter<T: IntoIterator<Item=Vec<Pattern<'a, 'tcx>>>>(iter: T) -> Self\n     {\n         Matrix(iter.into_iter().collect())\n     }\n@@ -349,8 +394,8 @@ fn check_arms(cx: &MatchCheckCtxt,\n                             err.span_label(pat.span, &format!(\"this is an unreachable pattern\"));\n                             // if we had a catchall pattern, hint at that\n                             for row in &seen.0 {\n-                                if pat_is_catchall(&cx.tcx.def_map.borrow(), row[0].0) {\n-                                    span_note!(err, row[0].0.span,\n+                                if row[0].is_catchall(&cx.tcx.def_map.borrow()) {\n+                                    span_note!(err, row[0].span(),\n                                                \"this pattern matches any value\");\n                                 }\n                             }\n@@ -374,29 +419,11 @@ fn check_arms(cx: &MatchCheckCtxt,\n     }\n }\n \n-/// Checks for common cases of \"catchall\" patterns that may not be intended as such.\n-fn pat_is_catchall(dm: &DefMap, p: &Pat) -> bool {\n-    match p.node {\n-        PatKind::Binding(.., None) => true,\n-        PatKind::Binding(.., Some(ref s)) => pat_is_catchall(dm, &s),\n-        PatKind::Ref(ref s, _) => pat_is_catchall(dm, &s),\n-        PatKind::Tuple(ref v, _) => v.iter().all(|p| pat_is_catchall(dm, &p)),\n-        _ => false\n-    }\n-}\n-\n-fn raw_pat(p: &Pat) -> &Pat {\n-    match p.node {\n-        PatKind::Binding(.., Some(ref s)) => raw_pat(&s),\n-        _ => p\n-    }\n-}\n-\n fn check_exhaustive<'a, 'tcx>(cx: &MatchCheckCtxt<'a, 'tcx>,\n                               sp: Span,\n                               matrix: &Matrix<'a, 'tcx>,\n                               source: hir::MatchSource) {\n-    match is_useful(cx, matrix, &[(DUMMY_WILD_PAT, None)], ConstructWitness) {\n+    match is_useful(cx, matrix, &[DUMMY_WILD_PATTERN], ConstructWitness) {\n         UsefulWithWitness(pats) => {\n             let witnesses = if pats.is_empty() {\n                 vec![DUMMY_WILD_PAT]\n@@ -655,7 +682,7 @@ impl Constructor {\n fn missing_constructors(cx: &MatchCheckCtxt, &Matrix(ref rows): &Matrix,\n                        left_ty: Ty, max_slice_length: usize) -> Vec<Constructor> {\n     let used_constructors: Vec<Constructor> = rows.iter()\n-        .flat_map(|row| pat_constructors(cx, row[0].0, left_ty, max_slice_length))\n+        .flat_map(|row| pat_constructors(cx, row[0], left_ty, max_slice_length))\n         .collect();\n     all_constructors(cx, left_ty, max_slice_length)\n         .into_iter()\n@@ -695,7 +722,7 @@ fn all_constructors(_cx: &MatchCheckCtxt, left_ty: Ty,\n // So it assumes that v is non-empty.\n fn is_useful<'a, 'tcx>(cx: &MatchCheckCtxt<'a, 'tcx>,\n                        matrix: &Matrix<'a, 'tcx>,\n-                       v: &[(&Pat, Option<Ty<'tcx>>)],\n+                       v: &[Pattern<'a, 'tcx>],\n                        witness: WitnessPreference)\n                        -> Usefulness {\n     let &Matrix(ref rows) = matrix;\n@@ -710,20 +737,22 @@ fn is_useful<'a, 'tcx>(cx: &MatchCheckCtxt<'a, 'tcx>,\n         return NotUseful;\n     }\n     assert!(rows.iter().all(|r| r.len() == v.len()));\n-    let left_ty = match rows.iter().filter_map(|r| r[0].1).next().or_else(|| v[0].1) {\n+    let left_ty = match rows.iter().filter_map(|r| r[0].pattern_ty).next()\n+        .or_else(|| v[0].pattern_ty)\n+    {\n         Some(ty) => ty,\n         None => {\n             // all patterns are wildcards - we can pick any type we want\n             cx.tcx.types.bool\n         }\n     };\n \n-    let max_slice_length = rows.iter().filter_map(|row| match row[0].0.node {\n+    let max_slice_length = rows.iter().filter_map(|row| match row[0].pat.node {\n         PatKind::Slice(ref before, _, ref after) => Some(before.len() + after.len()),\n         _ => None\n     }).max().map_or(0, |v| v + 1);\n \n-    let constructors = pat_constructors(cx, v[0].0, left_ty, max_slice_length);\n+    let constructors = pat_constructors(cx, v[0], left_ty, max_slice_length);\n     debug!(\"is_useful - pat_constructors = {:?} left_ty = {:?}\", constructors,\n            left_ty);\n     if constructors.is_empty() {\n@@ -749,7 +778,7 @@ fn is_useful<'a, 'tcx>(cx: &MatchCheckCtxt<'a, 'tcx>,\n             }).find(|result| result != &NotUseful).unwrap_or(NotUseful)\n         } else {\n             let matrix = rows.iter().filter_map(|r| {\n-                match raw_pat(r[0].0).node {\n+                match r[0].as_raw().node {\n                     PatKind::Binding(..) | PatKind::Wild => Some(r[1..].to_vec()),\n                     _ => None,\n                 }\n@@ -777,7 +806,7 @@ fn is_useful<'a, 'tcx>(cx: &MatchCheckCtxt<'a, 'tcx>,\n fn is_useful_specialized<'a, 'tcx>(\n     cx: &MatchCheckCtxt<'a, 'tcx>,\n     &Matrix(ref m): &Matrix<'a, 'tcx>,\n-    v: &[(&Pat, Option<Ty<'tcx>>)],\n+    v: &[Pattern<'a, 'tcx>],\n     ctor: Constructor,\n     lty: Ty<'tcx>,\n     witness: WitnessPreference) -> Usefulness\n@@ -801,18 +830,18 @@ fn is_useful_specialized<'a, 'tcx>(\n ///\n /// On the other hand, a wild pattern and an identifier pattern cannot be\n /// specialized in any way.\n-fn pat_constructors(cx: &MatchCheckCtxt, p: &Pat,\n+fn pat_constructors(cx: &MatchCheckCtxt, p: Pattern,\n                     left_ty: Ty, max_slice_length: usize) -> Vec<Constructor> {\n-    let pat = raw_pat(p);\n+    let pat = p.as_raw();\n     match pat.node {\n         PatKind::Struct(..) | PatKind::TupleStruct(..) | PatKind::Path(..) =>\n             match cx.tcx.expect_def(pat.id) {\n                 Def::Variant(id) | Def::VariantCtor(id, ..) => vec![Variant(id)],\n                 Def::Struct(..) | Def::StructCtor(..) | Def::Union(..) |\n                 Def::TyAlias(..) | Def::AssociatedTy(..) => vec![Single],\n                 Def::Const(..) | Def::AssociatedConst(..) =>\n-                    span_bug!(pat.span, \"const pattern should've been rewritten\"),\n-                def => span_bug!(pat.span, \"pat_constructors: unexpected definition {:?}\", def),\n+                    span_bug!(p.span(), \"const pattern should've been rewritten\"),\n+                def => span_bug!(p.span(), \"pat_constructors: unexpected definition {:?}\", def),\n             },\n         PatKind::Lit(ref expr) =>\n             vec![ConstantValue(eval_const_expr(cx.tcx, &expr))],\n@@ -881,15 +910,18 @@ fn range_covered_by_constructor(tcx: TyCtxt, span: Span,\n \n fn wrap_pat<'a, 'b, 'tcx>(cx: &MatchCheckCtxt<'b, 'tcx>,\n                           pat: &'a Pat)\n-                          -> (&'a Pat, Option<Ty<'tcx>>)\n+                          -> Pattern<'a, 'tcx>\n {\n     let pat_ty = cx.tcx.pat_ty(pat);\n-    (pat, Some(match pat.node {\n-        PatKind::Binding(hir::BindByRef(..), ..) => {\n-            pat_ty.builtin_deref(false, ty::NoPreference).unwrap().ty\n-        }\n-        _ => pat_ty\n-    }))\n+    Pattern {\n+        pat: pat,\n+        pattern_ty: Some(match pat.node {\n+            PatKind::Binding(hir::BindByRef(..), ..) => {\n+                pat_ty.builtin_deref(false, ty::NoPreference).unwrap().ty\n+            }\n+            _ => pat_ty\n+        })\n+    }\n }\n \n /// This is the main specialization step. It expands the first pattern in the given row\n@@ -902,20 +934,19 @@ fn wrap_pat<'a, 'b, 'tcx>(cx: &MatchCheckCtxt<'b, 'tcx>,\n /// fields filled with wild patterns.\n pub fn specialize<'a, 'b, 'tcx>(\n     cx: &MatchCheckCtxt<'b, 'tcx>,\n-    r: &[(&'a Pat, Option<Ty<'tcx>>)],\n+    r: &[Pattern<'a, 'tcx>],\n     constructor: &Constructor, col: usize, arity: usize)\n-    -> Option<Vec<(&'a Pat, Option<Ty<'tcx>>)>>\n+    -> Option<Vec<Pattern<'a, 'tcx>>>\n {\n-    let pat = raw_pat(r[col].0);\n+    let pat = r[col].as_raw();\n     let &Pat {\n         id: pat_id, ref node, span: pat_span\n     } = pat;\n     let wpat = |pat: &'a Pat| wrap_pat(cx, pat);\n-    let dummy_pat = (DUMMY_WILD_PAT, None);\n \n-    let head: Option<Vec<(&Pat, Option<Ty>)>> = match *node {\n+    let head: Option<Vec<Pattern>> = match *node {\n         PatKind::Binding(..) | PatKind::Wild =>\n-            Some(vec![dummy_pat; arity]),\n+            Some(vec![DUMMY_WILD_PATTERN; arity]),\n \n         PatKind::Path(..) => {\n             match cx.tcx.expect_def(pat_id) {\n@@ -942,7 +973,7 @@ pub fn specialize<'a, 'b, 'tcx>(\n                             let mut pats: Vec<_> = args[..ddpos].iter().map(|p| {\n                                 wpat(p)\n                             }).collect();\n-                            pats.extend(repeat((DUMMY_WILD_PAT, None)).take(arity - args.len()));\n+                            pats.extend(repeat(DUMMY_WILD_PATTERN).take(arity - args.len()));\n                             pats.extend(args[ddpos..].iter().map(|p| wpat(p)));\n                             Some(pats)\n                         }\n@@ -961,7 +992,7 @@ pub fn specialize<'a, 'b, 'tcx>(\n                 Some(variant.fields.iter().map(|sf| {\n                     match pattern_fields.iter().find(|f| f.node.name == sf.name) {\n                         Some(ref f) => wpat(&f.node.pat),\n-                        _ => dummy_pat\n+                        _ => DUMMY_WILD_PATTERN\n                     }\n                 }).collect())\n             } else {\n@@ -971,7 +1002,7 @@ pub fn specialize<'a, 'b, 'tcx>(\n \n         PatKind::Tuple(ref args, Some(ddpos)) => {\n             let mut pats: Vec<_> = args[..ddpos].iter().map(|p| wpat(p)).collect();\n-            pats.extend(repeat(dummy_pat).take(arity - args.len()));\n+            pats.extend(repeat(DUMMY_WILD_PATTERN).take(arity - args.len()));\n             pats.extend(args[ddpos..].iter().map(|p| wpat(p)));\n             Some(pats)\n         }\n@@ -982,12 +1013,15 @@ pub fn specialize<'a, 'b, 'tcx>(\n             Some(vec![wpat(&**inner)]),\n \n         PatKind::Lit(ref expr) => {\n-            match r[col].1 {\n+            match r[col].pattern_ty {\n                 Some(&ty::TyS { sty: ty::TyRef(_, mt), .. }) => {\n                     // HACK: handle string literals. A string literal pattern\n                     // serves both as an unary reference pattern and as a\n                     // nullary value pattern, depending on the type.\n-                    Some(vec![(pat, Some(mt.ty))])\n+                    Some(vec![Pattern {\n+                        pat: pat,\n+                        pattern_ty: Some(mt.ty)\n+                    }])\n                 }\n                 Some(ty) => {\n                     assert_eq!(constructor_arity(cx, constructor, ty), 0);\n@@ -1023,14 +1057,14 @@ pub fn specialize<'a, 'b, 'tcx>(\n                     // Fixed-length vectors.\n                     Some(\n                         before.iter().map(|p| wpat(p)).chain(\n-                        repeat(dummy_pat).take(arity - pat_len).chain(\n+                        repeat(DUMMY_WILD_PATTERN).take(arity - pat_len).chain(\n                         after.iter().map(|p| wpat(p))\n                     )).collect())\n                 },\n                 Slice(length) if pat_len <= length && slice.is_some() => {\n                     Some(\n                         before.iter().map(|p| wpat(p)).chain(\n-                        repeat(dummy_pat).take(arity - pat_len).chain(\n+                        repeat(DUMMY_WILD_PATTERN).take(arity - pat_len).chain(\n                         after.iter().map(|p| wpat(p))\n                     )).collect())\n                 }\n@@ -1105,7 +1139,7 @@ fn is_refutable<A, F>(cx: &MatchCheckCtxt, pat: &Pat, refutable: F) -> Option<A>\n     F: FnOnce(&Pat) -> A,\n {\n     let pats = Matrix(vec!(vec!(wrap_pat(cx, pat))));\n-    match is_useful(cx, &pats, &[(DUMMY_WILD_PAT, None)], ConstructWitness) {\n+    match is_useful(cx, &pats, &[DUMMY_WILD_PATTERN], ConstructWitness) {\n         UsefulWithWitness(pats) => Some(refutable(&pats[0])),\n         NotUseful => None,\n         Useful => bug!()"}]}