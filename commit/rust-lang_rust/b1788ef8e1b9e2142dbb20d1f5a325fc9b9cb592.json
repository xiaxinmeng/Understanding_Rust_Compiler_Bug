{"sha": "b1788ef8e1b9e2142dbb20d1f5a325fc9b9cb592", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIxNzg4ZWY4ZTFiOWUyMTQyZGJiMjBkMWY1YTMyNWZjOWI5Y2I1OTI=", "commit": {"author": {"name": "Jonathan S", "email": "gereeter+code@gmail.com", "date": "2015-11-04T12:26:00Z"}, "committer": {"name": "Jonathan S", "email": "gereeter+code@gmail.com", "date": "2015-11-05T02:38:03Z"}, "message": "Remove use of RefCell<DefMap> in the simpler parts of pat_util", "tree": {"sha": "b559cd0b8cda6eb86fd3f9614a2296108b23e39e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b559cd0b8cda6eb86fd3f9614a2296108b23e39e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b1788ef8e1b9e2142dbb20d1f5a325fc9b9cb592", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b1788ef8e1b9e2142dbb20d1f5a325fc9b9cb592", "html_url": "https://github.com/rust-lang/rust/commit/b1788ef8e1b9e2142dbb20d1f5a325fc9b9cb592", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b1788ef8e1b9e2142dbb20d1f5a325fc9b9cb592/comments", "author": {"login": "gereeter", "id": 2328242, "node_id": "MDQ6VXNlcjIzMjgyNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/2328242?v=4", "gravatar_id": "", "url": "https://api.github.com/users/gereeter", "html_url": "https://github.com/gereeter", "followers_url": "https://api.github.com/users/gereeter/followers", "following_url": "https://api.github.com/users/gereeter/following{/other_user}", "gists_url": "https://api.github.com/users/gereeter/gists{/gist_id}", "starred_url": "https://api.github.com/users/gereeter/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/gereeter/subscriptions", "organizations_url": "https://api.github.com/users/gereeter/orgs", "repos_url": "https://api.github.com/users/gereeter/repos", "events_url": "https://api.github.com/users/gereeter/events{/privacy}", "received_events_url": "https://api.github.com/users/gereeter/received_events", "type": "User", "site_admin": false}, "committer": {"login": "gereeter", "id": 2328242, "node_id": "MDQ6VXNlcjIzMjgyNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/2328242?v=4", "gravatar_id": "", "url": "https://api.github.com/users/gereeter", "html_url": "https://github.com/gereeter", "followers_url": "https://api.github.com/users/gereeter/followers", "following_url": "https://api.github.com/users/gereeter/following{/other_user}", "gists_url": "https://api.github.com/users/gereeter/gists{/gist_id}", "starred_url": "https://api.github.com/users/gereeter/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/gereeter/subscriptions", "organizations_url": "https://api.github.com/users/gereeter/orgs", "repos_url": "https://api.github.com/users/gereeter/repos", "events_url": "https://api.github.com/users/gereeter/events{/privacy}", "received_events_url": "https://api.github.com/users/gereeter/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1ca1874986206b0d635b69e91f33195624bae74f", "url": "https://api.github.com/repos/rust-lang/rust/commits/1ca1874986206b0d635b69e91f33195624bae74f", "html_url": "https://github.com/rust-lang/rust/commit/1ca1874986206b0d635b69e91f33195624bae74f"}], "stats": {"total": 75, "additions": 38, "deletions": 37}, "files": [{"sha": "5b931857decca24fa75c0338cd65efeec25d9d1b", "filename": "src/librustc/middle/cfg/construct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b1788ef8e1b9e2142dbb20d1f5a325fc9b9cb592/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1788ef8e1b9e2142dbb20d1f5a325fc9b9cb592/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=b1788ef8e1b9e2142dbb20d1f5a325fc9b9cb592", "patch": "@@ -472,7 +472,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                     let guard_exit = self.expr(&**guard, guard_start);\n \n                     let this_has_bindings = pat_util::pat_contains_bindings_or_wild(\n-                        &self.tcx.def_map, &**pat);\n+                        &self.tcx.def_map.borrow(), &**pat);\n \n                     // If both this pattern and the previous pattern\n                     // were free of bindings, they must consist only"}, {"sha": "f46e55e24414081edb708232852dbe98d5502ff9", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b1788ef8e1b9e2142dbb20d1f5a325fc9b9cb592/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1788ef8e1b9e2142dbb20d1f5a325fc9b9cb592/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=b1788ef8e1b9e2142dbb20d1f5a325fc9b9cb592", "patch": "@@ -702,7 +702,7 @@ fn is_useful(cx: &MatchCheckCtxt,\n \n             Some(constructor) => {\n                 let matrix = rows.iter().filter_map(|r| {\n-                    if pat_is_binding_or_wild(&cx.tcx.def_map, raw_pat(r[0])) {\n+                    if pat_is_binding_or_wild(&cx.tcx.def_map.borrow(), raw_pat(r[0])) {\n                         Some(r[1..].to_vec())\n                     } else {\n                         None\n@@ -1073,7 +1073,7 @@ fn check_legality_of_move_bindings(cx: &MatchCheckCtxt,\n         // check legality of moving out of the enum\n \n         // x @ Foo(..) is legal, but x @ Foo(y) isn't.\n-        if sub.map_or(false, |p| pat_contains_bindings(def_map, &*p)) {\n+        if sub.map_or(false, |p| pat_contains_bindings(&def_map.borrow(), &*p)) {\n             span_err!(cx.tcx.sess, p.span, E0007, \"cannot bind by-move with sub-bindings\");\n         } else if has_guard {\n             span_err!(cx.tcx.sess, p.span, E0008, \"cannot bind by-move into a pattern guard\");\n@@ -1086,7 +1086,7 @@ fn check_legality_of_move_bindings(cx: &MatchCheckCtxt,\n \n     for pat in pats {\n         front_util::walk_pat(&**pat, |p| {\n-            if pat_is_binding(def_map, &*p) {\n+            if pat_is_binding(&def_map.borrow(), &*p) {\n                 match p.node {\n                     hir::PatIdent(hir::BindByValue(_), _, ref sub) => {\n                         let pat_ty = tcx.node_id_to_type(p.id);\n@@ -1181,7 +1181,7 @@ struct AtBindingPatternVisitor<'a, 'b:'a, 'tcx:'b> {\n \n impl<'a, 'b, 'tcx, 'v> Visitor<'v> for AtBindingPatternVisitor<'a, 'b, 'tcx> {\n     fn visit_pat(&mut self, pat: &Pat) {\n-        if !self.bindings_allowed && pat_is_binding(&self.cx.tcx.def_map, pat) {\n+        if !self.bindings_allowed && pat_is_binding(&self.cx.tcx.def_map.borrow(), pat) {\n             span_err!(self.cx.tcx.sess, pat.span, E0303,\n                                       \"pattern bindings are not allowed \\\n                                        after an `@`\");"}, {"sha": "b4280f86c7d584e68fbfe80b040b2514ae5affd3", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b1788ef8e1b9e2142dbb20d1f5a325fc9b9cb592/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1788ef8e1b9e2142dbb20d1f5a325fc9b9cb592/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=b1788ef8e1b9e2142dbb20d1f5a325fc9b9cb592", "patch": "@@ -250,7 +250,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for MarkSymbolVisitor<'a, 'tcx> {\n     fn visit_arm(&mut self, arm: &hir::Arm) {\n         if arm.pats.len() == 1 {\n             let pat = &*arm.pats[0];\n-            let variants = pat_util::necessary_variants(&self.tcx.def_map, pat);\n+            let variants = pat_util::necessary_variants(&self.tcx.def_map.borrow(), pat);\n \n             // Inside the body, ignore constructions of variants\n             // necessary for the pattern to match. Those construction sites\n@@ -270,7 +270,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for MarkSymbolVisitor<'a, 'tcx> {\n             hir::PatStruct(_, ref fields, _) => {\n                 self.handle_field_pattern_match(pat, fields);\n             }\n-            _ if pat_util::pat_is_const(def_map, pat) => {\n+            _ if pat_util::pat_is_const(&def_map.borrow(), pat) => {\n                 // it might be the only use of a const\n                 self.lookup_and_handle_definition(&pat.id)\n             }"}, {"sha": "ce8d74bf191c784d4d1edd18714a3e94684d7380", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b1788ef8e1b9e2142dbb20d1f5a325fc9b9cb592/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1788ef8e1b9e2142dbb20d1f5a325fc9b9cb592/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=b1788ef8e1b9e2142dbb20d1f5a325fc9b9cb592", "patch": "@@ -934,7 +934,7 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n         return_if_err!(self.mc.cat_pattern(cmt_discr, pat, |_mc, cmt_pat, pat| {\n             let tcx = self.tcx();\n             let def_map = &self.tcx().def_map;\n-            if pat_util::pat_is_binding(def_map, pat) {\n+            if pat_util::pat_is_binding(&def_map.borrow(), pat) {\n                 match pat.node {\n                     hir::PatIdent(hir::BindByRef(_), _, _) =>\n                         mode.lub(BorrowingMatch),\n@@ -969,7 +969,7 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n         let def_map = &self.tcx().def_map;\n         let delegate = &mut self.delegate;\n         return_if_err!(mc.cat_pattern(cmt_discr.clone(), pat, |mc, cmt_pat, pat| {\n-            if pat_util::pat_is_binding(def_map, pat) {\n+            if pat_util::pat_is_binding(&def_map.borrow(), pat) {\n                 let tcx = typer.tcx;\n \n                 debug!(\"binding cmt_pat={:?} pat={:?} match_mode={:?}\","}, {"sha": "09132396054ff15fb15fa49416d60535c993d37a", "filename": "src/librustc/middle/pat_util.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/b1788ef8e1b9e2142dbb20d1f5a325fc9b9cb592/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1788ef8e1b9e2142dbb20d1f5a325fc9b9cb592/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fpat_util.rs?ref=b1788ef8e1b9e2142dbb20d1f5a325fc9b9cb592", "patch": "@@ -32,13 +32,13 @@ pub fn pat_id_map(dm: &RefCell<DefMap>, pat: &hir::Pat) -> PatIdMap {\n     map\n }\n \n-pub fn pat_is_refutable(dm: &RefCell<DefMap>, pat: &hir::Pat) -> bool {\n+pub fn pat_is_refutable(dm: &DefMap, pat: &hir::Pat) -> bool {\n     match pat.node {\n         hir::PatLit(_) | hir::PatRange(_, _) | hir::PatQPath(..) => true,\n         hir::PatEnum(_, _) |\n         hir::PatIdent(_, _, None) |\n         hir::PatStruct(..) => {\n-            match dm.borrow().get(&pat.id).map(|d| d.full_def()) {\n+            match dm.get(&pat.id).map(|d| d.full_def()) {\n                 Some(DefVariant(..)) => true,\n                 _ => false\n             }\n@@ -48,12 +48,12 @@ pub fn pat_is_refutable(dm: &RefCell<DefMap>, pat: &hir::Pat) -> bool {\n     }\n }\n \n-pub fn pat_is_variant_or_struct(dm: &RefCell<DefMap>, pat: &hir::Pat) -> bool {\n+pub fn pat_is_variant_or_struct(dm: &DefMap, pat: &hir::Pat) -> bool {\n     match pat.node {\n         hir::PatEnum(_, _) |\n         hir::PatIdent(_, _, None) |\n         hir::PatStruct(..) => {\n-            match dm.borrow().get(&pat.id).map(|d| d.full_def()) {\n+            match dm.get(&pat.id).map(|d| d.full_def()) {\n                 Some(DefVariant(..)) | Some(DefStruct(..)) => true,\n                 _ => false\n             }\n@@ -62,10 +62,10 @@ pub fn pat_is_variant_or_struct(dm: &RefCell<DefMap>, pat: &hir::Pat) -> bool {\n     }\n }\n \n-pub fn pat_is_const(dm: &RefCell<DefMap>, pat: &hir::Pat) -> bool {\n+pub fn pat_is_const(dm: &DefMap, pat: &hir::Pat) -> bool {\n     match pat.node {\n         hir::PatIdent(_, _, None) | hir::PatEnum(..) | hir::PatQPath(..) => {\n-            match dm.borrow().get(&pat.id).map(|d| d.full_def()) {\n+            match dm.get(&pat.id).map(|d| d.full_def()) {\n                 Some(DefConst(..)) | Some(DefAssociatedConst(..)) => true,\n                 _ => false\n             }\n@@ -76,10 +76,10 @@ pub fn pat_is_const(dm: &RefCell<DefMap>, pat: &hir::Pat) -> bool {\n \n // Same as above, except that partially-resolved defs cause `false` to be\n // returned instead of a panic.\n-pub fn pat_is_resolved_const(dm: &RefCell<DefMap>, pat: &hir::Pat) -> bool {\n+pub fn pat_is_resolved_const(dm: &DefMap, pat: &hir::Pat) -> bool {\n     match pat.node {\n         hir::PatIdent(_, _, None) | hir::PatEnum(..) | hir::PatQPath(..) => {\n-            match dm.borrow().get(&pat.id)\n+            match dm.get(&pat.id)\n                     .and_then(|d| if d.depth == 0 { Some(d.base_def) }\n                                   else { None } ) {\n                 Some(DefConst(..)) | Some(DefAssociatedConst(..)) => true,\n@@ -90,7 +90,7 @@ pub fn pat_is_resolved_const(dm: &RefCell<DefMap>, pat: &hir::Pat) -> bool {\n     }\n }\n \n-pub fn pat_is_binding(dm: &RefCell<DefMap>, pat: &hir::Pat) -> bool {\n+pub fn pat_is_binding(dm: &DefMap, pat: &hir::Pat) -> bool {\n     match pat.node {\n         hir::PatIdent(..) => {\n             !pat_is_variant_or_struct(dm, pat) &&\n@@ -100,7 +100,7 @@ pub fn pat_is_binding(dm: &RefCell<DefMap>, pat: &hir::Pat) -> bool {\n     }\n }\n \n-pub fn pat_is_binding_or_wild(dm: &RefCell<DefMap>, pat: &hir::Pat) -> bool {\n+pub fn pat_is_binding_or_wild(dm: &DefMap, pat: &hir::Pat) -> bool {\n     match pat.node {\n         hir::PatIdent(..) => pat_is_binding(dm, pat),\n         hir::PatWild => true,\n@@ -115,7 +115,7 @@ pub fn pat_bindings<I>(dm: &RefCell<DefMap>, pat: &hir::Pat, mut it: I) where\n {\n     walk_pat(pat, |p| {\n         match p.node {\n-          hir::PatIdent(binding_mode, ref pth, _) if pat_is_binding(dm, p) => {\n+          hir::PatIdent(binding_mode, ref pth, _) if pat_is_binding(&dm.borrow(), p) => {\n             it(binding_mode, p.id, p.span, &respan(pth.span, pth.node.name));\n           }\n           _ => {}\n@@ -129,7 +129,7 @@ pub fn pat_bindings_hygienic<I>(dm: &RefCell<DefMap>, pat: &hir::Pat, mut it: I)\n {\n     walk_pat(pat, |p| {\n         match p.node {\n-          hir::PatIdent(binding_mode, ref pth, _) if pat_is_binding(dm, p) => {\n+          hir::PatIdent(binding_mode, ref pth, _) if pat_is_binding(&dm.borrow(), p) => {\n             it(binding_mode, p.id, p.span, &respan(pth.span, pth.node));\n           }\n           _ => {}\n@@ -140,7 +140,7 @@ pub fn pat_bindings_hygienic<I>(dm: &RefCell<DefMap>, pat: &hir::Pat, mut it: I)\n \n /// Checks if the pattern contains any patterns that bind something to\n /// an ident, e.g. `foo`, or `Foo(foo)` or `foo @ Bar(..)`.\n-pub fn pat_contains_bindings(dm: &RefCell<DefMap>, pat: &hir::Pat) -> bool {\n+pub fn pat_contains_bindings(dm: &DefMap, pat: &hir::Pat) -> bool {\n     let mut contains_bindings = false;\n     walk_pat(pat, |p| {\n         if pat_is_binding(dm, p) {\n@@ -185,7 +185,7 @@ pub fn arm_contains_ref_binding(dm: &RefCell<DefMap>, arm: &hir::Arm) -> Option<\n \n /// Checks if the pattern contains any patterns that bind something to\n /// an ident or wildcard, e.g. `foo`, or `Foo(_)`, `foo @ Bar(..)`,\n-pub fn pat_contains_bindings_or_wild(dm: &RefCell<DefMap>, pat: &hir::Pat) -> bool {\n+pub fn pat_contains_bindings_or_wild(dm: &DefMap, pat: &hir::Pat) -> bool {\n     let mut contains_bindings = false;\n     walk_pat(pat, |p| {\n         if pat_is_binding_or_wild(dm, p) {\n@@ -221,14 +221,14 @@ pub fn def_to_path(tcx: &ty::ctxt, id: DefId) -> hir::Path {\n }\n \n /// Return variants that are necessary to exist for the pattern to match.\n-pub fn necessary_variants(dm: &RefCell<DefMap>, pat: &hir::Pat) -> Vec<DefId> {\n+pub fn necessary_variants(dm: &DefMap, pat: &hir::Pat) -> Vec<DefId> {\n     let mut variants = vec![];\n     walk_pat(pat, |p| {\n         match p.node {\n             hir::PatEnum(_, _) |\n             hir::PatIdent(_, _, None) |\n             hir::PatStruct(..) => {\n-                match dm.borrow().get(&p.id) {\n+                match dm.get(&p.id) {\n                     Some(&PathResolution { base_def: DefVariant(_, id, _), .. }) => {\n                         variants.push(id);\n                     }"}, {"sha": "fa9678041790552228eecc39cb568dc173941161", "filename": "src/librustc_mir/hair/cx/pattern.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b1788ef8e1b9e2142dbb20d1f5a325fc9b9cb592/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1788ef8e1b9e2142dbb20d1f5a325fc9b9cb592/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs?ref=b1788ef8e1b9e2142dbb20d1f5a325fc9b9cb592", "patch": "@@ -155,7 +155,7 @@ impl<'tcx> Mirror<'tcx> for PatNode<'tcx> {\n             },\n \n             hir::PatEnum(..) | hir::PatIdent(..) | hir::PatQPath(..)\n-                if pat_is_resolved_const(&cx.tcx.def_map, self.pat) =>\n+                if pat_is_resolved_const(&cx.tcx.def_map.borrow(), self.pat) =>\n             {\n                 let def = cx.tcx.def_map.borrow().get(&self.pat.id).unwrap().full_def();\n                 match def {\n@@ -231,7 +231,7 @@ impl<'tcx> Mirror<'tcx> for PatNode<'tcx> {\n             }\n \n             hir::PatIdent(bm, ref ident, ref sub)\n-                if pat_is_binding(&cx.tcx.def_map, self.pat) =>\n+                if pat_is_binding(&cx.tcx.def_map.borrow(), self.pat) =>\n             {\n                 let id = match self.binding_map {\n                     None => self.pat.id,"}, {"sha": "0fb0407d3ba72351229d78895a761529bbeb2249", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b1788ef8e1b9e2142dbb20d1f5a325fc9b9cb592/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1788ef8e1b9e2142dbb20d1f5a325fc9b9cb592/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=b1788ef8e1b9e2142dbb20d1f5a325fc9b9cb592", "patch": "@@ -517,7 +517,7 @@ fn enter_match<'a, 'b, 'p, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n             let mut bound_ptrs = br.bound_ptrs.clone();\n             match this.node {\n                 hir::PatIdent(_, ref path, None) => {\n-                    if pat_is_binding(dm, &*this) {\n+                    if pat_is_binding(&dm.borrow(), &*this) {\n                         bound_ptrs.push((path.node.name, val.val));\n                     }\n                 }\n@@ -556,7 +556,7 @@ fn enter_default<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     // Collect all of the matches that can match against anything.\n     enter_match(bcx, dm, m, col, val, |pats| {\n-        if pat_is_binding_or_wild(dm, &*pats[col]) {\n+        if pat_is_binding_or_wild(&dm.borrow(), &*pats[col]) {\n             let mut r = pats[..col].to_vec();\n             r.push_all(&pats[col + 1..]);\n             Some(r)\n@@ -847,7 +847,7 @@ fn pick_column_to_specialize(def_map: &RefCell<DefMap>, m: &[Match]) -> Option<u\n     fn pat_score(def_map: &RefCell<DefMap>, pat: &hir::Pat) -> usize {\n         match pat.node {\n             hir::PatIdent(_, _, Some(ref inner)) => pat_score(def_map, &**inner),\n-            _ if pat_is_refutable(def_map, pat) => 1,\n+            _ if pat_is_refutable(&def_map.borrow(), pat) => 1,\n             _ => 0\n         }\n     }\n@@ -1801,7 +1801,7 @@ pub fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let ccx = bcx.ccx();\n     match pat.node {\n         hir::PatIdent(pat_binding_mode, ref path1, ref inner) => {\n-            if pat_is_binding(&tcx.def_map, &*pat) {\n+            if pat_is_binding(&tcx.def_map.borrow(), &*pat) {\n                 // Allocate the stack slot where the value of this\n                 // binding will live and place it into the appropriate\n                 // map."}, {"sha": "0c424de9e10b89ee6657c1b1b5fd84c9f77febcf", "filename": "src/librustc_trans/trans/debuginfo/create_scope_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b1788ef8e1b9e2142dbb20d1f5a325fc9b9cb592/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fcreate_scope_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1788ef8e1b9e2142dbb20d1f5a325fc9b9cb592/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fcreate_scope_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fcreate_scope_map.rs?ref=b1788ef8e1b9e2142dbb20d1f5a325fc9b9cb592", "patch": "@@ -167,7 +167,7 @@ fn walk_pattern(cx: &CrateContext,\n \n             // Check if this is a binding. If so we need to put it on the\n             // scope stack and maybe introduce an artificial scope\n-            if pat_util::pat_is_binding(def_map, &*pat) {\n+            if pat_util::pat_is_binding(&def_map.borrow(), &*pat) {\n \n                 let name = path1.node.name;\n "}, {"sha": "cd7012cd4ec6ddb6919360d757703819629fe7a6", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b1788ef8e1b9e2142dbb20d1f5a325fc9b9cb592/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1788ef8e1b9e2142dbb20d1f5a325fc9b9cb592/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=b1788ef8e1b9e2142dbb20d1f5a325fc9b9cb592", "patch": "@@ -133,7 +133,8 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n             // subtyping doesn't matter here, as the value is some kind of scalar\n             demand::eqtype(fcx, pat.span, expected, lhs_ty);\n         }\n-        hir::PatEnum(..) | hir::PatIdent(..) if pat_is_resolved_const(&tcx.def_map, pat) => {\n+        hir::PatEnum(..) | hir::PatIdent(..)\n+                if pat_is_resolved_const(&tcx.def_map.borrow(), pat) => {\n             let const_did = tcx.def_map.borrow().get(&pat.id).unwrap().def_id();\n             let const_scheme = tcx.lookup_item_type(const_did);\n             assert!(const_scheme.generics.is_empty());\n@@ -149,7 +150,7 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n             // is good enough.\n             demand::suptype(fcx, pat.span, expected, const_ty);\n         }\n-        hir::PatIdent(bm, ref path, ref sub) if pat_is_binding(&tcx.def_map, pat) => {\n+        hir::PatIdent(bm, ref path, ref sub) if pat_is_binding(&tcx.def_map.borrow(), pat) => {\n             let typ = fcx.local_ty(pat.span, pat.id);\n             match bm {\n                 hir::BindByRef(mutbl) => {\n@@ -410,7 +411,7 @@ pub fn check_dereferencable<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n                                       inner: &hir::Pat) -> bool {\n     let fcx = pcx.fcx;\n     let tcx = pcx.fcx.ccx.tcx;\n-    if pat_is_binding(&tcx.def_map, inner) {\n+    if pat_is_binding(&tcx.def_map.borrow(), inner) {\n         let expected = fcx.infcx().shallow_resolve(expected);\n         expected.builtin_deref(true, ty::NoPreference).map_or(true, |mt| match mt.ty.sty {\n             ty::TyTrait(_) => {"}, {"sha": "cfa32bc073a1f6c10c8ba74b227a9ea62e7f0c9a", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b1788ef8e1b9e2142dbb20d1f5a325fc9b9cb592/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1788ef8e1b9e2142dbb20d1f5a325fc9b9cb592/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=b1788ef8e1b9e2142dbb20d1f5a325fc9b9cb592", "patch": "@@ -529,7 +529,7 @@ impl<'a, 'tcx> Visitor<'tcx> for GatherLocalsVisitor<'a, 'tcx> {\n     // Add pattern bindings.\n     fn visit_pat(&mut self, p: &'tcx hir::Pat) {\n         if let hir::PatIdent(_, ref path1, _) = p.node {\n-            if pat_util::pat_is_binding(&self.fcx.ccx.tcx.def_map, p) {\n+            if pat_util::pat_is_binding(&self.fcx.ccx.tcx.def_map.borrow(), p) {\n                 let var_ty = self.assign(p.span, p.id, None);\n \n                 self.fcx.require_type_is_sized(var_ty, p.span,"}, {"sha": "5b1fafe09fac90d4f866553955fdaf2c1231c3ca", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b1788ef8e1b9e2142dbb20d1f5a325fc9b9cb592/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1788ef8e1b9e2142dbb20d1f5a325fc9b9cb592/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=b1788ef8e1b9e2142dbb20d1f5a325fc9b9cb592", "patch": "@@ -57,7 +57,7 @@ pub fn resolve_type_vars_in_fn(fcx: &FnCtxt,\n         wbcx.visit_pat(&*arg.pat);\n \n         // Privacy needs the type for the whole pattern, not just each binding\n-        if !pat_util::pat_is_binding(&fcx.tcx().def_map, &*arg.pat) {\n+        if !pat_util::pat_is_binding(&fcx.tcx().def_map.borrow(), &*arg.pat) {\n             wbcx.visit_node_id(ResolvingPattern(arg.pat.span),\n                                arg.pat.id);\n         }"}]}