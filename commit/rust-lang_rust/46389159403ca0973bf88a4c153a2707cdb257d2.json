{"sha": "46389159403ca0973bf88a4c153a2707cdb257d2", "node_id": "C_kwDOAAsO6NoAKDQ2Mzg5MTU5NDAzY2EwOTczYmY4OGE0YzE1M2EyNzA3Y2RiMjU3ZDI", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-05-28T03:03:57Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-05-28T19:16:05Z"}, "message": "Make TyCtxt implement Interner, make HashStable generic and move to rustc_type_ir", "tree": {"sha": "e840b90c6d65e0b5f6d513eb376b46dd3c320cd4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e840b90c6d65e0b5f6d513eb376b46dd3c320cd4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/46389159403ca0973bf88a4c153a2707cdb257d2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/46389159403ca0973bf88a4c153a2707cdb257d2", "html_url": "https://github.com/rust-lang/rust/commit/46389159403ca0973bf88a4c153a2707cdb257d2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/46389159403ca0973bf88a4c153a2707cdb257d2/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f05a92d15896604faf30d33e73c7d40b98b2ec9c", "url": "https://api.github.com/repos/rust-lang/rust/commits/f05a92d15896604faf30d33e73c7d40b98b2ec9c", "html_url": "https://github.com/rust-lang/rust/commit/f05a92d15896604faf30d33e73c7d40b98b2ec9c"}], "stats": {"total": 477, "additions": 229, "deletions": 248}, "files": [{"sha": "a39b44139811ebc8fee1445ea7ddb572897ad2c4", "filename": "compiler/rustc_macros/src/serialize.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/46389159403ca0973bf88a4c153a2707cdb257d2/compiler%2Frustc_macros%2Fsrc%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46389159403ca0973bf88a4c153a2707cdb257d2/compiler%2Frustc_macros%2Fsrc%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fserialize.rs?ref=46389159403ca0973bf88a4c153a2707cdb257d2", "patch": "@@ -8,7 +8,7 @@ pub fn type_decodable_derive(mut s: synstructure::Structure<'_>) -> proc_macro2:\n     if !s.ast().generics.lifetimes().any(|lt| lt.lifetime.ident == \"tcx\") {\n         s.add_impl_generic(parse_quote! { 'tcx });\n     }\n-    s.add_impl_generic(parse_quote! {#decoder_ty: ::rustc_type_ir::codec::TyDecoder<I = ::rustc_middle::ty::TyInterner<'tcx>>});\n+    s.add_impl_generic(parse_quote! {#decoder_ty: ::rustc_type_ir::codec::TyDecoder<I = ::rustc_middle::ty::TyCtxt<'tcx>>});\n     s.add_bounds(synstructure::AddBounds::Generics);\n \n     decodable_body(s, decoder_ty)\n@@ -95,7 +95,7 @@ pub fn type_encodable_derive(mut s: synstructure::Structure<'_>) -> proc_macro2:\n         s.add_impl_generic(parse_quote! {'tcx});\n     }\n     let encoder_ty = quote! { __E };\n-    s.add_impl_generic(parse_quote! {#encoder_ty: ::rustc_type_ir::codec::TyEncoder<I = ::rustc_middle::ty::TyInterner<'tcx>>});\n+    s.add_impl_generic(parse_quote! {#encoder_ty: ::rustc_type_ir::codec::TyEncoder<I = ::rustc_middle::ty::TyCtxt<'tcx>>});\n     s.add_bounds(synstructure::AddBounds::Generics);\n \n     encodable_body(s, encoder_ty, false)"}, {"sha": "775ebb48402aabef8b08384c3dd1743baf51f132", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/46389159403ca0973bf88a4c153a2707cdb257d2/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46389159403ca0973bf88a4c153a2707cdb257d2/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=46389159403ca0973bf88a4c153a2707cdb257d2", "patch": "@@ -24,8 +24,8 @@ use rustc_middle::mir::interpret::{AllocDecodingSession, AllocDecodingState};\n use rustc_middle::thir;\n use rustc_middle::ty::codec::TyDecoder;\n use rustc_middle::ty::fast_reject::SimplifiedType;\n+use rustc_middle::ty::GeneratorDiagnosticData;\n use rustc_middle::ty::{self, ParameterizedOverTcx, Ty, TyCtxt, Visibility};\n-use rustc_middle::ty::{GeneratorDiagnosticData, TyInterner};\n use rustc_serialize::{opaque, Decodable, Decoder};\n use rustc_session::cstore::{\n     CrateSource, ExternCrate, ForeignModule, LinkagePreference, NativeLib,\n@@ -380,11 +380,11 @@ impl<'a, 'tcx> DecodeContext<'a, 'tcx> {\n impl<'a, 'tcx> TyDecoder for DecodeContext<'a, 'tcx> {\n     const CLEAR_CROSS_CRATE: bool = true;\n \n-    type I = TyInterner<'tcx>;\n+    type I = TyCtxt<'tcx>;\n \n     #[inline]\n     fn interner(&self) -> Self::I {\n-        TyInterner { tcx: self.tcx() }\n+        self.tcx()\n     }\n \n     #[inline]"}, {"sha": "5a40986307c7fe6d5b9b0c9d989ebfb141b90deb", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/46389159403ca0973bf88a4c153a2707cdb257d2/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46389159403ca0973bf88a4c153a2707cdb257d2/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=46389159403ca0973bf88a4c153a2707cdb257d2", "patch": "@@ -26,7 +26,7 @@ use rustc_middle::traits::specialization_graph;\n use rustc_middle::ty::codec::TyEncoder;\n use rustc_middle::ty::fast_reject::{self, SimplifiedType, TreatParams};\n use rustc_middle::ty::query::Providers;\n-use rustc_middle::ty::{self, SymbolName, Ty, TyCtxt, TyInterner};\n+use rustc_middle::ty::{self, SymbolName, Ty, TyCtxt};\n use rustc_serialize::{opaque, Encodable, Encoder};\n use rustc_session::config::CrateType;\n use rustc_session::cstore::{ForeignModule, LinkagePreference, NativeLib};\n@@ -316,7 +316,7 @@ impl<'a, 'tcx> Encodable<EncodeContext<'a, 'tcx>> for Span {\n impl<'a, 'tcx> TyEncoder for EncodeContext<'a, 'tcx> {\n     const CLEAR_CROSS_CRATE: bool = true;\n \n-    type I = TyInterner<'tcx>;\n+    type I = TyCtxt<'tcx>;\n \n     fn position(&self) -> usize {\n         self.opaque.position()"}, {"sha": "06cd6a66e39f580762e11645834fdac4379e1d9e", "filename": "compiler/rustc_middle/src/mir/interpret/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/46389159403ca0973bf88a4c153a2707cdb257d2/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46389159403ca0973bf88a4c153a2707cdb257d2/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs?ref=46389159403ca0973bf88a4c153a2707cdb257d2", "patch": "@@ -115,7 +115,7 @@ use rustc_target::abi::Endian;\n use crate::mir;\n use crate::ty::codec::{TyDecoder, TyEncoder};\n use crate::ty::subst::GenericArgKind;\n-use crate::ty::{self, Instance, Ty, TyCtxt, TyInterner};\n+use crate::ty::{self, Instance, Ty, TyCtxt};\n \n pub use self::error::{\n     struct_error, CheckInAllocMsg, ErrorHandled, EvalToAllocationRawResult, EvalToConstValueResult,\n@@ -203,7 +203,7 @@ enum AllocDiscriminant {\n     Static,\n }\n \n-pub fn specialized_encode_alloc_id<'tcx, E: TyEncoder<I = TyInterner<'tcx>>>(\n+pub fn specialized_encode_alloc_id<'tcx, E: TyEncoder<I = TyCtxt<'tcx>>>(\n     encoder: &mut E,\n     tcx: TyCtxt<'tcx>,\n     alloc_id: AllocId,\n@@ -277,7 +277,7 @@ impl<'s> AllocDecodingSession<'s> {\n     /// Decodes an `AllocId` in a thread-safe way.\n     pub fn decode_alloc_id<'tcx, D>(&self, decoder: &mut D) -> AllocId\n     where\n-        D: TyDecoder<I = TyInterner<'tcx>>,\n+        D: TyDecoder<I = TyCtxt<'tcx>>,\n     {\n         // Read the index of the allocation.\n         let idx = usize::try_from(decoder.read_u32()).unwrap();\n@@ -305,7 +305,7 @@ impl<'s> AllocDecodingSession<'s> {\n                         AllocDiscriminant::Alloc => {\n                             // If this is an allocation, we need to reserve an\n                             // `AllocId` so we can decode cyclic graphs.\n-                            let alloc_id = decoder.interner().tcx.reserve_alloc_id();\n+                            let alloc_id = decoder.interner().reserve_alloc_id();\n                             *entry =\n                                 State::InProgress(TinyList::new_single(self.session_id), alloc_id);\n                             Some(alloc_id)\n@@ -349,23 +349,23 @@ impl<'s> AllocDecodingSession<'s> {\n                     // We already have a reserved `AllocId`.\n                     let alloc_id = alloc_id.unwrap();\n                     trace!(\"decoded alloc {:?}: {:#?}\", alloc_id, alloc);\n-                    decoder.interner().tcx.set_alloc_id_same_memory(alloc_id, alloc);\n+                    decoder.interner().set_alloc_id_same_memory(alloc_id, alloc);\n                     alloc_id\n                 }\n                 AllocDiscriminant::Fn => {\n                     assert!(alloc_id.is_none());\n                     trace!(\"creating fn alloc ID\");\n                     let instance = ty::Instance::decode(decoder);\n                     trace!(\"decoded fn alloc instance: {:?}\", instance);\n-                    let alloc_id = decoder.interner().tcx.create_fn_alloc(instance);\n+                    let alloc_id = decoder.interner().create_fn_alloc(instance);\n                     alloc_id\n                 }\n                 AllocDiscriminant::Static => {\n                     assert!(alloc_id.is_none());\n                     trace!(\"creating extern static alloc ID\");\n                     let did = <DefId as Decodable<D>>::decode(decoder);\n                     trace!(\"decoded static def-ID: {:?}\", did);\n-                    let alloc_id = decoder.interner().tcx.create_static_alloc(did);\n+                    let alloc_id = decoder.interner().create_static_alloc(did);\n                     alloc_id\n                 }\n             }"}, {"sha": "1e2d1fbeb4bf635ba7c34333d82c568ac43b2b1b", "filename": "compiler/rustc_middle/src/ty/codec.rs", "status": "modified", "additions": 62, "deletions": 67, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/46389159403ca0973bf88a4c153a2707cdb257d2/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46389159403ca0973bf88a4c153a2707cdb257d2/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs?ref=46389159403ca0973bf88a4c153a2707cdb257d2", "patch": "@@ -17,7 +17,7 @@ use crate::traits;\n use crate::ty::subst::SubstsRef;\n use crate::ty::{self, AdtDef, Ty};\n use rustc_data_structures::fx::FxHashMap;\n-use rustc_middle::ty::TyInterner;\n+use rustc_middle::ty::TyCtxt;\n use rustc_serialize::{Decodable, Encodable};\n use rustc_span::Span;\n pub use rustc_type_ir::{TyDecoder, TyEncoder};\n@@ -36,7 +36,7 @@ pub trait EncodableWithShorthand<E: TyEncoder>: Copy + Eq + Hash {\n }\n \n #[allow(rustc::usage_of_ty_tykind)]\n-impl<'tcx, E: TyEncoder<I = TyInterner<'tcx>>> EncodableWithShorthand<E> for Ty<'tcx> {\n+impl<'tcx, E: TyEncoder<I = TyCtxt<'tcx>>> EncodableWithShorthand<E> for Ty<'tcx> {\n     type Variant = ty::TyKind<'tcx>;\n \n     #[inline]\n@@ -45,9 +45,7 @@ impl<'tcx, E: TyEncoder<I = TyInterner<'tcx>>> EncodableWithShorthand<E> for Ty<\n     }\n }\n \n-impl<'tcx, E: TyEncoder<I = TyInterner<'tcx>>> EncodableWithShorthand<E>\n-    for ty::PredicateKind<'tcx>\n-{\n+impl<'tcx, E: TyEncoder<I = TyCtxt<'tcx>>> EncodableWithShorthand<E> for ty::PredicateKind<'tcx> {\n     type Variant = ty::PredicateKind<'tcx>;\n \n     #[inline]\n@@ -66,7 +64,7 @@ impl<'tcx, E: TyEncoder<I = TyInterner<'tcx>>> EncodableWithShorthand<E>\n ///\n /// `Decodable` can still be implemented in cases where `Decodable` is required\n /// by a trait bound.\n-pub trait RefDecodable<'tcx, D: TyDecoder<I = TyInterner<'tcx>>> {\n+pub trait RefDecodable<'tcx, D: TyDecoder<I = TyCtxt<'tcx>>> {\n     fn decode(d: &mut D) -> &'tcx Self;\n }\n \n@@ -77,7 +75,7 @@ pub fn encode_with_shorthand<'tcx, E, T, M>(\n     cache: M,\n ) -> Result<(), E::Error>\n where\n-    E: TyEncoder<I = TyInterner<'tcx>>,\n+    E: TyEncoder<I = TyCtxt<'tcx>>,\n     M: for<'b> Fn(&'b mut E) -> &'b mut FxHashMap<T, usize>,\n     T: EncodableWithShorthand<E>,\n     // The discriminant and shorthand must have the same size.\n@@ -114,13 +112,13 @@ where\n     Ok(())\n }\n \n-impl<'tcx, E: TyEncoder<I = TyInterner<'tcx>>> Encodable<E> for Ty<'tcx> {\n+impl<'tcx, E: TyEncoder<I = TyCtxt<'tcx>>> Encodable<E> for Ty<'tcx> {\n     fn encode(&self, e: &mut E) -> Result<(), E::Error> {\n         encode_with_shorthand(e, self, TyEncoder::type_shorthands)\n     }\n }\n \n-impl<'tcx, E: TyEncoder<I = TyInterner<'tcx>>> Encodable<E>\n+impl<'tcx, E: TyEncoder<I = TyCtxt<'tcx>>> Encodable<E>\n     for ty::Binder<'tcx, ty::PredicateKind<'tcx>>\n {\n     fn encode(&self, e: &mut E) -> Result<(), E::Error> {\n@@ -129,37 +127,37 @@ impl<'tcx, E: TyEncoder<I = TyInterner<'tcx>>> Encodable<E>\n     }\n }\n \n-impl<'tcx, E: TyEncoder<I = TyInterner<'tcx>>> Encodable<E> for ty::Predicate<'tcx> {\n+impl<'tcx, E: TyEncoder<I = TyCtxt<'tcx>>> Encodable<E> for ty::Predicate<'tcx> {\n     fn encode(&self, e: &mut E) -> Result<(), E::Error> {\n         self.kind().encode(e)\n     }\n }\n \n-impl<'tcx, E: TyEncoder<I = TyInterner<'tcx>>> Encodable<E> for ty::Region<'tcx> {\n+impl<'tcx, E: TyEncoder<I = TyCtxt<'tcx>>> Encodable<E> for ty::Region<'tcx> {\n     fn encode(&self, e: &mut E) -> Result<(), E::Error> {\n         self.kind().encode(e)\n     }\n }\n \n-impl<'tcx, E: TyEncoder<I = TyInterner<'tcx>>> Encodable<E> for ty::Const<'tcx> {\n+impl<'tcx, E: TyEncoder<I = TyCtxt<'tcx>>> Encodable<E> for ty::Const<'tcx> {\n     fn encode(&self, e: &mut E) -> Result<(), E::Error> {\n         self.0.0.encode(e)\n     }\n }\n \n-impl<'tcx, E: TyEncoder<I = TyInterner<'tcx>>> Encodable<E> for ConstAllocation<'tcx> {\n+impl<'tcx, E: TyEncoder<I = TyCtxt<'tcx>>> Encodable<E> for ConstAllocation<'tcx> {\n     fn encode(&self, e: &mut E) -> Result<(), E::Error> {\n         self.inner().encode(e)\n     }\n }\n \n-impl<'tcx, E: TyEncoder<I = TyInterner<'tcx>>> Encodable<E> for AdtDef<'tcx> {\n+impl<'tcx, E: TyEncoder<I = TyCtxt<'tcx>>> Encodable<E> for AdtDef<'tcx> {\n     fn encode(&self, e: &mut E) -> Result<(), E::Error> {\n         self.0.0.encode(e)\n     }\n }\n \n-impl<'tcx, E: TyEncoder<I = TyInterner<'tcx>>> Encodable<E> for AllocId {\n+impl<'tcx, E: TyEncoder<I = TyCtxt<'tcx>>> Encodable<E> for AllocId {\n     fn encode(&self, e: &mut E) -> Result<(), E::Error> {\n         e.encode_alloc_id(self)\n     }\n@@ -168,32 +166,32 @@ impl<'tcx, E: TyEncoder<I = TyInterner<'tcx>>> Encodable<E> for AllocId {\n #[inline]\n fn decode_arena_allocable<\n     'tcx,\n-    D: TyDecoder<I = TyInterner<'tcx>>,\n+    D: TyDecoder<I = TyCtxt<'tcx>>,\n     T: ArenaAllocatable<'tcx> + Decodable<D>,\n >(\n     decoder: &mut D,\n ) -> &'tcx T\n where\n     D: TyDecoder,\n {\n-    decoder.interner().tcx.arena.alloc(Decodable::decode(decoder))\n+    decoder.interner().arena.alloc(Decodable::decode(decoder))\n }\n \n #[inline]\n fn decode_arena_allocable_slice<\n     'tcx,\n-    D: TyDecoder<I = TyInterner<'tcx>>,\n+    D: TyDecoder<I = TyCtxt<'tcx>>,\n     T: ArenaAllocatable<'tcx> + Decodable<D>,\n >(\n     decoder: &mut D,\n ) -> &'tcx [T]\n where\n     D: TyDecoder,\n {\n-    decoder.interner().tcx.arena.alloc_from_iter(<Vec<T> as Decodable<D>>::decode(decoder))\n+    decoder.interner().arena.alloc_from_iter(<Vec<T> as Decodable<D>>::decode(decoder))\n }\n \n-impl<'tcx, D: TyDecoder<I = TyInterner<'tcx>>> Decodable<D> for Ty<'tcx> {\n+impl<'tcx, D: TyDecoder<I = TyCtxt<'tcx>>> Decodable<D> for Ty<'tcx> {\n     #[allow(rustc::usage_of_ty_tykind)]\n     fn decode(decoder: &mut D) -> Ty<'tcx> {\n         // Handle shorthands first, if we have a usize > 0x80.\n@@ -206,13 +204,13 @@ impl<'tcx, D: TyDecoder<I = TyInterner<'tcx>>> Decodable<D> for Ty<'tcx> {\n                 decoder.with_position(shorthand, Ty::decode)\n             })\n         } else {\n-            let tcx = decoder.interner().tcx;\n+            let tcx = decoder.interner();\n             tcx.mk_ty(rustc_type_ir::TyKind::decode(decoder))\n         }\n     }\n }\n \n-impl<'tcx, D: TyDecoder<I = TyInterner<'tcx>>> Decodable<D>\n+impl<'tcx, D: TyDecoder<I = TyCtxt<'tcx>>> Decodable<D>\n     for ty::Binder<'tcx, ty::PredicateKind<'tcx>>\n {\n     fn decode(decoder: &mut D) -> ty::Binder<'tcx, ty::PredicateKind<'tcx>> {\n@@ -233,154 +231,151 @@ impl<'tcx, D: TyDecoder<I = TyInterner<'tcx>>> Decodable<D>\n     }\n }\n \n-impl<'tcx, D: TyDecoder<I = TyInterner<'tcx>>> Decodable<D> for ty::Predicate<'tcx> {\n+impl<'tcx, D: TyDecoder<I = TyCtxt<'tcx>>> Decodable<D> for ty::Predicate<'tcx> {\n     fn decode(decoder: &mut D) -> ty::Predicate<'tcx> {\n         let predicate_kind = Decodable::decode(decoder);\n-        decoder.interner().tcx.mk_predicate(predicate_kind)\n+        decoder.interner().mk_predicate(predicate_kind)\n     }\n }\n \n-impl<'tcx, D: TyDecoder<I = TyInterner<'tcx>>> Decodable<D> for SubstsRef<'tcx> {\n+impl<'tcx, D: TyDecoder<I = TyCtxt<'tcx>>> Decodable<D> for SubstsRef<'tcx> {\n     fn decode(decoder: &mut D) -> Self {\n         let len = decoder.read_usize();\n-        let tcx = decoder.interner().tcx;\n+        let tcx = decoder.interner();\n         tcx.mk_substs(\n             (0..len).map::<ty::subst::GenericArg<'tcx>, _>(|_| Decodable::decode(decoder)),\n         )\n     }\n }\n \n-impl<'tcx, D: TyDecoder<I = TyInterner<'tcx>>> Decodable<D> for mir::Place<'tcx> {\n+impl<'tcx, D: TyDecoder<I = TyCtxt<'tcx>>> Decodable<D> for mir::Place<'tcx> {\n     fn decode(decoder: &mut D) -> Self {\n         let local: mir::Local = Decodable::decode(decoder);\n         let len = decoder.read_usize();\n-        let projection = decoder.interner().tcx.mk_place_elems(\n+        let projection = decoder.interner().mk_place_elems(\n             (0..len).map::<mir::PlaceElem<'tcx>, _>(|_| Decodable::decode(decoder)),\n         );\n         mir::Place { local, projection }\n     }\n }\n \n-impl<'tcx, D: TyDecoder<I = TyInterner<'tcx>>> Decodable<D> for ty::Region<'tcx> {\n+impl<'tcx, D: TyDecoder<I = TyCtxt<'tcx>>> Decodable<D> for ty::Region<'tcx> {\n     fn decode(decoder: &mut D) -> Self {\n-        decoder.interner().tcx.mk_region(Decodable::decode(decoder))\n+        decoder.interner().mk_region(Decodable::decode(decoder))\n     }\n }\n \n-impl<'tcx, D: TyDecoder<I = TyInterner<'tcx>>> Decodable<D> for CanonicalVarInfos<'tcx> {\n+impl<'tcx, D: TyDecoder<I = TyCtxt<'tcx>>> Decodable<D> for CanonicalVarInfos<'tcx> {\n     fn decode(decoder: &mut D) -> Self {\n         let len = decoder.read_usize();\n         let interned: Vec<CanonicalVarInfo<'tcx>> =\n             (0..len).map(|_| Decodable::decode(decoder)).collect();\n-        decoder.interner().tcx.intern_canonical_var_infos(interned.as_slice())\n+        decoder.interner().intern_canonical_var_infos(interned.as_slice())\n     }\n }\n \n-impl<'tcx, D: TyDecoder<I = TyInterner<'tcx>>> Decodable<D> for AllocId {\n+impl<'tcx, D: TyDecoder<I = TyCtxt<'tcx>>> Decodable<D> for AllocId {\n     fn decode(decoder: &mut D) -> Self {\n         decoder.decode_alloc_id()\n     }\n }\n \n-impl<'tcx, D: TyDecoder<I = TyInterner<'tcx>>> Decodable<D> for ty::SymbolName<'tcx> {\n+impl<'tcx, D: TyDecoder<I = TyCtxt<'tcx>>> Decodable<D> for ty::SymbolName<'tcx> {\n     fn decode(decoder: &mut D) -> Self {\n-        ty::SymbolName::new(decoder.interner().tcx, &decoder.read_str())\n+        ty::SymbolName::new(decoder.interner(), &decoder.read_str())\n     }\n }\n \n macro_rules! impl_decodable_via_ref {\n     ($($t:ty),+) => {\n-        $(impl<'tcx, D: TyDecoder<I = TyInterner<'tcx>>> Decodable<D> for $t {\n+        $(impl<'tcx, D: TyDecoder<I = TyCtxt<'tcx>>> Decodable<D> for $t {\n             fn decode(decoder: &mut D) -> Self {\n                 RefDecodable::decode(decoder)\n             }\n         })*\n     }\n }\n \n-impl<'tcx, D: TyDecoder<I = TyInterner<'tcx>>> RefDecodable<'tcx, D> for ty::List<Ty<'tcx>> {\n+impl<'tcx, D: TyDecoder<I = TyCtxt<'tcx>>> RefDecodable<'tcx, D> for ty::List<Ty<'tcx>> {\n     fn decode(decoder: &mut D) -> &'tcx Self {\n         let len = decoder.read_usize();\n-        decoder\n-            .interner()\n-            .tcx\n-            .mk_type_list((0..len).map::<Ty<'tcx>, _>(|_| Decodable::decode(decoder)))\n+        decoder.interner().mk_type_list((0..len).map::<Ty<'tcx>, _>(|_| Decodable::decode(decoder)))\n     }\n }\n \n-impl<'tcx, D: TyDecoder<I = TyInterner<'tcx>>> RefDecodable<'tcx, D>\n+impl<'tcx, D: TyDecoder<I = TyCtxt<'tcx>>> RefDecodable<'tcx, D>\n     for ty::List<ty::Binder<'tcx, ty::ExistentialPredicate<'tcx>>>\n {\n     fn decode(decoder: &mut D) -> &'tcx Self {\n         let len = decoder.read_usize();\n-        decoder.interner().tcx.mk_poly_existential_predicates(\n+        decoder.interner().mk_poly_existential_predicates(\n             (0..len).map::<ty::Binder<'tcx, _>, _>(|_| Decodable::decode(decoder)),\n         )\n     }\n }\n \n-impl<'tcx, D: TyDecoder<I = TyInterner<'tcx>>> Decodable<D> for ty::Const<'tcx> {\n+impl<'tcx, D: TyDecoder<I = TyCtxt<'tcx>>> Decodable<D> for ty::Const<'tcx> {\n     fn decode(decoder: &mut D) -> Self {\n-        decoder.interner().tcx.mk_const(Decodable::decode(decoder))\n+        decoder.interner().mk_const(Decodable::decode(decoder))\n     }\n }\n \n-impl<'tcx, D: TyDecoder<I = TyInterner<'tcx>>> RefDecodable<'tcx, D> for [ty::ValTree<'tcx>] {\n+impl<'tcx, D: TyDecoder<I = TyCtxt<'tcx>>> RefDecodable<'tcx, D> for [ty::ValTree<'tcx>] {\n     fn decode(decoder: &mut D) -> &'tcx Self {\n-        decoder.interner().tcx.arena.alloc_from_iter(\n+        decoder.interner().arena.alloc_from_iter(\n             (0..decoder.read_usize()).map(|_| Decodable::decode(decoder)).collect::<Vec<_>>(),\n         )\n     }\n }\n \n-impl<'tcx, D: TyDecoder<I = TyInterner<'tcx>>> Decodable<D> for ConstAllocation<'tcx> {\n+impl<'tcx, D: TyDecoder<I = TyCtxt<'tcx>>> Decodable<D> for ConstAllocation<'tcx> {\n     fn decode(decoder: &mut D) -> Self {\n-        decoder.interner().tcx.intern_const_alloc(Decodable::decode(decoder))\n+        decoder.interner().intern_const_alloc(Decodable::decode(decoder))\n     }\n }\n \n-impl<'tcx, D: TyDecoder<I = TyInterner<'tcx>>> Decodable<D> for AdtDef<'tcx> {\n+impl<'tcx, D: TyDecoder<I = TyCtxt<'tcx>>> Decodable<D> for AdtDef<'tcx> {\n     fn decode(decoder: &mut D) -> Self {\n-        decoder.interner().tcx.intern_adt_def(Decodable::decode(decoder))\n+        decoder.interner().intern_adt_def(Decodable::decode(decoder))\n     }\n }\n \n-impl<'tcx, D: TyDecoder<I = TyInterner<'tcx>>> RefDecodable<'tcx, D>\n+impl<'tcx, D: TyDecoder<I = TyCtxt<'tcx>>> RefDecodable<'tcx, D>\n     for [(ty::Predicate<'tcx>, Span)]\n {\n     fn decode(decoder: &mut D) -> &'tcx Self {\n-        decoder.interner().tcx.arena.alloc_from_iter(\n+        decoder.interner().arena.alloc_from_iter(\n             (0..decoder.read_usize()).map(|_| Decodable::decode(decoder)).collect::<Vec<_>>(),\n         )\n     }\n }\n \n-impl<'tcx, D: TyDecoder<I = TyInterner<'tcx>>> RefDecodable<'tcx, D>\n+impl<'tcx, D: TyDecoder<I = TyCtxt<'tcx>>> RefDecodable<'tcx, D>\n     for [thir::abstract_const::Node<'tcx>]\n {\n     fn decode(decoder: &mut D) -> &'tcx Self {\n-        decoder.interner().tcx.arena.alloc_from_iter(\n+        decoder.interner().arena.alloc_from_iter(\n             (0..decoder.read_usize()).map(|_| Decodable::decode(decoder)).collect::<Vec<_>>(),\n         )\n     }\n }\n \n-impl<'tcx, D: TyDecoder<I = TyInterner<'tcx>>> RefDecodable<'tcx, D>\n+impl<'tcx, D: TyDecoder<I = TyCtxt<'tcx>>> RefDecodable<'tcx, D>\n     for [thir::abstract_const::NodeId]\n {\n     fn decode(decoder: &mut D) -> &'tcx Self {\n-        decoder.interner().tcx.arena.alloc_from_iter(\n+        decoder.interner().arena.alloc_from_iter(\n             (0..decoder.read_usize()).map(|_| Decodable::decode(decoder)).collect::<Vec<_>>(),\n         )\n     }\n }\n \n-impl<'tcx, D: TyDecoder<I = TyInterner<'tcx>>> RefDecodable<'tcx, D>\n+impl<'tcx, D: TyDecoder<I = TyCtxt<'tcx>>> RefDecodable<'tcx, D>\n     for ty::List<ty::BoundVariableKind>\n {\n     fn decode(decoder: &mut D) -> &'tcx Self {\n         let len = decoder.read_usize();\n-        decoder.interner().tcx.mk_bound_variable_kinds(\n+        decoder.interner().mk_bound_variable_kinds(\n             (0..len).map::<ty::BoundVariableKind, _>(|_| Decodable::decode(decoder)),\n         )\n     }\n@@ -414,14 +409,14 @@ macro_rules! impl_arena_allocatable_decoder {\n     ([]$args:tt) => {};\n     ([decode $(, $attrs:ident)*]\n      [$name:ident: $ty:ty]) => {\n-        impl<'tcx, D: TyDecoder<I = TyInterner<'tcx>>> RefDecodable<'tcx, D> for $ty {\n+        impl<'tcx, D: TyDecoder<I = TyCtxt<'tcx>>> RefDecodable<'tcx, D> for $ty {\n             #[inline]\n             fn decode(decoder: &mut D) -> &'tcx Self {\n                 decode_arena_allocable(decoder)\n             }\n         }\n \n-        impl<'tcx, D: TyDecoder<I = TyInterner<'tcx>>> RefDecodable<'tcx, D> for [$ty] {\n+        impl<'tcx, D: TyDecoder<I = TyCtxt<'tcx>>> RefDecodable<'tcx, D> for [$ty] {\n             #[inline]\n             fn decode(decoder: &mut D) -> &'tcx Self {\n                 decode_arena_allocable_slice(decoder)\n@@ -443,17 +438,17 @@ arena_types!(impl_arena_allocatable_decoders);\n \n macro_rules! impl_arena_copy_decoder {\n     (<$tcx:tt> $($ty:ty,)*) => {\n-        $(impl<'tcx, D: TyDecoder<I = TyInterner<'tcx>>> RefDecodable<'tcx, D> for $ty {\n+        $(impl<'tcx, D: TyDecoder<I = TyCtxt<'tcx>>> RefDecodable<'tcx, D> for $ty {\n             #[inline]\n             fn decode(decoder: &mut D) -> &'tcx Self {\n-                decoder.interner().tcx.arena.alloc(Decodable::decode(decoder))\n+                decoder.interner().arena.alloc(Decodable::decode(decoder))\n             }\n         }\n \n-        impl<'tcx, D: TyDecoder<I = TyInterner<'tcx>>> RefDecodable<'tcx, D> for [$ty] {\n+        impl<'tcx, D: TyDecoder<I = TyCtxt<'tcx>>> RefDecodable<'tcx, D> for [$ty] {\n             #[inline]\n             fn decode(decoder: &mut D) -> &'tcx Self {\n-                decoder.interner().tcx.arena.alloc_from_iter(<Vec<_> as Decodable<D>>::decode(decoder))\n+                decoder.interner().arena.alloc_from_iter(<Vec<_> as Decodable<D>>::decode(decoder))\n             }\n         })*\n     };\n@@ -512,13 +507,13 @@ macro_rules! implement_ty_decoder {\n macro_rules! impl_binder_encode_decode {\n     ($($t:ty),+ $(,)?) => {\n         $(\n-            impl<'tcx, E: TyEncoder<I = TyInterner<'tcx>>> Encodable<E> for ty::Binder<'tcx, $t> {\n+            impl<'tcx, E: TyEncoder<I = TyCtxt<'tcx>>> Encodable<E> for ty::Binder<'tcx, $t> {\n                 fn encode(&self, e: &mut E) -> Result<(), E::Error> {\n                     self.bound_vars().encode(e)?;\n                     self.as_ref().skip_binder().encode(e)\n                 }\n             }\n-            impl<'tcx, D: TyDecoder<I = TyInterner<'tcx>>> Decodable<D> for ty::Binder<'tcx, $t> {\n+            impl<'tcx, D: TyDecoder<I = TyCtxt<'tcx>>> Decodable<D> for ty::Binder<'tcx, $t> {\n                 fn decode(decoder: &mut D) -> Self {\n                     let bound_vars = Decodable::decode(decoder);\n                     ty::Binder::bind_with_vars(Decodable::decode(decoder), bound_vars)"}, {"sha": "a0d92e2a5dd94fc89102ac8bff7cf5e11b858560", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/46389159403ca0973bf88a4c153a2707cdb257d2/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46389159403ca0973bf88a4c153a2707cdb257d2/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=46389159403ca0973bf88a4c153a2707cdb257d2", "patch": "@@ -90,12 +90,8 @@ pub trait OnDiskCache<'tcx>: rustc_data_structures::sync::Sync {\n     fn serialize(&self, tcx: TyCtxt<'tcx>, encoder: &mut FileEncoder) -> FileEncodeResult;\n }\n \n-pub struct TyInterner<'tcx> {\n-    pub tcx: TyCtxt<'tcx>,\n-}\n-\n #[allow(rustc::usage_of_ty_tykind)]\n-impl<'tcx> Interner for TyInterner<'tcx> {\n+impl<'tcx> Interner for TyCtxt<'tcx> {\n     type AdtDef = ty::AdtDef<'tcx>;\n     type SubstsRef = ty::SubstsRef<'tcx>;\n     type DefId = DefId;\n@@ -1103,11 +1099,6 @@ pub struct GlobalCtxt<'tcx> {\n }\n \n impl<'tcx> TyCtxt<'tcx> {\n-    #[inline]\n-    pub fn interner(self) -> TyInterner<'tcx> {\n-        TyInterner { tcx: self }\n-    }\n-\n     /// Expects a body and returns its codegen attributes.\n     ///\n     /// Unlike `codegen_fn_attrs`, this returns `CodegenFnAttrs::EMPTY` for"}, {"sha": "14e5dc0dd772250ed73d858597338a668c7a2eb7", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 7, "deletions": 20, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/46389159403ca0973bf88a4c153a2707cdb257d2/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46389159403ca0973bf88a4c153a2707cdb257d2/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=46389159403ca0973bf88a4c153a2707cdb257d2", "patch": "@@ -68,8 +68,8 @@ pub use self::consts::{\n pub use self::context::{\n     tls, CanonicalUserType, CanonicalUserTypeAnnotation, CanonicalUserTypeAnnotations,\n     CtxtInterners, DelaySpanBugEmitted, FreeRegionInfo, GeneratorDiagnosticData,\n-    GeneratorInteriorTypeCause, GlobalCtxt, Lift, OnDiskCache, TyCtxt, TyInterner, TypeckResults,\n-    UserType, UserTypeAnnotationIndex,\n+    GeneratorInteriorTypeCause, GlobalCtxt, Lift, OnDiskCache, TyCtxt, TypeckResults, UserType,\n+    UserTypeAnnotationIndex,\n };\n pub use self::instance::{Instance, InstanceDef};\n pub use self::list::List;\n@@ -463,30 +463,17 @@ static_assert_size!(WithStableHash<TyS<'_>>, 56);\n #[rustc_pass_by_value]\n pub struct Ty<'tcx>(Interned<'tcx, WithStableHash<TyS<'tcx>>>);\n \n-static LEAKED_BOOL_TY_ALREADY: std::sync::atomic::AtomicBool =\n-    std::sync::atomic::AtomicBool::new(false);\n-\n-/// \"Static\" bool only used for internal testing.\n-///\n-/// FIXME(rustc_type_ir): This really should be replaced with something that doesn't leak.\n-/// however, since it's used for testing, it's not _that_ bad.\n-pub fn leak_bool_ty_for_unit_testing<'tcx>() -> Ty<'tcx> {\n-    use std::sync::atomic::*;\n-\n-    if LEAKED_BOOL_TY_ALREADY.load(Ordering::Acquire) {\n-        panic!(\"Can only leak one bool type, since its equality depends on its address\");\n-    } else {\n-        LEAKED_BOOL_TY_ALREADY.store(true, Ordering::Release);\n-    }\n-\n-    Ty(Interned::new_unchecked(Box::leak(Box::new(WithStableHash {\n+impl<'tcx> TyCtxt<'tcx> {\n+    /// A \"bool\" type used in rustc_mir_transform unit tests when we\n+    /// have not spun up a TyCtxt.\n+    pub const BOOL_TY_FOR_UNIT_TESTING: Ty<'tcx> = Ty(Interned::new_unchecked(&WithStableHash {\n         internee: TyS {\n             kind: ty::Bool,\n             flags: TypeFlags::empty(),\n             outer_exclusive_binder: DebruijnIndex::from_usize(0),\n         },\n         stable_hash: Fingerprint::ZERO,\n-    }))))\n+    }));\n }\n \n impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for TyS<'tcx> {"}, {"sha": "faeb729c88483463a49d33c5c27d4ca305893d86", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46389159403ca0973bf88a4c153a2707cdb257d2/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46389159403ca0973bf88a4c153a2707cdb257d2/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=46389159403ca0973bf88a4c153a2707cdb257d2", "patch": "@@ -32,7 +32,7 @@ use rustc_type_ir::TyKind as IrTyKind;\n \n // Re-export the `TyKind` from `rustc_type_ir` here for convenience\n #[rustc_diagnostic_item = \"TyKind\"]\n-pub type TyKind<'tcx> = IrTyKind<ty::TyInterner<'tcx>>;\n+pub type TyKind<'tcx> = IrTyKind<TyCtxt<'tcx>>;\n \n #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, TyEncodable, TyDecodable)]\n #[derive(HashStable, TypeFoldable, Lift)]"}, {"sha": "290485ab5fe0f83d51cecb317c8973f4310dbf62", "filename": "compiler/rustc_middle/src/ty/subst.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/46389159403ca0973bf88a4c153a2707cdb257d2/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46389159403ca0973bf88a4c153a2707cdb257d2/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs?ref=46389159403ca0973bf88a4c153a2707cdb257d2", "patch": "@@ -4,7 +4,7 @@ use crate::mir;\n use crate::ty::codec::{TyDecoder, TyEncoder};\n use crate::ty::fold::{FallibleTypeFolder, TypeFoldable, TypeFolder, TypeVisitor};\n use crate::ty::sty::{ClosureSubsts, GeneratorSubsts, InlineConstSubsts};\n-use crate::ty::{self, Lift, List, ParamConst, Ty, TyCtxt, TyInterner};\n+use crate::ty::{self, Lift, List, ParamConst, Ty, TyCtxt};\n \n use rustc_data_structures::intern::{Interned, WithStableHash};\n use rustc_hir::def_id::DefId;\n@@ -216,13 +216,13 @@ impl<'tcx> TypeFoldable<'tcx> for GenericArg<'tcx> {\n     }\n }\n \n-impl<'tcx, E: TyEncoder<I = TyInterner<'tcx>>> Encodable<E> for GenericArg<'tcx> {\n+impl<'tcx, E: TyEncoder<I = TyCtxt<'tcx>>> Encodable<E> for GenericArg<'tcx> {\n     fn encode(&self, e: &mut E) -> Result<(), E::Error> {\n         self.unpack().encode(e)\n     }\n }\n \n-impl<'tcx, D: TyDecoder<I = TyInterner<'tcx>>> Decodable<D> for GenericArg<'tcx> {\n+impl<'tcx, D: TyDecoder<I = TyCtxt<'tcx>>> Decodable<D> for GenericArg<'tcx> {\n     fn decode(d: &mut D) -> GenericArg<'tcx> {\n         GenericArgKind::decode(d).pack()\n     }"}, {"sha": "213bb6608e1396fc51a199c9a4123ff356e86afa", "filename": "compiler/rustc_mir_transform/src/coverage/tests.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/46389159403ca0973bf88a4c153a2707cdb257d2/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46389159403ca0973bf88a4c153a2707cdb257d2/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Ftests.rs?ref=46389159403ca0973bf88a4c153a2707cdb257d2", "patch": "@@ -37,7 +37,7 @@ use rustc_data_structures::graph::WithSuccessors;\n use rustc_index::vec::{Idx, IndexVec};\n use rustc_middle::mir::coverage::CoverageKind;\n use rustc_middle::mir::*;\n-use rustc_middle::ty::{self, Ty};\n+use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_span::{self, BytePos, Pos, Span, DUMMY_SP};\n \n // All `TEMP_BLOCK` targets should be replaced before calling `to_body() -> mir::Body`.\n@@ -56,7 +56,7 @@ impl<'tcx> MockBlocks<'tcx> {\n             blocks: IndexVec::new(),\n             dummy_place: Place { local: RETURN_PLACE, projection: ty::List::empty() },\n             next_local: 0,\n-            bool_ty: ty::leak_bool_ty_for_unit_testing(),\n+            bool_ty: TyCtxt::BOOL_TY_FOR_UNIT_TESTING,\n         }\n     }\n "}, {"sha": "8e4b3269402e9b6a84dc40d144ab0825acba1792", "filename": "compiler/rustc_query_impl/src/on_disk_cache.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/46389159403ca0973bf88a4c153a2707cdb257d2/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46389159403ca0973bf88a4c153a2707cdb257d2/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs?ref=46389159403ca0973bf88a4c153a2707cdb257d2", "patch": "@@ -11,7 +11,7 @@ use rustc_middle::mir::interpret::{AllocDecodingSession, AllocDecodingState};\n use rustc_middle::mir::{self, interpret};\n use rustc_middle::thir;\n use rustc_middle::ty::codec::{RefDecodable, TyDecoder, TyEncoder};\n-use rustc_middle::ty::{self, Ty, TyCtxt, TyInterner};\n+use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_query_system::dep_graph::DepContext;\n use rustc_query_system::query::{QueryCache, QueryContext, QuerySideEffects};\n use rustc_serialize::{\n@@ -548,12 +548,12 @@ where\n }\n \n impl<'a, 'tcx> TyDecoder for CacheDecoder<'a, 'tcx> {\n-    type I = TyInterner<'tcx>;\n+    type I = TyCtxt<'tcx>;\n     const CLEAR_CROSS_CRATE: bool = false;\n \n     #[inline]\n-    fn interner(&self) -> TyInterner<'tcx> {\n-        TyInterner { tcx: self.tcx }\n+    fn interner(&self) -> TyCtxt<'tcx> {\n+        self.tcx\n     }\n \n     #[inline]\n@@ -932,7 +932,7 @@ impl<'a, 'tcx, E> TyEncoder for CacheEncoder<'a, 'tcx, E>\n where\n     E: 'a + OpaqueEncoder,\n {\n-    type I = TyInterner<'tcx>;\n+    type I = TyCtxt<'tcx>;\n     const CLEAR_CROSS_CRATE: bool = false;\n \n     fn position(&self) -> usize {"}, {"sha": "0a1c350b2db13cba843d89b34b5ff62aaf826946", "filename": "compiler/rustc_query_system/src/ich/mod.rs", "status": "modified", "additions": 0, "deletions": 122, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/46389159403ca0973bf88a4c153a2707cdb257d2/compiler%2Frustc_query_system%2Fsrc%2Fich%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46389159403ca0973bf88a4c153a2707cdb257d2/compiler%2Frustc_query_system%2Fsrc%2Fich%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fich%2Fmod.rs?ref=46389159403ca0973bf88a4c153a2707cdb257d2", "patch": "@@ -1,7 +1,6 @@\n //! ICH - Incremental Compilation Hash\n \n pub use self::hcx::StableHashingContext;\n-use rustc_data_structures::stable_hasher::HashStable;\n use rustc_span::symbol::{sym, Symbol};\n \n mod hcx;\n@@ -18,124 +17,3 @@ pub const IGNORED_ATTRIBUTES: &[Symbol] = &[\n     sym::rustc_partition_codegened,\n     sym::rustc_expected_cgu_reuse,\n ];\n-\n-#[allow(rustc::usage_of_ty_tykind)]\n-impl<'__ctx, I: rustc_type_ir::Interner> HashStable<StableHashingContext<'__ctx>>\n-    for rustc_type_ir::TyKind<I>\n-where\n-    I::AdtDef: HashStable<StableHashingContext<'__ctx>>,\n-    I::DefId: HashStable<StableHashingContext<'__ctx>>,\n-    I::SubstsRef: HashStable<StableHashingContext<'__ctx>>,\n-    I::Ty: HashStable<StableHashingContext<'__ctx>>,\n-    I::Const: HashStable<StableHashingContext<'__ctx>>,\n-    I::TypeAndMut: HashStable<StableHashingContext<'__ctx>>,\n-    I::PolyFnSig: HashStable<StableHashingContext<'__ctx>>,\n-    I::ListBinderExistentialPredicate: HashStable<StableHashingContext<'__ctx>>,\n-    I::Region: HashStable<StableHashingContext<'__ctx>>,\n-    I::Movability: HashStable<StableHashingContext<'__ctx>>,\n-    I::Mutability: HashStable<StableHashingContext<'__ctx>>,\n-    I::BinderListTy: HashStable<StableHashingContext<'__ctx>>,\n-    I::ListTy: HashStable<StableHashingContext<'__ctx>>,\n-    I::ProjectionTy: HashStable<StableHashingContext<'__ctx>>,\n-    I::BoundTy: HashStable<StableHashingContext<'__ctx>>,\n-    I::ParamTy: HashStable<StableHashingContext<'__ctx>>,\n-    I::PlaceholderType: HashStable<StableHashingContext<'__ctx>>,\n-    I::InferTy: HashStable<StableHashingContext<'__ctx>>,\n-    I::DelaySpanBugEmitted: HashStable<StableHashingContext<'__ctx>>,\n-{\n-    #[inline]\n-    fn hash_stable(\n-        &self,\n-        __hcx: &mut crate::ich::StableHashingContext<'__ctx>,\n-        __hasher: &mut rustc_data_structures::stable_hasher::StableHasher,\n-    ) {\n-        std::mem::discriminant(self).hash_stable(__hcx, __hasher);\n-        use rustc_type_ir::TyKind::*;\n-        match self {\n-            Bool => {}\n-            Char => {}\n-            Int(i) => {\n-                i.hash_stable(__hcx, __hasher);\n-            }\n-            Uint(u) => {\n-                u.hash_stable(__hcx, __hasher);\n-            }\n-            Float(f) => {\n-                f.hash_stable(__hcx, __hasher);\n-            }\n-            Adt(adt, substs) => {\n-                adt.hash_stable(__hcx, __hasher);\n-                substs.hash_stable(__hcx, __hasher);\n-            }\n-            Foreign(def_id) => {\n-                def_id.hash_stable(__hcx, __hasher);\n-            }\n-            Str => {}\n-            Array(t, c) => {\n-                t.hash_stable(__hcx, __hasher);\n-                c.hash_stable(__hcx, __hasher);\n-            }\n-            Slice(t) => {\n-                t.hash_stable(__hcx, __hasher);\n-            }\n-            RawPtr(tam) => {\n-                tam.hash_stable(__hcx, __hasher);\n-            }\n-            Ref(r, t, m) => {\n-                r.hash_stable(__hcx, __hasher);\n-                t.hash_stable(__hcx, __hasher);\n-                m.hash_stable(__hcx, __hasher);\n-            }\n-            FnDef(def_id, substs) => {\n-                def_id.hash_stable(__hcx, __hasher);\n-                substs.hash_stable(__hcx, __hasher);\n-            }\n-            FnPtr(polyfnsig) => {\n-                polyfnsig.hash_stable(__hcx, __hasher);\n-            }\n-            Dynamic(l, r) => {\n-                l.hash_stable(__hcx, __hasher);\n-                r.hash_stable(__hcx, __hasher);\n-            }\n-            Closure(def_id, substs) => {\n-                def_id.hash_stable(__hcx, __hasher);\n-                substs.hash_stable(__hcx, __hasher);\n-            }\n-            Generator(def_id, substs, m) => {\n-                def_id.hash_stable(__hcx, __hasher);\n-                substs.hash_stable(__hcx, __hasher);\n-                m.hash_stable(__hcx, __hasher);\n-            }\n-            GeneratorWitness(b) => {\n-                b.hash_stable(__hcx, __hasher);\n-            }\n-            Never => {}\n-            Tuple(substs) => {\n-                substs.hash_stable(__hcx, __hasher);\n-            }\n-            Projection(p) => {\n-                p.hash_stable(__hcx, __hasher);\n-            }\n-            Opaque(def_id, substs) => {\n-                def_id.hash_stable(__hcx, __hasher);\n-                substs.hash_stable(__hcx, __hasher);\n-            }\n-            Param(p) => {\n-                p.hash_stable(__hcx, __hasher);\n-            }\n-            Bound(d, b) => {\n-                d.hash_stable(__hcx, __hasher);\n-                b.hash_stable(__hcx, __hasher);\n-            }\n-            Placeholder(p) => {\n-                p.hash_stable(__hcx, __hasher);\n-            }\n-            Infer(i) => {\n-                i.hash_stable(__hcx, __hasher);\n-            }\n-            Error(d) => {\n-                d.hash_stable(__hcx, __hasher);\n-            }\n-        }\n-    }\n-}"}, {"sha": "6380001b57c08b1ab11e2968535e38573e70ca46", "filename": "compiler/rustc_type_ir/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/46389159403ca0973bf88a4c153a2707cdb257d2/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46389159403ca0973bf88a4c153a2707cdb257d2/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs?ref=46389159403ca0973bf88a4c153a2707cdb257d2", "patch": "@@ -8,7 +8,6 @@ extern crate rustc_macros;\n \n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::unify::{EqUnifyValue, UnifyKey};\n-//use rustc_serialize::{Decodable, Encodable};\n use smallvec::SmallVec;\n use std::fmt;\n use std::fmt::Debug;"}, {"sha": "650c3519b562e8cf4bc1045bd0925481019e082d", "filename": "compiler/rustc_type_ir/src/sty.rs", "status": "modified", "additions": 134, "deletions": 1, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/46389159403ca0973bf88a4c153a2707cdb257d2/compiler%2Frustc_type_ir%2Fsrc%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46389159403ca0973bf88a4c153a2707cdb257d2/compiler%2Frustc_type_ir%2Fsrc%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_type_ir%2Fsrc%2Fsty.rs?ref=46389159403ca0973bf88a4c153a2707cdb257d2", "patch": "@@ -13,6 +13,7 @@ use crate::UintTy;\n \n use self::TyKind::*;\n \n+use rustc_data_structures::stable_hasher::HashStable;\n use rustc_serialize::{Decodable, Encodable};\n \n /// Defines the kinds of types used by the type system.\n@@ -198,7 +199,10 @@ impl<I: Interner> TyKind<I> {\n     }\n }\n \n-fn discriminant<I: Interner>(value: &TyKind<I>) -> usize {\n+// This is manually implemented for `TyKind` because `std::mem::discriminant`\n+// returns an opaque value that is `PartialEq` but not `PartialOrd`\n+#[inline]\n+const fn discriminant<I: Interner>(value: &TyKind<I>) -> usize {\n     match value {\n         Bool => 0,\n         Char => 1,\n@@ -230,6 +234,7 @@ fn discriminant<I: Interner>(value: &TyKind<I>) -> usize {\n     }\n }\n \n+// This is manually implemented because a derive would require `I: Clone`\n impl<I: Interner> Clone for TyKind<I> {\n     fn clone(&self) -> Self {\n         match self {\n@@ -264,6 +269,7 @@ impl<I: Interner> Clone for TyKind<I> {\n     }\n }\n \n+// This is manually implemented because a derive would require `I: PartialEq`\n impl<I: Interner> PartialEq for TyKind<I> {\n     #[inline]\n     fn eq(&self, other: &TyKind<I>) -> bool {\n@@ -324,15 +330,18 @@ impl<I: Interner> PartialEq for TyKind<I> {\n     }\n }\n \n+// This is manually implemented because a derive would require `I: Eq`\n impl<I: Interner> Eq for TyKind<I> {}\n \n+// This is manually implemented because a derive would require `I: PartialOrd`\n impl<I: Interner> PartialOrd for TyKind<I> {\n     #[inline]\n     fn partial_cmp(&self, other: &TyKind<I>) -> Option<Ordering> {\n         Some(Ord::cmp(self, other))\n     }\n }\n \n+// This is manually implemented because a derive would require `I: Ord`\n impl<I: Interner> Ord for TyKind<I> {\n     #[inline]\n     fn cmp(&self, other: &TyKind<I>) -> Ordering {\n@@ -430,6 +439,7 @@ impl<I: Interner> Ord for TyKind<I> {\n     }\n }\n \n+// This is manually implemented because a derive would require `I: Hash`\n impl<I: Interner> hash::Hash for TyKind<I> {\n     fn hash<__H: hash::Hasher>(&self, state: &mut __H) -> () {\n         match (&*self,) {\n@@ -541,6 +551,7 @@ impl<I: Interner> hash::Hash for TyKind<I> {\n     }\n }\n \n+// This is manually implemented because a derive would require `I: Debug`\n impl<I: Interner> fmt::Debug for TyKind<I> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match (&*self,) {\n@@ -678,6 +689,7 @@ impl<I: Interner> fmt::Debug for TyKind<I> {\n     }\n }\n \n+// This is manually implemented because a derive would require `I: Encodable`\n impl<I: Interner, E: TyEncoder> Encodable<E> for TyKind<I>\n where\n     I::DelaySpanBugEmitted: Encodable<E>,\n@@ -819,6 +831,7 @@ where\n     }\n }\n \n+// This is manually implemented because a derive would require `I: Decodable`\n impl<I: Interner, D: TyDecoder<I = I>> Decodable<D> for TyKind<I>\n where\n     I::DelaySpanBugEmitted: Decodable<D>,\n@@ -905,3 +918,123 @@ where\n         }\n     }\n }\n+\n+// This is not a derived impl because a derive would require `I: HashStable`\n+#[allow(rustc::usage_of_ty_tykind)]\n+impl<CTX, I: Interner> HashStable<CTX> for TyKind<I>\n+where\n+    I::AdtDef: HashStable<CTX>,\n+    I::DefId: HashStable<CTX>,\n+    I::SubstsRef: HashStable<CTX>,\n+    I::Ty: HashStable<CTX>,\n+    I::Const: HashStable<CTX>,\n+    I::TypeAndMut: HashStable<CTX>,\n+    I::PolyFnSig: HashStable<CTX>,\n+    I::ListBinderExistentialPredicate: HashStable<CTX>,\n+    I::Region: HashStable<CTX>,\n+    I::Movability: HashStable<CTX>,\n+    I::Mutability: HashStable<CTX>,\n+    I::BinderListTy: HashStable<CTX>,\n+    I::ListTy: HashStable<CTX>,\n+    I::ProjectionTy: HashStable<CTX>,\n+    I::BoundTy: HashStable<CTX>,\n+    I::ParamTy: HashStable<CTX>,\n+    I::PlaceholderType: HashStable<CTX>,\n+    I::InferTy: HashStable<CTX>,\n+    I::DelaySpanBugEmitted: HashStable<CTX>,\n+{\n+    #[inline]\n+    fn hash_stable(\n+        &self,\n+        __hcx: &mut CTX,\n+        __hasher: &mut rustc_data_structures::stable_hasher::StableHasher,\n+    ) {\n+        std::mem::discriminant(self).hash_stable(__hcx, __hasher);\n+        match self {\n+            Bool => {}\n+            Char => {}\n+            Int(i) => {\n+                i.hash_stable(__hcx, __hasher);\n+            }\n+            Uint(u) => {\n+                u.hash_stable(__hcx, __hasher);\n+            }\n+            Float(f) => {\n+                f.hash_stable(__hcx, __hasher);\n+            }\n+            Adt(adt, substs) => {\n+                adt.hash_stable(__hcx, __hasher);\n+                substs.hash_stable(__hcx, __hasher);\n+            }\n+            Foreign(def_id) => {\n+                def_id.hash_stable(__hcx, __hasher);\n+            }\n+            Str => {}\n+            Array(t, c) => {\n+                t.hash_stable(__hcx, __hasher);\n+                c.hash_stable(__hcx, __hasher);\n+            }\n+            Slice(t) => {\n+                t.hash_stable(__hcx, __hasher);\n+            }\n+            RawPtr(tam) => {\n+                tam.hash_stable(__hcx, __hasher);\n+            }\n+            Ref(r, t, m) => {\n+                r.hash_stable(__hcx, __hasher);\n+                t.hash_stable(__hcx, __hasher);\n+                m.hash_stable(__hcx, __hasher);\n+            }\n+            FnDef(def_id, substs) => {\n+                def_id.hash_stable(__hcx, __hasher);\n+                substs.hash_stable(__hcx, __hasher);\n+            }\n+            FnPtr(polyfnsig) => {\n+                polyfnsig.hash_stable(__hcx, __hasher);\n+            }\n+            Dynamic(l, r) => {\n+                l.hash_stable(__hcx, __hasher);\n+                r.hash_stable(__hcx, __hasher);\n+            }\n+            Closure(def_id, substs) => {\n+                def_id.hash_stable(__hcx, __hasher);\n+                substs.hash_stable(__hcx, __hasher);\n+            }\n+            Generator(def_id, substs, m) => {\n+                def_id.hash_stable(__hcx, __hasher);\n+                substs.hash_stable(__hcx, __hasher);\n+                m.hash_stable(__hcx, __hasher);\n+            }\n+            GeneratorWitness(b) => {\n+                b.hash_stable(__hcx, __hasher);\n+            }\n+            Never => {}\n+            Tuple(substs) => {\n+                substs.hash_stable(__hcx, __hasher);\n+            }\n+            Projection(p) => {\n+                p.hash_stable(__hcx, __hasher);\n+            }\n+            Opaque(def_id, substs) => {\n+                def_id.hash_stable(__hcx, __hasher);\n+                substs.hash_stable(__hcx, __hasher);\n+            }\n+            Param(p) => {\n+                p.hash_stable(__hcx, __hasher);\n+            }\n+            Bound(d, b) => {\n+                d.hash_stable(__hcx, __hasher);\n+                b.hash_stable(__hcx, __hasher);\n+            }\n+            Placeholder(p) => {\n+                p.hash_stable(__hcx, __hasher);\n+            }\n+            Infer(i) => {\n+                i.hash_stable(__hcx, __hasher);\n+            }\n+            Error(d) => {\n+                d.hash_stable(__hcx, __hasher);\n+            }\n+        }\n+    }\n+}"}, {"sha": "3ae04706e4bc33d8acf8914f14d2771b792985f4", "filename": "compiler/rustc_typeck/src/check/op.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46389159403ca0973bf88a4c153a2707cdb257d2/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46389159403ca0973bf88a4c153a2707cdb257d2/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fop.rs?ref=46389159403ca0973bf88a4c153a2707cdb257d2", "patch": "@@ -677,8 +677,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         operand_ty: Ty<'tcx>,\n         op: hir::UnOp,\n     ) -> Ty<'tcx> {\n-        use rustc_type_ir::sty::TyKind::*;\n-\n         assert!(op.is_by_value());\n         match self.lookup_op_method(operand_ty, None, None, Op::Unary(op, ex.span)) {\n             Ok(method) => {"}]}