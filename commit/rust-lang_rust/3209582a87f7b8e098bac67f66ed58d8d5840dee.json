{"sha": "3209582a87f7b8e098bac67f66ed58d8d5840dee", "node_id": "C_kwDOAAsO6NoAKDMyMDk1ODJhODdmN2I4ZTA5OGJhYzY3ZjY2ZWQ1OGQ4ZDU4NDBkZWU", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2021-10-06T19:33:13Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-10-06T19:33:13Z"}, "message": "Rollup merge of #87601 - a1phyr:feature_uint_add_signed, r=kennytm\n\nAdd functions to add unsigned and signed integers\n\nThis PR adds methods to unsigned integers to add signed integers with good overflow semantics under `#![feature(mixed_integer_ops)]`.\n\nThe added API is:\n\n```rust\n// `uX` is `u8`, `u16`, `u32`, `u64`,`u128`, `usize`\nimpl uX {\n    pub const fn checked_add_signed(self, iX) -> Option<Self>;\n    pub const fn overflowing_add_signed(self, iX) -> (Self, bool);\n    pub const fn saturating_add_signed(self, iX) -> Self;\n    pub const fn wrapping_add_signed(self, iX) -> Self;\n}\n\nimpl iX {\n    pub const fn checked_add_unsigned(self, uX) -> Option<Self>;\n    pub const fn overflowing_add_unsigned(self, uX) -> (Self, bool);\n    pub const fn saturating_add_unsigned(self, uX) -> Self;\n    pub const fn wrapping_add_unsigned(self, uX) -> Self;\n\n    pub const fn checked_sub_unsigned(self, uX) -> Option<Self>;\n    pub const fn overflowing_sub_unsigned(self, uX) -> (Self, bool);\n    pub const fn saturating_sub_unsigned(self, uX) -> Self;\n    pub const fn wrapping_sub_unsigned(self, uX) -> Self;\n}\n```\n\nMaybe it would be interesting to also have `add_signed` that panics in debug and wraps in release ?", "tree": {"sha": "dd17f17506a04ccb9167e7d3b6b2bb8cbf1a6a86", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dd17f17506a04ccb9167e7d3b6b2bb8cbf1a6a86"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3209582a87f7b8e098bac67f66ed58d8d5840dee", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhXfn5CRBK7hj4Ov3rIwAA7IsIAKJ+R744QToMt98e0m0fFpay\nWynBsHmJBf8yYNACtf2fLSlkKNX93UvLvapm/Vxin7c7/fSmHnIw36zC0/PFlE5H\nJ8MyR4RPmKC0mfTG1mVB2XZ6fkqXwmi/QOIirS1jiEDO1uT85Alu8jRhSBfcguUh\n0G2+8TwHiYH3fNm3+CB5we5a6puV+iwd0DS8ZLJOYUFe5hVIpeWPwZBJXpvAL7gD\n0wM5Irp4TAdyxZ/ZjmDpMvznG1cH3hInCuXbr7XEZTpsamb5Xlzez+2gNymWxcFZ\njB17NZk7OD1AbeRGcTrmk6aIZIyrwBBf1e1gVm5gf93l8ItuK70oXO22mHYqLFQ=\n=wtF7\n-----END PGP SIGNATURE-----\n", "payload": "tree dd17f17506a04ccb9167e7d3b6b2bb8cbf1a6a86\nparent d7539a6af09e5889ed9bcb8b49571b7a59c32e65\nparent 47edde1086412b36e9efd6098b191ec15a2a760a\nauthor Manish Goregaokar <manishsmail@gmail.com> 1633548793 -0700\ncommitter GitHub <noreply@github.com> 1633548793 -0700\n\nRollup merge of #87601 - a1phyr:feature_uint_add_signed, r=kennytm\n\nAdd functions to add unsigned and signed integers\n\nThis PR adds methods to unsigned integers to add signed integers with good overflow semantics under `#![feature(mixed_integer_ops)]`.\n\nThe added API is:\n\n```rust\n// `uX` is `u8`, `u16`, `u32`, `u64`,`u128`, `usize`\nimpl uX {\n    pub const fn checked_add_signed(self, iX) -> Option<Self>;\n    pub const fn overflowing_add_signed(self, iX) -> (Self, bool);\n    pub const fn saturating_add_signed(self, iX) -> Self;\n    pub const fn wrapping_add_signed(self, iX) -> Self;\n}\n\nimpl iX {\n    pub const fn checked_add_unsigned(self, uX) -> Option<Self>;\n    pub const fn overflowing_add_unsigned(self, uX) -> (Self, bool);\n    pub const fn saturating_add_unsigned(self, uX) -> Self;\n    pub const fn wrapping_add_unsigned(self, uX) -> Self;\n\n    pub const fn checked_sub_unsigned(self, uX) -> Option<Self>;\n    pub const fn overflowing_sub_unsigned(self, uX) -> (Self, bool);\n    pub const fn saturating_sub_unsigned(self, uX) -> Self;\n    pub const fn wrapping_sub_unsigned(self, uX) -> Self;\n}\n```\n\nMaybe it would be interesting to also have `add_signed` that panics in debug and wraps in release ?\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3209582a87f7b8e098bac67f66ed58d8d5840dee", "html_url": "https://github.com/rust-lang/rust/commit/3209582a87f7b8e098bac67f66ed58d8d5840dee", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3209582a87f7b8e098bac67f66ed58d8d5840dee/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d7539a6af09e5889ed9bcb8b49571b7a59c32e65", "url": "https://api.github.com/repos/rust-lang/rust/commits/d7539a6af09e5889ed9bcb8b49571b7a59c32e65", "html_url": "https://github.com/rust-lang/rust/commit/d7539a6af09e5889ed9bcb8b49571b7a59c32e65"}, {"sha": "47edde1086412b36e9efd6098b191ec15a2a760a", "url": "https://api.github.com/repos/rust-lang/rust/commits/47edde1086412b36e9efd6098b191ec15a2a760a", "html_url": "https://github.com/rust-lang/rust/commit/47edde1086412b36e9efd6098b191ec15a2a760a"}], "stats": {"total": 319, "additions": 304, "deletions": 15}, "files": [{"sha": "f9d517ce8c0eb52beae244452b9f1069cdbfb84e", "filename": "library/core/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3209582a87f7b8e098bac67f66ed58d8d5840dee/library%2Fcore%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3209582a87f7b8e098bac67f66ed58d8d5840dee/library%2Fcore%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Flib.rs?ref=3209582a87f7b8e098bac67f66ed58d8d5840dee", "patch": "@@ -142,6 +142,7 @@\n #![feature(link_llvm_intrinsics)]\n #![feature(llvm_asm)]\n #![feature(min_specialization)]\n+#![feature(mixed_integer_ops)]\n #![cfg_attr(not(bootstrap), feature(must_not_suspend))]\n #![feature(negative_impls)]\n #![feature(never_type)]"}, {"sha": "12dda61400f2a62ccd816e9c9b2bb9abba0ce7fe", "filename": "library/core/src/num/int_macros.rs", "status": "modified", "additions": 192, "deletions": 0, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/3209582a87f7b8e098bac67f66ed58d8d5840dee/library%2Fcore%2Fsrc%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3209582a87f7b8e098bac67f66ed58d8d5840dee/library%2Fcore%2Fsrc%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fint_macros.rs?ref=3209582a87f7b8e098bac67f66ed58d8d5840dee", "patch": "@@ -433,6 +433,28 @@ macro_rules! int_impl {\n             unsafe { intrinsics::unchecked_add(self, rhs) }\n         }\n \n+        /// Checked addition with an unsigned integer. Computes `self + rhs`,\n+        /// returning `None` if overflow occurred.\n+        ///\n+        /// # Examples\n+        ///\n+        /// Basic usage:\n+        ///\n+        /// ```\n+        /// # #![feature(mixed_integer_ops)]\n+        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_add_unsigned(2), Some(3));\")]\n+        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).checked_add_unsigned(3), None);\")]\n+        /// ```\n+        #[unstable(feature = \"mixed_integer_ops\", issue = \"87840\")]\n+        #[rustc_const_unstable(feature = \"mixed_integer_ops\", issue = \"87840\")]\n+        #[must_use = \"this returns the result of the operation, \\\n+                      without modifying the original\"]\n+        #[inline]\n+        pub const fn checked_add_unsigned(self, rhs: $UnsignedT) -> Option<Self> {\n+            let (a, b) = self.overflowing_add_unsigned(rhs);\n+            if unlikely!(b) {None} else {Some(a)}\n+        }\n+\n         /// Checked integer subtraction. Computes `self - rhs`, returning `None` if\n         /// overflow occurred.\n         ///\n@@ -479,6 +501,28 @@ macro_rules! int_impl {\n             unsafe { intrinsics::unchecked_sub(self, rhs) }\n         }\n \n+        /// Checked subtraction with an unsigned integer. Computes `self - rhs`,\n+        /// returning `None` if overflow occurred.\n+        ///\n+        /// # Examples\n+        ///\n+        /// Basic usage:\n+        ///\n+        /// ```\n+        /// # #![feature(mixed_integer_ops)]\n+        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_sub_unsigned(2), Some(-1));\")]\n+        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MIN + 2).checked_sub_unsigned(3), None);\")]\n+        /// ```\n+        #[unstable(feature = \"mixed_integer_ops\", issue = \"87840\")]\n+        #[rustc_const_unstable(feature = \"mixed_integer_ops\", issue = \"87840\")]\n+        #[must_use = \"this returns the result of the operation, \\\n+                      without modifying the original\"]\n+        #[inline]\n+        pub const fn checked_sub_unsigned(self, rhs: $UnsignedT) -> Option<Self> {\n+            let (a, b) = self.overflowing_sub_unsigned(rhs);\n+            if unlikely!(b) {None} else {Some(a)}\n+        }\n+\n         /// Checked integer multiplication. Computes `self * rhs`, returning `None` if\n         /// overflow occurred.\n         ///\n@@ -826,6 +870,32 @@ macro_rules! int_impl {\n             intrinsics::saturating_add(self, rhs)\n         }\n \n+        /// Saturating addition with an unsigned integer. Computes `self + rhs`,\n+        /// saturating at the numeric bounds instead of overflowing.\n+        ///\n+        /// # Examples\n+        ///\n+        /// Basic usage:\n+        ///\n+        /// ```\n+        /// # #![feature(mixed_integer_ops)]\n+        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".saturating_add_unsigned(2), 3);\")]\n+        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.saturating_add_unsigned(100), \", stringify!($SelfT), \"::MAX);\")]\n+        /// ```\n+        #[unstable(feature = \"mixed_integer_ops\", issue = \"87840\")]\n+        #[rustc_const_unstable(feature = \"mixed_integer_ops\", issue = \"87840\")]\n+        #[must_use = \"this returns the result of the operation, \\\n+                      without modifying the original\"]\n+        #[inline]\n+        pub const fn saturating_add_unsigned(self, rhs: $UnsignedT) -> Self {\n+            // Overflow can only happen at the upper bound\n+            // We cannot use `unwrap_or` here because it is not `const`\n+            match self.checked_add_unsigned(rhs) {\n+                Some(x) => x,\n+                None => Self::MAX,\n+            }\n+        }\n+\n         /// Saturating integer subtraction. Computes `self - rhs`, saturating at the\n         /// numeric bounds instead of overflowing.\n         ///\n@@ -847,6 +917,32 @@ macro_rules! int_impl {\n             intrinsics::saturating_sub(self, rhs)\n         }\n \n+        /// Saturating subtraction with an unsigned integer. Computes `self - rhs`,\n+        /// saturating at the numeric bounds instead of overflowing.\n+        ///\n+        /// # Examples\n+        ///\n+        /// Basic usage:\n+        ///\n+        /// ```\n+        /// # #![feature(mixed_integer_ops)]\n+        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".saturating_sub_unsigned(127), -27);\")]\n+        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.saturating_sub_unsigned(100), \", stringify!($SelfT), \"::MIN);\")]\n+        /// ```\n+        #[unstable(feature = \"mixed_integer_ops\", issue = \"87840\")]\n+        #[rustc_const_unstable(feature = \"mixed_integer_ops\", issue = \"87840\")]\n+        #[must_use = \"this returns the result of the operation, \\\n+                      without modifying the original\"]\n+        #[inline]\n+        pub const fn saturating_sub_unsigned(self, rhs: $UnsignedT) -> Self {\n+            // Overflow can only happen at the lower bound\n+            // We cannot use `unwrap_or` here because it is not `const`\n+            match self.checked_sub_unsigned(rhs) {\n+                Some(x) => x,\n+                None => Self::MIN,\n+            }\n+        }\n+\n         /// Saturating integer negation. Computes `-self`, returning `MAX` if `self == MIN`\n         /// instead of overflowing.\n         ///\n@@ -1002,6 +1098,27 @@ macro_rules! int_impl {\n             intrinsics::wrapping_add(self, rhs)\n         }\n \n+        /// Wrapping (modular) addition with an unsigned integer. Computes\n+        /// `self + rhs`, wrapping around at the boundary of the type.\n+        ///\n+        /// # Examples\n+        ///\n+        /// Basic usage:\n+        ///\n+        /// ```\n+        /// # #![feature(mixed_integer_ops)]\n+        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_add_unsigned(27), 127);\")]\n+        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.wrapping_add_unsigned(2), \", stringify!($SelfT), \"::MIN + 1);\")]\n+        /// ```\n+        #[unstable(feature = \"mixed_integer_ops\", issue = \"87840\")]\n+        #[rustc_const_unstable(feature = \"mixed_integer_ops\", issue = \"87840\")]\n+        #[must_use = \"this returns the result of the operation, \\\n+                      without modifying the original\"]\n+        #[inline(always)]\n+        pub const fn wrapping_add_unsigned(self, rhs: $UnsignedT) -> Self {\n+            self.wrapping_add(rhs as Self)\n+        }\n+\n         /// Wrapping (modular) subtraction. Computes `self - rhs`, wrapping around at the\n         /// boundary of the type.\n         ///\n@@ -1022,6 +1139,27 @@ macro_rules! int_impl {\n             intrinsics::wrapping_sub(self, rhs)\n         }\n \n+        /// Wrapping (modular) subtraction with an unsigned integer. Computes\n+        /// `self - rhs`, wrapping around at the boundary of the type.\n+        ///\n+        /// # Examples\n+        ///\n+        /// Basic usage:\n+        ///\n+        /// ```\n+        /// # #![feature(mixed_integer_ops)]\n+        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".wrapping_sub_unsigned(127), -127);\")]\n+        #[doc = concat!(\"assert_eq!((-2\", stringify!($SelfT), \").wrapping_sub_unsigned(\", stringify!($UnsignedT), \"::MAX), -1);\")]\n+        /// ```\n+        #[unstable(feature = \"mixed_integer_ops\", issue = \"87840\")]\n+        #[rustc_const_unstable(feature = \"mixed_integer_ops\", issue = \"87840\")]\n+        #[must_use = \"this returns the result of the operation, \\\n+                      without modifying the original\"]\n+        #[inline(always)]\n+        pub const fn wrapping_sub_unsigned(self, rhs: $UnsignedT) -> Self {\n+            self.wrapping_sub(rhs as Self)\n+        }\n+\n         /// Wrapping (modular) multiplication. Computes `self * rhs`, wrapping around at\n         /// the boundary of the type.\n         ///\n@@ -1372,6 +1510,33 @@ macro_rules! int_impl {\n             (sum as $SelfT, carry)\n         }\n \n+        /// Calculates `self` + `rhs` with an unsigned `rhs`\n+        ///\n+        /// Returns a tuple of the addition along with a boolean indicating\n+        /// whether an arithmetic overflow would occur. If an overflow would\n+        /// have occurred then the wrapped value is returned.\n+        ///\n+        /// # Examples\n+        ///\n+        /// Basic usage:\n+        ///\n+        /// ```\n+        /// # #![feature(mixed_integer_ops)]\n+        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".overflowing_add_unsigned(2), (3, false));\")]\n+        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MIN).overflowing_add_unsigned(\", stringify!($UnsignedT), \"::MAX), (\", stringify!($SelfT), \"::MAX, false));\")]\n+        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).overflowing_add_unsigned(3), (\", stringify!($SelfT), \"::MIN, true));\")]\n+        /// ```\n+        #[unstable(feature = \"mixed_integer_ops\", issue = \"87840\")]\n+        #[rustc_const_unstable(feature = \"mixed_integer_ops\", issue = \"87840\")]\n+        #[must_use = \"this returns the result of the operation, \\\n+                      without modifying the original\"]\n+        #[inline]\n+        pub const fn overflowing_add_unsigned(self, rhs: $UnsignedT) -> (Self, bool) {\n+            let rhs = rhs as Self;\n+            let (res, overflowed) = self.overflowing_add(rhs);\n+            (res, overflowed ^ (rhs < 0))\n+        }\n+\n         /// Calculates `self` - `rhs`\n         ///\n         /// Returns a tuple of the subtraction along with a boolean indicating whether an arithmetic overflow\n@@ -1423,6 +1588,33 @@ macro_rules! int_impl {\n             (sum as $SelfT, borrow)\n         }\n \n+        /// Calculates `self` - `rhs` with an unsigned `rhs`\n+        ///\n+        /// Returns a tuple of the subtraction along with a boolean indicating\n+        /// whether an arithmetic overflow would occur. If an overflow would\n+        /// have occurred then the wrapped value is returned.\n+        ///\n+        /// # Examples\n+        ///\n+        /// Basic usage:\n+        ///\n+        /// ```\n+        /// # #![feature(mixed_integer_ops)]\n+        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".overflowing_sub_unsigned(2), (-1, false));\")]\n+        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX).overflowing_sub_unsigned(\", stringify!($UnsignedT), \"::MAX), (\", stringify!($SelfT), \"::MIN, false));\")]\n+        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MIN + 2).overflowing_sub_unsigned(3), (\", stringify!($SelfT), \"::MAX, true));\")]\n+        /// ```\n+        #[unstable(feature = \"mixed_integer_ops\", issue = \"87840\")]\n+        #[rustc_const_unstable(feature = \"mixed_integer_ops\", issue = \"87840\")]\n+        #[must_use = \"this returns the result of the operation, \\\n+                      without modifying the original\"]\n+        #[inline]\n+        pub const fn overflowing_sub_unsigned(self, rhs: $UnsignedT) -> (Self, bool) {\n+            let rhs = rhs as Self;\n+            let (res, overflowed) = self.overflowing_sub(rhs);\n+            (res, overflowed ^ (rhs < 0))\n+        }\n+\n         /// Calculates the multiplication of `self` and `rhs`.\n         ///\n         /// Returns a tuple of the multiplication along with a boolean indicating whether an arithmetic overflow"}, {"sha": "8966a9c11d2b48b7e9c2dd159db56baa4607e26b", "filename": "library/core/src/num/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3209582a87f7b8e098bac67f66ed58d8d5840dee/library%2Fcore%2Fsrc%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3209582a87f7b8e098bac67f66ed58d8d5840dee/library%2Fcore%2Fsrc%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fmod.rs?ref=3209582a87f7b8e098bac67f66ed58d8d5840dee", "patch": "@@ -245,7 +245,7 @@ const ASCII_CASE_MASK: u8 = 0b0010_0000;\n #[lang = \"u8\"]\n impl u8 {\n     widening_impl! { u8, u16, 8 }\n-    uint_impl! { u8, u8, 8, 255, 2, \"0x82\", \"0xa\", \"0x12\", \"0x12\", \"0x48\", \"[0x12]\",\n+    uint_impl! { u8, u8, i8, 8, 255, 2, \"0x82\", \"0xa\", \"0x12\", \"0x12\", \"0x48\", \"[0x12]\",\n     \"[0x12]\", \"\", \"\" }\n \n     /// Checks if the value is within the ASCII range.\n@@ -779,21 +779,21 @@ impl u8 {\n #[lang = \"u16\"]\n impl u16 {\n     widening_impl! { u16, u32, 16 }\n-    uint_impl! { u16, u16, 16, 65535, 4, \"0xa003\", \"0x3a\", \"0x1234\", \"0x3412\", \"0x2c48\",\n+    uint_impl! { u16, u16, i16, 16, 65535, 4, \"0xa003\", \"0x3a\", \"0x1234\", \"0x3412\", \"0x2c48\",\n     \"[0x34, 0x12]\", \"[0x12, 0x34]\", \"\", \"\" }\n }\n \n #[lang = \"u32\"]\n impl u32 {\n     widening_impl! { u32, u64, 32 }\n-    uint_impl! { u32, u32, 32, 4294967295, 8, \"0x10000b3\", \"0xb301\", \"0x12345678\",\n+    uint_impl! { u32, u32, i32, 32, 4294967295, 8, \"0x10000b3\", \"0xb301\", \"0x12345678\",\n     \"0x78563412\", \"0x1e6a2c48\", \"[0x78, 0x56, 0x34, 0x12]\", \"[0x12, 0x34, 0x56, 0x78]\", \"\", \"\" }\n }\n \n #[lang = \"u64\"]\n impl u64 {\n     widening_impl! { u64, u128, 64 }\n-    uint_impl! { u64, u64, 64, 18446744073709551615, 12, \"0xaa00000000006e1\", \"0x6e10aa\",\n+    uint_impl! { u64, u64, i64, 64, 18446744073709551615, 12, \"0xaa00000000006e1\", \"0x6e10aa\",\n     \"0x1234567890123456\", \"0x5634129078563412\", \"0x6a2c48091e6a2c48\",\n     \"[0x56, 0x34, 0x12, 0x90, 0x78, 0x56, 0x34, 0x12]\",\n     \"[0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56]\",\n@@ -802,7 +802,7 @@ impl u64 {\n \n #[lang = \"u128\"]\n impl u128 {\n-    uint_impl! { u128, u128, 128, 340282366920938463463374607431768211455, 16,\n+    uint_impl! { u128, u128, i128, 128, 340282366920938463463374607431768211455, 16,\n     \"0x13f40000000000000000000000004f76\", \"0x4f7613f4\", \"0x12345678901234567890123456789012\",\n     \"0x12907856341290785634129078563412\", \"0x48091e6a2c48091e6a2c48091e6a2c48\",\n     \"[0x12, 0x90, 0x78, 0x56, 0x34, 0x12, 0x90, 0x78, \\\n@@ -816,15 +816,15 @@ impl u128 {\n #[lang = \"usize\"]\n impl usize {\n     widening_impl! { usize, u32, 16 }\n-    uint_impl! { usize, u16, 16, 65535, 4, \"0xa003\", \"0x3a\", \"0x1234\", \"0x3412\", \"0x2c48\",\n+    uint_impl! { usize, u16, isize, 16, 65535, 4, \"0xa003\", \"0x3a\", \"0x1234\", \"0x3412\", \"0x2c48\",\n     \"[0x34, 0x12]\", \"[0x12, 0x34]\",\n     usize_isize_to_xe_bytes_doc!(), usize_isize_from_xe_bytes_doc!() }\n }\n #[cfg(target_pointer_width = \"32\")]\n #[lang = \"usize\"]\n impl usize {\n     widening_impl! { usize, u64, 32 }\n-    uint_impl! { usize, u32, 32, 4294967295, 8, \"0x10000b3\", \"0xb301\", \"0x12345678\",\n+    uint_impl! { usize, u32, isize, 32, 4294967295, 8, \"0x10000b3\", \"0xb301\", \"0x12345678\",\n     \"0x78563412\", \"0x1e6a2c48\", \"[0x78, 0x56, 0x34, 0x12]\", \"[0x12, 0x34, 0x56, 0x78]\",\n     usize_isize_to_xe_bytes_doc!(), usize_isize_from_xe_bytes_doc!() }\n }\n@@ -833,7 +833,7 @@ impl usize {\n #[lang = \"usize\"]\n impl usize {\n     widening_impl! { usize, u128, 64 }\n-    uint_impl! { usize, u64, 64, 18446744073709551615, 12, \"0xaa00000000006e1\", \"0x6e10aa\",\n+    uint_impl! { usize, u64, isize, 64, 18446744073709551615, 12, \"0xaa00000000006e1\", \"0x6e10aa\",\n     \"0x1234567890123456\", \"0x5634129078563412\", \"0x6a2c48091e6a2c48\",\n     \"[0x56, 0x34, 0x12, 0x90, 0x78, 0x56, 0x34, 0x12]\",\n      \"[0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56]\","}, {"sha": "25cd582bb67d7a3fd98087fa3f2cd417080b2f9e", "filename": "library/core/src/num/uint_macros.rs", "status": "modified", "additions": 101, "deletions": 1, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/3209582a87f7b8e098bac67f66ed58d8d5840dee/library%2Fcore%2Fsrc%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3209582a87f7b8e098bac67f66ed58d8d5840dee/library%2Fcore%2Fsrc%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fuint_macros.rs?ref=3209582a87f7b8e098bac67f66ed58d8d5840dee", "patch": "@@ -1,5 +1,5 @@\n macro_rules! uint_impl {\n-    ($SelfT:ty, $ActualT:ident, $BITS:expr, $MaxV:expr,\n+    ($SelfT:ty, $ActualT:ident, $SignedT:ident, $BITS:expr, $MaxV:expr,\n         $rot:expr, $rot_op:expr, $rot_result:expr, $swap_op:expr, $swapped:expr,\n         $reversed:expr, $le_bytes:expr, $be_bytes:expr,\n         $to_xe_bytes_doc:expr, $from_xe_bytes_doc:expr) => {\n@@ -442,6 +442,29 @@ macro_rules! uint_impl {\n             unsafe { intrinsics::unchecked_add(self, rhs) }\n         }\n \n+        /// Checked addition with a signed integer. Computes `self + rhs`,\n+        /// returning `None` if overflow occurred.\n+        ///\n+        /// # Examples\n+        ///\n+        /// Basic usage:\n+        ///\n+        /// ```\n+        /// # #![feature(mixed_integer_ops)]\n+        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_add_signed(2), Some(3));\")]\n+        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_add_signed(-2), None);\")]\n+        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).checked_add_signed(3), None);\")]\n+        /// ```\n+        #[unstable(feature = \"mixed_integer_ops\", issue = \"87840\")]\n+        #[rustc_const_unstable(feature = \"mixed_integer_ops\", issue = \"87840\")]\n+        #[must_use = \"this returns the result of the operation, \\\n+                      without modifying the original\"]\n+        #[inline]\n+        pub const fn checked_add_signed(self, rhs: $SignedT) -> Option<Self> {\n+            let (a, b) = self.overflowing_add_signed(rhs);\n+            if unlikely!(b) {None} else {Some(a)}\n+        }\n+\n         /// Checked integer subtraction. Computes `self - rhs`, returning\n         /// `None` if overflow occurred.\n         ///\n@@ -995,6 +1018,35 @@ macro_rules! uint_impl {\n             intrinsics::saturating_add(self, rhs)\n         }\n \n+        /// Saturating addition with a signed integer. Computes `self + rhs`,\n+        /// saturating at the numeric bounds instead of overflowing.\n+        ///\n+        /// # Examples\n+        ///\n+        /// Basic usage:\n+        ///\n+        /// ```\n+        /// # #![feature(mixed_integer_ops)]\n+        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".saturating_add_signed(2), 3);\")]\n+        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".saturating_add_signed(-2), 0);\")]\n+        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).saturating_add_signed(4), \", stringify!($SelfT), \"::MAX);\")]\n+        /// ```\n+        #[unstable(feature = \"mixed_integer_ops\", issue = \"87840\")]\n+        #[rustc_const_unstable(feature = \"mixed_integer_ops\", issue = \"87840\")]\n+        #[must_use = \"this returns the result of the operation, \\\n+                      without modifying the original\"]\n+        #[inline]\n+        pub const fn saturating_add_signed(self, rhs: $SignedT) -> Self {\n+            let (res, overflow) = self.overflowing_add(rhs as Self);\n+            if overflow == (rhs < 0) {\n+                res\n+            } else if overflow {\n+                Self::MAX\n+            } else {\n+                0\n+            }\n+        }\n+\n         /// Saturating integer subtraction. Computes `self - rhs`, saturating\n         /// at the numeric bounds instead of overflowing.\n         ///\n@@ -1111,6 +1163,28 @@ macro_rules! uint_impl {\n             intrinsics::wrapping_add(self, rhs)\n         }\n \n+        /// Wrapping (modular) addition with a signed integer. Computes\n+        /// `self + rhs`, wrapping around at the boundary of the type.\n+        ///\n+        /// # Examples\n+        ///\n+        /// Basic usage:\n+        ///\n+        /// ```\n+        /// # #![feature(mixed_integer_ops)]\n+        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".wrapping_add_signed(2), 3);\")]\n+        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".wrapping_add_signed(-2), \", stringify!($SelfT), \"::MAX);\")]\n+        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).wrapping_add_signed(4), 1);\")]\n+        /// ```\n+        #[unstable(feature = \"mixed_integer_ops\", issue = \"87840\")]\n+        #[rustc_const_unstable(feature = \"mixed_integer_ops\", issue = \"87840\")]\n+        #[must_use = \"this returns the result of the operation, \\\n+                      without modifying the original\"]\n+        #[inline]\n+        pub const fn wrapping_add_signed(self, rhs: $SignedT) -> Self {\n+            self.wrapping_add(rhs as Self)\n+        }\n+\n         /// Wrapping (modular) subtraction. Computes `self - rhs`,\n         /// wrapping around at the boundary of the type.\n         ///\n@@ -1435,6 +1509,32 @@ macro_rules! uint_impl {\n             (c, b | d)\n         }\n \n+        /// Calculates `self` + `rhs` with a signed `rhs`\n+        ///\n+        /// Returns a tuple of the addition along with a boolean indicating\n+        /// whether an arithmetic overflow would occur. If an overflow would\n+        /// have occurred then the wrapped value is returned.\n+        ///\n+        /// # Examples\n+        ///\n+        /// Basic usage:\n+        ///\n+        /// ```\n+        /// # #![feature(mixed_integer_ops)]\n+        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".overflowing_add_signed(2), (3, false));\")]\n+        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".overflowing_add_signed(-2), (\", stringify!($SelfT), \"::MAX, true));\")]\n+        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).overflowing_add_signed(4), (1, true));\")]\n+        /// ```\n+        #[unstable(feature = \"mixed_integer_ops\", issue = \"87840\")]\n+        #[rustc_const_unstable(feature = \"mixed_integer_ops\", issue = \"87840\")]\n+        #[must_use = \"this returns the result of the operation, \\\n+                      without modifying the original\"]\n+        #[inline]\n+        pub const fn overflowing_add_signed(self, rhs: $SignedT) -> (Self, bool) {\n+            let (res, overflowed) = self.overflowing_add(rhs as Self);\n+            (res, overflowed ^ (rhs < 0))\n+        }\n+\n         /// Calculates `self` - `rhs`\n         ///\n         /// Returns a tuple of the subtraction along with a boolean indicating"}, {"sha": "980b2531192e8649c422c21f4b83f9e28b633a09", "filename": "library/std/src/io/cursor.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3209582a87f7b8e098bac67f66ed58d8d5840dee/library%2Fstd%2Fsrc%2Fio%2Fcursor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3209582a87f7b8e098bac67f66ed58d8d5840dee/library%2Fstd%2Fsrc%2Fio%2Fcursor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fcursor.rs?ref=3209582a87f7b8e098bac67f66ed58d8d5840dee", "patch": "@@ -292,12 +292,7 @@ where\n             SeekFrom::End(n) => (self.inner.as_ref().len() as u64, n),\n             SeekFrom::Current(n) => (self.pos, n),\n         };\n-        let new_pos = if offset >= 0 {\n-            base_pos.checked_add(offset as u64)\n-        } else {\n-            base_pos.checked_sub((offset.wrapping_neg()) as u64)\n-        };\n-        match new_pos {\n+        match base_pos.checked_add_signed(offset) {\n             Some(n) => {\n                 self.pos = n;\n                 Ok(self.pos)"}, {"sha": "a7516bf4ffd375e8816396eeee60b8b0cf1687b0", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3209582a87f7b8e098bac67f66ed58d8d5840dee/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3209582a87f7b8e098bac67f66ed58d8d5840dee/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=3209582a87f7b8e098bac67f66ed58d8d5840dee", "patch": "@@ -297,6 +297,7 @@\n #![feature(maybe_uninit_slice)]\n #![feature(maybe_uninit_uninit_array)]\n #![feature(min_specialization)]\n+#![feature(mixed_integer_ops)]\n #![cfg_attr(not(bootstrap), feature(must_not_suspend))]\n #![feature(needs_panic_runtime)]\n #![feature(negative_impls)]"}]}