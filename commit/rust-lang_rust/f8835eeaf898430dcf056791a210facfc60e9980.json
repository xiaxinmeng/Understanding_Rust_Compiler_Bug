{"sha": "f8835eeaf898430dcf056791a210facfc60e9980", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY4ODM1ZWVhZjg5ODQzMGRjZjA1Njc5MWEyMTBmYWNmYzYwZTk5ODA=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-08-28T06:48:10Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-09-05T06:33:09Z"}, "message": "resolve: cleanup using `with_rib`, etc.", "tree": {"sha": "8e604a287a410c310571ec5565d72dc9d1505b86", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8e604a287a410c310571ec5565d72dc9d1505b86"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f8835eeaf898430dcf056791a210facfc60e9980", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f8835eeaf898430dcf056791a210facfc60e9980", "html_url": "https://github.com/rust-lang/rust/commit/f8835eeaf898430dcf056791a210facfc60e9980", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f8835eeaf898430dcf056791a210facfc60e9980/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "af06bfb84c47add51a41153f6f71fc07d4c60a8d", "url": "https://api.github.com/repos/rust-lang/rust/commits/af06bfb84c47add51a41153f6f71fc07d4c60a8d", "html_url": "https://github.com/rust-lang/rust/commit/af06bfb84c47add51a41153f6f71fc07d4c60a8d"}], "stats": {"total": 263, "additions": 118, "deletions": 145}, "files": [{"sha": "5029d61d6e4e1ff5c7ea69dfdc74e7b5baac2302", "filename": "src/librustc_resolve/late.rs", "status": "modified", "additions": 118, "deletions": 145, "changes": 263, "blob_url": "https://github.com/rust-lang/rust/blob/f8835eeaf898430dcf056791a210facfc60e9980/src%2Flibrustc_resolve%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8835eeaf898430dcf056791a210facfc60e9980/src%2Flibrustc_resolve%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate.rs?ref=f8835eeaf898430dcf056791a210facfc60e9980", "patch": "@@ -406,44 +406,32 @@ impl<'a, 'tcx> Visitor<'tcx> for LateResolutionVisitor<'a, '_> {\n             visit::walk_foreign_item(this, foreign_item);\n         });\n     }\n-    fn visit_fn(&mut self,\n-                function_kind: FnKind<'tcx>,\n-                declaration: &'tcx FnDecl,\n-                _: Span,\n-                _: NodeId)\n-    {\n+    fn visit_fn(&mut self, fn_kind: FnKind<'tcx>, declaration: &'tcx FnDecl, _: Span, _: NodeId) {\n         debug!(\"(resolving function) entering function\");\n-        let rib_kind = match function_kind {\n+        let rib_kind = match fn_kind {\n             FnKind::ItemFn(..) => FnItemRibKind,\n             FnKind::Method(..) | FnKind::Closure(_) => NormalRibKind,\n         };\n \n         // Create a value rib for the function.\n-        self.ribs[ValueNS].push(Rib::new(rib_kind));\n-\n-        // Create a label rib for the function.\n-        self.label_ribs.push(Rib::new(rib_kind));\n-\n-        // Add each argument to the rib.\n-        self.resolve_params(&declaration.inputs);\n-\n-        visit::walk_fn_ret_ty(self, &declaration.output);\n-\n-        // Resolve the function body, potentially inside the body of an async closure\n-        match function_kind {\n-            FnKind::ItemFn(.., body) |\n-            FnKind::Method(.., body) => {\n-                self.visit_block(body);\n-            }\n-            FnKind::Closure(body) => {\n-                self.visit_expr(body);\n-            }\n-        };\n-\n-        debug!(\"(resolving function) leaving function\");\n-\n-        self.label_ribs.pop();\n-        self.ribs[ValueNS].pop();\n+        self.with_rib(ValueNS, rib_kind, |this| {\n+            // Create a label rib for the function.\n+            this.with_label_rib(rib_kind, |this| {\n+                // Add each argument to the rib.\n+                this.resolve_params(&declaration.inputs);\n+\n+                visit::walk_fn_ret_ty(this, &declaration.output);\n+\n+                // Resolve the function body, potentially inside the body of an async closure\n+                match fn_kind {\n+                    FnKind::ItemFn(.., body) |\n+                    FnKind::Method(.., body) => this.visit_block(body),\n+                    FnKind::Closure(body) => this.visit_expr(body),\n+                };\n+\n+                debug!(\"(resolving function) leaving function\");\n+            })\n+        });\n     }\n \n     fn visit_generics(&mut self, generics: &'tcx Generics) {\n@@ -522,13 +510,14 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n         // although it may be useful to track other components as well for diagnostics.\n         let graph_root = resolver.graph_root;\n         let parent_scope = ParentScope::module(graph_root);\n+        let start_rib_kind = ModuleRibKind(graph_root);\n         LateResolutionVisitor {\n             r: resolver,\n             parent_scope,\n             ribs: PerNS {\n-                value_ns: vec![Rib::new(ModuleRibKind(graph_root))],\n-                type_ns: vec![Rib::new(ModuleRibKind(graph_root))],\n-                macro_ns: vec![Rib::new(ModuleRibKind(graph_root))],\n+                value_ns: vec![Rib::new(start_rib_kind)],\n+                type_ns: vec![Rib::new(start_rib_kind)],\n+                macro_ns: vec![Rib::new(start_rib_kind)],\n             },\n             label_ribs: Vec::new(),\n             current_trait_ref: None,\n@@ -582,23 +571,32 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n     // generate a fake \"implementation scope\" containing all the\n     // implementations thus found, for compatibility with old resolve pass.\n \n-    fn with_scope<F, T>(&mut self, id: NodeId, f: F) -> T\n-        where F: FnOnce(&mut LateResolutionVisitor<'_, '_>) -> T\n-    {\n+    /// Do some `work` within a new innermost rib of the given `kind` in the given namespace (`ns`).\n+    fn with_rib<T>(\n+        &mut self,\n+        ns: Namespace,\n+        kind: RibKind<'a>,\n+        work: impl FnOnce(&mut Self) -> T,\n+    ) -> T {\n+        self.ribs[ns].push(Rib::new(kind));\n+        let ret = work(self);\n+        self.ribs[ns].pop();\n+        ret\n+    }\n+\n+    fn with_scope<T>(&mut self, id: NodeId, f: impl FnOnce(&mut Self) -> T) -> T {\n         let id = self.r.definitions.local_def_id(id);\n         let module = self.r.module_map.get(&id).cloned(); // clones a reference\n         if let Some(module) = module {\n             // Move down in the graph.\n             let orig_module = replace(&mut self.parent_scope.module, module);\n-            self.ribs[ValueNS].push(Rib::new(ModuleRibKind(module)));\n-            self.ribs[TypeNS].push(Rib::new(ModuleRibKind(module)));\n-\n-            let ret = f(self);\n-\n-            self.parent_scope.module = orig_module;\n-            self.ribs[ValueNS].pop();\n-            self.ribs[TypeNS].pop();\n-            ret\n+            self.with_rib(ValueNS, ModuleRibKind(module), |this| {\n+                this.with_rib(TypeNS, ModuleRibKind(module), |this| {\n+                    let ret = f(this);\n+                    this.parent_scope.module = orig_module;\n+                    ret\n+                })\n+            })\n         } else {\n             f(self)\n         }\n@@ -802,7 +800,7 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n     }\n \n     fn with_generic_param_rib<'c, F>(&'c mut self, generic_params: GenericParameters<'a, 'c>, f: F)\n-        where F: FnOnce(&mut LateResolutionVisitor<'_, '_>)\n+        where F: FnOnce(&mut Self)\n     {\n         debug!(\"with_generic_param_rib\");\n         match generic_params {\n@@ -888,58 +886,44 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n         }\n     }\n \n-    fn with_label_rib<F>(&mut self, f: F)\n-        where F: FnOnce(&mut LateResolutionVisitor<'_, '_>)\n-    {\n-        self.label_ribs.push(Rib::new(NormalRibKind));\n+    fn with_label_rib(&mut self, kind: RibKind<'a>, f: impl FnOnce(&mut Self)) {\n+        self.label_ribs.push(Rib::new(kind));\n         f(self);\n         self.label_ribs.pop();\n     }\n \n-    fn with_item_rib<F>(&mut self, f: F)\n-        where F: FnOnce(&mut LateResolutionVisitor<'_, '_>)\n-    {\n-        self.ribs[ValueNS].push(Rib::new(ItemRibKind));\n-        self.ribs[TypeNS].push(Rib::new(ItemRibKind));\n-        f(self);\n-        self.ribs[TypeNS].pop();\n-        self.ribs[ValueNS].pop();\n+    fn with_item_rib(&mut self, f: impl FnOnce(&mut Self)) {\n+        self.with_rib(ValueNS, ItemRibKind, |this| this.with_rib(TypeNS, ItemRibKind, f))\n     }\n \n-    fn with_constant_rib<F>(&mut self, f: F)\n-        where F: FnOnce(&mut LateResolutionVisitor<'_, '_>)\n-    {\n+    fn with_constant_rib(&mut self, f: impl FnOnce(&mut Self)) {\n         debug!(\"with_constant_rib\");\n-        self.ribs[ValueNS].push(Rib::new(ConstantItemRibKind));\n-        self.label_ribs.push(Rib::new(ConstantItemRibKind));\n-        f(self);\n-        self.label_ribs.pop();\n-        self.ribs[ValueNS].pop();\n+        self.with_rib(ValueNS, ConstantItemRibKind, |this| {\n+            this.with_label_rib(ConstantItemRibKind, f);\n+        });\n     }\n \n-    fn with_current_self_type<T, F>(&mut self, self_type: &Ty, f: F) -> T\n-        where F: FnOnce(&mut LateResolutionVisitor<'_, '_>) -> T\n-    {\n+    fn with_current_self_type<T>(&mut self, self_type: &Ty, f: impl FnOnce(&mut Self) -> T) -> T {\n         // Handle nested impls (inside fn bodies)\n         let previous_value = replace(&mut self.current_self_type, Some(self_type.clone()));\n         let result = f(self);\n         self.current_self_type = previous_value;\n         result\n     }\n \n-    fn with_current_self_item<T, F>(&mut self, self_item: &Item, f: F) -> T\n-        where F: FnOnce(&mut LateResolutionVisitor<'_, '_>) -> T\n-    {\n+    fn with_current_self_item<T>(&mut self, self_item: &Item, f: impl FnOnce(&mut Self) -> T) -> T {\n         let previous_value = replace(&mut self.current_self_item, Some(self_item.id));\n         let result = f(self);\n         self.current_self_item = previous_value;\n         result\n     }\n \n     /// When evaluating a `trait` use its associated types' idents for suggestionsa in E0412.\n-    fn with_trait_items<T, F>(&mut self, trait_items: &Vec<TraitItem>, f: F) -> T\n-        where F: FnOnce(&mut LateResolutionVisitor<'_, '_>) -> T\n-    {\n+    fn with_trait_items<T>(\n+        &mut self,\n+        trait_items: &Vec<TraitItem>,\n+        f: impl FnOnce(&mut Self) -> T,\n+    ) -> T {\n         let trait_assoc_types = replace(\n             &mut self.current_trait_assoc_types,\n             trait_items.iter().filter_map(|item| match &item.node {\n@@ -953,9 +937,11 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n     }\n \n     /// This is called to resolve a trait reference from an `impl` (i.e., `impl Trait for Foo`).\n-    fn with_optional_trait_ref<T, F>(&mut self, opt_trait_ref: Option<&TraitRef>, f: F) -> T\n-        where F: FnOnce(&mut LateResolutionVisitor<'_, '_>, Option<DefId>) -> T\n-    {\n+    fn with_optional_trait_ref<T>(\n+        &mut self,\n+        opt_trait_ref: Option<&TraitRef>,\n+        f: impl FnOnce(&mut Self, Option<DefId>) -> T\n+    ) -> T {\n         let mut new_val = None;\n         let mut new_id = None;\n         if let Some(trait_ref) = opt_trait_ref {\n@@ -990,27 +976,18 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n         result\n     }\n \n-    fn with_self_rib<F>(&mut self, self_res: Res, f: F)\n-        where F: FnOnce(&mut LateResolutionVisitor<'_, '_>)\n-    {\n+    fn with_self_rib_ns(&mut self, ns: Namespace, self_res: Res, f: impl FnOnce(&mut Self)) {\n         let mut self_type_rib = Rib::new(NormalRibKind);\n \n         // Plain insert (no renaming, since types are not currently hygienic)\n         self_type_rib.bindings.insert(Ident::with_dummy_span(kw::SelfUpper), self_res);\n-        self.ribs[TypeNS].push(self_type_rib);\n+        self.ribs[ns].push(self_type_rib);\n         f(self);\n-        self.ribs[TypeNS].pop();\n+        self.ribs[ns].pop();\n     }\n \n-    fn with_self_struct_ctor_rib<F>(&mut self, impl_id: DefId, f: F)\n-        where F: FnOnce(&mut LateResolutionVisitor<'_, '_>)\n-    {\n-        let self_res = Res::SelfCtor(impl_id);\n-        let mut self_type_rib = Rib::new(NormalRibKind);\n-        self_type_rib.bindings.insert(Ident::with_dummy_span(kw::SelfUpper), self_res);\n-        self.ribs[ValueNS].push(self_type_rib);\n-        f(self);\n-        self.ribs[ValueNS].pop();\n+    fn with_self_rib(&mut self, self_res: Res, f: impl FnOnce(&mut Self)) {\n+        self.with_self_rib_ns(TypeNS, self_res, f)\n     }\n \n     fn resolve_implementation(&mut self,\n@@ -1038,8 +1015,8 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n                         this.visit_generics(generics);\n                         // Resolve the items within the impl.\n                         this.with_current_self_type(self_type, |this| {\n-                            this.with_self_struct_ctor_rib(item_def_id, |this| {\n-                                debug!(\"resolve_implementation with_self_struct_ctor_rib\");\n+                            this.with_self_rib_ns(ValueNS, Res::SelfCtor(item_def_id), |this| {\n+                                debug!(\"resolve_implementation with_self_rib_ns(ValueNS, ...)\");\n                                 for impl_item in impl_items {\n                                     // We also need a new scope for the impl item type parameters.\n                                     let generic_params = HasGenericParams(&impl_item.generics,\n@@ -1231,16 +1208,13 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n     }\n \n     fn resolve_arm(&mut self, arm: &Arm) {\n-        self.ribs[ValueNS].push(Rib::new(NormalRibKind));\n-\n-        self.resolve_pats(&arm.pats, PatternSource::Match);\n-\n-        if let Some(ref expr) = arm.guard {\n-            self.visit_expr(expr)\n-        }\n-        self.visit_expr(&arm.body);\n-\n-        self.ribs[ValueNS].pop();\n+        self.with_rib(ValueNS, NormalRibKind, |this| {\n+            this.resolve_pats(&arm.pats, PatternSource::Match);\n+            if let Some(ref expr) = arm.guard {\n+                this.visit_expr(expr)\n+            }\n+            this.visit_expr(&arm.body);\n+        });\n     }\n \n     /// Arising from `source`, resolve a sequence of patterns (top level or-patterns).\n@@ -1333,7 +1307,7 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n                         pat_src == PatternSource::Let => {\n                 // `Variant1(a) | Variant2(a)`, ok\n                 // Reuse definition from the first `a`.\n-                res = self.ribs[ValueNS].last_mut().unwrap().bindings[&ident];\n+                res = self.innermost_rib_bindings(ValueNS)[&ident];\n             }\n             Some(..) => {\n                 span_bug!(ident.span, \"two bindings with the same name from \\\n@@ -1343,14 +1317,18 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n                 // A completely fresh binding, add to the lists if it's valid.\n                 if ident.name != kw::Invalid {\n                     bindings.insert(ident, outer_pat_id);\n-                    self.ribs[ValueNS].last_mut().unwrap().bindings.insert(ident, res);\n+                    self.innermost_rib_bindings(ValueNS).insert(ident, res);\n                 }\n             }\n         }\n \n         res\n     }\n \n+    fn innermost_rib_bindings(&mut self, ns: Namespace) -> &mut FxHashMap<Ident, Res> {\n+        &mut self.ribs[ns].last_mut().unwrap().bindings\n+    }\n+\n     fn resolve_pattern(&mut self,\n                        pat: &Pat,\n                        pat_src: PatternSource,\n@@ -1726,12 +1704,10 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n         Some(result)\n     }\n \n-    fn with_resolved_label<F>(&mut self, label: Option<Label>, id: NodeId, f: F)\n-        where F: FnOnce(&mut LateResolutionVisitor<'_, '_>)\n-    {\n+    fn with_resolved_label(&mut self, label: Option<Label>, id: NodeId, f: impl FnOnce(&mut Self)) {\n         if let Some(label) = label {\n             self.unused_labels.insert(id, label.ident.span);\n-            self.with_label_rib(|this| {\n+            self.with_label_rib(NormalRibKind, |this| {\n                 let ident = label.ident.modern_and_legacy();\n                 this.label_ribs.last_mut().unwrap().bindings.insert(ident, id);\n                 f(this);\n@@ -1805,33 +1781,30 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n             }\n \n             ExprKind::If(ref cond, ref then, ref opt_else) => {\n-                self.ribs[ValueNS].push(Rib::new(NormalRibKind));\n-                self.visit_expr(cond);\n-                self.visit_block(then);\n-                self.ribs[ValueNS].pop();\n-\n+                self.with_rib(ValueNS, NormalRibKind, |this| {\n+                    this.visit_expr(cond);\n+                    this.visit_block(then);\n+                });\n                 opt_else.as_ref().map(|expr| self.visit_expr(expr));\n             }\n \n             ExprKind::Loop(ref block, label) => self.resolve_labeled_block(label, expr.id, &block),\n \n-            ExprKind::While(ref subexpression, ref block, label) => {\n+            ExprKind::While(ref cond, ref block, label) => {\n                 self.with_resolved_label(label, expr.id, |this| {\n-                    this.ribs[ValueNS].push(Rib::new(NormalRibKind));\n-                    this.visit_expr(subexpression);\n-                    this.visit_block(block);\n-                    this.ribs[ValueNS].pop();\n+                    this.with_rib(ValueNS, NormalRibKind, |this| {\n+                        this.visit_expr(cond);\n+                        this.visit_block(block);\n+                    })\n                 });\n             }\n \n-            ExprKind::ForLoop(ref pattern, ref subexpression, ref block, label) => {\n-                self.visit_expr(subexpression);\n-                self.ribs[ValueNS].push(Rib::new(NormalRibKind));\n-                self.resolve_pattern(pattern, PatternSource::For, &mut FxHashMap::default());\n-\n-                self.resolve_labeled_block(label, expr.id, block);\n-\n-                self.ribs[ValueNS].pop();\n+            ExprKind::ForLoop(ref pat, ref iter_expr, ref block, label) => {\n+                self.visit_expr(iter_expr);\n+                self.with_rib(ValueNS, NormalRibKind, |this| {\n+                    this.resolve_pattern(pat, PatternSource::For, &mut FxHashMap::default());\n+                    this.resolve_labeled_block(label, expr.id, block);\n+                });\n             }\n \n             ExprKind::Block(ref block, label) => self.resolve_labeled_block(label, block.id, block),\n@@ -1864,21 +1837,21 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n             // resolve the arguments within the proper scopes so that usages of them inside the\n             // closure are detected as upvars rather than normal closure arg usages.\n             ExprKind::Closure(_, IsAsync::Async { .. }, _, ref fn_decl, ref body, _span) => {\n-                self.ribs[ValueNS].push(Rib::new(NormalRibKind));\n-                // Resolve arguments:\n-                self.resolve_params(&fn_decl.inputs);\n-                // No need to resolve return type --\n-                // the outer closure return type is `FunctionRetTy::Default`.\n-\n-                // Now resolve the inner closure\n-                {\n-                    // No need to resolve arguments: the inner closure has none.\n-                    // Resolve the return type:\n-                    visit::walk_fn_ret_ty(self, &fn_decl.output);\n-                    // Resolve the body\n-                    self.visit_expr(body);\n-                }\n-                self.ribs[ValueNS].pop();\n+                self.with_rib(ValueNS, NormalRibKind, |this| {\n+                    // Resolve arguments:\n+                    this.resolve_params(&fn_decl.inputs);\n+                    // No need to resolve return type --\n+                    // the outer closure return type is `FunctionRetTy::Default`.\n+\n+                    // Now resolve the inner closure\n+                    {\n+                        // No need to resolve arguments: the inner closure has none.\n+                        // Resolve the return type:\n+                        visit::walk_fn_ret_ty(this, &fn_decl.output);\n+                        // Resolve the body\n+                        this.visit_expr(body);\n+                    }\n+                });\n             }\n             _ => {\n                 visit::walk_expr(self, expr);"}]}