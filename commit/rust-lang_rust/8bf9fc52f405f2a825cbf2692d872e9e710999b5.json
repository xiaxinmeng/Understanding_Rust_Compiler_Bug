{"sha": "8bf9fc52f405f2a825cbf2692d872e9e710999b5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhiZjlmYzUyZjQwNWYyYTgyNWNiZjI2OTJkODcyZTllNzEwOTk5YjU=", "commit": {"author": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2013-04-09T14:54:32Z"}, "committer": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2013-04-13T09:51:14Z"}, "message": "initial iterator object library", "tree": {"sha": "fe95b358c9a8f1703793b20ef6ba5b423a3578b4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fe95b358c9a8f1703793b20ef6ba5b423a3578b4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8bf9fc52f405f2a825cbf2692d872e9e710999b5", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8bf9fc52f405f2a825cbf2692d872e9e710999b5", "html_url": "https://github.com/rust-lang/rust/commit/8bf9fc52f405f2a825cbf2692d872e9e710999b5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8bf9fc52f405f2a825cbf2692d872e9e710999b5/comments", "author": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "committer": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "65ff441b3d25d83335dc46ed4ef86421fca29c8d", "url": "https://api.github.com/repos/rust-lang/rust/commits/65ff441b3d25d83335dc46ed4ef86421fca29c8d", "html_url": "https://github.com/rust-lang/rust/commit/65ff441b3d25d83335dc46ed4ef86421fca29c8d"}], "stats": {"total": 380, "additions": 216, "deletions": 164}, "files": [{"sha": "2415ae1d1941cc55bb670e1fecd7c07f5583812d", "filename": "src/libcore/core.rc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8bf9fc52f405f2a825cbf2692d872e9e710999b5/src%2Flibcore%2Fcore.rc", "raw_url": "https://github.com/rust-lang/rust/raw/8bf9fc52f405f2a825cbf2692d872e9e710999b5/src%2Flibcore%2Fcore.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rc?ref=8bf9fc52f405f2a825cbf2692d872e9e710999b5", "patch": "@@ -176,6 +176,7 @@ pub mod from_str;\n #[path = \"num/num.rs\"]\n pub mod num;\n pub mod iter;\n+pub mod iterator;\n pub mod to_str;\n pub mod to_bytes;\n pub mod clone;"}, {"sha": "e7a2f3a3928882e07e1b8d38bf66cd630544aebd", "filename": "src/libcore/iterator.rs", "status": "added", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/8bf9fc52f405f2a825cbf2692d872e9e710999b5/src%2Flibcore%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bf9fc52f405f2a825cbf2692d872e9e710999b5/src%2Flibcore%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiterator.rs?ref=8bf9fc52f405f2a825cbf2692d872e9e710999b5", "patch": "@@ -0,0 +1,101 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Composable iterator objects\n+\n+use prelude::*;\n+\n+pub trait Iterator<T> {\n+    /// Advance the iterator and return the next value. Return `None` when the end is reached.\n+    fn next(&mut self) -> Option<T>;\n+}\n+\n+/// A shim implementing the `for` loop iteration protocol for iterator objects\n+#[inline]\n+pub fn advance<T, U: Iterator<T>>(iter: &mut U, f: &fn(T) -> bool) {\n+    loop {\n+        match iter.next() {\n+            Some(x) => {\n+                if !f(x) { return }\n+            }\n+            None => return\n+        }\n+    }\n+}\n+\n+pub struct ZipIterator<T, U> {\n+    priv a: T,\n+    priv b: U\n+}\n+\n+pub impl<A, B, T: Iterator<A>, U: Iterator<B>> ZipIterator<T, U> {\n+    #[inline(always)]\n+    fn new(a: T, b: U) -> ZipIterator<T, U> {\n+        ZipIterator{a: a, b: b}\n+    }\n+}\n+\n+impl<A, B, T: Iterator<A>, U: Iterator<B>> Iterator<(A, B)> for ZipIterator<T, U> {\n+    #[inline]\n+    fn next(&mut self) -> Option<(A, B)> {\n+        match (self.a.next(), self.b.next()) {\n+            (Some(x), Some(y)) => Some((x, y)),\n+            _ => None\n+        }\n+    }\n+}\n+\n+pub struct FilterIterator<'self, A, T> {\n+    priv iter: T,\n+    priv predicate: &'self fn(&A) -> bool\n+}\n+\n+pub impl<'self, A, T: Iterator<A>> FilterIterator<'self, A, T> {\n+    #[inline(always)]\n+    fn new(iter: T, predicate: &'self fn(&A) -> bool) -> FilterIterator<'self, A, T> {\n+        FilterIterator{iter: iter, predicate: predicate}\n+    }\n+}\n+\n+impl<'self, A, T: Iterator<A>> Iterator<A> for FilterIterator<'self, A, T> {\n+    #[inline]\n+    fn next(&mut self) -> Option<A> {\n+        for advance(self) |x| {\n+            if (self.predicate)(&x) {\n+                return Some(x);\n+            } else {\n+                loop\n+            }\n+        }\n+        None\n+    }\n+}\n+\n+pub struct MapIterator<'self, A, B, T> {\n+    priv iter: T,\n+    priv f: &'self fn(A) -> B\n+}\n+\n+pub impl<'self, A, B, T: Iterator<A>> MapIterator<'self, A, B, T> {\n+    #[inline(always)]\n+    fn new(iter: T, f: &'self fn(A) -> B) -> MapIterator<'self, A, B, T> {\n+        MapIterator{iter: iter, f: f}\n+    }\n+}\n+\n+impl<'self, A, B, T: Iterator<A>> Iterator<B> for MapIterator<'self, A, B, T> {\n+    #[inline]\n+    fn next(&mut self) -> Option<B> {\n+        match self.iter.next() {\n+            Some(a) => Some((self.f)(a)),\n+            _ => None\n+        }\n+    }\n+}"}, {"sha": "e4e53b9b61486af912b192a2d4cf12185ad6168b", "filename": "src/libstd/serialize.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8bf9fc52f405f2a825cbf2692d872e9e710999b5/src%2Flibstd%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bf9fc52f405f2a825cbf2692d872e9e710999b5/src%2Flibstd%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fserialize.rs?ref=8bf9fc52f405f2a825cbf2692d872e9e710999b5", "patch": "@@ -21,6 +21,9 @@ use core::hashmap::{HashMap, HashSet};\n use core::trie::{TrieMap, TrieSet};\n use deque::Deque;\n use dlist::DList;\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+#[cfg(stage3)]\n use treemap::{TreeMap, TreeSet};\n \n pub trait Encoder {\n@@ -738,6 +741,9 @@ impl<D: Decoder> Decodable<D> for TrieSet {\n     }\n }\n \n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+#[cfg(stage3)]\n impl<\n     E: Encoder,\n     K: Encodable<E> + Eq + TotalOrd,\n@@ -755,6 +761,9 @@ impl<\n     }\n }\n \n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+#[cfg(stage3)]\n impl<\n     D: Decoder,\n     K: Decodable<D> + Eq + TotalOrd,\n@@ -773,6 +782,9 @@ impl<\n     }\n }\n \n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+#[cfg(stage3)]\n impl<\n     S: Encoder,\n     T: Encodable<S> + Eq + TotalOrd\n@@ -788,6 +800,9 @@ impl<\n     }\n }\n \n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+#[cfg(stage3)]\n impl<\n     D: Decoder,\n     T: Decodable<D> + Eq + TotalOrd"}, {"sha": "3dfc3200f0f5205d3680c54c609161c376a82f4d", "filename": "src/libstd/std.rc", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8bf9fc52f405f2a825cbf2692d872e9e710999b5/src%2Flibstd%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/8bf9fc52f405f2a825cbf2692d872e9e710999b5/src%2Flibstd%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstd.rc?ref=8bf9fc52f405f2a825cbf2692d872e9e710999b5", "patch": "@@ -76,6 +76,9 @@ pub mod rope;\n pub mod smallintmap;\n pub mod sort;\n pub mod dlist;\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+#[cfg(stage3)]\n pub mod treemap;\n \n // And ... other stuff"}, {"sha": "bc8cbaa0825ce0b66725ac9f07ec0743490db768", "filename": "src/libstd/treemap.rs", "status": "modified", "additions": 96, "deletions": 164, "changes": 260, "blob_url": "https://github.com/rust-lang/rust/blob/8bf9fc52f405f2a825cbf2692d872e9e710999b5/src%2Flibstd%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bf9fc52f405f2a825cbf2692d872e9e710999b5/src%2Flibstd%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftreemap.rs?ref=8bf9fc52f405f2a825cbf2692d872e9e710999b5", "patch": "@@ -13,6 +13,7 @@\n //! `TotalOrd`.\n \n use core::prelude::*;\n+use core::iterator::*;\n \n // This is implemented as an AA tree, which is a simplified variation of\n // a red-black tree where where red (horizontal) nodes can only be added\n@@ -43,8 +44,7 @@ impl<K: Eq + TotalOrd, V: Eq> Eq for TreeMap<K, V> {\n             let mut x = self.iter();\n             let mut y = other.iter();\n             for self.len().times {\n-                if map_next(&mut x).unwrap() !=\n-                   map_next(&mut y).unwrap() {\n+                if x.next().unwrap() != y.next().unwrap() {\n                     return false\n                 }\n             }\n@@ -62,8 +62,8 @@ fn lt<K: Ord + TotalOrd, V>(a: &TreeMap<K, V>,\n \n     let (a_len, b_len) = (a.len(), b.len());\n     for uint::min(a_len, b_len).times {\n-        let (key_a,_) = map_next(&mut x).unwrap();\n-        let (key_b,_) = map_next(&mut y).unwrap();\n+        let (key_a,_) = x.next().unwrap();\n+        let (key_b,_) = y.next().unwrap();\n         if *key_a < *key_b { return true; }\n         if *key_a > *key_b { return false; }\n     };\n@@ -105,15 +105,6 @@ impl<K: TotalOrd, V> Map<K, V> for TreeMap<K, V> {\n     }\n \n     /// Visit all key-value pairs in order\n-    #[cfg(stage0)]\n-    fn each(&self, f: &fn(&'self K, &'self V) -> bool) {\n-        each(&self.root, f)\n-    }\n-\n-    /// Visit all key-value pairs in order\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    #[cfg(stage3)]\n     fn each<'a>(&'a self, f: &fn(&'a K, &'a V) -> bool) {\n         each(&self.root, f)\n     }\n@@ -124,15 +115,6 @@ impl<K: TotalOrd, V> Map<K, V> for TreeMap<K, V> {\n     }\n \n     /// Visit all values in order\n-    #[cfg(stage0)]\n-    fn each_value(&self, f: &fn(&V) -> bool) {\n-        self.each(|_, v| f(v))\n-    }\n-\n-    /// Visit all values in order\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    #[cfg(stage3)]\n     fn each_value<'a>(&'a self, f: &fn(&'a V) -> bool) {\n         self.each(|_, v| f(v))\n     }\n@@ -143,27 +125,6 @@ impl<K: TotalOrd, V> Map<K, V> for TreeMap<K, V> {\n     }\n \n     /// Return a reference to the value corresponding to the key\n-    #[cfg(stage0)]\n-    fn find(&self, key: &K) -> Option<&'self V> {\n-        let mut current: &'self Option<~TreeNode<K, V>> = &self.root;\n-        loop {\n-            match *current {\n-              Some(ref r) => {\n-                match key.cmp(&r.key) {\n-                  Less => current = &r.left,\n-                  Greater => current = &r.right,\n-                  Equal => return Some(&r.value)\n-                }\n-              }\n-              None => return None\n-            }\n-        }\n-    }\n-\n-    /// Return a reference to the value corresponding to the key\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    #[cfg(stage3)]\n     fn find<'a>(&'a self, key: &K) -> Option<&'a V> {\n         let mut current: &'a Option<~TreeNode<K, V>> = &self.root;\n         loop {\n@@ -182,16 +143,6 @@ impl<K: TotalOrd, V> Map<K, V> for TreeMap<K, V> {\n \n     /// Return a mutable reference to the value corresponding to the key\n     #[inline(always)]\n-    #[cfg(stage0)]\n-    fn find_mut(&mut self, key: &K) -> Option<&'self mut V> {\n-        find_mut(&mut self.root, key)\n-    }\n-\n-    /// Return a mutable reference to the value corresponding to the key\n-    #[inline(always)]\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    #[cfg(stage3)]\n     fn find_mut<'a>(&'a mut self, key: &K) -> Option<&'a mut V> {\n         find_mut(&mut self.root, key)\n     }\n@@ -219,15 +170,6 @@ pub impl<K: TotalOrd, V> TreeMap<K, V> {\n     fn new() -> TreeMap<K, V> { TreeMap{root: None, length: 0} }\n \n     /// Visit all key-value pairs in reverse order\n-    #[cfg(stage0)]\n-    fn each_reverse(&self, f: &fn(&'self K, &'self V) -> bool) {\n-        each_reverse(&self.root, f);\n-    }\n-\n-    /// Visit all key-value pairs in reverse order\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    #[cfg(stage3)]\n     fn each_reverse<'a>(&'a self, f: &fn(&'a K, &'a V) -> bool) {\n         each_reverse(&self.root, f);\n     }\n@@ -244,16 +186,6 @@ pub impl<K: TotalOrd, V> TreeMap<K, V> {\n \n     /// Get a lazy iterator over the key-value pairs in the map.\n     /// Requires that it be frozen (immutable).\n-    #[cfg(stage0)]\n-    fn iter(&self) -> TreeMapIterator<'self, K, V> {\n-        TreeMapIterator{stack: ~[], node: &self.root}\n-    }\n-\n-    /// Get a lazy iterator over the key-value pairs in the map.\n-    /// Requires that it be frozen (immutable).\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    #[cfg(stage3)]\n     fn iter<'a>(&'a self) -> TreeMapIterator<'a, K, V> {\n         TreeMapIterator{stack: ~[], node: &self.root}\n     }\n@@ -265,37 +197,33 @@ pub struct TreeMapIterator<'self, K, V> {\n     priv node: &'self Option<~TreeNode<K, V>>\n }\n \n-/// Advance the iterator to the next node (in order) and return a\n-/// tuple with a reference to the key and value. If there are no\n-/// more nodes, return `None`.\n-pub fn map_next<'r, K, V>(iter: &mut TreeMapIterator<'r, K, V>)\n-                       -> Option<(&'r K, &'r V)> {\n-    while !iter.stack.is_empty() || iter.node.is_some() {\n-        match *iter.node {\n-          Some(ref x) => {\n-            iter.stack.push(x);\n-            iter.node = &x.left;\n-          }\n-          None => {\n-            let res = iter.stack.pop();\n-            iter.node = &res.right;\n-            return Some((&res.key, &res.value));\n-          }\n+impl<'self, K, V> Iterator<(&'self K, &'self V)> for TreeMapIterator<'self, K, V> {\n+    /// Advance the iterator to the next node (in order) and return a\n+    /// tuple with a reference to the key and value. If there are no\n+    /// more nodes, return `None`.\n+    fn next(&mut self) -> Option<(&'self K, &'self V)> {\n+        while !self.stack.is_empty() || self.node.is_some() {\n+            match *self.node {\n+              Some(ref x) => {\n+                self.stack.push(x);\n+                self.node = &x.left;\n+              }\n+              None => {\n+                let res = self.stack.pop();\n+                self.node = &res.right;\n+                return Some((&res.key, &res.value));\n+              }\n+            }\n         }\n+        None\n     }\n-    None\n }\n \n-/// Advance the iterator through the map\n-pub fn map_advance<'r, K, V>(iter: &mut TreeMapIterator<'r, K, V>,\n-                             f: &fn((&'r K, &'r V)) -> bool) {\n-    loop {\n-        match map_next(iter) {\n-          Some(x) => {\n-            if !f(x) { return }\n-          }\n-          None => return\n-        }\n+impl<'self, T> Iterator<&'self T> for TreeSetIterator<'self, T> {\n+    /// Advance the iterator to the next node (in order). If there are no more nodes, return `None`.\n+    #[inline(always)]\n+    fn next(&mut self) -> Option<&'self T> {\n+        do self.iter.next().map |&(value, _)| { value }\n     }\n }\n \n@@ -375,14 +303,14 @@ impl<T: TotalOrd> Set<T> for TreeSet<T> {\n     fn is_disjoint(&self, other: &TreeSet<T>) -> bool {\n         let mut x = self.iter();\n         let mut y = other.iter();\n-        let mut a = set_next(&mut x);\n-        let mut b = set_next(&mut y);\n+        let mut a = x.next();\n+        let mut b = y.next();\n         while a.is_some() && b.is_some() {\n             let a1 = a.unwrap();\n             let b1 = b.unwrap();\n             match a1.cmp(b1) {\n-              Less => a = set_next(&mut x),\n-              Greater => b = set_next(&mut y),\n+              Less => a = x.next(),\n+              Greater => b = y.next(),\n               Equal => return false\n             }\n         }\n@@ -399,8 +327,8 @@ impl<T: TotalOrd> Set<T> for TreeSet<T> {\n     fn is_superset(&self, other: &TreeSet<T>) -> bool {\n         let mut x = self.iter();\n         let mut y = other.iter();\n-        let mut a = set_next(&mut x);\n-        let mut b = set_next(&mut y);\n+        let mut a = x.next();\n+        let mut b = y.next();\n         while b.is_some() {\n             if a.is_none() {\n                 return false\n@@ -412,10 +340,10 @@ impl<T: TotalOrd> Set<T> for TreeSet<T> {\n             match a1.cmp(b1) {\n               Less => (),\n               Greater => return false,\n-              Equal => b = set_next(&mut y),\n+              Equal => b = y.next(),\n             }\n \n-            a = set_next(&mut x);\n+            a = x.next();\n         }\n         true\n     }\n@@ -425,13 +353,13 @@ impl<T: TotalOrd> Set<T> for TreeSet<T> {\n         let mut x = self.iter();\n         let mut y = other.iter();\n \n-        let mut a = set_next(&mut x);\n-        let mut b = set_next(&mut y);\n+        let mut a = x.next();\n+        let mut b = y.next();\n \n         while a.is_some() {\n             if b.is_none() {\n                 return do a.while_some() |a1| {\n-                    if f(a1) { set_next(&mut x) } else { None }\n+                    if f(a1) { x.next() } else { None }\n                 }\n             }\n \n@@ -442,10 +370,10 @@ impl<T: TotalOrd> Set<T> for TreeSet<T> {\n \n             if cmp == Less {\n                 if !f(a1) { return }\n-                a = set_next(&mut x);\n+                a = x.next();\n             } else {\n-                if cmp == Equal { a = set_next(&mut x) }\n-                b = set_next(&mut y);\n+                if cmp == Equal { a = x.next() }\n+                b = y.next();\n             }\n         }\n     }\n@@ -456,13 +384,13 @@ impl<T: TotalOrd> Set<T> for TreeSet<T> {\n         let mut x = self.iter();\n         let mut y = other.iter();\n \n-        let mut a = set_next(&mut x);\n-        let mut b = set_next(&mut y);\n+        let mut a = x.next();\n+        let mut b = y.next();\n \n         while a.is_some() {\n             if b.is_none() {\n                 return do a.while_some() |a1| {\n-                    if f(a1) { set_next(&mut x) } else { None }\n+                    if f(a1) { x.next() } else { None }\n                 }\n             }\n \n@@ -473,18 +401,18 @@ impl<T: TotalOrd> Set<T> for TreeSet<T> {\n \n             if cmp == Less {\n                 if !f(a1) { return }\n-                a = set_next(&mut x);\n+                a = x.next();\n             } else {\n                 if cmp == Greater {\n                     if !f(b1) { return }\n                 } else {\n-                    a = set_next(&mut x);\n+                    a = x.next();\n                 }\n-                b = set_next(&mut y);\n+                b = y.next();\n             }\n         }\n         do b.while_some |b1| {\n-            if f(b1) { set_next(&mut y) } else { None }\n+            if f(b1) { y.next() } else { None }\n         }\n     }\n \n@@ -493,8 +421,8 @@ impl<T: TotalOrd> Set<T> for TreeSet<T> {\n         let mut x = self.iter();\n         let mut y = other.iter();\n \n-        let mut a = set_next(&mut x);\n-        let mut b = set_next(&mut y);\n+        let mut a = x.next();\n+        let mut b = y.next();\n \n         while a.is_some() && b.is_some() {\n             let a1 = a.unwrap();\n@@ -503,12 +431,12 @@ impl<T: TotalOrd> Set<T> for TreeSet<T> {\n             let cmp = a1.cmp(b1);\n \n             if cmp == Less {\n-                a = set_next(&mut x);\n+                a = x.next();\n             } else {\n                 if cmp == Equal {\n                     if !f(a1) { return }\n                 }\n-                b = set_next(&mut y);\n+                b = y.next();\n             }\n         }\n     }\n@@ -518,13 +446,13 @@ impl<T: TotalOrd> Set<T> for TreeSet<T> {\n         let mut x = self.iter();\n         let mut y = other.iter();\n \n-        let mut a = set_next(&mut x);\n-        let mut b = set_next(&mut y);\n+        let mut a = x.next();\n+        let mut b = y.next();\n \n         while a.is_some() {\n             if b.is_none() {\n                 return do a.while_some() |a1| {\n-                    if f(a1) { set_next(&mut x) } else { None }\n+                    if f(a1) { x.next() } else { None }\n                 }\n             }\n \n@@ -535,17 +463,17 @@ impl<T: TotalOrd> Set<T> for TreeSet<T> {\n \n             if cmp == Greater {\n                 if !f(b1) { return }\n-                b = set_next(&mut y);\n+                b = y.next();\n             } else {\n                 if !f(a1) { return }\n                 if cmp == Equal {\n-                    b = set_next(&mut y);\n+                    b = y.next();\n                 }\n-                a = set_next(&mut x);\n+                a = x.next();\n             }\n         }\n         do b.while_some |b1| {\n-            if f(b1) { set_next(&mut y) } else { None }\n+            if f(b1) { y.next() } else { None }\n         }\n     }\n }\n@@ -558,17 +486,6 @@ pub impl <T: TotalOrd> TreeSet<T> {\n     /// Get a lazy iterator over the values in the set.\n     /// Requires that it be frozen (immutable).\n     #[inline(always)]\n-    #[cfg(stage0)]\n-    fn iter(&self) -> TreeSetIterator<'self, T> {\n-        TreeSetIterator{iter: self.map.iter()}\n-    }\n-\n-    /// Get a lazy iterator over the values in the set.\n-    /// Requires that it be frozen (immutable).\n-    #[inline(always)]\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    #[cfg(stage3)]\n     fn iter<'a>(&'a self) -> TreeSetIterator<'a, T> {\n         TreeSetIterator{iter: self.map.iter()}\n     }\n@@ -579,20 +496,6 @@ pub struct TreeSetIterator<'self, T> {\n     priv iter: TreeMapIterator<'self, T, ()>\n }\n \n-/// Advance the iterator to the next node (in order). If this iterator is\n-/// finished, does nothing.\n-#[inline(always)]\n-pub fn set_next<'r, T>(iter: &mut TreeSetIterator<'r, T>) -> Option<&'r T> {\n-    do map_next(&mut iter.iter).map |&(value, _)| { value }\n-}\n-\n-/// Advance the iterator through the set\n-#[inline(always)]\n-pub fn set_advance<'r, T>(iter: &mut TreeSetIterator<'r, T>,\n-                          f: &fn(&'r T) -> bool) {\n-    do map_advance(&mut iter.iter) |(k, _)| { f(k) }\n-}\n-\n // Nodes keep track of their level in the tree, starting at 1 in the\n // leaves and with a red child sharing the level of the parent.\n struct TreeNode<K, V> {\n@@ -792,6 +695,7 @@ fn remove<K: TotalOrd, V>(node: &mut Option<~TreeNode<K, V>>,\n #[cfg(test)]\n mod test_treemap {\n     use core::prelude::*;\n+    use core::iterator::*;\n     use super::*;\n     use core::rand::RngUtil;\n     use core::rand;\n@@ -1078,21 +982,21 @@ mod test_treemap {\n         let m = m;\n         let mut a = m.iter();\n \n-        assert!(map_next(&mut a).unwrap() == (&x1, &y1));\n-        assert!(map_next(&mut a).unwrap() == (&x2, &y2));\n-        assert!(map_next(&mut a).unwrap() == (&x3, &y3));\n-        assert!(map_next(&mut a).unwrap() == (&x4, &y4));\n-        assert!(map_next(&mut a).unwrap() == (&x5, &y5));\n+        assert!(a.next().unwrap() == (&x1, &y1));\n+        assert!(a.next().unwrap() == (&x2, &y2));\n+        assert!(a.next().unwrap() == (&x3, &y3));\n+        assert!(a.next().unwrap() == (&x4, &y4));\n+        assert!(a.next().unwrap() == (&x5, &y5));\n \n-        assert!(map_next(&mut a).is_none());\n+        assert!(a.next().is_none());\n \n         let mut b = m.iter();\n \n         let expected = [(&x1, &y1), (&x2, &y2), (&x3, &y3), (&x4, &y4),\n                         (&x5, &y5)];\n         let mut i = 0;\n \n-        for map_advance(&mut b) |x| {\n+        for advance(&mut b) |x| {\n             assert!(expected[i] == x);\n             i += 1;\n \n@@ -1101,7 +1005,7 @@ mod test_treemap {\n             }\n         }\n \n-        for map_advance(&mut b) |x| {\n+        for advance(&mut b) |x| {\n             assert!(expected[i] == x);\n             i += 1;\n         }\n@@ -1110,6 +1014,8 @@ mod test_treemap {\n \n #[cfg(test)]\n mod test_set {\n+    use core::prelude::*;\n+    use core::iterator::*;\n     use super::*;\n \n     #[test]\n@@ -1289,4 +1195,30 @@ mod test_set {\n                     [-2, 1, 5, 9, 13, 19],\n                     [-2, 1, 3, 5, 9, 11, 13, 16, 19, 24]);\n     }\n+\n+    #[test]\n+    fn test_zip() {\n+        let mut x = TreeSet::new();\n+        x.insert(5u);\n+        x.insert(12u);\n+        x.insert(11u);\n+\n+        let mut y = TreeSet::new();\n+        y.insert(\"foo\");\n+        y.insert(\"bar\");\n+\n+        let x = x;\n+        let y = y;\n+        let mut z = ZipIterator::new(x.iter(), y.iter());\n+\n+        // FIXME: #5801: this needs a type hint to compile...\n+        let result: Option<(&uint, & &'static str)> = z.next();\n+        assert!(result.unwrap() == (&5u, & &\"bar\"));\n+\n+        let result: Option<(&uint, & &'static str)> = z.next();\n+        assert!(result.unwrap() == (&11u, & &\"foo\"));\n+\n+        let result: Option<(&uint, & &'static str)> = z.next();\n+        assert!(result.is_none());\n+    }\n }"}]}