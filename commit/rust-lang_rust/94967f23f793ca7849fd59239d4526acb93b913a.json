{"sha": "94967f23f793ca7849fd59239d4526acb93b913a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk0OTY3ZjIzZjc5M2NhNzg0OWZkNTkyMzlkNDUyNmFjYjkzYjkxM2E=", "commit": {"author": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2019-08-31T15:40:20Z"}, "committer": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2019-10-15T20:12:05Z"}, "message": "Remove gensyms", "tree": {"sha": "fa7a988e863d6bca452ca808291a13fd5401662b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fa7a988e863d6bca452ca808291a13fd5401662b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/94967f23f793ca7849fd59239d4526acb93b913a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/94967f23f793ca7849fd59239d4526acb93b913a", "html_url": "https://github.com/rust-lang/rust/commit/94967f23f793ca7849fd59239d4526acb93b913a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/94967f23f793ca7849fd59239d4526acb93b913a/comments", "author": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1a2597b64a9d76eb336878e9b0b9dd4021b0240c", "url": "https://api.github.com/repos/rust-lang/rust/commits/1a2597b64a9d76eb336878e9b0b9dd4021b0240c", "html_url": "https://github.com/rust-lang/rust/commit/1a2597b64a9d76eb336878e9b0b9dd4021b0240c"}], "stats": {"total": 97, "additions": 9, "deletions": 88}, "files": [{"sha": "d17e909c4d53e4134bac507b08fed29f605bf0a2", "filename": "src/libsyntax_pos/symbol.rs", "status": "modified", "additions": 9, "deletions": 81, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/94967f23f793ca7849fd59239d4526acb93b913a/src%2Flibsyntax_pos%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94967f23f793ca7849fd59239d4526acb93b913a/src%2Flibsyntax_pos%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fsymbol.rs?ref=94967f23f793ca7849fd59239d4526acb93b913a", "patch": "@@ -807,25 +807,13 @@ impl Ident {\n         Ident::new(self.name, self.span.modern_and_legacy())\n     }\n \n-    /// Transforms an underscore identifier into one with the same name, but\n-    /// gensymed. Leaves non-underscore identifiers unchanged.\n-    pub fn gensym_if_underscore(self) -> Ident {\n-        if self.name == kw::Underscore {\n-            let name = with_interner(|interner| interner.gensymed(self.name));\n-            Ident::new(name, self.span)\n-        } else {\n-            self\n-        }\n-    }\n-\n     /// Convert the name to a `LocalInternedString`. This is a slowish\n     /// operation because it requires locking the symbol interner.\n     pub fn as_str(self) -> LocalInternedString {\n         self.name.as_str()\n     }\n \n-    /// Convert the name to an `InternedString`. This is a slowish operation\n-    /// because it requires locking the symbol interner.\n+    /// Convert the name to an `InternedString`.\n     pub fn as_interned_str(self) -> InternedString {\n         self.name.as_interned_str()\n     }\n@@ -880,26 +868,9 @@ impl UseSpecializedDecodable for Ident {\n     }\n }\n \n-/// A symbol is an interned or gensymed string. A gensym is a symbol that is\n-/// never equal to any other symbol.\n+/// An interned string.\n ///\n-/// Conceptually, a gensym can be thought of as a normal symbol with an\n-/// invisible unique suffix. Gensyms are useful when creating new identifiers\n-/// that must not match any existing identifiers, e.g. during macro expansion\n-/// and syntax desugaring. Because gensyms should always be identifiers, all\n-/// gensym operations are on `Ident` rather than `Symbol`. (Indeed, in the\n-/// future the gensym-ness may be moved from `Symbol` to hygiene data.)\n-///\n-/// Examples:\n-/// ```\n-/// assert_eq!(Ident::from_str(\"_\"), Ident::from_str(\"_\"))\n-/// assert_ne!(Ident::from_str(\"_\").gensym_if_underscore(), Ident::from_str(\"_\"))\n-/// assert_ne!(\n-///     Ident::from_str(\"_\").gensym_if_underscore(),\n-///     Ident::from_str(\"_\").gensym_if_underscore(),\n-/// )\n-/// ```\n-/// Internally, a symbol is implemented as an index, and all operations\n+/// Internally, a `Symbol` is implemented as an index, and all operations\n /// (including hashing, equality, and ordering) operate on that index. The use\n /// of `rustc_index::newtype_index!` means that `Option<Symbol>` only takes up 4 bytes,\n /// because `rustc_index::newtype_index!` reserves the last 256 values for tagging purposes.\n@@ -950,12 +921,9 @@ impl Symbol {\n         })\n     }\n \n-    /// Convert to an `InternedString`. This is a slowish operation because it\n-    /// requires locking the symbol interner.\n+    /// Convert to an `InternedString`.\n     pub fn as_interned_str(self) -> InternedString {\n-        with_interner(|interner| InternedString {\n-            symbol: interner.interned(self)\n-        })\n+        InternedString { symbol: self }\n     }\n \n     pub fn as_u32(self) -> u32 {\n@@ -965,12 +933,7 @@ impl Symbol {\n \n impl fmt::Debug for Symbol {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        let is_gensymed = with_interner(|interner| interner.is_gensymed(*self));\n-        if is_gensymed {\n-            write!(f, \"{}({:?})\", self, self.0)\n-        } else {\n-            write!(f, \"{}\", self)\n-        }\n+        fmt::Display::fmt(self, f)\n     }\n }\n \n@@ -993,15 +956,11 @@ impl Decodable for Symbol {\n }\n \n // The `&'static str`s in this type actually point into the arena.\n-//\n-// Note that normal symbols are indexed upward from 0, and gensyms are indexed\n-// downward from SymbolIndex::MAX_AS_U32.\n #[derive(Default)]\n pub struct Interner {\n     arena: DroplessArena,\n     names: FxHashMap<&'static str, Symbol>,\n     strings: Vec<&'static str>,\n-    gensyms: Vec<Symbol>,\n }\n \n impl Interner {\n@@ -1034,34 +993,10 @@ impl Interner {\n         self.names.insert(string, name);\n         name\n     }\n-\n-    fn interned(&self, symbol: Symbol) -> Symbol {\n-        if (symbol.0.as_usize()) < self.strings.len() {\n-            symbol\n-        } else {\n-            self.gensyms[(SymbolIndex::MAX_AS_U32 - symbol.0.as_u32()) as usize]\n-        }\n-    }\n-\n-    fn gensymed(&mut self, symbol: Symbol) -> Symbol {\n-        self.gensyms.push(symbol);\n-        Symbol::new(SymbolIndex::MAX_AS_U32 - self.gensyms.len() as u32 + 1)\n-    }\n-\n-    fn is_gensymed(&mut self, symbol: Symbol) -> bool {\n-        symbol.0.as_usize() >= self.strings.len()\n-    }\n-\n     // Get the symbol as a string. `Symbol::as_str()` should be used in\n     // preference to this function.\n     pub fn get(&self, symbol: Symbol) -> &str {\n-        match self.strings.get(symbol.0.as_usize()) {\n-            Some(string) => string,\n-            None => {\n-                let symbol = self.gensyms[(SymbolIndex::MAX_AS_U32 - symbol.0.as_u32()) as usize];\n-                self.strings[symbol.0.as_usize()]\n-            }\n-        }\n+        self.strings[symbol.0.as_usize()]\n     }\n }\n \n@@ -1246,19 +1181,12 @@ impl fmt::Display for LocalInternedString {\n     }\n }\n \n-/// An alternative to `Symbol` that is focused on string contents. It has two\n-/// main differences to `Symbol`.\n+/// An alternative to `Symbol` that is focused on string contents.\n ///\n-/// First, its implementations of `Hash`, `PartialOrd` and `Ord` work with the\n+/// Its implementations of `Hash`, `PartialOrd` and `Ord` work with the\n /// string chars rather than the symbol integer. This is useful when hash\n /// stability is required across compile sessions, or a guaranteed sort\n /// ordering is required.\n-///\n-/// Second, gensym-ness is irrelevant. E.g.:\n-/// ```\n-/// assert_ne!(Symbol::gensym(\"x\"), Symbol::gensym(\"x\"))\n-/// assert_eq!(Symbol::gensym(\"x\").as_interned_str(), Symbol::gensym(\"x\").as_interned_str())\n-/// ```\n #[derive(Clone, Copy, PartialEq, Eq)]\n pub struct InternedString {\n     symbol: Symbol,"}, {"sha": "f74b9a0cd1d1df0213739c04d1d389c9825ebe71", "filename": "src/libsyntax_pos/symbol/tests.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/94967f23f793ca7849fd59239d4526acb93b913a/src%2Flibsyntax_pos%2Fsymbol%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94967f23f793ca7849fd59239d4526acb93b913a/src%2Flibsyntax_pos%2Fsymbol%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fsymbol%2Ftests.rs?ref=94967f23f793ca7849fd59239d4526acb93b913a", "patch": "@@ -14,13 +14,6 @@ fn interner_tests() {\n     assert_eq!(i.intern(\"cat\"), Symbol::new(1));\n     // dog is still at zero\n     assert_eq!(i.intern(\"dog\"), Symbol::new(0));\n-    let z = i.intern(\"zebra\");\n-    assert_eq!(i.gensymed(z), Symbol::new(SymbolIndex::MAX_AS_U32));\n-    // gensym of same string gets new number:\n-    assert_eq!(i.gensymed(z), Symbol::new(SymbolIndex::MAX_AS_U32 - 1));\n-    // gensym of *existing* string gets new number:\n-    let d = i.intern(\"dog\");\n-    assert_eq!(i.gensymed(d), Symbol::new(SymbolIndex::MAX_AS_U32 - 2));\n }\n \n #[test]"}]}