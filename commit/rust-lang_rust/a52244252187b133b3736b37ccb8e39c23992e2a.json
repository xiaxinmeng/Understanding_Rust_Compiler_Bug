{"sha": "a52244252187b133b3736b37ccb8e39c23992e2a", "node_id": "C_kwDOAAsO6NoAKGE1MjI0NDI1MjE4N2IxMzNiMzczNmIzN2NjYjhlMzljMjM5OTJlMmE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-07T02:49:33Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-07T02:49:33Z"}, "message": "Auto merge of #2474 - RalfJung:cargo-metadata-args, r=RalfJung\n\nalso forward --manifest-path to 'cargo metadata'\n\nand then I went on to refactor the argument flag splitting thing a bit, and, uh, that snowballed...", "tree": {"sha": "e4cb7b0a6362991099a8c02bf9e92524ad352ba0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e4cb7b0a6362991099a8c02bf9e92524ad352ba0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a52244252187b133b3736b37ccb8e39c23992e2a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a52244252187b133b3736b37ccb8e39c23992e2a", "html_url": "https://github.com/rust-lang/rust/commit/a52244252187b133b3736b37ccb8e39c23992e2a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a52244252187b133b3736b37ccb8e39c23992e2a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aa53f3f77fea74e5a99e700e24b620cb5ad8242a", "url": "https://api.github.com/repos/rust-lang/rust/commits/aa53f3f77fea74e5a99e700e24b620cb5ad8242a", "html_url": "https://github.com/rust-lang/rust/commit/aa53f3f77fea74e5a99e700e24b620cb5ad8242a"}, {"sha": "04744a2935ba5c3e01af396ff91e24afba212acb", "url": "https://api.github.com/repos/rust-lang/rust/commits/04744a2935ba5c3e01af396ff91e24afba212acb", "html_url": "https://github.com/rust-lang/rust/commit/04744a2935ba5c3e01af396ff91e24afba212acb"}], "stats": {"total": 272, "additions": 171, "deletions": 101}, "files": [{"sha": "e8bac4625f71053d0784513a8f32821a2cdcdf20", "filename": "cargo-miri/src/arg.rs", "status": "added", "additions": 134, "deletions": 0, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/a52244252187b133b3736b37ccb8e39c23992e2a/cargo-miri%2Fsrc%2Farg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a52244252187b133b3736b37ccb8e39c23992e2a/cargo-miri%2Fsrc%2Farg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/cargo-miri%2Fsrc%2Farg.rs?ref=a52244252187b133b3736b37ccb8e39c23992e2a", "patch": "@@ -0,0 +1,134 @@\n+//! Utilities for dealing with argument flags\n+\n+use std::borrow::Cow;\n+use std::env;\n+\n+/// Determines whether a `--flag` is present.\n+pub fn has_arg_flag(name: &str) -> bool {\n+    num_arg_flag(name) > 0\n+}\n+\n+/// Determines how many times a `--flag` is present.\n+pub fn num_arg_flag(name: &str) -> usize {\n+    env::args().take_while(|val| val != \"--\").filter(|val| val == name).count()\n+}\n+\n+/// Yields all values of command line flag `name` as `Ok(arg)`, and all other arguments except\n+/// the flag as `Err(arg)`. (The flag `name` itself is not yielded at all, only its values are.)\n+pub struct ArgSplitFlagValue<'a, I> {\n+    args: Option<I>,\n+    name: &'a str,\n+}\n+\n+impl<'a, I: Iterator> ArgSplitFlagValue<'a, I> {\n+    fn new(args: I, name: &'a str) -> Self {\n+        Self { args: Some(args), name }\n+    }\n+}\n+\n+impl<'s, I: Iterator<Item = Cow<'s, str>>> Iterator for ArgSplitFlagValue<'_, I> {\n+    // If the original iterator was all `Owned`, then we will only ever yield `Owned`\n+    // (so `into_owned()` is cheap).\n+    type Item = Result<Cow<'s, str>, Cow<'s, str>>;\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        let Some(args) = self.args.as_mut() else {\n+            // We already canceled this iterator.\n+            return None;\n+        };\n+        let arg = args.next()?;\n+        if arg == \"--\" {\n+            // Stop searching at `--`.\n+            self.args = None;\n+            return None;\n+        }\n+        // These branches cannot be merged if we want to avoid the allocation in the `Borrowed` branch.\n+        match &arg {\n+            Cow::Borrowed(arg) =>\n+                if let Some(suffix) = arg.strip_prefix(self.name) {\n+                    // Strip leading `name`.\n+                    if suffix.is_empty() {\n+                        // This argument is exactly `name`; the next one is the value.\n+                        return args.next().map(Ok);\n+                    } else if let Some(suffix) = suffix.strip_prefix('=') {\n+                        // This argument is `name=value`; get the value.\n+                        return Some(Ok(Cow::Borrowed(suffix)));\n+                    }\n+                },\n+            Cow::Owned(arg) =>\n+                if let Some(suffix) = arg.strip_prefix(self.name) {\n+                    // Strip leading `name`.\n+                    if suffix.is_empty() {\n+                        // This argument is exactly `name`; the next one is the value.\n+                        return args.next().map(Ok);\n+                    } else if let Some(suffix) = suffix.strip_prefix('=') {\n+                        // This argument is `name=value`; get the value. We need to do an allocation\n+                        // here as a `String` cannot be subsliced (what would the lifetime be?).\n+                        return Some(Ok(Cow::Owned(suffix.to_owned())));\n+                    }\n+                },\n+        }\n+        Some(Err(arg))\n+    }\n+}\n+\n+impl<'a, I: Iterator<Item = String> + 'a> ArgSplitFlagValue<'a, I> {\n+    pub fn from_string_iter(\n+        args: I,\n+        name: &'a str,\n+    ) -> impl Iterator<Item = Result<String, String>> + 'a {\n+        ArgSplitFlagValue::new(args.map(Cow::Owned), name).map(|x| {\n+            match x {\n+                Ok(Cow::Owned(s)) => Ok(s),\n+                Err(Cow::Owned(s)) => Err(s),\n+                _ => panic!(\"iterator converted owned to borrowed\"),\n+            }\n+        })\n+    }\n+}\n+\n+impl<'x: 'a, 'a, I: Iterator<Item = &'x str> + 'a> ArgSplitFlagValue<'a, I> {\n+    pub fn from_str_iter(\n+        args: I,\n+        name: &'a str,\n+    ) -> impl Iterator<Item = Result<&'x str, &'x str>> + 'a {\n+        ArgSplitFlagValue::new(args.map(Cow::Borrowed), name).map(|x| {\n+            match x {\n+                Ok(Cow::Borrowed(s)) => Ok(s),\n+                Err(Cow::Borrowed(s)) => Err(s),\n+                _ => panic!(\"iterator converted borrowed to owned\"),\n+            }\n+        })\n+    }\n+}\n+\n+/// Yields all values of command line flag `name`.\n+pub struct ArgFlagValueIter;\n+\n+impl ArgFlagValueIter {\n+    pub fn from_string_iter<'a, I: Iterator<Item = String> + 'a>(\n+        args: I,\n+        name: &'a str,\n+    ) -> impl Iterator<Item = String> + 'a {\n+        ArgSplitFlagValue::from_string_iter(args, name).filter_map(Result::ok)\n+    }\n+}\n+\n+impl ArgFlagValueIter {\n+    pub fn from_str_iter<'x: 'a, 'a, I: Iterator<Item = &'x str> + 'a>(\n+        args: I,\n+        name: &'a str,\n+    ) -> impl Iterator<Item = &'x str> + 'a {\n+        ArgSplitFlagValue::from_str_iter(args, name).filter_map(Result::ok)\n+    }\n+}\n+\n+/// Gets the values of a `--flag`.\n+pub fn get_arg_flag_values(name: &str) -> impl Iterator<Item = String> + '_ {\n+    ArgFlagValueIter::from_string_iter(env::args(), name)\n+}\n+\n+/// Gets the value of a `--flag`.\n+pub fn get_arg_flag_value(name: &str) -> Option<String> {\n+    get_arg_flag_values(name).next()\n+}"}, {"sha": "f809eecf96af8f4b39e68f7803c18bdcc322e1b2", "filename": "cargo-miri/src/main.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a52244252187b133b3736b37ccb8e39c23992e2a/cargo-miri%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a52244252187b133b3736b37ccb8e39c23992e2a/cargo-miri%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/cargo-miri%2Fsrc%2Fmain.rs?ref=a52244252187b133b3736b37ccb8e39c23992e2a", "patch": "@@ -1,6 +1,7 @@\n #![feature(let_else)]\n #![allow(clippy::useless_format, clippy::derive_partial_eq_without_eq)]\n \n+mod arg;\n mod phases;\n mod setup;\n mod util;"}, {"sha": "d0c0dafe071afa8c63cf9744e886cec41c50595c", "filename": "cargo-miri/src/phases.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a52244252187b133b3736b37ccb8e39c23992e2a/cargo-miri%2Fsrc%2Fphases.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a52244252187b133b3736b37ccb8e39c23992e2a/cargo-miri%2Fsrc%2Fphases.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/cargo-miri%2Fsrc%2Fphases.rs?ref=a52244252187b133b3736b37ccb8e39c23992e2a", "patch": "@@ -117,8 +117,9 @@ pub fn phase_cargo_miri(mut args: impl Iterator<Item = String>) {\n     cmd.arg(cargo_cmd);\n \n     // Forward all arguments before `--` other than `--target-dir` and its value to Cargo.\n+    // (We want to *change* the target-dir value, so we must not forward it.)\n     let mut target_dir = None;\n-    for arg in ArgSplitFlagValue::new(&mut args, \"--target-dir\") {\n+    for arg in ArgSplitFlagValue::from_string_iter(&mut args, \"--target-dir\") {\n         match arg {\n             Ok(value) => {\n                 if target_dir.is_some() {\n@@ -309,17 +310,18 @@ pub fn phase_rustc(mut args: impl Iterator<Item = String>, phase: RustcPhase) {\n             let mut cmd = miri();\n \n             // Ensure --emit argument for a check-only build is present.\n-            // We cannot use the usual helpers since we need to check specifically in `env.args`.\n-            if let Some(i) = env.args.iter().position(|arg| arg.starts_with(\"--emit=\")) {\n+            if let Some(val) =\n+                ArgFlagValueIter::from_str_iter(env.args.iter().map(|s| s as &str), \"--emit\").next()\n+            {\n                 // For `no_run` tests, rustdoc passes a `--emit` flag; make sure it has the right shape.\n-                assert_eq!(env.args[i], \"--emit=metadata\");\n+                assert_eq!(val, \"metadata\");\n             } else {\n                 // For all other kinds of tests, we can just add our flag.\n                 cmd.arg(\"--emit=metadata\");\n             }\n \n             // Alter the `-o` parameter so that it does not overwrite the JSON file we stored above.\n-            let mut args = env.args.clone();\n+            let mut args = env.args;\n             for i in 0..args.len() {\n                 if args[i] == \"-o\" {\n                     args[i + 1].push_str(\".miri\");\n@@ -343,7 +345,7 @@ pub fn phase_rustc(mut args: impl Iterator<Item = String>, phase: RustcPhase) {\n         return;\n     }\n \n-    if runnable_crate && ArgFlagValueIter::new(\"--extern\").any(|krate| krate == \"proc_macro\") {\n+    if runnable_crate && get_arg_flag_values(\"--extern\").any(|krate| krate == \"proc_macro\") {\n         // This is a \"runnable\" `proc-macro` crate (unit tests). We do not support\n         // interpreting that under Miri now, so we write a JSON file to (display a\n         // helpful message and) skip it in the runner phase.\n@@ -567,7 +569,7 @@ pub fn phase_rustdoc(mut args: impl Iterator<Item = String>) {\n \n     // Doctests of `proc-macro` crates (and their dependencies) are always built for the host,\n     // so we are not able to run them in Miri.\n-    if ArgFlagValueIter::new(\"--crate-type\").any(|crate_type| crate_type == \"proc-macro\") {\n+    if get_arg_flag_values(\"--crate-type\").any(|crate_type| crate_type == \"proc-macro\") {\n         eprintln!(\"Running doctests of `proc-macro` crates is not currently supported by Miri.\");\n         return;\n     }"}, {"sha": "04cfd2077bb7226eb044103f38cc1ba7a47d33f3", "filename": "cargo-miri/src/util.rs", "status": "modified", "additions": 23, "deletions": 90, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/a52244252187b133b3736b37ccb8e39c23992e2a/cargo-miri%2Fsrc%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a52244252187b133b3736b37ccb8e39c23992e2a/cargo-miri%2Fsrc%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/cargo-miri%2Fsrc%2Futil.rs?ref=a52244252187b133b3736b37ccb8e39c23992e2a", "patch": "@@ -4,7 +4,6 @@ use std::ffi::OsString;\n use std::fmt::Write as _;\n use std::fs::{self, File};\n use std::io::{self, BufWriter, Read, Write};\n-use std::iter::TakeWhile;\n use std::ops::Not;\n use std::path::{Path, PathBuf};\n use std::process::Command;\n@@ -13,6 +12,8 @@ use cargo_metadata::{Metadata, MetadataCommand};\n use rustc_version::VersionMeta;\n use serde::{Deserialize, Serialize};\n \n+pub use crate::arg::*;\n+\n /// The information to run a crate with the given environment.\n #[derive(Clone, Serialize, Deserialize)]\n pub struct CrateRunEnv {\n@@ -74,78 +75,6 @@ pub fn show_error(msg: String) -> ! {\n     std::process::exit(1)\n }\n \n-/// Determines whether a `--flag` is present.\n-pub fn has_arg_flag(name: &str) -> bool {\n-    num_arg_flag(name) > 0\n-}\n-\n-/// Determines how many times a `--flag` is present.\n-pub fn num_arg_flag(name: &str) -> usize {\n-    std::env::args().take_while(|val| val != \"--\").filter(|val| val == name).count()\n-}\n-\n-/// Yields all values of command line flag `name` as `Ok(arg)`, and all other arguments except\n-/// the flag as `Err(arg)`. (The flag `name` itself is not yielded at all, only its values are.)\n-pub struct ArgSplitFlagValue<'a, I> {\n-    args: TakeWhile<I, fn(&String) -> bool>,\n-    name: &'a str,\n-}\n-\n-impl<'a, I: Iterator<Item = String>> ArgSplitFlagValue<'a, I> {\n-    pub fn new(args: I, name: &'a str) -> Self {\n-        Self {\n-            // Stop searching at `--`.\n-            args: args.take_while(|val| val != \"--\"),\n-            name,\n-        }\n-    }\n-}\n-\n-impl<I: Iterator<Item = String>> Iterator for ArgSplitFlagValue<'_, I> {\n-    type Item = Result<String, String>;\n-\n-    fn next(&mut self) -> Option<Self::Item> {\n-        let arg = self.args.next()?;\n-        if let Some(suffix) = arg.strip_prefix(self.name) {\n-            // Strip leading `name`.\n-            if suffix.is_empty() {\n-                // This argument is exactly `name`; the next one is the value.\n-                return self.args.next().map(Ok);\n-            } else if let Some(suffix) = suffix.strip_prefix('=') {\n-                // This argument is `name=value`; get the value.\n-                return Some(Ok(suffix.to_owned()));\n-            }\n-        }\n-        Some(Err(arg))\n-    }\n-}\n-\n-/// Yields all values of command line flag `name`.\n-pub struct ArgFlagValueIter<'a>(ArgSplitFlagValue<'a, env::Args>);\n-\n-impl<'a> ArgFlagValueIter<'a> {\n-    pub fn new(name: &'a str) -> Self {\n-        Self(ArgSplitFlagValue::new(env::args(), name))\n-    }\n-}\n-\n-impl Iterator for ArgFlagValueIter<'_> {\n-    type Item = String;\n-\n-    fn next(&mut self) -> Option<Self::Item> {\n-        loop {\n-            if let Ok(value) = self.0.next()? {\n-                return Some(value);\n-            }\n-        }\n-    }\n-}\n-\n-/// Gets the value of a `--flag`.\n-pub fn get_arg_flag_value(name: &str) -> Option<String> {\n-    ArgFlagValueIter::new(name).next()\n-}\n-\n /// Escapes `s` in a way that is suitable for using it as a string literal in TOML syntax.\n pub fn escape_for_toml(s: &str) -> String {\n     // We want to surround this string in quotes `\"`. So we first escape all quotes,\n@@ -287,29 +216,33 @@ pub fn write_to_file(filename: &Path, content: &str) {\n     fs::rename(temp_filename, filename).unwrap();\n }\n \n-pub fn get_cargo_metadata() -> Metadata {\n-    // The `build.target-dir` config can be passed by `--config` flags, so forward them to\n-    // `cargo metadata`.\n-    let mut additional_options = Vec::new();\n+// Computes the extra flags that need to be passed to cargo to make it behave like the current\n+// cargo invocation.\n+fn cargo_extra_flags() -> Vec<String> {\n+    let mut flags = Vec::new();\n     // `-Zunstable-options` is required by `--config`.\n-    additional_options.push(\"-Zunstable-options\".to_string());\n+    flags.push(\"-Zunstable-options\".to_string());\n \n+    // Forward `--config` flags.\n     let config_flag = \"--config\";\n-    for arg in ArgSplitFlagValue::new(\n-        env::args().skip(3), // skip the program name, \"miri\" and \"run\" / \"test\"\n-        config_flag,\n-    )\n-    // Only look at `Ok`\n-    .flatten()\n-    {\n-        additional_options.push(config_flag.to_string());\n-        additional_options.push(arg);\n+    for arg in get_arg_flag_values(config_flag) {\n+        flags.push(config_flag.to_string());\n+        flags.push(arg);\n     }\n \n-    let metadata =\n-        MetadataCommand::new().no_deps().other_options(additional_options).exec().unwrap();\n+    // Forward `--manifest-path`.\n+    let manifest_flag = \"--manifest-path\";\n+    if let Some(manifest) = get_arg_flag_value(manifest_flag) {\n+        flags.push(manifest_flag.to_string());\n+        flags.push(manifest);\n+    }\n+\n+    flags\n+}\n \n-    metadata\n+pub fn get_cargo_metadata() -> Metadata {\n+    // This will honor the `CARGO` env var the same way our `cargo()` does.\n+    MetadataCommand::new().no_deps().other_options(cargo_extra_flags()).exec().unwrap()\n }\n \n /// Pulls all the crates in this workspace from the cargo metadata."}, {"sha": "a29fc3deca58dc32816f54fa5fb5d7a83de1a2d7", "filename": "ci.sh", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a52244252187b133b3736b37ccb8e39c23992e2a/ci.sh", "raw_url": "https://github.com/rust-lang/rust/raw/a52244252187b133b3736b37ccb8e39c23992e2a/ci.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/ci.sh?ref=a52244252187b133b3736b37ccb8e39c23992e2a", "patch": "@@ -54,8 +54,8 @@ function run_tests {\n   unset RUSTC MIRI\n   rm -rf .cargo\n \n-  # Ensure that our benchmarks all work, on the host at least.\n-  if [ -z \"${MIRI_TEST_TARGET+exists}\" ]; then\n+  # Ensure that our benchmarks all work, but only on Linux hosts.\n+  if [ -z \"${MIRI_TEST_TARGET+exists}\" ] && [ \"$HOST_TARGET\" = x86_64-unknown-linux-gnu ] ; then\n     for BENCH in $(ls \"bench-cargo-miri\"); do\n       cargo miri run --manifest-path bench-cargo-miri/$BENCH/Cargo.toml\n     done"}, {"sha": "0295fc3ab3ac32a2d4acc1a484033f40c8a1c97b", "filename": "miri", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a52244252187b133b3736b37ccb8e39c23992e2a/miri", "raw_url": "https://github.com/rust-lang/rust/raw/a52244252187b133b3736b37ccb8e39c23992e2a/miri", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/miri?ref=a52244252187b133b3736b37ccb8e39c23992e2a", "patch": "@@ -90,13 +90,13 @@ bench)\n     # Make sure we have an up-to-date Miri installed\n     \"$0\" install\n     # Run the requested benchmarks\n-    if [ -z \"$@\" ]; then\n+    if [ -z \"${1+exists}\" ]; then\n         BENCHES=( $(ls \"$MIRIDIR/bench-cargo-miri\" ) )\n     else\n         BENCHES=(\"$@\")\n     fi\n     for BENCH in \"${BENCHES[@]}\"; do\n-        hyperfine -w 1 -m 5 --shell=none \"cargo +$TOOLCHAIN miri run --manifest-path bench-cargo-miri/$BENCH/Cargo.toml\"\n+        hyperfine -w 1 -m 5 --shell=none \"cargo +$TOOLCHAIN miri run --manifest-path $MIRIDIR/bench-cargo-miri/$BENCH/Cargo.toml\"\n     done\n     exit 0\n     ;;"}]}