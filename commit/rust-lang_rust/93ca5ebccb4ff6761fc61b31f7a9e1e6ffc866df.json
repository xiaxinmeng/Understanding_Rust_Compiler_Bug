{"sha": "93ca5ebccb4ff6761fc61b31f7a9e1e6ffc866df", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkzY2E1ZWJjY2I0ZmY2NzYxZmM2MWIzMWY3YTllMWU2ZmZjODY2ZGY=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-04-27T01:59:59Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-05-13T21:24:10Z"}, "message": "core::rt: Clean up the interface to rtio\n\nMake names that better match rt::io. Return error types.", "tree": {"sha": "ff2c1bb92f0b14fba8d236e20b82c10ea6cd53ce", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ff2c1bb92f0b14fba8d236e20b82c10ea6cd53ce"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/93ca5ebccb4ff6761fc61b31f7a9e1e6ffc866df", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/93ca5ebccb4ff6761fc61b31f7a9e1e6ffc866df", "html_url": "https://github.com/rust-lang/rust/commit/93ca5ebccb4ff6761fc61b31f7a9e1e6ffc866df", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/93ca5ebccb4ff6761fc61b31f7a9e1e6ffc866df/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b2fbd34603c5e209ab7a61a09ca943bd5b15f1a3", "url": "https://api.github.com/repos/rust-lang/rust/commits/b2fbd34603c5e209ab7a61a09ca943bd5b15f1a3", "html_url": "https://github.com/rust-lang/rust/commit/b2fbd34603c5e209ab7a61a09ca943bd5b15f1a3"}], "stats": {"total": 123, "additions": 63, "deletions": 60}, "files": [{"sha": "8f56005d0a4f66d8f3f20be736edc5a92777ec18", "filename": "src/libcore/rt/io/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/93ca5ebccb4ff6761fc61b31f7a9e1e6ffc866df/src%2Flibcore%2Frt%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93ca5ebccb4ff6761fc61b31f7a9e1e6ffc866df/src%2Flibcore%2Frt%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fio%2Fmod.rs?ref=93ca5ebccb4ff6761fc61b31f7a9e1e6ffc866df", "patch": "@@ -238,6 +238,7 @@ Out of scope\n * How does I/O relate to the Iterator trait?\n * std::base64 filters\n * Using conditions is a big unknown since we don't have much experience with them\n+* Too many uses of OtherIoError\n \n */\n "}, {"sha": "95f43b259ce5237521a7a66601de518811d9fbe7", "filename": "src/libcore/rt/io/net/tcp.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/93ca5ebccb4ff6761fc61b31f7a9e1e6ffc866df/src%2Flibcore%2Frt%2Fio%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93ca5ebccb4ff6761fc61b31f7a9e1e6ffc866df/src%2Flibcore%2Frt%2Fio%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fio%2Fnet%2Ftcp.rs?ref=93ca5ebccb4ff6761fc61b31f7a9e1e6ffc866df", "patch": "@@ -9,21 +9,22 @@\n // except according to those terms.\n \n use option::{Option, Some, None};\n-use result::{Result, Ok, Err};\n+use result::{Ok, Err};\n use ops::Drop;\n use rt::sched::local_sched::unsafe_borrow_io;\n use rt::io::net::ip::IpAddr;\n use rt::io::{Reader, Writer, Listener};\n use rt::io::io_error;\n-use rt::rtio;\n-use rt::rtio::{IoFactory, TcpListener, Stream};\n+use rt::rtio::{IoFactory,\n+               RtioTcpListener, RtioTcpListenerObject,\n+               RtioTcpStream, RtioTcpStreamObject};\n \n pub struct TcpStream {\n-    rtstream: ~rtio::StreamObject\n+    rtstream: ~RtioTcpStreamObject\n }\n \n impl TcpStream {\n-    fn new(s: ~rtio::StreamObject) -> TcpStream {\n+    fn new(s: ~RtioTcpStreamObject) -> TcpStream {\n         TcpStream {\n             rtstream: s\n         }\n@@ -34,7 +35,7 @@ impl TcpStream {\n             rtdebug!(\"borrowing io to connect\");\n             let io = unsafe_borrow_io();\n             rtdebug!(\"about to connect\");\n-            io.connect(addr)\n+            io.tcp_connect(addr)\n         };\n \n         match stream {\n@@ -85,12 +86,12 @@ impl Drop for TcpStream {\n }\n \n pub struct TcpListener {\n-    rtlistener: ~rtio::TcpListenerObject\n+    rtlistener: ~RtioTcpListenerObject\n }\n \n impl TcpListener {\n     pub fn bind(addr: IpAddr) -> Option<TcpListener> {\n-        let listener = unsafe { unsafe_borrow_io().bind(addr) };\n+        let listener = unsafe { unsafe_borrow_io().tcp_bind(addr) };\n         match listener {\n             Ok(l) => {\n                 Some(TcpListener {\n@@ -107,12 +108,12 @@ impl TcpListener {\n \n impl Listener<TcpStream> for TcpListener {\n     fn accept(&mut self) -> Option<TcpStream> {\n-        let rtstream = self.rtlistener.listen();\n+        let rtstream = self.rtlistener.accept();\n         match rtstream {\n-            Some(s) => {\n+            Ok(s) => {\n                 Some(TcpStream::new(s))\n             }\n-            None => {\n+            Err(_) => {\n                 abort!(\"TODO\");\n             }\n         }"}, {"sha": "1d8604bc3fd6ca3f9a858ac5bd009a5e38726dac", "filename": "src/libcore/rt/rtio.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/93ca5ebccb4ff6761fc61b31f7a9e1e6ffc866df/src%2Flibcore%2Frt%2Frtio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93ca5ebccb4ff6761fc61b31f7a9e1e6ffc866df/src%2Flibcore%2Frt%2Frtio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Frtio.rs?ref=93ca5ebccb4ff6761fc61b31f7a9e1e6ffc866df", "patch": "@@ -18,8 +18,8 @@ use super::io::net::ip::IpAddr;\n // types to use instead\n pub type EventLoopObject = super::uvio::UvEventLoop;\n pub type IoFactoryObject = super::uvio::UvIoFactory;\n-pub type StreamObject = super::uvio::UvStream;\n-pub type TcpListenerObject = super::uvio::UvTcpListener;\n+pub type RtioTcpStreamObject = super::uvio::UvTcpStream;\n+pub type RtioTcpListenerObject = super::uvio::UvTcpListener;\n \n pub trait EventLoop {\n     fn run(&mut self);\n@@ -29,15 +29,15 @@ pub trait EventLoop {\n }\n \n pub trait IoFactory {\n-    fn connect(&mut self, addr: IpAddr) -> Result<~StreamObject, IoError>;\n-    fn bind(&mut self, addr: IpAddr) -> Result<~TcpListenerObject, IoError>;\n+    fn tcp_connect(&mut self, addr: IpAddr) -> Result<~RtioTcpStreamObject, IoError>;\n+    fn tcp_bind(&mut self, addr: IpAddr) -> Result<~RtioTcpListenerObject, IoError>;\n }\n \n-pub trait TcpListener {\n-    fn listen(&mut self) -> Option<~StreamObject>;\n+pub trait RtioTcpListener {\n+    fn accept(&mut self) -> Result<~RtioTcpStreamObject, IoError>;\n }\n \n-pub trait Stream {\n-    fn read(&mut self, buf: &mut [u8]) -> Result<uint, ()>;\n-    fn write(&mut self, buf: &[u8]) -> Result<(), ()>;\n+pub trait RtioTcpStream {\n+    fn read(&mut self, buf: &mut [u8]) -> Result<uint, IoError>;\n+    fn write(&mut self, buf: &[u8]) -> Result<(), IoError>;\n }"}, {"sha": "24b6c353cced06b7e9e4cb23fdd8f0f0fa8f8263", "filename": "src/libcore/rt/uv/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/93ca5ebccb4ff6761fc61b31f7a9e1e6ffc866df/src%2Flibcore%2Frt%2Fuv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93ca5ebccb4ff6761fc61b31f7a9e1e6ffc866df/src%2Flibcore%2Frt%2Fuv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fuv%2Fmod.rs?ref=93ca5ebccb4ff6761fc61b31f7a9e1e6ffc866df", "patch": "@@ -48,7 +48,7 @@ use ptr::null;\n use unstable::finally::Finally;\n \n use rt::uvll;\n-use rt::io::{IoError, FileNotFound};\n+use rt::io::IoError;\n \n #[cfg(test)] use unstable::run_in_bare_thread;\n "}, {"sha": "70f233a29d3409ce93b617c7c3dd879153f035bd", "filename": "src/libcore/rt/uvio.rs", "status": "modified", "additions": 40, "deletions": 39, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/93ca5ebccb4ff6761fc61b31f7a9e1e6ffc866df/src%2Flibcore%2Frt%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93ca5ebccb4ff6761fc61b31f7a9e1e6ffc866df/src%2Flibcore%2Frt%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fuvio.rs?ref=93ca5ebccb4ff6761fc61b31f7a9e1e6ffc866df", "patch": "@@ -10,19 +10,20 @@\n \n use option::*;\n use result::*;\n-\n-use rt::io::IoError;\n-use super::io::net::ip::IpAddr;\n-use super::uv::*;\n-use super::rtio::*;\n use ops::Drop;\n use cell::{Cell, empty_cell};\n use cast::transmute;\n-use super::sched::{Scheduler, local_sched};\n+\n+use rt::io::IoError;\n+use rt::io::net::ip::IpAddr;\n+use rt::uv::*;\n+use rt::rtio::*;\n+use rt::sched::{Scheduler, local_sched};\n+use rt::io::{standard_error, OtherIoError};\n \n #[cfg(test)] use uint;\n #[cfg(test)] use unstable::run_in_bare_thread;\n-#[cfg(test)] use super::test::*;\n+#[cfg(test)] use rt::test::*;\n \n pub struct UvEventLoop {\n     uvio: UvIoFactory\n@@ -99,11 +100,11 @@ impl IoFactory for UvIoFactory {\n     // Connect to an address and return a new stream\n     // NB: This blocks the task waiting on the connection.\n     // It would probably be better to return a future\n-    fn connect(&mut self, addr: IpAddr) -> Result<~StreamObject, IoError> {\n+    fn tcp_connect(&mut self, addr: IpAddr) -> Result<~RtioTcpStreamObject, IoError> {\n         // Create a cell in the task to hold the result. We will fill\n         // the cell before resuming the task.\n         let result_cell = empty_cell();\n-        let result_cell_ptr: *Cell<Result<~StreamObject, IoError>> = &result_cell;\n+        let result_cell_ptr: *Cell<Result<~RtioTcpStreamObject, IoError>> = &result_cell;\n \n         let scheduler = local_sched::take();\n         assert!(scheduler.in_task_context());\n@@ -123,7 +124,7 @@ impl IoFactory for UvIoFactory {\n                 rtdebug!(\"connect: in connect callback\");\n                 let maybe_stream = if status.is_none() {\n                     rtdebug!(\"status is none\");\n-                    Ok(~UvStream(stream_watcher))\n+                    Ok(~UvTcpStream(stream_watcher))\n                 } else {\n                     rtdebug!(\"status is some\");\n                     // XXX: Wait for close\n@@ -144,7 +145,7 @@ impl IoFactory for UvIoFactory {\n         return result_cell.take();\n     }\n \n-    fn bind(&mut self, addr: IpAddr) -> Result<~TcpListenerObject, IoError> {\n+    fn tcp_bind(&mut self, addr: IpAddr) -> Result<~RtioTcpListenerObject, IoError> {\n         let mut watcher = TcpWatcher::new(self.uv_loop());\n         match watcher.bind(addr) {\n             Ok(_) => Ok(~UvTcpListener(watcher)),\n@@ -177,12 +178,12 @@ impl Drop for UvTcpListener {\n     }\n }\n \n-impl TcpListener for UvTcpListener {\n+impl RtioTcpListener for UvTcpListener {\n \n-    fn listen(&mut self) -> Option<~StreamObject> {\n+    fn accept(&mut self) -> Result<~RtioTcpStreamObject, IoError> {\n         rtdebug!(\"entering listen\");\n         let result_cell = empty_cell();\n-        let result_cell_ptr: *Cell<Option<~StreamObject>> = &result_cell;\n+        let result_cell_ptr: *Cell<Result<~RtioTcpStreamObject, IoError>> = &result_cell;\n \n         let server_tcp_watcher = self.watcher();\n \n@@ -199,9 +200,9 @@ impl TcpListener for UvTcpListener {\n                     let client_tcp_watcher = TcpWatcher::new(&mut loop_).as_stream();\n                     // XXX: Needs to be surfaced in interface\n                     server_stream_watcher.accept(client_tcp_watcher);\n-                    Some(~UvStream::new(client_tcp_watcher))\n+                    Ok(~UvTcpStream::new(client_tcp_watcher))\n                 } else {\n-                    None\n+                    Err(standard_error(OtherIoError))\n                 };\n \n                 unsafe { (*result_cell_ptr).put_back(maybe_stream); }\n@@ -218,15 +219,15 @@ impl TcpListener for UvTcpListener {\n     }\n }\n \n-pub struct UvStream(StreamWatcher);\n+pub struct UvTcpStream(StreamWatcher);\n \n-impl UvStream {\n-    fn new(watcher: StreamWatcher) -> UvStream {\n-        UvStream(watcher)\n+impl UvTcpStream {\n+    fn new(watcher: StreamWatcher) -> UvTcpStream {\n+        UvTcpStream(watcher)\n     }\n \n     fn watcher(&self) -> StreamWatcher {\n-        match self { &UvStream(w) => w }\n+        match self { &UvTcpStream(w) => w }\n     }\n \n     // XXX: finalize isn't working for ~UvStream???\n@@ -236,17 +237,17 @@ impl UvStream {\n     }\n }\n \n-impl Drop for UvStream {\n+impl Drop for UvTcpStream {\n     fn finalize(&self) {\n         rtdebug!(\"closing stream\");\n         //self.watcher().close(||());\n     }\n }\n \n-impl Stream for UvStream {\n-    fn read(&mut self, buf: &mut [u8]) -> Result<uint, ()> {\n+impl RtioTcpStream for UvTcpStream {\n+    fn read(&mut self, buf: &mut [u8]) -> Result<uint, IoError> {\n         let result_cell = empty_cell();\n-        let result_cell_ptr: *Cell<Result<uint, ()>> = &result_cell;\n+        let result_cell_ptr: *Cell<Result<uint, IoError>> = &result_cell;\n \n         let scheduler = local_sched::take();\n         assert!(scheduler.in_task_context());\n@@ -277,7 +278,7 @@ impl Stream for UvStream {\n                     assert!(nread >= 0);\n                     Ok(nread as uint)\n                 } else {\n-                    Err(())\n+                    Err(standard_error(OtherIoError))\n                 };\n \n                 unsafe { (*result_cell_ptr).put_back(result); }\n@@ -291,9 +292,9 @@ impl Stream for UvStream {\n         return result_cell.take();\n     }\n \n-    fn write(&mut self, buf: &[u8]) -> Result<(), ()> {\n+    fn write(&mut self, buf: &[u8]) -> Result<(), IoError> {\n         let result_cell = empty_cell();\n-        let result_cell_ptr: *Cell<Result<(), ()>> = &result_cell;\n+        let result_cell_ptr: *Cell<Result<(), IoError>> = &result_cell;\n         let scheduler = local_sched::take();\n         assert!(scheduler.in_task_context());\n         let watcher = self.watcher();\n@@ -308,7 +309,7 @@ impl Stream for UvStream {\n                 let result = if status.is_none() {\n                     Ok(())\n                 } else {\n-                    Err(())\n+                    Err(standard_error(OtherIoError))\n                 };\n \n                 unsafe { (*result_cell_ptr).put_back(result); }\n@@ -328,7 +329,7 @@ fn test_simple_io_no_connect() {\n     do run_in_newsched_task {\n         let io = unsafe { local_sched::unsafe_borrow_io() };\n         let addr = next_test_ip4();\n-        let maybe_chan = io.connect(addr);\n+        let maybe_chan = io.tcp_connect(addr);\n         assert!(maybe_chan.is_err());\n     }\n }\n@@ -342,8 +343,8 @@ fn test_simple_tcp_server_and_client() {\n         do spawntask_immediately {\n             unsafe {\n                 let io = local_sched::unsafe_borrow_io();\n-                let mut listener = io.bind(addr).unwrap();\n-                let mut stream = listener.listen().unwrap();\n+                let mut listener = io.tcp_bind(addr).unwrap();\n+                let mut stream = listener.accept().unwrap();\n                 let mut buf = [0, .. 2048];\n                 let nread = stream.read(buf).unwrap();\n                 assert!(nread == 8);\n@@ -359,7 +360,7 @@ fn test_simple_tcp_server_and_client() {\n         do spawntask_immediately {\n             unsafe {\n                 let io = local_sched::unsafe_borrow_io();\n-                let mut stream = io.connect(addr).unwrap();\n+                let mut stream = io.tcp_connect(addr).unwrap();\n                 stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n                 stream.close();\n             }\n@@ -374,8 +375,8 @@ fn test_read_and_block() {\n \n         do spawntask_immediately {\n             let io = unsafe { local_sched::unsafe_borrow_io() };\n-            let mut listener = io.bind(addr).unwrap();\n-            let mut stream = listener.listen().unwrap();\n+            let mut listener = io.tcp_bind(addr).unwrap();\n+            let mut stream = listener.accept().unwrap();\n             let mut buf = [0, .. 2048];\n \n             let expected = 32;\n@@ -412,7 +413,7 @@ fn test_read_and_block() {\n \n         do spawntask_immediately {\n             let io = unsafe { local_sched::unsafe_borrow_io() };\n-            let mut stream = io.connect(addr).unwrap();\n+            let mut stream = io.tcp_connect(addr).unwrap();\n             stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n             stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n             stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n@@ -432,8 +433,8 @@ fn test_read_read_read() {\n         do spawntask_immediately {\n             unsafe {\n                 let io = local_sched::unsafe_borrow_io();\n-                let mut listener = io.bind(addr).unwrap();\n-                let mut stream = listener.listen().unwrap();\n+                let mut listener = io.tcp_bind(addr).unwrap();\n+                let mut stream = listener.accept().unwrap();\n                 let mut buf = [1, .. 2048];\n                 let mut total_bytes_written = 0;\n                 while total_bytes_written < MAX {\n@@ -447,7 +448,7 @@ fn test_read_read_read() {\n \n         do spawntask_immediately {\n             let io = unsafe { local_sched::unsafe_borrow_io() };\n-            let mut stream = io.connect(addr).unwrap();\n+            let mut stream = io.tcp_connect(addr).unwrap();\n             let mut buf = [0, .. 2048];\n             let mut total_bytes_read = 0;\n             while total_bytes_read < MAX {"}]}