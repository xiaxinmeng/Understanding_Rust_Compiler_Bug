{"sha": "43a8f7b3e90784ae9e4237a07913f2c5d2bd1631", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQzYThmN2IzZTkwNzg0YWU5ZTQyMzdhMDc5MTNmMmM1ZDJiZDE2MzE=", "commit": {"author": {"name": "Dmitry Promsky", "email": "dmitry@willworkforcookies.com", "date": "2014-03-03T10:44:43Z"}, "committer": {"name": "Dmitry Promsky", "email": "dmitry@willworkforcookies.com", "date": "2014-03-09T22:28:04Z"}, "message": "syntax: fixed ICEs and incorrect line nums when reporting Spans at the end of the file.\n\nCodeMap.span_to_* perform a lookup of a BytePos(sp.hi), which lands into the next filemap if the last byte of range denoted by Span is also the last byte of the filemap, which results in ICEs or incorrect error reports.\n\n    Example:\n        ````\n\n        pub fn main() {\n            let mut num = 3;\n            let refe = &mut num;\n            *refe = 5;\n            println!(\"{}\", num);\n        }````\n\n(note the empty line in the beginning and the absence of newline at the end)\n\nThe above would have caused ICE when trying to report where \"refe\" borrow ends.\nThe above without an empty line in the beginning would have reported borrow end to be the first line.\n\nMost probably, this is also responsible for (at least some occurrences of) issue #8256.\n\nThe issue is fixed by always adding a newline at the end of non-empty filemaps in case there isn't a new line there already.", "tree": {"sha": "bbc49082113a10574ed8dabe6a3f726bf25145a7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bbc49082113a10574ed8dabe6a3f726bf25145a7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/43a8f7b3e90784ae9e4237a07913f2c5d2bd1631", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/43a8f7b3e90784ae9e4237a07913f2c5d2bd1631", "html_url": "https://github.com/rust-lang/rust/commit/43a8f7b3e90784ae9e4237a07913f2c5d2bd1631", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/43a8f7b3e90784ae9e4237a07913f2c5d2bd1631/comments", "author": {"login": "dmski", "id": 1293095, "node_id": "MDQ6VXNlcjEyOTMwOTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1293095?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dmski", "html_url": "https://github.com/dmski", "followers_url": "https://api.github.com/users/dmski/followers", "following_url": "https://api.github.com/users/dmski/following{/other_user}", "gists_url": "https://api.github.com/users/dmski/gists{/gist_id}", "starred_url": "https://api.github.com/users/dmski/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dmski/subscriptions", "organizations_url": "https://api.github.com/users/dmski/orgs", "repos_url": "https://api.github.com/users/dmski/repos", "events_url": "https://api.github.com/users/dmski/events{/privacy}", "received_events_url": "https://api.github.com/users/dmski/received_events", "type": "User", "site_admin": false}, "committer": {"login": "dmski", "id": 1293095, "node_id": "MDQ6VXNlcjEyOTMwOTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1293095?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dmski", "html_url": "https://github.com/dmski", "followers_url": "https://api.github.com/users/dmski/followers", "following_url": "https://api.github.com/users/dmski/following{/other_user}", "gists_url": "https://api.github.com/users/dmski/gists{/gist_id}", "starred_url": "https://api.github.com/users/dmski/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dmski/subscriptions", "organizations_url": "https://api.github.com/users/dmski/orgs", "repos_url": "https://api.github.com/users/dmski/repos", "events_url": "https://api.github.com/users/dmski/events{/privacy}", "received_events_url": "https://api.github.com/users/dmski/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "62f1d68439dcfd509eaca29887afa97f22938373", "url": "https://api.github.com/repos/rust-lang/rust/commits/62f1d68439dcfd509eaca29887afa97f22938373", "html_url": "https://github.com/rust-lang/rust/commit/62f1d68439dcfd509eaca29887afa97f22938373"}], "stats": {"total": 72, "additions": 58, "deletions": 14}, "files": [{"sha": "5be03317b7770375066fb874b20f323e06985411", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 58, "deletions": 14, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/43a8f7b3e90784ae9e4237a07913f2c5d2bd1631/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43a8f7b3e90784ae9e4237a07913f2c5d2bd1631/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=43a8f7b3e90784ae9e4237a07913f2c5d2bd1631", "patch": "@@ -221,6 +221,10 @@ impl FileMap {\n     // UNCHECKED INVARIANT: these offsets must be added in the right\n     // order and must be in the right places; there is shared knowledge\n     // about what ends a line between this file and parse.rs\n+    // WARNING: pos param here is the offset relative to start of CodeMap,\n+    // and CodeMap will append a newline when adding a filemap without a newline at the end,\n+    // so the safe way to call this is with value calculated as\n+    // filemap.start_pos + newline_offset_relative_to_the_start_of_filemap.\n     pub fn next_line(&self, pos: BytePos) {\n         // the new charpos must be > the last one (or it's the first one).\n         let mut lines = self.lines.borrow_mut();;\n@@ -267,13 +271,21 @@ impl CodeMap {\n         }\n     }\n \n-    pub fn new_filemap(&self, filename: FileName, src: ~str) -> @FileMap {\n+    pub fn new_filemap(&self, filename: FileName, mut src: ~str) -> @FileMap {\n         let mut files = self.files.borrow_mut();\n         let start_pos = match files.get().last() {\n             None => 0,\n             Some(last) => last.start_pos.to_uint() + last.src.len(),\n         };\n \n+        // Append '\\n' in case it's not already there.\n+        // This is a workaround to prevent CodeMap.lookup_filemap_idx from accidentally\n+        // overflowing into the next filemap in case the last byte of span is also the last\n+        // byte of filemap, which leads to incorrect results from CodeMap.span_to_*.\n+        if src.len() > 0 && !src.ends_with(\"\\n\") {\n+            src.push_char('\\n');\n+        }\n+\n         let filemap = @FileMap {\n             name: filename,\n             src: src,\n@@ -510,9 +522,9 @@ mod test {\n \n         fm1.next_line(BytePos(0));\n         fm1.next_line(BytePos(12));\n-        fm2.next_line(BytePos(23));\n-        fm3.next_line(BytePos(23));\n-        fm3.next_line(BytePos(33));\n+        fm2.next_line(BytePos(24));\n+        fm3.next_line(BytePos(24));\n+        fm3.next_line(BytePos(34));\n \n         cm\n     }\n@@ -526,7 +538,7 @@ mod test {\n         assert_eq!(fmabp1.fm.name, ~\"blork.rs\");\n         assert_eq!(fmabp1.pos, BytePos(22));\n \n-        let fmabp2 = cm.lookup_byte_offset(BytePos(23));\n+        let fmabp2 = cm.lookup_byte_offset(BytePos(24));\n         assert_eq!(fmabp2.fm.name, ~\"blork2.rs\");\n         assert_eq!(fmabp2.pos, BytePos(0));\n     }\n@@ -539,7 +551,7 @@ mod test {\n         let cp1 = cm.bytepos_to_file_charpos(BytePos(22));\n         assert_eq!(cp1, CharPos(22));\n \n-        let cp2 = cm.bytepos_to_file_charpos(BytePos(23));\n+        let cp2 = cm.bytepos_to_file_charpos(BytePos(24));\n         assert_eq!(cp2, CharPos(0));\n     }\n \n@@ -553,7 +565,7 @@ mod test {\n         assert_eq!(loc1.line, 2);\n         assert_eq!(loc1.col, CharPos(10));\n \n-        let loc2 = cm.lookup_char_pos(BytePos(23));\n+        let loc2 = cm.lookup_char_pos(BytePos(24));\n         assert_eq!(loc2.file.name, ~\"blork2.rs\");\n         assert_eq!(loc2.line, 1);\n         assert_eq!(loc2.col, CharPos(0));\n@@ -567,17 +579,17 @@ mod test {\n \n         fm1.next_line(BytePos(0));\n         fm1.next_line(BytePos(22));\n-        fm2.next_line(BytePos(39));\n-        fm2.next_line(BytePos(57));\n+        fm2.next_line(BytePos(40));\n+        fm2.next_line(BytePos(58));\n \n         fm1.record_multibyte_char(BytePos(3), 3);\n         fm1.record_multibyte_char(BytePos(9), 3);\n         fm1.record_multibyte_char(BytePos(12), 3);\n         fm1.record_multibyte_char(BytePos(15), 3);\n         fm1.record_multibyte_char(BytePos(18), 3);\n-        fm2.record_multibyte_char(BytePos(49), 3);\n-        fm2.record_multibyte_char(BytePos(52), 3);\n-        fm2.record_multibyte_char(BytePos(57), 3);\n+        fm2.record_multibyte_char(BytePos(50), 3);\n+        fm2.record_multibyte_char(BytePos(53), 3);\n+        fm2.record_multibyte_char(BytePos(58), 3);\n \n         cm\n     }\n@@ -593,10 +605,42 @@ mod test {\n         let cp2 = cm.bytepos_to_file_charpos(BytePos(6));\n         assert_eq!(cp2, CharPos(4));\n \n-        let cp3 = cm.bytepos_to_file_charpos(BytePos(55));\n+        let cp3 = cm.bytepos_to_file_charpos(BytePos(56));\n         assert_eq!(cp3, CharPos(12));\n \n-        let cp4 = cm.bytepos_to_file_charpos(BytePos(60));\n+        let cp4 = cm.bytepos_to_file_charpos(BytePos(61));\n         assert_eq!(cp4, CharPos(15));\n     }\n+\n+    #[test]\n+    fn t7() {\n+        // Test span_to_lines for a span ending at the end of filemap\n+        let cm = init_code_map();\n+        let span = Span {lo: BytePos(12), hi: BytePos(23), expn_info: None};\n+        let file_lines = cm.span_to_lines(span);\n+\n+        assert_eq!(file_lines.file.name, ~\"blork.rs\");\n+        assert_eq!(file_lines.lines.len(), 1);\n+        assert_eq!(*file_lines.lines.get(0), 1u);\n+    }\n+\n+    #[test]\n+    fn t8() {\n+        // Test span_to_snippet for a span ending at the end of filemap\n+        let cm = init_code_map();\n+        let span = Span {lo: BytePos(12), hi: BytePos(23), expn_info: None};\n+        let snippet = cm.span_to_snippet(span);\n+\n+        assert_eq!(snippet, Some(~\"second line\"));\n+    }\n+\n+    #[test]\n+    fn t9() {\n+        // Test span_to_str for a span ending at the end of filemap\n+        let cm = init_code_map();\n+        let span = Span {lo: BytePos(12), hi: BytePos(23), expn_info: None};\n+        let sstr =  cm.span_to_str(span);\n+\n+        assert_eq!(sstr, ~\"blork.rs:2:1: 2:12\");\n+    }\n }"}]}