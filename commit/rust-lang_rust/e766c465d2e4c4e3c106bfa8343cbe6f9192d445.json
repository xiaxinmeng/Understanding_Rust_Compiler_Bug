{"sha": "e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU3NjZjNDY1ZDJlNGM0ZTNjMTA2YmZhODM0M2NiZTZmOTE5MmQ0NDU=", "commit": {"author": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2016-12-28T01:02:52Z"}, "committer": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2016-12-28T01:02:52Z"}, "message": "Merge branch 'master' into escape-reason-docs", "tree": {"sha": "821a7cf1e0b04ac9c0cddede6eb760bbf2d0ce62", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/821a7cf1e0b04ac9c0cddede6eb760bbf2d0ce62"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "html_url": "https://github.com/rust-lang/rust/commit/e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "96c52d4fd86aed6320732a511c04bcbfff7d117f", "url": "https://api.github.com/repos/rust-lang/rust/commits/96c52d4fd86aed6320732a511c04bcbfff7d117f", "html_url": "https://github.com/rust-lang/rust/commit/96c52d4fd86aed6320732a511c04bcbfff7d117f"}, {"sha": "314c28b729ae359b99586cc62c486c28e0d44424", "url": "https://api.github.com/repos/rust-lang/rust/commits/314c28b729ae359b99586cc62c486c28e0d44424", "html_url": "https://github.com/rust-lang/rust/commit/314c28b729ae359b99586cc62c486c28e0d44424"}], "stats": {"total": 29633, "additions": 19297, "deletions": 10336}, "files": [{"sha": "3a9635a86180addce75221b1465c2667ec48f92f", "filename": ".travis.yml", "status": "modified", "additions": 18, "deletions": 9, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/.travis.yml", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/.travis.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.travis.yml?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -8,6 +8,8 @@ git:\n   depth: 1\n   submodules: false\n \n+osx_image: xcode8.2\n+\n matrix:\n   include:\n     # Linux builders, all docker images\n@@ -27,28 +29,37 @@ matrix:\n     # OSX builders\n     - env: >\n         RUST_CHECK_TARGET=check\n-        RUST_CONFIGURE_ARGS=--target=x86_64-apple-darwin\n+        RUST_CONFIGURE_ARGS=--build=x86_64-apple-darwin\n         SRC=.\n       os: osx\n-      install: brew install ccache\n+      install: &osx_install_sccache >\n+        curl -L https://api.pub.build.mozilla.org/tooltool/sha512/d0025b286468cc5ada83b23d3fafbc936b9f190eaa7d4a981715b18e8e3bf720a7bcee7bfe758cfdeb8268857f6098fd52dcdd8818232692a30ce91039936596 |\n+          tar xJf - -C /usr/local/bin --strip-components=1\n     - env: >\n         RUST_CHECK_TARGET=check\n-        RUST_CONFIGURE_ARGS=--target=i686-apple-darwin\n+        RUST_CONFIGURE_ARGS=--build=i686-apple-darwin\n         SRC=.\n       os: osx\n-      install: brew install ccache\n+      install: *osx_install_sccache\n     - env: >\n         RUST_CHECK_TARGET=check\n-        RUST_CONFIGURE_ARGS=--target=x86_64-apple-darwin --disable-rustbuild\n+        RUST_CONFIGURE_ARGS=--build=x86_64-apple-darwin --disable-rustbuild\n         SRC=.\n       os: osx\n-      install: brew install ccache\n+      install: *osx_install_sccache\n     - env: >\n         RUST_CHECK_TARGET=\n         RUST_CONFIGURE_ARGS=--target=aarch64-apple-ios,armv7-apple-ios,armv7s-apple-ios,i386-apple-ios,x86_64-apple-ios\n         SRC=.\n       os: osx\n-      install: brew install ccache\n+      install: *osx_install_sccache\n+\n+env:\n+  global:\n+    - SCCACHE_BUCKET=rust-lang-ci-sccache\n+    - AWS_ACCESS_KEY_ID=AKIAIMX7VLAS3PZAVLUQ\n+    # AWS_SECRET_ACCESS_KEY=...\n+    - secure: \"Pixhh0hXDqGCdOyLtGFjli3J2AtDWIpyb2btIrLe956nCBDRutRoMm6rv5DI9sFZN07Mms7VzNNvhc9wCW1y63JAm414d2Co7Ob8kWMZlz9l9t7ACHuktUiis8yr+S4Quq1Vqd6pqi7pf2J++UxC8R/uLeqVrubzr6+X7AbmEFE=\"\n \n script:\n   - >\n@@ -77,5 +88,3 @@ notifications:\n cache:\n   directories:\n     - $HOME/docker\n-    - $HOME/.ccache\n-    - $HOME/.cargo"}, {"sha": "cdbabeaddfba8a17ee886aff226ac3461328186a", "filename": "CONTRIBUTING.md", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/CONTRIBUTING.md", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/CONTRIBUTING.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CONTRIBUTING.md?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -212,12 +212,13 @@ Some common invocations of `x.py` are:\n   & everything builds in the correct manner.\n - `x.py test src/libstd --stage 1` - test the standard library without\n   recompiling stage 2.\n-- `x.py test src/test/run-pass --filter TESTNAME` - Run a matching set of tests.\n+- `x.py test src/test/run-pass --test-args TESTNAME` - Run a matching set of\n+  tests.\n   - `TESTNAME` should be a substring of the tests to match against e.g. it could\n     be the fully qualified test name, or just a part of it.\n     `TESTNAME=collections::hash::map::test_map::test_capacity_not_less_than_len`\n     or `TESTNAME=test_capacity_not_less_than_len`.\n-- `x.py test src/test/run-pass --stage 1 --filter <substring-of-test-name>` -\n+- `x.py test src/test/run-pass --stage 1 --test-args <substring-of-test-name>` -\n   Run a single rpass test with the stage1 compiler (this will be quicker than\n   running the command above as we only build the stage1 compiler, not the entire\n   thing).  You can also leave off the directory argument to run all stage1 test\n@@ -284,7 +285,7 @@ been approved. The PR then enters the [merge queue][merge-queue], where @bors\n will run all the tests on every platform we support. If it all works out,\n @bors will merge your code into `master` and close the pull request.\n \n-[merge-queue]: http://buildbot.rust-lang.org/homu/queue/rust\n+[merge-queue]: https://buildbot.rust-lang.org/homu/queue/rust\n \n Speaking of tests, Rust has a comprehensive test suite. More information about\n it can be found\n@@ -403,4 +404,4 @@ are:\n [tlgba]: http://tomlee.co/2014/04/a-more-detailed-tour-of-the-rust-compiler/\n [ro]: http://www.rustaceans.org/\n [rctd]: ./COMPILER_TESTS.md\n-[cheatsheet]: http://buildbot.rust-lang.org/homu/\n+[cheatsheet]: https://buildbot.rust-lang.org/homu/"}, {"sha": "e85c9d18db9807891e48ceb4f3d921c76062609c", "filename": "RELEASES.md", "status": "modified", "additions": 219, "deletions": 0, "changes": 219, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/RELEASES.md", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/RELEASES.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/RELEASES.md?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -1,3 +1,222 @@\n+Version 1.14.0 (2016-12-22)\n+===========================\n+\n+Language\n+--------\n+\n+* [`..` matches multiple tuple fields in enum variants, structs\n+  and tuples][36843]. [RFC 1492].\n+* [Safe `fn` items can be coerced to `unsafe fn` pointers][37389]\n+* [`use *` and `use ::*` both glob-import from the crate root][37367]\n+* [It's now possible to call a `Vec<Box<Fn()>>` without explicit\n+  dereferencing][36822]\n+\n+Compiler\n+--------\n+\n+* [Mark enums with non-zero discriminant as non-zero][37224]\n+* [Lower-case `static mut` names are linted like other\n+  statics and consts][37162]\n+* [Fix ICE on some macros in const integer positions\n+   (e.g. `[u8; m!()]`)][36819]\n+* [Improve error message and snippet for \"did you mean `x`\"][36798]\n+* [Add a panic-strategy field to the target specification][36794]\n+* [Include LLVM version in `--version --verbose`][37200]\n+\n+Compile-time Optimizations\n+--------------------------\n+\n+* [Improve macro expansion performance][37569]\n+* [Shrink `Expr_::ExprInlineAsm`][37445]\n+* [Replace all uses of SHA-256 with BLAKE2b][37439]\n+* [Reduce the number of bytes hashed by `IchHasher`][37427]\n+* [Avoid more allocations when compiling html5ever][37373]\n+* [Use `SmallVector` in `CombineFields::instantiate`][37322]\n+* [Avoid some allocations in the macro parser][37318]\n+* [Use a faster deflate setting][37298]\n+* [Add `ArrayVec` and `AccumulateVec` to reduce heap allocations\n+  during interning of slices][37270]\n+* [Optimize `write_metadata`][37267]\n+* [Don't process obligation forest cycles when stalled][37231]\n+* [Avoid many `CrateConfig` clones][37161]\n+* [Optimize `Substs::super_fold_with`][37108]\n+* [Optimize `ObligationForest`'s `NodeState` handling][36993]\n+* [Speed up `plug_leaks`][36917]\n+\n+Libraries\n+---------\n+\n+* [`println!()`, with no arguments, prints newline][36825].\n+  Previously, an empty string was required to achieve the same.\n+* [`Wrapping` impls standard binary and unary operators, as well as\n+   the `Sum` and `Product` iterators][37356]\n+* [Implement `From<Cow<str>> for String` and `From<Cow<[T]>> for\n+  Vec<T>`][37326]\n+* [Improve `fold` performance for `chain`, `cloned`, `map`, and\n+  `VecDeque` iterators][37315]\n+* [Improve `SipHasher` performance on small values][37312]\n+* [Add Iterator trait TrustedLen to enable better FromIterator /\n+  Extend][37306]\n+* [Expand `.zip()` specialization to `.map()` and `.cloned()`][37230]\n+* [`ReadDir` implements `Debug`][37221]\n+* [Implement `RefUnwindSafe` for atomic types][37178]\n+* [Specialize `Vec::extend` to `Vec::extend_from_slice`][37094]\n+* [Avoid allocations in `Decoder::read_str`][37064]\n+* [`io::Error` implements `From<io::ErrorKind>`][37037]\n+* [Impl `Debug` for raw pointers to unsized data][36880]\n+* [Don't reuse `HashMap` random seeds][37470]\n+* [The internal memory layout of `HashMap` is more cache-friendly, for\n+  significant improvements in some operations][36692]\n+* [`HashMap` uses less memory on 32-bit architectures][36595]\n+* [Impl `Add<{str, Cow<str>}>` for `Cow<str>`][36430]\n+\n+Cargo\n+-----\n+\n+* [Expose rustc cfg values to build scripts][cargo/3243]\n+* [Allow cargo to work with read-only `CARGO_HOME`][cargo/3259]\n+* [Fix passing --features when testing multiple packages][cargo/3280]\n+* [Use a single profile set per workspace][cargo/3249]\n+* [Load `replace` sections from lock files][cargo/3220]\n+* [Ignore `panic` configuration for test/bench profiles][cargo/3175]\n+\n+Tooling\n+-------\n+\n+* [rustup is the recommended Rust installation method][1.14rustup]\n+* This release includes host (rustc) builds for Linux on MIPS, PowerPC, and\n+  S390x. These are [tier 2] platforms and may have major defects. Follow the\n+  instructions on the website to install, or add the targets to an existing\n+  installation with `rustup target add`. The new target triples are:\n+  - `mips-unknown-linux-gnu`\n+  - `mipsel-unknown-linux-gnu`\n+  - `mips64-unknown-linux-gnuabi64`\n+  - `mips64el-unknown-linux-gnuabi64 `\n+  - `powerpc-unknown-linux-gnu`\n+  - `powerpc64-unknown-linux-gnu`\n+  - `powerpc64le-unknown-linux-gnu`\n+  - `s390x-unknown-linux-gnu `\n+* This release includes target (std) builds for ARM Linux running MUSL\n+  libc. These are [tier 2] platforms and may have major defects. Add the\n+  following triples to an existing rustup installation with `rustup target add`:\n+  - `arm-unknown-linux-musleabi`\n+  - `arm-unknown-linux-musleabihf`\n+  - `armv7-unknown-linux-musleabihf`\n+* This release includes [experimental support for WebAssembly][1.14wasm], via\n+  the `wasm32-unknown-emscripten` target. This target is known to have major\n+  defects. Please test, report, and fix.\n+* rustup no longer installs documentation by default. Run `rustup\n+  component add rust-docs` to install.\n+* [Fix line stepping in debugger][37310]\n+* [Enable line number debuginfo in releases][37280]\n+\n+Misc\n+----\n+\n+* [Disable jemalloc on aarch64/powerpc/mips][37392]\n+* [Add support for Fuchsia OS][37313]\n+* [Detect local-rebuild by only MAJOR.MINOR version][37273]\n+\n+Compatibility Notes\n+-------------------\n+\n+* [A number of forward-compatibility lints used by the compiler\n+  to gradually introduce language changes have been converted\n+  to deny by default][36894]:\n+  - [\"use of inaccessible extern crate erroneously allowed\"][36886]\n+  - [\"type parameter default erroneously allowed in invalid location\"][36887]\n+  - [\"detects super or self keywords at the beginning of global path\"][36888]\n+  - [\"two overlapping inherent impls define an item with the same name\n+    were erroneously allowed\"][36889]\n+  - [\"floating-point constants cannot be used in patterns\"][36890]\n+  - [\"constants of struct or enum type can only be used in a pattern if\n+     the struct or enum has `#[derive(PartialEq, Eq)]`\"][36891]\n+  - [\"lifetimes or labels named `'_` were erroneously allowed\"][36892]\n+* [Prohibit patterns in trait methods without bodies][37378]\n+* [The atomic `Ordering` enum may not be matched exhaustively][37351]\n+* [Future-proofing `#[no_link]` breaks some obscure cases][37247]\n+* [The `$crate` macro variable is accepted in fewer locations][37213]\n+* [Impls specifying extra region requirements beyond the trait\n+  they implement are rejected][37167]\n+* [Enums may not be unsized][37111]. Unsized enums are intended to\n+  work but never have. For now they are forbidden.\n+* [Enforce the shadowing restrictions from RFC 1560 for today's macros][36767]\n+\n+[tier 2]: https://forge.rust-lang.org/platform-support.html\n+[1.14rustup]: https://internals.rust-lang.org/t/beta-testing-rustup-rs/3316/204\n+[1.14wasm]: https://users.rust-lang.org/t/compiling-to-the-web-with-rust-and-emscripten/7627\n+[36430]: https://github.com/rust-lang/rust/pull/36430\n+[36595]: https://github.com/rust-lang/rust/pull/36595\n+[36595]: https://github.com/rust-lang/rust/pull/36595\n+[36692]: https://github.com/rust-lang/rust/pull/36692\n+[36767]: https://github.com/rust-lang/rust/pull/36767\n+[36794]: https://github.com/rust-lang/rust/pull/36794\n+[36798]: https://github.com/rust-lang/rust/pull/36798\n+[36819]: https://github.com/rust-lang/rust/pull/36819\n+[36822]: https://github.com/rust-lang/rust/pull/36822\n+[36825]: https://github.com/rust-lang/rust/pull/36825\n+[36843]: https://github.com/rust-lang/rust/pull/36843\n+[36880]: https://github.com/rust-lang/rust/pull/36880\n+[36886]: https://github.com/rust-lang/rust/issues/36886\n+[36887]: https://github.com/rust-lang/rust/issues/36887\n+[36888]: https://github.com/rust-lang/rust/issues/36888\n+[36889]: https://github.com/rust-lang/rust/issues/36889\n+[36890]: https://github.com/rust-lang/rust/issues/36890\n+[36891]: https://github.com/rust-lang/rust/issues/36891\n+[36892]: https://github.com/rust-lang/rust/issues/36892\n+[36894]: https://github.com/rust-lang/rust/pull/36894\n+[36917]: https://github.com/rust-lang/rust/pull/36917\n+[36993]: https://github.com/rust-lang/rust/pull/36993\n+[37037]: https://github.com/rust-lang/rust/pull/37037\n+[37064]: https://github.com/rust-lang/rust/pull/37064\n+[37094]: https://github.com/rust-lang/rust/pull/37094\n+[37108]: https://github.com/rust-lang/rust/pull/37108\n+[37111]: https://github.com/rust-lang/rust/pull/37111\n+[37161]: https://github.com/rust-lang/rust/pull/37161\n+[37162]: https://github.com/rust-lang/rust/pull/37162\n+[37167]: https://github.com/rust-lang/rust/pull/37167\n+[37178]: https://github.com/rust-lang/rust/pull/37178\n+[37200]: https://github.com/rust-lang/rust/pull/37200\n+[37213]: https://github.com/rust-lang/rust/pull/37213\n+[37221]: https://github.com/rust-lang/rust/pull/37221\n+[37224]: https://github.com/rust-lang/rust/pull/37224\n+[37230]: https://github.com/rust-lang/rust/pull/37230\n+[37231]: https://github.com/rust-lang/rust/pull/37231\n+[37247]: https://github.com/rust-lang/rust/pull/37247\n+[37267]: https://github.com/rust-lang/rust/pull/37267\n+[37270]: https://github.com/rust-lang/rust/pull/37270\n+[37273]: https://github.com/rust-lang/rust/pull/37273\n+[37280]: https://github.com/rust-lang/rust/pull/37280\n+[37298]: https://github.com/rust-lang/rust/pull/37298\n+[37306]: https://github.com/rust-lang/rust/pull/37306\n+[37310]: https://github.com/rust-lang/rust/pull/37310\n+[37312]: https://github.com/rust-lang/rust/pull/37312\n+[37313]: https://github.com/rust-lang/rust/pull/37313\n+[37315]: https://github.com/rust-lang/rust/pull/37315\n+[37318]: https://github.com/rust-lang/rust/pull/37318\n+[37322]: https://github.com/rust-lang/rust/pull/37322\n+[37326]: https://github.com/rust-lang/rust/pull/37326\n+[37351]: https://github.com/rust-lang/rust/pull/37351\n+[37356]: https://github.com/rust-lang/rust/pull/37356\n+[37367]: https://github.com/rust-lang/rust/pull/37367\n+[37373]: https://github.com/rust-lang/rust/pull/37373\n+[37378]: https://github.com/rust-lang/rust/pull/37378\n+[37389]: https://github.com/rust-lang/rust/pull/37389\n+[37392]: https://github.com/rust-lang/rust/pull/37392\n+[37427]: https://github.com/rust-lang/rust/pull/37427\n+[37439]: https://github.com/rust-lang/rust/pull/37439\n+[37445]: https://github.com/rust-lang/rust/pull/37445\n+[37470]: https://github.com/rust-lang/rust/pull/37470\n+[37569]: https://github.com/rust-lang/rust/pull/37569\n+[RFC 1492]: https://github.com/rust-lang/rfcs/blob/master/text/1492-dotdot-in-patterns.md\n+[cargo/3175]: https://github.com/rust-lang/cargo/pull/3175\n+[cargo/3220]: https://github.com/rust-lang/cargo/pull/3220\n+[cargo/3243]: https://github.com/rust-lang/cargo/pull/3243\n+[cargo/3249]: https://github.com/rust-lang/cargo/pull/3249\n+[cargo/3259]: https://github.com/rust-lang/cargo/pull/3259\n+[cargo/3280]: https://github.com/rust-lang/cargo/pull/3280\n+\n+\n Version 1.13.0 (2016-11-10)\n ===========================\n "}, {"sha": "cb3b50cbaeff24734345a44270d19ad343e17831", "filename": "appveyor.yml", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/appveyor.yml", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/appveyor.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/appveyor.yml?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -1,4 +1,9 @@\n environment:\n+  SCCACHE_BUCKET: rust-lang-ci-sccache\n+  AWS_ACCESS_KEY_ID: AKIAIMX7VLAS3PZAVLUQ\n+  AWS_SECRET_ACCESS_KEY:\n+    secure: 1UkmbiDd15tWtYbMm5O2Uqm0b0Ur8v1MoSlydxl4ojcroPeerRMlUges0l57py8c\n+  SCCACHE_DIGEST: f808afabb4a4eb1d7112bcb3fa6be03b61e93412890c88e177c667eb37f46353d7ec294e559b16f9f4b5e894f2185fe7670a0df15fd064889ecbd80f0c34166c\n   matrix:\n   # 32/64 bit MSVC\n   - MSYS_BITS: 64\n@@ -84,6 +89,13 @@ install:\n   # Otherwise pull in the MinGW installed on appveyor\n   - if NOT defined MINGW_URL set PATH=C:\\msys64\\mingw%MSYS_BITS%\\bin;C:\\msys64\\usr\\bin;%PATH%\n \n+  # Download and install sccache\n+  - appveyor DownloadFile https://api.pub.build.mozilla.org/tooltool/sha512/%SCCACHE_DIGEST%\n+  - mv %SCCACHE_DIGEST% sccache.tar.bz2\n+  - 7z x -y sccache.tar.bz2 > nul\n+  - 7z x -y sccache.tar > nul\n+  - set PATH=%PATH%;%CD%\\sccache2\n+\n test_script:\n   - git submodule update --init\n   - set SRC=."}, {"sha": "4f1e8f656ae22418ba18f942d48bff588935673f", "filename": "configure", "status": "modified", "additions": 29, "deletions": 4, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/configure", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/configure", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/configure?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -621,6 +621,7 @@ opt llvm-assertions 0 \"build LLVM with assertions\"\n opt debug-assertions 0 \"build with debugging assertions\"\n opt fast-make 0 \"use .gitmodules as timestamp for submodule deps\"\n opt ccache 0 \"invoke gcc/clang via ccache to reuse object files between builds\"\n+opt sccache 0 \"invoke gcc/clang via sccache to reuse object files between builds\"\n opt local-rust 0 \"use an installed rustc rather than downloading a snapshot\"\n opt local-rebuild 0 \"assume local-rust matches the current version, for rebuilds; implies local-rust, and is implied if local-rust already matches the current version\"\n opt llvm-static-stdcpp 0 \"statically link to libstdc++ for LLVM\"\n@@ -916,6 +917,18 @@ case $CFG_BUILD in\n esac\n putvar CFG_LLDB_PYTHON\n \n+# Do some sanity checks if running on buildbot\n+# (these env vars are set by rust-buildbot)\n+if [ -n \"$RUST_DIST_SERVER\" -a -n \"$ALLOW_NONZERO_RLIMIT_CORE\" ]; then\n+   # Frequently the llvm submodule directory is broken by the build\n+   # being killed\n+   llvm_lock=\"${CFG_SRC_DIR}/.git/modules/src/llvm/index.lock\"\n+   if [ -e \"$llvm_lock\" ]; then\n+       step_msg \"removing $llvm_lock\"\n+       rm -f \"$llvm_lock\"\n+   fi\n+fi\n+\n step_msg \"looking for target specific programs\"\n \n probe CFG_ADB        adb\n@@ -1677,11 +1690,23 @@ do\n             LLVM_CC_64_ARG1=\"gcc\"\n             ;;\n         (\"gcc\")\n-            LLVM_CXX_32=\"g++\"\n-            LLVM_CC_32=\"gcc\"\n+            if [ -z \"$CFG_ENABLE_SCCACHE\" ]; then\n+                LLVM_CXX_32=\"g++\"\n+                LLVM_CC_32=\"gcc\"\n \n-            LLVM_CXX_64=\"g++\"\n-            LLVM_CC_64=\"gcc\"\n+                LLVM_CXX_64=\"g++\"\n+                LLVM_CC_64=\"gcc\"\n+            else\n+                LLVM_CXX_32=\"sccache\"\n+                LLVM_CC_32=\"sccache\"\n+                LLVM_CXX_32_ARG1=\"g++\"\n+                LLVM_CC_32_ARG1=\"gcc\"\n+\n+                LLVM_CXX_64=\"sccache\"\n+                LLVM_CC_64=\"sccache\"\n+                LLVM_CXX_64_ARG1=\"g++\"\n+                LLVM_CC_64_ARG1=\"gcc\"\n+            fi\n             ;;\n \n         (*)"}, {"sha": "34aee77ae2107fbe45fcb960d74d2ffdd5c57bf1", "filename": "mk/cfg/x86_64-unknown-redox.mk", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/mk%2Fcfg%2Fx86_64-unknown-redox.mk", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/mk%2Fcfg%2Fx86_64-unknown-redox.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Fx86_64-unknown-redox.mk?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -0,0 +1 @@\n+# rustbuild-only target"}, {"sha": "d01ec07b4244e665b076c540969ecc5b22d6f9f7", "filename": "mk/main.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/mk%2Fmain.mk", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/mk%2Fmain.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fmain.mk?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -13,7 +13,7 @@\n ######################################################################\n \n # The version number\n-CFG_RELEASE_NUM=1.15.0\n+CFG_RELEASE_NUM=1.16.0\n \n # An optional number to put after the label, e.g. '.2' -> '-beta.2'\n # NB Make sure it starts with a dot to conform to semver pre-release"}, {"sha": "3317688f042a2049ed3c19cb6379e4f8234c4831", "filename": "mk/tests.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/mk%2Ftests.mk", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/mk%2Ftests.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftests.mk?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -22,7 +22,7 @@ $(eval $(call RUST_CRATE,coretest))\n DEPS_collectionstest :=\n $(eval $(call RUST_CRATE,collectionstest))\n \n-TEST_TARGET_CRATES = $(filter-out core rustc_unicode alloc_system libc \\\n+TEST_TARGET_CRATES = $(filter-out core std_unicode alloc_system libc \\\n \t\t     \t\t  alloc_jemalloc panic_unwind \\\n \t\t\t\t  panic_abort,$(TARGET_CRATES)) \\\n \t\t\tcollectionstest coretest"}, {"sha": "9cd77e71b82dde04638ee53c04353b5ced783024", "filename": "src/Cargo.lock", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -19,7 +19,7 @@ version = \"0.0.0\"\n dependencies = [\n  \"build_helper 0.1.0\",\n  \"core 0.0.0\",\n- \"gcc 0.3.38 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"gcc 0.3.40 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libc 0.0.0\",\n ]\n \n@@ -42,7 +42,7 @@ dependencies = [\n  \"build_helper 0.1.0\",\n  \"cmake 0.1.18 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"filetime 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"gcc 0.3.38 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"gcc 0.3.40 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"getopts 0.2.14 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libc 0.2.17 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"num_cpus 0.2.13 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -63,7 +63,7 @@ name = \"cmake\"\n version = \"0.1.18\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"gcc 0.3.38 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"gcc 0.3.40 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -80,7 +80,7 @@ name = \"compiler_builtins\"\n version = \"0.0.0\"\n dependencies = [\n  \"core 0.0.0\",\n- \"gcc 0.3.38 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"gcc 0.3.40 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -121,7 +121,7 @@ name = \"flate\"\n version = \"0.0.0\"\n dependencies = [\n  \"build_helper 0.1.0\",\n- \"gcc 0.3.38 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"gcc 0.3.40 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -130,7 +130,7 @@ version = \"0.0.0\"\n \n [[package]]\n name = \"gcc\"\n-version = \"0.3.38\"\n+version = \"0.3.40\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n@@ -402,7 +402,7 @@ name = \"rustc_llvm\"\n version = \"0.0.0\"\n dependencies = [\n  \"build_helper 0.1.0\",\n- \"gcc 0.3.38 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"gcc 0.3.40 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc_bitflags 0.0.0\",\n ]\n \n@@ -551,7 +551,7 @@ version = \"0.0.0\"\n dependencies = [\n  \"arena 0.0.0\",\n  \"build_helper 0.1.0\",\n- \"gcc 0.3.38 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"gcc 0.3.40 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.0.0\",\n  \"rustc 0.0.0\",\n  \"rustc_back 0.0.0\",\n@@ -587,7 +587,7 @@ dependencies = [\n  \"collections 0.0.0\",\n  \"compiler_builtins 0.0.0\",\n  \"core 0.0.0\",\n- \"gcc 0.3.38 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"gcc 0.3.40 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libc 0.0.0\",\n  \"panic_abort 0.0.0\",\n  \"panic_unwind 0.0.0\",\n@@ -677,7 +677,7 @@ dependencies = [\n \"checksum cmake 0.1.18 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0e5bcf27e097a184c1df4437654ed98df3d7a516e8508a6ba45d8b092bbdf283\"\n \"checksum env_logger 0.3.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"15abd780e45b3ea4f76b4e9a26ff4843258dd8a3eed2775a0e7368c2e7936c2f\"\n \"checksum filetime 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\" = \"5363ab8e4139b8568a6237db5248646e5a8a2f89bd5ccb02092182b11fd3e922\"\n-\"checksum gcc 0.3.38 (registry+https://github.com/rust-lang/crates.io-index)\" = \"553f11439bdefe755bf366b264820f1da70f3aaf3924e594b886beb9c831bcf5\"\n+\"checksum gcc 0.3.40 (registry+https://github.com/rust-lang/crates.io-index)\" = \"872db9e59486ef2b14f8e8c10e9ef02de2bccef6363d7f34835dedb386b3d950\"\n \"checksum getopts 0.2.14 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d9047cfbd08a437050b363d35ef160452c5fe8ea5187ae0a624708c91581d685\"\n \"checksum libc 0.2.17 (registry+https://github.com/rust-lang/crates.io-index)\" = \"044d1360593a78f5c8e5e710beccdc24ab71d1f01bc19a29bcacdba22e8475d8\"\n \"checksum log 0.3.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ab83497bf8bf4ed2a74259c1c802351fcd67a65baa86394b6ba73c36f4838054\""}, {"sha": "ac84edb4038470445bdc7e56b93ade654fa4c18b", "filename": "src/bootstrap/README.md", "status": "modified", "additions": 47, "deletions": 2, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Fbootstrap%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Fbootstrap%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2FREADME.md?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -22,7 +22,7 @@ Note that if you're on Unix you should be able to execute the script directly:\n ./x.py build\n ```\n \n-The script accepts commands, flags, and filters to determine what to do:\n+The script accepts commands, flags, and arguments to determine what to do:\n \n * `build` - a general purpose command for compiling code. Alone `build` will\n   bootstrap the entire compiler, and otherwise arguments passed indicate what to\n@@ -42,6 +42,15 @@ The script accepts commands, flags, and filters to determine what to do:\n   ./x.py build --stage 0 src/libtest\n   ```\n \n+  If files are dirty that would normally be rebuilt from stage 0, that can be\n+  overidden using `--keep-stage 0`. Using `--keep-stage n` will skip all steps\n+  that belong to stage n or earlier:\n+\n+  ```\n+  # keep old build products for stage 0 and build stage 1\n+  ./x.py build --keep-stage 0 --stage 1\n+  ```\n+\n * `test` - a command for executing unit tests. Like the `build` command this\n   will execute the entire test suite by default, and otherwise it can be used to\n   select which test suite is run:\n@@ -54,7 +63,7 @@ The script accepts commands, flags, and filters to determine what to do:\n   ./x.py test src/test/run-pass\n \n   # execute only some tests in the run-pass test suite\n-  ./x.py test src/test/run-pass --filter my-filter\n+  ./x.py test src/test/run-pass --test-args substring-of-test-name\n \n   # execute tests in the standard library in stage0\n   ./x.py test --stage 0 src/libstd\n@@ -107,6 +116,42 @@ compiler. What actually happens when you invoke rustbuild is:\n The goal of each stage is to (a) leverage Cargo as much as possible and failing\n that (b) leverage Rust as much as possible!\n \n+## Incremental builds\n+\n+You can configure rustbuild to use incremental compilation. Because\n+incremental is new and evolving rapidly, if you want to use it, it is\n+recommended that you replace the snapshot with a locally installed\n+nightly build of rustc. You will want to keep this up to date.\n+\n+To follow this course of action, first thing you will want to do is to\n+install a nightly, presumably using `rustup`. You will then want to\n+configure your directory to use this build, like so:\n+\n+```\n+# configure to use local rust instead of downloding a beta.\n+# `--local-rust-root` is optional here. If elided, we will\n+# use whatever rustc we find on your PATH.\n+> configure --enable-rustbuild --local-rust-root=~/.cargo/ --enable-local-rebuild\n+```\n+\n+After that, you can use the `--incremental` flag to actually do\n+incremental builds:\n+\n+```\n+> ../x.py build --incremental\n+```\n+\n+The `--incremental` flag will store incremental compilation artifacts\n+in `build/<host>/stage0-incremental`. Note that we only use incremental\n+compilation for the stage0 -> stage1 compilation -- this is because\n+the stage1 compiler is changing, and we don't try to cache and reuse\n+incremental artifacts across different versions of the compiler. For\n+this reason, `--incremental` defaults to `--stage 1` (though you can\n+manually select a higher stage, if you prefer).\n+\n+You can always drop the `--incremental` to build as normal (but you\n+will still be using the local nightly as your bootstrap).\n+\n ## Directory Layout\n \n This build system houses all output under the `build` directory, which looks"}, {"sha": "9cab6c423f5f98d1df57071a9d2019ea72a0db43", "filename": "src/bootstrap/bin/rustc.rs", "status": "modified", "additions": 52, "deletions": 3, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Fbootstrap%2Fbin%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Fbootstrap%2Fbin%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbin%2Frustc.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -25,12 +25,17 @@\n //! switching compilers for the bootstrap and for build scripts will probably\n //! never get replaced.\n \n+#![deny(warnings)]\n+\n extern crate bootstrap;\n \n use std::env;\n use std::ffi::OsString;\n+use std::io;\n+use std::io::prelude::*;\n+use std::str::FromStr;\n use std::path::PathBuf;\n-use std::process::Command;\n+use std::process::{Command, ExitStatus};\n \n fn main() {\n     let args = env::args_os().skip(1).collect::<Vec<_>>();\n@@ -41,6 +46,11 @@ fn main() {\n         .and_then(|w| w[1].to_str());\n     let version = args.iter().find(|w| &**w == \"-vV\");\n \n+    let verbose = match env::var(\"RUSTC_VERBOSE\") {\n+        Ok(s) => usize::from_str(&s).expect(\"RUSTC_VERBOSE should be an integer\"),\n+        Err(_) => 0,\n+    };\n+\n     // Build scripts always use the snapshot compiler which is guaranteed to be\n     // able to produce an executable, whereas intermediate compilers may not\n     // have the standard library built yet and may not be able to produce an\n@@ -95,6 +105,15 @@ fn main() {\n             cmd.args(&s.split(\" \").filter(|s| !s.is_empty()).collect::<Vec<_>>());\n         }\n \n+        // Pass down incremental directory, if any.\n+        if let Ok(dir) = env::var(\"RUSTC_INCREMENTAL\") {\n+            cmd.arg(format!(\"-Zincremental={}\", dir));\n+\n+            if verbose > 0 {\n+                cmd.arg(\"-Zincremental-info\");\n+            }\n+        }\n+\n         // If we're compiling specifically the `panic_abort` crate then we pass\n         // the `-C panic=abort` option. Note that we do not do this for any\n         // other crate intentionally as this is the only crate for now that we\n@@ -158,6 +177,15 @@ fn main() {\n         // to change a flag in a binary?\n         if env::var(\"RUSTC_RPATH\") == Ok(\"true\".to_string()) {\n             let rpath = if target.contains(\"apple\") {\n+\n+                // Note that we need to take one extra step on OSX to also pass\n+                // `-Wl,-instal_name,@rpath/...` to get things to work right. To\n+                // do that we pass a weird flag to the compiler to get it to do\n+                // so. Note that this is definitely a hack, and we should likely\n+                // flesh out rpath support more fully in the future.\n+                if stage != \"0\" {\n+                    cmd.arg(\"-Z\").arg(\"osx-rpath-install-name\");\n+                }\n                 Some(\"-Wl,-rpath,@loader_path/../lib\")\n             } else if !target.contains(\"windows\") {\n                 Some(\"-Wl,-rpath,$ORIGIN/../lib\")\n@@ -167,12 +195,33 @@ fn main() {\n             if let Some(rpath) = rpath {\n                 cmd.arg(\"-C\").arg(format!(\"link-args={}\", rpath));\n             }\n+\n+            if let Ok(s) = env::var(\"RUSTFLAGS\") {\n+                for flag in s.split_whitespace() {\n+                    cmd.arg(flag);\n+                }\n+            }\n         }\n     }\n \n+    if verbose > 1 {\n+        writeln!(&mut io::stderr(), \"rustc command: {:?}\", cmd).unwrap();\n+    }\n+\n     // Actually run the compiler!\n-    std::process::exit(match cmd.status() {\n-        Ok(s) => s.code().unwrap_or(1),\n+    std::process::exit(match exec_cmd(&mut cmd) {\n+        Ok(s) => s.code().unwrap_or(0xfe),\n         Err(e) => panic!(\"\\n\\nfailed to run {:?}: {}\\n\\n\", cmd, e),\n     })\n }\n+\n+#[cfg(unix)]\n+fn exec_cmd(cmd: &mut Command) -> ::std::io::Result<ExitStatus> {\n+    use std::os::unix::process::CommandExt;\n+    Err(cmd.exec())\n+}\n+\n+#[cfg(not(unix))]\n+fn exec_cmd(cmd: &mut Command) -> ::std::io::Result<ExitStatus> {\n+    cmd.status()\n+}"}, {"sha": "a53bbe22eb94cbd9a2c5adfe2cdb20dec667d0dc", "filename": "src/bootstrap/bin/rustdoc.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Fbootstrap%2Fbin%2Frustdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Fbootstrap%2Fbin%2Frustdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbin%2Frustdoc.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -12,6 +12,8 @@\n //!\n //! See comments in `src/bootstrap/rustc.rs` for more information.\n \n+#![deny(warnings)]\n+\n extern crate bootstrap;\n \n use std::env;"}, {"sha": "89d297760e2864c8345b876d87112be2fb5c2998", "filename": "src/bootstrap/bootstrap.py", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Fbootstrap%2Fbootstrap.py", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Fbootstrap%2Fbootstrap.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbootstrap.py?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -81,7 +81,7 @@ def verify(path, sha_path, verbose):\n     with open(path, \"rb\") as f:\n         found = hashlib.sha256(f.read()).hexdigest()\n     with open(sha_path, \"r\") as f:\n-        expected, _ = f.readline().split()\n+        expected = f.readline().split()[0]\n     verified = found == expected\n     if not verified:\n         print(\"invalid checksum:\\n\"\n@@ -146,7 +146,7 @@ class RustBuild(object):\n     def download_stage0(self):\n         cache_dst = os.path.join(self.build_dir, \"cache\")\n         rustc_cache = os.path.join(cache_dst, self.stage0_rustc_date())\n-        cargo_cache = os.path.join(cache_dst, self.stage0_cargo_date())\n+        cargo_cache = os.path.join(cache_dst, self.stage0_cargo_rev())\n         if not os.path.exists(rustc_cache):\n             os.makedirs(rustc_cache)\n         if not os.path.exists(cargo_cache):\n@@ -179,21 +179,17 @@ def download_stage0(self):\n         if self.cargo().startswith(self.bin_root()) and \\\n                 (not os.path.exists(self.cargo()) or self.cargo_out_of_date()):\n             self.print_what_it_means_to_bootstrap()\n-            channel = self.stage0_cargo_channel()\n-            filename = \"cargo-{}-{}.tar.gz\".format(channel, self.build)\n-            url = \"https://static.rust-lang.org/cargo-dist/\" + self.stage0_cargo_date()\n+            filename = \"cargo-nightly-{}.tar.gz\".format(self.build)\n+            url = \"https://s3.amazonaws.com/rust-lang-ci/cargo-builds/\" + self.stage0_cargo_rev()\n             tarball = os.path.join(cargo_cache, filename)\n             if not os.path.exists(tarball):\n                 get(\"{}/{}\".format(url, filename), tarball, verbose=self.verbose)\n             unpack(tarball, self.bin_root(), match=\"cargo\", verbose=self.verbose)\n             with open(self.cargo_stamp(), 'w') as f:\n-                f.write(self.stage0_cargo_date())\n+                f.write(self.stage0_cargo_rev())\n \n-    def stage0_cargo_date(self):\n-        return self._cargo_date\n-\n-    def stage0_cargo_channel(self):\n-        return self._cargo_channel\n+    def stage0_cargo_rev(self):\n+        return self._cargo_rev\n \n     def stage0_rustc_date(self):\n         return self._rustc_date\n@@ -217,7 +213,7 @@ def cargo_out_of_date(self):\n         if not os.path.exists(self.cargo_stamp()) or self.clean:\n             return True\n         with open(self.cargo_stamp(), 'r') as f:\n-            return self.stage0_cargo_date() != f.read()\n+            return self.stage0_cargo_rev() != f.read()\n \n     def bin_root(self):\n         return os.path.join(self.build_dir, self.build, \"stage0\")\n@@ -294,6 +290,8 @@ def build_bootstrap(self):\n         env[\"DYLD_LIBRARY_PATH\"] = os.path.join(self.bin_root(), \"lib\")\n         env[\"PATH\"] = os.path.join(self.bin_root(), \"bin\") + \\\n                       os.pathsep + env[\"PATH\"]\n+        if not os.path.isfile(self.cargo()):\n+            raise Exception(\"no cargo executable found at `%s`\" % self.cargo())\n         args = [self.cargo(), \"build\", \"--manifest-path\",\n                 os.path.join(self.rust_root, \"src/bootstrap/Cargo.toml\")]\n         if self.use_vendored_sources:\n@@ -467,7 +465,7 @@ def main():\n \n     data = stage0_data(rb.rust_root)\n     rb._rustc_channel, rb._rustc_date = data['rustc'].split('-', 1)\n-    rb._cargo_channel, rb._cargo_date = data['cargo'].split('-', 1)\n+    rb._cargo_rev = data['cargo']\n \n     start_time = time()\n "}, {"sha": "c38bb33aa02b124f62aa78d7bd715cd66e12bd0d", "filename": "src/bootstrap/channel.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Fbootstrap%2Fchannel.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Fbootstrap%2Fchannel.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fchannel.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -15,7 +15,7 @@\n //! `package_vers`, and otherwise indicating to the compiler what it should\n //! print out as part of its version information.\n \n-use std::fs::{self, File};\n+use std::fs::File;\n use std::io::prelude::*;\n use std::process::Command;\n \n@@ -69,7 +69,7 @@ pub fn collect(build: &mut Build) {\n \n     // If we have a git directory, add in some various SHA information of what\n     // commit this compiler was compiled from.\n-    if fs::metadata(build.src.join(\".git\")).is_ok() {\n+    if build.src.join(\".git\").is_dir() {\n         let ver_date = output(Command::new(\"git\").current_dir(&build.src)\n                                       .arg(\"log\").arg(\"-1\")\n                                       .arg(\"--date=short\")"}, {"sha": "e7b0afeb8ce630447d596704c771aa8656922cc9", "filename": "src/bootstrap/check.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Fbootstrap%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Fbootstrap%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcheck.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -13,6 +13,8 @@\n //! This file implements the various regression test suites that we execute on\n //! our CI.\n \n+extern crate build_helper;\n+\n use std::collections::HashSet;\n use std::env;\n use std::fmt;\n@@ -190,7 +192,7 @@ pub fn compiletest(build: &Build,\n \n     cmd.args(&build.flags.cmd.test_args());\n \n-    if build.config.verbose || build.flags.verbose {\n+    if build.config.verbose() || build.flags.verbose() {\n         cmd.arg(\"--verbose\");\n     }\n \n@@ -299,6 +301,7 @@ fn markdown_test(build: &Build, compiler: &Compiler, markdown: &Path) {\n     build.add_rust_test_threads(&mut cmd);\n     cmd.arg(\"--test\");\n     cmd.arg(markdown);\n+    cmd.env(\"RUSTC_BOOTSTRAP\", \"1\");\n \n     let mut test_args = build.flags.cmd.test_args().join(\" \");\n     if build.config.quiet_tests {\n@@ -542,7 +545,7 @@ pub fn distcheck(build: &Build) {\n     build.run(&mut cmd);\n     build.run(Command::new(\"./configure\")\n                      .current_dir(&dir));\n-    build.run(Command::new(\"make\")\n+    build.run(Command::new(build_helper::make(&build.config.build))\n                      .arg(\"check\")\n                      .current_dir(&dir));\n }"}, {"sha": "6b86e537b7d22098e8e2b2e47e1a77e8a04acd2f", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 50, "deletions": 5, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -38,9 +38,9 @@ use util::push_exe_path;\n /// `src/bootstrap/config.toml.example`.\n #[derive(Default)]\n pub struct Config {\n-    pub ccache: bool,\n+    pub ccache: Option<String>,\n     pub ninja: bool,\n-    pub verbose: bool,\n+    pub verbose: usize,\n     pub submodules: bool,\n     pub compiler_docs: bool,\n     pub docs: bool,\n@@ -113,6 +113,7 @@ pub struct Target {\n #[derive(RustcDecodable, Default)]\n struct TomlConfig {\n     build: Option<Build>,\n+    install: Option<Install>,\n     llvm: Option<Llvm>,\n     rust: Option<Rust>,\n     target: Option<HashMap<String, TomlTarget>>,\n@@ -135,10 +136,16 @@ struct Build {\n     python: Option<String>,\n }\n \n+/// TOML representation of various global install decisions.\n+#[derive(RustcDecodable, Default, Clone)]\n+struct Install {\n+    prefix: Option<String>,\n+}\n+\n /// TOML representation of how the LLVM build is configured.\n #[derive(RustcDecodable, Default)]\n struct Llvm {\n-    ccache: Option<bool>,\n+    ccache: Option<StringOrBool>,\n     ninja: Option<bool>,\n     assertions: Option<bool>,\n     optimize: Option<bool>,\n@@ -147,6 +154,18 @@ struct Llvm {\n     static_libstdcpp: Option<bool>,\n }\n \n+#[derive(RustcDecodable)]\n+enum StringOrBool {\n+    String(String),\n+    Bool(bool),\n+}\n+\n+impl Default for StringOrBool {\n+    fn default() -> StringOrBool {\n+        StringOrBool::Bool(false)\n+    }\n+}\n+\n /// TOML representation of how the Rust build is configured.\n #[derive(RustcDecodable, Default)]\n struct Rust {\n@@ -246,15 +265,28 @@ impl Config {\n         set(&mut config.submodules, build.submodules);\n         set(&mut config.vendor, build.vendor);\n \n+        if let Some(ref install) = toml.install {\n+            config.prefix = install.prefix.clone();\n+        }\n+\n         if let Some(ref llvm) = toml.llvm {\n-            set(&mut config.ccache, llvm.ccache);\n+            match llvm.ccache {\n+                Some(StringOrBool::String(ref s)) => {\n+                    config.ccache = Some(s.to_string())\n+                }\n+                Some(StringOrBool::Bool(true)) => {\n+                    config.ccache = Some(\"ccache\".to_string());\n+                }\n+                Some(StringOrBool::Bool(false)) | None => {}\n+            }\n             set(&mut config.ninja, llvm.ninja);\n             set(&mut config.llvm_assertions, llvm.assertions);\n             set(&mut config.llvm_optimize, llvm.optimize);\n             set(&mut config.llvm_release_debuginfo, llvm.release_debuginfo);\n             set(&mut config.llvm_version_check, llvm.version_check);\n             set(&mut config.llvm_static_stdcpp, llvm.static_libstdcpp);\n         }\n+\n         if let Some(ref rust) = toml.rust {\n             set(&mut config.rust_debug_assertions, rust.debug_assertions);\n             set(&mut config.rust_debuginfo, rust.debuginfo);\n@@ -338,7 +370,6 @@ impl Config {\n             }\n \n             check! {\n-                (\"CCACHE\", self.ccache),\n                 (\"MANAGE_SUBMODULES\", self.submodules),\n                 (\"COMPILER_DOCS\", self.compiler_docs),\n                 (\"DOCS\", self.docs),\n@@ -475,10 +506,24 @@ impl Config {\n                     let path = parse_configure_path(value);\n                     self.python = Some(path);\n                 }\n+                \"CFG_ENABLE_CCACHE\" if value == \"1\" => {\n+                    self.ccache = Some(\"ccache\".to_string());\n+                }\n+                \"CFG_ENABLE_SCCACHE\" if value == \"1\" => {\n+                    self.ccache = Some(\"sccache\".to_string());\n+                }\n                 _ => {}\n             }\n         }\n     }\n+\n+    pub fn verbose(&self) -> bool {\n+        self.verbose > 0\n+    }\n+\n+    pub fn very_verbose(&self) -> bool {\n+        self.verbose > 1\n+    }\n }\n \n #[cfg(not(windows))]"}, {"sha": "5fc095137c793e0101d102ae64b22790ed3a29bd", "filename": "src/bootstrap/config.toml.example", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Fbootstrap%2Fconfig.toml.example", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Fbootstrap%2Fconfig.toml.example", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.toml.example?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -25,6 +25,8 @@\n \n # Indicates whether ccache is used when building LLVM\n #ccache = false\n+# or alternatively ...\n+#ccache = \"/path/to/ccache\"\n \n # If an external LLVM root is specified, we automatically check the version by\n # default to make sure it's within the range that we're expecting, but setting\n@@ -98,6 +100,14 @@\n # Indicate whether the vendored sources are used for Rust dependencies or not\n #vendor = false\n \n+# =============================================================================\n+# General install configuration options\n+# =============================================================================\n+[install]\n+\n+# Instead of installing to /usr/local, install to this path instead.\n+#prefix = \"/path/to/install\"\n+\n # =============================================================================\n # Options for compiling Rust code itself\n # ============================================================================="}, {"sha": "6e3174ed2f6d00cc6939c9f61f96414fe9634dd2", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 27, "deletions": 9, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -48,6 +48,11 @@ pub fn tmpdir(build: &Build) -> PathBuf {\n /// Slurps up documentation from the `stage`'s `host`.\n pub fn docs(build: &Build, stage: u32, host: &str) {\n     println!(\"Dist docs stage{} ({})\", stage, host);\n+    if !build.config.docs {\n+        println!(\"\\tskipping - docs disabled\");\n+        return\n+    }\n+\n     let name = format!(\"rust-docs-{}\", package_vers(build));\n     let image = tmpdir(build).join(format!(\"{}-{}-image\", name, name));\n     let _ = fs::remove_dir_all(&image);\n@@ -92,6 +97,7 @@ pub fn mingw(build: &Build, host: &str) {\n     let name = format!(\"rust-mingw-{}\", package_vers(build));\n     let image = tmpdir(build).join(format!(\"{}-{}-image\", name, host));\n     let _ = fs::remove_dir_all(&image);\n+    t!(fs::create_dir_all(&image));\n \n     // The first argument to the script is a \"temporary directory\" which is just\n     // thrown away (this contains the runtime DLLs included in the rustc package\n@@ -260,6 +266,14 @@ pub fn debugger_scripts(build: &Build,\n pub fn std(build: &Build, compiler: &Compiler, target: &str) {\n     println!(\"Dist std stage{} ({} -> {})\", compiler.stage, compiler.host,\n              target);\n+\n+    // The only true set of target libraries came from the build triple, so\n+    // let's reduce redundant work by only producing archives from that host.\n+    if compiler.host != build.config.build {\n+        println!(\"\\tskipping, not a build host\");\n+        return\n+    }\n+\n     let name = format!(\"rust-std-{}\", package_vers(build));\n     let image = tmpdir(build).join(format!(\"{}-{}-image\", name, target));\n     let _ = fs::remove_dir_all(&image);\n@@ -294,10 +308,15 @@ pub fn analysis(build: &Build, compiler: &Compiler, target: &str) {\n     println!(\"Dist analysis\");\n \n     if build.config.channel != \"nightly\" {\n-        println!(\"Skipping dist-analysis - not on nightly channel\");\n+        println!(\"\\tskipping - not on nightly channel\");\n         return;\n     }\n+    if compiler.host != build.config.build {\n+        println!(\"\\tskipping - not a build host\");\n+        return\n+    }\n     if compiler.stage != 2 {\n+        println!(\"\\tskipping - not stage2\");\n         return\n     }\n \n@@ -324,18 +343,17 @@ pub fn analysis(build: &Build, compiler: &Compiler, target: &str) {\n        .arg(\"--legacy-manifest-dirs=rustlib,cargo\");\n     build.run(&mut cmd);\n     t!(fs::remove_dir_all(&image));\n-\n-    // Create plain source tarball\n-    let mut cmd = Command::new(\"tar\");\n-    cmd.arg(\"-czf\").arg(sanitize_sh(&distdir(build).join(&format!(\"{}.tar.gz\", name))))\n-       .arg(\"analysis\")\n-       .current_dir(&src);\n-    build.run(&mut cmd);\n }\n \n /// Creates the `rust-src` installer component and the plain source tarball\n-pub fn rust_src(build: &Build) {\n+pub fn rust_src(build: &Build, host: &str) {\n     println!(\"Dist src\");\n+\n+    if host != build.config.build {\n+        println!(\"\\tskipping, not a build host\");\n+        return\n+    }\n+\n     let plain_name = format!(\"rustc-{}-src\", package_vers(build));\n     let name = format!(\"rust-src-{}\", package_vers(build));\n     let image = tmpdir(build).join(format!(\"{}-image\", name));"}, {"sha": "b2412fbb3c84400310798a96175d79862a4b6b18", "filename": "src/bootstrap/flags.rs", "status": "modified", "additions": 30, "deletions": 5, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Fbootstrap%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Fbootstrap%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fflags.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -27,15 +27,27 @@ use step;\n \n /// Deserialized version of all flags for this compile.\n pub struct Flags {\n-    pub verbose: bool,\n+    pub verbose: usize, // verbosity level: 0 == not verbose, 1 == verbose, 2 == very verbose\n     pub stage: Option<u32>,\n+    pub keep_stage: Option<u32>,\n     pub build: String,\n     pub host: Vec<String>,\n     pub target: Vec<String>,\n     pub config: Option<PathBuf>,\n     pub src: Option<PathBuf>,\n     pub jobs: Option<u32>,\n     pub cmd: Subcommand,\n+    pub incremental: bool,\n+}\n+\n+impl Flags {\n+    pub fn verbose(&self) -> bool {\n+        self.verbose > 0\n+    }\n+\n+    pub fn very_verbose(&self) -> bool {\n+        self.verbose > 1\n+    }\n }\n \n pub enum Subcommand {\n@@ -62,12 +74,14 @@ pub enum Subcommand {\n impl Flags {\n     pub fn parse(args: &[String]) -> Flags {\n         let mut opts = Options::new();\n-        opts.optflag(\"v\", \"verbose\", \"use verbose output\");\n+        opts.optflagmulti(\"v\", \"verbose\", \"use verbose output (-vv for very verbose)\");\n+        opts.optflag(\"i\", \"incremental\", \"use incremental compilation\");\n         opts.optopt(\"\", \"config\", \"TOML configuration file for build\", \"FILE\");\n         opts.optopt(\"\", \"build\", \"build target of the stage0 compiler\", \"BUILD\");\n         opts.optmulti(\"\", \"host\", \"host targets to build\", \"HOST\");\n         opts.optmulti(\"\", \"target\", \"target targets to build\", \"TARGET\");\n         opts.optopt(\"\", \"stage\", \"stage to build\", \"N\");\n+        opts.optopt(\"\", \"keep-stage\", \"stage to keep without recompiling\", \"N\");\n         opts.optopt(\"\", \"src\", \"path to the root of the rust checkout\", \"DIR\");\n         opts.optopt(\"j\", \"jobs\", \"number of jobs to run in parallel\", \"JOBS\");\n         opts.optflag(\"h\", \"help\", \"print this help message\");\n@@ -108,7 +122,6 @@ Arguments:\n     tests that should be compiled and run. For example:\n \n         ./x.py test src/test/run-pass\n-        ./x.py test src/test/run-pass/assert-*\n         ./x.py test src/libstd --test-args hash_map\n         ./x.py test src/libstd --stage 0\n \n@@ -255,9 +268,20 @@ To learn more about a subcommand, run `./x.py <command> -h`\n             }\n         });\n \n+        let mut stage = m.opt_str(\"stage\").map(|j| j.parse().unwrap());\n+\n+        let incremental = m.opt_present(\"i\");\n+\n+        if incremental {\n+            if stage.is_none() {\n+                stage = Some(1);\n+            }\n+        }\n+\n         Flags {\n-            verbose: m.opt_present(\"v\"),\n-            stage: m.opt_str(\"stage\").map(|j| j.parse().unwrap()),\n+            verbose: m.opt_count(\"v\"),\n+            stage: stage,\n+            keep_stage: m.opt_str(\"keep-stage\").map(|j| j.parse().unwrap()),\n             build: m.opt_str(\"build\").unwrap_or_else(|| {\n                 env::var(\"BUILD\").unwrap()\n             }),\n@@ -267,6 +291,7 @@ To learn more about a subcommand, run `./x.py <command> -h`\n             src: m.opt_str(\"src\").map(PathBuf::from),\n             jobs: m.opt_str(\"jobs\").map(|j| j.parse().unwrap()),\n             cmd: cmd,\n+            incremental: incremental,\n         }\n     }\n }"}, {"sha": "665e0c67b7f6c1153bb32104d799449d74a0ef04", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 24, "deletions": 3, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -64,6 +64,8 @@\n //! More documentation can be found in each respective module below, and you can\n //! also check out the `src/bootstrap/README.md` file for more information.\n \n+#![deny(warnings)]\n+\n extern crate build_helper;\n extern crate cmake;\n extern crate filetime;\n@@ -74,6 +76,7 @@ extern crate rustc_serialize;\n extern crate toml;\n \n use std::collections::HashMap;\n+use std::cmp;\n use std::env;\n use std::ffi::OsString;\n use std::fs::{self, File};\n@@ -497,6 +500,17 @@ impl Build {\n         cargo.env(\"RUSTC_BOOTSTRAP\", \"1\");\n         self.add_rust_test_threads(&mut cargo);\n \n+        // Ignore incremental modes except for stage0, since we're\n+        // not guaranteeing correctness acros builds if the compiler\n+        // is changing under your feet.`\n+        if self.flags.incremental && compiler.stage == 0 {\n+            let incr_dir = self.incremental_dir(compiler);\n+            cargo.env(\"RUSTC_INCREMENTAL\", incr_dir);\n+        }\n+\n+        let verbose = cmp::max(self.config.verbose, self.flags.verbose);\n+        cargo.env(\"RUSTC_VERBOSE\", format!(\"{}\", verbose));\n+\n         // Specify some various options for build scripts used throughout\n         // the build.\n         //\n@@ -516,7 +530,7 @@ impl Build {\n         // FIXME: should update code to not require this env var\n         cargo.env(\"CFG_COMPILER_HOST_TRIPLE\", target);\n \n-        if self.config.verbose || self.flags.verbose {\n+        if self.config.verbose() || self.flags.verbose() {\n             cargo.arg(\"-v\");\n         }\n         // FIXME: cargo bench does not accept `--release`\n@@ -630,6 +644,12 @@ impl Build {\n         }\n     }\n \n+    /// Get the directory for incremental by-products when using the\n+    /// given compiler.\n+    fn incremental_dir(&self, compiler: &Compiler) -> PathBuf {\n+        self.out.join(compiler.host).join(format!(\"stage{}-incremental\", compiler.stage))\n+    }\n+\n     /// Returns the libdir where the standard library and other artifacts are\n     /// found for a compiler's sysroot.\n     fn sysroot_libdir(&self, compiler: &Compiler, target: &str) -> PathBuf {\n@@ -703,7 +723,8 @@ impl Build {\n     fn llvm_filecheck(&self, target: &str) -> PathBuf {\n         let target_config = self.config.target_config.get(target);\n         if let Some(s) = target_config.and_then(|c| c.llvm_config.as_ref()) {\n-            s.parent().unwrap().join(exe(\"FileCheck\", target))\n+            let llvm_bindir = output(Command::new(s).arg(\"--bindir\"));\n+            Path::new(llvm_bindir.trim()).join(exe(\"FileCheck\", target))\n         } else {\n             let base = self.llvm_out(&self.config.build).join(\"build\");\n             let exe = exe(\"FileCheck\", target);\n@@ -768,7 +789,7 @@ impl Build {\n \n     /// Prints a message if this build is configured in verbose mode.\n     fn verbose(&self, msg: &str) {\n-        if self.flags.verbose || self.config.verbose {\n+        if self.flags.verbose() || self.config.verbose() {\n             println!(\"{}\", msg);\n         }\n     }"}, {"sha": "0d83a79cf32d96c3a815007352711039298449e3", "filename": "src/bootstrap/mk/Makefile.in", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Fbootstrap%2Fmk%2FMakefile.in", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Fbootstrap%2Fmk%2FMakefile.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fmk%2FMakefile.in?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -56,7 +56,8 @@ check-cargotest:\n dist:\n \t$(Q)$(BOOTSTRAP) dist $(BOOTSTRAP_ARGS)\n distcheck:\n-\t$(Q)$(BOOTSTRAP) test distcheck\n+\t$(Q)$(BOOTSTRAP) dist $(BOOTSTRAP_ARGS)\n+\t$(Q)$(BOOTSTRAP) test distcheck $(BOOTSTRAP_ARGS)\n install:\n \t$(Q)$(BOOTSTRAP) dist --install $(BOOTSTRAP_ARGS)\n tidy:\n@@ -65,7 +66,7 @@ tidy:\n check-stage2-T-arm-linux-androideabi-H-x86_64-unknown-linux-gnu:\n \t$(Q)$(BOOTSTRAP) test --target arm-linux-androideabi\n check-stage2-T-x86_64-unknown-linux-musl-H-x86_64-unknown-linux-gnu:\n-\t$(Q)$(BOOTSTRAP) test --target x86_64-unknown-linux-gnu\n+\t$(Q)$(BOOTSTRAP) test --target x86_64-unknown-linux-musl\n \n \n .PHONY: dist"}, {"sha": "09dbd9f8220b0922d32eba5ff3d2e03ddf29312a", "filename": "src/bootstrap/native.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Fbootstrap%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Fbootstrap%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fnative.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -81,7 +81,7 @@ pub fn llvm(build: &Build, target: &str) {\n        .profile(profile)\n        .define(\"LLVM_ENABLE_ASSERTIONS\", assertions)\n        .define(\"LLVM_TARGETS_TO_BUILD\",\n-               \"X86;ARM;AArch64;Mips;PowerPC;SystemZ;JSBackend;MSP430\")\n+               \"X86;ARM;AArch64;Mips;PowerPC;SystemZ;JSBackend;MSP430;Sparc\")\n        .define(\"LLVM_INCLUDE_EXAMPLES\", \"OFF\")\n        .define(\"LLVM_INCLUDE_TESTS\", \"OFF\")\n        .define(\"LLVM_INCLUDE_DOCS\", \"OFF\")\n@@ -109,10 +109,10 @@ pub fn llvm(build: &Build, target: &str) {\n \n     // MSVC handles compiler business itself\n     if !target.contains(\"msvc\") {\n-        if build.config.ccache {\n-           cfg.define(\"CMAKE_C_COMPILER\", \"ccache\")\n+        if let Some(ref ccache) = build.config.ccache {\n+           cfg.define(\"CMAKE_C_COMPILER\", ccache)\n               .define(\"CMAKE_C_COMPILER_ARG1\", build.cc(target))\n-              .define(\"CMAKE_CXX_COMPILER\", \"ccache\")\n+              .define(\"CMAKE_CXX_COMPILER\", ccache)\n               .define(\"CMAKE_CXX_COMPILER_ARG1\", build.cxx(target));\n         } else {\n            cfg.define(\"CMAKE_C_COMPILER\", build.cc(target))"}, {"sha": "5d543419fc9b6a78b8331728caf46d2f02e31aa3", "filename": "src/bootstrap/sanity.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Fbootstrap%2Fsanity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Fbootstrap%2Fsanity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fsanity.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -143,7 +143,7 @@ pub fn check(build: &mut Build) {\n     // Externally configured LLVM requires FileCheck to exist\n     let filecheck = build.llvm_filecheck(&build.config.build);\n     if !filecheck.starts_with(&build.out) && !filecheck.exists() && build.config.codegen_tests {\n-        panic!(\"filecheck executable {:?} does not exist\", filecheck);\n+        panic!(\"FileCheck executable {:?} does not exist\", filecheck);\n     }\n \n     for target in build.config.target.iter() {\n@@ -223,4 +223,8 @@ $ pacman -R cmake && pacman -S mingw-w64-x86_64-cmake\n     if build.lldb_version.is_some() {\n         build.lldb_python_dir = run(Command::new(\"lldb\").arg(\"-P\")).ok();\n     }\n+\n+    if let Some(ref s) = build.config.ccache {\n+        need_cmd(s.as_ref());\n+    }\n }"}, {"sha": "c5898c1119a670d31ae710f31afb78152aca780c", "filename": "src/bootstrap/step.rs", "status": "modified", "additions": 42, "deletions": 23, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Fbootstrap%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Fbootstrap%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fstep.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -86,7 +86,7 @@ pub fn build_rules(build: &Build) -> Rules {\n     //\n     // To handle this we do a bit of dynamic dispatch to see what the dependency\n     // is. If we're building a LLVM for the build triple, then we don't actually\n-    // have any dependencies! To do that we return a dependency on the \"dummy\"\n+    // have any dependencies! To do that we return a dependency on the `Step::noop()`\n     // target which does nothing.\n     //\n     // If we're build a cross-compiled LLVM, however, we need to assemble the\n@@ -104,7 +104,7 @@ pub fn build_rules(build: &Build) -> Rules {\n          .host(true)\n          .dep(move |s| {\n              if s.target == build.config.build {\n-                 dummy(s, build)\n+                 Step::noop()\n              } else {\n                  s.target(&build.config.build)\n              }\n@@ -115,14 +115,11 @@ pub fn build_rules(build: &Build) -> Rules {\n     // going on here. You can check out the API docs below and also see a bunch\n     // more examples of rules directly below as well.\n \n-    // dummy rule to do nothing, useful when a dep maps to no deps\n-    rules.build(\"dummy\", \"path/to/nowhere\");\n-\n     // the compiler with no target libraries ready to go\n     rules.build(\"rustc\", \"src/rustc\")\n          .dep(move |s| {\n              if s.stage == 0 {\n-                 dummy(s, build)\n+                 Step::noop()\n              } else {\n                  s.name(\"librustc\")\n                   .host(&build.config.build)\n@@ -165,7 +162,7 @@ pub fn build_rules(build: &Build) -> Rules {\n              .dep(move |s| s.name(\"rustc\").host(&build.config.build).target(s.host))\n              .dep(move |s| {\n                  if s.host == build.config.build {\n-                    dummy(s, build)\n+                     Step::noop()\n                  } else {\n                     s.host(&build.config.build)\n                  }\n@@ -183,7 +180,7 @@ pub fn build_rules(build: &Build) -> Rules {\n              .dep(|s| s.name(\"libstd\"))\n              .dep(move |s| {\n                  if s.host == build.config.build {\n-                    dummy(s, build)\n+                    Step::noop()\n                  } else {\n                     s.host(&build.config.build)\n                  }\n@@ -203,7 +200,7 @@ pub fn build_rules(build: &Build) -> Rules {\n              .dep(move |s| s.name(\"llvm\").host(&build.config.build).stage(0))\n              .dep(move |s| {\n                  if s.host == build.config.build {\n-                    dummy(s, build)\n+                    Step::noop()\n                  } else {\n                     s.host(&build.config.build)\n                  }\n@@ -233,7 +230,7 @@ pub fn build_rules(build: &Build) -> Rules {\n                      if s.target.contains(\"android\") {\n                          s.name(\"android-copy-libs\")\n                      } else {\n-                         dummy(s, build)\n+                         Step::noop()\n                      }\n                  })\n                  .default(true)\n@@ -270,16 +267,18 @@ pub fn build_rules(build: &Build) -> Rules {\n         // nothing to do for debuginfo tests\n     } else if build.config.build.contains(\"apple\") {\n         rules.test(\"check-debuginfo\", \"src/test/debuginfo\")\n+             .default(true)\n              .dep(|s| s.name(\"libtest\"))\n-             .dep(|s| s.name(\"tool-compiletest\").host(s.host))\n+             .dep(|s| s.name(\"tool-compiletest\").target(s.host))\n              .dep(|s| s.name(\"test-helpers\"))\n              .dep(|s| s.name(\"debugger-scripts\"))\n              .run(move |s| check::compiletest(build, &s.compiler(), s.target,\n                                          \"debuginfo-lldb\", \"debuginfo\"));\n     } else {\n         rules.test(\"check-debuginfo\", \"src/test/debuginfo\")\n+             .default(true)\n              .dep(|s| s.name(\"libtest\"))\n-             .dep(|s| s.name(\"tool-compiletest\").host(s.host))\n+             .dep(|s| s.name(\"tool-compiletest\").target(s.host))\n              .dep(|s| s.name(\"test-helpers\"))\n              .dep(|s| s.name(\"debugger-scripts\"))\n              .run(move |s| check::compiletest(build, &s.compiler(), s.target,\n@@ -458,7 +457,7 @@ pub fn build_rules(build: &Build) -> Rules {\n     for (krate, path, default) in krates(\"test_shim\") {\n         rules.doc(&krate.doc_step, path)\n              .dep(|s| s.name(\"libtest\"))\n-             .default(default && build.config.docs)\n+             .default(default && build.config.compiler_docs)\n              .run(move |s| doc::test(build, s.stage, s.target));\n     }\n     for (krate, path, default) in krates(\"rustc-main\") {\n@@ -490,16 +489,21 @@ pub fn build_rules(build: &Build) -> Rules {\n          .default(true)\n          .run(move |s| dist::std(build, &s.compiler(), s.target));\n     rules.dist(\"dist-mingw\", \"path/to/nowhere\")\n-         .run(move |s| dist::mingw(build, s.target));\n+         .default(true)\n+         .run(move |s| {\n+             if s.target.contains(\"pc-windows-gnu\") {\n+                 dist::mingw(build, s.target)\n+             }\n+         });\n     rules.dist(\"dist-src\", \"src\")\n          .default(true)\n          .host(true)\n-         .run(move |_| dist::rust_src(build));\n+         .run(move |s| dist::rust_src(build, s.target));\n     rules.dist(\"dist-docs\", \"src/doc\")\n          .default(true)\n          .dep(|s| s.name(\"default:doc\"))\n          .run(move |s| dist::docs(build, s.stage, s.target));\n-    rules.dist(\"dist-analysis\", \"src/libstd\")\n+    rules.dist(\"dist-analysis\", \"analysis\")\n          .dep(|s| s.name(\"dist-std\"))\n          .default(true)\n          .run(move |s| dist::analysis(build, &s.compiler(), s.target));\n@@ -509,12 +513,6 @@ pub fn build_rules(build: &Build) -> Rules {\n \n     rules.verify();\n     return rules;\n-\n-    fn dummy<'a>(s: &Step<'a>, build: &'a Build) -> Step<'a> {\n-        s.name(\"dummy\").stage(0)\n-         .target(&build.config.build)\n-         .host(&build.config.build)\n-    }\n }\n \n #[derive(PartialEq, Eq, Hash, Clone, Debug)]\n@@ -538,6 +536,10 @@ struct Step<'a> {\n }\n \n impl<'a> Step<'a> {\n+    fn noop() -> Step<'a> {\n+        Step { name: \"\", stage: 0, host: \"\", target: \"\" }\n+    }\n+\n     /// Creates a new step which is the same as this, except has a new name.\n     fn name(&self, name: &'a str) -> Step<'a> {\n         Step { name: name, ..*self }\n@@ -733,6 +735,9 @@ impl<'a> Rules<'a> {\n                 if self.rules.contains_key(&dep.name) || dep.name.starts_with(\"default:\") {\n                     continue\n                 }\n+                if dep == Step::noop() {\n+                    continue\n+                }\n                 panic!(\"\\\n \n invalid rule dependency graph detected, was a rule added and maybe typo'd?\n@@ -817,7 +822,16 @@ invalid rule dependency graph detected, was a rule added and maybe typo'd?\n             let hosts = if self.build.flags.host.len() > 0 {\n                 &self.build.flags.host\n             } else {\n-                &self.build.config.host\n+                if kind == Kind::Dist {\n+                    // For 'dist' steps we only distribute artifacts built from\n+                    // the build platform, so only consider that in the hosts\n+                    // array.\n+                    // NOTE: This relies on the fact that the build triple is\n+                    // always placed first, as done in `config.rs`.\n+                    &self.build.config.host[..1]\n+                } else {\n+                    &self.build.config.host\n+                }\n             };\n             let targets = if self.build.flags.target.len() > 0 {\n                 &self.build.flags.target\n@@ -859,6 +873,7 @@ invalid rule dependency graph detected, was a rule added and maybe typo'd?\n         // of what we need to do.\n         let mut order = Vec::new();\n         let mut added = HashSet::new();\n+        added.insert(Step::noop());\n         for step in steps.iter().cloned() {\n             self.fill(step, &mut order, &mut added);\n         }\n@@ -871,6 +886,10 @@ invalid rule dependency graph detected, was a rule added and maybe typo'd?\n \n         // And finally, iterate over everything and execute it.\n         for step in order.iter() {\n+            if self.build.flags.keep_stage.map_or(false, |s| step.stage <= s) {\n+                self.build.verbose(&format!(\"keeping step {:?}\", step));\n+                continue;\n+            }\n             self.build.verbose(&format!(\"executing step {:?}\", step));\n             (self.rules[step.name].run)(step);\n         }"}, {"sha": "c9e756b6f993659e05bba2069657e7b385303db0", "filename": "src/bootstrap/util.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Fbootstrap%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Fbootstrap%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Futil.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -41,6 +41,12 @@ pub fn mtime(path: &Path) -> FileTime {\n /// Copies a file from `src` to `dst`, attempting to use hard links and then\n /// falling back to an actually filesystem copy if necessary.\n pub fn copy(src: &Path, dst: &Path) {\n+    // A call to `hard_link` will fail if `dst` exists, so remove it if it\n+    // already exists so we can try to help `hard_link` succeed.\n+    let _ = fs::remove_file(&dst);\n+\n+    // Attempt to \"easy copy\" by creating a hard link (symlinks don't work on\n+    // windows), but if that fails just fall back to a slow `copy` operation.\n     let res = fs::hard_link(src, dst);\n     let res = res.or_else(|_| fs::copy(src, dst).map(|_| ()));\n     if let Err(e) = res {"}, {"sha": "d0d588f46a7549a9402f404b395aebe0a2868dde", "filename": "src/build_helper/lib.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Fbuild_helper%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Fbuild_helper%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbuild_helper%2Flib.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -47,6 +47,8 @@ pub fn cc2ar(cc: &Path, target: &str) -> Option<PathBuf> {\n         None\n     } else if target.contains(\"musl\") {\n         Some(PathBuf::from(\"ar\"))\n+    } else if target.contains(\"openbsd\") {\n+        Some(PathBuf::from(\"ar\"))\n     } else {\n         let parent = cc.parent().unwrap();\n         let file = cc.file_name().unwrap().to_str().unwrap();\n@@ -61,6 +63,16 @@ pub fn cc2ar(cc: &Path, target: &str) -> Option<PathBuf> {\n     }\n }\n \n+pub fn make(host: &str) -> PathBuf {\n+    if host.contains(\"bitrig\") || host.contains(\"dragonfly\") ||\n+        host.contains(\"freebsd\") || host.contains(\"netbsd\") ||\n+        host.contains(\"openbsd\") {\n+        PathBuf::from(\"gmake\")\n+    } else {\n+        PathBuf::from(\"make\")\n+    }\n+}\n+\n pub fn output(cmd: &mut Command) -> String {\n     let output = match cmd.stderr(Stdio::inherit()).output() {\n         Ok(status) => status,"}, {"sha": "8911b4ff0cb87e5353a818201f6a2853ee740b1c", "filename": "src/ci/docker/arm-android/Dockerfile", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Fci%2Fdocker%2Farm-android%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Fci%2Fdocker%2Farm-android%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Farm-android%2FDockerfile?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -16,7 +16,8 @@ RUN dpkg --add-architecture i386 && \\\n   expect \\\n   openjdk-9-jre \\\n   sudo \\\n-  libstdc++6:i386\n+  libstdc++6:i386 \\\n+  xz-utils\n \n WORKDIR /android/\n ENV PATH=$PATH:/android/ndk-arm-9/bin:/android/sdk/tools:/android/sdk/platform-tools\n@@ -25,8 +26,17 @@ COPY install-ndk.sh install-sdk.sh accept-licenses.sh /android/\n RUN sh /android/install-ndk.sh\n RUN sh /android/install-sdk.sh\n \n+RUN curl -OL https://github.com/Yelp/dumb-init/releases/download/v1.2.0/dumb-init_1.2.0_amd64.deb && \\\n+    dpkg -i dumb-init_*.deb && \\\n+    rm dumb-init_*.deb\n+\n COPY start-emulator.sh /android/\n-ENTRYPOINT [\"/android/start-emulator.sh\"]\n+\n+ENTRYPOINT [\"/usr/bin/dumb-init\", \"--\", \"/android/start-emulator.sh\"]\n+\n+ENV SCCACHE_DIGEST=7237e38e029342fa27b7ac25412cb9d52554008b12389727320bd533fd7f05b6a96d55485f305caf95e5c8f5f97c3313e10012ccad3e752aba2518f3522ba783\n+RUN curl -L https://api.pub.build.mozilla.org/tooltool/sha512/$SCCACHE_DIGEST | \\\n+      tar xJf - -C /usr/local/bin --strip-components=1\n \n ENV TARGETS=arm-linux-androideabi\n ENV TARGETS=$TARGETS,i686-linux-android"}, {"sha": "08b436313f6378c60efa525e65e0f4323d613489", "filename": "src/ci/docker/cross/Dockerfile", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Fci%2Fdocker%2Fcross%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Fci%2Fdocker%2Fcross%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fcross%2FDockerfile?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -21,7 +21,17 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   gcc-powerpc-linux-gnu libc6-dev-powerpc-cross \\\n   gcc-powerpc64-linux-gnu libc6-dev-ppc64-cross \\\n   gcc-powerpc64le-linux-gnu libc6-dev-ppc64el-cross \\\n-  gcc-s390x-linux-gnu libc6-dev-s390x-cross\n+  gcc-s390x-linux-gnu libc6-dev-s390x-cross \\\n+  xz-utils\n+\n+ENV SCCACHE_DIGEST=7237e38e029342fa27b7ac25412cb9d52554008b12389727320bd533fd7f05b6a96d55485f305caf95e5c8f5f97c3313e10012ccad3e752aba2518f3522ba783\n+RUN curl -L https://api.pub.build.mozilla.org/tooltool/sha512/$SCCACHE_DIGEST | \\\n+      tar xJf - -C /usr/local/bin --strip-components=1\n+\n+RUN curl -OL https://github.com/Yelp/dumb-init/releases/download/v1.2.0/dumb-init_1.2.0_amd64.deb && \\\n+    dpkg -i dumb-init_*.deb && \\\n+    rm dumb-init_*.deb\n+ENTRYPOINT [\"/usr/bin/dumb-init\", \"--\"]\n \n ENV TARGETS=aarch64-unknown-linux-gnu\n ENV TARGETS=$TARGETS,arm-unknown-linux-gnueabi"}, {"sha": "1da33c94c7b18d6caece93cbfb0d638cc7c8ccfa", "filename": "src/ci/docker/i686-gnu-nopt/Dockerfile", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Fci%2Fdocker%2Fi686-gnu-nopt%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Fci%2Fdocker%2Fi686-gnu-nopt%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fi686-gnu-nopt%2FDockerfile?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -11,7 +11,17 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   cmake \\\n   ccache \\\n   sudo \\\n-  gdb\n+  gdb \\\n+  xz-utils\n+\n+ENV SCCACHE_DIGEST=7237e38e029342fa27b7ac25412cb9d52554008b12389727320bd533fd7f05b6a96d55485f305caf95e5c8f5f97c3313e10012ccad3e752aba2518f3522ba783\n+RUN curl -L https://api.pub.build.mozilla.org/tooltool/sha512/$SCCACHE_DIGEST | \\\n+      tar xJf - -C /usr/local/bin --strip-components=1\n+\n+RUN curl -OL https://github.com/Yelp/dumb-init/releases/download/v1.2.0/dumb-init_1.2.0_amd64.deb && \\\n+    dpkg -i dumb-init_*.deb && \\\n+    rm dumb-init_*.deb\n+ENTRYPOINT [\"/usr/bin/dumb-init\", \"--\"]\n \n ENV RUST_CONFIGURE_ARGS --build=i686-unknown-linux-gnu --disable-optimize-tests\n ENV RUST_CHECK_TARGET check"}, {"sha": "9e5b0e0435e8b88dcec18a96b50ba4932572cc69", "filename": "src/ci/docker/i686-gnu/Dockerfile", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Fci%2Fdocker%2Fi686-gnu%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Fci%2Fdocker%2Fi686-gnu%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fi686-gnu%2FDockerfile?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -11,7 +11,17 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   cmake \\\n   ccache \\\n   sudo \\\n-  gdb\n+  gdb \\\n+  xz-utils\n+\n+ENV SCCACHE_DIGEST=7237e38e029342fa27b7ac25412cb9d52554008b12389727320bd533fd7f05b6a96d55485f305caf95e5c8f5f97c3313e10012ccad3e752aba2518f3522ba783\n+RUN curl -L https://api.pub.build.mozilla.org/tooltool/sha512/$SCCACHE_DIGEST | \\\n+      tar xJf - -C /usr/local/bin --strip-components=1\n+\n+RUN curl -OL https://github.com/Yelp/dumb-init/releases/download/v1.2.0/dumb-init_1.2.0_amd64.deb && \\\n+    dpkg -i dumb-init_*.deb && \\\n+    rm dumb-init_*.deb\n+ENTRYPOINT [\"/usr/bin/dumb-init\", \"--\"]\n \n ENV RUST_CONFIGURE_ARGS --build=i686-unknown-linux-gnu\n ENV RUST_CHECK_TARGET check"}, {"sha": "8c2c8d2a9db5a352bf9b9d444efab6fffa7135de", "filename": "src/ci/docker/run.sh", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Fci%2Fdocker%2Frun.sh", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Fci%2Fdocker%2Frun.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Frun.sh?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -25,18 +25,26 @@ docker \\\n   -t rust-ci \\\n   \"`dirname \"$script\"`/$image\"\n \n-mkdir -p $HOME/.ccache\n mkdir -p $HOME/.cargo\n mkdir -p $root_dir/obj\n \n+args=\n+if [ \"$SCCACHE_BUCKET\" != \"\" ]; then\n+    args=\"$args --env SCCACHE_BUCKET=$SCCACHE_BUCKET\"\n+    args=\"$args --env AWS_ACCESS_KEY_ID=$AWS_ACCESS_KEY_ID\"\n+    args=\"$args --env AWS_SECRET_ACCESS_KEY=$AWS_SECRET_ACCESS_KEY\"\n+else\n+    mkdir -p $HOME/.cache/sccache\n+    args=\"$args --env SCCACHE_DIR=/sccache --volume $HOME/.cache/sccache:/sccache\"\n+fi\n+\n exec docker \\\n   run \\\n   --volume \"$root_dir:/checkout:ro\" \\\n   --volume \"$root_dir/obj:/checkout/obj\" \\\n   --workdir /checkout/obj \\\n   --env SRC=/checkout \\\n-  --env CCACHE_DIR=/ccache \\\n-  --volume \"$HOME/.ccache:/ccache\" \\\n+  $args \\\n   --env CARGO_HOME=/cargo \\\n   --env LOCAL_USER_ID=`id -u` \\\n   --volume \"$HOME/.cargo:/cargo\" \\"}, {"sha": "75f3174e2c0443458eaf592e52af065f0e29271b", "filename": "src/ci/docker/x86_64-freebsd/Dockerfile", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Fci%2Fdocker%2Fx86_64-freebsd%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Fci%2Fdocker%2Fx86_64-freebsd%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-freebsd%2FDockerfile?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -18,6 +18,15 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n COPY build-toolchain.sh /tmp/\n RUN sh /tmp/build-toolchain.sh\n \n+RUN curl -OL https://github.com/Yelp/dumb-init/releases/download/v1.2.0/dumb-init_1.2.0_amd64.deb && \\\n+    dpkg -i dumb-init_*.deb && \\\n+    rm dumb-init_*.deb\n+ENTRYPOINT [\"/usr/bin/dumb-init\", \"--\"]\n+\n+ENV SCCACHE_DIGEST=7237e38e029342fa27b7ac25412cb9d52554008b12389727320bd533fd7f05b6a96d55485f305caf95e5c8f5f97c3313e10012ccad3e752aba2518f3522ba783\n+RUN curl -L https://api.pub.build.mozilla.org/tooltool/sha512/$SCCACHE_DIGEST | \\\n+      tar xJf - -C /usr/local/bin --strip-components=1\n+\n ENV \\\n     AR_x86_64_unknown_freebsd=x86_64-unknown-freebsd10-ar \\\n     CC_x86_64_unknown_freebsd=x86_64-unknown-freebsd10-gcc"}, {"sha": "2c3db87d9fb1fdd716f22aa489483e44a983ea34", "filename": "src/ci/docker/x86_64-gnu-cargotest/Dockerfile", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Fci%2Fdocker%2Fx86_64-gnu-cargotest%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Fci%2Fdocker%2Fx86_64-gnu-cargotest%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-cargotest%2FDockerfile?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -11,7 +11,18 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   cmake \\\n   ccache \\\n   libssl-dev \\\n-  sudo\n+  sudo \\\n+  xz-utils \\\n+  pkg-config\n+\n+ENV SCCACHE_DIGEST=7237e38e029342fa27b7ac25412cb9d52554008b12389727320bd533fd7f05b6a96d55485f305caf95e5c8f5f97c3313e10012ccad3e752aba2518f3522ba783\n+RUN curl -L https://api.pub.build.mozilla.org/tooltool/sha512/$SCCACHE_DIGEST | \\\n+      tar xJf - -C /usr/local/bin --strip-components=1\n+\n+RUN curl -OL https://github.com/Yelp/dumb-init/releases/download/v1.2.0/dumb-init_1.2.0_amd64.deb && \\\n+    dpkg -i dumb-init_*.deb && \\\n+    rm dumb-init_*.deb\n+ENTRYPOINT [\"/usr/bin/dumb-init\", \"--\"]\n \n ENV RUST_CONFIGURE_ARGS --build=x86_64-unknown-linux-gnu\n ENV RUST_CHECK_TARGET check-cargotest"}, {"sha": "eec88442293a4c2bbdf62231db3e06be061688fb", "filename": "src/ci/docker/x86_64-gnu-debug/Dockerfile", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Fci%2Fdocker%2Fx86_64-gnu-debug%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Fci%2Fdocker%2Fx86_64-gnu-debug%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-debug%2FDockerfile?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -11,7 +11,17 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   cmake \\\n   ccache \\\n   sudo \\\n-  gdb\n+  gdb \\\n+  xz-utils\n+\n+ENV SCCACHE_DIGEST=7237e38e029342fa27b7ac25412cb9d52554008b12389727320bd533fd7f05b6a96d55485f305caf95e5c8f5f97c3313e10012ccad3e752aba2518f3522ba783\n+RUN curl -L https://api.pub.build.mozilla.org/tooltool/sha512/$SCCACHE_DIGEST | \\\n+      tar xJf - -C /usr/local/bin --strip-components=1\n+\n+RUN curl -OL https://github.com/Yelp/dumb-init/releases/download/v1.2.0/dumb-init_1.2.0_amd64.deb && \\\n+    dpkg -i dumb-init_*.deb && \\\n+    rm dumb-init_*.deb\n+ENTRYPOINT [\"/usr/bin/dumb-init\", \"--\"]\n \n ENV RUST_CONFIGURE_ARGS \\\n       --build=x86_64-unknown-linux-gnu \\"}, {"sha": "4c9198d88eb2129fe53ac18924fb4c9eed95b375", "filename": "src/ci/docker/x86_64-gnu-llvm-3.7/Dockerfile", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Fci%2Fdocker%2Fx86_64-gnu-llvm-3.7%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Fci%2Fdocker%2Fx86_64-gnu-llvm-3.7%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-llvm-3.7%2FDockerfile?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -14,7 +14,17 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   gdb \\\n   llvm-3.7-tools \\\n   libedit-dev \\\n-  zlib1g-dev\n+  zlib1g-dev \\\n+  xz-utils\n+\n+ENV SCCACHE_DIGEST=7237e38e029342fa27b7ac25412cb9d52554008b12389727320bd533fd7f05b6a96d55485f305caf95e5c8f5f97c3313e10012ccad3e752aba2518f3522ba783\n+RUN curl -L https://api.pub.build.mozilla.org/tooltool/sha512/$SCCACHE_DIGEST | \\\n+      tar xJf - -C /usr/local/bin --strip-components=1\n+\n+RUN curl -OL https://github.com/Yelp/dumb-init/releases/download/v1.2.0/dumb-init_1.2.0_amd64.deb && \\\n+    dpkg -i dumb-init_*.deb && \\\n+    rm dumb-init_*.deb\n+ENTRYPOINT [\"/usr/bin/dumb-init\", \"--\"]\n \n ENV RUST_CONFIGURE_ARGS \\\n       --build=x86_64-unknown-linux-gnu \\"}, {"sha": "1c503aea13d5087d803ef3a8304fb52de6a83b30", "filename": "src/ci/docker/x86_64-gnu-make/Dockerfile", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Fci%2Fdocker%2Fx86_64-gnu-make%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Fci%2Fdocker%2Fx86_64-gnu-make%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-make%2FDockerfile?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -11,7 +11,17 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   cmake \\\n   ccache \\\n   sudo \\\n-  gdb\n+  gdb \\\n+  xz-utils\n+\n+ENV SCCACHE_DIGEST=7237e38e029342fa27b7ac25412cb9d52554008b12389727320bd533fd7f05b6a96d55485f305caf95e5c8f5f97c3313e10012ccad3e752aba2518f3522ba783\n+RUN curl -L https://api.pub.build.mozilla.org/tooltool/sha512/$SCCACHE_DIGEST | \\\n+      tar xJf - -C /usr/local/bin --strip-components=1\n+\n+RUN curl -OL https://github.com/Yelp/dumb-init/releases/download/v1.2.0/dumb-init_1.2.0_amd64.deb && \\\n+    dpkg -i dumb-init_*.deb && \\\n+    rm dumb-init_*.deb\n+ENTRYPOINT [\"/usr/bin/dumb-init\", \"--\"]\n \n ENV RUST_CONFIGURE_ARGS --build=x86_64-unknown-linux-gnu --disable-rustbuild\n ENV RUST_CHECK_TARGET check"}, {"sha": "66de6ea13ac67c830210516d9a9c45359992e7b3", "filename": "src/ci/docker/x86_64-gnu-nopt/Dockerfile", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Fci%2Fdocker%2Fx86_64-gnu-nopt%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Fci%2Fdocker%2Fx86_64-gnu-nopt%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-nopt%2FDockerfile?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -11,7 +11,17 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   cmake \\\n   ccache \\\n   sudo \\\n-  gdb\n+  gdb \\\n+  xz-utils\n+\n+ENV SCCACHE_DIGEST=7237e38e029342fa27b7ac25412cb9d52554008b12389727320bd533fd7f05b6a96d55485f305caf95e5c8f5f97c3313e10012ccad3e752aba2518f3522ba783\n+RUN curl -L https://api.pub.build.mozilla.org/tooltool/sha512/$SCCACHE_DIGEST | \\\n+      tar xJf - -C /usr/local/bin --strip-components=1\n+\n+RUN curl -OL https://github.com/Yelp/dumb-init/releases/download/v1.2.0/dumb-init_1.2.0_amd64.deb && \\\n+    dpkg -i dumb-init_*.deb && \\\n+    rm dumb-init_*.deb\n+ENTRYPOINT [\"/usr/bin/dumb-init\", \"--\"]\n \n ENV RUST_CONFIGURE_ARGS --build=x86_64-unknown-linux-gnu --disable-optimize-tests\n ENV RUST_CHECK_TARGET check"}, {"sha": "3d71b7ffb9a3a04a1554e1c6549e34c27bc45cd3", "filename": "src/ci/docker/x86_64-gnu/Dockerfile", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Fci%2Fdocker%2Fx86_64-gnu%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Fci%2Fdocker%2Fx86_64-gnu%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu%2FDockerfile?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -11,7 +11,17 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   cmake \\\n   ccache \\\n   sudo \\\n-  gdb\n+  gdb \\\n+  xz-utils\n+\n+ENV SCCACHE_DIGEST=7237e38e029342fa27b7ac25412cb9d52554008b12389727320bd533fd7f05b6a96d55485f305caf95e5c8f5f97c3313e10012ccad3e752aba2518f3522ba783\n+RUN curl -L https://api.pub.build.mozilla.org/tooltool/sha512/$SCCACHE_DIGEST | \\\n+      tar xJf - -C /usr/local/bin --strip-components=1\n+\n+RUN curl -OL https://github.com/Yelp/dumb-init/releases/download/v1.2.0/dumb-init_1.2.0_amd64.deb && \\\n+    dpkg -i dumb-init_*.deb && \\\n+    rm dumb-init_*.deb\n+ENTRYPOINT [\"/usr/bin/dumb-init\", \"--\"]\n \n ENV RUST_CONFIGURE_ARGS --build=x86_64-unknown-linux-gnu\n ENV RUST_CHECK_TARGET check"}, {"sha": "96b38067cbb1479be05ec81c5f144deac440d442", "filename": "src/ci/docker/x86_64-musl/Dockerfile", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Fci%2Fdocker%2Fx86_64-musl%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Fci%2Fdocker%2Fx86_64-musl%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-musl%2FDockerfile?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -18,6 +18,15 @@ WORKDIR /build/\n COPY build-musl.sh /build/\n RUN sh /build/build-musl.sh && rm -rf /build\n \n+RUN curl -OL https://github.com/Yelp/dumb-init/releases/download/v1.2.0/dumb-init_1.2.0_amd64.deb && \\\n+    dpkg -i dumb-init_*.deb && \\\n+    rm dumb-init_*.deb\n+ENTRYPOINT [\"/usr/bin/dumb-init\", \"--\"]\n+\n+ENV SCCACHE_DIGEST=7237e38e029342fa27b7ac25412cb9d52554008b12389727320bd533fd7f05b6a96d55485f305caf95e5c8f5f97c3313e10012ccad3e752aba2518f3522ba783\n+RUN curl -L https://api.pub.build.mozilla.org/tooltool/sha512/$SCCACHE_DIGEST | \\\n+      tar xJf - -C /usr/local/bin --strip-components=1\n+\n ENV RUST_CONFIGURE_ARGS \\\n       --target=x86_64-unknown-linux-musl \\\n       --musl-root-x86_64=/musl-x86_64"}, {"sha": "152694346aa25bf34a786e00566efe8b7eab96ec", "filename": "src/ci/run.sh", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Fci%2Frun.sh", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Fci%2Frun.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Frun.sh?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -26,17 +26,13 @@ if [ \"$NO_VENDOR\" = \"\" ]; then\n   ENABLE_VENDOR=--enable-vendor\n fi\n \n-if [ \"$NO_CCACHE\" = \"\" ]; then\n-  ENABLE_CCACHE=--enable-ccache\n-fi\n-\n set -ex\n \n $SRC/configure \\\n   --disable-manage-submodules \\\n   --enable-debug-assertions \\\n   --enable-quiet-tests \\\n-  $ENABLE_CCACHE \\\n+  --enable-sccache \\\n   $ENABLE_VENDOR \\\n   $ENABLE_LLVM_ASSERTIONS \\\n   $RUST_CONFIGURE_ARGS"}, {"sha": "a8f8224c58b81e3ca43c6b83bccfb2aa8715e712", "filename": "src/doc/book/casting-between-types.md", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Fdoc%2Fbook%2Fcasting-between-types.md", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Fdoc%2Fbook%2Fcasting-between-types.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fcasting-between-types.md?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -16,18 +16,18 @@ function result.\n \n The most common case of coercion is removing mutability from a reference:\n \n- * `&mut T` to `&T`\n+* `&mut T` to `&T`\n \n An analogous conversion is to remove mutability from a\n [raw pointer](raw-pointers.md):\n \n- * `*mut T` to `*const T`\n+* `*mut T` to `*const T`\n \n References can also be coerced to raw pointers:\n \n- * `&T` to `*const T`\n+* `&T` to `*const T`\n \n- * `&mut T` to `*mut T`\n+* `&mut T` to `*mut T`\n \n Custom coercions may be defined using [`Deref`](deref-coercions.md).\n \n@@ -59,11 +59,11 @@ A cast `e as U` is valid if `e` has type `T` and `T` *coerces* to `U`.\n \n A cast `e as U` is also valid in any of the following cases:\n \n- * `e` has type `T` and `T` and `U` are any numeric types; *numeric-cast*\n- * `e` is a C-like enum (with no data attached to the variants),\n-    and `U` is an integer type; *enum-cast*\n- * `e` has type `bool` or `char` and `U` is an integer type; *prim-int-cast*\n- * `e` has type `u8` and `U` is `char`; *u8-char-cast*\n+* `e` has type `T` and `T` and `U` are any numeric types; *numeric-cast*\n+* `e` is a C-like enum (with no data attached to the variants),\n+   and `U` is an integer type; *enum-cast*\n+* `e` has type `bool` or `char` and `U` is an integer type; *prim-int-cast*\n+* `e` has type `u8` and `U` is `char`; *u8-char-cast*\n \n For example\n "}, {"sha": "dafcffc39c802b0ff992fb4be06d8b9e5f86fcf2", "filename": "src/doc/book/documentation.md", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Fdoc%2Fbook%2Fdocumentation.md", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Fdoc%2Fbook%2Fdocumentation.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fdocumentation.md?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -460,8 +460,9 @@ not actually pass as a test.\n ```\n \n The `no_run` attribute will compile your code, but not run it. This is\n-important for examples such as \"Here's how to start up a network service,\"\n-which you would want to make sure compile, but might run in an infinite loop!\n+important for examples such as \"Here's how to retrieve a web page,\"\n+which you would want to ensure compiles, but might be run in a test\n+environment that has no network access.\n \n ### Documenting modules\n "}, {"sha": "5aae693ad6b54a48ba878f4b6d812350501e3118", "filename": "src/doc/book/getting-started.md", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Fdoc%2Fbook%2Fgetting-started.md", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Fdoc%2Fbook%2Fgetting-started.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fgetting-started.md?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -24,41 +24,40 @@ see the website][platform-support].\n \n [platform-support]: https://forge.rust-lang.org/platform-support.html\n \n-## Installing on Linux or Mac\n+## Installing Rust\n \n-If we're on Linux or a Mac, all we need to do is open a terminal and type this:\n+All you need to do on Unix systems like Linux and macOS is open a\n+terminal and type this:\n \n ```bash\n-$ curl -sSf https://static.rust-lang.org/rustup.sh | sh\n+$ curl https://sh.rustup.rs -sSf | sh\n ```\n \n-This will download a script, and start the installation. If it all goes well,\n-you\u2019ll see this appear:\n+It will download a script, and start the installation. If everything\n+goes well, you\u2019ll see this appear:\n \n ```text\n-Rust is ready to roll.\n+Rust is installed now. Great! \n ```\n \n-From here, press `y` for \u2018yes\u2019, and then follow the rest of the prompts.\n+Installing on Windows is nearly as easy: download and run\n+[rustup-init.exe]. It will start the installation in a console and\n+present the above message on success.\n \n-## Installing on Windows\n+For other installation options and information, visit the [install]\n+page of the Rust website.\n \n-If you're on Windows, please download the appropriate [installer][install-page].\n-\n-[install-page]: https://www.rust-lang.org/install.html\n+[rustup-init.exe]: https://win.rustup.rs\n+[install]: https://www.rust-lang.org/install.html\n \n ## Uninstalling\n \n-Uninstalling Rust is as easy as installing it. On Linux or Mac, run\n-the uninstall script:\n+Uninstalling Rust is as easy as installing it:\n \n ```bash\n-$ sudo /usr/local/lib/rustlib/uninstall.sh\n+$ rustup self uninstall\n ```\n \n-If we used the Windows installer, we can re-run the `.msi` and it will give us\n-an uninstall option.\n-\n ## Troubleshooting\n \n If we've got Rust installed, we can open up a shell, and type this:\n@@ -71,12 +70,15 @@ You should see the version number, commit hash, and commit date.\n \n If you do, Rust has been installed successfully! Congrats!\n \n-If you don't and you're on Windows, check that Rust is in your %PATH% system\n-variable: `$ echo %PATH%`. If it isn't, run the installer again, select \"Change\"\n-on the \"Change, repair, or remove installation\" page and ensure \"Add to PATH\" is\n-installed on the local hard drive.  If you need to configure your path manually,\n-you can find the Rust executables in a directory like\n-`\"C:\\Program Files\\Rust stable GNU 1.x\\bin\"`.\n+If you don't, that probably means that the `PATH` environment variable\n+doesn't include Cargo's binary directory, `~/.cargo/bin` on Unix, or\n+`%USERPROFILE%\\.cargo\\bin` on Windows. This is the directory where\n+Rust development tools live, and most Rust developers keep it in their\n+`PATH` environment variable, which makes it possible to run `rustc` on\n+the command line. Due to differences in operating systems, command\n+shells, and bugs in installation, you may need to restart your shell,\n+log out of the system, or configure `PATH` manually as appropriate for\n+your operating environment.\n \n Rust does not do its own linking, and so you\u2019ll need to have a linker\n installed. Doing so will depend on your specific system. For\n@@ -106,9 +108,7 @@ resources include [the user\u2019s forum][users] and [Stack Overflow][stackoverflow\n [stackoverflow]: http://stackoverflow.com/questions/tagged/rust\n \n This installer also installs a copy of the documentation locally, so we can\n-read it offline. On UNIX systems, `/usr/local/share/doc/rust` is the location.\n-On Windows, it's in a `share/doc` directory, inside the directory to which Rust\n-was installed.\n+read it offline. It's only a `rustup doc` away!\n \n # Hello, world!\n "}, {"sha": "96cec7295aa9d11abfcd6d4598543137194da9ed", "filename": "src/doc/book/testing.md", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Fdoc%2Fbook%2Ftesting.md", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Fdoc%2Fbook%2Ftesting.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Ftesting.md?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -589,11 +589,10 @@ please see the [Documentation chapter](documentation.html).\n \n # Testing and concurrency\n \n-One thing that is important to note when writing tests is that they may be run\n-concurrently using threads. For this reason you should take care that your tests\n-are written in such a way as to not depend on each-other, or on any shared\n-state. \"Shared state\" can also include the environment, such as the current\n-working directory, or environment variables.\n+It is important to note that tests are run concurrently using threads. For this\n+reason, care should be taken to ensure your tests do not depend on each-other,\n+or on any shared state. \"Shared state\" can also include the environment, such\n+as the current working directory, or environment variables.\n \n If this is an issue it is possible to control this concurrency, either by\n setting the environment variable `RUST_TEST_THREADS`, or by passing the argument"}, {"sha": "b5a91a170d8ed478b71b0bedf1a4cfde5d600a20", "filename": "src/doc/reference.md", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -1731,7 +1731,8 @@ of an item to see whether it should be allowed or not. This is where privacy\n warnings are generated, or otherwise \"you used a private item of another module\n and weren't allowed to.\"\n \n-By default, everything in Rust is *private*, with one exception. Enum variants\n+By default, everything in Rust is *private*, with two exceptions: Associated\n+items in a `pub` Trait are public by default; Enum variants\n in a `pub` enum are also public by default. When an item is declared as `pub`,\n it can be thought of as being accessible to the outside world. For example:\n "}, {"sha": "664bc0fdab0025c0e5111f448cb7f0c8ba7aa2ac", "filename": "src/doc/rust.css", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Fdoc%2Frust.css", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Fdoc%2Frust.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frust.css?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -44,7 +44,9 @@\n     font-family: 'Source Code Pro';\n     font-style: normal;\n     font-weight: 400;\n-    src: local('Source Code Pro'), url(\"SourceCodePro-Regular.woff\") format('woff');\n+    /* Avoid using locally installed font because bad versions are in circulation:\n+     * see https://github.com/rust-lang/rust/issues/24355 */\n+    src: url(\"SourceCodePro-Regular.woff\") format('woff');\n }\n \n *:not(body) {"}, {"sha": "1cad8f7f40788dc07c78b18203f1e80890e008a1", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -392,8 +392,6 @@ impl<T: ?Sized> Arc<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(arc_counts)]\n-    ///\n     /// use std::sync::Arc;\n     ///\n     /// let five = Arc::new(5);\n@@ -404,8 +402,7 @@ impl<T: ?Sized> Arc<T> {\n     /// assert_eq!(1, Arc::weak_count(&five));\n     /// ```\n     #[inline]\n-    #[unstable(feature = \"arc_counts\", reason = \"not clearly useful, and racy\",\n-               issue = \"28356\")]\n+    #[stable(feature = \"arc_counts\", since = \"1.15.0\")]\n     pub fn weak_count(this: &Self) -> usize {\n         this.inner().weak.load(SeqCst) - 1\n     }\n@@ -421,8 +418,6 @@ impl<T: ?Sized> Arc<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(arc_counts)]\n-    ///\n     /// use std::sync::Arc;\n     ///\n     /// let five = Arc::new(5);\n@@ -433,8 +428,7 @@ impl<T: ?Sized> Arc<T> {\n     /// assert_eq!(2, Arc::strong_count(&five));\n     /// ```\n     #[inline]\n-    #[unstable(feature = \"arc_counts\", reason = \"not clearly useful, and racy\",\n-               issue = \"28356\")]\n+    #[stable(feature = \"arc_counts\", since = \"1.15.0\")]\n     pub fn strong_count(this: &Self) -> usize {\n         this.inner().strong.load(SeqCst)\n     }"}, {"sha": "81ed4be7763e945d1c9338fb3f105696f98abe57", "filename": "src/liballoc/heap.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Fliballoc%2Fheap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Fliballoc%2Fheap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fheap.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -127,6 +127,7 @@ pub fn usable_size(size: usize, align: usize) -> usize {\n pub const EMPTY: *mut () = 0x1 as *mut ();\n \n /// The allocator for unique pointers.\n+// This function must not unwind. If it does, MIR trans will fail.\n #[cfg(not(test))]\n #[lang = \"exchange_malloc\"]\n #[inline]\n@@ -143,6 +144,7 @@ unsafe fn exchange_malloc(size: usize, align: usize) -> *mut u8 {\n }\n \n #[cfg(not(test))]\n+#[cfg(stage0)]\n #[lang = \"exchange_free\"]\n #[inline]\n unsafe fn exchange_free(ptr: *mut u8, old_size: usize, align: usize) {"}, {"sha": "86f8c746646aac2e26a8570f70d3ccad48335add", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 7, "deletions": 39, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -320,7 +320,7 @@ impl<T> Rc<T> {\n     #[inline]\n     #[stable(feature = \"rc_unique\", since = \"1.4.0\")]\n     pub fn try_unwrap(this: Self) -> Result<T, Self> {\n-        if Rc::would_unwrap(&this) {\n+        if Rc::strong_count(&this) == 1 {\n             unsafe {\n                 let val = ptr::read(&*this); // copy the contained object\n \n@@ -343,26 +343,10 @@ impl<T> Rc<T> {\n     ///\n     /// [try_unwrap]: struct.Rc.html#method.try_unwrap\n     /// [`Ok`]: ../../std/result/enum.Result.html#variant.Ok\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(rc_would_unwrap)]\n-    ///\n-    /// use std::rc::Rc;\n-    ///\n-    /// let x = Rc::new(3);\n-    /// assert!(Rc::would_unwrap(&x));\n-    /// assert_eq!(Rc::try_unwrap(x), Ok(3));\n-    ///\n-    /// let x = Rc::new(4);\n-    /// let _y = x.clone();\n-    /// assert!(!Rc::would_unwrap(&x));\n-    /// assert_eq!(*Rc::try_unwrap(x).unwrap_err(), 4);\n-    /// ```\n     #[unstable(feature = \"rc_would_unwrap\",\n                reason = \"just added for niche usecase\",\n                issue = \"28356\")]\n+    #[rustc_deprecated(since = \"1.15.0\", reason = \"too niche; use `strong_count` instead\")]\n     pub fn would_unwrap(this: &Self) -> bool {\n         Rc::strong_count(&this) == 1\n     }\n@@ -482,8 +466,6 @@ impl<T: ?Sized> Rc<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(rc_counts)]\n-    ///\n     /// use std::rc::Rc;\n     ///\n     /// let five = Rc::new(5);\n@@ -492,8 +474,7 @@ impl<T: ?Sized> Rc<T> {\n     /// assert_eq!(1, Rc::weak_count(&five));\n     /// ```\n     #[inline]\n-    #[unstable(feature = \"rc_counts\", reason = \"not clearly useful\",\n-               issue = \"28356\")]\n+    #[stable(feature = \"rc_counts\", since = \"1.15.0\")]\n     pub fn weak_count(this: &Self) -> usize {\n         this.weak() - 1\n     }\n@@ -503,8 +484,6 @@ impl<T: ?Sized> Rc<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(rc_counts)]\n-    ///\n     /// use std::rc::Rc;\n     ///\n     /// let five = Rc::new(5);\n@@ -513,8 +492,7 @@ impl<T: ?Sized> Rc<T> {\n     /// assert_eq!(2, Rc::strong_count(&five));\n     /// ```\n     #[inline]\n-    #[unstable(feature = \"rc_counts\", reason = \"not clearly useful\",\n-               issue = \"28356\")]\n+    #[stable(feature = \"rc_counts\", since = \"1.15.0\")]\n     pub fn strong_count(this: &Self) -> usize {\n         this.strong()\n     }\n@@ -523,21 +501,11 @@ impl<T: ?Sized> Rc<T> {\n     /// this inner value.\n     ///\n     /// [weak]: struct.Weak.html\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(rc_counts)]\n-    ///\n-    /// use std::rc::Rc;\n-    ///\n-    /// let five = Rc::new(5);\n-    ///\n-    /// assert!(Rc::is_unique(&five));\n-    /// ```\n     #[inline]\n-    #[unstable(feature = \"rc_counts\", reason = \"uniqueness has unclear meaning\",\n+    #[unstable(feature = \"is_unique\", reason = \"uniqueness has unclear meaning\",\n                issue = \"28356\")]\n+    #[rustc_deprecated(since = \"1.15.0\",\n+                       reason = \"too niche; use `strong_count` and `weak_count` instead\")]\n     pub fn is_unique(this: &Self) -> bool {\n         Rc::weak_count(this) == 0 && Rc::strong_count(this) == 1\n     }"}, {"sha": "2bbec9e5fc2250aa222d754896487ddd6e949234", "filename": "src/liballoc_jemalloc/build.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Fliballoc_jemalloc%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Fliballoc_jemalloc%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc_jemalloc%2Fbuild.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -36,7 +36,8 @@ fn main() {\n     // targets, which means we have to build the alloc_jemalloc crate\n     // for targets like emscripten, even if we don't use it.\n     if target.contains(\"rumprun\") || target.contains(\"bitrig\") || target.contains(\"openbsd\") ||\n-       target.contains(\"msvc\") || target.contains(\"emscripten\") || target.contains(\"fuchsia\") {\n+       target.contains(\"msvc\") || target.contains(\"emscripten\") || target.contains(\"fuchsia\") ||\n+       target.contains(\"redox\") {\n         println!(\"cargo:rustc-cfg=dummy_jemalloc\");\n         return;\n     }\n@@ -151,7 +152,7 @@ fn main() {\n     cmd.arg(format!(\"--build={}\", build_helper::gnu_target(&host)));\n \n     run(&mut cmd);\n-    let mut make = Command::new(\"make\");\n+    let mut make = Command::new(build_helper::make(&host));\n     make.current_dir(&build_dir)\n         .arg(\"build_lib_static\");\n "}, {"sha": "4daa6cbb8465e58e7d939ef68617c46e0fc0b122", "filename": "src/liballoc_system/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Fliballoc_system%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Fliballoc_system%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc_system%2Flib.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -19,7 +19,7 @@\n             issue = \"27783\")]\n #![feature(allocator)]\n #![feature(staged_api)]\n-#![cfg_attr(unix, feature(libc))]\n+#![cfg_attr(any(unix, target_os = \"redox\"), feature(libc))]\n \n // The minimum alignment guaranteed by the architecture. This value is used to\n // add fast paths for low alignment values. In practice, the alignment is a\n@@ -71,7 +71,7 @@ pub extern \"C\" fn __rust_usable_size(size: usize, align: usize) -> usize {\n     imp::usable_size(size, align)\n }\n \n-#[cfg(unix)]\n+#[cfg(any(unix, target_os = \"redox\"))]\n mod imp {\n     extern crate libc;\n \n@@ -87,7 +87,7 @@ mod imp {\n         }\n     }\n \n-    #[cfg(target_os = \"android\")]\n+    #[cfg(any(target_os = \"android\", target_os = \"redox\"))]\n     unsafe fn aligned_malloc(size: usize, align: usize) -> *mut u8 {\n         // On android we currently target API level 9 which unfortunately\n         // doesn't have the `posix_memalign` API used below. Instead we use\n@@ -109,7 +109,7 @@ mod imp {\n         libc::memalign(align as libc::size_t, size as libc::size_t) as *mut u8\n     }\n \n-    #[cfg(not(target_os = \"android\"))]\n+    #[cfg(not(any(target_os = \"android\", target_os = \"redox\")))]\n     unsafe fn aligned_malloc(size: usize, align: usize) -> *mut u8 {\n         let mut out = ptr::null_mut();\n         let ret = libc::posix_memalign(&mut out, align as libc::size_t, size as libc::size_t);"}, {"sha": "c5d5ad27d2304923dc51aa9196933c78072475b6", "filename": "src/libcollections/binary_heap.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbinary_heap.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -225,7 +225,7 @@ pub struct BinaryHeap<T> {\n /// [`peek_mut()`]: struct.BinaryHeap.html#method.peek_mut\n #[stable(feature = \"binary_heap_peek_mut\", since = \"1.12.0\")]\n pub struct PeekMut<'a, T: 'a + Ord> {\n-    heap: &'a mut BinaryHeap<T>\n+    heap: &'a mut BinaryHeap<T>,\n }\n \n #[stable(feature = \"binary_heap_peek_mut\", since = \"1.12.0\")]\n@@ -385,9 +385,7 @@ impl<T: Ord> BinaryHeap<T> {\n         if self.is_empty() {\n             None\n         } else {\n-            Some(PeekMut {\n-                heap: self\n-            })\n+            Some(PeekMut { heap: self })\n         }\n     }\n \n@@ -1126,7 +1124,9 @@ impl<T: Ord> IntoIterator for BinaryHeap<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, T> IntoIterator for &'a BinaryHeap<T> where T: Ord {\n+impl<'a, T> IntoIterator for &'a BinaryHeap<T>\n+    where T: Ord\n+{\n     type Item = &'a T;\n     type IntoIter = Iter<'a, T>;\n "}, {"sha": "e5bcf0d8e81797d97d2cf134f9a04aa16ac21de2", "filename": "src/libcollections/borrow.rs", "status": "modified", "additions": 25, "deletions": 11, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibcollections%2Fborrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibcollections%2Fborrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fborrow.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -63,7 +63,9 @@ pub trait ToOwned {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> ToOwned for T where T: Clone {\n+impl<T> ToOwned for T\n+    where T: Clone\n+{\n     type Owned = T;\n     fn to_owned(&self) -> T {\n         self.clone()\n@@ -117,17 +119,19 @@ pub enum Cow<'a, B: ?Sized + 'a>\n {\n     /// Borrowed data.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    Borrowed(#[stable(feature = \"rust1\", since = \"1.0.0\")] &'a B),\n+    Borrowed(#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+             &'a B),\n \n     /// Owned data.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    Owned(\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")] <B as ToOwned>::Owned\n-    ),\n+    Owned(#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+          <B as ToOwned>::Owned),\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, B: ?Sized> Clone for Cow<'a, B> where B: ToOwned {\n+impl<'a, B: ?Sized> Clone for Cow<'a, B>\n+    where B: ToOwned\n+{\n     fn clone(&self) -> Cow<'a, B> {\n         match *self {\n             Borrowed(b) => Borrowed(b),\n@@ -139,7 +143,9 @@ impl<'a, B: ?Sized> Clone for Cow<'a, B> where B: ToOwned {\n     }\n }\n \n-impl<'a, B: ?Sized> Cow<'a, B> where B: ToOwned {\n+impl<'a, B: ?Sized> Cow<'a, B>\n+    where B: ToOwned\n+{\n     /// Acquires a mutable reference to the owned form of the data.\n     ///\n     /// Clones the data if it is not already owned.\n@@ -194,7 +200,9 @@ impl<'a, B: ?Sized> Cow<'a, B> where B: ToOwned {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, B: ?Sized> Deref for Cow<'a, B> where B: ToOwned {\n+impl<'a, B: ?Sized> Deref for Cow<'a, B>\n+    where B: ToOwned\n+{\n     type Target = B;\n \n     fn deref(&self) -> &B {\n@@ -209,7 +217,9 @@ impl<'a, B: ?Sized> Deref for Cow<'a, B> where B: ToOwned {\n impl<'a, B: ?Sized> Eq for Cow<'a, B> where B: Eq + ToOwned {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, B: ?Sized> Ord for Cow<'a, B> where B: Ord + ToOwned {\n+impl<'a, B: ?Sized> Ord for Cow<'a, B>\n+    where B: Ord + ToOwned\n+{\n     #[inline]\n     fn cmp(&self, other: &Cow<'a, B>) -> Ordering {\n         Ord::cmp(&**self, &**other)\n@@ -228,7 +238,9 @@ impl<'a, 'b, B: ?Sized, C: ?Sized> PartialEq<Cow<'b, C>> for Cow<'a, B>\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, B: ?Sized> PartialOrd for Cow<'a, B> where B: PartialOrd + ToOwned {\n+impl<'a, B: ?Sized> PartialOrd for Cow<'a, B>\n+    where B: PartialOrd + ToOwned\n+{\n     #[inline]\n     fn partial_cmp(&self, other: &Cow<'a, B>) -> Option<Ordering> {\n         PartialOrd::partial_cmp(&**self, &**other)\n@@ -273,7 +285,9 @@ impl<'a, B: ?Sized> Default for Cow<'a, B>\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, B: ?Sized> Hash for Cow<'a, B> where B: Hash + ToOwned {\n+impl<'a, B: ?Sized> Hash for Cow<'a, B>\n+    where B: Hash + ToOwned\n+{\n     #[inline]\n     fn hash<H: Hasher>(&self, state: &mut H) {\n         Hash::hash(&**self, state)"}, {"sha": "34674e3a0bd3098da987525b68812ba805970817", "filename": "src/libcollections/btree/set.rs", "status": "modified", "additions": 58, "deletions": 11, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fset.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -74,53 +74,89 @@ pub struct BTreeSet<T> {\n     map: BTreeMap<T, ()>,\n }\n \n-/// An iterator over a BTreeSet's items.\n+/// An iterator over a `BTreeSet`'s items.\n+///\n+/// This structure is created by the [`iter`] method on [`BTreeSet`].\n+///\n+/// [`BTreeSet`]: struct.BTreeSet.html\n+/// [`iter`]: struct.BTreeSet.html#method.iter\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Iter<'a, T: 'a> {\n     iter: Keys<'a, T, ()>,\n }\n \n-/// An owning iterator over a BTreeSet's items.\n+/// An owning iterator over a `BTreeSet`'s items.\n+///\n+/// This structure is created by the `into_iter` method on [`BTreeSet`]\n+/// [`BTreeSet`] (provided by the `IntoIterator` trait).\n+///\n+/// [`BTreeSet`]: struct.BTreeSet.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IntoIter<T> {\n     iter: ::btree_map::IntoIter<T, ()>,\n }\n \n-/// An iterator over a sub-range of BTreeSet's items.\n+/// An iterator over a sub-range of `BTreeSet`'s items.\n+///\n+/// This structure is created by the [`range`] method on [`BTreeSet`].\n+///\n+/// [`BTreeSet`]: struct.BTreeSet.html\n+/// [`range`]: struct.BTreeSet.html#method.range\n pub struct Range<'a, T: 'a> {\n     iter: ::btree_map::Range<'a, T, ()>,\n }\n \n /// A lazy iterator producing elements in the set difference (in-order).\n+///\n+/// This structure is created by the [`difference`] method on [`BTreeSet`].\n+///\n+/// [`BTreeSet`]: struct.BTreeSet.html\n+/// [`difference`]: struct.BTreeSet.html#method.difference\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Difference<'a, T: 'a> {\n     a: Peekable<Iter<'a, T>>,\n     b: Peekable<Iter<'a, T>>,\n }\n \n /// A lazy iterator producing elements in the set symmetric difference (in-order).\n+///\n+/// This structure is created by the [`symmetric_difference`] method on\n+/// [`BTreeSet`].\n+///\n+/// [`BTreeSet`]: struct.BTreeSet.html\n+/// [`symmetric_difference`]: struct.BTreeSet.html#method.symmetric_difference\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct SymmetricDifference<'a, T: 'a> {\n     a: Peekable<Iter<'a, T>>,\n     b: Peekable<Iter<'a, T>>,\n }\n \n /// A lazy iterator producing elements in the set intersection (in-order).\n+///\n+/// This structure is created by the [`intersection`] method on [`BTreeSet`].\n+///\n+/// [`BTreeSet`]: struct.BTreeSet.html\n+/// [`intersection`]: struct.BTreeSet.html#method.intersection\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Intersection<'a, T: 'a> {\n     a: Peekable<Iter<'a, T>>,\n     b: Peekable<Iter<'a, T>>,\n }\n \n /// A lazy iterator producing elements in the set union (in-order).\n+///\n+/// This structure is created by the [`union`] method on [`BTreeSet`].\n+///\n+/// [`BTreeSet`]: struct.BTreeSet.html\n+/// [`union`]: struct.BTreeSet.html#method.union\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Union<'a, T: 'a> {\n     a: Peekable<Iter<'a, T>>,\n     b: Peekable<Iter<'a, T>>,\n }\n \n impl<T: Ord> BTreeSet<T> {\n-    /// Makes a new BTreeSet with a reasonable choice of B.\n+    /// Makes a new `BTreeSet` with a reasonable choice of B.\n     ///\n     /// # Examples\n     ///\n@@ -137,21 +173,32 @@ impl<T: Ord> BTreeSet<T> {\n }\n \n impl<T> BTreeSet<T> {\n-    /// Gets an iterator over the BTreeSet's contents.\n+    /// Gets an iterator that visits the values in the `BTreeSet` in ascending order.\n     ///\n     /// # Examples\n     ///\n     /// ```\n     /// use std::collections::BTreeSet;\n     ///\n-    /// let set: BTreeSet<usize> = [1, 2, 3, 4].iter().cloned().collect();\n+    /// let set: BTreeSet<usize> = [1, 2, 3].iter().cloned().collect();\n+    /// let mut set_iter = set.iter();\n+    /// assert_eq!(set_iter.next(), Some(&1));\n+    /// assert_eq!(set_iter.next(), Some(&2));\n+    /// assert_eq!(set_iter.next(), Some(&3));\n+    /// assert_eq!(set_iter.next(), None);\n+    /// ```\n     ///\n-    /// for x in set.iter() {\n-    ///     println!(\"{}\", x);\n-    /// }\n+    /// Values returned by the iterator are returned in ascending order:\n     ///\n-    /// let v: Vec<_> = set.iter().cloned().collect();\n-    /// assert_eq!(v, [1, 2, 3, 4]);\n+    /// ```\n+    /// use std::collections::BTreeSet;\n+    ///\n+    /// let set: BTreeSet<usize> = [3, 1, 2].iter().cloned().collect();\n+    /// let mut set_iter = set.iter();\n+    /// assert_eq!(set_iter.next(), Some(&1));\n+    /// assert_eq!(set_iter.next(), Some(&2));\n+    /// assert_eq!(set_iter.next(), Some(&3));\n+    /// assert_eq!(set_iter.next(), None);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter(&self) -> Iter<T> {"}, {"sha": "87bc5e59ef78c178cff569aa19dba980dd42ded5", "filename": "src/libcollections/enum_set.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibcollections%2Fenum_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibcollections%2Fenum_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fenum_set.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -276,7 +276,8 @@ impl<E: CLike> FromIterator<E> for EnumSet<E> {\n     }\n }\n \n-impl<'a, E> IntoIterator for &'a EnumSet<E> where E: CLike\n+impl<'a, E> IntoIterator for &'a EnumSet<E>\n+    where E: CLike\n {\n     type Item = E;\n     type IntoIter = Iter<E>;"}, {"sha": "310855090885caf3ecf48100cfe6490d36f39cd1", "filename": "src/libcollections/linked_list.rs", "status": "modified", "additions": 49, "deletions": 21, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibcollections%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibcollections%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flinked_list.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -10,8 +10,15 @@\n \n //! A doubly-linked list with owned nodes.\n //!\n-//! The `LinkedList` allows pushing and popping elements at either end and is thus\n-//! efficiently usable as a double-ended queue.\n+//! The `LinkedList` allows pushing and popping elements at either end\n+//! in constant time.\n+//!\n+//! Almost always it is better to use `Vec` or [`VecDeque`] instead of\n+//! [`LinkedList`]. In general, array-based containers are faster,\n+//! more memory efficient and make better use of CPU cache.\n+//!\n+//! [`LinkedList`]: ../linked_list/struct.LinkedList.html\n+//! [`VecDeque`]: ../vec_deque/struct.VecDeque.html\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n@@ -27,7 +34,14 @@ use core::ptr::{self, Shared};\n \n use super::SpecExtend;\n \n-/// A doubly-linked list.\n+/// A doubly-linked list with owned nodes.\n+///\n+/// The `LinkedList` allows pushing and popping elements at either end\n+/// in constant time.\n+///\n+/// Almost always it is better to use `Vec` or `VecDeque` instead of\n+/// `LinkedList`. In general, array-based containers are faster,\n+/// more memory efficient and make better use of CPU cache.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct LinkedList<T> {\n     head: Option<Shared<Node<T>>>,\n@@ -225,15 +239,17 @@ impl<T> LinkedList<T> {\n     pub fn append(&mut self, other: &mut Self) {\n         match self.tail {\n             None => mem::swap(self, other),\n-            Some(tail) => if let Some(other_head) = other.head.take() {\n-                unsafe {\n-                    (**tail).next = Some(other_head);\n-                    (**other_head).prev = Some(tail);\n-                }\n+            Some(tail) => {\n+                if let Some(other_head) = other.head.take() {\n+                    unsafe {\n+                        (**tail).next = Some(other_head);\n+                        (**other_head).prev = Some(tail);\n+                    }\n \n-                self.tail = other.tail.take();\n-                self.len += mem::replace(&mut other.len, 0);\n-            },\n+                    self.tail = other.tail.take();\n+                    self.len += mem::replace(&mut other.len, 0);\n+                }\n+            }\n         }\n     }\n \n@@ -674,7 +690,10 @@ impl<T> LinkedList<T> {\n                reason = \"method name and placement protocol are subject to change\",\n                issue = \"30172\")]\n     pub fn front_place(&mut self) -> FrontPlace<T> {\n-        FrontPlace { list: self, node: IntermediateBox::make_place() }\n+        FrontPlace {\n+            list: self,\n+            node: IntermediateBox::make_place(),\n+        }\n     }\n \n     /// Returns a place for insertion at the back of the list.\n@@ -699,7 +718,10 @@ impl<T> LinkedList<T> {\n                reason = \"method name and placement protocol are subject to change\",\n                issue = \"30172\")]\n     pub fn back_place(&mut self) -> BackPlace<T> {\n-        BackPlace { list: self, node: IntermediateBox::make_place() }\n+        BackPlace {\n+            list: self,\n+            node: IntermediateBox::make_place(),\n+        }\n     }\n }\n \n@@ -852,7 +874,7 @@ impl<'a, T> IterMut<'a, T> {\n                 (**head).prev = node;\n \n                 self.list.len += 1;\n-            }\n+            },\n         }\n     }\n \n@@ -1135,9 +1157,15 @@ impl<'a, T> InPlace<T> for BackPlace<'a, T> {\n // Ensure that `LinkedList` and its read-only iterators are covariant in their type parameters.\n #[allow(dead_code)]\n fn assert_covariance() {\n-    fn a<'a>(x: LinkedList<&'static str>) -> LinkedList<&'a str> { x }\n-    fn b<'i, 'a>(x: Iter<'i, &'static str>) -> Iter<'i, &'a str> { x }\n-    fn c<'a>(x: IntoIter<&'static str>) -> IntoIter<&'a str> { x }\n+    fn a<'a>(x: LinkedList<&'static str>) -> LinkedList<&'a str> {\n+        x\n+    }\n+    fn b<'i, 'a>(x: Iter<'i, &'static str>) -> Iter<'i, &'a str> {\n+        x\n+    }\n+    fn c<'a>(x: IntoIter<&'static str>) -> IntoIter<&'a str> {\n+        x\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1298,10 +1326,10 @@ mod tests {\n     fn test_send() {\n         let n = list_from(&[1, 2, 3]);\n         thread::spawn(move || {\n-            check_links(&n);\n-            let a: &[_] = &[&1, &2, &3];\n-            assert_eq!(a, &n.iter().collect::<Vec<_>>()[..]);\n-        })\n+                check_links(&n);\n+                let a: &[_] = &[&1, &2, &3];\n+                assert_eq!(a, &n.iter().collect::<Vec<_>>()[..]);\n+            })\n             .join()\n             .ok()\n             .unwrap();"}, {"sha": "b5e6669220535282c1694e44c79264c970e62540", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -1496,10 +1496,10 @@ unsafe fn merge<T, F>(v: &mut [T], mid: usize, buf: *mut T, compare: &mut F)\n /// The algorithm identifies strictly descending and non-descending subsequences, which are called\n /// natural runs. There is a stack of pending runs yet to be merged. Each newly found run is pushed\n /// onto the stack, and then some pairs of adjacent runs are merged until these two invariants are\n-/// satisfied, for every `i` in `0 .. runs.len() - 2`:\n+/// satisfied:\n ///\n-/// 1. `runs[i].len > runs[i + 1].len`\n-/// 2. `runs[i].len > runs[i + 1].len + runs[i + 2].len`\n+/// 1. for every `i` in `1..runs.len()`: `runs[i - 1].len > runs[i].len`\n+/// 2. for every `i` in `2..runs.len()`: `runs[i - 2].len > runs[i - 1].len + runs[i].len`\n ///\n /// The invariants ensure that the total running time is `O(n log n)` worst-case.\n fn merge_sort<T, F>(v: &mut [T], mut compare: F)"}, {"sha": "70cedce9a905e7bebaeb536b25eadae5f38c2af8", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -1697,11 +1697,7 @@ impl str {\n             debug_assert!('\u03a3'.len_utf8() == 2);\n             let is_word_final = case_ignoreable_then_cased(from[..i].chars().rev()) &&\n                                 !case_ignoreable_then_cased(from[i + 2..].chars());\n-            to.push_str(if is_word_final {\n-                \"\u03c2\"\n-            } else {\n-                \"\u03c3\"\n-            });\n+            to.push_str(if is_word_final { \"\u03c2\" } else { \"\u03c3\" });\n         }\n \n         fn case_ignoreable_then_cased<I: Iterator<Item = char>>(iter: I) -> bool {"}, {"sha": "157c762b4a7ed3767cb223852dd5a4c67681fef1", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -542,11 +542,7 @@ impl String {\n             unsafe { *xs.get_unchecked(i) }\n         }\n         fn safe_get(xs: &[u8], i: usize, total: usize) -> u8 {\n-            if i >= total {\n-                0\n-            } else {\n-                unsafe_get(xs, i)\n-            }\n+            if i >= total { 0 } else { unsafe_get(xs, i) }\n         }\n \n         let mut res = String::with_capacity(total);\n@@ -976,7 +972,7 @@ impl String {\n     pub fn push(&mut self, ch: char) {\n         match ch.len_utf8() {\n             1 => self.vec.push(ch as u8),\n-            _ => self.vec.extend_from_slice(ch.encode_utf8(&mut [0;4]).as_bytes()),\n+            _ => self.vec.extend_from_slice(ch.encode_utf8(&mut [0; 4]).as_bytes()),\n         }\n     }\n \n@@ -1935,7 +1931,7 @@ impl<'a> FromIterator<String> for Cow<'a, str> {\n \n #[stable(feature = \"from_string_for_vec_u8\", since = \"1.14.0\")]\n impl From<String> for Vec<u8> {\n-    fn from(string : String) -> Vec<u8> {\n+    fn from(string: String) -> Vec<u8> {\n         string.into_bytes()\n     }\n }"}, {"sha": "f2ef54f6e56794cdb67ed26f59ed77b36344675f", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -1902,14 +1902,13 @@ impl<T> IntoIter<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(vec_into_iter_as_slice)]\n     /// let vec = vec!['a', 'b', 'c'];\n     /// let mut into_iter = vec.into_iter();\n     /// assert_eq!(into_iter.as_slice(), &['a', 'b', 'c']);\n     /// let _ = into_iter.next().unwrap();\n     /// assert_eq!(into_iter.as_slice(), &['b', 'c']);\n     /// ```\n-    #[unstable(feature = \"vec_into_iter_as_slice\", issue = \"35601\")]\n+    #[stable(feature = \"vec_into_iter_as_slice\", since = \"1.15.0\")]\n     pub fn as_slice(&self) -> &[T] {\n         unsafe {\n             slice::from_raw_parts(self.ptr, self.len())\n@@ -1921,7 +1920,6 @@ impl<T> IntoIter<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(vec_into_iter_as_slice)]\n     /// let vec = vec!['a', 'b', 'c'];\n     /// let mut into_iter = vec.into_iter();\n     /// assert_eq!(into_iter.as_slice(), &['a', 'b', 'c']);\n@@ -1930,7 +1928,7 @@ impl<T> IntoIter<T> {\n     /// assert_eq!(into_iter.next().unwrap(), 'b');\n     /// assert_eq!(into_iter.next().unwrap(), 'z');\n     /// ```\n-    #[unstable(feature = \"vec_into_iter_as_slice\", issue = \"35601\")]\n+    #[stable(feature = \"vec_into_iter_as_slice\", since = \"1.15.0\")]\n     pub fn as_mut_slice(&self) -> &mut [T] {\n         unsafe {\n             slice::from_raw_parts_mut(self.ptr as *mut T, self.len())"}, {"sha": "67621b860bf391c5ad964a8e2b9f5bd23aecebc8", "filename": "src/libcollections/vec_deque.rs", "status": "modified", "additions": 35, "deletions": 48, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_deque.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -206,11 +206,7 @@ impl<T> VecDeque<T> {\n     unsafe fn wrap_copy(&self, dst: usize, src: usize, len: usize) {\n         #[allow(dead_code)]\n         fn diff(a: usize, b: usize) -> usize {\n-            if a <= b {\n-                b - a\n-            } else {\n-                a - b\n-            }\n+            if a <= b { b - a } else { a - b }\n         }\n         debug_assert!(cmp::min(diff(dst, src), self.cap() - diff(dst, src)) + len <= self.cap(),\n                       \"wrc dst={} src={} len={} cap={}\",\n@@ -552,8 +548,8 @@ impl<T> VecDeque<T> {\n         let old_cap = self.cap();\n         let used_cap = self.len() + 1;\n         let new_cap = used_cap.checked_add(additional)\n-                              .and_then(|needed_cap| needed_cap.checked_next_power_of_two())\n-                              .expect(\"capacity overflow\");\n+            .and_then(|needed_cap| needed_cap.checked_next_power_of_two())\n+            .expect(\"capacity overflow\");\n \n         if new_cap > self.capacity() {\n             self.buf.reserve_exact(used_cap, new_cap - used_cap);\n@@ -1293,9 +1289,7 @@ impl<T> VecDeque<T> {\n \n         let contiguous = self.is_contiguous();\n \n-        match (contiguous,\n-               distance_to_tail <= distance_to_head,\n-               idx >= self.tail) {\n+        match (contiguous, distance_to_tail <= distance_to_head, idx >= self.tail) {\n             (true, true, _) if index == 0 => {\n                 // push_front\n                 //\n@@ -1513,9 +1507,7 @@ impl<T> VecDeque<T> {\n \n         let contiguous = self.is_contiguous();\n \n-        match (contiguous,\n-               distance_to_tail <= distance_to_head,\n-               idx >= self.tail) {\n+        match (contiguous, distance_to_tail <= distance_to_head, idx >= self.tail) {\n             (true, true, _) => {\n                 unsafe {\n                     // contiguous, remove closer to tail:\n@@ -1812,7 +1804,7 @@ fn wrap_index(index: usize, size: usize) -> usize {\n }\n \n /// Returns the two slices that cover the VecDeque's valid range\n-trait RingSlices : Sized {\n+trait RingSlices: Sized {\n     fn slice(self, from: usize, to: usize) -> Self;\n     fn split_at(self, i: usize) -> (Self, Self);\n \n@@ -1895,7 +1887,7 @@ impl<'a, T> Iterator for Iter<'a, T> {\n     }\n \n     fn fold<Acc, F>(self, mut accum: Acc, mut f: F) -> Acc\n-        where F: FnMut(Acc, Self::Item) -> Acc,\n+        where F: FnMut(Acc, Self::Item) -> Acc\n     {\n         let (front, back) = RingSlices::ring_slices(self.ring, self.head, self.tail);\n         accum = front.iter().fold(accum, &mut f);\n@@ -1959,7 +1951,7 @@ impl<'a, T> Iterator for IterMut<'a, T> {\n     }\n \n     fn fold<Acc, F>(self, mut accum: Acc, mut f: F) -> Acc\n-        where F: FnMut(Acc, Self::Item) -> Acc,\n+        where F: FnMut(Acc, Self::Item) -> Acc\n     {\n         let (front, back) = RingSlices::ring_slices(self.ring, self.head, self.tail);\n         accum = front.iter_mut().fold(accum, &mut f);\n@@ -2082,17 +2074,15 @@ impl<'a, T: 'a> Drop for Drain<'a, T> {\n             (_, 0) => {\n                 source_deque.head = drain_tail;\n             }\n-            _ => {\n-                unsafe {\n-                    if tail_len <= head_len {\n-                        source_deque.tail = source_deque.wrap_sub(drain_head, tail_len);\n-                        source_deque.wrap_copy(source_deque.tail, orig_tail, tail_len);\n-                    } else {\n-                        source_deque.head = source_deque.wrap_add(drain_tail, head_len);\n-                        source_deque.wrap_copy(drain_tail, drain_head, head_len);\n-                    }\n+            _ => unsafe {\n+                if tail_len <= head_len {\n+                    source_deque.tail = source_deque.wrap_sub(drain_head, tail_len);\n+                    source_deque.wrap_copy(source_deque.tail, orig_tail, tail_len);\n+                } else {\n+                    source_deque.head = source_deque.wrap_add(drain_tail, head_len);\n+                    source_deque.wrap_copy(drain_tail, drain_head, head_len);\n                 }\n-            }\n+            },\n         }\n     }\n }\n@@ -2288,18 +2278,16 @@ impl<T> From<Vec<T>> for VecDeque<T> {\n \n             // We need to extend the buf if it's not a power of two, too small\n             // or doesn't have at least one free space\n-            if !buf.cap().is_power_of_two()\n-                || (buf.cap() < (MINIMUM_CAPACITY + 1))\n-                || (buf.cap() == len)\n-            {\n+            if !buf.cap().is_power_of_two() || (buf.cap() < (MINIMUM_CAPACITY + 1)) ||\n+               (buf.cap() == len) {\n                 let cap = cmp::max(buf.cap() + 1, MINIMUM_CAPACITY + 1).next_power_of_two();\n                 buf.reserve_exact(len, cap - len);\n             }\n \n             VecDeque {\n                 tail: 0,\n                 head: len,\n-                buf: buf\n+                buf: buf,\n             }\n         }\n     }\n@@ -2324,18 +2312,17 @@ impl<T> From<VecDeque<T>> for Vec<T> {\n                     // do this in at most three copy moves.\n                     if (cap - tail) > head {\n                         // right hand block is the long one; move that enough for the left\n-                        ptr::copy(\n-                            buf.offset(tail as isize),\n-                            buf.offset((tail - head) as isize),\n-                            cap - tail);\n+                        ptr::copy(buf.offset(tail as isize),\n+                                  buf.offset((tail - head) as isize),\n+                                  cap - tail);\n                         // copy left in the end\n                         ptr::copy(buf, buf.offset((cap - head) as isize), head);\n                         // shift the new thing to the start\n-                        ptr::copy(buf.offset((tail-head) as isize), buf, len);\n+                        ptr::copy(buf.offset((tail - head) as isize), buf, len);\n                     } else {\n                         // left hand block is the long one, we can do it in two!\n-                        ptr::copy(buf, buf.offset((cap-tail) as isize), head);\n-                        ptr::copy(buf.offset(tail as isize), buf, cap-tail);\n+                        ptr::copy(buf, buf.offset((cap - tail) as isize), head);\n+                        ptr::copy(buf.offset(tail as isize), buf, cap - tail);\n                     }\n                 } else {\n                     // Need to use N swaps to move the ring\n@@ -2576,8 +2563,8 @@ mod tests {\n \n                         // We should see the correct values in the VecDeque\n                         let expected: VecDeque<_> = (0..drain_start)\n-                                                        .chain(drain_end..len)\n-                                                        .collect();\n+                            .chain(drain_end..len)\n+                            .collect();\n                         assert_eq!(expected, tester);\n                     }\n                 }\n@@ -2693,19 +2680,19 @@ mod tests {\n             let cap = (2i32.pow(cap_pwr) - 1) as usize;\n \n             // In these cases there is enough free space to solve it with copies\n-            for len in 0..((cap+1)/2) {\n+            for len in 0..((cap + 1) / 2) {\n                 // Test contiguous cases\n-                for offset in 0..(cap-len) {\n+                for offset in 0..(cap - len) {\n                     create_vec_and_test_convert(cap, offset, len)\n                 }\n \n                 // Test cases where block at end of buffer is bigger than block at start\n-                for offset in (cap-len)..(cap-(len/2)) {\n+                for offset in (cap - len)..(cap - (len / 2)) {\n                     create_vec_and_test_convert(cap, offset, len)\n                 }\n \n                 // Test cases where block at start of buffer is bigger than block at end\n-                for offset in (cap-(len/2))..cap {\n+                for offset in (cap - (len / 2))..cap {\n                     create_vec_and_test_convert(cap, offset, len)\n                 }\n             }\n@@ -2714,19 +2701,19 @@ mod tests {\n             // the ring will use swapping when:\n             // (cap + 1 - offset) > (cap + 1 - len) && (len - (cap + 1 - offset)) > (cap + 1 - len))\n             //  right block size  >   free space    &&      left block size       >    free space\n-            for len in ((cap+1)/2)..cap {\n+            for len in ((cap + 1) / 2)..cap {\n                 // Test contiguous cases\n-                for offset in 0..(cap-len) {\n+                for offset in 0..(cap - len) {\n                     create_vec_and_test_convert(cap, offset, len)\n                 }\n \n                 // Test cases where block at end of buffer is bigger than block at start\n-                for offset in (cap-len)..(cap-(len/2)) {\n+                for offset in (cap - len)..(cap - (len / 2)) {\n                     create_vec_and_test_convert(cap, offset, len)\n                 }\n \n                 // Test cases where block at start of buffer is bigger than block at end\n-                for offset in (cap-(len/2))..cap {\n+                for offset in (cap - (len / 2))..cap {\n                     create_vec_and_test_convert(cap, offset, len)\n                 }\n             }"}, {"sha": "d4fb5ea03adea50071566bff326a29e763fee87a", "filename": "src/libcollectionstest/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibcollectionstest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibcollectionstest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Flib.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -29,7 +29,6 @@\n #![feature(test)]\n #![feature(unboxed_closures)]\n #![feature(unicode)]\n-#![feature(vec_into_iter_as_slice)]\n \n extern crate collections;\n extern crate test;"}, {"sha": "44aa08e245873511bcc1d86302df813d9f2a8374", "filename": "src/libcompiler_builtins/build.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibcompiler_builtins%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibcompiler_builtins%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcompiler_builtins%2Fbuild.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -242,7 +242,7 @@ fn main() {\n                          \"atomic_thread_fence.c\"]);\n     }\n \n-    if !target.contains(\"windows\") {\n+    if !target.contains(\"redox\") && !target.contains(\"windows\") {\n         sources.extend(&[\"emutls.c\"]);\n     }\n "}, {"sha": "c3f862e7c5418b5a8bb4d14ffe1a02fc87c9492f", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -393,6 +393,8 @@ pub struct RefCell<T: ?Sized> {\n /// An enumeration of values returned from the `state` method on a `RefCell<T>`.\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n #[unstable(feature = \"borrow_state\", issue = \"27733\")]\n+#[rustc_deprecated(since = \"1.15.0\", reason = \"use `try_borrow` instead\")]\n+#[allow(deprecated)]\n pub enum BorrowState {\n     /// The cell is currently being read, there is at least one active `borrow`.\n     Reading,\n@@ -511,6 +513,8 @@ impl<T: ?Sized> RefCell<T> {\n     /// }\n     /// ```\n     #[unstable(feature = \"borrow_state\", issue = \"27733\")]\n+    #[rustc_deprecated(since = \"1.15.0\", reason = \"use `try_borrow` instead\")]\n+    #[allow(deprecated)]\n     #[inline]\n     pub fn borrow_state(&self) -> BorrowState {\n         match self.borrow.get() {\n@@ -888,9 +892,7 @@ impl<'b, T: ?Sized> Ref<'b, T> {\n     /// `Ref::clone(...)`.  A `Clone` implementation or a method would interfere\n     /// with the widespread use of `r.borrow().clone()` to clone the contents of\n     /// a `RefCell`.\n-    #[unstable(feature = \"cell_extras\",\n-               reason = \"likely to be moved to a method, pending language changes\",\n-               issue = \"27746\")]\n+    #[stable(feature = \"cell_extras\", since = \"1.15.0\")]\n     #[inline]\n     pub fn clone(orig: &Ref<'b, T>) -> Ref<'b, T> {\n         Ref {"}, {"sha": "c14ae6e08987357b19c3e26fd568e37a4f3d8d23", "filename": "src/libcore/char.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -327,9 +327,9 @@ pub trait CharExt {\n     fn len_utf8(self) -> usize;\n     #[stable(feature = \"core\", since = \"1.6.0\")]\n     fn len_utf16(self) -> usize;\n-    #[unstable(feature = \"unicode\", issue = \"27784\")]\n+    #[stable(feature = \"unicode_encode_char\", since = \"1.15.0\")]\n     fn encode_utf8(self, dst: &mut [u8]) -> &mut str;\n-    #[unstable(feature = \"unicode\", issue = \"27784\")]\n+    #[stable(feature = \"unicode_encode_char\", since = \"1.15.0\")]\n     fn encode_utf16(self, dst: &mut [u16]) -> &mut [u16];\n }\n "}, {"sha": "2ba7d6e8bd1ac4d885c9edc336762950f8fe1ff6", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -12,7 +12,7 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-use cell::{UnsafeCell, Cell, RefCell, Ref, RefMut, BorrowState};\n+use cell::{UnsafeCell, Cell, RefCell, Ref, RefMut};\n use marker::PhantomData;\n use mem;\n use num::flt2dec;\n@@ -1634,13 +1634,13 @@ impl<T: Copy + Debug> Debug for Cell<T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized + Debug> Debug for RefCell<T> {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n-        match self.borrow_state() {\n-            BorrowState::Unused | BorrowState::Reading => {\n+        match self.try_borrow() {\n+            Ok(borrow) => {\n                 f.debug_struct(\"RefCell\")\n-                    .field(\"value\", &self.borrow())\n+                    .field(\"value\", &borrow)\n                     .finish()\n             }\n-            BorrowState::Writing => {\n+            Err(_) => {\n                 f.debug_struct(\"RefCell\")\n                     .field(\"value\", &\"<borrowed>\")\n                     .finish()"}, {"sha": "18b465d85a12f74413e01ed908fedfcfeb8c8acf", "filename": "src/libcore/hash/mod.rs", "status": "modified", "additions": 37, "deletions": 3, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibcore%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibcore%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fmod.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -255,10 +255,44 @@ pub trait BuildHasher {\n     fn build_hasher(&self) -> Self::Hasher;\n }\n \n-/// A structure which implements `BuildHasher` for all `Hasher` types which also\n-/// implement `Default`.\n+/// The `BuildHasherDefault` structure is used in scenarios where one has a\n+/// type that implements [`Hasher`] and [`Default`], but needs that type to\n+/// implement [`BuildHasher`].\n ///\n-/// This struct is 0-sized and does not need construction.\n+/// This structure is zero-sized and does not need construction.\n+///\n+/// # Examples\n+///\n+/// Using `BuildHasherDefault` to specify a custom [`BuildHasher`] for\n+/// [`HashMap`]:\n+///\n+/// ```\n+/// use std::collections::HashMap;\n+/// use std::hash::{BuildHasherDefault, Hasher};\n+///\n+/// #[derive(Default)]\n+/// struct MyHasher;\n+///\n+/// impl Hasher for MyHasher {\n+///     fn write(&mut self, bytes: &[u8]) {\n+///         // Your hashing algorithm goes here!\n+///        unimplemented!()\n+///     }\n+///\n+///     fn finish(&self) -> u64 {\n+///         // Your hashing algorithm goes here!\n+///         unimplemented!()\n+///     }\n+/// }\n+///\n+/// type MyBuildHasher = BuildHasherDefault<MyHasher>;\n+///\n+/// let hash_map = HashMap::<u32, u32, MyBuildHasher>::default();\n+/// ```\n+///\n+/// [`BuildHasher`]: trait.BuildHasher.html\n+/// [`Default`]: ../default/trait.Default.html\n+/// [`Hasher`]: trait.Hasher.html\n #[stable(since = \"1.7.0\", feature = \"build_hasher\")]\n pub struct BuildHasherDefault<H>(marker::PhantomData<H>);\n "}, {"sha": "ec590d2bd06f89686011ee9a21990384cebce005", "filename": "src/libcore/iter/iterator.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibcore%2Fiter%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibcore%2Fiter%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fiterator.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -1696,12 +1696,11 @@ pub trait Iterator {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(iter_max_by)]\n     /// let a = [-3_i32, 0, 1, 5, -10];\n     /// assert_eq!(*a.iter().max_by(|x, y| x.cmp(y)).unwrap(), 5);\n     /// ```\n     #[inline]\n-    #[unstable(feature = \"iter_max_by\", issue=\"36105\")]\n+    #[stable(feature = \"iter_max_by\", since = \"1.15.0\")]\n     fn max_by<F>(self, mut compare: F) -> Option<Self::Item>\n         where Self: Sized, F: FnMut(&Self::Item, &Self::Item) -> Ordering,\n     {\n@@ -1746,12 +1745,11 @@ pub trait Iterator {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(iter_min_by)]\n     /// let a = [-3_i32, 0, 1, 5, -10];\n     /// assert_eq!(*a.iter().min_by(|x, y| x.cmp(y)).unwrap(), -10);\n     /// ```\n     #[inline]\n-    #[unstable(feature = \"iter_min_by\", issue=\"36105\")]\n+    #[stable(feature = \"iter_min_by\", since = \"1.15.0\")]\n     fn min_by<F>(self, mut compare: F) -> Option<Self::Item>\n         where Self: Sized, F: FnMut(&Self::Item, &Self::Item) -> Ordering,\n     {"}, {"sha": "e3ca8eca76c570979eaa607bb4f422368985863d", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -117,6 +117,8 @@ pub unsafe fn replace<T>(dest: *mut T, mut src: T) -> T {\n /// `zero_memory`, or `copy_memory`). Note that `*src = foo` counts as a use\n /// because it will attempt to drop the value previously at `*src`.\n ///\n+/// The pointer must be aligned; use `read_unaligned` if that is not the case.\n+///\n /// # Examples\n ///\n /// Basic usage:\n@@ -137,6 +139,44 @@ pub unsafe fn read<T>(src: *const T) -> T {\n     tmp\n }\n \n+/// Reads the value from `src` without moving it. This leaves the\n+/// memory in `src` unchanged.\n+///\n+/// Unlike `read`, the pointer may be unaligned.\n+///\n+/// # Safety\n+///\n+/// Beyond accepting a raw pointer, this is unsafe because it semantically\n+/// moves the value out of `src` without preventing further usage of `src`.\n+/// If `T` is not `Copy`, then care must be taken to ensure that the value at\n+/// `src` is not used before the data is overwritten again (e.g. with `write`,\n+/// `zero_memory`, or `copy_memory`). Note that `*src = foo` counts as a use\n+/// because it will attempt to drop the value previously at `*src`.\n+///\n+/// # Examples\n+///\n+/// Basic usage:\n+///\n+/// ```\n+/// #![feature(ptr_unaligned)]\n+///\n+/// let x = 12;\n+/// let y = &x as *const i32;\n+///\n+/// unsafe {\n+///     assert_eq!(std::ptr::read_unaligned(y), 12);\n+/// }\n+/// ```\n+#[inline(always)]\n+#[unstable(feature = \"ptr_unaligned\", issue = \"37955\")]\n+pub unsafe fn read_unaligned<T>(src: *const T) -> T {\n+    let mut tmp: T = mem::uninitialized();\n+    copy_nonoverlapping(src as *const u8,\n+                        &mut tmp as *mut T as *mut u8,\n+                        mem::size_of::<T>());\n+    tmp\n+}\n+\n /// Overwrites a memory location with the given value without reading or\n /// dropping the old value.\n ///\n@@ -151,6 +191,8 @@ pub unsafe fn read<T>(src: *const T) -> T {\n /// This is appropriate for initializing uninitialized memory, or overwriting\n /// memory that has previously been `read` from.\n ///\n+/// The pointer must be aligned; use `write_unaligned` if that is not the case.\n+///\n /// # Examples\n ///\n /// Basic usage:\n@@ -171,6 +213,47 @@ pub unsafe fn write<T>(dst: *mut T, src: T) {\n     intrinsics::move_val_init(&mut *dst, src)\n }\n \n+/// Overwrites a memory location with the given value without reading or\n+/// dropping the old value.\n+///\n+/// Unlike `write`, the pointer may be unaligned.\n+///\n+/// # Safety\n+///\n+/// This operation is marked unsafe because it accepts a raw pointer.\n+///\n+/// It does not drop the contents of `dst`. This is safe, but it could leak\n+/// allocations or resources, so care must be taken not to overwrite an object\n+/// that should be dropped.\n+///\n+/// This is appropriate for initializing uninitialized memory, or overwriting\n+/// memory that has previously been `read` from.\n+///\n+/// # Examples\n+///\n+/// Basic usage:\n+///\n+/// ```\n+/// #![feature(ptr_unaligned)]\n+///\n+/// let mut x = 0;\n+/// let y = &mut x as *mut i32;\n+/// let z = 12;\n+///\n+/// unsafe {\n+///     std::ptr::write_unaligned(y, z);\n+///     assert_eq!(std::ptr::read_unaligned(y), 12);\n+/// }\n+/// ```\n+#[inline]\n+#[unstable(feature = \"ptr_unaligned\", issue = \"37955\")]\n+pub unsafe fn write_unaligned<T>(dst: *mut T, src: T) {\n+    copy_nonoverlapping(&src as *const T as *const u8,\n+                        dst as *mut u8,\n+                        mem::size_of::<T>());\n+    mem::forget(src);\n+}\n+\n /// Performs a volatile read of the value from `src` without moving it. This\n /// leaves the memory in `src` unchanged.\n ///"}, {"sha": "99c407e5273eae922249ca45ee325e9c8f2028cd", "filename": "src/libcore/result.rs", "status": "modified", "additions": 26, "deletions": 3, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -501,6 +501,8 @@ impl<T, E> Result<T, E> {\n \n     /// Returns an iterator over the possibly contained value.\n     ///\n+    /// The iterator yields one value if the result is [`Ok`], otherwise none.\n+    ///\n     /// # Examples\n     ///\n     /// Basic usage:\n@@ -512,6 +514,8 @@ impl<T, E> Result<T, E> {\n     /// let x: Result<u32, &str> = Err(\"nothing!\");\n     /// assert_eq!(x.iter().next(), None);\n     /// ```\n+    ///\n+    /// [`Ok`]: enum.Result.html#variant.Ok\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter(&self) -> Iter<T> {\n@@ -520,6 +524,8 @@ impl<T, E> Result<T, E> {\n \n     /// Returns a mutable iterator over the possibly contained value.\n     ///\n+    /// The iterator yields one value if the result is [`Ok`], otherwise none.\n+    ///\n     /// # Examples\n     ///\n     /// Basic usage:\n@@ -535,6 +541,8 @@ impl<T, E> Result<T, E> {\n     /// let mut x: Result<u32, &str> = Err(\"nothing!\");\n     /// assert_eq!(x.iter_mut().next(), None);\n     /// ```\n+    ///\n+    /// [`Ok`]: enum.Result.html#variant.Ok\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter_mut(&mut self) -> IterMut<T> {\n@@ -848,6 +856,8 @@ impl<T, E> IntoIterator for Result<T, E> {\n \n     /// Returns a consuming iterator over the possibly contained value.\n     ///\n+    /// The iterator yields one value if the result is [`Ok`], otherwise none.\n+    ///\n     /// # Examples\n     ///\n     /// Basic usage:\n@@ -861,6 +871,8 @@ impl<T, E> IntoIterator for Result<T, E> {\n     /// let v: Vec<u32> = x.into_iter().collect();\n     /// assert_eq!(v, []);\n     /// ```\n+    ///\n+    /// [`Ok`]: enum.Result.html#variant.Ok\n     #[inline]\n     fn into_iter(self) -> IntoIter<T> {\n         IntoIter { inner: self.ok() }\n@@ -893,8 +905,13 @@ impl<'a, T, E> IntoIterator for &'a mut Result<T, E> {\n \n /// An iterator over a reference to the [`Ok`] variant of a [`Result`].\n ///\n+/// The iterator yields one value if the result is [`Ok`], otherwise none.\n+///\n+/// Created by [`Result::iter`].\n+///\n /// [`Ok`]: enum.Result.html#variant.Ok\n /// [`Result`]: enum.Result.html\n+/// [`Result::iter`]: enum.Result.html#method.iter\n #[derive(Debug)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Iter<'a, T: 'a> { inner: Option<&'a T> }\n@@ -934,8 +951,11 @@ impl<'a, T> Clone for Iter<'a, T> {\n \n /// An iterator over a mutable reference to the [`Ok`] variant of a [`Result`].\n ///\n+/// Created by [`Result::iter_mut`].\n+///\n /// [`Ok`]: enum.Result.html#variant.Ok\n /// [`Result`]: enum.Result.html\n+/// [`Result::iter_mut`]: enum.Result.html#method.iter_mut\n #[derive(Debug)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IterMut<'a, T: 'a> { inner: Option<&'a mut T> }\n@@ -968,9 +988,12 @@ impl<'a, T> FusedIterator for IterMut<'a, T> {}\n #[unstable(feature = \"trusted_len\", issue = \"37572\")]\n unsafe impl<'a, A> TrustedLen for IterMut<'a, A> {}\n \n-/// An iterator over the value in a [`Ok`] variant of a [`Result`]. This struct is\n-/// created by the [`into_iter`] method on [`Result`][`Result`] (provided by\n-/// the [`IntoIterator`] trait).\n+/// An iterator over the value in a [`Ok`] variant of a [`Result`].\n+///\n+/// The iterator yields one value if the result is [`Ok`], otherwise none.\n+///\n+/// This struct is created by the [`into_iter`] method on\n+/// [`Result`][`Result`] (provided by the [`IntoIterator`] trait).\n ///\n /// [`Ok`]: enum.Result.html#variant.Ok\n /// [`Result`]: enum.Result.html"}, {"sha": "e0a49e2ae45d0b895af72f3018d6276e00106125", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -33,6 +33,7 @@\n // * The `raw` and `bytes` submodules.\n // * Boilerplate trait implementations.\n \n+use borrow::Borrow;\n use cmp::Ordering::{self, Less, Equal, Greater};\n use cmp;\n use fmt;\n@@ -100,15 +101,17 @@ pub trait SliceExt {\n     #[stable(feature = \"core\", since = \"1.6.0\")]\n     fn as_ptr(&self) -> *const Self::Item;\n     #[stable(feature = \"core\", since = \"1.6.0\")]\n-    fn binary_search(&self, x: &Self::Item) -> Result<usize, usize>\n-        where Self::Item: Ord;\n+    fn binary_search<Q: ?Sized>(&self, x: &Q) -> Result<usize, usize>\n+        where Self::Item: Borrow<Q>,\n+              Q: Ord;\n     #[stable(feature = \"core\", since = \"1.6.0\")]\n     fn binary_search_by<'a, F>(&'a self, f: F) -> Result<usize, usize>\n         where F: FnMut(&'a Self::Item) -> Ordering;\n     #[stable(feature = \"slice_binary_search_by_key\", since = \"1.10.0\")]\n-    fn binary_search_by_key<'a, B, F>(&'a self, b: &B, f: F) -> Result<usize, usize>\n+    fn binary_search_by_key<'a, B, F, Q: ?Sized>(&'a self, b: &Q, f: F) -> Result<usize, usize>\n         where F: FnMut(&'a Self::Item) -> B,\n-              B: Ord;\n+              B: Borrow<Q>,\n+              Q: Ord;\n     #[stable(feature = \"core\", since = \"1.6.0\")]\n     fn len(&self) -> usize;\n     #[stable(feature = \"core\", since = \"1.6.0\")]\n@@ -493,8 +496,8 @@ impl<T> SliceExt for [T] {\n         m >= n && needle == &self[m-n..]\n     }\n \n-    fn binary_search(&self, x: &T) -> Result<usize, usize> where T: Ord {\n-        self.binary_search_by(|p| p.cmp(x))\n+    fn binary_search<Q: ?Sized>(&self, x: &Q) -> Result<usize, usize> where T: Borrow<Q>, Q: Ord {\n+        self.binary_search_by(|p| p.borrow().cmp(x))\n     }\n \n     #[inline]\n@@ -522,11 +525,12 @@ impl<T> SliceExt for [T] {\n     }\n \n     #[inline]\n-    fn binary_search_by_key<'a, B, F>(&'a self, b: &B, mut f: F) -> Result<usize, usize>\n+    fn binary_search_by_key<'a, B, F, Q: ?Sized>(&'a self, b: &Q, mut f: F) -> Result<usize, usize>\n         where F: FnMut(&'a Self::Item) -> B,\n-              B: Ord\n+              B: Borrow<Q>,\n+              Q: Ord\n     {\n-        self.binary_search_by(|k| f(k).cmp(b))\n+        self.binary_search_by(|k| f(k).borrow().cmp(b))\n     }\n }\n "}, {"sha": "198db0e7c0aac46f6642960da8dbf22c1b1c4a84", "filename": "src/libcore/sync/atomic.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibcore%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibcore%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsync%2Fatomic.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -203,7 +203,6 @@ impl AtomicBool {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(atomic_access)]\n     /// use std::sync::atomic::{AtomicBool, Ordering};\n     ///\n     /// let mut some_bool = AtomicBool::new(true);\n@@ -212,7 +211,7 @@ impl AtomicBool {\n     /// assert_eq!(some_bool.load(Ordering::SeqCst), false);\n     /// ```\n     #[inline]\n-    #[unstable(feature = \"atomic_access\", issue = \"35603\")]\n+    #[stable(feature = \"atomic_access\", since = \"1.15.0\")]\n     pub fn get_mut(&mut self) -> &mut bool {\n         unsafe { &mut *(self.v.get() as *mut bool) }\n     }\n@@ -225,14 +224,13 @@ impl AtomicBool {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(atomic_access)]\n     /// use std::sync::atomic::AtomicBool;\n     ///\n     /// let some_bool = AtomicBool::new(true);\n     /// assert_eq!(some_bool.into_inner(), true);\n     /// ```\n     #[inline]\n-    #[unstable(feature = \"atomic_access\", issue = \"35603\")]\n+    #[stable(feature = \"atomic_access\", since = \"1.15.0\")]\n     pub fn into_inner(self) -> bool {\n         unsafe { self.v.into_inner() != 0 }\n     }\n@@ -588,15 +586,14 @@ impl<T> AtomicPtr<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(atomic_access)]\n     /// use std::sync::atomic::{AtomicPtr, Ordering};\n     ///\n     /// let mut atomic_ptr = AtomicPtr::new(&mut 10);\n     /// *atomic_ptr.get_mut() = &mut 5;\n     /// assert_eq!(unsafe { *atomic_ptr.load(Ordering::SeqCst) }, 5);\n     /// ```\n     #[inline]\n-    #[unstable(feature = \"atomic_access\", issue = \"35603\")]\n+    #[stable(feature = \"atomic_access\", since = \"1.15.0\")]\n     pub fn get_mut(&mut self) -> &mut *mut T {\n         unsafe { &mut *self.p.get() }\n     }\n@@ -609,14 +606,13 @@ impl<T> AtomicPtr<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(atomic_access)]\n     /// use std::sync::atomic::AtomicPtr;\n     ///\n     /// let atomic_ptr = AtomicPtr::new(&mut 5);\n     /// assert_eq!(unsafe { *atomic_ptr.into_inner() }, 5);\n     /// ```\n     #[inline]\n-    #[unstable(feature = \"atomic_access\", issue = \"35603\")]\n+    #[stable(feature = \"atomic_access\", since = \"1.15.0\")]\n     pub fn into_inner(self) -> *mut T {\n         unsafe { self.p.into_inner() }\n     }\n@@ -883,7 +879,6 @@ macro_rules! atomic_int {\n             /// # Examples\n             ///\n             /// ```\n-            /// #![feature(atomic_access)]\n             /// use std::sync::atomic::{AtomicIsize, Ordering};\n             ///\n             /// let mut some_isize = AtomicIsize::new(10);\n@@ -905,7 +900,6 @@ macro_rules! atomic_int {\n             /// # Examples\n             ///\n             /// ```\n-            /// #![feature(atomic_access)]\n             /// use std::sync::atomic::AtomicIsize;\n             ///\n             /// let some_isize = AtomicIsize::new(5);\n@@ -1261,15 +1255,15 @@ atomic_int!{\n     stable(feature = \"rust1\", since = \"1.0.0\"),\n     stable(feature = \"extended_compare_and_swap\", since = \"1.10.0\"),\n     stable(feature = \"atomic_debug\", since = \"1.3.0\"),\n-    unstable(feature = \"atomic_access\", issue = \"35603\"),\n+    stable(feature = \"atomic_access\", since = \"1.15.0\"),\n     isize AtomicIsize ATOMIC_ISIZE_INIT\n }\n #[cfg(target_has_atomic = \"ptr\")]\n atomic_int!{\n     stable(feature = \"rust1\", since = \"1.0.0\"),\n     stable(feature = \"extended_compare_and_swap\", since = \"1.10.0\"),\n     stable(feature = \"atomic_debug\", since = \"1.3.0\"),\n-    unstable(feature = \"atomic_access\", issue = \"35603\"),\n+    stable(feature = \"atomic_access\", since = \"1.15.0\"),\n     usize AtomicUsize ATOMIC_USIZE_INIT\n }\n "}, {"sha": "724a312ea79e0a7427df2856805485c8cc146802", "filename": "src/libcoretest/cell.rs", "status": "modified", "additions": 22, "deletions": 15, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibcoretest%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibcoretest%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fcell.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -59,22 +59,22 @@ fn double_imm_borrow() {\n fn no_mut_then_imm_borrow() {\n     let x = RefCell::new(0);\n     let _b1 = x.borrow_mut();\n-    assert_eq!(x.borrow_state(), BorrowState::Writing);\n+    assert!(x.try_borrow().is_err());\n }\n \n #[test]\n fn no_imm_then_borrow_mut() {\n     let x = RefCell::new(0);\n     let _b1 = x.borrow();\n-    assert_eq!(x.borrow_state(), BorrowState::Reading);\n+    assert!(x.try_borrow_mut().is_err());\n }\n \n #[test]\n fn no_double_borrow_mut() {\n     let x = RefCell::new(0);\n-    assert_eq!(x.borrow_state(), BorrowState::Unused);\n+    assert!(x.try_borrow().is_ok());\n     let _b1 = x.borrow_mut();\n-    assert_eq!(x.borrow_state(), BorrowState::Writing);\n+    assert!(x.try_borrow().is_err());\n }\n \n #[test]\n@@ -102,7 +102,8 @@ fn double_borrow_single_release_no_borrow_mut() {\n     {\n         let _b2 = x.borrow();\n     }\n-    assert_eq!(x.borrow_state(), BorrowState::Reading);\n+    assert!(x.try_borrow().is_ok());\n+    assert!(x.try_borrow_mut().is_err());\n }\n \n #[test]\n@@ -119,30 +120,38 @@ fn ref_clone_updates_flag() {\n     let x = RefCell::new(0);\n     {\n         let b1 = x.borrow();\n-        assert_eq!(x.borrow_state(), BorrowState::Reading);\n+        assert!(x.try_borrow().is_ok());\n+        assert!(x.try_borrow_mut().is_err());\n         {\n             let _b2 = Ref::clone(&b1);\n-            assert_eq!(x.borrow_state(), BorrowState::Reading);\n+            assert!(x.try_borrow().is_ok());\n+            assert!(x.try_borrow_mut().is_err());\n         }\n-        assert_eq!(x.borrow_state(), BorrowState::Reading);\n+        assert!(x.try_borrow().is_ok());\n+        assert!(x.try_borrow_mut().is_err());\n     }\n-    assert_eq!(x.borrow_state(), BorrowState::Unused);\n+    assert!(x.try_borrow().is_ok());\n+    assert!(x.try_borrow_mut().is_ok());\n }\n \n #[test]\n fn ref_map_does_not_update_flag() {\n     let x = RefCell::new(Some(5));\n     {\n         let b1: Ref<Option<u32>> = x.borrow();\n-        assert_eq!(x.borrow_state(), BorrowState::Reading);\n+        assert!(x.try_borrow().is_ok());\n+        assert!(x.try_borrow_mut().is_err());\n         {\n             let b2: Ref<u32> = Ref::map(b1, |o| o.as_ref().unwrap());\n             assert_eq!(*b2, 5);\n-            assert_eq!(x.borrow_state(), BorrowState::Reading);\n+            assert!(x.try_borrow().is_ok());\n+            assert!(x.try_borrow_mut().is_err());\n         }\n-        assert_eq!(x.borrow_state(), BorrowState::Unused);\n+        assert!(x.try_borrow().is_ok());\n+        assert!(x.try_borrow_mut().is_ok());\n     }\n-    assert_eq!(x.borrow_state(), BorrowState::Unused);\n+    assert!(x.try_borrow().is_ok());\n+    assert!(x.try_borrow_mut().is_ok());\n }\n \n #[test]\n@@ -247,5 +256,3 @@ fn refcell_ref_coercion() {\n         assert_eq!(&*coerced, comp);\n     }\n }\n-\n-"}, {"sha": "d12616a97a647dbc6dba8a5780dfe0efba575ac3", "filename": "src/libcoretest/lib.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibcoretest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibcoretest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Flib.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -10,9 +10,7 @@\n \n #![deny(warnings)]\n \n-#![feature(borrow_state)]\n #![feature(box_syntax)]\n-#![feature(cell_extras)]\n #![feature(char_escape_debug)]\n #![feature(const_fn)]\n #![feature(core_private_bignum)]\n@@ -32,10 +30,9 @@\n #![feature(try_from)]\n #![feature(unicode)]\n #![feature(unique)]\n-#![feature(iter_max_by)]\n-#![feature(iter_min_by)]\n #![feature(ordering_chaining)]\n #![feature(result_unwrap_or_default)]\n+#![feature(ptr_unaligned)]\n \n extern crate core;\n extern crate test;"}, {"sha": "7f6f472bfbb78ea5588f7a770a61792f95bc6f1a", "filename": "src/libcoretest/ptr.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibcoretest%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibcoretest%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fptr.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n use core::ptr::*;\n+use core::cell::RefCell;\n \n #[test]\n fn test() {\n@@ -189,3 +190,25 @@ pub fn test_variadic_fnptr() {\n     let mut s = SipHasher::new();\n     assert_eq!(p.hash(&mut s), q.hash(&mut s));\n }\n+\n+#[test]\n+fn write_unaligned_drop() {\n+    thread_local! {\n+        static DROPS: RefCell<Vec<u32>> = RefCell::new(Vec::new());\n+    }\n+\n+    struct Dropper(u32);\n+\n+    impl Drop for Dropper {\n+        fn drop(&mut self) {\n+            DROPS.with(|d| d.borrow_mut().push(self.0));\n+        }\n+    }\n+\n+    {\n+        let c = Dropper(0);\n+        let mut t = Dropper(1);\n+        unsafe { write_unaligned(&mut t, c); }\n+    }\n+    DROPS.with(|d| assert_eq!(*d.borrow(), [0]));\n+}"}, {"sha": "e49e9bb7c3d9c7f2fd893f0ee0db81617b8db21f", "filename": "src/liblibc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblibc?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -1 +1 @@\n-Subproject commit 0ac39c5ccf6a04395b7c40dd62321cb91f63f160\n+Subproject commit e49e9bb7c3d9c7f2fd893f0ee0db81617b8db21f"}, {"sha": "8f85bfe2c638eafeb2de9e46f4583a6201ceabec", "filename": "src/libpanic_abort/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibpanic_abort%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibpanic_abort%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_abort%2Flib.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -28,7 +28,7 @@\n #![panic_runtime]\n #![feature(panic_runtime)]\n #![cfg_attr(unix, feature(libc))]\n-#![cfg_attr(windows, feature(core_intrinsics))]\n+#![cfg_attr(any(target_os = \"redox\", windows), feature(core_intrinsics))]\n \n // Rust's \"try\" function, but if we're aborting on panics we just call the\n // function as there's nothing else we need to do here.\n@@ -61,7 +61,7 @@ pub unsafe extern fn __rust_start_panic(_data: usize, _vtable: usize) -> u32 {\n         libc::abort();\n     }\n \n-    #[cfg(windows)]\n+    #[cfg(any(target_os = \"redox\", windows))]\n     unsafe fn abort() -> ! {\n         core::intrinsics::abort();\n     }"}, {"sha": "b75d9ec6520a4519062de54d60cd91d46eba5d45", "filename": "src/libpanic_unwind/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibpanic_unwind%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibpanic_unwind%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Flib.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -69,6 +69,7 @@ mod imp;\n \n // i686-pc-windows-gnu and all others\n #[cfg(any(all(unix, not(target_os = \"emscripten\")),\n+          target_os = \"redox\",\n           all(windows, target_arch = \"x86\", target_env = \"gnu\")))]\n #[path = \"gcc.rs\"]\n mod imp;"}, {"sha": "d2b94db689bc45c63b3bd1de3049739c45736e6e", "filename": "src/librustc/dep_graph/README.md", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc%2Fdep_graph%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc%2Fdep_graph%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2FREADME.md?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -418,7 +418,7 @@ to see something like:\n \n     Hir(foo) -> Collect(bar)\n     Collect(bar) -> TypeckItemBody(bar)\n-    \n+\n That first edge looks suspicious to you. So you set\n `RUST_FORBID_DEP_GRAPH_EDGE` to `Hir&foo -> Collect&bar`, re-run, and\n then observe the backtrace. Voila, bug fixed!\n@@ -440,6 +440,4 @@ To achieve this, the HIR map will detect if the def-id originates in\n an inlined node and add a dependency to a suitable `MetaData` node\n instead. If you are reading a HIR node and are not sure if it may be\n inlined or not, you can use `tcx.map.read(node_id)` and it will detect\n-whether the node is inlined or not and do the right thing.  You can\n-also use `tcx.map.is_inlined_def_id()` and\n-`tcx.map.is_inlined_node_id()` to test.\n+whether the node is inlined or not and do the right thing."}, {"sha": "5d4190a8ae1a35bd76d35bab0e7641897ba25e5b", "filename": "src/librustc/dep_graph/shadow.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc%2Fdep_graph%2Fshadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc%2Fdep_graph%2Fshadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fshadow.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -27,7 +27,7 @@\n //! created.  See `./README.md` for details.\n \n use hir::def_id::DefId;\n-use std::cell::{BorrowState, RefCell};\n+use std::cell::RefCell;\n use std::env;\n \n use super::DepNode;\n@@ -71,15 +71,11 @@ impl ShadowGraph {\n \n     pub fn enqueue(&self, message: &DepMessage) {\n         if ENABLED {\n-            match self.stack.borrow_state() {\n-                BorrowState::Unused => {}\n-                _ => {\n-                    // When we apply edge filters, that invokes the\n-                    // Debug trait on DefIds, which in turn reads from\n-                    // various bits of state and creates reads! Ignore\n-                    // those recursive reads.\n-                    return;\n-                }\n+            if self.stack.try_borrow().is_err() {\n+                // When we apply edge filters, that invokes the Debug trait on\n+                // DefIds, which in turn reads from various bits of state and\n+                // creates reads! Ignore those recursive reads.\n+                return;\n             }\n \n             let mut stack = self.stack.borrow_mut();"}, {"sha": "f6a22e47cf21278051fd3f11fc5ab474cab25303", "filename": "src/librustc/dep_graph/visit.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc%2Fdep_graph%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc%2Fdep_graph%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fvisit.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -40,7 +40,6 @@ pub fn visit_all_item_likes_in_krate<'a, 'tcx, V, F>(tcx: TyCtxt<'a, 'tcx, 'tcx>\n             let task_id = (self.dep_node_fn)(item_def_id);\n             let _task = self.tcx.dep_graph.in_task(task_id.clone());\n             debug!(\"Started task {:?}\", task_id);\n-            assert!(!self.tcx.map.is_inlined_def_id(item_def_id));\n             self.tcx.dep_graph.read(DepNode::Hir(item_def_id));\n             self.visitor.visit_item(i);\n             debug!(\"Ended task {:?}\", task_id);\n@@ -51,7 +50,6 @@ pub fn visit_all_item_likes_in_krate<'a, 'tcx, V, F>(tcx: TyCtxt<'a, 'tcx, 'tcx>\n             let task_id = (self.dep_node_fn)(impl_item_def_id);\n             let _task = self.tcx.dep_graph.in_task(task_id.clone());\n             debug!(\"Started task {:?}\", task_id);\n-            assert!(!self.tcx.map.is_inlined_def_id(impl_item_def_id));\n             self.tcx.dep_graph.read(DepNode::Hir(impl_item_def_id));\n             self.visitor.visit_impl_item(i);\n             debug!(\"Ended task {:?}\", task_id);"}, {"sha": "1655c716b6bfa59dac2c36c52420a055b115e29d", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -1236,6 +1236,23 @@ struct Foo<'a, T: 'a> {\n     foo: &'a T\n }\n ```\n+\n+To see why this is important, consider the case where `T` is itself a reference\n+(e.g., `T = &str`). If we don't include the restriction that `T: 'a`, the\n+following code would be perfectly legal:\n+\n+```compile_fail,E0309\n+struct Foo<'a, T> {\n+    foo: &'a T\n+}\n+\n+fn main() {\n+    let v = \"42\".to_string();\n+    let f = Foo{foo: &v};\n+    drop(v);\n+    println!(\"{}\", f.foo); // but we've already dropped v!\n+}\n+```\n \"##,\n \n E0310: r##\""}, {"sha": "cbf162cc1366ef0401a061f1a7506c39ecea898c", "filename": "src/librustc/hir/def_id.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc%2Fhir%2Fdef_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc%2Fhir%2Fdef_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef_id.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -120,9 +120,7 @@ impl fmt::Debug for DefId {\n \n         ty::tls::with_opt(|opt_tcx| {\n             if let Some(tcx) = opt_tcx {\n-                if let Some(def_path) = tcx.opt_def_path(*self) {\n-                    write!(f, \" => {}\", def_path.to_string(tcx))?;\n-                }\n+                write!(f, \" => {}\", tcx.def_path(*self).to_string(tcx))?;\n             }\n             Ok(())\n         })?;"}, {"sha": "186d6f626509fd0b0daf5f37ddeefa42d516ab1a", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -365,7 +365,6 @@ pub fn walk_crate<'v, V: Visitor<'v>>(visitor: &mut V, krate: &'v Crate) {\n pub fn walk_macro_def<'v, V: Visitor<'v>>(visitor: &mut V, macro_def: &'v MacroDef) {\n     visitor.visit_id(macro_def.id);\n     visitor.visit_name(macro_def.span, macro_def.name);\n-    walk_opt_name(visitor, macro_def.span, macro_def.imported_from);\n     walk_list!(visitor, visit_attribute, &macro_def.attrs);\n }\n "}, {"sha": "1cf5e35a0957fa4341a1f148bf101cef36d9e584", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 34, "deletions": 32, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -81,7 +81,7 @@ pub struct LoweringContext<'a> {\n }\n \n pub trait Resolver {\n-    // Resolve a global hir path generated by the lowerer when expanding `for`, `if let`, etc.\n+    // Resolve a hir path generated by the lowerer when expanding `for`, `if let`, etc.\n     fn resolve_hir_path(&mut self, path: &mut hir::Path, is_value: bool);\n \n     // Obtain the resolution for a node id\n@@ -337,7 +337,6 @@ impl<'a> LoweringContext<'a> {\n \n         let proj_start = p.segments.len() - resolution.depth;\n         let path = P(hir::Path {\n-            global: p.global,\n             def: resolution.base_def,\n             segments: p.segments[..proj_start].iter().enumerate().map(|(i, segment)| {\n                 let param_mode = match (qself_position, param_mode) {\n@@ -404,12 +403,17 @@ impl<'a> LoweringContext<'a> {\n                         id: NodeId,\n                         p: &Path,\n                         name: Option<Name>,\n-                        param_mode: ParamMode)\n+                        param_mode: ParamMode,\n+                        defaults_to_global: bool)\n                         -> hir::Path {\n+        let mut segments = p.segments.iter();\n+        if defaults_to_global && p.is_global() {\n+            segments.next();\n+        }\n+\n         hir::Path {\n-            global: p.global,\n             def: self.expect_full_def(id),\n-            segments: p.segments.iter().map(|segment| {\n+            segments: segments.map(|segment| {\n                 self.lower_path_segment(segment, param_mode)\n             }).chain(name.map(|name| {\n                 hir::PathSegment {\n@@ -424,22 +428,29 @@ impl<'a> LoweringContext<'a> {\n     fn lower_path(&mut self,\n                   id: NodeId,\n                   p: &Path,\n-                  param_mode: ParamMode)\n+                  param_mode: ParamMode,\n+                  defaults_to_global: bool)\n                   -> hir::Path {\n-        self.lower_path_extra(id, p, None, param_mode)\n+        self.lower_path_extra(id, p, None, param_mode, defaults_to_global)\n     }\n \n     fn lower_path_segment(&mut self,\n                           segment: &PathSegment,\n                           param_mode: ParamMode)\n                           -> hir::PathSegment {\n-        let parameters = match segment.parameters {\n-            PathParameters::AngleBracketed(ref data) => {\n-                let data = self.lower_angle_bracketed_parameter_data(data, param_mode);\n-                hir::AngleBracketedParameters(data)\n+        let parameters = if let Some(ref parameters) = segment.parameters {\n+            match **parameters {\n+                PathParameters::AngleBracketed(ref data) => {\n+                    let data = self.lower_angle_bracketed_parameter_data(data, param_mode);\n+                    hir::AngleBracketedParameters(data)\n+                }\n+                PathParameters::Parenthesized(ref data) => {\n+                    hir::ParenthesizedParameters(self.lower_parenthesized_parameter_data(data))\n+                }\n             }\n-            PathParameters::Parenthesized(ref data) =>\n-                hir::ParenthesizedParameters(self.lower_parenthesized_parameter_data(data)),\n+        } else {\n+            let data = self.lower_angle_bracketed_parameter_data(&Default::default(), param_mode);\n+            hir::AngleBracketedParameters(data)\n         };\n \n         hir::PathSegment {\n@@ -596,8 +607,8 @@ impl<'a> LoweringContext<'a> {\n                         // Check if the where clause type is a plain type parameter.\n                         match bound_pred.bounded_ty.node {\n                             TyKind::Path(None, ref path)\n-                                    if !path.global && path.segments.len() == 1 &&\n-                                        bound_pred.bound_lifetimes.is_empty() => {\n+                                    if path.segments.len() == 1 &&\n+                                       bound_pred.bound_lifetimes.is_empty() => {\n                                 if let Some(Def::TyParam(def_id)) =\n                                         self.resolver.get_resolution(bound_pred.bounded_ty.id)\n                                                      .map(|d| d.base_def) {\n@@ -671,7 +682,7 @@ impl<'a> LoweringContext<'a> {\n                                                           span}) => {\n                 hir::WherePredicate::EqPredicate(hir::WhereEqPredicate {\n                     id: id,\n-                    path: self.lower_path(id, path, ParamMode::Explicit),\n+                    path: self.lower_path(id, path, ParamMode::Explicit, false),\n                     ty: self.lower_ty(ty),\n                     span: span,\n                 })\n@@ -701,7 +712,7 @@ impl<'a> LoweringContext<'a> {\n \n     fn lower_trait_ref(&mut self, p: &TraitRef) -> hir::TraitRef {\n         hir::TraitRef {\n-            path: self.lower_path(p.ref_id, &p.path, ParamMode::Explicit),\n+            path: self.lower_path(p.ref_id, &p.path, ParamMode::Explicit, false),\n             ref_id: p.ref_id,\n         }\n     }\n@@ -794,7 +805,7 @@ impl<'a> LoweringContext<'a> {\n                             };\n \n                             let mut path = self.lower_path_extra(import.id, path, suffix,\n-                                                                 ParamMode::Explicit);\n+                                                                 ParamMode::Explicit, true);\n                             path.span = span;\n                             self.items.insert(import.id, hir::Item {\n                                 id: import.id,\n@@ -808,7 +819,7 @@ impl<'a> LoweringContext<'a> {\n                         path\n                     }\n                 };\n-                let path = P(self.lower_path(id, path, ParamMode::Explicit));\n+                let path = P(self.lower_path(id, path, ParamMode::Explicit, true));\n                 let kind = match view_path.node {\n                     ViewPathSimple(ident, _) => {\n                         *name = ident.name;\n@@ -987,8 +998,6 @@ impl<'a> LoweringContext<'a> {\n             attrs: self.lower_attrs(&m.attrs),\n             id: m.id,\n             span: m.span,\n-            imported_from: m.imported_from.map(|x| x.name),\n-            allow_internal_unstable: m.allow_internal_unstable,\n             body: m.body.clone().into(),\n         }\n     }\n@@ -1131,7 +1140,6 @@ impl<'a> LoweringContext<'a> {\n                             Some(def) => {\n                                 hir::PatKind::Path(hir::QPath::Resolved(None, P(hir::Path {\n                                     span: pth1.span,\n-                                    global: false,\n                                     def: def,\n                                     segments: hir_vec![\n                                         hir::PathSegment::from_name(pth1.node.name)\n@@ -1874,7 +1882,7 @@ impl<'a> LoweringContext<'a> {\n             Visibility::Crate(_) => hir::Visibility::Crate,\n             Visibility::Restricted { ref path, id } => {\n                 hir::Visibility::Restricted {\n-                    path: P(self.lower_path(id, path, ParamMode::Explicit)),\n+                    path: P(self.lower_path(id, path, ParamMode::Explicit, true)),\n                     id: id\n                 }\n             }\n@@ -1967,7 +1975,6 @@ impl<'a> LoweringContext<'a> {\n \n         let expr_path = hir::ExprPath(hir::QPath::Resolved(None, P(hir::Path {\n             span: span,\n-            global: false,\n             def: def,\n             segments: hir_vec![hir::PathSegment::from_name(id)],\n         })));\n@@ -2135,17 +2142,12 @@ impl<'a> LoweringContext<'a> {\n     /// `fld.cx.use_std`, and `::core::b::c::d` otherwise.\n     /// The path is also resolved according to `is_value`.\n     fn std_path(&mut self, span: Span, components: &[&str], is_value: bool) -> hir::Path {\n-        let idents = self.crate_root.iter().chain(components);\n-\n-        let segments: Vec<_> = idents.map(|name| {\n-            hir::PathSegment::from_name(Symbol::intern(name))\n-        }).collect();\n-\n         let mut path = hir::Path {\n             span: span,\n-            global: true,\n             def: Def::Err,\n-            segments: segments.into(),\n+            segments: iter::once(keywords::CrateRoot.name()).chain({\n+                self.crate_root.into_iter().chain(components.iter().cloned()).map(Symbol::intern)\n+            }).map(hir::PathSegment::from_name).collect(),\n         };\n \n         self.resolver.resolve_hir_path(&mut path, is_value);"}, {"sha": "45988886a608a30ff7ede1d35d39ca5096d63270", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -11,7 +11,6 @@\n use super::*;\n \n use hir::intravisit::{Visitor, NestedVisitorMap};\n-use hir::def_id::DefId;\n use middle::cstore::InlinedItem;\n use std::iter::repeat;\n use syntax::ast::{NodeId, CRATE_NODE_ID};\n@@ -47,8 +46,6 @@ impl<'ast> NodeCollector<'ast> {\n     pub fn extend(krate: &'ast Crate,\n                   parent: &'ast InlinedItem,\n                   parent_node: NodeId,\n-                  parent_def_path: DefPath,\n-                  parent_def_id: DefId,\n                   map: Vec<MapEntry<'ast>>)\n                   -> NodeCollector<'ast> {\n         let mut collector = NodeCollector {\n@@ -58,7 +55,6 @@ impl<'ast> NodeCollector<'ast> {\n             ignore_nested_items: true\n         };\n \n-        assert_eq!(parent_def_path.krate, parent_def_id.krate);\n         collector.insert_entry(parent_node, RootInlinedParent(parent));\n \n         collector"}, {"sha": "256aee342a3fc448f83637f02a78d7401df22c3f", "filename": "src/librustc/hir/map/def_collector.rs", "status": "modified", "additions": 1, "deletions": 212, "changes": 213, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -9,12 +9,7 @@\n // except according to those terms.\n \n use hir::map::definitions::*;\n-\n-use hir;\n-use hir::intravisit::{self, Visitor, NestedVisitorMap};\n-use hir::def_id::{CRATE_DEF_INDEX, DefId, DefIndex};\n-\n-use middle::cstore::InlinedItem;\n+use hir::def_id::{CRATE_DEF_INDEX, DefIndex};\n \n use syntax::ast::*;\n use syntax::ext::hygiene::Mark;\n@@ -23,9 +18,6 @@ use syntax::symbol::{Symbol, keywords};\n \n /// Creates def ids for nodes in the HIR.\n pub struct DefCollector<'a> {\n-    // If we are walking HIR (c.f., AST), we need to keep a reference to the\n-    // crate.\n-    hir_crate: Option<&'a hir::Crate>,\n     definitions: &'a mut Definitions,\n     parent_def: Option<DefIndex>,\n     pub visit_macro_invoc: Option<&'a mut FnMut(MacroInvocationData)>,\n@@ -40,43 +32,16 @@ pub struct MacroInvocationData {\n impl<'a> DefCollector<'a> {\n     pub fn new(definitions: &'a mut Definitions) -> Self {\n         DefCollector {\n-            hir_crate: None,\n             definitions: definitions,\n             parent_def: None,\n             visit_macro_invoc: None,\n         }\n     }\n \n-    pub fn extend(parent_node: NodeId,\n-                  parent_def_path: DefPath,\n-                  parent_def_id: DefId,\n-                  definitions: &'a mut Definitions)\n-                  -> Self {\n-        let mut collector = DefCollector::new(definitions);\n-\n-        assert_eq!(parent_def_path.krate, parent_def_id.krate);\n-        let root_path = Box::new(InlinedRootPath {\n-            data: parent_def_path.data,\n-            def_id: parent_def_id,\n-        });\n-\n-        let def = collector.create_def(parent_node, DefPathData::InlinedRoot(root_path));\n-        collector.parent_def = Some(def);\n-\n-        collector\n-    }\n-\n     pub fn collect_root(&mut self) {\n         let root = self.create_def_with_parent(None, CRATE_NODE_ID, DefPathData::CrateRoot);\n         assert_eq!(root, CRATE_DEF_INDEX);\n         self.parent_def = Some(root);\n-\n-        self.create_def_with_parent(Some(CRATE_DEF_INDEX), DUMMY_NODE_ID, DefPathData::Misc);\n-    }\n-\n-    pub fn walk_item(&mut self, ii: &'a InlinedItem, krate: &'a hir::Crate) {\n-        self.hir_crate = Some(krate);\n-        ii.visit(self);\n     }\n \n     fn create_def(&mut self, node_id: NodeId, data: DefPathData) -> DefIndex {\n@@ -114,16 +79,6 @@ impl<'a> DefCollector<'a> {\n         self.create_def(expr.id, DefPathData::Initializer);\n     }\n \n-    fn visit_hir_const_integer(&mut self, expr: &hir::Expr) {\n-        // FIXME(eddyb) Closures should have separate\n-        // function definition IDs and expression IDs.\n-        if let hir::ExprClosure(..) = expr.node {\n-            return;\n-        }\n-\n-        self.create_def(expr.id, DefPathData::Initializer);\n-    }\n-\n     fn visit_macro_invoc(&mut self, id: NodeId, const_integer: bool) {\n         if let Some(ref mut visit) = self.visit_macro_invoc {\n             visit(MacroInvocationData {\n@@ -324,169 +279,3 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n         }\n     }\n }\n-\n-// We walk the HIR rather than the AST when reading items from metadata.\n-impl<'ast> Visitor<'ast> for DefCollector<'ast> {\n-    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'ast> {\n-        // note however that we override `visit_body` below\n-        NestedVisitorMap::None\n-    }\n-\n-    fn visit_body(&mut self, id: hir::ExprId) {\n-        if let Some(krate) = self.hir_crate {\n-            self.visit_expr(krate.expr(id));\n-        }\n-    }\n-\n-    fn visit_item(&mut self, i: &'ast hir::Item) {\n-        debug!(\"visit_item: {:?}\", i);\n-\n-        // Pick the def data. This need not be unique, but the more\n-        // information we encapsulate into\n-        let def_data = match i.node {\n-            hir::ItemDefaultImpl(..) | hir::ItemImpl(..) =>\n-                DefPathData::Impl,\n-            hir::ItemEnum(..) | hir::ItemStruct(..) | hir::ItemUnion(..) |\n-            hir::ItemTrait(..) | hir::ItemExternCrate(..) | hir::ItemMod(..) |\n-            hir::ItemForeignMod(..) | hir::ItemTy(..) =>\n-                DefPathData::TypeNs(i.name.as_str()),\n-            hir::ItemStatic(..) | hir::ItemConst(..) | hir::ItemFn(..) =>\n-                DefPathData::ValueNs(i.name.as_str()),\n-            hir::ItemUse(..) => DefPathData::Misc,\n-        };\n-        let def = self.create_def(i.id, def_data);\n-\n-        self.with_parent(def, |this| {\n-            match i.node {\n-                hir::ItemEnum(ref enum_definition, _) => {\n-                    for v in &enum_definition.variants {\n-                        let variant_def_index =\n-                            this.create_def(v.node.data.id(),\n-                                            DefPathData::EnumVariant(v.node.name.as_str()));\n-\n-                        this.with_parent(variant_def_index, |this| {\n-                            for field in v.node.data.fields() {\n-                                this.create_def(field.id,\n-                                                DefPathData::Field(field.name.as_str()));\n-                            }\n-                            if let Some(ref expr) = v.node.disr_expr {\n-                                this.visit_hir_const_integer(expr);\n-                            }\n-                        });\n-                    }\n-                }\n-                hir::ItemStruct(ref struct_def, _) |\n-                hir::ItemUnion(ref struct_def, _) => {\n-                    // If this is a tuple-like struct, register the constructor.\n-                    if !struct_def.is_struct() {\n-                        this.create_def(struct_def.id(),\n-                                        DefPathData::StructCtor);\n-                    }\n-\n-                    for field in struct_def.fields() {\n-                        this.create_def(field.id, DefPathData::Field(field.name.as_str()));\n-                    }\n-                }\n-                _ => {}\n-            }\n-            intravisit::walk_item(this, i);\n-        });\n-    }\n-\n-    fn visit_foreign_item(&mut self, foreign_item: &'ast hir::ForeignItem) {\n-        let def = self.create_def(foreign_item.id,\n-                                  DefPathData::ValueNs(foreign_item.name.as_str()));\n-\n-        self.with_parent(def, |this| {\n-            intravisit::walk_foreign_item(this, foreign_item);\n-        });\n-    }\n-\n-    fn visit_generics(&mut self, generics: &'ast hir::Generics) {\n-        for ty_param in generics.ty_params.iter() {\n-            self.create_def(ty_param.id, DefPathData::TypeParam(ty_param.name.as_str()));\n-        }\n-\n-        intravisit::walk_generics(self, generics);\n-    }\n-\n-    fn visit_trait_item(&mut self, ti: &'ast hir::TraitItem) {\n-        let def_data = match ti.node {\n-            hir::MethodTraitItem(..) | hir::ConstTraitItem(..) =>\n-                DefPathData::ValueNs(ti.name.as_str()),\n-            hir::TypeTraitItem(..) => DefPathData::TypeNs(ti.name.as_str()),\n-        };\n-\n-        let def = self.create_def(ti.id, def_data);\n-        self.with_parent(def, |this| {\n-            if let hir::ConstTraitItem(_, Some(ref expr)) = ti.node {\n-                this.create_def(expr.id, DefPathData::Initializer);\n-            }\n-\n-            intravisit::walk_trait_item(this, ti);\n-        });\n-    }\n-\n-    fn visit_impl_item(&mut self, ii: &'ast hir::ImplItem) {\n-        let def_data = match ii.node {\n-            hir::ImplItemKind::Method(..) | hir::ImplItemKind::Const(..) =>\n-                DefPathData::ValueNs(ii.name.as_str()),\n-            hir::ImplItemKind::Type(..) => DefPathData::TypeNs(ii.name.as_str()),\n-        };\n-\n-        let def = self.create_def(ii.id, def_data);\n-        self.with_parent(def, |this| {\n-            if let hir::ImplItemKind::Const(_, ref expr) = ii.node {\n-                this.create_def(expr.id, DefPathData::Initializer);\n-            }\n-\n-            intravisit::walk_impl_item(this, ii);\n-        });\n-    }\n-\n-    fn visit_pat(&mut self, pat: &'ast hir::Pat) {\n-        let parent_def = self.parent_def;\n-\n-        if let hir::PatKind::Binding(_, _, name, _) = pat.node {\n-            let def = self.create_def(pat.id, DefPathData::Binding(name.node.as_str()));\n-            self.parent_def = Some(def);\n-        }\n-\n-        intravisit::walk_pat(self, pat);\n-        self.parent_def = parent_def;\n-    }\n-\n-    fn visit_expr(&mut self, expr: &'ast hir::Expr) {\n-        let parent_def = self.parent_def;\n-\n-        if let hir::ExprRepeat(_, ref count) = expr.node {\n-            self.visit_hir_const_integer(count);\n-        }\n-\n-        if let hir::ExprClosure(..) = expr.node {\n-            let def = self.create_def(expr.id, DefPathData::ClosureExpr);\n-            self.parent_def = Some(def);\n-        }\n-\n-        intravisit::walk_expr(self, expr);\n-        self.parent_def = parent_def;\n-    }\n-\n-    fn visit_ty(&mut self, ty: &'ast hir::Ty) {\n-        if let hir::TyArray(_, ref length) = ty.node {\n-            self.visit_hir_const_integer(length);\n-        }\n-        if let hir::TyImplTrait(..) = ty.node {\n-            self.create_def(ty.id, DefPathData::ImplTrait);\n-        }\n-        intravisit::walk_ty(self, ty);\n-    }\n-\n-    fn visit_lifetime_def(&mut self, def: &'ast hir::LifetimeDef) {\n-        self.create_def(def.lifetime.id, DefPathData::LifetimeDef(def.lifetime.name.as_str()));\n-    }\n-\n-    fn visit_macro_def(&mut self, macro_def: &'ast hir::MacroDef) {\n-        self.create_def(macro_def.id, DefPathData::MacroDef(macro_def.name.as_str()));\n-    }\n-}"}, {"sha": "4f64670f482796bde55b37dda9a0d31df0bf0817", "filename": "src/librustc/hir/map/definitions.rs", "status": "modified", "additions": 130, "deletions": 83, "changes": 213, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -8,22 +8,119 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+//! For each definition, we track the following data.  A definition\n+//! here is defined somewhat circularly as \"something with a def-id\",\n+//! but it generally corresponds to things like structs, enums, etc.\n+//! There are also some rather random cases (like const initializer\n+//! expressions) that are mostly just leftovers.\n+\n use hir::def_id::{CrateNum, DefId, DefIndex, LOCAL_CRATE};\n use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::stable_hasher::StableHasher;\n+use serialize::{Encodable, Decodable, Encoder, Decoder};\n use std::fmt::Write;\n use std::hash::{Hash, Hasher};\n-use std::collections::hash_map::DefaultHasher;\n use syntax::ast;\n use syntax::symbol::{Symbol, InternedString};\n use ty::TyCtxt;\n use util::nodemap::NodeMap;\n \n-/// The definition table containing node definitions\n+/// The DefPathTable maps DefIndexes to DefKeys and vice versa.\n+/// Internally the DefPathTable holds a tree of DefKeys, where each DefKey\n+/// stores the DefIndex of its parent.\n+/// There is one DefPathTable for each crate.\n+#[derive(Clone)]\n+pub struct DefPathTable {\n+    index_to_key: Vec<DefKey>,\n+    key_to_index: FxHashMap<DefKey, DefIndex>,\n+}\n+\n+impl DefPathTable {\n+    fn insert(&mut self, key: DefKey) -> DefIndex {\n+        let index = DefIndex::new(self.index_to_key.len());\n+        debug!(\"DefPathTable::insert() - {:?} <-> {:?}\", key, index);\n+        self.index_to_key.push(key.clone());\n+        self.key_to_index.insert(key, index);\n+        index\n+    }\n+\n+    #[inline(always)]\n+    pub fn def_key(&self, index: DefIndex) -> DefKey {\n+        self.index_to_key[index.as_usize()].clone()\n+    }\n+\n+    #[inline(always)]\n+    pub fn def_index_for_def_key(&self, key: &DefKey) -> Option<DefIndex> {\n+        self.key_to_index.get(key).cloned()\n+    }\n+\n+    #[inline(always)]\n+    pub fn contains_key(&self, key: &DefKey) -> bool {\n+        self.key_to_index.contains_key(key)\n+    }\n+\n+    pub fn retrace_path(&self,\n+                        path_data: &[DisambiguatedDefPathData])\n+                        -> Option<DefIndex> {\n+        let root_key = DefKey {\n+            parent: None,\n+            disambiguated_data: DisambiguatedDefPathData {\n+                data: DefPathData::CrateRoot,\n+                disambiguator: 0,\n+            },\n+        };\n+\n+        let root_index = self.key_to_index\n+                             .get(&root_key)\n+                             .expect(\"no root key?\")\n+                             .clone();\n+\n+        debug!(\"retrace_path: root_index={:?}\", root_index);\n+\n+        let mut index = root_index;\n+        for data in path_data {\n+            let key = DefKey { parent: Some(index), disambiguated_data: data.clone() };\n+            debug!(\"retrace_path: key={:?}\", key);\n+            match self.key_to_index.get(&key) {\n+                Some(&i) => index = i,\n+                None => return None,\n+            }\n+        }\n+\n+        Some(index)\n+    }\n+}\n+\n+\n+impl Encodable for DefPathTable {\n+    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+        self.index_to_key.encode(s)\n+    }\n+}\n+\n+impl Decodable for DefPathTable {\n+    fn decode<D: Decoder>(d: &mut D) -> Result<DefPathTable, D::Error> {\n+        let index_to_key: Vec<DefKey> = Decodable::decode(d)?;\n+        let key_to_index = index_to_key.iter()\n+                                       .enumerate()\n+                                       .map(|(index, key)| (key.clone(), DefIndex::new(index)))\n+                                       .collect();\n+        Ok(DefPathTable {\n+            index_to_key: index_to_key,\n+            key_to_index: key_to_index,\n+        })\n+    }\n+}\n+\n+\n+/// The definition table containing node definitions.\n+/// It holds the DefPathTable for local DefIds/DefPaths and it also stores a\n+/// mapping from NodeIds to local DefIds.\n #[derive(Clone)]\n pub struct Definitions {\n-    data: Vec<DefData>,\n-    key_map: FxHashMap<DefKey, DefIndex>,\n-    node_map: NodeMap<DefIndex>,\n+    table: DefPathTable,\n+    node_to_def_index: NodeMap<DefIndex>,\n+    def_index_to_node: Vec<ast::NodeId>,\n }\n \n /// A unique identifier that we can use to lookup a definition\n@@ -50,19 +147,6 @@ pub struct DisambiguatedDefPathData {\n     pub disambiguator: u32\n }\n \n-/// For each definition, we track the following data.  A definition\n-/// here is defined somewhat circularly as \"something with a def-id\",\n-/// but it generally corresponds to things like structs, enums, etc.\n-/// There are also some rather random cases (like const initializer\n-/// expressions) that are mostly just leftovers.\n-#[derive(Clone, Debug)]\n-pub struct DefData {\n-    pub key: DefKey,\n-\n-    /// Local ID within the HIR.\n-    pub node_id: ast::NodeId,\n-}\n-\n #[derive(Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n pub struct DefPath {\n     /// the path leading from the crate root to the item\n@@ -77,12 +161,11 @@ impl DefPath {\n         self.krate == LOCAL_CRATE\n     }\n \n-    pub fn make<FN>(start_krate: CrateNum,\n+    pub fn make<FN>(krate: CrateNum,\n                     start_index: DefIndex,\n                     mut get_key: FN) -> DefPath\n         where FN: FnMut(DefIndex) -> DefKey\n     {\n-        let mut krate = start_krate;\n         let mut data = vec![];\n         let mut index = Some(start_index);\n         loop {\n@@ -95,13 +178,6 @@ impl DefPath {\n                     assert!(key.parent.is_none());\n                     break;\n                 }\n-                DefPathData::InlinedRoot(ref p) => {\n-                    assert!(key.parent.is_none());\n-                    assert!(!p.def_id.is_local());\n-                    data.extend(p.data.iter().cloned().rev());\n-                    krate = p.def_id.krate;\n-                    break;\n-                }\n                 _ => {\n                     data.push(key.disambiguated_data);\n                     index = key.parent;\n@@ -131,7 +207,8 @@ impl DefPath {\n     }\n \n     pub fn deterministic_hash(&self, tcx: TyCtxt) -> u64 {\n-        let mut state = DefaultHasher::new();\n+        debug!(\"deterministic_hash({:?})\", self);\n+        let mut state = StableHasher::new();\n         self.deterministic_hash_to(tcx, &mut state);\n         state.finish()\n     }\n@@ -143,40 +220,13 @@ impl DefPath {\n     }\n }\n \n-/// Root of an inlined item. We track the `DefPath` of the item within\n-/// the original crate but also its def-id. This is kind of an\n-/// augmented version of a `DefPath` that includes a `DefId`. This is\n-/// all sort of ugly but the hope is that inlined items will be going\n-/// away soon anyway.\n-///\n-/// Some of the constraints that led to the current approach:\n-///\n-/// - I don't want to have a `DefId` in the main `DefPath` because\n-///   that gets serialized for incr. comp., and when reloaded the\n-///   `DefId` is no longer valid. I'd rather maintain the invariant\n-///   that every `DefId` is valid, and a potentially outdated `DefId` is\n-///   represented as a `DefPath`.\n-///   - (We don't serialize def-paths from inlined items, so it's ok to have one here.)\n-/// - We need to be able to extract the def-id from inline items to\n-///   make the symbol name. In theory we could retrace it from the\n-///   data, but the metadata doesn't have the required indices, and I\n-///   don't want to write the code to create one just for this.\n-/// - It may be that we don't actually need `data` at all. We'll have\n-///   to see about that.\n-#[derive(Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n-pub struct InlinedRootPath {\n-    pub data: Vec<DisambiguatedDefPathData>,\n-    pub def_id: DefId,\n-}\n \n #[derive(Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n pub enum DefPathData {\n     // Root: these should only be used for the root nodes, because\n     // they are treated specially by the `def_path` function.\n     /// The crate root (marker)\n     CrateRoot,\n-    /// An inlined root\n-    InlinedRoot(Box<InlinedRootPath>),\n \n     // Catch-all for random DefId things like DUMMY_NODE_ID\n     Misc,\n@@ -218,23 +268,30 @@ impl Definitions {\n     /// Create new empty definition map.\n     pub fn new() -> Definitions {\n         Definitions {\n-            data: vec![],\n-            key_map: FxHashMap(),\n-            node_map: NodeMap(),\n+            table: DefPathTable {\n+                index_to_key: vec![],\n+                key_to_index: FxHashMap(),\n+            },\n+            node_to_def_index: NodeMap(),\n+            def_index_to_node: vec![],\n         }\n     }\n \n+    pub fn def_path_table(&self) -> &DefPathTable {\n+        &self.table\n+    }\n+\n     /// Get the number of definitions.\n     pub fn len(&self) -> usize {\n-        self.data.len()\n+        self.def_index_to_node.len()\n     }\n \n     pub fn def_key(&self, index: DefIndex) -> DefKey {\n-        self.data[index.as_usize()].key.clone()\n+        self.table.def_key(index)\n     }\n \n     pub fn def_index_for_def_key(&self, key: DefKey) -> Option<DefIndex> {\n-        self.key_map.get(&key).cloned()\n+        self.table.def_index_for_def_key(&key)\n     }\n \n     /// Returns the path from the crate root to `index`. The root\n@@ -247,7 +304,7 @@ impl Definitions {\n     }\n \n     pub fn opt_def_index(&self, node: ast::NodeId) -> Option<DefIndex> {\n-        self.node_map.get(&node).cloned()\n+        self.node_to_def_index.get(&node).cloned()\n     }\n \n     pub fn opt_local_def_id(&self, node: ast::NodeId) -> Option<DefId> {\n@@ -260,8 +317,8 @@ impl Definitions {\n \n     pub fn as_local_node_id(&self, def_id: DefId) -> Option<ast::NodeId> {\n         if def_id.krate == LOCAL_CRATE {\n-            assert!(def_id.index.as_usize() < self.data.len());\n-            Some(self.data[def_id.index.as_usize()].node_id)\n+            assert!(def_id.index.as_usize() < self.def_index_to_node.len());\n+            Some(self.def_index_to_node[def_id.index.as_usize()])\n         } else {\n             None\n         }\n@@ -276,16 +333,13 @@ impl Definitions {\n         debug!(\"create_def_with_parent(parent={:?}, node_id={:?}, data={:?})\",\n                parent, node_id, data);\n \n-        assert!(!self.node_map.contains_key(&node_id),\n+        assert!(!self.node_to_def_index.contains_key(&node_id),\n                 \"adding a def'n for node-id {:?} and data {:?} but a previous def'n exists: {:?}\",\n                 node_id,\n                 data,\n-                self.data[self.node_map[&node_id].as_usize()]);\n+                self.table.def_key(self.node_to_def_index[&node_id]));\n \n-        assert!(parent.is_some() ^ match data {\n-            DefPathData::CrateRoot | DefPathData::InlinedRoot(_) => true,\n-            _ => false,\n-        });\n+        assert!(parent.is_some() ^ (data == DefPathData::CrateRoot));\n \n         // Find a unique DefKey. This basically means incrementing the disambiguator\n         // until we get no match.\n@@ -297,20 +351,18 @@ impl Definitions {\n             }\n         };\n \n-        while self.key_map.contains_key(&key) {\n+        while self.table.contains_key(&key) {\n             key.disambiguated_data.disambiguator += 1;\n         }\n \n         debug!(\"create_def_with_parent: after disambiguation, key = {:?}\", key);\n \n         // Create the definition.\n-        let index = DefIndex::new(self.data.len());\n-        self.data.push(DefData { key: key.clone(), node_id: node_id });\n-        debug!(\"create_def_with_parent: node_map[{:?}] = {:?}\", node_id, index);\n-        self.node_map.insert(node_id, index);\n-        debug!(\"create_def_with_parent: key_map[{:?}] = {:?}\", key, index);\n-        self.key_map.insert(key, index);\n-\n+        let index = self.table.insert(key);\n+        debug!(\"create_def_with_parent: def_index_to_node[{:?} <-> {:?}\", index, node_id);\n+        self.node_to_def_index.insert(node_id, index);\n+        assert_eq!(index.as_usize(), self.def_index_to_node.len());\n+        self.def_index_to_node.push(node_id);\n \n         index\n     }\n@@ -332,7 +384,6 @@ impl DefPathData {\n \n             Impl |\n             CrateRoot |\n-            InlinedRoot(_) |\n             Misc |\n             ClosureExpr |\n             StructCtor |\n@@ -359,9 +410,6 @@ impl DefPathData {\n             // note that this does not show up in user printouts\n             CrateRoot => \"{{root}}\",\n \n-            // note that this does not show up in user printouts\n-            InlinedRoot(_) => \"{{inlined-root}}\",\n-\n             Impl => \"{{impl}}\",\n             Misc => \"{{?}}\",\n             ClosureExpr => \"{{closure}}\",\n@@ -377,4 +425,3 @@ impl DefPathData {\n         self.as_interned_str().to_string()\n     }\n }\n-"}, {"sha": "4546f6d8c27e6b64674c9fd166d8498de791c3db", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 13, "deletions": 32, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -13,7 +13,7 @@ use self::MapEntry::*;\n use self::collector::NodeCollector;\n pub use self::def_collector::{DefCollector, MacroInvocationData};\n pub use self::definitions::{Definitions, DefKey, DefPath, DefPathData,\n-                            DisambiguatedDefPathData, InlinedRootPath};\n+                            DisambiguatedDefPathData};\n \n use dep_graph::{DepGraph, DepNode};\n \n@@ -221,22 +221,14 @@ pub struct Map<'ast> {\n     /// plain old integers.\n     map: RefCell<Vec<MapEntry<'ast>>>,\n \n-    definitions: RefCell<Definitions>,\n+    definitions: Definitions,\n \n     /// All NodeIds that are numerically greater or equal to this value come\n     /// from inlined items.\n     local_node_id_watermark: NodeId,\n-\n-    /// All def-indices that are numerically greater or equal to this value come\n-    /// from inlined items.\n-    local_def_id_watermark: usize,\n }\n \n impl<'ast> Map<'ast> {\n-    pub fn is_inlined_def_id(&self, id: DefId) -> bool {\n-        id.is_local() && id.index.as_usize() >= self.local_def_id_watermark\n-    }\n-\n     pub fn is_inlined_node_id(&self, id: NodeId) -> bool {\n         id >= self.local_node_id_watermark\n     }\n@@ -262,7 +254,6 @@ impl<'ast> Map<'ast> {\n                     EntryItem(_, item) => {\n                         assert_eq!(id, item.id);\n                         let def_id = self.local_def_id(id);\n-                        assert!(!self.is_inlined_def_id(def_id));\n \n                         if let Some(last_id) = last_expr {\n                             // The body of the item may have a separate dep node\n@@ -278,7 +269,6 @@ impl<'ast> Map<'ast> {\n \n                     EntryImplItem(_, item) => {\n                         let def_id = self.local_def_id(id);\n-                        assert!(!self.is_inlined_def_id(def_id));\n \n                         if let Some(last_id) = last_expr {\n                             // The body of the item may have a separate dep node\n@@ -392,12 +382,16 @@ impl<'ast> Map<'ast> {\n     }\n \n     pub fn num_local_def_ids(&self) -> usize {\n-        self.definitions.borrow().len()\n+        self.definitions.len()\n+    }\n+\n+    pub fn definitions(&self) -> &Definitions {\n+        &self.definitions\n     }\n \n     pub fn def_key(&self, def_id: DefId) -> DefKey {\n         assert!(def_id.is_local());\n-        self.definitions.borrow().def_key(def_id.index)\n+        self.definitions.def_key(def_id.index)\n     }\n \n     pub fn def_path_from_id(&self, id: NodeId) -> Option<DefPath> {\n@@ -408,11 +402,11 @@ impl<'ast> Map<'ast> {\n \n     pub fn def_path(&self, def_id: DefId) -> DefPath {\n         assert!(def_id.is_local());\n-        self.definitions.borrow().def_path(def_id.index)\n+        self.definitions.def_path(def_id.index)\n     }\n \n     pub fn def_index_for_def_key(&self, def_key: DefKey) -> Option<DefIndex> {\n-        self.definitions.borrow().def_index_for_def_key(def_key)\n+        self.definitions.def_index_for_def_key(def_key)\n     }\n \n     pub fn local_def_id(&self, node: NodeId) -> DefId {\n@@ -423,11 +417,11 @@ impl<'ast> Map<'ast> {\n     }\n \n     pub fn opt_local_def_id(&self, node: NodeId) -> Option<DefId> {\n-        self.definitions.borrow().opt_local_def_id(node)\n+        self.definitions.opt_local_def_id(node)\n     }\n \n     pub fn as_local_node_id(&self, def_id: DefId) -> Option<NodeId> {\n-        self.definitions.borrow().as_local_node_id(def_id)\n+        self.definitions.as_local_node_id(def_id)\n     }\n \n     fn entry_count(&self) -> usize {\n@@ -930,42 +924,29 @@ pub fn map_crate<'ast>(forest: &'ast mut Forest,\n     }\n \n     let local_node_id_watermark = NodeId::new(map.len());\n-    let local_def_id_watermark = definitions.len();\n \n     Map {\n         forest: forest,\n         dep_graph: forest.dep_graph.clone(),\n         map: RefCell::new(map),\n-        definitions: RefCell::new(definitions),\n+        definitions: definitions,\n         local_node_id_watermark: local_node_id_watermark,\n-        local_def_id_watermark: local_def_id_watermark,\n     }\n }\n \n /// Used for items loaded from external crate that are being inlined into this\n /// crate.\n pub fn map_decoded_item<'ast>(map: &Map<'ast>,\n-                              parent_def_path: DefPath,\n-                              parent_def_id: DefId,\n                               ii: InlinedItem,\n                               ii_parent_id: NodeId)\n                               -> &'ast InlinedItem {\n     let _ignore = map.forest.dep_graph.in_ignore();\n \n     let ii = map.forest.inlined_items.alloc(ii);\n \n-    let defs = &mut *map.definitions.borrow_mut();\n-    let mut def_collector = DefCollector::extend(ii_parent_id,\n-                                                 parent_def_path.clone(),\n-                                                 parent_def_id,\n-                                                 defs);\n-    def_collector.walk_item(ii, map.krate());\n-\n     let mut collector = NodeCollector::extend(map.krate(),\n                                               ii,\n                                               ii_parent_id,\n-                                              parent_def_path,\n-                                              parent_def_id,\n                                               mem::replace(&mut *map.map.borrow_mut(), vec![]));\n     ii.visit(&mut collector);\n     *map.map.borrow_mut() = collector.map;"}, {"sha": "4eee76d466ac1a67adbb49df190e03a22ac59fed", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -105,15 +105,18 @@ pub struct LifetimeDef {\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash)]\n pub struct Path {\n     pub span: Span,\n-    /// A `::foo` path, is relative to the crate root rather than current\n-    /// module (like paths in an import).\n-    pub global: bool,\n     /// The definition that the path resolved to.\n     pub def: Def,\n     /// The segments in the path: the things separated by `::`.\n     pub segments: HirVec<PathSegment>,\n }\n \n+impl Path {\n+    pub fn is_global(&self) -> bool {\n+        !self.segments.is_empty() && self.segments[0].name == keywords::CrateRoot.name()\n+    }\n+}\n+\n impl fmt::Debug for Path {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"path({})\", print::path_to_string(self))\n@@ -475,8 +478,6 @@ pub struct MacroDef {\n     pub attrs: HirVec<Attribute>,\n     pub id: NodeId,\n     pub span: Span,\n-    pub imported_from: Option<Name>,\n-    pub allow_internal_unstable: bool,\n     pub body: HirVec<TokenTree>,\n }\n \n@@ -1533,8 +1534,6 @@ pub struct ItemId {\n     pub id: NodeId,\n }\n \n-//  FIXME (#3300): Should allow items to be anonymous. Right now\n-//  we just use dummy names for anon items.\n /// An item\n ///\n /// The name might be a dummy name in case of anonymous items"}, {"sha": "100e344d9418036af1b7790a2a2b9bbc8ba5d285", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 12, "deletions": 16, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -1643,17 +1643,14 @@ impl<'a> State<'a> {\n                   -> io::Result<()> {\n         self.maybe_print_comment(path.span.lo)?;\n \n-        let mut first = !path.global;\n-        for segment in &path.segments {\n-            if first {\n-                first = false\n-            } else {\n+        for (i, segment) in path.segments.iter().enumerate() {\n+            if i > 0 {\n                 word(&mut self.s, \"::\")?\n             }\n-\n-            self.print_name(segment.name)?;\n-\n-            self.print_path_parameters(&segment.parameters, colons_before_params)?;\n+            if segment.name != keywords::CrateRoot.name() && segment.name != \"$crate\" {\n+                self.print_name(segment.name)?;\n+                self.print_path_parameters(&segment.parameters, colons_before_params)?;\n+            }\n         }\n \n         Ok(())\n@@ -1673,15 +1670,14 @@ impl<'a> State<'a> {\n                 space(&mut self.s)?;\n                 self.word_space(\"as\")?;\n \n-                let mut first = !path.global;\n-                for segment in &path.segments[..path.segments.len() - 1] {\n-                    if first {\n-                        first = false\n-                    } else {\n+                for (i, segment) in path.segments[..path.segments.len() - 1].iter().enumerate() {\n+                    if i > 0 {\n                         word(&mut self.s, \"::\")?\n                     }\n-                    self.print_name(segment.name)?;\n-                    self.print_path_parameters(&segment.parameters, colons_before_params)?;\n+                    if segment.name != keywords::CrateRoot.name() && segment.name != \"$crate\" {\n+                        self.print_name(segment.name)?;\n+                        self.print_path_parameters(&segment.parameters, colons_before_params)?;\n+                    }\n                 }\n \n                 word(&mut self.s, \">\")?;"}, {"sha": "9d48fbca53edd9ddf11c8af56286e87fd8bc9ed1", "filename": "src/librustc/infer/error_reporting.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -1620,7 +1620,6 @@ impl<'a, 'gcx, 'tcx> Rebuilder<'a, 'gcx, 'tcx> {\n         new_segs.push(new_seg);\n         hir::Path {\n             span: path.span,\n-            global: path.global,\n             def: path.def,\n             segments: new_segs.into()\n         }"}, {"sha": "3e7cc0b1e3e9c2150b8235b1576b478f938901ee", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -1367,9 +1367,10 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                    cause: &ObligationCause<'tcx>,\n                                    expected: Ty<'tcx>,\n                                    actual: Ty<'tcx>,\n-                                   err: TypeError<'tcx>) {\n+                                   err: TypeError<'tcx>)\n+                                   -> DiagnosticBuilder<'tcx> {\n         let trace = TypeTrace::types(cause, true, expected, actual);\n-        self.report_and_explain_type_error(trace, &err).emit();\n+        self.report_and_explain_type_error(trace, &err)\n     }\n \n     pub fn report_conflicting_default_types(&self,"}, {"sha": "17cc34fcd839414b36e8445bbf91d2dac34515c1", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -24,7 +24,6 @@\n #![cfg_attr(not(stage0), deny(warnings))]\n \n #![feature(associated_consts)]\n-#![feature(borrow_state)]\n #![feature(box_patterns)]\n #![feature(box_syntax)]\n #![feature(collections)]"}, {"sha": "667c2590fa9966d7b6f539fc70c5ad5849f15dfd", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -211,6 +211,12 @@ declare_lint! {\n      not named `mod.rs`\"\n }\n \n+declare_lint! {\n+    pub LEGACY_IMPORTS,\n+    Warn,\n+    \"detects names that resolve to ambiguous glob imports with RFC 1560\"\n+}\n+\n declare_lint! {\n     pub DEPRECATED,\n     Warn,\n@@ -257,6 +263,7 @@ impl LintPass for HardwiredLints {\n             PATTERNS_IN_FNS_WITHOUT_BODY,\n             EXTRA_REQUIREMENT_IN_IMPL,\n             LEGACY_DIRECTORY_OWNERSHIP,\n+            LEGACY_IMPORTS,\n             DEPRECATED\n         )\n     }"}, {"sha": "d0003693eefe34e78b071150593427bfa13443e3", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 18, "deletions": 19, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -25,7 +25,7 @@\n use hir::def::{self, Def};\n use hir::def_id::{CrateNum, DefId, DefIndex};\n use hir::map as hir_map;\n-use hir::map::definitions::{Definitions, DefKey};\n+use hir::map::definitions::{Definitions, DefKey, DisambiguatedDefPathData};\n use hir::svh::Svh;\n use middle::lang_items;\n use ty::{self, Ty, TyCtxt};\n@@ -298,8 +298,7 @@ pub trait CrateStore<'tcx> {\n \n     // trait/impl-item info\n     fn trait_of_item(&self, def_id: DefId) -> Option<DefId>;\n-    fn associated_item<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n-                           -> Option<ty::AssociatedItem>;\n+    fn associated_item(&self, def: DefId) -> Option<ty::AssociatedItem>;\n \n     // flags\n     fn is_const_fn(&self, did: DefId) -> bool;\n@@ -336,12 +335,12 @@ pub trait CrateStore<'tcx> {\n     fn is_no_builtins(&self, cnum: CrateNum) -> bool;\n \n     // resolve\n-    fn def_index_for_def_key(&self,\n-                             cnum: CrateNum,\n-                             def: DefKey)\n-                             -> Option<DefIndex>;\n-    fn def_key(&self, def: DefId) -> hir_map::DefKey;\n-    fn relative_def_path(&self, def: DefId) -> Option<hir_map::DefPath>;\n+    fn retrace_path(&self,\n+                    cnum: CrateNum,\n+                    path_data: &[DisambiguatedDefPathData])\n+                    -> Option<DefId>;\n+    fn def_key(&self, def: DefId) -> DefKey;\n+    fn def_path(&self, def: DefId) -> hir_map::DefPath;\n     fn struct_field_names(&self, def: DefId) -> Vec<ast::Name>;\n     fn item_children(&self, did: DefId) -> Vec<def::Export>;\n     fn load_macro(&self, did: DefId, sess: &Session) -> LoadedMacro;\n@@ -442,12 +441,6 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n \n     // trait info\n     fn implementations_of_trait(&self, filter: Option<DefId>) -> Vec<DefId> { vec![] }\n-    fn def_index_for_def_key(&self,\n-                             cnum: CrateNum,\n-                             def: DefKey)\n-                             -> Option<DefIndex> {\n-        None\n-    }\n \n     // impl info\n     fn associated_item_def_ids(&self, def_id: DefId) -> Vec<DefId>\n@@ -462,8 +455,7 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n \n     // trait/impl-item info\n     fn trait_of_item(&self, def_id: DefId) -> Option<DefId> { bug!(\"trait_of_item\") }\n-    fn associated_item<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n-                           -> Option<ty::AssociatedItem> { bug!(\"associated_item\") }\n+    fn associated_item(&self, def: DefId) -> Option<ty::AssociatedItem> { bug!(\"associated_item\") }\n \n     // flags\n     fn is_const_fn(&self, did: DefId) -> bool { bug!(\"is_const_fn\") }\n@@ -508,8 +500,15 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n     fn is_no_builtins(&self, cnum: CrateNum) -> bool { bug!(\"is_no_builtins\") }\n \n     // resolve\n-    fn def_key(&self, def: DefId) -> hir_map::DefKey { bug!(\"def_key\") }\n-    fn relative_def_path(&self, def: DefId) -> Option<hir_map::DefPath> {\n+    fn retrace_path(&self,\n+                    cnum: CrateNum,\n+                    path_data: &[DisambiguatedDefPathData])\n+                    -> Option<DefId> {\n+        None\n+    }\n+\n+    fn def_key(&self, def: DefId) -> DefKey { bug!(\"def_key\") }\n+    fn def_path(&self, def: DefId) -> hir_map::DefPath {\n         bug!(\"relative_def_path\")\n     }\n     fn struct_field_names(&self, def: DefId) -> Vec<ast::Name> { bug!(\"struct_field_names\") }"}, {"sha": "1c5dd97b74bd332c2b5854116df34f5910c34649", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 6, "deletions": 18, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -86,20 +86,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n         }\n     }\n \n-    fn handle_definition(&mut self, id: ast::NodeId, def: Def) {\n-        // If `bar` is a trait item, make sure to mark Foo as alive in `Foo::bar`\n-        match def {\n-            Def::AssociatedTy(..) | Def::Method(_) | Def::AssociatedConst(_)\n-            if self.tcx.trait_of_item(def.def_id()).is_some() => {\n-                if let Some(substs) = self.tcx.tables().item_substs.get(&id) {\n-                    if let ty::TyAdt(tyid, _) = substs.substs.type_at(0).sty {\n-                        self.check_def_id(tyid.did);\n-                    }\n-                }\n-            }\n-            _ => {}\n-        }\n-\n+    fn handle_definition(&mut self, def: Def) {\n         match def {\n             Def::Const(_) | Def::AssociatedConst(..) => {\n                 self.check_def_id(def.def_id());\n@@ -241,7 +228,7 @@ impl<'a, 'tcx> Visitor<'tcx> for MarkSymbolVisitor<'a, 'tcx> {\n         match expr.node {\n             hir::ExprPath(ref qpath @ hir::QPath::TypeRelative(..)) => {\n                 let def = self.tcx.tables().qpath_def(qpath, expr.id);\n-                self.handle_definition(expr.id, def);\n+                self.handle_definition(def);\n             }\n             hir::ExprMethodCall(..) => {\n                 self.lookup_and_handle_method(expr.id);\n@@ -281,7 +268,7 @@ impl<'a, 'tcx> Visitor<'tcx> for MarkSymbolVisitor<'a, 'tcx> {\n             }\n             PatKind::Path(ref qpath @ hir::QPath::TypeRelative(..)) => {\n                 let def = self.tcx.tables().qpath_def(qpath, pat.id);\n-                self.handle_definition(pat.id, def);\n+                self.handle_definition(def);\n             }\n             _ => ()\n         }\n@@ -291,8 +278,8 @@ impl<'a, 'tcx> Visitor<'tcx> for MarkSymbolVisitor<'a, 'tcx> {\n         self.ignore_non_const_paths = false;\n     }\n \n-    fn visit_path(&mut self, path: &'tcx hir::Path, id: ast::NodeId) {\n-        self.handle_definition(id, path.def);\n+    fn visit_path(&mut self, path: &'tcx hir::Path, _: ast::NodeId) {\n+        self.handle_definition(path.def);\n         intravisit::walk_path(self, path);\n     }\n }\n@@ -426,6 +413,7 @@ impl<'a, 'tcx> DeadVisitor<'a, 'tcx> {\n             hir::ItemStatic(..)\n             | hir::ItemConst(..)\n             | hir::ItemFn(..)\n+            | hir::ItemTy(..)\n             | hir::ItemEnum(..)\n             | hir::ItemStruct(..)\n             | hir::ItemUnion(..) => true,"}, {"sha": "029a1d66add0b3f8deb728e388c252fcb00beff9", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -328,7 +328,6 @@ language_item_table! {\n     PanicFmtLangItem,                \"panic_fmt\",               panic_fmt;\n \n     ExchangeMallocFnLangItem,        \"exchange_malloc\",         exchange_malloc_fn;\n-    ExchangeFreeFnLangItem,          \"exchange_free\",           exchange_free_fn;\n     BoxFreeFnLangItem,               \"box_free\",                box_free_fn;\n     StrDupUniqFnLangItem,            \"strdup_uniq\",             strdup_uniq_fn;\n "}, {"sha": "f45e86f2f4b9615d32aae1b8c51fb41adf328ff2", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -302,9 +302,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Annotator<'a, 'tcx> {\n     }\n \n     fn visit_macro_def(&mut self, md: &'tcx hir::MacroDef) {\n-        if md.imported_from.is_none() {\n-            self.annotate(md.id, &md.attrs, md.span, AnnotationKind::Required, |_| {});\n-        }\n+        self.annotate(md.id, &md.attrs, md.span, AnnotationKind::Required, |_| {});\n     }\n }\n \n@@ -373,9 +371,7 @@ impl<'a, 'tcx> Visitor<'tcx> for MissingStabilityAnnotations<'a, 'tcx> {\n     }\n \n     fn visit_macro_def(&mut self, md: &'tcx hir::MacroDef) {\n-        if md.imported_from.is_none() {\n-            self.check_missing_stability(md.id, md.span);\n-        }\n+        self.check_missing_stability(md.id, md.span);\n     }\n }\n "}, {"sha": "a042b2abf3a298a3179f45df69a3b8f910ece145", "filename": "src/librustc/session/code_stats.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc%2Fsession%2Fcode_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc%2Fsession%2Fcode_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fcode_stats.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -142,7 +142,12 @@ impl CodeStats {\n                 max_variant_size = cmp::max(max_variant_size, size);\n \n                 let mut min_offset = discr_size;\n-                for field in fields {\n+\n+                // We want to print fields by increasing offset.\n+                let mut fields = fields.clone();\n+                fields.sort_by_key(|f| f.offset);\n+\n+                for field in fields.iter() {\n                     let FieldInfo { ref name, offset, size, align } = *field;\n \n                     // Include field alignment in output only if it caused padding injection"}, {"sha": "ecc8042e9404f20d1fd777d51fbfc1b2fe76bd87", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -928,6 +928,8 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n           \"print some statistics about MIR\"),\n     always_encode_mir: bool = (false, parse_bool, [TRACKED],\n           \"encode MIR of all functions into the crate metadata\"),\n+    osx_rpath_install_name: bool = (false, parse_bool, [TRACKED],\n+          \"pass `-install_name @rpath/...` to the OSX linker\"),\n }\n \n pub fn default_lib_output() -> CrateType {\n@@ -943,26 +945,20 @@ pub fn default_configuration(sess: &Session) -> ast::CrateConfig {\n     let vendor = &sess.target.target.target_vendor;\n     let max_atomic_width = sess.target.target.max_atomic_width();\n \n-    let fam = if let Some(ref fam) = sess.target.target.options.target_family {\n-        Symbol::intern(fam)\n-    } else if sess.target.target.options.is_like_windows {\n-        Symbol::intern(\"windows\")\n-    } else {\n-        Symbol::intern(\"unix\")\n-    };\n-\n     let mut ret = HashSet::new();\n     // Target bindings.\n     ret.insert((Symbol::intern(\"target_os\"), Some(Symbol::intern(os))));\n-    ret.insert((Symbol::intern(\"target_family\"), Some(fam)));\n+    if let Some(ref fam) = sess.target.target.options.target_family {\n+        ret.insert((Symbol::intern(\"target_family\"), Some(Symbol::intern(fam))));\n+        if fam == \"windows\" || fam == \"unix\" {\n+            ret.insert((Symbol::intern(fam), None));\n+        }\n+    }\n     ret.insert((Symbol::intern(\"target_arch\"), Some(Symbol::intern(arch))));\n     ret.insert((Symbol::intern(\"target_endian\"), Some(Symbol::intern(end))));\n     ret.insert((Symbol::intern(\"target_pointer_width\"), Some(Symbol::intern(wordsz))));\n     ret.insert((Symbol::intern(\"target_env\"), Some(Symbol::intern(env))));\n     ret.insert((Symbol::intern(\"target_vendor\"), Some(Symbol::intern(vendor))));\n-    if fam == \"windows\" || fam == \"unix\" {\n-        ret.insert((fam, None));\n-    }\n     if sess.target.target.options.has_elf_tls {\n         ret.insert((Symbol::intern(\"target_thread_local\"), None));\n     }"}, {"sha": "36a887e062273b719d31edaa1311fba38432fa2c", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -136,6 +136,8 @@ pub struct PerfStats {\n     pub incr_comp_bytes_hashed: Cell<u64>,\n     // The accumulated time spent on computing symbol hashes\n     pub symbol_hash_time: Cell<Duration>,\n+    // The accumulated time spent decoding def path tables from metadata\n+    pub decode_def_path_tables_time: Cell<Duration>,\n }\n \n impl Session {\n@@ -501,6 +503,8 @@ impl Session {\n                  self.perf_stats.incr_comp_hashes_count.get());\n         println!(\"Total time spent computing symbol hashes:      {}\",\n                  duration_to_secs_str(self.perf_stats.symbol_hash_time.get()));\n+        println!(\"Total time spent decoding DefPath tables:      {}\",\n+                 duration_to_secs_str(self.perf_stats.decode_def_path_tables_time.get()));\n     }\n }\n \n@@ -635,6 +639,7 @@ pub fn build_session_(sopts: config::Options,\n             incr_comp_hashes_count: Cell::new(0),\n             incr_comp_bytes_hashed: Cell::new(0),\n             symbol_hash_time: Cell::new(Duration::from_secs(0)),\n+            decode_def_path_tables_time: Cell::new(Duration::from_secs(0)),\n         },\n         code_stats: RefCell::new(CodeStats::new()),\n     };"}, {"sha": "ab8c552d561f6100dc4cde5e5ccd5af1b4fe5788", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 38, "deletions": 8, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -458,11 +458,28 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         err\n     }\n \n+\n+    /// Get the parent trait chain start\n+    fn get_parent_trait_ref(&self, code: &ObligationCauseCode<'tcx>) -> Option<String> {\n+        match code {\n+            &ObligationCauseCode::BuiltinDerivedObligation(ref data) => {\n+                let parent_trait_ref = self.resolve_type_vars_if_possible(\n+                    &data.parent_trait_ref);\n+                match self.get_parent_trait_ref(&data.parent_code) {\n+                    Some(t) => Some(t),\n+                    None => Some(format!(\"{}\", parent_trait_ref.0.self_ty())),\n+                }\n+            }\n+            _ => None,\n+        }\n+    }\n+\n     pub fn report_selection_error(&self,\n                                   obligation: &PredicateObligation<'tcx>,\n                                   error: &SelectionError<'tcx>)\n     {\n         let span = obligation.cause.span;\n+\n         let mut err = match *error {\n             SelectionError::Unimplemented => {\n                 if let ObligationCauseCode::CompareImplMethodObligation {\n@@ -487,14 +504,27 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                 return;\n                             } else {\n                                 let trait_ref = trait_predicate.to_poly_trait_ref();\n-\n-                                let mut err = struct_span_err!(self.tcx.sess, span, E0277,\n-                                    \"the trait bound `{}` is not satisfied\",\n-                                    trait_ref.to_predicate());\n-                                err.span_label(span, &format!(\"the trait `{}` is not implemented \\\n-                                                               for `{}`\",\n-                                                              trait_ref,\n-                                                              trait_ref.self_ty()));\n+                                let (post_message, pre_message) = match self.get_parent_trait_ref(\n+                                    &obligation.cause.code)\n+                                {\n+                                    Some(t) => {\n+                                        (format!(\" in `{}`\", t), format!(\"within `{}`, \", t))\n+                                    }\n+                                    None => (String::new(), String::new()),\n+                                };\n+                                let mut err = struct_span_err!(\n+                                    self.tcx.sess,\n+                                    span,\n+                                    E0277,\n+                                    \"the trait bound `{}` is not satisfied{}\",\n+                                    trait_ref.to_predicate(),\n+                                    post_message);\n+                                err.span_label(span,\n+                                               &format!(\"{}the trait `{}` is not \\\n+                                                         implemented for `{}`\",\n+                                                        pre_message,\n+                                                        trait_ref,\n+                                                        trait_ref.self_ty()));\n \n                                 // Try to report a help message\n "}, {"sha": "f24ff98035532222905e7e32733d8f3d1f5b498a", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 14, "deletions": 45, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -15,9 +15,9 @@ use session::Session;\n use middle;\n use hir::TraitMap;\n use hir::def::Def;\n-use hir::def_id::{CrateNum, DefId, DefIndex, LOCAL_CRATE};\n+use hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use hir::map as ast_map;\n-use hir::map::{DefKey, DefPathData, DisambiguatedDefPathData};\n+use hir::map::DisambiguatedDefPathData;\n use middle::free_region::FreeRegionMap;\n use middle::region::RegionMaps;\n use middle::resolve_lifetime;\n@@ -627,50 +627,21 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    /// Given a def-key `key` and a crate `krate`, finds the def-index\n-    /// that `krate` assigned to `key`. This `DefIndex` will always be\n-    /// relative to `krate`.\n-    ///\n-    /// Returns `None` if there is no `DefIndex` with that key.\n-    pub fn def_index_for_def_key(self, krate: CrateNum, key: DefKey)\n-                                 -> Option<DefIndex> {\n-        if krate == LOCAL_CRATE {\n-            self.map.def_index_for_def_key(key)\n-        } else {\n-            self.sess.cstore.def_index_for_def_key(krate, key)\n-        }\n-    }\n-\n     pub fn retrace_path(self,\n                         krate: CrateNum,\n                         path_data: &[DisambiguatedDefPathData])\n                         -> Option<DefId> {\n         debug!(\"retrace_path(path={:?}, krate={:?})\", path_data, self.crate_name(krate));\n \n-        let root_key = DefKey {\n-            parent: None,\n-            disambiguated_data: DisambiguatedDefPathData {\n-                data: DefPathData::CrateRoot,\n-                disambiguator: 0,\n-            },\n-        };\n-\n-        let root_index = self.def_index_for_def_key(krate, root_key)\n-                             .expect(\"no root key?\");\n-\n-        debug!(\"retrace_path: root_index={:?}\", root_index);\n-\n-        let mut index = root_index;\n-        for data in path_data {\n-            let key = DefKey { parent: Some(index), disambiguated_data: data.clone() };\n-            debug!(\"retrace_path: key={:?}\", key);\n-            match self.def_index_for_def_key(krate, key) {\n-                Some(i) => index = i,\n-                None => return None,\n-            }\n+        if krate == LOCAL_CRATE {\n+            self.map\n+                .definitions()\n+                .def_path_table()\n+                .retrace_path(path_data)\n+                .map(|def_index| DefId { krate: krate, index: def_index })\n+        } else {\n+            self.sess.cstore.retrace_path(krate, path_data)\n         }\n-\n-        Some(DefId { krate: krate, index: index })\n     }\n \n     pub fn type_parameter_def(self,\n@@ -762,11 +733,9 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// reference to the context, to allow formatting values that need it.\n     pub fn create_and_enter<F, R>(s: &'tcx Session,\n                                   arenas: &'tcx CtxtArenas<'tcx>,\n-                                  trait_map: TraitMap,\n+                                  resolutions: ty::Resolutions,\n                                   named_region_map: resolve_lifetime::NamedRegionMap,\n                                   map: ast_map::Map<'tcx>,\n-                                  freevars: FreevarMap,\n-                                 maybe_unused_trait_imports: NodeSet,\n                                   region_maps: RegionMaps,\n                                   lang_items: middle::lang_items::LanguageItems,\n                                   stability: stability::Index<'tcx>,\n@@ -790,7 +759,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             item_variance_map: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n             variance_computed: Cell::new(false),\n             sess: s,\n-            trait_map: trait_map,\n+            trait_map: resolutions.trait_map,\n             tables: RefCell::new(Tables::empty()),\n             impl_trait_refs: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n             trait_defs: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n@@ -802,8 +771,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             fulfilled_predicates: RefCell::new(fulfilled_predicates),\n             map: map,\n             mir_map: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n-            freevars: RefCell::new(freevars),\n-            maybe_unused_trait_imports: maybe_unused_trait_imports,\n+            freevars: RefCell::new(resolutions.freevars),\n+            maybe_unused_trait_imports: resolutions.maybe_unused_trait_imports,\n             item_types: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n             rcache: RefCell::new(FxHashMap()),\n             tc_cache: RefCell::new(FxHashMap()),"}, {"sha": "0e4c14029e9b9860b3cc86942ab023c7c0ad96d2", "filename": "src/librustc/ty/item_path.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc%2Fty%2Fitem_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc%2Fty%2Fitem_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fitem_path.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -160,11 +160,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                 self.push_krate_path(buffer, def_id.krate);\n             }\n \n-            DefPathData::InlinedRoot(ref root_path) => {\n-                assert!(key.parent.is_none());\n-                self.push_item_path(buffer, root_path.def_id);\n-            }\n-\n             DefPathData::Impl => {\n                 self.push_impl_path(buffer, def_id);\n             }"}, {"sha": "ebac30c8e506edf57fbca9e28c1bca2bdd55b711", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 310, "deletions": 124, "changes": 434, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -24,6 +24,7 @@ use syntax_pos::DUMMY_SP;\n use std::cmp;\n use std::fmt;\n use std::i64;\n+use std::iter;\n \n /// Parsed [Data layout](http://llvm.org/docs/LangRef.html#data-layout)\n /// for a target, which contains everything needed to compute layouts.\n@@ -415,7 +416,7 @@ impl Integer {\n     /// signed discriminant range and #[repr] attribute.\n     /// N.B.: u64 values above i64::MAX will be treated as signed, but\n     /// that shouldn't affect anything, other than maybe debuginfo.\n-    pub fn repr_discr(tcx: TyCtxt, ty: Ty, hint: attr::ReprAttr, min: i64, max: i64)\n+    fn repr_discr(tcx: TyCtxt, ty: Ty, hints: &[attr::ReprAttr], min: i64, max: i64)\n                       -> (Integer, bool) {\n         // Theoretically, negative values could be larger in unsigned representation\n         // than the unsigned representation of the signed minimum. However, if there\n@@ -424,34 +425,41 @@ impl Integer {\n         let unsigned_fit = Integer::fit_unsigned(cmp::max(min as u64, max as u64));\n         let signed_fit = cmp::max(Integer::fit_signed(min), Integer::fit_signed(max));\n \n-        let at_least = match hint {\n-            attr::ReprInt(ity) => {\n-                let discr = Integer::from_attr(&tcx.data_layout, ity);\n-                let fit = if ity.is_signed() { signed_fit } else { unsigned_fit };\n-                if discr < fit {\n-                    bug!(\"Integer::repr_discr: `#[repr]` hint too small for \\\n-                          discriminant range of enum `{}\", ty)\n+        let mut min_from_extern = None;\n+        let min_default = I8;\n+\n+        for &r in hints.iter() {\n+            match r {\n+                attr::ReprInt(ity) => {\n+                    let discr = Integer::from_attr(&tcx.data_layout, ity);\n+                    let fit = if ity.is_signed() { signed_fit } else { unsigned_fit };\n+                    if discr < fit {\n+                        bug!(\"Integer::repr_discr: `#[repr]` hint too small for \\\n+                              discriminant range of enum `{}\", ty)\n+                    }\n+                    return (discr, ity.is_signed());\n                 }\n-                return (discr, ity.is_signed());\n-            }\n-            attr::ReprExtern => {\n-                match &tcx.sess.target.target.arch[..] {\n-                    // WARNING: the ARM EABI has two variants; the one corresponding\n-                    // to `at_least == I32` appears to be used on Linux and NetBSD,\n-                    // but some systems may use the variant corresponding to no\n-                    // lower bound.  However, we don't run on those yet...?\n-                    \"arm\" => I32,\n-                    _ => I32,\n+                attr::ReprExtern => {\n+                    match &tcx.sess.target.target.arch[..] {\n+                        // WARNING: the ARM EABI has two variants; the one corresponding\n+                        // to `at_least == I32` appears to be used on Linux and NetBSD,\n+                        // but some systems may use the variant corresponding to no\n+                        // lower bound.  However, we don't run on those yet...?\n+                        \"arm\" => min_from_extern = Some(I32),\n+                        _ => min_from_extern = Some(I32),\n+                    }\n+                }\n+                attr::ReprAny => {},\n+                attr::ReprPacked => {\n+                    bug!(\"Integer::repr_discr: found #[repr(packed)] on enum `{}\", ty);\n+                }\n+                attr::ReprSimd => {\n+                    bug!(\"Integer::repr_discr: found #[repr(simd)] on enum `{}\", ty);\n                 }\n             }\n-            attr::ReprAny => I8,\n-            attr::ReprPacked => {\n-                bug!(\"Integer::repr_discr: found #[repr(packed)] on enum `{}\", ty);\n-            }\n-            attr::ReprSimd => {\n-                bug!(\"Integer::repr_discr: found #[repr(simd)] on enum `{}\", ty);\n-            }\n-        };\n+        }\n+\n+        let at_least = min_from_extern.unwrap_or(min_default);\n \n         // If there are no negative values, we can use the unsigned fit.\n         if min >= 0 {\n@@ -511,70 +519,162 @@ pub struct Struct {\n     /// If true, the size is exact, otherwise it's only a lower bound.\n     pub sized: bool,\n \n-    /// Offsets for the first byte of each field.\n+    /// Offsets for the first byte of each field, ordered to match the source definition order.\n+    /// This vector does not go in increasing order.\n     /// FIXME(eddyb) use small vector optimization for the common case.\n     pub offsets: Vec<Size>,\n \n+    /// Maps source order field indices to memory order indices, depending how fields were permuted.\n+    /// FIXME (camlorn) also consider small vector  optimization here.\n+    pub memory_index: Vec<u32>,\n+\n     pub min_size: Size,\n }\n \n+// Info required to optimize struct layout.\n+#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Debug)]\n+enum StructKind {\n+    // A tuple, closure, or univariant which cannot be coerced to unsized.\n+    AlwaysSizedUnivariant,\n+    // A univariant, the last field of which may be coerced to unsized.\n+    MaybeUnsizedUnivariant,\n+    // A univariant, but part of an enum.\n+    EnumVariant,\n+}\n+\n impl<'a, 'gcx, 'tcx> Struct {\n-    pub fn new(dl: &TargetDataLayout, packed: bool) -> Struct {\n-        Struct {\n+    // FIXME(camlorn): reprs need a better representation to deal with multiple reprs on one type.\n+    fn new(dl: &TargetDataLayout, fields: &Vec<&'a Layout>,\n+                  reprs: &[attr::ReprAttr], kind: StructKind,\n+                  scapegoat: Ty<'gcx>) -> Result<Struct, LayoutError<'gcx>> {\n+        let packed = reprs.contains(&attr::ReprPacked);\n+        let mut ret = Struct {\n             align: if packed { dl.i8_align } else { dl.aggregate_align },\n             packed: packed,\n             sized: true,\n             offsets: vec![],\n+            memory_index: vec![],\n             min_size: Size::from_bytes(0),\n+        };\n+\n+        // Anything with ReprExtern or ReprPacked doesn't optimize.\n+        // Neither do  1-member and 2-member structs.\n+        // In addition, code in trans assume that 2-element structs can become pairs.\n+        // It's easier to just short-circuit here.\n+        let mut can_optimize = fields.len() > 2 || StructKind::EnumVariant == kind;\n+        if can_optimize {\n+            // This exhaustive match makes new reprs force the adder to modify this function.\n+            // Otherwise, things can silently break.\n+            // Note the inversion, return true to stop optimizing.\n+            can_optimize = !reprs.iter().any(|r| {\n+                match *r {\n+                    attr::ReprAny | attr::ReprInt(_) => false,\n+                    attr::ReprExtern | attr::ReprPacked => true,\n+                    attr::ReprSimd => bug!(\"Simd  vectors should be represented as layout::Vector\")\n+                }\n+            });\n         }\n-    }\n \n-    /// Extend the Struct with more fields.\n-    pub fn extend<I>(&mut self, dl: &TargetDataLayout,\n-                     fields: I,\n-                     scapegoat: Ty<'gcx>)\n-                     -> Result<(), LayoutError<'gcx>>\n-    where I: Iterator<Item=Result<&'a Layout, LayoutError<'gcx>>> {\n-        self.offsets.reserve(fields.size_hint().0);\n+        // Disable field reordering until we can decide what to do.\n+        // The odd pattern here avoids a warning about the value never being read.\n+        if can_optimize { can_optimize = false }\n \n-        let mut offset = self.min_size;\n+        let (optimize, sort_ascending) = match kind {\n+            StructKind::AlwaysSizedUnivariant => (can_optimize, false),\n+            StructKind::MaybeUnsizedUnivariant => (can_optimize, false),\n+            StructKind::EnumVariant => {\n+                assert!(fields.len() >= 1, \"Enum variants must have discriminants.\");\n+                (can_optimize && fields[0].size(dl).bytes() == 1, true)\n+            }\n+        };\n \n-        for field in fields {\n-            if !self.sized {\n-                bug!(\"Struct::extend: field #{} of `{}` comes after unsized field\",\n-                     self.offsets.len(), scapegoat);\n+        ret.offsets = vec![Size::from_bytes(0); fields.len()];\n+        let mut inverse_memory_index: Vec<u32> = (0..fields.len() as u32).collect();\n+\n+        if optimize {\n+            let start = if let StructKind::EnumVariant = kind { 1 } else { 0 };\n+            let end = if let StructKind::MaybeUnsizedUnivariant = kind {\n+                fields.len() - 1\n+            } else {\n+                fields.len()\n+            };\n+            if end > start {\n+                let optimizing  = &mut inverse_memory_index[start..end];\n+                if sort_ascending {\n+                    optimizing.sort_by_key(|&x| fields[x as usize].align(dl).abi());\n+                } else {\n+                    optimizing.sort_by(| &a, &b | {\n+                        let a = fields[a as usize].align(dl).abi();\n+                        let b = fields[b as usize].align(dl).abi();\n+                        b.cmp(&a)\n+                    });\n+                }\n+            }\n+        }\n+\n+        // inverse_memory_index holds field indices by increasing memory offset.\n+        // That is, if field 5 has offset 0, the first element of inverse_memory_index is 5.\n+        // We now write field offsets to the corresponding offset slot;\n+        // field 5 with offset 0 puts 0 in offsets[5].\n+        // At the bottom of this function, we use inverse_memory_index to produce memory_index.\n+\n+        if let StructKind::EnumVariant = kind {\n+            assert_eq!(inverse_memory_index[0], 0,\n+              \"Enum variant discriminants must have the lowest offset.\");\n+        }\n+\n+        let mut offset = Size::from_bytes(0);\n+\n+        for i in inverse_memory_index.iter() {\n+            let field = fields[*i as usize];\n+            if !ret.sized {\n+                bug!(\"Struct::new: field #{} of `{}` comes after unsized field\",\n+                     ret.offsets.len(), scapegoat);\n             }\n \n-            let field = field?;\n             if field.is_unsized() {\n-                self.sized = false;\n+                ret.sized = false;\n             }\n \n             // Invariant: offset < dl.obj_size_bound() <= 1<<61\n-            if !self.packed {\n+            if !ret.packed {\n                 let align = field.align(dl);\n-                self.align = self.align.max(align);\n+                ret.align = ret.align.max(align);\n                 offset = offset.abi_align(align);\n             }\n \n-            self.offsets.push(offset);\n-\n-            debug!(\"Struct::extend offset: {:?} field: {:?} {:?}\", offset, field, field.size(dl));\n+            debug!(\"Struct::new offset: {:?} field: {:?} {:?}\", offset, field, field.size(dl));\n+            ret.offsets[*i as usize] = offset;\n \n             offset = offset.checked_add(field.size(dl), dl)\n                            .map_or(Err(LayoutError::SizeOverflow(scapegoat)), Ok)?;\n         }\n \n-        debug!(\"Struct::extend min_size: {:?}\", offset);\n \n-        self.min_size = offset;\n+        debug!(\"Struct::new min_size: {:?}\", offset);\n+        ret.min_size = offset;\n \n-        Ok(())\n-    }\n+        // As stated above, inverse_memory_index holds field indices by increasing offset.\n+        // This makes it an already-sorted view of the offsets vec.\n+        // To invert it, consider:\n+        // If field 5 has offset 0, offsets[0] is 5, and memory_index[5] should be 0.\n+        // Field 5 would be the first element, so memory_index is i:\n+        // Note: if we didn't optimize, it's already right.\n \n-    /// Get the size without trailing alignment padding.\n+        if optimize {\n+            ret.memory_index = vec![0; inverse_memory_index.len()];\n \n-    /// Get the size with trailing aligment padding.\n+            for i in 0..inverse_memory_index.len() {\n+                ret.memory_index[inverse_memory_index[i] as usize]  = i as u32;\n+            }\n+        } else {\n+            ret.memory_index = inverse_memory_index;\n+        }\n+\n+        Ok(ret)\n+    }\n+\n+    /// Get the size with trailing alignment padding.\n     pub fn stride(&self) -> Size {\n         self.min_size.abi_align(self.align)\n     }\n@@ -592,18 +692,45 @@ impl<'a, 'gcx, 'tcx> Struct {\n         Ok(true)\n     }\n \n+    /// Get indices of the tys that made this struct by increasing offset.\n+    #[inline]\n+    pub fn field_index_by_increasing_offset<'b>(&'b self) -> impl iter::Iterator<Item=usize>+'b {\n+        let mut inverse_small = [0u8; 64];\n+        let mut inverse_big = vec![];\n+        let use_small = self.memory_index.len() <= inverse_small.len();\n+\n+        // We have to write this logic twice in order to keep the array small.\n+        if use_small {\n+            for i in 0..self.memory_index.len() {\n+                inverse_small[self.memory_index[i] as usize] = i as u8;\n+            }\n+        } else {\n+            inverse_big = vec![0; self.memory_index.len()];\n+            for i in 0..self.memory_index.len() {\n+                inverse_big[self.memory_index[i] as usize] = i as u32;\n+            }\n+        }\n+\n+        (0..self.memory_index.len()).map(move |i| {\n+            if use_small { inverse_small[i] as usize }\n+            else { inverse_big[i] as usize }\n+        })\n+    }\n+\n     /// Find the path leading to a non-zero leaf field, starting from\n     /// the given type and recursing through aggregates.\n+    /// The tuple is `(path, source_path)`,\n+    /// where `path` is in memory order and `source_path` in source order.\n     // FIXME(eddyb) track value ranges and traverse already optimized enums.\n-    pub fn non_zero_field_in_type(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n-                                  ty: Ty<'gcx>)\n-                                  -> Result<Option<FieldPath>, LayoutError<'gcx>> {\n+    fn non_zero_field_in_type(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+                               ty: Ty<'gcx>)\n+                               -> Result<Option<(FieldPath, FieldPath)>, LayoutError<'gcx>> {\n         let tcx = infcx.tcx.global_tcx();\n         match (ty.layout(infcx)?, &ty.sty) {\n             (&Scalar { non_zero: true, .. }, _) |\n-            (&CEnum { non_zero: true, .. }, _) => Ok(Some(vec![])),\n+            (&CEnum { non_zero: true, .. }, _) => Ok(Some((vec![], vec![]))),\n             (&FatPointer { non_zero: true, .. }, _) => {\n-                Ok(Some(vec![FAT_PTR_ADDR as u32]))\n+                Ok(Some((vec![FAT_PTR_ADDR as u32], vec![FAT_PTR_ADDR as u32])))\n             }\n \n             // Is this the NonZero lang item wrapping a pointer or integer type?\n@@ -614,38 +741,42 @@ impl<'a, 'gcx, 'tcx> Struct {\n                     // FIXME(eddyb) also allow floating-point types here.\n                     Scalar { value: Int(_), non_zero: false } |\n                     Scalar { value: Pointer, non_zero: false } => {\n-                        Ok(Some(vec![0]))\n+                        Ok(Some((vec![0], vec![0])))\n                     }\n                     FatPointer { non_zero: false, .. } => {\n-                        Ok(Some(vec![FAT_PTR_ADDR as u32, 0]))\n+                        let tmp = vec![FAT_PTR_ADDR as u32, 0];\n+                        Ok(Some((tmp.clone(), tmp)))\n                     }\n                     _ => Ok(None)\n                 }\n             }\n \n             // Perhaps one of the fields of this struct is non-zero\n             // let's recurse and find out\n-            (_, &ty::TyAdt(def, substs)) if def.is_struct() => {\n-                Struct::non_zero_field_path(infcx, def.struct_variant().fields\n+            (&Univariant { ref variant, .. }, &ty::TyAdt(def, substs)) if def.is_struct() => {\n+                Struct::non_zero_field_paths(infcx, def.struct_variant().fields\n                                                       .iter().map(|field| {\n                     field.ty(tcx, substs)\n-                }))\n+                }),\n+                Some(&variant.memory_index[..]))\n             }\n \n             // Perhaps one of the upvars of this closure is non-zero\n-            // Let's recurse and find out!\n-            (_, &ty::TyClosure(def_id, ref substs)) => {\n-                Struct::non_zero_field_path(infcx, substs.upvar_tys(def_id, tcx))\n+            (&Univariant { ref variant, .. }, &ty::TyClosure(def, substs)) => {\n+                let upvar_tys = substs.upvar_tys(def, tcx);\n+                Struct::non_zero_field_paths(infcx, upvar_tys,\n+                    Some(&variant.memory_index[..]))\n             }\n             // Can we use one of the fields in this tuple?\n-            (_, &ty::TyTuple(tys)) => {\n-                Struct::non_zero_field_path(infcx, tys.iter().cloned())\n+            (&Univariant { ref variant, .. }, &ty::TyTuple(tys)) => {\n+                Struct::non_zero_field_paths(infcx, tys.iter().cloned(),\n+                    Some(&variant.memory_index[..]))\n             }\n \n             // Is this a fixed-size array of something non-zero\n             // with at least one element?\n             (_, &ty::TyArray(ety, d)) if d > 0 => {\n-                Struct::non_zero_field_path(infcx, Some(ety).into_iter())\n+                Struct::non_zero_field_paths(infcx, Some(ety).into_iter(), None)\n             }\n \n             (_, &ty::TyProjection(_)) | (_, &ty::TyAnon(..)) => {\n@@ -663,14 +794,23 @@ impl<'a, 'gcx, 'tcx> Struct {\n \n     /// Find the path leading to a non-zero leaf field, starting from\n     /// the given set of fields and recursing through aggregates.\n-    pub fn non_zero_field_path<I>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n-                                  fields: I)\n-                                  -> Result<Option<FieldPath>, LayoutError<'gcx>>\n+    /// Returns Some((path, source_path)) on success.\n+    /// `path` is translated to memory order. `source_path` is not.\n+    fn non_zero_field_paths<I>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+                                  fields: I,\n+                                  permutation: Option<&[u32]>)\n+                                  -> Result<Option<(FieldPath, FieldPath)>, LayoutError<'gcx>>\n     where I: Iterator<Item=Ty<'gcx>> {\n         for (i, ty) in fields.enumerate() {\n-            if let Some(mut path) = Struct::non_zero_field_in_type(infcx, ty)? {\n-                path.push(i as u32);\n-                return Ok(Some(path));\n+            if let Some((mut path, mut source_path)) = Struct::non_zero_field_in_type(infcx, ty)? {\n+                source_path.push(i as u32);\n+                let index = if let Some(p) = permutation {\n+                    p[i] as usize\n+                } else {\n+                    i\n+                };\n+                path.push(index as u32);\n+                return Ok(Some((path, source_path)));\n             }\n         }\n         Ok(None)\n@@ -723,7 +863,7 @@ impl<'a, 'gcx, 'tcx> Union {\n         Ok(())\n     }\n \n-    /// Get the size with trailing aligment padding.\n+    /// Get the size with trailing alignment padding.\n     pub fn stride(&self) -> Size {\n         self.min_size.abi_align(self.align)\n     }\n@@ -833,7 +973,9 @@ pub enum Layout {\n         nndiscr: u64,\n         nonnull: Struct,\n         // N.B. There is a 0 at the start, for LLVM GEP through a pointer.\n-        discrfield: FieldPath\n+        discrfield: FieldPath,\n+        // Like discrfield, but in source order. For debuginfo.\n+        discrfield_source: FieldPath\n     }\n }\n \n@@ -887,6 +1029,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n         let dl = &tcx.data_layout;\n         assert!(!ty.has_infer_types());\n \n+\n         let layout = match ty.sty {\n             // Basic scalars.\n             ty::TyBool => Scalar { value: Int(I1), non_zero: false },\n@@ -908,7 +1051,11 @@ impl<'a, 'gcx, 'tcx> Layout {\n             ty::TyFnPtr(_) => Scalar { value: Pointer, non_zero: true },\n \n             // The never type.\n-            ty::TyNever => Univariant { variant: Struct::new(dl, false), non_zero: false },\n+            ty::TyNever => Univariant {\n+                variant: Struct::new(dl, &vec![], &[],\n+                  StructKind::AlwaysSizedUnivariant, ty)?,\n+                non_zero: false\n+            },\n \n             // Potentially-fat pointers.\n             ty::TyBox(pointee) |\n@@ -959,27 +1106,36 @@ impl<'a, 'gcx, 'tcx> Layout {\n             // Odd unit types.\n             ty::TyFnDef(..) => {\n                 Univariant {\n-                    variant: Struct::new(dl, false),\n+                    variant: Struct::new(dl, &vec![],\n+                      &[], StructKind::AlwaysSizedUnivariant, ty)?,\n                     non_zero: false\n                 }\n             }\n             ty::TyDynamic(..) => {\n-                let mut unit = Struct::new(dl, false);\n+                let mut unit = Struct::new(dl, &vec![], &[],\n+                  StructKind::AlwaysSizedUnivariant, ty)?;\n                 unit.sized = false;\n                 Univariant { variant: unit, non_zero: false }\n             }\n \n             // Tuples and closures.\n             ty::TyClosure(def_id, ref substs) => {\n-                let mut st = Struct::new(dl, false);\n                 let tys = substs.upvar_tys(def_id, tcx);\n-                st.extend(dl, tys.map(|ty| ty.layout(infcx)), ty)?;\n+                let st = Struct::new(dl,\n+                    &tys.map(|ty| ty.layout(infcx))\n+                      .collect::<Result<Vec<_>, _>>()?,\n+                    &[],\n+                    StructKind::AlwaysSizedUnivariant, ty)?;\n                 Univariant { variant: st, non_zero: false }\n             }\n \n             ty::TyTuple(tys) => {\n-                let mut st = Struct::new(dl, false);\n-                st.extend(dl, tys.iter().map(|ty| ty.layout(infcx)), ty)?;\n+                // FIXME(camlorn): if we ever allow unsized tuples, this needs to be checked.\n+                // See the univariant case below to learn how.\n+                let st = Struct::new(dl,\n+                    &tys.iter().map(|ty| ty.layout(infcx))\n+                      .collect::<Result<Vec<_>, _>>()?,\n+                    &[], StructKind::AlwaysSizedUnivariant, ty)?;\n                 Univariant { variant: st, non_zero: false }\n             }\n \n@@ -1003,16 +1159,16 @@ impl<'a, 'gcx, 'tcx> Layout {\n \n             // ADTs.\n             ty::TyAdt(def, substs) => {\n-                let hint = *tcx.lookup_repr_hints(def.did).get(0)\n-                    .unwrap_or(&attr::ReprAny);\n+                let hints = &tcx.lookup_repr_hints(def.did)[..];\n \n                 if def.variants.is_empty() {\n                     // Uninhabitable; represent as unit\n                     // (Typechecking will reject discriminant-sizing attrs.)\n-                    assert_eq!(hint, attr::ReprAny);\n+                    assert_eq!(hints.len(), 0);\n \n                     return success(Univariant {\n-                        variant: Struct::new(dl, false),\n+                        variant: Struct::new(dl, &vec![],\n+                          &hints[..], StructKind::AlwaysSizedUnivariant, ty)?,\n                         non_zero: false\n                     });\n                 }\n@@ -1027,7 +1183,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n                         if x > max { max = x; }\n                     }\n \n-                    let (discr, signed) = Integer::repr_discr(tcx, ty, hint, min, max);\n+                    let (discr, signed) = Integer::repr_discr(tcx, ty, &hints[..], min, max);\n                     return success(CEnum {\n                         discr: discr,\n                         signed: signed,\n@@ -1037,21 +1193,35 @@ impl<'a, 'gcx, 'tcx> Layout {\n                     });\n                 }\n \n-                if !def.is_enum() || def.variants.len() == 1 && hint == attr::ReprAny {\n+                if !def.is_enum() || def.variants.len() == 1 && hints.is_empty() {\n                     // Struct, or union, or univariant enum equivalent to a struct.\n                     // (Typechecking will reject discriminant-sizing attrs.)\n \n+                    let kind = if def.is_enum() || def.variants[0].fields.len() == 0{\n+                        StructKind::AlwaysSizedUnivariant\n+                    } else {\n+                        use middle::region::ROOT_CODE_EXTENT;\n+                        let param_env = tcx.construct_parameter_environment(DUMMY_SP,\n+                          def.did, ROOT_CODE_EXTENT);\n+                        let fields = &def.variants[0].fields;\n+                        let last_field = &fields[fields.len()-1];\n+                        let always_sized = last_field.ty(tcx, param_env.free_substs)\n+                          .is_sized(tcx, &param_env, DUMMY_SP);\n+                        if !always_sized { StructKind::MaybeUnsizedUnivariant }\n+                        else { StructKind::AlwaysSizedUnivariant }\n+                    };\n+\n                     let fields = def.variants[0].fields.iter().map(|field| {\n                         field.ty(tcx, substs).layout(infcx)\n-                    });\n+                    }).collect::<Result<Vec<_>, _>>()?;\n                     let packed = tcx.lookup_packed(def.did);\n                     let layout = if def.is_union() {\n                         let mut un = Union::new(dl, packed);\n-                        un.extend(dl, fields, ty)?;\n+                        un.extend(dl, fields.iter().map(|&f| Ok(f)), ty)?;\n                         UntaggedUnion { variants: un }\n                     } else {\n-                        let mut st = Struct::new(dl, packed);\n-                        st.extend(dl, fields, ty)?;\n+                        let st = Struct::new(dl, &fields, &hints[..],\n+                          kind, ty)?;\n                         let non_zero = Some(def.did) == tcx.lang_items.non_zero();\n                         Univariant { variant: st, non_zero: non_zero }\n                     };\n@@ -1073,7 +1243,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n                     v.fields.iter().map(|field| field.ty(tcx, substs)).collect::<Vec<_>>()\n                 }).collect::<Vec<_>>();\n \n-                if variants.len() == 2 && hint == attr::ReprAny {\n+                if variants.len() == 2 && hints.is_empty() {\n                     // Nullable pointer optimization\n                     for discr in 0..2 {\n                         let other_fields = variants[1 - discr].iter().map(|ty| {\n@@ -1082,9 +1252,11 @@ impl<'a, 'gcx, 'tcx> Layout {\n                         if !Struct::would_be_zero_sized(dl, other_fields)? {\n                             continue;\n                         }\n-                        let path = Struct::non_zero_field_path(infcx,\n-                            variants[discr].iter().cloned())?;\n-                        let mut path = if let Some(p) = path { p } else { continue };\n+                        let paths = Struct::non_zero_field_paths(infcx,\n+                            variants[discr].iter().cloned(),\n+                            None)?;\n+                        let (mut path, mut path_source) = if let Some(p) = paths { p }\n+                          else { continue };\n \n                         // FIXME(eddyb) should take advantage of a newtype.\n                         if path == &[0] && variants[discr].len() == 1 {\n@@ -1101,22 +1273,33 @@ impl<'a, 'gcx, 'tcx> Layout {\n                             });\n                         }\n \n+                        let st = Struct::new(dl,\n+                            &variants[discr].iter().map(|ty| ty.layout(infcx))\n+                              .collect::<Result<Vec<_>, _>>()?,\n+                            &hints[..], StructKind::AlwaysSizedUnivariant, ty)?;\n+\n+                        // We have to fix the last element of path here.\n+                        let mut i = *path.last().unwrap();\n+                        i = st.memory_index[i as usize];\n+                        *path.last_mut().unwrap() = i;\n                         path.push(0); // For GEP through a pointer.\n                         path.reverse();\n-                        let mut st = Struct::new(dl, false);\n-                        st.extend(dl, variants[discr].iter().map(|ty| ty.layout(infcx)), ty)?;\n+                        path_source.push(0);\n+                        path_source.reverse();\n+\n                         return success(StructWrappedNullablePointer {\n                             nndiscr: discr as u64,\n                             nonnull: st,\n-                            discrfield: path\n+                            discrfield: path,\n+                            discrfield_source: path_source\n                         });\n                     }\n                 }\n \n                 // The general case.\n                 let discr_max = (variants.len() - 1) as i64;\n                 assert!(discr_max >= 0);\n-                let (min_ity, _) = Integer::repr_discr(tcx, ty, hint, 0, discr_max);\n+                let (min_ity, _) = Integer::repr_discr(tcx, ty, &hints[..], 0, discr_max);\n \n                 let mut align = dl.aggregate_align;\n                 let mut size = Size::from_bytes(0);\n@@ -1126,24 +1309,26 @@ impl<'a, 'gcx, 'tcx> Layout {\n \n                 // Create the set of structs that represent each variant\n                 // Use the minimum integer type we figured out above\n-                let discr = Some(Scalar { value: Int(min_ity), non_zero: false });\n+                let discr = Scalar { value: Int(min_ity), non_zero: false };\n                 let mut variants = variants.into_iter().map(|fields| {\n-                    let mut found_start = false;\n-                    let fields = fields.into_iter().map(|field| {\n-                        let field = field.layout(infcx)?;\n-                        if !found_start {\n-                            // Find the first field we can't move later\n-                            // to make room for a larger discriminant.\n-                            let field_align = field.align(dl);\n-                            if field.size(dl).bytes() != 0 || field_align.abi() != 1 {\n-                                start_align = start_align.min(field_align);\n-                                found_start = true;\n-                            }\n+                    let mut fields = fields.into_iter().map(|field| {\n+                        field.layout(infcx)\n+                    }).collect::<Result<Vec<_>, _>>()?;\n+                    fields.insert(0, &discr);\n+                    let st = Struct::new(dl,\n+                        &fields,\n+                        &hints[..], StructKind::EnumVariant, ty)?;\n+                    // Find the first field we can't move later\n+                    // to make room for a larger discriminant.\n+                    // It is important to skip the first field.\n+                    for i in st.field_index_by_increasing_offset().skip(1) {\n+                        let field = fields[i];\n+                        let field_align = field.align(dl);\n+                        if field.size(dl).bytes() != 0 || field_align.abi() != 1 {\n+                            start_align = start_align.min(field_align);\n+                            break;\n                         }\n-                        Ok(field)\n-                    });\n-                    let mut st = Struct::new(dl, false);\n-                    st.extend(dl, discr.iter().map(Ok).chain(fields), ty)?;\n+                    }\n                     size = cmp::max(size, st.min_size);\n                     align = align.max(st.align);\n                     Ok(st)\n@@ -1177,11 +1362,12 @@ impl<'a, 'gcx, 'tcx> Layout {\n                     let old_ity_size = Int(min_ity).size(dl);\n                     let new_ity_size = Int(ity).size(dl);\n                     for variant in &mut variants {\n-                        for offset in &mut variant.offsets[1..] {\n-                            if *offset > old_ity_size {\n-                                break;\n+                        for i in variant.offsets.iter_mut() {\n+                            // The first field is the discrimminant, at offset 0.\n+                            // These aren't in order, and we need to skip it.\n+                            if *i <= old_ity_size && *i > Size::from_bytes(0) {\n+                                *i = new_ity_size;\n                             }\n-                            *offset = new_ity_size;\n                         }\n                         // We might be making the struct larger.\n                         if variant.min_size <= old_ity_size {"}, {"sha": "2ab10d0446b2a11f22749cc6044a9ec07bee14d2", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 44, "deletions": 59, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -17,7 +17,7 @@ pub use self::LvaluePreference::*;\n pub use self::fold::TypeFoldable;\n \n use dep_graph::{self, DepNode};\n-use hir::map as ast_map;\n+use hir::{map as ast_map, FreevarMap, TraitMap};\n use middle;\n use hir::def::{Def, CtorKind, ExportMap};\n use hir::def_id::{CrateNum, DefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n@@ -112,6 +112,13 @@ pub struct CrateAnalysis<'tcx> {\n     pub hir_ty_to_ty: NodeMap<Ty<'tcx>>,\n }\n \n+#[derive(Clone)]\n+pub struct Resolutions {\n+    pub freevars: FreevarMap,\n+    pub trait_map: TraitMap,\n+    pub maybe_unused_trait_imports: NodeSet,\n+}\n+\n #[derive(Copy, Clone)]\n pub enum DtorKind {\n     NoDtor,\n@@ -212,63 +219,65 @@ pub enum Visibility {\n     /// Visible everywhere (including in other crates).\n     Public,\n     /// Visible only in the given crate-local module.\n-    Restricted(NodeId),\n+    Restricted(DefId),\n     /// Not visible anywhere in the local crate. This is the visibility of private external items.\n-    PrivateExternal,\n+    Invisible,\n }\n \n-pub trait NodeIdTree {\n-    fn is_descendant_of(&self, node: NodeId, ancestor: NodeId) -> bool;\n+pub trait DefIdTree: Copy {\n+    fn parent(self, id: DefId) -> Option<DefId>;\n }\n \n-impl<'a> NodeIdTree for ast_map::Map<'a> {\n-    fn is_descendant_of(&self, node: NodeId, ancestor: NodeId) -> bool {\n-        let mut node_ancestor = node;\n-        while node_ancestor != ancestor {\n-            let node_ancestor_parent = self.get_module_parent(node_ancestor);\n-            if node_ancestor_parent == node_ancestor {\n-                return false;\n-            }\n-            node_ancestor = node_ancestor_parent;\n-        }\n-        true\n+impl<'a, 'gcx, 'tcx> DefIdTree for TyCtxt<'a, 'gcx, 'tcx> {\n+    fn parent(self, id: DefId) -> Option<DefId> {\n+        self.def_key(id).parent.map(|index| DefId { index: index, ..id })\n     }\n }\n \n impl Visibility {\n     pub fn from_hir(visibility: &hir::Visibility, id: NodeId, tcx: TyCtxt) -> Self {\n         match *visibility {\n             hir::Public => Visibility::Public,\n-            hir::Visibility::Crate => Visibility::Restricted(ast::CRATE_NODE_ID),\n+            hir::Visibility::Crate => Visibility::Restricted(DefId::local(CRATE_DEF_INDEX)),\n             hir::Visibility::Restricted { ref path, .. } => match path.def {\n                 // If there is no resolution, `resolve` will have already reported an error, so\n                 // assume that the visibility is public to avoid reporting more privacy errors.\n                 Def::Err => Visibility::Public,\n-                def => Visibility::Restricted(tcx.map.as_local_node_id(def.def_id()).unwrap()),\n+                def => Visibility::Restricted(def.def_id()),\n             },\n-            hir::Inherited => Visibility::Restricted(tcx.map.get_module_parent(id)),\n+            hir::Inherited => {\n+                Visibility::Restricted(tcx.map.local_def_id(tcx.map.get_module_parent(id)))\n+            }\n         }\n     }\n \n     /// Returns true if an item with this visibility is accessible from the given block.\n-    pub fn is_accessible_from<T: NodeIdTree>(self, block: NodeId, tree: &T) -> bool {\n+    pub fn is_accessible_from<T: DefIdTree>(self, mut module: DefId, tree: T) -> bool {\n         let restriction = match self {\n             // Public items are visible everywhere.\n             Visibility::Public => return true,\n             // Private items from other crates are visible nowhere.\n-            Visibility::PrivateExternal => return false,\n+            Visibility::Invisible => return false,\n             // Restricted items are visible in an arbitrary local module.\n+            Visibility::Restricted(other) if other.krate != module.krate => return false,\n             Visibility::Restricted(module) => module,\n         };\n \n-        tree.is_descendant_of(block, restriction)\n+        while module != restriction {\n+            match tree.parent(module) {\n+                Some(parent) => module = parent,\n+                None => return false,\n+            }\n+        }\n+\n+        true\n     }\n \n     /// Returns true if this visibility is at least as accessible as the given visibility\n-    pub fn is_at_least<T: NodeIdTree>(self, vis: Visibility, tree: &T) -> bool {\n+    pub fn is_at_least<T: DefIdTree>(self, vis: Visibility, tree: T) -> bool {\n         let vis_restriction = match vis {\n             Visibility::Public => return self == Visibility::Public,\n-            Visibility::PrivateExternal => return true,\n+            Visibility::Invisible => return true,\n             Visibility::Restricted(module) => module,\n         };\n \n@@ -1772,7 +1781,7 @@ impl<'a, 'gcx, 'tcx> FieldDef {\n                                   block: Option<NodeId>,\n                                   tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                                   substs: &'tcx Substs<'tcx>) -> bool {\n-        block.map_or(true, |b| self.vis.is_accessible_from(b, &tcx.map)) &&\n+        block.map_or(true, |b| tcx.vis_is_accessible_from(self.vis, b)) &&\n         self.ty(tcx, substs).is_uninhabited_recurse(visited, block, tcx)\n     }\n }\n@@ -2062,7 +2071,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn associated_item(self, def_id: DefId) -> AssociatedItem {\n         self.associated_items.memoize(def_id, || {\n             if !def_id.is_local() {\n-                return self.sess.cstore.associated_item(self.global_tcx(), def_id)\n+                return self.sess.cstore.associated_item(def_id)\n                            .expect(\"missing AssociatedItem in metadata\");\n             }\n \n@@ -2241,40 +2250,13 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// Convert a `DefId` into its fully expanded `DefPath` (every\n     /// `DefId` is really just an interned def-path).\n     ///\n-    /// Note that if `id` is not local to this crate -- or is\n-    /// inlined into this crate -- the result will be a non-local\n-    /// `DefPath`.\n-    ///\n-    /// This function is only safe to use when you are sure that the\n-    /// full def-path is accessible. Examples that are known to be\n-    /// safe are local def-ids or items; see `opt_def_path` for more\n-    /// details.\n+    /// Note that if `id` is not local to this crate, the result will\n+    //  be a non-local `DefPath`.\n     pub fn def_path(self, id: DefId) -> ast_map::DefPath {\n-        self.opt_def_path(id).unwrap_or_else(|| {\n-            bug!(\"could not load def-path for {:?}\", id)\n-        })\n-    }\n-\n-    /// Convert a `DefId` into its fully expanded `DefPath` (every\n-    /// `DefId` is really just an interned def-path).\n-    ///\n-    /// When going across crates, we do not save the full info for\n-    /// every cross-crate def-id, and hence we may not always be able\n-    /// to create a def-path. Therefore, this returns\n-    /// `Option<DefPath>` to cover that possibility. It will always\n-    /// return `Some` for local def-ids, however, as well as for\n-    /// items. The problems arise with \"minor\" def-ids like those\n-    /// associated with a pattern, `impl Trait`, or other internal\n-    /// detail to a fn.\n-    ///\n-    /// Note that if `id` is not local to this crate -- or is\n-    /// inlined into this crate -- the result will be a non-local\n-    /// `DefPath`.\n-    pub fn opt_def_path(self, id: DefId) -> Option<ast_map::DefPath> {\n         if id.is_local() {\n-            Some(self.map.def_path(id))\n+            self.map.def_path(id)\n         } else {\n-            self.sess.cstore.relative_def_path(id)\n+            self.sess.cstore.def_path(id)\n         }\n     }\n \n@@ -2286,6 +2268,10 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n+    pub fn vis_is_accessible_from(self, vis: Visibility, block: NodeId) -> bool {\n+        vis.is_accessible_from(self.map.local_def_id(self.map.get_module_parent(block)), self)\n+    }\n+\n     pub fn item_name(self, id: DefId) -> ast::Name {\n         if let Some(id) = self.map.as_local_node_id(id) {\n             self.map.name(id)\n@@ -2540,8 +2526,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// ID of the impl that the method belongs to. Otherwise, return `None`.\n     pub fn impl_of_method(self, def_id: DefId) -> Option<DefId> {\n         if def_id.krate != LOCAL_CRATE {\n-            return self.sess.cstore.associated_item(self.global_tcx(), def_id)\n-                       .and_then(|item| {\n+            return self.sess.cstore.associated_item(def_id).and_then(|item| {\n                 match item.container {\n                     TraitContainer(_) => None,\n                     ImplContainer(def_id) => Some(def_id),"}, {"sha": "638345608c2f5d9743595101ff8352a506d07d4d", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -543,6 +543,7 @@ pub struct ProjectionTy<'tcx> {\n pub struct BareFnTy<'tcx> {\n     pub unsafety: hir::Unsafety,\n     pub abi: abi::Abi,\n+    /// Signature (inputs and output) of this function type.\n     pub sig: PolyFnSig<'tcx>,\n }\n "}, {"sha": "b4ac6b9d2502ece9030c319723ecd1e76d2603b8", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 16, "deletions": 88, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -24,11 +24,11 @@ use util::nodemap::FxHashMap;\n use middle::lang_items;\n \n use rustc_const_math::{ConstInt, ConstIsize, ConstUsize};\n+use rustc_data_structures::stable_hasher::{StableHasher, StableHasherResult};\n \n use std::cell::RefCell;\n use std::cmp;\n-use std::hash::{Hash, Hasher};\n-use std::collections::hash_map::DefaultHasher;\n+use std::hash::Hash;\n use std::intrinsics;\n use syntax::ast::{self, Name};\n use syntax::attr::{self, SignedInt, UnsignedInt};\n@@ -349,7 +349,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// Creates a hash of the type `Ty` which will be the same no matter what crate\n     /// context it's calculated within. This is used by the `type_id` intrinsic.\n     pub fn type_id_hash(self, ty: Ty<'tcx>) -> u64 {\n-        let mut hasher = TypeIdHasher::new(self, DefaultHasher::default());\n+        let mut hasher = TypeIdHasher::new(self);\n         hasher.visit_ty(ty);\n         hasher.finish()\n     }\n@@ -395,96 +395,26 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n }\n \n-/// When hashing a type this ends up affecting properties like symbol names. We\n-/// want these symbol names to be calculated independent of other factors like\n-/// what architecture you're compiling *from*.\n-///\n-/// The hashing just uses the standard `Hash` trait, but the implementations of\n-/// `Hash` for the `usize` and `isize` types are *not* architecture independent\n-/// (e.g. they has 4 or 8 bytes). As a result we want to avoid `usize` and\n-/// `isize` completely when hashing. To ensure that these don't leak in we use a\n-/// custom hasher implementation here which inflates the size of these to a `u64`\n-/// and `i64`.\n-///\n-/// The same goes for endianess: We always convert multi-byte integers to little\n-/// endian before hashing.\n-#[derive(Debug)]\n-pub struct ArchIndependentHasher<H> {\n-    inner: H,\n-}\n-\n-impl<H> ArchIndependentHasher<H> {\n-    pub fn new(inner: H) -> ArchIndependentHasher<H> {\n-        ArchIndependentHasher { inner: inner }\n-    }\n-\n-    pub fn into_inner(self) -> H {\n-        self.inner\n-    }\n+pub struct TypeIdHasher<'a, 'gcx: 'a+'tcx, 'tcx: 'a, W> {\n+    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    state: StableHasher<W>,\n }\n \n-impl<H: Hasher> Hasher for ArchIndependentHasher<H> {\n-    fn write(&mut self, bytes: &[u8]) {\n-        self.inner.write(bytes)\n-    }\n-\n-    fn finish(&self) -> u64 {\n-        self.inner.finish()\n-    }\n-\n-    fn write_u8(&mut self, i: u8) {\n-        self.inner.write_u8(i)\n-    }\n-    fn write_u16(&mut self, i: u16) {\n-        self.inner.write_u16(i.to_le())\n-    }\n-    fn write_u32(&mut self, i: u32) {\n-        self.inner.write_u32(i.to_le())\n-    }\n-    fn write_u64(&mut self, i: u64) {\n-        self.inner.write_u64(i.to_le())\n-    }\n-    fn write_usize(&mut self, i: usize) {\n-        self.inner.write_u64((i as u64).to_le())\n+impl<'a, 'gcx, 'tcx, W> TypeIdHasher<'a, 'gcx, 'tcx, W>\n+    where W: StableHasherResult\n+{\n+    pub fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Self {\n+        TypeIdHasher { tcx: tcx, state: StableHasher::new() }\n     }\n-    fn write_i8(&mut self, i: i8) {\n-        self.inner.write_i8(i)\n-    }\n-    fn write_i16(&mut self, i: i16) {\n-        self.inner.write_i16(i.to_le())\n-    }\n-    fn write_i32(&mut self, i: i32) {\n-        self.inner.write_i32(i.to_le())\n-    }\n-    fn write_i64(&mut self, i: i64) {\n-        self.inner.write_i64(i.to_le())\n-    }\n-    fn write_isize(&mut self, i: isize) {\n-        self.inner.write_i64((i as i64).to_le())\n-    }\n-}\n-\n-pub struct TypeIdHasher<'a, 'gcx: 'a+'tcx, 'tcx: 'a, H> {\n-    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-    state: ArchIndependentHasher<H>,\n-}\n \n-impl<'a, 'gcx, 'tcx, H: Hasher> TypeIdHasher<'a, 'gcx, 'tcx, H> {\n-    pub fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>, state: H) -> Self {\n-        TypeIdHasher {\n-            tcx: tcx,\n-            state: ArchIndependentHasher::new(state),\n-        }\n+    pub fn finish(self) -> W {\n+        self.state.finish()\n     }\n \n     pub fn hash<T: Hash>(&mut self, x: T) {\n         x.hash(&mut self.state);\n     }\n \n-    pub fn finish(self) -> u64 {\n-        self.state.finish()\n-    }\n-\n     fn hash_discriminant_u8<T>(&mut self, x: &T) {\n         let v = unsafe {\n             intrinsics::discriminant_value(x)\n@@ -504,13 +434,11 @@ impl<'a, 'gcx, 'tcx, H: Hasher> TypeIdHasher<'a, 'gcx, 'tcx, H> {\n     pub fn def_path(&mut self, def_path: &ast_map::DefPath) {\n         def_path.deterministic_hash_to(self.tcx, &mut self.state);\n     }\n-\n-    pub fn into_inner(self) -> H {\n-        self.state.inner\n-    }\n }\n \n-impl<'a, 'gcx, 'tcx, H: Hasher> TypeVisitor<'tcx> for TypeIdHasher<'a, 'gcx, 'tcx, H> {\n+impl<'a, 'gcx, 'tcx, W> TypeVisitor<'tcx> for TypeIdHasher<'a, 'gcx, 'tcx, W>\n+    where W: StableHasherResult\n+{\n     fn visit_ty(&mut self, ty: Ty<'tcx>) -> bool {\n         // Distinguish between the Ty variants uniformly.\n         self.hash_discriminant_u8(&ty.sty);"}, {"sha": "54eead94986cc9b441854d5ccd207bdaa6d27d9a", "filename": "src/librustc_back/target/aarch64_linux_android.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_back%2Ftarget%2Faarch64_linux_android.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_back%2Ftarget%2Faarch64_linux_android.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Faarch64_linux_android.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -10,6 +10,9 @@\n \n use target::{Target, TargetOptions, TargetResult};\n \n+// See https://developer.android.com/ndk/guides/abis.html#arm64-v8a\n+// for target ABI requirements.\n+\n pub fn target() -> TargetResult {\n     let mut base = super::android_base::opts();\n     base.max_atomic_width = Some(128);"}, {"sha": "21a2d4293df77025700e162354fa90aeadb954b2", "filename": "src/librustc_back/target/apple_base.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_back%2Ftarget%2Fapple_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_back%2Ftarget%2Fapple_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fapple_base.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -37,6 +37,7 @@ pub fn opts() -> TargetOptions {\n         function_sections: false,\n         dynamic_linking: true,\n         executables: true,\n+        target_family: Some(\"unix\".to_string()),\n         is_like_osx: true,\n         has_rpath: true,\n         dll_prefix: \"lib\".to_string(),"}, {"sha": "36f409b7948c27ace4ef2e8b6698bff9036ac2f9", "filename": "src/librustc_back/target/armv7_linux_androideabi.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_back%2Ftarget%2Farmv7_linux_androideabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_back%2Ftarget%2Farmv7_linux_androideabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Farmv7_linux_androideabi.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -10,9 +10,12 @@\n \n use target::{Target, TargetOptions, TargetResult};\n \n+// See https://developer.android.com/ndk/guides/abis.html#v7a\n+// for target ABI requirements.\n+\n pub fn target() -> TargetResult {\n     let mut base = super::android_base::opts();\n-    base.features = \"+v7,+thumb2,+vfp3,+d16\".to_string();\n+    base.features = \"+v7,+thumb2,+vfp3,+d16,-neon\".to_string();\n     base.max_atomic_width = Some(64);\n \n     Ok(Target {"}, {"sha": "98a9e343d004426f732233ae3b55e7133cf3ef94", "filename": "src/librustc_back/target/asmjs_unknown_emscripten.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_back%2Ftarget%2Fasmjs_unknown_emscripten.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_back%2Ftarget%2Fasmjs_unknown_emscripten.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fasmjs_unknown_emscripten.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -23,6 +23,7 @@ pub fn target() -> Result<Target, String> {\n         obj_is_bitcode: true,\n         max_atomic_width: Some(32),\n         post_link_args: vec![\"-s\".to_string(), \"ERROR_ON_UNDEFINED_SYMBOLS=1\".to_string()],\n+        target_family: Some(\"unix\".to_string()),\n         .. Default::default()\n     };\n     Ok(Target {"}, {"sha": "62418e68d43415fe020671e30759bcf075d076ac", "filename": "src/librustc_back/target/bitrig_base.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_back%2Ftarget%2Fbitrig_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_back%2Ftarget%2Fbitrig_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fbitrig_base.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -15,6 +15,7 @@ pub fn opts() -> TargetOptions {\n     TargetOptions {\n         dynamic_linking: true,\n         executables: true,\n+        target_family: Some(\"unix\".to_string()),\n         linker_is_gnu: true,\n         has_rpath: true,\n         position_independent_executables: true,"}, {"sha": "dca33e45af7c7ffc656b02609dedf9dc537b4fa5", "filename": "src/librustc_back/target/dragonfly_base.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_back%2Ftarget%2Fdragonfly_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_back%2Ftarget%2Fdragonfly_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fdragonfly_base.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -15,6 +15,7 @@ pub fn opts() -> TargetOptions {\n     TargetOptions {\n         dynamic_linking: true,\n         executables: true,\n+        target_family: Some(\"unix\".to_string()),\n         linker_is_gnu: true,\n         has_rpath: true,\n         pre_link_args: vec!["}, {"sha": "dca33e45af7c7ffc656b02609dedf9dc537b4fa5", "filename": "src/librustc_back/target/freebsd_base.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_back%2Ftarget%2Ffreebsd_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_back%2Ftarget%2Ffreebsd_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Ffreebsd_base.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -15,6 +15,7 @@ pub fn opts() -> TargetOptions {\n     TargetOptions {\n         dynamic_linking: true,\n         executables: true,\n+        target_family: Some(\"unix\".to_string()),\n         linker_is_gnu: true,\n         has_rpath: true,\n         pre_link_args: vec!["}, {"sha": "8c517224201b2fe7b2e44b5a7812055c9a5cbfb0", "filename": "src/librustc_back/target/fuchsia_base.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_back%2Ftarget%2Ffuchsia_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_back%2Ftarget%2Ffuchsia_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Ffuchsia_base.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -15,6 +15,7 @@ pub fn opts() -> TargetOptions {\n     TargetOptions {\n         dynamic_linking: true,\n         executables: true,\n+        target_family: Some(\"unix\".to_string()),\n         linker_is_gnu: true,\n         has_rpath: true,\n         pre_link_args: vec!["}, {"sha": "bfdc9faaa8a736b37addb6b2c67868ca5cf37c63", "filename": "src/librustc_back/target/haiku_base.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_back%2Ftarget%2Fhaiku_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_back%2Ftarget%2Fhaiku_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fhaiku_base.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -17,6 +17,7 @@ pub fn opts() -> TargetOptions {\n         dynamic_linking: true,\n         executables: true,\n         has_rpath: true,\n+        target_family: Some(\"unix\".to_string()),\n         linker_is_gnu: true,\n         .. Default::default()\n     }"}, {"sha": "f8a8f5a3500befb6a1d7a789e7fb2ff078d07421", "filename": "src/librustc_back/target/i686_linux_android.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_back%2Ftarget%2Fi686_linux_android.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_back%2Ftarget%2Fi686_linux_android.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fi686_linux_android.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -10,6 +10,9 @@\n \n use target::{Target, TargetResult};\n \n+// See https://developer.android.com/ndk/guides/abis.html#x86\n+// for target ABI requirements.\n+\n pub fn target() -> TargetResult {\n     let mut base = super::android_base::opts();\n "}, {"sha": "4b2ae9c8e699c1e23ca0f056afff69d02faf1ea1", "filename": "src/librustc_back/target/linux_base.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_back%2Ftarget%2Flinux_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_back%2Ftarget%2Flinux_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Flinux_base.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -15,6 +15,7 @@ pub fn opts() -> TargetOptions {\n     TargetOptions {\n         dynamic_linking: true,\n         executables: true,\n+        target_family: Some(\"unix\".to_string()),\n         linker_is_gnu: true,\n         has_rpath: true,\n         pre_link_args: vec!["}, {"sha": "8c37eb6986a7cd77a6887dcd75eaeaef4482de64", "filename": "src/librustc_back/target/mod.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmod.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -69,6 +69,7 @@ mod windows_base;\n mod windows_msvc_base;\n mod thumb_base;\n mod fuchsia_base;\n+mod redox_base;\n \n pub type TargetResult = Result<Target, String>;\n \n@@ -184,6 +185,8 @@ supported_targets! {\n     (\"aarch64-unknown-fuchsia\", aarch64_unknown_fuchsia),\n     (\"x86_64-unknown-fuchsia\", x86_64_unknown_fuchsia),\n \n+    (\"x86_64-unknown-redox\", x86_64_unknown_redox),\n+\n     (\"i386-apple-ios\", i386_apple_ios),\n     (\"x86_64-apple-ios\", x86_64_apple_ios),\n     (\"aarch64-apple-ios\", aarch64_apple_ios),\n@@ -267,6 +270,9 @@ pub struct TargetOptions {\n     /// user-defined libraries.\n     pub post_link_args: Vec<String>,\n \n+    /// Extra arguments to pass to the external assembler (when used)\n+    pub asm_args: Vec<String>,\n+\n     /// Default CPU to pass to LLVM. Corresponds to `llc -mcpu=$cpu`. Defaults\n     /// to \"generic\".\n     pub cpu: String,\n@@ -394,6 +400,7 @@ impl Default for TargetOptions {\n             ar: option_env!(\"CFG_DEFAULT_AR\").unwrap_or(\"ar\").to_string(),\n             pre_link_args: Vec::new(),\n             post_link_args: Vec::new(),\n+            asm_args: Vec::new(),\n             cpu: \"generic\".to_string(),\n             features: \"\".to_string(),\n             dynamic_linking: false,\n@@ -561,6 +568,7 @@ impl Target {\n         key!(late_link_args, list);\n         key!(post_link_objects, list);\n         key!(post_link_args, list);\n+        key!(asm_args, list);\n         key!(cpu);\n         key!(features);\n         key!(dynamic_linking, bool);\n@@ -723,6 +731,7 @@ impl ToJson for Target {\n         target_option_val!(late_link_args);\n         target_option_val!(post_link_objects);\n         target_option_val!(post_link_args);\n+        target_option_val!(asm_args);\n         target_option_val!(cpu);\n         target_option_val!(features);\n         target_option_val!(dynamic_linking);"}, {"sha": "57179a68afd8e9ccdc79bb1f459296277bca6339", "filename": "src/librustc_back/target/netbsd_base.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_back%2Ftarget%2Fnetbsd_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_back%2Ftarget%2Fnetbsd_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fnetbsd_base.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -15,6 +15,7 @@ pub fn opts() -> TargetOptions {\n     TargetOptions {\n         dynamic_linking: true,\n         executables: true,\n+        target_family: Some(\"unix\".to_string()),\n         linker_is_gnu: true,\n         has_rpath: true,\n         pre_link_args: vec!["}, {"sha": "12b8e8bdc88fd931e776664af40136cacf0afd81", "filename": "src/librustc_back/target/openbsd_base.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_back%2Ftarget%2Fopenbsd_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_back%2Ftarget%2Fopenbsd_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fopenbsd_base.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -15,6 +15,7 @@ pub fn opts() -> TargetOptions {\n     TargetOptions {\n         dynamic_linking: true,\n         executables: true,\n+        target_family: Some(\"unix\".to_string()),\n         linker_is_gnu: true,\n         has_rpath: true,\n         is_like_openbsd: true,"}, {"sha": "1dffff598096b9c8e4b310cff69f452a7a9665e5", "filename": "src/librustc_back/target/redox_base.rs", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_back%2Ftarget%2Fredox_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_back%2Ftarget%2Fredox_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fredox_base.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -0,0 +1,50 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use PanicStrategy;\n+use target::TargetOptions;\n+use std::default::Default;\n+\n+pub fn opts() -> TargetOptions {\n+    TargetOptions {\n+        pre_link_args: vec![\n+            // We want to be able to strip as much executable code as possible\n+            // from the linker command line, and this flag indicates to the\n+            // linker that it can avoid linking in dynamic libraries that don't\n+            // actually satisfy any symbols up to that point (as with many other\n+            // resolutions the linker does). This option only applies to all\n+            // following libraries so we're sure to pass it as one of the first\n+            // arguments.\n+            \"-Wl,--as-needed\".to_string(),\n+\n+            // Always enable NX protection when it is available\n+            \"-Wl,-z,noexecstack\".to_string(),\n+\n+            // Static link\n+            \"-static\".to_string()\n+        ],\n+        late_link_args: vec![\n+            \"-lc\".to_string(),\n+            \"-lm\".to_string()\n+        ],\n+        executables: true,\n+        relocation_model: \"static\".to_string(),\n+        disable_redzone: true,\n+        eliminate_frame_pointer: false,\n+        target_family: None,\n+        linker_is_gnu: true,\n+        no_default_libraries: true,\n+        lib_allocation_crate: \"alloc_system\".to_string(),\n+        exe_allocation_crate: \"alloc_system\".to_string(),\n+        has_elf_tls: true,\n+        panic_strategy: PanicStrategy::Abort,\n+        .. Default::default()\n+    }\n+}"}, {"sha": "41323c9c26ba7290fc0b7216d68a477e17a3d7f5", "filename": "src/librustc_back/target/solaris_base.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_back%2Ftarget%2Fsolaris_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_back%2Ftarget%2Fsolaris_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fsolaris_base.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -16,6 +16,7 @@ pub fn opts() -> TargetOptions {\n         dynamic_linking: true,\n         executables: true,\n         has_rpath: true,\n+        target_family: Some(\"unix\".to_string()),\n         is_like_solaris: true,\n         exe_allocation_crate: super::maybe_jemalloc(),\n "}, {"sha": "fec269074da8bed879f94e795c9be087db0ae019", "filename": "src/librustc_back/target/wasm32_unknown_emscripten.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_back%2Ftarget%2Fwasm32_unknown_emscripten.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_back%2Ftarget%2Fwasm32_unknown_emscripten.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fwasm32_unknown_emscripten.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -26,6 +26,7 @@ pub fn target() -> Result<Target, String> {\n         max_atomic_width: Some(32),\n         post_link_args: vec![\"-s\".to_string(), \"BINARYEN=1\".to_string(),\n                              \"-s\".to_string(), \"ERROR_ON_UNDEFINED_SYMBOLS=1\".to_string()],\n+        target_family: Some(\"unix\".to_string()),\n         .. Default::default()\n     };\n     Ok(Target {"}, {"sha": "db02e142fcc8efac34aca9480845a87696be1cdf", "filename": "src/librustc_back/target/windows_base.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_back%2Ftarget%2Fwindows_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_back%2Ftarget%2Fwindows_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fwindows_base.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -24,6 +24,7 @@ pub fn opts() -> TargetOptions {\n         staticlib_prefix: \"\".to_string(),\n         staticlib_suffix: \".lib\".to_string(),\n         no_default_libraries: true,\n+        target_family: Some(\"windows\".to_string()),\n         is_like_windows: true,\n         allows_weak_linkage: false,\n         pre_link_args: vec!["}, {"sha": "efa215b419d7044fed385b8b176d2f664a6e3bc1", "filename": "src/librustc_back/target/windows_msvc_base.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_back%2Ftarget%2Fwindows_msvc_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_back%2Ftarget%2Fwindows_msvc_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fwindows_msvc_base.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -53,6 +53,7 @@ pub fn opts() -> TargetOptions {\n         exe_suffix: \".exe\".to_string(),\n         staticlib_prefix: \"\".to_string(),\n         staticlib_suffix: \".lib\".to_string(),\n+        target_family: Some(\"windows\".to_string()),\n         is_like_windows: true,\n         is_like_msvc: true,\n         pre_link_args: vec!["}, {"sha": "cecac06b235275a6b18162e7b532c9168ff983c3", "filename": "src/librustc_back/target/x86_64_unknown_redox.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_redox.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_redox.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_redox.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -0,0 +1,30 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use target::{Target, TargetResult};\n+\n+pub fn target() -> TargetResult {\n+    let mut base = super::redox_base::opts();\n+    base.cpu = \"x86-64\".to_string();\n+    base.max_atomic_width = Some(64);\n+    base.pre_link_args.push(\"-m64\".to_string());\n+\n+    Ok(Target {\n+        llvm_target: \"x86_64-unknown-redox\".to_string(),\n+        target_endian: \"little\".to_string(),\n+        target_pointer_width: \"64\".to_string(),\n+        data_layout: \"e-m:e-i64:64-f80:128-n8:16:32:64-S128\".to_string(),\n+        arch: \"x86_64\".to_string(),\n+        target_os: \"redox\".to_string(),\n+        target_env: \"\".to_string(),\n+        target_vendor: \"unknown\".to_string(),\n+        options: base,\n+    })\n+}"}, {"sha": "88e5bae483d73deddeaf807d8162f13e5c5faf24", "filename": "src/librustc_borrowck/borrowck/mir/elaborate_drops.rs", "status": "modified", "additions": 39, "deletions": 38, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -481,54 +481,55 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n                            is_cleanup: bool)\n                            -> Vec<BasicBlock>\n     {\n-        let mut succ = succ;\n         let mut unwind_succ = if is_cleanup {\n             None\n         } else {\n             c.unwind\n         };\n-        let mut update_drop_flag = true;\n+\n+        let mut succ = self.new_block(\n+            c, c.is_cleanup, TerminatorKind::Goto { target: succ }\n+        );\n+\n+        // Always clear the \"master\" drop flag at the bottom of the\n+        // ladder. This is needed because the \"master\" drop flag\n+        // protects the ADT's discriminant, which is invalidated\n+        // after the ADT is dropped.\n+        self.set_drop_flag(\n+            Location { block: succ, statement_index: 0 },\n+            c.path,\n+            DropFlagState::Absent\n+        );\n \n         fields.iter().rev().enumerate().map(|(i, &(ref lv, path))| {\n-            let drop_block = match path {\n-                Some(path) => {\n-                    debug!(\"drop_ladder: for std field {} ({:?})\", i, lv);\n-\n-                    self.elaborated_drop_block(&DropCtxt {\n-                        source_info: c.source_info,\n-                        is_cleanup: is_cleanup,\n-                        init_data: c.init_data,\n-                        lvalue: lv,\n-                        path: path,\n-                        succ: succ,\n-                        unwind: unwind_succ,\n-                    })\n-                }\n-                None => {\n-                    debug!(\"drop_ladder: for rest field {} ({:?})\", i, lv);\n-\n-                    let blk = self.complete_drop(&DropCtxt {\n-                        source_info: c.source_info,\n-                        is_cleanup: is_cleanup,\n-                        init_data: c.init_data,\n-                        lvalue: lv,\n-                        path: c.path,\n-                        succ: succ,\n-                        unwind: unwind_succ,\n-                    }, update_drop_flag);\n-\n-                    // the drop flag has been updated - updating\n-                    // it again would clobber it.\n-                    update_drop_flag = false;\n-\n-                    blk\n-                }\n+            succ = if let Some(path) = path {\n+                debug!(\"drop_ladder: for std field {} ({:?})\", i, lv);\n+\n+                self.elaborated_drop_block(&DropCtxt {\n+                    source_info: c.source_info,\n+                    is_cleanup: is_cleanup,\n+                    init_data: c.init_data,\n+                    lvalue: lv,\n+                    path: path,\n+                    succ: succ,\n+                    unwind: unwind_succ,\n+                })\n+            } else {\n+                debug!(\"drop_ladder: for rest field {} ({:?})\", i, lv);\n+\n+                self.complete_drop(&DropCtxt {\n+                    source_info: c.source_info,\n+                    is_cleanup: is_cleanup,\n+                    init_data: c.init_data,\n+                    lvalue: lv,\n+                    path: c.path,\n+                    succ: succ,\n+                    unwind: unwind_succ,\n+                }, false)\n             };\n \n-            succ = drop_block;\n             unwind_succ = unwind_ladder.as_ref().map(|p| p[i]);\n-\n-            drop_block\n+            succ\n         }).collect()\n     }\n "}, {"sha": "ebe103490110436e6712fbf3b86b52805cf655c8", "filename": "src/librustc_const_eval/_match.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_const_eval%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_const_eval%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2F_match.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -324,7 +324,6 @@ impl Witness {\n                     let v = ctor.variant_for_adt(adt);\n                     let qpath = hir::QPath::Resolved(None, P(hir::Path {\n                         span: DUMMY_SP,\n-                        global: false,\n                         def: Def::Err,\n                         segments: vec![hir::PathSegment::from_name(v.name)].into(),\n                     }));"}, {"sha": "4359581a897f57153df7e6179f8bb9f4ba553548", "filename": "src/librustc_data_structures/base_n.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_data_structures%2Fbase_n.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_data_structures%2Fbase_n.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fbase_n.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -14,6 +14,8 @@\n use std::str;\n \n pub const MAX_BASE: u64 = 64;\n+pub const ALPHANUMERIC_ONLY: u64 = 62;\n+\n const BASE_64: &'static [u8; MAX_BASE as usize] =\n     b\"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ@$\";\n "}, {"sha": "33d71ba86264388ed9e329b41620448d1aa06a8a", "filename": "src/librustc_data_structures/flock.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_data_structures%2Fflock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_data_structures%2Fflock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fflock.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -31,6 +31,7 @@ mod imp {\n     mod os {\n         use libc;\n \n+        #[repr(C)]\n         pub struct flock {\n             pub l_type: libc::c_short,\n             pub l_whence: libc::c_short,\n@@ -53,6 +54,7 @@ mod imp {\n     mod os {\n         use libc;\n \n+        #[repr(C)]\n         pub struct flock {\n             pub l_start: libc::off_t,\n             pub l_len: libc::off_t,\n@@ -76,6 +78,7 @@ mod imp {\n     mod os {\n         use libc;\n \n+        #[repr(C)]\n         pub struct flock {\n             pub l_start: libc::off_t,\n             pub l_len: libc::off_t,\n@@ -98,6 +101,7 @@ mod imp {\n     mod os {\n         use libc;\n \n+        #[repr(C)]\n         pub struct flock {\n             pub l_type: libc::c_short,\n             pub l_whence: libc::c_short,\n@@ -119,6 +123,7 @@ mod imp {\n     mod os {\n         use libc;\n \n+        #[repr(C)]\n         pub struct flock {\n             pub l_start: libc::off_t,\n             pub l_len: libc::off_t,\n@@ -141,6 +146,7 @@ mod imp {\n     mod os {\n         use libc;\n \n+        #[repr(C)]\n         pub struct flock {\n             pub l_type: libc::c_short,\n             pub l_whence: libc::c_short,"}, {"sha": "bdefc39a61a851077c44a2dcda3ce3a8dd2e28b4", "filename": "src/librustc_data_structures/graph/tests.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_data_structures%2Fgraph%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_data_structures%2Fgraph%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fgraph%2Ftests.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -11,8 +11,6 @@\n use graph::*;\n use std::fmt::Debug;\n \n-type TestNode = Node<&'static str>;\n-type TestEdge = Edge<&'static str>;\n type TestGraph = Graph<&'static str, &'static str>;\n \n fn create_graph() -> TestGraph {"}, {"sha": "86f244d65dd42fe16bc8e7f420cf948ed82202e5", "filename": "src/librustc_data_structures/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_data_structures%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_data_structures%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Flib.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -44,6 +44,8 @@ extern crate serialize as rustc_serialize; // used by deriving\n #[cfg(unix)]\n extern crate libc;\n \n+pub use rustc_serialize::hex::ToHex;\n+\n pub mod array_vec;\n pub mod accumulate_vec;\n pub mod small_vec;\n@@ -59,6 +61,7 @@ pub mod indexed_vec;\n pub mod obligation_forest;\n pub mod snapshot_map;\n pub mod snapshot_vec;\n+pub mod stable_hasher;\n pub mod transitive_relation;\n pub mod unify;\n pub mod fnv;"}, {"sha": "ed97c3dde5effae11c16d94ff21fda4995d77f74", "filename": "src/librustc_data_structures/stable_hasher.rs", "status": "added", "additions": 176, "deletions": 0, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_data_structures%2Fstable_hasher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_data_structures%2Fstable_hasher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fstable_hasher.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -0,0 +1,176 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::hash::Hasher;\n+use std::marker::PhantomData;\n+use std::mem;\n+use blake2b::Blake2bHasher;\n+use rustc_serialize::leb128;\n+\n+fn write_unsigned_leb128_to_buf(buf: &mut [u8; 16], value: u64) -> usize {\n+    leb128::write_unsigned_leb128_to(value, |i, v| buf[i] = v)\n+}\n+\n+fn write_signed_leb128_to_buf(buf: &mut [u8; 16], value: i64) -> usize {\n+    leb128::write_signed_leb128_to(value, |i, v| buf[i] = v)\n+}\n+\n+/// When hashing something that ends up affecting properties like symbol names. We\n+/// want these symbol names to be calculated independent of other factors like\n+/// what architecture you're compiling *from*.\n+///\n+/// The hashing just uses the standard `Hash` trait, but the implementations of\n+/// `Hash` for the `usize` and `isize` types are *not* architecture independent\n+/// (e.g. they has 4 or 8 bytes). As a result we want to avoid `usize` and\n+/// `isize` completely when hashing.\n+///\n+/// To do that, we encode all integers to be hashed with some\n+/// arch-independent encoding.\n+///\n+/// At the moment, we pass i8/u8 straight through and encode\n+/// all other integers using leb128.\n+///\n+/// This hasher currently always uses the stable Blake2b algorithm\n+/// and allows for variable output lengths through its type\n+/// parameter.\n+#[derive(Debug)]\n+pub struct StableHasher<W> {\n+    state: Blake2bHasher,\n+    bytes_hashed: u64,\n+    width: PhantomData<W>,\n+}\n+\n+pub trait StableHasherResult: Sized {\n+    fn finish(hasher: StableHasher<Self>) -> Self;\n+}\n+\n+impl<W: StableHasherResult> StableHasher<W> {\n+    pub fn new() -> Self {\n+        StableHasher {\n+            state: Blake2bHasher::new(mem::size_of::<W>(), &[]),\n+            bytes_hashed: 0,\n+            width: PhantomData,\n+        }\n+    }\n+\n+    pub fn finish(self) -> W {\n+        W::finish(self)\n+    }\n+}\n+\n+impl StableHasherResult for [u8; 20] {\n+    fn finish(mut hasher: StableHasher<Self>) -> Self {\n+        let mut result: [u8; 20] = [0; 20];\n+        result.copy_from_slice(hasher.state.finalize());\n+        result\n+    }\n+}\n+\n+impl StableHasherResult for u64 {\n+    fn finish(mut hasher: StableHasher<Self>) -> Self {\n+        hasher.state.finalize();\n+        hasher.state.finish()\n+    }\n+}\n+\n+impl<W> StableHasher<W> {\n+    #[inline]\n+    pub fn finalize(&mut self) -> &[u8] {\n+        self.state.finalize()\n+    }\n+\n+    #[inline]\n+    pub fn bytes_hashed(&self) -> u64 {\n+        self.bytes_hashed\n+    }\n+\n+    #[inline]\n+    fn write_uleb128(&mut self, value: u64) {\n+        let mut buf = [0; 16];\n+        let len = write_unsigned_leb128_to_buf(&mut buf, value);\n+        self.state.write(&buf[..len]);\n+        self.bytes_hashed += len as u64;\n+    }\n+\n+    #[inline]\n+    fn write_ileb128(&mut self, value: i64) {\n+        let mut buf = [0; 16];\n+        let len = write_signed_leb128_to_buf(&mut buf, value);\n+        self.state.write(&buf[..len]);\n+        self.bytes_hashed += len as u64;\n+    }\n+}\n+\n+// For the non-u8 integer cases we leb128 encode them first. Because small\n+// integers dominate, this significantly and cheaply reduces the number of\n+// bytes hashed, which is good because blake2b is expensive.\n+impl<W> Hasher for StableHasher<W> {\n+    fn finish(&self) -> u64 {\n+        panic!(\"use StableHasher::finish instead\");\n+    }\n+\n+    #[inline]\n+    fn write(&mut self, bytes: &[u8]) {\n+        self.state.write(bytes);\n+        self.bytes_hashed += bytes.len() as u64;\n+    }\n+\n+    #[inline]\n+    fn write_u8(&mut self, i: u8) {\n+        self.state.write_u8(i);\n+        self.bytes_hashed += 1;\n+    }\n+\n+    #[inline]\n+    fn write_u16(&mut self, i: u16) {\n+        self.write_uleb128(i as u64);\n+    }\n+\n+    #[inline]\n+    fn write_u32(&mut self, i: u32) {\n+        self.write_uleb128(i as u64);\n+    }\n+\n+    #[inline]\n+    fn write_u64(&mut self, i: u64) {\n+        self.write_uleb128(i);\n+    }\n+\n+    #[inline]\n+    fn write_usize(&mut self, i: usize) {\n+        self.write_uleb128(i as u64);\n+    }\n+\n+    #[inline]\n+    fn write_i8(&mut self, i: i8) {\n+        self.state.write_i8(i);\n+        self.bytes_hashed += 1;\n+    }\n+\n+    #[inline]\n+    fn write_i16(&mut self, i: i16) {\n+        self.write_ileb128(i as i64);\n+    }\n+\n+    #[inline]\n+    fn write_i32(&mut self, i: i32) {\n+        self.write_ileb128(i as i64);\n+    }\n+\n+    #[inline]\n+    fn write_i64(&mut self, i: i64) {\n+        self.write_ileb128(i);\n+    }\n+\n+    #[inline]\n+    fn write_isize(&mut self, i: isize) {\n+        self.write_ileb128(i as i64);\n+    }\n+}"}, {"sha": "8da9a23f4faad2d5b949592641fafe752a91b279", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 9, "deletions": 21, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -8,12 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use rustc::hir;\n-use rustc::hir::{map as hir_map, FreevarMap, TraitMap};\n+use rustc::hir::{self, map as hir_map};\n use rustc::hir::lowering::lower_crate;\n-use rustc_data_structures::blake2b::Blake2bHasher;\n-use rustc_data_structures::fmt_wrap::FmtWrap;\n-use rustc::ty::util::ArchIndependentHasher;\n+use rustc_data_structures::stable_hasher::StableHasher;\n use rustc_mir as mir;\n use rustc::session::{Session, CompileResult, compile_result_from_err_count};\n use rustc::session::config::{self, Input, OutputFilenames, OutputType,\n@@ -22,11 +19,12 @@ use rustc::session::search_paths::PathKind;\n use rustc::lint;\n use rustc::middle::{self, dependency_format, stability, reachable};\n use rustc::middle::privacy::AccessLevels;\n-use rustc::ty::{self, TyCtxt};\n+use rustc::ty::{self, TyCtxt, Resolutions};\n use rustc::util::common::time;\n use rustc::util::nodemap::{NodeSet, NodeMap};\n use rustc_borrowck as borrowck;\n use rustc_incremental::{self, IncrementalHashesMap};\n+use rustc_incremental::ich::Fingerprint;\n use rustc_resolve::{MakeGlobMap, Resolver};\n use rustc_metadata::creader::CrateLoader;\n use rustc_metadata::cstore::CStore;\n@@ -60,13 +58,6 @@ use syntax_ext;\n \n use derive_registrar;\n \n-#[derive(Clone)]\n-pub struct Resolutions {\n-    pub freevars: FreevarMap,\n-    pub trait_map: TraitMap,\n-    pub maybe_unused_trait_imports: NodeSet,\n-}\n-\n pub fn compile_input(sess: &Session,\n                      cstore: &CStore,\n                      input: &Input,\n@@ -601,6 +592,7 @@ pub fn phase_2_configure_and_expand<F>(sess: &Session,\n         }\n     });\n \n+    let whitelisted_legacy_custom_derives = registry.take_whitelisted_custom_derives();\n     let Registry { syntax_exts, early_lint_passes, late_lint_passes, lint_groups,\n                    llvm_passes, attributes, mir_passes, .. } = registry;\n \n@@ -640,6 +632,7 @@ pub fn phase_2_configure_and_expand<F>(sess: &Session,\n     let resolver_arenas = Resolver::arenas();\n     let mut resolver =\n         Resolver::new(sess, &krate, make_glob_map, &mut crate_loader, &resolver_arenas);\n+    resolver.whitelisted_legacy_custom_derives = whitelisted_legacy_custom_derives;\n     syntax_ext::register_builtins(&mut resolver, syntax_exts, sess.features.borrow().quote);\n \n     krate = time(time_passes, \"expansion\", || {\n@@ -865,11 +858,9 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n \n     TyCtxt::create_and_enter(sess,\n                              arenas,\n-                             resolutions.trait_map,\n+                             resolutions,\n                              named_region_map,\n                              hir_map,\n-                             resolutions.freevars,\n-                             resolutions.maybe_unused_trait_imports,\n                              region_map,\n                              lang_items,\n                              index,\n@@ -1274,7 +1265,7 @@ pub fn compute_crate_disambiguator(session: &Session) -> String {\n     // FIXME(mw): It seems that the crate_disambiguator is used everywhere as\n     //            a hex-string instead of raw bytes. We should really use the\n     //            smaller representation.\n-    let mut hasher = ArchIndependentHasher::new(Blake2bHasher::new(128 / 8, &[]));\n+    let mut hasher = StableHasher::<Fingerprint>::new();\n \n     let mut metadata = session.opts.cg.metadata.clone();\n     // We don't want the crate_disambiguator to dependent on the order\n@@ -1292,14 +1283,11 @@ pub fn compute_crate_disambiguator(session: &Session) -> String {\n         hasher.write(s.as_bytes());\n     }\n \n-    let mut hash_state = hasher.into_inner();\n-    let hash_bytes = hash_state.finalize();\n-\n     // If this is an executable, add a special suffix, so that we don't get\n     // symbol conflicts when linking against a library of the same name.\n     let is_exe = session.crate_types.borrow().contains(&config::CrateTypeExecutable);\n \n-    format!(\"{:x}{}\", FmtWrap(hash_bytes), if is_exe { \"-exe\" } else {\"\"})\n+    format!(\"{}{}\", hasher.finish().to_hex(), if is_exe { \"-exe\" } else {\"\"})\n }\n \n pub fn build_output_filenames(input: &Input,"}, {"sha": "74df1e52bde43143a7dab39a42aee28611022fc9", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -15,10 +15,9 @@ pub use self::PpSourceMode::*;\n pub use self::PpMode::*;\n use self::NodesMatchingUII::*;\n \n-use abort_on_err;\n-use driver::{self, Resolutions};\n+use {abort_on_err, driver};\n \n-use rustc::ty::{self, TyCtxt};\n+use rustc::ty::{self, TyCtxt, Resolutions};\n use rustc::cfg;\n use rustc::cfg::graphviz::LabelledCFG;\n use rustc::dep_graph::DepGraph;"}, {"sha": "cbab39c390829422419cbacd3e6bd51320dee7fc", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -138,11 +138,9 @@ fn test_env<F>(source_string: &str,\n     let index = stability::Index::new(&ast_map);\n     TyCtxt::create_and_enter(&sess,\n                              &arenas,\n-                             resolutions.trait_map,\n+                             resolutions,\n                              named_region_map.unwrap(),\n                              ast_map,\n-                             resolutions.freevars,\n-                             resolutions.maybe_unused_trait_imports,\n                              region_map,\n                              lang_items,\n                              index,"}, {"sha": "d7d9c231a91f48ea772b72585da7cd23dcfd316b", "filename": "src/librustc_incremental/calculate_svh/hasher.rs", "status": "removed", "additions": 0, "deletions": 88, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/96c52d4fd86aed6320732a511c04bcbfff7d117f/src%2Flibrustc_incremental%2Fcalculate_svh%2Fhasher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96c52d4fd86aed6320732a511c04bcbfff7d117f/src%2Flibrustc_incremental%2Fcalculate_svh%2Fhasher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh%2Fhasher.rs?ref=96c52d4fd86aed6320732a511c04bcbfff7d117f", "patch": "@@ -1,88 +0,0 @@\n-// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use std::mem;\n-use std::hash::Hasher;\n-use rustc_data_structures::blake2b::Blake2bHasher;\n-use rustc::ty::util::ArchIndependentHasher;\n-use ich::Fingerprint;\n-use rustc_serialize::leb128::write_unsigned_leb128;\n-\n-#[derive(Debug)]\n-pub struct IchHasher {\n-    state: ArchIndependentHasher<Blake2bHasher>,\n-    leb128_helper: Vec<u8>,\n-    bytes_hashed: u64,\n-}\n-\n-impl IchHasher {\n-    pub fn new() -> IchHasher {\n-        let hash_size = mem::size_of::<Fingerprint>();\n-        IchHasher {\n-            state: ArchIndependentHasher::new(Blake2bHasher::new(hash_size, &[])),\n-            leb128_helper: vec![],\n-            bytes_hashed: 0\n-        }\n-    }\n-\n-    pub fn bytes_hashed(&self) -> u64 {\n-        self.bytes_hashed\n-    }\n-\n-    pub fn finish(self) -> Fingerprint {\n-        let mut fingerprint = Fingerprint::zero();\n-        fingerprint.0.copy_from_slice(self.state.into_inner().finalize());\n-        fingerprint\n-    }\n-\n-    #[inline]\n-    fn write_uleb128(&mut self, value: u64) {\n-        let len = write_unsigned_leb128(&mut self.leb128_helper, 0, value);\n-        self.state.write(&self.leb128_helper[0..len]);\n-        self.bytes_hashed += len as u64;\n-    }\n-}\n-\n-// For the non-u8 integer cases we leb128 encode them first. Because small\n-// integers dominate, this significantly and cheaply reduces the number of\n-// bytes hashed, which is good because blake2b is expensive.\n-impl Hasher for IchHasher {\n-    fn finish(&self) -> u64 {\n-        bug!(\"Use other finish() implementation to get the full 128-bit hash.\");\n-    }\n-\n-    #[inline]\n-    fn write(&mut self, bytes: &[u8]) {\n-        self.state.write(bytes);\n-        self.bytes_hashed += bytes.len() as u64;\n-    }\n-\n-    // There is no need to leb128-encode u8 values.\n-\n-    #[inline]\n-    fn write_u16(&mut self, i: u16) {\n-        self.write_uleb128(i as u64);\n-    }\n-\n-    #[inline]\n-    fn write_u32(&mut self, i: u32) {\n-        self.write_uleb128(i as u64);\n-    }\n-\n-    #[inline]\n-    fn write_u64(&mut self, i: u64) {\n-        self.write_uleb128(i);\n-    }\n-\n-    #[inline]\n-    fn write_usize(&mut self, i: usize) {\n-        self.write_uleb128(i as u64);\n-    }\n-}"}, {"sha": "eb31be4a8ade289d58edc0c3c1eff942cee0fb74", "filename": "src/librustc_incremental/calculate_svh/mod.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -36,21 +36,21 @@ use rustc::hir::def_id::{CRATE_DEF_INDEX, DefId};\n use rustc::hir::intravisit as visit;\n use rustc::hir::intravisit::{Visitor, NestedVisitorMap};\n use rustc::ty::TyCtxt;\n+use rustc_data_structures::stable_hasher::StableHasher;\n+use ich::Fingerprint;\n use rustc_data_structures::fx::FxHashMap;\n use rustc::util::common::record_time;\n use rustc::session::config::DebugInfoLevel::NoDebugInfo;\n \n use self::def_path_hash::DefPathHashes;\n use self::svh_visitor::StrictVersionHashVisitor;\n use self::caching_codemap_view::CachingCodemapView;\n-use self::hasher::IchHasher;\n-use ich::Fingerprint;\n-\n \n mod def_path_hash;\n mod svh_visitor;\n mod caching_codemap_view;\n-pub mod hasher;\n+\n+pub type IchHasher = StableHasher<Fingerprint>;\n \n pub struct IncrementalHashesMap {\n     hashes: FxHashMap<DepNode<DefId>, Fingerprint>,\n@@ -244,4 +244,3 @@ impl<'a, 'tcx> Visitor<'tcx> for HashItemsVisitor<'a, 'tcx> {\n         visit::walk_foreign_item(self, item);\n     }\n }\n-"}, {"sha": "ccae5f3b003662a08cca8ac62fe3173bef9259c4", "filename": "src/librustc_incremental/calculate_svh/svh_visitor.rs", "status": "modified", "additions": 44, "deletions": 6, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -28,11 +28,11 @@ use rustc::hir::def_id::DefId;\n use rustc::hir::intravisit as visit;\n use rustc::ty::TyCtxt;\n use rustc_data_structures::fnv;\n-use std::hash::Hash;\n+use std::hash::{Hash, Hasher};\n \n use super::def_path_hash::DefPathHashes;\n use super::caching_codemap_view::CachingCodemapView;\n-use super::hasher::IchHasher;\n+use super::IchHasher;\n \n const IGNORED_ATTRIBUTES: &'static [&'static str] = &[\n     \"cfg\",\n@@ -189,7 +189,6 @@ enum SawAbiComponent<'a> {\n     SawStructField,\n     SawVariant,\n     SawQPath,\n-    SawPath(bool),\n     SawPathSegment,\n     SawPathParameters,\n     SawBlock,\n@@ -265,7 +264,7 @@ enum SawExprComponent<'a> {\n     SawExprPath,\n     SawExprAddrOf(hir::Mutability),\n     SawExprRet,\n-    SawExprInlineAsm(&'a hir::InlineAsm),\n+    SawExprInlineAsm(StableInlineAsm<'a>),\n     SawExprStruct,\n     SawExprRepeat,\n }\n@@ -341,7 +340,7 @@ fn saw_expr<'a>(node: &'a Expr_,\n         ExprBreak(label, _)      => (SawExprBreak(label.map(|l| l.name.as_str())), false),\n         ExprAgain(label)         => (SawExprAgain(label.map(|l| l.name.as_str())), false),\n         ExprRet(..)              => (SawExprRet, false),\n-        ExprInlineAsm(ref a,..)  => (SawExprInlineAsm(a), false),\n+        ExprInlineAsm(ref a,..)  => (SawExprInlineAsm(StableInlineAsm(a)), false),\n         ExprStruct(..)           => (SawExprStruct, false),\n         ExprRepeat(..)           => (SawExprRepeat, false),\n     }\n@@ -492,6 +491,46 @@ enum SawSpanExpnKind {\n     SomeExpansion,\n }\n \n+/// A wrapper that provides a stable Hash implementation.\n+struct StableInlineAsm<'a>(&'a InlineAsm);\n+\n+impl<'a> Hash for StableInlineAsm<'a> {\n+    fn hash<H: Hasher>(&self, state: &mut H) {\n+        let InlineAsm {\n+            asm,\n+            asm_str_style,\n+            ref outputs,\n+            ref inputs,\n+            ref clobbers,\n+            volatile,\n+            alignstack,\n+            dialect,\n+            expn_id: _, // This is used for error reporting\n+        } = *self.0;\n+\n+        asm.as_str().hash(state);\n+        asm_str_style.hash(state);\n+        outputs.len().hash(state);\n+        for output in outputs {\n+            let InlineAsmOutput { constraint, is_rw, is_indirect } = *output;\n+            constraint.as_str().hash(state);\n+            is_rw.hash(state);\n+            is_indirect.hash(state);\n+        }\n+        inputs.len().hash(state);\n+        for input in inputs {\n+            input.as_str().hash(state);\n+        }\n+        clobbers.len().hash(state);\n+        for clobber in clobbers {\n+            clobber.as_str().hash(state);\n+        }\n+        volatile.hash(state);\n+        alignstack.hash(state);\n+        dialect.hash(state);\n+    }\n+}\n+\n macro_rules! hash_attrs {\n     ($visitor:expr, $attrs:expr) => ({\n         let attrs = $attrs;\n@@ -678,7 +717,6 @@ impl<'a, 'hash, 'tcx> visit::Visitor<'tcx> for StrictVersionHashVisitor<'a, 'has\n \n     fn visit_path(&mut self, path: &'tcx Path, _: ast::NodeId) {\n         debug!(\"visit_path: st={:?}\", self.st);\n-        SawPath(path.global).hash(self.st);\n         hash_span!(self, path.span);\n         visit::walk_path(self, path)\n     }"}, {"sha": "d296d8293fb0674010bb00d12ec012fdfaca0588", "filename": "src/librustc_incremental/ich/fingerprint.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_incremental%2Fich%2Ffingerprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_incremental%2Fich%2Ffingerprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fich%2Ffingerprint.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -9,6 +9,8 @@\n // except according to those terms.\n \n use rustc_serialize::{Encodable, Decodable, Encoder, Decoder};\n+use rustc_data_structures::stable_hasher;\n+use rustc_data_structures::ToHex;\n \n const FINGERPRINT_LENGTH: usize = 16;\n \n@@ -44,6 +46,10 @@ impl Fingerprint {\n         ((self.0[6] as u64) << 48) |\n         ((self.0[7] as u64) << 56)\n     }\n+\n+    pub fn to_hex(&self) -> String {\n+        self.0.to_hex()\n+    }\n }\n \n impl Encodable for Fingerprint {\n@@ -79,3 +85,12 @@ impl ::std::fmt::Display for Fingerprint {\n         Ok(())\n     }\n }\n+\n+\n+impl stable_hasher::StableHasherResult for Fingerprint {\n+    fn finish(mut hasher: stable_hasher::StableHasher<Self>) -> Self {\n+        let mut fingerprint = Fingerprint::zero();\n+        fingerprint.0.copy_from_slice(hasher.finalize());\n+        fingerprint\n+    }\n+}"}, {"sha": "ce73b14ef2d027c926393936a1dd00ebe79ac6fd", "filename": "src/librustc_incremental/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_incremental%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_incremental%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Flib.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -48,7 +48,7 @@ pub mod ich;\n pub use assert_dep_graph::assert_dep_graph;\n pub use calculate_svh::compute_incremental_hashes_map;\n pub use calculate_svh::IncrementalHashesMap;\n-pub use calculate_svh::hasher::IchHasher;\n+pub use calculate_svh::IchHasher;\n pub use persist::load_dep_graph;\n pub use persist::save_dep_graph;\n pub use persist::save_trans_partition;"}, {"sha": "799cb6c5e3d8c7d56d334fdea26869126accd844", "filename": "src/librustc_incremental/persist/hash.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_incremental%2Fpersist%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_incremental%2Fpersist%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fhash.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -66,11 +66,6 @@ impl<'a, 'tcx> HashContext<'a, 'tcx> {\n                         def_id,\n                         self.tcx.item_path_str(def_id));\n \n-                assert!(!self.tcx.map.is_inlined_def_id(def_id),\n-                        \"cannot hash HIR for inlined def-id {:?} => {:?}\",\n-                        def_id,\n-                        self.tcx.item_path_str(def_id));\n-\n                 Some(self.incremental_hashes_map[dep_node])\n             }\n "}, {"sha": "f3bbd02dffa3f1d8fc54a329c311391e7da39993", "filename": "src/librustc_incremental/persist/save.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -30,7 +30,7 @@ use super::preds::*;\n use super::fs::*;\n use super::dirty_clean;\n use super::file_format;\n-use calculate_svh::hasher::IchHasher;\n+use calculate_svh::IchHasher;\n \n pub fn save_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                 incremental_hashes_map: &IncrementalHashesMap,"}, {"sha": "1d384741d9660b974ed3e53643229dbdc3581a18", "filename": "src/librustc_lint/bad_style.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_lint%2Fbad_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_lint%2Fbad_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbad_style.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -382,7 +382,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonUpperCaseGlobals {\n     fn check_pat(&mut self, cx: &LateContext, p: &hir::Pat) {\n         // Lint for constants that look like binding identifiers (#7526)\n         if let PatKind::Path(hir::QPath::Resolved(None, ref path)) = p.node {\n-            if !path.global && path.segments.len() == 1 && path.segments[0].parameters.is_empty() {\n+            if path.segments.len() == 1 && path.segments[0].parameters.is_empty() {\n                 if let Def::Const(..) = path.def {\n                     NonUpperCaseGlobals::check_upper_case(cx,\n                                                           \"constant in pattern\","}, {"sha": "a53d43b2a257ae365b390fb7ebce3763319fbe81", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -234,6 +234,10 @@ pub fn register_builtins(store: &mut lint::LintStore, sess: Option<&Session>) {\n             id: LintId::of(LEGACY_DIRECTORY_OWNERSHIP),\n             reference: \"issue #37872 <https://github.com/rust-lang/rust/issues/37872>\",\n         },\n+        FutureIncompatibleInfo {\n+            id: LintId::of(LEGACY_IMPORTS),\n+            reference: \"issue #38260 <https://github.com/rust-lang/rust/issues/38260>\",\n+        },\n         ]);\n \n     // Register renamed and removed lints"}, {"sha": "751c9c3440f66326a06454204416c9cf237f388f", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -750,7 +750,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for VariantSizeDifferences {\n                 if let Layout::General { ref variants, ref size, discr, .. } = *layout {\n                     let discr_size = Primitive::Int(discr).size(&cx.tcx.data_layout).bytes();\n \n-                    debug!(\"enum `{}` is {} bytes large\", t, size.bytes());\n+                    debug!(\"enum `{}` is {} bytes large with layout:\\n{:#?}\",\n+                      t, size.bytes(), layout);\n \n                     let (largest, slargest, largest_index) = enum_definition.variants\n                         .iter()"}, {"sha": "e681a81cf0c3f3665d5df23953c144ee02995146", "filename": "src/librustc_llvm/build.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_llvm%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_llvm%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Fbuild.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -95,7 +95,8 @@ fn main() {\n     let is_crossed = target != host;\n \n     let optional_components =\n-        [\"x86\", \"arm\", \"aarch64\", \"mips\", \"powerpc\", \"pnacl\", \"systemz\", \"jsbackend\", \"msp430\"];\n+        [\"x86\", \"arm\", \"aarch64\", \"mips\", \"powerpc\", \"pnacl\", \"systemz\", \"jsbackend\", \"msp430\",\n+         \"sparc\"];\n \n     // FIXME: surely we don't need all these components, right? Stuff like mcjit\n     //        or interpreter the compiler itself never uses.\n@@ -230,18 +231,25 @@ fn main() {\n         }\n     }\n \n+    // OpenBSD has a particular C++ runtime library name\n+    let stdcppname = if target.contains(\"openbsd\") {\n+        \"estdc++\"\n+    } else {\n+        \"stdc++\"\n+    };\n+\n     // C++ runtime library\n     if !target.contains(\"msvc\") {\n         if let Some(s) = env::var_os(\"LLVM_STATIC_STDCPP\") {\n             assert!(!cxxflags.contains(\"stdlib=libc++\"));\n             let path = PathBuf::from(s);\n             println!(\"cargo:rustc-link-search=native={}\",\n                      path.parent().unwrap().display());\n-            println!(\"cargo:rustc-link-lib=static=stdc++\");\n+            println!(\"cargo:rustc-link-lib=static={}\", stdcppname);\n         } else if cxxflags.contains(\"stdlib=libc++\") {\n             println!(\"cargo:rustc-link-lib=c++\");\n         } else {\n-            println!(\"cargo:rustc-link-lib=stdc++\");\n+            println!(\"cargo:rustc-link-lib={}\", stdcppname);\n         }\n     }\n }"}, {"sha": "f3dbac7ce682eed8078ecd0fab5c9437f3693b93", "filename": "src/librustc_llvm/ffi.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_llvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_llvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Fffi.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -117,6 +117,7 @@ pub enum Attribute {\n     StructRet       = 16,\n     UWTable         = 17,\n     ZExt            = 18,\n+    InReg           = 19,\n }\n \n /// LLVMIntPredicate\n@@ -710,6 +711,7 @@ extern \"C\" {\n \n     // Operations on instructions\n     pub fn LLVMGetInstructionParent(Inst: ValueRef) -> BasicBlockRef;\n+    pub fn LLVMGetFirstBasicBlock(Fn: ValueRef) -> BasicBlockRef;\n     pub fn LLVMGetFirstInstruction(BB: BasicBlockRef) -> ValueRef;\n     pub fn LLVMInstructionEraseFromParent(Inst: ValueRef);\n \n@@ -1417,7 +1419,8 @@ extern \"C\" {\n                                                  Ty: DIType,\n                                                  isLocalToUnit: bool,\n                                                  Val: ValueRef,\n-                                                 Decl: DIDescriptor)\n+                                                 Decl: DIDescriptor,\n+                                                 AlignInBits: u64)\n                                                  -> DIGlobalVariable;\n \n     pub fn LLVMRustDIBuilderCreateVariable(Builder: DIBuilderRef,\n@@ -1429,7 +1432,8 @@ extern \"C\" {\n                                            Ty: DIType,\n                                            AlwaysPreserve: bool,\n                                            Flags: DIFlags,\n-                                           ArgNo: c_uint)\n+                                           ArgNo: c_uint,\n+                                           AlignInBits: u64)\n                                            -> DIVariable;\n \n     pub fn LLVMRustDIBuilderCreateArrayType(Builder: DIBuilderRef,"}, {"sha": "69709f72b8b42e00e20e1e57df37312d4d4601ba", "filename": "src/librustc_llvm/lib.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Flib.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -270,7 +270,8 @@ pub fn mk_section_iter(llof: ObjectFileRef) -> SectionIter {\n /// Safe wrapper around `LLVMGetParam`, because segfaults are no fun.\n pub fn get_param(llfn: ValueRef, index: c_uint) -> ValueRef {\n     unsafe {\n-        assert!(index < LLVMCountParams(llfn));\n+        assert!(index < LLVMCountParams(llfn),\n+            \"out of bounds argument access: {} out of {} arguments\", index, LLVMCountParams(llfn));\n         LLVMGetParam(llfn, index)\n     }\n }\n@@ -370,6 +371,12 @@ pub fn initialize_available_targets() {\n                  LLVMInitializeMSP430Target,\n                  LLVMInitializeMSP430TargetMC,\n                  LLVMInitializeMSP430AsmPrinter);\n+    init_target!(llvm_component = \"sparc\",\n+                 LLVMInitializeSparcTargetInfo,\n+                 LLVMInitializeSparcTarget,\n+                 LLVMInitializeSparcTargetMC,\n+                 LLVMInitializeSparcAsmPrinter,\n+                 LLVMInitializeSparcAsmParser);\n }\n \n pub fn last_error() -> Option<String> {"}, {"sha": "926c44824ce482393083697b4569d9a8dbbeee16", "filename": "src/librustc_metadata/astencode.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_metadata%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_metadata%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fastencode.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -102,8 +102,6 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for SideTableEncodingIdVisitor<'a, 'b, 'tcx> {\n /// ast-map.\n pub fn decode_inlined_item<'a, 'tcx>(cdata: &CrateMetadata,\n                                      tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                     parent_def_path: ast_map::DefPath,\n-                                     parent_did: DefId,\n                                      ast: Ast<'tcx>,\n                                      orig_did: DefId)\n                                      -> &'tcx InlinedItem {\n@@ -120,17 +118,9 @@ pub fn decode_inlined_item<'a, 'tcx>(cdata: &CrateMetadata,\n     let ii = ast.item.decode((cdata, tcx, id_ranges));\n     let item_node_id = tcx.sess.next_node_id();\n     let ii = ast_map::map_decoded_item(&tcx.map,\n-                                       parent_def_path,\n-                                       parent_did,\n                                        ii,\n                                        item_node_id);\n \n-    let inlined_did = tcx.map.local_def_id(item_node_id);\n-    let ty = tcx.item_type(orig_did);\n-    let generics = tcx.item_generics(orig_did);\n-    tcx.item_types.borrow_mut().insert(inlined_did, ty);\n-    tcx.generics.borrow_mut().insert(inlined_did, generics);\n-\n     for (id, entry) in ast.side_tables.decode((cdata, tcx, id_ranges)) {\n         match entry {\n             TableEntry::TypeRelativeDef(def) => {"}, {"sha": "a9af4118c5957f7266fe05bfdf6252fe58192696", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -22,6 +22,7 @@ use rustc_back::PanicStrategy;\n use rustc::session::search_paths::PathKind;\n use rustc::middle;\n use rustc::middle::cstore::{CrateStore, validate_crate_name, ExternCrate};\n+use rustc::util::common::record_time;\n use rustc::util::nodemap::FxHashSet;\n use rustc::middle::cstore::NativeLibrary;\n use rustc::hir::map::Definitions;\n@@ -297,10 +298,14 @@ impl<'a> CrateLoader<'a> {\n \n         let cnum_map = self.resolve_crate_deps(root, &crate_root, &metadata, cnum, span, dep_kind);\n \n+        let def_path_table = record_time(&self.sess.perf_stats.decode_def_path_tables_time, || {\n+            crate_root.def_path_table.decode(&metadata)\n+        });\n+\n         let mut cmeta = cstore::CrateMetadata {\n             name: name,\n             extern_crate: Cell::new(None),\n-            key_map: metadata.load_key_map(crate_root.index),\n+            def_path_table: def_path_table,\n             proc_macros: crate_root.macro_derive_registrar.map(|_| {\n                 self.load_derive_macros(&crate_root, dylib.clone().map(|p| p.0), span)\n             }),"}, {"sha": "7ec847d24cfa3fc73823ce1a427550454ef172ba", "filename": "src/librustc_metadata/cstore.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_metadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_metadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -16,7 +16,7 @@ use schema;\n \n use rustc::dep_graph::DepGraph;\n use rustc::hir::def_id::{CRATE_DEF_INDEX, LOCAL_CRATE, CrateNum, DefIndex, DefId};\n-use rustc::hir::map::DefKey;\n+use rustc::hir::map::definitions::DefPathTable;\n use rustc::hir::svh::Svh;\n use rustc::middle::cstore::{DepKind, ExternCrate};\n use rustc_back::PanicStrategy;\n@@ -78,7 +78,7 @@ pub struct CrateMetadata {\n     /// hashmap, which gives the reverse mapping.  This allows us to\n     /// quickly retrace a `DefPath`, which is needed for incremental\n     /// compilation support.\n-    pub key_map: FxHashMap<DefKey, DefIndex>,\n+    pub def_path_table: DefPathTable,\n \n     pub dep_kind: Cell<DepKind>,\n     pub source: CrateSource,"}, {"sha": "0ac3ffd5cb9ce2a4d6f8a3073bfd0a6df74b60a6", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -22,8 +22,7 @@ use rustc::ty::{self, Ty, TyCtxt};\n use rustc::hir::def_id::{CrateNum, DefId, DefIndex, CRATE_DEF_INDEX, LOCAL_CRATE};\n \n use rustc::dep_graph::DepNode;\n-use rustc::hir::map as hir_map;\n-use rustc::hir::map::DefKey;\n+use rustc::hir::map::{DefKey, DefPath, DisambiguatedDefPathData};\n use rustc::mir::Mir;\n use rustc::util::nodemap::{NodeSet, DefIdMap};\n use rustc_back::PanicStrategy;\n@@ -189,8 +188,7 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         self.get_crate_data(def_id.krate).get_trait_of_item(def_id.index)\n     }\n \n-    fn associated_item<'a>(&self, _tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n-                           -> Option<ty::AssociatedItem>\n+    fn associated_item(&self, def: DefId) -> Option<ty::AssociatedItem>\n     {\n         self.dep_graph.read(DepNode::MetaData(def));\n         self.get_crate_data(def.krate).get_associated_item(def.index)\n@@ -336,18 +334,20 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         self.get_crate_data(cnum).is_no_builtins()\n     }\n \n-    fn def_index_for_def_key(&self,\n-                             cnum: CrateNum,\n-                             def: DefKey)\n-                             -> Option<DefIndex> {\n+    fn retrace_path(&self,\n+                    cnum: CrateNum,\n+                    path: &[DisambiguatedDefPathData])\n+                    -> Option<DefId> {\n         let cdata = self.get_crate_data(cnum);\n-        cdata.key_map.get(&def).cloned()\n+        cdata.def_path_table\n+             .retrace_path(&path)\n+             .map(|index| DefId { krate: cnum, index: index })\n     }\n \n     /// Returns the `DefKey` for a given `DefId`. This indicates the\n     /// parent `DefId` as well as some idea of what kind of data the\n     /// `DefId` refers to.\n-    fn def_key(&self, def: DefId) -> hir_map::DefKey {\n+    fn def_key(&self, def: DefId) -> DefKey {\n         // Note: loading the def-key (or def-path) for a def-id is not\n         // a *read* of its metadata. This is because the def-id is\n         // really just an interned shorthand for a def-path, which is the\n@@ -357,7 +357,7 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         self.get_crate_data(def.krate).def_key(def.index)\n     }\n \n-    fn relative_def_path(&self, def: DefId) -> Option<hir_map::DefPath> {\n+    fn def_path(&self, def: DefId) -> DefPath {\n         // See `Note` above in `def_key()` for why this read is\n         // commented out:\n         //\n@@ -418,8 +418,6 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n             ident: ast::Ident::with_empty_ctxt(name),\n             id: ast::DUMMY_NODE_ID,\n             span: local_span,\n-            imported_from: None, // FIXME\n-            allow_internal_unstable: attr::contains_name(&attrs, \"allow_internal_unstable\"),\n             attrs: attrs,\n             body: body,\n         })"}, {"sha": "400a3ac0e3e0d8e98a0dee65e339955fecf82354", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 53, "deletions": 65, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -12,12 +12,9 @@\n \n use astencode::decode_inlined_item;\n use cstore::{self, CrateMetadata, MetadataBlob, NativeLibrary};\n-use index::Index;\n use schema::*;\n \n-use rustc::hir::map as hir_map;\n-use rustc::hir::map::{DefKey, DefPathData};\n-use rustc::util::nodemap::FxHashMap;\n+use rustc::hir::map::{DefKey, DefPath, DefPathData};\n use rustc::hir;\n use rustc::hir::intravisit::IdRange;\n \n@@ -44,7 +41,7 @@ use rustc_serialize::{Decodable, Decoder, SpecializedDecoder, opaque};\n use syntax::attr;\n use syntax::ast::{self, NodeId};\n use syntax::codemap;\n-use syntax_pos::{self, Span, BytePos, Pos};\n+use syntax_pos::{self, Span, BytePos, Pos, DUMMY_SP};\n \n pub struct DecodeContext<'a, 'tcx: 'a> {\n     opaque: opaque::Decoder<'a>,\n@@ -456,14 +453,6 @@ impl<'a, 'tcx> MetadataBlob {\n         Lazy::with_position(pos).decode(self)\n     }\n \n-    /// Go through each item in the metadata and create a map from that\n-    /// item's def-key to the item's DefIndex.\n-    pub fn load_key_map(&self, index: LazySeq<Index>) -> FxHashMap<DefKey, DefIndex> {\n-        index.iter_enumerated(self.raw_bytes())\n-            .map(|(index, item)| (item.decode(self).def_key.decode(self), index))\n-            .collect()\n-    }\n-\n     pub fn list_crate_metadata(&self, out: &mut io::Write) -> io::Result<()> {\n         write!(out, \"=External Dependencies=\\n\")?;\n         let root = self.get_root();\n@@ -515,7 +504,12 @@ impl<'tcx> EntryKind<'tcx> {\n }\n \n impl<'a, 'tcx> CrateMetadata {\n+    fn is_proc_macro(&self, id: DefIndex) -> bool {\n+        self.proc_macros.is_some() && id != CRATE_DEF_INDEX\n+    }\n+\n     fn maybe_entry(&self, item_id: DefIndex) -> Option<Lazy<Entry<'tcx>>> {\n+        assert!(!self.is_proc_macro(item_id));\n         self.root.index.lookup(self.blob.raw_bytes(), item_id)\n     }\n \n@@ -538,28 +532,26 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    fn item_name(&self, item: &Entry<'tcx>) -> ast::Name {\n-        item.def_key\n-            .decode(self)\n+    fn item_name(&self, item_index: DefIndex) -> ast::Name {\n+        self.def_key(item_index)\n             .disambiguated_data\n             .data\n             .get_opt_name()\n             .expect(\"no name in item_name\")\n     }\n \n     pub fn get_def(&self, index: DefIndex) -> Option<Def> {\n-        if self.proc_macros.is_some() {\n-            Some(match index {\n-                CRATE_DEF_INDEX => Def::Mod(self.local_def_id(index)),\n-                _ => Def::Macro(self.local_def_id(index)),\n-            })\n-        } else {\n-            self.entry(index).kind.to_def(self.local_def_id(index))\n+        match self.is_proc_macro(index) {\n+            true => Some(Def::Macro(self.local_def_id(index))),\n+            false => self.entry(index).kind.to_def(self.local_def_id(index)),\n         }\n     }\n \n     pub fn get_span(&self, index: DefIndex, sess: &Session) -> Span {\n-        self.entry(index).span.decode((self, sess))\n+        match self.is_proc_macro(index) {\n+            true => DUMMY_SP,\n+            false => self.entry(index).span.decode((self, sess)),\n+        }\n     }\n \n     pub fn get_trait_def(&self,\n@@ -574,7 +566,7 @@ impl<'a, 'tcx> CrateMetadata {\n         ty::TraitDef::new(self.local_def_id(item_id),\n                           data.unsafety,\n                           data.paren_sugar,\n-                          self.def_path(item_id).unwrap().deterministic_hash(tcx))\n+                          self.def_path(item_id).deterministic_hash(tcx))\n     }\n \n     fn get_variant(&self,\n@@ -590,13 +582,13 @@ impl<'a, 'tcx> CrateMetadata {\n \n         (ty::VariantDef {\n             did: self.local_def_id(data.struct_ctor.unwrap_or(index)),\n-            name: self.item_name(item),\n+            name: self.item_name(index),\n             fields: item.children.decode(self).map(|index| {\n                 let f = self.entry(index);\n                 ty::FieldDef {\n                     did: self.local_def_id(index),\n-                    name: self.item_name(&f),\n-                    vis: f.visibility\n+                    name: self.item_name(index),\n+                    vis: f.visibility.decode(self)\n                 }\n             }).collect(),\n             disr_val: ConstInt::Infer(data.disr),\n@@ -670,23 +662,23 @@ impl<'a, 'tcx> CrateMetadata {\n     }\n \n     pub fn get_stability(&self, id: DefIndex) -> Option<attr::Stability> {\n-        match self.proc_macros {\n-            Some(_) if id != CRATE_DEF_INDEX => None,\n-            _ => self.entry(id).stability.map(|stab| stab.decode(self)),\n+        match self.is_proc_macro(id) {\n+            true => None,\n+            false => self.entry(id).stability.map(|stab| stab.decode(self)),\n         }\n     }\n \n     pub fn get_deprecation(&self, id: DefIndex) -> Option<attr::Deprecation> {\n-        match self.proc_macros {\n-            Some(_) if id != CRATE_DEF_INDEX => None,\n-            _ => self.entry(id).deprecation.map(|depr| depr.decode(self)),\n+        match self.is_proc_macro(id) {\n+            true => None,\n+            false => self.entry(id).deprecation.map(|depr| depr.decode(self)),\n         }\n     }\n \n     pub fn get_visibility(&self, id: DefIndex) -> ty::Visibility {\n-        match self.proc_macros {\n-            Some(_) => ty::Visibility::Public,\n-            _ => self.entry(id).visibility,\n+        match self.is_proc_macro(id) {\n+            true => ty::Visibility::Public,\n+            false => self.entry(id).visibility.decode(self),\n         }\n     }\n \n@@ -767,7 +759,7 @@ impl<'a, 'tcx> CrateMetadata {\n                             if let Some(def) = self.get_def(child_index) {\n                                 callback(def::Export {\n                                     def: def,\n-                                    name: self.item_name(&self.entry(child_index)),\n+                                    name: self.item_name(child_index),\n                                 });\n                             }\n                         }\n@@ -779,7 +771,7 @@ impl<'a, 'tcx> CrateMetadata {\n                     _ => {}\n                 }\n \n-                let def_key = child.def_key.decode(self);\n+                let def_key = self.def_key(child_index);\n                 if let (Some(def), Some(name)) =\n                     (self.get_def(child_index), def_key.disambiguated_data.data.get_opt_name()) {\n                     callback(def::Export {\n@@ -832,18 +824,17 @@ impl<'a, 'tcx> CrateMetadata {\n                               id: DefIndex)\n                               -> Option<&'tcx InlinedItem> {\n         debug!(\"Looking up item: {:?}\", id);\n+        if self.is_proc_macro(id) { return None; }\n         let item_doc = self.entry(id);\n         let item_did = self.local_def_id(id);\n-        let parent_def_id = self.local_def_id(self.def_key(id).parent.unwrap());\n-        let mut parent_def_path = self.def_path(id).unwrap();\n-        parent_def_path.data.pop();\n         item_doc.ast.map(|ast| {\n             let ast = ast.decode(self);\n-            decode_inlined_item(self, tcx, parent_def_path, parent_def_id, ast, item_did)\n+            decode_inlined_item(self, tcx, ast, item_did)\n         })\n     }\n \n     pub fn is_item_mir_available(&self, id: DefIndex) -> bool {\n+        !self.is_proc_macro(id) &&\n         self.maybe_entry(id).and_then(|item| item.decode(self).mir).is_some()\n     }\n \n@@ -874,13 +865,16 @@ impl<'a, 'tcx> CrateMetadata {\n                               tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                               id: DefIndex)\n                               -> Option<Mir<'tcx>> {\n-        self.entry(id).mir.map(|mir| mir.decode((self, tcx)))\n+        match self.is_proc_macro(id) {\n+            true => None,\n+            false => self.entry(id).mir.map(|mir| mir.decode((self, tcx))),\n+        }\n     }\n \n     pub fn get_associated_item(&self, id: DefIndex) -> Option<ty::AssociatedItem> {\n         let item = self.entry(id);\n         let parent_and_name = || {\n-            let def_key = item.def_key.decode(self);\n+            let def_key = self.def_key(id);\n             (self.local_def_id(def_key.parent.unwrap()),\n              def_key.disambiguated_data.data.get_opt_name().unwrap())\n         };\n@@ -891,7 +885,7 @@ impl<'a, 'tcx> CrateMetadata {\n                 ty::AssociatedItem {\n                     name: name,\n                     kind: ty::AssociatedKind::Const,\n-                    vis: item.visibility,\n+                    vis: item.visibility.decode(self),\n                     defaultness: container.defaultness(),\n                     def_id: self.local_def_id(id),\n                     container: container.with_def_id(parent),\n@@ -904,7 +898,7 @@ impl<'a, 'tcx> CrateMetadata {\n                 ty::AssociatedItem {\n                     name: name,\n                     kind: ty::AssociatedKind::Method,\n-                    vis: item.visibility,\n+                    vis: item.visibility.decode(self),\n                     defaultness: data.container.defaultness(),\n                     def_id: self.local_def_id(id),\n                     container: data.container.with_def_id(parent),\n@@ -916,7 +910,7 @@ impl<'a, 'tcx> CrateMetadata {\n                 ty::AssociatedItem {\n                     name: name,\n                     kind: ty::AssociatedKind::Type,\n-                    vis: item.visibility,\n+                    vis: item.visibility.decode(self),\n                     defaultness: container.defaultness(),\n                     def_id: self.local_def_id(id),\n                     container: container.with_def_id(parent),\n@@ -950,14 +944,14 @@ impl<'a, 'tcx> CrateMetadata {\n     }\n \n     pub fn get_item_attrs(&self, node_id: DefIndex) -> Vec<ast::Attribute> {\n-        if self.proc_macros.is_some() && node_id != CRATE_DEF_INDEX {\n+        if self.is_proc_macro(node_id) {\n             return Vec::new();\n         }\n         // The attributes for a tuple struct are attached to the definition, not the ctor;\n         // we assume that someone passing in a tuple struct ctor is actually wanting to\n         // look at the definition\n         let mut item = self.entry(node_id);\n-        let def_key = item.def_key.decode(self);\n+        let def_key = self.def_key(node_id);\n         if def_key.disambiguated_data.data == DefPathData::StructCtor {\n             item = self.entry(def_key.parent.unwrap());\n         }\n@@ -968,7 +962,7 @@ impl<'a, 'tcx> CrateMetadata {\n         self.entry(id)\n             .children\n             .decode(self)\n-            .map(|index| self.item_name(&self.entry(index)))\n+            .map(|index| self.item_name(index))\n             .collect()\n     }\n \n@@ -1012,6 +1006,7 @@ impl<'a, 'tcx> CrateMetadata {\n         let filter = match filter.map(|def_id| self.reverse_translate_def_id(def_id)) {\n             Some(Some(def_id)) => Some((def_id.krate.as_u32(), def_id.index)),\n             Some(None) => return,\n+            None if self.proc_macros.is_some() => return,\n             None => None,\n         };\n \n@@ -1030,7 +1025,7 @@ impl<'a, 'tcx> CrateMetadata {\n     }\n \n     pub fn get_trait_of_item(&self, id: DefIndex) -> Option<DefId> {\n-        self.entry(id).def_key.decode(self).parent.and_then(|parent_index| {\n+        self.def_key(id).parent.and_then(|parent_index| {\n             match self.entry(parent_index).kind {\n                 EntryKind::Trait(_) => Some(self.local_def_id(parent_index)),\n                 _ => None,\n@@ -1076,7 +1071,7 @@ impl<'a, 'tcx> CrateMetadata {\n     pub fn get_macro(&self, id: DefIndex) -> (ast::Name, MacroDef) {\n         let entry = self.entry(id);\n         match entry.kind {\n-            EntryKind::MacroDef(macro_def) => (self.item_name(&entry), macro_def.decode(self)),\n+            EntryKind::MacroDef(macro_def) => (self.item_name(id), macro_def.decode(self)),\n             _ => bug!(),\n         }\n     }\n@@ -1129,21 +1124,14 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    pub fn def_key(&self, id: DefIndex) -> hir_map::DefKey {\n-        debug!(\"def_key: id={:?}\", id);\n-        self.entry(id).def_key.decode(self)\n+    pub fn def_key(&self, index: DefIndex) -> DefKey {\n+        self.def_path_table.def_key(index)\n     }\n \n-    // Returns the path leading to the thing with this `id`. Note that\n-    // some def-ids don't wind up in the metadata, so `def_path` sometimes\n-    // returns `None`\n-    pub fn def_path(&self, id: DefIndex) -> Option<hir_map::DefPath> {\n+    // Returns the path leading to the thing with this `id`.\n+    pub fn def_path(&self, id: DefIndex) -> DefPath {\n         debug!(\"def_path(id={:?})\", id);\n-        if self.maybe_entry(id).is_some() {\n-            Some(hir_map::DefPath::make(self.cnum, id, |parent| self.def_key(parent)))\n-        } else {\n-            None\n-        }\n+        DefPath::make(self.cnum, id, |parent| self.def_path_table.def_key(parent))\n     }\n \n     /// Imports the codemap from an external crate into the codemap of the crate"}, {"sha": "d3a2b6f1683e228994ae2c66d84836edac885b6e", "filename": "src/librustc_metadata/diagnostics.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_metadata%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_metadata%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdiagnostics.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -57,9 +57,9 @@ An unknown \"kind\" was specified for a link attribute. Erroneous code example:\n \n Please specify a valid \"kind\" value, from one of the following:\n \n- * static\n- * dylib\n- * framework\n+* static\n+* dylib\n+* framework\n \n \"##,\n "}, {"sha": "bc0a64b9a51700a58426fc0608fdfdd61ea852a5", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 24, "deletions": 54, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -16,6 +16,7 @@ use rustc::middle::cstore::{InlinedItemRef, LinkMeta};\n use rustc::middle::cstore::{LinkagePreference, NativeLibrary};\n use rustc::hir::def;\n use rustc::hir::def_id::{CrateNum, CRATE_DEF_INDEX, DefIndex, DefId};\n+use rustc::hir::map::definitions::DefPathTable;\n use rustc::middle::dependency_format::Linkage;\n use rustc::middle::lang_items;\n use rustc::mir;\n@@ -233,13 +234,6 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         Ok(())\n     }\n \n-    /// For every DefId that we create a metadata item for, we include a\n-    /// serialized copy of its DefKey, which allows us to recreate a path.\n-    fn encode_def_key(&mut self, def_id: DefId) -> Lazy<hir::map::DefKey> {\n-        let tcx = self.tcx;\n-        self.lazy(&tcx.map.def_key(def_id))\n-    }\n-\n     fn encode_item_variances(&mut self, def_id: DefId) -> LazySeq<ty::Variance> {\n         let tcx = self.tcx;\n         self.lazy_seq(tcx.item_variances(def_id).iter().cloned())\n@@ -274,9 +268,8 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n         Entry {\n             kind: EntryKind::Variant(self.lazy(&data)),\n-            visibility: enum_vis.simplify(),\n+            visibility: self.lazy(&ty::Visibility::from_hir(enum_vis, enum_id, tcx)),\n             span: self.lazy(&tcx.def_span(def_id)),\n-            def_key: self.encode_def_key(def_id),\n             attributes: self.encode_attributes(&tcx.get_attrs(def_id)),\n             children: self.lazy_seq(variant.fields.iter().map(|f| {\n                 assert!(f.did.is_local());\n@@ -313,9 +306,8 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n         Entry {\n             kind: EntryKind::Mod(self.lazy(&data)),\n-            visibility: vis.simplify(),\n+            visibility: self.lazy(&ty::Visibility::from_hir(vis, id, tcx)),\n             span: self.lazy(&md.inner),\n-            def_key: self.encode_def_key(def_id),\n             attributes: self.encode_attributes(attrs),\n             children: self.lazy_seq(md.item_ids.iter().map(|item_id| {\n                 tcx.map.local_def_id(item_id.id).index\n@@ -335,30 +327,6 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n     }\n }\n \n-trait Visibility {\n-    fn simplify(&self) -> ty::Visibility;\n-}\n-\n-impl Visibility for hir::Visibility {\n-    fn simplify(&self) -> ty::Visibility {\n-        if *self == hir::Public {\n-            ty::Visibility::Public\n-        } else {\n-            ty::Visibility::PrivateExternal\n-        }\n-    }\n-}\n-\n-impl Visibility for ty::Visibility {\n-    fn simplify(&self) -> ty::Visibility {\n-        if *self == ty::Visibility::Public {\n-            ty::Visibility::Public\n-        } else {\n-            ty::Visibility::PrivateExternal\n-        }\n-    }\n-}\n-\n impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n     fn encode_fields(&mut self, adt_def_id: DefId) {\n         let def = self.tcx.lookup_adt_def(adt_def_id);\n@@ -394,9 +362,8 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n         Entry {\n             kind: EntryKind::Field,\n-            visibility: field.vis.simplify(),\n+            visibility: self.lazy(&field.vis),\n             span: self.lazy(&tcx.def_span(def_id)),\n-            def_key: self.encode_def_key(def_id),\n             attributes: self.encode_attributes(&variant_data.fields()[field_index].attrs),\n             children: LazySeq::empty(),\n             stability: self.encode_stability(def_id),\n@@ -428,9 +395,8 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n         Entry {\n             kind: EntryKind::Struct(self.lazy(&data)),\n-            visibility: struct_vis.simplify(),\n+            visibility: self.lazy(&ty::Visibility::from_hir(struct_vis, struct_id, tcx)),\n             span: self.lazy(&tcx.def_span(def_id)),\n-            def_key: self.encode_def_key(def_id),\n             attributes: LazySeq::empty(),\n             children: LazySeq::empty(),\n             stability: self.encode_stability(def_id),\n@@ -495,9 +461,8 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n         Entry {\n             kind: kind,\n-            visibility: trait_item.vis.simplify(),\n+            visibility: self.lazy(&trait_item.vis),\n             span: self.lazy(&ast_item.span),\n-            def_key: self.encode_def_key(def_id),\n             attributes: self.encode_attributes(&ast_item.attrs),\n             children: LazySeq::empty(),\n             stability: self.encode_stability(def_id),\n@@ -585,9 +550,8 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n         Entry {\n             kind: kind,\n-            visibility: impl_item.vis.simplify(),\n+            visibility: self.lazy(&impl_item.vis),\n             span: self.lazy(&ast_item.span),\n-            def_key: self.encode_def_key(def_id),\n             attributes: self.encode_attributes(&ast_item.attrs),\n             children: LazySeq::empty(),\n             stability: self.encode_stability(def_id),\n@@ -748,9 +712,8 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n         Entry {\n             kind: kind,\n-            visibility: item.vis.simplify(),\n+            visibility: self.lazy(&ty::Visibility::from_hir(&item.vis, item.id, tcx)),\n             span: self.lazy(&item.span),\n-            def_key: self.encode_def_key(def_id),\n             attributes: self.encode_attributes(&item.attrs),\n             children: match item.node {\n                 hir::ItemForeignMod(ref fm) => {\n@@ -858,14 +821,12 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n     /// Serialize the text of exported macros\n     fn encode_info_for_macro_def(&mut self, macro_def: &hir::MacroDef) -> Entry<'tcx> {\n-        let def_id = self.tcx.map.local_def_id(macro_def.id);\n         Entry {\n             kind: EntryKind::MacroDef(self.lazy(&MacroDef {\n                 body: ::syntax::print::pprust::tts_to_string(&macro_def.body)\n             })),\n-            visibility: ty::Visibility::Public,\n+            visibility: self.lazy(&ty::Visibility::Public),\n             span: self.lazy(&macro_def.span),\n-            def_key: self.encode_def_key(def_id),\n \n             attributes: self.encode_attributes(&macro_def.attrs),\n             children: LazySeq::empty(),\n@@ -965,9 +926,8 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n         Entry {\n             kind: kind,\n-            visibility: nitem.vis.simplify(),\n+            visibility: self.lazy(&ty::Visibility::from_hir(&nitem.vis, nitem.id, tcx)),\n             span: self.lazy(&nitem.span),\n-            def_key: self.encode_def_key(def_id),\n             attributes: self.encode_attributes(&nitem.attrs),\n             children: LazySeq::empty(),\n             stability: self.encode_stability(def_id),\n@@ -1048,9 +1008,8 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         let tcx = self.tcx;\n         Entry {\n             kind: EntryKind::Type,\n-            visibility: ty::Visibility::Public,\n+            visibility: self.lazy(&ty::Visibility::Public),\n             span: self.lazy(&tcx.def_span(def_id)),\n-            def_key: self.encode_def_key(def_id),\n             attributes: LazySeq::empty(),\n             children: LazySeq::empty(),\n             stability: None,\n@@ -1077,9 +1036,8 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n         Entry {\n             kind: EntryKind::Closure(self.lazy(&data)),\n-            visibility: ty::Visibility::Public,\n+            visibility: self.lazy(&ty::Visibility::Public),\n             span: self.lazy(&tcx.def_span(def_id)),\n-            def_key: self.encode_def_key(def_id),\n             attributes: self.encode_attributes(&tcx.get_attrs(def_id)),\n             children: LazySeq::empty(),\n             stability: None,\n@@ -1179,6 +1137,11 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             })\n             .map(|filemap| &**filemap))\n     }\n+\n+    fn encode_def_path_table(&mut self) -> Lazy<DefPathTable> {\n+        let definitions = self.tcx.map.definitions();\n+        self.lazy(definitions.def_path_table())\n+    }\n }\n \n struct ImplVisitor<'a, 'tcx: 'a> {\n@@ -1276,6 +1239,11 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         let codemap = self.encode_codemap();\n         let codemap_bytes = self.position() - i;\n \n+        // Encode DefPathTable\n+        i = self.position();\n+        let def_path_table = self.encode_def_path_table();\n+        let def_path_table_bytes = self.position() - i;\n+\n         // Encode the def IDs of impls, for coherence checking.\n         i = self.position();\n         let impls = self.encode_impls();\n@@ -1321,6 +1289,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             lang_items_missing: lang_items_missing,\n             native_libraries: native_libraries,\n             codemap: codemap,\n+            def_path_table: def_path_table,\n             impls: impls,\n             exported_symbols: exported_symbols,\n             index: index,\n@@ -1343,6 +1312,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             println!(\"         codemap bytes: {}\", codemap_bytes);\n             println!(\"            impl bytes: {}\", impl_bytes);\n             println!(\"    exp. symbols bytes: {}\", exported_symbols_bytes);\n+            println!(\"  def-path table bytes: {}\", def_path_table_bytes);\n             println!(\"            item bytes: {}\", item_bytes);\n             println!(\"           index bytes: {}\", index_bytes);\n             println!(\"            zero bytes: {}\", zero_bytes);"}, {"sha": "5b52b268849d3d6c2c080806531c62cdf6ed5d8b", "filename": "src/librustc_metadata/index.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_metadata%2Findex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_metadata%2Findex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Findex.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -70,7 +70,7 @@ impl<'tcx> LazySeq<Index> {\n                index,\n                words.len());\n \n-        let position = u32::from_le(words[index]);\n+        let position = u32::from_le(words[index].get());\n         if position == u32::MAX {\n             debug!(\"Index::lookup: position=u32::MAX\");\n             None\n@@ -84,7 +84,7 @@ impl<'tcx> LazySeq<Index> {\n                                bytes: &'a [u8])\n                                -> impl Iterator<Item = (DefIndex, Lazy<Entry<'tcx>>)> + 'a {\n         let words = &bytes_to_words(&bytes[self.position..])[..self.len];\n-        words.iter().enumerate().filter_map(|(index, &position)| {\n+        words.iter().map(|word| word.get()).enumerate().filter_map(|(index, position)| {\n             if position == u32::MAX {\n                 None\n             } else {\n@@ -95,8 +95,16 @@ impl<'tcx> LazySeq<Index> {\n     }\n }\n \n-fn bytes_to_words(b: &[u8]) -> &[u32] {\n-    unsafe { slice::from_raw_parts(b.as_ptr() as *const u32, b.len() / 4) }\n+#[repr(packed)]\n+#[derive(Copy, Clone)]\n+struct Unaligned<T>(T);\n+\n+impl<T> Unaligned<T> {\n+    fn get(self) -> T { self.0 }\n+}\n+\n+fn bytes_to_words(b: &[u8]) -> &[Unaligned<u32>] {\n+    unsafe { slice::from_raw_parts(b.as_ptr() as *const Unaligned<u32>, b.len() / 4) }\n }\n \n fn words_to_bytes(w: &[u32]) -> &[u8] {"}, {"sha": "2bd5a9ea59d04274aeb723bc9d5dac88da80e421", "filename": "src/librustc_metadata/schema.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_metadata%2Fschema.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_metadata%2Fschema.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fschema.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -179,6 +179,7 @@ pub struct CrateRoot {\n     pub lang_items_missing: LazySeq<lang_items::LangItem>,\n     pub native_libraries: LazySeq<NativeLibrary>,\n     pub codemap: LazySeq<syntax_pos::FileMap>,\n+    pub def_path_table: Lazy<hir::map::definitions::DefPathTable>,\n     pub impls: LazySeq<TraitImpls>,\n     pub exported_symbols: LazySeq<DefIndex>,\n     pub index: LazySeq<index::Index>,\n@@ -200,9 +201,8 @@ pub struct TraitImpls {\n #[derive(RustcEncodable, RustcDecodable)]\n pub struct Entry<'tcx> {\n     pub kind: EntryKind<'tcx>,\n-    pub visibility: ty::Visibility,\n+    pub visibility: Lazy<ty::Visibility>,\n     pub span: Lazy<Span>,\n-    pub def_key: Lazy<hir::map::DefKey>,\n     pub attributes: LazySeq<ast::Attribute>,\n     pub children: LazySeq<DefIndex>,\n     pub stability: Option<Lazy<attr::Stability>>,"}, {"sha": "b355c8f2c4c6f57be318a2143a50e7cb61c31220", "filename": "src/librustc_mir/hair/cx/block.rs", "status": "modified", "additions": 30, "deletions": 25, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -26,47 +26,52 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Block {\n             extent: cx.tcx.region_maps.node_extent(self.id),\n             span: self.span,\n             stmts: stmts,\n-            expr: self.expr.to_ref()\n+            expr: self.expr.to_ref(),\n         }\n     }\n }\n \n fn mirror_stmts<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                 block_id: ast::NodeId,\n                                 stmts: &'tcx [hir::Stmt])\n-                                -> Vec<StmtRef<'tcx>>\n-{\n+                                -> Vec<StmtRef<'tcx>> {\n     let mut result = vec![];\n     for (index, stmt) in stmts.iter().enumerate() {\n         match stmt.node {\n-            hir::StmtExpr(ref expr, id) | hir::StmtSemi(ref expr, id) =>\n+            hir::StmtExpr(ref expr, id) |\n+            hir::StmtSemi(ref expr, id) => {\n                 result.push(StmtRef::Mirror(Box::new(Stmt {\n                     span: stmt.span,\n                     kind: StmtKind::Expr {\n                         scope: cx.tcx.region_maps.node_extent(id),\n-                        expr: expr.to_ref()\n+                        expr: expr.to_ref(),\n+                    },\n+                })))\n+            }\n+            hir::StmtDecl(ref decl, id) => {\n+                match decl.node {\n+                    hir::DeclItem(..) => {\n+                        // ignore for purposes of the MIR\n                     }\n-                }))),\n-            hir::StmtDecl(ref decl, id) => match decl.node {\n-                hir::DeclItem(..) => { /* ignore for purposes of the MIR */ }\n-                hir::DeclLocal(ref local) => {\n-                    let remainder_extent = CodeExtentData::Remainder(BlockRemainder {\n-                        block: block_id,\n-                        first_statement_index: index as u32,\n-                    });\n-                    let remainder_extent =\n-                        cx.tcx.region_maps.lookup_code_extent(remainder_extent);\n+                    hir::DeclLocal(ref local) => {\n+                        let remainder_extent = CodeExtentData::Remainder(BlockRemainder {\n+                            block: block_id,\n+                            first_statement_index: index as u32,\n+                        });\n+                        let remainder_extent =\n+                            cx.tcx.region_maps.lookup_code_extent(remainder_extent);\n \n-                    let pattern = Pattern::from_hir(cx.tcx, &local.pat);\n-                    result.push(StmtRef::Mirror(Box::new(Stmt {\n-                        span: stmt.span,\n-                        kind: StmtKind::Let {\n-                            remainder_scope: remainder_extent,\n-                            init_scope: cx.tcx.region_maps.node_extent(id),\n-                            pattern: pattern,\n-                            initializer: local.init.to_ref(),\n-                        },\n-                    })));\n+                        let pattern = Pattern::from_hir(cx.tcx, &local.pat);\n+                        result.push(StmtRef::Mirror(Box::new(Stmt {\n+                            span: stmt.span,\n+                            kind: StmtKind::Let {\n+                                remainder_scope: remainder_extent,\n+                                init_scope: cx.tcx.region_maps.node_extent(id),\n+                                pattern: pattern,\n+                                initializer: local.init.to_ref(),\n+                            },\n+                        })));\n+                    }\n                 }\n             }\n         }"}, {"sha": "d579cdb042fb3f3b7d4075beacff0eef321d121b", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 307, "deletions": 258, "changes": 565, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -36,7 +36,8 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n         let adj = cx.tcx.tables().adjustments.get(&self.id).cloned();\n \n         debug!(\"make_mirror: unadjusted-expr={:?} applying adjustments={:?}\",\n-               expr, adj);\n+               expr,\n+               adj);\n \n         // Now apply adjustments, if any.\n         match adj.map(|adj| (adj.kind, adj.target)) {\n@@ -78,41 +79,44 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n                 for i in 0..autoderefs {\n                     let i = i as u32;\n                     let adjusted_ty =\n-                        expr.ty.adjust_for_autoderef(\n-                            cx.tcx,\n-                            self.id,\n-                            self.span,\n-                            i,\n-                            |mc| cx.tcx.tables().method_map.get(&mc).map(|m| m.ty));\n-                    debug!(\"make_mirror: autoderef #{}, adjusted_ty={:?}\", i, adjusted_ty);\n+                        expr.ty.adjust_for_autoderef(cx.tcx, self.id, self.span, i, |mc| {\n+                            cx.tcx.tables().method_map.get(&mc).map(|m| m.ty)\n+                        });\n+                    debug!(\"make_mirror: autoderef #{}, adjusted_ty={:?}\",\n+                           i,\n+                           adjusted_ty);\n                     let method_key = ty::MethodCall::autoderef(self.id, i);\n-                    let meth_ty =\n-                        cx.tcx.tables().method_map.get(&method_key).map(|m| m.ty);\n+                    let meth_ty = cx.tcx.tables().method_map.get(&method_key).map(|m| m.ty);\n                     let kind = if let Some(meth_ty) = meth_ty {\n                         debug!(\"make_mirror: overloaded autoderef (meth_ty={:?})\", meth_ty);\n \n                         let ref_ty = cx.tcx.no_late_bound_regions(&meth_ty.fn_ret());\n                         let (region, mutbl) = match ref_ty {\n-                            Some(&ty::TyS {\n-                                sty: ty::TyRef(region, mt), ..\n-                            }) => (region, mt.mutbl),\n-                            _ => span_bug!(expr.span, \"autoderef returned bad type\")\n+                            Some(&ty::TyS { sty: ty::TyRef(region, mt), .. }) => (region, mt.mutbl),\n+                            _ => span_bug!(expr.span, \"autoderef returned bad type\"),\n                         };\n \n                         expr = Expr {\n                             temp_lifetime: temp_lifetime,\n-                            ty: cx.tcx.mk_ref(\n-                                region, ty::TypeAndMut { ty: expr.ty, mutbl: mutbl }),\n+                            ty: cx.tcx.mk_ref(region,\n+                                              ty::TypeAndMut {\n+                                                  ty: expr.ty,\n+                                                  mutbl: mutbl,\n+                                              }),\n                             span: expr.span,\n                             kind: ExprKind::Borrow {\n                                 region: region,\n                                 borrow_kind: to_borrow_kind(mutbl),\n-                                arg: expr.to_ref()\n-                            }\n+                                arg: expr.to_ref(),\n+                            },\n                         };\n \n-                        overloaded_lvalue(cx, self, method_key,\n-                                          PassArgs::ByRef, expr.to_ref(), vec![])\n+                        overloaded_lvalue(cx,\n+                                          self,\n+                                          method_key,\n+                                          PassArgs::ByRef,\n+                                          expr.to_ref(),\n+                                          vec![])\n                     } else {\n                         debug!(\"make_mirror: built-in autoderef\");\n                         ExprKind::Deref { arg: expr.to_ref() }\n@@ -148,7 +152,11 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n                             let region = cx.tcx.mk_region(region);\n                             expr = Expr {\n                                 temp_lifetime: temp_lifetime,\n-                                ty: cx.tcx.mk_ref(region, ty::TypeAndMut { ty: expr.ty, mutbl: m }),\n+                                ty: cx.tcx.mk_ref(region,\n+                                                  ty::TypeAndMut {\n+                                                      ty: expr.ty,\n+                                                      mutbl: m,\n+                                                  }),\n                                 span: self.span,\n                                 kind: ExprKind::Borrow {\n                                     region: region,\n@@ -240,57 +248,62 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n \n                 let sig = match method.ty.sty {\n                     ty::TyFnDef(.., fn_ty) => &fn_ty.sig,\n-                    _ => span_bug!(expr.span, \"type of method is not an fn\")\n+                    _ => span_bug!(expr.span, \"type of method is not an fn\"),\n                 };\n \n-                let sig = cx.tcx.no_late_bound_regions(sig).unwrap_or_else(|| {\n-                    span_bug!(expr.span, \"method call has late-bound regions\")\n-                });\n+                let sig = cx.tcx\n+                    .no_late_bound_regions(sig)\n+                    .unwrap_or_else(|| span_bug!(expr.span, \"method call has late-bound regions\"));\n \n                 assert_eq!(sig.inputs().len(), 2);\n \n                 let tupled_args = Expr {\n                     ty: sig.inputs()[1],\n                     temp_lifetime: temp_lifetime,\n                     span: expr.span,\n-                    kind: ExprKind::Tuple {\n-                        fields: args.iter().map(ToRef::to_ref).collect()\n-                    }\n+                    kind: ExprKind::Tuple { fields: args.iter().map(ToRef::to_ref).collect() },\n                 };\n \n                 ExprKind::Call {\n                     ty: method.ty,\n                     fun: method.to_ref(),\n-                    args: vec![fun.to_ref(), tupled_args.to_ref()]\n+                    args: vec![fun.to_ref(), tupled_args.to_ref()],\n                 }\n             } else {\n                 let adt_data = if let hir::ExprPath(hir::QPath::Resolved(_, ref path)) = fun.node {\n                     // Tuple-like ADTs are represented as ExprCall. We convert them here.\n-                    expr_ty.ty_adt_def().and_then(|adt_def|{\n+                    expr_ty.ty_adt_def().and_then(|adt_def| {\n                         match path.def {\n                             Def::VariantCtor(variant_id, CtorKind::Fn) => {\n                                 Some((adt_def, adt_def.variant_index_with_id(variant_id)))\n-                            },\n-                            Def::StructCtor(_, CtorKind::Fn) => {\n-                                Some((adt_def, 0))\n-                            },\n-                            _ => None\n+                            }\n+                            Def::StructCtor(_, CtorKind::Fn) => Some((adt_def, 0)),\n+                            _ => None,\n                         }\n                     })\n-                } else { None };\n+                } else {\n+                    None\n+                };\n                 if let Some((adt_def, index)) = adt_data {\n-                    let substs = cx.tcx.tables().node_id_item_substs(fun.id)\n+                    let substs = cx.tcx\n+                        .tables()\n+                        .node_id_item_substs(fun.id)\n                         .unwrap_or_else(|| cx.tcx.intern_substs(&[]));\n-                    let field_refs = args.iter().enumerate().map(|(idx, e)| FieldExprRef {\n-                        name: Field::new(idx),\n-                        expr: e.to_ref()\n-                    }).collect();\n+                    let field_refs = args.iter()\n+                        .enumerate()\n+                        .map(|(idx, e)| {\n+                            FieldExprRef {\n+                                name: Field::new(idx),\n+                                expr: e.to_ref(),\n+                            }\n+                        })\n+                        .collect();\n                     ExprKind::Adt {\n                         adt_def: adt_def,\n                         substs: substs,\n                         variant_index: index,\n                         fields: field_refs,\n-                        base: None\n+                        base: None,\n                     }\n                 } else {\n                     ExprKind::Call {\n@@ -314,9 +327,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             }\n         }\n \n-        hir::ExprBlock(ref blk) => {\n-            ExprKind::Block { body: &blk }\n-        }\n+        hir::ExprBlock(ref blk) => ExprKind::Block { body: &blk },\n \n         hir::ExprAssign(ref lhs, ref rhs) => {\n             ExprKind::Assign {\n@@ -332,8 +343,12 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                 } else {\n                     PassArgs::ByRef\n                 };\n-                overloaded_operator(cx, expr, ty::MethodCall::expr(expr.id),\n-                                    pass_args, lhs.to_ref(), vec![rhs])\n+                overloaded_operator(cx,\n+                                    expr,\n+                                    ty::MethodCall::expr(expr.id),\n+                                    pass_args,\n+                                    lhs.to_ref(),\n+                                    vec![rhs])\n             } else {\n                 ExprKind::AssignOp {\n                     op: bin_op(op.node),\n@@ -343,9 +358,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             }\n         }\n \n-        hir::ExprLit(..) => ExprKind::Literal {\n-            literal: cx.const_eval_literal(expr)\n-        },\n+        hir::ExprLit(..) => ExprKind::Literal { literal: cx.const_eval_literal(expr) },\n \n         hir::ExprBinary(op, ref lhs, ref rhs) => {\n             if cx.tcx.tables().is_method_call(expr.id) {\n@@ -354,8 +367,12 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                 } else {\n                     PassArgs::ByRef\n                 };\n-                overloaded_operator(cx, expr, ty::MethodCall::expr(expr.id),\n-                                    pass_args, lhs.to_ref(), vec![rhs])\n+                overloaded_operator(cx,\n+                                    expr,\n+                                    ty::MethodCall::expr(expr.id),\n+                                    pass_args,\n+                                    lhs.to_ref(),\n+                                    vec![rhs])\n             } else {\n                 // FIXME overflow\n                 match (op.node, cx.constness) {\n@@ -405,8 +422,12 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n \n         hir::ExprIndex(ref lhs, ref index) => {\n             if cx.tcx.tables().is_method_call(expr.id) {\n-                overloaded_lvalue(cx, expr, ty::MethodCall::expr(expr.id),\n-                                  PassArgs::ByValue, lhs.to_ref(), vec![index])\n+                overloaded_lvalue(cx,\n+                                  expr,\n+                                  ty::MethodCall::expr(expr.id),\n+                                  PassArgs::ByValue,\n+                                  lhs.to_ref(),\n+                                  vec![index])\n             } else {\n                 ExprKind::Index {\n                     lhs: lhs.to_ref(),\n@@ -417,17 +438,25 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n \n         hir::ExprUnary(hir::UnOp::UnDeref, ref arg) => {\n             if cx.tcx.tables().is_method_call(expr.id) {\n-                overloaded_lvalue(cx, expr, ty::MethodCall::expr(expr.id),\n-                                  PassArgs::ByValue, arg.to_ref(), vec![])\n+                overloaded_lvalue(cx,\n+                                  expr,\n+                                  ty::MethodCall::expr(expr.id),\n+                                  PassArgs::ByValue,\n+                                  arg.to_ref(),\n+                                  vec![])\n             } else {\n                 ExprKind::Deref { arg: arg.to_ref() }\n             }\n         }\n \n         hir::ExprUnary(hir::UnOp::UnNot, ref arg) => {\n             if cx.tcx.tables().is_method_call(expr.id) {\n-                overloaded_operator(cx, expr, ty::MethodCall::expr(expr.id),\n-                                    PassArgs::ByValue, arg.to_ref(), vec![])\n+                overloaded_operator(cx,\n+                                    expr,\n+                                    ty::MethodCall::expr(expr.id),\n+                                    PassArgs::ByValue,\n+                                    arg.to_ref(),\n+                                    vec![])\n             } else {\n                 ExprKind::Unary {\n                     op: UnOp::Not,\n@@ -438,14 +467,16 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n \n         hir::ExprUnary(hir::UnOp::UnNeg, ref arg) => {\n             if cx.tcx.tables().is_method_call(expr.id) {\n-                overloaded_operator(cx, expr, ty::MethodCall::expr(expr.id),\n-                                    PassArgs::ByValue, arg.to_ref(), vec![])\n+                overloaded_operator(cx,\n+                                    expr,\n+                                    ty::MethodCall::expr(expr.id),\n+                                    PassArgs::ByValue,\n+                                    arg.to_ref(),\n+                                    vec![])\n             } else {\n                 // FIXME runtime-overflow\n                 if let hir::ExprLit(_) = arg.node {\n-                    ExprKind::Literal {\n-                        literal: cx.const_eval_literal(expr),\n-                    }\n+                    ExprKind::Literal { literal: cx.const_eval_literal(expr) }\n                 } else {\n                     ExprKind::Unary {\n                         op: UnOp::Neg,\n@@ -457,56 +488,54 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n \n         hir::ExprStruct(ref qpath, ref fields, ref base) => {\n             match expr_ty.sty {\n-                ty::TyAdt(adt, substs) => match adt.adt_kind() {\n-                    AdtKind::Struct | AdtKind::Union => {\n-                        let field_refs = field_refs(&adt.variants[0], fields);\n-                        ExprKind::Adt {\n-                            adt_def: adt,\n-                            variant_index: 0,\n-                            substs: substs,\n-                            fields: field_refs,\n-                            base: base.as_ref().map(|base| {\n-                                FruInfo {\n-                                    base: base.to_ref(),\n-                                    field_types:\n-                                        cx.tcx.tables().fru_field_types[&expr.id].clone()\n-                                }\n-                            })\n+                ty::TyAdt(adt, substs) => {\n+                    match adt.adt_kind() {\n+                        AdtKind::Struct | AdtKind::Union => {\n+                            let field_refs = field_refs(&adt.variants[0], fields);\n+                            ExprKind::Adt {\n+                                adt_def: adt,\n+                                variant_index: 0,\n+                                substs: substs,\n+                                fields: field_refs,\n+                                base: base.as_ref().map(|base| {\n+                                    FruInfo {\n+                                        base: base.to_ref(),\n+                                        field_types: cx.tcx.tables().fru_field_types[&expr.id]\n+                                            .clone(),\n+                                    }\n+                                }),\n+                            }\n                         }\n-                    }\n-                    AdtKind::Enum => {\n-                        let def = match *qpath {\n-                            hir::QPath::Resolved(_, ref path) => path.def,\n-                            hir::QPath::TypeRelative(..) => Def::Err\n-                        };\n-                        match def {\n-                            Def::Variant(variant_id) => {\n-                                assert!(base.is_none());\n-\n-                                let index = adt.variant_index_with_id(variant_id);\n-                                let field_refs = field_refs(&adt.variants[index], fields);\n-                                ExprKind::Adt {\n-                                    adt_def: adt,\n-                                    variant_index: index,\n-                                    substs: substs,\n-                                    fields: field_refs,\n-                                    base: None\n+                        AdtKind::Enum => {\n+                            let def = match *qpath {\n+                                hir::QPath::Resolved(_, ref path) => path.def,\n+                                hir::QPath::TypeRelative(..) => Def::Err,\n+                            };\n+                            match def {\n+                                Def::Variant(variant_id) => {\n+                                    assert!(base.is_none());\n+\n+                                    let index = adt.variant_index_with_id(variant_id);\n+                                    let field_refs = field_refs(&adt.variants[index], fields);\n+                                    ExprKind::Adt {\n+                                        adt_def: adt,\n+                                        variant_index: index,\n+                                        substs: substs,\n+                                        fields: field_refs,\n+                                        base: None,\n+                                    }\n+                                }\n+                                _ => {\n+                                    span_bug!(expr.span, \"unexpected def: {:?}\", def);\n                                 }\n-                            }\n-                            _ => {\n-                                span_bug!(\n-                                    expr.span,\n-                                    \"unexpected def: {:?}\",\n-                                    def);\n                             }\n                         }\n                     }\n-                },\n+                }\n                 _ => {\n-                    span_bug!(\n-                        expr.span,\n-                        \"unexpected type for struct literal: {:?}\",\n-                        expr_ty);\n+                    span_bug!(expr.span,\n+                              \"unexpected type for struct literal: {:?}\",\n+                              expr_ty);\n                 }\n             }\n         }\n@@ -516,9 +545,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             let (def_id, substs) = match closure_ty.sty {\n                 ty::TyClosure(def_id, substs) => (def_id, substs),\n                 _ => {\n-                    span_bug!(expr.span,\n-                              \"closure expr w/o closure type: {:?}\",\n-                              closure_ty);\n+                    span_bug!(expr.span, \"closure expr w/o closure type: {:?}\", closure_ty);\n                 }\n             };\n             let upvars = cx.tcx.with_freevars(expr.id, |freevars| {\n@@ -543,69 +570,81 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             ExprKind::InlineAsm {\n                 asm: asm,\n                 outputs: outputs.to_ref(),\n-                inputs: inputs.to_ref()\n+                inputs: inputs.to_ref(),\n             }\n         }\n \n         // Now comes the rote stuff:\n-\n-        hir::ExprRepeat(ref v, ref c) => ExprKind::Repeat {\n-            value: v.to_ref(),\n-            count: TypedConstVal {\n-                ty: cx.tcx.tables().expr_ty(c),\n-                span: c.span,\n-                value: match const_eval::eval_const_expr(cx.tcx.global_tcx(), c) {\n-                    ConstVal::Integral(ConstInt::Usize(u)) => u,\n-                    other => bug!(\"constant evaluation of repeat count yielded {:?}\", other),\n+        hir::ExprRepeat(ref v, ref c) => {\n+            ExprKind::Repeat {\n+                value: v.to_ref(),\n+                count: TypedConstVal {\n+                    ty: cx.tcx.tables().expr_ty(c),\n+                    span: c.span,\n+                    value: match const_eval::eval_const_expr(cx.tcx.global_tcx(), c) {\n+                        ConstVal::Integral(ConstInt::Usize(u)) => u,\n+                        other => bug!(\"constant evaluation of repeat count yielded {:?}\", other),\n+                    },\n                 },\n             }\n-        },\n-        hir::ExprRet(ref v) =>\n-            ExprKind::Return { value: v.to_ref() },\n-        hir::ExprBreak(label, ref value) =>\n+        }\n+        hir::ExprRet(ref v) => ExprKind::Return { value: v.to_ref() },\n+        hir::ExprBreak(label, ref value) => {\n             ExprKind::Break {\n-                label: label.map(|label| {\n-                    cx.tcx.region_maps.node_extent(label.loop_id)\n-                }),\n-                value: value.to_ref()\n-            },\n-        hir::ExprAgain(label) =>\n+                label: label.map(|label| cx.tcx.region_maps.node_extent(label.loop_id)),\n+                value: value.to_ref(),\n+            }\n+        }\n+        hir::ExprAgain(label) => {\n             ExprKind::Continue {\n-                label: label.map(|label| {\n-                    cx.tcx.region_maps.node_extent(label.loop_id)\n-                })\n-            },\n-        hir::ExprMatch(ref discr, ref arms, _) =>\n-            ExprKind::Match { discriminant: discr.to_ref(),\n-                              arms: arms.iter().map(|a| convert_arm(cx, a)).collect() },\n-        hir::ExprIf(ref cond, ref then, ref otherwise) =>\n-            ExprKind::If { condition: cond.to_ref(),\n-                           then: block::to_expr_ref(cx, then),\n-                           otherwise: otherwise.to_ref() },\n-        hir::ExprWhile(ref cond, ref body, _) =>\n-            ExprKind::Loop { condition: Some(cond.to_ref()),\n-                             body: block::to_expr_ref(cx, body) },\n-        hir::ExprLoop(ref body, _, _) =>\n-            ExprKind::Loop { condition: None,\n-                             body: block::to_expr_ref(cx, body) },\n+                label: label.map(|label| cx.tcx.region_maps.node_extent(label.loop_id)),\n+            }\n+        }\n+        hir::ExprMatch(ref discr, ref arms, _) => {\n+            ExprKind::Match {\n+                discriminant: discr.to_ref(),\n+                arms: arms.iter().map(|a| convert_arm(cx, a)).collect(),\n+            }\n+        }\n+        hir::ExprIf(ref cond, ref then, ref otherwise) => {\n+            ExprKind::If {\n+                condition: cond.to_ref(),\n+                then: block::to_expr_ref(cx, then),\n+                otherwise: otherwise.to_ref(),\n+            }\n+        }\n+        hir::ExprWhile(ref cond, ref body, _) => {\n+            ExprKind::Loop {\n+                condition: Some(cond.to_ref()),\n+                body: block::to_expr_ref(cx, body),\n+            }\n+        }\n+        hir::ExprLoop(ref body, _, _) => {\n+            ExprKind::Loop {\n+                condition: None,\n+                body: block::to_expr_ref(cx, body),\n+            }\n+        }\n         hir::ExprField(ref source, name) => {\n             let index = match cx.tcx.tables().expr_ty_adjusted(source).sty {\n-                ty::TyAdt(adt_def, _) =>\n-                    adt_def.variants[0].index_of_field_named(name.node),\n-                ref ty =>\n-                    span_bug!(expr.span, \"field of non-ADT: {:?}\", ty),\n+                ty::TyAdt(adt_def, _) => adt_def.variants[0].index_of_field_named(name.node),\n+                ref ty => span_bug!(expr.span, \"field of non-ADT: {:?}\", ty),\n             };\n-            let index = index.unwrap_or_else(|| {\n-                span_bug!(\n-                    expr.span,\n-                    \"no index found for field `{}`\",\n-                    name.node)\n-            });\n-            ExprKind::Field { lhs: source.to_ref(), name: Field::new(index) }\n+            let index =\n+                index.unwrap_or_else(|| {\n+                    span_bug!(expr.span, \"no index found for field `{}`\", name.node)\n+                });\n+            ExprKind::Field {\n+                lhs: source.to_ref(),\n+                name: Field::new(index),\n+            }\n+        }\n+        hir::ExprTupField(ref source, index) => {\n+            ExprKind::Field {\n+                lhs: source.to_ref(),\n+                name: Field::new(index.node as usize),\n+            }\n         }\n-        hir::ExprTupField(ref source, index) =>\n-            ExprKind::Field { lhs: source.to_ref(),\n-                              name: Field::new(index.node as usize) },\n         hir::ExprCast(ref source, _) => {\n             // Check to see if this cast is a \"coercion cast\", where the cast is actually done\n             // using a coercion (or is a no-op).\n@@ -616,17 +655,15 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                 ExprKind::Cast { source: source.to_ref() }\n             }\n         }\n-        hir::ExprType(ref source, _) =>\n-            return source.make_mirror(cx),\n-        hir::ExprBox(ref value) =>\n+        hir::ExprType(ref source, _) => return source.make_mirror(cx),\n+        hir::ExprBox(ref value) => {\n             ExprKind::Box {\n                 value: value.to_ref(),\n-                value_extents: cx.tcx.region_maps.node_extent(value.id)\n-            },\n-        hir::ExprArray(ref fields) =>\n-            ExprKind::Vec { fields: fields.to_ref() },\n-        hir::ExprTup(ref fields) =>\n-            ExprKind::Tuple { fields: fields.to_ref() },\n+                value_extents: cx.tcx.region_maps.node_extent(value.id),\n+            }\n+        }\n+        hir::ExprArray(ref fields) => ExprKind::Vec { fields: fields.to_ref() },\n+        hir::ExprTup(ref fields) => ExprKind::Tuple { fields: fields.to_ref() },\n     };\n \n     Expr {\n@@ -663,8 +700,7 @@ fn to_borrow_kind(m: hir::Mutability) -> BorrowKind {\n     }\n }\n \n-fn convert_arm<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n-                               arm: &'tcx hir::Arm) -> Arm<'tcx> {\n+fn convert_arm<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>, arm: &'tcx hir::Arm) -> Arm<'tcx> {\n     Arm {\n         patterns: arm.pats.iter().map(|p| Pattern::from_hir(cx.tcx, p)).collect(),\n         guard: arm.guard.to_ref(),\n@@ -676,41 +712,48 @@ fn convert_path_expr<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                      expr: &'tcx hir::Expr,\n                                      def: Def)\n                                      -> ExprKind<'tcx> {\n-    let substs = cx.tcx.tables().node_id_item_substs(expr.id)\n+    let substs = cx.tcx\n+        .tables()\n+        .node_id_item_substs(expr.id)\n         .unwrap_or_else(|| cx.tcx.intern_substs(&[]));\n     let def_id = match def {\n         // A regular function, constructor function or a constant.\n-        Def::Fn(def_id) | Def::Method(def_id) |\n+        Def::Fn(def_id) |\n+        Def::Method(def_id) |\n         Def::StructCtor(def_id, CtorKind::Fn) |\n         Def::VariantCtor(def_id, CtorKind::Fn) |\n-        Def::Const(def_id) | Def::AssociatedConst(def_id) => def_id,\n+        Def::Const(def_id) |\n+        Def::AssociatedConst(def_id) => def_id,\n \n         Def::StructCtor(def_id, CtorKind::Const) |\n         Def::VariantCtor(def_id, CtorKind::Const) => {\n             match cx.tcx.tables().node_id_to_type(expr.id).sty {\n                 // A unit struct/variant which is used as a value.\n                 // We return a completely different ExprKind here to account for this special case.\n-                ty::TyAdt(adt_def, substs) => return ExprKind::Adt {\n-                    adt_def: adt_def,\n-                    variant_index: adt_def.variant_index_with_id(def_id),\n-                    substs: substs,\n-                    fields: vec![],\n-                    base: None,\n-                },\n-                ref sty => bug!(\"unexpected sty: {:?}\", sty)\n+                ty::TyAdt(adt_def, substs) => {\n+                    return ExprKind::Adt {\n+                        adt_def: adt_def,\n+                        variant_index: adt_def.variant_index_with_id(def_id),\n+                        substs: substs,\n+                        fields: vec![],\n+                        base: None,\n+                    }\n+                }\n+                ref sty => bug!(\"unexpected sty: {:?}\", sty),\n             }\n         }\n \n-        Def::Static(node_id, _) => return ExprKind::StaticRef {\n-            id: node_id,\n-        },\n+        Def::Static(node_id, _) => return ExprKind::StaticRef { id: node_id },\n \n         Def::Local(..) | Def::Upvar(..) => return convert_var(cx, expr, def),\n \n         _ => span_bug!(expr.span, \"def `{:?}` not yet implemented\", def),\n     };\n     ExprKind::Literal {\n-        literal: Literal::Item { def_id: def_id, substs: substs }\n+        literal: Literal::Item {\n+            def_id: def_id,\n+            substs: substs,\n+        },\n     }\n }\n \n@@ -723,14 +766,15 @@ fn convert_var<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n     match def {\n         Def::Local(def_id) => {\n             let node_id = cx.tcx.map.as_local_node_id(def_id).unwrap();\n-            ExprKind::VarRef {\n-                id: node_id,\n-            }\n+            ExprKind::VarRef { id: node_id }\n         }\n \n         Def::Upvar(def_id, index, closure_expr_id) => {\n             let id_var = cx.tcx.map.as_local_node_id(def_id).unwrap();\n-            debug!(\"convert_var(upvar({:?}, {:?}, {:?}))\", id_var, index, closure_expr_id);\n+            debug!(\"convert_var(upvar({:?}, {:?}, {:?}))\",\n+                   id_var,\n+                   index,\n+                   closure_expr_id);\n             let var_ty = cx.tcx.tables().node_id_to_type(id_var);\n \n             let body_id = match cx.tcx.map.find(closure_expr_id) {\n@@ -761,41 +805,45 @@ fn convert_var<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n \n             let self_expr = match cx.tcx.closure_kind(cx.tcx.map.local_def_id(closure_expr_id)) {\n                 ty::ClosureKind::Fn => {\n-                    let ref_closure_ty =\n-                        cx.tcx.mk_ref(region,\n-                                   ty::TypeAndMut { ty: closure_ty,\n-                                                    mutbl: hir::MutImmutable });\n+                    let ref_closure_ty = cx.tcx.mk_ref(region,\n+                                                       ty::TypeAndMut {\n+                                                           ty: closure_ty,\n+                                                           mutbl: hir::MutImmutable,\n+                                                       });\n                     Expr {\n                         ty: closure_ty,\n                         temp_lifetime: temp_lifetime,\n                         span: expr.span,\n                         kind: ExprKind::Deref {\n                             arg: Expr {\n-                                ty: ref_closure_ty,\n-                                temp_lifetime: temp_lifetime,\n-                                span: expr.span,\n-                                kind: ExprKind::SelfRef\n-                            }.to_ref()\n-                        }\n+                                    ty: ref_closure_ty,\n+                                    temp_lifetime: temp_lifetime,\n+                                    span: expr.span,\n+                                    kind: ExprKind::SelfRef,\n+                                }\n+                                .to_ref(),\n+                        },\n                     }\n                 }\n                 ty::ClosureKind::FnMut => {\n-                    let ref_closure_ty =\n-                        cx.tcx.mk_ref(region,\n-                                   ty::TypeAndMut { ty: closure_ty,\n-                                                    mutbl: hir::MutMutable });\n+                    let ref_closure_ty = cx.tcx.mk_ref(region,\n+                                                       ty::TypeAndMut {\n+                                                           ty: closure_ty,\n+                                                           mutbl: hir::MutMutable,\n+                                                       });\n                     Expr {\n                         ty: closure_ty,\n                         temp_lifetime: temp_lifetime,\n                         span: expr.span,\n                         kind: ExprKind::Deref {\n                             arg: Expr {\n-                                ty: ref_closure_ty,\n-                                temp_lifetime: temp_lifetime,\n-                                span: expr.span,\n-                                kind: ExprKind::SelfRef\n-                            }.to_ref()\n-                        }\n+                                    ty: ref_closure_ty,\n+                                    temp_lifetime: temp_lifetime,\n+                                    span: expr.span,\n+                                    kind: ExprKind::SelfRef,\n+                                }\n+                                .to_ref(),\n+                        },\n                     }\n                 }\n                 ty::ClosureKind::FnOnce => {\n@@ -823,26 +871,24 @@ fn convert_var<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             let upvar_capture = match cx.tcx.tables().upvar_capture(upvar_id) {\n                 Some(c) => c,\n                 None => {\n-                    span_bug!(\n-                        expr.span,\n-                        \"no upvar_capture for {:?}\",\n-                        upvar_id);\n+                    span_bug!(expr.span, \"no upvar_capture for {:?}\", upvar_id);\n                 }\n             };\n             match upvar_capture {\n                 ty::UpvarCapture::ByValue => field_kind,\n                 ty::UpvarCapture::ByRef(borrow) => {\n                     ExprKind::Deref {\n                         arg: Expr {\n-                            temp_lifetime: temp_lifetime,\n-                            ty: cx.tcx.mk_ref(borrow.region,\n-                                ty::TypeAndMut {\n-                                    ty: var_ty,\n-                                    mutbl: borrow.kind.to_mutbl_lossy()\n-                                }),\n-                            span: expr.span,\n-                            kind: field_kind,\n-                        }.to_ref()\n+                                temp_lifetime: temp_lifetime,\n+                                ty: cx.tcx.mk_ref(borrow.region,\n+                                                  ty::TypeAndMut {\n+                                                      ty: var_ty,\n+                                                      mutbl: borrow.kind.to_mutbl_lossy(),\n+                                                  }),\n+                                span: expr.span,\n+                                kind: field_kind,\n+                            }\n+                            .to_ref(),\n                     }\n                 }\n             }\n@@ -894,30 +940,31 @@ fn overloaded_operator<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n     // the arguments, unfortunately, do not, so if this is a ByRef\n     // operator, we have to gin up the autorefs (but by value is easy)\n     match pass_args {\n-        PassArgs::ByValue => {\n-            argrefs.extend(args.iter().map(|arg| arg.to_ref()))\n-        }\n+        PassArgs::ByValue => argrefs.extend(args.iter().map(|arg| arg.to_ref())),\n \n         PassArgs::ByRef => {\n             let region = cx.tcx.node_scope_region(expr.id);\n             let temp_lifetime = cx.tcx.region_maps.temporary_scope(expr.id);\n-            argrefs.extend(\n-                args.iter()\n-                    .map(|arg| {\n-                        let arg_ty = cx.tcx.tables().expr_ty_adjusted(arg);\n-                        let adjusted_ty =\n-                            cx.tcx.mk_ref(region,\n-                                       ty::TypeAndMut { ty: arg_ty,\n-                                                        mutbl: hir::MutImmutable });\n-                        Expr {\n+            argrefs.extend(args.iter()\n+                .map(|arg| {\n+                    let arg_ty = cx.tcx.tables().expr_ty_adjusted(arg);\n+                    let adjusted_ty = cx.tcx.mk_ref(region,\n+                                                    ty::TypeAndMut {\n+                                                        ty: arg_ty,\n+                                                        mutbl: hir::MutImmutable,\n+                                                    });\n+                    Expr {\n                             temp_lifetime: temp_lifetime,\n                             ty: adjusted_ty,\n                             span: expr.span,\n-                            kind: ExprKind::Borrow { region: region,\n-                                                     borrow_kind: BorrowKind::Shared,\n-                                                     arg: arg.to_ref() }\n-                        }.to_ref()\n-                    }))\n+                            kind: ExprKind::Borrow {\n+                                region: region,\n+                                borrow_kind: BorrowKind::Shared,\n+                                arg: arg.to_ref(),\n+                            },\n+                        }\n+                        .to_ref()\n+                }))\n         }\n     }\n \n@@ -981,36 +1028,38 @@ fn capture_freevar<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         kind: convert_var(cx, closure_expr, freevar.def),\n     };\n     match upvar_capture {\n-        ty::UpvarCapture::ByValue => {\n-            captured_var.to_ref()\n-        }\n+        ty::UpvarCapture::ByValue => captured_var.to_ref(),\n         ty::UpvarCapture::ByRef(upvar_borrow) => {\n             let borrow_kind = match upvar_borrow.kind {\n                 ty::BorrowKind::ImmBorrow => BorrowKind::Shared,\n                 ty::BorrowKind::UniqueImmBorrow => BorrowKind::Unique,\n                 ty::BorrowKind::MutBorrow => BorrowKind::Mut,\n             };\n             Expr {\n-                temp_lifetime: temp_lifetime,\n-                ty: freevar_ty,\n-                span: closure_expr.span,\n-                kind: ExprKind::Borrow { region: upvar_borrow.region,\n-                                         borrow_kind: borrow_kind,\n-                                         arg: captured_var.to_ref() }\n-            }.to_ref()\n+                    temp_lifetime: temp_lifetime,\n+                    ty: freevar_ty,\n+                    span: closure_expr.span,\n+                    kind: ExprKind::Borrow {\n+                        region: upvar_borrow.region,\n+                        borrow_kind: borrow_kind,\n+                        arg: captured_var.to_ref(),\n+                    },\n+                }\n+                .to_ref()\n         }\n     }\n }\n \n /// Converts a list of named fields (i.e. for struct-like struct/enum ADTs) into FieldExprRef.\n fn field_refs<'tcx>(variant: &'tcx VariantDef,\n                     fields: &'tcx [hir::Field])\n-                    -> Vec<FieldExprRef<'tcx>>\n-{\n+                    -> Vec<FieldExprRef<'tcx>> {\n     fields.iter()\n-          .map(|field| FieldExprRef {\n-              name: Field::new(variant.index_of_field_named(field.name.node).unwrap()),\n-              expr: field.expr.to_ref(),\n-          })\n-          .collect()\n+        .map(|field| {\n+            FieldExprRef {\n+                name: Field::new(variant.index_of_field_named(field.name.node).unwrap()),\n+                expr: field.expr.to_ref(),\n+            }\n+        })\n+        .collect()\n }"}, {"sha": "7d111fccd0056c5801671605153d863ed33918d7", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -8,12 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-/*!\n- * This module contains the code to convert from the wacky tcx data\n- * structures into the hair. The `builder` is generally ignorant of\n- * the tcx etc, and instead goes through the `Cx` for most of its\n- * work.\n- */\n+//! This module contains the code to convert from the wacky tcx data\n+//! structures into the hair. The `builder` is generally ignorant of\n+//! the tcx etc, and instead goes through the `Cx` for most of its\n+//! work.\n+//!\n \n use hair::*;\n use rustc::mir::transform::MirSource;\n@@ -32,27 +31,25 @@ use rustc::hir;\n use rustc_const_math::{ConstInt, ConstUsize};\n \n #[derive(Copy, Clone)]\n-pub struct Cx<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+pub struct Cx<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n     constness: hir::Constness,\n \n     /// True if this constant/function needs overflow checks.\n-    check_overflow: bool\n+    check_overflow: bool,\n }\n \n impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n-    pub fn new(infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n-               src: MirSource)\n-               -> Cx<'a, 'gcx, 'tcx> {\n+    pub fn new(infcx: &'a InferCtxt<'a, 'gcx, 'tcx>, src: MirSource) -> Cx<'a, 'gcx, 'tcx> {\n         let constness = match src {\n             MirSource::Const(_) |\n             MirSource::Static(..) => hir::Constness::Const,\n             MirSource::Fn(id) => {\n                 let fn_like = FnLikeNode::from_node(infcx.tcx.map.get(id));\n                 fn_like.map_or(hir::Constness::NotConst, |f| f.constness())\n             }\n-            MirSource::Promoted(..) => bug!()\n+            MirSource::Promoted(..) => bug!(),\n         };\n \n         let src_node_id = src.item_id();\n@@ -70,13 +67,16 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n         // Some functions always have overflow checks enabled,\n         // however, they may not get codegen'd, depending on\n         // the settings for the crate they are translated in.\n-        let mut check_overflow = attrs.iter().any(|item| {\n-            item.check_name(\"rustc_inherit_overflow_checks\")\n-        });\n+        let mut check_overflow = attrs.iter()\n+            .any(|item| item.check_name(\"rustc_inherit_overflow_checks\"));\n \n         // Respect -Z force-overflow-checks=on and -C debug-assertions.\n-        check_overflow |= infcx.tcx.sess.opts.debugging_opts.force_overflow_checks\n-               .unwrap_or(infcx.tcx.sess.opts.debug_assertions);\n+        check_overflow |= infcx.tcx\n+            .sess\n+            .opts\n+            .debugging_opts\n+            .force_overflow_checks\n+            .unwrap_or(infcx.tcx.sess.opts.debug_assertions);\n \n         // Constants and const fn's always need overflow checks.\n         check_overflow |= constness == hir::Constness::Const;\n@@ -85,7 +85,7 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n             tcx: infcx.tcx,\n             infcx: infcx,\n             constness: constness,\n-            check_overflow: check_overflow\n+            check_overflow: check_overflow,\n         }\n     }\n }\n@@ -102,7 +102,7 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n \n     pub fn usize_literal(&mut self, value: u64) -> Literal<'tcx> {\n         match ConstUsize::new(value, self.tcx.sess.target.uint_type) {\n-            Ok(val) => Literal::Value { value: ConstVal::Integral(ConstInt::Usize(val))},\n+            Ok(val) => Literal::Value { value: ConstVal::Integral(ConstInt::Usize(val)) },\n             Err(_) => bug!(\"usize literal out of range for target\"),\n         }\n     }\n@@ -128,9 +128,7 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn const_eval_literal(&mut self, e: &hir::Expr) -> Literal<'tcx> {\n-        Literal::Value {\n-            value: const_eval::eval_const_expr(self.tcx.global_tcx(), e)\n-        }\n+        Literal::Value { value: const_eval::eval_const_expr(self.tcx.global_tcx(), e) }\n     }\n \n     pub fn trait_method(&mut self,\n@@ -145,10 +143,11 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n             if item.kind == ty::AssociatedKind::Method && item.name == method_name {\n                 let method_ty = self.tcx.item_type(item.def_id);\n                 let method_ty = method_ty.subst(self.tcx, substs);\n-                return (method_ty, Literal::Item {\n-                    def_id: item.def_id,\n-                    substs: substs,\n-                });\n+                return (method_ty,\n+                        Literal::Item {\n+                            def_id: item.def_id,\n+                            substs: substs,\n+                        });\n             }\n         }\n \n@@ -168,7 +167,8 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n     pub fn needs_drop(&mut self, ty: Ty<'tcx>) -> bool {\n         let ty = self.tcx.lift_to_global(&ty).unwrap_or_else(|| {\n             bug!(\"MIR: Cx::needs_drop({}) got \\\n-                  type with inference types/regions\", ty);\n+                  type with inference types/regions\",\n+                 ty);\n         });\n         self.tcx.type_needs_drop_given_env(ty, &self.infcx.parameter_environment)\n     }"}, {"sha": "6930a959d6515ce2365e26e1a47574e15794b857", "filename": "src/librustc_mir/hair/cx/to_ref.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_mir%2Fhair%2Fcx%2Fto_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_mir%2Fhair%2Fcx%2Fto_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fto_ref.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -18,32 +18,32 @@ pub trait ToRef {\n     fn to_ref(self) -> Self::Output;\n }\n \n-impl<'a,'tcx:'a> ToRef for &'tcx hir::Expr {\n+impl<'a, 'tcx: 'a> ToRef for &'tcx hir::Expr {\n     type Output = ExprRef<'tcx>;\n \n     fn to_ref(self) -> ExprRef<'tcx> {\n         ExprRef::Hair(self)\n     }\n }\n \n-impl<'a,'tcx:'a> ToRef for &'tcx P<hir::Expr> {\n+impl<'a, 'tcx: 'a> ToRef for &'tcx P<hir::Expr> {\n     type Output = ExprRef<'tcx>;\n \n     fn to_ref(self) -> ExprRef<'tcx> {\n         ExprRef::Hair(&**self)\n     }\n }\n \n-impl<'a,'tcx:'a> ToRef for Expr<'tcx> {\n+impl<'a, 'tcx: 'a> ToRef for Expr<'tcx> {\n     type Output = ExprRef<'tcx>;\n \n     fn to_ref(self) -> ExprRef<'tcx> {\n         ExprRef::Mirror(Box::new(self))\n     }\n }\n \n-impl<'a,'tcx:'a,T,U> ToRef for &'tcx Option<T>\n-    where &'tcx T: ToRef<Output=U>\n+impl<'a, 'tcx: 'a, T, U> ToRef for &'tcx Option<T>\n+    where &'tcx T: ToRef<Output = U>\n {\n     type Output = Option<U>;\n \n@@ -52,8 +52,8 @@ impl<'a,'tcx:'a,T,U> ToRef for &'tcx Option<T>\n     }\n }\n \n-impl<'a,'tcx:'a,T,U> ToRef for &'tcx Vec<T>\n-    where &'tcx T: ToRef<Output=U>\n+impl<'a, 'tcx: 'a, T, U> ToRef for &'tcx Vec<T>\n+    where &'tcx T: ToRef<Output = U>\n {\n     type Output = Vec<U>;\n \n@@ -62,8 +62,8 @@ impl<'a,'tcx:'a,T,U> ToRef for &'tcx Vec<T>\n     }\n }\n \n-impl<'a,'tcx:'a,T,U> ToRef for &'tcx P<[T]>\n-    where &'tcx T: ToRef<Output=U>\n+impl<'a, 'tcx: 'a, T, U> ToRef for &'tcx P<[T]>\n+    where &'tcx T: ToRef<Output = U>\n {\n     type Output = Vec<U>;\n "}, {"sha": "3cbf8573ba97fdf67a25b36a708eca03b0e24b4a", "filename": "src/librustc_mir/transform/copy_prop.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -30,7 +30,7 @@\n //! future.\n \n use def_use::DefUseAnalysis;\n-use rustc::mir::{Constant, Local, Location, Lvalue, Mir, Operand, Rvalue, StatementKind};\n+use rustc::mir::{Constant, Local, LocalKind, Location, Lvalue, Mir, Operand, Rvalue, StatementKind};\n use rustc::mir::transform::{MirPass, MirSource, Pass};\n use rustc::mir::visit::MutVisitor;\n use rustc::ty::TyCtxt;\n@@ -122,7 +122,7 @@ impl<'tcx> MirPass<'tcx> for CopyPropagation {\n                                 local == dest_local => {\n                             let maybe_action = match *operand {\n                                 Operand::Consume(ref src_lvalue) => {\n-                                    Action::local_copy(&def_use_analysis, src_lvalue)\n+                                    Action::local_copy(&mir, &def_use_analysis, src_lvalue)\n                                 }\n                                 Operand::Constant(ref src_constant) => {\n                                     Action::constant(src_constant)\n@@ -159,7 +159,7 @@ enum Action<'tcx> {\n }\n \n impl<'tcx> Action<'tcx> {\n-    fn local_copy(def_use_analysis: &DefUseAnalysis, src_lvalue: &Lvalue<'tcx>)\n+    fn local_copy(mir: &Mir<'tcx>, def_use_analysis: &DefUseAnalysis, src_lvalue: &Lvalue<'tcx>)\n                   -> Option<Action<'tcx>> {\n         // The source must be a local.\n         let src_local = if let Lvalue::Local(local) = *src_lvalue {\n@@ -195,7 +195,9 @@ impl<'tcx> Action<'tcx> {\n         //     SRC = X;\n         //     USE(SRC);\n         let src_def_count = src_use_info.def_count_not_including_drop();\n-        if src_def_count != 1 {\n+        // allow function arguments to be propagated\n+        if src_def_count > 1 ||\n+            (src_def_count == 0 && mir.local_kind(src_local) != LocalKind::Arg) {\n             debug!(\"  Can't copy-propagate local: {} defs of src\",\n                    src_use_info.def_count_not_including_drop());\n             return None"}, {"sha": "52bdd014933b8d6438949a179e1afe5cbe041d7a", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -154,8 +154,8 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n     }\n \n     fn visit_path(&mut self, path: &'a Path, id: NodeId) {\n-        if path.global && path.segments.len() > 0 {\n-            let ident = path.segments[0].identifier;\n+        if path.segments.len() >= 2 && path.is_global() {\n+            let ident = path.segments[1].identifier;\n             if token::Ident(ident).is_path_segment_keyword() {\n                 self.session.add_lint(lint::builtin::SUPER_OR_SELF_IN_GLOBAL_PATH,\n                                       id,\n@@ -171,7 +171,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n         match item.node {\n             ItemKind::Use(ref view_path) => {\n                 let path = view_path.node.path();\n-                if !path.segments.iter().all(|segment| segment.parameters.is_empty()) {\n+                if path.segments.iter().any(|segment| segment.parameters.is_some()) {\n                     self.err_handler()\n                         .span_err(path.span, \"type or lifetime parameters in import path\");\n                 }\n@@ -275,7 +275,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n     fn visit_vis(&mut self, vis: &'a Visibility) {\n         match *vis {\n             Visibility::Restricted { ref path, .. } => {\n-                if !path.segments.iter().all(|segment| segment.parameters.is_empty()) {\n+                if !path.segments.iter().all(|segment| segment.parameters.is_none()) {\n                     self.err_handler()\n                         .span_err(path.span, \"type or lifetime parameters in visibility path\");\n                 }"}, {"sha": "3700d0295e9639dd50a7a08a85a3263a0d3c92f8", "filename": "src/librustc_plugin/registry.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_plugin%2Fregistry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_plugin%2Fregistry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin%2Fregistry.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -64,6 +64,8 @@ pub struct Registry<'a> {\n \n     #[doc(hidden)]\n     pub attributes: Vec<(String, AttributeType)>,\n+\n+    whitelisted_custom_derives: Vec<ast::Name>,\n }\n \n impl<'a> Registry<'a> {\n@@ -80,6 +82,7 @@ impl<'a> Registry<'a> {\n             llvm_passes: vec![],\n             attributes: vec![],\n             mir_passes: Vec::new(),\n+            whitelisted_custom_derives: Vec::new(),\n         }\n     }\n \n@@ -115,6 +118,21 @@ impl<'a> Registry<'a> {\n         }));\n     }\n \n+    /// This can be used in place of `register_syntax_extension` to register legacy custom derives\n+    /// (i.e. attribute syntax extensions whose name begins with `derive_`). Legacy custom\n+    /// derives defined by this function do not trigger deprecation warnings when used.\n+    #[unstable(feature = \"rustc_private\", issue = \"27812\")]\n+    #[rustc_deprecated(since = \"1.15.0\", reason = \"replaced by macros 1.1 (RFC 1861)\")]\n+    pub fn register_custom_derive(&mut self, name: ast::Name, extension: SyntaxExtension) {\n+        assert!(name.as_str().starts_with(\"derive_\"));\n+        self.whitelisted_custom_derives.push(name);\n+        self.register_syntax_extension(name, extension);\n+    }\n+\n+    pub fn take_whitelisted_custom_derives(&mut self) -> Vec<ast::Name> {\n+        ::std::mem::replace(&mut self.whitelisted_custom_derives, Vec::new())\n+    }\n+\n     /// Register a macro of the usual kind.\n     ///\n     /// This is a convenience wrapper for `register_syntax_extension`."}, {"sha": "ca3e4e1c762c72e837bd3e0a49439b5aff75641d", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -28,7 +28,7 @@ extern crate syntax_pos;\n use rustc::dep_graph::DepNode;\n use rustc::hir::{self, PatKind};\n use rustc::hir::def::{self, Def, CtorKind};\n-use rustc::hir::def_id::DefId;\n+use rustc::hir::def_id::{CRATE_DEF_INDEX, DefId};\n use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use rustc::hir::itemlikevisit::DeepVisitor;\n use rustc::hir::pat_util::EnumerateAndAdjustIterator;\n@@ -391,7 +391,7 @@ impl<'b, 'a, 'tcx> TypeVisitor<'tcx> for ReachEverythingInTheInterfaceVisitor<'b\n \n struct PrivacyVisitor<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    curitem: ast::NodeId,\n+    curitem: DefId,\n     in_foreign: bool,\n }\n \n@@ -401,12 +401,12 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n             Some(node_id) =>\n                 ty::Visibility::from_hir(&self.tcx.map.expect_item(node_id).vis, node_id, self.tcx),\n             None => self.tcx.sess.cstore.visibility(did),\n-        }.is_accessible_from(self.curitem, &self.tcx.map)\n+        }.is_accessible_from(self.curitem, self.tcx)\n     }\n \n     // Checks that a field is in scope.\n     fn check_field(&mut self, span: Span, def: &'tcx ty::AdtDef, field: &'tcx ty::FieldDef) {\n-        if !def.is_enum() && !field.vis.is_accessible_from(self.curitem, &self.tcx.map) {\n+        if !def.is_enum() && !field.vis.is_accessible_from(self.curitem, self.tcx) {\n             struct_span_err!(self.tcx.sess, span, E0451, \"field `{}` of {} `{}` is private\",\n                       field.name, def.variant_descr(), self.tcx.item_path_str(def.did))\n                 .span_label(span, &format!(\"field `{}` is private\", field.name))\n@@ -437,7 +437,7 @@ impl<'a, 'tcx> Visitor<'tcx> for PrivacyVisitor<'a, 'tcx> {\n     }\n \n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n-        let orig_curitem = replace(&mut self.curitem, item.id);\n+        let orig_curitem = replace(&mut self.curitem, self.tcx.map.local_def_id(item.id));\n         intravisit::walk_item(self, item);\n         self.curitem = orig_curitem;\n     }\n@@ -474,7 +474,7 @@ impl<'a, 'tcx> Visitor<'tcx> for PrivacyVisitor<'a, 'tcx> {\n                 if let Def::StructCtor(_, CtorKind::Fn) = path.def {\n                     let adt_def = self.tcx.expect_variant_def(path.def);\n                     let private_indexes = adt_def.fields.iter().enumerate().filter(|&(_, field)| {\n-                        !field.vis.is_accessible_from(self.curitem, &self.tcx.map)\n+                        !field.vis.is_accessible_from(self.curitem, self.tcx)\n                     }).map(|(i, _)| i).collect::<Vec<_>>();\n \n                     if !private_indexes.is_empty() {\n@@ -940,7 +940,7 @@ impl<'a, 'tcx: 'a> TypeVisitor<'tcx> for SearchInterfaceForPrivateItemsVisitor<'\n             ty::TyAdt(adt, _) => Some(adt.did),\n             ty::TyDynamic(ref obj, ..) => obj.principal().map(|p| p.def_id()),\n             ty::TyProjection(ref proj) => {\n-                if self.required_visibility == ty::Visibility::PrivateExternal {\n+                if self.required_visibility == ty::Visibility::Invisible {\n                     // Conservatively approximate the whole type alias as public without\n                     // recursing into its components when determining impl publicity.\n                     // For example, `impl <Type as Trait>::Alias {...}` may be a public impl\n@@ -961,10 +961,10 @@ impl<'a, 'tcx: 'a> TypeVisitor<'tcx> for SearchInterfaceForPrivateItemsVisitor<'\n                 let item = self.tcx.map.expect_item(node_id);\n                 let vis = ty::Visibility::from_hir(&item.vis, node_id, self.tcx);\n \n-                if !vis.is_at_least(self.min_visibility, &self.tcx.map) {\n+                if !vis.is_at_least(self.min_visibility, self.tcx) {\n                     self.min_visibility = vis;\n                 }\n-                if !vis.is_at_least(self.required_visibility, &self.tcx.map) {\n+                if !vis.is_at_least(self.required_visibility, self.tcx) {\n                     if self.tcx.sess.features.borrow().pub_restricted || self.has_old_errors {\n                         let mut err = struct_span_err!(self.tcx.sess, self.span, E0446,\n                             \"private type `{}` in public interface\", ty);\n@@ -996,10 +996,10 @@ impl<'a, 'tcx: 'a> TypeVisitor<'tcx> for SearchInterfaceForPrivateItemsVisitor<'\n             let item = self.tcx.map.expect_item(node_id);\n             let vis = ty::Visibility::from_hir(&item.vis, node_id, self.tcx);\n \n-            if !vis.is_at_least(self.min_visibility, &self.tcx.map) {\n+            if !vis.is_at_least(self.min_visibility, self.tcx) {\n                 self.min_visibility = vis;\n             }\n-            if !vis.is_at_least(self.required_visibility, &self.tcx.map) {\n+            if !vis.is_at_least(self.required_visibility, self.tcx) {\n                 if self.tcx.sess.features.borrow().pub_restricted || self.has_old_errors {\n                     struct_span_err!(self.tcx.sess, self.span, E0445,\n                                      \"private trait `{}` in public interface\", trait_ref)\n@@ -1071,7 +1071,7 @@ impl<'a, 'tcx> Visitor<'tcx> for PrivateItemsInPublicInterfacesVisitor<'a, 'tcx>\n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n         let tcx = self.tcx;\n         let min = |vis1: ty::Visibility, vis2| {\n-            if vis1.is_at_least(vis2, &tcx.map) { vis2 } else { vis1 }\n+            if vis1.is_at_least(vis2, tcx) { vis2 } else { vis1 }\n         };\n \n         let item_visibility = ty::Visibility::from_hir(&item.vis, item.id, tcx);\n@@ -1137,8 +1137,8 @@ impl<'a, 'tcx> Visitor<'tcx> for PrivateItemsInPublicInterfacesVisitor<'a, 'tcx>\n             // An inherent impl is public when its type is public\n             // Subitems of inherent impls have their own publicity\n             hir::ItemImpl(.., None, _, ref impl_item_refs) => {\n-                let ty_vis = self.check(item.id, ty::Visibility::PrivateExternal)\n-                                 .item_type().min_visibility;\n+                let ty_vis =\n+                    self.check(item.id, ty::Visibility::Invisible).item_type().min_visibility;\n                 self.check(item.id, ty_vis).generics().predicates();\n \n                 for impl_item_ref in impl_item_refs {\n@@ -1156,7 +1156,7 @@ impl<'a, 'tcx> Visitor<'tcx> for PrivateItemsInPublicInterfacesVisitor<'a, 'tcx>\n             // A trait impl is public when both its type and its trait are public\n             // Subitems of trait impls have inherited publicity\n             hir::ItemImpl(.., Some(_), _, ref impl_item_refs) => {\n-                let vis = self.check(item.id, ty::Visibility::PrivateExternal)\n+                let vis = self.check(item.id, ty::Visibility::Invisible)\n                               .item_type().impl_trait_ref().min_visibility;\n                 self.check(item.id, vis).generics().predicates();\n                 for impl_item_ref in impl_item_refs {\n@@ -1203,7 +1203,7 @@ pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     // Use the parent map to check the privacy of everything\n     let mut visitor = PrivacyVisitor {\n-        curitem: ast::DUMMY_NODE_ID,\n+        curitem: DefId::local(CRATE_DEF_INDEX),\n         in_foreign: false,\n         tcx: tcx,\n     };"}, {"sha": "1b3791355d2c35a460f79d58c9e542e2babf4a70", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 130, "deletions": 155, "changes": 285, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -16,7 +16,8 @@\n use macros::{InvocationData, LegacyScope};\n use resolve_imports::ImportDirective;\n use resolve_imports::ImportDirectiveSubclass::{self, GlobImport, SingleImport};\n-use {Resolver, Module, ModuleS, ModuleKind, NameBinding, NameBindingKind, ToNameBinding};\n+use {Module, ModuleData, ModuleKind, NameBinding, NameBindingKind, ToNameBinding};\n+use {Resolver, ResolverArenas};\n use Namespace::{self, TypeNS, ValueNS, MacroNS};\n use {resolve_error, resolve_struct_error, ResolutionError};\n \n@@ -28,7 +29,7 @@ use rustc::ty;\n use std::cell::Cell;\n use std::rc::Rc;\n \n-use syntax::ast::Name;\n+use syntax::ast::{Name, Ident};\n use syntax::attr;\n \n use syntax::ast::{self, Block, ForeignItem, ForeignItemKind, Item, ItemKind};\n@@ -39,30 +40,31 @@ use syntax::ext::base::Determinacy::Undetermined;\n use syntax::ext::expand::mark_tts;\n use syntax::ext::hygiene::Mark;\n use syntax::ext::tt::macro_rules;\n+use syntax::parse::token;\n use syntax::symbol::keywords;\n use syntax::visit::{self, Visitor};\n \n use syntax_pos::{Span, DUMMY_SP};\n \n impl<'a> ToNameBinding<'a> for (Module<'a>, ty::Visibility, Span, Mark) {\n-    fn to_name_binding(self) -> NameBinding<'a> {\n-        NameBinding {\n+    fn to_name_binding(self, arenas: &'a ResolverArenas<'a>) -> &'a NameBinding<'a> {\n+        arenas.alloc_name_binding(NameBinding {\n             kind: NameBindingKind::Module(self.0),\n             vis: self.1,\n             span: self.2,\n             expansion: self.3,\n-        }\n+        })\n     }\n }\n \n impl<'a> ToNameBinding<'a> for (Def, ty::Visibility, Span, Mark) {\n-    fn to_name_binding(self) -> NameBinding<'a> {\n-        NameBinding {\n+    fn to_name_binding(self, arenas: &'a ResolverArenas<'a>) -> &'a NameBinding<'a> {\n+        arenas.alloc_name_binding(NameBinding {\n             kind: NameBindingKind::Def(self.0),\n             vis: self.1,\n             span: self.2,\n             expansion: self.3,\n-        }\n+        })\n     }\n }\n \n@@ -73,15 +75,15 @@ struct LegacyMacroImports {\n     reexports: Vec<(Name, Span)>,\n }\n \n-impl<'b> Resolver<'b> {\n+impl<'a> Resolver<'a> {\n     /// Defines `name` in namespace `ns` of module `parent` to be `def` if it is not yet defined;\n     /// otherwise, reports an error.\n-    fn define<T>(&mut self, parent: Module<'b>, name: Name, ns: Namespace, def: T)\n-        where T: ToNameBinding<'b>,\n+    fn define<T>(&mut self, parent: Module<'a>, ident: Ident, ns: Namespace, def: T)\n+        where T: ToNameBinding<'a>,\n     {\n-        let binding = def.to_name_binding();\n-        if let Err(old_binding) = self.try_define(parent, name, ns, binding.clone()) {\n-            self.report_conflict(parent, name, ns, old_binding, &binding);\n+        let binding = def.to_name_binding(self.arenas);\n+        if let Err(old_binding) = self.try_define(parent, ident, ns, binding) {\n+            self.report_conflict(parent, ident, ns, old_binding, &binding);\n         }\n     }\n \n@@ -102,7 +104,7 @@ impl<'b> Resolver<'b> {\n     /// Constructs the reduced graph for one item.\n     fn build_reduced_graph_for_item(&mut self, item: &Item, expansion: Mark) {\n         let parent = self.current_module;\n-        let name = item.ident.name;\n+        let ident = item.ident;\n         let sp = item.span;\n         let vis = self.resolve_visibility(&item.vis);\n \n@@ -111,7 +113,7 @@ impl<'b> Resolver<'b> {\n                 // Extract and intern the module part of the path. For\n                 // globs and lists, the path is found directly in the AST;\n                 // for simple paths we have to munge the path a little.\n-                let module_path: Vec<_> = match view_path.node {\n+                let mut module_path: Vec<_> = match view_path.node {\n                     ViewPathSimple(_, ref full_path) => {\n                         full_path.segments\n                                  .split_last()\n@@ -131,6 +133,12 @@ impl<'b> Resolver<'b> {\n                     }\n                 };\n \n+                // This can be removed once warning cycle #36888 is complete.\n+                if module_path.len() >= 2 && module_path[0].name == keywords::CrateRoot.name() &&\n+                   token::Ident(module_path[1]).is_path_segment_keyword() {\n+                    module_path.remove(0);\n+                }\n+\n                 // Build up the import directives.\n                 let is_prelude = attr::contains_name(&item.attrs, \"prelude_import\");\n \n@@ -157,8 +165,8 @@ impl<'b> Resolver<'b> {\n                         }\n \n                         let subclass = SingleImport {\n-                            target: binding.name,\n-                            source: source.name,\n+                            target: binding,\n+                            source: source,\n                             result: self.per_ns(|_, _| Cell::new(Err(Undetermined))),\n                         };\n                         self.add_import_directive(\n@@ -187,31 +195,29 @@ impl<'b> Resolver<'b> {\n \n                         for source_item in source_items {\n                             let node = source_item.node;\n-                            let (module_path, name, rename) = {\n+                            let (module_path, ident, rename) = {\n                                 if node.name.name != keywords::SelfValue.name() {\n-                                    let rename = node.rename.unwrap_or(node.name).name;\n-                                    (module_path.clone(), node.name.name, rename)\n+                                    let rename = node.rename.unwrap_or(node.name);\n+                                    (module_path.clone(), node.name, rename)\n                                 } else {\n-                                    let name = match module_path.last() {\n-                                        Some(ident) => ident.name,\n-                                        None => {\n-                                            resolve_error(\n-                                                self,\n-                                                source_item.span,\n-                                                ResolutionError::\n-                                                SelfImportOnlyInImportListWithNonEmptyPrefix\n-                                            );\n-                                            continue;\n-                                        }\n-                                    };\n+                                    let ident = *module_path.last().unwrap();\n+                                    if ident.name == keywords::CrateRoot.name() {\n+                                        resolve_error(\n+                                            self,\n+                                            source_item.span,\n+                                            ResolutionError::\n+                                            SelfImportOnlyInImportListWithNonEmptyPrefix\n+                                        );\n+                                        continue;\n+                                    }\n                                     let module_path = module_path.split_last().unwrap().1;\n-                                    let rename = node.rename.map(|i| i.name).unwrap_or(name);\n-                                    (module_path.to_vec(), name, rename)\n+                                    let rename = node.rename.unwrap_or(ident);\n+                                    (module_path.to_vec(), ident, rename)\n                                 }\n                             };\n                             let subclass = SingleImport {\n                                 target: rename,\n-                                source: name,\n+                                source: ident,\n                                 result: self.per_ns(|_, _| Cell::new(Err(Undetermined))),\n                             };\n                             let id = source_item.node.id;\n@@ -223,7 +229,7 @@ impl<'b> Resolver<'b> {\n                     ViewPathGlob(_) => {\n                         let subclass = GlobImport {\n                             is_prelude: is_prelude,\n-                            max_vis: Cell::new(ty::Visibility::PrivateExternal),\n+                            max_vis: Cell::new(ty::Visibility::Invisible),\n                         };\n                         self.add_import_directive(\n                             module_path, subclass, view_path.span, item.id, vis, expansion,\n@@ -238,8 +244,8 @@ impl<'b> Resolver<'b> {\n                 // n.b. we don't need to look at the path option here, because cstore already did\n                 let crate_id = self.session.cstore.extern_mod_stmt_cnum(item.id).unwrap();\n                 let module = self.get_extern_crate_root(crate_id);\n-                let binding = (module, ty::Visibility::Public, sp, expansion).to_name_binding();\n-                let binding = self.arenas.alloc_name_binding(binding);\n+                let binding =\n+                    (module, ty::Visibility::Public, sp, expansion).to_name_binding(self.arenas);\n                 let directive = self.arenas.alloc_import_directive(ImportDirective {\n                     id: item.id,\n                     parent: parent,\n@@ -251,24 +257,24 @@ impl<'b> Resolver<'b> {\n                     expansion: expansion,\n                 });\n                 let imported_binding = self.import(binding, directive);\n-                self.define(parent, name, TypeNS, imported_binding);\n+                self.define(parent, ident, TypeNS, imported_binding);\n                 self.populate_module_if_necessary(module);\n                 self.process_legacy_macro_imports(item, module, expansion);\n             }\n \n             ItemKind::Mod(..) if item.ident == keywords::Invalid.ident() => {} // Crate root\n \n             ItemKind::Mod(..) => {\n-                let def = Def::Mod(self.definitions.local_def_id(item.id));\n-                let module = self.arenas.alloc_module(ModuleS {\n+                let def_id = self.definitions.local_def_id(item.id);\n+                let module_kind = ModuleKind::Def(Def::Mod(def_id), ident.name);\n+                let module = self.arenas.alloc_module(ModuleData {\n                     no_implicit_prelude: parent.no_implicit_prelude || {\n                         attr::contains_name(&item.attrs, \"no_implicit_prelude\")\n                     },\n-                    normal_ancestor_id: Some(item.id),\n-                    ..ModuleS::new(Some(parent), ModuleKind::Def(def, name))\n+                    ..ModuleData::new(Some(parent), module_kind, def_id)\n                 });\n-                self.define(parent, name, TypeNS, (module, vis, sp, expansion));\n-                self.module_map.insert(item.id, module);\n+                self.define(parent, ident, TypeNS, (module, vis, sp, expansion));\n+                self.module_map.insert(def_id, module);\n \n                 // Descend into the module.\n                 self.current_module = module;\n@@ -280,27 +286,28 @@ impl<'b> Resolver<'b> {\n             ItemKind::Static(_, m, _) => {\n                 let mutbl = m == Mutability::Mutable;\n                 let def = Def::Static(self.definitions.local_def_id(item.id), mutbl);\n-                self.define(parent, name, ValueNS, (def, vis, sp, expansion));\n+                self.define(parent, ident, ValueNS, (def, vis, sp, expansion));\n             }\n             ItemKind::Const(..) => {\n                 let def = Def::Const(self.definitions.local_def_id(item.id));\n-                self.define(parent, name, ValueNS, (def, vis, sp, expansion));\n+                self.define(parent, ident, ValueNS, (def, vis, sp, expansion));\n             }\n             ItemKind::Fn(..) => {\n                 let def = Def::Fn(self.definitions.local_def_id(item.id));\n-                self.define(parent, name, ValueNS, (def, vis, sp, expansion));\n+                self.define(parent, ident, ValueNS, (def, vis, sp, expansion));\n             }\n \n             // These items live in the type namespace.\n             ItemKind::Ty(..) => {\n                 let def = Def::TyAlias(self.definitions.local_def_id(item.id));\n-                self.define(parent, name, TypeNS, (def, vis, sp, expansion));\n+                self.define(parent, ident, TypeNS, (def, vis, sp, expansion));\n             }\n \n             ItemKind::Enum(ref enum_definition, _) => {\n                 let def = Def::Enum(self.definitions.local_def_id(item.id));\n-                let module = self.new_module(parent, ModuleKind::Def(def, name), true);\n-                self.define(parent, name, TypeNS, (module, vis, sp, expansion));\n+                let module_kind = ModuleKind::Def(def, ident.name);\n+                let module = self.new_module(parent, module_kind, parent.normal_ancestor_id);\n+                self.define(parent, ident, TypeNS, (module, vis, sp, expansion));\n \n                 for variant in &(*enum_definition).variants {\n                     self.build_reduced_graph_for_variant(variant, module, vis, expansion);\n@@ -311,14 +318,14 @@ impl<'b> Resolver<'b> {\n             ItemKind::Struct(ref struct_def, _) => {\n                 // Define a name in the type namespace.\n                 let def = Def::Struct(self.definitions.local_def_id(item.id));\n-                self.define(parent, name, TypeNS, (def, vis, sp, expansion));\n+                self.define(parent, ident, TypeNS, (def, vis, sp, expansion));\n \n                 // If this is a tuple or unit struct, define a name\n                 // in the value namespace as well.\n                 if !struct_def.is_struct() {\n                     let ctor_def = Def::StructCtor(self.definitions.local_def_id(struct_def.id()),\n                                                    CtorKind::from_ast(struct_def));\n-                    self.define(parent, name, ValueNS, (ctor_def, vis, sp, expansion));\n+                    self.define(parent, ident, ValueNS, (ctor_def, vis, sp, expansion));\n                 }\n \n                 // Record field names for error reporting.\n@@ -332,7 +339,7 @@ impl<'b> Resolver<'b> {\n \n             ItemKind::Union(ref vdata, _) => {\n                 let def = Def::Union(self.definitions.local_def_id(item.id));\n-                self.define(parent, name, TypeNS, (def, vis, sp, expansion));\n+                self.define(parent, ident, TypeNS, (def, vis, sp, expansion));\n \n                 // Record field names for error reporting.\n                 let field_names = vdata.fields().iter().filter_map(|field| {\n@@ -349,9 +356,9 @@ impl<'b> Resolver<'b> {\n                 let def_id = self.definitions.local_def_id(item.id);\n \n                 // Add all the items within to a new module.\n-                let module =\n-                    self.new_module(parent, ModuleKind::Def(Def::Trait(def_id), name), true);\n-                self.define(parent, name, TypeNS, (module, vis, sp, expansion));\n+                let module_kind = ModuleKind::Def(Def::Trait(def_id), ident.name);\n+                let module = self.new_module(parent, module_kind, parent.normal_ancestor_id);\n+                self.define(parent, ident, TypeNS, (module, vis, sp, expansion));\n                 self.current_module = module;\n             }\n             ItemKind::Mac(_) => panic!(\"unexpanded macro in resolve!\"),\n@@ -362,29 +369,26 @@ impl<'b> Resolver<'b> {\n     // type and value namespaces.\n     fn build_reduced_graph_for_variant(&mut self,\n                                        variant: &Variant,\n-                                       parent: Module<'b>,\n+                                       parent: Module<'a>,\n                                        vis: ty::Visibility,\n                                        expansion: Mark) {\n-        let name = variant.node.name.name;\n+        let ident = variant.node.name;\n         let def_id = self.definitions.local_def_id(variant.node.data.id());\n \n         // Define a name in the type namespace.\n         let def = Def::Variant(def_id);\n-        self.define(parent, name, TypeNS, (def, vis, variant.span, expansion));\n+        self.define(parent, ident, TypeNS, (def, vis, variant.span, expansion));\n \n         // Define a constructor name in the value namespace.\n         // Braced variants, unlike structs, generate unusable names in\n         // value namespace, they are reserved for possible future use.\n         let ctor_kind = CtorKind::from_ast(&variant.node.data);\n         let ctor_def = Def::VariantCtor(def_id, ctor_kind);\n-        self.define(parent, name, ValueNS, (ctor_def, vis, variant.span, expansion));\n+        self.define(parent, ident, ValueNS, (ctor_def, vis, variant.span, expansion));\n     }\n \n     /// Constructs the reduced graph for one foreign item.\n     fn build_reduced_graph_for_foreign_item(&mut self, item: &ForeignItem, expansion: Mark) {\n-        let parent = self.current_module;\n-        let name = item.ident.name;\n-\n         let def = match item.node {\n             ForeignItemKind::Fn(..) => {\n                 Def::Fn(self.definitions.local_def_id(item.id))\n@@ -393,111 +397,79 @@ impl<'b> Resolver<'b> {\n                 Def::Static(self.definitions.local_def_id(item.id), m)\n             }\n         };\n+        let parent = self.current_module;\n         let vis = self.resolve_visibility(&item.vis);\n-        self.define(parent, name, ValueNS, (def, vis, item.span, expansion));\n+        self.define(parent, item.ident, ValueNS, (def, vis, item.span, expansion));\n     }\n \n     fn build_reduced_graph_for_block(&mut self, block: &Block) {\n         let parent = self.current_module;\n         if self.block_needs_anonymous_module(block) {\n-            let block_id = block.id;\n-\n-            debug!(\"(building reduced graph for block) creating a new anonymous module for block \\\n-                    {}\",\n-                   block_id);\n-\n-            let new_module = self.new_module(parent, ModuleKind::Block(block_id), true);\n-            self.module_map.insert(block_id, new_module);\n-            self.current_module = new_module; // Descend into the block.\n+            let module =\n+                self.new_module(parent, ModuleKind::Block(block.id), parent.normal_ancestor_id);\n+            self.block_map.insert(block.id, module);\n+            self.current_module = module; // Descend into the block.\n         }\n     }\n \n     /// Builds the reduced graph for a single item in an external crate.\n-    fn build_reduced_graph_for_external_crate_def(&mut self, parent: Module<'b>, child: Export) {\n-        let name = child.name;\n+    fn build_reduced_graph_for_external_crate_def(&mut self, parent: Module<'a>, child: Export) {\n+        let ident = Ident::with_empty_ctxt(child.name);\n         let def = child.def;\n         let def_id = def.def_id();\n-        let vis = match def {\n-            Def::Macro(..) => ty::Visibility::Public,\n-            _ if parent.is_trait() => ty::Visibility::Public,\n-            _ => self.session.cstore.visibility(def_id),\n-        };\n+        let vis = self.session.cstore.visibility(def_id);\n \n         match def {\n             Def::Mod(..) | Def::Enum(..) => {\n-                let module = self.new_module(parent, ModuleKind::Def(def, name), false);\n-                self.define(parent, name, TypeNS, (module, vis, DUMMY_SP, Mark::root()));\n+                let module = self.new_module(parent, ModuleKind::Def(def, ident.name), def_id);\n+                self.define(parent, ident, TypeNS, (module, vis, DUMMY_SP, Mark::root()));\n             }\n-            Def::Variant(..) => {\n-                self.define(parent, name, TypeNS, (def, vis, DUMMY_SP, Mark::root()));\n+            Def::Variant(..) | Def::TyAlias(..) => {\n+                self.define(parent, ident, TypeNS, (def, vis, DUMMY_SP, Mark::root()));\n             }\n-            Def::VariantCtor(..) => {\n-                self.define(parent, name, ValueNS, (def, vis, DUMMY_SP, Mark::root()));\n-            }\n-            Def::Fn(..) |\n-            Def::Static(..) |\n-            Def::Const(..) |\n-            Def::AssociatedConst(..) |\n-            Def::Method(..) => {\n-                self.define(parent, name, ValueNS, (def, vis, DUMMY_SP, Mark::root()));\n+            Def::Fn(..) | Def::Static(..) | Def::Const(..) |\n+            Def::VariantCtor(..) | Def::StructCtor(..) => {\n+                self.define(parent, ident, ValueNS, (def, vis, DUMMY_SP, Mark::root()));\n             }\n             Def::Trait(..) => {\n-                let module = self.new_module(parent, ModuleKind::Def(def, name), false);\n-                self.define(parent, name, TypeNS, (module, vis, DUMMY_SP, Mark::root()));\n-\n-                // If this is a trait, add all the trait item names to the trait info.\n-                let trait_item_def_ids = self.session.cstore.associated_item_def_ids(def_id);\n-                for trait_item_def_id in trait_item_def_ids {\n-                    let trait_item_name = self.session.cstore.def_key(trait_item_def_id)\n-                                              .disambiguated_data.data.get_opt_name()\n-                                              .expect(\"opt_item_name returned None for trait\");\n-                    self.trait_item_map.insert((trait_item_name, def_id), false);\n+                let module_kind = ModuleKind::Def(def, ident.name);\n+                let module = self.new_module(parent, module_kind, parent.normal_ancestor_id);\n+                self.define(parent, ident, TypeNS, (module, vis, DUMMY_SP, Mark::root()));\n+\n+                for child in self.session.cstore.item_children(def_id) {\n+                    let ns = if let Def::AssociatedTy(..) = child.def { TypeNS } else { ValueNS };\n+                    let ident = Ident::with_empty_ctxt(child.name);\n+                    self.define(module, ident, ns, (child.def, ty::Visibility::Public,\n+                                                    DUMMY_SP, Mark::root()));\n+\n+                    let has_self = self.session.cstore.associated_item(child.def.def_id())\n+                                       .map_or(false, |item| item.method_has_self_argument);\n+                    self.trait_item_map.insert((def_id, child.name, ns), (child.def, has_self));\n                 }\n+                module.populated.set(true);\n             }\n-            Def::TyAlias(..) | Def::AssociatedTy(..) => {\n-                self.define(parent, name, TypeNS, (def, vis, DUMMY_SP, Mark::root()));\n-            }\n-            Def::Struct(..) => {\n-                self.define(parent, name, TypeNS, (def, vis, DUMMY_SP, Mark::root()));\n-\n-                // Record field names for error reporting.\n-                let field_names = self.session.cstore.struct_field_names(def_id);\n-                self.insert_field_names(def_id, field_names);\n-            }\n-            Def::StructCtor(..) => {\n-                self.define(parent, name, ValueNS, (def, vis, DUMMY_SP, Mark::root()));\n-            }\n-            Def::Union(..) => {\n-                self.define(parent, name, TypeNS, (def, vis, DUMMY_SP, Mark::root()));\n+            Def::Struct(..) | Def::Union(..) => {\n+                self.define(parent, ident, TypeNS, (def, vis, DUMMY_SP, Mark::root()));\n \n                 // Record field names for error reporting.\n                 let field_names = self.session.cstore.struct_field_names(def_id);\n                 self.insert_field_names(def_id, field_names);\n             }\n             Def::Macro(..) => {\n-                self.define(parent, name, MacroNS, (def, vis, DUMMY_SP, Mark::root()));\n-            }\n-            Def::Local(..) |\n-            Def::PrimTy(..) |\n-            Def::TyParam(..) |\n-            Def::Upvar(..) |\n-            Def::Label(..) |\n-            Def::SelfTy(..) |\n-            Def::Err => {\n-                bug!(\"unexpected definition: {:?}\", def);\n+                self.define(parent, ident, MacroNS, (def, vis, DUMMY_SP, Mark::root()));\n             }\n+            _ => bug!(\"unexpected definition: {:?}\", def)\n         }\n     }\n \n-    fn get_extern_crate_root(&mut self, cnum: CrateNum) -> Module<'b> {\n+    fn get_extern_crate_root(&mut self, cnum: CrateNum) -> Module<'a> {\n         let def_id = DefId { krate: cnum, index: CRATE_DEF_INDEX };\n+        let name = self.session.cstore.crate_name(cnum);\n         let macros_only = self.session.cstore.dep_kind(cnum).macros_only();\n+        let module_kind = ModuleKind::Def(Def::Mod(def_id), name);\n         let arenas = self.arenas;\n         *self.extern_crate_roots.entry((cnum, macros_only)).or_insert_with(|| {\n-            arenas.alloc_module(ModuleS {\n-                populated: Cell::new(false),\n-                ..ModuleS::new(None, ModuleKind::Def(Def::Mod(def_id), keywords::Invalid.name()))\n-            })\n+            arenas.alloc_module(ModuleData::new(None, module_kind, def_id))\n         })\n     }\n \n@@ -532,7 +504,7 @@ impl<'b> Resolver<'b> {\n \n     /// Ensures that the reduced graph rooted at the given external module\n     /// is built, building it if it is not.\n-    pub fn populate_module_if_necessary(&mut self, module: Module<'b>) {\n+    pub fn populate_module_if_necessary(&mut self, module: Module<'a>) {\n         if module.populated.get() { return }\n         for child in self.session.cstore.item_children(module.def_id().unwrap()) {\n             self.build_reduced_graph_for_external_crate_def(module, child);\n@@ -542,7 +514,7 @@ impl<'b> Resolver<'b> {\n \n     fn legacy_import_macro(&mut self,\n                            name: Name,\n-                           binding: &'b NameBinding<'b>,\n+                           binding: &'a NameBinding<'a>,\n                            span: Span,\n                            allow_shadowing: bool) {\n         self.used_crates.insert(binding.def().def_id().krate);\n@@ -555,7 +527,7 @@ impl<'b> Resolver<'b> {\n         }\n     }\n \n-    fn process_legacy_macro_imports(&mut self, item: &Item, module: Module<'b>, expansion: Mark) {\n+    fn process_legacy_macro_imports(&mut self, item: &Item, module: Module<'a>, expansion: Mark) {\n         let allow_shadowing = expansion == Mark::root();\n         let legacy_imports = self.legacy_macro_imports(&item.attrs);\n         let cnum = module.def_id().unwrap().krate;\n@@ -574,12 +546,13 @@ impl<'b> Resolver<'b> {\n         }\n \n         if let Some(span) = legacy_imports.import_all {\n-            module.for_each_child(|name, ns, binding| if ns == MacroNS {\n-                self.legacy_import_macro(name, binding, span, allow_shadowing);\n+            module.for_each_child(|ident, ns, binding| if ns == MacroNS {\n+                self.legacy_import_macro(ident.name, binding, span, allow_shadowing);\n             });\n         } else {\n             for (name, span) in legacy_imports.imports {\n-                let result = self.resolve_name_in_module(module, name, MacroNS, false, None);\n+                let ident = Ident::with_empty_ctxt(name);\n+                let result = self.resolve_ident_in_module(module, ident, MacroNS, false, None);\n                 if let Ok(binding) = result {\n                     self.legacy_import_macro(name, binding, span, allow_shadowing);\n                 } else {\n@@ -591,7 +564,8 @@ impl<'b> Resolver<'b> {\n             let krate = module.def_id().unwrap().krate;\n             self.used_crates.insert(krate);\n             self.session.cstore.export_macros(krate);\n-            let result = self.resolve_name_in_module(module, name, MacroNS, false, None);\n+            let ident = Ident::with_empty_ctxt(name);\n+            let result = self.resolve_ident_in_module(module, ident, MacroNS, false, None);\n             if let Ok(binding) = result {\n                 self.macro_exports.push(Export { name: name, def: binding.def() });\n             } else {\n@@ -696,9 +670,13 @@ impl<'a, 'b> Visitor<'a> for BuildReducedGraphVisitor<'a, 'b> {\n \n     fn visit_item(&mut self, item: &'a Item) {\n         let macro_use = match item.node {\n-            ItemKind::Mac(..) if item.id == ast::DUMMY_NODE_ID => return, // Scope placeholder\n-            ItemKind::Mac(..) => {\n-                return self.legacy_scope = LegacyScope::Expansion(self.visit_invoc(item.id));\n+            ItemKind::Mac(ref mac) => {\n+                if mac.node.path.segments.is_empty() {\n+                    self.legacy_scope = LegacyScope::Expansion(self.visit_invoc(item.id));\n+                } else {\n+                    self.resolver.define_macro(item, &mut self.legacy_scope);\n+                }\n+                return\n             }\n             ItemKind::Mod(..) => self.resolver.contains_macro_use(&item.attrs),\n             _ => false,\n@@ -745,21 +723,18 @@ impl<'a, 'b> Visitor<'a> for BuildReducedGraphVisitor<'a, 'b> {\n \n         // Add the item to the trait info.\n         let item_def_id = self.resolver.definitions.local_def_id(item.id);\n-        let mut is_static_method = false;\n-        let (def, ns) = match item.node {\n-            TraitItemKind::Const(..) => (Def::AssociatedConst(item_def_id), ValueNS),\n-            TraitItemKind::Method(ref sig, _) => {\n-                is_static_method = !sig.decl.has_self();\n-                (Def::Method(item_def_id), ValueNS)\n-            }\n-            TraitItemKind::Type(..) => (Def::AssociatedTy(item_def_id), TypeNS),\n+        let (def, ns, has_self) = match item.node {\n+            TraitItemKind::Const(..) => (Def::AssociatedConst(item_def_id), ValueNS, false),\n+            TraitItemKind::Method(ref sig, _) =>\n+                (Def::Method(item_def_id), ValueNS, sig.decl.has_self()),\n+            TraitItemKind::Type(..) => (Def::AssociatedTy(item_def_id), TypeNS, false),\n             TraitItemKind::Macro(_) => bug!(),  // handled above\n         };\n \n-        self.resolver.trait_item_map.insert((item.ident.name, def_id), is_static_method);\n+        self.resolver.trait_item_map.insert((def_id, item.ident.name, ns), (def, has_self));\n \n         let vis = ty::Visibility::Public;\n-        self.resolver.define(parent, item.ident.name, ns, (def, vis, item.span, self.expansion));\n+        self.resolver.define(parent, item.ident, ns, (def, vis, item.span, self.expansion));\n \n         self.resolver.current_module = parent.parent.unwrap(); // nearest normal ancestor\n         visit::walk_trait_item(self, item);"}, {"sha": "2fada8a9ec212f0e051129115a002eb27d71c34b", "filename": "src/librustc_resolve/diagnostics.rs", "status": "modified", "additions": 26, "deletions": 1, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -860,6 +860,26 @@ match (A, B, C) {\n ```\n \"##,\n \n+E0422: r##\"\n+You are trying to use an identifier that is either undefined or not a struct.\n+Erroneous code example:\n+``` compile_fail,E0422\n+fn main () {\n+    let x = Foo { x: 1, y: 2 };\n+}\n+```\n+In this case, `Foo` is undefined, so it inherently isn't anything, and\n+definitely not a struct.\n+```compile_fail\n+fn main () {\n+    let foo = 1;\n+    let x = foo { x: 1, y: 2 };\n+}\n+```\n+In this case, `foo` is defined, but is not a struct, so Rust can't use it as\n+one.\n+\"##,\n+\n E0423: r##\"\n A `struct` variant name was used like a function name.\n \n@@ -1519,7 +1539,12 @@ register_diagnostics! {\n //  E0419, merged into 531\n //  E0420, merged into 532\n //  E0421, merged into 531\n-//  E0422, merged into 531/532\n     E0531, // unresolved pattern path kind `name`\n //  E0427, merged into 530\n+    E0573,\n+    E0574,\n+    E0575,\n+    E0576,\n+    E0577,\n+    E0578,\n }"}, {"sha": "a0af4c456535990c0b9ce9f7f91a52353bd9584b", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 796, "deletions": 938, "changes": 1734, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445"}, {"sha": "44cc580ad123b727af7b0ef976e66881c1cd3df0", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 84, "deletions": 61, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use {AmbiguityError, Resolver, ResolutionError, resolve_error};\n-use {Module, ModuleKind, NameBinding, NameBindingKind, PathScope, PathResult};\n+use {Module, ModuleKind, NameBinding, NameBindingKind, PathResult};\n use Namespace::{self, MacroNS};\n use build_reduced_graph::BuildReducedGraphVisitor;\n use resolve_imports::ImportResolver;\n@@ -19,16 +19,18 @@ use rustc::hir::map::{self, DefCollector};\n use rustc::ty;\n use std::cell::Cell;\n use std::rc::Rc;\n-use syntax::ast::{self, Name};\n+use syntax::ast::{self, Name, Ident};\n+use syntax::attr;\n use syntax::errors::DiagnosticBuilder;\n use syntax::ext::base::{self, Determinacy, MultiModifier, MultiDecorator};\n-use syntax::ext::base::{NormalTT, SyntaxExtension};\n-use syntax::ext::expand::Expansion;\n+use syntax::ext::base::{NormalTT, Resolver as SyntaxResolver, SyntaxExtension};\n+use syntax::ext::expand::{Expansion, mark_tts};\n use syntax::ext::hygiene::Mark;\n use syntax::ext::tt::macro_rules;\n use syntax::feature_gate::{emit_feature_err, GateIssue};\n use syntax::fold::Folder;\n use syntax::ptr::P;\n+use syntax::symbol::keywords;\n use syntax::util::lev_distance::find_best_match_for_name;\n use syntax::visit::Visitor;\n use syntax_pos::{Span, DUMMY_SP};\n@@ -86,7 +88,7 @@ impl<'a> base::Resolver for Resolver<'a> {\n \n     fn get_module_scope(&mut self, id: ast::NodeId) -> Mark {\n         let mark = Mark::fresh();\n-        let module = self.module_map[&id];\n+        let module = self.module_map[&self.definitions.local_def_id(id)];\n         self.invocations.insert(mark, self.arenas.alloc_invocation_data(InvocationData {\n             module: Cell::new(module),\n             def_index: module.def_id().unwrap().index,\n@@ -104,15 +106,13 @@ impl<'a> base::Resolver for Resolver<'a> {\n             fn fold_path(&mut self, mut path: ast::Path) -> ast::Path {\n                 let ident = path.segments[0].identifier;\n                 if ident.name == \"$crate\" {\n-                    path.global = true;\n+                    path.segments[0].identifier.name = keywords::CrateRoot.name();\n                     let module = self.0.resolve_crate_var(ident.ctxt);\n-                    if module.is_local() {\n-                        path.segments.remove(0);\n-                    } else {\n-                        path.segments[0].identifier = match module.kind {\n-                            ModuleKind::Def(_, name) => ast::Ident::with_empty_ctxt(name),\n+                    if !module.is_local() {\n+                        path.segments.insert(1, match module.kind {\n+                            ModuleKind::Def(_, name) => ast::Ident::with_empty_ctxt(name).into(),\n                             _ => unreachable!(),\n-                        };\n+                        })\n                     }\n                 }\n                 path\n@@ -122,6 +122,10 @@ impl<'a> base::Resolver for Resolver<'a> {\n         EliminateCrateVar(self).fold_item(item).expect_one(\"\")\n     }\n \n+    fn is_whitelisted_legacy_custom_derive(&self, name: Name) -> bool {\n+        self.whitelisted_legacy_custom_derives.contains(&name)\n+    }\n+\n     fn visit_expansion(&mut self, mark: Mark, expansion: &Expansion) {\n         let invocation = self.invocations[&mark];\n         self.collect_def_ids(invocation, expansion);\n@@ -138,34 +142,6 @@ impl<'a> base::Resolver for Resolver<'a> {\n         invocation.expansion.set(visitor.legacy_scope);\n     }\n \n-    fn add_macro(&mut self, scope: Mark, mut def: ast::MacroDef, export: bool) {\n-        if def.ident.name == \"macro_rules\" {\n-            self.session.span_err(def.span, \"user-defined macros may not be named `macro_rules`\");\n-        }\n-\n-        let invocation = self.invocations[&scope];\n-        let binding = self.arenas.alloc_legacy_binding(LegacyBinding {\n-            parent: Cell::new(invocation.legacy_scope.get()),\n-            name: def.ident.name,\n-            ext: Rc::new(macro_rules::compile(&self.session.parse_sess, &def)),\n-            span: def.span,\n-        });\n-        invocation.legacy_scope.set(LegacyScope::Binding(binding));\n-        self.macro_names.insert(def.ident.name);\n-\n-        if export {\n-            def.id = self.next_node_id();\n-            DefCollector::new(&mut self.definitions).with_parent(CRATE_DEF_INDEX, |collector| {\n-                collector.visit_macro_def(&def)\n-            });\n-            self.macro_exports.push(Export {\n-                name: def.ident.name,\n-                def: Def::Macro(self.definitions.local_def_id(def.id)),\n-            });\n-            self.exported_macros.push(def);\n-        }\n-    }\n-\n     fn add_ext(&mut self, ident: ast::Ident, ext: Rc<SyntaxExtension>) {\n         if let NormalTT(..) = *ext {\n             self.macro_names.insert(ident.name);\n@@ -178,7 +154,7 @@ impl<'a> base::Resolver for Resolver<'a> {\n         let binding = self.arenas.alloc_name_binding(NameBinding {\n             kind: NameBindingKind::Def(Def::Macro(def_id)),\n             span: DUMMY_SP,\n-            vis: ty::Visibility::PrivateExternal,\n+            vis: ty::Visibility::Invisible,\n             expansion: Mark::root(),\n         });\n         self.builtin_macros.insert(ident.name, binding);\n@@ -209,44 +185,46 @@ impl<'a> base::Resolver for Resolver<'a> {\n \n     fn resolve_macro(&mut self, scope: Mark, path: &ast::Path, force: bool)\n                      -> Result<Rc<SyntaxExtension>, Determinacy> {\n-        let ast::Path { ref segments, global, span } = *path;\n-        if segments.iter().any(|segment| !segment.parameters.is_empty()) {\n+        let ast::Path { ref segments, span } = *path;\n+        if segments.iter().any(|segment| segment.parameters.is_some()) {\n             let kind =\n-                if segments.last().unwrap().parameters.is_empty() { \"module\" } else { \"macro\" };\n+                if segments.last().unwrap().parameters.is_some() { \"macro\" } else { \"module\" };\n             let msg = format!(\"type parameters are not allowed on {}s\", kind);\n             self.session.span_err(path.span, &msg);\n             return Err(Determinacy::Determined);\n         }\n \n-        let path_scope = if global { PathScope::Global } else { PathScope::Lexical };\n         let path: Vec<_> = segments.iter().map(|seg| seg.identifier).collect();\n         let invocation = self.invocations[&scope];\n         self.current_module = invocation.module.get();\n \n-        if path.len() > 1 || global {\n+        if path.len() > 1 {\n             if !self.use_extern_macros {\n                 let msg = \"non-ident macro paths are experimental\";\n                 let feature = \"use_extern_macros\";\n                 emit_feature_err(&self.session.parse_sess, feature, span, GateIssue::Language, msg);\n                 return Err(Determinacy::Determined);\n             }\n \n-            let ext = match self.resolve_path(&path, path_scope, Some(MacroNS), None) {\n-                PathResult::NonModule(path_res) => Ok(self.get_macro(path_res.base_def)),\n+            let ext = match self.resolve_path(&path, Some(MacroNS), None) {\n+                PathResult::NonModule(path_res) => match path_res.base_def {\n+                    Def::Err => Err(Determinacy::Determined),\n+                    def @ _ => Ok(self.get_macro(def)),\n+                },\n                 PathResult::Module(..) => unreachable!(),\n                 PathResult::Indeterminate if !force => return Err(Determinacy::Undetermined),\n                 _ => Err(Determinacy::Determined),\n             };\n             self.current_module.macro_resolutions.borrow_mut()\n-                .push((path.into_boxed_slice(), path_scope, span));\n+                .push((path.into_boxed_slice(), span));\n             return ext;\n         }\n \n         let name = path[0].name;\n         let result = match self.resolve_legacy_scope(&invocation.legacy_scope, name, false) {\n             Some(MacroBinding::Legacy(binding)) => Ok(binding.ext.clone()),\n             Some(MacroBinding::Modern(binding)) => Ok(binding.get_macro(self)),\n-            None => match self.resolve_lexical_macro_path_segment(name, MacroNS, None) {\n+            None => match self.resolve_lexical_macro_path_segment(path[0], MacroNS, None) {\n                 Ok(binding) => Ok(binding.get_macro(self)),\n                 Err(Determinacy::Undetermined) if !force => return Err(Determinacy::Undetermined),\n                 _ => {\n@@ -260,7 +238,7 @@ impl<'a> base::Resolver for Resolver<'a> {\n         };\n \n         if self.use_extern_macros {\n-            self.current_module.legacy_macro_resolutions.borrow_mut().push((scope, name, span));\n+            self.current_module.legacy_macro_resolutions.borrow_mut().push((scope, path[0], span));\n         }\n         result\n     }\n@@ -269,7 +247,7 @@ impl<'a> base::Resolver for Resolver<'a> {\n impl<'a> Resolver<'a> {\n     // Resolve the initial segment of a non-global macro path (e.g. `foo` in `foo::bar!();`)\n     pub fn resolve_lexical_macro_path_segment(&mut self,\n-                                              name: Name,\n+                                              ident: Ident,\n                                               ns: Namespace,\n                                               record_used: Option<Span>)\n                                               -> Result<&'a NameBinding<'a>, Determinacy> {\n@@ -278,16 +256,18 @@ impl<'a> Resolver<'a> {\n         loop {\n             // Since expanded macros may not shadow the lexical scope (enforced below),\n             // we can ignore unresolved invocations (indicated by the penultimate argument).\n-            match self.resolve_name_in_module(module, name, ns, true, record_used) {\n+            match self.resolve_ident_in_module(module, ident, ns, true, record_used) {\n                 Ok(binding) => {\n                     let span = match record_used {\n                         Some(span) => span,\n                         None => return Ok(binding),\n                     };\n                     match potential_expanded_shadower {\n                         Some(shadower) if shadower.def() != binding.def() => {\n+                            let name = ident.name;\n                             self.ambiguity_errors.push(AmbiguityError {\n                                 span: span, name: name, b1: shadower, b2: binding, lexical: true,\n+                                legacy: false,\n                             });\n                             return Ok(shadower);\n                         }\n@@ -373,8 +353,8 @@ impl<'a> Resolver<'a> {\n \n     pub fn finalize_current_module_macro_resolutions(&mut self) {\n         let module = self.current_module;\n-        for &(ref path, scope, span) in module.macro_resolutions.borrow().iter() {\n-            match self.resolve_path(path, scope, Some(MacroNS), Some(span)) {\n+        for &(ref path, span) in module.macro_resolutions.borrow().iter() {\n+            match self.resolve_path(path, Some(MacroNS), Some(span)) {\n                 PathResult::NonModule(_) => {},\n                 PathResult::Failed(msg, _) => {\n                     resolve_error(self, span, ResolutionError::FailedToResolve(&msg));\n@@ -383,10 +363,10 @@ impl<'a> Resolver<'a> {\n             }\n         }\n \n-        for &(mark, name, span) in module.legacy_macro_resolutions.borrow().iter() {\n+        for &(mark, ident, span) in module.legacy_macro_resolutions.borrow().iter() {\n             let legacy_scope = &self.invocations[&mark].legacy_scope;\n-            let legacy_resolution = self.resolve_legacy_scope(legacy_scope, name, true);\n-            let resolution = self.resolve_lexical_macro_path_segment(name, MacroNS, Some(span));\n+            let legacy_resolution = self.resolve_legacy_scope(legacy_scope, ident.name, true);\n+            let resolution = self.resolve_lexical_macro_path_segment(ident, MacroNS, Some(span));\n             let (legacy_resolution, resolution) = match (legacy_resolution, resolution) {\n                 (Some(legacy_resolution), Ok(resolution)) => (legacy_resolution, resolution),\n                 _ => continue,\n@@ -396,9 +376,9 @@ impl<'a> Resolver<'a> {\n                 MacroBinding::Modern(binding) => (binding.span, \"imported\"),\n                 MacroBinding::Legacy(binding) => (binding.span, \"defined\"),\n             };\n-            let msg1 = format!(\"`{}` could resolve to the macro {} here\", name, participle);\n-            let msg2 = format!(\"`{}` could also resolve to the macro imported here\", name);\n-            self.session.struct_span_err(span, &format!(\"`{}` is ambiguous\", name))\n+            let msg1 = format!(\"`{}` could resolve to the macro {} here\", ident, participle);\n+            let msg2 = format!(\"`{}` could also resolve to the macro imported here\", ident);\n+            self.session.struct_span_err(span, &format!(\"`{}` is ambiguous\", ident))\n                 .span_note(legacy_span, &msg1)\n                 .span_note(resolution.span, &msg2)\n                 .emit();\n@@ -442,4 +422,47 @@ impl<'a> Resolver<'a> {\n             expansion.visit_with(def_collector)\n         });\n     }\n+\n+    pub fn define_macro(&mut self, item: &ast::Item, legacy_scope: &mut LegacyScope<'a>) {\n+        let tts = match item.node {\n+            ast::ItemKind::Mac(ref mac) => &mac.node.tts,\n+            _ => unreachable!(),\n+        };\n+\n+        if item.ident.name == \"macro_rules\" {\n+            self.session.span_err(item.span, \"user-defined macros may not be named `macro_rules`\");\n+        }\n+\n+        let mark = Mark::from_placeholder_id(item.id);\n+        let invocation = self.invocations[&mark];\n+        invocation.module.set(self.current_module);\n+\n+        let mut def = ast::MacroDef {\n+            ident: item.ident,\n+            attrs: item.attrs.clone(),\n+            id: ast::DUMMY_NODE_ID,\n+            span: item.span,\n+            body: mark_tts(tts, mark),\n+        };\n+\n+        *legacy_scope = LegacyScope::Binding(self.arenas.alloc_legacy_binding(LegacyBinding {\n+            parent: Cell::new(*legacy_scope),\n+            name: def.ident.name,\n+            ext: Rc::new(macro_rules::compile(&self.session.parse_sess, &def)),\n+            span: def.span,\n+        }));\n+        self.macro_names.insert(def.ident.name);\n+\n+        if attr::contains_name(&def.attrs, \"macro_export\") {\n+            def.id = self.next_node_id();\n+            DefCollector::new(&mut self.definitions).with_parent(CRATE_DEF_INDEX, |collector| {\n+                collector.visit_macro_def(&def)\n+            });\n+            self.macro_exports.push(Export {\n+                name: def.ident.name,\n+                def: Def::Macro(self.definitions.local_def_id(def.id)),\n+            });\n+            self.exported_macros.push(def);\n+        }\n+    }\n }"}, {"sha": "41d8f16b88dfd4849200d72eaf157f564c717e30", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 127, "deletions": 101, "changes": 228, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -12,18 +12,20 @@ use self::ImportDirectiveSubclass::*;\n \n use {AmbiguityError, Module, PerNS};\n use Namespace::{self, TypeNS, MacroNS};\n-use {NameBinding, NameBindingKind, PathResult, PathScope, PrivacyError, ToNameBinding};\n+use {NameBinding, NameBindingKind, PathResult, PrivacyError};\n use Resolver;\n use {names_to_string, module_to_string};\n use {resolve_error, ResolutionError};\n \n use rustc::ty;\n use rustc::lint::builtin::PRIVATE_IN_PUBLIC;\n+use rustc::hir::def_id::DefId;\n use rustc::hir::def::*;\n \n-use syntax::ast::{Ident, NodeId, Name};\n+use syntax::ast::{Ident, NodeId};\n use syntax::ext::base::Determinacy::{self, Determined, Undetermined};\n use syntax::ext::hygiene::Mark;\n+use syntax::parse::token;\n use syntax::symbol::keywords;\n use syntax::util::lev_distance::find_best_match_for_name;\n use syntax_pos::Span;\n@@ -35,8 +37,8 @@ use std::mem;\n #[derive(Clone, Debug)]\n pub enum ImportDirectiveSubclass<'a> {\n     SingleImport {\n-        target: Name,\n-        source: Name,\n+        target: Ident,\n+        source: Ident,\n         result: PerNS<Cell<Result<&'a NameBinding<'a>, Determinacy>>>,\n     },\n     GlobImport {\n@@ -126,33 +128,32 @@ impl<'a> NameResolution<'a> {\n }\n \n impl<'a> Resolver<'a> {\n-    fn resolution(&self, module: Module<'a>, name: Name, ns: Namespace)\n+    fn resolution(&self, module: Module<'a>, ident: Ident, ns: Namespace)\n                   -> &'a RefCell<NameResolution<'a>> {\n-        *module.resolutions.borrow_mut().entry((name, ns))\n+        let ident = ident.unhygienize();\n+        *module.resolutions.borrow_mut().entry((ident, ns))\n                .or_insert_with(|| self.arenas.alloc_name_resolution())\n     }\n \n-    /// Attempts to resolve the supplied name in the given module for the given namespace.\n-    /// If successful, returns the binding corresponding to the name.\n+    /// Attempts to resolve `ident` in namespaces `ns` of `module`.\n     /// Invariant: if `record_used` is `Some`, import resolution must be complete.\n-    pub fn resolve_name_in_module(&mut self,\n-                                  module: Module<'a>,\n-                                  name: Name,\n-                                  ns: Namespace,\n-                                  ignore_unresolved_invocations: bool,\n-                                  record_used: Option<Span>)\n-                                  -> Result<&'a NameBinding<'a>, Determinacy> {\n+    pub fn resolve_ident_in_module(&mut self,\n+                                   module: Module<'a>,\n+                                   ident: Ident,\n+                                   ns: Namespace,\n+                                   ignore_unresolved_invocations: bool,\n+                                   record_used: Option<Span>)\n+                                   -> Result<&'a NameBinding<'a>, Determinacy> {\n         self.populate_module_if_necessary(module);\n \n-        let resolution = self.resolution(module, name, ns);\n-        let resolution = match resolution.borrow_state() {\n-            ::std::cell::BorrowState::Unused => resolution.borrow_mut(),\n-            _ => return Err(Determined), // This happens when there is a cycle of imports\n-        };\n+        let resolution = self.resolution(module, ident, ns)\n+            .try_borrow_mut()\n+            .map_err(|_| Determined)?; // This happens when there is a cycle of imports\n \n         if let Some(span) = record_used {\n             if let Some(binding) = resolution.binding {\n                 if let Some(shadowed_glob) = resolution.shadows_glob {\n+                    let name = ident.name;\n                     // If we ignore unresolved invocations, we must forbid\n                     // expanded shadowing to avoid time travel.\n                     if ignore_unresolved_invocations &&\n@@ -161,14 +162,15 @@ impl<'a> Resolver<'a> {\n                        binding.def() != shadowed_glob.def() {\n                         self.ambiguity_errors.push(AmbiguityError {\n                             span: span, name: name, lexical: false, b1: binding, b2: shadowed_glob,\n+                            legacy: false,\n                         });\n                     }\n                 }\n-                if self.record_use(name, ns, binding, span) {\n+                if self.record_use(ident, ns, binding, span) {\n                     return Ok(self.dummy_binding);\n                 }\n                 if !self.is_accessible(binding.vis) {\n-                    self.privacy_errors.push(PrivacyError(span, name, binding));\n+                    self.privacy_errors.push(PrivacyError(span, ident.name, binding));\n                 }\n             }\n \n@@ -196,11 +198,11 @@ impl<'a> Resolver<'a> {\n                     Some(module) => module,\n                     None => return Err(Undetermined),\n                 };\n-                let name = match directive.subclass {\n+                let ident = match directive.subclass {\n                     SingleImport { source, .. } => source,\n                     _ => unreachable!(),\n                 };\n-                match self.resolve_name_in_module(module, name, ns, false, None) {\n+                match self.resolve_ident_in_module(module, ident, ns, false, None) {\n                     Err(Determined) => {}\n                     _ => return Err(Undetermined),\n                 }\n@@ -222,7 +224,7 @@ impl<'a> Resolver<'a> {\n         for directive in module.globs.borrow().iter() {\n             if self.is_accessible(directive.vis.get()) {\n                 if let Some(module) = directive.imported_module.get() {\n-                    let result = self.resolve_name_in_module(module, name, ns, false, None);\n+                    let result = self.resolve_ident_in_module(module, ident, ns, false, None);\n                     if let Err(Undetermined) = result {\n                         return Err(Undetermined);\n                     }\n@@ -273,8 +275,8 @@ impl<'a> Resolver<'a> {\n \n     // Given a binding and an import directive that resolves to it,\n     // return the corresponding binding defined by the import directive.\n-    pub fn import(&mut self, binding: &'a NameBinding<'a>, directive: &'a ImportDirective<'a>)\n-                  -> NameBinding<'a> {\n+    pub fn import(&self, binding: &'a NameBinding<'a>, directive: &'a ImportDirective<'a>)\n+                  -> &'a NameBinding<'a> {\n         let vis = if binding.pseudo_vis().is_at_least(directive.vis.get(), self) ||\n                      !directive.is_glob() && binding.is_extern_crate() { // c.f. `PRIVATE_IN_PUBLIC`\n             directive.vis.get()\n@@ -288,7 +290,7 @@ impl<'a> Resolver<'a> {\n             }\n         }\n \n-        NameBinding {\n+        self.arenas.alloc_name_binding(NameBinding {\n             kind: NameBindingKind::Import {\n                 binding: binding,\n                 directive: directive,\n@@ -297,24 +299,25 @@ impl<'a> Resolver<'a> {\n             span: directive.span,\n             vis: vis,\n             expansion: directive.expansion,\n-        }\n+        })\n     }\n \n     // Define the name or return the existing binding if there is a collision.\n-    pub fn try_define<T>(&mut self, module: Module<'a>, name: Name, ns: Namespace, binding: T)\n-                         -> Result<(), &'a NameBinding<'a>>\n-        where T: ToNameBinding<'a>\n-    {\n-        let binding = self.arenas.alloc_name_binding(binding.to_name_binding());\n-        self.update_resolution(module, name, ns, |this, resolution| {\n+    pub fn try_define(&mut self,\n+                      module: Module<'a>,\n+                      ident: Ident,\n+                      ns: Namespace,\n+                      binding: &'a NameBinding<'a>)\n+                      -> Result<(), &'a NameBinding<'a>> {\n+        self.update_resolution(module, ident, ns, |this, resolution| {\n             if let Some(old_binding) = resolution.binding {\n                 if binding.is_glob_import() {\n                     if !old_binding.is_glob_import() &&\n                        !(ns == MacroNS && old_binding.expansion != Mark::root()) {\n                         resolution.shadows_glob = Some(binding);\n                     } else if binding.def() != old_binding.def() {\n                         resolution.binding = Some(this.ambiguity(old_binding, binding));\n-                    } else if !old_binding.vis.is_at_least(binding.vis, this) {\n+                    } else if !old_binding.vis.is_at_least(binding.vis, &*this) {\n                         // We are glob-importing the same item but with greater visibility.\n                         resolution.binding = Some(binding);\n                     }\n@@ -337,10 +340,10 @@ impl<'a> Resolver<'a> {\n         })\n     }\n \n-    pub fn ambiguity(&mut self, b1: &'a NameBinding<'a>, b2: &'a NameBinding<'a>)\n-                 -> &'a NameBinding<'a> {\n+    pub fn ambiguity(&self, b1: &'a NameBinding<'a>, b2: &'a NameBinding<'a>)\n+                     -> &'a NameBinding<'a> {\n         self.arenas.alloc_name_binding(NameBinding {\n-            kind: NameBindingKind::Ambiguity { b1: b1, b2: b2 },\n+            kind: NameBindingKind::Ambiguity { b1: b1, b2: b2, legacy: false },\n             vis: if b1.vis.is_at_least(b2.vis, self) { b1.vis } else { b2.vis },\n             span: b1.span,\n             expansion: Mark::root(),\n@@ -349,13 +352,14 @@ impl<'a> Resolver<'a> {\n \n     // Use `f` to mutate the resolution of the name in the module.\n     // If the resolution becomes a success, define it in the module's glob importers.\n-    fn update_resolution<T, F>(&mut self, module: Module<'a>, name: Name, ns: Namespace, f: F) -> T\n+    fn update_resolution<T, F>(&mut self, module: Module<'a>, ident: Ident, ns: Namespace, f: F)\n+                               -> T\n         where F: FnOnce(&mut Resolver<'a>, &mut NameResolution<'a>) -> T\n     {\n         // Ensure that `resolution` isn't borrowed when defining in the module's glob importers,\n         // during which the resolution might end up getting re-defined via a glob cycle.\n         let (binding, t) = {\n-            let mut resolution = &mut *self.resolution(module, name, ns).borrow_mut();\n+            let mut resolution = &mut *self.resolution(module, ident, ns).borrow_mut();\n             let old_binding = resolution.binding();\n \n             let t = f(self, resolution);\n@@ -374,7 +378,7 @@ impl<'a> Resolver<'a> {\n         for directive in module.glob_importers.borrow_mut().iter() {\n             if self.is_accessible_from(binding.vis, directive.parent) {\n                 let imported_binding = self.import(binding, directive);\n-                let _ = self.try_define(directive.parent, name, ns, imported_binding);\n+                let _ = self.try_define(directive.parent, ident, ns, imported_binding);\n             }\n         }\n \n@@ -388,7 +392,7 @@ impl<'a> Resolver<'a> {\n             let dummy_binding = self.dummy_binding;\n             let dummy_binding = self.import(dummy_binding, directive);\n             self.per_ns(|this, ns| {\n-                let _ = this.try_define(directive.parent, target, ns, dummy_binding.clone());\n+                let _ = this.try_define(directive.parent, target, ns, dummy_binding);\n             });\n         }\n     }\n@@ -411,9 +415,9 @@ impl<'a, 'b: 'a> ::std::ops::DerefMut for ImportResolver<'a, 'b> {\n     }\n }\n \n-impl<'a, 'b: 'a> ty::NodeIdTree for ImportResolver<'a, 'b> {\n-    fn is_descendant_of(&self, node: NodeId, ancestor: NodeId) -> bool {\n-        self.resolver.is_descendant_of(node, ancestor)\n+impl<'a, 'b: 'a> ty::DefIdTree for &'a ImportResolver<'a, 'b> {\n+    fn parent(self, id: DefId) -> Option<DefId> {\n+        self.resolver.parent(id)\n     }\n }\n \n@@ -486,8 +490,8 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n             let vis = directive.vis.get();\n             // For better failure detection, pretend that the import will not define any names\n             // while resolving its module path.\n-            directive.vis.set(ty::Visibility::PrivateExternal);\n-            let result = self.resolve_path(&directive.module_path, PathScope::Import, None, None);\n+            directive.vis.set(ty::Visibility::Invisible);\n+            let result = self.resolve_path(&directive.module_path, None, None);\n             directive.vis.set(vis);\n \n             match result {\n@@ -510,15 +514,16 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n         let mut indeterminate = false;\n         self.per_ns(|this, ns| {\n             if let Err(Undetermined) = result[ns].get() {\n-                result[ns].set(this.resolve_name_in_module(module, source, ns, false, None));\n+                result[ns].set(this.resolve_ident_in_module(module, source, ns, false, None));\n             } else {\n                 return\n             };\n \n+            let parent = directive.parent;\n             match result[ns].get() {\n                 Err(Undetermined) => indeterminate = true,\n                 Err(Determined) => {\n-                    this.update_resolution(directive.parent, target, ns, |_, resolution| {\n+                    this.update_resolution(parent, target, ns, |_, resolution| {\n                         resolution.single_imports.directive_failed()\n                     });\n                 }\n@@ -533,10 +538,9 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n                 }\n                 Ok(binding) => {\n                     let imported_binding = this.import(binding, directive);\n-                    let conflict = this.try_define(directive.parent, target, ns, imported_binding);\n+                    let conflict = this.try_define(parent, target, ns, imported_binding);\n                     if let Err(old_binding) = conflict {\n-                        let binding = &this.import(binding, directive);\n-                        this.report_conflict(directive.parent, target, ns, binding, old_binding);\n+                        this.report_conflict(parent, target, ns, imported_binding, old_binding);\n                     }\n                 }\n             }\n@@ -550,32 +554,34 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n         self.current_module = directive.parent;\n \n         let ImportDirective { ref module_path, span, .. } = *directive;\n-        let module_result = self.resolve_path(&module_path, PathScope::Import, None, Some(span));\n+        let module_result = self.resolve_path(&module_path, None, Some(span));\n         let module = match module_result {\n             PathResult::Module(module) => module,\n             PathResult::Failed(msg, _) => {\n-                let mut path = vec![keywords::SelfValue.ident()];\n-                path.extend(module_path);\n-                let result = self.resolve_path(&path, PathScope::Import, None, None);\n-                return if let PathResult::Module(..) = result {\n-                    Some(format!(\"Did you mean `self::{}`?\", &names_to_string(module_path)))\n+                let (mut self_path, mut self_result) = (module_path.clone(), None);\n+                if !self_path.is_empty() && !token::Ident(self_path[0]).is_path_segment_keyword() {\n+                    self_path[0].name = keywords::SelfValue.name();\n+                    self_result = Some(self.resolve_path(&self_path, None, None));\n+                }\n+                return if let Some(PathResult::Module(..)) = self_result {\n+                    Some(format!(\"Did you mean `{}`?\", names_to_string(&self_path)))\n                 } else {\n                     Some(msg)\n                 };\n             },\n             _ => return None,\n         };\n \n-        let (name, result) = match directive.subclass {\n+        let (ident, result) = match directive.subclass {\n             SingleImport { source, ref result, .. } => (source, result),\n             GlobImport { .. } if module.def_id() == directive.parent.def_id() => {\n                 // Importing a module into itself is not allowed.\n                 return Some(\"Cannot glob-import a module into itself.\".to_string());\n             }\n             GlobImport { is_prelude, ref max_vis } => {\n                 if !is_prelude &&\n-                   max_vis.get() != ty::Visibility::PrivateExternal && // Allow empty globs.\n-                   !max_vis.get().is_at_least(directive.vis.get(), self) {\n+                   max_vis.get() != ty::Visibility::Invisible && // Allow empty globs.\n+                   !max_vis.get().is_at_least(directive.vis.get(), &*self) {\n                     let msg = \"A non-empty glob must import something with the glob's visibility\";\n                     self.session.span_err(directive.span, msg);\n                 }\n@@ -588,8 +594,8 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n         self.per_ns(|this, ns| {\n             if let Ok(binding) = result[ns].get() {\n                 all_ns_err = false;\n-                if this.record_use(name, ns, binding, directive.span) {\n-                    this.resolution(module, name, ns).borrow_mut().binding =\n+                if this.record_use(ident, ns, binding, directive.span) {\n+                    this.resolution(module, ident, ns).borrow_mut().binding =\n                         Some(this.dummy_binding);\n                 }\n             }\n@@ -598,35 +604,36 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n         if all_ns_err {\n             let mut all_ns_failed = true;\n             self.per_ns(|this, ns| {\n-                match this.resolve_name_in_module(module, name, ns, false, Some(span)) {\n+                match this.resolve_ident_in_module(module, ident, ns, false, Some(span)) {\n                     Ok(_) => all_ns_failed = false,\n                     _ => {}\n                 }\n             });\n \n             return if all_ns_failed {\n                 let resolutions = module.resolutions.borrow();\n-                let names = resolutions.iter().filter_map(|(&(ref n, _), resolution)| {\n-                    if *n == name { return None; } // Never suggest the same name\n+                let names = resolutions.iter().filter_map(|(&(ref i, _), resolution)| {\n+                    if *i == ident { return None; } // Never suggest the same name\n                     match *resolution.borrow() {\n-                        NameResolution { binding: Some(_), .. } => Some(n),\n+                        NameResolution { binding: Some(_), .. } => Some(&i.name),\n                         NameResolution { single_imports: SingleImports::None, .. } => None,\n-                        _ => Some(n),\n+                        _ => Some(&i.name),\n                     }\n                 });\n-                let lev_suggestion = match find_best_match_for_name(names, &name.as_str(), None) {\n-                    Some(name) => format!(\". Did you mean to use `{}`?\", name),\n-                    None => \"\".to_owned(),\n-                };\n+                let lev_suggestion =\n+                    match find_best_match_for_name(names, &ident.name.as_str(), None) {\n+                        Some(name) => format!(\". Did you mean to use `{}`?\", name),\n+                        None => \"\".to_owned(),\n+                    };\n                 let module_str = module_to_string(module);\n                 let msg = if &module_str == \"???\" {\n-                    format!(\"no `{}` in the root{}\", name, lev_suggestion)\n+                    format!(\"no `{}` in the root{}\", ident, lev_suggestion)\n                 } else {\n-                    format!(\"no `{}` in `{}`{}\", name, module_str, lev_suggestion)\n+                    format!(\"no `{}` in `{}`{}\", ident, module_str, lev_suggestion)\n                 };\n                 Some(msg)\n             } else {\n-                // `resolve_name_in_module` reported a privacy error.\n+                // `resolve_ident_in_module` reported a privacy error.\n                 self.import_dummy_binding(directive);\n                 None\n             }\n@@ -637,7 +644,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n         self.per_ns(|this, ns| {\n             if let Ok(binding) = result[ns].get() {\n                 let vis = directive.vis.get();\n-                if !binding.pseudo_vis().is_at_least(vis, this) {\n+                if !binding.pseudo_vis().is_at_least(vis, &*this) {\n                     reexport_error = Some((ns, binding));\n                 } else {\n                     any_successful_reexport = true;\n@@ -651,18 +658,18 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n             if ns == TypeNS && binding.is_extern_crate() {\n                 let msg = format!(\"extern crate `{}` is private, and cannot be reexported \\\n                                    (error E0364), consider declaring with `pub`\",\n-                                   name);\n+                                   ident);\n                 self.session.add_lint(PRIVATE_IN_PUBLIC, directive.id, directive.span, msg);\n             } else if ns == TypeNS {\n                 struct_span_err!(self.session, directive.span, E0365,\n-                                 \"`{}` is private, and cannot be reexported\", name)\n-                    .span_label(directive.span, &format!(\"reexport of private `{}`\", name))\n-                    .note(&format!(\"consider declaring type or module `{}` with `pub`\", name))\n+                                 \"`{}` is private, and cannot be reexported\", ident)\n+                    .span_label(directive.span, &format!(\"reexport of private `{}`\", ident))\n+                    .note(&format!(\"consider declaring type or module `{}` with `pub`\", ident))\n                     .emit();\n             } else {\n-                let msg = format!(\"`{}` is private, and cannot be reexported\", name);\n+                let msg = format!(\"`{}` is private, and cannot be reexported\", ident);\n                 let note_msg =\n-                    format!(\"consider marking `{}` as `pub` in the imported module\", name);\n+                    format!(\"consider marking `{}` as `pub` in the imported module\", ident);\n                 struct_span_err!(self.session, directive.span, E0364, \"{}\", &msg)\n                     .span_note(directive.span, &note_msg)\n                     .emit();\n@@ -699,21 +706,18 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n \n         // Ensure that `resolutions` isn't borrowed during `try_define`,\n         // since it might get updated via a glob cycle.\n-        let bindings = module.resolutions.borrow().iter().filter_map(|(name, resolution)| {\n-            resolution.borrow().binding().map(|binding| (*name, binding))\n+        let bindings = module.resolutions.borrow().iter().filter_map(|(&ident, resolution)| {\n+            resolution.borrow().binding().map(|binding| (ident, binding))\n         }).collect::<Vec<_>>();\n-        for ((name, ns), binding) in bindings {\n+        for ((ident, ns), binding) in bindings {\n             if binding.pseudo_vis() == ty::Visibility::Public || self.is_accessible(binding.vis) {\n                 let imported_binding = self.import(binding, directive);\n-                let _ = self.try_define(directive.parent, name, ns, imported_binding);\n+                let _ = self.try_define(directive.parent, ident, ns, imported_binding);\n             }\n         }\n \n         // Record the destination of this import\n-        if let Some(did) = module.def_id() {\n-            let resolution = PathResolution::new(Def::Mod(did));\n-            self.def_map.insert(directive.id, resolution);\n-        }\n+        self.record_def(directive.id, PathResolution::new(module.def().unwrap()));\n     }\n \n     // Miscellaneous post-processing, including recording reexports, reporting conflicts,\n@@ -727,8 +731,8 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n             reexports = mem::replace(&mut self.macro_exports, Vec::new());\n         }\n \n-        for (&(name, ns), resolution) in module.resolutions.borrow().iter() {\n-            let resolution = resolution.borrow();\n+        for (&(ident, ns), resolution) in module.resolutions.borrow().iter() {\n+            let resolution = &mut *resolution.borrow_mut();\n             let binding = match resolution.binding {\n                 Some(binding) => binding,\n                 None => continue,\n@@ -741,18 +745,38 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n                     if !def.def_id().is_local() {\n                         self.session.cstore.export_macros(def.def_id().krate);\n                     }\n-                    reexports.push(Export { name: name, def: def });\n+                    reexports.push(Export { name: ident.name, def: def });\n                 }\n             }\n \n-            if let NameBindingKind::Import { binding: orig_binding, directive, .. } = binding.kind {\n-                if ns == TypeNS && orig_binding.is_variant() &&\n-                   !orig_binding.vis.is_at_least(binding.vis, self) {\n-                    let msg = format!(\"variant `{}` is private, and cannot be reexported \\\n-                                       (error E0364), consider declaring its enum as `pub`\",\n-                                      name);\n-                    self.session.add_lint(PRIVATE_IN_PUBLIC, directive.id, binding.span, msg);\n+            match binding.kind {\n+                NameBindingKind::Import { binding: orig_binding, directive, .. } => {\n+                    if ns == TypeNS && orig_binding.is_variant() &&\n+                       !orig_binding.vis.is_at_least(binding.vis, &*self) {\n+                        let msg = format!(\"variant `{}` is private, and cannot be reexported \\\n+                                           (error E0364), consider declaring its enum as `pub`\",\n+                                          ident);\n+                        self.session.add_lint(PRIVATE_IN_PUBLIC, directive.id, binding.span, msg);\n+                    }\n+                }\n+                NameBindingKind::Ambiguity { b1, b2, .. }\n+                        if b1.is_glob_import() && b2.is_glob_import() => {\n+                    let (orig_b1, orig_b2) = match (&b1.kind, &b2.kind) {\n+                        (&NameBindingKind::Import { binding: b1, .. },\n+                         &NameBindingKind::Import { binding: b2, .. }) => (b1, b2),\n+                        _ => continue,\n+                    };\n+                    let (b1, b2) = match (orig_b1.vis, orig_b2.vis) {\n+                        (ty::Visibility::Public, ty::Visibility::Public) => continue,\n+                        (ty::Visibility::Public, _) => (b1, b2),\n+                        (_, ty::Visibility::Public) => (b2, b1),\n+                        _ => continue,\n+                    };\n+                    resolution.binding = Some(self.arenas.alloc_name_binding(NameBinding {\n+                        kind: NameBindingKind::Ambiguity { b1: b1, b2: b2, legacy: true }, ..*b1\n+                    }));\n                 }\n+                _ => {}\n             }\n         }\n \n@@ -766,6 +790,8 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n }\n \n fn import_path_to_string(names: &[Ident], subclass: &ImportDirectiveSubclass) -> String {\n+    let global = !names.is_empty() && names[0].name == keywords::CrateRoot.name();\n+    let names = if global { &names[1..] } else { names };\n     if names.is_empty() {\n         import_directive_subclass_to_string(subclass)\n     } else {"}, {"sha": "0a6281bf8c54ccaf4357f956fc97844fe136a41d", "filename": "src/librustc_save_analysis/data.rs", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_save_analysis%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_save_analysis%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdata.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -135,6 +135,7 @@ pub struct EnumData {\n     pub variants: Vec<NodeId>,\n     pub visibility: Visibility,\n     pub docs: String,\n+    pub sig: Signature,\n }\n \n /// Data for extern crates.\n@@ -169,6 +170,7 @@ pub struct FunctionData {\n     pub visibility: Visibility,\n     pub parent: Option<DefId>,\n     pub docs: String,\n+    pub sig: Signature,\n }\n \n /// Data about a function call.\n@@ -253,6 +255,7 @@ pub struct MethodData {\n     pub parent: Option<DefId>,\n     pub visibility: Visibility,\n     pub docs: String,\n+    pub sig: Signature,\n }\n \n /// Data for modules.\n@@ -267,6 +270,7 @@ pub struct ModData {\n     pub items: Vec<NodeId>,\n     pub visibility: Visibility,\n     pub docs: String,\n+    pub sig: Signature,\n }\n \n /// Data for a reference to a module.\n@@ -290,6 +294,7 @@ pub struct StructData {\n     pub fields: Vec<NodeId>,\n     pub visibility: Visibility,\n     pub docs: String,\n+    pub sig: Signature,\n }\n \n #[derive(Debug, RustcEncodable)]\n@@ -303,6 +308,7 @@ pub struct StructVariantData {\n     pub scope: NodeId,\n     pub parent: Option<DefId>,\n     pub docs: String,\n+    pub sig: Signature,\n }\n \n #[derive(Debug, RustcEncodable)]\n@@ -316,6 +322,7 @@ pub struct TraitData {\n     pub items: Vec<NodeId>,\n     pub visibility: Visibility,\n     pub docs: String,\n+    pub sig: Signature,\n }\n \n #[derive(Debug, RustcEncodable)]\n@@ -329,6 +336,7 @@ pub struct TupleVariantData {\n     pub scope: NodeId,\n     pub parent: Option<DefId>,\n     pub docs: String,\n+    pub sig: Signature,\n }\n \n /// Data for a typedef.\n@@ -342,6 +350,7 @@ pub struct TypeDefData {\n     pub visibility: Visibility,\n     pub parent: Option<DefId>,\n     pub docs: String,\n+    pub sig: Option<Signature>,\n }\n \n /// Data for a reference to a type or trait.\n@@ -386,6 +395,7 @@ pub struct VariableData {\n     pub type_value: String,\n     pub visibility: Visibility,\n     pub docs: String,\n+    pub sig: Option<Signature>,\n }\n \n #[derive(Debug, RustcEncodable)]\n@@ -405,3 +415,28 @@ pub struct VariableRefData {\n     pub scope: NodeId,\n     pub ref_id: DefId,\n }\n+\n+\n+/// Encodes information about the signature of a definition. This should have\n+/// enough information to create a nice display about a definition without\n+/// access to the source code.\n+#[derive(Clone, Debug, RustcEncodable)]\n+pub struct Signature {\n+    pub span: Span,\n+    pub text: String,\n+    // These identify the main identifier for the defintion as byte offsets into\n+    // `text`. E.g., of `foo` in `pub fn foo(...)`\n+    pub ident_start: usize,\n+    pub ident_end: usize,\n+    pub defs: Vec<SigElement>,\n+    pub refs: Vec<SigElement>,\n+}\n+\n+/// An element of a signature. `start` and `end` are byte offsets into the `text`\n+/// of the parent `Signature`.\n+#[derive(Clone, Debug, RustcEncodable)]\n+pub struct SigElement {\n+    pub id: DefId,\n+    pub start: usize,\n+    pub end: usize,\n+}"}, {"sha": "093a739c69ffadbc6550653cdff9f222ae474c1b", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 44, "deletions": 38, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -143,19 +143,20 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n     // a str representation of the entire prefix.\n     fn process_path_prefixes(&self, path: &ast::Path) -> Vec<(Span, String)> {\n         let spans = self.span.spans_for_path_segments(path);\n+        let segments = &path.segments[if path.is_global() { 1 } else { 0 }..];\n \n         // Paths to enums seem to not match their spans - the span includes all the\n         // variants too. But they seem to always be at the end, so I hope we can cope with\n         // always using the first ones. So, only error out if we don't have enough spans.\n         // What could go wrong...?\n-        if spans.len() < path.segments.len() {\n+        if spans.len() < segments.len() {\n             if generated_code(path.span) {\n                 return vec![];\n             }\n             error!(\"Mis-calculated spans for path '{}'. Found {} spans, expected {}. Found spans:\",\n                    path_to_string(path),\n                    spans.len(),\n-                   path.segments.len());\n+                   segments.len());\n             for s in &spans {\n                 let loc = self.sess.codemap().lookup_char_pos(s.lo);\n                 error!(\"    '{}' in {}, line {}\",\n@@ -170,14 +171,13 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n         let mut result: Vec<(Span, String)> = vec![];\n \n         let mut segs = vec![];\n-        for (i, (seg, span)) in path.segments.iter().zip(&spans).enumerate() {\n+        for (i, (seg, span)) in segments.iter().zip(&spans).enumerate() {\n             segs.push(seg.clone());\n             let sub_path = ast::Path {\n                 span: *span, // span for the last segment\n-                global: path.global,\n                 segments: segs,\n             };\n-            let qualname = if i == 0 && path.global {\n+            let qualname = if i == 0 && path.is_global() {\n                 format!(\"::{}\", path_to_string(&sub_path))\n             } else {\n                 path_to_string(&sub_path)\n@@ -189,20 +189,11 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n         result\n     }\n \n-    // The global arg allows us to override the global-ness of the path (which\n-    // actually means 'does the path start with `::`', rather than 'is the path\n-    // semantically global). We use the override for `use` imports (etc.) where\n-    // the syntax is non-global, but the semantics are global.\n-    fn write_sub_paths(&mut self, path: &ast::Path, global: bool) {\n+    fn write_sub_paths(&mut self, path: &ast::Path) {\n         let sub_paths = self.process_path_prefixes(path);\n-        for (i, &(ref span, ref qualname)) in sub_paths.iter().enumerate() {\n-            let qualname = if i == 0 && global && !path.global {\n-                format!(\"::{}\", qualname)\n-            } else {\n-                qualname.clone()\n-            };\n+        for (span, qualname) in sub_paths {\n             self.dumper.mod_ref(ModRefData {\n-                span: *span,\n+                span: span,\n                 qualname: qualname,\n                 scope: self.cur_scope,\n                 ref_id: None\n@@ -212,22 +203,16 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n \n     // As write_sub_paths, but does not process the last ident in the path (assuming it\n     // will be processed elsewhere). See note on write_sub_paths about global.\n-    fn write_sub_paths_truncated(&mut self, path: &ast::Path, global: bool) {\n+    fn write_sub_paths_truncated(&mut self, path: &ast::Path) {\n         let sub_paths = self.process_path_prefixes(path);\n         let len = sub_paths.len();\n         if len <= 1 {\n             return;\n         }\n \n-        let sub_paths = &sub_paths[..len-1];\n-        for (i, &(ref span, ref qualname)) in sub_paths.iter().enumerate() {\n-            let qualname = if i == 0 && global && !path.global {\n-                format!(\"::{}\", qualname)\n-            } else {\n-                qualname.clone()\n-            };\n+        for (span, qualname) in sub_paths.into_iter().take(len - 1) {\n             self.dumper.mod_ref(ModRefData {\n-                span: *span,\n+                span: span,\n                 qualname: qualname,\n                 scope: self.cur_scope,\n                 ref_id: None\n@@ -372,6 +357,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                         parent: None,\n                         visibility: Visibility::Inherited,\n                         docs: String::new(),\n+                        sig: None,\n                     }.lower(self.tcx));\n                 }\n             }\n@@ -444,6 +430,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                     parent: trait_id,\n                     visibility: vis,\n                     docs: docs_for_attrs(attrs),\n+                    sig: method_data.sig,\n                 }.lower(self.tcx));\n             }\n \n@@ -515,6 +502,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                     visibility: Visibility::Inherited,\n                     parent: None,\n                     docs: String::new(),\n+                    sig: None,\n                 }.lower(self.tcx));\n             }\n         }\n@@ -587,6 +575,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                 parent: Some(parent_id),\n                 visibility: vis,\n                 docs: docs_for_attrs(attrs),\n+                sig: None,\n             }.lower(self.tcx));\n         }\n \n@@ -630,11 +619,10 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                 fields: fields,\n                 visibility: From::from(&item.vis),\n                 docs: docs_for_attrs(&item.attrs),\n+                sig: self.save_ctxt.sig_base(item),\n             }.lower(self.tcx));\n         }\n \n-\n-        // fields\n         for field in def.fields() {\n             self.process_struct_field_def(field, item.id);\n             self.visit_ty(&field.ty);\n@@ -663,6 +651,18 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n             qualname.push_str(\"::\");\n             qualname.push_str(&name);\n \n+            let text = self.span.signature_string_for_span(variant.span);\n+            let ident_start = text.find(&name).unwrap();\n+            let ident_end = ident_start + name.len();\n+            let sig = Signature {\n+                span: variant.span,\n+                text: text,\n+                ident_start: ident_start,\n+                ident_end: ident_end,\n+                defs: vec![],\n+                refs: vec![],\n+            };\n+\n             match variant.node.data {\n                 ast::VariantData::Struct(ref fields, _) => {\n                     let sub_span = self.span.span_for_first_ident(variant.span);\n@@ -684,6 +684,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                             scope: enum_data.scope,\n                             parent: Some(make_def_id(item.id, &self.tcx.map)),\n                             docs: docs_for_attrs(&variant.node.attrs),\n+                            sig: sig,\n                         }.lower(self.tcx));\n                     }\n                 }\n@@ -709,6 +710,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                             scope: enum_data.scope,\n                             parent: Some(make_def_id(item.id, &self.tcx.map)),\n                             docs: docs_for_attrs(&variant.node.attrs),\n+                            sig: sig,\n                         }.lower(self.tcx));\n                     }\n                 }\n@@ -793,6 +795,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                 items: methods.iter().map(|i| i.id).collect(),\n                 visibility: From::from(&item.vis),\n                 docs: docs_for_attrs(&item.attrs),\n+                sig: self.save_ctxt.sig_base(item),\n             }.lower(self.tcx));\n         }\n \n@@ -935,7 +938,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n             Def::Union(..) |\n             Def::Variant(..) |\n             Def::TyAlias(..) |\n-            Def::AssociatedTy(..) => self.write_sub_paths_truncated(path, false),\n+            Def::AssociatedTy(..) => self.write_sub_paths_truncated(path),\n             _ => {}\n         }\n     }\n@@ -946,7 +949,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                           fields: &'l [ast::Field],\n                           variant: &'l ty::VariantDef,\n                           base: &'l Option<P<ast::Expr>>) {\n-        self.write_sub_paths_truncated(path, false);\n+        self.write_sub_paths_truncated(path);\n \n         if let Some(struct_lit_data) = self.save_ctxt.get_expr_data(ex) {\n             down_cast_data!(struct_lit_data, TypeRefData, ex.span);\n@@ -1058,6 +1061,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                     parent: None,\n                     visibility: Visibility::Inherited,\n                     docs: String::new(),\n+                    sig: None,\n                 }.lower(self.tcx));\n             }\n         }\n@@ -1201,7 +1205,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor<'l> for DumpVisitor<'l, 'tcx, 'll,\n                                 visibility: From::from(&item.vis),\n                             }.lower(self.tcx));\n                         }\n-                        self.write_sub_paths_truncated(path, true);\n+                        self.write_sub_paths_truncated(path);\n                     }\n                     ast::ViewPathGlob(ref path) => {\n                         // Make a comma-separated list of names of imported modules.\n@@ -1225,7 +1229,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor<'l> for DumpVisitor<'l, 'tcx, 'll,\n                                 visibility: From::from(&item.vis),\n                             }.lower(self.tcx));\n                         }\n-                        self.write_sub_paths(path, true);\n+                        self.write_sub_paths(path);\n                     }\n                     ast::ViewPathList(ref path, ref list) => {\n                         for plid in list {\n@@ -1237,7 +1241,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor<'l> for DumpVisitor<'l, 'tcx, 'll,\n                             }\n                         }\n \n-                        self.write_sub_paths(path, true);\n+                        self.write_sub_paths(path);\n                     }\n                 }\n             }\n@@ -1272,10 +1276,10 @@ impl<'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor<'l> for DumpVisitor<'l, 'tcx, 'll,\n             Struct(ref def, ref ty_params) => self.process_struct(item, def, ty_params),\n             Enum(ref def, ref ty_params) => self.process_enum(item, def, ty_params),\n             Impl(..,\n-                          ref ty_params,\n-                          ref trait_ref,\n-                          ref typ,\n-                          ref impl_items) => {\n+                 ref ty_params,\n+                 ref trait_ref,\n+                 ref typ,\n+                 ref impl_items) => {\n                 self.process_impl(item, ty_params, trait_ref, &typ, impl_items)\n             }\n             Trait(_, ref generics, ref trait_refs, ref methods) =>\n@@ -1298,6 +1302,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor<'l> for DumpVisitor<'l, 'tcx, 'll,\n                         visibility: From::from(&item.vis),\n                         parent: None,\n                         docs: docs_for_attrs(&item.attrs),\n+                        sig: Some(self.save_ctxt.sig_base(item)),\n                     }.lower(self.tcx));\n                 }\n \n@@ -1340,7 +1345,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor<'l> for DumpVisitor<'l, 'tcx, 'll,\n                     }.lower(self.tcx));\n                 }\n \n-                self.write_sub_paths_truncated(path, false);\n+                self.write_sub_paths_truncated(path);\n \n                 visit::walk_path(self, path);\n             }\n@@ -1507,6 +1512,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor<'l> for DumpVisitor<'l, 'tcx, 'll,\n                             parent: None,\n                             visibility: Visibility::Inherited,\n                             docs: String::new(),\n+                            sig: None,\n                         }.lower(self.tcx));\n                     }\n                 }"}, {"sha": "18ae3a7fa9ea8b1c83ded974401100d642048b28", "filename": "src/librustc_save_analysis/external_data.rs", "status": "modified", "additions": 48, "deletions": 1, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_save_analysis%2Fexternal_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_save_analysis%2Fexternal_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fexternal_data.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -15,7 +15,7 @@ use syntax::ast::NodeId;\n use syntax::codemap::CodeMap;\n use syntax_pos::Span;\n \n-use data::{self, Visibility};\n+use data::{self, Visibility, SigElement};\n \n // FIXME: this should be pub(crate), but the current snapshot doesn't allow it yet\n pub trait Lower {\n@@ -97,6 +97,7 @@ pub struct EnumData {\n     pub variants: Vec<DefId>,\n     pub visibility: Visibility,\n     pub docs: String,\n+    pub sig: Signature,\n }\n \n impl Lower for data::EnumData {\n@@ -113,6 +114,7 @@ impl Lower for data::EnumData {\n             variants: self.variants.into_iter().map(|id| make_def_id(id, &tcx.map)).collect(),\n             visibility: self.visibility,\n             docs: self.docs,\n+            sig: self.sig.lower(tcx),\n         }\n     }\n }\n@@ -176,6 +178,7 @@ pub struct FunctionData {\n     pub visibility: Visibility,\n     pub parent: Option<DefId>,\n     pub docs: String,\n+    pub sig: Signature,\n }\n \n impl Lower for data::FunctionData {\n@@ -193,6 +196,7 @@ impl Lower for data::FunctionData {\n             visibility: self.visibility,\n             parent: self.parent,\n             docs: self.docs,\n+            sig: self.sig.lower(tcx),\n         }\n     }\n }\n@@ -341,6 +345,7 @@ pub struct MethodData {\n     pub visibility: Visibility,\n     pub parent: Option<DefId>,\n     pub docs: String,\n+    pub sig: Signature,\n }\n \n impl Lower for data::MethodData {\n@@ -358,6 +363,7 @@ impl Lower for data::MethodData {\n             visibility: self.visibility,\n             parent: self.parent,\n             docs: self.docs,\n+            sig: self.sig.lower(tcx),\n         }\n     }\n }\n@@ -374,6 +380,7 @@ pub struct ModData {\n     pub items: Vec<DefId>,\n     pub visibility: Visibility,\n     pub docs: String,\n+    pub sig: Signature,\n }\n \n impl Lower for data::ModData {\n@@ -390,6 +397,7 @@ impl Lower for data::ModData {\n             items: self.items.into_iter().map(|id| make_def_id(id, &tcx.map)).collect(),\n             visibility: self.visibility,\n             docs: self.docs,\n+            sig: self.sig.lower(tcx),\n         }\n     }\n }\n@@ -428,6 +436,7 @@ pub struct StructData {\n     pub fields: Vec<DefId>,\n     pub visibility: Visibility,\n     pub docs: String,\n+    pub sig: Signature,\n }\n \n impl Lower for data::StructData {\n@@ -445,6 +454,7 @@ impl Lower for data::StructData {\n             fields: self.fields.into_iter().map(|id| make_def_id(id, &tcx.map)).collect(),\n             visibility: self.visibility,\n             docs: self.docs,\n+            sig: self.sig.lower(tcx),\n         }\n     }\n }\n@@ -460,6 +470,7 @@ pub struct StructVariantData {\n     pub scope: DefId,\n     pub parent: Option<DefId>,\n     pub docs: String,\n+    pub sig: Signature,\n }\n \n impl Lower for data::StructVariantData {\n@@ -476,6 +487,7 @@ impl Lower for data::StructVariantData {\n             scope: make_def_id(self.scope, &tcx.map),\n             parent: self.parent,\n             docs: self.docs,\n+            sig: self.sig.lower(tcx),\n         }\n     }\n }\n@@ -491,6 +503,7 @@ pub struct TraitData {\n     pub items: Vec<DefId>,\n     pub visibility: Visibility,\n     pub docs: String,\n+    pub sig: Signature,\n }\n \n impl Lower for data::TraitData {\n@@ -507,6 +520,7 @@ impl Lower for data::TraitData {\n             items: self.items.into_iter().map(|id| make_def_id(id, &tcx.map)).collect(),\n             visibility: self.visibility,\n             docs: self.docs,\n+            sig: self.sig.lower(tcx),\n         }\n     }\n }\n@@ -522,6 +536,7 @@ pub struct TupleVariantData {\n     pub scope: DefId,\n     pub parent: Option<DefId>,\n     pub docs: String,\n+    pub sig: Signature,\n }\n \n impl Lower for data::TupleVariantData {\n@@ -538,6 +553,7 @@ impl Lower for data::TupleVariantData {\n             scope: make_def_id(self.scope, &tcx.map),\n             parent: self.parent,\n             docs: self.docs,\n+            sig: self.sig.lower(tcx),\n         }\n     }\n }\n@@ -553,6 +569,7 @@ pub struct TypeDefData {\n     pub visibility: Visibility,\n     pub parent: Option<DefId>,\n     pub docs: String,\n+    pub sig: Option<Signature>,\n }\n \n impl Lower for data::TypeDefData {\n@@ -568,6 +585,7 @@ impl Lower for data::TypeDefData {\n             visibility: self.visibility,\n             parent: self.parent,\n             docs: self.docs,\n+            sig: self.sig.map(|s| s.lower(tcx)),\n         }\n     }\n }\n@@ -656,6 +674,7 @@ pub struct VariableData {\n     pub parent: Option<DefId>,\n     pub visibility: Visibility,\n     pub docs: String,\n+    pub sig: Option<Signature>,\n }\n \n impl Lower for data::VariableData {\n@@ -674,6 +693,7 @@ impl Lower for data::VariableData {\n             parent: self.parent,\n             visibility: self.visibility,\n             docs: self.docs,\n+            sig: self.sig.map(|s| s.lower(tcx)),\n         }\n     }\n }\n@@ -700,3 +720,30 @@ impl Lower for data::VariableRefData {\n         }\n     }\n }\n+\n+#[derive(Clone, Debug, RustcEncodable)]\n+pub struct Signature {\n+    pub span: SpanData,\n+    pub text: String,\n+    // These identify the main identifier for the defintion as byte offsets into\n+    // `text`. E.g., of `foo` in `pub fn foo(...)`\n+    pub ident_start: usize,\n+    pub ident_end: usize,\n+    pub defs: Vec<SigElement>,\n+    pub refs: Vec<SigElement>,\n+}\n+\n+impl Lower for data::Signature {\n+    type Target = Signature;\n+\n+    fn lower(self, tcx: TyCtxt) -> Signature {\n+        Signature {\n+            span: SpanData::from_span(self.span, tcx.sess.codemap()),\n+            text: self.text,\n+            ident_start: self.ident_start,\n+            ident_end: self.ident_end,\n+            defs: self.defs,\n+            refs: self.refs,\n+        }\n+    }\n+}"}, {"sha": "342c33af2f8963854b65a15e5a60e6c0e76c78a9", "filename": "src/librustc_save_analysis/json_api_dumper.rs", "status": "modified", "additions": 54, "deletions": 1, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_save_analysis%2Fjson_api_dumper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_save_analysis%2Fjson_api_dumper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fjson_api_dumper.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -14,7 +14,7 @@ use rustc::hir::def_id::DefId;\n use rustc_serialize::json::as_json;\n \n use external_data::*;\n-use data::{VariableKind, Visibility};\n+use data::{VariableKind, Visibility, SigElement};\n use dump::Dump;\n use super::Format;\n \n@@ -179,6 +179,7 @@ struct Def {\n     children: Vec<Id>,\n     decl_id: Option<Id>,\n     docs: String,\n+    sig: Option<JsonSignature>,\n }\n \n #[derive(Debug, RustcEncodable)]\n@@ -221,6 +222,7 @@ impl From<EnumData> for Option<Def> {\n                 children: data.variants.into_iter().map(|id| From::from(id)).collect(),\n                 decl_id: None,\n                 docs: data.docs,\n+                sig: Some(From::from(data.sig)),\n             }),\n             _ => None,\n         }\n@@ -240,6 +242,7 @@ impl From<TupleVariantData> for Option<Def> {\n             children: vec![],\n             decl_id: None,\n             docs: data.docs,\n+            sig: Some(From::from(data.sig)),\n         })\n     }\n }\n@@ -256,6 +259,7 @@ impl From<StructVariantData> for Option<Def> {\n             children: vec![],\n             decl_id: None,\n             docs: data.docs,\n+            sig: Some(From::from(data.sig)),\n         })\n     }\n }\n@@ -273,6 +277,7 @@ impl From<StructData> for Option<Def> {\n             children: data.fields.into_iter().map(|id| From::from(id)).collect(),\n             decl_id: None,\n             docs: data.docs,\n+            sig: Some(From::from(data.sig)),\n         }),\n             _ => None,\n         }\n@@ -292,6 +297,7 @@ impl From<TraitData> for Option<Def> {\n                 parent: None,\n                 decl_id: None,\n                 docs: data.docs,\n+                sig: Some(From::from(data.sig)),\n             }),\n             _ => None,\n         }\n@@ -311,6 +317,7 @@ impl From<FunctionData> for Option<Def> {\n                 parent: data.parent.map(|id| From::from(id)),\n                 decl_id: None,\n                 docs: data.docs,\n+                sig: Some(From::from(data.sig)),\n             }),\n             _ => None,\n         }\n@@ -330,6 +337,7 @@ impl From<MethodData> for Option<Def> {\n                 parent: data.parent.map(|id| From::from(id)),\n                 decl_id: data.decl_id.map(|id| From::from(id)),\n                 docs: data.docs,\n+                sig: Some(From::from(data.sig)),\n             }),\n             _ => None,\n         }\n@@ -348,6 +356,7 @@ impl From<MacroData> for Option<Def> {\n             parent: None,\n             decl_id: None,\n             docs: data.docs,\n+            sig: None,\n         })\n     }\n }\n@@ -365,6 +374,7 @@ impl From<ModData> for Option<Def> {\n                 parent: None,\n                 decl_id: None,\n                 docs: data.docs,\n+                sig: Some(From::from(data.sig)),\n             }),\n             _ => None,\n         }\n@@ -384,11 +394,13 @@ impl From<TypeDefData> for Option<Def> {\n                 parent: data.parent.map(|id| From::from(id)),\n                 decl_id: None,\n                 docs: String::new(),\n+                sig: data.sig.map(|s| From::from(s)),\n             }),\n             _ => None,\n         }\n     }\n }\n+\n impl From<VariableData> for Option<Def> {\n     fn from(data: VariableData) -> Option<Def> {\n         match data.visibility {\n@@ -408,8 +420,49 @@ impl From<VariableData> for Option<Def> {\n                 parent: data.parent.map(|id| From::from(id)),\n                 decl_id: None,\n                 docs: data.docs,\n+                sig: data.sig.map(|s| From::from(s)),\n             }),\n             _ => None,\n         }\n     }\n }\n+\n+#[derive(Debug, RustcEncodable)]\n+pub struct JsonSignature {\n+    span: SpanData,\n+    text: String,\n+    ident_start: usize,\n+    ident_end: usize,\n+    defs: Vec<JsonSigElement>,\n+    refs: Vec<JsonSigElement>,\n+}\n+\n+impl From<Signature> for JsonSignature {\n+    fn from(data: Signature) -> JsonSignature {\n+        JsonSignature {\n+            span: data.span,\n+            text: data.text,\n+            ident_start: data.ident_start,\n+            ident_end: data.ident_end,\n+            defs: data.defs.into_iter().map(|s| From::from(s)).collect(),\n+            refs: data.refs.into_iter().map(|s| From::from(s)).collect(),\n+        }\n+    }\n+}\n+\n+#[derive(Debug, RustcEncodable)]\n+pub struct JsonSigElement {\n+    id: Id,\n+    start: usize,\n+    end: usize,\n+}\n+\n+impl From<SigElement> for JsonSigElement {\n+    fn from(data: SigElement) -> JsonSigElement {\n+        JsonSigElement {\n+            id: From::from(data.id),\n+            start: data.start,\n+            end: data.end,\n+        }\n+    }\n+}"}, {"sha": "16c06a556df0e74932559e5e2dddbe1140a78bb9", "filename": "src/librustc_save_analysis/json_dumper.rs", "status": "modified", "additions": 53, "deletions": 2, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_save_analysis%2Fjson_dumper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_save_analysis%2Fjson_dumper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fjson_dumper.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -14,7 +14,7 @@ use rustc::hir::def_id::DefId;\n use rustc_serialize::json::as_json;\n \n use external_data::*;\n-use data::VariableKind;\n+use data::{VariableKind, SigElement};\n use dump::Dump;\n use super::Format;\n \n@@ -86,6 +86,7 @@ impl<'b, W: Write + 'b> Dump for JsonDumper<'b, W> {\n             children: data.items.into_iter().map(|id| From::from(id)).collect(),\n             decl_id: None,\n             docs: data.docs,\n+            sig: Some(From::from(data.sig)),\n         };\n         if def.span.file_name != def.value {\n             // If the module is an out-of-line defintion, then we'll make the\n@@ -223,6 +224,7 @@ struct Def {\n     children: Vec<Id>,\n     decl_id: Option<Id>,\n     docs: String,\n+    sig: Option<JsonSignature>,\n }\n \n #[derive(Debug, RustcEncodable)]\n@@ -264,6 +266,7 @@ impl From<EnumData> for Def {\n             children: data.variants.into_iter().map(|id| From::from(id)).collect(),\n             decl_id: None,\n             docs: data.docs,\n+            sig: Some(From::from(data.sig)),\n         }\n     }\n }\n@@ -280,6 +283,7 @@ impl From<TupleVariantData> for Def {\n             children: vec![],\n             decl_id: None,\n             docs: data.docs,\n+            sig: Some(From::from(data.sig)),\n         }\n     }\n }\n@@ -295,6 +299,7 @@ impl From<StructVariantData> for Def {\n             children: vec![],\n             decl_id: None,\n             docs: data.docs,\n+            sig: Some(From::from(data.sig)),\n         }\n     }\n }\n@@ -310,6 +315,7 @@ impl From<StructData> for Def {\n             children: data.fields.into_iter().map(|id| From::from(id)).collect(),\n             decl_id: None,\n             docs: data.docs,\n+            sig: Some(From::from(data.sig)),\n         }\n     }\n }\n@@ -325,6 +331,7 @@ impl From<TraitData> for Def {\n             children: data.items.into_iter().map(|id| From::from(id)).collect(),\n             decl_id: None,\n             docs: data.docs,\n+            sig: Some(From::from(data.sig)),\n         }\n     }\n }\n@@ -340,6 +347,7 @@ impl From<FunctionData> for Def {\n             children: vec![],\n             decl_id: None,\n             docs: data.docs,\n+            sig: Some(From::from(data.sig)),\n         }\n     }\n }\n@@ -355,6 +363,7 @@ impl From<MethodData> for Def {\n             children: vec![],\n             decl_id: data.decl_id.map(|id| From::from(id)),\n             docs: data.docs,\n+            sig: Some(From::from(data.sig)),\n         }\n     }\n }\n@@ -370,10 +379,10 @@ impl From<MacroData> for Def {\n             children: vec![],\n             decl_id: None,\n             docs: data.docs,\n+            sig: None,\n         }\n     }\n }\n-\n impl From<TypeDefData> for Def {\n     fn from(data: TypeDefData) -> Def {\n         Def {\n@@ -386,6 +395,7 @@ impl From<TypeDefData> for Def {\n             children: vec![],\n             decl_id: None,\n             docs: String::new(),\n+            sig: data.sig.map(|s| From::from(s)),\n         }\n     }\n }\n@@ -406,6 +416,7 @@ impl From<VariableData> for Def {\n             children: vec![],\n             decl_id: None,\n             docs: data.docs,\n+            sig: None,\n         }\n     }\n }\n@@ -496,3 +507,43 @@ impl From<MacroUseData> for MacroRef {\n         }\n     }\n }\n+\n+#[derive(Debug, RustcEncodable)]\n+pub struct JsonSignature {\n+    span: SpanData,\n+    text: String,\n+    ident_start: usize,\n+    ident_end: usize,\n+    defs: Vec<JsonSigElement>,\n+    refs: Vec<JsonSigElement>,\n+}\n+\n+impl From<Signature> for JsonSignature {\n+    fn from(data: Signature) -> JsonSignature {\n+        JsonSignature {\n+            span: data.span,\n+            text: data.text,\n+            ident_start: data.ident_start,\n+            ident_end: data.ident_end,\n+            defs: data.defs.into_iter().map(|s| From::from(s)).collect(),\n+            refs: data.refs.into_iter().map(|s| From::from(s)).collect(),\n+        }\n+    }\n+}\n+\n+#[derive(Debug, RustcEncodable)]\n+pub struct JsonSigElement {\n+    id: Id,\n+    start: usize,\n+    end: usize,\n+}\n+\n+impl From<SigElement> for JsonSigElement {\n+    fn from(data: SigElement) -> JsonSigElement {\n+        JsonSigElement {\n+            id: From::from(data.id),\n+            start: data.start,\n+            end: data.end,\n+        }\n+    }\n+}"}, {"sha": "491521a3239495454e9bb5680bf1535b26b1dff0", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 61, "deletions": 8, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -48,7 +48,7 @@ use rustc::session::config::CrateType::CrateTypeExecutable;\n use rustc::ty::{self, TyCtxt};\n \n use std::env;\n-use std::fs::{self, File};\n+use std::fs::File;\n use std::path::{Path, PathBuf};\n \n use syntax::ast::{self, NodeId, PatKind, Attribute, CRATE_NODE_ID};\n@@ -152,6 +152,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                     visibility: From::from(&item.vis),\n                     parent: None,\n                     docs: docs_for_attrs(&item.attrs),\n+                    sig: self.sig_base(item),\n                 }))\n             }\n             ast::ItemKind::Static(ref typ, mt, ref expr) => {\n@@ -179,6 +180,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                     type_value: ty_to_string(&typ),\n                     visibility: From::from(&item.vis),\n                     docs: docs_for_attrs(&item.attrs),\n+                    sig: Some(self.sig_base(item)),\n                 }))\n             }\n             ast::ItemKind::Const(ref typ, ref expr) => {\n@@ -197,6 +199,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                     type_value: ty_to_string(&typ),\n                     visibility: From::from(&item.vis),\n                     docs: docs_for_attrs(&item.attrs),\n+                    sig: Some(self.sig_base(item)),\n                 }))\n             }\n             ast::ItemKind::Mod(ref m) => {\n@@ -207,6 +210,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n \n                 let sub_span = self.span_utils.sub_span_after_keyword(item.span, keywords::Mod);\n                 filter!(self.span_utils, sub_span, item.span, None);\n+\n                 Some(Data::ModData(ModData {\n                     id: item.id,\n                     name: item.ident.to_string(),\n@@ -217,6 +221,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                     items: m.items.iter().map(|i| i.id).collect(),\n                     visibility: From::from(&item.vis),\n                     docs: docs_for_attrs(&item.attrs),\n+                    sig: self.sig_base(item),\n                 }))\n             }\n             ast::ItemKind::Enum(ref def, _) => {\n@@ -239,6 +244,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                     variants: def.variants.iter().map(|v| v.node.data.id()).collect(),\n                     visibility: From::from(&item.vis),\n                     docs: docs_for_attrs(&item.attrs),\n+                    sig: self.sig_base(item),\n                 }))\n             }\n             ast::ItemKind::Impl(.., ref trait_ref, ref typ, _) => {\n@@ -287,18 +293,34 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n         }\n     }\n \n-    pub fn get_field_data(&self, field: &ast::StructField,\n-                          scope: NodeId) -> Option<VariableData> {\n+    pub fn get_field_data(&self,\n+                          field: &ast::StructField,\n+                          scope: NodeId)\n+                          -> Option<VariableData> {\n         if let Some(ident) = field.ident {\n+            let name = ident.to_string();\n             let qualname = format!(\"::{}::{}\", self.tcx.node_path_str(scope), ident);\n-            let def_id = self.tcx.map.local_def_id(field.id);\n-            let typ = self.tcx.item_type(def_id).to_string();\n             let sub_span = self.span_utils.sub_span_before_token(field.span, token::Colon);\n             filter!(self.span_utils, sub_span, field.span, None);\n+            let def_id = self.tcx.map.local_def_id(field.id);\n+            let typ = self.tcx.item_type(def_id).to_string();\n+\n+            let span = field.span;\n+            let text = self.span_utils.snippet(field.span);\n+            let ident_start = text.find(&name).unwrap();\n+            let ident_end = ident_start + name.len();\n+            let sig = Signature {\n+                span: span,\n+                text: text,\n+                ident_start: ident_start,\n+                ident_end: ident_end,\n+                defs: vec![],\n+                refs: vec![],\n+            };\n             Some(VariableData {\n                 id: field.id,\n                 kind: VariableKind::Field,\n-                name: ident.to_string(),\n+                name: name,\n                 qualname: qualname,\n                 span: sub_span.unwrap(),\n                 scope: scope,\n@@ -307,6 +329,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                 type_value: typ,\n                 visibility: From::from(&field.vis),\n                 docs: docs_for_attrs(&field.attrs),\n+                sig: Some(sig),\n             })\n         } else {\n             None\n@@ -388,9 +411,23 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n \n         let sub_span = self.span_utils.sub_span_after_keyword(span, keywords::Fn);\n         filter!(self.span_utils, sub_span, span, None);\n+\n+        let name = name.to_string();\n+        let text = self.span_utils.signature_string_for_span(span);\n+        let ident_start = text.find(&name).unwrap();\n+        let ident_end = ident_start + name.len();\n+        let sig = Signature {\n+            span: span,\n+            text: text,\n+            ident_start: ident_start,\n+            ident_end: ident_end,\n+            defs: vec![],\n+            refs: vec![],\n+        };\n+\n         Some(FunctionData {\n             id: id,\n-            name: name.to_string(),\n+            name: name,\n             qualname: qualname,\n             declaration: decl_id,\n             span: sub_span.unwrap(),\n@@ -400,6 +437,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n             visibility: vis,\n             parent: parent_scope,\n             docs: docs,\n+            sig: sig,\n         })\n     }\n \n@@ -695,6 +733,21 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n         }\n     }\n \n+    fn sig_base(&self, item: &ast::Item) -> Signature {\n+        let text = self.span_utils.signature_string_for_span(item.span);\n+        let name = item.ident.to_string();\n+        let ident_start = text.find(&name).expect(\"Name not in signature?\");\n+        let ident_end = ident_start + name.len();\n+        Signature {\n+            span: mk_sp(item.span.lo, item.span.lo + BytePos(text.len() as u32)),\n+            text: text,\n+            ident_start: ident_start,\n+            ident_end: ident_end,\n+            defs: vec![],\n+            refs: vec![],\n+        }\n+    }\n+\n     #[inline]\n     pub fn enclosing_scope(&self, id: NodeId) -> NodeId {\n         self.tcx.map.get_enclosing_scope(id).unwrap_or(CRATE_NODE_ID)\n@@ -832,7 +885,7 @@ pub fn process_crate<'l, 'tcx>(tcx: TyCtxt<'l, 'tcx, 'tcx>,\n         },\n     };\n \n-    if let Err(e) = fs::create_dir_all(&root_path) {\n+    if let Err(e) = rustc::util::fs::create_dir_racy(&root_path) {\n         tcx.sess.err(&format!(\"Could not create directory {}: {}\",\n                               root_path.display(),\n                               e));"}, {"sha": "448bb2e761749c380ba4620ee669ef262b502c37", "filename": "src/librustc_save_analysis/span_utils.rs", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_save_analysis%2Fspan_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_save_analysis%2Fspan_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fspan_utils.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -19,7 +19,9 @@ use std::path::Path;\n use syntax::ast;\n use syntax::parse::lexer::{self, Reader, StringReader};\n use syntax::parse::token::{self, Token};\n+use syntax::parse::parser::Parser;\n use syntax::symbol::keywords;\n+use syntax::tokenstream::TokenTree;\n use syntax_pos::*;\n \n #[derive(Clone)]\n@@ -87,6 +89,12 @@ impl<'a> SpanUtils<'a> {\n         lexer::StringReader::new(s.diagnostic(), filemap)\n     }\n \n+    fn span_to_tts(&self, span: Span) -> Vec<TokenTree> {\n+        let srdr = self.retokenise_span(span);\n+        let mut p = Parser::new(&self.sess.parse_sess, Box::new(srdr), None, false);\n+        p.parse_all_token_trees().expect(\"Couldn't re-parse span\")\n+    }\n+\n     // Re-parses a path and returns the span for the last identifier in the path\n     pub fn span_for_last_ident(&self, span: Span) -> Option<Span> {\n         let mut result = None;\n@@ -308,6 +316,42 @@ impl<'a> SpanUtils<'a> {\n         }\n     }\n \n+    /// `span` must be the span for an item such as a function or struct. This\n+    /// function returns the program text from the start of the span until the\n+    /// end of the 'signature' part, that is up to, but not including an opening\n+    /// brace or semicolon.\n+    pub fn signature_string_for_span(&self, span: Span) -> String {\n+        let mut toks = self.span_to_tts(span).into_iter();\n+        let mut prev = toks.next().unwrap();\n+        let first_span = prev.get_span();\n+        let mut angle_count = 0;\n+        for tok in toks {\n+            if let TokenTree::Token(_, ref tok) = prev {\n+                angle_count += match *tok {\n+                    token::Eof => { break; }\n+                    token::Lt => 1,\n+                    token::Gt => -1,\n+                    token::BinOp(token::Shl) => 2,\n+                    token::BinOp(token::Shr) => -2,\n+                    _ => 0,\n+                };\n+            }\n+            if angle_count > 0 {\n+                prev = tok;\n+                continue;\n+            }\n+            if let TokenTree::Token(_, token::Semi) = tok {\n+                return self.snippet(mk_sp(first_span.lo, prev.get_span().hi));\n+            } else if let TokenTree::Delimited(_, ref d) = tok {\n+                if d.delim == token::Brace {\n+                    return self.snippet(mk_sp(first_span.lo, prev.get_span().hi));\n+                }\n+            }\n+            prev = tok;\n+        }\n+        self.snippet(span)\n+    }\n+\n     pub fn sub_span_before_token(&self, span: Span, tok: Token) -> Option<Span> {\n         let mut toks = self.retokenise_span(span);\n         let mut prev = toks.real_token();"}, {"sha": "cd43cbd7052825ab92e083b97ea395f0106316fe", "filename": "src/librustc_trans/README.md", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_trans%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_trans%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2FREADME.md?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -0,0 +1 @@\n+See [librustc/README.md](../librustc/README.md)."}, {"sha": "1f416d5404d2778d0fdea4768371232068e2bae8", "filename": "src/librustc_trans/README.txt", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/96c52d4fd86aed6320732a511c04bcbfff7d117f/src%2Flibrustc_trans%2FREADME.txt", "raw_url": "https://github.com/rust-lang/rust/raw/96c52d4fd86aed6320732a511c04bcbfff7d117f/src%2Flibrustc_trans%2FREADME.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2FREADME.txt?ref=96c52d4fd86aed6320732a511c04bcbfff7d117f", "patch": "@@ -1 +0,0 @@\n-See the README.md in ../librustc."}, {"sha": "9c4246e079b749074bb154e64badc4bca42f7f0f", "filename": "src/librustc_trans/abi.rs", "status": "modified", "additions": 18, "deletions": 19, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_trans%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_trans%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fabi.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -10,7 +10,6 @@\n \n use llvm::{self, ValueRef, Integer, Pointer, Float, Double, Struct, Array, Vector, AttributePlace};\n use base;\n-use build::AllocaFcx;\n use common::{type_is_fat_ptr, BlockAndBuilder, C_uint};\n use context::CrateContext;\n use cabi_x86;\n@@ -25,6 +24,7 @@ use cabi_mips;\n use cabi_mips64;\n use cabi_asmjs;\n use cabi_msp430;\n+use cabi_sparc;\n use machine::{llalign_of_min, llsize_of, llsize_of_alloc};\n use type_::Type;\n use type_of;\n@@ -59,7 +59,7 @@ mod attr_impl {\n     // The subset of llvm::Attribute needed for arguments, packed into a bitfield.\n     bitflags! {\n         #[derive(Default, Debug)]\n-        flags ArgAttribute : u8 {\n+        flags ArgAttribute : u16 {\n             const ByVal     = 1 << 0,\n             const NoAlias   = 1 << 1,\n             const NoCapture = 1 << 2,\n@@ -68,6 +68,7 @@ mod attr_impl {\n             const SExt      = 1 << 5,\n             const StructRet = 1 << 6,\n             const ZExt      = 1 << 7,\n+            const InReg     = 1 << 8,\n         }\n     }\n }\n@@ -81,7 +82,7 @@ macro_rules! for_each_kind {\n impl ArgAttribute {\n     fn for_each_kind<F>(&self, mut f: F) where F: FnMut(llvm::Attribute) {\n         for_each_kind!(self, f,\n-                       ByVal, NoAlias, NoCapture, NonNull, ReadOnly, SExt, StructRet, ZExt)\n+                       ByVal, NoAlias, NoCapture, NonNull, ReadOnly, SExt, StructRet, ZExt, InReg)\n     }\n }\n \n@@ -99,21 +100,11 @@ impl ArgAttributes {\n         self\n     }\n \n-    pub fn unset(&mut self, attr: ArgAttribute) -> &mut Self {\n-        self.regular = self.regular - attr;\n-        self\n-    }\n-\n     pub fn set_dereferenceable(&mut self, bytes: u64) -> &mut Self {\n         self.dereferenceable_bytes = bytes;\n         self\n     }\n \n-    pub fn unset_dereferenceable(&mut self) -> &mut Self {\n-        self.dereferenceable_bytes = 0;\n-        self\n-    }\n-\n     pub fn apply_llfn(&self, idx: AttributePlace, llfn: ValueRef) {\n         unsafe {\n             self.regular.for_each_kind(|attr| attr.apply_llfn(idx, llfn));\n@@ -246,7 +237,7 @@ impl ArgType {\n         if self.is_ignore() {\n             return;\n         }\n-        let ccx = bcx.ccx();\n+        let ccx = bcx.ccx;\n         if self.is_indirect() {\n             let llsz = llsize_of(ccx, self.ty);\n             let llalign = llalign_of_min(ccx, self.ty);\n@@ -278,7 +269,7 @@ impl ArgType {\n                 //   bitcasting to the struct type yields invalid cast errors.\n \n                 // We instead thus allocate some scratch space...\n-                let llscratch = AllocaFcx(bcx.fcx(), ty, \"abi_cast\");\n+                let llscratch = bcx.fcx().alloca(ty, \"abi_cast\");\n                 base::Lifetime::Start.call(bcx, llscratch);\n \n                 // ...where we first store the value...\n@@ -431,7 +422,7 @@ impl FnType {\n         let ret_ty = sig.output();\n         let mut ret = arg_of(ret_ty, true);\n \n-        if !type_is_fat_ptr(ccx.tcx(), ret_ty) {\n+        if !type_is_fat_ptr(ccx, ret_ty) {\n             // The `noalias` attribute on the return value is useful to a\n             // function ptr caller.\n             if let ty::TyBox(_) = ret_ty.sty {\n@@ -496,7 +487,7 @@ impl FnType {\n         for ty in inputs.iter().chain(extra_args.iter()) {\n             let mut arg = arg_of(ty, false);\n \n-            if type_is_fat_ptr(ccx.tcx(), ty) {\n+            if type_is_fat_ptr(ccx, ty) {\n                 let original_tys = arg.original_ty.field_types();\n                 let sizing_tys = arg.ty.field_types();\n                 assert_eq!((original_tys.len(), sizing_tys.len()), (2, 2));\n@@ -569,7 +560,7 @@ impl FnType {\n             };\n             // Fat pointers are returned by-value.\n             if !self.ret.is_ignore() {\n-                if !type_is_fat_ptr(ccx.tcx(), sig.output()) {\n+                if !type_is_fat_ptr(ccx, sig.output()) {\n                     fixup(&mut self.ret);\n                 }\n             }\n@@ -584,7 +575,14 @@ impl FnType {\n         }\n \n         match &ccx.sess().target.target.arch[..] {\n-            \"x86\" => cabi_x86::compute_abi_info(ccx, self),\n+            \"x86\" => {\n+                let flavor = if abi == Abi::Fastcall {\n+                    cabi_x86::Flavor::Fastcall\n+                } else {\n+                    cabi_x86::Flavor::General\n+                };\n+                cabi_x86::compute_abi_info(ccx, self, flavor);\n+            },\n             \"x86_64\" => if abi == Abi::SysV64 {\n                 cabi_x86_64::compute_abi_info(ccx, self);\n             } else if abi == Abi::Win64 || ccx.sess().target.target.options.is_like_windows {\n@@ -609,6 +607,7 @@ impl FnType {\n             \"asmjs\" => cabi_asmjs::compute_abi_info(ccx, self),\n             \"wasm32\" => cabi_asmjs::compute_abi_info(ccx, self),\n             \"msp430\" => cabi_msp430::compute_abi_info(ccx, self),\n+            \"sparc\" => cabi_sparc::compute_abi_info(ccx, self),\n             a => ccx.sess().fatal(&format!(\"unrecognized arch \\\"{}\\\" in target specification\", a))\n         }\n "}, {"sha": "31a5538a3c1179f3126eb279fffbc59ae9427d37", "filename": "src/librustc_trans/adt.rs", "status": "modified", "additions": 117, "deletions": 119, "changes": 236, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_trans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_trans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fadt.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -48,9 +48,7 @@ use std;\n use llvm::{ValueRef, True, IntEQ, IntNE};\n use rustc::ty::layout;\n use rustc::ty::{self, Ty, AdtKind};\n-use build::*;\n use common::*;\n-use debuginfo::DebugLoc;\n use glue;\n use base;\n use machine;\n@@ -151,14 +149,14 @@ pub fn finish_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         | layout::UntaggedUnion { .. } | layout::RawNullablePointer { .. } => { }\n         layout::Univariant { ..}\n         | layout::StructWrappedNullablePointer { .. } => {\n-            let (nonnull_variant, packed) = match *l {\n-                layout::Univariant { ref variant, .. } => (0, variant.packed),\n+            let (nonnull_variant_index, nonnull_variant, packed) = match *l {\n+                layout::Univariant { ref variant, .. } => (0, variant, variant.packed),\n                 layout::StructWrappedNullablePointer { nndiscr, ref nonnull, .. } =>\n-                    (nndiscr, nonnull.packed),\n+                    (nndiscr, nonnull, nonnull.packed),\n                 _ => unreachable!()\n             };\n-            let fields = compute_fields(cx, t, nonnull_variant as usize, true);\n-            llty.set_struct_body(&struct_llfields(cx, &fields, false, false),\n+            let fields = compute_fields(cx, t, nonnull_variant_index as usize, true);\n+            llty.set_struct_body(&struct_llfields(cx, &fields, nonnull_variant, false, false),\n                                  packed)\n         },\n         _ => bug!(\"This function cannot handle {} with layout {:#?}\", t, l)\n@@ -188,7 +186,7 @@ fn generic_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             let fields = compute_fields(cx, t, nndiscr as usize, false);\n             match name {\n                 None => {\n-                    Type::struct_(cx, &struct_llfields(cx, &fields, sizing, dst),\n+                    Type::struct_(cx, &struct_llfields(cx, &fields, nonnull, sizing, dst),\n                                   nonnull.packed)\n                 }\n                 Some(name) => {\n@@ -203,7 +201,7 @@ fn generic_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             let fields = compute_fields(cx, t, 0, true);\n             match name {\n                 None => {\n-                    let fields = struct_llfields(cx, &fields, sizing, dst);\n+                    let fields = struct_llfields(cx, &fields, &variant, sizing, dst);\n                     Type::struct_(cx, &fields, variant.packed)\n                 }\n                 Some(name) => {\n@@ -291,23 +289,26 @@ fn union_fill(cx: &CrateContext, size: u64, align: u64) -> Type {\n \n \n fn struct_llfields<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, fields: &Vec<Ty<'tcx>>,\n+                             variant: &layout::Struct,\n                              sizing: bool, dst: bool) -> Vec<Type> {\n+    let fields = variant.field_index_by_increasing_offset().map(|i| fields[i as usize]);\n     if sizing {\n-        fields.iter().filter(|&ty| !dst || type_is_sized(cx.tcx(), *ty))\n-            .map(|&ty| type_of::sizing_type_of(cx, ty)).collect()\n+        fields.filter(|ty| !dst || cx.shared().type_is_sized(*ty))\n+            .map(|ty| type_of::sizing_type_of(cx, ty)).collect()\n     } else {\n-        fields.iter().map(|&ty| type_of::in_memory_type_of(cx, ty)).collect()\n+        fields.map(|ty| type_of::in_memory_type_of(cx, ty)).collect()\n     }\n }\n \n /// Obtain a representation of the discriminant sufficient to translate\n /// destructuring; this may or may not involve the actual discriminant.\n-pub fn trans_switch<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                t: Ty<'tcx>,\n-                                scrutinee: ValueRef,\n-                                range_assert: bool)\n-                                -> (BranchKind, Option<ValueRef>) {\n-    let l = bcx.ccx().layout_of(t);\n+pub fn trans_switch<'a, 'tcx>(\n+    bcx: &BlockAndBuilder<'a, 'tcx>,\n+    t: Ty<'tcx>,\n+    scrutinee: ValueRef,\n+    range_assert: bool\n+) -> (BranchKind, Option<ValueRef>) {\n+    let l = bcx.ccx.layout_of(t);\n     match *l {\n         layout::CEnum { .. } | layout::General { .. } |\n         layout::RawNullablePointer { .. } | layout::StructWrappedNullablePointer { .. } => {\n@@ -329,34 +330,37 @@ pub fn is_discr_signed<'tcx>(l: &layout::Layout) -> bool {\n }\n \n /// Obtain the actual discriminant of a value.\n-pub fn trans_get_discr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, t: Ty<'tcx>,\n-                                   scrutinee: ValueRef, cast_to: Option<Type>,\n-                                   range_assert: bool)\n-    -> ValueRef {\n+pub fn trans_get_discr<'a, 'tcx>(\n+    bcx: &BlockAndBuilder<'a, 'tcx>,\n+    t: Ty<'tcx>,\n+    scrutinee: ValueRef,\n+    cast_to: Option<Type>,\n+    range_assert: bool\n+) -> ValueRef {\n     let (def, substs) = match t.sty {\n         ty::TyAdt(ref def, substs) if def.adt_kind() == AdtKind::Enum => (def, substs),\n         _ => bug!(\"{} is not an enum\", t)\n     };\n \n     debug!(\"trans_get_discr t: {:?}\", t);\n-    let l = bcx.ccx().layout_of(t);\n+    let l = bcx.ccx.layout_of(t);\n \n     let val = match *l {\n         layout::CEnum { discr, min, max, .. } => {\n             load_discr(bcx, discr, scrutinee, min, max, range_assert)\n         }\n         layout::General { discr, .. } => {\n-            let ptr = StructGEP(bcx, scrutinee, 0);\n+            let ptr = bcx.struct_gep(scrutinee, 0);\n             load_discr(bcx, discr, ptr, 0, def.variants.len() as u64 - 1,\n                        range_assert)\n         }\n-        layout::Univariant { .. } | layout::UntaggedUnion { .. } => C_u8(bcx.ccx(), 0),\n+        layout::Univariant { .. } | layout::UntaggedUnion { .. } => C_u8(bcx.ccx, 0),\n         layout::RawNullablePointer { nndiscr, .. } => {\n             let cmp = if nndiscr == 0 { IntEQ } else { IntNE };\n-            let llptrty = type_of::sizing_type_of(bcx.ccx(),\n-                monomorphize::field_ty(bcx.ccx().tcx(), substs,\n+            let llptrty = type_of::sizing_type_of(bcx.ccx,\n+                monomorphize::field_ty(bcx.ccx.tcx(), substs,\n                 &def.variants[nndiscr as usize].fields[0]));\n-            ICmp(bcx, cmp, Load(bcx, scrutinee), C_null(llptrty), DebugLoc::None)\n+            bcx.icmp(cmp, bcx.load(scrutinee), C_null(llptrty))\n         }\n         layout::StructWrappedNullablePointer { nndiscr, ref discrfield, .. } => {\n             struct_wrapped_nullable_bitdiscr(bcx, nndiscr, discrfield, scrutinee)\n@@ -365,24 +369,28 @@ pub fn trans_get_discr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, t: Ty<'tcx>,\n     };\n     match cast_to {\n         None => val,\n-        Some(llty) => if is_discr_signed(&l) { SExt(bcx, val, llty) } else { ZExt(bcx, val, llty) }\n+        Some(llty) => if is_discr_signed(&l) { bcx.sext(val, llty) } else { bcx.zext(val, llty) }\n     }\n }\n \n-fn struct_wrapped_nullable_bitdiscr(bcx: Block, nndiscr: u64, discrfield: &layout::FieldPath,\n-                                    scrutinee: ValueRef) -> ValueRef {\n-    let llptrptr = GEPi(bcx, scrutinee,\n+fn struct_wrapped_nullable_bitdiscr(\n+    bcx: &BlockAndBuilder,\n+    nndiscr: u64,\n+    discrfield: &layout::FieldPath,\n+    scrutinee: ValueRef\n+) -> ValueRef {\n+    let llptrptr = bcx.gepi(scrutinee,\n         &discrfield.iter().map(|f| *f as usize).collect::<Vec<_>>()[..]);\n-    let llptr = Load(bcx, llptrptr);\n+    let llptr = bcx.load(llptrptr);\n     let cmp = if nndiscr == 0 { IntEQ } else { IntNE };\n-    ICmp(bcx, cmp, llptr, C_null(val_ty(llptr)), DebugLoc::None)\n+    bcx.icmp(cmp, llptr, C_null(val_ty(llptr)))\n }\n \n /// Helper for cases where the discriminant is simply loaded.\n-fn load_discr(bcx: Block, ity: layout::Integer, ptr: ValueRef, min: u64, max: u64,\n+fn load_discr(bcx: &BlockAndBuilder, ity: layout::Integer, ptr: ValueRef, min: u64, max: u64,\n               range_assert: bool)\n     -> ValueRef {\n-    let llty = Type::from_integer(bcx.ccx(), ity);\n+    let llty = Type::from_integer(bcx.ccx, ity);\n     assert_eq!(val_ty(ptr), llty.ptr_to());\n     let bits = ity.size().bits();\n     assert!(bits <= 64);\n@@ -395,30 +403,29 @@ fn load_discr(bcx: Block, ity: layout::Integer, ptr: ValueRef, min: u64, max: u6\n         // rejected by the LLVM verifier (it would mean either an\n         // empty set, which is impossible, or the entire range of the\n         // type, which is pointless).\n-        Load(bcx, ptr)\n+        bcx.load(ptr)\n     } else {\n         // llvm::ConstantRange can deal with ranges that wrap around,\n         // so an overflow on (max + 1) is fine.\n-        LoadRangeAssert(bcx, ptr, min, max.wrapping_add(1), /* signed: */ True)\n+        bcx.load_range_assert(ptr, min, max.wrapping_add(1), /* signed: */ True)\n     }\n }\n \n /// Yield information about how to dispatch a case of the\n /// discriminant-like value returned by `trans_switch`.\n ///\n /// This should ideally be less tightly tied to `_match`.\n-pub fn trans_case<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, t: Ty<'tcx>, value: Disr)\n-                              -> ValueRef {\n-    let l = bcx.ccx().layout_of(t);\n+pub fn trans_case<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>, t: Ty<'tcx>, value: Disr) -> ValueRef {\n+    let l = bcx.ccx.layout_of(t);\n     match *l {\n         layout::CEnum { discr, .. }\n         | layout::General { discr, .. }=> {\n-            C_integral(Type::from_integer(bcx.ccx(), discr), value.0, true)\n+            C_integral(Type::from_integer(bcx.ccx, discr), value.0, true)\n         }\n         layout::RawNullablePointer { .. } |\n         layout::StructWrappedNullablePointer { .. } => {\n             assert!(value == Disr(0) || value == Disr(1));\n-            C_bool(bcx.ccx(), value != Disr(0))\n+            C_bool(bcx.ccx, value != Disr(0))\n         }\n         _ => {\n             bug!(\"{} does not have a discriminant. Represented as {:#?}\", t, l);\n@@ -428,29 +435,30 @@ pub fn trans_case<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, t: Ty<'tcx>, value: Disr)\n \n /// Set the discriminant for a new value of the given case of the given\n /// representation.\n-pub fn trans_set_discr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, t: Ty<'tcx>,\n-                                   val: ValueRef, to: Disr) {\n-    let l = bcx.ccx().layout_of(t);\n+pub fn trans_set_discr<'a, 'tcx>(\n+    bcx: &BlockAndBuilder<'a, 'tcx>, t: Ty<'tcx>, val: ValueRef, to: Disr\n+) {\n+    let l = bcx.ccx.layout_of(t);\n     match *l {\n         layout::CEnum{ discr, min, max, .. } => {\n             assert_discr_in_range(Disr(min), Disr(max), to);\n-            Store(bcx, C_integral(Type::from_integer(bcx.ccx(), discr), to.0, true),\n+            bcx.store(C_integral(Type::from_integer(bcx.ccx, discr), to.0, true),\n                   val);\n         }\n         layout::General{ discr, .. } => {\n-            Store(bcx, C_integral(Type::from_integer(bcx.ccx(), discr), to.0, true),\n-                  StructGEP(bcx, val, 0));\n+            bcx.store(C_integral(Type::from_integer(bcx.ccx, discr), to.0, true),\n+                  bcx.struct_gep(val, 0));\n         }\n         layout::Univariant { .. }\n         | layout::UntaggedUnion { .. }\n         | layout::Vector { .. } => {\n             assert_eq!(to, Disr(0));\n         }\n         layout::RawNullablePointer { nndiscr, .. } => {\n-            let nnty = compute_fields(bcx.ccx(), t, nndiscr as usize, false)[0];\n+            let nnty = compute_fields(bcx.ccx, t, nndiscr as usize, false)[0];\n             if to.0 != nndiscr {\n-                let llptrty = type_of::sizing_type_of(bcx.ccx(), nnty);\n-                Store(bcx, C_null(llptrty), val);\n+                let llptrty = type_of::sizing_type_of(bcx.ccx, nnty);\n+                bcx.store(C_null(llptrty), val);\n             }\n         }\n         layout::StructWrappedNullablePointer { nndiscr, ref discrfield, ref nonnull, .. } => {\n@@ -459,25 +467,24 @@ pub fn trans_set_discr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, t: Ty<'tcx>,\n                     // Issue #34427: As workaround for LLVM bug on\n                     // ARM, use memset of 0 on whole struct rather\n                     // than storing null to single target field.\n-                    let b = B(bcx);\n-                    let llptr = b.pointercast(val, Type::i8(b.ccx).ptr_to());\n-                    let fill_byte = C_u8(b.ccx, 0);\n-                    let size = C_uint(b.ccx, nonnull.stride().bytes());\n-                    let align = C_i32(b.ccx, nonnull.align.abi() as i32);\n-                    base::call_memset(&b, llptr, fill_byte, size, align, false);\n+                    let llptr = bcx.pointercast(val, Type::i8(bcx.ccx).ptr_to());\n+                    let fill_byte = C_u8(bcx.ccx, 0);\n+                    let size = C_uint(bcx.ccx, nonnull.stride().bytes());\n+                    let align = C_i32(bcx.ccx, nonnull.align.abi() as i32);\n+                    base::call_memset(bcx, llptr, fill_byte, size, align, false);\n                 } else {\n                     let path = discrfield.iter().map(|&i| i as usize).collect::<Vec<_>>();\n-                    let llptrptr = GEPi(bcx, val, &path[..]);\n+                    let llptrptr = bcx.gepi(val, &path[..]);\n                     let llptrty = val_ty(llptrptr).element_type();\n-                    Store(bcx, C_null(llptrty), llptrptr);\n+                    bcx.store(C_null(llptrty), llptrptr);\n                 }\n             }\n         }\n         _ => bug!(\"Cannot handle {} represented as {:#?}\", t, l)\n     }\n }\n \n-fn target_sets_discr_via_memset<'blk, 'tcx>(bcx: Block<'blk, 'tcx>) -> bool {\n+fn target_sets_discr_via_memset<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>) -> bool {\n     bcx.sess().target.target.arch == \"arm\" || bcx.sess().target.target.arch == \"aarch64\"\n }\n \n@@ -490,27 +497,23 @@ fn assert_discr_in_range(min: Disr, max: Disr, discr: Disr) {\n }\n \n /// Access a field, at a point when the value's case is known.\n-pub fn trans_field_ptr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, t: Ty<'tcx>,\n-                                   val: MaybeSizedValue, discr: Disr, ix: usize) -> ValueRef {\n-    trans_field_ptr_builder(&bcx.build(), t, val, discr, ix)\n-}\n-\n-/// Access a field, at a point when the value's case is known.\n-pub fn trans_field_ptr_builder<'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>,\n-                                           t: Ty<'tcx>,\n-                                           val: MaybeSizedValue,\n-                                           discr: Disr, ix: usize)\n-                                           -> ValueRef {\n-    let l = bcx.ccx().layout_of(t);\n-    debug!(\"trans_field_ptr_builder on {} represented as {:#?}\", t, l);\n+pub fn trans_field_ptr<'a, 'tcx>(\n+    bcx: &BlockAndBuilder<'a, 'tcx>,\n+    t: Ty<'tcx>,\n+    val: MaybeSizedValue,\n+    discr: Disr,\n+    ix: usize\n+) -> ValueRef {\n+    let l = bcx.ccx.layout_of(t);\n+    debug!(\"trans_field_ptr on {} represented as {:#?}\", t, l);\n     // Note: if this ever needs to generate conditionals (e.g., if we\n     // decide to do some kind of cdr-coding-like non-unique repr\n     // someday), it will need to return a possibly-new bcx as well.\n     match *l {\n         layout::Univariant { ref variant, .. } => {\n             assert_eq!(discr, Disr(0));\n             struct_field_ptr(bcx, &variant,\n-             &compute_fields(bcx.ccx(), t, 0, false),\n+             &compute_fields(bcx.ccx, t, 0, false),\n              val, ix, false)\n         }\n         layout::Vector { count, .. } => {\n@@ -519,61 +522,57 @@ pub fn trans_field_ptr_builder<'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>,\n             bcx.struct_gep(val.value, ix)\n         }\n         layout::General { discr: d, ref variants, .. } => {\n-            let mut fields = compute_fields(bcx.ccx(), t, discr.0 as usize, false);\n-            fields.insert(0, d.to_ty(&bcx.ccx().tcx(), false));\n+            let mut fields = compute_fields(bcx.ccx, t, discr.0 as usize, false);\n+            fields.insert(0, d.to_ty(&bcx.ccx.tcx(), false));\n             struct_field_ptr(bcx, &variants[discr.0 as usize],\n              &fields,\n              val, ix + 1, true)\n         }\n         layout::UntaggedUnion { .. } => {\n-            let fields = compute_fields(bcx.ccx(), t, 0, false);\n-            let ty = type_of::in_memory_type_of(bcx.ccx(), fields[ix]);\n-            if bcx.is_unreachable() { return C_undef(ty.ptr_to()); }\n+            let fields = compute_fields(bcx.ccx, t, 0, false);\n+            let ty = type_of::in_memory_type_of(bcx.ccx, fields[ix]);\n             bcx.pointercast(val.value, ty.ptr_to())\n         }\n         layout::RawNullablePointer { nndiscr, .. } |\n         layout::StructWrappedNullablePointer { nndiscr,  .. } if discr.0 != nndiscr => {\n-            let nullfields = compute_fields(bcx.ccx(), t, (1-nndiscr) as usize, false);\n+            let nullfields = compute_fields(bcx.ccx, t, (1-nndiscr) as usize, false);\n             // The unit-like case might have a nonzero number of unit-like fields.\n             // (e.d., Result of Either with (), as one side.)\n-            let ty = type_of::type_of(bcx.ccx(), nullfields[ix]);\n-            assert_eq!(machine::llsize_of_alloc(bcx.ccx(), ty), 0);\n-            // The contents of memory at this pointer can't matter, but use\n-            // the value that's \"reasonable\" in case of pointer comparison.\n-            if bcx.is_unreachable() { return C_undef(ty.ptr_to()); }\n+            let ty = type_of::type_of(bcx.ccx, nullfields[ix]);\n+            assert_eq!(machine::llsize_of_alloc(bcx.ccx, ty), 0);\n             bcx.pointercast(val.value, ty.ptr_to())\n         }\n         layout::RawNullablePointer { nndiscr, .. } => {\n-            let nnty = compute_fields(bcx.ccx(), t, nndiscr as usize, false)[0];\n+            let nnty = compute_fields(bcx.ccx, t, nndiscr as usize, false)[0];\n             assert_eq!(ix, 0);\n             assert_eq!(discr.0, nndiscr);\n-            let ty = type_of::type_of(bcx.ccx(), nnty);\n-            if bcx.is_unreachable() { return C_undef(ty.ptr_to()); }\n+            let ty = type_of::type_of(bcx.ccx, nnty);\n             bcx.pointercast(val.value, ty.ptr_to())\n         }\n         layout::StructWrappedNullablePointer { ref nonnull, nndiscr, .. } => {\n             assert_eq!(discr.0, nndiscr);\n             struct_field_ptr(bcx, &nonnull,\n-             &compute_fields(bcx.ccx(), t, discr.0 as usize, false),\n+             &compute_fields(bcx.ccx, t, discr.0 as usize, false),\n              val, ix, false)\n         }\n         _ => bug!(\"element access in type without elements: {} represented as {:#?}\", t, l)\n     }\n }\n \n-fn struct_field_ptr<'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>,\n-                                st: &layout::Struct, fields: &Vec<Ty<'tcx>>, val: MaybeSizedValue,\n-                                ix: usize, needs_cast: bool) -> ValueRef {\n-    let ccx = bcx.ccx();\n+fn struct_field_ptr<'a, 'tcx>(\n+    bcx: &BlockAndBuilder<'a, 'tcx>,\n+    st: &layout::Struct,\n+    fields: &Vec<Ty<'tcx>>,\n+    val: MaybeSizedValue,\n+    ix: usize,\n+    needs_cast: bool\n+) -> ValueRef {\n     let fty = fields[ix];\n-    let ll_fty = type_of::in_memory_type_of(bcx.ccx(), fty);\n-    if bcx.is_unreachable() {\n-        return C_undef(ll_fty.ptr_to());\n-    }\n+    let ccx = bcx.ccx;\n \n     let ptr_val = if needs_cast {\n-        let fields = fields.iter().map(|&ty| {\n-            type_of::in_memory_type_of(ccx, ty)\n+        let fields = st.field_index_by_increasing_offset().map(|i| {\n+            type_of::in_memory_type_of(ccx, fields[i])\n         }).collect::<Vec<_>>();\n         let real_ty = Type::struct_(ccx, &fields[..], st.packed);\n         bcx.pointercast(val.value, real_ty.ptr_to())\n@@ -585,15 +584,16 @@ fn struct_field_ptr<'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>,\n     //   * First field - Always aligned properly\n     //   * Packed struct - There is no alignment padding\n     //   * Field is sized - pointer is properly aligned already\n-    if ix == 0 || st.packed || type_is_sized(bcx.tcx(), fty) {\n-        return bcx.struct_gep(ptr_val, ix);\n+    if st.offsets[ix] == layout::Size::from_bytes(0) || st.packed ||\n+        bcx.ccx.shared().type_is_sized(fty) {\n+        return bcx.struct_gep(ptr_val, st.memory_index[ix] as usize);\n     }\n \n     // If the type of the last field is [T] or str, then we don't need to do\n     // any adjusments\n     match fty.sty {\n         ty::TySlice(..) | ty::TyStr => {\n-            return bcx.struct_gep(ptr_val, ix);\n+            return bcx.struct_gep(ptr_val, st.memory_index[ix] as usize);\n         }\n         _ => ()\n     }\n@@ -605,8 +605,6 @@ fn struct_field_ptr<'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>,\n         return bcx.struct_gep(ptr_val, ix);\n     }\n \n-    let dbloc = DebugLoc::None;\n-\n     // We need to get the pointer manually now.\n     // We do this by casting to a *i8, then offsetting it by the appropriate amount.\n     // We do this instead of, say, simply adjusting the pointer from the result of a GEP\n@@ -626,7 +624,7 @@ fn struct_field_ptr<'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>,\n \n \n     let offset = st.offsets[ix].bytes();\n-    let unaligned_offset = C_uint(bcx.ccx(), offset);\n+    let unaligned_offset = C_uint(bcx.ccx, offset);\n \n     // Get the alignment of the field\n     let (_, align) = glue::size_and_align_of_dst(bcx, fty, meta);\n@@ -637,19 +635,18 @@ fn struct_field_ptr<'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>,\n     //   (unaligned offset + (align - 1)) & -align\n \n     // Calculate offset\n-    dbloc.apply(bcx.fcx());\n-    let align_sub_1 = bcx.sub(align, C_uint(bcx.ccx(), 1u64));\n+    let align_sub_1 = bcx.sub(align, C_uint(bcx.ccx, 1u64));\n     let offset = bcx.and(bcx.add(unaligned_offset, align_sub_1),\n                          bcx.neg(align));\n \n     debug!(\"struct_field_ptr: DST field offset: {:?}\", Value(offset));\n \n     // Cast and adjust pointer\n-    let byte_ptr = bcx.pointercast(ptr_val, Type::i8p(bcx.ccx()));\n+    let byte_ptr = bcx.pointercast(ptr_val, Type::i8p(bcx.ccx));\n     let byte_ptr = bcx.gep(byte_ptr, &[offset]);\n \n     // Finally, cast back to the type expected\n-    let ll_fty = type_of::in_memory_type_of(bcx.ccx(), fty);\n+    let ll_fty = type_of::in_memory_type_of(bcx.ccx, fty);\n     debug!(\"struct_field_ptr: Field type is {:?}\", ll_fty);\n     bcx.pointercast(byte_ptr, ll_fty.ptr_to())\n }\n@@ -755,8 +752,12 @@ fn build_const_struct<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     // offset of current value\n     let mut offset = 0;\n     let mut cfields = Vec::new();\n-    let offsets = st.offsets.iter().map(|i| i.bytes());\n-    for (&val, target_offset) in vals.iter().zip(offsets) {\n+    cfields.reserve(st.offsets.len()*2);\n+\n+    let parts = st.field_index_by_increasing_offset().map(|i| {\n+        (&vals[i], st.offsets[i].bytes())\n+    });\n+    for (&val, target_offset) in parts {\n         if offset < target_offset {\n             cfields.push(padding(ccx, target_offset - offset));\n             offset = target_offset;\n@@ -807,14 +808,11 @@ pub fn const_get_field<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>,\n     let l = ccx.layout_of(t);\n     match *l {\n         layout::CEnum { .. } => bug!(\"element access in C-like enum const\"),\n-        layout::Univariant { .. } | layout::Vector { .. } => const_struct_field(val, ix),\n+        layout::Univariant { ref variant, .. } => {\n+            const_struct_field(val, variant.memory_index[ix] as usize)\n+        }\n+        layout::Vector { .. } => const_struct_field(val, ix),\n         layout::UntaggedUnion { .. } => const_struct_field(val, 0),\n-        layout::General { .. } => const_struct_field(val, ix + 1),\n-        layout::RawNullablePointer { .. } => {\n-            assert_eq!(ix, 0);\n-            val\n-        },\n-        layout::StructWrappedNullablePointer{ .. } => const_struct_field(val, ix),\n         _ => bug!(\"{} does not have fields.\", t)\n     }\n }"}, {"sha": "d6385e1ca156263994ec0ef4d35c030b13a23416", "filename": "src/librustc_trans/asm.rs", "status": "modified", "additions": 23, "deletions": 21, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_trans%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_trans%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fasm.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -12,7 +12,6 @@\n \n use llvm::{self, ValueRef};\n use base;\n-use build::*;\n use common::*;\n use type_of;\n use type_::Type;\n@@ -25,10 +24,12 @@ use syntax::ast::AsmDialect;\n use libc::{c_uint, c_char};\n \n // Take an inline assembly expression and splat it out via LLVM\n-pub fn trans_inline_asm<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                    ia: &hir::InlineAsm,\n-                                    outputs: Vec<(ValueRef, Ty<'tcx>)>,\n-                                    mut inputs: Vec<ValueRef>) {\n+pub fn trans_inline_asm<'a, 'tcx>(\n+    bcx: &BlockAndBuilder<'a, 'tcx>,\n+    ia: &hir::InlineAsm,\n+    outputs: Vec<(ValueRef, Ty<'tcx>)>,\n+    mut inputs: Vec<ValueRef>\n+) {\n     let mut ext_constraints = vec![];\n     let mut output_types = vec![];\n \n@@ -47,7 +48,7 @@ pub fn trans_inline_asm<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         if out.is_indirect {\n             indirect_outputs.push(val.unwrap());\n         } else {\n-            output_types.push(type_of::type_of(bcx.ccx(), ty));\n+            output_types.push(type_of::type_of(bcx.ccx, ty));\n         }\n     }\n     if !indirect_outputs.is_empty() {\n@@ -78,9 +79,9 @@ pub fn trans_inline_asm<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     // Depending on how many outputs we have, the return type is different\n     let num_outputs = output_types.len();\n     let output_type = match num_outputs {\n-        0 => Type::void(bcx.ccx()),\n+        0 => Type::void(bcx.ccx),\n         1 => output_types[0],\n-        _ => Type::struct_(bcx.ccx(), &output_types[..], false)\n+        _ => Type::struct_(bcx.ccx, &output_types[..], false)\n     };\n \n     let dialect = match ia.dialect {\n@@ -90,32 +91,33 @@ pub fn trans_inline_asm<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     let asm = CString::new(ia.asm.as_str().as_bytes()).unwrap();\n     let constraint_cstr = CString::new(all_constraints).unwrap();\n-    let r = InlineAsmCall(bcx,\n-                          asm.as_ptr(),\n-                          constraint_cstr.as_ptr(),\n-                          &inputs,\n-                          output_type,\n-                          ia.volatile,\n-                          ia.alignstack,\n-                          dialect);\n+    let r = bcx.inline_asm_call(\n+        asm.as_ptr(),\n+        constraint_cstr.as_ptr(),\n+        &inputs,\n+        output_type,\n+        ia.volatile,\n+        ia.alignstack,\n+        dialect\n+    );\n \n     // Again, based on how many outputs we have\n     let outputs = ia.outputs.iter().zip(&outputs).filter(|&(ref o, _)| !o.is_indirect);\n     for (i, (_, &(val, _))) in outputs.enumerate() {\n-        let v = if num_outputs == 1 { r } else { ExtractValue(bcx, r, i) };\n-        Store(bcx, v, val);\n+        let v = if num_outputs == 1 { r } else { bcx.extract_value(r, i) };\n+        bcx.store(v, val);\n     }\n \n     // Store expn_id in a metadata node so we can map LLVM errors\n     // back to source locations.  See #17552.\n     unsafe {\n         let key = \"srcloc\";\n-        let kind = llvm::LLVMGetMDKindIDInContext(bcx.ccx().llcx(),\n+        let kind = llvm::LLVMGetMDKindIDInContext(bcx.ccx.llcx(),\n             key.as_ptr() as *const c_char, key.len() as c_uint);\n \n-        let val: llvm::ValueRef = C_i32(bcx.ccx(), ia.expn_id.into_u32() as i32);\n+        let val: llvm::ValueRef = C_i32(bcx.ccx, ia.expn_id.into_u32() as i32);\n \n         llvm::LLVMSetMetadata(r, kind,\n-            llvm::LLVMMDNodeInContext(bcx.ccx().llcx(), &val, 1));\n+            llvm::LLVMMDNodeInContext(bcx.ccx.llcx(), &val, 1));\n     }\n }"}, {"sha": "a147b598940a234100258990cb4e2c53e0cf764c", "filename": "src/librustc_trans/back/linker.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_trans%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_trans%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flinker.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -207,7 +207,12 @@ impl<'a> Linker for GnuLinker<'a> {\n         if self.sess.target.target.options.is_like_osx {\n             self.cmd.args(&[\"-dynamiclib\", \"-Wl,-dylib\"]);\n \n-            if self.sess.opts.cg.rpath {\n+            // Note that the `osx_rpath_install_name` option here is a hack\n+            // purely to support rustbuild right now, we should get a more\n+            // principled solution at some point to force the compiler to pass\n+            // the right `-Wl,-install_name` with an `@rpath` in it.\n+            if self.sess.opts.cg.rpath ||\n+               self.sess.opts.debugging_opts.osx_rpath_install_name {\n                 let mut v = OsString::from(\"-Wl,-install_name,@rpath/\");\n                 v.push(out_filename.file_name().unwrap());\n                 self.cmd.arg(&v);"}, {"sha": "8242f53896afc6c762a3ff2ef84edf62295456de", "filename": "src/librustc_trans/back/msvc/registry.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_trans%2Fback%2Fmsvc%2Fregistry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_trans%2Fback%2Fmsvc%2Fregistry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fmsvc%2Fregistry.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -12,7 +12,7 @@ use std::io;\n use std::ffi::{OsString, OsStr};\n use std::os::windows::prelude::*;\n use std::ptr;\n-use libc::{c_void, c_long};\n+use libc::c_long;\n \n pub type DWORD = u32;\n type LPCWSTR = *const u16;\n@@ -38,8 +38,6 @@ pub enum __HKEY__ {}\n pub type HKEY = *mut __HKEY__;\n pub type PHKEY = *mut HKEY;\n pub type REGSAM = DWORD;\n-pub type LPWSTR = *mut u16;\n-pub type PFILETIME = *mut c_void;\n \n #[link(name = \"advapi32\")]\n extern \"system\" {"}, {"sha": "938848054fee24266522d561ce951da69cef6d55", "filename": "src/librustc_trans/back/symbol_names.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -99,8 +99,6 @@\n \n use common::SharedCrateContext;\n use monomorphize::Instance;\n-use rustc_data_structures::fmt_wrap::FmtWrap;\n-use rustc_data_structures::blake2b::Blake2bHasher;\n \n use rustc::middle::weak_lang_items;\n use rustc::hir::def_id::LOCAL_CRATE;\n@@ -135,7 +133,7 @@ fn get_symbol_hash<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n \n     let tcx = scx.tcx();\n \n-    let mut hasher = ty::util::TypeIdHasher::new(tcx, Blake2bHasher::new(8, &[]));\n+    let mut hasher = ty::util::TypeIdHasher::<u64>::new(tcx);\n \n     record_time(&tcx.sess.perf_stats.symbol_hash_time, || {\n         // the main symbol name is not necessarily unique; hash in the\n@@ -158,9 +156,7 @@ fn get_symbol_hash<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n     });\n \n     // 64 bits should be enough to avoid collisions.\n-    let mut hasher = hasher.into_inner();\n-    let hash_bytes = hasher.finalize();\n-    format!(\"h{:x}\", FmtWrap(hash_bytes))\n+    format!(\"h{:016x}\", hasher.finish())\n }\n \n impl<'a, 'tcx> Instance<'tcx> {"}, {"sha": "de8814f143e04f62b4c07b046a7c5ac0039b01f7", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -1085,6 +1085,10 @@ fn run_work_multithreaded(sess: &Session,\n pub fn run_assembler(sess: &Session, outputs: &OutputFilenames) {\n     let (pname, mut cmd, _) = get_linker(sess);\n \n+    for arg in &sess.target.target.options.asm_args {\n+        cmd.arg(arg);\n+    }\n+\n     cmd.arg(\"-c\").arg(\"-o\").arg(&outputs.path(OutputType::Object))\n                            .arg(&outputs.temp_path(OutputType::Assembly, None));\n     debug!(\"{:?}\", cmd);"}, {"sha": "76bb1c56af3818aa155be237b4bb5da7292aded4", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 166, "deletions": 616, "changes": 782, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -23,8 +23,6 @@\n //!     but one TypeRef corresponds to many `Ty`s; for instance, tup(int, int,\n //!     int) and rec(x=int, y=int, z=int) will have the same TypeRef.\n \n-#![allow(non_camel_case_types)]\n-\n use super::CrateTranslation;\n use super::ModuleLlvm;\n use super::ModuleSource;\n@@ -37,7 +35,7 @@ use back::symbol_export::{self, ExportedSymbols};\n use llvm::{Linkage, ValueRef, Vector, get_param};\n use llvm;\n use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n-use middle::lang_items::{LangItem, ExchangeMallocFnLangItem, StartFnLangItem};\n+use middle::lang_items::StartFnLangItem;\n use rustc::ty::subst::Substs;\n use rustc::traits;\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n@@ -51,20 +49,18 @@ use session::{self, DataTypeKind, Session};\n use abi::{self, Abi, FnType};\n use adt;\n use attributes;\n-use build::*;\n-use builder::{Builder, noname};\n+use builder::Builder;\n use callee::{Callee};\n-use common::{Block, C_bool, C_bytes_in_context, C_i32, C_uint};\n+use common::{BlockAndBuilder, C_bool, C_bytes_in_context, C_i32, C_uint};\n use collector::{self, TransItemCollectionMode};\n-use common::{C_null, C_struct_in_context, C_u64, C_u8, C_undef};\n+use common::{C_struct_in_context, C_u64, C_undef};\n use common::{CrateContext, FunctionContext};\n-use common::{Result};\n use common::{fulfill_obligation};\n use common::{type_is_zero_size, val_ty};\n use common;\n use consts;\n use context::{SharedCrateContext, CrateContextList};\n-use debuginfo::{self, DebugLoc};\n+use debuginfo;\n use declare;\n use machine;\n use machine::{llalign_of_min, llsize_of};\n@@ -81,11 +77,8 @@ use value::Value;\n use Disr;\n use util::nodemap::{NodeSet, FxHashMap, FxHashSet};\n \n-use arena::TypedArena;\n use libc::c_uint;\n use std::ffi::{CStr, CString};\n-use std::cell::{Cell, RefCell};\n-use std::ptr;\n use std::rc::Rc;\n use std::str;\n use std::i32;\n@@ -95,52 +88,6 @@ use rustc::hir;\n use rustc::ty::layout::{self, Layout};\n use syntax::ast;\n \n-thread_local! {\n-    static TASK_LOCAL_INSN_KEY: RefCell<Option<Vec<&'static str>>> = {\n-        RefCell::new(None)\n-    }\n-}\n-\n-pub fn with_insn_ctxt<F>(blk: F)\n-    where F: FnOnce(&[&'static str])\n-{\n-    TASK_LOCAL_INSN_KEY.with(move |slot| {\n-        slot.borrow().as_ref().map(move |s| blk(s));\n-    })\n-}\n-\n-pub fn init_insn_ctxt() {\n-    TASK_LOCAL_INSN_KEY.with(|slot| {\n-        *slot.borrow_mut() = Some(Vec::new());\n-    });\n-}\n-\n-pub struct _InsnCtxt {\n-    _cannot_construct_outside_of_this_module: (),\n-}\n-\n-impl Drop for _InsnCtxt {\n-    fn drop(&mut self) {\n-        TASK_LOCAL_INSN_KEY.with(|slot| {\n-            if let Some(ctx) = slot.borrow_mut().as_mut() {\n-                ctx.pop();\n-            }\n-        })\n-    }\n-}\n-\n-pub fn push_ctxt(s: &'static str) -> _InsnCtxt {\n-    debug!(\"new InsnCtxt: {}\", s);\n-    TASK_LOCAL_INSN_KEY.with(|slot| {\n-        if let Some(ctx) = slot.borrow_mut().as_mut() {\n-            ctx.push(s)\n-        }\n-    });\n-    _InsnCtxt {\n-        _cannot_construct_outside_of_this_module: (),\n-    }\n-}\n-\n pub struct StatRecorder<'a, 'tcx: 'a> {\n     ccx: &'a CrateContext<'a, 'tcx>,\n     name: Option<String>,\n@@ -162,10 +109,7 @@ impl<'a, 'tcx> Drop for StatRecorder<'a, 'tcx> {\n     fn drop(&mut self) {\n         if self.ccx.sess().trans_stats() {\n             let iend = self.ccx.stats().n_llvm_insns.get();\n-            self.ccx\n-                .stats()\n-                .fn_stats\n-                .borrow_mut()\n+            self.ccx.stats().fn_stats.borrow_mut()\n                 .push((self.name.take().unwrap(), iend - self.istart));\n             self.ccx.stats().n_fns.set(self.ccx.stats().n_fns.get() + 1);\n             // Reset LLVM insn count to avoid compound costs.\n@@ -174,52 +118,14 @@ impl<'a, 'tcx> Drop for StatRecorder<'a, 'tcx> {\n     }\n }\n \n-pub fn get_meta(bcx: Block, fat_ptr: ValueRef) -> ValueRef {\n-    StructGEP(bcx, fat_ptr, abi::FAT_PTR_EXTRA)\n-}\n-\n-pub fn get_dataptr(bcx: Block, fat_ptr: ValueRef) -> ValueRef {\n-    StructGEP(bcx, fat_ptr, abi::FAT_PTR_ADDR)\n+pub fn get_meta(bcx: &Builder, fat_ptr: ValueRef) -> ValueRef {\n+    bcx.struct_gep(fat_ptr, abi::FAT_PTR_EXTRA)\n }\n \n-pub fn get_meta_builder(b: &Builder, fat_ptr: ValueRef) -> ValueRef {\n-    b.struct_gep(fat_ptr, abi::FAT_PTR_EXTRA)\n+pub fn get_dataptr(bcx: &Builder, fat_ptr: ValueRef) -> ValueRef {\n+    bcx.struct_gep(fat_ptr, abi::FAT_PTR_ADDR)\n }\n \n-pub fn get_dataptr_builder(b: &Builder, fat_ptr: ValueRef) -> ValueRef {\n-    b.struct_gep(fat_ptr, abi::FAT_PTR_ADDR)\n-}\n-\n-fn require_alloc_fn<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, info_ty: Ty<'tcx>, it: LangItem) -> DefId {\n-    match bcx.tcx().lang_items.require(it) {\n-        Ok(id) => id,\n-        Err(s) => {\n-            bcx.sess().fatal(&format!(\"allocation of `{}` {}\", info_ty, s));\n-        }\n-    }\n-}\n-\n-// The following malloc_raw_dyn* functions allocate a box to contain\n-// a given type, but with a potentially dynamic size.\n-\n-pub fn malloc_raw_dyn<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                  llty_ptr: Type,\n-                                  info_ty: Ty<'tcx>,\n-                                  size: ValueRef,\n-                                  align: ValueRef,\n-                                  debug_loc: DebugLoc)\n-                                  -> Result<'blk, 'tcx> {\n-    let _icx = push_ctxt(\"malloc_raw_exchange\");\n-\n-    // Allocate space:\n-    let def_id = require_alloc_fn(bcx, info_ty, ExchangeMallocFnLangItem);\n-    let r = Callee::def(bcx.ccx(), def_id, bcx.tcx().intern_substs(&[]))\n-        .call(bcx, debug_loc, &[size, align], None);\n-\n-    Result::new(r.bcx, PointerCast(r.bcx, r.val, llty_ptr))\n-}\n-\n-\n pub fn bin_op_to_icmp_predicate(op: hir::BinOp_,\n                                 signed: bool)\n                                 -> llvm::IntPredicate {\n@@ -254,18 +160,18 @@ pub fn bin_op_to_fcmp_predicate(op: hir::BinOp_) -> llvm::RealPredicate {\n     }\n }\n \n-pub fn compare_simd_types<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                      lhs: ValueRef,\n-                                      rhs: ValueRef,\n-                                      t: Ty<'tcx>,\n-                                      ret_ty: Type,\n-                                      op: hir::BinOp_,\n-                                      debug_loc: DebugLoc)\n-                                      -> ValueRef {\n+pub fn compare_simd_types<'a, 'tcx>(\n+    bcx: &BlockAndBuilder<'a, 'tcx>,\n+    lhs: ValueRef,\n+    rhs: ValueRef,\n+    t: Ty<'tcx>,\n+    ret_ty: Type,\n+    op: hir::BinOp_\n+) -> ValueRef {\n     let signed = match t.sty {\n         ty::TyFloat(_) => {\n             let cmp = bin_op_to_fcmp_predicate(op);\n-            return SExt(bcx, FCmp(bcx, cmp, lhs, rhs, debug_loc), ret_ty);\n+            return bcx.sext(bcx.fcmp(cmp, lhs, rhs), ret_ty);\n         },\n         ty::TyUint(_) => false,\n         ty::TyInt(_) => true,\n@@ -277,7 +183,7 @@ pub fn compare_simd_types<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     // to get the correctly sized type. This will compile to a single instruction\n     // once the IR is converted to assembly if the SIMD instruction is supported\n     // by the target architecture.\n-    SExt(bcx, ICmp(bcx, cmp, lhs, rhs, debug_loc), ret_ty)\n+    bcx.sext(bcx.icmp(cmp, lhs, rhs), ret_ty)\n }\n \n /// Retrieve the information we are losing (making dynamic) in an unsizing\n@@ -311,11 +217,12 @@ pub fn unsized_info<'ccx, 'tcx>(ccx: &CrateContext<'ccx, 'tcx>,\n }\n \n /// Coerce `src` to `dst_ty`. `src_ty` must be a thin pointer.\n-pub fn unsize_thin_ptr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                   src: ValueRef,\n-                                   src_ty: Ty<'tcx>,\n-                                   dst_ty: Ty<'tcx>)\n-                                   -> (ValueRef, ValueRef) {\n+pub fn unsize_thin_ptr<'a, 'tcx>(\n+    bcx: &BlockAndBuilder<'a, 'tcx>,\n+    src: ValueRef,\n+    src_ty: Ty<'tcx>,\n+    dst_ty: Ty<'tcx>\n+) -> (ValueRef, ValueRef) {\n     debug!(\"unsize_thin_ptr: {:?} => {:?}\", src_ty, dst_ty);\n     match (&src_ty.sty, &dst_ty.sty) {\n         (&ty::TyBox(a), &ty::TyBox(b)) |\n@@ -325,35 +232,34 @@ pub fn unsize_thin_ptr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n          &ty::TyRawPtr(ty::TypeAndMut { ty: b, .. })) |\n         (&ty::TyRawPtr(ty::TypeAndMut { ty: a, .. }),\n          &ty::TyRawPtr(ty::TypeAndMut { ty: b, .. })) => {\n-            assert!(common::type_is_sized(bcx.tcx(), a));\n-            let ptr_ty = type_of::in_memory_type_of(bcx.ccx(), b).ptr_to();\n-            (PointerCast(bcx, src, ptr_ty),\n-             unsized_info(bcx.ccx(), a, b, None))\n+            assert!(bcx.ccx.shared().type_is_sized(a));\n+            let ptr_ty = type_of::in_memory_type_of(bcx.ccx, b).ptr_to();\n+            (bcx.pointercast(src, ptr_ty), unsized_info(bcx.ccx, a, b, None))\n         }\n         _ => bug!(\"unsize_thin_ptr: called on bad types\"),\n     }\n }\n \n /// Coerce `src`, which is a reference to a value of type `src_ty`,\n /// to a value of type `dst_ty` and store the result in `dst`\n-pub fn coerce_unsized_into<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                       src: ValueRef,\n-                                       src_ty: Ty<'tcx>,\n-                                       dst: ValueRef,\n-                                       dst_ty: Ty<'tcx>) {\n+pub fn coerce_unsized_into<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n+                                     src: ValueRef,\n+                                     src_ty: Ty<'tcx>,\n+                                     dst: ValueRef,\n+                                     dst_ty: Ty<'tcx>) {\n     match (&src_ty.sty, &dst_ty.sty) {\n         (&ty::TyBox(..), &ty::TyBox(..)) |\n         (&ty::TyRef(..), &ty::TyRef(..)) |\n         (&ty::TyRef(..), &ty::TyRawPtr(..)) |\n         (&ty::TyRawPtr(..), &ty::TyRawPtr(..)) => {\n-            let (base, info) = if common::type_is_fat_ptr(bcx.tcx(), src_ty) {\n+            let (base, info) = if common::type_is_fat_ptr(bcx.ccx, src_ty) {\n                 // fat-ptr to fat-ptr unsize preserves the vtable\n                 // i.e. &'a fmt::Debug+Send => &'a fmt::Debug\n                 // So we need to pointercast the base to ensure\n                 // the types match up.\n                 let (base, info) = load_fat_ptr(bcx, src, src_ty);\n-                let llcast_ty = type_of::fat_ptr_base_ty(bcx.ccx(), dst_ty);\n-                let base = PointerCast(bcx, base, llcast_ty);\n+                let llcast_ty = type_of::fat_ptr_base_ty(bcx.ccx, dst_ty);\n+                let base = bcx.pointercast(base, llcast_ty);\n                 (base, info)\n             } else {\n                 let base = load_ty(bcx, src, src_ty);\n@@ -377,7 +283,7 @@ pub fn coerce_unsized_into<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n             let iter = src_fields.zip(dst_fields).enumerate();\n             for (i, (src_fty, dst_fty)) in iter {\n-                if type_is_zero_size(bcx.ccx(), dst_fty) {\n+                if type_is_zero_size(bcx.ccx, dst_fty) {\n                     continue;\n                 }\n \n@@ -415,8 +321,10 @@ pub fn custom_coerce_unsize_info<'scx, 'tcx>(scx: &SharedCrateContext<'scx, 'tcx\n     }\n }\n \n-pub fn cast_shift_expr_rhs(cx: Block, op: hir::BinOp_, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n-    cast_shift_rhs(op, lhs, rhs, |a, b| Trunc(cx, a, b), |a, b| ZExt(cx, a, b))\n+pub fn cast_shift_expr_rhs(\n+    cx: &BlockAndBuilder, op: hir::BinOp_, lhs: ValueRef, rhs: ValueRef\n+) -> ValueRef {\n+    cast_shift_rhs(op, lhs, rhs, |a, b| cx.trunc(a, b), |a, b| cx.zext(a, b))\n }\n \n pub fn cast_shift_const_rhs(op: hir::BinOp_, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n@@ -462,42 +370,6 @@ fn cast_shift_rhs<F, G>(op: hir::BinOp_,\n     }\n }\n \n-pub fn invoke<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                          llfn: ValueRef,\n-                          llargs: &[ValueRef],\n-                          debug_loc: DebugLoc)\n-                          -> (ValueRef, Block<'blk, 'tcx>) {\n-    let _icx = push_ctxt(\"invoke_\");\n-    if bcx.unreachable.get() {\n-        return (C_null(Type::i8(bcx.ccx())), bcx);\n-    }\n-\n-    if need_invoke(bcx) {\n-        debug!(\"invoking {:?} at {:?}\", Value(llfn), bcx.llbb);\n-        for &llarg in llargs {\n-            debug!(\"arg: {:?}\", Value(llarg));\n-        }\n-        let normal_bcx = bcx.fcx.new_block(\"normal-return\");\n-        let landing_pad = bcx.fcx.get_landing_pad();\n-\n-        let llresult = Invoke(bcx,\n-                              llfn,\n-                              &llargs[..],\n-                              normal_bcx.llbb,\n-                              landing_pad,\n-                              debug_loc);\n-        return (llresult, normal_bcx);\n-    } else {\n-        debug!(\"calling {:?} at {:?}\", Value(llfn), bcx.llbb);\n-        for &llarg in llargs {\n-            debug!(\"arg: {:?}\", Value(llarg));\n-        }\n-\n-        let llresult = Call(bcx, llfn, &llargs[..], debug_loc);\n-        return (llresult, bcx);\n-    }\n-}\n-\n /// Returns whether this session's target will use SEH-based unwinding.\n ///\n /// This is only true for MSVC targets, and even then the 64-bit MSVC target\n@@ -507,18 +379,6 @@ pub fn wants_msvc_seh(sess: &Session) -> bool {\n     sess.target.target.options.is_like_msvc\n }\n \n-pub fn avoid_invoke(bcx: Block) -> bool {\n-    bcx.sess().no_landing_pads() || bcx.lpad().is_some()\n-}\n-\n-pub fn need_invoke(bcx: Block) -> bool {\n-    if avoid_invoke(bcx) {\n-        false\n-    } else {\n-        bcx.fcx.needs_invoke()\n-    }\n-}\n-\n pub fn call_assume<'a, 'tcx>(b: &Builder<'a, 'tcx>, val: ValueRef) {\n     let assume_intrinsic = b.ccx.get_intrinsic(\"llvm.assume\");\n     b.call(assume_intrinsic, &[val], None);\n@@ -527,14 +387,7 @@ pub fn call_assume<'a, 'tcx>(b: &Builder<'a, 'tcx>, val: ValueRef) {\n /// Helper for loading values from memory. Does the necessary conversion if the in-memory type\n /// differs from the type used for SSA values. Also handles various special cases where the type\n /// gives us better information about what we are loading.\n-pub fn load_ty<'blk, 'tcx>(cx: Block<'blk, 'tcx>, ptr: ValueRef, t: Ty<'tcx>) -> ValueRef {\n-    if cx.unreachable.get() {\n-        return C_undef(type_of::type_of(cx.ccx(), t));\n-    }\n-    load_ty_builder(&B(cx), ptr, t)\n-}\n-\n-pub fn load_ty_builder<'a, 'tcx>(b: &Builder<'a, 'tcx>, ptr: ValueRef, t: Ty<'tcx>) -> ValueRef {\n+pub fn load_ty<'a, 'tcx>(b: &Builder<'a, 'tcx>, ptr: ValueRef, t: Ty<'tcx>) -> ValueRef {\n     let ccx = b.ccx;\n     if type_is_zero_size(ccx, t) {\n         return C_undef(type_of::type_of(ccx, t));\n@@ -559,8 +412,7 @@ pub fn load_ty_builder<'a, 'tcx>(b: &Builder<'a, 'tcx>, ptr: ValueRef, t: Ty<'tc\n         // a char is a Unicode codepoint, and so takes values from 0\n         // to 0x10FFFF inclusive only.\n         b.load_range_assert(ptr, 0, 0x10FFFF + 1, llvm::False)\n-    } else if (t.is_region_ptr() || t.is_unique()) &&\n-              !common::type_is_fat_ptr(ccx.tcx(), t) {\n+    } else if (t.is_region_ptr() || t.is_unique()) && !common::type_is_fat_ptr(ccx, t) {\n         b.load_nonnull(ptr)\n     } else {\n         b.load(ptr)\n@@ -569,177 +421,96 @@ pub fn load_ty_builder<'a, 'tcx>(b: &Builder<'a, 'tcx>, ptr: ValueRef, t: Ty<'tc\n \n /// Helper for storing values in memory. Does the necessary conversion if the in-memory type\n /// differs from the type used for SSA values.\n-pub fn store_ty<'blk, 'tcx>(cx: Block<'blk, 'tcx>, v: ValueRef, dst: ValueRef, t: Ty<'tcx>) {\n-    if cx.unreachable.get() {\n-        return;\n-    }\n-\n+pub fn store_ty<'a, 'tcx>(cx: &BlockAndBuilder<'a, 'tcx>, v: ValueRef, dst: ValueRef, t: Ty<'tcx>) {\n     debug!(\"store_ty: {:?} : {:?} <- {:?}\", Value(dst), t, Value(v));\n \n-    if common::type_is_fat_ptr(cx.tcx(), t) {\n-        let lladdr = ExtractValue(cx, v, abi::FAT_PTR_ADDR);\n-        let llextra = ExtractValue(cx, v, abi::FAT_PTR_EXTRA);\n+    if common::type_is_fat_ptr(cx.ccx, t) {\n+        let lladdr = cx.extract_value(v, abi::FAT_PTR_ADDR);\n+        let llextra = cx.extract_value(v, abi::FAT_PTR_EXTRA);\n         store_fat_ptr(cx, lladdr, llextra, dst, t);\n     } else {\n-        Store(cx, from_immediate(cx, v), dst);\n+        cx.store(from_immediate(cx, v), dst);\n     }\n }\n \n-pub fn store_fat_ptr<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n-                                 data: ValueRef,\n-                                 extra: ValueRef,\n-                                 dst: ValueRef,\n-                                 _ty: Ty<'tcx>) {\n+pub fn store_fat_ptr<'a, 'tcx>(cx: &BlockAndBuilder<'a, 'tcx>,\n+                               data: ValueRef,\n+                               extra: ValueRef,\n+                               dst: ValueRef,\n+                               _ty: Ty<'tcx>) {\n     // FIXME: emit metadata\n-    Store(cx, data, get_dataptr(cx, dst));\n-    Store(cx, extra, get_meta(cx, dst));\n+    cx.store(data, get_dataptr(cx, dst));\n+    cx.store(extra, get_meta(cx, dst));\n }\n \n-pub fn load_fat_ptr<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n-                                src: ValueRef,\n-                                ty: Ty<'tcx>)\n-                                -> (ValueRef, ValueRef)\n-{\n-    if cx.unreachable.get() {\n-        // FIXME: remove me\n-        return (Load(cx, get_dataptr(cx, src)),\n-                Load(cx, get_meta(cx, src)));\n-    }\n-\n-    load_fat_ptr_builder(&B(cx), src, ty)\n-}\n-\n-pub fn load_fat_ptr_builder<'a, 'tcx>(\n-    b: &Builder<'a, 'tcx>,\n-    src: ValueRef,\n-    t: Ty<'tcx>)\n-    -> (ValueRef, ValueRef)\n-{\n-\n-    let ptr = get_dataptr_builder(b, src);\n+pub fn load_fat_ptr<'a, 'tcx>(\n+    b: &Builder<'a, 'tcx>, src: ValueRef, t: Ty<'tcx>\n+) -> (ValueRef, ValueRef) {\n+    let ptr = get_dataptr(b, src);\n     let ptr = if t.is_region_ptr() || t.is_unique() {\n         b.load_nonnull(ptr)\n     } else {\n         b.load(ptr)\n     };\n \n     // FIXME: emit metadata on `meta`.\n-    let meta = b.load(get_meta_builder(b, src));\n+    let meta = b.load(get_meta(b, src));\n \n     (ptr, meta)\n }\n \n-pub fn from_immediate(bcx: Block, val: ValueRef) -> ValueRef {\n-    if val_ty(val) == Type::i1(bcx.ccx()) {\n-        ZExt(bcx, val, Type::i8(bcx.ccx()))\n+pub fn from_immediate(bcx: &BlockAndBuilder, val: ValueRef) -> ValueRef {\n+    if val_ty(val) == Type::i1(bcx.ccx) {\n+        bcx.zext(val, Type::i8(bcx.ccx))\n     } else {\n         val\n     }\n }\n \n-pub fn to_immediate(bcx: Block, val: ValueRef, ty: Ty) -> ValueRef {\n+pub fn to_immediate(bcx: &BlockAndBuilder, val: ValueRef, ty: Ty) -> ValueRef {\n     if ty.is_bool() {\n-        Trunc(bcx, val, Type::i1(bcx.ccx()))\n+        bcx.trunc(val, Type::i1(bcx.ccx))\n     } else {\n         val\n     }\n }\n \n-pub fn with_cond<'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>, val: ValueRef, f: F) -> Block<'blk, 'tcx>\n-    where F: FnOnce(Block<'blk, 'tcx>) -> Block<'blk, 'tcx>\n-{\n-    let _icx = push_ctxt(\"with_cond\");\n-\n-    if bcx.unreachable.get() || common::const_to_opt_uint(val) == Some(0) {\n-        return bcx;\n-    }\n-\n-    let fcx = bcx.fcx;\n-    let next_cx = fcx.new_block(\"next\");\n-    let cond_cx = fcx.new_block(\"cond\");\n-    CondBr(bcx, val, cond_cx.llbb, next_cx.llbb, DebugLoc::None);\n-    let after_cx = f(cond_cx);\n-    if !after_cx.terminated.get() {\n-        Br(after_cx, next_cx.llbb, DebugLoc::None);\n-    }\n-    next_cx\n-}\n-\n pub enum Lifetime { Start, End }\n \n-// If LLVM lifetime intrinsic support is enabled (i.e. optimizations\n-// on), and `ptr` is nonzero-sized, then extracts the size of `ptr`\n-// and the intrinsic for `lt` and passes them to `emit`, which is in\n-// charge of generating code to call the passed intrinsic on whatever\n-// block of generated code is targetted for the intrinsic.\n-//\n-// If LLVM lifetime intrinsic support is disabled (i.e.  optimizations\n-// off) or `ptr` is zero-sized, then no-op (does not call `emit`).\n-fn core_lifetime_emit<'blk, 'tcx, F>(ccx: &'blk CrateContext<'blk, 'tcx>,\n-                                     ptr: ValueRef,\n-                                     lt: Lifetime,\n-                                     emit: F)\n-    where F: FnOnce(&'blk CrateContext<'blk, 'tcx>, machine::llsize, ValueRef)\n-{\n-    if ccx.sess().opts.optimize == config::OptLevel::No {\n-        return;\n-    }\n-\n-    let _icx = push_ctxt(match lt {\n-        Lifetime::Start => \"lifetime_start\",\n-        Lifetime::End => \"lifetime_end\"\n-    });\n-\n-    let size = machine::llsize_of_alloc(ccx, val_ty(ptr).element_type());\n-    if size == 0 {\n-        return;\n-    }\n-\n-    let lifetime_intrinsic = ccx.get_intrinsic(match lt {\n-        Lifetime::Start => \"llvm.lifetime.start\",\n-        Lifetime::End => \"llvm.lifetime.end\"\n-    });\n-    emit(ccx, size, lifetime_intrinsic)\n-}\n-\n impl Lifetime {\n+    // If LLVM lifetime intrinsic support is enabled (i.e. optimizations\n+    // on), and `ptr` is nonzero-sized, then extracts the size of `ptr`\n+    // and the intrinsic for `lt` and passes them to `emit`, which is in\n+    // charge of generating code to call the passed intrinsic on whatever\n+    // block of generated code is targetted for the intrinsic.\n+    //\n+    // If LLVM lifetime intrinsic support is disabled (i.e.  optimizations\n+    // off) or `ptr` is zero-sized, then no-op (does not call `emit`).\n     pub fn call(self, b: &Builder, ptr: ValueRef) {\n-        core_lifetime_emit(b.ccx, ptr, self, |ccx, size, lifetime_intrinsic| {\n-            let ptr = b.pointercast(ptr, Type::i8p(ccx));\n-            b.call(lifetime_intrinsic, &[C_u64(ccx, size), ptr], None);\n-        });\n-    }\n-}\n+        if b.ccx.sess().opts.optimize == config::OptLevel::No {\n+            return;\n+        }\n \n-pub fn call_lifetime_start(bcx: Block, ptr: ValueRef) {\n-    if !bcx.unreachable.get() {\n-        Lifetime::Start.call(&bcx.build(), ptr);\n-    }\n-}\n+        let size = machine::llsize_of_alloc(b.ccx, val_ty(ptr).element_type());\n+        if size == 0 {\n+            return;\n+        }\n \n-pub fn call_lifetime_end(bcx: Block, ptr: ValueRef) {\n-    if !bcx.unreachable.get() {\n-        Lifetime::End.call(&bcx.build(), ptr);\n-    }\n-}\n+        let lifetime_intrinsic = b.ccx.get_intrinsic(match self {\n+            Lifetime::Start => \"llvm.lifetime.start\",\n+            Lifetime::End => \"llvm.lifetime.end\"\n+        });\n \n-// Generates code for resumption of unwind at the end of a landing pad.\n-pub fn trans_unwind_resume(bcx: Block, lpval: ValueRef) {\n-    if !bcx.sess().target.target.options.custom_unwind_resume {\n-        Resume(bcx, lpval);\n-    } else {\n-        let exc_ptr = ExtractValue(bcx, lpval, 0);\n-        bcx.fcx.eh_unwind_resume()\n-            .call(bcx, DebugLoc::None, &[exc_ptr], None);\n+        let ptr = b.pointercast(ptr, Type::i8p(b.ccx));\n+        b.call(lifetime_intrinsic, &[C_u64(b.ccx, size), ptr], None);\n     }\n }\n \n-pub fn call_memcpy<'bcx, 'tcx>(b: &Builder<'bcx, 'tcx>,\n+pub fn call_memcpy<'a, 'tcx>(b: &Builder<'a, 'tcx>,\n                                dst: ValueRef,\n                                src: ValueRef,\n                                n_bytes: ValueRef,\n                                align: u32) {\n-    let _icx = push_ctxt(\"call_memcpy\");\n     let ccx = b.ccx;\n     let ptr_width = &ccx.sess().target.target.target_pointer_width[..];\n     let key = format!(\"llvm.memcpy.p0i8.p0i8.i{}\", ptr_width);\n@@ -752,253 +523,44 @@ pub fn call_memcpy<'bcx, 'tcx>(b: &Builder<'bcx, 'tcx>,\n     b.call(memcpy, &[dst_ptr, src_ptr, size, align, volatile], None);\n }\n \n-pub fn memcpy_ty<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, dst: ValueRef, src: ValueRef, t: Ty<'tcx>) {\n-    let _icx = push_ctxt(\"memcpy_ty\");\n-    let ccx = bcx.ccx();\n+pub fn memcpy_ty<'a, 'tcx>(\n+    bcx: &BlockAndBuilder<'a, 'tcx>, dst: ValueRef, src: ValueRef, t: Ty<'tcx>\n+) {\n+    let ccx = bcx.ccx;\n \n-    if type_is_zero_size(ccx, t) || bcx.unreachable.get() {\n+    if type_is_zero_size(ccx, t) {\n         return;\n     }\n \n     if t.is_structural() {\n         let llty = type_of::type_of(ccx, t);\n         let llsz = llsize_of(ccx, llty);\n         let llalign = type_of::align_of(ccx, t);\n-        call_memcpy(&B(bcx), dst, src, llsz, llalign as u32);\n-    } else if common::type_is_fat_ptr(bcx.tcx(), t) {\n+        call_memcpy(bcx, dst, src, llsz, llalign as u32);\n+    } else if common::type_is_fat_ptr(bcx.ccx, t) {\n         let (data, extra) = load_fat_ptr(bcx, src, t);\n         store_fat_ptr(bcx, data, extra, dst, t);\n     } else {\n         store_ty(bcx, load_ty(bcx, src, t), dst, t);\n     }\n }\n \n-pub fn init_zero_mem<'blk, 'tcx>(cx: Block<'blk, 'tcx>, llptr: ValueRef, t: Ty<'tcx>) {\n-    if cx.unreachable.get() {\n-        return;\n-    }\n-    let _icx = push_ctxt(\"init_zero_mem\");\n-    let bcx = cx;\n-    memfill(&B(bcx), llptr, t, 0);\n-}\n-\n-// Always use this function instead of storing a constant byte to the memory\n-// in question. e.g. if you store a zero constant, LLVM will drown in vreg\n-// allocation for large data structures, and the generated code will be\n-// awful. (A telltale sign of this is large quantities of\n-// `mov [byte ptr foo],0` in the generated code.)\n-fn memfill<'a, 'tcx>(b: &Builder<'a, 'tcx>, llptr: ValueRef, ty: Ty<'tcx>, byte: u8) {\n-    let _icx = push_ctxt(\"memfill\");\n-    let ccx = b.ccx;\n-    let llty = type_of::type_of(ccx, ty);\n-    let llptr = b.pointercast(llptr, Type::i8(ccx).ptr_to());\n-    let llzeroval = C_u8(ccx, byte);\n-    let size = machine::llsize_of(ccx, llty);\n-    let align = C_i32(ccx, type_of::align_of(ccx, ty) as i32);\n-    call_memset(b, llptr, llzeroval, size, align, false);\n-}\n-\n-pub fn call_memset<'bcx, 'tcx>(b: &Builder<'bcx, 'tcx>,\n+pub fn call_memset<'a, 'tcx>(b: &Builder<'a, 'tcx>,\n                                ptr: ValueRef,\n                                fill_byte: ValueRef,\n                                size: ValueRef,\n                                align: ValueRef,\n-                               volatile: bool) {\n-    let ccx = b.ccx;\n-    let ptr_width = &ccx.sess().target.target.target_pointer_width[..];\n+                               volatile: bool) -> ValueRef {\n+    let ptr_width = &b.ccx.sess().target.target.target_pointer_width[..];\n     let intrinsic_key = format!(\"llvm.memset.p0i8.i{}\", ptr_width);\n-    let llintrinsicfn = ccx.get_intrinsic(&intrinsic_key);\n-    let volatile = C_bool(ccx, volatile);\n-    b.call(llintrinsicfn, &[ptr, fill_byte, size, align, volatile], None);\n+    let llintrinsicfn = b.ccx.get_intrinsic(&intrinsic_key);\n+    let volatile = C_bool(b.ccx, volatile);\n+    b.call(llintrinsicfn, &[ptr, fill_byte, size, align, volatile], None)\n }\n \n-pub fn alloc_ty<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                            ty: Ty<'tcx>,\n-                            name: &str) -> ValueRef {\n+pub fn alloc_ty<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>, ty: Ty<'tcx>, name: &str) -> ValueRef {\n     assert!(!ty.has_param_types());\n-    alloca(bcx, type_of::type_of(bcx.ccx(), ty), name)\n-}\n-\n-pub fn alloca(cx: Block, ty: Type, name: &str) -> ValueRef {\n-    let _icx = push_ctxt(\"alloca\");\n-    if cx.unreachable.get() {\n-        unsafe {\n-            return llvm::LLVMGetUndef(ty.ptr_to().to_ref());\n-        }\n-    }\n-    DebugLoc::None.apply(cx.fcx);\n-    Alloca(cx, ty, name)\n-}\n-\n-impl<'blk, 'tcx> FunctionContext<'blk, 'tcx> {\n-    /// Create a function context for the given function.\n-    /// Beware that you must call `fcx.init` or `fcx.bind_args`\n-    /// before doing anything with the returned function context.\n-    pub fn new(ccx: &'blk CrateContext<'blk, 'tcx>,\n-               llfndecl: ValueRef,\n-               fn_ty: FnType,\n-               definition: Option<(Instance<'tcx>, &ty::FnSig<'tcx>, Abi)>,\n-               block_arena: &'blk TypedArena<common::BlockS<'blk, 'tcx>>)\n-               -> FunctionContext<'blk, 'tcx> {\n-        let (param_substs, def_id) = match definition {\n-            Some((instance, ..)) => {\n-                common::validate_substs(instance.substs);\n-                (instance.substs, Some(instance.def))\n-            }\n-            None => (ccx.tcx().intern_substs(&[]), None)\n-        };\n-\n-        let local_id = def_id.and_then(|id| ccx.tcx().map.as_local_node_id(id));\n-\n-        debug!(\"FunctionContext::new({})\",\n-               definition.map_or(String::new(), |d| d.0.to_string()));\n-\n-        let no_debug = if let Some(id) = local_id {\n-            ccx.tcx().map.attrs(id)\n-               .iter().any(|item| item.check_name(\"no_debug\"))\n-        } else if let Some(def_id) = def_id {\n-            ccx.sess().cstore.item_attrs(def_id)\n-               .iter().any(|item| item.check_name(\"no_debug\"))\n-        } else {\n-            false\n-        };\n-\n-        let mir = def_id.map(|id| ccx.tcx().item_mir(id));\n-\n-        let debug_context = if let (false, Some((instance, sig, abi)), &Some(ref mir)) =\n-                (no_debug, definition, &mir) {\n-            debuginfo::create_function_debug_context(ccx, instance, sig, abi, llfndecl, mir)\n-        } else {\n-            debuginfo::empty_function_debug_context(ccx)\n-        };\n-\n-        FunctionContext {\n-            mir: mir,\n-            llfn: llfndecl,\n-            llretslotptr: Cell::new(None),\n-            param_env: ccx.tcx().empty_parameter_environment(),\n-            alloca_insert_pt: Cell::new(None),\n-            landingpad_alloca: Cell::new(None),\n-            fn_ty: fn_ty,\n-            param_substs: param_substs,\n-            span: None,\n-            block_arena: block_arena,\n-            lpad_arena: TypedArena::new(),\n-            ccx: ccx,\n-            debug_context: debug_context,\n-            scopes: RefCell::new(Vec::new()),\n-        }\n-    }\n-\n-    /// Performs setup on a newly created function, creating the entry\n-    /// scope block and allocating space for the return pointer.\n-    pub fn init(&'blk self, skip_retptr: bool) -> Block<'blk, 'tcx> {\n-        let entry_bcx = self.new_block(\"entry-block\");\n-\n-        // Use a dummy instruction as the insertion point for all allocas.\n-        // This is later removed in FunctionContext::cleanup.\n-        self.alloca_insert_pt.set(Some(unsafe {\n-            Load(entry_bcx, C_null(Type::i8p(self.ccx)));\n-            llvm::LLVMGetFirstInstruction(entry_bcx.llbb)\n-        }));\n-\n-        if !self.fn_ty.ret.is_ignore() && !skip_retptr {\n-            // We normally allocate the llretslotptr, unless we\n-            // have been instructed to skip it for immediate return\n-            // values, or there is nothing to return at all.\n-\n-            // We create an alloca to hold a pointer of type `ret.original_ty`\n-            // which will hold the pointer to the right alloca which has the\n-            // final ret value\n-            let llty = self.fn_ty.ret.memory_ty(self.ccx);\n-            // But if there are no nested returns, we skip the indirection\n-            // and have a single retslot\n-            let slot = if self.fn_ty.ret.is_indirect() {\n-                get_param(self.llfn, 0)\n-            } else {\n-                AllocaFcx(self, llty, \"sret_slot\")\n-            };\n-\n-            self.llretslotptr.set(Some(slot));\n-        }\n-\n-        entry_bcx\n-    }\n-\n-    /// Ties up the llstaticallocas -> llloadenv -> lltop edges,\n-    /// and builds the return block.\n-    pub fn finish(&'blk self, ret_cx: Block<'blk, 'tcx>,\n-                  ret_debug_loc: DebugLoc) {\n-        let _icx = push_ctxt(\"FunctionContext::finish\");\n-\n-        self.build_return_block(ret_cx, ret_debug_loc);\n-\n-        DebugLoc::None.apply(self);\n-        self.cleanup();\n-    }\n-\n-    // Builds the return block for a function.\n-    pub fn build_return_block(&self, ret_cx: Block<'blk, 'tcx>,\n-                              ret_debug_location: DebugLoc) {\n-        if self.llretslotptr.get().is_none() ||\n-           ret_cx.unreachable.get() ||\n-           self.fn_ty.ret.is_indirect() {\n-            return RetVoid(ret_cx, ret_debug_location);\n-        }\n-\n-        let retslot = self.llretslotptr.get().unwrap();\n-        let retptr = Value(retslot);\n-        let llty = self.fn_ty.ret.original_ty;\n-        match (retptr.get_dominating_store(ret_cx), self.fn_ty.ret.cast) {\n-            // If there's only a single store to the ret slot, we can directly return\n-            // the value that was stored and omit the store and the alloca.\n-            // However, we only want to do this when there is no cast needed.\n-            (Some(s), None) => {\n-                let mut retval = s.get_operand(0).unwrap().get();\n-                s.erase_from_parent();\n-\n-                if retptr.has_no_uses() {\n-                    retptr.erase_from_parent();\n-                }\n-\n-                if self.fn_ty.ret.is_indirect() {\n-                    Store(ret_cx, retval, get_param(self.llfn, 0));\n-                    RetVoid(ret_cx, ret_debug_location)\n-                } else {\n-                    if llty == Type::i1(self.ccx) {\n-                        retval = Trunc(ret_cx, retval, llty);\n-                    }\n-                    Ret(ret_cx, retval, ret_debug_location)\n-                }\n-            }\n-            (_, cast_ty) if self.fn_ty.ret.is_indirect() => {\n-                // Otherwise, copy the return value to the ret slot.\n-                assert_eq!(cast_ty, None);\n-                let llsz = llsize_of(self.ccx, self.fn_ty.ret.ty);\n-                let llalign = llalign_of_min(self.ccx, self.fn_ty.ret.ty);\n-                call_memcpy(&B(ret_cx), get_param(self.llfn, 0),\n-                            retslot, llsz, llalign as u32);\n-                RetVoid(ret_cx, ret_debug_location)\n-            }\n-            (_, Some(cast_ty)) => {\n-                let load = Load(ret_cx, PointerCast(ret_cx, retslot, cast_ty.ptr_to()));\n-                let llalign = llalign_of_min(self.ccx, self.fn_ty.ret.ty);\n-                unsafe {\n-                    llvm::LLVMSetAlignment(load, llalign);\n-                }\n-                Ret(ret_cx, load, ret_debug_location)\n-            }\n-            (_, None) => {\n-                let retval = if llty == Type::i1(self.ccx) {\n-                    let val = LoadRangeAssert(ret_cx, retslot, 0, 2, llvm::False);\n-                    Trunc(ret_cx, val, llty)\n-                } else {\n-                    Load(ret_cx, retslot)\n-                };\n-                Ret(ret_cx, retval, ret_debug_location)\n-            }\n-        }\n-    }\n+    bcx.fcx().alloca(type_of::type_of(bcx.ccx, ty), name)\n }\n \n pub fn trans_instance<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, instance: Instance<'tcx>) {\n@@ -1016,8 +578,6 @@ pub fn trans_instance<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, instance: Instance\n     // release builds.\n     info!(\"trans_instance({})\", instance);\n \n-    let _icx = push_ctxt(\"trans_instance\");\n-\n     let fn_ty = ccx.tcx().item_type(instance.def);\n     let fn_ty = ccx.tcx().erase_regions(&fn_ty);\n     let fn_ty = monomorphize::apply_param_substs(ccx.shared(), instance.substs, &fn_ty);\n@@ -1038,19 +598,9 @@ pub fn trans_instance<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, instance: Instance\n \n     let fn_ty = FnType::new(ccx, abi, &sig, &[]);\n \n-    let (arena, fcx): (TypedArena<_>, FunctionContext);\n-    arena = TypedArena::new();\n-    fcx = FunctionContext::new(ccx,\n-                               lldecl,\n-                               fn_ty,\n-                               Some((instance, &sig, abi)),\n-                               &arena);\n-\n-    if fcx.mir.is_none() {\n-        bug!(\"attempted translation of `{}` w/o MIR\", instance);\n-    }\n-\n-    mir::trans_mir(&fcx);\n+    let fcx = FunctionContext::new(ccx, lldecl);\n+    let mir = ccx.tcx().item_mir(instance.def);\n+    mir::trans_mir(&fcx, fn_ty, &mir, instance, &sig, abi);\n }\n \n pub fn trans_ctor_shim<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n@@ -1067,34 +617,55 @@ pub fn trans_ctor_shim<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     let sig = ccx.tcx().erase_late_bound_regions_and_normalize(&ctor_ty.fn_sig());\n     let fn_ty = FnType::new(ccx, Abi::Rust, &sig, &[]);\n \n-    let (arena, fcx): (TypedArena<_>, FunctionContext);\n-    arena = TypedArena::new();\n-    fcx = FunctionContext::new(ccx, llfndecl, fn_ty, None, &arena);\n-    let bcx = fcx.init(false);\n-\n-    if !fcx.fn_ty.ret.is_ignore() {\n-        let dest = fcx.llretslotptr.get().unwrap();\n+    let fcx = FunctionContext::new(ccx, llfndecl);\n+    let bcx = fcx.get_entry_block();\n+    if !fn_ty.ret.is_ignore() {\n+        // But if there are no nested returns, we skip the indirection\n+        // and have a single retslot\n+        let dest = if fn_ty.ret.is_indirect() {\n+            get_param(fcx.llfn, 0)\n+        } else {\n+            // We create an alloca to hold a pointer of type `ret.original_ty`\n+            // which will hold the pointer to the right alloca which has the\n+            // final ret value\n+            fcx.alloca(fn_ty.ret.memory_ty(ccx), \"sret_slot\")\n+        };\n         let dest_val = adt::MaybeSizedValue::sized(dest); // Can return unsized value\n-        let mut llarg_idx = fcx.fn_ty.ret.is_indirect() as usize;\n+        let mut llarg_idx = fn_ty.ret.is_indirect() as usize;\n         let mut arg_idx = 0;\n         for (i, arg_ty) in sig.inputs().iter().enumerate() {\n-            let lldestptr = adt::trans_field_ptr(bcx, sig.output(), dest_val, Disr::from(disr), i);\n-            let arg = &fcx.fn_ty.args[arg_idx];\n+            let lldestptr = adt::trans_field_ptr(&bcx, sig.output(), dest_val, Disr::from(disr), i);\n+            let arg = &fn_ty.args[arg_idx];\n             arg_idx += 1;\n-            let b = &bcx.build();\n-            if common::type_is_fat_ptr(bcx.tcx(), arg_ty) {\n-                let meta = &fcx.fn_ty.args[arg_idx];\n+            if common::type_is_fat_ptr(bcx.ccx, arg_ty) {\n+                let meta = &fn_ty.args[arg_idx];\n                 arg_idx += 1;\n-                arg.store_fn_arg(b, &mut llarg_idx, get_dataptr(bcx, lldestptr));\n-                meta.store_fn_arg(b, &mut llarg_idx, get_meta(bcx, lldestptr));\n+                arg.store_fn_arg(&bcx, &mut llarg_idx, get_dataptr(&bcx, lldestptr));\n+                meta.store_fn_arg(&bcx, &mut llarg_idx, get_meta(&bcx, lldestptr));\n             } else {\n-                arg.store_fn_arg(b, &mut llarg_idx, lldestptr);\n+                arg.store_fn_arg(&bcx, &mut llarg_idx, lldestptr);\n             }\n         }\n-        adt::trans_set_discr(bcx, sig.output(), dest, disr);\n-    }\n+        adt::trans_set_discr(&bcx, sig.output(), dest, disr);\n \n-    fcx.finish(bcx, DebugLoc::None);\n+        if fn_ty.ret.is_indirect() {\n+            bcx.ret_void();\n+            return;\n+        }\n+\n+        if let Some(cast_ty) = fn_ty.ret.cast {\n+            let load = bcx.load(bcx.pointercast(dest, cast_ty.ptr_to()));\n+            let llalign = llalign_of_min(ccx, fn_ty.ret.ty);\n+            unsafe {\n+                llvm::LLVMSetAlignment(load, llalign);\n+            }\n+            bcx.ret(load)\n+        } else {\n+            bcx.ret(bcx.load(dest))\n+        }\n+    } else {\n+        bcx.ret_void();\n+    }\n }\n \n pub fn llvm_linkage_by_name(name: &str) -> Option<Linkage> {\n@@ -1166,9 +737,7 @@ pub fn maybe_create_entry_wrapper(ccx: &CrateContext) {\n \n     let et = ccx.sess().entry_type.get().unwrap();\n     match et {\n-        config::EntryMain => {\n-            create_entry_fn(ccx, span, main_llfn, true);\n-        }\n+        config::EntryMain => create_entry_fn(ccx, span, main_llfn, true),\n         config::EntryStart => create_entry_fn(ccx, span, main_llfn, false),\n         config::EntryNone => {}    // Do nothing.\n     }\n@@ -1193,47 +762,27 @@ pub fn maybe_create_entry_wrapper(ccx: &CrateContext) {\n         attributes::set_frame_pointer_elimination(ccx, llfn);\n \n         let llbb = unsafe {\n-            llvm::LLVMAppendBasicBlockInContext(ccx.llcx(), llfn, \"top\\0\".as_ptr() as *const _)\n+            let name = CString::new(\"top\").unwrap();\n+            llvm::LLVMAppendBasicBlockInContext(ccx.llcx(), llfn, name.as_ptr())\n         };\n-        let bld = ccx.raw_builder();\n-        unsafe {\n-            llvm::LLVMPositionBuilderAtEnd(bld, llbb);\n-\n-            debuginfo::gdb::insert_reference_to_gdb_debug_scripts_section_global(ccx);\n-\n-            let (start_fn, args) = if use_start_lang_item {\n-                let start_def_id = match ccx.tcx().lang_items.require(StartFnLangItem) {\n-                    Ok(id) => id,\n-                    Err(s) => ccx.sess().fatal(&s)\n-                };\n-                let empty_substs = ccx.tcx().intern_substs(&[]);\n-                let start_fn = Callee::def(ccx, start_def_id, empty_substs).reify(ccx);\n-                let args = {\n-                    let opaque_rust_main =\n-                        llvm::LLVMBuildPointerCast(bld,\n-                                                   rust_main,\n-                                                   Type::i8p(ccx).to_ref(),\n-                                                   \"rust_main\\0\".as_ptr() as *const _);\n-\n-                    vec![opaque_rust_main, get_param(llfn, 0), get_param(llfn, 1)]\n-                };\n-                (start_fn, args)\n-            } else {\n-                debug!(\"using user-defined start fn\");\n-                let args = vec![get_param(llfn, 0 as c_uint), get_param(llfn, 1 as c_uint)];\n+        let bld = Builder::with_ccx(ccx);\n+        bld.position_at_end(llbb);\n \n-                (rust_main, args)\n-            };\n+        debuginfo::gdb::insert_reference_to_gdb_debug_scripts_section_global(ccx, &bld);\n \n-            let result = llvm::LLVMRustBuildCall(bld,\n-                                                 start_fn,\n-                                                 args.as_ptr(),\n-                                                 args.len() as c_uint,\n-                                                 ptr::null_mut(),\n-                                                 noname());\n+        let (start_fn, args) = if use_start_lang_item {\n+            let start_def_id = ccx.tcx().require_lang_item(StartFnLangItem);\n+            let empty_substs = ccx.tcx().intern_substs(&[]);\n+            let start_fn = Callee::def(ccx, start_def_id, empty_substs).reify(ccx);\n+            (start_fn, vec![bld.pointercast(rust_main, Type::i8p(ccx).ptr_to()), get_param(llfn, 0),\n+                get_param(llfn, 1)])\n+        } else {\n+            debug!(\"using user-defined start fn\");\n+            (rust_main, vec![get_param(llfn, 0 as c_uint), get_param(llfn, 1 as c_uint)])\n+        };\n \n-            llvm::LLVMBuildRet(bld, result);\n-        }\n+        let result = bld.call(start_fn, &args, None);\n+        bld.ret(result);\n     }\n }\n \n@@ -1868,7 +1417,8 @@ fn gather_type_sizes<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n         match **layout {\n             Layout::StructWrappedNullablePointer { nonnull: ref variant_layout,\n                                                    nndiscr,\n-                                                   discrfield: _ } => {\n+                                                   discrfield: _,\n+                                                   discrfield_source: _ } => {\n                 debug!(\"print-type-size t: `{:?}` adt struct-wrapped nullable nndiscr {} is {:?}\",\n                        ty, nndiscr, variant_layout);\n                 let variant_def = &adt_def.variants[nndiscr as usize];"}, {"sha": "60bd3fb8ef1b8db10ed2417a2a6db484d5e8e73a", "filename": "src/librustc_trans/basic_block.rs", "status": "removed", "additions": 0, "deletions": 58, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/96c52d4fd86aed6320732a511c04bcbfff7d117f/src%2Flibrustc_trans%2Fbasic_block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96c52d4fd86aed6320732a511c04bcbfff7d117f/src%2Flibrustc_trans%2Fbasic_block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbasic_block.rs?ref=96c52d4fd86aed6320732a511c04bcbfff7d117f", "patch": "@@ -1,58 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use llvm;\n-use llvm::BasicBlockRef;\n-use value::{Users, Value};\n-use std::iter::{Filter, Map};\n-\n-#[derive(Copy, Clone)]\n-pub struct BasicBlock(pub BasicBlockRef);\n-\n-pub type Preds = Map<Filter<Users, fn(&Value) -> bool>, fn(Value) -> BasicBlock>;\n-\n-/// Wrapper for LLVM BasicBlockRef\n-impl BasicBlock {\n-    pub fn get(&self) -> BasicBlockRef {\n-        let BasicBlock(v) = *self; v\n-    }\n-\n-    pub fn as_value(self) -> Value {\n-        unsafe {\n-            Value(llvm::LLVMBasicBlockAsValue(self.get()))\n-        }\n-    }\n-\n-    pub fn pred_iter(self) -> Preds {\n-        fn is_a_terminator_inst(user: &Value) -> bool { user.is_a_terminator_inst() }\n-        let is_a_terminator_inst: fn(&Value) -> bool = is_a_terminator_inst;\n-\n-        fn get_parent(user: Value) -> BasicBlock { user.get_parent().unwrap() }\n-        let get_parent: fn(Value) -> BasicBlock = get_parent;\n-\n-        self.as_value().user_iter()\n-            .filter(is_a_terminator_inst)\n-            .map(get_parent)\n-    }\n-\n-    pub fn get_single_predecessor(self) -> Option<BasicBlock> {\n-        let mut iter = self.pred_iter();\n-        match (iter.next(), iter.next()) {\n-            (Some(first), None) => Some(first),\n-            _ => None\n-        }\n-    }\n-\n-    pub fn delete(self) {\n-        unsafe {\n-            llvm::LLVMDeleteBasicBlock(self.0);\n-        }\n-    }\n-}"}, {"sha": "8cd47bd148d0cf597e5241a65bc6b0b511a7635f", "filename": "src/librustc_trans/build.rs", "status": "removed", "additions": 0, "deletions": 1167, "changes": 1167, "blob_url": "https://github.com/rust-lang/rust/blob/96c52d4fd86aed6320732a511c04bcbfff7d117f/src%2Flibrustc_trans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96c52d4fd86aed6320732a511c04bcbfff7d117f/src%2Flibrustc_trans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbuild.rs?ref=96c52d4fd86aed6320732a511c04bcbfff7d117f", "patch": "@@ -1,1167 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![allow(dead_code)] // FFI wrappers\n-#![allow(non_snake_case)]\n-\n-use llvm;\n-use llvm::{AtomicRmwBinOp, AtomicOrdering, SynchronizationScope, AsmDialect};\n-use llvm::{Opcode, IntPredicate, RealPredicate};\n-use llvm::{ValueRef, BasicBlockRef};\n-use common::*;\n-use syntax_pos::Span;\n-\n-use builder::Builder;\n-use type_::Type;\n-use value::Value;\n-use debuginfo::DebugLoc;\n-\n-use libc::{c_uint, c_char};\n-\n-pub fn terminate(cx: Block, _: &str) {\n-    debug!(\"terminate({})\", cx.to_str());\n-    cx.terminated.set(true);\n-}\n-\n-pub fn check_not_terminated(cx: Block) {\n-    if cx.terminated.get() {\n-        bug!(\"already terminated!\");\n-    }\n-}\n-\n-pub fn B<'blk, 'tcx>(cx: Block<'blk, 'tcx>) -> Builder<'blk, 'tcx> {\n-    let b = cx.fcx.ccx.builder();\n-    b.position_at_end(cx.llbb);\n-    b\n-}\n-\n-// The difference between a block being unreachable and being terminated is\n-// somewhat obscure, and has to do with error checking. When a block is\n-// terminated, we're saying that trying to add any further statements in the\n-// block is an error. On the other hand, if something is unreachable, that\n-// means that the block was terminated in some way that we don't want to check\n-// for (panic/break/return statements, call to diverging functions, etc), and\n-// further instructions to the block should simply be ignored.\n-\n-pub fn RetVoid(cx: Block, debug_loc: DebugLoc) {\n-    if cx.unreachable.get() {\n-        return;\n-    }\n-    check_not_terminated(cx);\n-    terminate(cx, \"RetVoid\");\n-    debug_loc.apply(cx.fcx);\n-    B(cx).ret_void();\n-}\n-\n-pub fn Ret(cx: Block, v: ValueRef, debug_loc: DebugLoc) {\n-    if cx.unreachable.get() {\n-        return;\n-    }\n-    check_not_terminated(cx);\n-    terminate(cx, \"Ret\");\n-    debug_loc.apply(cx.fcx);\n-    B(cx).ret(v);\n-}\n-\n-pub fn AggregateRet(cx: Block,\n-                    ret_vals: &[ValueRef],\n-                    debug_loc: DebugLoc) {\n-    if cx.unreachable.get() {\n-        return;\n-    }\n-    check_not_terminated(cx);\n-    terminate(cx, \"AggregateRet\");\n-    debug_loc.apply(cx.fcx);\n-    B(cx).aggregate_ret(ret_vals);\n-}\n-\n-pub fn Br(cx: Block, dest: BasicBlockRef, debug_loc: DebugLoc) {\n-    if cx.unreachable.get() {\n-        return;\n-    }\n-    check_not_terminated(cx);\n-    terminate(cx, \"Br\");\n-    debug_loc.apply(cx.fcx);\n-    B(cx).br(dest);\n-}\n-\n-pub fn CondBr(cx: Block,\n-              if_: ValueRef,\n-              then: BasicBlockRef,\n-              else_: BasicBlockRef,\n-              debug_loc: DebugLoc) {\n-    if cx.unreachable.get() {\n-        return;\n-    }\n-    check_not_terminated(cx);\n-    terminate(cx, \"CondBr\");\n-    debug_loc.apply(cx.fcx);\n-    B(cx).cond_br(if_, then, else_);\n-}\n-\n-pub fn Switch(cx: Block, v: ValueRef, else_: BasicBlockRef, num_cases: usize)\n-    -> ValueRef {\n-    if cx.unreachable.get() { return _Undef(v); }\n-    check_not_terminated(cx);\n-    terminate(cx, \"Switch\");\n-    B(cx).switch(v, else_, num_cases)\n-}\n-\n-pub fn AddCase(s: ValueRef, on_val: ValueRef, dest: BasicBlockRef) {\n-    unsafe {\n-        if llvm::LLVMIsUndef(s) == llvm::True { return; }\n-        llvm::LLVMAddCase(s, on_val, dest);\n-    }\n-}\n-\n-pub fn IndirectBr(cx: Block,\n-                  addr: ValueRef,\n-                  num_dests: usize,\n-                  debug_loc: DebugLoc) {\n-    if cx.unreachable.get() {\n-        return;\n-    }\n-    check_not_terminated(cx);\n-    terminate(cx, \"IndirectBr\");\n-    debug_loc.apply(cx.fcx);\n-    B(cx).indirect_br(addr, num_dests);\n-}\n-\n-pub fn Invoke(cx: Block,\n-              fn_: ValueRef,\n-              args: &[ValueRef],\n-              then: BasicBlockRef,\n-              catch: BasicBlockRef,\n-              debug_loc: DebugLoc)\n-              -> ValueRef {\n-    if cx.unreachable.get() {\n-        return C_null(Type::i8(cx.ccx()));\n-    }\n-    check_not_terminated(cx);\n-    terminate(cx, \"Invoke\");\n-    debug!(\"Invoke({:?} with arguments ({}))\",\n-           Value(fn_),\n-           args.iter().map(|a| {\n-                format!(\"{:?}\", Value(*a))\n-           }).collect::<Vec<String>>().join(\", \"));\n-    debug_loc.apply(cx.fcx);\n-    let bundle = cx.lpad().and_then(|b| b.bundle());\n-    B(cx).invoke(fn_, args, then, catch, bundle)\n-}\n-\n-pub fn Unreachable(cx: Block) {\n-    if cx.unreachable.get() {\n-        return\n-    }\n-    cx.unreachable.set(true);\n-    if !cx.terminated.get() {\n-        B(cx).unreachable();\n-    }\n-}\n-\n-pub fn _Undef(val: ValueRef) -> ValueRef {\n-    unsafe {\n-        return llvm::LLVMGetUndef(val_ty(val).to_ref());\n-    }\n-}\n-\n-/* Arithmetic */\n-pub fn Add(cx: Block,\n-           lhs: ValueRef,\n-           rhs: ValueRef,\n-           debug_loc: DebugLoc)\n-           -> ValueRef {\n-    if cx.unreachable.get() {\n-        return _Undef(lhs);\n-    }\n-    debug_loc.apply(cx.fcx);\n-    B(cx).add(lhs, rhs)\n-}\n-\n-pub fn NSWAdd(cx: Block,\n-              lhs: ValueRef,\n-              rhs: ValueRef,\n-              debug_loc: DebugLoc)\n-              -> ValueRef {\n-    if cx.unreachable.get() {\n-        return _Undef(lhs);\n-    }\n-    debug_loc.apply(cx.fcx);\n-    B(cx).nswadd(lhs, rhs)\n-}\n-\n-pub fn NUWAdd(cx: Block,\n-              lhs: ValueRef,\n-              rhs: ValueRef,\n-              debug_loc: DebugLoc)\n-              -> ValueRef {\n-    if cx.unreachable.get() {\n-        return _Undef(lhs);\n-    }\n-    debug_loc.apply(cx.fcx);\n-    B(cx).nuwadd(lhs, rhs)\n-}\n-\n-pub fn FAdd(cx: Block,\n-            lhs: ValueRef,\n-            rhs: ValueRef,\n-            debug_loc: DebugLoc)\n-            -> ValueRef {\n-    if cx.unreachable.get() {\n-        return _Undef(lhs);\n-    }\n-    debug_loc.apply(cx.fcx);\n-    B(cx).fadd(lhs, rhs)\n-}\n-\n-pub fn FAddFast(cx: Block,\n-                lhs: ValueRef,\n-                rhs: ValueRef,\n-                debug_loc: DebugLoc)\n-            -> ValueRef {\n-    if cx.unreachable.get() {\n-        return _Undef(lhs);\n-    }\n-    debug_loc.apply(cx.fcx);\n-    B(cx).fadd_fast(lhs, rhs)\n-}\n-\n-pub fn Sub(cx: Block,\n-           lhs: ValueRef,\n-           rhs: ValueRef,\n-           debug_loc: DebugLoc)\n-           -> ValueRef {\n-    if cx.unreachable.get() {\n-        return _Undef(lhs);\n-    }\n-    debug_loc.apply(cx.fcx);\n-    B(cx).sub(lhs, rhs)\n-}\n-\n-pub fn NSWSub(cx: Block,\n-              lhs: ValueRef,\n-              rhs: ValueRef,\n-              debug_loc: DebugLoc)\n-              -> ValueRef {\n-    if cx.unreachable.get() {\n-        return _Undef(lhs);\n-    }\n-    debug_loc.apply(cx.fcx);\n-    B(cx).nswsub(lhs, rhs)\n-}\n-\n-pub fn NUWSub(cx: Block,\n-              lhs: ValueRef,\n-              rhs: ValueRef,\n-              debug_loc: DebugLoc)\n-              -> ValueRef {\n-    if cx.unreachable.get() {\n-        return _Undef(lhs);\n-    }\n-    debug_loc.apply(cx.fcx);\n-    B(cx).nuwsub(lhs, rhs)\n-}\n-\n-pub fn FSub(cx: Block,\n-            lhs: ValueRef,\n-            rhs: ValueRef,\n-            debug_loc: DebugLoc)\n-            -> ValueRef {\n-    if cx.unreachable.get() {\n-        return _Undef(lhs);\n-    }\n-    debug_loc.apply(cx.fcx);\n-    B(cx).fsub(lhs, rhs)\n-}\n-\n-pub fn FSubFast(cx: Block,\n-                lhs: ValueRef,\n-                rhs: ValueRef,\n-                debug_loc: DebugLoc)\n-            -> ValueRef {\n-    if cx.unreachable.get() {\n-        return _Undef(lhs);\n-    }\n-    debug_loc.apply(cx.fcx);\n-    B(cx).fsub_fast(lhs, rhs)\n-}\n-\n-pub fn Mul(cx: Block,\n-           lhs: ValueRef,\n-           rhs: ValueRef,\n-           debug_loc: DebugLoc)\n-           -> ValueRef {\n-    if cx.unreachable.get() {\n-        return _Undef(lhs);\n-    }\n-    debug_loc.apply(cx.fcx);\n-    B(cx).mul(lhs, rhs)\n-}\n-\n-pub fn NSWMul(cx: Block,\n-              lhs: ValueRef,\n-              rhs: ValueRef,\n-              debug_loc: DebugLoc)\n-              -> ValueRef {\n-    if cx.unreachable.get() {\n-        return _Undef(lhs);\n-    }\n-    debug_loc.apply(cx.fcx);\n-    B(cx).nswmul(lhs, rhs)\n-}\n-\n-pub fn NUWMul(cx: Block,\n-              lhs: ValueRef,\n-              rhs: ValueRef,\n-              debug_loc: DebugLoc)\n-              -> ValueRef {\n-    if cx.unreachable.get() {\n-        return _Undef(lhs);\n-    }\n-    debug_loc.apply(cx.fcx);\n-    B(cx).nuwmul(lhs, rhs)\n-}\n-\n-pub fn FMul(cx: Block,\n-            lhs: ValueRef,\n-            rhs: ValueRef,\n-            debug_loc: DebugLoc)\n-            -> ValueRef {\n-    if cx.unreachable.get() {\n-        return _Undef(lhs);\n-    }\n-    debug_loc.apply(cx.fcx);\n-    B(cx).fmul(lhs, rhs)\n-}\n-\n-pub fn FMulFast(cx: Block,\n-                lhs: ValueRef,\n-                rhs: ValueRef,\n-                debug_loc: DebugLoc)\n-            -> ValueRef {\n-    if cx.unreachable.get() {\n-        return _Undef(lhs);\n-    }\n-    debug_loc.apply(cx.fcx);\n-    B(cx).fmul_fast(lhs, rhs)\n-}\n-\n-pub fn UDiv(cx: Block,\n-            lhs: ValueRef,\n-            rhs: ValueRef,\n-            debug_loc: DebugLoc)\n-            -> ValueRef {\n-    if cx.unreachable.get() {\n-        return _Undef(lhs);\n-    }\n-    debug_loc.apply(cx.fcx);\n-    B(cx).udiv(lhs, rhs)\n-}\n-\n-pub fn SDiv(cx: Block,\n-            lhs: ValueRef,\n-            rhs: ValueRef,\n-            debug_loc: DebugLoc)\n-            -> ValueRef {\n-    if cx.unreachable.get() {\n-        return _Undef(lhs);\n-    }\n-    debug_loc.apply(cx.fcx);\n-    B(cx).sdiv(lhs, rhs)\n-}\n-\n-pub fn ExactSDiv(cx: Block,\n-                 lhs: ValueRef,\n-                 rhs: ValueRef,\n-                 debug_loc: DebugLoc)\n-                 -> ValueRef {\n-    if cx.unreachable.get() {\n-        return _Undef(lhs);\n-    }\n-    debug_loc.apply(cx.fcx);\n-    B(cx).exactsdiv(lhs, rhs)\n-}\n-\n-pub fn FDiv(cx: Block,\n-            lhs: ValueRef,\n-            rhs: ValueRef,\n-            debug_loc: DebugLoc)\n-            -> ValueRef {\n-    if cx.unreachable.get() {\n-        return _Undef(lhs);\n-    }\n-    debug_loc.apply(cx.fcx);\n-    B(cx).fdiv(lhs, rhs)\n-}\n-\n-pub fn FDivFast(cx: Block,\n-                lhs: ValueRef,\n-                rhs: ValueRef,\n-                debug_loc: DebugLoc)\n-            -> ValueRef {\n-    if cx.unreachable.get() {\n-        return _Undef(lhs);\n-    }\n-    debug_loc.apply(cx.fcx);\n-    B(cx).fdiv_fast(lhs, rhs)\n-}\n-\n-pub fn URem(cx: Block,\n-            lhs: ValueRef,\n-            rhs: ValueRef,\n-            debug_loc: DebugLoc)\n-            -> ValueRef {\n-    if cx.unreachable.get() {\n-        return _Undef(lhs);\n-    }\n-    debug_loc.apply(cx.fcx);\n-    B(cx).urem(lhs, rhs)\n-}\n-\n-pub fn SRem(cx: Block,\n-            lhs: ValueRef,\n-            rhs: ValueRef,\n-            debug_loc: DebugLoc)\n-            -> ValueRef {\n-    if cx.unreachable.get() {\n-        return _Undef(lhs);\n-    }\n-    debug_loc.apply(cx.fcx);\n-    B(cx).srem(lhs, rhs)\n-}\n-\n-pub fn FRem(cx: Block,\n-            lhs: ValueRef,\n-            rhs: ValueRef,\n-            debug_loc: DebugLoc)\n-            -> ValueRef {\n-    if cx.unreachable.get() {\n-        return _Undef(lhs);\n-    }\n-    debug_loc.apply(cx.fcx);\n-    B(cx).frem(lhs, rhs)\n-}\n-\n-pub fn FRemFast(cx: Block,\n-                lhs: ValueRef,\n-                rhs: ValueRef,\n-                debug_loc: DebugLoc)\n-            -> ValueRef {\n-    if cx.unreachable.get() {\n-        return _Undef(lhs);\n-    }\n-    debug_loc.apply(cx.fcx);\n-    B(cx).frem_fast(lhs, rhs)\n-}\n-\n-pub fn Shl(cx: Block,\n-           lhs: ValueRef,\n-           rhs: ValueRef,\n-           debug_loc: DebugLoc)\n-           -> ValueRef {\n-    if cx.unreachable.get() {\n-        return _Undef(lhs);\n-    }\n-    debug_loc.apply(cx.fcx);\n-    B(cx).shl(lhs, rhs)\n-}\n-\n-pub fn LShr(cx: Block,\n-            lhs: ValueRef,\n-            rhs: ValueRef,\n-            debug_loc: DebugLoc)\n-            -> ValueRef {\n-    if cx.unreachable.get() {\n-        return _Undef(lhs);\n-    }\n-    debug_loc.apply(cx.fcx);\n-    B(cx).lshr(lhs, rhs)\n-}\n-\n-pub fn AShr(cx: Block,\n-            lhs: ValueRef,\n-            rhs: ValueRef,\n-            debug_loc: DebugLoc)\n-            -> ValueRef {\n-    if cx.unreachable.get() {\n-        return _Undef(lhs);\n-    }\n-    debug_loc.apply(cx.fcx);\n-    B(cx).ashr(lhs, rhs)\n-}\n-\n-pub fn And(cx: Block,\n-           lhs: ValueRef,\n-           rhs: ValueRef,\n-           debug_loc: DebugLoc)\n-           -> ValueRef {\n-    if cx.unreachable.get() {\n-        return _Undef(lhs);\n-    }\n-    debug_loc.apply(cx.fcx);\n-    B(cx).and(lhs, rhs)\n-}\n-\n-pub fn Or(cx: Block,\n-          lhs: ValueRef,\n-          rhs: ValueRef,\n-          debug_loc: DebugLoc)\n-          -> ValueRef {\n-    if cx.unreachable.get() {\n-        return _Undef(lhs);\n-    }\n-    debug_loc.apply(cx.fcx);\n-    B(cx).or(lhs, rhs)\n-}\n-\n-pub fn Xor(cx: Block,\n-           lhs: ValueRef,\n-           rhs: ValueRef,\n-           debug_loc: DebugLoc)\n-           -> ValueRef {\n-    if cx.unreachable.get() {\n-        return _Undef(lhs);\n-    }\n-    debug_loc.apply(cx.fcx);\n-    B(cx).xor(lhs, rhs)\n-}\n-\n-pub fn BinOp(cx: Block,\n-             op: Opcode,\n-             lhs: ValueRef,\n-             rhs: ValueRef,\n-             debug_loc: DebugLoc)\n-          -> ValueRef {\n-    if cx.unreachable.get() {\n-        return _Undef(lhs);\n-    }\n-    debug_loc.apply(cx.fcx);\n-    B(cx).binop(op, lhs, rhs)\n-}\n-\n-pub fn Neg(cx: Block, v: ValueRef, debug_loc: DebugLoc) -> ValueRef {\n-    if cx.unreachable.get() {\n-        return _Undef(v);\n-    }\n-    debug_loc.apply(cx.fcx);\n-    B(cx).neg(v)\n-}\n-\n-pub fn NSWNeg(cx: Block, v: ValueRef, debug_loc: DebugLoc) -> ValueRef {\n-    if cx.unreachable.get() {\n-        return _Undef(v);\n-    }\n-    debug_loc.apply(cx.fcx);\n-    B(cx).nswneg(v)\n-}\n-\n-pub fn NUWNeg(cx: Block, v: ValueRef, debug_loc: DebugLoc) -> ValueRef {\n-    if cx.unreachable.get() {\n-        return _Undef(v);\n-    }\n-    debug_loc.apply(cx.fcx);\n-    B(cx).nuwneg(v)\n-}\n-pub fn FNeg(cx: Block, v: ValueRef, debug_loc: DebugLoc) -> ValueRef {\n-    if cx.unreachable.get() {\n-        return _Undef(v);\n-    }\n-    debug_loc.apply(cx.fcx);\n-    B(cx).fneg(v)\n-}\n-\n-pub fn Not(cx: Block, v: ValueRef, debug_loc: DebugLoc) -> ValueRef {\n-    if cx.unreachable.get() {\n-        return _Undef(v);\n-    }\n-    debug_loc.apply(cx.fcx);\n-    B(cx).not(v)\n-}\n-\n-pub fn Alloca(cx: Block, ty: Type, name: &str) -> ValueRef {\n-    unsafe {\n-        if cx.unreachable.get() { return llvm::LLVMGetUndef(ty.ptr_to().to_ref()); }\n-        AllocaFcx(cx.fcx, ty, name)\n-    }\n-}\n-\n-pub fn AllocaFcx(fcx: &FunctionContext, ty: Type, name: &str) -> ValueRef {\n-    let b = fcx.ccx.builder();\n-    b.position_before(fcx.alloca_insert_pt.get().unwrap());\n-    DebugLoc::None.apply(fcx);\n-    b.alloca(ty, name)\n-}\n-\n-pub fn Free(cx: Block, pointer_val: ValueRef) {\n-    if cx.unreachable.get() { return; }\n-    B(cx).free(pointer_val)\n-}\n-\n-pub fn Load(cx: Block, pointer_val: ValueRef) -> ValueRef {\n-    unsafe {\n-        let ccx = cx.fcx.ccx;\n-        if cx.unreachable.get() {\n-            let ty = val_ty(pointer_val);\n-            let eltty = if ty.kind() == llvm::Array {\n-                ty.element_type()\n-            } else {\n-                ccx.int_type()\n-            };\n-            return llvm::LLVMGetUndef(eltty.to_ref());\n-        }\n-        B(cx).load(pointer_val)\n-    }\n-}\n-\n-pub fn VolatileLoad(cx: Block, pointer_val: ValueRef) -> ValueRef {\n-    unsafe {\n-        if cx.unreachable.get() {\n-            return llvm::LLVMGetUndef(Type::nil(cx.ccx()).to_ref());\n-        }\n-        B(cx).volatile_load(pointer_val)\n-    }\n-}\n-\n-pub fn AtomicLoad(cx: Block, pointer_val: ValueRef, order: AtomicOrdering) -> ValueRef {\n-    unsafe {\n-        let ccx = cx.fcx.ccx;\n-        if cx.unreachable.get() {\n-            return llvm::LLVMGetUndef(ccx.int_type().to_ref());\n-        }\n-        B(cx).atomic_load(pointer_val, order)\n-    }\n-}\n-\n-\n-pub fn LoadRangeAssert(cx: Block, pointer_val: ValueRef, lo: u64,\n-                       hi: u64, signed: llvm::Bool) -> ValueRef {\n-    if cx.unreachable.get() {\n-        let ccx = cx.fcx.ccx;\n-        let ty = val_ty(pointer_val);\n-        let eltty = if ty.kind() == llvm::Array {\n-            ty.element_type()\n-        } else {\n-            ccx.int_type()\n-        };\n-        unsafe {\n-            llvm::LLVMGetUndef(eltty.to_ref())\n-        }\n-    } else {\n-        B(cx).load_range_assert(pointer_val, lo, hi, signed)\n-    }\n-}\n-\n-pub fn LoadNonNull(cx: Block, ptr: ValueRef) -> ValueRef {\n-    if cx.unreachable.get() {\n-        let ccx = cx.fcx.ccx;\n-        let ty = val_ty(ptr);\n-        let eltty = if ty.kind() == llvm::Array {\n-            ty.element_type()\n-        } else {\n-            ccx.int_type()\n-        };\n-        unsafe {\n-            llvm::LLVMGetUndef(eltty.to_ref())\n-        }\n-    } else {\n-        B(cx).load_nonnull(ptr)\n-    }\n-}\n-\n-pub fn Store(cx: Block, val: ValueRef, ptr: ValueRef) -> ValueRef {\n-    if cx.unreachable.get() { return C_nil(cx.ccx()); }\n-    B(cx).store(val, ptr)\n-}\n-\n-pub fn VolatileStore(cx: Block, val: ValueRef, ptr: ValueRef) -> ValueRef {\n-    if cx.unreachable.get() { return C_nil(cx.ccx()); }\n-    B(cx).volatile_store(val, ptr)\n-}\n-\n-pub fn AtomicStore(cx: Block, val: ValueRef, ptr: ValueRef, order: AtomicOrdering) {\n-    if cx.unreachable.get() { return; }\n-    B(cx).atomic_store(val, ptr, order)\n-}\n-\n-pub fn GEP(cx: Block, pointer: ValueRef, indices: &[ValueRef]) -> ValueRef {\n-    unsafe {\n-        if cx.unreachable.get() {\n-            return llvm::LLVMGetUndef(Type::nil(cx.ccx()).ptr_to().to_ref());\n-        }\n-        B(cx).gep(pointer, indices)\n-    }\n-}\n-\n-// Simple wrapper around GEP that takes an array of ints and wraps them\n-// in C_i32()\n-#[inline]\n-pub fn GEPi(cx: Block, base: ValueRef, ixs: &[usize]) -> ValueRef {\n-    unsafe {\n-        if cx.unreachable.get() {\n-            return llvm::LLVMGetUndef(Type::nil(cx.ccx()).ptr_to().to_ref());\n-        }\n-        B(cx).gepi(base, ixs)\n-    }\n-}\n-\n-pub fn InBoundsGEP(cx: Block, pointer: ValueRef, indices: &[ValueRef]) -> ValueRef {\n-    unsafe {\n-        if cx.unreachable.get() {\n-            return llvm::LLVMGetUndef(Type::nil(cx.ccx()).ptr_to().to_ref());\n-        }\n-        B(cx).inbounds_gep(pointer, indices)\n-    }\n-}\n-\n-pub fn StructGEP(cx: Block, pointer: ValueRef, idx: usize) -> ValueRef {\n-    unsafe {\n-        if cx.unreachable.get() {\n-            return llvm::LLVMGetUndef(Type::nil(cx.ccx()).ptr_to().to_ref());\n-        }\n-        B(cx).struct_gep(pointer, idx)\n-    }\n-}\n-\n-pub fn GlobalString(cx: Block, _str: *const c_char) -> ValueRef {\n-    unsafe {\n-        if cx.unreachable.get() {\n-            return llvm::LLVMGetUndef(Type::i8p(cx.ccx()).to_ref());\n-        }\n-        B(cx).global_string(_str)\n-    }\n-}\n-\n-pub fn GlobalStringPtr(cx: Block, _str: *const c_char) -> ValueRef {\n-    unsafe {\n-        if cx.unreachable.get() {\n-            return llvm::LLVMGetUndef(Type::i8p(cx.ccx()).to_ref());\n-        }\n-        B(cx).global_string_ptr(_str)\n-    }\n-}\n-\n-/* Casts */\n-pub fn Trunc(cx: Block, val: ValueRef, dest_ty: Type) -> ValueRef {\n-    unsafe {\n-        if cx.unreachable.get() { return llvm::LLVMGetUndef(dest_ty.to_ref()); }\n-        B(cx).trunc(val, dest_ty)\n-    }\n-}\n-\n-pub fn ZExt(cx: Block, val: ValueRef, dest_ty: Type) -> ValueRef {\n-    unsafe {\n-        if cx.unreachable.get() { return llvm::LLVMGetUndef(dest_ty.to_ref()); }\n-        B(cx).zext(val, dest_ty)\n-    }\n-}\n-\n-pub fn SExt(cx: Block, val: ValueRef, dest_ty: Type) -> ValueRef {\n-    unsafe {\n-        if cx.unreachable.get() { return llvm::LLVMGetUndef(dest_ty.to_ref()); }\n-        B(cx).sext(val, dest_ty)\n-    }\n-}\n-\n-pub fn FPToUI(cx: Block, val: ValueRef, dest_ty: Type) -> ValueRef {\n-    unsafe {\n-        if cx.unreachable.get() { return llvm::LLVMGetUndef(dest_ty.to_ref()); }\n-        B(cx).fptoui(val, dest_ty)\n-    }\n-}\n-\n-pub fn FPToSI(cx: Block, val: ValueRef, dest_ty: Type) -> ValueRef {\n-    unsafe {\n-        if cx.unreachable.get() { return llvm::LLVMGetUndef(dest_ty.to_ref()); }\n-        B(cx).fptosi(val, dest_ty)\n-    }\n-}\n-\n-pub fn UIToFP(cx: Block, val: ValueRef, dest_ty: Type) -> ValueRef {\n-    unsafe {\n-        if cx.unreachable.get() { return llvm::LLVMGetUndef(dest_ty.to_ref()); }\n-        B(cx).uitofp(val, dest_ty)\n-    }\n-}\n-\n-pub fn SIToFP(cx: Block, val: ValueRef, dest_ty: Type) -> ValueRef {\n-    unsafe {\n-        if cx.unreachable.get() { return llvm::LLVMGetUndef(dest_ty.to_ref()); }\n-        B(cx).sitofp(val, dest_ty)\n-    }\n-}\n-\n-pub fn FPTrunc(cx: Block, val: ValueRef, dest_ty: Type) -> ValueRef {\n-    unsafe {\n-        if cx.unreachable.get() { return llvm::LLVMGetUndef(dest_ty.to_ref()); }\n-        B(cx).fptrunc(val, dest_ty)\n-    }\n-}\n-\n-pub fn FPExt(cx: Block, val: ValueRef, dest_ty: Type) -> ValueRef {\n-    unsafe {\n-        if cx.unreachable.get() { return llvm::LLVMGetUndef(dest_ty.to_ref()); }\n-        B(cx).fpext(val, dest_ty)\n-    }\n-}\n-\n-pub fn PtrToInt(cx: Block, val: ValueRef, dest_ty: Type) -> ValueRef {\n-    unsafe {\n-        if cx.unreachable.get() { return llvm::LLVMGetUndef(dest_ty.to_ref()); }\n-        B(cx).ptrtoint(val, dest_ty)\n-    }\n-}\n-\n-pub fn IntToPtr(cx: Block, val: ValueRef, dest_ty: Type) -> ValueRef {\n-    unsafe {\n-        if cx.unreachable.get() { return llvm::LLVMGetUndef(dest_ty.to_ref()); }\n-        B(cx).inttoptr(val, dest_ty)\n-    }\n-}\n-\n-pub fn BitCast(cx: Block, val: ValueRef, dest_ty: Type) -> ValueRef {\n-    unsafe {\n-        if cx.unreachable.get() { return llvm::LLVMGetUndef(dest_ty.to_ref()); }\n-        B(cx).bitcast(val, dest_ty)\n-    }\n-}\n-\n-pub fn ZExtOrBitCast(cx: Block, val: ValueRef, dest_ty: Type) -> ValueRef {\n-    unsafe {\n-        if cx.unreachable.get() { return llvm::LLVMGetUndef(dest_ty.to_ref()); }\n-        B(cx).zext_or_bitcast(val, dest_ty)\n-    }\n-}\n-\n-pub fn SExtOrBitCast(cx: Block, val: ValueRef, dest_ty: Type) -> ValueRef {\n-    unsafe {\n-        if cx.unreachable.get() { return llvm::LLVMGetUndef(dest_ty.to_ref()); }\n-        B(cx).sext_or_bitcast(val, dest_ty)\n-    }\n-}\n-\n-pub fn TruncOrBitCast(cx: Block, val: ValueRef, dest_ty: Type) -> ValueRef {\n-    unsafe {\n-        if cx.unreachable.get() { return llvm::LLVMGetUndef(dest_ty.to_ref()); }\n-        B(cx).trunc_or_bitcast(val, dest_ty)\n-    }\n-}\n-\n-pub fn Cast(cx: Block, op: Opcode, val: ValueRef, dest_ty: Type,\n-            _: *const u8)\n-     -> ValueRef {\n-    unsafe {\n-        if cx.unreachable.get() { return llvm::LLVMGetUndef(dest_ty.to_ref()); }\n-        B(cx).cast(op, val, dest_ty)\n-    }\n-}\n-\n-pub fn PointerCast(cx: Block, val: ValueRef, dest_ty: Type) -> ValueRef {\n-    unsafe {\n-        if cx.unreachable.get() { return llvm::LLVMGetUndef(dest_ty.to_ref()); }\n-        B(cx).pointercast(val, dest_ty)\n-    }\n-}\n-\n-pub fn IntCast(cx: Block, val: ValueRef, dest_ty: Type) -> ValueRef {\n-    unsafe {\n-        if cx.unreachable.get() { return llvm::LLVMGetUndef(dest_ty.to_ref()); }\n-        B(cx).intcast(val, dest_ty)\n-    }\n-}\n-\n-pub fn FPCast(cx: Block, val: ValueRef, dest_ty: Type) -> ValueRef {\n-    unsafe {\n-        if cx.unreachable.get() { return llvm::LLVMGetUndef(dest_ty.to_ref()); }\n-        B(cx).fpcast(val, dest_ty)\n-    }\n-}\n-\n-\n-/* Comparisons */\n-pub fn ICmp(cx: Block,\n-            op: IntPredicate,\n-            lhs: ValueRef,\n-            rhs: ValueRef,\n-            debug_loc: DebugLoc)\n-            -> ValueRef {\n-    unsafe {\n-        if cx.unreachable.get() {\n-            return llvm::LLVMGetUndef(Type::i1(cx.ccx()).to_ref());\n-        }\n-        debug_loc.apply(cx.fcx);\n-        B(cx).icmp(op, lhs, rhs)\n-    }\n-}\n-\n-pub fn FCmp(cx: Block,\n-            op: RealPredicate,\n-            lhs: ValueRef,\n-            rhs: ValueRef,\n-            debug_loc: DebugLoc)\n-            -> ValueRef {\n-    unsafe {\n-        if cx.unreachable.get() {\n-            return llvm::LLVMGetUndef(Type::i1(cx.ccx()).to_ref());\n-        }\n-        debug_loc.apply(cx.fcx);\n-        B(cx).fcmp(op, lhs, rhs)\n-    }\n-}\n-\n-/* Miscellaneous instructions */\n-pub fn EmptyPhi(cx: Block, ty: Type) -> ValueRef {\n-    unsafe {\n-        if cx.unreachable.get() { return llvm::LLVMGetUndef(ty.to_ref()); }\n-        B(cx).empty_phi(ty)\n-    }\n-}\n-\n-pub fn Phi(cx: Block, ty: Type, vals: &[ValueRef],\n-           bbs: &[BasicBlockRef]) -> ValueRef {\n-    unsafe {\n-        if cx.unreachable.get() { return llvm::LLVMGetUndef(ty.to_ref()); }\n-        B(cx).phi(ty, vals, bbs)\n-    }\n-}\n-\n-pub fn AddIncomingToPhi(phi: ValueRef, val: ValueRef, bb: BasicBlockRef) {\n-    unsafe {\n-        if llvm::LLVMIsUndef(phi) == llvm::True { return; }\n-        llvm::LLVMAddIncoming(phi, &val, &bb, 1 as c_uint);\n-    }\n-}\n-\n-pub fn _UndefReturn(cx: Block, fn_: ValueRef) -> ValueRef {\n-    unsafe {\n-        let ccx = cx.fcx.ccx;\n-        let ty = val_ty(fn_);\n-        let retty = if ty.kind() == llvm::Function {\n-            ty.return_type()\n-        } else {\n-            ccx.int_type()\n-        };\n-        B(cx).count_insn(\"ret_undef\");\n-        llvm::LLVMGetUndef(retty.to_ref())\n-    }\n-}\n-\n-pub fn add_span_comment(cx: Block, sp: Span, text: &str) {\n-    B(cx).add_span_comment(sp, text)\n-}\n-\n-pub fn add_comment(cx: Block, text: &str) {\n-    B(cx).add_comment(text)\n-}\n-\n-pub fn InlineAsmCall(cx: Block, asm: *const c_char, cons: *const c_char,\n-                     inputs: &[ValueRef], output: Type,\n-                     volatile: bool, alignstack: bool,\n-                     dia: AsmDialect) -> ValueRef {\n-    B(cx).inline_asm_call(asm, cons, inputs, output, volatile, alignstack, dia)\n-}\n-\n-pub fn Call(cx: Block,\n-            fn_: ValueRef,\n-            args: &[ValueRef],\n-            debug_loc: DebugLoc)\n-            -> ValueRef {\n-    if cx.unreachable.get() {\n-        return _UndefReturn(cx, fn_);\n-    }\n-    debug_loc.apply(cx.fcx);\n-    let bundle = cx.lpad.get().and_then(|b| b.bundle());\n-    B(cx).call(fn_, args, bundle)\n-}\n-\n-pub fn AtomicFence(cx: Block, order: AtomicOrdering, scope: SynchronizationScope) {\n-    if cx.unreachable.get() { return; }\n-    B(cx).atomic_fence(order, scope)\n-}\n-\n-pub fn Select(cx: Block, if_: ValueRef, then: ValueRef, else_: ValueRef) -> ValueRef {\n-    if cx.unreachable.get() { return _Undef(then); }\n-    B(cx).select(if_, then, else_)\n-}\n-\n-pub fn VAArg(cx: Block, list: ValueRef, ty: Type) -> ValueRef {\n-    unsafe {\n-        if cx.unreachable.get() { return llvm::LLVMGetUndef(ty.to_ref()); }\n-        B(cx).va_arg(list, ty)\n-    }\n-}\n-\n-pub fn ExtractElement(cx: Block, vec_val: ValueRef, index: ValueRef) -> ValueRef {\n-    unsafe {\n-        if cx.unreachable.get() {\n-            return llvm::LLVMGetUndef(Type::nil(cx.ccx()).to_ref());\n-        }\n-        B(cx).extract_element(vec_val, index)\n-    }\n-}\n-\n-pub fn InsertElement(cx: Block, vec_val: ValueRef, elt_val: ValueRef,\n-                     index: ValueRef) -> ValueRef {\n-    unsafe {\n-        if cx.unreachable.get() {\n-            return llvm::LLVMGetUndef(Type::nil(cx.ccx()).to_ref());\n-        }\n-        B(cx).insert_element(vec_val, elt_val, index)\n-    }\n-}\n-\n-pub fn ShuffleVector(cx: Block, v1: ValueRef, v2: ValueRef,\n-                     mask: ValueRef) -> ValueRef {\n-    unsafe {\n-        if cx.unreachable.get() {\n-            return llvm::LLVMGetUndef(Type::nil(cx.ccx()).to_ref());\n-        }\n-        B(cx).shuffle_vector(v1, v2, mask)\n-    }\n-}\n-\n-pub fn VectorSplat(cx: Block, num_elts: usize, elt_val: ValueRef) -> ValueRef {\n-    unsafe {\n-        if cx.unreachable.get() {\n-            return llvm::LLVMGetUndef(Type::nil(cx.ccx()).to_ref());\n-        }\n-        B(cx).vector_splat(num_elts, elt_val)\n-    }\n-}\n-\n-pub fn ExtractValue(cx: Block, agg_val: ValueRef, index: usize) -> ValueRef {\n-    unsafe {\n-        if cx.unreachable.get() {\n-            return llvm::LLVMGetUndef(Type::nil(cx.ccx()).to_ref());\n-        }\n-        B(cx).extract_value(agg_val, index)\n-    }\n-}\n-\n-pub fn InsertValue(cx: Block, agg_val: ValueRef, elt_val: ValueRef, index: usize) -> ValueRef {\n-    unsafe {\n-        if cx.unreachable.get() {\n-            return llvm::LLVMGetUndef(Type::nil(cx.ccx()).to_ref());\n-        }\n-        B(cx).insert_value(agg_val, elt_val, index)\n-    }\n-}\n-\n-pub fn IsNull(cx: Block, val: ValueRef) -> ValueRef {\n-    unsafe {\n-        if cx.unreachable.get() {\n-            return llvm::LLVMGetUndef(Type::i1(cx.ccx()).to_ref());\n-        }\n-        B(cx).is_null(val)\n-    }\n-}\n-\n-pub fn IsNotNull(cx: Block, val: ValueRef) -> ValueRef {\n-    unsafe {\n-        if cx.unreachable.get() {\n-            return llvm::LLVMGetUndef(Type::i1(cx.ccx()).to_ref());\n-        }\n-        B(cx).is_not_null(val)\n-    }\n-}\n-\n-pub fn PtrDiff(cx: Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n-    unsafe {\n-        let ccx = cx.fcx.ccx;\n-        if cx.unreachable.get() { return llvm::LLVMGetUndef(ccx.int_type().to_ref()); }\n-        B(cx).ptrdiff(lhs, rhs)\n-    }\n-}\n-\n-pub fn Trap(cx: Block) {\n-    if cx.unreachable.get() { return; }\n-    B(cx).trap();\n-}\n-\n-pub fn LandingPad(cx: Block, ty: Type, pers_fn: ValueRef,\n-                  num_clauses: usize) -> ValueRef {\n-    check_not_terminated(cx);\n-    assert!(!cx.unreachable.get());\n-    B(cx).landing_pad(ty, pers_fn, num_clauses, cx.fcx.llfn)\n-}\n-\n-pub fn AddClause(cx: Block, landing_pad: ValueRef, clause: ValueRef) {\n-    B(cx).add_clause(landing_pad, clause)\n-}\n-\n-pub fn SetCleanup(cx: Block, landing_pad: ValueRef) {\n-    B(cx).set_cleanup(landing_pad)\n-}\n-\n-pub fn SetPersonalityFn(cx: Block, f: ValueRef) {\n-    B(cx).set_personality_fn(f)\n-}\n-\n-pub fn Resume(cx: Block, exn: ValueRef) -> ValueRef {\n-    check_not_terminated(cx);\n-    terminate(cx, \"Resume\");\n-    B(cx).resume(exn)\n-}\n-\n-// Atomic Operations\n-pub fn AtomicCmpXchg(cx: Block, dst: ValueRef,\n-                     cmp: ValueRef, src: ValueRef,\n-                     order: AtomicOrdering,\n-                     failure_order: AtomicOrdering,\n-                     weak: llvm::Bool) -> ValueRef {\n-    B(cx).atomic_cmpxchg(dst, cmp, src, order, failure_order, weak)\n-}\n-pub fn AtomicRMW(cx: Block, op: AtomicRmwBinOp,\n-                 dst: ValueRef, src: ValueRef,\n-                 order: AtomicOrdering) -> ValueRef {\n-    B(cx).atomic_rmw(op, dst, src, order)\n-}\n-\n-pub fn CleanupPad(cx: Block,\n-                  parent: Option<ValueRef>,\n-                  args: &[ValueRef]) -> ValueRef {\n-    check_not_terminated(cx);\n-    assert!(!cx.unreachable.get());\n-    B(cx).cleanup_pad(parent, args)\n-}\n-\n-pub fn CleanupRet(cx: Block,\n-                  cleanup: ValueRef,\n-                  unwind: Option<BasicBlockRef>) -> ValueRef {\n-    check_not_terminated(cx);\n-    terminate(cx, \"CleanupRet\");\n-    B(cx).cleanup_ret(cleanup, unwind)\n-}\n-\n-pub fn CatchPad(cx: Block,\n-                parent: ValueRef,\n-                args: &[ValueRef]) -> ValueRef {\n-    check_not_terminated(cx);\n-    assert!(!cx.unreachable.get());\n-    B(cx).catch_pad(parent, args)\n-}\n-\n-pub fn CatchRet(cx: Block, pad: ValueRef, unwind: BasicBlockRef) -> ValueRef {\n-    check_not_terminated(cx);\n-    terminate(cx, \"CatchRet\");\n-    B(cx).catch_ret(pad, unwind)\n-}\n-\n-pub fn CatchSwitch(cx: Block,\n-                   parent: Option<ValueRef>,\n-                   unwind: Option<BasicBlockRef>,\n-                   num_handlers: usize) -> ValueRef {\n-    check_not_terminated(cx);\n-    terminate(cx, \"CatchSwitch\");\n-    B(cx).catch_switch(parent, unwind, num_handlers)\n-}\n-\n-pub fn AddHandler(cx: Block, catch_switch: ValueRef, handler: BasicBlockRef) {\n-    B(cx).add_handler(catch_switch, handler)\n-}"}, {"sha": "136d1aad31a03965077995779028848e8b3ae033", "filename": "src/librustc_trans/builder.rs", "status": "modified", "additions": 34, "deletions": 47, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_trans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_trans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbuilder.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -14,12 +14,10 @@ use llvm;\n use llvm::{AtomicRmwBinOp, AtomicOrdering, SynchronizationScope, AsmDialect};\n use llvm::{Opcode, IntPredicate, RealPredicate, False, OperandBundleDef};\n use llvm::{ValueRef, BasicBlockRef, BuilderRef, ModuleRef};\n-use base;\n use common::*;\n use machine::llalign_of_pref;\n use type_::Type;\n use value::Value;\n-use util::nodemap::FxHashMap;\n use libc::{c_uint, c_char};\n \n use std::borrow::Cow;\n@@ -32,65 +30,40 @@ pub struct Builder<'a, 'tcx: 'a> {\n     pub ccx: &'a CrateContext<'a, 'tcx>,\n }\n \n+impl<'a, 'tcx> Drop for Builder<'a, 'tcx> {\n+    fn drop(&mut self) {\n+        unsafe {\n+            llvm::LLVMDisposeBuilder(self.llbuilder);\n+        }\n+    }\n+}\n+\n // This is a really awful way to get a zero-length c-string, but better (and a\n // lot more efficient) than doing str::as_c_str(\"\", ...) every time.\n-pub fn noname() -> *const c_char {\n+fn noname() -> *const c_char {\n     static CNULL: c_char = 0;\n     &CNULL\n }\n \n impl<'a, 'tcx> Builder<'a, 'tcx> {\n-    pub fn new(ccx: &'a CrateContext<'a, 'tcx>) -> Builder<'a, 'tcx> {\n+    pub fn with_ccx(ccx: &'a CrateContext<'a, 'tcx>) -> Self {\n+        // Create a fresh builder from the crate context.\n+        let llbuilder = unsafe {\n+            llvm::LLVMCreateBuilderInContext(ccx.llcx())\n+        };\n         Builder {\n-            llbuilder: ccx.raw_builder(),\n+            llbuilder: llbuilder,\n             ccx: ccx,\n         }\n     }\n \n-    pub fn count_insn(&self, category: &str) {\n+    fn count_insn(&self, category: &str) {\n         if self.ccx.sess().trans_stats() {\n-            self.ccx.stats().n_llvm_insns.set(self.ccx\n-                                                .stats()\n-                                                .n_llvm_insns\n-                                                .get() + 1);\n+            self.ccx.stats().n_llvm_insns.set(self.ccx.stats().n_llvm_insns.get() + 1);\n         }\n-        self.ccx.count_llvm_insn();\n         if self.ccx.sess().count_llvm_insns() {\n-            base::with_insn_ctxt(|v| {\n-                let mut h = self.ccx.stats().llvm_insns.borrow_mut();\n-\n-                // Build version of path with cycles removed.\n-\n-                // Pass 1: scan table mapping str -> rightmost pos.\n-                let mut mm = FxHashMap();\n-                let len = v.len();\n-                let mut i = 0;\n-                while i < len {\n-                    mm.insert(v[i], i);\n-                    i += 1;\n-                }\n-\n-                // Pass 2: concat strings for each elt, skipping\n-                // forwards over any cycles by advancing to rightmost\n-                // occurrence of each element in path.\n-                let mut s = String::from(\".\");\n-                i = 0;\n-                while i < len {\n-                    i = mm[v[i]];\n-                    s.push('/');\n-                    s.push_str(v[i]);\n-                    i += 1;\n-                }\n-\n-                s.push('/');\n-                s.push_str(category);\n-\n-                let n = match h.get(&s) {\n-                    Some(&n) => n,\n-                    _ => 0\n-                };\n-                h.insert(s, n+1);\n-            })\n+            let mut h = self.ccx.stats().llvm_insns.borrow_mut();\n+            *h.entry(category.to_string()).or_insert(0) += 1;\n         }\n     }\n \n@@ -462,7 +435,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n     }\n \n-    pub fn alloca(&self, ty: Type, name: &str) -> ValueRef {\n+    pub fn dynamic_alloca(&self, ty: Type, name: &str) -> ValueRef {\n         self.count_insn(\"alloca\");\n         unsafe {\n             if name.is_empty() {\n@@ -1103,6 +1076,20 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n     }\n \n+    pub fn add_case(&self, s: ValueRef, on_val: ValueRef, dest: BasicBlockRef) {\n+        unsafe {\n+            if llvm::LLVMIsUndef(s) == llvm::True { return; }\n+            llvm::LLVMAddCase(s, on_val, dest)\n+        }\n+    }\n+\n+    pub fn add_incoming_to_phi(&self, phi: ValueRef, val: ValueRef, bb: BasicBlockRef) {\n+        unsafe {\n+            if llvm::LLVMIsUndef(phi) == llvm::True { return; }\n+            llvm::LLVMAddIncoming(phi, &val, &bb, 1 as c_uint);\n+        }\n+    }\n+\n     /// Returns the ptr value that should be used for storing `val`.\n     fn check_store<'b>(&self,\n                        val: ValueRef,"}, {"sha": "85b26074bae6d4358758eaea18d7bd0f3a5ba427", "filename": "src/librustc_trans/cabi_arm.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_trans%2Fcabi_arm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_trans%2Fcabi_arm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_arm.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![allow(non_upper_case_globals)]\n-\n use llvm::{Integer, Pointer, Float, Double, Struct, Array, Vector};\n use abi::{self, align_up_to, FnType, ArgType};\n use context::CrateContext;"}, {"sha": "25fe53e7ef40f88ab96ba44d3ed6198a9af6fd24", "filename": "src/librustc_trans/cabi_sparc.rs", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_trans%2Fcabi_sparc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_trans%2Fcabi_sparc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_sparc.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -0,0 +1,108 @@\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(non_upper_case_globals)]\n+\n+use libc::c_uint;\n+use std::cmp;\n+use llvm;\n+use llvm::{Integer, Pointer, Float, Double, Vector};\n+use abi::{self, align_up_to, ArgType, FnType};\n+use context::CrateContext;\n+use type_::Type;\n+\n+fn ty_align(ty: Type) -> usize {\n+    abi::ty_align(ty, 4)\n+}\n+\n+fn ty_size(ty: Type) -> usize {\n+    abi::ty_size(ty, 4)\n+}\n+\n+fn classify_ret_ty(ccx: &CrateContext, ret: &mut ArgType) {\n+    if is_reg_ty(ret.ty) {\n+        ret.extend_integer_width_to(32);\n+    } else {\n+        ret.make_indirect(ccx);\n+    }\n+}\n+\n+fn classify_arg_ty(ccx: &CrateContext, arg: &mut ArgType, offset: &mut usize) {\n+    let orig_offset = *offset;\n+    let size = ty_size(arg.ty) * 8;\n+    let mut align = ty_align(arg.ty);\n+\n+    align = cmp::min(cmp::max(align, 4), 8);\n+    *offset = align_up_to(*offset, align);\n+    *offset += align_up_to(size, align * 8) / 8;\n+\n+    if !is_reg_ty(arg.ty) {\n+        arg.cast = Some(struct_ty(ccx, arg.ty));\n+        arg.pad = padding_ty(ccx, align, orig_offset);\n+    } else {\n+        arg.extend_integer_width_to(32);\n+    }\n+}\n+\n+fn is_reg_ty(ty: Type) -> bool {\n+    return match ty.kind() {\n+        Integer\n+        | Pointer\n+        | Float\n+        | Double\n+        | Vector => true,\n+        _ => false\n+    };\n+}\n+\n+fn padding_ty(ccx: &CrateContext, align: usize, offset: usize) -> Option<Type> {\n+    if ((align - 1 ) & offset) > 0 {\n+        Some(Type::i32(ccx))\n+    } else {\n+        None\n+    }\n+}\n+\n+fn coerce_to_int(ccx: &CrateContext, size: usize) -> Vec<Type> {\n+    let int_ty = Type::i32(ccx);\n+    let mut args = Vec::new();\n+\n+    let mut n = size / 32;\n+    while n > 0 {\n+        args.push(int_ty);\n+        n -= 1;\n+    }\n+\n+    let r = size % 32;\n+    if r > 0 {\n+        unsafe {\n+            args.push(Type::from_ref(llvm::LLVMIntTypeInContext(ccx.llcx(), r as c_uint)));\n+        }\n+    }\n+\n+    args\n+}\n+\n+fn struct_ty(ccx: &CrateContext, ty: Type) -> Type {\n+    let size = ty_size(ty) * 8;\n+    Type::struct_(ccx, &coerce_to_int(ccx, size), false)\n+}\n+\n+pub fn compute_abi_info(ccx: &CrateContext, fty: &mut FnType) {\n+    if !fty.ret.is_ignore() {\n+        classify_ret_ty(ccx, &mut fty.ret);\n+    }\n+\n+    let mut offset = if fty.ret.is_indirect() { 4 } else { 0 };\n+    for arg in &mut fty.args {\n+        if arg.is_ignore() { continue; }\n+        classify_arg_ty(ccx, arg, &mut offset);\n+    }\n+}"}, {"sha": "fea005f3d77da388194cdaf7a9f4d1734b544dd0", "filename": "src/librustc_trans/cabi_x86.rs", "status": "modified", "additions": 49, "deletions": 1, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_trans%2Fcabi_x86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_trans%2Fcabi_x86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_x86.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -14,7 +14,13 @@ use type_::Type;\n use super::common::*;\n use super::machine::*;\n \n-pub fn compute_abi_info(ccx: &CrateContext, fty: &mut FnType) {\n+#[derive(PartialEq)]\n+pub enum Flavor {\n+    General,\n+    Fastcall\n+}\n+\n+pub fn compute_abi_info(ccx: &CrateContext, fty: &mut FnType, flavor: Flavor) {\n     if !fty.ret.is_ignore() {\n         if fty.ret.ty.kind() == Struct {\n             // Returning a structure. Most often, this will use\n@@ -51,4 +57,46 @@ pub fn compute_abi_info(ccx: &CrateContext, fty: &mut FnType) {\n             arg.extend_integer_width_to(32);\n         }\n     }\n+\n+    if flavor == Flavor::Fastcall {\n+        // Mark arguments as InReg like clang does it,\n+        // so our fastcall is compatible with C/C++ fastcall.\n+\n+        // Clang reference: lib/CodeGen/TargetInfo.cpp\n+        // See X86_32ABIInfo::shouldPrimitiveUseInReg(), X86_32ABIInfo::updateFreeRegs()\n+\n+        // IsSoftFloatABI is only set to true on ARM platforms,\n+        // which in turn can't be x86?\n+\n+        let mut free_regs = 2;\n+\n+        for arg in &mut fty.args {\n+            if arg.is_ignore() || arg.is_indirect() { continue; }\n+\n+            if arg.ty.kind() == Float {\n+                continue;\n+            }\n+\n+            let size = llbitsize_of_real(ccx, arg.ty);\n+            let size_in_regs = (size + 31) / 32;\n+\n+            if size_in_regs == 0 {\n+                continue;\n+            }\n+\n+            if size_in_regs > free_regs {\n+                break;\n+            }\n+\n+            free_regs -= size_in_regs;\n+\n+            if size <= 32 && (arg.ty.kind() == Pointer || arg.ty.kind() == Integer) {\n+                arg.attrs.set(ArgAttribute::InReg);\n+            }\n+\n+            if free_regs == 0 {\n+                break;\n+            }\n+        }\n+    }\n }"}, {"sha": "1abe25ea6073e6579dbb0e464076b04f896430d3", "filename": "src/librustc_trans/callee.rs", "status": "modified", "additions": 60, "deletions": 167, "changes": 227, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_trans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_trans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcallee.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -16,7 +16,6 @@\n \n pub use self::CalleeData::*;\n \n-use arena::TypedArena;\n use llvm::{self, ValueRef, get_params};\n use rustc::hir::def_id::DefId;\n use rustc::ty::subst::Substs;\n@@ -25,10 +24,11 @@ use abi::{Abi, FnType};\n use attributes;\n use base;\n use base::*;\n-use build::*;\n-use common::{self, Block, Result, CrateContext, FunctionContext, SharedCrateContext};\n+use common::{\n+    self, CrateContext, FunctionContext, SharedCrateContext\n+};\n+use adt::MaybeSizedValue;\n use consts;\n-use debuginfo::DebugLoc;\n use declare;\n use value::Value;\n use meth;\n@@ -71,25 +71,8 @@ impl<'tcx> Callee<'tcx> {\n         }\n     }\n \n-    /// Trait or impl method call.\n-    pub fn method_call<'blk>(bcx: Block<'blk, 'tcx>,\n-                             method_call: ty::MethodCall)\n-                             -> Callee<'tcx> {\n-        let method = bcx.tcx().tables().method_map[&method_call];\n-        Callee::method(bcx, method)\n-    }\n-\n-    /// Trait or impl method.\n-    pub fn method<'blk>(bcx: Block<'blk, 'tcx>,\n-                        method: ty::MethodCallee<'tcx>) -> Callee<'tcx> {\n-        let substs = bcx.fcx.monomorphize(&method.substs);\n-        Callee::def(bcx.ccx(), method.def_id, substs)\n-    }\n-\n     /// Function or method definition.\n-    pub fn def<'a>(ccx: &CrateContext<'a, 'tcx>,\n-                   def_id: DefId,\n-                   substs: &'tcx Substs<'tcx>)\n+    pub fn def<'a>(ccx: &CrateContext<'a, 'tcx>, def_id: DefId, substs: &'tcx Substs<'tcx>)\n                    -> Callee<'tcx> {\n         let tcx = ccx.tcx();\n \n@@ -196,25 +179,6 @@ impl<'tcx> Callee<'tcx> {\n         fn_ty\n     }\n \n-    /// This behemoth of a function translates function calls. Unfortunately, in\n-    /// order to generate more efficient LLVM output at -O0, it has quite a complex\n-    /// signature (refactoring this into two functions seems like a good idea).\n-    ///\n-    /// In particular, for lang items, it is invoked with a dest of None, and in\n-    /// that case the return value contains the result of the fn. The lang item must\n-    /// not return a structural type or else all heck breaks loose.\n-    ///\n-    /// For non-lang items, `dest` is always Some, and hence the result is written\n-    /// into memory somewhere. Nonetheless we return the actual return value of the\n-    /// function.\n-    pub fn call<'a, 'blk>(self, bcx: Block<'blk, 'tcx>,\n-                          debug_loc: DebugLoc,\n-                          args: &[ValueRef],\n-                          dest: Option<ValueRef>)\n-                          -> Result<'blk, 'tcx> {\n-        trans_call_inner(bcx, debug_loc, self, args, dest)\n-    }\n-\n     /// Turn the callee into a function pointer.\n     pub fn reify<'a>(self, ccx: &CrateContext<'a, 'tcx>) -> ValueRef {\n         match self.data {\n@@ -267,8 +231,6 @@ fn trans_closure_method<'a, 'tcx>(ccx: &'a CrateContext<'a, 'tcx>,\n     // then adapt the self type\n     let llfn_closure_kind = ccx.tcx().closure_kind(def_id);\n \n-    let _icx = push_ctxt(\"trans_closure_adapter_shim\");\n-\n     debug!(\"trans_closure_adapter_shim(llfn_closure_kind={:?}, \\\n            trait_closure_kind={:?}, llfn={:?})\",\n            llfn_closure_kind, trait_closure_kind, Value(llfn));\n@@ -367,57 +329,66 @@ fn trans_fn_once_adapter_shim<'a, 'tcx>(\n     let lloncefn = declare::define_internal_fn(ccx, &function_name, llonce_fn_ty);\n     attributes::set_frame_pointer_elimination(ccx, lloncefn);\n \n-    let (block_arena, fcx): (TypedArena<_>, FunctionContext);\n-    block_arena = TypedArena::new();\n-    fcx = FunctionContext::new(ccx, lloncefn, fn_ty, None, &block_arena);\n-    let mut bcx = fcx.init(false);\n+    let orig_fn_ty = fn_ty;\n+    let fcx = FunctionContext::new(ccx, lloncefn);\n+    let mut bcx = fcx.get_entry_block();\n \n+    let callee = Callee {\n+        data: Fn(llreffn),\n+        ty: llref_fn_ty\n+    };\n \n     // the first argument (`self`) will be the (by value) closure env.\n \n     let mut llargs = get_params(fcx.llfn);\n-    let mut self_idx = fcx.fn_ty.ret.is_indirect() as usize;\n-    let env_arg = &fcx.fn_ty.args[0];\n+    let fn_ret = callee.ty.fn_ret();\n+    let fn_ty = callee.direct_fn_type(bcx.ccx, &[]);\n+    let self_idx = fn_ty.ret.is_indirect() as usize;\n+    let env_arg = &orig_fn_ty.args[0];\n     let llenv = if env_arg.is_indirect() {\n         llargs[self_idx]\n     } else {\n-        let scratch = alloc_ty(bcx, closure_ty, \"self\");\n+        let scratch = alloc_ty(&bcx, closure_ty, \"self\");\n         let mut llarg_idx = self_idx;\n-        env_arg.store_fn_arg(&bcx.build(), &mut llarg_idx, scratch);\n+        env_arg.store_fn_arg(&bcx, &mut llarg_idx, scratch);\n         scratch\n     };\n \n     debug!(\"trans_fn_once_adapter_shim: env={:?}\", Value(llenv));\n     // Adjust llargs such that llargs[self_idx..] has the call arguments.\n     // For zero-sized closures that means sneaking in a new argument.\n     if env_arg.is_ignore() {\n-        if self_idx > 0 {\n-            self_idx -= 1;\n-            llargs[self_idx] = llenv;\n-        } else {\n-            llargs.insert(0, llenv);\n-        }\n+        llargs.insert(self_idx, llenv);\n     } else {\n         llargs[self_idx] = llenv;\n     }\n \n-    let dest = fcx.llretslotptr.get();\n-\n-    let callee = Callee {\n-        data: Fn(llreffn),\n-        ty: llref_fn_ty\n-    };\n-\n     // Call the by-ref closure body with `self` in a cleanup scope,\n     // to drop `self` when the body returns, or in case it unwinds.\n-    let self_scope = fcx.push_custom_cleanup_scope();\n-    fcx.schedule_drop_mem(self_scope, llenv, closure_ty);\n-\n-    bcx = callee.call(bcx, DebugLoc::None, &llargs[self_idx..], dest).bcx;\n+    let self_scope = fcx.schedule_drop_mem(MaybeSizedValue::sized(llenv), closure_ty);\n+\n+    let llfn = callee.reify(bcx.ccx);\n+    let llret;\n+    if let Some(landing_pad) = self_scope.landing_pad {\n+        let normal_bcx = bcx.fcx().build_new_block(\"normal-return\");\n+        llret = bcx.invoke(llfn, &llargs[..], normal_bcx.llbb(), landing_pad, None);\n+        bcx = normal_bcx;\n+    } else {\n+        llret = bcx.call(llfn, &llargs[..], None);\n+    }\n+    fn_ty.apply_attrs_callsite(llret);\n \n-    fcx.pop_and_trans_custom_cleanup_scope(bcx, self_scope);\n+    if fn_ret.0.is_never() {\n+        bcx.unreachable();\n+    } else {\n+        self_scope.trans(&bcx);\n \n-    fcx.finish(bcx, DebugLoc::None);\n+        if fn_ty.ret.is_indirect() || fn_ty.ret.is_ignore() {\n+            bcx.ret_void();\n+        } else {\n+            bcx.ret(llret);\n+        }\n+    }\n \n     ccx.instances().borrow_mut().insert(method_instance, lloncefn);\n \n@@ -443,7 +414,6 @@ fn trans_fn_pointer_shim<'a, 'tcx>(\n     bare_fn_ty: Ty<'tcx>)\n     -> ValueRef\n {\n-    let _icx = push_ctxt(\"trans_fn_pointer_shim\");\n     let tcx = ccx.tcx();\n \n     // Normalize the type for better caching.\n@@ -519,32 +489,39 @@ fn trans_fn_pointer_shim<'a, 'tcx>(\n     let llfn = declare::define_internal_fn(ccx, &function_name, tuple_fn_ty);\n     attributes::set_frame_pointer_elimination(ccx, llfn);\n     //\n-    let (block_arena, fcx): (TypedArena<_>, FunctionContext);\n-    block_arena = TypedArena::new();\n-    fcx = FunctionContext::new(ccx, llfn, fn_ty, None, &block_arena);\n-    let mut bcx = fcx.init(false);\n+    let fcx = FunctionContext::new(ccx, llfn);\n+    let bcx = fcx.get_entry_block();\n \n-    let llargs = get_params(fcx.llfn);\n+    let mut llargs = get_params(fcx.llfn);\n \n-    let self_idx = fcx.fn_ty.ret.is_indirect() as usize;\n+    let self_arg = llargs.remove(fn_ty.ret.is_indirect() as usize);\n     let llfnpointer = llfnpointer.unwrap_or_else(|| {\n         // the first argument (`self`) will be ptr to the fn pointer\n         if is_by_ref {\n-            Load(bcx, llargs[self_idx])\n+            bcx.load(self_arg)\n         } else {\n-            llargs[self_idx]\n+            self_arg\n         }\n     });\n \n-    let dest = fcx.llretslotptr.get();\n-\n     let callee = Callee {\n         data: Fn(llfnpointer),\n         ty: bare_fn_ty\n     };\n-    bcx = callee.call(bcx, DebugLoc::None, &llargs[(self_idx + 1)..], dest).bcx;\n+    let fn_ret = callee.ty.fn_ret();\n+    let fn_ty = callee.direct_fn_type(ccx, &[]);\n+    let llret = bcx.call(llfnpointer, &llargs, None);\n+    fn_ty.apply_attrs_callsite(llret);\n \n-    fcx.finish(bcx, DebugLoc::None);\n+    if fn_ret.0.is_never() {\n+        bcx.unreachable();\n+    } else {\n+        if fn_ty.ret.is_indirect() || fn_ty.ret.is_ignore() {\n+            bcx.ret_void();\n+        } else {\n+            bcx.ret(llret);\n+        }\n+    }\n \n     ccx.fn_pointer_shims().borrow_mut().insert(bare_fn_ty_maybe_ref, llfn);\n \n@@ -649,87 +626,3 @@ fn get_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n     (llfn, fn_ty)\n }\n-\n-// ______________________________________________________________________\n-// Translating calls\n-\n-fn trans_call_inner<'a, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                    debug_loc: DebugLoc,\n-                                    callee: Callee<'tcx>,\n-                                    args: &[ValueRef],\n-                                    opt_llretslot: Option<ValueRef>)\n-                                    -> Result<'blk, 'tcx> {\n-    // Introduce a temporary cleanup scope that will contain cleanups\n-    // for the arguments while they are being evaluated. The purpose\n-    // this cleanup is to ensure that, should a panic occur while\n-    // evaluating argument N, the values for arguments 0...N-1 are all\n-    // cleaned up. If no panic occurs, the values are handed off to\n-    // the callee, and hence none of the cleanups in this temporary\n-    // scope will ever execute.\n-    let fcx = bcx.fcx;\n-    let ccx = fcx.ccx;\n-\n-    let fn_ret = callee.ty.fn_ret();\n-    let fn_ty = callee.direct_fn_type(ccx, &[]);\n-\n-    let mut callee = match callee.data {\n-        NamedTupleConstructor(_) | Intrinsic => {\n-            bug!(\"{:?} calls should not go through Callee::call\", callee);\n-        }\n-        f => f\n-    };\n-\n-    // If there no destination, return must be direct, with no cast.\n-    if opt_llretslot.is_none() {\n-        assert!(!fn_ty.ret.is_indirect() && fn_ty.ret.cast.is_none());\n-    }\n-\n-    let mut llargs = Vec::new();\n-\n-    if fn_ty.ret.is_indirect() {\n-        let mut llretslot = opt_llretslot.unwrap();\n-        if let Some(ty) = fn_ty.ret.cast {\n-            llretslot = PointerCast(bcx, llretslot, ty.ptr_to());\n-        }\n-        llargs.push(llretslot);\n-    }\n-\n-    match callee {\n-        Virtual(idx) => {\n-            llargs.push(args[0]);\n-\n-            let fn_ptr = meth::get_virtual_method(bcx, args[1], idx);\n-            let llty = fn_ty.llvm_type(bcx.ccx()).ptr_to();\n-            callee = Fn(PointerCast(bcx, fn_ptr, llty));\n-            llargs.extend_from_slice(&args[2..]);\n-        }\n-        _ => llargs.extend_from_slice(args)\n-    }\n-\n-    let llfn = match callee {\n-        Fn(f) => f,\n-        _ => bug!(\"expected fn pointer callee, found {:?}\", callee)\n-    };\n-\n-    let (llret, bcx) = base::invoke(bcx, llfn, &llargs, debug_loc);\n-    if !bcx.unreachable.get() {\n-        fn_ty.apply_attrs_callsite(llret);\n-\n-        // If the function we just called does not use an outpointer,\n-        // store the result into the rust outpointer. Cast the outpointer\n-        // type to match because some ABIs will use a different type than\n-        // the Rust type. e.g., a {u32,u32} struct could be returned as\n-        // u64.\n-        if !fn_ty.ret.is_indirect() {\n-            if let Some(llretslot) = opt_llretslot {\n-                fn_ty.ret.store(&bcx.build(), llret, llretslot);\n-            }\n-        }\n-    }\n-\n-    if fn_ret.0.is_never() {\n-        Unreachable(bcx);\n-    }\n-\n-    Result::new(bcx, llret)\n-}"}, {"sha": "4e59ea3f6c5ed71664a5bc9078684291ee03fdf7", "filename": "src/librustc_trans/cleanup.rs", "status": "modified", "additions": 80, "deletions": 631, "changes": 711, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_trans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_trans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcleanup.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -11,694 +11,143 @@\n //! ## The Cleanup module\n //!\n //! The cleanup module tracks what values need to be cleaned up as scopes\n-//! are exited, either via panic or just normal control flow. The basic\n-//! idea is that the function context maintains a stack of cleanup scopes\n-//! that are pushed/popped as we traverse the AST tree. There is typically\n-//! at least one cleanup scope per AST node; some AST nodes may introduce\n-//! additional temporary scopes.\n+//! are exited, either via panic or just normal control flow.\n //!\n //! Cleanup items can be scheduled into any of the scopes on the stack.\n-//! Typically, when a scope is popped, we will also generate the code for\n-//! each of its cleanups at that time. This corresponds to a normal exit\n-//! from a block (for example, an expression completing evaluation\n-//! successfully without panic). However, it is also possible to pop a\n-//! block *without* executing its cleanups; this is typically used to\n-//! guard intermediate values that must be cleaned up on panic, but not\n-//! if everything goes right. See the section on custom scopes below for\n-//! more details.\n-//!\n-//! Cleanup scopes come in three kinds:\n-//!\n-//! - **AST scopes:** each AST node in a function body has a corresponding\n-//!   AST scope. We push the AST scope when we start generate code for an AST\n-//!   node and pop it once the AST node has been fully generated.\n-//! - **Loop scopes:** loops have an additional cleanup scope. Cleanups are\n-//!   never scheduled into loop scopes; instead, they are used to record the\n-//!   basic blocks that we should branch to when a `continue` or `break` statement\n-//!   is encountered.\n-//! - **Custom scopes:** custom scopes are typically used to ensure cleanup\n-//!   of intermediate values.\n-//!\n-//! ### When to schedule cleanup\n-//!\n-//! Although the cleanup system is intended to *feel* fairly declarative,\n-//! it's still important to time calls to `schedule_clean()` correctly.\n-//! Basically, you should not schedule cleanup for memory until it has\n-//! been initialized, because if an unwind should occur before the memory\n-//! is fully initialized, then the cleanup will run and try to free or\n-//! drop uninitialized memory. If the initialization itself produces\n-//! byproducts that need to be freed, then you should use temporary custom\n-//! scopes to ensure that those byproducts will get freed on unwind.  For\n-//! example, an expression like `box foo()` will first allocate a box in the\n-//! heap and then call `foo()` -- if `foo()` should panic, this box needs\n-//! to be *shallowly* freed.\n-//!\n-//! ### Long-distance jumps\n-//!\n-//! In addition to popping a scope, which corresponds to normal control\n-//! flow exiting the scope, we may also *jump out* of a scope into some\n-//! earlier scope on the stack. This can occur in response to a `return`,\n-//! `break`, or `continue` statement, but also in response to panic. In\n-//! any of these cases, we will generate a series of cleanup blocks for\n-//! each of the scopes that is exited. So, if the stack contains scopes A\n-//! ... Z, and we break out of a loop whose corresponding cleanup scope is\n-//! X, we would generate cleanup blocks for the cleanups in X, Y, and Z.\n-//! After cleanup is done we would branch to the exit point for scope X.\n-//! But if panic should occur, we would generate cleanups for all the\n-//! scopes from A to Z and then resume the unwind process afterwards.\n-//!\n-//! To avoid generating tons of code, we cache the cleanup blocks that we\n-//! create for breaks, returns, unwinds, and other jumps. Whenever a new\n-//! cleanup is scheduled, though, we must clear these cached blocks. A\n-//! possible improvement would be to keep the cached blocks but simply\n-//! generate a new block which performs the additional cleanup and then\n-//! branches to the existing cached blocks.\n-//!\n-//! ### AST and loop cleanup scopes\n-//!\n-//! AST cleanup scopes are pushed when we begin and end processing an AST\n-//! node. They are used to house cleanups related to rvalue temporary that\n-//! get referenced (e.g., due to an expression like `&Foo()`). Whenever an\n-//! AST scope is popped, we always trans all the cleanups, adding the cleanup\n-//! code after the postdominator of the AST node.\n-//!\n-//! AST nodes that represent breakable loops also push a loop scope; the\n-//! loop scope never has any actual cleanups, it's just used to point to\n-//! the basic blocks where control should flow after a \"continue\" or\n-//! \"break\" statement. Popping a loop scope never generates code.\n-//!\n-//! ### Custom cleanup scopes\n-//!\n-//! Custom cleanup scopes are used for a variety of purposes. The most\n-//! common though is to handle temporary byproducts, where cleanup only\n-//! needs to occur on panic. The general strategy is to push a custom\n-//! cleanup scope, schedule *shallow* cleanups into the custom scope, and\n-//! then pop the custom scope (without transing the cleanups) when\n-//! execution succeeds normally. This way the cleanups are only trans'd on\n-//! unwind, and only up until the point where execution succeeded, at\n-//! which time the complete value should be stored in an lvalue or some\n-//! other place where normal cleanup applies.\n-//!\n-//! To spell it out, here is an example. Imagine an expression `box expr`.\n-//! We would basically:\n-//!\n-//! 1. Push a custom cleanup scope C.\n-//! 2. Allocate the box.\n-//! 3. Schedule a shallow free in the scope C.\n-//! 4. Trans `expr` into the box.\n-//! 5. Pop the scope C.\n-//! 6. Return the box as an rvalue.\n-//!\n-//! This way, if a panic occurs while transing `expr`, the custom\n-//! cleanup scope C is pushed and hence the box will be freed. The trans\n-//! code for `expr` itself is responsible for freeing any other byproducts\n-//! that may be in play.\n-\n-pub use self::EarlyExitLabel::*;\n+//! Typically, when a scope is finished, we generate the cleanup code. This\n+//! corresponds to a normal exit from a block (for example, an expression\n+//! completing evaluation successfully without panic).\n \n-use llvm::{BasicBlockRef, ValueRef};\n+use llvm::BasicBlockRef;\n use base;\n-use build;\n-use common;\n-use common::{Block, FunctionContext, LandingPad};\n-use debuginfo::{DebugLoc};\n+use adt::MaybeSizedValue;\n+use common::{BlockAndBuilder, FunctionContext, Funclet};\n use glue;\n use type_::Type;\n-use value::Value;\n use rustc::ty::Ty;\n \n pub struct CleanupScope<'tcx> {\n-    // Cleanups to run upon scope exit.\n-    cleanups: Vec<DropValue<'tcx>>,\n-\n-    // The debug location any drop calls generated for this scope will be\n-    // associated with.\n-    debug_loc: DebugLoc,\n+    // Cleanup to run upon scope exit.\n+    cleanup: Option<DropValue<'tcx>>,\n \n-    cached_early_exits: Vec<CachedEarlyExit>,\n-    cached_landing_pad: Option<BasicBlockRef>,\n+    // Computed on creation if compiling with landing pads (!sess.no_landing_pads)\n+    pub landing_pad: Option<BasicBlockRef>,\n }\n \n-#[derive(Copy, Clone, Debug)]\n-pub struct CustomScopeIndex {\n-    index: usize\n+#[derive(Copy, Clone)]\n+pub struct DropValue<'tcx> {\n+    val: MaybeSizedValue,\n+    ty: Ty<'tcx>,\n+    skip_dtor: bool,\n }\n \n-#[derive(Copy, Clone, PartialEq, Debug)]\n-pub enum EarlyExitLabel {\n-    UnwindExit(UnwindKind),\n-}\n+impl<'tcx> DropValue<'tcx> {\n+    fn trans<'a>(&self, funclet: Option<&'a Funclet>, bcx: &BlockAndBuilder<'a, 'tcx>) {\n+        glue::call_drop_glue(bcx, self.val, self.ty, self.skip_dtor, funclet)\n+    }\n \n-#[derive(Copy, Clone, Debug)]\n-pub enum UnwindKind {\n-    LandingPad,\n-    CleanupPad(ValueRef),\n-}\n+    /// Creates a landing pad for the top scope. The landing pad will perform all cleanups necessary\n+    /// for an unwind and then `resume` to continue error propagation:\n+    ///\n+    ///     landing_pad -> ... cleanups ... -> [resume]\n+    ///\n+    /// This should only be called once per function, as it creates an alloca for the landingpad.\n+    fn get_landing_pad<'a>(&self, fcx: &FunctionContext<'a, 'tcx>) -> BasicBlockRef {\n+        debug!(\"get_landing_pad\");\n+        let bcx = fcx.build_new_block(\"cleanup_unwind\");\n+        let llpersonality = bcx.ccx.eh_personality();\n+        bcx.set_personality_fn(llpersonality);\n \n-#[derive(Copy, Clone)]\n-pub struct CachedEarlyExit {\n-    label: EarlyExitLabel,\n-    cleanup_block: BasicBlockRef,\n-    last_cleanup: usize,\n-}\n+        if base::wants_msvc_seh(fcx.ccx.sess()) {\n+            let pad = bcx.cleanup_pad(None, &[]);\n+            let funclet = Some(Funclet::new(pad));\n+            self.trans(funclet.as_ref(), &bcx);\n \n-impl<'blk, 'tcx> FunctionContext<'blk, 'tcx> {\n-    pub fn push_custom_cleanup_scope(&self) -> CustomScopeIndex {\n-        let index = self.scopes_len();\n-        debug!(\"push_custom_cleanup_scope(): {}\", index);\n+            bcx.cleanup_ret(pad, None);\n+        } else {\n+            // The landing pad return type (the type being propagated). Not sure\n+            // what this represents but it's determined by the personality\n+            // function and this is what the EH proposal example uses.\n+            let llretty = Type::struct_(fcx.ccx, &[Type::i8p(fcx.ccx), Type::i32(fcx.ccx)], false);\n \n-        // Just copy the debuginfo source location from the enclosing scope\n-        let debug_loc = self.scopes\n-                            .borrow()\n-                            .last()\n-                            .map(|opt_scope| opt_scope.debug_loc)\n-                            .unwrap_or(DebugLoc::None);\n+            // The only landing pad clause will be 'cleanup'\n+            let llretval = bcx.landing_pad(llretty, llpersonality, 1, bcx.fcx().llfn);\n \n-        self.push_scope(CleanupScope::new(debug_loc));\n-        CustomScopeIndex { index: index }\n-    }\n+            // The landing pad block is a cleanup\n+            bcx.set_cleanup(llretval);\n \n-    /// Removes the top cleanup scope from the stack without executing its cleanups. The top\n-    /// cleanup scope must be the temporary scope `custom_scope`.\n-    pub fn pop_custom_cleanup_scope(&self,\n-                                    custom_scope: CustomScopeIndex) {\n-        debug!(\"pop_custom_cleanup_scope({})\", custom_scope.index);\n-        assert!(self.is_valid_to_pop_custom_scope(custom_scope));\n-        let _ = self.pop_scope();\n-    }\n+            // Insert cleanup instructions into the cleanup block\n+            self.trans(None, &bcx);\n \n-    /// Removes the top cleanup scope from the stack, which must be a temporary scope, and\n-    /// generates the code to do its cleanups for normal exit.\n-    pub fn pop_and_trans_custom_cleanup_scope(&self,\n-                                              bcx: Block<'blk, 'tcx>,\n-                                              custom_scope: CustomScopeIndex)\n-                                              -> Block<'blk, 'tcx> {\n-        debug!(\"pop_and_trans_custom_cleanup_scope({:?})\", custom_scope);\n-        assert!(self.is_valid_to_pop_custom_scope(custom_scope));\n+            if !bcx.sess().target.target.options.custom_unwind_resume {\n+                bcx.resume(llretval);\n+            } else {\n+                let exc_ptr = bcx.extract_value(llretval, 0);\n+                bcx.call(bcx.ccx.eh_unwind_resume(), &[exc_ptr], None);\n+                bcx.unreachable();\n+            }\n+        }\n \n-        let scope = self.pop_scope();\n-        self.trans_scope_cleanups(bcx, &scope)\n+        bcx.llbb()\n     }\n+}\n \n-    /// Schedules a (deep) drop of `val`, which is a pointer to an instance of\n-    /// `ty`\n-    pub fn schedule_drop_mem(&self,\n-                             cleanup_scope: CustomScopeIndex,\n-                             val: ValueRef,\n-                             ty: Ty<'tcx>) {\n-        if !self.type_needs_drop(ty) { return; }\n+impl<'a, 'tcx> FunctionContext<'a, 'tcx> {\n+    /// Schedules a (deep) drop of `val`, which is a pointer to an instance of `ty`\n+    pub fn schedule_drop_mem(&self, val: MaybeSizedValue, ty: Ty<'tcx>) -> CleanupScope<'tcx> {\n+        if !self.ccx.shared().type_needs_drop(ty) { return CleanupScope::noop(); }\n         let drop = DropValue {\n-            is_immediate: false,\n             val: val,\n             ty: ty,\n             skip_dtor: false,\n         };\n \n-        debug!(\"schedule_drop_mem({:?}, val={:?}, ty={:?}) skip_dtor={}\",\n-               cleanup_scope,\n-               Value(val),\n-               ty,\n-               drop.skip_dtor);\n-\n-        self.schedule_clean(cleanup_scope, drop);\n+        CleanupScope::new(self, drop)\n     }\n \n     /// Issue #23611: Schedules a (deep) drop of the contents of\n     /// `val`, which is a pointer to an instance of struct/enum type\n     /// `ty`. The scheduled code handles extracting the discriminant\n     /// and dropping the contents associated with that variant\n     /// *without* executing any associated drop implementation.\n-    pub fn schedule_drop_adt_contents(&self,\n-                                      cleanup_scope: CustomScopeIndex,\n-                                      val: ValueRef,\n-                                      ty: Ty<'tcx>) {\n+    pub fn schedule_drop_adt_contents(&self, val: MaybeSizedValue, ty: Ty<'tcx>)\n+        -> CleanupScope<'tcx> {\n         // `if` below could be \"!contents_needs_drop\"; skipping drop\n         // is just an optimization, so sound to be conservative.\n-        if !self.type_needs_drop(ty) { return; }\n+        if !self.ccx.shared().type_needs_drop(ty) { return CleanupScope::noop(); }\n \n         let drop = DropValue {\n-            is_immediate: false,\n             val: val,\n             ty: ty,\n             skip_dtor: true,\n         };\n \n-        debug!(\"schedule_drop_adt_contents({:?}, val={:?}, ty={:?}) skip_dtor={}\",\n-               cleanup_scope,\n-               Value(val),\n-               ty,\n-               drop.skip_dtor);\n-\n-        self.schedule_clean(cleanup_scope, drop);\n-    }\n-\n-    /// Schedules a (deep) drop of `val`, which is an instance of `ty`\n-    pub fn schedule_drop_immediate(&self,\n-                                   cleanup_scope: CustomScopeIndex,\n-                                   val: ValueRef,\n-                                   ty: Ty<'tcx>) {\n-\n-        if !self.type_needs_drop(ty) { return; }\n-        let drop = DropValue {\n-            is_immediate: true,\n-            val: val,\n-            ty: ty,\n-            skip_dtor: false,\n-        };\n-\n-        debug!(\"schedule_drop_immediate({:?}, val={:?}, ty={:?}) skip_dtor={}\",\n-               cleanup_scope,\n-               Value(val),\n-               ty,\n-               drop.skip_dtor);\n-\n-        self.schedule_clean(cleanup_scope, drop);\n-    }\n-\n-    /// Schedules a cleanup to occur in the top-most scope, which must be a temporary scope.\n-    fn schedule_clean(&self, custom_scope: CustomScopeIndex, cleanup: DropValue<'tcx>) {\n-        debug!(\"schedule_clean_in_custom_scope(custom_scope={})\",\n-               custom_scope.index);\n-\n-        assert!(self.is_valid_custom_scope(custom_scope));\n-\n-        let mut scopes = self.scopes.borrow_mut();\n-        let scope = &mut (*scopes)[custom_scope.index];\n-        scope.cleanups.push(cleanup);\n-        scope.cached_landing_pad = None;\n-    }\n-\n-    /// Returns true if there are pending cleanups that should execute on panic.\n-    pub fn needs_invoke(&self) -> bool {\n-        self.scopes.borrow().iter().rev().any(|s| s.needs_invoke())\n-    }\n-\n-    /// Returns a basic block to branch to in the event of a panic. This block\n-    /// will run the panic cleanups and eventually resume the exception that\n-    /// caused the landing pad to be run.\n-    pub fn get_landing_pad(&'blk self) -> BasicBlockRef {\n-        let _icx = base::push_ctxt(\"get_landing_pad\");\n-\n-        debug!(\"get_landing_pad\");\n-\n-        let orig_scopes_len = self.scopes_len();\n-        assert!(orig_scopes_len > 0);\n-\n-        // Remove any scopes that do not have cleanups on panic:\n-        let mut popped_scopes = vec![];\n-        while !self.top_scope(|s| s.needs_invoke()) {\n-            debug!(\"top scope does not need invoke\");\n-            popped_scopes.push(self.pop_scope());\n-        }\n-\n-        // Check for an existing landing pad in the new topmost scope:\n-        let llbb = self.get_or_create_landing_pad();\n-\n-        // Push the scopes we removed back on:\n-        loop {\n-            match popped_scopes.pop() {\n-                Some(scope) => self.push_scope(scope),\n-                None => break\n-            }\n-        }\n-\n-        assert_eq!(self.scopes_len(), orig_scopes_len);\n-\n-        return llbb;\n-    }\n-\n-    fn is_valid_to_pop_custom_scope(&self, custom_scope: CustomScopeIndex) -> bool {\n-        self.is_valid_custom_scope(custom_scope) &&\n-            custom_scope.index == self.scopes.borrow().len() - 1\n-    }\n-\n-    fn is_valid_custom_scope(&self, custom_scope: CustomScopeIndex) -> bool {\n-        let scopes = self.scopes.borrow();\n-        custom_scope.index < scopes.len()\n-    }\n-\n-    /// Generates the cleanups for `scope` into `bcx`\n-    fn trans_scope_cleanups(&self, // cannot borrow self, will recurse\n-                            bcx: Block<'blk, 'tcx>,\n-                            scope: &CleanupScope<'tcx>) -> Block<'blk, 'tcx> {\n-\n-        let mut bcx = bcx;\n-        if !bcx.unreachable.get() {\n-            for cleanup in scope.cleanups.iter().rev() {\n-                bcx = cleanup.trans(bcx, scope.debug_loc);\n-            }\n-        }\n-        bcx\n-    }\n-\n-    fn scopes_len(&self) -> usize {\n-        self.scopes.borrow().len()\n-    }\n-\n-    fn push_scope(&self, scope: CleanupScope<'tcx>) {\n-        self.scopes.borrow_mut().push(scope)\n-    }\n-\n-    fn pop_scope(&self) -> CleanupScope<'tcx> {\n-        debug!(\"popping cleanup scope {}, {} scopes remaining\",\n-               self.top_scope(|s| s.block_name(\"\")),\n-               self.scopes_len() - 1);\n-\n-        self.scopes.borrow_mut().pop().unwrap()\n-    }\n-\n-    fn top_scope<R, F>(&self, f: F) -> R where F: FnOnce(&CleanupScope<'tcx>) -> R {\n-        f(self.scopes.borrow().last().unwrap())\n-    }\n-\n-    /// Used when the caller wishes to jump to an early exit, such as a return,\n-    /// break, continue, or unwind. This function will generate all cleanups\n-    /// between the top of the stack and the exit `label` and return a basic\n-    /// block that the caller can branch to.\n-    ///\n-    /// For example, if the current stack of cleanups were as follows:\n-    ///\n-    ///      AST 22\n-    ///      Custom 1\n-    ///      AST 23\n-    ///      Loop 23\n-    ///      Custom 2\n-    ///      AST 24\n-    ///\n-    /// and the `label` specifies a break from `Loop 23`, then this function\n-    /// would generate a series of basic blocks as follows:\n-    ///\n-    ///      Cleanup(AST 24) -> Cleanup(Custom 2) -> break_blk\n-    ///\n-    /// where `break_blk` is the block specified in `Loop 23` as the target for\n-    /// breaks. The return value would be the first basic block in that sequence\n-    /// (`Cleanup(AST 24)`). The caller could then branch to `Cleanup(AST 24)`\n-    /// and it will perform all cleanups and finally branch to the `break_blk`.\n-    fn trans_cleanups_to_exit_scope(&'blk self,\n-                                    label: EarlyExitLabel)\n-                                    -> BasicBlockRef {\n-        debug!(\"trans_cleanups_to_exit_scope label={:?} scopes={}\",\n-               label, self.scopes_len());\n-\n-        let orig_scopes_len = self.scopes_len();\n-        let mut prev_llbb;\n-        let mut popped_scopes = vec![];\n-        let mut skip = 0;\n-\n-        // First we pop off all the cleanup stacks that are\n-        // traversed until the exit is reached, pushing them\n-        // onto the side vector `popped_scopes`. No code is\n-        // generated at this time.\n-        //\n-        // So, continuing the example from above, we would wind up\n-        // with a `popped_scopes` vector of `[AST 24, Custom 2]`.\n-        // (Presuming that there are no cached exits)\n-        loop {\n-            if self.scopes_len() == 0 {\n-                match label {\n-                    UnwindExit(val) => {\n-                        // Generate a block that will resume unwinding to the\n-                        // calling function\n-                        let bcx = self.new_block(\"resume\");\n-                        match val {\n-                            UnwindKind::LandingPad => {\n-                                let addr = self.landingpad_alloca.get()\n-                                               .unwrap();\n-                                let lp = build::Load(bcx, addr);\n-                                base::call_lifetime_end(bcx, addr);\n-                                base::trans_unwind_resume(bcx, lp);\n-                            }\n-                            UnwindKind::CleanupPad(_) => {\n-                                let pad = build::CleanupPad(bcx, None, &[]);\n-                                build::CleanupRet(bcx, pad, None);\n-                            }\n-                        }\n-                        prev_llbb = bcx.llbb;\n-                        break;\n-                    }\n-                }\n-            }\n-\n-            // Pop off the scope, since we may be generating\n-            // unwinding code for it.\n-            let top_scope = self.pop_scope();\n-            let cached_exit = top_scope.cached_early_exit(label);\n-            popped_scopes.push(top_scope);\n-\n-            // Check if we have already cached the unwinding of this\n-            // scope for this label. If so, we can stop popping scopes\n-            // and branch to the cached label, since it contains the\n-            // cleanups for any subsequent scopes.\n-            if let Some((exit, last_cleanup)) = cached_exit {\n-                prev_llbb = exit;\n-                skip = last_cleanup;\n-                break;\n-            }\n-        }\n-\n-        debug!(\"trans_cleanups_to_exit_scope: popped {} scopes\",\n-               popped_scopes.len());\n-\n-        // Now push the popped scopes back on. As we go,\n-        // we track in `prev_llbb` the exit to which this scope\n-        // should branch when it's done.\n-        //\n-        // So, continuing with our example, we will start out with\n-        // `prev_llbb` being set to `break_blk` (or possibly a cached\n-        // early exit). We will then pop the scopes from `popped_scopes`\n-        // and generate a basic block for each one, prepending it in the\n-        // series and updating `prev_llbb`. So we begin by popping `Custom 2`\n-        // and generating `Cleanup(Custom 2)`. We make `Cleanup(Custom 2)`\n-        // branch to `prev_llbb == break_blk`, giving us a sequence like:\n-        //\n-        //     Cleanup(Custom 2) -> prev_llbb\n-        //\n-        // We then pop `AST 24` and repeat the process, giving us the sequence:\n-        //\n-        //     Cleanup(AST 24) -> Cleanup(Custom 2) -> prev_llbb\n-        //\n-        // At this point, `popped_scopes` is empty, and so the final block\n-        // that we return to the user is `Cleanup(AST 24)`.\n-        while let Some(mut scope) = popped_scopes.pop() {\n-            if !scope.cleanups.is_empty() {\n-                let name = scope.block_name(\"clean\");\n-                debug!(\"generating cleanups for {}\", name);\n-\n-                let bcx_in = self.new_block(&name[..]);\n-                let exit_label = label.start(bcx_in);\n-                let mut bcx_out = bcx_in;\n-                let len = scope.cleanups.len();\n-                for cleanup in scope.cleanups.iter().rev().take(len - skip) {\n-                    bcx_out = cleanup.trans(bcx_out, scope.debug_loc);\n-                }\n-                skip = 0;\n-                exit_label.branch(bcx_out, prev_llbb);\n-                prev_llbb = bcx_in.llbb;\n-\n-                scope.add_cached_early_exit(exit_label, prev_llbb, len);\n-            }\n-            self.push_scope(scope);\n-        }\n-\n-        debug!(\"trans_cleanups_to_exit_scope: prev_llbb={:?}\", prev_llbb);\n-\n-        assert_eq!(self.scopes_len(), orig_scopes_len);\n-        prev_llbb\n-    }\n-\n-    /// Creates a landing pad for the top scope, if one does not exist.  The\n-    /// landing pad will perform all cleanups necessary for an unwind and then\n-    /// `resume` to continue error propagation:\n-    ///\n-    ///     landing_pad -> ... cleanups ... -> [resume]\n-    ///\n-    /// (The cleanups and resume instruction are created by\n-    /// `trans_cleanups_to_exit_scope()`, not in this function itself.)\n-    fn get_or_create_landing_pad(&'blk self) -> BasicBlockRef {\n-        let pad_bcx;\n-\n-        debug!(\"get_or_create_landing_pad\");\n-\n-        // Check if a landing pad block exists; if not, create one.\n-        {\n-            let mut scopes = self.scopes.borrow_mut();\n-            let last_scope = scopes.last_mut().unwrap();\n-            match last_scope.cached_landing_pad {\n-                Some(llbb) => return llbb,\n-                None => {\n-                    let name = last_scope.block_name(\"unwind\");\n-                    pad_bcx = self.new_block(&name[..]);\n-                    last_scope.cached_landing_pad = Some(pad_bcx.llbb);\n-                }\n-            }\n-        };\n-\n-        let llpersonality = pad_bcx.fcx.eh_personality();\n-\n-        let val = if base::wants_msvc_seh(self.ccx.sess()) {\n-            // A cleanup pad requires a personality function to be specified, so\n-            // we do that here explicitly (happens implicitly below through\n-            // creation of the landingpad instruction). We then create a\n-            // cleanuppad instruction which has no filters to run cleanup on all\n-            // exceptions.\n-            build::SetPersonalityFn(pad_bcx, llpersonality);\n-            let llretval = build::CleanupPad(pad_bcx, None, &[]);\n-            UnwindKind::CleanupPad(llretval)\n-        } else {\n-            // The landing pad return type (the type being propagated). Not sure\n-            // what this represents but it's determined by the personality\n-            // function and this is what the EH proposal example uses.\n-            let llretty = Type::struct_(self.ccx,\n-                                        &[Type::i8p(self.ccx), Type::i32(self.ccx)],\n-                                        false);\n-\n-            // The only landing pad clause will be 'cleanup'\n-            let llretval = build::LandingPad(pad_bcx, llretty, llpersonality, 1);\n-\n-            // The landing pad block is a cleanup\n-            build::SetCleanup(pad_bcx, llretval);\n-\n-            let addr = match self.landingpad_alloca.get() {\n-                Some(addr) => addr,\n-                None => {\n-                    let addr = base::alloca(pad_bcx, common::val_ty(llretval),\n-                                            \"\");\n-                    base::call_lifetime_start(pad_bcx, addr);\n-                    self.landingpad_alloca.set(Some(addr));\n-                    addr\n-                }\n-            };\n-            build::Store(pad_bcx, llretval, addr);\n-            UnwindKind::LandingPad\n-        };\n-\n-        // Generate the cleanup block and branch to it.\n-        let label = UnwindExit(val);\n-        let cleanup_llbb = self.trans_cleanups_to_exit_scope(label);\n-        label.branch(pad_bcx, cleanup_llbb);\n-\n-        return pad_bcx.llbb;\n+        CleanupScope::new(self, drop)\n     }\n }\n \n impl<'tcx> CleanupScope<'tcx> {\n-    fn new(debug_loc: DebugLoc) -> CleanupScope<'tcx> {\n+    fn new<'a>(fcx: &FunctionContext<'a, 'tcx>, drop_val: DropValue<'tcx>) -> CleanupScope<'tcx> {\n         CleanupScope {\n-            debug_loc: debug_loc,\n-            cleanups: vec![],\n-            cached_early_exits: vec![],\n-            cached_landing_pad: None,\n-        }\n-    }\n-\n-    fn cached_early_exit(&self,\n-                         label: EarlyExitLabel)\n-                         -> Option<(BasicBlockRef, usize)> {\n-        self.cached_early_exits.iter().rev().\n-            find(|e| e.label == label).\n-            map(|e| (e.cleanup_block, e.last_cleanup))\n-    }\n-\n-    fn add_cached_early_exit(&mut self,\n-                             label: EarlyExitLabel,\n-                             blk: BasicBlockRef,\n-                             last_cleanup: usize) {\n-        self.cached_early_exits.push(\n-            CachedEarlyExit { label: label,\n-                              cleanup_block: blk,\n-                              last_cleanup: last_cleanup});\n-    }\n-\n-    /// True if this scope has cleanups that need unwinding\n-    fn needs_invoke(&self) -> bool {\n-        self.cached_landing_pad.is_some() ||\n-            !self.cleanups.is_empty()\n-    }\n-\n-    /// Returns a suitable name to use for the basic block that handles this cleanup scope\n-    fn block_name(&self, prefix: &str) -> String {\n-        format!(\"{}_custom_\", prefix)\n-    }\n-}\n-\n-impl EarlyExitLabel {\n-    /// Generates a branch going from `from_bcx` to `to_llbb` where `self` is\n-    /// the exit label attached to the start of `from_bcx`.\n-    ///\n-    /// Transitions from an exit label to other exit labels depend on the type\n-    /// of label. For example with MSVC exceptions unwind exit labels will use\n-    /// the `cleanupret` instruction instead of the `br` instruction.\n-    fn branch(&self, from_bcx: Block, to_llbb: BasicBlockRef) {\n-        if let UnwindExit(UnwindKind::CleanupPad(pad)) = *self {\n-            build::CleanupRet(from_bcx, pad, Some(to_llbb));\n-        } else {\n-            build::Br(from_bcx, to_llbb, DebugLoc::None);\n+            cleanup: Some(drop_val),\n+            landing_pad: if !fcx.ccx.sess().no_landing_pads() {\n+                Some(drop_val.get_landing_pad(fcx))\n+            } else {\n+                None\n+            },\n         }\n     }\n \n-    /// Generates the necessary instructions at the start of `bcx` to prepare\n-    /// for the same kind of early exit label that `self` is.\n-    ///\n-    /// This function will appropriately configure `bcx` based on the kind of\n-    /// label this is. For UnwindExit labels, the `lpad` field of the block will\n-    /// be set to `Some`, and for MSVC exceptions this function will generate a\n-    /// `cleanuppad` instruction at the start of the block so it may be jumped\n-    /// to in the future (e.g. so this block can be cached as an early exit).\n-    ///\n-    /// Returns a new label which will can be used to cache `bcx` in the list of\n-    /// early exits.\n-    fn start(&self, bcx: Block) -> EarlyExitLabel {\n-        match *self {\n-            UnwindExit(UnwindKind::CleanupPad(..)) => {\n-                let pad = build::CleanupPad(bcx, None, &[]);\n-                bcx.lpad.set(Some(bcx.fcx.lpad_arena.alloc(LandingPad::msvc(pad))));\n-                UnwindExit(UnwindKind::CleanupPad(pad))\n-            }\n-            UnwindExit(UnwindKind::LandingPad) => {\n-                bcx.lpad.set(Some(bcx.fcx.lpad_arena.alloc(LandingPad::gnu())));\n-                *self\n-            }\n+    pub fn noop() -> CleanupScope<'tcx> {\n+        CleanupScope {\n+            cleanup: None,\n+            landing_pad: None,\n         }\n     }\n-}\n \n-impl PartialEq for UnwindKind {\n-    fn eq(&self, val: &UnwindKind) -> bool {\n-        match (*self, *val) {\n-            (UnwindKind::LandingPad, UnwindKind::LandingPad) |\n-            (UnwindKind::CleanupPad(..), UnwindKind::CleanupPad(..)) => true,\n-            _ => false,\n+    pub fn trans<'a>(self, bcx: &'a BlockAndBuilder<'a, 'tcx>) {\n+        if let Some(cleanup) = self.cleanup {\n+            cleanup.trans(None, &bcx);\n         }\n     }\n }\n-\n-///////////////////////////////////////////////////////////////////////////\n-// Cleanup types\n-\n-#[derive(Copy, Clone)]\n-pub struct DropValue<'tcx> {\n-    is_immediate: bool,\n-    val: ValueRef,\n-    ty: Ty<'tcx>,\n-    skip_dtor: bool,\n-}\n-\n-impl<'tcx> DropValue<'tcx> {\n-    fn trans<'blk>(&self,\n-                   bcx: Block<'blk, 'tcx>,\n-                   debug_loc: DebugLoc)\n-                   -> Block<'blk, 'tcx> {\n-        let skip_dtor = self.skip_dtor;\n-        let _icx = if skip_dtor {\n-            base::push_ctxt(\"<DropValue as Cleanup>::trans skip_dtor=true\")\n-        } else {\n-            base::push_ctxt(\"<DropValue as Cleanup>::trans skip_dtor=false\")\n-        };\n-        let bcx = if self.is_immediate {\n-            glue::drop_ty_immediate(bcx, self.val, self.ty, debug_loc, self.skip_dtor)\n-        } else {\n-            glue::drop_ty_core(bcx, self.val, self.ty, debug_loc, self.skip_dtor)\n-        };\n-        bcx\n-    }\n-}"}, {"sha": "84222bfe56eee3646e79a91c77612bdd28ec2d6e", "filename": "src/librustc_trans/collector.rs", "status": "modified", "additions": 27, "deletions": 31, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_trans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_trans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcollector.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -193,9 +193,9 @@ use rustc::hir::itemlikevisit::ItemLikeVisitor;\n \n use rustc::hir::map as hir_map;\n use rustc::hir::def_id::DefId;\n-use rustc::middle::lang_items::{ExchangeFreeFnLangItem, ExchangeMallocFnLangItem};\n+use rustc::middle::lang_items::{BoxFreeFnLangItem, ExchangeMallocFnLangItem};\n use rustc::traits;\n-use rustc::ty::subst::{Substs, Subst};\n+use rustc::ty::subst::{Kind, Substs, Subst};\n use rustc::ty::{self, TypeFoldable, TyCtxt};\n use rustc::ty::adjustment::CustomCoerceUnsized;\n use rustc::mir::{self, Location};\n@@ -208,13 +208,15 @@ use syntax::abi::Abi;\n use syntax_pos::DUMMY_SP;\n use base::custom_coerce_unsize_info;\n use context::SharedCrateContext;\n-use common::{fulfill_obligation, type_is_sized};\n+use common::fulfill_obligation;\n use glue::{self, DropGlueKind};\n use monomorphize::{self, Instance};\n use util::nodemap::{FxHashSet, FxHashMap, DefIdMap};\n \n use trans_item::{TransItem, DefPathBasedNames};\n \n+use std::iter;\n+\n #[derive(PartialEq, Eq, Hash, Clone, Copy, Debug)]\n pub enum TransItemCollectionMode {\n     Eager,\n@@ -337,7 +339,7 @@ fn collect_items_rec<'a, 'tcx: 'a>(scx: &SharedCrateContext<'a, 'tcx>,\n         TransItem::Static(node_id) => {\n             let def_id = scx.tcx().map.local_def_id(node_id);\n             let ty = scx.tcx().item_type(def_id);\n-            let ty = glue::get_drop_glue_type(scx.tcx(), ty);\n+            let ty = glue::get_drop_glue_type(scx, ty);\n             neighbors.push(TransItem::DropGlue(DropGlueKind::Ty(ty)));\n \n             recursion_depth_reset = None;\n@@ -542,7 +544,7 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n                                                       self.param_substs,\n                                                       &ty);\n             assert!(ty.is_normalized_for_trans());\n-            let ty = glue::get_drop_glue_type(self.scx.tcx(), ty);\n+            let ty = glue::get_drop_glue_type(self.scx, ty);\n             self.output.push(TransItem::DropGlue(DropGlueKind::Ty(ty)));\n         }\n \n@@ -678,7 +680,7 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n                             let operand_ty = monomorphize::apply_param_substs(self.scx,\n                                                                               self.param_substs,\n                                                                               &mt.ty);\n-                            let ty = glue::get_drop_glue_type(tcx, operand_ty);\n+                            let ty = glue::get_drop_glue_type(self.scx, operand_ty);\n                             self.output.push(TransItem::DropGlue(DropGlueKind::Ty(ty)));\n                         } else {\n                             bug!(\"Has the drop_in_place() intrinsic's signature changed?\")\n@@ -723,23 +725,17 @@ fn find_drop_glue_neighbors<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n \n     debug!(\"find_drop_glue_neighbors: {}\", type_to_string(scx.tcx(), ty));\n \n-    // Make sure the exchange_free_fn() lang-item gets translated if\n-    // there is a boxed value.\n-    if let ty::TyBox(_) = ty.sty {\n-        let exchange_free_fn_def_id = scx.tcx()\n-                                         .lang_items\n-                                         .require(ExchangeFreeFnLangItem)\n-                                         .unwrap_or_else(|e| scx.sess().fatal(&e));\n-\n-        assert!(can_have_local_instance(scx.tcx(), exchange_free_fn_def_id));\n-        let fn_substs = scx.empty_substs_for_def_id(exchange_free_fn_def_id);\n-        let exchange_free_fn_trans_item =\n+    // Make sure the BoxFreeFn lang-item gets translated if there is a boxed value.\n+    if let ty::TyBox(content_type) = ty.sty {\n+        let def_id = scx.tcx().require_lang_item(BoxFreeFnLangItem);\n+        assert!(can_have_local_instance(scx.tcx(), def_id));\n+        let box_free_fn_trans_item =\n             create_fn_trans_item(scx,\n-                                 exchange_free_fn_def_id,\n-                                 fn_substs,\n+                                 def_id,\n+                                 scx.tcx().mk_substs(iter::once(Kind::from(content_type))),\n                                  scx.tcx().intern_substs(&[]));\n \n-        output.push(exchange_free_fn_trans_item);\n+        output.push(box_free_fn_trans_item);\n     }\n \n     // If the type implements Drop, also add a translation item for the\n@@ -804,33 +800,33 @@ fn find_drop_glue_neighbors<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n                 let field_type = monomorphize::apply_param_substs(scx,\n                                                                   substs,\n                                                                   &field_type);\n-                let field_type = glue::get_drop_glue_type(scx.tcx(), field_type);\n+                let field_type = glue::get_drop_glue_type(scx, field_type);\n \n-                if glue::type_needs_drop(scx.tcx(), field_type) {\n+                if scx.type_needs_drop(field_type) {\n                     output.push(TransItem::DropGlue(DropGlueKind::Ty(field_type)));\n                 }\n             }\n         }\n         ty::TyClosure(def_id, substs) => {\n             for upvar_ty in substs.upvar_tys(def_id, scx.tcx()) {\n-                let upvar_ty = glue::get_drop_glue_type(scx.tcx(), upvar_ty);\n-                if glue::type_needs_drop(scx.tcx(), upvar_ty) {\n+                let upvar_ty = glue::get_drop_glue_type(scx, upvar_ty);\n+                if scx.type_needs_drop(upvar_ty) {\n                     output.push(TransItem::DropGlue(DropGlueKind::Ty(upvar_ty)));\n                 }\n             }\n         }\n         ty::TyBox(inner_type)      |\n         ty::TySlice(inner_type)    |\n         ty::TyArray(inner_type, _) => {\n-            let inner_type = glue::get_drop_glue_type(scx.tcx(), inner_type);\n-            if glue::type_needs_drop(scx.tcx(), inner_type) {\n+            let inner_type = glue::get_drop_glue_type(scx, inner_type);\n+            if scx.type_needs_drop(inner_type) {\n                 output.push(TransItem::DropGlue(DropGlueKind::Ty(inner_type)));\n             }\n         }\n         ty::TyTuple(args) => {\n             for arg in args {\n-                let arg = glue::get_drop_glue_type(scx.tcx(), arg);\n-                if glue::type_needs_drop(scx.tcx(), arg) {\n+                let arg = glue::get_drop_glue_type(scx, arg);\n+                if scx.type_needs_drop(arg) {\n                     output.push(TransItem::DropGlue(DropGlueKind::Ty(arg)));\n                 }\n             }\n@@ -969,7 +965,7 @@ fn find_vtable_types_for_unsizing<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n          &ty::TyRawPtr(ty::TypeAndMut { ty: b, .. })) => {\n             let (inner_source, inner_target) = (a, b);\n \n-            if !type_is_sized(scx.tcx(), inner_source) {\n+            if !scx.type_is_sized(inner_source) {\n                 (inner_source, inner_target)\n             } else {\n                 scx.tcx().struct_lockstep_tails(inner_source, inner_target)\n@@ -1051,7 +1047,7 @@ fn create_trans_items_for_vtable_methods<'a, 'tcx>(scx: &SharedCrateContext<'a,\n             output.extend(methods);\n         }\n         // Also add the destructor\n-        let dg_type = glue::get_drop_glue_type(scx.tcx(), impl_ty);\n+        let dg_type = glue::get_drop_glue_type(scx, impl_ty);\n         output.push(TransItem::DropGlue(DropGlueKind::Ty(dg_type)));\n     }\n }\n@@ -1097,7 +1093,7 @@ impl<'b, 'a, 'v> ItemLikeVisitor<'v> for RootCollector<'b, 'a, 'v> {\n                                def_id_to_string(self.scx.tcx(), def_id));\n \n                         let ty = self.scx.tcx().item_type(def_id);\n-                        let ty = glue::get_drop_glue_type(self.scx.tcx(), ty);\n+                        let ty = glue::get_drop_glue_type(self.scx, ty);\n                         self.output.push(TransItem::DropGlue(DropGlueKind::Ty(ty)));\n                     }\n                 }"}, {"sha": "71e17f1ea74051376c83ab4df19be3b06b1e9fac", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 113, "deletions": 428, "changes": 541, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -14,24 +14,16 @@\n \n use session::Session;\n use llvm;\n-use llvm::{ValueRef, BasicBlockRef, BuilderRef, ContextRef, TypeKind};\n+use llvm::{ValueRef, BasicBlockRef, ContextRef, TypeKind};\n use llvm::{True, False, Bool, OperandBundleDef};\n use rustc::hir::def::Def;\n use rustc::hir::def_id::DefId;\n use rustc::hir::map::DefPathData;\n-use rustc::infer::TransNormalize;\n-use rustc::mir::Mir;\n use rustc::util::common::MemoizationMap;\n use middle::lang_items::LangItem;\n-use rustc::ty::subst::Substs;\n-use abi::{Abi, FnType};\n use base;\n-use build;\n use builder::Builder;\n-use callee::Callee;\n-use cleanup;\n use consts;\n-use debuginfo::{self, DebugLoc};\n use declare;\n use machine;\n use monomorphize;\n@@ -40,34 +32,26 @@ use value::Value;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::layout::Layout;\n use rustc::traits::{self, SelectionContext, Reveal};\n-use rustc::ty::fold::TypeFoldable;\n use rustc::hir;\n \n-use arena::TypedArena;\n use libc::{c_uint, c_char};\n use std::borrow::Cow;\n use std::iter;\n use std::ops::Deref;\n use std::ffi::CString;\n-use std::cell::{Cell, RefCell, Ref};\n \n use syntax::ast;\n use syntax::symbol::{Symbol, InternedString};\n-use syntax_pos::{DUMMY_SP, Span};\n+use syntax_pos::Span;\n \n pub use context::{CrateContext, SharedCrateContext};\n \n-/// Is the type's representation size known at compile time?\n-pub fn type_is_sized<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, ty: Ty<'tcx>) -> bool {\n-    ty.is_sized(tcx, &tcx.empty_parameter_environment(), DUMMY_SP)\n-}\n-\n-pub fn type_is_fat_ptr<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, ty: Ty<'tcx>) -> bool {\n+pub fn type_is_fat_ptr<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) -> bool {\n     match ty.sty {\n         ty::TyRawPtr(ty::TypeAndMut{ty, ..}) |\n         ty::TyRef(_, ty::TypeAndMut{ty, ..}) |\n         ty::TyBox(ty) => {\n-            !type_is_sized(tcx, ty)\n+            !ccx.shared().type_is_sized(ty)\n         }\n         _ => {\n             false\n@@ -79,14 +63,13 @@ pub fn type_is_immediate<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) -\n     use machine::llsize_of_alloc;\n     use type_of::sizing_type_of;\n \n-    let tcx = ccx.tcx();\n     let simple = ty.is_scalar() ||\n         ty.is_unique() || ty.is_region_ptr() ||\n         ty.is_simd();\n-    if simple && !type_is_fat_ptr(tcx, ty) {\n+    if simple && !type_is_fat_ptr(ccx, ty) {\n         return true;\n     }\n-    if !type_is_sized(tcx, ty) {\n+    if !ccx.shared().type_is_sized(ty) {\n         return false;\n     }\n     match ty.sty {\n@@ -236,416 +219,139 @@ impl<'a, 'tcx> VariantInfo<'tcx> {\n     }\n }\n \n-pub struct BuilderRef_res {\n-    pub b: BuilderRef,\n-}\n-\n-impl Drop for BuilderRef_res {\n-    fn drop(&mut self) {\n-        unsafe {\n-            llvm::LLVMDisposeBuilder(self.b);\n-        }\n-    }\n-}\n-\n-pub fn BuilderRef_res(b: BuilderRef) -> BuilderRef_res {\n-    BuilderRef_res {\n-        b: b\n-    }\n-}\n-\n-pub fn validate_substs(substs: &Substs) {\n-    assert!(!substs.needs_infer());\n-}\n-\n-// Function context.  Every LLVM function we create will have one of\n-// these.\n+// Function context. Every LLVM function we create will have one of these.\n pub struct FunctionContext<'a, 'tcx: 'a> {\n-    // The MIR for this function.\n-    pub mir: Option<Ref<'tcx, Mir<'tcx>>>,\n-\n     // The ValueRef returned from a call to llvm::LLVMAddFunction; the\n     // address of the first instruction in the sequence of\n     // instructions for this function that will go in the .text\n     // section of the executable we're generating.\n     pub llfn: ValueRef,\n \n-    // always an empty parameter-environment NOTE: @jroesch another use of ParamEnv\n-    pub param_env: ty::ParameterEnvironment<'tcx>,\n-\n-    // A pointer to where to store the return value. If the return type is\n-    // immediate, this points to an alloca in the function. Otherwise, it's a\n-    // pointer to the hidden first parameter of the function. After function\n-    // construction, this should always be Some.\n-    pub llretslotptr: Cell<Option<ValueRef>>,\n-\n-    // These pub elements: \"hoisted basic blocks\" containing\n-    // administrative activities that have to happen in only one place in\n-    // the function, due to LLVM's quirks.\n     // A marker for the place where we want to insert the function's static\n     // allocas, so that LLVM will coalesce them into a single alloca call.\n-    pub alloca_insert_pt: Cell<Option<ValueRef>>,\n-\n-    // When working with landingpad-based exceptions this value is alloca'd and\n-    // later loaded when using the resume instruction. This ends up being\n-    // critical to chaining landing pads and resuing already-translated\n-    // cleanups.\n-    //\n-    // Note that for cleanuppad-based exceptions this is not used.\n-    pub landingpad_alloca: Cell<Option<ValueRef>>,\n-\n-    // Describes the return/argument LLVM types and their ABI handling.\n-    pub fn_ty: FnType,\n-\n-    // If this function is being monomorphized, this contains the type\n-    // substitutions used.\n-    pub param_substs: &'tcx Substs<'tcx>,\n-\n-    // The source span and nesting context where this function comes from, for\n-    // error reporting and symbol generation.\n-    pub span: Option<Span>,\n-\n-    // The arena that blocks are allocated from.\n-    pub block_arena: &'a TypedArena<BlockS<'a, 'tcx>>,\n-\n-    // The arena that landing pads are allocated from.\n-    pub lpad_arena: TypedArena<LandingPad>,\n+    alloca_insert_pt: Option<ValueRef>,\n \n     // This function's enclosing crate context.\n     pub ccx: &'a CrateContext<'a, 'tcx>,\n \n-    // Used and maintained by the debuginfo module.\n-    pub debug_context: debuginfo::FunctionDebugContext,\n-\n-    // Cleanup scopes.\n-    pub scopes: RefCell<Vec<cleanup::CleanupScope<'tcx>>>,\n+    alloca_builder: Builder<'a, 'tcx>,\n }\n \n impl<'a, 'tcx> FunctionContext<'a, 'tcx> {\n-    pub fn mir(&self) -> Ref<'tcx, Mir<'tcx>> {\n-        self.mir.as_ref().map(Ref::clone).expect(\"fcx.mir was empty\")\n+    /// Create a function context for the given function.\n+    /// Call FunctionContext::get_entry_block for the first entry block.\n+    pub fn new(ccx: &'a CrateContext<'a, 'tcx>, llfndecl: ValueRef) -> FunctionContext<'a, 'tcx> {\n+        let mut fcx = FunctionContext {\n+            llfn: llfndecl,\n+            alloca_insert_pt: None,\n+            ccx: ccx,\n+            alloca_builder: Builder::with_ccx(ccx),\n+        };\n+\n+        let val = {\n+            let entry_bcx = fcx.build_new_block(\"entry-block\");\n+            let val = entry_bcx.load(C_null(Type::i8p(ccx)));\n+            fcx.alloca_builder.position_at_start(entry_bcx.llbb());\n+            val\n+        };\n+\n+        // Use a dummy instruction as the insertion point for all allocas.\n+        // This is later removed in the drop of FunctionContext.\n+        fcx.alloca_insert_pt = Some(val);\n+\n+        fcx\n     }\n \n-    pub fn cleanup(&self) {\n-        unsafe {\n-            llvm::LLVMInstructionEraseFromParent(self.alloca_insert_pt\n-                                                     .get()\n-                                                     .unwrap());\n-        }\n+    pub fn get_entry_block(&'a self) -> BlockAndBuilder<'a, 'tcx> {\n+        BlockAndBuilder::new(unsafe {\n+            llvm::LLVMGetFirstBasicBlock(self.llfn)\n+        }, self)\n     }\n \n-    pub fn new_block(&'a self,\n-                     name: &str)\n-                     -> Block<'a, 'tcx> {\n+    pub fn new_block(&'a self, name: &str) -> BasicBlockRef {\n         unsafe {\n             let name = CString::new(name).unwrap();\n-            let llbb = llvm::LLVMAppendBasicBlockInContext(self.ccx.llcx(),\n-                                                           self.llfn,\n-                                                           name.as_ptr());\n-            BlockS::new(llbb, self)\n+            llvm::LLVMAppendBasicBlockInContext(\n+                self.ccx.llcx(),\n+                self.llfn,\n+                name.as_ptr()\n+            )\n         }\n     }\n \n-    pub fn monomorphize<T>(&self, value: &T) -> T\n-        where T: TransNormalize<'tcx>\n-    {\n-        monomorphize::apply_param_substs(self.ccx.shared(),\n-                                         self.param_substs,\n-                                         value)\n-    }\n-\n-    /// This is the same as `common::type_needs_drop`, except that it\n-    /// may use or update caches within this `FunctionContext`.\n-    pub fn type_needs_drop(&self, ty: Ty<'tcx>) -> bool {\n-        self.ccx.tcx().type_needs_drop_given_env(ty, &self.param_env)\n+    pub fn build_new_block(&'a self, name: &str) -> BlockAndBuilder<'a, 'tcx> {\n+        BlockAndBuilder::new(self.new_block(name), self)\n     }\n \n-    pub fn eh_personality(&self) -> ValueRef {\n-        // The exception handling personality function.\n-        //\n-        // If our compilation unit has the `eh_personality` lang item somewhere\n-        // within it, then we just need to translate that. Otherwise, we're\n-        // building an rlib which will depend on some upstream implementation of\n-        // this function, so we just codegen a generic reference to it. We don't\n-        // specify any of the types for the function, we just make it a symbol\n-        // that LLVM can later use.\n-        //\n-        // Note that MSVC is a little special here in that we don't use the\n-        // `eh_personality` lang item at all. Currently LLVM has support for\n-        // both Dwarf and SEH unwind mechanisms for MSVC targets and uses the\n-        // *name of the personality function* to decide what kind of unwind side\n-        // tables/landing pads to emit. It looks like Dwarf is used by default,\n-        // injecting a dependency on the `_Unwind_Resume` symbol for resuming\n-        // an \"exception\", but for MSVC we want to force SEH. This means that we\n-        // can't actually have the personality function be our standard\n-        // `rust_eh_personality` function, but rather we wired it up to the\n-        // CRT's custom personality function, which forces LLVM to consider\n-        // landing pads as \"landing pads for SEH\".\n-        let ccx = self.ccx;\n-        let tcx = ccx.tcx();\n-        match tcx.lang_items.eh_personality() {\n-            Some(def_id) if !base::wants_msvc_seh(ccx.sess()) => {\n-                Callee::def(ccx, def_id, tcx.intern_substs(&[])).reify(ccx)\n-            }\n-            _ => {\n-                if let Some(llpersonality) = ccx.eh_personality().get() {\n-                    return llpersonality\n-                }\n-                let name = if base::wants_msvc_seh(ccx.sess()) {\n-                    \"__CxxFrameHandler3\"\n-                } else {\n-                    \"rust_eh_personality\"\n-                };\n-                let fty = Type::variadic_func(&[], &Type::i32(ccx));\n-                let f = declare::declare_cfn(ccx, name, fty);\n-                ccx.eh_personality().set(Some(f));\n-                f\n-            }\n-        }\n+    pub fn alloca(&self, ty: Type, name: &str) -> ValueRef {\n+        self.alloca_builder.dynamic_alloca(ty, name)\n     }\n+}\n \n-    // Returns a ValueRef of the \"eh_unwind_resume\" lang item if one is defined,\n-    // otherwise declares it as an external function.\n-    pub fn eh_unwind_resume(&self) -> Callee<'tcx> {\n-        use attributes;\n-        let ccx = self.ccx;\n-        let tcx = ccx.tcx();\n-        assert!(ccx.sess().target.target.options.custom_unwind_resume);\n-        if let Some(def_id) = tcx.lang_items.eh_unwind_resume() {\n-            return Callee::def(ccx, def_id, tcx.intern_substs(&[]));\n-        }\n-\n-        let ty = tcx.mk_fn_ptr(tcx.mk_bare_fn(ty::BareFnTy {\n-            unsafety: hir::Unsafety::Unsafe,\n-            abi: Abi::C,\n-            sig: ty::Binder(tcx.mk_fn_sig(\n-                iter::once(tcx.mk_mut_ptr(tcx.types.u8)),\n-                tcx.types.never,\n-                false\n-            )),\n-        }));\n-\n-        let unwresume = ccx.eh_unwind_resume();\n-        if let Some(llfn) = unwresume.get() {\n-            return Callee::ptr(llfn, ty);\n+impl<'a, 'tcx> Drop for FunctionContext<'a, 'tcx> {\n+    fn drop(&mut self) {\n+        unsafe {\n+            llvm::LLVMInstructionEraseFromParent(self.alloca_insert_pt.unwrap());\n         }\n-        let llfn = declare::declare_fn(ccx, \"rust_eh_unwind_resume\", ty);\n-        attributes::unwind(llfn, true);\n-        unwresume.set(Some(llfn));\n-        Callee::ptr(llfn, ty)\n     }\n }\n \n-// Basic block context.  We create a block context for each basic block\n-// (single-entry, single-exit sequence of instructions) we generate from Rust\n-// code.  Each basic block we generate is attached to a function, typically\n-// with many basic blocks per function.  All the basic blocks attached to a\n-// function are organized as a directed graph.\n-pub struct BlockS<'blk, 'tcx: 'blk> {\n+#[must_use]\n+pub struct BlockAndBuilder<'a, 'tcx: 'a> {\n     // The BasicBlockRef returned from a call to\n     // llvm::LLVMAppendBasicBlock(llfn, name), which adds a basic\n     // block to the function pointed to by llfn.  We insert\n     // instructions into that block by way of this block context.\n     // The block pointing to this one in the function's digraph.\n-    pub llbb: BasicBlockRef,\n-    pub terminated: Cell<bool>,\n-    pub unreachable: Cell<bool>,\n-\n-    // If this block part of a landing pad, then this is `Some` indicating what\n-    // kind of landing pad its in, otherwise this is none.\n-    pub lpad: Cell<Option<&'blk LandingPad>>,\n+    llbb: BasicBlockRef,\n \n     // The function context for the function to which this block is\n     // attached.\n-    pub fcx: &'blk FunctionContext<'blk, 'tcx>,\n-}\n-\n-pub type Block<'blk, 'tcx> = &'blk BlockS<'blk, 'tcx>;\n-\n-impl<'blk, 'tcx> BlockS<'blk, 'tcx> {\n-    pub fn new(llbb: BasicBlockRef,\n-               fcx: &'blk FunctionContext<'blk, 'tcx>)\n-               -> Block<'blk, 'tcx> {\n-        fcx.block_arena.alloc(BlockS {\n-            llbb: llbb,\n-            terminated: Cell::new(false),\n-            unreachable: Cell::new(false),\n-            lpad: Cell::new(None),\n-            fcx: fcx\n-        })\n-    }\n-\n-    pub fn ccx(&self) -> &'blk CrateContext<'blk, 'tcx> {\n-        self.fcx.ccx\n-    }\n-    pub fn fcx(&self) -> &'blk FunctionContext<'blk, 'tcx> {\n-        self.fcx\n-    }\n-    pub fn tcx(&self) -> TyCtxt<'blk, 'tcx, 'tcx> {\n-        self.fcx.ccx.tcx()\n-    }\n-    pub fn sess(&self) -> &'blk Session { self.fcx.ccx.sess() }\n-\n-    pub fn lpad(&self) -> Option<&'blk LandingPad> {\n-        self.lpad.get()\n-    }\n-\n-    pub fn set_lpad_ref(&self, lpad: Option<&'blk LandingPad>) {\n-        // FIXME: use an IVar?\n-        self.lpad.set(lpad);\n-    }\n+    fcx: &'a FunctionContext<'a, 'tcx>,\n \n-    pub fn set_lpad(&self, lpad: Option<LandingPad>) {\n-        self.set_lpad_ref(lpad.map(|p| &*self.fcx().lpad_arena.alloc(p)))\n-    }\n-\n-    pub fn mir(&self) -> Ref<'tcx, Mir<'tcx>> {\n-        self.fcx.mir()\n-    }\n-\n-    pub fn name(&self, name: ast::Name) -> String {\n-        name.to_string()\n-    }\n-\n-    pub fn node_id_to_string(&self, id: ast::NodeId) -> String {\n-        self.tcx().map.node_to_string(id).to_string()\n-    }\n-\n-    pub fn to_str(&self) -> String {\n-        format!(\"[block {:p}]\", self)\n-    }\n-\n-    pub fn monomorphize<T>(&self, value: &T) -> T\n-        where T: TransNormalize<'tcx>\n-    {\n-        monomorphize::apply_param_substs(self.fcx.ccx.shared(),\n-                                         self.fcx.param_substs,\n-                                         value)\n-    }\n-\n-    pub fn build(&'blk self) -> BlockAndBuilder<'blk, 'tcx> {\n-        BlockAndBuilder::new(self, OwnedBuilder::new_with_ccx(self.ccx()))\n-    }\n-}\n-\n-pub struct OwnedBuilder<'blk, 'tcx: 'blk> {\n-    builder: Builder<'blk, 'tcx>\n+    builder: Builder<'a, 'tcx>,\n }\n \n-impl<'blk, 'tcx> OwnedBuilder<'blk, 'tcx> {\n-    pub fn new_with_ccx(ccx: &'blk CrateContext<'blk, 'tcx>) -> Self {\n-        // Create a fresh builder from the crate context.\n-        let llbuilder = unsafe {\n-            llvm::LLVMCreateBuilderInContext(ccx.llcx())\n-        };\n-        OwnedBuilder {\n-            builder: Builder {\n-                llbuilder: llbuilder,\n-                ccx: ccx,\n-            }\n-        }\n-    }\n-}\n-\n-impl<'blk, 'tcx> Drop for OwnedBuilder<'blk, 'tcx> {\n-    fn drop(&mut self) {\n-        unsafe {\n-            llvm::LLVMDisposeBuilder(self.builder.llbuilder);\n-        }\n-    }\n-}\n-\n-pub struct BlockAndBuilder<'blk, 'tcx: 'blk> {\n-    bcx: Block<'blk, 'tcx>,\n-    owned_builder: OwnedBuilder<'blk, 'tcx>,\n-}\n-\n-impl<'blk, 'tcx> BlockAndBuilder<'blk, 'tcx> {\n-    pub fn new(bcx: Block<'blk, 'tcx>, owned_builder: OwnedBuilder<'blk, 'tcx>) -> Self {\n+impl<'a, 'tcx> BlockAndBuilder<'a, 'tcx> {\n+    pub fn new(llbb: BasicBlockRef, fcx: &'a FunctionContext<'a, 'tcx>) -> Self {\n+        let builder = Builder::with_ccx(fcx.ccx);\n         // Set the builder's position to this block's end.\n-        owned_builder.builder.position_at_end(bcx.llbb);\n+        builder.position_at_end(llbb);\n         BlockAndBuilder {\n-            bcx: bcx,\n-            owned_builder: owned_builder,\n+            llbb: llbb,\n+            fcx: fcx,\n+            builder: builder,\n         }\n     }\n \n-    pub fn with_block<F, R>(&self, f: F) -> R\n-        where F: FnOnce(Block<'blk, 'tcx>) -> R\n-    {\n-        let result = f(self.bcx);\n-        self.position_at_end(self.bcx.llbb);\n-        result\n-    }\n-\n-    pub fn map_block<F>(self, f: F) -> Self\n-        where F: FnOnce(Block<'blk, 'tcx>) -> Block<'blk, 'tcx>\n-    {\n-        let BlockAndBuilder { bcx, owned_builder } = self;\n-        let bcx = f(bcx);\n-        BlockAndBuilder::new(bcx, owned_builder)\n-    }\n-\n     pub fn at_start<F, R>(&self, f: F) -> R\n-        where F: FnOnce(&BlockAndBuilder<'blk, 'tcx>) -> R\n+        where F: FnOnce(&BlockAndBuilder<'a, 'tcx>) -> R\n     {\n-        self.position_at_start(self.bcx.llbb);\n+        self.position_at_start(self.llbb);\n         let r = f(self);\n-        self.position_at_end(self.bcx.llbb);\n+        self.position_at_end(self.llbb);\n         r\n     }\n \n-    // Methods delegated to bcx\n-\n-    pub fn is_unreachable(&self) -> bool {\n-        self.bcx.unreachable.get()\n-    }\n-\n-    pub fn ccx(&self) -> &'blk CrateContext<'blk, 'tcx> {\n-        self.bcx.ccx()\n-    }\n-    pub fn fcx(&self) -> &'blk FunctionContext<'blk, 'tcx> {\n-        self.bcx.fcx()\n+    pub fn fcx(&self) -> &'a FunctionContext<'a, 'tcx> {\n+        self.fcx\n     }\n-    pub fn tcx(&self) -> TyCtxt<'blk, 'tcx, 'tcx> {\n-        self.bcx.tcx()\n+    pub fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx> {\n+        self.ccx.tcx()\n     }\n-    pub fn sess(&self) -> &'blk Session {\n-        self.bcx.sess()\n+    pub fn sess(&self) -> &'a Session {\n+        self.ccx.sess()\n     }\n \n     pub fn llbb(&self) -> BasicBlockRef {\n-        self.bcx.llbb\n-    }\n-\n-    pub fn mir(&self) -> Ref<'tcx, Mir<'tcx>> {\n-        self.bcx.mir()\n-    }\n-\n-    pub fn monomorphize<T>(&self, value: &T) -> T\n-        where T: TransNormalize<'tcx>\n-    {\n-        self.bcx.monomorphize(value)\n-    }\n-\n-    pub fn set_lpad(&self, lpad: Option<LandingPad>) {\n-        self.bcx.set_lpad(lpad)\n-    }\n-\n-    pub fn set_lpad_ref(&self, lpad: Option<&'blk LandingPad>) {\n-        // FIXME: use an IVar?\n-        self.bcx.set_lpad_ref(lpad);\n-    }\n-\n-    pub fn lpad(&self) -> Option<&'blk LandingPad> {\n-        self.bcx.lpad()\n+        self.llbb\n     }\n }\n \n-impl<'blk, 'tcx> Deref for BlockAndBuilder<'blk, 'tcx> {\n-    type Target = Builder<'blk, 'tcx>;\n+impl<'a, 'tcx> Deref for BlockAndBuilder<'a, 'tcx> {\n+    type Target = Builder<'a, 'tcx>;\n     fn deref(&self) -> &Self::Target {\n-        &self.owned_builder.builder\n+        &self.builder\n     }\n }\n \n@@ -663,53 +369,33 @@ impl<'blk, 'tcx> Deref for BlockAndBuilder<'blk, 'tcx> {\n /// When inside of a landing pad, each function call in LLVM IR needs to be\n /// annotated with which landing pad it's a part of. This is accomplished via\n /// the `OperandBundleDef` value created for MSVC landing pads.\n-pub struct LandingPad {\n-    cleanuppad: Option<ValueRef>,\n-    operand: Option<OperandBundleDef>,\n+pub struct Funclet {\n+    cleanuppad: ValueRef,\n+    operand: OperandBundleDef,\n }\n \n-impl LandingPad {\n-    pub fn gnu() -> LandingPad {\n-        LandingPad { cleanuppad: None, operand: None }\n-    }\n-\n-    pub fn msvc(cleanuppad: ValueRef) -> LandingPad {\n-        LandingPad {\n-            cleanuppad: Some(cleanuppad),\n-            operand: Some(OperandBundleDef::new(\"funclet\", &[cleanuppad])),\n+impl Funclet {\n+    pub fn new(cleanuppad: ValueRef) -> Funclet {\n+        Funclet {\n+            cleanuppad: cleanuppad,\n+            operand: OperandBundleDef::new(\"funclet\", &[cleanuppad]),\n         }\n     }\n \n-    pub fn bundle(&self) -> Option<&OperandBundleDef> {\n-        self.operand.as_ref()\n-    }\n-\n-    pub fn cleanuppad(&self) -> Option<ValueRef> {\n+    pub fn cleanuppad(&self) -> ValueRef {\n         self.cleanuppad\n     }\n-}\n \n-impl Clone for LandingPad {\n-    fn clone(&self) -> LandingPad {\n-        LandingPad {\n-            cleanuppad: self.cleanuppad,\n-            operand: self.cleanuppad.map(|p| {\n-                OperandBundleDef::new(\"funclet\", &[p])\n-            }),\n-        }\n+    pub fn bundle(&self) -> &OperandBundleDef {\n+        &self.operand\n     }\n }\n \n-pub struct Result<'blk, 'tcx: 'blk> {\n-    pub bcx: Block<'blk, 'tcx>,\n-    pub val: ValueRef\n-}\n-\n-impl<'b, 'tcx> Result<'b, 'tcx> {\n-    pub fn new(bcx: Block<'b, 'tcx>, val: ValueRef) -> Result<'b, 'tcx> {\n-        Result {\n-            bcx: bcx,\n-            val: val,\n+impl Clone for Funclet {\n+    fn clone(&self) -> Funclet {\n+        Funclet {\n+            cleanuppad: self.cleanuppad,\n+            operand: OperandBundleDef::new(\"funclet\", &[self.cleanuppad]),\n         }\n     }\n }\n@@ -1016,43 +702,42 @@ pub fn langcall(tcx: TyCtxt,\n // all shifts). For 32- and 64-bit types, this matches the semantics\n // of Java. (See related discussion on #1877 and #10183.)\n \n-pub fn build_unchecked_lshift<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                          lhs: ValueRef,\n-                                          rhs: ValueRef,\n-                                          binop_debug_loc: DebugLoc) -> ValueRef {\n+pub fn build_unchecked_lshift<'a, 'tcx>(\n+    bcx: &BlockAndBuilder<'a, 'tcx>,\n+    lhs: ValueRef,\n+    rhs: ValueRef\n+) -> ValueRef {\n     let rhs = base::cast_shift_expr_rhs(bcx, hir::BinOp_::BiShl, lhs, rhs);\n     // #1877, #10183: Ensure that input is always valid\n-    let rhs = shift_mask_rhs(bcx, rhs, binop_debug_loc);\n-    build::Shl(bcx, lhs, rhs, binop_debug_loc)\n+    let rhs = shift_mask_rhs(bcx, rhs);\n+    bcx.shl(lhs, rhs)\n }\n \n-pub fn build_unchecked_rshift<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                          lhs_t: Ty<'tcx>,\n-                                          lhs: ValueRef,\n-                                          rhs: ValueRef,\n-                                          binop_debug_loc: DebugLoc) -> ValueRef {\n+pub fn build_unchecked_rshift<'a, 'tcx>(\n+    bcx: &BlockAndBuilder<'a, 'tcx>, lhs_t: Ty<'tcx>, lhs: ValueRef, rhs: ValueRef\n+) -> ValueRef {\n     let rhs = base::cast_shift_expr_rhs(bcx, hir::BinOp_::BiShr, lhs, rhs);\n     // #1877, #10183: Ensure that input is always valid\n-    let rhs = shift_mask_rhs(bcx, rhs, binop_debug_loc);\n+    let rhs = shift_mask_rhs(bcx, rhs);\n     let is_signed = lhs_t.is_signed();\n     if is_signed {\n-        build::AShr(bcx, lhs, rhs, binop_debug_loc)\n+        bcx.ashr(lhs, rhs)\n     } else {\n-        build::LShr(bcx, lhs, rhs, binop_debug_loc)\n+        bcx.lshr(lhs, rhs)\n     }\n }\n \n-fn shift_mask_rhs<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                              rhs: ValueRef,\n-                              debug_loc: DebugLoc) -> ValueRef {\n+fn shift_mask_rhs<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>, rhs: ValueRef) -> ValueRef {\n     let rhs_llty = val_ty(rhs);\n-    build::And(bcx, rhs, shift_mask_val(bcx, rhs_llty, rhs_llty, false), debug_loc)\n+    bcx.and(rhs, shift_mask_val(bcx, rhs_llty, rhs_llty, false))\n }\n \n-pub fn shift_mask_val<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                              llty: Type,\n-                              mask_llty: Type,\n-                              invert: bool) -> ValueRef {\n+pub fn shift_mask_val<'a, 'tcx>(\n+    bcx: &BlockAndBuilder<'a, 'tcx>,\n+    llty: Type,\n+    mask_llty: Type,\n+    invert: bool\n+) -> ValueRef {\n     let kind = llty.kind();\n     match kind {\n         TypeKind::Integer => {\n@@ -1066,7 +751,7 @@ pub fn shift_mask_val<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         },\n         TypeKind::Vector => {\n             let mask = shift_mask_val(bcx, llty.element_type(), mask_llty.element_type(), invert);\n-            build::VectorSplat(bcx, mask_llty.vector_length(), mask)\n+            bcx.vector_splat(mask_llty.vector_length(), mask)\n         },\n         _ => bug!(\"shift_mask_val: expected Integer or Vector, found {:?}\", kind),\n     }"}, {"sha": "2e2644d91bb6c3584aadeec23a53e7b52cbd6b53", "filename": "src/librustc_trans/consts.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_trans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_trans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fconsts.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -16,7 +16,7 @@ use rustc_const_eval::ConstEvalErr;\n use rustc::hir::def_id::DefId;\n use rustc::hir::map as hir_map;\n use {debuginfo, machine};\n-use base::{self, push_ctxt};\n+use base;\n use trans_item::TransItem;\n use common::{CrateContext, val_ty};\n use declare;\n@@ -221,7 +221,6 @@ pub fn trans_static(ccx: &CrateContext,\n                     attrs: &[ast::Attribute])\n                     -> Result<ValueRef, ConstEvalErr> {\n     unsafe {\n-        let _icx = push_ctxt(\"trans_static\");\n         let def_id = ccx.tcx().map.local_def_id(id);\n         let g = get_static(ccx, def_id);\n "}, {"sha": "f292a70965004c0a2c3964b043d1842cc1889e5b", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 96, "deletions": 89, "changes": 185, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -9,17 +9,16 @@\n // except according to those terms.\n \n use llvm;\n-use llvm::{ContextRef, ModuleRef, ValueRef, BuilderRef};\n-use rustc::dep_graph::{DepGraph, DepNode, DepTrackingMap, DepTrackingMapConfig,\n-                       WorkProduct};\n+use llvm::{ContextRef, ModuleRef, ValueRef};\n+use rustc::dep_graph::{DepGraph, DepNode, DepTrackingMap, DepTrackingMapConfig, WorkProduct};\n use middle::cstore::LinkMeta;\n+use rustc::hir;\n use rustc::hir::def::ExportMap;\n use rustc::hir::def_id::DefId;\n use rustc::traits;\n-use base;\n-use builder::Builder;\n-use common::BuilderRef_res;\n use debuginfo;\n+use callee::Callee;\n+use base;\n use declare;\n use glue::DropGlueKind;\n use monomorphize::Instance;\n@@ -40,11 +39,13 @@ use std::ffi::{CStr, CString};\n use std::cell::{Cell, RefCell};\n use std::marker::PhantomData;\n use std::ptr;\n+use std::iter;\n use std::rc::Rc;\n use std::str;\n use syntax::ast;\n use syntax::symbol::InternedString;\n-use abi::FnType;\n+use syntax_pos::DUMMY_SP;\n+use abi::{Abi, FnType};\n \n pub struct Stats {\n     pub n_glues_created: Cell<usize>,\n@@ -71,6 +72,7 @@ pub struct SharedCrateContext<'a, 'tcx: 'a> {\n     exported_symbols: NodeSet,\n     link_meta: LinkMeta,\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    empty_param_env: ty::ParameterEnvironment<'tcx>,\n     stats: Stats,\n     check_overflow: bool,\n \n@@ -140,7 +142,6 @@ pub struct LocalCrateContext<'tcx> {\n     int_type: Type,\n     opaque_vec_type: Type,\n     str_slice_type: Type,\n-    builder: BuilderRef_res,\n \n     /// Holds the LLVM values for closure IDs.\n     closure_vals: RefCell<FxHashMap<Instance<'tcx>, ValueRef>>,\n@@ -153,11 +154,6 @@ pub struct LocalCrateContext<'tcx> {\n \n     intrinsics: RefCell<FxHashMap<&'static str, ValueRef>>,\n \n-    /// Number of LLVM instructions translated into this `LocalCrateContext`.\n-    /// This is used to perform some basic load-balancing to keep all LLVM\n-    /// contexts around the same size.\n-    n_llvm_insns: Cell<usize>,\n-\n     /// Depth of the current type-of computation - used to bail out\n     type_of_depth: Cell<usize>,\n \n@@ -316,38 +312,6 @@ impl<'a, 'tcx> Iterator for CrateContextIterator<'a,'tcx> {\n     }\n }\n \n-/// The iterator produced by `CrateContext::maybe_iter`.\n-pub struct CrateContextMaybeIterator<'a, 'tcx: 'a> {\n-    shared: &'a SharedCrateContext<'a, 'tcx>,\n-    local_ccxs: &'a [LocalCrateContext<'tcx>],\n-    index: usize,\n-    single: bool,\n-    origin: usize,\n-}\n-\n-impl<'a, 'tcx> Iterator for CrateContextMaybeIterator<'a, 'tcx> {\n-    type Item = (CrateContext<'a, 'tcx>, bool);\n-\n-    fn next(&mut self) -> Option<(CrateContext<'a, 'tcx>, bool)> {\n-        if self.index >= self.local_ccxs.len() {\n-            return None;\n-        }\n-\n-        let index = self.index;\n-        self.index += 1;\n-        if self.single {\n-            self.index = self.local_ccxs.len();\n-        }\n-\n-        let ccx = CrateContext {\n-            shared: self.shared,\n-            index: index,\n-            local_ccxs: self.local_ccxs\n-        };\n-        Some((ccx, index == self.origin))\n-    }\n-}\n-\n pub fn get_reloc_model(sess: &Session) -> llvm::RelocMode {\n     let reloc_model_arg = match sess.opts.cg.relocation_model {\n         Some(ref s) => &s[..],\n@@ -496,6 +460,7 @@ impl<'b, 'tcx> SharedCrateContext<'b, 'tcx> {\n             export_map: export_map,\n             exported_symbols: exported_symbols,\n             link_meta: link_meta,\n+            empty_param_env: tcx.empty_parameter_environment(),\n             tcx: tcx,\n             stats: Stats {\n                 n_glues_created: Cell::new(0),\n@@ -516,6 +481,14 @@ impl<'b, 'tcx> SharedCrateContext<'b, 'tcx> {\n         }\n     }\n \n+    pub fn type_needs_drop(&self, ty: Ty<'tcx>) -> bool {\n+        self.tcx.type_needs_drop_given_env(ty, &self.empty_param_env)\n+    }\n+\n+    pub fn type_is_sized(&self, ty: Ty<'tcx>) -> bool {\n+        ty.is_sized(self.tcx, &self.empty_param_env, DUMMY_SP)\n+    }\n+\n     pub fn metadata_llmod(&self) -> ModuleRef {\n         self.metadata_llmod\n     }\n@@ -638,14 +611,12 @@ impl<'tcx> LocalCrateContext<'tcx> {\n                 int_type: Type::from_ref(ptr::null_mut()),\n                 opaque_vec_type: Type::from_ref(ptr::null_mut()),\n                 str_slice_type: Type::from_ref(ptr::null_mut()),\n-                builder: BuilderRef_res(llvm::LLVMCreateBuilderInContext(llcx)),\n                 closure_vals: RefCell::new(FxHashMap()),\n                 dbg_cx: dbg_cx,\n                 eh_personality: Cell::new(None),\n                 eh_unwind_resume: Cell::new(None),\n                 rust_try_fn: Cell::new(None),\n                 intrinsics: RefCell::new(FxHashMap()),\n-                n_llvm_insns: Cell::new(0),\n                 type_of_depth: Cell::new(0),\n                 symbol_map: symbol_map,\n                 local_gen_sym_counter: Cell::new(0),\n@@ -671,10 +642,6 @@ impl<'tcx> LocalCrateContext<'tcx> {\n             local_ccx.opaque_vec_type = opaque_vec_type;\n             local_ccx.str_slice_type = str_slice_ty;\n \n-            if shared.tcx.sess.count_llvm_insns() {\n-                base::init_insn_ctxt()\n-            }\n-\n             local_ccx\n         }\n     }\n@@ -703,26 +670,10 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         self.shared\n     }\n \n-    pub fn local(&self) -> &'b LocalCrateContext<'tcx> {\n+    fn local(&self) -> &'b LocalCrateContext<'tcx> {\n         &self.local_ccxs[self.index]\n     }\n \n-    /// Either iterate over only `self`, or iterate over all `CrateContext`s in\n-    /// the `SharedCrateContext`.  The iterator produces `(ccx, is_origin)`\n-    /// pairs, where `is_origin` is `true` if `ccx` is `self` and `false`\n-    /// otherwise.  This method is useful for avoiding code duplication in\n-    /// cases where it may or may not be necessary to translate code into every\n-    /// context.\n-    pub fn maybe_iter(&self, iter_all: bool) -> CrateContextMaybeIterator<'b, 'tcx> {\n-        CrateContextMaybeIterator {\n-            shared: self.shared,\n-            index: if iter_all { 0 } else { self.index },\n-            single: !iter_all,\n-            origin: self.index,\n-            local_ccxs: self.local_ccxs,\n-        }\n-    }\n-\n     pub fn tcx<'a>(&'a self) -> TyCtxt<'a, 'tcx, 'tcx> {\n         self.shared.tcx\n     }\n@@ -731,14 +682,6 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         &self.shared.tcx.sess\n     }\n \n-    pub fn builder<'a>(&'a self) -> Builder<'a, 'tcx> {\n-        Builder::new(self)\n-    }\n-\n-    pub fn raw_builder<'a>(&'a self) -> BuilderRef {\n-        self.local().builder.b\n-    }\n-\n     pub fn get_intrinsic(&self, key: &str) -> ValueRef {\n         if let Some(v) = self.intrinsics().borrow().get(key).cloned() {\n             return v;\n@@ -886,14 +829,6 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         &self.local().dbg_cx\n     }\n \n-    pub fn eh_personality<'a>(&'a self) -> &'a Cell<Option<ValueRef>> {\n-        &self.local().eh_personality\n-    }\n-\n-    pub fn eh_unwind_resume<'a>(&'a self) -> &'a Cell<Option<ValueRef>> {\n-        &self.local().eh_unwind_resume\n-    }\n-\n     pub fn rust_try_fn<'a>(&'a self) -> &'a Cell<Option<ValueRef>> {\n         &self.local().rust_try_fn\n     }\n@@ -902,10 +837,6 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         &self.local().intrinsics\n     }\n \n-    pub fn count_llvm_insn(&self) {\n-        self.local().n_llvm_insns.set(self.local().n_llvm_insns.get() + 1);\n-    }\n-\n     pub fn obj_size_bound(&self) -> u64 {\n         self.tcx().data_layout.obj_size_bound()\n     }\n@@ -971,9 +902,85 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         let mut name = String::with_capacity(prefix.len() + 6);\n         name.push_str(prefix);\n         name.push_str(\".\");\n-        base_n::push_str(idx as u64, base_n::MAX_BASE, &mut name);\n+        base_n::push_str(idx as u64, base_n::ALPHANUMERIC_ONLY, &mut name);\n         name\n     }\n+\n+    pub fn eh_personality(&self) -> ValueRef {\n+        // The exception handling personality function.\n+        //\n+        // If our compilation unit has the `eh_personality` lang item somewhere\n+        // within it, then we just need to translate that. Otherwise, we're\n+        // building an rlib which will depend on some upstream implementation of\n+        // this function, so we just codegen a generic reference to it. We don't\n+        // specify any of the types for the function, we just make it a symbol\n+        // that LLVM can later use.\n+        //\n+        // Note that MSVC is a little special here in that we don't use the\n+        // `eh_personality` lang item at all. Currently LLVM has support for\n+        // both Dwarf and SEH unwind mechanisms for MSVC targets and uses the\n+        // *name of the personality function* to decide what kind of unwind side\n+        // tables/landing pads to emit. It looks like Dwarf is used by default,\n+        // injecting a dependency on the `_Unwind_Resume` symbol for resuming\n+        // an \"exception\", but for MSVC we want to force SEH. This means that we\n+        // can't actually have the personality function be our standard\n+        // `rust_eh_personality` function, but rather we wired it up to the\n+        // CRT's custom personality function, which forces LLVM to consider\n+        // landing pads as \"landing pads for SEH\".\n+        if let Some(llpersonality) = self.local().eh_personality.get() {\n+            return llpersonality\n+        }\n+        let tcx = self.tcx();\n+        let llfn = match tcx.lang_items.eh_personality() {\n+            Some(def_id) if !base::wants_msvc_seh(self.sess()) => {\n+                Callee::def(self, def_id, tcx.intern_substs(&[])).reify(self)\n+            }\n+            _ => {\n+                let name = if base::wants_msvc_seh(self.sess()) {\n+                    \"__CxxFrameHandler3\"\n+                } else {\n+                    \"rust_eh_personality\"\n+                };\n+                let fty = Type::variadic_func(&[], &Type::i32(self));\n+                declare::declare_cfn(self, name, fty)\n+            }\n+        };\n+        self.local().eh_personality.set(Some(llfn));\n+        llfn\n+    }\n+\n+    // Returns a ValueRef of the \"eh_unwind_resume\" lang item if one is defined,\n+    // otherwise declares it as an external function.\n+    pub fn eh_unwind_resume(&self) -> ValueRef {\n+        use attributes;\n+        let unwresume = &self.local().eh_unwind_resume;\n+        if let Some(llfn) = unwresume.get() {\n+            return llfn;\n+        }\n+\n+        let tcx = self.tcx();\n+        assert!(self.sess().target.target.options.custom_unwind_resume);\n+        if let Some(def_id) = tcx.lang_items.eh_unwind_resume() {\n+            let llfn = Callee::def(self, def_id, tcx.intern_substs(&[])).reify(self);\n+            unwresume.set(Some(llfn));\n+            return llfn;\n+        }\n+\n+        let ty = tcx.mk_fn_ptr(tcx.mk_bare_fn(ty::BareFnTy {\n+            unsafety: hir::Unsafety::Unsafe,\n+            abi: Abi::C,\n+            sig: ty::Binder(tcx.mk_fn_sig(\n+                iter::once(tcx.mk_mut_ptr(tcx.types.u8)),\n+                tcx.types.never,\n+                false\n+            )),\n+        }));\n+\n+        let llfn = declare::declare_fn(self, \"rust_eh_unwind_resume\", ty);\n+        attributes::unwind(llfn, true);\n+        unwresume.set(Some(llfn));\n+        llfn\n+    }\n }\n \n pub struct TypeOfDepthLock<'a, 'tcx: 'a>(&'a LocalCrateContext<'tcx>);"}, {"sha": "f5a8eeacf38adba37051666d798402945cb92170", "filename": "src/librustc_trans/debuginfo/create_scope_map.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_trans%2Fdebuginfo%2Fcreate_scope_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_trans%2Fdebuginfo%2Fcreate_scope_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fcreate_scope_map.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -44,17 +44,17 @@ impl MirDebugScope {\n \n /// Produce DIScope DIEs for each MIR Scope which has variables defined in it.\n /// If debuginfo is disabled, the returned vector is empty.\n-pub fn create_mir_scopes(fcx: &FunctionContext) -> IndexVec<VisibilityScope, MirDebugScope> {\n-    let mir = fcx.mir();\n+pub fn create_mir_scopes(fcx: &FunctionContext, mir: &Mir, debug_context: &FunctionDebugContext)\n+    -> IndexVec<VisibilityScope, MirDebugScope> {\n     let null_scope = MirDebugScope {\n         scope_metadata: ptr::null_mut(),\n         file_start_pos: BytePos(0),\n         file_end_pos: BytePos(0)\n     };\n     let mut scopes = IndexVec::from_elem(null_scope, &mir.visibility_scopes);\n \n-    let fn_metadata = match fcx.debug_context {\n-        FunctionDebugContext::RegularContext(box ref data) => data.fn_metadata,\n+    let fn_metadata = match *debug_context {\n+        FunctionDebugContext::RegularContext(ref data) => data.fn_metadata,\n         FunctionDebugContext::DebugInfoDisabled |\n         FunctionDebugContext::FunctionWithoutDebugInfo => {\n             return scopes;"}, {"sha": "e8728a39993081bc3bcc45966b43537922ea2b37", "filename": "src/librustc_trans/debuginfo/gdb.rs", "status": "modified", "additions": 8, "deletions": 19, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_trans%2Fdebuginfo%2Fgdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_trans%2Fdebuginfo%2Fgdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fgdb.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -13,37 +13,26 @@\n use llvm;\n \n use common::{C_bytes, CrateContext, C_i32};\n+use builder::Builder;\n use declare;\n use type_::Type;\n use session::config::NoDebugInfo;\n \n-use std::ffi::CString;\n use std::ptr;\n use syntax::attr;\n \n \n /// Inserts a side-effect free instruction sequence that makes sure that the\n /// .debug_gdb_scripts global is referenced, so it isn't removed by the linker.\n-pub fn insert_reference_to_gdb_debug_scripts_section_global(ccx: &CrateContext) {\n+pub fn insert_reference_to_gdb_debug_scripts_section_global(ccx: &CrateContext, builder: &Builder) {\n     if needs_gdb_debug_scripts_section(ccx) {\n-        let empty = CString::new(\"\").unwrap();\n-        let gdb_debug_scripts_section_global =\n-            get_or_insert_gdb_debug_scripts_section_global(ccx);\n+        let gdb_debug_scripts_section_global = get_or_insert_gdb_debug_scripts_section_global(ccx);\n+        // Load just the first byte as that's all that's necessary to force\n+        // LLVM to keep around the reference to the global.\n+        let indices = [C_i32(ccx, 0), C_i32(ccx, 0)];\n+        let element = builder.inbounds_gep(gdb_debug_scripts_section_global, &indices);\n+        let volative_load_instruction = builder.volatile_load(element);\n         unsafe {\n-            // Load just the first byte as that's all that's necessary to force\n-            // LLVM to keep around the reference to the global.\n-            let indices = [C_i32(ccx, 0), C_i32(ccx, 0)];\n-            let element =\n-                llvm::LLVMBuildInBoundsGEP(ccx.raw_builder(),\n-                                           gdb_debug_scripts_section_global,\n-                                           indices.as_ptr(),\n-                                           indices.len() as ::libc::c_uint,\n-                                           empty.as_ptr());\n-            let volative_load_instruction =\n-                llvm::LLVMBuildLoad(ccx.raw_builder(),\n-                                    element,\n-                                    empty.as_ptr());\n-            llvm::LLVMSetVolatile(volative_load_instruction, llvm::True);\n             llvm::LLVMSetAlignment(volative_load_instruction, 1);\n         }\n     }"}, {"sha": "511c9d3c13f91ad33a65bc47e733754a024962aa", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 44, "deletions": 38, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -31,7 +31,7 @@ use rustc::ty::fold::TypeVisitor;\n use rustc::ty::subst::Substs;\n use rustc::ty::util::TypeIdHasher;\n use rustc::hir;\n-use rustc_data_structures::blake2b::Blake2bHasher;\n+use rustc_data_structures::ToHex;\n use {type_of, machine, monomorphize};\n use common::CrateContext;\n use type_::Type;\n@@ -42,7 +42,6 @@ use util::common::path2cstr;\n \n use libc::{c_uint, c_longlong};\n use std::ffi::CString;\n-use std::fmt::Write;\n use std::path::Path;\n use std::ptr;\n use syntax::ast;\n@@ -147,21 +146,11 @@ impl<'tcx> TypeMap<'tcx> {\n \n         // The hasher we are using to generate the UniqueTypeId. We want\n         // something that provides more than the 64 bits of the DefaultHasher.\n-        const TYPE_ID_HASH_LENGTH: usize = 20;\n \n-        let mut type_id_hasher = TypeIdHasher::new(cx.tcx(),\n-                                                   Blake2bHasher::new(TYPE_ID_HASH_LENGTH, &[]));\n+        let mut type_id_hasher = TypeIdHasher::<[u8; 20]>::new(cx.tcx());\n         type_id_hasher.visit_ty(type_);\n-        let mut hash_state = type_id_hasher.into_inner();\n-        let hash: &[u8] = hash_state.finalize();\n-        debug_assert!(hash.len() == TYPE_ID_HASH_LENGTH);\n-\n-        let mut unique_type_id = String::with_capacity(TYPE_ID_HASH_LENGTH * 2);\n-\n-        for byte in hash.into_iter() {\n-            write!(&mut unique_type_id, \"{:x}\", byte).unwrap();\n-        }\n \n+        let unique_type_id = type_id_hasher.finish().to_hex();\n         let key = self.unique_id_interner.intern(&unique_type_id);\n         self.type_to_unique_id.insert(type_, UniqueTypeId(key));\n \n@@ -881,25 +870,28 @@ impl<'tcx> MemberDescriptionFactory<'tcx> {\n \n // Creates MemberDescriptions for the fields of a struct\n struct StructMemberDescriptionFactory<'tcx> {\n+    ty: Ty<'tcx>,\n     variant: &'tcx ty::VariantDef,\n     substs: &'tcx Substs<'tcx>,\n-    is_simd: bool,\n     span: Span,\n }\n \n impl<'tcx> StructMemberDescriptionFactory<'tcx> {\n     fn create_member_descriptions<'a>(&self, cx: &CrateContext<'a, 'tcx>)\n                                       -> Vec<MemberDescription> {\n-        let field_size = if self.is_simd {\n-            let fty = monomorphize::field_ty(cx.tcx(),\n-                                             self.substs,\n-                                             &self.variant.fields[0]);\n-            Some(machine::llsize_of_alloc(\n-                cx,\n-                type_of::type_of(cx, fty)\n-            ) as usize)\n-        } else {\n-            None\n+        let layout = cx.layout_of(self.ty);\n+\n+        let tmp;\n+        let offsets = match *layout {\n+            layout::Univariant { ref variant, .. } => &variant.offsets,\n+            layout::Vector { element, count } => {\n+                let element_size = element.size(&cx.tcx().data_layout).bytes();\n+                tmp = (0..count).\n+                  map(|i| layout::Size::from_bytes(i*element_size))\n+                  .collect::<Vec<layout::Size>>();\n+                &tmp\n+            }\n+            _ => bug!(\"{} is not a struct\", self.ty)\n         };\n \n         self.variant.fields.iter().enumerate().map(|(i, f)| {\n@@ -910,11 +902,7 @@ impl<'tcx> StructMemberDescriptionFactory<'tcx> {\n             };\n             let fty = monomorphize::field_ty(cx.tcx(), self.substs, f);\n \n-            let offset = if self.is_simd {\n-                FixedMemberOffset { bytes: i * field_size.unwrap() }\n-            } else {\n-                ComputedMemberOffset\n-            };\n+            let offset = FixedMemberOffset { bytes: offsets[i].bytes() as usize};\n \n             MemberDescription {\n                 name: name,\n@@ -956,9 +944,9 @@ fn prepare_struct_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         struct_metadata_stub,\n         struct_llvm_type,\n         StructMDF(StructMemberDescriptionFactory {\n+            ty: struct_type,\n             variant: variant,\n             substs: substs,\n-            is_simd: struct_type.is_simd(),\n             span: span,\n         })\n     )\n@@ -970,13 +958,21 @@ fn prepare_struct_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n // Creates MemberDescriptions for the fields of a tuple\n struct TupleMemberDescriptionFactory<'tcx> {\n+    ty: Ty<'tcx>,\n     component_types: Vec<Ty<'tcx>>,\n     span: Span,\n }\n \n impl<'tcx> TupleMemberDescriptionFactory<'tcx> {\n     fn create_member_descriptions<'a>(&self, cx: &CrateContext<'a, 'tcx>)\n                                       -> Vec<MemberDescription> {\n+        let layout = cx.layout_of(self.ty);\n+        let offsets = if let layout::Univariant { ref variant, .. } = *layout {\n+            &variant.offsets\n+        } else {\n+            bug!(\"{} is not a tuple\", self.ty);\n+        };\n+\n         self.component_types\n             .iter()\n             .enumerate()\n@@ -985,7 +981,7 @@ impl<'tcx> TupleMemberDescriptionFactory<'tcx> {\n                 name: format!(\"__{}\", i),\n                 llvm_type: type_of::type_of(cx, component_type),\n                 type_metadata: type_metadata(cx, component_type, self.span),\n-                offset: ComputedMemberOffset,\n+                offset: FixedMemberOffset { bytes: offsets[i].bytes() as usize },\n                 flags: DIFlags::FlagZero,\n             }\n         }).collect()\n@@ -1012,6 +1008,7 @@ fn prepare_tuple_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                            NO_SCOPE_METADATA),\n         tuple_llvm_type,\n         TupleMDF(TupleMemberDescriptionFactory {\n+            ty: tuple_type,\n             component_types: component_types.to_vec(),\n             span: span,\n         })\n@@ -1250,7 +1247,7 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n             },\n             layout::StructWrappedNullablePointer { nonnull: ref struct_def,\n                                                 nndiscr,\n-                                                ref discrfield, ..} => {\n+                                                ref discrfield_source, ..} => {\n                 // Create a description of the non-null variant\n                 let (variant_type_metadata, variant_llvm_type, member_description_factory) =\n                     describe_enum_variant(cx,\n@@ -1273,12 +1270,12 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n                 // member's name.\n                 let null_variant_index = (1 - nndiscr) as usize;\n                 let null_variant_name = adt.variants[null_variant_index].name;\n-                let discrfield = discrfield.iter()\n+                let discrfield_source = discrfield_source.iter()\n                                            .skip(1)\n                                            .map(|x| x.to_string())\n                                            .collect::<Vec<_>>().join(\"$\");\n                 let union_member_name = format!(\"RUST$ENCODED$ENUM${}${}\",\n-                                                discrfield,\n+                                                discrfield_source,\n                                                 null_variant_name);\n \n                 // Create the (singleton) list of descriptions of union members.\n@@ -1300,6 +1297,8 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n \n // Creates MemberDescriptions for the fields of a single enum variant.\n struct VariantMemberDescriptionFactory<'tcx> {\n+    // Cloned from the layout::Struct describing the variant.\n+    offsets: &'tcx [layout::Size],\n     args: Vec<(String, Ty<'tcx>)>,\n     discriminant_type_metadata: Option<DIType>,\n     span: Span,\n@@ -1316,7 +1315,7 @@ impl<'tcx> VariantMemberDescriptionFactory<'tcx> {\n                     Some(metadata) if i == 0 => metadata,\n                     _ => type_metadata(cx, ty, self.span)\n                 },\n-                offset: ComputedMemberOffset,\n+                offset: FixedMemberOffset { bytes: self.offsets[i].bytes() as usize },\n                 flags: DIFlags::FlagZero\n             }\n         }).collect()\n@@ -1336,7 +1335,7 @@ enum EnumDiscriminantInfo {\n // full RecursiveTypeDescription.\n fn describe_enum_variant<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                    enum_type: Ty<'tcx>,\n-                                   struct_def: &layout::Struct,\n+                                   struct_def: &'tcx layout::Struct,\n                                    variant: &'tcx ty::VariantDef,\n                                    discriminant_info: EnumDiscriminantInfo,\n                                    containing_scope: DIScope,\n@@ -1420,6 +1419,7 @@ fn describe_enum_variant<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n     let member_description_factory =\n         VariantMDF(VariantMemberDescriptionFactory {\n+            offsets: &struct_def.offsets[..],\n             args: args,\n             discriminant_type_metadata: match discriminant_info {\n                 RegularDiscriminant(discriminant_type_metadata) => {\n@@ -1763,6 +1763,10 @@ pub fn create_global_var_metadata(cx: &CrateContext,\n \n     let var_name = CString::new(var_name).unwrap();\n     let linkage_name = CString::new(linkage_name).unwrap();\n+\n+    let ty = cx.tcx().item_type(node_def_id);\n+    let global_align = type_of::align_of(cx, ty);\n+\n     unsafe {\n         llvm::LLVMRustDIBuilderCreateStaticVariable(DIB(cx),\n                                                     var_scope,\n@@ -1773,7 +1777,9 @@ pub fn create_global_var_metadata(cx: &CrateContext,\n                                                     type_metadata,\n                                                     is_local_to_unit,\n                                                     global,\n-                                                    ptr::null_mut());\n+                                                    ptr::null_mut(),\n+                                                    global_align as u64,\n+        );\n     }\n }\n "}, {"sha": "86099d241df686bec35b2594f87cb3ef78e990ab", "filename": "src/librustc_trans/debuginfo/mod.rs", "status": "modified", "additions": 35, "deletions": 69, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -27,7 +27,7 @@ use rustc::hir::def_id::DefId;\n use rustc::ty::subst::Substs;\n \n use abi::Abi;\n-use common::{CrateContext, FunctionContext, Block, BlockAndBuilder};\n+use common::{CrateContext, BlockAndBuilder};\n use monomorphize::{self, Instance};\n use rustc::ty::{self, Ty};\n use rustc::mir;\n@@ -55,6 +55,7 @@ pub use self::create_scope_map::{create_mir_scopes, MirDebugScope};\n pub use self::source_loc::start_emitting_source_locations;\n pub use self::metadata::create_global_var_metadata;\n pub use self::metadata::extend_scope_to_file;\n+pub use self::source_loc::set_source_location;\n \n #[allow(non_upper_case_globals)]\n const DW_TAG_auto_variable: c_uint = 0x100;\n@@ -65,7 +66,6 @@ const DW_TAG_arg_variable: c_uint = 0x101;\n pub struct CrateDebugContext<'tcx> {\n     llcontext: ContextRef,\n     builder: DIBuilderRef,\n-    current_debug_location: Cell<InternalDebugLocation>,\n     created_files: RefCell<FxHashMap<String, DIFile>>,\n     created_enum_disr_types: RefCell<FxHashMap<(DefId, layout::Integer), DIType>>,\n \n@@ -83,40 +83,33 @@ impl<'tcx> CrateDebugContext<'tcx> {\n         let builder = unsafe { llvm::LLVMRustDIBuilderCreate(llmod) };\n         // DIBuilder inherits context from the module, so we'd better use the same one\n         let llcontext = unsafe { llvm::LLVMGetModuleContext(llmod) };\n-        return CrateDebugContext {\n+        CrateDebugContext {\n             llcontext: llcontext,\n             builder: builder,\n-            current_debug_location: Cell::new(InternalDebugLocation::UnknownLocation),\n             created_files: RefCell::new(FxHashMap()),\n             created_enum_disr_types: RefCell::new(FxHashMap()),\n             type_map: RefCell::new(TypeMap::new()),\n             namespace_map: RefCell::new(DefIdMap()),\n             composite_types_completed: RefCell::new(FxHashSet()),\n-        };\n+        }\n     }\n }\n \n pub enum FunctionDebugContext {\n-    RegularContext(Box<FunctionDebugContextData>),\n+    RegularContext(FunctionDebugContextData),\n     DebugInfoDisabled,\n     FunctionWithoutDebugInfo,\n }\n \n impl FunctionDebugContext {\n-    fn get_ref<'a>(&'a self,\n-                   span: Span)\n-                   -> &'a FunctionDebugContextData {\n+    fn get_ref<'a>(&'a self, span: Span) -> &'a FunctionDebugContextData {\n         match *self {\n-            FunctionDebugContext::RegularContext(box ref data) => data,\n+            FunctionDebugContext::RegularContext(ref data) => data,\n             FunctionDebugContext::DebugInfoDisabled => {\n-                span_bug!(span,\n-                          \"{}\",\n-                          FunctionDebugContext::debuginfo_disabled_message());\n+                span_bug!(span, \"{}\", FunctionDebugContext::debuginfo_disabled_message());\n             }\n             FunctionDebugContext::FunctionWithoutDebugInfo => {\n-                span_bug!(span,\n-                          \"{}\",\n-                          FunctionDebugContext::should_be_ignored_message());\n+                span_bug!(span, \"{}\", FunctionDebugContext::should_be_ignored_message());\n             }\n         }\n     }\n@@ -134,7 +127,6 @@ impl FunctionDebugContext {\n pub struct FunctionDebugContextData {\n     fn_metadata: DISubprogram,\n     source_locations_enabled: Cell<bool>,\n-    source_location_override: Cell<bool>,\n }\n \n pub enum VariableAccess<'a> {\n@@ -197,18 +189,6 @@ pub fn finalize(cx: &CrateContext) {\n     };\n }\n \n-/// Creates a function-specific debug context for a function w/o debuginfo.\n-pub fn empty_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>)\n-                                              -> FunctionDebugContext {\n-    if cx.sess().opts.debuginfo == NoDebugInfo {\n-        return FunctionDebugContext::DebugInfoDisabled;\n-    }\n-\n-    // Clear the debug location so we don't assign them in the function prelude.\n-    source_loc::set_debug_location(cx, None, UnknownLocation);\n-    FunctionDebugContext::FunctionWithoutDebugInfo\n-}\n-\n /// Creates the function-specific debug context.\n ///\n /// Returns the FunctionDebugContext for the function which holds state needed\n@@ -225,15 +205,18 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         return FunctionDebugContext::DebugInfoDisabled;\n     }\n \n-    // Clear the debug location so we don't assign them in the function prelude.\n-    // Do this here already, in case we do an early exit from this function.\n-    source_loc::set_debug_location(cx, None, UnknownLocation);\n+    for attr in cx.tcx().get_attrs(instance.def).iter() {\n+        if attr.check_name(\"no_debug\") {\n+            return FunctionDebugContext::FunctionWithoutDebugInfo;\n+        }\n+    }\n \n     let containing_scope = get_containing_scope(cx, instance);\n     let span = mir.span;\n \n     // This can be the case for functions inlined from another crate\n     if span == syntax_pos::DUMMY_SP {\n+        // FIXME(simulacrum): Probably can't happen; remove.\n         return FunctionDebugContext::FunctionWithoutDebugInfo;\n     }\n \n@@ -293,10 +276,9 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     };\n \n     // Initialize fn debug context (including scope map and namespace map)\n-    let fn_debug_context = box FunctionDebugContextData {\n+    let fn_debug_context = FunctionDebugContextData {\n         fn_metadata: fn_metadata,\n         source_locations_enabled: Cell::new(false),\n-        source_location_override: Cell::new(false),\n     };\n \n     return FunctionDebugContext::RegularContext(fn_debug_context);\n@@ -441,14 +423,15 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     }\n }\n \n-pub fn declare_local<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                 variable_name: ast::Name,\n-                                 variable_type: Ty<'tcx>,\n-                                 scope_metadata: DIScope,\n-                                 variable_access: VariableAccess,\n-                                 variable_kind: VariableKind,\n-                                 span: Span) {\n-    let cx: &CrateContext = bcx.ccx();\n+pub fn declare_local<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n+                               dbg_context: &FunctionDebugContext,\n+                               variable_name: ast::Name,\n+                               variable_type: Ty<'tcx>,\n+                               scope_metadata: DIScope,\n+                               variable_access: VariableAccess,\n+                               variable_kind: VariableKind,\n+                               span: Span) {\n+    let cx = bcx.ccx;\n \n     let file = span_start(cx, span).file;\n     let filename = file.name.clone();\n@@ -462,6 +445,7 @@ pub fn declare_local<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         LocalVariable    |\n         CapturedVariable => (0, DW_TAG_auto_variable)\n     };\n+    let align = ::type_of::align_of(cx, variable_type);\n \n     let name = CString::new(variable_name.as_str().as_bytes()).unwrap();\n     match (variable_access, &[][..]) {\n@@ -478,51 +462,33 @@ pub fn declare_local<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                     type_metadata,\n                     cx.sess().opts.optimize != config::OptLevel::No,\n                     DIFlags::FlagZero,\n-                    argument_index)\n+                    argument_index,\n+                    align as u64,\n+                )\n             };\n-            source_loc::set_debug_location(cx, None,\n+            source_loc::set_debug_location(bcx,\n                 InternalDebugLocation::new(scope_metadata, loc.line, loc.col.to_usize()));\n             unsafe {\n-                let debug_loc = llvm::LLVMGetCurrentDebugLocation(cx.raw_builder());\n+                let debug_loc = llvm::LLVMGetCurrentDebugLocation(bcx.llbuilder);\n                 let instr = llvm::LLVMRustDIBuilderInsertDeclareAtEnd(\n                     DIB(cx),\n                     alloca,\n                     metadata,\n                     address_operations.as_ptr(),\n                     address_operations.len() as c_uint,\n                     debug_loc,\n-                    bcx.llbb);\n+                    bcx.llbb());\n \n-                llvm::LLVMSetInstDebugLocation(::build::B(bcx).llbuilder, instr);\n+                llvm::LLVMSetInstDebugLocation(bcx.llbuilder, instr);\n             }\n         }\n     }\n \n     match variable_kind {\n         ArgumentVariable(_) | CapturedVariable => {\n-            assert!(!bcx.fcx\n-                        .debug_context\n-                        .get_ref(span)\n-                        .source_locations_enabled\n-                        .get());\n-            source_loc::set_debug_location(cx, None, UnknownLocation);\n+            assert!(!dbg_context.get_ref(span).source_locations_enabled.get());\n+            source_loc::set_debug_location(bcx, UnknownLocation);\n         }\n         _ => { /* nothing to do */ }\n     }\n }\n-\n-#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n-pub enum DebugLoc {\n-    ScopeAt(DIScope, Span),\n-    None\n-}\n-\n-impl DebugLoc {\n-    pub fn apply(self, fcx: &FunctionContext) {\n-        source_loc::set_source_location(fcx, None, self);\n-    }\n-\n-    pub fn apply_to_bcx(self, bcx: &BlockAndBuilder) {\n-        source_loc::set_source_location(bcx.fcx(), Some(bcx), self);\n-    }\n-}"}, {"sha": "e02c8be19a2f477315c2e1cdf671ee205c7f6796", "filename": "src/librustc_trans/debuginfo/source_loc.rs", "status": "modified", "additions": 18, "deletions": 48, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_trans%2Fdebuginfo%2Fsource_loc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_trans%2Fdebuginfo%2Fsource_loc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fsource_loc.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -11,57 +11,40 @@\n use self::InternalDebugLocation::*;\n \n use super::utils::{debug_context, span_start};\n-use super::metadata::{UNKNOWN_COLUMN_NUMBER};\n-use super::{FunctionDebugContext, DebugLoc};\n+use super::metadata::UNKNOWN_COLUMN_NUMBER;\n+use super::FunctionDebugContext;\n \n use llvm;\n use llvm::debuginfo::DIScope;\n use builder::Builder;\n-use common::{CrateContext, FunctionContext};\n \n use libc::c_uint;\n use std::ptr;\n-use syntax_pos::Pos;\n+use syntax_pos::{Span, Pos};\n \n /// Sets the current debug location at the beginning of the span.\n ///\n /// Maps to a call to llvm::LLVMSetCurrentDebugLocation(...).\n-pub fn set_source_location(fcx: &FunctionContext,\n-                           builder: Option<&Builder>,\n-                           debug_loc: DebugLoc) {\n-    let builder = builder.map(|b| b.llbuilder);\n-    let function_debug_context = match fcx.debug_context {\n+pub fn set_source_location(\n+    debug_context: &FunctionDebugContext, builder: &Builder, scope: DIScope, span: Span\n+) {\n+    let function_debug_context = match *debug_context {\n         FunctionDebugContext::DebugInfoDisabled => return,\n         FunctionDebugContext::FunctionWithoutDebugInfo => {\n-            set_debug_location(fcx.ccx, builder, UnknownLocation);\n+            set_debug_location(builder, UnknownLocation);\n             return;\n         }\n-        FunctionDebugContext::RegularContext(box ref data) => data\n+        FunctionDebugContext::RegularContext(ref data) => data\n     };\n \n-    if function_debug_context.source_location_override.get() {\n-        // Just ignore any attempts to set a new debug location while\n-        // the override is active.\n-        return;\n-    }\n-\n     let dbg_loc = if function_debug_context.source_locations_enabled.get() {\n-        let (scope, span) = match debug_loc {\n-            DebugLoc::ScopeAt(scope, span) => (scope, span),\n-            DebugLoc::None => {\n-                set_debug_location(fcx.ccx, builder, UnknownLocation);\n-                return;\n-            }\n-        };\n-\n-        debug!(\"set_source_location: {}\",\n-               fcx.ccx.sess().codemap().span_to_string(span));\n-        let loc = span_start(fcx.ccx, span);\n+        debug!(\"set_source_location: {}\", builder.ccx.sess().codemap().span_to_string(span));\n+        let loc = span_start(builder.ccx, span);\n         InternalDebugLocation::new(scope, loc.line, loc.col.to_usize())\n     } else {\n         UnknownLocation\n     };\n-    set_debug_location(fcx.ccx, builder, dbg_loc);\n+    set_debug_location(builder, dbg_loc);\n }\n \n /// Enables emitting source locations for the given functions.\n@@ -70,9 +53,9 @@ pub fn set_source_location(fcx: &FunctionContext,\n /// they are disabled when beginning to translate a new function. This functions\n /// switches source location emitting on and must therefore be called before the\n /// first real statement/expression of the function is translated.\n-pub fn start_emitting_source_locations(fcx: &FunctionContext) {\n-    match fcx.debug_context {\n-        FunctionDebugContext::RegularContext(box ref data) => {\n+pub fn start_emitting_source_locations(dbg_context: &FunctionDebugContext) {\n+    match *dbg_context {\n+        FunctionDebugContext::RegularContext(ref data) => {\n             data.source_locations_enabled.set(true)\n         },\n         _ => { /* safe to ignore */ }\n@@ -96,15 +79,7 @@ impl InternalDebugLocation {\n     }\n }\n \n-pub fn set_debug_location(cx: &CrateContext,\n-                          builder: Option<llvm::BuilderRef>,\n-                          debug_location: InternalDebugLocation) {\n-    if builder.is_none() {\n-        if debug_location == debug_context(cx).current_debug_location.get() {\n-            return;\n-        }\n-    }\n-\n+pub fn set_debug_location(builder: &Builder, debug_location: InternalDebugLocation) {\n     let metadata_node = match debug_location {\n         KnownLocation { scope, line, .. } => {\n             // Always set the column to zero like Clang and GCC\n@@ -113,7 +88,7 @@ pub fn set_debug_location(cx: &CrateContext,\n \n             unsafe {\n                 llvm::LLVMRustDIBuilderCreateDebugLocation(\n-                    debug_context(cx).llcontext,\n+                    debug_context(builder.ccx).llcontext,\n                     line as c_uint,\n                     col as c_uint,\n                     scope,\n@@ -126,12 +101,7 @@ pub fn set_debug_location(cx: &CrateContext,\n         }\n     };\n \n-    if builder.is_none() {\n-        debug_context(cx).current_debug_location.set(debug_location);\n-    }\n-\n-    let builder = builder.unwrap_or_else(|| cx.raw_builder());\n     unsafe {\n-        llvm::LLVMSetCurrentDebugLocation(builder, metadata_node);\n+        llvm::LLVMSetCurrentDebugLocation(builder.llbuilder, metadata_node);\n     }\n }"}, {"sha": "3989dae553ffca928818fe265bd40b83702ac7f9", "filename": "src/librustc_trans/glue.rs", "status": "modified", "additions": 207, "deletions": 334, "changes": 541, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_trans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_trans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fglue.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "patch": "@@ -13,19 +13,19 @@\n // Code relating to drop glue.\n \n use std;\n+use std::iter;\n \n use llvm;\n use llvm::{ValueRef, get_param};\n-use middle::lang_items::ExchangeFreeFnLangItem;\n+use middle::lang_items::BoxFreeFnLangItem;\n use rustc::ty::subst::{Substs};\n use rustc::traits;\n-use rustc::ty::{self, AdtKind, Ty, TyCtxt, TypeFoldable};\n-use adt;\n+use rustc::ty::{self, AdtKind, Ty, TypeFoldable};\n+use rustc::ty::subst::Kind;\n+use adt::{self, MaybeSizedValue};\n use base::*;\n-use build::*;\n-use callee::{Callee};\n+use callee::Callee;\n use common::*;\n-use debuginfo::DebugLoc;\n use machine::*;\n use monomorphize;\n use trans_item::TransItem;\n@@ -34,69 +34,34 @@ use type_of::{type_of, sizing_type_of, align_of};\n use type_::Type;\n use value::Value;\n use Disr;\n+use cleanup::CleanupScope;\n \n-use arena::TypedArena;\n use syntax_pos::DUMMY_SP;\n \n-pub fn trans_exchange_free_dyn<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                           v: ValueRef,\n-                                           size: ValueRef,\n-                                           align: ValueRef,\n-                                           debug_loc: DebugLoc)\n-                                           -> Block<'blk, 'tcx> {\n-    let _icx = push_ctxt(\"trans_exchange_free\");\n-\n-    let def_id = langcall(bcx.tcx(), None, \"\", ExchangeFreeFnLangItem);\n-    let args = [PointerCast(bcx, v, Type::i8p(bcx.ccx())), size, align];\n-    Callee::def(bcx.ccx(), def_id, bcx.tcx().intern_substs(&[]))\n-        .call(bcx, debug_loc, &args, None).bcx\n-}\n+pub fn trans_exchange_free_ty<'a, 'tcx>(\n+    bcx: &BlockAndBuilder<'a, 'tcx>,\n+    ptr: MaybeSizedValue,\n+    content_ty: Ty<'tcx>\n+) {\n+    let def_id = langcall(bcx.tcx(), None, \"\", BoxFreeFnLangItem);\n+    let substs = bcx.tcx().mk_substs(iter::once(Kind::from(content_ty)));\n+    let callee = Callee::def(bcx.ccx, def_id, substs);\n \n-pub fn trans_exchange_free<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n-                                       v: ValueRef,\n-                                       size: u64,\n-                                       align: u32,\n-                                       debug_loc: DebugLoc)\n-                                       -> Block<'blk, 'tcx> {\n-    trans_exchange_free_dyn(cx,\n-                            v,\n-                            C_uint(cx.ccx(), size),\n-                            C_uint(cx.ccx(), align),\n-                            debug_loc)\n-}\n+    let fn_ty = callee.direct_fn_type(bcx.ccx, &[]);\n \n-pub fn trans_exchange_free_ty<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                          ptr: ValueRef,\n-                                          content_ty: Ty<'tcx>,\n-                                          debug_loc: DebugLoc)\n-                                          -> Block<'blk, 'tcx> {\n-    assert!(type_is_sized(bcx.ccx().tcx(), content_ty));\n-    let sizing_type = sizing_type_of(bcx.ccx(), content_ty);\n-    let content_size = llsize_of_alloc(bcx.ccx(), sizing_type);\n-\n-    // `Box<ZeroSizeType>` does not allocate.\n-    if content_size != 0 {\n-        let content_align = align_of(bcx.ccx(), content_ty);\n-        trans_exchange_free(bcx, ptr, content_size, content_align, debug_loc)\n-    } else {\n-        bcx\n-    }\n+    let llret = bcx.call(callee.reify(bcx.ccx),\n+        &[ptr.value, ptr.meta][..1 + ptr.has_meta() as usize], None);\n+    fn_ty.apply_attrs_callsite(llret);\n }\n \n-pub fn type_needs_drop<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                 ty: Ty<'tcx>) -> bool {\n-    tcx.type_needs_drop_given_env(ty, &tcx.empty_parameter_environment())\n-}\n-\n-pub fn get_drop_glue_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                    t: Ty<'tcx>) -> Ty<'tcx> {\n+pub fn get_drop_glue_type<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Ty<'tcx> {\n     assert!(t.is_normalized_for_trans());\n \n-    let t = tcx.erase_regions(&t);\n+    let t = scx.tcx().erase_regions(&t);\n \n     // Even if there is no dtor for t, there might be one deeper down and we\n     // might need to pass in the vtable ptr.\n-    if !type_is_sized(tcx, t) {\n+    if !scx.type_is_sized(t) {\n         return t;\n     }\n \n@@ -109,17 +74,16 @@ pub fn get_drop_glue_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // returned `tcx.types.i8` does not appear unsound. The impact on\n     // code quality is unknown at this time.)\n \n-    if !type_needs_drop(tcx, t) {\n-        return tcx.types.i8;\n+    if !scx.type_needs_drop(t) {\n+        return scx.tcx().types.i8;\n     }\n     match t.sty {\n-        ty::TyBox(typ) if !type_needs_drop(tcx, typ)\n-                         && type_is_sized(tcx, typ) => {\n-            tcx.infer_ctxt(None, None, traits::Reveal::All).enter(|infcx| {\n+        ty::TyBox(typ) if !scx.type_needs_drop(typ) && scx.type_is_sized(typ) => {\n+            scx.tcx().infer_ctxt(None, None, traits::Reveal::All).enter(|infcx| {\n                 let layout = t.layout(&infcx).unwrap();\n-                if layout.size(&tcx.data_layout).bytes() == 0 {\n+                if layout.size(&scx.tcx().data_layout).bytes() == 0 {\n                     // `Box<ZeroSizeType>` does not allocate.\n-                    tcx.types.i8\n+                    scx.tcx().types.i8\n                 } else {\n                     t\n                 }\n@@ -129,56 +93,36 @@ pub fn get_drop_glue_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n }\n \n-pub fn drop_ty<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                           v: ValueRef,\n-                           t: Ty<'tcx>,\n-                           debug_loc: DebugLoc) -> Block<'blk, 'tcx> {\n-    drop_ty_core(bcx, v, t, debug_loc, false)\n+fn drop_ty<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>, args: MaybeSizedValue, t: Ty<'tcx>) {\n+    call_drop_glue(bcx, args, t, false, None)\n }\n \n-pub fn drop_ty_core<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                v: ValueRef,\n-                                t: Ty<'tcx>,\n-                                debug_loc: DebugLoc,\n-                                skip_dtor: bool)\n-                                -> Block<'blk, 'tcx> {\n+pub fn call_drop_glue<'a, 'tcx>(\n+    bcx: &BlockAndBuilder<'a, 'tcx>,\n+    mut args: MaybeSizedValue,\n+    t: Ty<'tcx>,\n+    skip_dtor: bool,\n+    funclet: Option<&'a Funclet>,\n+) {\n     // NB: v is an *alias* of type t here, not a direct value.\n-    debug!(\"drop_ty_core(t={:?}, skip_dtor={})\", t, skip_dtor);\n-    let _icx = push_ctxt(\"drop_ty\");\n-    if bcx.fcx.type_needs_drop(t) {\n-        let ccx = bcx.ccx();\n+    debug!(\"call_drop_glue(t={:?}, skip_dtor={})\", t, skip_dtor);\n+    if bcx.ccx.shared().type_needs_drop(t) {\n+        let ccx = bcx.ccx;\n         let g = if skip_dtor {\n             DropGlueKind::TyContents(t)\n         } else {\n             DropGlueKind::Ty(t)\n         };\n         let glue = get_drop_glue_core(ccx, g);\n-        let glue_type = get_drop_glue_type(ccx.tcx(), t);\n-        let ptr = if glue_type != t {\n-            PointerCast(bcx, v, type_of(ccx, glue_type).ptr_to())\n-        } else {\n-            v\n-        };\n+        let glue_type = get_drop_glue_type(ccx.shared(), t);\n+        if glue_type != t {\n+            args.value = bcx.pointercast(args.value, type_of(ccx, glue_type).ptr_to());\n+        }\n \n         // No drop-hint ==> call standard drop glue\n-        Call(bcx, glue, &[ptr], debug_loc);\n+        bcx.call(glue, &[args.value, args.meta][..1 + args.has_meta() as usize],\n+            funclet.map(|b| b.bundle()));\n     }\n-    bcx\n-}\n-\n-pub fn drop_ty_immediate<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                     v: ValueRef,\n-                                     t: Ty<'tcx>,\n-                                     debug_loc: DebugLoc,\n-                                     skip_dtor: bool)\n-                                     -> Block<'blk, 'tcx> {\n-    let _icx = push_ctxt(\"drop_ty_immediate\");\n-    let vp = alloc_ty(bcx, t, \"\");\n-    call_lifetime_start(bcx, vp);\n-    store_ty(bcx, v, vp, t);\n-    let bcx = drop_ty_core(bcx, vp, t, debug_loc, skip_dtor);\n-    call_lifetime_end(bcx, vp);\n-    bcx\n }\n \n pub fn get_drop_glue<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> ValueRef {\n@@ -212,9 +156,8 @@ impl<'tcx> DropGlueKind<'tcx> {\n     }\n }\n \n-fn get_drop_glue_core<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                g: DropGlueKind<'tcx>) -> ValueRef {\n-    let g = g.map_ty(|t| get_drop_glue_type(ccx.tcx(), t));\n+fn get_drop_glue_core<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, g: DropGlueKind<'tcx>) -> ValueRef {\n+    let g = g.map_ty(|t| get_drop_glue_type(ccx.shared(), t));\n     match ccx.drop_glues().borrow().get(&g) {\n         Some(&(glue, _)) => glue,\n         None => {\n@@ -226,17 +169,12 @@ fn get_drop_glue_core<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     }\n }\n \n-pub fn implement_drop_glue<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                     g: DropGlueKind<'tcx>) {\n-    let tcx = ccx.tcx();\n-    assert_eq!(g.ty(), get_drop_glue_type(tcx, g.ty()));\n-    let (llfn, fn_ty) = ccx.drop_glues().borrow().get(&g).unwrap().clone();\n-\n-    let (arena, fcx): (TypedArena<_>, FunctionContext);\n-    arena = TypedArena::new();\n-    fcx = FunctionContext::new(ccx, llfn, fn_ty, None, &arena);\n+pub fn implement_drop_glue<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, g: DropGlueKind<'tcx>) {\n+    assert_eq!(g.ty(), get_drop_glue_type(ccx.shared(), g.ty()));\n+    let (llfn, _) = ccx.drop_glues().borrow().get(&g).unwrap().clone();\n \n-    let bcx = fcx.init(false);\n+    let fcx = FunctionContext::new(ccx, llfn);\n+    let mut bcx = fcx.get_entry_block();\n \n     ccx.stats().n_glues_created.set(ccx.stats().n_glues_created.get() + 1);\n     // All glue functions take values passed *by alias*; this is a\n@@ -247,86 +185,127 @@ pub fn implement_drop_glue<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     // llfn is expected be declared to take a parameter of the appropriate\n     // type, so we don't need to explicitly cast the function parameter.\n \n-    let bcx = make_drop_glue(bcx, get_param(llfn, 0), g);\n-    fcx.finish(bcx, DebugLoc::None);\n-}\n-\n-fn trans_custom_dtor<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                 t: Ty<'tcx>,\n-                                 v0: ValueRef,\n-                                 shallow_drop: bool)\n-                                 -> Block<'blk, 'tcx>\n-{\n-    debug!(\"trans_custom_dtor t: {}\", t);\n-    let tcx = bcx.tcx();\n-    let mut bcx = bcx;\n-\n-    let def = t.ty_adt_def().unwrap();\n-\n-    // Be sure to put the contents into a scope so we can use an invoke\n-    // instruction to call the user destructor but still call the field\n-    // destructors if the user destructor panics.\n-    //\n-    // FIXME (#14875) panic-in-drop semantics might be unsupported; we\n-    // might well consider changing below to more direct code.\n-    let contents_scope = bcx.fcx.push_custom_cleanup_scope();\n-\n-    // Issue #23611: schedule cleanup of contents, re-inspecting the\n-    // discriminant (if any) in case of variant swap in drop code.\n-    if !shallow_drop {\n-        bcx.fcx.schedule_drop_adt_contents(contents_scope, v0, t);\n-    }\n+    // NB: v0 is an *alias* of type t here, not a direct value.\n+    // Only drop the value when it ... well, we used to check for\n+    // non-null, (and maybe we need to continue doing so), but we now\n+    // must definitely check for special bit-patterns corresponding to\n+    // the special dtor markings.\n+    let t = g.ty();\n \n-    let (sized_args, unsized_args);\n-    let args: &[ValueRef] = if type_is_sized(tcx, t) {\n-        sized_args = [v0];\n-        &sized_args\n+    let value = get_param(llfn, 0);\n+    let ptr = if ccx.shared().type_is_sized(t) {\n+        MaybeSizedValue::sized(value)\n     } else {\n-        // FIXME(#36457) -- we should pass unsized values to drop glue as two arguments\n-        unsized_args = [\n-            Load(bcx, get_dataptr(bcx, v0)),\n-            Load(bcx, get_meta(bcx, v0))\n-        ];\n-        &unsized_args\n+        MaybeSizedValue::unsized_(value, get_param(llfn, 1))\n     };\n \n-    let trait_ref = ty::Binder(ty::TraitRef {\n-        def_id: tcx.lang_items.drop_trait().unwrap(),\n-        substs: tcx.mk_substs_trait(t, &[])\n-    });\n-    let vtbl = match fulfill_obligation(bcx.ccx().shared(), DUMMY_SP, trait_ref) {\n-        traits::VtableImpl(data) => data,\n-        _ => bug!(\"dtor for {:?} is not an impl???\", t)\n+    let skip_dtor = match g {\n+        DropGlueKind::Ty(_) => false,\n+        DropGlueKind::TyContents(_) => true\n     };\n-    let dtor_did = def.destructor().unwrap();\n-    bcx = Callee::def(bcx.ccx(), dtor_did, vtbl.substs)\n-        .call(bcx, DebugLoc::None, args, None).bcx;\n \n-    bcx.fcx.pop_and_trans_custom_cleanup_scope(bcx, contents_scope)\n+    let bcx = match t.sty {\n+        ty::TyBox(content_ty) => {\n+            // Support for TyBox is built-in and its drop glue is\n+            // special. It may move to library and have Drop impl. As\n+            // a safe-guard, assert TyBox not used with TyContents.\n+            assert!(!skip_dtor);\n+            let ptr = if !bcx.ccx.shared().type_is_sized(content_ty) {\n+                let llbox = bcx.load(get_dataptr(&bcx, ptr.value));\n+                let info = bcx.load(get_meta(&bcx, ptr.value));\n+                MaybeSizedValue::unsized_(llbox, info)\n+            } else {\n+                MaybeSizedValue::sized(bcx.load(ptr.value))\n+            };\n+            drop_ty(&bcx, ptr, content_ty);\n+            trans_exchange_free_ty(&bcx, ptr, content_ty);\n+            bcx\n+        }\n+        ty::TyDynamic(..) => {\n+            // No support in vtable for distinguishing destroying with\n+            // versus without calling Drop::drop. Assert caller is\n+            // okay with always calling the Drop impl, if any.\n+            assert!(!skip_dtor);\n+            let dtor = bcx.load(ptr.meta);\n+            bcx.call(dtor, &[ptr.value], None);\n+            bcx\n+        }\n+        ty::TyAdt(def, ..) if def.dtor_kind().is_present() && !skip_dtor => {\n+            let shallow_drop = def.is_union();\n+            let tcx = bcx.tcx();\n+\n+            let def = t.ty_adt_def().unwrap();\n+\n+            // Be sure to put the contents into a scope so we can use an invoke\n+            // instruction to call the user destructor but still call the field\n+            // destructors if the user destructor panics.\n+            //\n+            // FIXME (#14875) panic-in-drop semantics might be unsupported; we\n+            // might well consider changing below to more direct code.\n+            // Issue #23611: schedule cleanup of contents, re-inspecting the\n+            // discriminant (if any) in case of variant swap in drop code.\n+            let contents_scope = if !shallow_drop {\n+                bcx.fcx().schedule_drop_adt_contents(ptr, t)\n+            } else {\n+                CleanupScope::noop()\n+            };\n+\n+            let trait_ref = ty::Binder(ty::TraitRef {\n+                def_id: tcx.lang_items.drop_trait().unwrap(),\n+                substs: tcx.mk_substs_trait(t, &[])\n+            });\n+            let vtbl = match fulfill_obligation(bcx.ccx.shared(), DUMMY_SP, trait_ref) {\n+                traits::VtableImpl(data) => data,\n+                _ => bug!(\"dtor for {:?} is not an impl???\", t)\n+            };\n+            let dtor_did = def.destructor().unwrap();\n+            let callee = Callee::def(bcx.ccx, dtor_did, vtbl.substs);\n+            let fn_ty = callee.direct_fn_type(bcx.ccx, &[]);\n+            let llret;\n+            let args = &[ptr.value, ptr.meta][..1 + ptr.has_meta() as usize];\n+            if let Some(landing_pad) = contents_scope.landing_pad {\n+                let normal_bcx = bcx.fcx().build_new_block(\"normal-return\");\n+                llret = bcx.invoke(callee.reify(ccx), args, normal_bcx.llbb(), landing_pad, None);\n+                bcx = normal_bcx;\n+            } else {\n+                llret = bcx.call(callee.reify(bcx.ccx), args, None);\n+            }\n+            fn_ty.apply_attrs_callsite(llret);\n+            contents_scope.trans(&bcx);\n+            bcx\n+        }\n+        ty::TyAdt(def, ..) if def.is_union() => {\n+            bcx\n+        }\n+        _ => {\n+            if bcx.ccx.shared().type_needs_drop(t) {\n+                drop_structural_ty(bcx, ptr, t)\n+            } else {\n+                bcx\n+            }\n+        }\n+    };\n+    bcx.ret_void();\n }\n \n-pub fn size_and_align_of_dst<'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>,\n-                                         t: Ty<'tcx>, info: ValueRef)\n-                                         -> (ValueRef, ValueRef) {\n+pub fn size_and_align_of_dst<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n+                                       t: Ty<'tcx>, info: ValueRef)\n+                                       -> (ValueRef, ValueRef) {\n     debug!(\"calculate size of DST: {}; with lost info: {:?}\",\n            t, Value(info));\n-    if type_is_sized(bcx.tcx(), t) {\n-        let sizing_type = sizing_type_of(bcx.ccx(), t);\n-        let size = llsize_of_alloc(bcx.ccx(), sizing_type);\n-        let align = align_of(bcx.ccx(), t);\n+    if bcx.ccx.shared().type_is_sized(t) {\n+        let sizing_type = sizing_type_of(bcx.ccx, t);\n+        let size = llsize_of_alloc(bcx.ccx, sizing_type);\n+        let align = align_of(bcx.ccx, t);\n         debug!(\"size_and_align_of_dst t={} info={:?} size: {} align: {}\",\n                t, Value(info), size, align);\n-        let size = C_uint(bcx.ccx(), size);\n-        let align = C_uint(bcx.ccx(), align);\n+        let size = C_uint(bcx.ccx, size);\n+        let align = C_uint(bcx.ccx, align);\n         return (size, align);\n     }\n-    if bcx.is_unreachable() {\n-        let llty = Type::int(bcx.ccx());\n-        return (C_undef(llty), C_undef(llty));\n-    }\n     match t.sty {\n         ty::TyAdt(def, substs) => {\n-            let ccx = bcx.ccx();\n+            let ccx = bcx.ccx;\n             // First get the size of all statically known fields.\n             // Don't use type_of::sizing_type_of because that expects t to be sized,\n             // and it also rounds up to alignment, which we want to avoid,\n@@ -389,15 +368,15 @@ pub fn size_and_align_of_dst<'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>,\n             //\n             //   `(size + (align-1)) & -align`\n \n-            let addend = bcx.sub(align, C_uint(bcx.ccx(), 1_u64));\n+            let addend = bcx.sub(align, C_uint(bcx.ccx, 1_u64));\n             let size = bcx.and(bcx.add(size, addend), bcx.neg(align));\n \n             (size, align)\n         }\n         ty::TyDynamic(..) => {\n             // info points to the vtable and the second entry in the vtable is the\n             // dynamic size of the object.\n-            let info = bcx.pointercast(info, Type::int(bcx.ccx()).ptr_to());\n+            let info = bcx.pointercast(info, Type::int(bcx.ccx).ptr_to());\n             let size_ptr = bcx.gepi(info, &[1]);\n             let align_ptr = bcx.gepi(info, &[2]);\n             (bcx.load(size_ptr), bcx.load(align_ptr))\n@@ -406,194 +385,92 @@ pub fn size_and_align_of_dst<'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>,\n             let unit_ty = t.sequence_element_type(bcx.tcx());\n             // The info in this case is the length of the str, so the size is that\n             // times the unit size.\n-            let llunit_ty = sizing_type_of(bcx.ccx(), unit_ty);\n-            let unit_align = llalign_of_min(bcx.ccx(), llunit_ty);\n-            let unit_size = llsize_of_alloc(bcx.ccx(), llunit_ty);\n-            (bcx.mul(info, C_uint(bcx.ccx(), unit_size)),\n-             C_uint(bcx.ccx(), unit_align))\n+            let llunit_ty = sizing_type_of(bcx.ccx, unit_ty);\n+            let unit_align = llalign_of_min(bcx.ccx, llunit_ty);\n+            let unit_size = llsize_of_alloc(bcx.ccx, llunit_ty);\n+            (bcx.mul(info, C_uint(bcx.ccx, unit_size)),\n+             C_uint(bcx.ccx, unit_align))\n         }\n         _ => bug!(\"Unexpected unsized type, found {}\", t)\n     }\n }\n \n-fn make_drop_glue<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                              v0: ValueRef,\n-                              g: DropGlueKind<'tcx>)\n-                              -> Block<'blk, 'tcx> {\n-    let t = g.ty();\n-\n-    let skip_dtor = match g { DropGlueKind::Ty(_) => false, DropGlueKind::TyContents(_) => true };\n-    // NB: v0 is an *alias* of type t here, not a direct value.\n-    let _icx = push_ctxt(\"make_drop_glue\");\n-\n-    // Only drop the value when it ... well, we used to check for\n-    // non-null, (and maybe we need to continue doing so), but we now\n-    // must definitely check for special bit-patterns corresponding to\n-    // the special dtor markings.\n-\n-    match t.sty {\n-        ty::TyBox(content_ty) => {\n-            // Support for TyBox is built-in and its drop glue is\n-            // special. It may move to library and have Drop impl. As\n-            // a safe-guard, assert TyBox not used with TyContents.\n-            assert!(!skip_dtor);\n-            if !type_is_sized(bcx.tcx(), content_ty) {\n-                let llval = get_dataptr(bcx, v0);\n-                let llbox = Load(bcx, llval);\n-                let bcx = drop_ty(bcx, v0, content_ty, DebugLoc::None);\n-                // FIXME(#36457) -- we should pass unsized values to drop glue as two arguments\n-                let info = get_meta(bcx, v0);\n-                let info = Load(bcx, info);\n-                let (llsize, llalign) =\n-                    size_and_align_of_dst(&bcx.build(), content_ty, info);\n-\n-                // `Box<ZeroSizeType>` does not allocate.\n-                let needs_free = ICmp(bcx,\n-                                        llvm::IntNE,\n-                                        llsize,\n-                                        C_uint(bcx.ccx(), 0u64),\n-                                        DebugLoc::None);\n-                with_cond(bcx, needs_free, |bcx| {\n-                    trans_exchange_free_dyn(bcx, llbox, llsize, llalign, DebugLoc::None)\n-                })\n-            } else {\n-                let llval = v0;\n-                let llbox = Load(bcx, llval);\n-                let bcx = drop_ty(bcx, llbox, content_ty, DebugLoc::None);\n-                trans_exchange_free_ty(bcx, llbox, content_ty, DebugLoc::None)\n-            }\n-        }\n-        ty::TyDynamic(..) => {\n-            // No support in vtable for distinguishing destroying with\n-            // versus without calling Drop::drop. Assert caller is\n-            // okay with always calling the Drop impl, if any.\n-            // FIXME(#36457) -- we should pass unsized values to drop glue as two arguments\n-            assert!(!skip_dtor);\n-            let data_ptr = get_dataptr(bcx, v0);\n-            let vtable_ptr = Load(bcx, get_meta(bcx, v0));\n-            let dtor = Load(bcx, vtable_ptr);\n-            Call(bcx,\n-                 dtor,\n-                 &[PointerCast(bcx, Load(bcx, data_ptr), Type::i8p(bcx.ccx()))],\n-                 DebugLoc::None);\n-            bcx\n-        }\n-        ty::TyAdt(def, ..) if def.dtor_kind().is_present() && !skip_dtor => {\n-            trans_custom_dtor(bcx, t, v0, def.is_union())\n-        }\n-        ty::TyAdt(def, ..) if def.is_union() => {\n-            bcx\n-        }\n-        _ => {\n-            if bcx.fcx.type_needs_drop(t) {\n-                drop_structural_ty(bcx, v0, t)\n-            } else {\n-                bcx\n-            }\n-        }\n-    }\n-}\n-\n // Iterates through the elements of a structural type, dropping them.\n-fn drop_structural_ty<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n-                                  av: ValueRef,\n-                                  t: Ty<'tcx>)\n-                                  -> Block<'blk, 'tcx> {\n-    let _icx = push_ctxt(\"drop_structural_ty\");\n-\n-    fn iter_variant<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n-                                t: Ty<'tcx>,\n-                                av: adt::MaybeSizedValue,\n-                                variant: &'tcx ty::VariantDef,\n-                                substs: &Substs<'tcx>)\n-                                -> Block<'blk, 'tcx> {\n-        let _icx = push_ctxt(\"iter_variant\");\n+fn drop_structural_ty<'a, 'tcx>(cx: BlockAndBuilder<'a, 'tcx>,\n+                                ptr: MaybeSizedValue,\n+                                t: Ty<'tcx>)\n+                                -> BlockAndBuilder<'a, 'tcx> {\n+    fn iter_variant<'a, 'tcx>(cx: &BlockAndBuilder<'a, 'tcx>,\n+                              t: Ty<'tcx>,\n+                              av: adt::MaybeSizedValue,\n+                              variant: &'tcx ty::VariantDef,\n+                              substs: &Substs<'tcx>) {\n         let tcx = cx.tcx();\n-        let mut cx = cx;\n-\n         for (i, field) in variant.fields.iter().enumerate() {\n             let arg = monomorphize::field_ty(tcx, substs, field);\n-            cx = drop_ty(cx,\n-                         adt::trans_field_ptr(cx, t, av, Disr::from(variant.disr_val), i),\n-                         arg, DebugLoc::None);\n+            let field_ptr = adt::trans_field_ptr(&cx, t, av, Disr::from(variant.disr_val), i);\n+            drop_ty(&cx, MaybeSizedValue::sized(field_ptr), arg);\n         }\n-        return cx;\n     }\n \n-    let value = if type_is_sized(cx.tcx(), t) {\n-        adt::MaybeSizedValue::sized(av)\n-    } else {\n-        // FIXME(#36457) -- we should pass unsized values as two arguments\n-        let data = Load(cx, get_dataptr(cx, av));\n-        let info = Load(cx, get_meta(cx, av));\n-        adt::MaybeSizedValue::unsized_(data, info)\n-    };\n-\n     let mut cx = cx;\n     match t.sty {\n         ty::TyClosure(def_id, substs) => {\n             for (i, upvar_ty) in substs.upvar_tys(def_id, cx.tcx()).enumerate() {\n-                let llupvar = adt::trans_field_ptr(cx, t, value, Disr(0), i);\n-                cx = drop_ty(cx, llupvar, upvar_ty, DebugLoc::None);\n+                let llupvar = adt::trans_field_ptr(&cx, t, ptr, Disr(0), i);\n+                drop_ty(&cx, MaybeSizedValue::sized(llupvar), upvar_ty);\n             }\n         }\n         ty::TyArray(_, n) => {\n-            let base = get_dataptr(cx, value.value);\n-            let len = C_uint(cx.ccx(), n);\n+            let base = get_dataptr(&cx, ptr.value);\n+            let len = C_uint(cx.ccx, n);\n             let unit_ty = t.sequence_element_type(cx.tcx());\n-            cx = tvec::slice_for_each(cx, base, unit_ty, len,\n-                |bb, vv| drop_ty(bb, vv, unit_ty, DebugLoc::None));\n+            cx = tvec::slice_for_each(&cx, base, unit_ty, len,\n+                |bb, vv| drop_ty(bb, MaybeSizedValue::sized(vv), unit_ty));\n         }\n         ty::TySlice(_) | ty::TyStr => {\n             let unit_ty = t.sequence_element_type(cx.tcx());\n-            cx = tvec::slice_for_each(cx, value.value, unit_ty, value.meta,\n-                |bb, vv| drop_ty(bb, vv, unit_ty, DebugLoc::None));\n+            cx = tvec::slice_for_each(&cx, ptr.value, unit_ty, ptr.meta,\n+                |bb, vv| drop_ty(bb, MaybeSizedValue::sized(vv), unit_ty));\n         }\n         ty::TyTuple(ref args) => {\n             for (i, arg) in args.iter().enumerate() {\n-                let llfld_a = adt::trans_field_ptr(cx, t, value, Disr(0), i);\n-                cx = drop_ty(cx, llfld_a, *arg, DebugLoc::None);\n+                let llfld_a = adt::trans_field_ptr(&cx, t, ptr, Disr(0), i);\n+                drop_ty(&cx, MaybeSizedValue::sized(llfld_a), *arg);\n             }\n         }\n         ty::TyAdt(adt, substs) => match adt.adt_kind() {\n             AdtKind::Struct => {\n                 let VariantInfo { fields, discr } = VariantInfo::from_ty(cx.tcx(), t, None);\n                 for (i, &Field(_, field_ty)) in fields.iter().enumerate() {\n-                    let llfld_a = adt::trans_field_ptr(cx, t, value, Disr::from(discr), i);\n-\n-                    let val = if type_is_sized(cx.tcx(), field_ty) {\n-                        llfld_a\n+                    let llfld_a = adt::trans_field_ptr(&cx, t, ptr, Disr::from(discr), i);\n+                    let ptr = if cx.ccx.shared().type_is_sized(field_ty) {\n+                        MaybeSizedValue::sized(llfld_a)\n                     } else {\n-                        // FIXME(#36457) -- we should pass unsized values as two arguments\n-                        let scratch = alloc_ty(cx, field_ty, \"__fat_ptr_iter\");\n-                        Store(cx, llfld_a, get_dataptr(cx, scratch));\n-                        Store(cx, value.meta, get_meta(cx, scratch));\n-                        scratch\n+                        MaybeSizedValue::unsized_(llfld_a, ptr.meta)\n                     };\n-                    cx = drop_ty(cx, val, field_ty, DebugLoc::None);\n+                    drop_ty(&cx, ptr, field_ty);\n                 }\n             }\n             AdtKind::Union => {\n                 bug!(\"Union in `glue::drop_structural_ty`\");\n             }\n             AdtKind::Enum => {\n-                let fcx = cx.fcx;\n-                let ccx = fcx.ccx;\n                 let n_variants = adt.variants.len();\n \n                 // NB: we must hit the discriminant first so that structural\n                 // comparison know not to proceed when the discriminants differ.\n \n-                match adt::trans_switch(cx, t, av, false) {\n+                match adt::trans_switch(&cx, t, ptr.value, false) {\n                     (adt::BranchKind::Single, None) => {\n                         if n_variants != 0 {\n                             assert!(n_variants == 1);\n-                            cx = iter_variant(cx, t, adt::MaybeSizedValue::sized(av),\n-                                            &adt.variants[0], substs);\n+                            iter_variant(&cx, t, ptr, &adt.variants[0], substs);\n                         }\n                     }\n                     (adt::BranchKind::Switch, Some(lldiscrim_a)) => {\n-                        cx = drop_ty(cx, lldiscrim_a, cx.tcx().types.isize, DebugLoc::None);\n+                        let tcx = cx.tcx();\n+                        drop_ty(&cx, MaybeSizedValue::sized(lldiscrim_a), tcx.types.isize);\n \n                         // Create a fall-through basic block for the \"else\" case of\n                         // the switch instruction we're about to generate. Note that\n@@ -608,27 +485,23 @@ fn drop_structural_ty<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n                         // from the outer function, and any other use case will only\n                         // call this for an already-valid enum in which case the `ret\n                         // void` will never be hit.\n-                        let ret_void_cx = fcx.new_block(\"enum-iter-ret-void\");\n-                        RetVoid(ret_void_cx, DebugLoc::None);\n-                        let llswitch = Switch(cx, lldiscrim_a, ret_void_cx.llbb, n_variants);\n-                        let next_cx = fcx.new_block(\"enum-iter-next\");\n+                        let ret_void_cx = cx.fcx().build_new_block(\"enum-iter-ret-void\");\n+                        ret_void_cx.ret_void();\n+                        let llswitch = cx.switch(lldiscrim_a, ret_void_cx.llbb(), n_variants);\n+                        let next_cx = cx.fcx().build_new_block(\"enum-iter-next\");\n \n                         for variant in &adt.variants {\n-                            let variant_cx = fcx.new_block(&format!(\"enum-iter-variant-{}\",\n-                                                                        &variant.disr_val\n-                                                                                .to_string()));\n-                            let case_val = adt::trans_case(cx, t, Disr::from(variant.disr_val));\n-                            AddCase(llswitch, case_val, variant_cx.llbb);\n-                            let variant_cx = iter_variant(variant_cx,\n-                                                        t,\n-                                                        value,\n-                                                        variant,\n-                                                        substs);\n-                            Br(variant_cx, next_cx.llbb, DebugLoc::None);\n+                            let variant_cx_name = format!(\"enum-iter-variant-{}\",\n+                                &variant.disr_val.to_string());\n+                            let variant_cx = cx.fcx().build_new_block(&variant_cx_name);\n+                            let case_val = adt::trans_case(&cx, t, Disr::from(variant.disr_val));\n+                            variant_cx.add_case(llswitch, case_val, variant_cx.llbb());\n+                            iter_variant(&variant_cx, t, ptr, variant, substs);\n+                            variant_cx.br(next_cx.llbb());\n                         }\n                         cx = next_cx;\n                     }\n-                    _ => ccx.sess().unimpl(\"value from adt::trans_switch in drop_structural_ty\"),\n+                    _ => cx.ccx.sess().unimpl(\"value from adt::trans_switch in drop_structural_ty\"),\n                 }\n             }\n         },"}, {"sha": "b7116ba1f338baadec8f4abebeabe3e0ea588945", "filename": "src/librustc_trans/intrinsic.rs", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_trans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_trans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fintrinsic.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445"}, {"sha": "3a8eef131a2966eadbeb1495eda542c3bcfd3aa3", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445"}, {"sha": "cf50e7be2afb5c1692b3532ec84b0f33d5d1f3ae", "filename": "src/librustc_trans/meth.rs", "status": "modified", "additions": 37, "deletions": 32, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_trans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_trans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmeth.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445"}, {"sha": "8df24da7135887e4ecdea99dfcf1467ce2d7bc5b", "filename": "src/librustc_trans/mir/analyze.rs", "status": "modified", "additions": 27, "deletions": 35, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445"}, {"sha": "71ac7c0d252048ce818eabb0708251b05c073f72", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 167, "deletions": 194, "changes": 361, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445"}, {"sha": "08f68f8d49c78a8465ff7c5ec56d239a10e0b729", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 18, "deletions": 19, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445"}, {"sha": "0cd7f007c5df92dda45b67fee48d100b808ac524", "filename": "src/librustc_trans/mir/lvalue.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Flvalue.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445"}, {"sha": "7a50e5cbe8c79a4d8bef09bd7fc76e718e8e4321", "filename": "src/librustc_trans/mir/mod.rs", "status": "modified", "additions": 170, "deletions": 133, "changes": 303, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fmod.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445"}, {"sha": "a15d51d9da64dcc2850bb2d03bcd87950f06df0a", "filename": "src/librustc_trans/mir/operand.rs", "status": "modified", "additions": 30, "deletions": 40, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Foperand.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445"}, {"sha": "b17550087edf77c837870561b2f5dba8c0d333e2", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 106, "deletions": 136, "changes": 242, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445"}, {"sha": "cc85f68c197ec34551df74a1742b7d171ddf5bc5", "filename": "src/librustc_trans/mir/statement.rs", "status": "modified", "additions": 15, "deletions": 20, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_trans%2Fmir%2Fstatement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_trans%2Fmir%2Fstatement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fstatement.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445"}, {"sha": "6e0d8d08e70421152238c4f8f078733a391f755d", "filename": "src/librustc_trans/trans_item.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_trans%2Ftrans_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_trans%2Ftrans_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans_item.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445"}, {"sha": "c09726fda081028c6d48b71d8f9cdecdcf6ad624", "filename": "src/librustc_trans/tvec.rs", "status": "modified", "additions": 24, "deletions": 34, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_trans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_trans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftvec.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445"}, {"sha": "469214b466e1ae7b9c3ffeffaa5857703b4c63b2", "filename": "src/librustc_trans/type_of.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_trans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_trans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftype_of.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445"}, {"sha": "287ad87caacf94e6398c9e6bc8e1ebd9abb063e7", "filename": "src/librustc_trans/value.rs", "status": "modified", "additions": 1, "deletions": 155, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_trans%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_trans%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fvalue.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445"}, {"sha": "598003a3925127607c4347cf77c4e177ad4beb4e", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445"}, {"sha": "ff50ee11b390e674a703b9cdd9837a22676da5af", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445"}, {"sha": "b4647df3f4f0a6bed7b874084131c44b06379522", "filename": "src/librustc_typeck/check/autoderef.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445"}, {"sha": "265dcada1f810651a76401793644cfb0d17c1261", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445"}, {"sha": "393d9341a08432151876eb73941c90d3e5d50964", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 67, "deletions": 4, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445"}, {"sha": "9b8e77301e52480f5cb19576ffaaf51a44dec640", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445"}, {"sha": "1962534c397166d00861acf6c47ddb9f8095b89a", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 201, "deletions": 84, "changes": 285, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445"}, {"sha": "a2dceed8d2653f4c74261db5714e963d2dfabd54", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445"}, {"sha": "0e5a16987c12e408e9315cadd82ca3848872ae16", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445"}, {"sha": "cea3ad43a95b84624b670df1f4e1f498ad2c7496", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 3, "deletions": 21, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445"}, {"sha": "ec17813ed2a521fb479a0e012d1546890c31af33", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445"}, {"sha": "fdbd2f3647c0c482c787d2c82322567a48b593be", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 11, "deletions": 18, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445"}, {"sha": "31e10fbd3b7d3e16ca57628798caceba41d79661", "filename": "src/librustdoc/doctree.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustdoc%2Fdoctree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustdoc%2Fdoctree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctree.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445"}, {"sha": "796a3a93068c8a5d8886a39b83057594ffdce949", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445"}, {"sha": "06a816412969bfc7eff9475db1fa481cf7688aff", "filename": "src/librustdoc/html/layout.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Flayout.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445"}, {"sha": "1d7fb2cd238870819a06b28b1c1cc45796c53e5d", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 20, "deletions": 8, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445"}, {"sha": "c12e1e7d6080db8739e07db05e9744fd57aa745b", "filename": "src/librustdoc/html/static/main.js", "status": "modified", "additions": 5, "deletions": 16, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445"}, {"sha": "0ca4f7ea36f1be8cbdf78b7e9edca337174c4c10", "filename": "src/librustdoc/html/static/rustdoc.css", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445"}, {"sha": "862d6d12b9ad99f28489d34bdda597a430fb477e", "filename": "src/librustdoc/html/static/styles/main.css", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fstyles%2Fmain.css", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fstyles%2Fmain.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fstyles%2Fmain.css?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445"}, {"sha": "835825d31eec98f46e954707fdf3dea03a2e7ff1", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 23, "deletions": 8, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445"}, {"sha": "9dbc9d30e606b48851c59384b1d3ff93b5fc2bb9", "filename": "src/librustdoc/markdown.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustdoc%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustdoc%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445"}, {"sha": "c93112657b96db239e9b9528f53754f50108919e", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445"}, {"sha": "5b72c6d46aceb330b5a7c382e42e6b6a6123527a", "filename": "src/libserialize/leb128.rs", "status": "modified", "additions": 40, "deletions": 14, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibserialize%2Fleb128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibserialize%2Fleb128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fleb128.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445"}, {"sha": "f5e9ec6d89d0f62603bf0fc35700e6e2eb81847d", "filename": "src/libstd/ascii.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibstd%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibstd%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fascii.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445"}, {"sha": "5e1c3a2851568aef8c15caf46f19488375fa9893", "filename": "src/libstd/build.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibstd%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibstd%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbuild.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445"}, {"sha": "2fa3a9c4844b5502515f14ac07f6c14ee52e7bf8", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 81, "deletions": 2, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445"}, {"sha": "341b050862f5c455520c25d6496c7a264782fb0b", "filename": "src/libstd/collections/hash/set.rs", "status": "modified", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445"}, {"sha": "2cd9362a65791408f9ece6192f1857b7636e5b56", "filename": "src/libstd/collections/hash/table.rs", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445"}, {"sha": "0521f301321a736e08a5392dc1686e5913fb0abc", "filename": "src/libstd/env.rs", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibstd%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibstd%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fenv.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445"}, {"sha": "41934dc057e37eff774143b916e3924ade13a38a", "filename": "src/libstd/fs.rs", "status": "modified", "additions": 80, "deletions": 27, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibstd%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibstd%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffs.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445"}, {"sha": "c15a1c8328c03608a64344e0444201cab314dcda", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 86, "deletions": 13, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445"}, {"sha": "5450a10c9bd9f1111763c171d7781d7e55dc415f", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 22, "deletions": 3, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445"}, {"sha": "9d1c8942f8cf80605dab780459dcc69297786470", "filename": "src/libstd/io/stdio.rs", "status": "modified", "additions": 47, "deletions": 5, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibstd%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibstd%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fstdio.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445"}, {"sha": "436511031ef53f777e20eb09cd115ceca67f250a", "filename": "src/libstd/io/util.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibstd%2Fio%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibstd%2Fio%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Futil.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445"}, {"sha": "fc5c6968544e80d22d25b0a0d255ee331a15e86a", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445"}, {"sha": "6aab7486004f89e132c65e706a607760554ceed3", "filename": "src/libstd/net/ip.rs", "status": "modified", "additions": 27, "deletions": 1, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibstd%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibstd%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fip.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445"}, {"sha": "cadf87f32b14a6a93b58b7bbd1868cef0b9de794", "filename": "src/libstd/net/mod.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibstd%2Fnet%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibstd%2Fnet%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fmod.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445"}, {"sha": "63817c9f10f5fbb19892e61759b8e0f30f7858a5", "filename": "src/libstd/net/tcp.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibstd%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibstd%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Ftcp.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445"}, {"sha": "f8a5ec0b3791e87ab377330077d7c5fb9d11bad8", "filename": "src/libstd/net/udp.rs", "status": "modified", "additions": 58, "deletions": 1, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibstd%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibstd%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fudp.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445"}, {"sha": "7c9274d06016180e0bd7c1afab07e185984bd30c", "filename": "src/libstd/os/linux/raw.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibstd%2Fos%2Flinux%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibstd%2Fos%2Flinux%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Flinux%2Fraw.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445"}, {"sha": "e45af86705582e20647962a8a05c0580d70b8739", "filename": "src/libstd/os/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibstd%2Fos%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibstd%2Fos%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fmod.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445"}, {"sha": "cc154f7ab413b4341307d9eb127b91eb696f86f2", "filename": "src/libstd/os/raw.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibstd%2Fos%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibstd%2Fos%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fraw.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445"}, {"sha": "faf4949e86192e2d76ba2cc7199f9a6a7a67ead7", "filename": "src/libstd/panic.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibstd%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibstd%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpanic.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445"}, {"sha": "e5edea241e1990654e10d0113cc1dae57440363c", "filename": "src/libstd/panicking.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibstd%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibstd%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpanicking.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445"}, {"sha": "e15c37aaf24911ac6ade0258109aa5150b084350", "filename": "src/libstd/process.rs", "status": "modified", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibstd%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibstd%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprocess.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445"}, {"sha": "b853e83de5d6cb035b112da1a1fa1d2971db4add", "filename": "src/libstd/rand/mod.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibstd%2Frand%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibstd%2Frand%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fmod.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445"}, {"sha": "b8e83dced8d4b100bae84db8804628bb78bef740", "filename": "src/libstd/sync/barrier.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibstd%2Fsync%2Fbarrier.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibstd%2Fsync%2Fbarrier.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fbarrier.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445"}, {"sha": "8ab30c51b282eb601ffba3f3eefbe3f01847851d", "filename": "src/libstd/sync/condvar.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibstd%2Fsync%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibstd%2Fsync%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fcondvar.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445"}, {"sha": "aeeab170deafe9cfdd92324197a2bf14c74ffacd", "filename": "src/libstd/sync/mpsc/mod.rs", "status": "modified", "additions": 111, "deletions": 119, "changes": 230, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445"}, {"sha": "b8e50c9297b647c852eed8d5d4ed5e803c575047", "filename": "src/libstd/sync/mpsc/oneshot.rs", "status": "modified", "additions": 153, "deletions": 140, "changes": 293, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibstd%2Fsync%2Fmpsc%2Foneshot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibstd%2Fsync%2Fmpsc%2Foneshot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Foneshot.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445"}, {"sha": "f9e0290416432001d464d51e71d9a1d30cfc524b", "filename": "src/libstd/sync/mpsc/shared.rs", "status": "modified", "additions": 56, "deletions": 50, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibstd%2Fsync%2Fmpsc%2Fshared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibstd%2Fsync%2Fmpsc%2Fshared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fshared.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445"}, {"sha": "47cd8977fda23ced729085ce1339ca7c25b0ea6e", "filename": "src/libstd/sync/mpsc/stream.rs", "status": "modified", "additions": 34, "deletions": 31, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibstd%2Fsync%2Fmpsc%2Fstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibstd%2Fsync%2Fmpsc%2Fstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fstream.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445"}, {"sha": "f6dbe01d7bdbf05fab89719ccdf962370629ac4f", "filename": "src/libstd/sync/mutex.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibstd%2Fsync%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibstd%2Fsync%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmutex.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445"}, {"sha": "a9747639aacd797381e8df74d4eb2b44ecbf13a4", "filename": "src/libstd/sync/once.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibstd%2Fsync%2Fonce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibstd%2Fsync%2Fonce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fonce.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445"}, {"sha": "0a11c71706b7e45565349fd771619cc8f50598d0", "filename": "src/libstd/sync/rwlock.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibstd%2Fsync%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibstd%2Fsync%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Frwlock.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445"}, {"sha": "14da376efa998831a0d73cfea7eb99ef6fc04c6d", "filename": "src/libstd/sys/mod.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibstd%2Fsys%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibstd%2Fsys%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fmod.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445"}, {"sha": "f6fea2f10761b0b423e3ac716d15a365a40077c0", "filename": "src/libstd/sys/redox/args.rs", "status": "added", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibstd%2Fsys%2Fredox%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibstd%2Fsys%2Fredox%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fargs.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445"}, {"sha": "6f53841502ad23dc451283e4f16b0bda6b75feee", "filename": "src/libstd/sys/redox/backtrace.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibstd%2Fsys%2Fredox%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibstd%2Fsys%2Fredox%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fbacktrace.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445"}, {"sha": "0ca0987b245a291de772a04a54533ca6a0e6bd50", "filename": "src/libstd/sys/redox/condvar.rs", "status": "added", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibstd%2Fsys%2Fredox%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibstd%2Fsys%2Fredox%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fcondvar.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445"}, {"sha": "669b7520df846d90b237c35f4bb732d9a413a4a5", "filename": "src/libstd/sys/redox/env.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibstd%2Fsys%2Fredox%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibstd%2Fsys%2Fredox%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fenv.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445"}, {"sha": "d59b4fc0b70b8032a961d9123da86e7b5c2276ac", "filename": "src/libstd/sys/redox/ext/ffi.rs", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibstd%2Fsys%2Fredox%2Fext%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibstd%2Fsys%2Fredox%2Fext%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fext%2Fffi.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445"}, {"sha": "b4e220971fd9cbe28005573a847cb6657fa10d91", "filename": "src/libstd/sys/redox/ext/fs.rs", "status": "added", "additions": 298, "deletions": 0, "changes": 298, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibstd%2Fsys%2Fredox%2Fext%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibstd%2Fsys%2Fredox%2Fext%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fext%2Ffs.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445"}, {"sha": "8e7cc593dbdeddea4426fe3162724ab56bdde7b2", "filename": "src/libstd/sys/redox/ext/io.rs", "status": "added", "additions": 151, "deletions": 0, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibstd%2Fsys%2Fredox%2Fext%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibstd%2Fsys%2Fredox%2Fext%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fext%2Fio.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445"}, {"sha": "513ef272e9790d4fe4f8b0f64599f61dacc37489", "filename": "src/libstd/sys/redox/ext/mod.rs", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibstd%2Fsys%2Fredox%2Fext%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibstd%2Fsys%2Fredox%2Fext%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fext%2Fmod.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445"}, {"sha": "c59524974bf2f80d6e897bdf68950cdbe916a8f9", "filename": "src/libstd/sys/redox/ext/process.rs", "status": "added", "additions": 183, "deletions": 0, "changes": 183, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibstd%2Fsys%2Fredox%2Fext%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibstd%2Fsys%2Fredox%2Fext%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fext%2Fprocess.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445"}, {"sha": "6eeae2d90ea0e8cf307022907ca9fd7e86891b04", "filename": "src/libstd/sys/redox/fast_thread_local.rs", "status": "added", "additions": 116, "deletions": 0, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibstd%2Fsys%2Fredox%2Ffast_thread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibstd%2Fsys%2Fredox%2Ffast_thread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Ffast_thread_local.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445"}, {"sha": "b6de68a9dc1a9edfb1846b43aa16a1636e2755be", "filename": "src/libstd/sys/redox/fd.rs", "status": "added", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibstd%2Fsys%2Fredox%2Ffd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibstd%2Fsys%2Fredox%2Ffd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Ffd.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445"}, {"sha": "a8391d2b8982f23de0b79337a4f8ddd92e602d8b", "filename": "src/libstd/sys/redox/fs.rs", "status": "added", "additions": 470, "deletions": 0, "changes": 470, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibstd%2Fsys%2Fredox%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibstd%2Fsys%2Fredox%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Ffs.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445"}, {"sha": "4c314b7a472585b93faa63ae619a2aa28f727894", "filename": "src/libstd/sys/redox/memchr.rs", "status": "renamed", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibstd%2Fsys%2Fredox%2Fmemchr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibstd%2Fsys%2Fredox%2Fmemchr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fmemchr.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445", "previous_filename": "src/test/compile-fail/issue-23305.rs"}, {"sha": "5982bdd6549ca46a131810c60a4305851bc9a493", "filename": "src/libstd/sys/redox/mod.rs", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibstd%2Fsys%2Fredox%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibstd%2Fsys%2Fredox%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fmod.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445"}, {"sha": "a995f597fc46adc8e99dc2c6a700b92288bae416", "filename": "src/libstd/sys/redox/mutex.rs", "status": "added", "additions": 179, "deletions": 0, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibstd%2Fsys%2Fredox%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibstd%2Fsys%2Fredox%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fmutex.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445"}, {"sha": "8e6aaeb0293ad6d468b229ce3d2cceec5b7eb1ec", "filename": "src/libstd/sys/redox/net/dns/answer.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Fdns%2Fanswer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Fdns%2Fanswer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Fdns%2Fanswer.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445"}, {"sha": "43c4fe7ac9d96ad23aa1eb14b87b66935a7e9219", "filename": "src/libstd/sys/redox/net/dns/mod.rs", "status": "added", "additions": 217, "deletions": 0, "changes": 217, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Fdns%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Fdns%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Fdns%2Fmod.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445"}, {"sha": "b0dcdcb624abdf347b26a12ff1a2d89fd195eed6", "filename": "src/libstd/sys/redox/net/dns/query.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Fdns%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Fdns%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Fdns%2Fquery.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445"}, {"sha": "3fdf61cfed83c22cfd24c77f9d0b2109e4fd1c49", "filename": "src/libstd/sys/redox/net/mod.rs", "status": "added", "additions": 113, "deletions": 0, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Fmod.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445"}, {"sha": "03e1c9fffa4d0abdf78de2b08f4569bd197cf958", "filename": "src/libstd/sys/redox/net/netc.rs", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Fnetc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e766c465d2e4c4e3c106bfa8343cbe6f9192d445/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Fnetc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Fnetc.rs?ref=e766c465d2e4c4e3c106bfa8343cbe6f9192d445"}]}