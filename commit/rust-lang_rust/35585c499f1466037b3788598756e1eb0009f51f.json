{"sha": "35585c499f1466037b3788598756e1eb0009f51f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM1NTg1YzQ5OWYxNDY2MDM3YjM3ODg1OTg3NTZlMWViMDAwOWY1MWY=", "commit": {"author": {"name": "Alexander Regueiro", "email": "alexreg@me.com", "date": "2019-02-28T22:43:53Z"}, "committer": {"name": "Alexander Regueiro", "email": "alexreg@me.com", "date": "2019-06-05T20:09:26Z"}, "message": "Aggregation of drive-by cosmetic changes.", "tree": {"sha": "564b45c1826f5f8746b7ce8a657d1642b682beb5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/564b45c1826f5f8746b7ce8a657d1642b682beb5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/35585c499f1466037b3788598756e1eb0009f51f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/35585c499f1466037b3788598756e1eb0009f51f", "html_url": "https://github.com/rust-lang/rust/commit/35585c499f1466037b3788598756e1eb0009f51f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/35585c499f1466037b3788598756e1eb0009f51f/comments", "author": {"login": "alexreg", "id": 67036, "node_id": "MDQ6VXNlcjY3MDM2", "avatar_url": "https://avatars.githubusercontent.com/u/67036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexreg", "html_url": "https://github.com/alexreg", "followers_url": "https://api.github.com/users/alexreg/followers", "following_url": "https://api.github.com/users/alexreg/following{/other_user}", "gists_url": "https://api.github.com/users/alexreg/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexreg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexreg/subscriptions", "organizations_url": "https://api.github.com/users/alexreg/orgs", "repos_url": "https://api.github.com/users/alexreg/repos", "events_url": "https://api.github.com/users/alexreg/events{/privacy}", "received_events_url": "https://api.github.com/users/alexreg/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexreg", "id": 67036, "node_id": "MDQ6VXNlcjY3MDM2", "avatar_url": "https://avatars.githubusercontent.com/u/67036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexreg", "html_url": "https://github.com/alexreg", "followers_url": "https://api.github.com/users/alexreg/followers", "following_url": "https://api.github.com/users/alexreg/following{/other_user}", "gists_url": "https://api.github.com/users/alexreg/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexreg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexreg/subscriptions", "organizations_url": "https://api.github.com/users/alexreg/orgs", "repos_url": "https://api.github.com/users/alexreg/repos", "events_url": "https://api.github.com/users/alexreg/events{/privacy}", "received_events_url": "https://api.github.com/users/alexreg/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "47f4975cd751a03c941431b35cd7a6cba6201730", "url": "https://api.github.com/repos/rust-lang/rust/commits/47f4975cd751a03c941431b35cd7a6cba6201730", "html_url": "https://github.com/rust-lang/rust/commit/47f4975cd751a03c941431b35cd7a6cba6201730"}], "stats": {"total": 1092, "additions": 550, "deletions": 542}, "files": [{"sha": "239ff017cc2306b433c9d991336e21c3291d7d74", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/35585c499f1466037b3788598756e1eb0009f51f/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35585c499f1466037b3788598756e1eb0009f51f/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=35585c499f1466037b3788598756e1eb0009f51f", "patch": "@@ -1351,7 +1351,7 @@ impl<'b> BorrowRefMut<'b> {\n         }\n     }\n \n-    // Clone a `BorrowRefMut`.\n+    // Clones a `BorrowRefMut`.\n     //\n     // This is only valid if each `BorrowRefMut` is used to track a mutable\n     // reference to a distinct, nonoverlapping range of the original object."}, {"sha": "8e46830084642b573623723650f280e73671602e", "filename": "src/libcore/ops/unsize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/35585c499f1466037b3788598756e1eb0009f51f/src%2Flibcore%2Fops%2Funsize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35585c499f1466037b3788598756e1eb0009f51f/src%2Flibcore%2Fops%2Funsize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Funsize.rs?ref=35585c499f1466037b3788598756e1eb0009f51f", "patch": "@@ -71,7 +71,7 @@ impl<T: ?Sized+Unsize<U>, U: ?Sized> CoerceUnsized<*const U> for *const T {}\n \n /// This is used for object safety, to check that a method's receiver type can be dispatched on.\n ///\n-/// example impl:\n+/// An example implementation of the trait:\n ///\n /// ```\n /// # #![feature(dispatch_from_dyn, unsize)]"}, {"sha": "f838ec84d8b3170452ea93fe136c90c2c8762b37", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/35585c499f1466037b3788598756e1eb0009f51f/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35585c499f1466037b3788598756e1eb0009f51f/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=35585c499f1466037b3788598756e1eb0009f51f", "patch": "@@ -934,7 +934,6 @@ pub fn walk_impl_item_ref<'v, V: Visitor<'v>>(visitor: &mut V, impl_item_ref: &'\n     visitor.visit_defaultness(defaultness);\n }\n \n-\n pub fn walk_struct_def<'v, V: Visitor<'v>>(visitor: &mut V, struct_definition: &'v VariantData) {\n     if let Some(ctor_hir_id) = struct_definition.ctor_hir_id() {\n         visitor.visit_id(ctor_hir_id);"}, {"sha": "af8c9c38de5ff91cb02e943f488503a73379dc04", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 66, "deletions": 59, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/35585c499f1466037b3788598756e1eb0009f51f/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35585c499f1466037b3788598756e1eb0009f51f/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=35585c499f1466037b3788598756e1eb0009f51f", "patch": "@@ -17,7 +17,7 @@\n //! 'folding' an existing one), then you create a new ID using `next_id()`.\n //!\n //! You must ensure that IDs are unique. That means that you should only use the\n-//! ID from an AST node in a single HIR node (you can assume that AST node IDs\n+//! ID from an AST node in a single HIR node (you can assume that AST node-IDs\n //! are unique). Every new node must have a unique ID. Avoid cloning HIR nodes.\n //! If you do, you must then set the new node's ID to a fresh one.\n //!\n@@ -175,6 +175,8 @@ pub trait Resolver {\n     ) -> hir::Path;\n }\n \n+/// Context of `impl Trait` in code, which determines whether it is allowed in an HIR subtree,\n+/// and if so, what meaning it has.\n #[derive(Debug)]\n enum ImplTraitContext<'a> {\n     /// Treat `impl Trait` as shorthand for a new universal generic parameter.\n@@ -670,14 +672,14 @@ impl<'a> LoweringContext<'a> {\n \n     fn insert_item(&mut self, item: hir::Item) {\n         let id = item.hir_id;\n-        // FIXME: Use debug_asset-rt\n+        // FIXME: Use `debug_asset-rt`.\n         assert_eq!(id.local_id, hir::ItemLocalId::from_u32(0));\n         self.items.insert(id, item);\n         self.modules.get_mut(&self.current_module).unwrap().items.insert(id);\n     }\n \n     fn allocate_hir_id_counter(&mut self, owner: NodeId) -> hir::HirId {\n-        // Setup the counter if needed\n+        // Set up the counter if needed.\n         self.item_local_id_counters.entry(owner).or_insert(0);\n         // Always allocate the first `HirId` for the owner itself.\n         let lowered = self.lower_node_id_with_owner(owner, owner);\n@@ -718,7 +720,7 @@ impl<'a> LoweringContext<'a> {\n     {\n         let counter = self.item_local_id_counters\n             .insert(owner, HIR_ID_COUNTER_LOCKED)\n-            .unwrap_or_else(|| panic!(\"No item_local_id_counters entry for {:?}\", owner));\n+            .unwrap_or_else(|| panic!(\"no `item_local_id_counters` entry for {:?}\", owner));\n         let def_index = self.resolver.definitions().opt_def_index(owner).unwrap();\n         self.current_hir_id_owner.push((def_index, counter));\n         let ret = f(self);\n@@ -758,7 +760,7 @@ impl<'a> LoweringContext<'a> {\n             let local_id_counter = this\n                 .item_local_id_counters\n                 .get_mut(&owner)\n-                .expect(\"called lower_node_id_with_owner before allocate_hir_id_counter\");\n+                .expect(\"called `lower_node_id_with_owner` before `allocate_hir_id_counter`\");\n             let local_id = *local_id_counter;\n \n             // We want to be sure not to modify the counter in the map while it\n@@ -771,7 +773,7 @@ impl<'a> LoweringContext<'a> {\n                 .resolver\n                 .definitions()\n                 .opt_def_index(owner)\n-                .expect(\"You forgot to call `create_def_with_parent` or are lowering node ids \\\n+                .expect(\"you forgot to call `create_def_with_parent` or are lowering node-IDs \\\n                          that do not belong to the current owner\");\n \n             hir::HirId {\n@@ -863,7 +865,7 @@ impl<'a> LoweringContext<'a> {\n         result\n     }\n \n-    /// Creates a new hir::GenericParam for every new lifetime and\n+    /// Creates a new `hir::GenericParam` for every new lifetime and\n     /// type parameter encountered while evaluating `f`. Definitions\n     /// are created with the parent provided. If no `parent_id` is\n     /// provided, no definitions will be returned.\n@@ -1197,7 +1199,7 @@ impl<'a> LoweringContext<'a> {\n         assert_eq!(\n             len + 1,\n             self.loop_scopes.len(),\n-            \"Loop scopes should be added and removed in stack order\"\n+            \"loop scopes should be added and removed in stack order\"\n         );\n \n         self.loop_scopes.pop().unwrap();\n@@ -1351,9 +1353,9 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     fn lower_generic_arg(&mut self,\n-                        arg: &ast::GenericArg,\n-                        itctx: ImplTraitContext<'_>)\n-                        -> hir::GenericArg {\n+                         arg: &ast::GenericArg,\n+                         itctx: ImplTraitContext<'_>)\n+                         -> hir::GenericArg {\n         match arg {\n             ast::GenericArg::Lifetime(lt) => GenericArg::Lifetime(self.lower_lifetime(&lt)),\n             ast::GenericArg::Type(ty) => GenericArg::Type(self.lower_ty_direct(&ty, itctx)),\n@@ -1537,7 +1539,7 @@ impl<'a> LoweringContext<'a> {\n                     }\n                 }\n             }\n-            TyKind::Mac(_) => panic!(\"TyMac should have been expanded by now.\"),\n+            TyKind::Mac(_) => bug!(\"`TyMac` should have been expanded by now.\"),\n             TyKind::CVarArgs => {\n                 // Create the implicit lifetime of the \"spoofed\" `VaList`.\n                 let span = self.sess.source_map().next_point(t.span.shrink_to_lo());\n@@ -1563,7 +1565,7 @@ impl<'a> LoweringContext<'a> {\n         // Make sure we know that some funky desugaring has been going on here.\n         // This is a first: there is code in other places like for loop\n         // desugaring that explicitly states that we don't want to track that.\n-        // Not tracking it makes lints in rustc and clippy very fragile as\n+        // Not tracking it makes lints in rustc and clippy very fragile, as\n         // frequently opened issues show.\n         let exist_ty_span = self.mark_span_with_reason(\n             CompilerDesugaringKind::ExistentialReturnType,\n@@ -1650,7 +1652,7 @@ impl<'a> LoweringContext<'a> {\n         parent_index: DefIndex,\n         bounds: &hir::GenericBounds,\n     ) -> (HirVec<hir::GenericArg>, HirVec<hir::GenericParam>) {\n-        // This visitor walks over impl trait bounds and creates defs for all lifetimes which\n+        // This visitor walks over `impl Trait` bounds and creates defs for all lifetimes that\n         // appear in the bounds, excluding lifetimes that are created within the bounds.\n         // E.g., `'a`, `'b`, but not `'c` in `impl for<'c> SomeTrait<'a, 'b, 'c>`.\n         struct ImplTraitLifetimeCollector<'r, 'a: 'r> {\n@@ -1758,8 +1760,7 @@ impl<'a> LoweringContext<'a> {\n                         def_node_id,\n                         DefPathData::LifetimeNs(name.ident().as_interned_str()),\n                         Mark::root(),\n-                        lifetime.span,\n-                    );\n+                        lifetime.span);\n \n                     let (name, kind) = match name {\n                         hir::LifetimeName::Underscore => (\n@@ -1770,7 +1771,7 @@ impl<'a> LoweringContext<'a> {\n                             param_name,\n                             hir::LifetimeParamKind::Explicit,\n                         ),\n-                        _ => bug!(\"expected LifetimeName::Param or ParamName::Plain\"),\n+                        _ => bug!(\"expected `LifetimeName::Param` or `ParamName::Plain`\"),\n                     };\n \n                     self.output_lifetime_params.push(hir::GenericParam {\n@@ -1915,7 +1916,7 @@ impl<'a> LoweringContext<'a> {\n                         {\n                             ParenthesizedGenericArgs::Err\n                         }\n-                        // A warning for now, for compatibility reasons\n+                        // A warning for now, for compatibility reasons.\n                         _ => ParenthesizedGenericArgs::Warn,\n                     };\n \n@@ -2079,11 +2080,14 @@ impl<'a> LoweringContext<'a> {\n                             }\n                         };\n                         err.emit();\n-                        (self.lower_angle_bracketed_parameter_data(\n-                            &data.as_angle_bracketed_args(),\n-                            param_mode,\n-                            itctx).0,\n-                         false)\n+                        (\n+                            self.lower_angle_bracketed_parameter_data(\n+                                &data.as_angle_bracketed_args(),\n+                                param_mode,\n+                                itctx\n+                            ).0,\n+                            false,\n+                        )\n                     }\n                 },\n             }\n@@ -2109,11 +2113,11 @@ impl<'a> LoweringContext<'a> {\n                 let no_ty_args = generic_args.args.len() == expected_lifetimes;\n                 let no_bindings = generic_args.bindings.is_empty();\n                 let (incl_angl_brckt, insertion_span, suggestion) = if no_ty_args && no_bindings {\n-                    // If there are no (non-implicit) generic args or associated-type\n+                    // If there are no (non-implicit) generic args or associated type\n                     // bindings, our suggestion includes the angle brackets.\n                     (true, path_span.shrink_to_hi(), format!(\"<{}>\", anon_lt_suggestion))\n                 } else {\n-                    // Otherwise\u2014sorry, this is kind of gross\u2014we need to infer the\n+                    // Otherwise (sorry, this is kind of gross) we need to infer the\n                     // place to splice in the `'_, ` from the generics that do exist.\n                     let first_generic_span = first_generic_span\n                         .expect(\"already checked that type args or bindings exist\");\n@@ -2196,19 +2200,21 @@ impl<'a> LoweringContext<'a> {\n             ast::GenericArg::Type(_) => true,\n             _ => false,\n         });\n-        (hir::GenericArgs {\n-            args: args.iter().map(|a| self.lower_generic_arg(a, itctx.reborrow())).collect(),\n-            bindings: bindings.iter().map(|b| self.lower_ty_binding(b, itctx.reborrow())).collect(),\n-            parenthesized: false,\n-        },\n-        !has_types && param_mode == ParamMode::Optional)\n+        (\n+            hir::GenericArgs {\n+                args: args.iter().map(|a| self.lower_generic_arg(a, itctx.reborrow())).collect(),\n+                bindings: bindings.iter().map(|b| self.lower_ty_binding(b, itctx.reborrow())).collect(),\n+                parenthesized: false,\n+            },\n+            !has_types && param_mode == ParamMode::Optional\n+        )\n     }\n \n     fn lower_parenthesized_parameter_data(\n         &mut self,\n         data: &ParenthesizedArgs,\n     ) -> (hir::GenericArgs, bool) {\n-        // Switch to `PassThrough` mode for anonymous lifetimes: this\n+        // Switch to `PassThrough` mode for anonymous lifetimes; this\n         // means that we permit things like `&Ref<T>`, where `Ref` has\n         // a hidden lifetime parameter. This is needed for backwards\n         // compatibility, even in contexts like an impl header where\n@@ -2300,16 +2306,16 @@ impl<'a> LoweringContext<'a> {\n \n     // Lowers a function declaration.\n     //\n-    // decl: the unlowered (ast) function declaration.\n-    // fn_def_id: if `Some`, impl Trait arguments are lowered into generic parameters on the\n+    // `decl`: the unlowered (AST) function declaration.\n+    // `fn_def_id`: if `Some`, impl Trait arguments are lowered into generic parameters on the\n     //      given DefId, otherwise impl Trait is disallowed. Must be `Some` if\n-    //      make_ret_async is also `Some`.\n-    // impl_trait_return_allow: determines whether impl Trait can be used in return position.\n-    //      This guards against trait declarations and implementations where impl Trait is\n+    //      `make_ret_async` is also `Some`.\n+    // `impl_trait_return_allow`: determines whether `impl Trait` can be used in return position.\n+    //      This guards against trait declarations and implementations where `impl Trait` is\n     //      disallowed.\n-    // make_ret_async: if `Some`, converts `-> T` into `-> impl Future<Output = T>` in the\n-    //      return type. This is used for `async fn` declarations. The `NodeId` is the id of the\n-    //      return type impl Trait item.\n+    // `make_ret_async`: if `Some`, converts `-> T` into `-> impl Future<Output = T>` in the\n+    //      return type. This is used for `async fn` declarations. The `NodeId` is the ID of the\n+    //      return type `impl Trait` item.\n     fn lower_fn_decl(\n         &mut self,\n         decl: &FnDecl,\n@@ -2350,7 +2356,7 @@ impl<'a> LoweringContext<'a> {\n             );\n             self.lower_async_fn_ret_ty(\n                 &decl.output,\n-                in_band_ty_params.expect(\"make_ret_async but no fn_def_id\").0,\n+                in_band_ty_params.expect(\"`make_ret_async` but no `fn_def_id`\").0,\n                 ret_id,\n                 lt_replacement,\n             )\n@@ -2401,16 +2407,16 @@ impl<'a> LoweringContext<'a> {\n         })\n     }\n \n-    // Transform `-> T` for `async fn` into -> ExistTy { .. }\n+    // Transforms `-> T` for `async fn` into `-> ExistTy { .. }`\n     // combined with the following definition of `ExistTy`:\n     //\n-    // existential type ExistTy<generics_from_parent_fn>: Future<Output = T>;\n+    //     existential type ExistTy<generics_from_parent_fn>: Future<Output = T>;\n     //\n-    // inputs: lowered types of arguments to the function. Used to collect lifetimes.\n-    // output: unlowered output type (`T` in `-> T`)\n-    // fn_def_id: DefId of the parent function. Used to create child impl trait definition.\n-    // exist_ty_node_id: NodeId of the existential type that should be created.\n-    // elided_lt_replacement: replacement for elided lifetimes in the return type\n+    // `inputs`: lowered types of arguments to the function (used to collect lifetimes)\n+    // `output`: unlowered output type (`T` in `-> T`)\n+    // `fn_def_id`: `DefId` of the parent function (used to create child impl trait definition)\n+    // `exist_ty_node_id`: `NodeId` of the existential type that should be created\n+    // `elided_lt_replacement`: replacement for elided lifetimes in the return type\n     fn lower_async_fn_ret_ty(\n         &mut self,\n         output: &FunctionRetTy,\n@@ -2511,7 +2517,7 @@ impl<'a> LoweringContext<'a> {\n         }))\n     }\n \n-    /// Turns `-> T` into `Future<Output = T>`\n+    /// Transforms `-> T` into `Future<Output = T>`\n     fn lower_async_fn_output_type_to_future_bound(\n         &mut self,\n         output: &FunctionRetTy,\n@@ -2757,9 +2763,9 @@ impl<'a> LoweringContext<'a> {\n         -> hir::Generics\n     {\n         // Collect `?Trait` bounds in where clause and move them to parameter definitions.\n-        // FIXME: this could probably be done with less rightward drift. Also looks like two control\n-        //        paths where report_error is called are also the only paths that advance to after\n-        //        the match statement, so the error reporting could probably just be moved there.\n+        // FIXME: this could probably be done with less rightward drift. It also looks like two\n+        // control paths where `report_error` is called are the only paths that advance to after the\n+        // match statement, so the error reporting could probably just be moved there.\n         let mut add_bounds: NodeMap<Vec<_>> = Default::default();\n         for pred in &generics.where_clause.predicates {\n             if let WherePredicate::BoundPredicate(ref bound_pred) = *pred {\n@@ -2952,7 +2958,7 @@ impl<'a> LoweringContext<'a> {\n             hir_id: self.lower_node_id(f.id),\n             ident: match f.ident {\n                 Some(ident) => ident,\n-                // FIXME(jseyfried): positional field hygiene\n+                // FIXME(jseyfried): positional field hygiene.\n                 None => Ident::new(sym::integer(index), f.span),\n             },\n             vis: self.lower_visibility(&f.vis, None),\n@@ -2979,7 +2985,7 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     fn lower_param_bounds(&mut self, bounds: &[GenericBound], mut itctx: ImplTraitContext<'_>)\n-        -> hir::GenericBounds {\n+                          -> hir::GenericBounds {\n         bounds.iter().map(|bound| self.lower_param_bound(bound, itctx.reborrow())).collect()\n     }\n \n@@ -3157,7 +3163,7 @@ impl<'a> LoweringContext<'a> {\n         match *i {\n             ItemKind::ExternCrate(orig_name) => hir::ItemKind::ExternCrate(orig_name),\n             ItemKind::Use(ref use_tree) => {\n-                // Start with an empty prefix\n+                // Start with an empty prefix.\n                 let prefix = Path {\n                     segments: vec![],\n                     span: use_tree.span,\n@@ -3345,7 +3351,8 @@ impl<'a> LoweringContext<'a> {\n                 self.lower_generics(generics, ImplTraitContext::disallowed()),\n                 self.lower_param_bounds(bounds, ImplTraitContext::disallowed()),\n             ),\n-            ItemKind::MacroDef(..) | ItemKind::Mac(..) => panic!(\"Shouldn't still be around\"),\n+            ItemKind::MacroDef(..)\n+            | ItemKind::Mac(..) => bug!(\"`TyMac` should have been expanded by now\"),\n         }\n \n         // [1] `defaultness.has_value()` is never called for an `impl`, always `true` in order to\n@@ -3632,7 +3639,7 @@ impl<'a> LoweringContext<'a> {\n                         .map(|x| self.lower_ty(x, ImplTraitContext::disallowed())),\n                 ),\n             ),\n-            TraitItemKind::Macro(..) => panic!(\"Shouldn't exist any more\"),\n+            TraitItemKind::Macro(..) => bug!(\"macro item shouldn't exist at this point\"),\n         };\n \n         hir::TraitItem {\n@@ -3707,7 +3714,7 @@ impl<'a> LoweringContext<'a> {\n                     self.lower_param_bounds(bounds, ImplTraitContext::disallowed()),\n                 ),\n             ),\n-            ImplItemKind::Macro(..) => panic!(\"Shouldn't exist any more\"),\n+            ImplItemKind::Macro(..) => bug!(\"`TyMac` should have been expanded by now\"),\n         };\n \n         hir::ImplItem {\n@@ -5347,7 +5354,7 @@ impl<'a> LoweringContext<'a> {\n         })\n     }\n \n-    /// Given suffix [\"b\",\"c\",\"d\"], returns path `::std::b::c::d` when\n+    /// Given a suffix `[\"b\", \"c\", \"d\"]`, returns path `::std::b::c::d` when\n     /// `fld.cx.use_std`, and `::core::b::c::d` otherwise.\n     /// The path is also resolved according to `is_value`.\n     fn std_path("}, {"sha": "e66fa13f4fca21cfec4384bc02459a26a4ef7ccc", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/35585c499f1466037b3788598756e1eb0009f51f/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35585c499f1466037b3788598756e1eb0009f51f/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=35585c499f1466037b3788598756e1eb0009f51f", "patch": "@@ -19,7 +19,7 @@ use std::iter::repeat;\n use crate::ich::StableHashingContext;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher, StableHasherResult};\n \n-/// A Visitor that walks over the HIR and collects Nodes into a HIR map\n+/// A visitor that walks over the HIR and collects `Node`s into a HIR map.\n pub(super) struct NodeCollector<'a, 'hir> {\n     /// The crate\n     krate: &'hir Crate,\n@@ -45,7 +45,7 @@ pub(super) struct NodeCollector<'a, 'hir> {\n \n     hcx: StableHashingContext<'a>,\n \n-    // We are collecting DepNode::HirBody hashes here so we can compute the\n+    // We are collecting `DepNode::HirBody` hashes here so we can compute the\n     // crate hash from then later on.\n     hir_body_nodes: Vec<(DefPathHash, Fingerprint)>,\n }\n@@ -109,7 +109,7 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n \n         let mut hir_body_nodes = Vec::new();\n \n-        // Allocate DepNodes for the root module\n+        // Allocate `DepNode`s for the root module.\n         let (root_mod_sig_dep_index, root_mod_full_dep_index) = {\n             let Crate {\n                 ref module,"}, {"sha": "b85f6f6ce848317118c73c8aaac6aecc4d588567", "filename": "src/librustc/hir/map/definitions.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/35585c499f1466037b3788598756e1eb0009f51f/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35585c499f1466037b3788598756e1eb0009f51f/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs?ref=35585c499f1466037b3788598756e1eb0009f51f", "patch": "@@ -239,7 +239,7 @@ impl DefPath {\n                        \"{}[{}]\",\n                        component.data.as_interned_str(),\n                        component.disambiguator)\n-                    .unwrap();\n+                       .unwrap();\n             }\n         }\n \n@@ -263,7 +263,7 @@ impl DefPath {\n                        \"{}[{}]\",\n                        component.data.as_interned_str(),\n                        component.disambiguator)\n-                    .unwrap();\n+                       .unwrap();\n             }\n         }\n         s\n@@ -442,7 +442,7 @@ impl Definitions {\n         root_index\n     }\n \n-    /// Add a definition with a parent definition.\n+    /// Adds a definition with a parent definition.\n     pub fn create_def_with_parent(&mut self,\n                                   parent: DefIndex,\n                                   node_id: ast::NodeId,\n@@ -559,7 +559,7 @@ impl DefPathData {\n             GlobalMetaData(name) => {\n                 return name\n             }\n-            // note that this does not show up in user printouts\n+            // Note that this does not show up in user print-outs.\n             CrateRoot => sym::double_braced_crate,\n             Impl => sym::double_braced_impl,\n             Misc => sym::double_braced_misc,"}, {"sha": "18c596f164dc241e9de1e03b91a330618c4d3102", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 37, "deletions": 36, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/35585c499f1466037b3788598756e1eb0009f51f/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35585c499f1466037b3788598756e1eb0009f51f/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=35585c499f1466037b3788598756e1eb0009f51f", "patch": "@@ -1,7 +1,8 @@\n use self::collector::NodeCollector;\n pub use self::def_collector::{DefCollector, MacroInvocationData};\n-pub use self::definitions::{Definitions, DefKey, DefPath, DefPathData,\n-                            DisambiguatedDefPathData, DefPathHash};\n+pub use self::definitions::{\n+    Definitions, DefKey, DefPath, DefPathData, DisambiguatedDefPathData, DefPathHash\n+};\n \n use crate::dep_graph::{DepGraph, DepNode, DepKind, DepNodeIndex};\n \n@@ -238,7 +239,7 @@ impl<'hir> Map<'hir> {\n         })\n     }\n \n-    // FIXME(@ljedrz): replace the NodeId variant\n+    // FIXME(@ljedrz): replace the `NodeId` variant.\n     #[inline]\n     pub fn local_def_id_from_hir_id(&self, hir_id: HirId) -> DefId {\n         self.opt_local_def_id_from_hir_id(hir_id).unwrap_or_else(|| {\n@@ -247,7 +248,7 @@ impl<'hir> Map<'hir> {\n         })\n     }\n \n-    // FIXME(@ljedrz): replace the NodeId variant\n+    // FIXME(@ljedrz): replace the `NodeId` variant.\n     #[inline]\n     pub fn opt_local_def_id_from_hir_id(&self, hir_id: HirId) -> Option<DefId> {\n         let node_id = self.hir_to_node_id(hir_id);\n@@ -264,7 +265,7 @@ impl<'hir> Map<'hir> {\n         self.definitions.as_local_node_id(def_id)\n     }\n \n-    // FIXME(@ljedrz): replace the NodeId variant\n+    // FIXME(@ljedrz): replace the `NodeId` variant.\n     #[inline]\n     pub fn as_local_hir_id(&self, def_id: DefId) -> Option<HirId> {\n         self.definitions.as_local_hir_id(def_id)\n@@ -426,7 +427,7 @@ impl<'hir> Map<'hir> {\n         self.fn_decl_by_hir_id(hir_id)\n     }\n \n-    // FIXME(@ljedrz): replace the NodeId variant\n+    // FIXME(@ljedrz): replace the `NodeId` variant.\n     pub fn fn_decl_by_hir_id(&self, hir_id: HirId) -> Option<FnDecl> {\n         if let Some(entry) = self.find_entry(hir_id) {\n             entry.fn_decl().cloned()\n@@ -455,7 +456,7 @@ impl<'hir> Map<'hir> {\n         self.maybe_body_owned_by_by_hir_id(hir_id)\n     }\n \n-    // FIXME(@ljedrz): replace the NodeId variant\n+    // FIXME(@ljedrz): replace the `NodeId` variant.\n     pub fn maybe_body_owned_by_by_hir_id(&self, hir_id: HirId) -> Option<BodyId> {\n         if let Some(entry) = self.find_entry(hir_id) {\n             if self.dep_graph.is_fully_enabled() {\n@@ -483,7 +484,7 @@ impl<'hir> Map<'hir> {\n         self.body_owner_kind_by_hir_id(hir_id)\n     }\n \n-    // FIXME(@ljedrz): replace the NodeId variant\n+    // FIXME(@ljedrz): replace the `NodeId` variant.\n     pub fn body_owner_kind_by_hir_id(&self, id: HirId) -> BodyOwnerKind {\n         match self.get_by_hir_id(id) {\n             Node::Item(&Item { node: ItemKind::Const(..), .. }) |\n@@ -587,14 +588,13 @@ impl<'hir> Map<'hir> {\n         }\n     }\n \n-    /// Retrieve the Node corresponding to `id`, panicking if it cannot\n-    /// be found.\n+    /// Retrieves the `Node` corresponding to `id`, panicking if it cannot be found.\n     pub fn get(&self, id: NodeId) -> Node<'hir> {\n         let hir_id = self.node_to_hir_id(id);\n         self.get_by_hir_id(hir_id)\n     }\n \n-    // FIXME(@ljedrz): replace the NodeId variant\n+    // FIXME(@ljedrz): replace the `NodeId` variant.\n     pub fn get_by_hir_id(&self, id: HirId) -> Node<'hir> {\n         // read recorded by `find`\n         self.find_by_hir_id(id).unwrap_or_else(||\n@@ -634,7 +634,7 @@ impl<'hir> Map<'hir> {\n         self.find_by_hir_id(hir_id)\n     }\n \n-    // FIXME(@ljedrz): replace the NodeId variant\n+    // FIXME(@ljedrz): replace the `NodeId` variant.\n     pub fn find_by_hir_id(&self, hir_id: HirId) -> Option<Node<'hir>> {\n         let result = self.find_entry(hir_id).and_then(|entry| {\n             if let Node::Crate = entry.node {\n@@ -665,7 +665,7 @@ impl<'hir> Map<'hir> {\n         self.hir_to_node_id(parent_hir_id)\n     }\n \n-    // FIXME(@ljedrz): replace the NodeId variant\n+    // FIXME(@ljedrz): replace the `NodeId` variant.\n     pub fn get_parent_node_by_hir_id(&self, hir_id: HirId) -> HirId {\n         if self.dep_graph.is_fully_enabled() {\n             let hir_id_owner = hir_id.owner;\n@@ -721,24 +721,24 @@ impl<'hir> Map<'hir> {\n     {\n         let mut id = start_id;\n         loop {\n-            let parent_node = self.get_parent_node_by_hir_id(id);\n-            if parent_node == CRATE_HIR_ID {\n+            let parent_id = self.get_parent_node_by_hir_id(id);\n+            if parent_id == CRATE_HIR_ID {\n                 return Ok(CRATE_HIR_ID);\n             }\n-            if parent_node == id {\n+            if parent_id == id {\n                 return Err(id);\n             }\n \n-            if let Some(entry) = self.find_entry(parent_node) {\n+            if let Some(entry) = self.find_entry(parent_id) {\n                 if let Node::Crate = entry.node {\n                     return Err(id);\n                 }\n                 if found(&entry.node) {\n-                    return Ok(parent_node);\n+                    return Ok(parent_id);\n                 } else if bail_early(&entry.node) {\n-                    return Err(parent_node);\n+                    return Err(parent_id);\n                 }\n-                id = parent_node;\n+                id = parent_id;\n             } else {\n                 return Err(id);\n             }\n@@ -803,7 +803,7 @@ impl<'hir> Map<'hir> {\n         self.hir_to_node_id(parent_hir_id)\n     }\n \n-    // FIXME(@ljedrz): replace the NodeId variant\n+    // FIXME(@ljedrz): replace the `NodeId` variant.\n     pub fn get_parent_item(&self, hir_id: HirId) -> HirId {\n         match self.walk_parent_nodes(hir_id, |node| match *node {\n             Node::Item(_) |\n@@ -824,7 +824,7 @@ impl<'hir> Map<'hir> {\n         self.get_module_parent_by_hir_id(hir_id)\n     }\n \n-    // FIXME(@ljedrz): replace the NodeId variant\n+    // FIXME(@ljedrz): replace the `NodeId` variant.\n     pub fn get_module_parent_by_hir_id(&self, id: HirId) -> DefId {\n         self.local_def_id_from_hir_id(self.get_module_parent_node(id))\n     }\n@@ -861,7 +861,7 @@ impl<'hir> Map<'hir> {\n         self.get_parent_did_by_hir_id(hir_id)\n     }\n \n-    // FIXME(@ljedrz): replace the NodeId variant\n+    // FIXME(@ljedrz): replace the `NodeId` variant.\n     pub fn get_parent_did_by_hir_id(&self, id: HirId) -> DefId {\n         self.local_def_id_from_hir_id(self.get_parent_item(id))\n     }\n@@ -871,7 +871,7 @@ impl<'hir> Map<'hir> {\n         self.get_foreign_abi_by_hir_id(hir_id)\n     }\n \n-    // FIXME(@ljedrz): replace the NodeId variant\n+    // FIXME(@ljedrz): replace the `NodeId` variant.\n     pub fn get_foreign_abi_by_hir_id(&self, hir_id: HirId) -> Abi {\n         let parent = self.get_parent_item(hir_id);\n         if let Some(entry) = self.find_entry(parent) {\n@@ -890,7 +890,7 @@ impl<'hir> Map<'hir> {\n         self.expect_item_by_hir_id(hir_id)\n     }\n \n-    // FIXME(@ljedrz): replace the NodeId variant\n+    // FIXME(@ljedrz): replace the `NodeId` variant.\n     pub fn expect_item_by_hir_id(&self, id: HirId) -> &'hir Item {\n         match self.find_by_hir_id(id) { // read recorded by `find`\n             Some(Node::Item(item)) => item,\n@@ -946,7 +946,7 @@ impl<'hir> Map<'hir> {\n         self.expect_expr_by_hir_id(hir_id)\n     }\n \n-    // FIXME(@ljedrz): replace the NodeId variant\n+    // FIXME(@ljedrz): replace the `NodeId` variant.\n     pub fn expect_expr_by_hir_id(&self, id: HirId) -> &'hir Expr {\n         match self.find_by_hir_id(id) { // read recorded by find\n             Some(Node::Expr(expr)) => expr,\n@@ -960,7 +960,7 @@ impl<'hir> Map<'hir> {\n         self.name_by_hir_id(hir_id)\n     }\n \n-    // FIXME(@ljedrz): replace the NodeId variant\n+    // FIXME(@ljedrz): replace the `NodeId` variant.\n     pub fn name_by_hir_id(&self, id: HirId) -> Name {\n         match self.get_by_hir_id(id) {\n             Node::Item(i) => i.ident.name,\n@@ -977,14 +977,14 @@ impl<'hir> Map<'hir> {\n         }\n     }\n \n-    /// Given a node ID, get a list of attributes associated with the AST\n-    /// corresponding to the Node ID\n+    /// Given a node ID, gets a list of attributes associated with the AST\n+    /// corresponding to the node-ID.\n     pub fn attrs(&self, id: NodeId) -> &'hir [ast::Attribute] {\n         let hir_id = self.node_to_hir_id(id);\n         self.attrs_by_hir_id(hir_id)\n     }\n \n-    // FIXME(@ljedrz): replace the NodeId variant\n+    // FIXME(@ljedrz): replace the `NodeId` variant.\n     pub fn attrs_by_hir_id(&self, id: HirId) -> &'hir [ast::Attribute] {\n         self.read(id); // reveals attributes on the node\n         let attrs = match self.find_entry(id).map(|entry| entry.node) {\n@@ -1053,7 +1053,7 @@ impl<'hir> Map<'hir> {\n         self.span_by_hir_id(hir_id)\n     }\n \n-    // FIXME(@ljedrz): replace the NodeId variant\n+    // FIXME(@ljedrz): replace the `NodeId` variant.\n     pub fn span_by_hir_id(&self, hir_id: HirId) -> Span {\n         self.read(hir_id); // reveals span from node\n         match self.find_entry(hir_id).map(|entry| entry.node) {\n@@ -1101,7 +1101,7 @@ impl<'hir> Map<'hir> {\n         hir_id_to_string(self, self.node_to_hir_id(id), true)\n     }\n \n-    // FIXME(@ljedrz): replace the NodeId variant\n+    // FIXME(@ljedrz): replace the `NodeId` variant.\n     pub fn hir_to_string(&self, id: HirId) -> String {\n         hir_id_to_string(self, id, true)\n     }\n@@ -1110,7 +1110,7 @@ impl<'hir> Map<'hir> {\n         hir_id_to_string(self, self.node_to_hir_id(id), false)\n     }\n \n-    // FIXME(@ljedrz): replace the NodeId variant\n+    // FIXME(@ljedrz): replace the `NodeId` variant.\n     pub fn hir_to_user_string(&self, id: HirId) -> String {\n         hir_id_to_string(self, id, false)\n     }\n@@ -1119,7 +1119,7 @@ impl<'hir> Map<'hir> {\n         print::to_string(self, |s| s.print_node(self.get(id)))\n     }\n \n-    // FIXME(@ljedrz): replace the NodeId variant\n+    // FIXME(@ljedrz): replace the `NodeId` variant.\n     pub fn hir_to_pretty_string(&self, id: HirId) -> String {\n         print::to_string(self, |s| s.print_node(self.get_by_hir_id(id)))\n     }\n@@ -1451,8 +1451,9 @@ pub fn provide(providers: &mut Providers<'_>) {\n         if let Some(node_id) = tcx.hir().as_local_node_id(def_id) {\n             tcx.hir().def_kind(node_id)\n         } else {\n-            bug!(\"Calling local def_kind query provider for upstream DefId: {:?}\",\n-                def_id)\n+            bug!(\"calling local def_kind query provider for upstream DefId: {:?}\",\n+                def_id\n+            );\n         }\n     };\n }"}, {"sha": "e29998db7778f4036b091a9e400feb39792fdd6e", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 17, "deletions": 19, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/35585c499f1466037b3788598756e1eb0009f51f/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35585c499f1466037b3788598756e1eb0009f51f/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=35585c499f1466037b3788598756e1eb0009f51f", "patch": "@@ -1,4 +1,4 @@\n-// HIR datatypes. See the [rustc guide] for more info.\n+//! HIR datatypes. See the [rustc guide] for more info.\n //!\n //! [rustc guide]: https://rust-lang.github.io/rustc-guide/hir.html\n \n@@ -121,13 +121,13 @@ impl fmt::Display for HirId {\n     }\n }\n \n-// hack to ensure that we don't try to access the private parts of `ItemLocalId` in this module\n+// Hack to ensure that we don't try to access the private parts of `ItemLocalId` in this module\n mod item_local_id_inner {\n     use rustc_data_structures::indexed_vec::Idx;\n     use rustc_macros::HashStable;\n     newtype_index! {\n-        /// An `ItemLocalId` uniquely identifies something within a given \"item-like\",\n-        /// that is, within a hir::Item, hir::TraitItem, or hir::ImplItem. There is no\n+        /// An `ItemLocalId` uniquely identifies something within a given \"item-like\";\n+        /// that is, within a `hir::Item`, `hir::TraitItem`, or `hir::ImplItem`. There is no\n         /// guarantee that the numerical value of a given `ItemLocalId` corresponds to\n         /// the node's position within the owning item in any way, but there is a\n         /// guarantee that the `LocalItemId`s within an owner occupy a dense range of\n@@ -568,7 +568,6 @@ pub struct GenericParam {\n     pub bounds: GenericBounds,\n     pub span: Span,\n     pub pure_wrt_drop: bool,\n-\n     pub kind: GenericParamKind,\n }\n \n@@ -1566,13 +1565,13 @@ pub enum ExprKind {\n \n     /// A struct or struct-like variant literal expression.\n     ///\n-    /// For example, `Foo {x: 1, y: 2}`, or\n-    /// `Foo {x: 1, .. base}`, where `base` is the `Option<Expr>`.\n+    /// E.g., `Foo {x: 1, y: 2}`, or `Foo {x: 1, .. base}`,\n+    /// where `base` is the `Option<Expr>`.\n     Struct(P<QPath>, HirVec<Field>, Option<P<Expr>>),\n \n     /// An array literal constructed from one repeated element.\n     ///\n-    /// For example, `[1; 5]`. The first expression is the element\n+    /// E.g., `[1; 5]`. The first expression is the element\n     /// to be repeated; the second is the number of times to repeat it.\n     Repeat(P<Expr>, AnonConst),\n \n@@ -1583,7 +1582,7 @@ pub enum ExprKind {\n     Err,\n }\n \n-/// Optionally `Self`-qualified value/type path or associated extension.\n+/// Represents an optionally `Self`-qualified value/type path or associated extension.\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum QPath {\n     /// Path to a definition, optionally \"fully-qualified\" with a `Self`\n@@ -1738,7 +1737,7 @@ pub struct TraitItem {\n     pub span: Span,\n }\n \n-/// A trait method's body (or just argument names).\n+/// Represents a trait method's body (or just argument names).\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum TraitMethod {\n     /// No default body in the trait, just a signature.\n@@ -1751,13 +1750,12 @@ pub enum TraitMethod {\n /// Represents a trait method or associated constant or type\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum TraitItemKind {\n-    /// An associated constant with an optional value (otherwise `impl`s\n-    /// must contain a value)\n+    /// An associated constant with an optional value (otherwise `impl`s must contain a value).\n     Const(P<Ty>, Option<BodyId>),\n-    /// A method with an optional body\n+    /// A method with an optional body.\n     Method(MethodSig, TraitMethod),\n     /// An associated type with (possibly empty) bounds and optional concrete\n-    /// type\n+    /// type.\n     Type(GenericBounds, Option<P<Ty>>),\n }\n \n@@ -1808,9 +1806,9 @@ pub struct TypeBinding {\n \n #[derive(Clone, RustcEncodable, RustcDecodable)]\n pub struct Ty {\n+    pub hir_id: HirId,\n     pub node: TyKind,\n     pub span: Span,\n-    pub hir_id: HirId,\n }\n \n impl fmt::Debug for Ty {\n@@ -1874,7 +1872,7 @@ pub enum TyKind {\n     BareFn(P<BareFnTy>),\n     /// The never type (`!`).\n     Never,\n-    /// A tuple (`(A, B, C, D,...)`).\n+    /// A tuple (`(A, B, C, D, ...)`).\n     Tup(HirVec<Ty>),\n     /// A path to a type definition (`module::module::...::Type`), or an\n     /// associated type (e.g., `<Vec<T> as Trait>::Type` or `<T>::Target`).\n@@ -2598,7 +2596,7 @@ impl CodegenFnAttrs {\n         }\n     }\n \n-    /// True if it looks like this symbol needs to be exported, for example:\n+    /// Returns `true` if it looks like this symbol needs to be exported, for example:\n     ///\n     /// * `#[no_mangle]` is present\n     /// * `#[export_name(...)]` is present\n@@ -2607,8 +2605,8 @@ impl CodegenFnAttrs {\n         self.flags.contains(CodegenFnAttrFlags::NO_MANGLE) ||\n             self.export_name.is_some() ||\n             match self.linkage {\n-                // these are private, make sure we don't try to consider\n-                // them external\n+                // These are private, so make sure we don't try to consider\n+                // them external.\n                 None |\n                 Some(Linkage::Internal) |\n                 Some(Linkage::Private) => false,"}, {"sha": "709a43c4734c1c7c9eb3dc6b217d58f8018b14ad", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/35585c499f1466037b3788598756e1eb0009f51f/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35585c499f1466037b3788598756e1eb0009f51f/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=35585c499f1466037b3788598756e1eb0009f51f", "patch": "@@ -1679,8 +1679,8 @@ impl<'a> State<'a> {\n                 })?;\n             }\n \n-            // FIXME(eddyb) This would leak into error messages, e.g.:\n-            // \"non-exhaustive patterns: `Some::<..>(_)` not covered\".\n+            // FIXME(eddyb): this would leak into error messages (e.g.,\n+            // \"non-exhaustive patterns: `Some::<..>(_)` not covered\").\n             if infer_types && false {\n                 start_or_comma(self)?;\n                 self.s.word(\"..\")?;"}, {"sha": "f2f909b6af156f96b47c2b37e5da513c6a493d83", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/35585c499f1466037b3788598756e1eb0009f51f/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35585c499f1466037b3788598756e1eb0009f51f/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=35585c499f1466037b3788598756e1eb0009f51f", "patch": "@@ -286,7 +286,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for hir::Mod {\n \n         inner_span.hash_stable(hcx, hasher);\n \n-        // Combining the DefPathHashes directly is faster than feeding them\n+        // Combining the `DefPathHash`s directly is faster than feeding them\n         // into the hasher. Because we use a commutative combine, we also don't\n         // have to sort the array.\n         let item_ids_hash = item_ids"}, {"sha": "e9c47002278df3c66336ae81107d5b403a66ec6b", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/35585c499f1466037b3788598756e1eb0009f51f/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35585c499f1466037b3788598756e1eb0009f51f/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=35585c499f1466037b3788598756e1eb0009f51f", "patch": "@@ -914,10 +914,9 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         // variable, and because type variable's can't (at present, at\n         // least) capture any of the things bound by this binder.\n         //\n-        // Really, there is no *particular* reason to do this\n-        // `shallow_resolve` here except as a\n-        // micro-optimization. Naturally I could not\n-        // resist. -nmatsakis\n+        // NOTE(nmatsakis): really, there is no *particular* reason to do this\n+        // `shallow_resolve` here except as a micro-optimization.\n+        // Naturally I could not resist.\n         let two_unbound_type_vars = {\n             let a = self.shallow_resolve(predicate.skip_binder().a);\n             let b = self.shallow_resolve(predicate.skip_binder().b);"}, {"sha": "1423b855745e7c7fbee98c039891067791471900", "filename": "src/librustc/infer/opaque_types/mod.rs", "status": "modified", "additions": 11, "deletions": 14, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/35585c499f1466037b3788598756e1eb0009f51f/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35585c499f1466037b3788598756e1eb0009f51f/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs?ref=35585c499f1466037b3788598756e1eb0009f51f", "patch": "@@ -858,7 +858,7 @@ impl<'a, 'gcx, 'tcx> Instantiator<'a, 'gcx, 'tcx> {\n             def_id, substs\n         );\n \n-        // Use the same type variable if the exact same Opaque appears more\n+        // Use the same type variable if the exact same opaque type appears more\n         // than once in the return type (e.g., if it's passed to a type alias).\n         if let Some(opaque_defn) = self.opaque_types.get(&def_id) {\n             return opaque_defn.concrete_ty;\n@@ -880,9 +880,9 @@ impl<'a, 'gcx, 'tcx> Instantiator<'a, 'gcx, 'tcx> {\n             required_region_bounds\n         );\n \n-        // make sure that we are in fact defining the *entire* type\n-        // e.g., `existential type Foo<T: Bound>: Bar;` needs to be\n-        // defined by a function like `fn foo<T: Bound>() -> Foo<T>`.\n+        // Make sure that we are in fact defining the *entire* type\n+        // (e.g., `existential type Foo<T: Bound>: Bar;` needs to be\n+        // defined by a function like `fn foo<T: Bound>() -> Foo<T>`).\n         debug!(\n             \"instantiate_opaque_types: param_env: {:#?}\",\n             self.param_env,\n@@ -945,18 +945,15 @@ pub fn may_define_existential_type(\n     def_id: DefId,\n     opaque_hir_id: hir::HirId,\n ) -> bool {\n-    let mut hir_id = tcx\n-        .hir()\n-        .as_local_hir_id(def_id)\n-        .unwrap();\n-    // named existential types can be defined by any siblings or\n-    // children of siblings\n+    let mut hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n+    // Named existential types can be defined by any siblings or\n+    // children of siblings.\n     let mod_id = tcx.hir().get_parent_item(opaque_hir_id);\n-    // so we walk up the node tree until we hit the root or the parent\n-    // of the opaque type\n-    while hir_id != mod_id && hir_id != hir::CRATE_HIR_ID {\n+    // We walk up the node tree until we hit the root or the parent\n+    // of the opaque type.\n+    while hir_id != mod_id && node_id != ast::CRATE_HIR_ID {\n         hir_id = tcx.hir().get_parent_item(hir_id);\n     }\n-    // syntactically we are allowed to define the concrete type\n+    // Syntactically we are allowed to define the concrete type.\n     hir_id == mod_id\n }"}, {"sha": "2e56ca6f56352911271afcbd40ea2ba035fa6edd", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/35585c499f1466037b3788598756e1eb0009f51f/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35585c499f1466037b3788598756e1eb0009f51f/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=35585c499f1466037b3788598756e1eb0009f51f", "patch": "@@ -1,6 +1,6 @@\n //! Name resolution for lifetimes.\n //!\n-//! Name resolution for lifetimes follows MUCH simpler rules than the\n+//! Name resolution for lifetimes follows *much* simpler rules than the\n //! full resolve. For example, lifetime names are never exported or\n //! used between functions, and they operate in a purely top-down\n //! way. Therefore, we break lifetime name resolution into a separate pass.\n@@ -1009,7 +1009,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n         trait_ref: &'tcx hir::PolyTraitRef,\n         _modifier: hir::TraitBoundModifier,\n     ) {\n-        debug!(\"visit_poly_trait_ref trait_ref={:?}\", trait_ref);\n+        debug!(\"visit_poly_trait_ref(trait_ref={:?})\", trait_ref);\n \n         if !self.trait_ref_hack || trait_ref.bound_generic_params.iter().any(|param| {\n             match param.kind {"}, {"sha": "815c68b6b1cb68c7b272836a3606dff124b3ed55", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/35585c499f1466037b3788598756e1eb0009f51f/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35585c499f1466037b3788598756e1eb0009f51f/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=35585c499f1466037b3788598756e1eb0009f51f", "patch": "@@ -124,12 +124,12 @@ impl<'a, 'tcx: 'a> Annotator<'a, 'tcx> {\n             // This crate explicitly wants staged API.\n             debug!(\"annotate(id = {:?}, attrs = {:?})\", hir_id, attrs);\n             if let Some(..) = attr::find_deprecation(&self.tcx.sess.parse_sess, attrs, item_sp) {\n-                self.tcx.sess.span_err(item_sp, \"`#[deprecated]` cannot be used in staged api, \\\n+                self.tcx.sess.span_err(item_sp, \"`#[deprecated]` cannot be used in staged API; \\\n                                                  use `#[rustc_deprecated]` instead\");\n             }\n             if let Some(mut stab) = attr::find_stability(&self.tcx.sess.parse_sess,\n                                                          attrs, item_sp) {\n-                // Error if prohibited, or can't inherit anything from a container\n+                // Error if prohibited, or can't inherit anything from a container.\n                 if kind == AnnotationKind::Prohibited ||\n                    (kind == AnnotationKind::Container &&\n                     stab.level.is_stable() &&"}, {"sha": "b4615aeb0db151959eb97f8df82caf29eb0dc7b1", "filename": "src/librustc/mir/interpret/error.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/35585c499f1466037b3788598756e1eb0009f51f/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35585c499f1466037b3788598756e1eb0009f51f/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs?ref=35585c499f1466037b3788598756e1eb0009f51f", "patch": "@@ -49,7 +49,8 @@ pub struct ConstEvalErr<'tcx> {\n \n #[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n pub struct FrameInfo<'tcx> {\n-    pub call_site: Span, // this span is in the caller!\n+    /// This span is in the caller.\n+    pub call_site: Span,\n     pub instance: ty::Instance<'tcx>,\n     pub lint_root: Option<hir::HirId>,\n }\n@@ -200,12 +201,12 @@ fn print_backtrace(backtrace: &mut Backtrace) {\n impl<'tcx> From<InterpError<'tcx, u64>> for EvalError<'tcx> {\n     fn from(kind: InterpError<'tcx, u64>) -> Self {\n         let backtrace = match env::var(\"RUST_CTFE_BACKTRACE\") {\n-            // matching RUST_BACKTRACE, we treat \"0\" the same as \"not present\".\n+            // Matching `RUST_BACKTRACE` -- we treat \"0\" the same as \"not present\".\n             Ok(ref val) if val != \"0\" => {\n                 let mut backtrace = Backtrace::new_unresolved();\n \n                 if val == \"immediate\" {\n-                    // Print it now\n+                    // Print it now.\n                     print_backtrace(&mut backtrace);\n                     None\n                 } else {"}, {"sha": "9f22e6a10889178f1af3e305c24432ac09dfa81a", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/35585c499f1466037b3788598756e1eb0009f51f/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35585c499f1466037b3788598756e1eb0009f51f/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=35585c499f1466037b3788598756e1eb0009f51f", "patch": "@@ -662,7 +662,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                             \"{}\",\n                             message.unwrap_or_else(||\n                                 format!(\"the trait bound `{}` is not satisfied{}\",\n-                                         trait_ref.to_predicate(), post_message)\n+                                        trait_ref.to_predicate(), post_message)\n                             ));\n \n                         let explanation =\n@@ -676,15 +676,15 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                             };\n \n                         if let Some(ref s) = label {\n-                            // If it has a custom \"#[rustc_on_unimplemented]\"\n+                            // If it has a custom `#[rustc_on_unimplemented]`\n                             // error message, let's display it as the label!\n                             err.span_label(span, s.as_str());\n                             err.help(&explanation);\n                         } else {\n                             err.span_label(span, explanation);\n                         }\n                         if let Some(ref s) = note {\n-                            // If it has a custom \"#[rustc_on_unimplemented]\" note, let's display it\n+                            // If it has a custom `#[rustc_on_unimplemented]` note, let's display it\n                             err.note(s.as_str());\n                         }\n "}, {"sha": "fc9756d52f55dbda917351ab77b9bad35a169c41", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/35585c499f1466037b3788598756e1eb0009f51f/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35585c499f1466037b3788598756e1eb0009f51f/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=35585c499f1466037b3788598756e1eb0009f51f", "patch": "@@ -1465,9 +1465,9 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         let predicate = self.infcx()\n             .resolve_vars_if_possible(&obligation.predicate);\n \n-        // OK to skip binder because of the nature of the\n+        // Okay to skip binder because of the nature of the\n         // trait-ref-is-knowable check, which does not care about\n-        // bound regions\n+        // bound regions.\n         let trait_ref = predicate.skip_binder().trait_ref;\n \n         let result = coherence::trait_ref_is_knowable(self.tcx(), trait_ref);\n@@ -1853,7 +1853,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         let matching_bounds =\n             all_bounds.filter(|p| p.def_id() == stack.obligation.predicate.def_id());\n \n-        // keep only those bounds which may apply, and propagate overflow if it occurs\n+        // Keep only those bounds which may apply, and propagate overflow if it occurs.\n         let mut param_candidates = vec![];\n         for bound in matching_bounds {\n             let wc = self.evaluate_where_clause(stack, bound.clone())?;\n@@ -1891,9 +1891,9 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             return Ok(());\n         }\n \n-        // OK to skip binder because the substs on generator types never\n+        // Okay to skip binder because the substs on generator types never\n         // touch bound regions, they just capture the in-scope\n-        // type/region parameters\n+        // type/region parameters.\n         let self_ty = *obligation.self_ty().skip_binder();\n         match self_ty.sty {\n             ty::Generator(..) => {\n@@ -1935,7 +1935,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             }\n         };\n \n-        // OK to skip binder because the substs on closure types never\n+        // Okay to skip binder because the substs on closure types never\n         // touch bound regions, they just capture the in-scope\n         // type/region parameters\n         match obligation.self_ty().skip_binder().sty {\n@@ -1985,7 +1985,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             return Ok(());\n         }\n \n-        // OK to skip binder because what we are inspecting doesn't involve bound regions\n+        // Okay to skip binder because what we are inspecting doesn't involve bound regions\n         let self_ty = *obligation.self_ty().skip_binder();\n         match self_ty.sty {\n             ty::Infer(ty::TyVar(_)) => {\n@@ -2042,7 +2042,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         obligation: &TraitObligation<'tcx>,\n         candidates: &mut SelectionCandidateSet<'tcx>,\n     ) -> Result<(), SelectionError<'tcx>> {\n-        // OK to skip binder here because the tests we do below do not involve bound regions\n+        // Okay to skip binder here because the tests we do below do not involve bound regions.\n         let self_ty = *obligation.self_ty().skip_binder();\n         debug!(\"assemble_candidates_from_auto_impls(self_ty={:?})\", self_ty);\n \n@@ -2274,7 +2274,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         obligation: &TraitObligation<'tcx>,\n         candidates: &mut SelectionCandidateSet<'tcx>,\n     ) -> Result<(), SelectionError<'tcx>> {\n-        // OK to skip binder here because the tests we do below do not involve bound regions\n+        // Okay to skip binder here because the tests we do below do not involve bound regions.\n         let self_ty = *obligation.self_ty().skip_binder();\n         debug!(\"assemble_candidates_for_trait_alias(self_ty={:?})\", self_ty);\n \n@@ -3094,7 +3094,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     ) -> Result<VtableFnPointerData<'tcx, PredicateObligation<'tcx>>, SelectionError<'tcx>> {\n         debug!(\"confirm_fn_pointer_candidate({:?})\", obligation);\n \n-        // OK to skip binder; it is reintroduced below\n+        // Okay to skip binder; it is reintroduced below.\n         let self_ty = self.infcx\n             .shallow_resolve(*obligation.self_ty().skip_binder());\n         let sig = self_ty.fn_sig(self.tcx());\n@@ -3172,9 +3172,9 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         &mut self,\n         obligation: &TraitObligation<'tcx>,\n     ) -> Result<VtableGeneratorData<'tcx, PredicateObligation<'tcx>>, SelectionError<'tcx>> {\n-        // OK to skip binder because the substs on generator types never\n+        // Okay to skip binder because the substs on generator types never\n         // touch bound regions, they just capture the in-scope\n-        // type/region parameters\n+        // type/region parameters.\n         let self_ty = self.infcx.shallow_resolve(*obligation.self_ty().skip_binder());\n         let (generator_def_id, substs) = match self_ty.sty {\n             ty::Generator(id, substs, _) => (id, substs),\n@@ -3229,9 +3229,9 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             .fn_trait_kind(obligation.predicate.def_id())\n             .unwrap_or_else(|| bug!(\"closure candidate for non-fn trait {:?}\", obligation));\n \n-        // OK to skip binder because the substs on closure types never\n+        // Okay to skip binder because the substs on closure types never\n         // touch bound regions, they just capture the in-scope\n-        // type/region parameters\n+        // type/region parameters.\n         let self_ty = self.infcx.shallow_resolve(*obligation.self_ty().skip_binder());\n         let (closure_def_id, substs) = match self_ty.sty {\n             ty::Closure(id, substs) => (id, substs),"}, {"sha": "4d382d6c45a76e1ad8d1269cf6b7b14e4a9ea793", "filename": "src/librustc/traits/structural_impls.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/35585c499f1466037b3788598756e1eb0009f51f/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35585c499f1466037b3788598756e1eb0009f51f/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs?ref=35585c499f1466037b3788598756e1eb0009f51f", "patch": "@@ -10,11 +10,11 @@ use std::fmt;\n use std::rc::Rc;\n use std::collections::{BTreeSet, BTreeMap};\n \n-// structural impls for the structs in traits\n+// Structural impls for the structs in `traits`.\n \n impl<'tcx, T: fmt::Debug> fmt::Debug for Normalized<'tcx, T> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"Normalized({:?},{:?})\", self.value, self.obligations)\n+        write!(f, \"Normalized({:?}, {:?})\", self.value, self.obligations)\n     }\n }\n \n@@ -23,13 +23,13 @@ impl<'tcx, O: fmt::Debug> fmt::Debug for traits::Obligation<'tcx, O> {\n         if ty::tls::with(|tcx| tcx.sess.verbose()) {\n             write!(\n                 f,\n-                \"Obligation(predicate={:?},cause={:?},param_env={:?},depth={})\",\n+                \"Obligation(predicate={:?}, cause={:?}, param_env={:?}, depth={})\",\n                 self.predicate, self.cause, self.param_env, self.recursion_depth\n             )\n         } else {\n             write!(\n                 f,\n-                \"Obligation(predicate={:?},depth={})\",\n+                \"Obligation(predicate={:?}, depth={})\",\n                 self.predicate, self.recursion_depth\n             )\n         }"}, {"sha": "e60022033cc542d6007e4ca6731b89dd42c01ec8", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/35585c499f1466037b3788598756e1eb0009f51f/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35585c499f1466037b3788598756e1eb0009f51f/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=35585c499f1466037b3788598756e1eb0009f51f", "patch": "@@ -1706,21 +1706,21 @@ impl<'gcx> GlobalCtxt<'gcx> {\n     }\n }\n \n-/// A trait implemented for all X<'a> types which can be safely and\n-/// efficiently converted to X<'tcx> as long as they are part of the\n-/// provided TyCtxt<'tcx>.\n-/// This can be done, for example, for Ty<'tcx> or SubstsRef<'tcx>\n+/// A trait implemented for all `X<'a>` types that can be safely and\n+/// efficiently converted to `X<'tcx>` as long as they are part of the\n+/// provided `TyCtxt<'tcx>`.\n+/// This can be done, for example, for `Ty<'tcx>` or `SubstsRef<'tcx>`\n /// by looking them up in their respective interners.\n ///\n /// However, this is still not the best implementation as it does\n /// need to compare the components, even for interned values.\n-/// It would be more efficient if TypedArena provided a way to\n+/// It would be more efficient if `TypedArena` provided a way to\n /// determine whether the address is in the allocated range.\n ///\n /// None is returned if the value or one of the components is not part\n /// of the provided context.\n-/// For Ty, None can be returned if either the type interner doesn't\n-/// contain the TyKind key or if the address of the interned\n+/// For `Ty`, `None` can be returned if either the type interner doesn't\n+/// contain the `TyKind` key or if the address of the interned\n /// pointer differs. The latter case is possible if a primitive type,\n /// e.g., `()` or `u8`, was interned in a different context.\n pub trait Lift<'tcx>: fmt::Debug {"}, {"sha": "69bf05c66f394eda1df54674e9db5c322226a746", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/35585c499f1466037b3788598756e1eb0009f51f/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35585c499f1466037b3788598756e1eb0009f51f/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=35585c499f1466037b3788598756e1eb0009f51f", "patch": "@@ -1090,7 +1090,7 @@ pub enum Predicate<'tcx> {\n     /// See the `ProjectionPredicate` struct for details.\n     Projection(PolyProjectionPredicate<'tcx>),\n \n-    /// no syntax: `T` well-formed\n+    /// No syntax: `T` well-formed.\n     WellFormed(Ty<'tcx>),\n \n     /// Trait must be object-safe.\n@@ -1245,19 +1245,17 @@ impl<'tcx> TraitPredicate<'tcx> {\n \n impl<'tcx> PolyTraitPredicate<'tcx> {\n     pub fn def_id(&self) -> DefId {\n-        // ok to skip binder since trait def-id does not care about regions\n+        // Ok to skip binder since trait def-ID does not care about regions.\n         self.skip_binder().def_id()\n     }\n }\n \n #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord,\n          Hash, Debug, RustcEncodable, RustcDecodable, HashStable)]\n-pub struct OutlivesPredicate<A,B>(pub A, pub B); // `A: B`\n-pub type PolyOutlivesPredicate<A,B> = ty::Binder<OutlivesPredicate<A,B>>;\n-pub type RegionOutlivesPredicate<'tcx> = OutlivesPredicate<ty::Region<'tcx>,\n-                                                           ty::Region<'tcx>>;\n-pub type TypeOutlivesPredicate<'tcx> = OutlivesPredicate<Ty<'tcx>,\n-                                                         ty::Region<'tcx>>;\n+pub struct OutlivesPredicate<A, B>(pub A, pub B); // `A: B`\n+pub type PolyOutlivesPredicate<A, B> = ty::Binder<OutlivesPredicate<A, B>>;\n+pub type RegionOutlivesPredicate<'tcx> = OutlivesPredicate<ty::Region<'tcx>, ty::Region<'tcx>>;\n+pub type TypeOutlivesPredicate<'tcx> = OutlivesPredicate<Ty<'tcx>, ty::Region<'tcx>>;\n pub type PolyRegionOutlivesPredicate<'tcx> = ty::Binder<RegionOutlivesPredicate<'tcx>>;\n pub type PolyTypeOutlivesPredicate<'tcx> = ty::Binder<TypeOutlivesPredicate<'tcx>>;\n \n@@ -1314,7 +1312,7 @@ impl<'tcx> PolyProjectionPredicate<'tcx> {\n     /// Note that this is not the `DefId` of the `TraitRef` containing this\n     /// associated type, which is in `tcx.associated_item(projection_def_id()).container`.\n     pub fn projection_def_id(&self) -> DefId {\n-        // okay to skip binder since trait def-id does not care about regions\n+        // Ok to skip binder since trait def-ID does not care about regions.\n         self.skip_binder().projection_ty.item_def_id\n     }\n }\n@@ -1371,7 +1369,7 @@ impl<'tcx> ToPredicate<'tcx> for PolyProjectionPredicate<'tcx> {\n     }\n }\n \n-// A custom iterator used by Predicate::walk_tys.\n+// A custom iterator used by `Predicate::walk_tys`.\n enum WalkTysIter<'tcx, I, J, K>\n     where I: Iterator<Item = Ty<'tcx>>,\n           J: Iterator<Item = Ty<'tcx>>,\n@@ -1505,7 +1503,7 @@ impl<'tcx> Predicate<'tcx> {\n ///\n /// Example:\n ///\n-///     struct Foo<T,U:Bar<T>> { ... }\n+///     struct Foo<T, U: Bar<T>> { ... }\n ///\n /// Here, the `GenericPredicates` for `Foo` would contain a list of bounds like\n /// `[[], [U:Bar<T>]]`. Now if there were some particular reference\n@@ -2785,10 +2783,10 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                 e.span\n             }\n             Some(f) => {\n-                bug!(\"Node id {} is not an expr: {:?}\", id, f);\n+                bug!(\"node-ID {} is not an expr: {:?}\", id, f);\n             }\n             None => {\n-                bug!(\"Node id {} is not present in the node map\", id);\n+                bug!(\"node-ID {} is not present in the node map\", id);\n             }\n         }\n     }"}, {"sha": "c2760ccb0c0a23a65191765e7a9fb6ab83dd1248", "filename": "src/librustc/ty/query/plumbing.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/35585c499f1466037b3788598756e1eb0009f51f/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35585c499f1466037b3788598756e1eb0009f51f/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs?ref=35585c499f1466037b3788598756e1eb0009f51f", "patch": "@@ -96,12 +96,12 @@ pub(super) struct JobOwner<'a, 'tcx: 'a, Q: QueryDescription<'tcx> + 'a> {\n }\n \n impl<'a, 'tcx, Q: QueryDescription<'tcx>> JobOwner<'a, 'tcx, Q> {\n-    /// Either gets a JobOwner corresponding the query, allowing us to\n+    /// Either gets a `JobOwner` corresponding the query, allowing us to\n     /// start executing the query, or it returns with the result of the query.\n     /// If the query is executing elsewhere, this will wait for it.\n     /// If the query panicked, this will silently panic.\n     ///\n-    /// This function is inlined because that results in a noticeable speedup\n+    /// This function is inlined because that results in a noticeable speed-up\n     /// for some compile-time benchmarks.\n     #[inline(always)]\n     pub(super) fn try_get(\n@@ -126,9 +126,9 @@ impl<'a, 'tcx, Q: QueryDescription<'tcx>> JobOwner<'a, 'tcx, Q> {\n                 Entry::Occupied(entry) => {\n                     match *entry.get() {\n                         QueryResult::Started(ref job) => {\n-                            //For parallel queries, we'll block and wait until the query running\n-                            //in another thread has completed. Record how long we wait in the\n-                            //self-profiler\n+                            // For parallel queries, we'll block and wait until the query running\n+                            // in another thread has completed. Record how long we wait in the\n+                            // self-profiler.\n                             #[cfg(parallel_compiler)]\n                             tcx.sess.profiler(|p| p.query_blocked_start(Q::NAME));\n \n@@ -138,7 +138,7 @@ impl<'a, 'tcx, Q: QueryDescription<'tcx>> JobOwner<'a, 'tcx, Q> {\n                     }\n                 }\n                 Entry::Vacant(entry) => {\n-                    // No job entry for this query. Return a new one to be started later\n+                    // No job entry for this query. Return a new one to be started later.\n                     return tls::with_related_context(tcx, |icx| {\n                         // Create the `parent` variable before `info`. This allows LLVM\n                         // to elide the move of `info`\n@@ -161,14 +161,14 @@ impl<'a, 'tcx, Q: QueryDescription<'tcx>> JobOwner<'a, 'tcx, Q> {\n             mem::drop(lock);\n \n             // If we are single-threaded we know that we have cycle error,\n-            // so we just return the error\n+            // so we just return the error.\n             #[cfg(not(parallel_compiler))]\n             return TryGetJob::Cycle(cold_path(|| {\n                 Q::handle_cycle_error(tcx, job.find_cycle_in_stack(tcx, span))\n             }));\n \n             // With parallel queries we might just have to wait on some other\n-            // thread\n+            // thread.\n             #[cfg(parallel_compiler)]\n             {\n                 let result = job.r#await(tcx, span);\n@@ -636,8 +636,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                                           profq_query_msg!(Q::NAME.as_str(), self, key))\n         );\n \n-        // We may be concurrently trying both execute and force a query\n-        // Ensure that only one of them runs the query\n+        // We may be concurrently trying both execute and force a query.\n+        // Ensure that only one of them runs the query.\n         let job = match JobOwner::try_get(self, span, &key) {\n             TryGetJob::NotYetStarted(job) => job,\n             TryGetJob::Cycle(_) |\n@@ -731,7 +731,7 @@ macro_rules! define_queries_inner {\n                 let mut jobs = Vec::new();\n \n                 // We use try_lock here since we are only called from the\n-                // deadlock handler, and this shouldn't be locked\n+                // deadlock handler, and this shouldn't be locked.\n                 $(\n                     jobs.extend(\n                         self.$name.try_lock().unwrap().active.values().filter_map(|v|"}, {"sha": "9b4029f409ba4890c10552dc749df6f48662cec2", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/35585c499f1466037b3788598756e1eb0009f51f/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35585c499f1466037b3788598756e1eb0009f51f/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=35585c499f1466037b3788598756e1eb0009f51f", "patch": "@@ -546,7 +546,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.def_key(def_id).disambiguated_data.data == DefPathData::Ctor\n     }\n \n-    /// Given the `DefId` of a fn or closure, returns the `DefId` of\n+    /// Given the def-ID of a fn or closure, returns the def-ID of\n     /// the innermost fn item that the closure is contained within.\n     /// This is a significant `DefId` because, when we do\n     /// type-checking, we type-check this fn item and all of its"}, {"sha": "2140018223c34cbfc48e443b27e80ab35a1b49ee", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/35585c499f1466037b3788598756e1eb0009f51f/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35585c499f1466037b3788598756e1eb0009f51f/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=35585c499f1466037b3788598756e1eb0009f51f", "patch": "@@ -18,7 +18,7 @@ use crate::dep_graph::{DepNode};\n use lazy_static;\n use crate::session::Session;\n \n-// The name of the associated type for `Fn` return types\n+// The name of the associated type for `Fn` return types.\n pub const FN_OUTPUT_NAME: Symbol = sym::Output;\n \n // Useful type to use with `Result<>` indicate that an error has already\n@@ -45,16 +45,16 @@ fn panic_hook(info: &panic::PanicInfo<'_>) {\n         TyCtxt::try_print_query_stack();\n     }\n \n-        #[cfg(windows)]\n-        unsafe {\n-            if env::var(\"RUSTC_BREAK_ON_ICE\").is_ok() {\n-                extern \"system\" {\n-                    fn DebugBreak();\n-                }\n-                // Trigger a debugger if we crashed during bootstrap\n-                DebugBreak();\n+    #[cfg(windows)]\n+    unsafe {\n+        if env::var(\"RUSTC_BREAK_ON_ICE\").is_ok() {\n+            extern \"system\" {\n+                fn DebugBreak();\n             }\n+            // Trigger a debugger if we crashed during bootstrap.\n+            DebugBreak();\n         }\n+    }\n }\n \n pub fn install_panic_hook() {\n@@ -80,42 +80,42 @@ pub struct QueryMsg {\n }\n \n /// A sequence of these messages induce a trace of query-based incremental compilation.\n-/// FIXME(matthewhammer): Determine whether we should include cycle detection here or not.\n+// FIXME(matthewhammer): Determine whether we should include cycle detection here or not.\n #[derive(Clone,Debug)]\n pub enum ProfileQueriesMsg {\n-    /// begin a timed pass\n+    /// Begin a timed pass.\n     TimeBegin(String),\n-    /// end a timed pass\n+    /// End a timed pass.\n     TimeEnd,\n-    /// begin a task (see dep_graph::graph::with_task)\n+    /// Begin a task (see `dep_graph::graph::with_task`).\n     TaskBegin(DepNode),\n-    /// end a task\n+    /// End a task.\n     TaskEnd,\n-    /// begin a new query\n-    /// can't use `Span` because queries are sent to other thread\n+    /// Begin a new query.\n+    /// Cannot use `Span` because queries are sent to other thread.\n     QueryBegin(SpanData, QueryMsg),\n-    /// query is satisfied by using an already-known value for the given key\n+    /// Query is satisfied by using an already-known value for the given key.\n     CacheHit,\n-    /// query requires running a provider; providers may nest, permitting queries to nest.\n+    /// Query requires running a provider; providers may nest, permitting queries to nest.\n     ProviderBegin,\n-    /// query is satisfied by a provider terminating with a value\n+    /// Query is satisfied by a provider terminating with a value.\n     ProviderEnd,\n-    /// dump a record of the queries to the given path\n+    /// Dump a record of the queries to the given path.\n     Dump(ProfQDumpParams),\n-    /// halt the profiling/monitoring background thread\n+    /// Halt the profiling/monitoring background thread.\n     Halt\n }\n \n-/// If enabled, send a message to the profile-queries thread\n+/// If enabled, send a message to the profile-queries thread.\n pub fn profq_msg(sess: &Session, msg: ProfileQueriesMsg) {\n     if let Some(s) = sess.profile_channel.borrow().as_ref() {\n         s.send(msg).unwrap()\n     } else {\n-        // Do nothing\n+        // Do nothing.\n     }\n }\n \n-/// Set channel for profile queries channel\n+/// Set channel for profile queries channel.\n pub fn profq_set_chan(sess: &Session, s: Sender<ProfileQueriesMsg>) -> bool {\n     let mut channel = sess.profile_channel.borrow_mut();\n     if channel.is_none() {"}, {"sha": "af10404cba395fb75186e29ff232898a93be61df", "filename": "src/librustc_borrowck/dataflow.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/35585c499f1466037b3788598756e1eb0009f51f/src%2Flibrustc_borrowck%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35585c499f1466037b3788598756e1eb0009f51f/src%2Flibrustc_borrowck%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fdataflow.rs?ref=35585c499f1466037b3788598756e1eb0009f51f", "patch": "@@ -19,7 +19,6 @@ use rustc::hir;\n use rustc::hir::intravisit;\n use rustc::hir::print as pprust;\n \n-\n #[derive(Copy, Clone, Debug)]\n pub enum EntryOrExit {\n     Entry,\n@@ -92,7 +91,7 @@ fn get_cfg_indices<'a>(id: hir::ItemLocalId,\n     index.get(&id).map_or(&[], |v| &v[..])\n }\n \n-impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n+impl<'a, 'tcx, O: DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n     fn has_bitset_for_local_id(&self, n: hir::ItemLocalId) -> bool {\n         assert!(n != hir::DUMMY_ITEM_LOCAL_ID);\n         self.local_id_to_index.contains_key(&n)\n@@ -225,7 +224,7 @@ pub enum KillFrom {\n     Execution,\n }\n \n-impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n+impl<'a, 'tcx, O: DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n     pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                analysis_name: &'static str,\n                body: Option<&hir::Body>,\n@@ -500,8 +499,8 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n     }\n }\n \n-impl<'a, 'tcx, O:DataFlowOperator+Clone+'static> DataFlowContext<'a, 'tcx, O> {\n-//                                ^^^^^^^^^^^^^ only needed for pretty printing\n+// N.B. `Clone + 'static` only needed for pretty printing.\n+impl<'a, 'tcx, O: DataFlowOperator + Clone + 'static> DataFlowContext<'a, 'tcx, O> {\n     pub fn propagate(&mut self, cfg: &cfg::CFG, body: &hir::Body) {\n         //! Performs the data flow analysis.\n \n@@ -538,7 +537,7 @@ impl<'a, 'tcx, O:DataFlowOperator+Clone+'static> DataFlowContext<'a, 'tcx, O> {\n     }\n }\n \n-impl<'a, 'b, 'tcx, O:DataFlowOperator> PropagationContext<'a, 'b, 'tcx, O> {\n+impl<'a, 'b, 'tcx, O: DataFlowOperator> PropagationContext<'a, 'b, 'tcx, O> {\n     fn walk_cfg(&mut self,\n                 cfg: &cfg::CFG,\n                 nodes_po: &[CFGIndex],\n@@ -547,7 +546,7 @@ impl<'a, 'b, 'tcx, O:DataFlowOperator> PropagationContext<'a, 'b, 'tcx, O> {\n                bits_to_string(in_out), self.dfcx.analysis_name);\n         assert!(self.dfcx.bits_per_id > 0);\n \n-        // Iterate over nodes in reverse postorder\n+        // Iterate over nodes in reverse post-order.\n         for &node_index in nodes_po.iter().rev() {\n             let node = cfg.graph.node(node_index);\n             debug!(\"DataFlowContext::walk_cfg idx={:?} id={:?} begin in_out={}\",\n@@ -631,9 +630,9 @@ fn bits_to_string(words: &[usize]) -> String {\n }\n \n #[inline]\n-fn bitwise<Op:BitwiseOperator>(out_vec: &mut [usize],\n-                               in_vec: &[usize],\n-                               op: &Op) -> bool {\n+fn bitwise<Op: BitwiseOperator>(out_vec: &mut [usize],\n+                                in_vec: &[usize],\n+                                op: &Op) -> bool {\n     assert_eq!(out_vec.len(), in_vec.len());\n     let mut changed = false;\n     for (out_elt, in_elt) in out_vec.iter_mut().zip(in_vec) {"}, {"sha": "f32dc4312654036c42182689bf465417c3dc9dda", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/35585c499f1466037b3788598756e1eb0009f51f/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35585c499f1466037b3788598756e1eb0009f51f/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=35585c499f1466037b3788598756e1eb0009f51f", "patch": "@@ -937,8 +937,8 @@ fn codegen_msvc_try(\n     bx.store(ret, dest, i32_align);\n }\n \n-// Definition of the standard \"try\" function for Rust using the GNU-like model\n-// of exceptions (e.g., the normal semantics of LLVM's landingpad and invoke\n+// Definition of the standard `try` function for Rust using the GNU-like model\n+// of exceptions (e.g., the normal semantics of LLVM's `landingpad` and `invoke`\n // instructions).\n //\n // This codegen is a little surprising because we always call a shim"}, {"sha": "0ba5451bd72f52a2e8cfe9a92fd6b324064fbaee", "filename": "src/librustc_codegen_ssa/back/link.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/35585c499f1466037b3788598756e1eb0009f51f/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35585c499f1466037b3788598756e1eb0009f51f/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs?ref=35585c499f1466037b3788598756e1eb0009f51f", "patch": "@@ -1127,10 +1127,10 @@ fn link_args<'a, B: ArchiveBuilder<'a>>(cmd: &mut dyn Linker,\n     // For this reason, we have organized the arguments we pass to the linker as\n     // such:\n     //\n-    //  1. The local object that LLVM just generated\n-    //  2. Local native libraries\n-    //  3. Upstream rust libraries\n-    //  4. Upstream native libraries\n+    // 1. The local object that LLVM just generated\n+    // 2. Local native libraries\n+    // 3. Upstream rust libraries\n+    // 4. Upstream native libraries\n     //\n     // The rationale behind this ordering is that those items lower down in the\n     // list can't depend on items higher up in the list. For example nothing can"}, {"sha": "7e5ee25d8ef78dd7ae3385ca2a9f390a78f03a7a", "filename": "src/librustc_codegen_ssa/mir/block.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/35585c499f1466037b3788598756e1eb0009f51f/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35585c499f1466037b3788598756e1eb0009f51f/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs?ref=35585c499f1466037b3788598756e1eb0009f51f", "patch": "@@ -967,7 +967,7 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                         bx.range_metadata(llval, 0..2);\n                     }\n                 }\n-                // We store bools as i8 so we need to truncate to i1.\n+                // We store bools as `i8` so we need to truncate to `i1`.\n                 llval = base::to_immediate(bx, llval, arg.layout);\n             }\n         }\n@@ -1097,7 +1097,7 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         fn_ret: &ArgType<'tcx, Ty<'tcx>>,\n         llargs: &mut Vec<Bx::Value>, is_intrinsic: bool\n     ) -> ReturnDest<'tcx, Bx::Value> {\n-        // If the return is ignored, we can just return a do-nothing ReturnDest\n+        // If the return is ignored, we can just return a do-nothing `ReturnDest`.\n         if fn_ret.is_ignore() {\n             return ReturnDest::Nothing;\n         }\n@@ -1106,8 +1106,8 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 LocalRef::Place(dest) => dest,\n                 LocalRef::UnsizedPlace(_) => bug!(\"return type must be sized\"),\n                 LocalRef::Operand(None) => {\n-                    // Handle temporary places, specifically Operand ones, as\n-                    // they don't have allocas\n+                    // Handle temporary places, specifically `Operand` ones, as\n+                    // they don't have `alloca`s.\n                     return if fn_ret.is_indirect() {\n                         // Odd, but possible, case, we have an operand temporary,\n                         // but the calling convention has an indirect return.\n@@ -1117,8 +1117,8 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                         ReturnDest::IndirectOperand(tmp, index)\n                     } else if is_intrinsic {\n                         // Currently, intrinsics always need a location to store\n-                        // the result. so we create a temporary alloca for the\n-                        // result\n+                        // the result, so we create a temporary `alloca` for the\n+                        // result.\n                         let tmp = PlaceRef::alloca(bx, fn_ret.layout, \"tmp_ret\");\n                         tmp.storage_live(bx);\n                         ReturnDest::IndirectOperand(tmp, index)\n@@ -1137,7 +1137,7 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             if dest.align < dest.layout.align.abi {\n                 // Currently, MIR code generation does not create calls\n                 // that store directly to fields of packed structs (in\n-                // fact, the calls it creates write only to temps),\n+                // fact, the calls it creates write only to temps).\n                 //\n                 // If someone changes that, please update this code path\n                 // to create a temporary.\n@@ -1232,12 +1232,12 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n }\n \n enum ReturnDest<'tcx, V> {\n-    // Do nothing, the return value is indirect or ignored\n+    // Do nothing; the return value is indirect or ignored.\n     Nothing,\n-    // Store the return value to the pointer\n+    // Store the return value to the pointer.\n     Store(PlaceRef<'tcx, V>),\n-    // Stores an indirect return value to an operand local place\n+    // Store an indirect return value to an operand local place.\n     IndirectOperand(PlaceRef<'tcx, V>, mir::Local),\n-    // Stores a direct return value to an operand local place\n+    // Store a direct return value to an operand local place.\n     DirectOperand(mir::Local)\n }"}, {"sha": "27311d0a8fbf1e2480c8a392697fdd9b1eba6d65", "filename": "src/librustc_codegen_ssa/mir/place.rs", "status": "modified", "additions": 23, "deletions": 22, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/35585c499f1466037b3788598756e1eb0009f51f/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35585c499f1466037b3788598756e1eb0009f51f/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs?ref=35585c499f1466037b3788598756e1eb0009f51f", "patch": "@@ -120,7 +120,7 @@ impl<'a, 'tcx: 'a, V: CodegenObject> PlaceRef<'tcx, V> {\n                 bx.struct_gep(self.llval, bx.cx().backend_field_index(self.layout, ix))\n             };\n             PlaceRef {\n-                // HACK(eddyb) have to bitcast pointers until LLVM removes pointee types.\n+                // HACK(eddyb): have to bitcast pointers until LLVM removes pointee types.\n                 llval: bx.pointercast(llval, bx.cx().type_ptr_to(bx.cx().backend_type(field))),\n                 llextra: if bx.cx().type_has_metadata(field.ty) {\n                     self.llextra\n@@ -134,7 +134,7 @@ impl<'a, 'tcx: 'a, V: CodegenObject> PlaceRef<'tcx, V> {\n \n         // Simple cases, which don't need DST adjustment:\n         //   * no metadata available - just log the case\n-        //   * known alignment - sized types, [T], str or a foreign type\n+        //   * known alignment - sized types, `[T]`, `str` or a foreign type\n         //   * packed struct - there is no alignment padding\n         match field.ty.sty {\n             _ if self.llextra.is_none() => {\n@@ -156,18 +156,19 @@ impl<'a, 'tcx: 'a, V: CodegenObject> PlaceRef<'tcx, V> {\n         }\n \n         // We need to get the pointer manually now.\n-        // We do this by casting to a *i8, then offsetting it by the appropriate amount.\n+        // We do this by casting to a `*i8`, then offsetting it by the appropriate amount.\n         // We do this instead of, say, simply adjusting the pointer from the result of a GEP\n         // because the field may have an arbitrary alignment in the LLVM representation\n         // anyway.\n         //\n         // To demonstrate:\n-        //   struct Foo<T: ?Sized> {\n-        //      x: u16,\n-        //      y: T\n-        //   }\n         //\n-        // The type Foo<Foo<Trait>> is represented in LLVM as { u16, { u16, u8 }}, meaning that\n+        //     struct Foo<T: ?Sized> {\n+        //         x: u16,\n+        //         y: T\n+        //     }\n+        //\n+        // The type `Foo<Foo<Trait>>` is represented in LLVM as `{ u16, { u16, u8 }}`, meaning that\n         // the `y` field has 16-bit alignment.\n \n         let meta = self.llextra;\n@@ -180,21 +181,21 @@ impl<'a, 'tcx: 'a, V: CodegenObject> PlaceRef<'tcx, V> {\n         // Bump the unaligned offset up to the appropriate alignment using the\n         // following expression:\n         //\n-        //   (unaligned offset + (align - 1)) & -align\n+        //     (unaligned offset + (align - 1)) & -align\n \n-        // Calculate offset\n+        // Calculate offset.\n         let align_sub_1 = bx.sub(unsized_align, bx.cx().const_usize(1u64));\n         let and_lhs = bx.add(unaligned_offset, align_sub_1);\n         let and_rhs = bx.neg(unsized_align);\n         let offset = bx.and(and_lhs, and_rhs);\n \n         debug!(\"struct_field_ptr: DST field offset: {:?}\", offset);\n \n-        // Cast and adjust pointer\n+        // Cast and adjust pointer.\n         let byte_ptr = bx.pointercast(self.llval, bx.cx().type_i8p());\n         let byte_ptr = bx.gep(byte_ptr, &[offset]);\n \n-        // Finally, cast back to the type expected\n+        // Finally, cast back to the type expected.\n         let ll_fty = bx.cx().backend_type(field);\n         debug!(\"struct_field_ptr: Field type is {:?}\", ll_fty);\n \n@@ -235,7 +236,7 @@ impl<'a, 'tcx: 'a, V: CodegenObject> PlaceRef<'tcx, V> {\n                     // We use `i1` for bytes that are always `0` or `1`,\n                     // e.g., `#[repr(i8)] enum E { A, B }`, but we can't\n                     // let LLVM interpret the `i1` as signed, because\n-                    // then `i1 1` (i.e., E::B) is effectively `i8 -1`.\n+                    // then `i1 1` (i.e., `E::B`) is effectively `i8 -1`.\n                     layout::Int(_, signed) => !discr_scalar.is_bool() && signed,\n                     _ => false\n                 };\n@@ -248,9 +249,9 @@ impl<'a, 'tcx: 'a, V: CodegenObject> PlaceRef<'tcx, V> {\n             } => {\n                 let niche_llty = bx.cx().immediate_backend_type(discr.layout);\n                 if niche_variants.start() == niche_variants.end() {\n-                    // FIXME(eddyb) Check the actual primitive type here.\n+                    // FIXME(eddyb): check the actual primitive type here.\n                     let niche_llval = if niche_start == 0 {\n-                        // HACK(eddyb) Using `c_null` as it works on all types.\n+                        // HACK(eddyb): using `c_null` as it works on all types.\n                         bx.cx().const_null(niche_llty)\n                     } else {\n                         bx.cx().const_uint_big(niche_llty, niche_start)\n@@ -314,7 +315,7 @@ impl<'a, 'tcx: 'a, V: CodegenObject> PlaceRef<'tcx, V> {\n                 if variant_index != dataful_variant {\n                     if bx.cx().sess().target.target.arch == \"arm\" ||\n                        bx.cx().sess().target.target.arch == \"aarch64\" {\n-                        // Issue #34427: As workaround for LLVM bug on ARM,\n+                        // FIXME(#34427): as workaround for LLVM bug on ARM,\n                         // use memset of 0 before assigning niche value.\n                         let fill_byte = bx.cx().const_u8(0);\n                         let size = bx.cx().const_usize(self.layout.size.bytes());\n@@ -326,9 +327,9 @@ impl<'a, 'tcx: 'a, V: CodegenObject> PlaceRef<'tcx, V> {\n                     let niche_value = variant_index.as_u32() - niche_variants.start().as_u32();\n                     let niche_value = (niche_value as u128)\n                         .wrapping_add(niche_start);\n-                    // FIXME(eddyb) Check the actual primitive type here.\n+                    // FIXME(eddyb): check the actual primitive type here.\n                     let niche_llval = if niche_value == 0 {\n-                        // HACK(eddyb) Using `c_null` as it works on all types.\n+                        // HACK(eddyb): using `c_null` as it works on all types.\n                         bx.cx().const_null(niche_llty)\n                     } else {\n                         bx.cx().const_uint_big(niche_llty, niche_value)\n@@ -429,10 +430,10 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                         _ => bug!(\"promoteds should have an allocation: {:?}\", val),\n                     },\n                     Err(_) => {\n-                        // this is unreachable as long as runtime\n+                        // This is unreachable as long as runtime\n                         // and compile-time agree on values\n-                        // With floats that won't always be true\n-                        // so we generate an abort\n+                        // With floats that won't always be true,\n+                        // so we generate an abort.\n                         bx.abort();\n                         let llval = bx.cx().const_undef(\n                             bx.cx().type_ptr_to(bx.cx().backend_type(layout))\n@@ -502,7 +503,7 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                         }\n \n                         // Cast the place pointer type to the new\n-                        // array or slice type (*[%_; new_len]).\n+                        // array or slice type (`*[%_; new_len]`).\n                         subslice.llval = bx.pointercast(subslice.llval,\n                             bx.cx().type_ptr_to(bx.cx().backend_type(subslice.layout)));\n "}, {"sha": "937085c8ad8e8e1e17ab6e75479cfbb207645353", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/35585c499f1466037b3788598756e1eb0009f51f/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35585c499f1466037b3788598756e1eb0009f51f/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=35585c499f1466037b3788598756e1eb0009f51f", "patch": "@@ -196,7 +196,7 @@ declare_lint_pass!(UnsafeCode => [UNSAFE_CODE]);\n \n impl UnsafeCode {\n     fn report_unsafe(&self, cx: &EarlyContext<'_>, span: Span, desc: &'static str) {\n-        // This comes from a macro that has #[allow_internal_unsafe].\n+        // This comes from a macro that has `#[allow_internal_unsafe]`.\n         if span.allows_unsafe() {\n             return;\n         }\n@@ -216,7 +216,7 @@ impl EarlyLintPass for UnsafeCode {\n \n     fn check_expr(&mut self, cx: &EarlyContext<'_>, e: &ast::Expr) {\n         if let ast::ExprKind::Block(ref blk, _) = e.node {\n-            // Don't warn about generated blocks, that'll just pollute the output.\n+            // Don't warn about generated blocks; that'll just pollute the output.\n             if blk.rules == ast::BlockCheckMode::Unsafe(ast::UserProvided) {\n                 self.report_unsafe(cx, blk.span, \"usage of an `unsafe` block\");\n             }\n@@ -335,7 +335,7 @@ impl MissingDoc {\n \n         // Only check publicly-visible items, using the result from the privacy pass.\n         // It's an option so the crate root can also use this function (it doesn't\n-        // have a NodeId).\n+        // have a `NodeId`).\n         if let Some(id) = id {\n             if !cx.access_levels.is_exported(id) {\n                 return;\n@@ -389,7 +389,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n             hir::ItemKind::Struct(..) => \"a struct\",\n             hir::ItemKind::Union(..) => \"a union\",\n             hir::ItemKind::Trait(.., ref trait_item_refs) => {\n-                // Issue #11592, traits are always considered exported, even when private.\n+                // Issue #11592: traits are always considered exported, even when private.\n                 if let hir::VisibilityKind::Inherited = it.vis.node {\n                     self.private_traits.insert(it.hir_id);\n                     for trait_item_ref in trait_item_refs {\n@@ -401,7 +401,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n             }\n             hir::ItemKind::Ty(..) => \"a type alias\",\n             hir::ItemKind::Impl(.., Some(ref trait_ref), _, ref impl_item_refs) => {\n-                // If the trait is private, add the impl items to private_traits so they don't get\n+                // If the trait is private, add the impl items to `private_traits` so they don't get\n                 // reported for missing docs.\n                 let real_trait = trait_ref.path.res.def_id();\n                 if let Some(hir_id) = cx.tcx.hir().as_local_hir_id(real_trait) {\n@@ -1215,7 +1215,6 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TrivialConstraints {\n         use rustc::ty::fold::TypeFoldable;\n         use rustc::ty::Predicate::*;\n \n-\n         if cx.tcx.features().trivial_bounds {\n             let def_id = cx.tcx.hir().local_def_id_from_hir_id(item.hir_id);\n             let predicates = cx.tcx.predicates_of(def_id);\n@@ -1464,7 +1463,7 @@ impl KeywordIdents {\n             _ => return,\n         };\n \n-        // don't lint `r#foo`\n+        // Don't lint `r#foo`.\n         if cx.sess.parse_sess.raw_identifier_spans.borrow().contains(&ident.span) {\n             return;\n         }\n@@ -1717,8 +1716,6 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ExplicitOutlivesRequirements {\n                 );\n                 err.emit();\n             }\n-\n         }\n     }\n-\n }"}, {"sha": "3bf0f7e04d29540ebcbc41131e63bde0303bd621", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/35585c499f1466037b3788598756e1eb0009f51f/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35585c499f1466037b3788598756e1eb0009f51f/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs?ref=35585c499f1466037b3788598756e1eb0009f51f", "patch": "@@ -576,7 +576,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// Adds a suggestion to errors where a `impl Trait` is returned.\n     ///\n     /// ```text\n-    /// help: to allow this impl Trait to capture borrowed data with lifetime `'1`, add `'_` as\n+    /// help: to allow this `impl Trait` to capture borrowed data with lifetime `'1`, add `'_` as\n     ///       a constraint\n     ///    |\n     /// LL |     fn iter_values_anon(&self) -> impl Iterator<Item=u32> + 'a {\n@@ -652,7 +652,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                         diag.span_suggestion(\n                             span,\n                             &format!(\n-                                \"to allow this impl Trait to capture borrowed data with lifetime \\\n+                                \"to allow this `impl Trait` to capture borrowed data with lifetime \\\n                                  `{}`, add `{}` as a constraint\",\n                                 fr_name, suggestable_fr_name,\n                             ),"}, {"sha": "7ca54a430a505531b9d816b77273355a5e701032", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/35585c499f1466037b3788598756e1eb0009f51f/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35585c499f1466037b3788598756e1eb0009f51f/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=35585c499f1466037b3788598756e1eb0009f51f", "patch": "@@ -289,9 +289,9 @@ pub enum BlockFrame {\n     /// Evaluation is currently within a statement.\n     ///\n     /// Examples include:\n-    ///  1. `EXPR;`\n-    ///  2. `let _ = EXPR;`\n-    ///  3. `let x = EXPR;`\n+    /// 1. `EXPR;`\n+    /// 2. `let _ = EXPR;`\n+    /// 3. `let x = EXPR;`\n     Statement {\n         /// If true, then statement discards result from evaluating\n         /// the expression (such as examples 1 and 2 above)."}, {"sha": "2c84364216633f9431aecc7eb103e4f6a3fd1c77", "filename": "src/librustc_mir/monomorphize/partitioning.rs", "status": "modified", "additions": 25, "deletions": 30, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/35585c499f1466037b3788598756e1eb0009f51f/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35585c499f1466037b3788598756e1eb0009f51f/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs?ref=35585c499f1466037b3788598756e1eb0009f51f", "patch": "@@ -90,7 +90,7 @@\n //!\n //! Note though that as a side-effect of creating a codegen units per\n //! source-level module, functions from the same module will be available for\n-//! inlining, even when they are not marked #[inline].\n+//! inlining, even when they are not marked `#[inline]`.\n \n use std::collections::hash_map::Entry;\n use std::cmp;\n@@ -152,7 +152,7 @@ pub fn partition<'a, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // In the next step, we use the inlining map to determine which additional\n     // monomorphizations have to go into each codegen unit. These additional\n     // monomorphizations can be drop-glue, functions from external crates, and\n-    // local functions the definition of which is marked with #[inline].\n+    // local functions the definition of which is marked with `#[inline]`.\n     let mut post_inlining = place_inlined_mono_items(initial_partitioning,\n                                                             inlining_map);\n \n@@ -166,7 +166,7 @@ pub fn partition<'a, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         internalize_symbols(tcx, &mut post_inlining, inlining_map);\n     }\n \n-    // Finally, sort by codegen unit name, so that we get deterministic results\n+    // Finally, sort by codegen unit name, so that we get deterministic results.\n     let PostInliningPartitioning {\n         codegen_units: mut result,\n         mono_item_placements: _,\n@@ -258,8 +258,8 @@ fn place_root_mono_items<'a, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         roots.insert(mono_item);\n     }\n \n-    // always ensure we have at least one CGU; otherwise, if we have a\n-    // crate with just types (for example), we could wind up with no CGU\n+    // Always ensure we have at least one CGU; otherwise, if we have a\n+    // crate with just types (for example), we could wind up with no CGU.\n     if codegen_units.is_empty() {\n         let codegen_unit_name = fallback_cgu_name(cgu_name_builder);\n         codegen_units.insert(codegen_unit_name.clone(),\n@@ -300,10 +300,10 @@ fn mono_item_visibility(\n     export_generics: bool,\n ) -> Visibility {\n     let instance = match mono_item {\n-        // This is pretty complicated, go below\n+        // This is pretty complicated; see below.\n         MonoItem::Fn(instance) => instance,\n \n-        // Misc handling for generics and such, but otherwise\n+        // Misc handling for generics and such, but otherwise:\n         MonoItem::Static(def_id) => {\n             return if tcx.is_reachable_non_generic(*def_id) {\n                 *can_be_internalized = false;\n@@ -358,11 +358,10 @@ fn mono_item_visibility(\n \n     let is_generic = instance.substs.non_erasable_generics().next().is_some();\n \n-    // Upstream `DefId` instances get different handling than local ones\n+    // Upstream `DefId` instances get different handling than local ones.\n     if !def_id.is_local() {\n         return if export_generics && is_generic {\n-            // If it is a upstream monomorphization\n-            // and we export generics, we must make\n+            // If it is a upstream monomorphization and we export generics, we must make\n             // it available to downstream crates.\n             *can_be_internalized = false;\n             default_visibility(tcx, def_id, true)\n@@ -374,20 +373,16 @@ fn mono_item_visibility(\n     if is_generic {\n         if export_generics {\n             if tcx.is_unreachable_local_definition(def_id) {\n-                // This instance cannot be used\n-                // from another crate.\n+                // This instance cannot be used from another crate.\n                 Visibility::Hidden\n             } else {\n-                // This instance might be useful in\n-                // a downstream crate.\n+                // This instance might be useful in a downstream crate.\n                 *can_be_internalized = false;\n                 default_visibility(tcx, def_id, true)\n             }\n         } else {\n-            // We are not exporting generics or\n-            // the definition is not reachable\n-            // for downstream crates, we can\n-            // internalize its instantiations.\n+            // We are not exporting generics or the definition is not reachable\n+            // for downstream crates, we can internalize its instantiations.\n             Visibility::Hidden\n         }\n     } else {\n@@ -449,19 +444,19 @@ fn default_visibility(tcx: TyCtxt<'_, '_, '_>, id: DefId, is_generic: bool) -> V\n         return Visibility::Default\n     }\n \n-    // Generic functions never have export level C\n+    // Generic functions never have export-level C.\n     if is_generic {\n         return Visibility::Hidden\n     }\n \n     // Things with export level C don't get instantiated in\n-    // downstream crates\n+    // downstream crates.\n     if !id.is_local() {\n         return Visibility::Hidden\n     }\n \n     // C-export level items remain at `Default`, all other internal\n-    // items become `Hidden`\n+    // items become `Hidden`.\n     match tcx.reachable_non_generics(id.krate).get(&id) {\n         Some(SymbolExportLevel::C) => Visibility::Default,\n         _ => Visibility::Hidden,\n@@ -519,26 +514,26 @@ fn place_inlined_mono_items<'tcx>(initial_partitioning: PreInliningPartitioning<\n     let single_codegen_unit = initial_cgus.len() == 1;\n \n     for old_codegen_unit in initial_cgus {\n-        // Collect all items that need to be available in this codegen unit\n+        // Collect all items that need to be available in this codegen unit.\n         let mut reachable = FxHashSet::default();\n         for root in old_codegen_unit.items().keys() {\n             follow_inlining(*root, inlining_map, &mut reachable);\n         }\n \n         let mut new_codegen_unit = CodegenUnit::new(old_codegen_unit.name().clone());\n \n-        // Add all monomorphizations that are not already there\n+        // Add all monomorphizations that are not already there.\n         for mono_item in reachable {\n             if let Some(linkage) = old_codegen_unit.items().get(&mono_item) {\n-                // This is a root, just copy it over\n+                // This is a root, just copy it over.\n                 new_codegen_unit.items_mut().insert(mono_item, *linkage);\n             } else {\n                 if roots.contains(&mono_item) {\n                     bug!(\"GloballyShared mono-item inlined into other CGU: \\\n                           {:?}\", mono_item);\n                 }\n \n-                // This is a cgu-private copy\n+                // This is a CGU-private copy.\n                 new_codegen_unit.items_mut().insert(\n                     mono_item,\n                     (Linkage::Internal, Visibility::Default),\n@@ -547,7 +542,7 @@ fn place_inlined_mono_items<'tcx>(initial_partitioning: PreInliningPartitioning<\n \n             if !single_codegen_unit {\n                 // If there is more than one codegen unit, we need to keep track\n-                // in which codegen units each monomorphization is placed:\n+                // in which codegen units each monomorphization is placed.\n                 match mono_item_placements.entry(mono_item) {\n                     Entry::Occupied(e) => {\n                         let placement = e.into_mut();\n@@ -656,8 +651,8 @@ fn internalize_symbols<'a, 'tcx>(_tcx: TyCtxt<'a, 'tcx, 'tcx>,\n }\n \n fn characteristic_def_id_of_mono_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                                 mono_item: MonoItem<'tcx>)\n-                                                 -> Option<DefId> {\n+                                                mono_item: MonoItem<'tcx>)\n+                                                -> Option<DefId> {\n     match mono_item {\n         MonoItem::Fn(instance) => {\n             let def_id = match instance.def {\n@@ -709,10 +704,10 @@ fn compute_codegen_unit_name(tcx: TyCtxt<'_, '_, '_>,\n                              volatile: bool,\n                              cache: &mut CguNameCache)\n                              -> InternedString {\n-    // Find the innermost module that is not nested within a function\n+    // Find the innermost module that is not nested within a function.\n     let mut current_def_id = def_id;\n     let mut cgu_def_id = None;\n-    // Walk backwards from the item we want to find the module for:\n+    // Walk backwards from the item we want to find the module for.\n     loop {\n         if current_def_id.index == CRATE_DEF_INDEX {\n             if cgu_def_id.is_none() {"}, {"sha": "6a17a84517e4a666f888ef7f72dccd038faf8713", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 19, "deletions": 16, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/35585c499f1466037b3788598756e1eb0009f51f/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35585c499f1466037b3788598756e1eb0009f51f/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=35585c499f1466037b3788598756e1eb0009f51f", "patch": "@@ -1,4 +1,4 @@\n-// Validate AST before lowering it to HIR\n+// Validate AST before lowering it to HIR.\n //\n // This pass is supposed to catch things that fit into AST data structures,\n // but not permitted by the language. It runs after expansion when AST is frozen,\n@@ -56,7 +56,7 @@ struct AstValidator<'a> {\n \n     /// Used to ban nested `impl Trait`, e.g., `impl Into<impl Debug>`.\n     /// Nested `impl Trait` _is_ allowed in associated type position,\n-    /// e.g `impl Iterator<Item=impl Debug>`\n+    /// e.g., `impl Iterator<Item = impl Debug>`.\n     outer_impl_trait: Option<OuterImplTrait>,\n \n     /// Used to ban `impl Trait` in path projections like `<impl Iterator>::Item`\n@@ -94,19 +94,19 @@ impl<'a> AstValidator<'a> {\n     }\n \n     fn visit_assoc_type_binding_from_generic_args(&mut self, type_binding: &'a TypeBinding) {\n-        // rust-lang/rust#57979: bug in old visit_generic_args called\n-        // walk_ty rather than visit_ty, skipping outer `impl Trait`\n-        // if it happened to occur at `type_binding.ty`\n+        // rust-lang/rust#57979: bug in old `visit_generic_args` called\n+        // `walk_ty` rather than `visit_ty`, skipping outer `impl Trait`\n+        // if it happened to occur at `type_binding.ty`.\n         if let TyKind::ImplTrait(..) = type_binding.ty.node {\n             self.warning_period_57979_didnt_record_next_impl_trait = true;\n         }\n         self.visit_assoc_type_binding(type_binding);\n     }\n \n     fn visit_ty_from_generic_args(&mut self, ty: &'a Ty) {\n-        // rust-lang/rust#57979: bug in old visit_generic_args called\n-        // walk_ty rather than visit_ty, skippping outer `impl Trait`\n-        // if it happened to occur at `ty`\n+        // rust-lang/rust#57979: bug in old `visit_generic_args` called\n+        // `walk_ty` rather than `visit_ty`, skippping outer `impl Trait`\n+        // if it happened to occur at `ty`.\n         if let TyKind::ImplTrait(..) = ty.node {\n             self.warning_period_57979_didnt_record_next_impl_trait = true;\n         }\n@@ -117,18 +117,18 @@ impl<'a> AstValidator<'a> {\n         let only_recorded_since_pull_request_57730 =\n             self.warning_period_57979_didnt_record_next_impl_trait;\n \n-        // (this flag is designed to be set to true and then only\n+        // (This flag is designed to be set to `true`, and then only\n         // reach the construction point for the outer impl trait once,\n         // so its safe and easiest to unconditionally reset it to\n-        // false)\n+        // false.)\n         self.warning_period_57979_didnt_record_next_impl_trait = false;\n \n         OuterImplTrait {\n             span, only_recorded_since_pull_request_57730,\n         }\n     }\n \n-    // Mirrors visit::walk_ty, but tracks relevant state\n+    // Mirrors `visit::walk_ty`, but tracks relevant state.\n     fn walk_ty(&mut self, t: &'a Ty) {\n         match t.node {\n             TyKind::ImplTrait(..) => {\n@@ -619,15 +619,18 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                     // Auto traits cannot have generics, super traits nor contain items.\n                     if !generics.params.is_empty() {\n                         struct_span_err!(self.session, item.span, E0567,\n-                                        \"auto traits cannot have generic parameters\").emit();\n+                            \"auto traits cannot have generic parameters\"\n+                        ).emit();\n                     }\n                     if !bounds.is_empty() {\n                         struct_span_err!(self.session, item.span, E0568,\n-                                        \"auto traits cannot have super traits\").emit();\n+                            \"auto traits cannot have super traits\"\n+                        ).emit();\n                     }\n                     if !trait_items.is_empty() {\n                         struct_span_err!(self.session, item.span, E0380,\n-                                \"auto traits cannot have methods or associated items\").emit();\n+                            \"auto traits cannot have methods or associated items\"\n+                        ).emit();\n                     }\n                 }\n                 self.no_questions_in_bounds(bounds, \"supertraits\", true);\n@@ -699,7 +702,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n         visit::walk_foreign_item(self, fi)\n     }\n \n-    // Mirrors visit::walk_generic_args, but tracks relevant state\n+    // Mirrors `visit::walk_generic_args`, but tracks relevant state.\n     fn visit_generic_args(&mut self, _: Span, generic_args: &'a GenericArgs) {\n         match *generic_args {\n             GenericArgs::AngleBracketed(ref data) => {\n@@ -718,7 +721,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                     generic_args.span(),\n                 );\n \n-                // Type bindings such as `Item=impl Debug` in `Iterator<Item=Debug>`\n+                // Type bindings such as `Item = impl Debug` in `Iterator<Item = Debug>`\n                 // are allowed to contain nested `impl Trait`.\n                 self.with_impl_trait(None, |this| {\n                     walk_list!(this, visit_assoc_type_binding_from_generic_args, &data.bindings);"}, {"sha": "fb5c1b1953f08d7edc2aa15c284681c2645e665c", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/35585c499f1466037b3788598756e1eb0009f51f/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35585c499f1466037b3788598756e1eb0009f51f/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=35585c499f1466037b3788598756e1eb0009f51f", "patch": "@@ -2134,7 +2134,7 @@ impl<'a> Resolver<'a> {\n                                       record_used_id: Option<NodeId>,\n                                       path_span: Span)\n                                       -> Option<LexicalScopeBinding<'a>> {\n-        assert!(ns == TypeNS  || ns == ValueNS);\n+        assert!(ns == TypeNS || ns == ValueNS);\n         if ident.name == kw::Invalid {\n             return Some(LexicalScopeBinding::Res(Res::Err));\n         }\n@@ -2530,10 +2530,12 @@ impl<'a> Resolver<'a> {\n \n         match item.node {\n             ItemKind::Ty(_, ref generics) |\n-            ItemKind::Fn(_, _, ref generics, _) |\n-            ItemKind::Existential(_, ref generics) => {\n-                self.with_generic_param_rib(HasGenericParams(generics, ItemRibKind),\n-                                             |this| visit::walk_item(this, item));\n+            ItemKind::Existential(_, ref generics) |\n+            ItemKind::Fn(_, _, ref generics, _) => {\n+                self.with_generic_param_rib(\n+                    HasGenericParams(generics, ItemRibKind),\n+                    |this| visit::walk_item(this, item)\n+                );\n             }\n \n             ItemKind::Enum(_, ref generics) |\n@@ -2967,7 +2969,7 @@ impl<'a> Resolver<'a> {\n         binding_map\n     }\n \n-    // check that all of the arms in an or-pattern have exactly the\n+    // Checks that all of the arms in an or-pattern have exactly the\n     // same set of bindings, with the same binding modes for each.\n     fn check_consistent_bindings(&mut self, pats: &[P<Pat>]) {\n         if pats.is_empty() {\n@@ -2987,7 +2989,7 @@ impl<'a> Resolver<'a> {\n                 let map_j = self.binding_mode_map(&q);\n                 for (&key, &binding_i) in &map_i {\n                     if map_j.is_empty() {                   // Account for missing bindings when\n-                        let binding_error = missing_vars    // map_j has none.\n+                        let binding_error = missing_vars    // `map_j` has none.\n                             .entry(key.name)\n                             .or_insert(BindingError {\n                                 name: key.name,"}, {"sha": "72ac041d2e57d233ce69c866f145a8e9d5714547", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 28, "deletions": 26, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/35585c499f1466037b3788598756e1eb0009f51f/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35585c499f1466037b3788598756e1eb0009f51f/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=35585c499f1466037b3788598756e1eb0009f51f", "patch": "@@ -47,14 +47,14 @@ pub trait AstConv<'gcx, 'tcx> {\n     fn get_type_parameter_bounds(&self, span: Span, def_id: DefId)\n                                  -> &'tcx ty::GenericPredicates<'tcx>;\n \n-    /// What lifetime should we use when a lifetime is omitted (and not elided)?\n+    /// Returns the lifetime to use when a lifetime is omitted (and not elided).\n     fn re_infer(&self, span: Span, _def: Option<&ty::GenericParamDef>)\n                 -> Option<ty::Region<'tcx>>;\n \n-    /// What type should we use when a type is omitted?\n+    /// Returns the type to use when a type is omitted.\n     fn ty_infer(&self, span: Span) -> Ty<'tcx>;\n \n-    /// Same as ty_infer, but with a known type parameter definition.\n+    /// Same as `ty_infer`, but with a known type parameter definition.\n     fn ty_infer_for_def(&self,\n                         _def: &ty::GenericParamDef,\n                         span: Span) -> Ty<'tcx> {\n@@ -376,8 +376,10 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n             }\n             err.emit();\n \n-            (provided > required, // `suppress_error`\n-             potential_assoc_types)\n+            (\n+                provided > required, // `suppress_error`\n+                potential_assoc_types,\n+            )\n         };\n \n         if reported_late_bound_region_err.is_none()\n@@ -556,7 +558,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n     }\n \n     /// Given the type/lifetime/const arguments provided to some path (along with\n-    /// an implicit `Self`, if this is a trait reference) returns the complete\n+    /// an implicit `Self`, if this is a trait reference), returns the complete\n     /// set of substitutions. This may involve applying defaulted type parameters.\n     ///\n     /// Note that the type listing given here is *exactly* what the user provided.\n@@ -708,8 +710,8 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n     /// are disallowed. Otherwise, they are pushed onto the vector given.\n     pub fn instantiate_mono_trait_ref(&self,\n         trait_ref: &hir::TraitRef,\n-        self_ty: Ty<'tcx>)\n-        -> ty::TraitRef<'tcx>\n+        self_ty: Ty<'tcx>\n+    ) -> ty::TraitRef<'tcx>\n     {\n         self.prohibit_generics(trait_ref.path.segments.split_last().unwrap().1);\n \n@@ -724,8 +726,8 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n         trait_ref: &hir::TraitRef,\n         self_ty: Ty<'tcx>,\n         poly_projections: &mut Vec<(ty::PolyProjectionPredicate<'tcx>, Span)>,\n-        speculative: bool)\n-        -> (ty::PolyTraitRef<'tcx>, Option<Vec<Span>>)\n+        speculative: bool,\n+    ) -> (ty::PolyTraitRef<'tcx>, Option<Vec<Span>>)\n     {\n         let trait_def_id = trait_ref.trait_def_id();\n \n@@ -851,13 +853,13 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n             // trait SubTrait: SuperTrait<int> { }\n             // trait SuperTrait<A> { type T; }\n             //\n-            // ... B : SubTrait<T=foo> ...\n+            // ... B: SubTrait<T = foo> ...\n             // ```\n             //\n             // We want to produce `<B as SuperTrait<int>>::T == foo`.\n \n             // Find any late-bound regions declared in `ty` that are not\n-            // declared in the trait-ref. These are not wellformed.\n+            // declared in the trait-ref. These are not well-formed.\n             //\n             // Example:\n             //\n@@ -1716,7 +1718,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n         let span = path.span;\n         match path.res {\n             Res::Def(DefKind::Existential, did) => {\n-                // Check for desugared impl trait.\n+                // Check for desugared `impl Trait`.\n                 assert!(ty::is_impl_trait_defn(tcx, did).is_none());\n                 let item_segment = path.segments.split_last().unwrap();\n                 self.prohibit_generics(item_segment.1);\n@@ -1767,19 +1769,19 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n                     &tcx.hir().local_def_id_from_hir_id(hir_id)];\n                 tcx.mk_ty_param(index, tcx.hir().name_by_hir_id(hir_id).as_interned_str())\n             }\n-            Res::SelfTy(_, Some(def_id)) => {\n-                // `Self` in impl (we know the concrete type).\n-                assert_eq!(opt_self_ty, None);\n-                self.prohibit_generics(&path.segments);\n-                // Try to evaluate any array length constants\n-                self.normalize_ty(span, tcx.at(span).type_of(def_id))\n-            }\n             Res::SelfTy(Some(_), None) => {\n                 // `Self` in trait.\n                 assert_eq!(opt_self_ty, None);\n                 self.prohibit_generics(&path.segments);\n                 tcx.mk_self_type()\n             }\n+            Res::SelfTy(_, Some(def_id)) => {\n+                // `Self` in impl (we know the concrete type).\n+                assert_eq!(opt_self_ty, None);\n+                self.prohibit_generics(&path.segments);\n+                // Try to evaluate any array length constants.\n+                self.normalize_ty(span, tcx.at(span).type_of(def_id))\n+            }\n             Res::Def(DefKind::AssocTy, def_id) => {\n                 debug_assert!(path.segments.len() >= 2);\n                 self.prohibit_generics(&path.segments[..path.segments.len() - 2]);\n@@ -1829,7 +1831,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n             }\n             hir::TyKind::Rptr(ref region, ref mt) => {\n                 let r = self.ast_region_to_region(region, None);\n-                debug!(\"Ref r={:?}\", r);\n+                debug!(\"ast_ty_to_ty: r={:?}\", r);\n                 let t = self.ast_ty_to_ty(&mt.ty);\n                 tcx.mk_ref(r, ty::TypeAndMut {ty: t, mutbl: mt.mutbl})\n             }\n@@ -1856,7 +1858,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n             hir::TyKind::Def(item_id, ref lifetimes) => {\n                 let did = tcx.hir().local_def_id_from_hir_id(item_id.id);\n                 self.impl_trait_ty_to_ty(did, lifetimes)\n-            },\n+            }\n             hir::TyKind::Path(hir::QPath::TypeRelative(ref qself, ref segment)) => {\n                 debug!(\"ast_ty_to_ty: qself={:?} segment={:?}\", qself, segment);\n                 let ty = self.ast_ty_to_ty(qself);\n@@ -1889,9 +1891,6 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n                 // handled specially and will not descend into this routine.\n                 self.ty_infer(ast_ty.span)\n             }\n-            hir::TyKind::Err => {\n-                tcx.types.err\n-            }\n             hir::TyKind::CVarArgs(lt) => {\n                 let va_list_did = match tcx.lang_items().va_list() {\n                     Some(did) => did,\n@@ -1901,6 +1900,9 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n                 let region = self.ast_region_to_region(&lt, None);\n                 tcx.type_of(va_list_did).subst(tcx, &[region.into()])\n             }\n+            hir::TyKind::Err => {\n+                tcx.types.err\n+            }\n         };\n \n         self.record_ty(ast_ty.hir_id, result_ty, ast_ty.span);\n@@ -1979,7 +1981,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n                     _ => bug!()\n                 }\n             } else {\n-                // Replace all parent lifetimes with 'static.\n+                // Replace all parent lifetimes with `'static`.\n                 match param.kind {\n                     GenericParamDefKind::Lifetime => {\n                         tcx.lifetimes.re_static.into()"}, {"sha": "aab873323f91e0bc407274270f7a378194de7ead", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/35585c499f1466037b3788598756e1eb0009f51f/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35585c499f1466037b3788598756e1eb0009f51f/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=35585c499f1466037b3788598756e1eb0009f51f", "patch": "@@ -173,7 +173,7 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n             // here, we would coerce from `!` to `?T`.\n             let b = self.shallow_resolve(b);\n             return if self.shallow_resolve(b).is_ty_var() {\n-                // micro-optimization: no need for this if `b` is\n+                // Micro-optimization: no need for this if `b` is\n                 // already resolved in some way.\n                 let diverging_ty = self.next_diverging_ty_var(\n                     TypeVariableOrigin::AdjustmentType(self.cause.span));"}, {"sha": "d165c7e2b2cf718121c6bc49bcc99723d13a8d5a", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/35585c499f1466037b3788598756e1eb0009f51f/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35585c499f1466037b3788598756e1eb0009f51f/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=35585c499f1466037b3788598756e1eb0009f51f", "patch": "@@ -518,10 +518,10 @@ pub struct FnCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     /// eventually).\n     param_env: ty::ParamEnv<'tcx>,\n \n-    // Number of errors that had been reported when we started\n-    // checking this function. On exit, if we find that *more* errors\n-    // have been reported, we will skip regionck and other work that\n-    // expects the types within the function to be consistent.\n+    /// Number of errors that had been reported when we started\n+    /// checking this function. On exit, if we find that *more* errors\n+    /// have been reported, we will skip regionck and other work that\n+    /// expects the types within the function to be consistent.\n     err_count_on_creation: usize,\n \n     ret_coercion: Option<RefCell<DynamicCoerceMany<'gcx, 'tcx>>>,"}, {"sha": "1bc7119b314e95383a54225bf139f44ff6a9454a", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/35585c499f1466037b3788598756e1eb0009f51f/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35585c499f1466037b3788598756e1eb0009f51f/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=35585c499f1466037b3788598756e1eb0009f51f", "patch": "@@ -450,38 +450,38 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n             let generics = self.tcx().generics_of(def_id);\n \n             let definition_ty = if generics.parent.is_some() {\n-                // impl trait\n+                // `impl Trait`\n                 self.fcx.infer_opaque_definition_from_instantiation(\n                     def_id,\n                     opaque_defn,\n                     instantiated_ty,\n                 )\n             } else {\n-                // prevent\n+                // Prevent:\n                 // * `fn foo<T>() -> Foo<T>`\n                 // * `fn foo<T: Bound + Other>() -> Foo<T>`\n-                // from being defining\n+                // from being defining.\n \n                 // Also replace all generic params with the ones from the existential type\n-                // definition so\n+                // definition so that\n                 // ```rust\n                 // existential type Foo<T>: 'static;\n                 // fn foo<U>() -> Foo<U> { .. }\n                 // ```\n-                // figures out the concrete type with `U`, but the stored type is with `T`\n+                // figures out the concrete type with `U`, but the stored type is with `T`.\n                 instantiated_ty.fold_with(&mut BottomUpFolder {\n                     tcx: self.tcx().global_tcx(),\n                     ty_op: |ty| {\n                         trace!(\"checking type {:?}\", ty);\n-                        // find a type parameter\n+                        // Find a type parameter.\n                         if let ty::Param(..) = ty.sty {\n-                            // look it up in the substitution list\n+                            // Look it up in the substitution list.\n                             assert_eq!(opaque_defn.substs.len(), generics.params.len());\n                             for (subst, param) in opaque_defn.substs.iter().zip(&generics.params) {\n                                 if let UnpackedKind::Type(subst) = subst.unpack() {\n                                     if subst == ty {\n-                                        // found it in the substitution list, replace with the\n-                                        // parameter from the existential type\n+                                        // Found it in the substitution list; replace with the\n+                                        // parameter from the existential type.\n                                         return self.tcx()\n                                             .global_tcx()\n                                             .mk_ty_param(param.index, param.name);\n@@ -505,16 +505,15 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n                     },\n                     lt_op: |region| {\n                         match region {\n-                            // Skip static and bound regions: they don't\n-                            // require substitution.\n+                            // Skip static and bound regions: they don't require substitution.\n                             ty::ReStatic | ty::ReLateBound(..) => region,\n                             _ => {\n                                 trace!(\"checking {:?}\", region);\n                                 for (subst, p) in opaque_defn.substs.iter().zip(&generics.params) {\n                                     if let UnpackedKind::Lifetime(subst) = subst.unpack() {\n                                         if subst == region {\n-                                            // found it in the substitution list, replace with the\n-                                            // parameter from the existential type\n+                                            // Found it in the substitution list; replace with the\n+                                            // parameter from the existential type.\n                                             let reg = ty::EarlyBoundRegion {\n                                                 def_id: p.def_id,\n                                                 index: p.index,\n@@ -586,8 +585,8 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n \n             if let ty::Opaque(defin_ty_def_id, _substs) = definition_ty.sty {\n                 if def_id == defin_ty_def_id {\n-                    // Concrete type resolved to the existential type itself\n-                    // Force a cycle error\n+                    // Concrete type resolved to the existential type itself.\n+                    // Force a cycle error.\n                     // FIXME(oli-obk): we could just not insert it into `concrete_existential_types`\n                     // which simply would make this use not a defining use.\n                     self.tcx().at(span).type_of(defin_ty_def_id);"}, {"sha": "f362263c16e75688821c0e9eb1e3f4986deddfca", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 28, "deletions": 23, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/35585c499f1466037b3788598756e1eb0009f51f/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35585c499f1466037b3788598756e1eb0009f51f/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=35585c499f1466037b3788598756e1eb0009f51f", "patch": "@@ -1,6 +1,6 @@\n //! \"Collection\" is the process of determining the type and other external\n //! details of each item in Rust. Collection is specifically concerned\n-//! with *interprocedural* things -- for example, for a function\n+//! with *inter-procedural* things -- for example, for a function\n //! definition, collection will figure out the type and signature of the\n //! function, but it will not visit the *body* of the function in any way,\n //! nor examine type annotations on local variables (that's the job of\n@@ -233,7 +233,7 @@ impl<'a, 'tcx> AstConv<'tcx, 'tcx> for ItemCtxt<'a, 'tcx> {\n     }\n \n     fn set_tainted_by_errors(&self) {\n-        // no obvious place to track this, just let it go\n+        // no obvious place to track this, so just let it go\n     }\n \n     fn record_ty(&self, _hir_id: hir::HirId, _ty: Ty<'tcx>, _span: Span) {\n@@ -447,7 +447,7 @@ fn convert_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, item_id: hir::HirId) {\n             }\n         }\n \n-        // Desugared from `impl Trait` -> visited by the function's return type\n+        // Desugared from `impl Trait`, so visited by the function's return type.\n         hir::ItemKind::Existential(hir::ExistTy {\n             impl_trait_fn: Some(_),\n             ..\n@@ -1218,7 +1218,7 @@ pub fn checked_type_of<'a, 'tcx>(\n                     impl_trait_fn: None,\n                     ..\n                 }) => find_existential_constraints(tcx, def_id),\n-                // existential types desugared from impl Trait\n+                // Existential types desugared from `impl Trait`.\n                 ItemKind::Existential(hir::ExistTy {\n                     impl_trait_fn: Some(owner),\n                     ..\n@@ -1472,11 +1472,13 @@ fn find_existential_constraints<'a, 'tcx>(\n ) -> Ty<'tcx> {\n     use rustc::hir::{ImplItem, Item, TraitItem};\n \n+    debug!(\"find_existential_constraints({:?})\", def_id);\n+\n     struct ConstraintLocator<'a, 'tcx: 'a> {\n         tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         def_id: DefId,\n-        // First found type span, actual type, mapping from the existential type's generic\n-        // parameters to the concrete type's generic parameters\n+        // (first found type span, actual type, mapping from the existential type's generic\n+        // parameters to the concrete type's generic parameters)\n         //\n         // The mapping is an index for each use site of a generic parameter in the concrete type\n         //\n@@ -1502,18 +1504,21 @@ fn find_existential_constraints<'a, 'tcx>(\n                 let span = self.tcx.def_span(def_id);\n                 // used to quickly look up the position of a generic parameter\n                 let mut index_map: FxHashMap<ty::ParamTy, usize> = FxHashMap::default();\n-                // skip binder is ok, since we only use this to find generic parameters and their\n-                // positions.\n+                // Skipping binder is ok, since we only use this to find generic parameters and\n+                // their positions.\n                 for (idx, subst) in substs.iter().enumerate() {\n                     if let UnpackedKind::Type(ty) = subst.unpack() {\n                         if let ty::Param(p) = ty.sty {\n                             if index_map.insert(p, idx).is_some() {\n-                                // there was already an entry for `p`, meaning a generic parameter\n-                                // was used twice\n+                                // There was already an entry for `p`, meaning a generic parameter\n+                                // was used twice.\n                                 self.tcx.sess.span_err(\n                                     span,\n-                                    &format!(\"defining existential type use restricts existential \\\n-                                    type by using the generic parameter `{}` twice\", p.name),\n+                                    &format!(\n+                                        \"defining existential type use restricts existential \\\n+                                         type by using the generic parameter `{}` twice\",\n+                                        p.name\n+                                    ),\n                                 );\n                                 return;\n                             }\n@@ -1528,8 +1533,8 @@ fn find_existential_constraints<'a, 'tcx>(\n                         }\n                     }\n                 }\n-                // compute the index within the existential type for each generic parameter used in\n-                // the concrete type\n+                // Compute the index within the existential type for each generic parameter used in\n+                // the concrete type.\n                 let indices = concrete_type\n                     .subst(self.tcx, substs)\n                     .walk()\n@@ -1607,15 +1612,15 @@ fn find_existential_constraints<'a, 'tcx>(\n         }\n         fn visit_item(&mut self, it: &'tcx Item) {\n             let def_id = self.tcx.hir().local_def_id_from_hir_id(it.hir_id);\n-            // the existential type itself or its children are not within its reveal scope\n+            // The existential type itself or its children are not within its reveal scope.\n             if def_id != self.def_id {\n                 self.check(def_id);\n                 intravisit::walk_item(self, it);\n             }\n         }\n         fn visit_impl_item(&mut self, it: &'tcx ImplItem) {\n             let def_id = self.tcx.hir().local_def_id_from_hir_id(it.hir_id);\n-            // the existential type itself or its children are not within its reveal scope\n+            // The existential type itself or its children are not within its reveal scope.\n             if def_id != self.def_id {\n                 self.check(def_id);\n                 intravisit::walk_impl_item(self, it);\n@@ -1960,7 +1965,7 @@ fn explicit_predicates_of<'a, 'tcx>(\n                 let substs = InternalSubsts::identity_for_item(tcx, def_id);\n                 let opaque_ty = tcx.mk_opaque(def_id, substs);\n \n-                // Collect the bounds, i.e., the `A+B+'c` in `impl A+B+'c`.\n+                // Collect the bounds, i.e., the `A + B + 'c` in `impl A + B + 'c`.\n                 let bounds = compute_bounds(\n                     &icx,\n                     opaque_ty,\n@@ -2006,7 +2011,7 @@ fn explicit_predicates_of<'a, 'tcx>(\n                     let substs = InternalSubsts::identity_for_item(tcx, def_id);\n                     let opaque_ty = tcx.mk_opaque(def_id, substs);\n \n-                    // Collect the bounds, i.e., the `A+B+'c` in `impl A+B+'c`.\n+                    // Collect the bounds, i.e., the `A + B + 'c` in `impl A + B + 'c`.\n                     let bounds = compute_bounds(\n                         &icx,\n                         opaque_ty,\n@@ -2016,7 +2021,7 @@ fn explicit_predicates_of<'a, 'tcx>(\n                     );\n \n                     if impl_trait_fn.is_some() {\n-                        // impl Trait\n+                        // opaque types\n                         return tcx.arena.alloc(ty::GenericPredicates {\n                             parent: None,\n                             predicates: bounds.predicates(tcx, opaque_ty),\n@@ -2093,7 +2098,7 @@ fn explicit_predicates_of<'a, 'tcx>(\n     }\n \n     // Collect the predicates that were written inline by the user on each\n-    // type parameter (e.g., `<T:Foo>`).\n+    // type parameter (e.g., `<T: Foo>`).\n     for param in &ast_generics.params {\n         if let GenericParamKind::Type { .. } = param.kind {\n             let name = param.name.ident().as_interned_str();\n@@ -2106,7 +2111,7 @@ fn explicit_predicates_of<'a, 'tcx>(\n         }\n     }\n \n-    // Add in the bounds that appear in the where-clause\n+    // Add in the bounds that appear in the where-clause.\n     let where_clause = &ast_generics.where_clause;\n     for predicate in &where_clause.predicates {\n         match predicate {\n@@ -2422,7 +2427,7 @@ fn from_target_feature(\n             continue;\n         }\n \n-        // Must be of the form `enable = \"...\"` ( a string)\n+        // Must be of the form `enable = \"...\"` (a string).\n         let value = match item.value_str() {\n             Some(value) => value,\n             None => {\n@@ -2545,7 +2550,7 @@ fn codegen_fn_attrs<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, id: DefId) -> Codegen\n             if tcx.is_foreign_item(id) {\n                 codegen_fn_attrs.flags |= CodegenFnAttrFlags::FFI_RETURNS_TWICE;\n             } else {\n-                // `#[ffi_returns_twice]` is only allowed `extern fn`s\n+                // `#[ffi_returns_twice]` is only allowed `extern fn`s.\n                 struct_span_err!(\n                     tcx.sess,\n                     attr.span,"}, {"sha": "024d73ff65bd2be7b0df9e2604df078ef1874885", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/35585c499f1466037b3788598756e1eb0009f51f/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35585c499f1466037b3788598756e1eb0009f51f/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=35585c499f1466037b3788598756e1eb0009f51f", "patch": "@@ -379,8 +379,8 @@ pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>)\n /// A quasi-deprecated helper used in rustdoc and clippy to get\n /// the type from a HIR node.\n pub fn hir_ty_to_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, hir_ty: &hir::Ty) -> Ty<'tcx> {\n-    // In case there are any projections etc, find the \"environment\"\n-    // def-id that will be used to determine the traits/predicates in\n+    // In case there are any projections, etc., find the \"environment\"\n+    // def-ID that will be used to determine the traits/predicates in\n     // scope.  This is derived from the enclosing item-like thing.\n     let env_node_id = tcx.hir().get_parent_item(hir_ty.hir_id);\n     let env_def_id = tcx.hir().local_def_id_from_hir_id(env_node_id);\n@@ -391,8 +391,8 @@ pub fn hir_ty_to_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, hir_ty: &hir::Ty) ->\n \n pub fn hir_trait_to_predicates<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, hir_trait: &hir::TraitRef)\n         -> (ty::PolyTraitRef<'tcx>, Vec<(ty::PolyProjectionPredicate<'tcx>, Span)>) {\n-    // In case there are any projections etc, find the \"environment\"\n-    // def-id that will be used to determine the traits/predicates in\n+    // In case there are any projections, etc., find the \"environment\"\n+    // def-ID that will be used to determine the traits/predicates in\n     // scope.  This is derived from the enclosing item-like thing.\n     let env_hir_id = tcx.hir().get_parent_item(hir_trait.hir_ref_id);\n     let env_def_id = tcx.hir().local_def_id_from_hir_id(env_hir_id);"}, {"sha": "f19e5180939ba3c4d34dde56d43b893469a1f57e", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/35585c499f1466037b3788598756e1eb0009f51f/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35585c499f1466037b3788598756e1eb0009f51f/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=35585c499f1466037b3788598756e1eb0009f51f", "patch": "@@ -2443,12 +2443,12 @@ pub struct PolyTrait {\n     pub generic_params: Vec<GenericParamDef>,\n }\n \n-/// A representation of a Type suitable for hyperlinking purposes. Ideally one can get the original\n-/// type out of the AST/TyCtxt given one of these, if more information is needed. Most importantly\n-/// it does not preserve mutability or boxes.\n+/// A representation of a type suitable for hyperlinking purposes. Ideally, one can get the original\n+/// type out of the AST/`TyCtxt` given one of these, if more information is needed. Most\n+/// importantly, it does not preserve mutability or boxes.\n #[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Debug, Hash)]\n pub enum Type {\n-    /// Structs/enums/traits (most that'd be an `hir::TyKind::Path`).\n+    /// Structs/enums/traits (most that would be an `hir::TyKind::Path`).\n     ResolvedPath {\n         path: Path,\n         param_names: Option<Vec<GenericBound>>,\n@@ -2462,7 +2462,7 @@ pub enum Type {\n     /// Primitives are the fixed-size numeric types (plus int/usize/float), char,\n     /// arrays, slices, and tuples.\n     Primitive(PrimitiveType),\n-    /// extern \"ABI\" fn\n+    /// `extern \"ABI\" fn`\n     BareFunction(Box<BareFunctionDecl>),\n     Tuple(Vec<Type>),\n     Slice(Box<Type>),\n@@ -2477,17 +2477,17 @@ pub enum Type {\n         type_: Box<Type>,\n     },\n \n-    // <Type as Trait>::Name\n+    // `<Type as Trait>::Name`\n     QPath {\n         name: String,\n         self_type: Box<Type>,\n         trait_: Box<Type>\n     },\n \n-    // _\n+    // `_`\n     Infer,\n \n-    // impl TraitA+TraitB\n+    // `impl TraitA + TraitB + ...`\n     ImplTrait(Vec<GenericBound>),\n }\n \n@@ -2747,7 +2747,6 @@ impl Clean<Type> for hir::Ty {\n \n         match self.node {\n             TyKind::Never => Never,\n-            TyKind::CVarArgs(_) => CVarArgs,\n             TyKind::Ptr(ref m) => RawPointer(m.mutbl.clean(cx), box m.ty.clean(cx)),\n             TyKind::Rptr(ref l, ref m) => {\n                 let lifetime = if l.is_elided() {\n@@ -2933,12 +2932,13 @@ impl Clean<Type> for hir::Ty {\n                         }\n                         ResolvedPath { path, param_names: Some(bounds), did, is_generic, }\n                     }\n-                    _ => Infer // shouldn't happen\n+                    _ => Infer, // shouldn't happen\n                 }\n             }\n             TyKind::BareFn(ref barefn) => BareFunction(box barefn.clean(cx)),\n             TyKind::Infer | TyKind::Err => Infer,\n             TyKind::Typeof(..) => panic!(\"Unimplemented type {:?}\", self.node),\n+            TyKind::CVarArgs(_) => CVarArgs,\n         }\n     }\n }"}, {"sha": "38cde121000567568c07c09bd1e001ddf436dac9", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/35585c499f1466037b3788598756e1eb0009f51f/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35585c499f1466037b3788598756e1eb0009f51f/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=35585c499f1466037b3788598756e1eb0009f51f", "patch": "@@ -18,7 +18,6 @@ use crate::core::DocAccessLevels;\n use crate::html::item_type::ItemType;\n use crate::html::render::{self, cache, CURRENT_LOCATION_KEY};\n \n-\n /// Helper to render an optional visibility with a space after it (if the\n /// visibility is preset)\n #[derive(Copy, Clone)]\n@@ -561,7 +560,7 @@ fn fmt_type(t: &clean::Type, f: &mut fmt::Formatter<'_>, use_absolute: bool) ->\n             if param_names.is_some() {\n                 f.write_str(\"dyn \")?;\n             }\n-            // Paths like T::Output and Self::Output should be rendered with all segments\n+            // Paths like `T::Output` and `Self::Output` should be rendered with all segments.\n             resolved_path(f, did, path, is_generic, use_absolute)?;\n             tybounds(f, param_names)\n         }\n@@ -585,7 +584,7 @@ fn fmt_type(t: &clean::Type, f: &mut fmt::Formatter<'_>, use_absolute: bool) ->\n                 &[] => primitive_link(f, PrimitiveType::Unit, \"()\"),\n                 &[ref one] => {\n                     primitive_link(f, PrimitiveType::Tuple, \"(\")?;\n-                    //carry f.alternate() into this display w/o branching manually\n+                    // Carry `f.alternate()` into this display w/o branching manually.\n                     fmt::Display::fmt(one, f)?;\n                     primitive_link(f, PrimitiveType::Tuple, \",)\")\n                 }\n@@ -638,7 +637,7 @@ fn fmt_type(t: &clean::Type, f: &mut fmt::Formatter<'_>, use_absolute: bool) ->\n                 \"&amp;\".to_string()\n             };\n             match **ty {\n-                clean::Slice(ref bt) => { // BorrowedRef{ ... Slice(T) } is &[T]\n+                clean::Slice(ref bt) => { // `BorrowedRef{ ... Slice(T) }` is `&[T]`\n                     match **bt {\n                         clean::Generic(_) => {\n                             if f.alternate() {"}, {"sha": "9ef42063f94126cd28a79179836bf8d4a370c4e2", "filename": "src/libstd/panicking.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/35585c499f1466037b3788598756e1eb0009f51f/src%2Flibstd%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35585c499f1466037b3788598756e1eb0009f51f/src%2Flibstd%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpanicking.rs?ref=35585c499f1466037b3788598756e1eb0009f51f", "patch": "@@ -171,7 +171,8 @@ fn default_hook(info: &PanicInfo<'_>) {\n         }\n     };\n \n-    let location = info.location().unwrap();  // The current implementation always returns Some\n+    // The current implementation always returns `Some`.\n+    let location = info.location().unwrap();\n \n     let msg = match info.payload().downcast_ref::<&'static str>() {\n         Some(s) => *s,\n@@ -196,7 +197,7 @@ fn default_hook(info: &PanicInfo<'_>) {\n             if let Some(format) = log_backtrace {\n                 let _ = backtrace::print(err, format);\n             } else if FIRST_PANIC.compare_and_swap(true, false, Ordering::SeqCst) {\n-                let _ = writeln!(err, \"note: Run with `RUST_BACKTRACE=1` \\\n+                let _ = writeln!(err, \"note: run with `RUST_BACKTRACE=1` \\\n                                        environment variable to display a backtrace.\");\n             }\n         }"}, {"sha": "bf37ff7ddbd3a2edb852e9a7a14ce41d73ee3264", "filename": "src/libstd/sys_common/backtrace.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/35585c499f1466037b3788598756e1eb0009f51f/src%2Flibstd%2Fsys_common%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35585c499f1466037b3788598756e1eb0009f51f/src%2Flibstd%2Fsys_common%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fbacktrace.rs?ref=35585c499f1466037b3788598756e1eb0009f51f", "patch": "@@ -173,7 +173,7 @@ impl<'a, 'b> Printer<'a, 'b> {\n             Some(symbol) => {\n                 match self.format {\n                     PrintFormat::Full => write!(self.out, \"{}\", symbol)?,\n-                    // strip the trailing hash if short mode\n+                    // Strip the trailing hash if short mode.\n                     PrintFormat::Short => write!(self.out, \"{:#}\", symbol)?,\n                 }\n             }"}, {"sha": "31e898048003de5fe6ccf3a70312ff630be0e712", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/35585c499f1466037b3788598756e1eb0009f51f/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35585c499f1466037b3788598756e1eb0009f51f/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=35585c499f1466037b3788598756e1eb0009f51f", "patch": "@@ -213,7 +213,7 @@ pub struct ParenthesizedArgs {\n     /// Overall span\n     pub span: Span,\n \n-    /// `(A,B)`\n+    /// `(A, B)`\n     pub inputs: Vec<P<Ty>>,\n \n     /// `C`\n@@ -1840,7 +1840,7 @@ impl Arg {\n     }\n }\n \n-/// Header (not the body) of a function declaration.\n+/// A header (not the body) of a function declaration.\n ///\n /// E.g., `fn foo(bar: baz)`.\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]"}, {"sha": "435a3d7b6a22a14164e84380ce197cb75a33f136", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 15, "deletions": 18, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/35585c499f1466037b3788598756e1eb0009f51f/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35585c499f1466037b3788598756e1eb0009f51f/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=35585c499f1466037b3788598756e1eb0009f51f", "patch": "@@ -10,7 +10,7 @@ use rustc_target::spec::abi::Abi;\n use syntax_pos::{Pos, Span};\n \n pub trait AstBuilder {\n-    // paths\n+    // Paths\n     fn path(&self, span: Span, strs: Vec<ast::Ident> ) -> ast::Path;\n     fn path_ident(&self, span: Span, id: ast::Ident) -> ast::Path;\n     fn path_global(&self, span: Span, strs: Vec<ast::Ident> ) -> ast::Path;\n@@ -69,7 +69,7 @@ pub trait AstBuilder {\n                     bounds: ast::GenericBounds)\n                     -> ast::GenericParam;\n \n-    // statements\n+    // Statements\n     fn stmt_expr(&self, expr: P<ast::Expr>) -> ast::Stmt;\n     fn stmt_semi(&self, expr: P<ast::Expr>) -> ast::Stmt;\n     fn stmt_let(&self, sp: Span, mutbl: bool, ident: ast::Ident, ex: P<ast::Expr>) -> ast::Stmt;\n@@ -83,11 +83,11 @@ pub trait AstBuilder {\n     fn stmt_let_type_only(&self, span: Span, ty: P<ast::Ty>) -> ast::Stmt;\n     fn stmt_item(&self, sp: Span, item: P<ast::Item>) -> ast::Stmt;\n \n-    // blocks\n+    // Blocks\n     fn block(&self, span: Span, stmts: Vec<ast::Stmt>) -> P<ast::Block>;\n     fn block_expr(&self, expr: P<ast::Expr>) -> P<ast::Block>;\n \n-    // expressions\n+    // Expressions\n     fn expr(&self, span: Span, node: ast::ExprKind) -> P<ast::Expr>;\n     fn expr_path(&self, path: ast::Path) -> P<ast::Expr>;\n     fn expr_qpath(&self, span: Span, qself: ast::QSelf, path: ast::Path) -> P<ast::Expr>;\n@@ -194,12 +194,12 @@ pub trait AstBuilder {\n     fn lambda_stmts_1(&self, span: Span, stmts: Vec<ast::Stmt>,\n                       ident: ast::Ident) -> P<ast::Expr>;\n \n-    // items\n+    // Items\n     fn item(&self, span: Span,\n             name: Ident, attrs: Vec<ast::Attribute> , node: ast::ItemKind) -> P<ast::Item>;\n \n     fn arg(&self, span: Span, name: Ident, ty: P<ast::Ty>) -> ast::Arg;\n-    // FIXME unused self\n+    // FIXME: unused `self`\n     fn fn_decl(&self, inputs: Vec<ast::Arg> , output: ast::FunctionRetTy) -> P<ast::FnDecl>;\n \n     fn item_fn_poly(&self,\n@@ -552,7 +552,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         }\n     }\n \n-    // Generate `let _: Type;`, usually used for type assertions.\n+    // Generates `let _: Type;`, which is usually used for type assertions.\n     fn stmt_let_type_only(&self, span: Span, ty: P<ast::Ty>) -> ast::Stmt {\n         let local = P(ast::Local {\n             pat: self.pat_wild(span),\n@@ -606,7 +606,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         self.expr(path.span, ast::ExprKind::Path(None, path))\n     }\n \n-    /// Constructs a QPath expression.\n+    /// Constructs a `QPath` expression.\n     fn expr_qpath(&self, span: Span, qself: ast::QSelf, path: ast::Path) -> P<ast::Expr> {\n         self.expr(span, ast::ExprKind::Path(Some(qself), path))\n     }\n@@ -736,7 +736,6 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         self.expr(sp, ast::ExprKind::Cast(expr, ty))\n     }\n \n-\n     fn expr_some(&self, sp: Span, expr: P<ast::Expr>) -> P<ast::Expr> {\n         let some = self.std_path(&[sym::option, sym::Option, sym::Some]);\n         self.expr_call_global(sp, some, vec![expr])\n@@ -748,12 +747,10 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         self.expr_path(none)\n     }\n \n-\n     fn expr_break(&self, sp: Span) -> P<ast::Expr> {\n         self.expr(sp, ast::ExprKind::Break(None, None))\n     }\n \n-\n     fn expr_tuple(&self, sp: Span, exprs: Vec<P<ast::Expr>>) -> P<ast::Expr> {\n         self.expr(sp, ast::ExprKind::Tup(exprs))\n     }\n@@ -797,22 +794,22 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         let binding_pat = self.pat_ident(sp, binding_variable);\n         let binding_expr = self.expr_ident(sp, binding_variable);\n \n-        // Ok(__try_var) pattern\n+        // `Ok(__try_var)` pattern\n         let ok_pat = self.pat_tuple_struct(sp, ok_path, vec![binding_pat.clone()]);\n \n-        // Err(__try_var)  (pattern and expression resp.)\n+        // `Err(__try_var)` (pattern and expression respectively)\n         let err_pat = self.pat_tuple_struct(sp, err_path.clone(), vec![binding_pat]);\n         let err_inner_expr = self.expr_call(sp, self.expr_path(err_path),\n                                             vec![binding_expr.clone()]);\n-        // return Err(__try_var)\n+        // `return Err(__try_var)`\n         let err_expr = self.expr(sp, ast::ExprKind::Ret(Some(err_inner_expr)));\n \n-        // Ok(__try_var) => __try_var\n+        // `Ok(__try_var) => __try_var`\n         let ok_arm = self.arm(sp, vec![ok_pat], binding_expr);\n-        // Err(__try_var) => return Err(__try_var)\n+        // `Err(__try_var) => return Err(__try_var)`\n         let err_arm = self.arm(sp, vec![err_pat], err_expr);\n \n-        // match head { Ok() => ..., Err() => ... }\n+        // `match head { Ok() => ..., Err() => ... }`\n         self.expr_match(sp, head, vec![ok_arm, err_arm])\n     }\n \n@@ -972,7 +969,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         }\n     }\n \n-    // FIXME unused self\n+    // FIXME: unused `self`\n     fn fn_decl(&self, inputs: Vec<ast::Arg>, output: ast::FunctionRetTy) -> P<ast::FnDecl> {\n         P(ast::FnDecl {\n             inputs,"}, {"sha": "abfce660c80417922db0549b35aea600dcfc0795", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/35585c499f1466037b3788598756e1eb0009f51f/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35585c499f1466037b3788598756e1eb0009f51f/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=35585c499f1466037b3788598756e1eb0009f51f", "patch": "@@ -191,24 +191,24 @@ enum PrevTokenKind {\n     Other,\n }\n \n-/* ident is handled by common.rs */\n+// NOTE: `Ident`s are handled by `common.rs`.\n \n #[derive(Clone)]\n pub struct Parser<'a> {\n     pub sess: &'a ParseSess,\n-    /// the current token:\n+    /// The current token.\n     pub token: token::Token,\n-    /// the span of the current token:\n+    /// The span of the current token.\n     pub span: Span,\n-    /// the span of the previous token:\n     meta_var_span: Option<Span>,\n+    /// The span of the previous token.\n     pub prev_span: Span,\n-    /// the previous token kind\n+    /// The kind of the previous troken.\n     prev_token_kind: PrevTokenKind,\n     restrictions: Restrictions,\n-    /// Used to determine the path to externally loaded source files\n+    /// Used to determine the path to externally loaded source files.\n     crate directory: Directory<'a>,\n-    /// Whether to parse sub-modules in other files.\n+    /// `true` to parse sub-modules in other files.\n     pub recurse_into_file_modules: bool,\n     /// Name of the root module this parser originated from. If `None`, then the\n     /// name is not known. This does not change while the parser is descending\n@@ -217,7 +217,7 @@ pub struct Parser<'a> {\n     crate expected_tokens: Vec<TokenType>,\n     crate token_cursor: TokenCursor,\n     desugar_doc_comments: bool,\n-    /// Whether we should configure out of line modules as we parse.\n+    /// `true` we should configure out of line modules as we parse.\n     pub cfg_mods: bool,\n     /// This field is used to keep track of how many left angle brackets we have seen. This is\n     /// required in order to detect extra leading left angle brackets (`<` characters) and error\n@@ -2680,8 +2680,7 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    // parse a stream of tokens into a list of TokenTree's,\n-    // up to EOF.\n+    /// Parses a stream of tokens into a list of `TokenTree`s, up to EOF.\n     pub fn parse_all_token_trees(&mut self) -> PResult<'a, Vec<TokenTree>> {\n         let mut tts = Vec::new();\n         while self.token != token::Eof {\n@@ -5344,9 +5343,10 @@ impl<'a> Parser<'a> {\n                 // Parse optional `for<'a, 'b>`.\n                 // This `for` is parsed greedily and applies to the whole predicate,\n                 // the bounded type can have its own `for` applying only to it.\n-                // Example 1: for<'a> Trait1<'a>: Trait2<'a /*ok*/>\n-                // Example 2: (for<'a> Trait1<'a>): Trait2<'a /*not ok*/>\n-                // Example 3: for<'a> for<'b> Trait1<'a, 'b>: Trait2<'a /*ok*/, 'b /*not ok*/>\n+                // Examples:\n+                // * `for<'a> Trait1<'a>: Trait2<'a /* ok */>`\n+                // * `(for<'a> Trait1<'a>): Trait2<'a /* not ok */>`\n+                // * `for<'a> for<'b> Trait1<'a, 'b>: Trait2<'a /* ok */, 'b /* not ok */>`\n                 let lifetime_defs = self.parse_late_bound_lifetime_defs()?;\n \n                 // Parse type with mandatory colon and (possibly empty) bounds,\n@@ -5478,17 +5478,17 @@ impl<'a> Parser<'a> {\n             this.look_ahead(n + 1, |t| t != &token::ModSep)\n         };\n \n-        // Parse optional self parameter of a method.\n-        // Only a limited set of initial token sequences is considered self parameters, anything\n+        // Parse optional `self` parameter of a method.\n+        // Only a limited set of initial token sequences is considered `self` parameters; anything\n         // else is parsed as a normal function parameter list, so some lookahead is required.\n         let eself_lo = self.span;\n         let (eself, eself_ident, eself_hi) = match self.token {\n             token::BinOp(token::And) => {\n-                // &self\n-                // &mut self\n-                // &'lt self\n-                // &'lt mut self\n-                // &not_self\n+                // `&self`\n+                // `&mut self`\n+                // `&'lt self`\n+                // `&'lt mut self`\n+                // `&not_self`\n                 (if isolated_self(self, 1) {\n                     self.bump();\n                     SelfKind::Region(None, Mutability::Immutable)\n@@ -5514,10 +5514,10 @@ impl<'a> Parser<'a> {\n                 }, expect_ident(self), self.prev_span)\n             }\n             token::BinOp(token::Star) => {\n-                // *self\n-                // *const self\n-                // *mut self\n-                // *not_self\n+                // `*self`\n+                // `*const self`\n+                // `*mut self`\n+                // `*not_self`\n                 // Emit special error for `self` cases.\n                 let msg = \"cannot pass `self` by raw pointer\";\n                 (if isolated_self(self, 1) {\n@@ -5540,8 +5540,8 @@ impl<'a> Parser<'a> {\n             }\n             token::Ident(..) => {\n                 if isolated_self(self, 0) {\n-                    // self\n-                    // self: TYPE\n+                    // `self`\n+                    // `self: TYPE`\n                     let eself_ident = expect_ident(self);\n                     let eself_hi = self.prev_span;\n                     (if self.eat(&token::Colon) {\n@@ -5552,8 +5552,8 @@ impl<'a> Parser<'a> {\n                     }, eself_ident, eself_hi)\n                 } else if self.token.is_keyword(kw::Mut) &&\n                           isolated_self(self, 1) {\n-                    // mut self\n-                    // mut self: TYPE\n+                    // `mut self`\n+                    // `mut self: TYPE`\n                     self.bump();\n                     let eself_ident = expect_ident(self);\n                     let eself_hi = self.prev_span;\n@@ -5580,7 +5580,7 @@ impl<'a> Parser<'a> {\n     {\n         self.expect(&token::OpenDelim(token::Paren))?;\n \n-        // Parse optional self argument\n+        // Parse optional self argument.\n         let self_arg = self.parse_self_arg()?;\n \n         // Parse the rest of the function parameter list."}, {"sha": "44e1f5398d3e08a31b592154866f51e17cb4db2d", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/35585c499f1466037b3788598756e1eb0009f51f/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35585c499f1466037b3788598756e1eb0009f51f/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=35585c499f1466037b3788598756e1eb0009f51f", "patch": "@@ -1715,7 +1715,7 @@ impl<'a> State<'a> {\n         match els {\n             Some(_else) => {\n                 match _else.node {\n-                    // \"another else-if\"\n+                    // Another `else if` block.\n                     ast::ExprKind::If(ref i, ref then, ref e) => {\n                         self.cbox(INDENT_UNIT - 1)?;\n                         self.ibox(0)?;\n@@ -1725,7 +1725,7 @@ impl<'a> State<'a> {\n                         self.print_block(then)?;\n                         self.print_else(e.as_ref().map(|e| &**e))\n                     }\n-                    // \"another else-if-let\"\n+                    // Another `else if let` block.\n                     ast::ExprKind::IfLet(ref pats, ref expr, ref then, ref e) => {\n                         self.cbox(INDENT_UNIT - 1)?;\n                         self.ibox(0)?;\n@@ -1738,14 +1738,14 @@ impl<'a> State<'a> {\n                         self.print_block(then)?;\n                         self.print_else(e.as_ref().map(|e| &**e))\n                     }\n-                    // \"final else\"\n+                    // Final `else` block.\n                     ast::ExprKind::Block(ref b, _) => {\n                         self.cbox(INDENT_UNIT - 1)?;\n                         self.ibox(0)?;\n                         self.s.word(\" else \")?;\n                         self.print_block(b)\n                     }\n-                    // BLEAH, constraints would be great here\n+                    // Constraints would be great here!\n                     _ => {\n                         panic!(\"print_if saw if with weird alternative\");\n                     }"}, {"sha": "d577243fb3dcd834590e1ddf511549037f0f3821", "filename": "src/libsyntax/ptr.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/35585c499f1466037b3788598756e1eb0009f51f/src%2Flibsyntax%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35585c499f1466037b3788598756e1eb0009f51f/src%2Flibsyntax%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fptr.rs?ref=35585c499f1466037b3788598756e1eb0009f51f", "patch": "@@ -57,7 +57,8 @@ impl<T: 'static> P<T> {\n     {\n         f(*self.ptr)\n     }\n-    /// Equivalent to and_then(|x| x)\n+\n+    /// Equivalent to `and_then(|x| x)`.\n     pub fn into_inner(self) -> T {\n         *self.ptr\n     }"}, {"sha": "ba57055b8e009b594eb9d70ec5c6c54e6e93ca3e", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/35585c499f1466037b3788598756e1eb0009f51f/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35585c499f1466037b3788598756e1eb0009f51f/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=35585c499f1466037b3788598756e1eb0009f51f", "patch": "@@ -499,7 +499,7 @@ pub fn walk_generic_param<'a, V: Visitor<'a>>(visitor: &mut V, param: &'a Generi\n     walk_list!(visitor, visit_attribute, param.attrs.iter());\n     walk_list!(visitor, visit_param_bound, &param.bounds);\n     match param.kind {\n-        GenericParamKind::Lifetime => {}\n+        GenericParamKind::Lifetime => (),\n         GenericParamKind::Type { ref default } => walk_list!(visitor, visit_ty, default),\n         GenericParamKind::Const { ref ty, .. } => visitor.visit_ty(ty),\n     }"}, {"sha": "ffec667aba5d3ae19c820b260d854fce95a7ac8a", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/35585c499f1466037b3788598756e1eb0009f51f/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35585c499f1466037b3788598756e1eb0009f51f/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=35585c499f1466037b3788598756e1eb0009f51f", "patch": "@@ -922,8 +922,7 @@ impl<'a> MethodDef<'a> {\n                      arg_types: Vec<(Ident, P<ast::Ty>)>,\n                      body: P<Expr>)\n                      -> ast::ImplItem {\n-\n-        // create the generics that aren't for Self\n+        // Create the generics that aren't for `Self`.\n         let fn_generics = self.generics.to_generics(cx, trait_.span, type_ident, generics);\n \n         let args = {"}, {"sha": "de8b689396fb9bb94cd83a461b4f7df78150a512", "filename": "src/libsyntax_ext/proc_macro_decls.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/35585c499f1466037b3788598756e1eb0009f51f/src%2Flibsyntax_ext%2Fproc_macro_decls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35585c499f1466037b3788598756e1eb0009f51f/src%2Flibsyntax_ext%2Fproc_macro_decls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fproc_macro_decls.rs?ref=35585c499f1466037b3788598756e1eb0009f51f", "patch": "@@ -245,8 +245,7 @@ impl<'a> Visitor<'a> for CollectProcMacros<'a> {\n         // First up, make sure we're checking a bare function. If we're not then\n         // we're just not interested in this item.\n         //\n-        // If we find one, try to locate a `#[proc_macro_derive]` attribute on\n-        // it.\n+        // If we find one, try to locate a `#[proc_macro_derive]` attribute on it.\n         let is_fn = match item.node {\n             ast::ItemKind::Fn(..) => true,\n             _ => false,\n@@ -259,15 +258,15 @@ impl<'a> Visitor<'a> for CollectProcMacros<'a> {\n                 if let Some(prev_attr) = found_attr {\n                     let msg = if attr.path.segments[0].ident.name ==\n                                  prev_attr.path.segments[0].ident.name {\n-                        format!(\"Only one `#[{}]` attribute is allowed on any given function\",\n+                        format!(\"only one `#[{}]` attribute is allowed on any given function\",\n                                 attr.path)\n                     } else {\n                         format!(\"`#[{}]` and `#[{}]` attributes cannot both be applied \\\n                                 to the same function\", attr.path, prev_attr.path)\n                     };\n \n                     self.handler.struct_span_err(attr.span, &msg)\n-                        .span_note(prev_attr.span, \"Previous attribute here\")\n+                        .span_note(prev_attr.span, \"previous attribute here\")\n                         .emit();\n \n                     return;"}, {"sha": "7e819e2b34e3888cdf33cc12f1aca4f89265150d", "filename": "src/test/run-pass-fulldeps/pprust-expr-roundtrip.rs", "status": "modified", "additions": 15, "deletions": 17, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/35585c499f1466037b3788598756e1eb0009f51f/src%2Ftest%2Frun-pass-fulldeps%2Fpprust-expr-roundtrip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35585c499f1466037b3788598756e1eb0009f51f/src%2Ftest%2Frun-pass-fulldeps%2Fpprust-expr-roundtrip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fpprust-expr-roundtrip.rs?ref=35585c499f1466037b3788598756e1eb0009f51f", "patch": "@@ -1,23 +1,21 @@\n // ignore-cross-compile\n \n-\n // The general idea of this test is to enumerate all \"interesting\" expressions and check that\n-// `parse(print(e)) == e` for all `e`.  Here's what's interesting, for the purposes of this test:\n+// `parse(print(e)) == e` for all `e`. Here's what's interesting, for the purposes of this test:\n //\n-//  1. The test focuses on expression nesting, because interactions between different expression\n-//     types are harder to test manually than single expression types in isolation.\n+// 1. The test focuses on expression nesting, because interactions between different expression\n+//    types are harder to test manually than single expression types in isolation.\n //\n-//  2. The test only considers expressions of at most two nontrivial nodes.  So it will check `x +\n-//     x` and `x + (x - x)` but not `(x * x) + (x - x)`.  The assumption here is that the correct\n-//     handling of an expression might depend on the expression's parent, but doesn't depend on its\n-//     siblings or any more distant ancestors.\n+// 2. The test only considers expressions of at most two nontrivial nodes. So it will check `x +\n+//    x` and `x + (x - x)` but not `(x * x) + (x - x)`. The assumption here is that the correct\n+//    handling of an expression might depend on the expression's parent, but doesn't depend on its\n+//    siblings or any more distant ancestors.\n //\n-// 3. The test only checks certain expression kinds.  The assumption is that similar expression\n-//    types, such as `if` and `while` or `+` and `-`,  will be handled identically in the printer\n-//    and parser.  So if all combinations of exprs involving `if` work correctly, then combinations\n+// 3. The test only checks certain expression kinds. The assumption is that similar expression\n+//    types, such as `if` and `while` or `+` and `-`, will be handled identically in the printer\n+//    and parser. So if all combinations of exprs involving `if` work correctly, then combinations\n //    using `while`, `if let`, and so on will likely work as well.\n \n-\n #![feature(rustc_private)]\n \n extern crate rustc_data_structures;\n@@ -155,9 +153,9 @@ fn iter_exprs(depth: usize, f: &mut dyn FnMut(P<Expr>)) {\n }\n \n \n-// Folders for manipulating the placement of `Paren` nodes.  See below for why this is needed.\n+// Folders for manipulating the placement of `Paren` nodes. See below for why this is needed.\n \n-/// MutVisitor that removes all `ExprKind::Paren` nodes.\n+/// `MutVisitor` that removes all `ExprKind::Paren` nodes.\n struct RemoveParens;\n \n impl MutVisitor for RemoveParens {\n@@ -171,7 +169,7 @@ impl MutVisitor for RemoveParens {\n }\n \n \n-/// MutVisitor that inserts `ExprKind::Paren` nodes around every `Expr`.\n+/// `MutVisitor` that inserts `ExprKind::Paren` nodes around every `Expr`.\n struct AddParens;\n \n impl MutVisitor for AddParens {\n@@ -205,8 +203,8 @@ fn run() {\n \n         // We want to know if `parsed` is structurally identical to `e`, ignoring trivial\n         // differences like placement of `Paren`s or the exact ranges of node spans.\n-        // Unfortunately, there is no easy way to make this comparison.  Instead, we add `Paren`s\n-        // everywhere we can, then pretty-print.  This should give an unambiguous representation of\n+        // Unfortunately, there is no easy way to make this comparison. Instead, we add `Paren`s\n+        // everywhere we can, then pretty-print. This should give an unambiguous representation of\n         // each `Expr`, and it bypasses nearly all of the parenthesization logic, so we aren't\n         // relying on the correctness of the very thing we're testing.\n         RemoveParens.visit_expr(&mut e);"}, {"sha": "39d25eb7fe05bace42367cca5e72504f30e5f680", "filename": "src/test/run-pass/traits/trait-object-auto-dedup.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/35585c499f1466037b3788598756e1eb0009f51f/src%2Ftest%2Frun-pass%2Ftraits%2Ftrait-object-auto-dedup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35585c499f1466037b3788598756e1eb0009f51f/src%2Ftest%2Frun-pass%2Ftraits%2Ftrait-object-auto-dedup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftraits%2Ftrait-object-auto-dedup.rs?ref=35585c499f1466037b3788598756e1eb0009f51f", "patch": "@@ -1,14 +1,15 @@\n // run-pass\n+\n #![allow(unused_assignments)]\n+\n // Test that duplicate auto trait bounds in trait objects don't create new types.\n #[allow(unused_assignments)]\n-\n use std::marker::Send as SendAlias;\n \n // A dummy trait for the non-auto trait.\n trait Trait {}\n \n-// A dummy struct to implement Trait, Send, and .\n+// A dummy struct to implement `Trait` and `Send`.\n struct Struct;\n \n impl Trait for Struct {}\n@@ -23,12 +24,12 @@ impl dyn Trait + Send + Send {\n }\n \n fn main() {\n-    // 1. Moving into a variable with more Sends and back.\n+    // 1. Moving into a variable with more `Send`s and back.\n     let mut dyn_trait_send = Box::new(Struct) as Box<dyn Trait + Send>;\n     let dyn_trait_send_send: Box<dyn Trait + Send + Send> = dyn_trait_send;\n     dyn_trait_send = dyn_trait_send_send;\n \n-    // 2. Calling methods with different number of Sends.\n+    // 2. Calling methods with different number of `Send`s.\n     let dyn_trait_send = Box::new(Struct) as Box<dyn Trait + Send>;\n     takes_dyn_trait_send_send(dyn_trait_send);\n "}, {"sha": "04793c67b564d27a02c366c308521b7a5dc7ac5b", "filename": "src/test/ui/existential_types/no_revealing_outside_defining_module.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/35585c499f1466037b3788598756e1eb0009f51f/src%2Ftest%2Fui%2Fexistential_types%2Fno_revealing_outside_defining_module.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35585c499f1466037b3788598756e1eb0009f51f/src%2Ftest%2Fui%2Fexistential_types%2Fno_revealing_outside_defining_module.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexistential_types%2Fno_revealing_outside_defining_module.rs?ref=35585c499f1466037b3788598756e1eb0009f51f", "patch": "@@ -9,7 +9,7 @@ mod boo {\n     }\n }\n \n-// don't actually know the type here\n+// We don't actually know the type here.\n \n fn bomp2() {\n     let _: &str = bomp(); //~ ERROR mismatched types"}, {"sha": "f3cc5becc6f74c5f5515dbae2a5910c8557c4d38", "filename": "src/test/ui/type/type-alias-bounds.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/35585c499f1466037b3788598756e1eb0009f51f/src%2Ftest%2Fui%2Ftype%2Ftype-alias-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35585c499f1466037b3788598756e1eb0009f51f/src%2Ftest%2Fui%2Ftype%2Ftype-alias-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Ftype-alias-bounds.rs?ref=35585c499f1466037b3788598756e1eb0009f51f", "patch": "@@ -1,44 +1,44 @@\n-// Test ignored_generic_bounds lint warning about bounds in type aliases\n+// Test `ignored_generic_bounds` lint warning about bounds in type aliases.\n \n // compile-pass\n #![allow(dead_code)]\n \n use std::rc::Rc;\n \n-type SVec<T: Send+Send> = Vec<T>;\n+type SVec<T: Send + Send> = Vec<T>;\n //~^ WARN bounds on generic parameters are not enforced in type aliases [type_alias_bounds]\n type S2Vec<T> where T: Send = Vec<T>;\n //~^ WARN where clauses are not enforced in type aliases [type_alias_bounds]\n-type VVec<'b, 'a: 'b+'b> = (&'b u32, Vec<&'a i32>);\n+type VVec<'b, 'a: 'b + 'b> = (&'b u32, Vec<&'a i32>);\n //~^ WARN bounds on generic parameters are not enforced in type aliases [type_alias_bounds]\n-type WVec<'b, T: 'b+'b> = (&'b u32, Vec<T>);\n+type WVec<'b, T: 'b + 'b> = (&'b u32, Vec<T>);\n //~^ WARN bounds on generic parameters are not enforced in type aliases [type_alias_bounds]\n type W2Vec<'b, T> where T: 'b, T: 'b = (&'b u32, Vec<T>);\n //~^ WARN where clauses are not enforced in type aliases [type_alias_bounds]\n \n-static STATIC : u32 = 0;\n+static STATIC: u32 = 0;\n \n fn foo<'a>(y: &'a i32) {\n     // If any of the bounds above would matter, the code below would be rejected.\n     // This can be seen when replacing the type aliases above by newtype structs.\n     // (The type aliases have no unused parameters to make that a valid transformation.)\n-    let mut x : SVec<_> = Vec::new();\n+    let mut x: SVec<_> = Vec::new();\n     x.push(Rc::new(42)); // is not send\n \n-    let mut x : S2Vec<_> = Vec::new();\n-    x.push(Rc::new(42)); // is not send\n+    let mut x: S2Vec<_> = Vec::new();\n+    x.push(Rc::new(42)); // is not `Send`\n \n-    let mut x : VVec<'static, 'a> = (&STATIC, Vec::new());\n-    x.1.push(y); // 'a: 'static does not hold\n+    let mut x: VVec<'static, 'a> = (&STATIC, Vec::new());\n+    x.1.push(y); // `'a: 'static` does not hold\n \n-    let mut x : WVec<'static, &'a i32> = (&STATIC, Vec::new());\n-    x.1.push(y); // &'a i32: 'static does not hold\n+    let mut x: WVec<'static, &'a i32> = (&STATIC, Vec::new());\n+    x.1.push(y); // `&'a i32: 'static` does not hold\n \n-    let mut x : W2Vec<'static, &'a i32> = (&STATIC, Vec::new());\n-    x.1.push(y); // &'a i32: 'static does not hold\n+    let mut x: W2Vec<'static, &'a i32> = (&STATIC, Vec::new());\n+    x.1.push(y); // `&'a i32: 'static` does not hold\n }\n \n-// Bounds are not checked either, i.e., the definition is not necessarily well-formed\n+// Bounds are not checked either; i.e., the definition is not necessarily well-formed.\n struct Sendable<T: Send>(T);\n type MySendable<T> = Sendable<T>; // no error here!\n \n@@ -47,9 +47,9 @@ trait Bound { type Assoc; }\n type T1<U: Bound> = U::Assoc; //~ WARN not enforced in type aliases\n type T2<U> where U: Bound = U::Assoc;  //~ WARN not enforced in type aliases\n \n-// This errors\n-// type T3<U> = U::Assoc;\n-// Do this instead\n+// This errors:\n+// `type T3<U> = U::Assoc;`\n+// Do this instead:\n type T4<U> = <U as Bound>::Assoc;\n \n // Make sure the help about associatd types is not shown incorrectly"}, {"sha": "c0ff56d5ec03842a5b0339a2c3ce12aafab2913a", "filename": "src/test/ui/type/type-alias-bounds.stderr", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/35585c499f1466037b3788598756e1eb0009f51f/src%2Ftest%2Fui%2Ftype%2Ftype-alias-bounds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/35585c499f1466037b3788598756e1eb0009f51f/src%2Ftest%2Fui%2Ftype%2Ftype-alias-bounds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Ftype-alias-bounds.stderr?ref=35585c499f1466037b3788598756e1eb0009f51f", "patch": "@@ -1,8 +1,18 @@\n+warning: duplicate auto trait `::marker[0]::Send[0]` found in type parameter bounds\n+  --> $DIR/type-alias-bounds.rs:8:14\n+   |\n+LL | type SVec<T: Send + Send> = Vec<T>;\n+   |              ^^^^   ^^^^ subsequent use of auto trait\n+   |              |\n+   |              first use of auto trait\n+   |\n+   = note: #[warn(duplicate_auto_traits_in_bounds)] on by default\n+\n warning: bounds on generic parameters are not enforced in type aliases\n   --> $DIR/type-alias-bounds.rs:8:14\n    |\n-LL | type SVec<T: Send+Send> = Vec<T>;\n-   |              ^^^^ ^^^^\n+LL | type SVec<T: Send + Send> = Vec<T>;\n+   |              ^^^^   ^^^^\n    |\n    = note: #[warn(type_alias_bounds)] on by default\n    = help: the bound will not be checked when the type alias is used, and should be removed\n@@ -18,16 +28,16 @@ LL | type S2Vec<T> where T: Send = Vec<T>;\n warning: bounds on generic parameters are not enforced in type aliases\n   --> $DIR/type-alias-bounds.rs:12:19\n    |\n-LL | type VVec<'b, 'a: 'b+'b> = (&'b u32, Vec<&'a i32>);\n-   |                   ^^ ^^\n+LL | type VVec<'b, 'a: 'b + 'b> = (&'b u32, Vec<&'a i32>);\n+   |                   ^^   ^^\n    |\n    = help: the bound will not be checked when the type alias is used, and should be removed\n \n warning: bounds on generic parameters are not enforced in type aliases\n   --> $DIR/type-alias-bounds.rs:14:18\n    |\n-LL | type WVec<'b, T: 'b+'b> = (&'b u32, Vec<T>);\n-   |                  ^^ ^^\n+LL | type WVec<'b, T: 'b + 'b> = (&'b u32, Vec<T>);\n+   |                  ^^   ^^\n    |\n    = help: the bound will not be checked when the type alias is used, and should be removed\n "}]}