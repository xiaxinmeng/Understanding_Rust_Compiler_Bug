{"sha": "303d916867040e269b54adf3cfc7f5c903dc26ff", "node_id": "C_kwDOAAsO6NoAKDMwM2Q5MTY4NjcwNDBlMjY5YjU0YWRmM2NmYzdmNWM5MDNkYzI2ZmY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-29T05:56:09Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-29T05:56:09Z"}, "message": "Auto merge of #96687 - jyn514:download-rustc, r=Mark-Simulacrum\n\nMove download-rustc from python to rustbuild\n\n- Remove download-rustc handling from bootstrap.py\n- Allow a custom `pattern` in `builder.unpack()`\n- Only download rustc once another part of bootstrap depends on it.\n\n  This is somewhat necessary since the download functions rely on having a full\n  `Builder`, which isn't available until after config parsing finishes.\n\nHelps with https://github.com/rust-lang/rust/issues/94829.", "tree": {"sha": "fd4ff88b3f4aae510b7d48260c94546db6c03fbd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fd4ff88b3f4aae510b7d48260c94546db6c03fbd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/303d916867040e269b54adf3cfc7f5c903dc26ff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/303d916867040e269b54adf3cfc7f5c903dc26ff", "html_url": "https://github.com/rust-lang/rust/commit/303d916867040e269b54adf3cfc7f5c903dc26ff", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/303d916867040e269b54adf3cfc7f5c903dc26ff/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0acc4a35853215a6f9388ab61455ced309711003", "url": "https://api.github.com/repos/rust-lang/rust/commits/0acc4a35853215a6f9388ab61455ced309711003", "html_url": "https://github.com/rust-lang/rust/commit/0acc4a35853215a6f9388ab61455ced309711003"}, {"sha": "00bb4df1fbfdcc9249f8fd5e009b0e18d30c96bf", "url": "https://api.github.com/repos/rust-lang/rust/commits/00bb4df1fbfdcc9249f8fd5e009b0e18d30c96bf", "html_url": "https://github.com/rust-lang/rust/commit/00bb4df1fbfdcc9249f8fd5e009b0e18d30c96bf"}], "stats": {"total": 770, "additions": 418, "deletions": 352}, "files": [{"sha": "955edd94c7828fd3432c735f1c5d0ab1ce027637", "filename": "src/bootstrap/bootstrap.py", "status": "modified", "additions": 38, "deletions": 116, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/303d916867040e269b54adf3cfc7f5c903dc26ff/src%2Fbootstrap%2Fbootstrap.py", "raw_url": "https://github.com/rust-lang/rust/raw/303d916867040e269b54adf3cfc7f5c903dc26ff/src%2Fbootstrap%2Fbootstrap.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbootstrap.py?ref=303d916867040e269b54adf3cfc7f5c903dc26ff", "patch": "@@ -444,9 +444,8 @@ def __init__(self):\n         self.verbose = False\n         self.git_version = None\n         self.nix_deps_dir = None\n-        self.rustc_commit = None\n \n-    def download_toolchain(self, stage0=True, rustc_channel=None):\n+    def download_toolchain(self):\n         \"\"\"Fetch the build system for Rust, written in Rust\n \n         This method will build a cache directory, then it will fetch the\n@@ -456,45 +455,35 @@ def download_toolchain(self, stage0=True, rustc_channel=None):\n         Each downloaded tarball is extracted, after that, the script\n         will move all the content to the right place.\n         \"\"\"\n-        if rustc_channel is None:\n-            rustc_channel = self.stage0_compiler.version\n-        bin_root = self.bin_root(stage0)\n+        rustc_channel = self.stage0_compiler.version\n+        bin_root = self.bin_root()\n \n         key = self.stage0_compiler.date\n-        if not stage0:\n-            key += str(self.rustc_commit)\n-        if self.rustc(stage0).startswith(bin_root) and \\\n-                (not os.path.exists(self.rustc(stage0)) or\n-                 self.program_out_of_date(self.rustc_stamp(stage0), key)):\n+        if self.rustc().startswith(bin_root) and \\\n+                (not os.path.exists(self.rustc()) or\n+                 self.program_out_of_date(self.rustc_stamp(), key)):\n             if os.path.exists(bin_root):\n                 shutil.rmtree(bin_root)\n             tarball_suffix = '.tar.xz' if support_xz() else '.tar.gz'\n             filename = \"rust-std-{}-{}{}\".format(\n                 rustc_channel, self.build, tarball_suffix)\n             pattern = \"rust-std-{}\".format(self.build)\n-            self._download_component_helper(filename, pattern, tarball_suffix, stage0)\n+            self._download_component_helper(filename, pattern, tarball_suffix)\n             filename = \"rustc-{}-{}{}\".format(rustc_channel, self.build,\n                                               tarball_suffix)\n-            self._download_component_helper(filename, \"rustc\", tarball_suffix, stage0)\n-            # download-rustc doesn't need its own cargo, it can just use beta's.\n-            if stage0:\n-                filename = \"cargo-{}-{}{}\".format(rustc_channel, self.build,\n-                                                tarball_suffix)\n-                self._download_component_helper(filename, \"cargo\", tarball_suffix)\n-                self.fix_bin_or_dylib(\"{}/bin/cargo\".format(bin_root))\n-            else:\n-                filename = \"rustc-dev-{}-{}{}\".format(rustc_channel, self.build, tarball_suffix)\n-                self._download_component_helper(\n-                    filename, \"rustc-dev\", tarball_suffix, stage0\n-                )\n+            self._download_component_helper(filename, \"rustc\", tarball_suffix)\n+            filename = \"cargo-{}-{}{}\".format(rustc_channel, self.build,\n+                                            tarball_suffix)\n+            self._download_component_helper(filename, \"cargo\", tarball_suffix)\n+            self.fix_bin_or_dylib(\"{}/bin/cargo\".format(bin_root))\n \n             self.fix_bin_or_dylib(\"{}/bin/rustc\".format(bin_root))\n             self.fix_bin_or_dylib(\"{}/bin/rustdoc\".format(bin_root))\n             lib_dir = \"{}/lib\".format(bin_root)\n             for lib in os.listdir(lib_dir):\n                 if lib.endswith(\".so\"):\n                     self.fix_bin_or_dylib(os.path.join(lib_dir, lib))\n-            with output(self.rustc_stamp(stage0)) as rust_stamp:\n+            with output(self.rustc_stamp()) as rust_stamp:\n                 rust_stamp.write(key)\n \n         if self.rustfmt() and self.rustfmt().startswith(bin_root) and (\n@@ -518,24 +507,17 @@ def download_toolchain(self, stage0=True, rustc_channel=None):\n                     rustfmt_stamp.write(self.stage0_rustfmt.channel())\n \n     def _download_component_helper(\n-        self, filename, pattern, tarball_suffix, stage0=True, key=None\n+        self, filename, pattern, tarball_suffix, key=None\n     ):\n         if key is None:\n-            if stage0:\n-                key = self.stage0_compiler.date\n-            else:\n-                key = self.rustc_commit\n+            key = self.stage0_compiler.date\n         cache_dst = os.path.join(self.build_dir, \"cache\")\n         rustc_cache = os.path.join(cache_dst, key)\n         if not os.path.exists(rustc_cache):\n             os.makedirs(rustc_cache)\n \n-        if stage0:\n-            base = self._download_url\n-            url = \"dist/{}\".format(key)\n-        else:\n-            base = \"https://ci-artifacts.rust-lang.org\"\n-            url = \"rustc-builds/{}\".format(self.rustc_commit)\n+        base = self._download_url\n+        url = \"dist/{}\".format(key)\n         tarball = os.path.join(rustc_cache, filename)\n         if not os.path.exists(tarball):\n             get(\n@@ -544,9 +526,9 @@ def _download_component_helper(\n                 tarball,\n                 self.checksums_sha256,\n                 verbose=self.verbose,\n-                do_verify=stage0,\n+                do_verify=True,\n             )\n-        unpack(tarball, tarball_suffix, self.bin_root(stage0), match=pattern, verbose=self.verbose)\n+        unpack(tarball, tarball_suffix, self.bin_root(), match=pattern, verbose=self.verbose)\n \n     def fix_bin_or_dylib(self, fname):\n         \"\"\"Modifies the interpreter section of 'fname' to fix the dynamic linker,\n@@ -644,62 +626,15 @@ def fix_bin_or_dylib(self, fname):\n             print(\"warning: failed to call patchelf:\", reason)\n             return\n \n-    # If `download-rustc` is set, download the most recent commit with CI artifacts\n-    def maybe_download_ci_toolchain(self):\n-        # If `download-rustc` is not set, default to rebuilding.\n-        download_rustc = self.get_toml(\"download-rustc\", section=\"rust\")\n-        if download_rustc is None or download_rustc == \"false\":\n-            return None\n-        assert download_rustc == \"true\" or download_rustc == \"if-unchanged\", download_rustc\n-\n-        # Handle running from a directory other than the top level\n-        rev_parse = [\"git\", \"rev-parse\", \"--show-toplevel\"]\n-        top_level = subprocess.check_output(rev_parse, universal_newlines=True).strip()\n-        compiler = \"{}/compiler/\".format(top_level)\n-        library = \"{}/library/\".format(top_level)\n-\n-        # Look for a version to compare to based on the current commit.\n-        # Only commits merged by bors will have CI artifacts.\n-        merge_base = [\n-            \"git\", \"rev-list\", \"--author=bors@rust-lang.org\", \"-n1\",\n-            \"--first-parent\", \"HEAD\"\n-        ]\n-        commit = subprocess.check_output(merge_base, universal_newlines=True).strip()\n-        if not commit:\n-            print(\"error: could not find commit hash for downloading rustc\")\n-            print(\"help: maybe your repository history is too shallow?\")\n-            print(\"help: consider disabling `download-rustc`\")\n-            print(\"help: or fetch enough history to include one upstream commit\")\n-            exit(1)\n-\n-        # Warn if there were changes to the compiler or standard library since the ancestor commit.\n-        status = subprocess.call([\"git\", \"diff-index\", \"--quiet\", commit, \"--\", compiler, library])\n-        if status != 0:\n-            if download_rustc == \"if-unchanged\":\n-                if self.verbose:\n-                    print(\"warning: saw changes to compiler/ or library/ since {}; \" \\\n-                          \"ignoring `download-rustc`\".format(commit))\n-                return None\n-            print(\"warning: `download-rustc` is enabled, but there are changes to \" \\\n-                  \"compiler/ or library/\")\n-\n-        if self.verbose:\n-            print(\"using downloaded stage2 artifacts from CI (commit {})\".format(commit))\n-        self.rustc_commit = commit\n-        # FIXME: support downloading artifacts from the beta channel\n-        self.download_toolchain(False, \"nightly\")\n-\n-    def rustc_stamp(self, stage0):\n+    def rustc_stamp(self):\n         \"\"\"Return the path for .rustc-stamp at the given stage\n \n         >>> rb = RustBuild()\n         >>> rb.build_dir = \"build\"\n-        >>> rb.rustc_stamp(True) == os.path.join(\"build\", \"stage0\", \".rustc-stamp\")\n-        True\n-        >>> rb.rustc_stamp(False) == os.path.join(\"build\", \"ci-rustc\", \".rustc-stamp\")\n+        >>> rb.rustc_stamp() == os.path.join(\"build\", \"stage0\", \".rustc-stamp\")\n         True\n         \"\"\"\n-        return os.path.join(self.bin_root(stage0), '.rustc-stamp')\n+        return os.path.join(self.bin_root(), '.rustc-stamp')\n \n     def rustfmt_stamp(self):\n         \"\"\"Return the path for .rustfmt-stamp\n@@ -709,7 +644,7 @@ def rustfmt_stamp(self):\n         >>> rb.rustfmt_stamp() == os.path.join(\"build\", \"stage0\", \".rustfmt-stamp\")\n         True\n         \"\"\"\n-        return os.path.join(self.bin_root(True), '.rustfmt-stamp')\n+        return os.path.join(self.bin_root(), '.rustfmt-stamp')\n \n     def program_out_of_date(self, stamp_path, key):\n         \"\"\"Check if the given program stamp is out of date\"\"\"\n@@ -718,26 +653,21 @@ def program_out_of_date(self, stamp_path, key):\n         with open(stamp_path, 'r') as stamp:\n             return key != stamp.read()\n \n-    def bin_root(self, stage0):\n+    def bin_root(self):\n         \"\"\"Return the binary root directory for the given stage\n \n         >>> rb = RustBuild()\n         >>> rb.build_dir = \"build\"\n-        >>> rb.bin_root(True) == os.path.join(\"build\", \"stage0\")\n-        True\n-        >>> rb.bin_root(False) == os.path.join(\"build\", \"ci-rustc\")\n+        >>> rb.bin_root() == os.path.join(\"build\", \"stage0\")\n         True\n \n         When the 'build' property is given should be a nested directory:\n \n         >>> rb.build = \"devel\"\n-        >>> rb.bin_root(True) == os.path.join(\"build\", \"devel\", \"stage0\")\n+        >>> rb.bin_root() == os.path.join(\"build\", \"devel\", \"stage0\")\n         True\n         \"\"\"\n-        if stage0:\n-            subdir = \"stage0\"\n-        else:\n-            subdir = \"ci-rustc\"\n+        subdir = \"stage0\"\n         return os.path.join(self.build_dir, self.build, subdir)\n \n     def get_toml(self, key, section=None):\n@@ -785,37 +715,33 @@ def cargo(self):\n         \"\"\"Return config path for cargo\"\"\"\n         return self.program_config('cargo')\n \n-    def rustc(self, stage0):\n+    def rustc(self):\n         \"\"\"Return config path for rustc\"\"\"\n-        return self.program_config('rustc', stage0)\n+        return self.program_config('rustc')\n \n     def rustfmt(self):\n         \"\"\"Return config path for rustfmt\"\"\"\n         if self.stage0_rustfmt is None:\n             return None\n         return self.program_config('rustfmt')\n \n-    def program_config(self, program, stage0=True):\n+    def program_config(self, program):\n         \"\"\"Return config path for the given program at the given stage\n \n         >>> rb = RustBuild()\n         >>> rb.config_toml = 'rustc = \"rustc\"\\\\n'\n         >>> rb.program_config('rustc')\n         'rustc'\n         >>> rb.config_toml = ''\n-        >>> cargo_path = rb.program_config('cargo', True)\n-        >>> cargo_path.rstrip(\".exe\") == os.path.join(rb.bin_root(True),\n-        ... \"bin\", \"cargo\")\n-        True\n-        >>> cargo_path = rb.program_config('cargo', False)\n-        >>> cargo_path.rstrip(\".exe\") == os.path.join(rb.bin_root(False),\n+        >>> cargo_path = rb.program_config('cargo')\n+        >>> cargo_path.rstrip(\".exe\") == os.path.join(rb.bin_root(),\n         ... \"bin\", \"cargo\")\n         True\n         \"\"\"\n         config = self.get_toml(program)\n         if config:\n             return os.path.expanduser(config)\n-        return os.path.join(self.bin_root(stage0), \"bin\", \"{}{}\".format(\n+        return os.path.join(self.bin_root(), \"bin\", \"{}{}\".format(\n             program, self.exe_suffix()))\n \n     @staticmethod\n@@ -871,14 +797,14 @@ def build_bootstrap(self):\n         if \"CARGO_BUILD_TARGET\" in env:\n             del env[\"CARGO_BUILD_TARGET\"]\n         env[\"CARGO_TARGET_DIR\"] = build_dir\n-        env[\"RUSTC\"] = self.rustc(True)\n-        env[\"LD_LIBRARY_PATH\"] = os.path.join(self.bin_root(True), \"lib\") + \\\n+        env[\"RUSTC\"] = self.rustc()\n+        env[\"LD_LIBRARY_PATH\"] = os.path.join(self.bin_root(), \"lib\") + \\\n             (os.pathsep + env[\"LD_LIBRARY_PATH\"]) \\\n             if \"LD_LIBRARY_PATH\" in env else \"\"\n-        env[\"DYLD_LIBRARY_PATH\"] = os.path.join(self.bin_root(True), \"lib\") + \\\n+        env[\"DYLD_LIBRARY_PATH\"] = os.path.join(self.bin_root(), \"lib\") + \\\n             (os.pathsep + env[\"DYLD_LIBRARY_PATH\"]) \\\n             if \"DYLD_LIBRARY_PATH\" in env else \"\"\n-        env[\"LIBRARY_PATH\"] = os.path.join(self.bin_root(True), \"lib\") + \\\n+        env[\"LIBRARY_PATH\"] = os.path.join(self.bin_root(), \"lib\") + \\\n             (os.pathsep + env[\"LIBRARY_PATH\"]) \\\n             if \"LIBRARY_PATH\" in env else \"\"\n \n@@ -900,7 +826,7 @@ def build_bootstrap(self):\n         if self.get_toml(\"deny-warnings\", \"rust\") != \"false\":\n             env[\"RUSTFLAGS\"] += \" -Dwarnings\"\n \n-        env[\"PATH\"] = os.path.join(self.bin_root(True), \"bin\") + \\\n+        env[\"PATH\"] = os.path.join(self.bin_root(), \"bin\") + \\\n             os.pathsep + env[\"PATH\"]\n         if not os.path.isfile(self.cargo()):\n             raise Exception(\"no cargo executable found at `{}`\".format(\n@@ -1171,8 +1097,6 @@ def bootstrap(help_triggered):\n \n     # Fetch/build the bootstrap\n     build.download_toolchain()\n-    # Download the master compiler if `download-rustc` is set\n-    build.maybe_download_ci_toolchain()\n     sys.stdout.flush()\n     build.ensure_vendored()\n     build.build_bootstrap()\n@@ -1184,8 +1108,6 @@ def bootstrap(help_triggered):\n     env = os.environ.copy()\n     env[\"BOOTSTRAP_PARENT_ID\"] = str(os.getpid())\n     env[\"BOOTSTRAP_PYTHON\"] = sys.executable\n-    if build.rustc_commit is not None:\n-        env[\"BOOTSTRAP_DOWNLOAD_RUSTC\"] = '1'\n     run(args, env=env, verbose=build.verbose, is_bootstrap=True)\n \n "}, {"sha": "d344c55158ac17bc1895055e7af14a51ead8d528", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 212, "deletions": 5, "changes": 217, "blob_url": "https://github.com/rust-lang/rust/blob/303d916867040e269b54adf3cfc7f5c903dc26ff/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/303d916867040e269b54adf3cfc7f5c903dc26ff/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=303d916867040e269b54adf3cfc7f5c903dc26ff", "patch": "@@ -2,13 +2,14 @@ use std::any::{type_name, Any};\n use std::cell::{Cell, RefCell};\n use std::collections::BTreeSet;\n use std::env;\n-use std::ffi::OsStr;\n+use std::ffi::{OsStr, OsString};\n use std::fmt::{Debug, Write};\n-use std::fs;\n+use std::fs::{self, File};\n use std::hash::Hash;\n+use std::io::{BufRead, BufReader, ErrorKind};\n use std::ops::Deref;\n use std::path::{Component, Path, PathBuf};\n-use std::process::Command;\n+use std::process::{Command, Stdio};\n use std::time::{Duration, Instant};\n \n use crate::cache::{Cache, Interned, INTERNER};\n@@ -29,7 +30,8 @@ use crate::{Build, CLang, DocTests, GitRepo, Mode};\n \n pub use crate::Compiler;\n // FIXME: replace with std::lazy after it gets stabilized and reaches beta\n-use once_cell::sync::Lazy;\n+use once_cell::sync::{Lazy, OnceCell};\n+use xz2::bufread::XzDecoder;\n \n pub struct Builder<'a> {\n     pub build: &'a Build,\n@@ -758,6 +760,207 @@ impl<'a> Builder<'a> {\n         StepDescription::run(v, self, paths);\n     }\n \n+    /// Modifies the interpreter section of 'fname' to fix the dynamic linker,\n+    /// or the RPATH section, to fix the dynamic library search path\n+    ///\n+    /// This is only required on NixOS and uses the PatchELF utility to\n+    /// change the interpreter/RPATH of ELF executables.\n+    ///\n+    /// Please see https://nixos.org/patchelf.html for more information\n+    pub(crate) fn fix_bin_or_dylib(&self, fname: &Path) {\n+        // FIXME: cache NixOS detection?\n+        match Command::new(\"uname\").arg(\"-s\").stderr(Stdio::inherit()).output() {\n+            Err(_) => return,\n+            Ok(output) if !output.status.success() => return,\n+            Ok(output) => {\n+                let mut s = output.stdout;\n+                if s.last() == Some(&b'\\n') {\n+                    s.pop();\n+                }\n+                if s != b\"Linux\" {\n+                    return;\n+                }\n+            }\n+        }\n+\n+        // If the user has asked binaries to be patched for Nix, then\n+        // don't check for NixOS or `/lib`, just continue to the patching.\n+        // NOTE: this intentionally comes after the Linux check:\n+        // - patchelf only works with ELF files, so no need to run it on Mac or Windows\n+        // - On other Unix systems, there is no stable syscall interface, so Nix doesn't manage the global libc.\n+        if !self.config.patch_binaries_for_nix {\n+            // Use `/etc/os-release` instead of `/etc/NIXOS`.\n+            // The latter one does not exist on NixOS when using tmpfs as root.\n+            const NIX_IDS: &[&str] = &[\"ID=nixos\", \"ID='nixos'\", \"ID=\\\"nixos\\\"\"];\n+            let os_release = match File::open(\"/etc/os-release\") {\n+                Err(e) if e.kind() == ErrorKind::NotFound => return,\n+                Err(e) => panic!(\"failed to access /etc/os-release: {}\", e),\n+                Ok(f) => f,\n+            };\n+            if !BufReader::new(os_release).lines().any(|l| NIX_IDS.contains(&t!(l).trim())) {\n+                return;\n+            }\n+            if Path::new(\"/lib\").exists() {\n+                return;\n+            }\n+        }\n+\n+        // At this point we're pretty sure the user is running NixOS or using Nix\n+        println!(\"info: you seem to be using Nix. Attempting to patch {}\", fname.display());\n+\n+        // Only build `.nix-deps` once.\n+        static NIX_DEPS_DIR: OnceCell<PathBuf> = OnceCell::new();\n+        let mut nix_build_succeeded = true;\n+        let nix_deps_dir = NIX_DEPS_DIR.get_or_init(|| {\n+            // Run `nix-build` to \"build\" each dependency (which will likely reuse\n+            // the existing `/nix/store` copy, or at most download a pre-built copy).\n+            //\n+            // Importantly, we create a gc-root called `.nix-deps` in the `build/`\n+            // directory, but still reference the actual `/nix/store` path in the rpath\n+            // as it makes it significantly more robust against changes to the location of\n+            // the `.nix-deps` location.\n+            //\n+            // bintools: Needed for the path of `ld-linux.so` (via `nix-support/dynamic-linker`).\n+            // zlib: Needed as a system dependency of `libLLVM-*.so`.\n+            // patchelf: Needed for patching ELF binaries (see doc comment above).\n+            let nix_deps_dir = self.out.join(\".nix-deps\");\n+            const NIX_EXPR: &str = \"\n+            with (import <nixpkgs> {});\n+            symlinkJoin {\n+                name = \\\"rust-stage0-dependencies\\\";\n+                paths = [\n+                    zlib\n+                    patchelf\n+                    stdenv.cc.bintools\n+                ];\n+            }\n+            \";\n+            nix_build_succeeded = self.try_run(Command::new(\"nix-build\").args(&[\n+                Path::new(\"-E\"),\n+                Path::new(NIX_EXPR),\n+                Path::new(\"-o\"),\n+                &nix_deps_dir,\n+            ]));\n+            nix_deps_dir\n+        });\n+        if !nix_build_succeeded {\n+            return;\n+        }\n+\n+        let mut patchelf = Command::new(nix_deps_dir.join(\"bin/patchelf\"));\n+        let rpath_entries = {\n+            // ORIGIN is a relative default, all binary and dynamic libraries we ship\n+            // appear to have this (even when `../lib` is redundant).\n+            // NOTE: there are only two paths here, delimited by a `:`\n+            let mut entries = OsString::from(\"$ORIGIN/../lib:\");\n+            entries.push(t!(fs::canonicalize(nix_deps_dir)));\n+            entries.push(\"/lib\");\n+            entries\n+        };\n+        patchelf.args(&[OsString::from(\"--set-rpath\"), rpath_entries]);\n+        if !fname.extension().map_or(false, |ext| ext == \"so\") {\n+            // Finally, set the corret .interp for binaries\n+            let dynamic_linker_path = nix_deps_dir.join(\"nix-support/dynamic-linker\");\n+            // FIXME: can we support utf8 here? `args` doesn't accept Vec<u8>, only OsString ...\n+            let dynamic_linker = t!(String::from_utf8(t!(fs::read(dynamic_linker_path))));\n+            patchelf.args(&[\"--set-interpreter\", dynamic_linker.trim_end()]);\n+        }\n+\n+        self.try_run(patchelf.arg(fname));\n+    }\n+\n+    pub(crate) fn download_component(&self, base: &str, url: &str, dest_path: &Path) {\n+        // Use a temporary file in case we crash while downloading, to avoid a corrupt download in cache/.\n+        let tempfile = self.tempdir().join(dest_path.file_name().unwrap());\n+        // FIXME: support `do_verify` (only really needed for nightly rustfmt)\n+        self.download_with_retries(&tempfile, &format!(\"{}/{}\", base, url));\n+        t!(std::fs::rename(&tempfile, dest_path));\n+    }\n+\n+    fn download_with_retries(&self, tempfile: &Path, url: &str) {\n+        println!(\"downloading {}\", url);\n+        // Try curl. If that fails and we are on windows, fallback to PowerShell.\n+        let mut curl = Command::new(\"curl\");\n+        curl.args(&[\n+            \"-#\",\n+            \"-y\",\n+            \"30\",\n+            \"-Y\",\n+            \"10\", // timeout if speed is < 10 bytes/sec for > 30 seconds\n+            \"--connect-timeout\",\n+            \"30\", // timeout if cannot connect within 30 seconds\n+            \"--retry\",\n+            \"3\",\n+            \"-Sf\",\n+            \"-o\",\n+        ]);\n+        curl.arg(tempfile);\n+        curl.arg(url);\n+        if !self.check_run(&mut curl) {\n+            if self.build.build.contains(\"windows-msvc\") {\n+                println!(\"Fallback to PowerShell\");\n+                for _ in 0..3 {\n+                    if self.try_run(Command::new(\"PowerShell.exe\").args(&[\n+                        \"/nologo\",\n+                        \"-Command\",\n+                        \"[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12;\",\n+                        &format!(\n+                            \"(New-Object System.Net.WebClient).DownloadFile('{}', '{}')\",\n+                            url, tempfile.to_str().expect(\"invalid UTF-8 not supported with powershell downloads\"),\n+                        ),\n+                    ])) {\n+                        return;\n+                    }\n+                    println!(\"\\nspurious failure, trying again\");\n+                }\n+            }\n+            std::process::exit(1);\n+        }\n+    }\n+\n+    pub(crate) fn unpack(&self, tarball: &Path, dst: &Path, pattern: &str) {\n+        println!(\"extracting {} to {}\", tarball.display(), dst.display());\n+        if !dst.exists() {\n+            t!(fs::create_dir_all(dst));\n+        }\n+\n+        // `tarball` ends with `.tar.xz`; strip that suffix\n+        // example: `rust-dev-nightly-x86_64-unknown-linux-gnu`\n+        let uncompressed_filename =\n+            Path::new(tarball.file_name().expect(\"missing tarball filename\")).file_stem().unwrap();\n+        let directory_prefix = Path::new(Path::new(uncompressed_filename).file_stem().unwrap());\n+\n+        // decompress the file\n+        let data = t!(File::open(tarball));\n+        let decompressor = XzDecoder::new(BufReader::new(data));\n+\n+        let mut tar = tar::Archive::new(decompressor);\n+        for member in t!(tar.entries()) {\n+            let mut member = t!(member);\n+            let original_path = t!(member.path()).into_owned();\n+            // skip the top-level directory\n+            if original_path == directory_prefix {\n+                continue;\n+            }\n+            let mut short_path = t!(original_path.strip_prefix(directory_prefix));\n+            if !short_path.starts_with(pattern) {\n+                continue;\n+            }\n+            short_path = t!(short_path.strip_prefix(pattern));\n+            let dst_path = dst.join(short_path);\n+            self.verbose(&format!(\"extracting {} to {}\", original_path.display(), dst.display()));\n+            if !t!(member.unpack_in(dst)) {\n+                panic!(\"path traversal attack ??\");\n+            }\n+            let src_path = dst.join(original_path);\n+            if src_path.is_dir() && dst_path.exists() {\n+                continue;\n+            }\n+            t!(fs::rename(src_path, dst_path));\n+        }\n+        t!(fs::remove_dir_all(dst.join(directory_prefix)));\n+    }\n+\n     /// Obtain a compiler at a given stage and for a given host. Explicitly does\n     /// not take `Compiler` since all `Compiler` instances are meant to be\n     /// obtained through this function, since it ensures that they are valid\n@@ -819,7 +1022,7 @@ impl<'a> Builder<'a> {\n                     .join(\"lib\");\n                 // Avoid deleting the rustlib/ directory we just copied\n                 // (in `impl Step for Sysroot`).\n-                if !builder.config.download_rustc {\n+                if !builder.download_rustc() {\n                     let _ = fs::remove_dir_all(&sysroot);\n                     t!(fs::create_dir_all(&sysroot));\n                 }\n@@ -976,6 +1179,10 @@ impl<'a> Builder<'a> {\n         Config::llvm_link_shared(self)\n     }\n \n+    pub(crate) fn download_rustc(&self) -> bool {\n+        Config::download_rustc(self)\n+    }\n+\n     /// Prepares an invocation of `cargo` to be run.\n     ///\n     /// This will create a `Command` that represents a pending execution of"}, {"sha": "9958fc26be7a5e4a67232c13cfc4906ae44767ed", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/303d916867040e269b54adf3cfc7f5c903dc26ff/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/303d916867040e269b54adf3cfc7f5c903dc26ff/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=303d916867040e269b54adf3cfc7f5c903dc26ff", "patch": "@@ -42,8 +42,10 @@ impl Step for Std {\n     fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         // When downloading stage1, the standard library has already been copied to the sysroot, so\n         // there's no need to rebuild it.\n-        let download_rustc = run.builder.config.download_rustc;\n-        run.all_krates(\"test\").path(\"library\").default_condition(!download_rustc)\n+        let builder = run.builder;\n+        run.all_krates(\"test\")\n+            .path(\"library\")\n+            .lazy_default_condition(Box::new(|| !builder.download_rustc()))\n     }\n \n     fn make_run(run: RunConfig<'_>) {\n@@ -66,7 +68,7 @@ impl Step for Std {\n         // Don't recompile them.\n         // NOTE: the ABI of the beta compiler is different from the ABI of the downloaded compiler,\n         // so its artifacts can't be reused.\n-        if builder.config.download_rustc && compiler.stage != 0 {\n+        if builder.download_rustc() && compiler.stage != 0 {\n             return;\n         }\n \n@@ -551,7 +553,7 @@ impl Step for Rustc {\n \n         // NOTE: the ABI of the beta compiler is different from the ABI of the downloaded compiler,\n         // so its artifacts can't be reused.\n-        if builder.config.download_rustc && compiler.stage != 0 {\n+        if builder.download_rustc() && compiler.stage != 0 {\n             // Copy the existing artifacts instead of rebuilding them.\n             // NOTE: this path is only taken for tools linking to rustc-dev.\n             builder.ensure(Sysroot { compiler });\n@@ -995,7 +997,7 @@ impl Step for Sysroot {\n         t!(fs::create_dir_all(&sysroot));\n \n         // If we're downloading a compiler from CI, we can use the same compiler for all stages other than 0.\n-        if builder.config.download_rustc && compiler.stage != 0 {\n+        if builder.download_rustc() && compiler.stage != 0 {\n             assert_eq!(\n                 builder.config.build, compiler.host,\n                 \"Cross-compiling is not yet supported with `download-rustc`\",\n@@ -1090,7 +1092,7 @@ impl Step for Assemble {\n         let build_compiler = builder.compiler(target_compiler.stage - 1, builder.config.build);\n \n         // If we're downloading a compiler from CI, we can use the same compiler for all stages other than 0.\n-        if builder.config.download_rustc {\n+        if builder.download_rustc() {\n             builder.ensure(Sysroot { compiler: target_compiler });\n             return target_compiler;\n         }"}, {"sha": "7775e0573704fcec011563b5d4a5dee75c45538e", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 142, "deletions": 4, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/303d916867040e269b54adf3cfc7f5c903dc26ff/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/303d916867040e269b54adf3cfc7f5c903dc26ff/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=303d916867040e269b54adf3cfc7f5c903dc26ff", "patch": "@@ -7,17 +7,20 @@ use std::cell::Cell;\n use std::cmp;\n use std::collections::{HashMap, HashSet};\n use std::env;\n+use std::ffi::OsStr;\n use std::fmt;\n use std::fs;\n use std::path::{Path, PathBuf};\n+use std::process::{exit, Command};\n use std::str::FromStr;\n \n use crate::builder::{Builder, TaskPath};\n use crate::cache::{Interned, INTERNER};\n use crate::channel::GitInfo;\n pub use crate::flags::Subcommand;\n use crate::flags::{Color, Flags};\n-use crate::util::{exe, t};\n+use crate::util::{exe, output, program_out_of_date, t};\n+use once_cell::sync::OnceCell;\n use serde::{Deserialize, Deserializer};\n \n macro_rules! check_ci_llvm {\n@@ -81,7 +84,11 @@ pub struct Config {\n     pub cmd: Subcommand,\n     pub incremental: bool,\n     pub dry_run: bool,\n-    pub download_rustc: bool,\n+    /// `None` if we shouldn't download CI compiler artifacts, or the commit to download if we should.\n+    #[cfg(not(test))]\n+    download_rustc_commit: Option<String>,\n+    #[cfg(test)]\n+    pub download_rustc_commit: Option<String>,\n \n     pub deny_warnings: bool,\n     pub backtrace_on_ice: bool,\n@@ -1080,7 +1087,8 @@ impl Config {\n             config.rust_codegen_units_std = rust.codegen_units_std.map(threads_from_config);\n             config.rust_profile_use = flags.rust_profile_use.or(rust.profile_use);\n             config.rust_profile_generate = flags.rust_profile_generate.or(rust.profile_generate);\n-            config.download_rustc = env::var(\"BOOTSTRAP_DOWNLOAD_RUSTC\").as_deref() == Ok(\"1\");\n+            config.download_rustc_commit =\n+                download_ci_rustc_commit(rust.download_rustc, config.verbose > 0);\n         } else {\n             config.rust_profile_use = flags.rust_profile_use;\n             config.rust_profile_generate = flags.rust_profile_generate;\n@@ -1192,7 +1200,7 @@ impl Config {\n         let default = config.channel == \"dev\";\n         config.ignore_git = ignore_git.unwrap_or(default);\n \n-        let download_rustc = config.download_rustc;\n+        let download_rustc = config.download_rustc_commit.is_some();\n         // See https://github.com/rust-lang/compiler-team/issues/326\n         config.stage = match config.cmd {\n             Subcommand::Check { .. } => flags.stage.or(build.check_stage).unwrap_or(0),\n@@ -1309,6 +1317,23 @@ impl Config {\n         llvm_link_shared\n     }\n \n+    /// Return whether we will use a downloaded, pre-compiled version of rustc, or just build from source.\n+    pub(crate) fn download_rustc(builder: &Builder<'_>) -> bool {\n+        static DOWNLOAD_RUSTC: OnceCell<bool> = OnceCell::new();\n+        if builder.config.dry_run && DOWNLOAD_RUSTC.get().is_none() {\n+            // avoid trying to actually download the commit\n+            return false;\n+        }\n+\n+        *DOWNLOAD_RUSTC.get_or_init(|| match &builder.config.download_rustc_commit {\n+            None => false,\n+            Some(commit) => {\n+                download_ci_rustc(builder, commit);\n+                true\n+            }\n+        })\n+    }\n+\n     pub fn verbose(&self) -> bool {\n         self.verbose > 0\n     }\n@@ -1358,3 +1383,116 @@ fn threads_from_config(v: u32) -> u32 {\n         n => n,\n     }\n }\n+\n+/// Returns the commit to download, or `None` if we shouldn't download CI artifacts.\n+fn download_ci_rustc_commit(download_rustc: Option<StringOrBool>, verbose: bool) -> Option<String> {\n+    // If `download-rustc` is not set, default to rebuilding.\n+    let if_unchanged = match download_rustc {\n+        None | Some(StringOrBool::Bool(false)) => return None,\n+        Some(StringOrBool::Bool(true)) => false,\n+        Some(StringOrBool::String(s)) if s == \"if-unchanged\" => true,\n+        Some(StringOrBool::String(other)) => {\n+            panic!(\"unrecognized option for download-rustc: {}\", other)\n+        }\n+    };\n+\n+    // Handle running from a directory other than the top level\n+    let top_level = output(Command::new(\"git\").args(&[\"rev-parse\", \"--show-toplevel\"]));\n+    let top_level = top_level.trim_end();\n+    let compiler = format!(\"{top_level}/compiler/\");\n+    let library = format!(\"{top_level}/library/\");\n+\n+    // Look for a version to compare to based on the current commit.\n+    // Only commits merged by bors will have CI artifacts.\n+    let merge_base = output(Command::new(\"git\").args(&[\n+        \"rev-list\",\n+        \"--author=bors@rust-lang.org\",\n+        \"-n1\",\n+        \"--first-parent\",\n+        \"HEAD\",\n+    ]));\n+    let commit = merge_base.trim_end();\n+    if commit.is_empty() {\n+        println!(\"error: could not find commit hash for downloading rustc\");\n+        println!(\"help: maybe your repository history is too shallow?\");\n+        println!(\"help: consider disabling `download-rustc`\");\n+        println!(\"help: or fetch enough history to include one upstream commit\");\n+        exit(1);\n+    }\n+\n+    // Warn if there were changes to the compiler or standard library since the ancestor commit.\n+    let has_changes = !t!(Command::new(\"git\")\n+        .args(&[\"diff-index\", \"--quiet\", &commit, \"--\", &compiler, &library])\n+        .status())\n+    .success();\n+    if has_changes {\n+        if if_unchanged {\n+            if verbose {\n+                println!(\n+                    \"warning: saw changes to compiler/ or library/ since {commit}; \\\n+                          ignoring `download-rustc`\"\n+                );\n+            }\n+            return None;\n+        }\n+        println!(\n+            \"warning: `download-rustc` is enabled, but there are changes to \\\n+                  compiler/ or library/\"\n+        );\n+    }\n+\n+    Some(commit.to_string())\n+}\n+\n+fn download_ci_rustc(builder: &Builder<'_>, commit: &str) {\n+    builder.verbose(&format!(\"using downloaded stage2 artifacts from CI (commit {commit})\"));\n+    // FIXME: support downloading artifacts from the beta channel\n+    const CHANNEL: &str = \"nightly\";\n+    let host = builder.config.build.triple;\n+    let bin_root = builder.out.join(host).join(\"ci-rustc\");\n+    let rustc_stamp = bin_root.join(\".rustc-stamp\");\n+\n+    if !bin_root.join(\"bin\").join(\"rustc\").exists() || program_out_of_date(&rustc_stamp, commit) {\n+        if bin_root.exists() {\n+            t!(fs::remove_dir_all(&bin_root));\n+        }\n+        let filename = format!(\"rust-std-{CHANNEL}-{host}.tar.xz\");\n+        let pattern = format!(\"rust-std-{host}\");\n+        download_component(builder, filename, &pattern, commit);\n+        let filename = format!(\"rustc-{CHANNEL}-{host}.tar.xz\");\n+        download_component(builder, filename, \"rustc\", commit);\n+        // download-rustc doesn't need its own cargo, it can just use beta's.\n+        let filename = format!(\"rustc-dev-{CHANNEL}-{host}.tar.xz\");\n+        download_component(builder, filename, \"rustc-dev\", commit);\n+\n+        builder.fix_bin_or_dylib(&bin_root.join(\"bin\").join(\"rustc\"));\n+        builder.fix_bin_or_dylib(&bin_root.join(\"bin\").join(\"rustdoc\"));\n+        let lib_dir = bin_root.join(\"lib\");\n+        for lib in t!(fs::read_dir(lib_dir)) {\n+            let lib = t!(lib);\n+            if lib.path().extension() == Some(OsStr::new(\"so\")) {\n+                builder.fix_bin_or_dylib(&lib.path());\n+            }\n+        }\n+        t!(fs::write(rustc_stamp, commit));\n+    }\n+}\n+\n+/// Download a single component of a CI-built toolchain (not necessarily a published nightly).\n+// NOTE: intentionally takes an owned string to avoid downloading multiple times by accident\n+fn download_component(builder: &Builder<'_>, filename: String, prefix: &str, commit: &str) {\n+    let cache_dst = builder.out.join(\"cache\");\n+    let rustc_cache = cache_dst.join(commit);\n+    if !rustc_cache.exists() {\n+        t!(fs::create_dir_all(&rustc_cache));\n+    }\n+\n+    let base = \"https://ci-artifacts.rust-lang.org\";\n+    let url = format!(\"rustc-builds/{commit}\");\n+    let tarball = rustc_cache.join(&filename);\n+    if !tarball.exists() {\n+        builder.download_component(base, &format!(\"{url}/{filename}\"), &tarball);\n+    }\n+    let bin_root = builder.out.join(builder.config.build.triple).join(\"ci-rustc\");\n+    builder.unpack(&tarball, &bin_root, prefix)\n+}"}, {"sha": "72c2c2e654d15f7af05a1b4da317c857c22de7f5", "filename": "src/bootstrap/native.rs", "status": "modified", "additions": 7, "deletions": 218, "changes": 225, "blob_url": "https://github.com/rust-lang/rust/blob/303d916867040e269b54adf3cfc7f5c903dc26ff/src%2Fbootstrap%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/303d916867040e269b54adf3cfc7f5c903dc26ff/src%2Fbootstrap%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fnative.rs?ref=303d916867040e269b54adf3cfc7f5c903dc26ff", "patch": "@@ -12,16 +12,13 @@ use std::env;\n use std::env::consts::EXE_EXTENSION;\n use std::ffi::{OsStr, OsString};\n use std::fs::{self, File};\n-use std::io::{self, BufRead, BufReader, ErrorKind};\n+use std::io;\n use std::path::{Path, PathBuf};\n-use std::process::{Command, Stdio};\n-\n-use once_cell::sync::OnceCell;\n-use xz2::bufread::XzDecoder;\n+use std::process::Command;\n \n use crate::builder::{Builder, RunConfig, ShouldRun, Step};\n use crate::config::TargetSelection;\n-use crate::util::{self, exe, output, t, up_to_date};\n+use crate::util::{self, exe, output, program_out_of_date, t, up_to_date};\n use crate::{CLang, GitRepo};\n \n pub struct Meta {\n@@ -151,13 +148,13 @@ pub(crate) fn maybe_download_ci_llvm(builder: &Builder<'_>) {\n     if program_out_of_date(&llvm_stamp, &key) && !config.dry_run {\n         download_ci_llvm(builder, &llvm_sha);\n         for binary in [\"llvm-config\", \"FileCheck\"] {\n-            fix_bin_or_dylib(builder, &llvm_root.join(\"bin\").join(binary));\n+            builder.fix_bin_or_dylib(&llvm_root.join(\"bin\").join(binary));\n         }\n         let llvm_lib = llvm_root.join(\"lib\");\n         for entry in t!(fs::read_dir(&llvm_lib)) {\n             let lib = t!(entry).path();\n             if lib.extension().map_or(false, |ext| ext == \"so\") {\n-                fix_bin_or_dylib(builder, &lib);\n+                builder.fix_bin_or_dylib(&lib);\n             }\n         }\n         t!(fs::write(llvm_stamp, key));\n@@ -182,218 +179,10 @@ fn download_ci_llvm(builder: &Builder<'_>, llvm_sha: &str) {\n     let filename = format!(\"rust-dev-nightly-{}.tar.xz\", builder.build.build.triple);\n     let tarball = rustc_cache.join(&filename);\n     if !tarball.exists() {\n-        download_component(builder, base, &format!(\"{}/{}\", url, filename), &tarball);\n+        builder.download_component(base, &format!(\"{}/{}\", url, filename), &tarball);\n     }\n     let llvm_root = builder.config.ci_llvm_root();\n-    unpack(builder, &tarball, &llvm_root);\n-}\n-\n-/// Modifies the interpreter section of 'fname' to fix the dynamic linker,\n-/// or the RPATH section, to fix the dynamic library search path\n-///\n-/// This is only required on NixOS and uses the PatchELF utility to\n-/// change the interpreter/RPATH of ELF executables.\n-///\n-/// Please see https://nixos.org/patchelf.html for more information\n-fn fix_bin_or_dylib(builder: &Builder<'_>, fname: &Path) {\n-    // FIXME: cache NixOS detection?\n-    match Command::new(\"uname\").arg(\"-s\").stderr(Stdio::inherit()).output() {\n-        Err(_) => return,\n-        Ok(output) if !output.status.success() => return,\n-        Ok(output) => {\n-            let mut s = output.stdout;\n-            if s.last() == Some(&b'\\n') {\n-                s.pop();\n-            }\n-            if s != b\"Linux\" {\n-                return;\n-            }\n-        }\n-    }\n-\n-    // If the user has asked binaries to be patched for Nix, then\n-    // don't check for NixOS or `/lib`, just continue to the patching.\n-    // FIXME: shouldn't this take precedence over the `uname` check above?\n-    if !builder.config.patch_binaries_for_nix {\n-        // Use `/etc/os-release` instead of `/etc/NIXOS`.\n-        // The latter one does not exist on NixOS when using tmpfs as root.\n-        const NIX_IDS: &[&str] = &[\"ID=nixos\", \"ID='nixos'\", \"ID=\\\"nixos\\\"\"];\n-        let os_release = match File::open(\"/etc/os-release\") {\n-            Err(e) if e.kind() == ErrorKind::NotFound => return,\n-            Err(e) => panic!(\"failed to access /etc/os-release: {}\", e),\n-            Ok(f) => f,\n-        };\n-        if !BufReader::new(os_release).lines().any(|l| NIX_IDS.contains(&t!(l).trim())) {\n-            return;\n-        }\n-        if Path::new(\"/lib\").exists() {\n-            return;\n-        }\n-    }\n-\n-    // At this point we're pretty sure the user is running NixOS or using Nix\n-    println!(\"info: you seem to be using Nix. Attempting to patch {}\", fname.display());\n-\n-    // Only build `.nix-deps` once.\n-    static NIX_DEPS_DIR: OnceCell<PathBuf> = OnceCell::new();\n-    let mut nix_build_succeeded = true;\n-    let nix_deps_dir = NIX_DEPS_DIR.get_or_init(|| {\n-        // Run `nix-build` to \"build\" each dependency (which will likely reuse\n-        // the existing `/nix/store` copy, or at most download a pre-built copy).\n-        //\n-        // Importantly, we create a gc-root called `.nix-deps` in the `build/`\n-        // directory, but still reference the actual `/nix/store` path in the rpath\n-        // as it makes it significantly more robust against changes to the location of\n-        // the `.nix-deps` location.\n-        //\n-        // bintools: Needed for the path of `ld-linux.so` (via `nix-support/dynamic-linker`).\n-        // zlib: Needed as a system dependency of `libLLVM-*.so`.\n-        // patchelf: Needed for patching ELF binaries (see doc comment above).\n-        let nix_deps_dir = builder.out.join(\".nix-deps\");\n-        const NIX_EXPR: &str = \"\n-        with (import <nixpkgs> {});\n-        symlinkJoin {\n-            name = \\\"rust-stage0-dependencies\\\";\n-            paths = [\n-                zlib\n-                patchelf\n-                stdenv.cc.bintools\n-            ];\n-        }\n-        \";\n-        nix_build_succeeded = builder.try_run(Command::new(\"nix-build\").args(&[\n-            Path::new(\"-E\"),\n-            Path::new(NIX_EXPR),\n-            Path::new(\"-o\"),\n-            &nix_deps_dir,\n-        ]));\n-        nix_deps_dir\n-    });\n-    if !nix_build_succeeded {\n-        return;\n-    }\n-\n-    let mut patchelf = Command::new(nix_deps_dir.join(\"bin/patchelf\"));\n-    let rpath_entries = {\n-        // ORIGIN is a relative default, all binary and dynamic libraries we ship\n-        // appear to have this (even when `../lib` is redundant).\n-        // NOTE: there are only two paths here, delimited by a `:`\n-        let mut entries = OsString::from(\"$ORIGIN/../lib:\");\n-        entries.push(t!(fs::canonicalize(nix_deps_dir)));\n-        entries.push(\"/lib\");\n-        entries\n-    };\n-    patchelf.args(&[OsString::from(\"--set-rpath\"), rpath_entries]);\n-    if !fname.extension().map_or(false, |ext| ext == \"so\") {\n-        // Finally, set the corret .interp for binaries\n-        let dynamic_linker_path = nix_deps_dir.join(\"nix-support/dynamic-linker\");\n-        // FIXME: can we support utf8 here? `args` doesn't accept Vec<u8>, only OsString ...\n-        let dynamic_linker = t!(String::from_utf8(t!(fs::read(dynamic_linker_path))));\n-        patchelf.args(&[\"--set-interpreter\", dynamic_linker.trim_end()]);\n-    }\n-\n-    builder.try_run(patchelf.arg(fname));\n-}\n-\n-fn download_component(builder: &Builder<'_>, base: &str, url: &str, dest_path: &Path) {\n-    // Use a temporary file in case we crash while downloading, to avoid a corrupt download in cache/.\n-    let tempfile = builder.tempdir().join(dest_path.file_name().unwrap());\n-    // FIXME: support `do_verify` (only really needed for nightly rustfmt)\n-    // FIXME: support non-utf8 paths?\n-    download_with_retries(builder, tempfile.to_str().unwrap(), &format!(\"{}/{}\", base, url));\n-    t!(std::fs::rename(&tempfile, dest_path));\n-}\n-\n-fn download_with_retries(builder: &Builder<'_>, tempfile: &str, url: &str) {\n-    println!(\"downloading {}\", url);\n-    // Try curl. If that fails and we are on windows, fallback to PowerShell.\n-    if !builder.check_run(Command::new(\"curl\").args(&[\n-        \"-#\",\n-        \"-y\",\n-        \"30\",\n-        \"-Y\",\n-        \"10\", // timeout if speed is < 10 bytes/sec for > 30 seconds\n-        \"--connect-timeout\",\n-        \"30\", // timeout if cannot connect within 30 seconds\n-        \"--retry\",\n-        \"3\",\n-        \"-Sf\",\n-        \"-o\",\n-        tempfile,\n-        url,\n-    ])) {\n-        if builder.build.build.contains(\"windows-msvc\") {\n-            println!(\"Fallback to PowerShell\");\n-            for _ in 0..3 {\n-                if builder.try_run(Command::new(\"PowerShell.exe\").args(&[\n-                    \"/nologo\",\n-                    \"-Command\",\n-                    \"[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12;\",\n-                    &format!(\n-                        \"(New-Object System.Net.WebClient).DownloadFile('{}', '{}')\",\n-                        url, tempfile\n-                    ),\n-                ])) {\n-                    return;\n-                }\n-                println!(\"\\nspurious failure, trying again\");\n-            }\n-        }\n-        std::process::exit(1);\n-    }\n-}\n-\n-fn unpack(builder: &Builder<'_>, tarball: &Path, dst: &Path) {\n-    println!(\"extracting {} to {}\", tarball.display(), dst.display());\n-    if !dst.exists() {\n-        t!(fs::create_dir_all(dst));\n-    }\n-\n-    // FIXME: will need to be a parameter once `download-rustc` is moved to rustbuild\n-    const MATCH: &str = \"rust-dev\";\n-\n-    // `tarball` ends with `.tar.xz`; strip that suffix\n-    // example: `rust-dev-nightly-x86_64-unknown-linux-gnu`\n-    let uncompressed_filename =\n-        Path::new(tarball.file_name().expect(\"missing tarball filename\")).file_stem().unwrap();\n-    let directory_prefix = Path::new(Path::new(uncompressed_filename).file_stem().unwrap());\n-\n-    // decompress the file\n-    let data = t!(File::open(tarball));\n-    let decompressor = XzDecoder::new(BufReader::new(data));\n-\n-    let mut tar = tar::Archive::new(decompressor);\n-    for member in t!(tar.entries()) {\n-        let mut member = t!(member);\n-        let original_path = t!(member.path()).into_owned();\n-        // skip the top-level directory\n-        if original_path == directory_prefix {\n-            continue;\n-        }\n-        let mut short_path = t!(original_path.strip_prefix(directory_prefix));\n-        if !short_path.starts_with(MATCH) {\n-            continue;\n-        }\n-        short_path = t!(short_path.strip_prefix(MATCH));\n-        let dst_path = dst.join(short_path);\n-        builder.verbose(&format!(\"extracting {} to {}\", original_path.display(), dst.display()));\n-        if !t!(member.unpack_in(dst)) {\n-            panic!(\"path traversal attack ??\");\n-        }\n-        let src_path = dst.join(original_path);\n-        if src_path.is_dir() && dst_path.exists() {\n-            continue;\n-        }\n-        t!(fs::rename(src_path, dst_path));\n-    }\n-    t!(fs::remove_dir_all(dst.join(directory_prefix)));\n-}\n-\n-fn program_out_of_date(stamp: &Path, key: &str) -> bool {\n-    if !stamp.exists() {\n-        return true;\n-    }\n-    t!(fs::read_to_string(stamp)) != key\n+    builder.unpack(&tarball, &llvm_root, \"rust-dev\");\n }\n \n #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]"}, {"sha": "99e9e8794e30bc0e74d6c65b09aaf4b631e984a1", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/303d916867040e269b54adf3cfc7f5c903dc26ff/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/303d916867040e269b54adf3cfc7f5c903dc26ff/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=303d916867040e269b54adf3cfc7f5c903dc26ff", "patch": "@@ -2058,7 +2058,7 @@ impl Step for CrateRustdoc {\n         let test_kind = self.test_kind;\n         let target = self.host;\n \n-        let compiler = if builder.config.download_rustc {\n+        let compiler = if builder.download_rustc() {\n             builder.compiler(builder.top_stage, target)\n         } else {\n             // Use the previous stage compiler to reuse the artifacts that are\n@@ -2127,7 +2127,7 @@ impl Step for CrateRustdoc {\n         // with.\n         //\n         // Note that this set the host libdir for `download_rustc`, which uses a normal rust distribution.\n-        let libdir = if builder.config.download_rustc {\n+        let libdir = if builder.download_rustc() {\n             builder.rustc_libdir(compiler)\n         } else {\n             builder.sysroot_libdir(compiler, target).to_path_buf()"}, {"sha": "b7abf6cc78d7125b62bc42cc7cfda52ef7e77f2c", "filename": "src/bootstrap/tool.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/303d916867040e269b54adf3cfc7f5c903dc26ff/src%2Fbootstrap%2Ftool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/303d916867040e269b54adf3cfc7f5c903dc26ff/src%2Fbootstrap%2Ftool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftool.rs?ref=303d916867040e269b54adf3cfc7f5c903dc26ff", "patch": "@@ -516,7 +516,7 @@ impl Step for Rustdoc {\n         builder.ensure(compile::Rustc { compiler: build_compiler, target: target_compiler.host });\n         // NOTE: this implies that `download-rustc` is pretty useless when compiling with the stage0\n         // compiler, since you do just as much work.\n-        if !builder.config.dry_run && builder.config.download_rustc && build_compiler.stage == 0 {\n+        if !builder.config.dry_run && builder.download_rustc() && build_compiler.stage == 0 {\n             println!(\n                 \"warning: `download-rustc` does nothing when building stage1 tools; consider using `--stage 2` instead\"\n             );"}, {"sha": "4b2b058a780f6df814a5899f908d938aac755d21", "filename": "src/bootstrap/util.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/303d916867040e269b54adf3cfc7f5c903dc26ff/src%2Fbootstrap%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/303d916867040e269b54adf3cfc7f5c903dc26ff/src%2Fbootstrap%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Futil.rs?ref=303d916867040e269b54adf3cfc7f5c903dc26ff", "patch": "@@ -115,6 +115,14 @@ impl Drop for TimeIt {\n     }\n }\n \n+/// Used for download caching\n+pub(crate) fn program_out_of_date(stamp: &Path, key: &str) -> bool {\n+    if !stamp.exists() {\n+        return true;\n+    }\n+    t!(fs::read_to_string(stamp)) != key\n+}\n+\n /// Symlinks two directories, using junctions on Windows and normal symlinks on\n /// Unix.\n pub fn symlink_dir(config: &Config, src: &Path, dest: &Path) -> io::Result<()> {"}]}