{"sha": "1a620661b7ef7bbee10e56895e6ee081504b7378", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFhNjIwNjYxYjdlZjdiYmVlMTBlNTY4OTVlNmVlMDgxNTA0YjczNzg=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2014-11-25T07:09:35Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2014-12-04T01:15:02Z"}, "message": "Special-case transmute for primitive, SIMD & pointer types.\n\nThis detects (a subset of) the cases when `transmute::<T, U>(x)` can be\nlowered to a direct `bitcast T x to U` in LLVM. This assists with\nefficiently handling a SIMD vector as multiple different types,\ne.g. swapping bytes/words/double words around inside some larger vector\ntype.\n\nC compilers like GCC and Clang handle integer vector types as `__m128i`\nfor all widths, and implicitly insert bitcasts as required. This patch\nallows Rust to express this, even if it takes a bit of `unsafe`, whereas\npreviously it was impossible to do at all without inline assembly.\n\nExample:\n\n    pub fn reverse_u32s(u: u64x2) -> u64x2 {\n        unsafe {\n            let tmp = mem::transmute::<_, u32x4>(u);\n            let swapped = u32x4(tmp.3, tmp.2, tmp.1, tmp.0);\n            mem::transmute::<_, u64x2>(swapped)\n        }\n    }\n\nCompiling with `--opt-level=3` gives:\n\nBefore\n\n    define <2 x i64> @_ZN12reverse_u32s20hbdb206aba18a03d8tbaE(<2 x i64>) unnamed_addr #0 {\n    entry-block:\n      %1 = bitcast <2 x i64> %0 to i128\n      %u.0.extract.trunc = trunc i128 %1 to i32\n      %u.4.extract.shift = lshr i128 %1, 32\n      %u.4.extract.trunc = trunc i128 %u.4.extract.shift to i32\n      %u.8.extract.shift = lshr i128 %1, 64\n      %u.8.extract.trunc = trunc i128 %u.8.extract.shift to i32\n      %u.12.extract.shift = lshr i128 %1, 96\n      %u.12.extract.trunc = trunc i128 %u.12.extract.shift to i32\n      %2 = insertelement <4 x i32> undef, i32 %u.12.extract.trunc, i64 0\n      %3 = insertelement <4 x i32> %2, i32 %u.8.extract.trunc, i64 1\n      %4 = insertelement <4 x i32> %3, i32 %u.4.extract.trunc, i64 2\n      %5 = insertelement <4 x i32> %4, i32 %u.0.extract.trunc, i64 3\n      %6 = bitcast <4 x i32> %5 to <2 x i64>\n      ret <2 x i64> %6\n    }\n\n    _ZN12reverse_u32s20hbdb206aba18a03d8tbaE:\n    \t.cfi_startproc\n    \tmovd\t%xmm0, %rax\n    \tpunpckhqdq\t%xmm0, %xmm0\n    \tmovd\t%xmm0, %rcx\n    \tmovq\t%rcx, %rdx\n    \tshrq\t$32, %rdx\n    \tmovq\t%rax, %rsi\n    \tshrq\t$32, %rsi\n    \tmovd\t%eax, %xmm0\n    \tmovd\t%ecx, %xmm1\n    \tpunpckldq\t%xmm0, %xmm1\n    \tmovd\t%esi, %xmm2\n    \tmovd\t%edx, %xmm0\n    \tpunpckldq\t%xmm2, %xmm0\n    \tpunpckldq\t%xmm1, %xmm0\n    \tretq\n\nAfter\n\n    define <2 x i64> @_ZN12reverse_u32s20hbdb206aba18a03d8tbaE(<2 x i64>) unnamed_addr #0 {\n    entry-block:\n      %1 = bitcast <2 x i64> %0 to <4 x i32>\n      %2 = shufflevector <4 x i32> %1, <4 x i32> undef, <4 x i32> <i32 3, i32 2, i32 1, i32 0>\n      %3 = bitcast <4 x i32> %2 to <2 x i64>\n      ret <2 x i64> %3\n    }\n\n    _ZN12reverse_u32s20hbdb206aba18a03d8tbaE:\n    \t.cfi_startproc\n    \tpshufd\t$27, %xmm0, %xmm0\n    \tretq", "tree": {"sha": "795b852f9c2c4dd5cfc1f4491faa580f6e199b54", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/795b852f9c2c4dd5cfc1f4491faa580f6e199b54"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1a620661b7ef7bbee10e56895e6ee081504b7378", "comment_count": 6, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1a620661b7ef7bbee10e56895e6ee081504b7378", "html_url": "https://github.com/rust-lang/rust/commit/1a620661b7ef7bbee10e56895e6ee081504b7378", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1a620661b7ef7bbee10e56895e6ee081504b7378/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5f9741e62d7cfe26ca94a28716a95bc03d74e87a", "url": "https://api.github.com/repos/rust-lang/rust/commits/5f9741e62d7cfe26ca94a28716a95bc03d74e87a", "html_url": "https://github.com/rust-lang/rust/commit/5f9741e62d7cfe26ca94a28716a95bc03d74e87a"}], "stats": {"total": 65, "additions": 59, "deletions": 6}, "files": [{"sha": "890652401d7eb11cfe9605be74e14133d2dd8ac7", "filename": "src/librustc_trans/trans/intrinsic.rs", "status": "modified", "additions": 59, "deletions": 6, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/1a620661b7ef7bbee10e56895e6ee081504b7378/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a620661b7ef7bbee10e56895e6ee081504b7378/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs?ref=1a620661b7ef7bbee10e56895e6ee081504b7378", "patch": "@@ -11,7 +11,7 @@\n #![allow(non_upper_case_globals)]\n \n use llvm;\n-use llvm::{SequentiallyConsistent, Acquire, Release, AtomicXchg, ValueRef};\n+use llvm::{SequentiallyConsistent, Acquire, Release, AtomicXchg, ValueRef, TypeKind};\n use middle::subst;\n use middle::subst::FnSpace;\n use trans::base::*;\n@@ -174,12 +174,65 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                 // This should be caught by the intrinsicck pass\n                 assert_eq!(in_type_size, out_type_size);\n \n-                // We need to cast the dest so the types work out\n-                let dest = match dest {\n-                    expr::SaveIn(d) => expr::SaveIn(PointerCast(bcx, d, llintype.ptr_to())),\n-                    expr::Ignore => expr::Ignore\n+                let nonpointer_nonaggregate = |llkind: TypeKind| -> bool {\n+                    use llvm::TypeKind::*;\n+                    match llkind {\n+                        Half | Float | Double | X86_FP80 | FP128 |\n+                            PPC_FP128 | Integer | Vector | X86_MMX => true,\n+                        _ => false\n+                    }\n+                };\n+\n+                // An approximation to which types can be directly cast via\n+                // LLVM's bitcast.  This doesn't cover pointer -> pointer casts,\n+                // but does, importantly, cover SIMD types.\n+                let in_kind = llintype.kind();\n+                let ret_kind = llret_ty.kind();\n+                let bitcast_compatible =\n+                    (nonpointer_nonaggregate(in_kind) && nonpointer_nonaggregate(ret_kind)) || {\n+                        in_kind == TypeKind::Pointer && ret_kind == TypeKind::Pointer\n+                    };\n+\n+                let dest = if bitcast_compatible {\n+                    // if we're here, the type is scalar-like (a primitive, a\n+                    // SIMD type or a pointer), and so can be handled as a\n+                    // by-value ValueRef and can also be directly bitcast to the\n+                    // target type.  Doing this special case makes conversions\n+                    // like `u32x4` -> `u64x2` much nicer for LLVM and so more\n+                    // efficient (these are done efficiently implicitly in C\n+                    // with the `__m128i` type and so this means Rust doesn't\n+                    // lose out there).\n+                    let expr = &*arg_exprs[0];\n+                    let datum = unpack_datum!(bcx, expr::trans(bcx, expr));\n+                    let datum = unpack_datum!(bcx, datum.to_rvalue_datum(bcx, \"transmute_temp\"));\n+                    let val = if datum.kind.is_by_ref() {\n+                        load_ty(bcx, datum.val, datum.ty)\n+                    } else {\n+                        datum.val\n+                    };\n+\n+                    let cast_val = BitCast(bcx, val, llret_ty);\n+\n+                    match dest {\n+                        expr::SaveIn(d) => {\n+                            // this often occurs in a sequence like `Store(val,\n+                            // d); val2 = Load(d)`, so disappears easily.\n+                            Store(bcx, cast_val, d);\n+                        }\n+                        expr::Ignore => {}\n+                    }\n+                    dest\n+                } else {\n+                    // The types are too complicated to do with a by-value\n+                    // bitcast, so pointer cast instead. We need to cast the\n+                    // dest so the types work out.\n+                    let dest = match dest {\n+                        expr::SaveIn(d) => expr::SaveIn(PointerCast(bcx, d, llintype.ptr_to())),\n+                        expr::Ignore => expr::Ignore\n+                    };\n+                    bcx = expr::trans_into(bcx, &*arg_exprs[0], dest);\n+                    dest\n                 };\n-                bcx = expr::trans_into(bcx, &*arg_exprs[0], dest);\n \n                 fcx.pop_custom_cleanup_scope(cleanup_scope);\n "}]}