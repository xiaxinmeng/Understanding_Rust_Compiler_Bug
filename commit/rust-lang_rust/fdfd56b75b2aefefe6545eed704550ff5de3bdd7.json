{"sha": "fdfd56b75b2aefefe6545eed704550ff5de3bdd7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZkZmQ1NmI3NWIyYWVmZWZlNjU0NWVlZDcwNDU1MGZmNWRlM2JkZDc=", "commit": {"author": {"name": "Vytautas Astrauskas", "email": "vastrauskas@gmail.com", "date": "2020-05-18T15:18:15Z"}, "committer": {"name": "Vytautas Astrauskas", "email": "vastrauskas@gmail.com", "date": "2020-05-24T22:02:54Z"}, "message": "Small changes.", "tree": {"sha": "5b9db9b8ad9070a06848ac617c656ade9f855798", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5b9db9b8ad9070a06848ac617c656ade9f855798"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fdfd56b75b2aefefe6545eed704550ff5de3bdd7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fdfd56b75b2aefefe6545eed704550ff5de3bdd7", "html_url": "https://github.com/rust-lang/rust/commit/fdfd56b75b2aefefe6545eed704550ff5de3bdd7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fdfd56b75b2aefefe6545eed704550ff5de3bdd7/comments", "author": {"login": "vakaras", "id": 75347, "node_id": "MDQ6VXNlcjc1MzQ3", "avatar_url": "https://avatars.githubusercontent.com/u/75347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vakaras", "html_url": "https://github.com/vakaras", "followers_url": "https://api.github.com/users/vakaras/followers", "following_url": "https://api.github.com/users/vakaras/following{/other_user}", "gists_url": "https://api.github.com/users/vakaras/gists{/gist_id}", "starred_url": "https://api.github.com/users/vakaras/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vakaras/subscriptions", "organizations_url": "https://api.github.com/users/vakaras/orgs", "repos_url": "https://api.github.com/users/vakaras/repos", "events_url": "https://api.github.com/users/vakaras/events{/privacy}", "received_events_url": "https://api.github.com/users/vakaras/received_events", "type": "User", "site_admin": false}, "committer": {"login": "vakaras", "id": 75347, "node_id": "MDQ6VXNlcjc1MzQ3", "avatar_url": "https://avatars.githubusercontent.com/u/75347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vakaras", "html_url": "https://github.com/vakaras", "followers_url": "https://api.github.com/users/vakaras/followers", "following_url": "https://api.github.com/users/vakaras/following{/other_user}", "gists_url": "https://api.github.com/users/vakaras/gists{/gist_id}", "starred_url": "https://api.github.com/users/vakaras/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vakaras/subscriptions", "organizations_url": "https://api.github.com/users/vakaras/orgs", "repos_url": "https://api.github.com/users/vakaras/repos", "events_url": "https://api.github.com/users/vakaras/events{/privacy}", "received_events_url": "https://api.github.com/users/vakaras/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3da61fa4274b370dc2c72ce8b7bdbbfeb836110a", "url": "https://api.github.com/repos/rust-lang/rust/commits/3da61fa4274b370dc2c72ce8b7bdbbfeb836110a", "html_url": "https://github.com/rust-lang/rust/commit/3da61fa4274b370dc2c72ce8b7bdbbfeb836110a"}], "stats": {"total": 204, "additions": 143, "deletions": 61}, "files": [{"sha": "ee2579c22f1794e126f3225ad2e4006af9a31222", "filename": "src/shims/sync.rs", "status": "modified", "additions": 27, "deletions": 36, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/fdfd56b75b2aefefe6545eed704550ff5de3bdd7/src%2Fshims%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdfd56b75b2aefefe6545eed704550ff5de3bdd7/src%2Fshims%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fsync.rs?ref=fdfd56b75b2aefefe6545eed704550ff5de3bdd7", "patch": "@@ -202,6 +202,7 @@ fn condattr_set_clock_id<'mir, 'tcx: 'mir>(\n // Our chosen memory layout for the emulated conditional variable (does not have\n // to match the platform layout!):\n \n+// bytes 0-3: reserved for signature on macOS\n // bytes 4-7: the conditional variable id as u32 or 0 if id is not assigned yet.\n // bytes 8-11: the clock id constant as i32\n \n@@ -275,19 +276,13 @@ fn release_cond_mutex<'mir, 'tcx: 'mir>(\n     active_thread: ThreadId,\n     mutex: MutexId,\n ) -> InterpResult<'tcx> {\n-    if let Some((owner_thread, current_locked_count)) = ecx.mutex_unlock(mutex) {\n-        if current_locked_count != 0 {\n-            throw_unsup_format!(\"awaiting on multiple times acquired lock is not supported\");\n+    if let Some((old_owner_thread, old_locked_count)) = ecx.mutex_unlock(mutex)? {\n+        if old_locked_count != 1 {\n+            throw_unsup_format!(\"awaiting on a lock acquired multiple times is not supported\");\n         }\n-        if owner_thread != active_thread {\n+        if old_owner_thread != active_thread {\n             throw_ub_format!(\"awaiting on a mutex owned by a different thread\");\n         }\n-        if let Some(thread) = ecx.mutex_dequeue(mutex) {\n-            // We have at least one thread waiting on this mutex. Transfer\n-            // ownership to it.\n-            ecx.mutex_lock(mutex, thread);\n-            ecx.unblock_thread(thread)?;\n-        }\n     } else {\n         throw_ub_format!(\"awaiting on unlocked mutex\");\n     }\n@@ -349,7 +344,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             mutexattr_get_kind(this, attr_op)?.not_undef()?\n         };\n \n-        let _ = mutex_get_or_create_id(this, mutex_op)?;\n+        // Write 0 to use the same code path as the static initializers.\n+        mutex_set_id(this, mutex_op, Scalar::from_i32(0))?;\n+\n         mutex_set_kind(this, mutex_op, kind)?;\n \n         Ok(0)\n@@ -427,19 +424,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let kind = mutex_get_kind(this, mutex_op)?.not_undef()?;\n         let id = mutex_get_or_create_id(this, mutex_op)?;\n \n-        if let Some((owner_thread, current_locked_count)) = this.mutex_unlock(id) {\n-            if owner_thread != this.get_active_thread()? {\n+        if let Some((old_owner_thread, _old_locked_count)) = this.mutex_unlock(id)? {\n+            if old_owner_thread != this.get_active_thread()? {\n                 throw_ub_format!(\"called pthread_mutex_unlock on a mutex owned by another thread\");\n             }\n-            if current_locked_count == 0 {\n-                // The mutex is unlocked.\n-                if let Some(thread) = this.mutex_dequeue(id) {\n-                    // We have at least one thread waiting on this mutex. Transfer\n-                    // ownership to it.\n-                    this.mutex_lock(id, thread);\n-                    this.unblock_thread(thread)?;\n-                }\n-            }\n             Ok(0)\n         } else {\n             if kind == this.eval_libc(\"PTHREAD_MUTEX_NORMAL\")? {\n@@ -476,11 +464,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let active_thread = this.get_active_thread()?;\n \n         if this.rwlock_is_write_locked(id) {\n-            this.rwlock_enqueue_reader(id, active_thread);\n-            this.block_thread(active_thread)?;\n+            this.rwlock_enqueue_and_block_reader(id, active_thread)?;\n             Ok(0)\n         } else {\n-            this.rwlock_reader_add(id, active_thread);\n+            this.rwlock_reader_lock(id, active_thread);\n             Ok(0)\n         }\n     }\n@@ -494,7 +481,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         if this.rwlock_is_write_locked(id) {\n             this.eval_libc_i32(\"EBUSY\")\n         } else {\n-            this.rwlock_reader_add(id, active_thread);\n+            this.rwlock_reader_lock(id, active_thread);\n             Ok(0)\n         }\n     }\n@@ -506,10 +493,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let active_thread = this.get_active_thread()?;\n \n         if this.rwlock_is_locked(id) {\n-            this.block_thread(active_thread)?;\n-            this.rwlock_enqueue_writer(id, active_thread);\n+            this.rwlock_enqueue_and_block_writer(id, active_thread)?;\n         } else {\n-            this.rwlock_writer_set(id, active_thread);\n+            this.rwlock_writer_lock(id, active_thread);\n         }\n \n         Ok(0)\n@@ -524,7 +510,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         if this.rwlock_is_locked(id) {\n             this.eval_libc_i32(\"EBUSY\")\n         } else {\n-            this.rwlock_writer_set(id, active_thread);\n+            this.rwlock_writer_lock(id, active_thread);\n             Ok(0)\n         }\n     }\n@@ -535,18 +521,18 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let id = rwlock_get_or_create_id(this, rwlock_op)?;\n         let active_thread = this.get_active_thread()?;\n \n-        if this.rwlock_reader_remove(id, active_thread) {\n+        if this.rwlock_reader_unlock(id, active_thread) {\n             // The thread was a reader.\n             if this.rwlock_is_locked(id) {\n                 // No more readers owning the lock. Give it to a writer if there\n                 // is any.\n                 if let Some(writer) = this.rwlock_dequeue_writer(id) {\n                     this.unblock_thread(writer)?;\n-                    this.rwlock_writer_set(id, writer);\n+                    this.rwlock_writer_lock(id, writer);\n                 }\n             }\n             Ok(0)\n-        } else if Some(active_thread) == this.rwlock_writer_remove(id) {\n+        } else if Some(active_thread) == this.rwlock_writer_unlock(id) {\n             // The thread was a writer.\n             //\n             // We are prioritizing writers here against the readers. As a\n@@ -555,12 +541,12 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             if let Some(writer) = this.rwlock_dequeue_writer(id) {\n                 // Give the lock to another writer.\n                 this.unblock_thread(writer)?;\n-                this.rwlock_writer_set(id, writer);\n+                this.rwlock_writer_lock(id, writer);\n             } else {\n                 // Give the lock to all readers.\n                 while let Some(reader) = this.rwlock_dequeue_reader(id) {\n                     this.unblock_thread(reader)?;\n-                    this.rwlock_reader_add(id, reader);\n+                    this.rwlock_reader_lock(id, reader);\n                 }\n             }\n             Ok(0)\n@@ -586,6 +572,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     fn pthread_condattr_init(&mut self, attr_op: OpTy<'tcx, Tag>) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n+        // The default value of the clock attribute shall refer to the system\n+        // clock.\n+        // https://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_condattr_setclock.html\n         let default_clock_id = this.eval_libc(\"CLOCK_REALTIME\")?;\n         condattr_set_clock_id(this, attr_op, default_clock_id)?;\n \n@@ -647,7 +636,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             condattr_get_clock_id(this, attr_op)?.not_undef()?\n         };\n \n-        let _ = cond_get_or_create_id(this, cond_op)?;\n+        // Write 0 to use the same code path as the static initializers.\n+        cond_set_id(this, cond_op, Scalar::from_i32(0))?;\n+\n         cond_set_clock_id(this, cond_op, clock_id)?;\n \n         Ok(0)"}, {"sha": "a71d4597c6697ba8a3c7bfa49e252fb57ab6c2af", "filename": "src/sync.rs", "status": "modified", "additions": 48, "deletions": 22, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/fdfd56b75b2aefefe6545eed704550ff5de3bdd7/src%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdfd56b75b2aefefe6545eed704550ff5de3bdd7/src%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fsync.rs?ref=fdfd56b75b2aefefe6545eed704550ff5de3bdd7", "patch": "@@ -1,6 +1,7 @@\n use std::collections::{hash_map::Entry, HashMap, VecDeque};\n use std::convert::TryFrom;\n use std::num::NonZeroU32;\n+use std::ops::Not;\n \n use rustc_index::vec::{Idx, IndexVec};\n \n@@ -142,34 +143,47 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         mutex.lock_count = mutex.lock_count.checked_add(1).unwrap();\n     }\n \n-    /// Unlock by decreasing the lock count. If the lock count reaches 0, unset\n-    /// the owner.\n-    fn mutex_unlock(&mut self, id: MutexId) -> Option<(ThreadId, usize)> {\n+    /// Try unlocking by decreasing the lock count and returning the old owner\n+    /// and the old lock count. If the lock count reaches 0, release the lock\n+    /// and potentially give to a new owner. If the lock was not locked, return\n+    /// `None`.\n+    ///\n+    /// Note: It is the caller's responsibility to check that the thread that\n+    /// unlocked the lock actually is the same one, which owned it.\n+    fn mutex_unlock(&mut self, id: MutexId) -> InterpResult<'tcx, Option<(ThreadId, usize)>> {\n         let this = self.eval_context_mut();\n         let mutex = &mut this.machine.threads.sync.mutexes[id];\n         if let Some(current_owner) = mutex.owner {\n-            mutex.lock_count = mutex\n-                .lock_count\n+            // Mutex is locked.\n+            let old_lock_count = mutex.lock_count;\n+            mutex.lock_count = old_lock_count\n                 .checked_sub(1)\n                 .expect(\"invariant violation: lock_count == 0 iff the thread is unlocked\");\n             if mutex.lock_count == 0 {\n                 mutex.owner = None;\n+                // The mutex is completely unlocked. Try transfering ownership\n+                // to another thread.\n+                if let Some(new_owner) = this.mutex_dequeue(id) {\n+                    this.mutex_lock(id, new_owner);\n+                    this.unblock_thread(new_owner)?;\n+                }\n             }\n-            Some((current_owner, mutex.lock_count))\n+            Ok(Some((current_owner, old_lock_count)))\n         } else {\n-            None\n+            // Mutex is unlocked.\n+            Ok(None)\n         }\n     }\n \n     #[inline]\n-    /// Take a thread out the queue waiting for the lock.\n+    /// Put the thread into the queue waiting for the lock.\n     fn mutex_enqueue(&mut self, id: MutexId, thread: ThreadId) {\n         let this = self.eval_context_mut();\n         this.machine.threads.sync.mutexes[id].queue.push_back(thread);\n     }\n \n     #[inline]\n-    /// Take a thread out the queue waiting for the lock.\n+    /// Take a thread out of the queue waiting for the lock.\n     fn mutex_dequeue(&mut self, id: MutexId) -> Option<ThreadId> {\n         let this = self.eval_context_mut();\n         this.machine.threads.sync.mutexes[id].queue.pop_front()\n@@ -187,7 +201,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     fn rwlock_is_locked(&mut self, id: RwLockId) -> bool {\n         let this = self.eval_context_mut();\n         this.machine.threads.sync.rwlocks[id].writer.is_some()\n-            || !this.machine.threads.sync.rwlocks[id].readers.is_empty()\n+            || this.machine.threads.sync.rwlocks[id].readers.is_empty().not()\n     }\n \n     #[inline]\n@@ -197,16 +211,18 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         this.machine.threads.sync.rwlocks[id].writer.is_some()\n     }\n \n-    /// Add a reader that collectively with other readers owns the lock.\n-    fn rwlock_reader_add(&mut self, id: RwLockId, reader: ThreadId) {\n+    /// Read-lock the lock by adding the `reader` the list of threads that own\n+    /// this lock.\n+    fn rwlock_reader_lock(&mut self, id: RwLockId, reader: ThreadId) {\n         let this = self.eval_context_mut();\n         assert!(!this.rwlock_is_write_locked(id), \"the lock is write locked\");\n         let count = this.machine.threads.sync.rwlocks[id].readers.entry(reader).or_insert(0);\n-        *count += 1;\n+        *count = count.checked_add(1).expect(\"the reader counter overflowed\");\n     }\n \n-    /// Try removing the reader. Returns `true` if succeeded.\n-    fn rwlock_reader_remove(&mut self, id: RwLockId, reader: ThreadId) -> bool {\n+    /// Try read-unlock the lock for `reader`. Returns `true` if succeeded,\n+    /// `false` if this `reader` did not hold the lock.\n+    fn rwlock_reader_unlock(&mut self, id: RwLockId, reader: ThreadId) -> bool {\n         let this = self.eval_context_mut();\n         match this.machine.threads.sync.rwlocks[id].readers.entry(reader) {\n             Entry::Occupied(mut entry) => {\n@@ -222,41 +238,51 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     }\n \n     #[inline]\n-    /// Put the reader in the queue waiting for the lock.\n-    fn rwlock_enqueue_reader(&mut self, id: RwLockId, reader: ThreadId) {\n+    /// Put the reader in the queue waiting for the lock and block it.\n+    fn rwlock_enqueue_and_block_reader(\n+        &mut self,\n+        id: RwLockId,\n+        reader: ThreadId,\n+    ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n         assert!(this.rwlock_is_write_locked(id), \"queueing on not write locked lock\");\n         this.machine.threads.sync.rwlocks[id].reader_queue.push_back(reader);\n+        this.block_thread(reader)\n     }\n \n     #[inline]\n-    /// Take the reader out the queue waiting for the lock.\n+    /// Take a reader out the queue waiting for the lock.\n     fn rwlock_dequeue_reader(&mut self, id: RwLockId) -> Option<ThreadId> {\n         let this = self.eval_context_mut();\n         this.machine.threads.sync.rwlocks[id].reader_queue.pop_front()\n     }\n \n     #[inline]\n     /// Lock by setting the writer that owns the lock.\n-    fn rwlock_writer_set(&mut self, id: RwLockId, writer: ThreadId) {\n+    fn rwlock_writer_lock(&mut self, id: RwLockId, writer: ThreadId) {\n         let this = self.eval_context_mut();\n         assert!(!this.rwlock_is_locked(id), \"the lock is already locked\");\n         this.machine.threads.sync.rwlocks[id].writer = Some(writer);\n     }\n \n     #[inline]\n-    /// Try removing the writer.\n-    fn rwlock_writer_remove(&mut self, id: RwLockId) -> Option<ThreadId> {\n+    /// Try to unlock by removing the writer.\n+    fn rwlock_writer_unlock(&mut self, id: RwLockId) -> Option<ThreadId> {\n         let this = self.eval_context_mut();\n         this.machine.threads.sync.rwlocks[id].writer.take()\n     }\n \n     #[inline]\n     /// Put the writer in the queue waiting for the lock.\n-    fn rwlock_enqueue_writer(&mut self, id: RwLockId, writer: ThreadId) {\n+    fn rwlock_enqueue_and_block_writer(\n+        &mut self,\n+        id: RwLockId,\n+        writer: ThreadId,\n+    ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n         assert!(this.rwlock_is_locked(id), \"queueing on unlocked lock\");\n         this.machine.threads.sync.rwlocks[id].writer_queue.push_back(writer);\n+        this.block_thread(writer)\n     }\n \n     #[inline]"}, {"sha": "e61761e599cd85340d4b1ad40db7f45f9ccc1669", "filename": "src/thread.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fdfd56b75b2aefefe6545eed704550ff5de3bdd7/src%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdfd56b75b2aefefe6545eed704550ff5de3bdd7/src%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fthread.rs?ref=fdfd56b75b2aefefe6545eed704550ff5de3bdd7", "patch": "@@ -32,7 +32,7 @@ pub enum SchedulingAction {\n     Stop,\n }\n \n-/// Timeout timeout_callbacks can be created by synchronization primitives to tell the\n+/// Timeout callbacks can be created by synchronization primitives to tell the\n /// scheduler that they should be called once some period of time passes.\n type TimeoutCallback<'mir, 'tcx> =\n     Box<dyn FnOnce(&mut InterpCx<'mir, 'tcx, Evaluator<'mir, 'tcx>>) -> InterpResult<'tcx> + 'tcx>;\n@@ -189,7 +189,7 @@ struct TimeoutCallbackInfo<'mir, 'tcx> {\n \n impl<'mir, 'tcx> std::fmt::Debug for TimeoutCallbackInfo<'mir, 'tcx> {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n-        write!(f, \"CallBack({:?})\", self.call_time)\n+        write!(f, \"TimeoutCallback({:?})\", self.call_time)\n     }\n }\n \n@@ -394,7 +394,8 @@ impl<'mir, 'tcx: 'mir> ThreadManager<'mir, 'tcx> {\n \n     /// Get a callback that is ready to be called.\n     fn get_ready_callback(&mut self) -> Option<(ThreadId, TimeoutCallback<'mir, 'tcx>)> {\n-        // We use a for loop here to make the scheduler more deterministic.\n+        // We iterate over all threads in the order of their indices because\n+        // this allows us to have a deterministic scheduler.\n         for thread in self.threads.indices() {\n             match self.timeout_callbacks.entry(thread) {\n                 Entry::Occupied(entry) =>"}, {"sha": "a73a8496a3296c5b6ce1a70fe2775ff2eba31dcc", "filename": "tests/compile-fail/sync/libc_pthread_rwlock_read_wrong_owner.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/fdfd56b75b2aefefe6545eed704550ff5de3bdd7/tests%2Fcompile-fail%2Fsync%2Flibc_pthread_rwlock_read_wrong_owner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdfd56b75b2aefefe6545eed704550ff5de3bdd7/tests%2Fcompile-fail%2Fsync%2Flibc_pthread_rwlock_read_wrong_owner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fsync%2Flibc_pthread_rwlock_read_wrong_owner.rs?ref=fdfd56b75b2aefefe6545eed704550ff5de3bdd7", "patch": "@@ -0,0 +1,32 @@\n+// ignore-windows: No libc on Windows\n+\n+#![feature(rustc_private)]\n+\n+extern crate libc;\n+\n+use std::cell::UnsafeCell;\n+use std::sync::Arc;\n+use std::thread;\n+\n+struct RwLock(UnsafeCell<libc::pthread_rwlock_t>);\n+\n+unsafe impl Send for RwLock {}\n+unsafe impl Sync for RwLock {}\n+\n+fn new_lock() -> Arc<RwLock> {\n+    Arc::new(RwLock(UnsafeCell::new(libc::PTHREAD_RWLOCK_INITIALIZER)))\n+}\n+\n+fn main() {\n+    unsafe {\n+        let lock = new_lock();\n+        assert_eq!(libc::pthread_rwlock_rdlock(lock.0.get() as *mut _), 0);\n+\n+        let lock_copy = lock.clone();\n+        thread::spawn(move || {\n+            assert_eq!(libc::pthread_rwlock_unlock(lock_copy.0.get() as *mut _), 0); //~ ERROR: Undefined Behavior: unlocked an rwlock that was not locked by the active thread\n+        })\n+        .join()\n+        .unwrap();\n+    }\n+}"}, {"sha": "663dedb6f6fca643f6b2a4c6bc83bc765e2df0f5", "filename": "tests/compile-fail/sync/libc_pthread_rwlock_write_wrong_owner.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/fdfd56b75b2aefefe6545eed704550ff5de3bdd7/tests%2Fcompile-fail%2Fsync%2Flibc_pthread_rwlock_write_wrong_owner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdfd56b75b2aefefe6545eed704550ff5de3bdd7/tests%2Fcompile-fail%2Fsync%2Flibc_pthread_rwlock_write_wrong_owner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fsync%2Flibc_pthread_rwlock_write_wrong_owner.rs?ref=fdfd56b75b2aefefe6545eed704550ff5de3bdd7", "patch": "@@ -0,0 +1,32 @@\n+// ignore-windows: No libc on Windows\n+\n+#![feature(rustc_private)]\n+\n+extern crate libc;\n+\n+use std::cell::UnsafeCell;\n+use std::sync::Arc;\n+use std::thread;\n+\n+struct RwLock(UnsafeCell<libc::pthread_rwlock_t>);\n+\n+unsafe impl Send for RwLock {}\n+unsafe impl Sync for RwLock {}\n+\n+fn new_lock() -> Arc<RwLock> {\n+    Arc::new(RwLock(UnsafeCell::new(libc::PTHREAD_RWLOCK_INITIALIZER)))\n+}\n+\n+fn main() {\n+    unsafe {\n+        let lock = new_lock();\n+        assert_eq!(libc::pthread_rwlock_wrlock(lock.0.get() as *mut _), 0);\n+\n+        let lock_copy = lock.clone();\n+        thread::spawn(move || {\n+            assert_eq!(libc::pthread_rwlock_unlock(lock_copy.0.get() as *mut _), 0); //~ ERROR: Undefined Behavior: unlocked an rwlock that was not locked by the active thread\n+        })\n+        .join()\n+        .unwrap();\n+    }\n+}"}]}