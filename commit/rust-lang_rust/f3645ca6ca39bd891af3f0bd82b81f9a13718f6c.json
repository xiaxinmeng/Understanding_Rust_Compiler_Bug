{"sha": "f3645ca6ca39bd891af3f0bd82b81f9a13718f6c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYzNjQ1Y2E2Y2EzOWJkODkxYWYzZjBiZDgyYjgxZjlhMTM3MThmNmM=", "commit": {"author": {"name": "Tshepang Lekhonkhobe", "email": "tshepang@gmail.com", "date": "2020-06-30T08:56:10Z"}, "committer": {"name": "Tshepang Lekhonkhobe", "email": "tshepang@gmail.com", "date": "2020-06-30T08:58:23Z"}, "message": "remove rustdoc warnings", "tree": {"sha": "9d39107bd90359c1c488b71d55c73e4e64071f69", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9d39107bd90359c1c488b71d55c73e4e64071f69"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f3645ca6ca39bd891af3f0bd82b81f9a13718f6c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f3645ca6ca39bd891af3f0bd82b81f9a13718f6c", "html_url": "https://github.com/rust-lang/rust/commit/f3645ca6ca39bd891af3f0bd82b81f9a13718f6c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f3645ca6ca39bd891af3f0bd82b81f9a13718f6c/comments", "author": {"login": "tshepang", "id": 588486, "node_id": "MDQ6VXNlcjU4ODQ4Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/588486?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tshepang", "html_url": "https://github.com/tshepang", "followers_url": "https://api.github.com/users/tshepang/followers", "following_url": "https://api.github.com/users/tshepang/following{/other_user}", "gists_url": "https://api.github.com/users/tshepang/gists{/gist_id}", "starred_url": "https://api.github.com/users/tshepang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tshepang/subscriptions", "organizations_url": "https://api.github.com/users/tshepang/orgs", "repos_url": "https://api.github.com/users/tshepang/repos", "events_url": "https://api.github.com/users/tshepang/events{/privacy}", "received_events_url": "https://api.github.com/users/tshepang/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tshepang", "id": 588486, "node_id": "MDQ6VXNlcjU4ODQ4Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/588486?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tshepang", "html_url": "https://github.com/tshepang", "followers_url": "https://api.github.com/users/tshepang/followers", "following_url": "https://api.github.com/users/tshepang/following{/other_user}", "gists_url": "https://api.github.com/users/tshepang/gists{/gist_id}", "starred_url": "https://api.github.com/users/tshepang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tshepang/subscriptions", "organizations_url": "https://api.github.com/users/tshepang/orgs", "repos_url": "https://api.github.com/users/tshepang/repos", "events_url": "https://api.github.com/users/tshepang/events{/privacy}", "received_events_url": "https://api.github.com/users/tshepang/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a1528c432e45339d9b5602a19ac3571e2900d37b", "url": "https://api.github.com/repos/rust-lang/rust/commits/a1528c432e45339d9b5602a19ac3571e2900d37b", "html_url": "https://github.com/rust-lang/rust/commit/a1528c432e45339d9b5602a19ac3571e2900d37b"}], "stats": {"total": 197, "additions": 99, "deletions": 98}, "files": [{"sha": "18b92bf29bf1b6bf5e6866ddcfb455a89bde34c9", "filename": "src/librustc_mir_build/hair/pattern/_match.rs", "status": "modified", "additions": 99, "deletions": 98, "changes": 197, "blob_url": "https://github.com/rust-lang/rust/blob/f3645ca6ca39bd891af3f0bd82b81f9a13718f6c/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3645ca6ca39bd891af3f0bd82b81f9a13718f6c/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2F_match.rs?ref=f3645ca6ca39bd891af3f0bd82b81f9a13718f6c", "patch": "@@ -4,8 +4,8 @@\n //! This file includes the logic for exhaustiveness and usefulness checking for\n //! pattern-matching. Specifically, given a list of patterns for a type, we can\n //! tell whether:\n-//! (a) the patterns cover every possible constructor for the type [exhaustiveness]\n-//! (b) each pattern is necessary [usefulness]\n+//! (a) the patterns cover every possible constructor for the type (exhaustiveness)\n+//! (b) each pattern is necessary (usefulness)\n //!\n //! The algorithm implemented here is a modified version of the one described in:\n //! http://moscova.inria.fr/~maranget/papers/warn/index.html\n@@ -101,53 +101,54 @@\n //! To match the paper, the top of the stack is at the beginning / on the left.\n //!\n //! There are two important operations on pattern-stacks necessary to understand the algorithm:\n-//!     1. We can pop a given constructor off the top of a stack. This operation is called\n-//!        `specialize`, and is denoted `S(c, p)` where `c` is a constructor (like `Some` or\n-//!        `None`) and `p` a pattern-stack.\n-//!        If the pattern on top of the stack can cover `c`, this removes the constructor and\n-//!        pushes its arguments onto the stack. It also expands OR-patterns into distinct patterns.\n-//!        Otherwise the pattern-stack is discarded.\n-//!        This essentially filters those pattern-stacks whose top covers the constructor `c` and\n-//!        discards the others.\n //!\n-//!        For example, the first pattern above initially gives a stack `[(Some(true), _)]`. If we\n-//!        pop the tuple constructor, we are left with `[Some(true), _]`, and if we then pop the\n-//!        `Some` constructor we get `[true, _]`. If we had popped `None` instead, we would get\n-//!        nothing back.\n+//! 1. We can pop a given constructor off the top of a stack. This operation is called\n+//!    `specialize`, and is denoted `S(c, p)` where `c` is a constructor (like `Some` or\n+//!    `None`) and `p` a pattern-stack.\n+//!    If the pattern on top of the stack can cover `c`, this removes the constructor and\n+//!    pushes its arguments onto the stack. It also expands OR-patterns into distinct patterns.\n+//!    Otherwise the pattern-stack is discarded.\n+//!    This essentially filters those pattern-stacks whose top covers the constructor `c` and\n+//!    discards the others.\n //!\n-//!        This returns zero or more new pattern-stacks, as follows. We look at the pattern `p_1`\n-//!        on top of the stack, and we have four cases:\n-//!             1.1. `p_1 = c(r_1, .., r_a)`, i.e. the top of the stack has constructor `c`. We\n-//!                  push onto the stack the arguments of this constructor, and return the result:\n-//!                     r_1, .., r_a, p_2, .., p_n\n-//!             1.2. `p_1 = c'(r_1, .., r_a')` where `c \u2260 c'`. We discard the current stack and\n-//!                  return nothing.\n-//!             1.3. `p_1 = _`. We push onto the stack as many wildcards as the constructor `c` has\n-//!                  arguments (its arity), and return the resulting stack:\n-//!                     _, .., _, p_2, .., p_n\n-//!             1.4. `p_1 = r_1 | r_2`. We expand the OR-pattern and then recurse on each resulting\n-//!                  stack:\n-//!                     S(c, (r_1, p_2, .., p_n))\n-//!                     S(c, (r_2, p_2, .., p_n))\n+//!    For example, the first pattern above initially gives a stack `[(Some(true), _)]`. If we\n+//!    pop the tuple constructor, we are left with `[Some(true), _]`, and if we then pop the\n+//!    `Some` constructor we get `[true, _]`. If we had popped `None` instead, we would get\n+//!    nothing back.\n //!\n-//!     2. We can pop a wildcard off the top of the stack. This is called `D(p)`, where `p` is\n-//!        a pattern-stack.\n-//!        This is used when we know there are missing constructor cases, but there might be\n-//!        existing wildcard patterns, so to check the usefulness of the matrix, we have to check\n-//!        all its *other* components.\n+//!    This returns zero or more new pattern-stacks, as follows. We look at the pattern `p_1`\n+//!    on top of the stack, and we have four cases:\n+//!         1.1. `p_1 = c(r_1, .., r_a)`, i.e. the top of the stack has constructor `c`. We\n+//!              push onto the stack the arguments of this constructor, and return the result:\n+//!                 r_1, .., r_a, p_2, .., p_n\n+//!         1.2. `p_1 = c'(r_1, .., r_a')` where `c \u2260 c'`. We discard the current stack and\n+//!              return nothing.\n+//!         1.3. `p_1 = _`. We push onto the stack as many wildcards as the constructor `c` has\n+//!              arguments (its arity), and return the resulting stack:\n+//!                 _, .., _, p_2, .., p_n\n+//!         1.4. `p_1 = r_1 | r_2`. We expand the OR-pattern and then recurse on each resulting\n+//!              stack:\n+//!                 S(c, (r_1, p_2, .., p_n))\n+//!                 S(c, (r_2, p_2, .., p_n))\n //!\n-//!        It is computed as follows. We look at the pattern `p_1` on top of the stack,\n-//!        and we have three cases:\n-//!             1.1. `p_1 = c(r_1, .., r_a)`. We discard the current stack and return nothing.\n-//!             1.2. `p_1 = _`. We return the rest of the stack:\n-//!                     p_2, .., p_n\n-//!             1.3. `p_1 = r_1 | r_2`. We expand the OR-pattern and then recurse on each resulting\n-//!               stack.\n-//!                     D((r_1, p_2, .., p_n))\n-//!                     D((r_2, p_2, .., p_n))\n+//! 2. We can pop a wildcard off the top of the stack. This is called `D(p)`, where `p` is\n+//!    a pattern-stack.\n+//!    This is used when we know there are missing constructor cases, but there might be\n+//!    existing wildcard patterns, so to check the usefulness of the matrix, we have to check\n+//!    all its *other* components.\n //!\n-//!     Note that the OR-patterns are not always used directly in Rust, but are used to derive the\n-//!     exhaustive integer matching rules, so they're written here for posterity.\n+//!    It is computed as follows. We look at the pattern `p_1` on top of the stack,\n+//!    and we have three cases:\n+//!         1.1. `p_1 = c(r_1, .., r_a)`. We discard the current stack and return nothing.\n+//!         1.2. `p_1 = _`. We return the rest of the stack:\n+//!                 p_2, .., p_n\n+//!         1.3. `p_1 = r_1 | r_2`. We expand the OR-pattern and then recurse on each resulting\n+//!           stack.\n+//!                 D((r_1, p_2, .., p_n))\n+//!                 D((r_2, p_2, .., p_n))\n+//!\n+//! Note that the OR-patterns are not always used directly in Rust, but are used to derive the\n+//! exhaustive integer matching rules, so they're written here for posterity.\n //!\n //! Both those operations extend straightforwardly to a list or pattern-stacks, i.e. a matrix, by\n //! working row-by-row. Popping a constructor ends up keeping only the matrix rows that start with\n@@ -168,66 +169,66 @@\n //!\n //! Inductive step. (`n > 0`, i.e., whether there's at least one column\n //!                  [which may then be expanded into further columns later])\n-//!     We're going to match on the top of the new pattern-stack, `p_1`.\n-//!         - If `p_1 == c(r_1, .., r_a)`, i.e. we have a constructor pattern.\n-//!           Then, the usefulness of `p_1` can be reduced to whether it is useful when\n-//!           we ignore all the patterns in the first column of `P` that involve other constructors.\n-//!           This is where `S(c, P)` comes in:\n-//!           `U(P, p) := U(S(c, P), S(c, p))`\n-//!           This special case is handled in `is_useful_specialized`.\n+//! We're going to match on the top of the new pattern-stack, `p_1`.\n+//!     - If `p_1 == c(r_1, .., r_a)`, i.e. we have a constructor pattern.\n+//! Then, the usefulness of `p_1` can be reduced to whether it is useful when\n+//! we ignore all the patterns in the first column of `P` that involve other constructors.\n+//! This is where `S(c, P)` comes in:\n+//! `U(P, p) := U(S(c, P), S(c, p))`\n+//! This special case is handled in `is_useful_specialized`.\n //!\n-//!           For example, if `P` is:\n-//!           [\n-//!               [Some(true), _],\n-//!               [None, 0],\n-//!           ]\n-//!           and `p` is [Some(false), 0], then we don't care about row 2 since we know `p` only\n-//!           matches values that row 2 doesn't. For row 1 however, we need to dig into the\n-//!           arguments of `Some` to know whether some new value is covered. So we compute\n-//!           `U([[true, _]], [false, 0])`.\n+//! For example, if `P` is:\n+//! [\n+//! [Some(true), _],\n+//! [None, 0],\n+//! ]\n+//! and `p` is [Some(false), 0], then we don't care about row 2 since we know `p` only\n+//! matches values that row 2 doesn't. For row 1 however, we need to dig into the\n+//! arguments of `Some` to know whether some new value is covered. So we compute\n+//! `U([[true, _]], [false, 0])`.\n //!\n-//!         - If `p_1 == _`, then we look at the list of constructors that appear in the first\n-//!               component of the rows of `P`:\n-//!             + If there are some constructors that aren't present, then we might think that the\n-//!               wildcard `_` is useful, since it covers those constructors that weren't covered\n-//!               before.\n-//!               That's almost correct, but only works if there were no wildcards in those first\n-//!               components. So we need to check that `p` is useful with respect to the rows that\n-//!               start with a wildcard, if there are any. This is where `D` comes in:\n-//!               `U(P, p) := U(D(P), D(p))`\n+//!   - If `p_1 == _`, then we look at the list of constructors that appear in the first\n+//! component of the rows of `P`:\n+//!   + If there are some constructors that aren't present, then we might think that the\n+//! wildcard `_` is useful, since it covers those constructors that weren't covered\n+//! before.\n+//! That's almost correct, but only works if there were no wildcards in those first\n+//! components. So we need to check that `p` is useful with respect to the rows that\n+//! start with a wildcard, if there are any. This is where `D` comes in:\n+//! `U(P, p) := U(D(P), D(p))`\n //!\n-//!               For example, if `P` is:\n-//!               [\n-//!                   [_, true, _],\n-//!                   [None, false, 1],\n-//!               ]\n-//!               and `p` is [_, false, _], the `Some` constructor doesn't appear in `P`. So if we\n-//!               only had row 2, we'd know that `p` is useful. However row 1 starts with a\n-//!               wildcard, so we need to check whether `U([[true, _]], [false, 1])`.\n+//! For example, if `P` is:\n+//! [\n+//!     [_, true, _],\n+//!     [None, false, 1],\n+//! ]\n+//! and `p` is [_, false, _], the `Some` constructor doesn't appear in `P`. So if we\n+//! only had row 2, we'd know that `p` is useful. However row 1 starts with a\n+//! wildcard, so we need to check whether `U([[true, _]], [false, 1])`.\n //!\n-//!             + Otherwise, all possible constructors (for the relevant type) are present. In this\n-//!               case we must check whether the wildcard pattern covers any unmatched value. For\n-//!               that, we can think of the `_` pattern as a big OR-pattern that covers all\n-//!               possible constructors. For `Option`, that would mean `_ = None | Some(_)` for\n-//!               example. The wildcard pattern is useful in this case if it is useful when\n-//!               specialized to one of the possible constructors. So we compute:\n-//!               `U(P, p) := \u2203(k \u03f5 constructors) U(S(k, P), S(k, p))`\n+//!   + Otherwise, all possible constructors (for the relevant type) are present. In this\n+//! case we must check whether the wildcard pattern covers any unmatched value. For\n+//! that, we can think of the `_` pattern as a big OR-pattern that covers all\n+//! possible constructors. For `Option`, that would mean `_ = None | Some(_)` for\n+//! example. The wildcard pattern is useful in this case if it is useful when\n+//! specialized to one of the possible constructors. So we compute:\n+//! `U(P, p) := \u2203(k \u03f5 constructors) U(S(k, P), S(k, p))`\n //!\n-//!               For example, if `P` is:\n-//!               [\n-//!                   [Some(true), _],\n-//!                   [None, false],\n-//!               ]\n-//!               and `p` is [_, false], both `None` and `Some` constructors appear in the first\n-//!               components of `P`. We will therefore try popping both constructors in turn: we\n-//!               compute U([[true, _]], [_, false]) for the `Some` constructor, and U([[false]],\n-//!               [false]) for the `None` constructor. The first case returns true, so we know that\n-//!               `p` is useful for `P`. Indeed, it matches `[Some(false), _]` that wasn't matched\n-//!               before.\n+//! For example, if `P` is:\n+//! [\n+//!     [Some(true), _],\n+//!     [None, false],\n+//! ]\n+//! and `p` is [_, false], both `None` and `Some` constructors appear in the first\n+//! components of `P`. We will therefore try popping both constructors in turn: we\n+//! compute `U([[true, _]], [_, false])` for the `Some` constructor, and `U([[false]],\n+//! [false])` for the `None` constructor. The first case returns true, so we know that\n+//! `p` is useful for `P`. Indeed, it matches `[Some(false), _]` that wasn't matched\n+//! before.\n //!\n-//!         - If `p_1 == r_1 | r_2`, then the usefulness depends on each `r_i` separately:\n-//!           `U(P, p) := U(P, (r_1, p_2, .., p_n))\n-//!                    || U(P, (r_2, p_2, .., p_n))`\n+//!   - If `p_1 == r_1 | r_2`, then the usefulness depends on each `r_i` separately:\n+//! `U(P, p) := U(P, (r_1, p_2, .., p_n))\n+//!  || U(P, (r_2, p_2, .., p_n))`\n //!\n //! Modifications to the algorithm\n //! ------------------------------"}]}