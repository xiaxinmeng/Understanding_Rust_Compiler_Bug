{"sha": "d26ebec81ce5d450f1bf3065ae990e6b1ca1c551", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQyNmViZWM4MWNlNWQ0NTBmMWJmMzA2NWFlOTkwZTZiMWNhMWM1NTE=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2018-01-25T11:59:24Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2018-03-08T07:34:09Z"}, "message": "Hide the RefCell inside InterpretInterner\n\nIt was too easy to get this wrong", "tree": {"sha": "cde065a45bec9dffb24aae3d48130af5db00829d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cde065a45bec9dffb24aae3d48130af5db00829d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d26ebec81ce5d450f1bf3065ae990e6b1ca1c551", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEYFTdM4NKd7XQft77pp+NIls619kFAlqg53EACgkQpp+NIls6\n19mn+xAAs7ennUP880CgfAyNeCPuVz7Jv7TK5vMj8TalX8JH2Tmku6ITF24ngS9w\n4wHjatjH8YMu0F4EQ5mVEUrommczApAwoJN4ZuabRliBxuAF0VlGt+VxEa6+QbDj\nTHnP3+gLyMjRv2ItmikEbEpXwOjr96zRFJfvGlNf/Ts91CR3v870fedXC5ZLN/i9\n91f5lQnexxnsC1atMPvzrtYPtBsUtblFxIV5AsoYc8EBywa8te/jMN3dTaXr+/CC\nHATblS101F5y9UXJEf2Bm8IrA1FPcu+abpmU5kTcwlLvDdLi2HcQePYk2qqjvRnY\nre1p+9n0gMOcPzPKcKqLpeARnCsTu0hGzHPchcu5Y53oz5XEtrO4sccKaAshJk1t\nKgx7ew4jJB4li8TrQveYcvPbwYwKCOlS6YhRTHwfaVtBvFElDgQwhrThaYRy8tK/\neuLd8quKOeq2FxxvjBLRSc7uYlCeNUy3O6Tw1La3ny92KGANPEJ4q1lr1alO/fGk\noZeXnfa1kwxmxxZyVFKztifJ6YhVQss/AO/JPUt5c8BzT7p3jDmhZEym8iTKKzmM\nhohOOuY3eEA9DIYIX+Q1bSCvJQfeQTFZzdcumyPWT6mdzsLziBa5r77uiE25iaz0\noB7X76JNpD1Uc+nKXiHfKYXf0sWtf4lUJjb2jX7YnQ2Zv6x9aEo=\n=RHjy\n-----END PGP SIGNATURE-----", "payload": "tree cde065a45bec9dffb24aae3d48130af5db00829d\nparent 37d8b9a86c7352f99c4f65987bd881d090fdee00\nauthor Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1516881564 +0100\ncommitter Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1520494449 +0100\n\nHide the RefCell inside InterpretInterner\n\nIt was too easy to get this wrong\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d26ebec81ce5d450f1bf3065ae990e6b1ca1c551", "html_url": "https://github.com/rust-lang/rust/commit/d26ebec81ce5d450f1bf3065ae990e6b1ca1c551", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d26ebec81ce5d450f1bf3065ae990e6b1ca1c551/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "37d8b9a86c7352f99c4f65987bd881d090fdee00", "url": "https://api.github.com/repos/rust-lang/rust/commits/37d8b9a86c7352f99c4f65987bd881d090fdee00", "html_url": "https://github.com/rust-lang/rust/commit/37d8b9a86c7352f99c4f65987bd881d090fdee00"}], "stats": {"total": 156, "additions": 72, "deletions": 84}, "files": [{"sha": "54297a1fc398f84cbdf06ec49db261383c3ebfb5", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d26ebec81ce5d450f1bf3065ae990e6b1ca1c551/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d26ebec81ce5d450f1bf3065ae990e6b1ca1c551/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=d26ebec81ce5d450f1bf3065ae990e6b1ca1c551", "patch": "@@ -376,18 +376,15 @@ impl<'a> HashStable<StableHashingContext<'a>> for mir::interpret::AllocId {\n     ) {\n         ty::tls::with_opt(|tcx| {\n             let tcx = tcx.expect(\"can't hash AllocIds during hir lowering\");\n-            let interner = tcx\n-                .interpret_interner\n-                .borrow();\n-            if let Some(def_id) = interner.get_corresponding_static_def_id(*self) {\n+            if let Some(def_id) = tcx.interpret_interner.get_corresponding_static_def_id(*self) {\n                 0.hash_stable(hcx, hasher);\n                 // statics are unique via their DefId\n                 def_id.hash_stable(hcx, hasher);\n-            } else if let Some(alloc) = interner.get_alloc(*self) {\n+            } else if let Some(alloc) = tcx.interpret_interner.get_alloc(*self) {\n                 // not a static, can't be recursive, hash the allocation\n                 1.hash_stable(hcx, hasher);\n                 alloc.hash_stable(hcx, hasher);\n-            } else if let Some(inst) = interner.get_fn(*self) {\n+            } else if let Some(inst) = tcx.interpret_interner.get_fn(*self) {\n                 2.hash_stable(hcx, hasher);\n                 inst.hash_stable(hcx, hasher);\n             } else {"}, {"sha": "24f4a74b3ac38f6a3e9c978edb4dc6c23405c4f8", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d26ebec81ce5d450f1bf3065ae990e6b1ca1c551/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d26ebec81ce5d450f1bf3065ae990e6b1ca1c551/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=d26ebec81ce5d450f1bf3065ae990e6b1ca1c551", "patch": "@@ -1897,7 +1897,6 @@ pub fn print_miri_value<W: Write>(value: Value, ty: Ty, f: &mut W) -> fmt::Resul\n             ty::tls::with(|tcx| {\n                 let alloc = tcx\n                     .interpret_interner\n-                    .borrow()\n                     .get_alloc(ptr.alloc_id);\n                 if let Some(alloc) = alloc {\n                     assert_eq!(len as usize as u128, len);"}, {"sha": "a4e5f725837dea3870c5142671e73a260041ee5b", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 33, "deletions": 25, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/d26ebec81ce5d450f1bf3065ae990e6b1ca1c551/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d26ebec81ce5d450f1bf3065ae990e6b1ca1c551/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=d26ebec81ce5d450f1bf3065ae990e6b1ca1c551", "patch": "@@ -869,7 +869,7 @@ pub struct GlobalCtxt<'tcx> {\n \n     stability_interner: RefCell<FxHashSet<&'tcx attr::Stability>>,\n \n-    pub interpret_interner: RefCell<InterpretInterner<'tcx>>,\n+    pub interpret_interner: InterpretInterner<'tcx>,\n \n     layout_interner: RefCell<FxHashSet<&'tcx LayoutDetails>>,\n \n@@ -893,6 +893,11 @@ pub struct GlobalCtxt<'tcx> {\n /// Everything needed to efficiently work with interned allocations\n #[derive(Debug, Default)]\n pub struct InterpretInterner<'tcx> {\n+    inner: RefCell<InterpretInternerInner<'tcx>>,\n+}\n+\n+#[derive(Debug, Default)]\n+struct InterpretInternerInner<'tcx> {\n     /// Stores the value of constants (and deduplicates the actual memory)\n     allocs: FxHashSet<&'tcx interpret::Allocation>,\n \n@@ -925,45 +930,47 @@ pub struct InterpretInterner<'tcx> {\n }\n \n impl<'tcx> InterpretInterner<'tcx> {\n-    pub fn create_fn_alloc(&mut self, instance: Instance<'tcx>) -> interpret::AllocId {\n-        if let Some(&alloc_id) = self.function_cache.get(&instance) {\n+    pub fn create_fn_alloc(&self, instance: Instance<'tcx>) -> interpret::AllocId {\n+        if let Some(&alloc_id) = self.inner.borrow().function_cache.get(&instance) {\n             return alloc_id;\n         }\n         let id = self.reserve();\n         debug!(\"creating fn ptr: {}\", id);\n-        self.functions.insert(id, instance);\n-        self.function_cache.insert(instance, id);\n+        let mut inner = self.inner.borrow_mut();\n+        inner.functions.insert(id, instance);\n+        inner.function_cache.insert(instance, id);\n         id\n     }\n \n     pub fn get_fn(\n         &self,\n         id: interpret::AllocId,\n     ) -> Option<Instance<'tcx>> {\n-        self.functions.get(&id).cloned()\n+        self.inner.borrow().functions.get(&id).cloned()\n     }\n \n     pub fn get_alloc(\n         &self,\n         id: interpret::AllocId,\n     ) -> Option<&'tcx interpret::Allocation> {\n-        self.alloc_by_id.get(&id).cloned()\n+        self.inner.borrow().alloc_by_id.get(&id).cloned()\n     }\n \n     pub fn get_cached(\n         &self,\n         static_id: DefId,\n     ) -> Option<interpret::AllocId> {\n-        self.alloc_cache.get(&static_id).cloned()\n+        self.inner.borrow().alloc_cache.get(&static_id).cloned()\n     }\n \n     pub fn cache(\n-        &mut self,\n+        &self,\n         static_id: DefId,\n         alloc_id: interpret::AllocId,\n     ) {\n-        self.global_cache.insert(alloc_id, static_id);\n-        if let Some(old) = self.alloc_cache.insert(static_id, alloc_id) {\n+        let mut inner = self.inner.borrow_mut();\n+        inner.global_cache.insert(alloc_id, static_id);\n+        if let Some(old) = inner.alloc_cache.insert(static_id, alloc_id) {\n             bug!(\"tried to cache {:?}, but was already existing as {:#?}\", static_id, old);\n         }\n     }\n@@ -972,26 +979,27 @@ impl<'tcx> InterpretInterner<'tcx> {\n         &self,\n         ptr: interpret::AllocId,\n     ) -> Option<DefId> {\n-        self.global_cache.get(&ptr).cloned()\n+        self.inner.borrow().global_cache.get(&ptr).cloned()\n     }\n \n     pub fn intern_at_reserved(\n-        &mut self,\n+        &self,\n         id: interpret::AllocId,\n         alloc: &'tcx interpret::Allocation,\n     ) {\n-        if let Some(old) = self.alloc_by_id.insert(id, alloc) {\n+        if let Some(old) = self.inner.borrow_mut().alloc_by_id.insert(id, alloc) {\n             bug!(\"tried to intern allocation at {}, but was already existing as {:#?}\", id, old);\n         }\n     }\n \n     /// obtains a new allocation ID that can be referenced but does not\n     /// yet have an allocation backing it.\n     pub fn reserve(\n-        &mut self,\n+        &self,\n     ) -> interpret::AllocId {\n-        let next = self.next_id;\n-        self.next_id.0 = self.next_id.0\n+        let mut inner = self.inner.borrow_mut();\n+        let next = inner.next_id;\n+        inner.next_id.0 = inner.next_id.0\n             .checked_add(1)\n             .expect(\"You overflowed a u64 by incrementing by 1... \\\n                      You've just earned yourself a free drink if we ever meet. \\\n@@ -1071,12 +1079,12 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self,\n         alloc: interpret::Allocation,\n     ) -> &'gcx interpret::Allocation {\n-        if let Some(alloc) = self.interpret_interner.borrow().allocs.get(&alloc) {\n+        if let Some(alloc) = self.interpret_interner.inner.borrow().allocs.get(&alloc) {\n             return alloc;\n         }\n \n         let interned = self.global_arenas.const_allocs.alloc(alloc);\n-        if let Some(prev) = self.interpret_interner.borrow_mut().allocs.replace(interned) {\n+        if let Some(prev) = self.interpret_interner.inner.borrow_mut().allocs.replace(interned) {\n             bug!(\"Tried to overwrite interned Allocation: {:#?}\", prev)\n         }\n         interned\n@@ -1085,20 +1093,20 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// Allocates a byte or string literal for `mir::interpret`\n     pub fn allocate_cached(self, bytes: &[u8]) -> interpret::AllocId {\n         // check whether we already allocated this literal or a constant with the same memory\n-        if let Some(&alloc_id) = self.interpret_interner.borrow().literal_alloc_cache.get(bytes) {\n+        if let Some(&alloc_id) = self.interpret_interner.inner.borrow()\n+                                     .literal_alloc_cache.get(bytes) {\n             return alloc_id;\n         }\n         // create an allocation that just contains these bytes\n         let alloc = interpret::Allocation::from_bytes(bytes);\n         let alloc = self.intern_const_alloc(alloc);\n \n-        let mut int = self.interpret_interner.borrow_mut();\n         // the next unique id\n-        let id = int.reserve();\n+        let id = self.interpret_interner.reserve();\n         // make the allocation identifiable\n-        int.alloc_by_id.insert(id, alloc);\n+        self.interpret_interner.inner.borrow_mut().alloc_by_id.insert(id, alloc);\n         // cache it for the future\n-        int.literal_alloc_cache.insert(bytes.to_owned(), id);\n+        self.interpret_interner.inner.borrow_mut().literal_alloc_cache.insert(bytes.to_owned(), id);\n         id\n     }\n \n@@ -1776,7 +1784,7 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n         println!(\"Substs interner: #{}\", self.interners.substs.borrow().len());\n         println!(\"Region interner: #{}\", self.interners.region.borrow().len());\n         println!(\"Stability interner: #{}\", self.stability_interner.borrow().len());\n-        println!(\"Interpret interner: #{}\", self.interpret_interner.borrow().allocs.len());\n+        println!(\"Interpret interner: #{}\", self.interpret_interner.inner.borrow().allocs.len());\n         println!(\"Layout interner: #{}\", self.layout_interner.borrow().len());\n     }\n }"}, {"sha": "5a24b1067b1ba5bc61289fa16d7cb02b5b51ed1e", "filename": "src/librustc/ty/maps/on_disk_cache.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d26ebec81ce5d450f1bf3065ae990e6b1ca1c551/src%2Flibrustc%2Fty%2Fmaps%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d26ebec81ce5d450f1bf3065ae990e6b1ca1c551/src%2Flibrustc%2Fty%2Fmaps%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fon_disk_cache.rs?ref=d26ebec81ce5d450f1bf3065ae990e6b1ca1c551", "patch": "@@ -548,22 +548,21 @@ impl<'a, 'tcx, 'x> SpecializedDecoder<interpret::AllocId> for CacheDecoder<'a, '\n     fn specialized_decode(&mut self) -> Result<interpret::AllocId, Self::Error> {\n         const MAX1: usize = usize::max_value() - 1;\n         let tcx = self.tcx;\n-        let interpret_interner = || tcx.interpret_interner.borrow_mut();\n         let pos = TyDecoder::position(self);\n         match usize::decode(self)? {\n             ::std::usize::MAX => {\n-                let alloc_id = interpret_interner().reserve();\n+                let alloc_id = tcx.interpret_interner.reserve();\n                 trace!(\"creating alloc id {:?} at {}\", alloc_id, pos);\n                 // insert early to allow recursive allocs\n                 self.interpret_alloc_cache.insert(pos, alloc_id);\n \n                 let allocation = interpret::Allocation::decode(self)?;\n                 trace!(\"decoded alloc {:?} {:#?}\", alloc_id, allocation);\n                 let allocation = self.tcx.intern_const_alloc(allocation);\n-                interpret_interner().intern_at_reserved(alloc_id, allocation);\n+                tcx.interpret_interner.intern_at_reserved(alloc_id, allocation);\n \n                 if let Some(glob) = Option::<DefId>::decode(self)? {\n-                    interpret_interner().cache(glob, alloc_id);\n+                    tcx.interpret_interner.cache(glob, alloc_id);\n                 }\n \n                 Ok(alloc_id)\n@@ -572,7 +571,7 @@ impl<'a, 'tcx, 'x> SpecializedDecoder<interpret::AllocId> for CacheDecoder<'a, '\n                 trace!(\"creating fn alloc id at {}\", pos);\n                 let instance = ty::Instance::decode(self)?;\n                 trace!(\"decoded fn alloc instance: {:?}\", instance);\n-                let id = interpret_interner().create_fn_alloc(instance);\n+                let id = tcx.interpret_interner.create_fn_alloc(instance);\n                 trace!(\"created fn alloc id: {:?}\", id);\n                 self.interpret_alloc_cache.insert(pos, id);\n                 Ok(id)\n@@ -796,14 +795,14 @@ impl<'enc, 'a, 'tcx, E> SpecializedEncoder<interpret::AllocId> for CacheEncoder<\n         // cache the allocation shorthand now, because the allocation itself might recursively\n         // point to itself.\n         self.interpret_alloc_shorthands.insert(*alloc_id, start);\n-        if let Some(alloc) = self.tcx.interpret_interner.borrow().get_alloc(*alloc_id) {\n+        if let Some(alloc) = self.tcx.interpret_interner.get_alloc(*alloc_id) {\n             trace!(\"encoding {:?} with {:#?}\", alloc_id, alloc);\n             usize::max_value().encode(self)?;\n             alloc.encode(self)?;\n-            self.tcx.interpret_interner.borrow()\n+            self.tcx.interpret_interner\n                 .get_corresponding_static_def_id(*alloc_id)\n                 .encode(self)?;\n-        } else if let Some(fn_instance) = self.tcx.interpret_interner.borrow().get_fn(*alloc_id) {\n+        } else if let Some(fn_instance) = self.tcx.interpret_interner.get_fn(*alloc_id) {\n             trace!(\"encoding {:?} with {:#?}\", alloc_id, fn_instance);\n             (usize::max_value() - 1).encode(self)?;\n             fn_instance.encode(self)?;"}, {"sha": "f44703b9335e20e360c71e02414e0ddbc976e61a", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d26ebec81ce5d450f1bf3065ae990e6b1ca1c551/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d26ebec81ce5d450f1bf3065ae990e6b1ca1c551/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=d26ebec81ce5d450f1bf3065ae990e6b1ca1c551", "patch": "@@ -283,23 +283,22 @@ impl<'a, 'tcx> SpecializedDecoder<LocalDefId> for DecodeContext<'a, 'tcx> {\n impl<'a, 'tcx> SpecializedDecoder<interpret::AllocId> for DecodeContext<'a, 'tcx> {\n     fn specialized_decode(&mut self) -> Result<interpret::AllocId, Self::Error> {\n         const MAX1: usize = usize::max_value() - 1;\n-        let tcx = self.tcx;\n-        let interpret_interner = || tcx.unwrap().interpret_interner.borrow_mut();\n+        let tcx = self.tcx.unwrap();\n         let pos = self.position();\n         match usize::decode(self)? {\n             ::std::usize::MAX => {\n-                let alloc_id = interpret_interner().reserve();\n+                let alloc_id = tcx.interpret_interner.reserve();\n                 trace!(\"creating alloc id {:?} at {}\", alloc_id, pos);\n                 // insert early to allow recursive allocs\n                 self.interpret_alloc_cache.insert(pos, alloc_id);\n \n                 let allocation = interpret::Allocation::decode(self)?;\n                 trace!(\"decoded alloc {:?} {:#?}\", alloc_id, allocation);\n                 let allocation = self.tcx.unwrap().intern_const_alloc(allocation);\n-                interpret_interner().intern_at_reserved(alloc_id, allocation);\n+                tcx.interpret_interner.intern_at_reserved(alloc_id, allocation);\n \n                 if let Some(glob) = Option::<DefId>::decode(self)? {\n-                    interpret_interner().cache(glob, alloc_id);\n+                    tcx.interpret_interner.cache(glob, alloc_id);\n                 }\n \n                 Ok(alloc_id)\n@@ -308,7 +307,7 @@ impl<'a, 'tcx> SpecializedDecoder<interpret::AllocId> for DecodeContext<'a, 'tcx\n                 trace!(\"creating fn alloc id at {}\", pos);\n                 let instance = ty::Instance::decode(self)?;\n                 trace!(\"decoded fn alloc instance: {:?}\", instance);\n-                let id = interpret_interner().create_fn_alloc(instance);\n+                let id = tcx.interpret_interner.create_fn_alloc(instance);\n                 trace!(\"created fn alloc id: {:?}\", id);\n                 self.interpret_alloc_cache.insert(pos, id);\n                 Ok(id)"}, {"sha": "d959482417489a16b015c8c77f23e31737a791ff", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d26ebec81ce5d450f1bf3065ae990e6b1ca1c551/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d26ebec81ce5d450f1bf3065ae990e6b1ca1c551/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=d26ebec81ce5d450f1bf3065ae990e6b1ca1c551", "patch": "@@ -205,14 +205,14 @@ impl<'a, 'tcx> SpecializedEncoder<interpret::AllocId> for EncodeContext<'a, 'tcx\n         // cache the allocation shorthand now, because the allocation itself might recursively\n         // point to itself.\n         self.interpret_alloc_shorthands.insert(*alloc_id, start);\n-        if let Some(alloc) = self.tcx.interpret_interner.borrow().get_alloc(*alloc_id) {\n+        if let Some(alloc) = self.tcx.interpret_interner.get_alloc(*alloc_id) {\n             trace!(\"encoding {:?} with {:#?}\", alloc_id, alloc);\n             usize::max_value().encode(self)?;\n             alloc.encode(self)?;\n-            self.tcx.interpret_interner.borrow()\n+            self.tcx.interpret_interner\n                 .get_corresponding_static_def_id(*alloc_id)\n                 .encode(self)?;\n-        } else if let Some(fn_instance) = self.tcx.interpret_interner.borrow().get_fn(*alloc_id) {\n+        } else if let Some(fn_instance) = self.tcx.interpret_interner.get_fn(*alloc_id) {\n             trace!(\"encoding {:?} with {:#?}\", alloc_id, fn_instance);\n             (usize::max_value() - 1).encode(self)?;\n             fn_instance.encode(self)?;"}, {"sha": "35aa5adf76d7c4e44ebfbf3717af590a8f9d20db", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d26ebec81ce5d450f1bf3065ae990e6b1ca1c551/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d26ebec81ce5d450f1bf3065ae990e6b1ca1c551/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=d26ebec81ce5d450f1bf3065ae990e6b1ca1c551", "patch": "@@ -263,7 +263,6 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n                     ConstVal::Value(Value::ByVal(PrimVal::Ptr(p))) => {\n                         self.tcx()\n                             .interpret_interner\n-                            .borrow()\n                             .get_fn(p.alloc_id)\n                             .map(|instance| instance.def_id())\n                     },\n@@ -1044,7 +1043,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 ..\n             }) => match val {\n                 ConstVal::Value(Value::ByVal(PrimVal::Ptr(p))) => {\n-                    let inst = self.tcx().interpret_interner.borrow().get_fn(p.alloc_id);\n+                    let inst = self.tcx().interpret_interner.get_fn(p.alloc_id);\n                     inst.map_or(false, |inst| {\n                         Some(inst.def_id()) == self.tcx().lang_items().box_free_fn()\n                     })"}, {"sha": "0f1eaf92ff12afbf8c4c5c7eaedf2deb0c4ddd2f", "filename": "src/librustc_mir/const_eval/_match.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d26ebec81ce5d450f1bf3065ae990e6b1ca1c551/src%2Flibrustc_mir%2Fconst_eval%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d26ebec81ce5d450f1bf3065ae990e6b1ca1c551/src%2Flibrustc_mir%2Fconst_eval%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2F_match.rs?ref=d26ebec81ce5d450f1bf3065ae990e6b1ca1c551", "patch": "@@ -192,7 +192,6 @@ impl<'a, 'tcx> MatchCheckCtxt<'a, 'tcx> {\n                             assert!(is_array_ptr);\n                             let alloc = tcx\n                                 .interpret_interner\n-                                .borrow()\n                                 .get_alloc(ptr.alloc_id)\n                                 .unwrap();\n                             assert_eq!(ptr.offset, 0);\n@@ -568,7 +567,6 @@ fn max_slice_length<'p, 'a: 'p, 'tcx: 'a, I>(\n                 if is_array_ptr {\n                     let alloc = cx.tcx\n                         .interpret_interner\n-                        .borrow()\n                         .get_alloc(ptr.alloc_id)\n                         .unwrap();\n                     max_fixed_len = cmp::max(max_fixed_len, alloc.bytes.len() as u64);\n@@ -958,7 +956,6 @@ fn slice_pat_covered_by_constructor(tcx: TyCtxt, _span: Span,\n             assert!(is_array_ptr);\n             tcx\n                 .interpret_interner\n-                .borrow()\n                 .get_alloc(ptr.alloc_id)\n                 .unwrap()\n                 .bytes\n@@ -1099,7 +1096,6 @@ fn specialize<'p, 'a: 'p, 'tcx: 'a>(\n                         assert!(is_array_ptr);\n                         let data_len = cx.tcx\n                             .interpret_interner\n-                            .borrow()\n                             .get_alloc(ptr.alloc_id)\n                             .unwrap()\n                             .bytes"}, {"sha": "c2bb9f2efe126e8c8fd8d063af899f4b0e65dbb9", "filename": "src/librustc_mir/interpret/const_eval.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d26ebec81ce5d450f1bf3065ae990e6b1ca1c551/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d26ebec81ce5d450f1bf3065ae990e6b1ca1c551/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs?ref=d26ebec81ce5d450f1bf3065ae990e6b1ca1c551", "patch": "@@ -106,7 +106,7 @@ fn eval_body_and_ecx<'a, 'mir, 'tcx>(\n             mir = &mir.promoted[index];\n         }\n         let layout = ecx.layout_of(mir.return_ty().subst(tcx, cid.instance.substs))?;\n-        let alloc = tcx.interpret_interner.borrow().get_cached(cid.instance.def_id());\n+        let alloc = tcx.interpret_interner.get_cached(cid.instance.def_id());\n         let alloc = match alloc {\n             Some(alloc) => {\n                 assert!(cid.promoted.is_none());\n@@ -121,7 +121,7 @@ fn eval_body_and_ecx<'a, 'mir, 'tcx>(\n                     None,\n                 )?;\n                 if tcx.is_static(cid.instance.def_id()).is_some() {\n-                    tcx.interpret_interner.borrow_mut().cache(cid.instance.def_id(), ptr.alloc_id);\n+                    tcx.interpret_interner.cache(cid.instance.def_id(), ptr.alloc_id);\n                 }\n                 let span = tcx.def_span(cid.instance.def_id());\n                 let internally_mutable = !layout.ty.is_freeze(tcx, param_env, span);\n@@ -343,7 +343,6 @@ impl<'mir, 'tcx> super::Machine<'mir, 'tcx> for CompileTimeEvaluator {\n         Ok(ecx\n             .tcx\n             .interpret_interner\n-            .borrow()\n             .get_cached(cid.instance.def_id())\n             .expect(\"uncached static\"))\n     }\n@@ -457,13 +456,13 @@ pub fn const_eval_provider<'a, 'tcx>(\n     let span = tcx.def_span(def_id);\n \n     if tcx.is_foreign_item(def_id) {\n-        let id = tcx.interpret_interner.borrow().get_cached(def_id);\n+        let id = tcx.interpret_interner.get_cached(def_id);\n         let id = match id {\n             // FIXME: due to caches this shouldn't happen, add some assertions\n             Some(id) => id,\n             None => {\n-                let id = tcx.interpret_interner.borrow_mut().reserve();\n-                tcx.interpret_interner.borrow_mut().cache(def_id, id);\n+                let id = tcx.interpret_interner.reserve();\n+                tcx.interpret_interner.cache(def_id, id);\n                 id\n             },\n         };"}, {"sha": "e759407f43157bc01ddf5ef2eedd3beef6140436", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d26ebec81ce5d450f1bf3065ae990e6b1ca1c551/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d26ebec81ce5d450f1bf3065ae990e6b1ca1c551/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=d26ebec81ce5d450f1bf3065ae990e6b1ca1c551", "patch": "@@ -945,7 +945,6 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n             let cached = self\n                 .tcx\n                 .interpret_interner\n-                .borrow()\n                 .get_cached(gid.instance.def_id());\n             if let Some(alloc_id) = cached {\n                 let layout = self.layout_of(ty)?;"}, {"sha": "a22158c73345c52c74eb13a54c7601ab2bd6e583", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 11, "deletions": 14, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/d26ebec81ce5d450f1bf3065ae990e6b1ca1c551/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d26ebec81ce5d450f1bf3065ae990e6b1ca1c551/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=d26ebec81ce5d450f1bf3065ae990e6b1ca1c551", "patch": "@@ -75,7 +75,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n     }\n \n     pub fn create_fn_alloc(&mut self, instance: Instance<'tcx>) -> MemoryPointer {\n-        let id = self.tcx.interpret_interner.borrow_mut().create_fn_alloc(instance);\n+        let id = self.tcx.interpret_interner.create_fn_alloc(instance);\n         MemoryPointer::new(id, 0)\n     }\n \n@@ -107,7 +107,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n             align,\n             mutable: false,\n         };\n-        let id = self.tcx.interpret_interner.borrow_mut().reserve();\n+        let id = self.tcx.interpret_interner.reserve();\n         M::add_lock(self, id);\n         match kind {\n             Some(kind @ MemoryKind::Stack) |\n@@ -186,12 +186,12 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n                     \"uninitializedstatic\".to_string(),\n                     format!(\"{:?}\", kind),\n                 ))\n-            } else if self.tcx.interpret_interner.borrow().get_fn(ptr.alloc_id).is_some() {\n+            } else if self.tcx.interpret_interner.get_fn(ptr.alloc_id).is_some() {\n                 return err!(DeallocatedWrongMemoryKind(\n                     \"function\".to_string(),\n                     format!(\"{:?}\", kind),\n                 ))\n-            } else if self.tcx.interpret_interner.borrow().get_alloc(ptr.alloc_id).is_some() {\n+            } else if self.tcx.interpret_interner.get_alloc(ptr.alloc_id).is_some() {\n                 return err!(DeallocatedWrongMemoryKind(\n                     \"static\".to_string(),\n                     format!(\"{:?}\", kind),\n@@ -295,11 +295,10 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n             None => match self.uninitialized_statics.get(&id) {\n                 Some(alloc) => Ok(alloc),\n                 None => {\n-                    let int = self.tcx.interpret_interner.borrow();\n                     // static alloc?\n-                    int.get_alloc(id)\n+                    self.tcx.interpret_interner.get_alloc(id)\n                         // no alloc? produce an error\n-                        .ok_or_else(|| if int.get_fn(id).is_some() {\n+                        .ok_or_else(|| if self.tcx.interpret_interner.get_fn(id).is_some() {\n                             EvalErrorKind::DerefFunctionPointer.into()\n                         } else {\n                             EvalErrorKind::DanglingPointerDeref.into()\n@@ -320,11 +319,10 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n             None => match self.uninitialized_statics.get_mut(&id) {\n                 Some(alloc) => Ok(alloc),\n                 None => {\n-                    let int = self.tcx.interpret_interner.borrow();\n                     // no alloc or immutable alloc? produce an error\n-                    if int.get_alloc(id).is_some() {\n+                    if self.tcx.interpret_interner.get_alloc(id).is_some() {\n                         err!(ModifiedConstantMemory)\n-                    } else if int.get_fn(id).is_some() {\n+                    } else if self.tcx.interpret_interner.get_fn(id).is_some() {\n                         err!(DerefFunctionPointer)\n                     } else {\n                         err!(DanglingPointerDeref)\n@@ -341,7 +339,6 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         debug!(\"reading fn ptr: {}\", ptr.alloc_id);\n         self.tcx\n             .interpret_interner\n-            .borrow()\n             .get_fn(ptr.alloc_id)\n             .ok_or(EvalErrorKind::ExecuteMemory.into())\n     }\n@@ -376,9 +373,9 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n                         Some(a) => (a, \" (static in the process of initialization)\".to_owned()),\n                         None => {\n                             // static alloc?\n-                            match self.tcx.interpret_interner.borrow().get_alloc(id) {\n+                            match self.tcx.interpret_interner.get_alloc(id) {\n                                 Some(a) => (a, \"(immutable)\".to_owned()),\n-                                None => if let Some(func) = self.tcx.interpret_interner.borrow().get_fn(id) {\n+                                None => if let Some(func) = self.tcx.interpret_interner.get_fn(id) {\n                                     trace!(\"{} {}\", msg, func);\n                                     continue;\n                                 } else {\n@@ -549,7 +546,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n             // ensure llvm knows not to put this into immutable memroy\n             alloc.mutable = mutability == Mutability::Mutable;\n             let alloc = self.tcx.intern_const_alloc(alloc);\n-            self.tcx.interpret_interner.borrow_mut().intern_at_reserved(alloc_id, alloc);\n+            self.tcx.interpret_interner.intern_at_reserved(alloc_id, alloc);\n             // recurse into inner allocations\n             for &alloc in alloc.relocations.values() {\n                 self.mark_inner_allocation_initialized(alloc, mutability)?;"}, {"sha": "e82a252a95b3aff59703b957264ca658f5c00e0c", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d26ebec81ce5d450f1bf3065ae990e6b1ca1c551/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d26ebec81ce5d450f1bf3065ae990e6b1ca1c551/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=d26ebec81ce5d450f1bf3065ae990e6b1ca1c551", "patch": "@@ -197,7 +197,6 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 let alloc = self\n                     .tcx\n                     .interpret_interner\n-                    .borrow()\n                     .get_cached(static_.def_id);\n                 let layout = self.layout_of(self.place_ty(mir_place))?;\n                 if let Some(alloc) = alloc {"}, {"sha": "3d393b5696a3ab0379264afedacb7a7d59d63dfb", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d26ebec81ce5d450f1bf3065ae990e6b1ca1c551/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d26ebec81ce5d450f1bf3065ae990e6b1ca1c551/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=d26ebec81ce5d450f1bf3065ae990e6b1ca1c551", "patch": "@@ -1117,12 +1117,12 @@ fn collect_miri<'a, 'tcx>(\n     alloc_id: AllocId,\n     output: &mut Vec<MonoItem<'tcx>>,\n ) {\n-    if let Some(alloc) = tcx.interpret_interner.borrow().get_alloc(alloc_id) {\n+    if let Some(alloc) = tcx.interpret_interner.get_alloc(alloc_id) {\n         trace!(\"collecting {:?} with {:#?}\", alloc_id, alloc);\n         for &inner in alloc.relocations.values() {\n             collect_miri(tcx, inner, output);\n         }\n-    } else if let Some(fn_instance) = tcx.interpret_interner.borrow().get_fn(alloc_id) {\n+    } else if let Some(fn_instance) = tcx.interpret_interner.get_fn(alloc_id) {\n         if should_monomorphize_locally(tcx, &fn_instance) {\n             trace!(\"collecting {:?} with {:#?}\", alloc_id, fn_instance);\n             output.push(create_fn_mono_item(fn_instance));"}, {"sha": "1d04e30eb3e83cba5f415af018093e4da3a640e2", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d26ebec81ce5d450f1bf3065ae990e6b1ca1c551/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d26ebec81ce5d450f1bf3065ae990e6b1ca1c551/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=d26ebec81ce5d450f1bf3065ae990e6b1ca1c551", "patch": "@@ -151,18 +151,17 @@ pub fn primval_to_llvm(cx: &CodegenCx,\n             }\n         },\n         PrimVal::Ptr(ptr) => {\n-            if let Some(fn_instance) = cx.tcx.interpret_interner.borrow().get_fn(ptr.alloc_id) {\n+            if let Some(fn_instance) = cx.tcx.interpret_interner.get_fn(ptr.alloc_id) {\n                 callee::get_fn(cx, fn_instance)\n             } else {\n                 let static_ = cx\n                     .tcx\n                     .interpret_interner\n-                    .borrow()\n                     .get_corresponding_static_def_id(ptr.alloc_id);\n                 let base_addr = if let Some(def_id) = static_ {\n                     assert!(cx.tcx.is_static(def_id).is_some());\n                     consts::get_static(cx, def_id)\n-                } else if let Some(alloc) = cx.tcx.interpret_interner.borrow()\n+                } else if let Some(alloc) = cx.tcx.interpret_interner\n                                               .get_alloc(ptr.alloc_id) {\n                     let init = global_initializer(cx, alloc);\n                     if alloc.mutable {\n@@ -239,14 +238,12 @@ pub fn trans_static_initializer<'a, 'tcx>(\n     let alloc_id = cx\n         .tcx\n         .interpret_interner\n-        .borrow()\n         .get_cached(def_id)\n         .expect(\"global not cached\");\n \n     let alloc = cx\n         .tcx\n         .interpret_interner\n-        .borrow()\n         .get_alloc(alloc_id)\n         .expect(\"miri allocation never successfully created\");\n     Ok(global_initializer(cx, alloc))"}]}