{"sha": "3163071c75bff08e3ea1b4ed0928933415377ca4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMxNjMwNzFjNzViZmYwOGUzZWExYjRlZDA5Mjg5MzM0MTUzNzdjYTQ=", "commit": {"author": {"name": "Connor Brewster", "email": "brewsterc@my.caspercollege.edu", "date": "2016-03-12T18:09:27Z"}, "committer": {"name": "Connor Brewster", "email": "brewsterc@my.caspercollege.edu", "date": "2016-03-12T18:09:27Z"}, "message": "Updated to latest rustfmt", "tree": {"sha": "e66d5d11b271260dba34ac199dd0d76f2433bd9d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e66d5d11b271260dba34ac199dd0d76f2433bd9d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3163071c75bff08e3ea1b4ed0928933415377ca4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3163071c75bff08e3ea1b4ed0928933415377ca4", "html_url": "https://github.com/rust-lang/rust/commit/3163071c75bff08e3ea1b4ed0928933415377ca4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3163071c75bff08e3ea1b4ed0928933415377ca4/comments", "author": {"login": "cbrewster", "id": 9086315, "node_id": "MDQ6VXNlcjkwODYzMTU=", "avatar_url": "https://avatars.githubusercontent.com/u/9086315?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cbrewster", "html_url": "https://github.com/cbrewster", "followers_url": "https://api.github.com/users/cbrewster/followers", "following_url": "https://api.github.com/users/cbrewster/following{/other_user}", "gists_url": "https://api.github.com/users/cbrewster/gists{/gist_id}", "starred_url": "https://api.github.com/users/cbrewster/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cbrewster/subscriptions", "organizations_url": "https://api.github.com/users/cbrewster/orgs", "repos_url": "https://api.github.com/users/cbrewster/repos", "events_url": "https://api.github.com/users/cbrewster/events{/privacy}", "received_events_url": "https://api.github.com/users/cbrewster/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cbrewster", "id": 9086315, "node_id": "MDQ6VXNlcjkwODYzMTU=", "avatar_url": "https://avatars.githubusercontent.com/u/9086315?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cbrewster", "html_url": "https://github.com/cbrewster", "followers_url": "https://api.github.com/users/cbrewster/followers", "following_url": "https://api.github.com/users/cbrewster/following{/other_user}", "gists_url": "https://api.github.com/users/cbrewster/gists{/gist_id}", "starred_url": "https://api.github.com/users/cbrewster/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cbrewster/subscriptions", "organizations_url": "https://api.github.com/users/cbrewster/orgs", "repos_url": "https://api.github.com/users/cbrewster/repos", "events_url": "https://api.github.com/users/cbrewster/events{/privacy}", "received_events_url": "https://api.github.com/users/cbrewster/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "87a5d88aeb0cda9fcd82c8e24080ed85c85a465f", "url": "https://api.github.com/repos/rust-lang/rust/commits/87a5d88aeb0cda9fcd82c8e24080ed85c85a465f", "html_url": "https://github.com/rust-lang/rust/commit/87a5d88aeb0cda9fcd82c8e24080ed85c85a465f"}, {"sha": "3fddb9814988f8e83003351c803ae09cd945cf4c", "url": "https://api.github.com/repos/rust-lang/rust/commits/3fddb9814988f8e83003351c803ae09cd945cf4c", "html_url": "https://github.com/rust-lang/rust/commit/3fddb9814988f8e83003351c803ae09cd945cf4c"}], "stats": {"total": 2123, "additions": 1501, "deletions": 622}, "files": [{"sha": "09b805d72ac2b5be22a78621ac08b3424e15b8f6", "filename": ".gitignore", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3163071c75bff08e3ea1b4ed0928933415377ca4/.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/3163071c75bff08e3ea1b4ed0928933415377ca4/.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitignore?ref=3163071c75bff08e3ea1b4ed0928933415377ca4", "patch": "@@ -1 +1,2 @@\n-/target/\n\\ No newline at end of file\n+**/*.rs.bk\n+/target/"}, {"sha": "9ebeff7bb254926035df7968283cc353349f1387", "filename": "Cargo.lock", "status": "modified", "additions": 36, "deletions": 30, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/3163071c75bff08e3ea1b4ed0928933415377ca4/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/3163071c75bff08e3ea1b4ed0928933415377ca4/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=3163071c75bff08e3ea1b4ed0928933415377ca4", "patch": "@@ -1,26 +1,26 @@\n [root]\n name = \"rustfmt\"\n-version = \"0.2.1\"\n+version = \"0.3.0\"\n dependencies = [\n- \"diff 0.1.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"diff 0.1.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"env_logger 0.3.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"getopts 0.2.14 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"log 0.3.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"regex 0.1.43 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-serialize 0.3.16 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"log 0.3.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"regex 0.1.54 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-serialize 0.3.18 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"strings 0.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"syntex_syntax 0.23.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"syntex_syntax 0.29.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"term 0.2.14 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"toml 0.1.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"toml 0.1.27 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"unicode-segmentation 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"aho-corasick\"\n-version = \"0.4.0\"\n+version = \"0.5.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"memchr 0.1.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"memchr 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -30,16 +30,16 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"diff\"\n-version = \"0.1.8\"\n+version = \"0.1.9\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"env_logger\"\n version = \"0.3.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"log 0.3.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"regex 0.1.43 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"log 0.3.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"regex 0.1.54 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -58,62 +58,63 @@ dependencies = [\n \n [[package]]\n name = \"libc\"\n-version = \"0.2.2\"\n+version = \"0.2.7\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"log\"\n-version = \"0.3.4\"\n+version = \"0.3.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"libc 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"memchr\"\n-version = \"0.1.7\"\n+version = \"0.1.10\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"libc 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"regex\"\n-version = \"0.1.43\"\n+version = \"0.1.54\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"aho-corasick 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"memchr 0.1.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"regex-syntax 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"aho-corasick 0.5.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"memchr 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"regex-syntax 0.2.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"utf8-ranges 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"regex-syntax\"\n-version = \"0.2.2\"\n+version = \"0.2.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"rustc-serialize\"\n-version = \"0.3.16\"\n+version = \"0.3.18\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"strings\"\n version = \"0.0.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"log 0.3.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"log 0.3.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"syntex_syntax\"\n-version = \"0.23.0\"\n+version = \"0.29.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"bitflags 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"log 0.3.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-serialize 0.3.16 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"log 0.3.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-serialize 0.3.18 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"term 0.2.14 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"unicode-xid 0.0.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n@@ -129,10 +130,10 @@ dependencies = [\n \n [[package]]\n name = \"toml\"\n-version = \"0.1.24\"\n+version = \"0.1.27\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"rustc-serialize 0.3.16 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-serialize 0.3.18 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -145,6 +146,11 @@ name = \"unicode-xid\"\n version = \"0.0.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n+[[package]]\n+name = \"utf8-ranges\"\n+version = \"0.1.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n [[package]]\n name = \"winapi\"\n version = \"0.2.5\""}, {"sha": "49bd30a73cabf896c6a221f2ac78883eef5cb9c9", "filename": "Cargo.toml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3163071c75bff08e3ea1b4ed0928933415377ca4/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/3163071c75bff08e3ea1b4ed0928933415377ca4/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=3163071c75bff08e3ea1b4ed0928933415377ca4", "patch": "@@ -1,7 +1,7 @@\n [package]\n \n name = \"rustfmt\"\n-version = \"0.2.1\"\n+version = \"0.3.0\"\n authors = [\"Nicholas Cameron <ncameron@mozilla.com>\", \"Marcus Klaas <mail@marcusklaas.nl>\", \"The Rustfmt contributors\"]\n description = \"Tool to find and fix Rust formatting issues\"\n repository = \"https://github.com/rust-lang-nursery/rustfmt\"\n@@ -21,7 +21,7 @@ regex = \"0.1.41\"\n term = \"0.2.11\"\n strings = \"0.0.1\"\n diff = \"0.1.8\"\n-syntex_syntax = \"0.23.0\"\n+syntex_syntax = \"0.29.1\"\n log = \"0.3.2\"\n env_logger = \"0.3.1\"\n getopts = \"0.2\""}, {"sha": "7e2f00aebdfa9dc59f42251c6bc6c27ff36f5853", "filename": "Design.md", "status": "modified", "additions": 23, "deletions": 14, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/3163071c75bff08e3ea1b4ed0928933415377ca4/Design.md", "raw_url": "https://github.com/rust-lang/rust/raw/3163071c75bff08e3ea1b4ed0928933415377ca4/Design.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Design.md?ref=3163071c75bff08e3ea1b4ed0928933415377ca4", "patch": "@@ -134,25 +134,34 @@ not worthwhile due to uniformity being desirable, but it is a useful goal).\n \n ### Architecture details\n \n-We use the AST from libsyntax. We use libsyntax's visit module to walk the AST\n-to find starting points for reformatting. Eventually, we should reformat everything\n-and we shouldn't need the visit module. We keep track of the last formatted\n-position in the code, and when we reformat the next piece of code we make sure\n-to output the span for all the code in between (handled by missed_spans.rs).\n+We use the AST from [syntex_syntax], an export of rustc's libsyntax. We use\n+syntex_syntax's visit module to walk the AST to find starting points for\n+reformatting. Eventually, we should reformat everything and we shouldn't need\n+the visit module. We keep track of the last formatted position in the code, and\n+when we reformat the next piece of code we make sure to output the span for all\n+the code in between (handled by missed_spans.rs).\n+\n+[syntex_syntax]: https://crates.io/crates/syntex_syntax\n+\n+We read in formatting configuration from a `rustfmt.toml` file if there is one.\n+The options and their defaults are defined in `config.rs`. A `Config` object is\n+passed throughout the formatting code, and each formatting routine looks there\n+for its configuration.\n \n Our visitor keeps track of the desired current indent due to blocks (\n-`block_indent`). Each `visit_*` method reformats code according to this indent\n-and `IDEAL_WIDTH` and `MAX_WIDTH` (which should one day be supplied from a\n-config file). Most reformatting done in the `visit_*` methods is a bit hackey\n-and is meant to be temporary until it can be done properly.\n+`block_indent`). Each `visit_*` method reformats code according to this indent,\n+`config.ideal_width` and `config.max_width`. Most reformatting done in the\n+`visit_*` methods is a bit hackey and is meant to be temporary until it can be\n+done properly.\n \n There are a bunch of methods called `rewrite_*`. There do the bulk of the\n reformatting. These take the AST node to be reformatted (this may not literally\n-be an AST node from libsyntax, there might be multiple parameters describing a\n-logical node), the current indent, and the current width budget. They return a\n-`String` (or sometimes an `Option<String>`) which formats the code in the box\n-given by the indent and width budget. If the method fails, it returns `None` and\n-the calling method then has to fallback in some way to give the callee more space.\n+be an AST node from syntex_syntax: there might be multiple parameters\n+describing a logical node), the current indent, and the current width budget.\n+They return a `String` (or sometimes an `Option<String>`) which formats the\n+code in the box given by the indent and width budget. If the method fails, it\n+returns `None` and the calling method then has to fallback in some way to give\n+the callee more space.\n \n So, in summary to format a node, we calculate the width budget and then walk down\n the tree from the node. At a leaf, we generate an actual string and then unwind,"}, {"sha": "bf6585a8576e46f9bcd76d027e62066de05158f2", "filename": "README.md", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/3163071c75bff08e3ea1b4ed0928933415377ca4/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/3163071c75bff08e3ea1b4ed0928933415377ca4/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=3163071c75bff08e3ea1b4ed0928933415377ca4", "patch": "@@ -51,14 +51,17 @@ read data from stdin. Alternatively, you can use `cargo fmt` to format all\n binary and library targets of your crate.\n \n You'll probably want to specify the write mode. Currently, there are modes for\n-replace, overwrite, display, and coverage. The replace mode is the default\n-and overwrites the original files after renaming them. In overwrite mode,\n-rustfmt does not backup the source files. To print the output to stdout, use the\n-display mode. The write mode can be set by passing the `--write-mode` flag on\n-the command line.\n+diff, replace, overwrite, display, coverage, and checkstyle.\n \n-`rustfmt filename --write-mode=display` prints the output of rustfmt to the\n-screen, for example.\n+* `replace` Is the default and overwrites the original files after creating backups of the files.\n+* `overwrite` Overwrites the original files _without_ creating backups.\n+* `display` Will print the formatted files to stdout.\n+* `diff` Will print a diff between the original files and formatted files to stdout.\n+* `checkstyle` Will output the lines that need to be corrected as a checkstyle XML file,\n+  that can be used by tools like Jenkins.\n+\n+The write mode can be set by passing the `--write-mode` flag on\n+the command line. For example `rustfmt --write-mode=display src/filename.rs`\n \n You can run `rustfmt --help` for more information.\n \n@@ -75,8 +78,6 @@ You can run `rustfmt --help` for more information.\n \n ## How to build and test\n \n-First make sure you've got Rust **1.4.0** or greater available, then:\n-\n `cargo build` to build.\n \n `cargo test` to run all tests.\n@@ -85,12 +86,12 @@ To run rustfmt after this, use `cargo run --bin rustfmt -- filename`. See the\n notes above on running rustfmt.\n \n \n-## What style does Rustfmt use?\n+## Configuring Rustfmt\n \n Rustfmt is designed to be very configurable. You can create a TOML file called\n rustfmt.toml, place it in the project directory and it will apply the options\n-in that file. See `cargo run -- --config-help` for the options which are available,\n-or if you prefer to see source code, [src/config.rs].\n+in that file. See `rustfmt --config-help` for the options which are available,\n+or if you prefer to see source code, [src/config.rs](src/config.rs).\n \n By default, Rustfmt uses a style which (mostly) conforms to the\n [Rust style guidelines](https://github.com/rust-lang/rust/tree/master/src/doc/style)."}, {"sha": "1524384fc1286594f6a6f1851400f0a58465c7be", "filename": "src/bin/rustfmt.rs", "status": "modified", "additions": 136, "deletions": 54, "changes": 190, "blob_url": "https://github.com/rust-lang/rust/blob/3163071c75bff08e3ea1b4ed0928933415377ca4/src%2Fbin%2Frustfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3163071c75bff08e3ea1b4ed0928933415377ca4/src%2Fbin%2Frustfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Frustfmt.rs?ref=3163071c75bff08e3ea1b4ed0928933415377ca4", "patch": "@@ -17,69 +17,120 @@ extern crate toml;\n extern crate env_logger;\n extern crate getopts;\n \n-use rustfmt::{WriteMode, run, run_from_stdin};\n-use rustfmt::config::Config;\n+use rustfmt::{run, run_from_stdin};\n+use rustfmt::config::{Config, WriteMode};\n \n use std::env;\n use std::fs::{self, File};\n-use std::io::{self, Read, Write};\n+use std::io::{self, ErrorKind, Read, Write};\n use std::path::{Path, PathBuf};\n+use std::str::FromStr;\n \n use getopts::{Matches, Options};\n \n /// Rustfmt operations.\n enum Operation {\n     /// Format files and their child modules.\n-    Format(Vec<PathBuf>, WriteMode),\n+    Format {\n+        files: Vec<PathBuf>,\n+        config_path: Option<PathBuf>,\n+    },\n     /// Print the help message.\n     Help,\n     // Print version information\n     Version,\n     /// Print detailed configuration help.\n     ConfigHelp,\n-    /// Invalid program input, including reason.\n-    InvalidInput(String),\n+    /// Invalid program input.\n+    InvalidInput {\n+        reason: String,\n+    },\n     /// No file specified, read from stdin\n-    Stdin(String, WriteMode),\n+    Stdin {\n+        input: String,\n+        config_path: Option<PathBuf>,\n+    },\n }\n \n-/// Try to find a project file in the input file directory and its parents.\n-fn lookup_project_file(input_file: &Path) -> io::Result<PathBuf> {\n-    let mut current = if input_file.is_relative() {\n-        try!(env::current_dir()).join(input_file)\n+/// Try to find a project file in the given directory and its parents. Returns the path of a the\n+/// nearest project file if one exists, or `None` if no project file was found.\n+fn lookup_project_file(dir: &Path) -> io::Result<Option<PathBuf>> {\n+    let mut current = if dir.is_relative() {\n+        try!(env::current_dir()).join(dir)\n     } else {\n-        input_file.to_path_buf()\n+        dir.to_path_buf()\n     };\n \n-    // FIXME: We should canonize path to properly handle its parents,\n-    // but `canonicalize` function is unstable now (recently added API)\n-    // current = try!(fs::canonicalize(current));\n+    current = try!(fs::canonicalize(current));\n \n     loop {\n         let config_file = current.join(\"rustfmt.toml\");\n-        if fs::metadata(&config_file).is_ok() {\n-            return Ok(config_file);\n+        match fs::metadata(&config_file) {\n+            Ok(md) => {\n+                // Properly handle unlikely situation of a directory named `rustfmt.toml`.\n+                if md.is_file() {\n+                    return Ok(Some(config_file));\n+                }\n+            }\n+            // If it's not found, we continue searching; otherwise something went wrong and we\n+            // return the error.\n+            Err(e) => {\n+                if e.kind() != ErrorKind::NotFound {\n+                    return Err(e);\n+                }\n+            }\n         }\n \n         // If the current directory has no parent, we're done searching.\n         if !current.pop() {\n-            return Err(io::Error::new(io::ErrorKind::NotFound, \"Config not found\"));\n+            return Ok(None);\n         }\n     }\n }\n \n-/// Try to find a project file. If it's found, read it.\n-fn lookup_and_read_project_file(input_file: &Path) -> io::Result<(PathBuf, String)> {\n-    let path = try!(lookup_project_file(input_file));\n+/// Resolve the config for input in `dir`.\n+///\n+/// Returns the `Config` to use, and the path of the project file if there was\n+/// one.\n+fn resolve_config(dir: &Path) -> io::Result<(Config, Option<PathBuf>)> {\n+    let path = try!(lookup_project_file(dir));\n+    if path.is_none() {\n+        return Ok((Config::default(), None));\n+    }\n+    let path = path.unwrap();\n     let mut file = try!(File::open(&path));\n     let mut toml = String::new();\n     try!(file.read_to_string(&mut toml));\n-    Ok((path, toml))\n+    Ok((Config::from_toml(&toml), Some(path)))\n+}\n+\n+/// read the given config file path recursively if present else read the project file path\n+fn match_cli_path_or_file(config_path: Option<PathBuf>,\n+                          input_file: &Path)\n+                          -> io::Result<(Config, Option<PathBuf>)> {\n+\n+    if let Some(config_file) = config_path {\n+        let (toml, path) = try!(resolve_config(config_file.as_ref()));\n+        if path.is_some() {\n+            return Ok((toml, path));\n+        }\n+    }\n+    resolve_config(input_file)\n }\n \n-fn update_config(config: &mut Config, matches: &Matches) {\n+fn update_config(config: &mut Config, matches: &Matches) -> Result<(), String> {\n     config.verbose = matches.opt_present(\"verbose\");\n     config.skip_children = matches.opt_present(\"skip-children\");\n+\n+    let write_mode = matches.opt_str(\"write-mode\");\n+    match matches.opt_str(\"write-mode\").map(|wm| WriteMode::from_str(&wm)) {\n+        None => Ok(()),\n+        Some(Ok(write_mode)) => {\n+            config.write_mode = write_mode;\n+            Ok(())\n+        }\n+        Some(Err(_)) => Err(format!(\"Invalid write-mode: {}\", write_mode.expect(\"cannot happen\"))),\n+    }\n }\n \n fn execute() -> i32 {\n@@ -90,12 +141,17 @@ fn execute() -> i32 {\n     opts.optopt(\"\",\n                 \"write-mode\",\n                 \"mode to write in (not usable when piping from stdin)\",\n-                \"[replace|overwrite|display|diff|coverage]\");\n+                \"[replace|overwrite|display|diff|coverage|checkstyle]\");\n     opts.optflag(\"\", \"skip-children\", \"don't reformat child modules\");\n \n     opts.optflag(\"\",\n                  \"config-help\",\n                  \"show details of rustfmt configuration options\");\n+    opts.optopt(\"\",\n+                \"config-path\",\n+                \"Recursively searches the given path for the rustfmt.toml config file. If not \\\n+                 found reverts to the input file path\",\n+                \"[Path for the configuration file]\");\n \n     let matches = match opts.parse(env::args().skip(1)) {\n         Ok(m) => m,\n@@ -108,7 +164,7 @@ fn execute() -> i32 {\n     let operation = determine_operation(&matches);\n \n     match operation {\n-        Operation::InvalidInput(reason) => {\n+        Operation::InvalidInput { reason } => {\n             print_usage(&opts, &reason);\n             1\n         }\n@@ -124,30 +180,51 @@ fn execute() -> i32 {\n             Config::print_docs();\n             0\n         }\n-        Operation::Stdin(input, write_mode) => {\n+        Operation::Stdin { input, config_path } => {\n             // try to read config from local directory\n-            let config = match lookup_and_read_project_file(&Path::new(\".\")) {\n-                Ok((_, toml)) => Config::from_toml(&toml),\n-                Err(_) => Default::default(),\n-            };\n+            let (mut config, _) = match_cli_path_or_file(config_path, &env::current_dir().unwrap())\n+                                      .expect(\"Error resolving config\");\n+\n+            // write_mode is always Plain for Stdin.\n+            config.write_mode = WriteMode::Plain;\n \n-            run_from_stdin(input, write_mode, &config);\n+            run_from_stdin(input, &config);\n             0\n         }\n-        Operation::Format(files, write_mode) => {\n+        Operation::Format { files, config_path } => {\n+            let mut config = Config::default();\n+            let mut path = None;\n+            // Load the config path file if provided\n+            if let Some(config_file) = config_path {\n+                let (cfg_tmp, path_tmp) = resolve_config(config_file.as_ref())\n+                                              .expect(&format!(\"Error resolving config for {:?}\",\n+                                                               config_file));\n+                config = cfg_tmp;\n+                path = path_tmp;\n+            };\n+            if let Some(path) = path.as_ref() {\n+                println!(\"Using rustfmt config file {}\", path.display());\n+            }\n             for file in files {\n-                let mut config = match lookup_and_read_project_file(&file) {\n-                    Ok((path, toml)) => {\n+                // Check the file directory if the config-path could not be read or not provided\n+                if path.is_none() {\n+                    let (config_tmp, path_tmp) = resolve_config(file.parent().unwrap())\n+                                                     .expect(&format!(\"Error resolving config \\\n+                                                                       for {}\",\n+                                                                      file.display()));\n+                    if let Some(path) = path_tmp.as_ref() {\n                         println!(\"Using rustfmt config file {} for {}\",\n                                  path.display(),\n                                  file.display());\n-                        Config::from_toml(&toml)\n                     }\n-                    Err(_) => Default::default(),\n-                };\n-\n-                update_config(&mut config, &matches);\n-                run(&file, write_mode, &config);\n+                    config = config_tmp;\n+                }\n+\n+                if let Err(e) = update_config(&mut config, &matches) {\n+                    print_usage(&opts, &e);\n+                    return 1;\n+                }\n+                run(&file, &config);\n             }\n             0\n         }\n@@ -196,30 +273,35 @@ fn determine_operation(matches: &Matches) -> Operation {\n         return Operation::Version;\n     }\n \n+    // Read the config_path and convert to parent dir if a file is provided.\n+    let config_path: Option<PathBuf> = matches.opt_str(\"config-path\")\n+                                              .map(PathBuf::from)\n+                                              .and_then(|dir| {\n+                                                  if dir.is_file() {\n+                                                      return dir.parent().map(|v| v.into());\n+                                                  }\n+                                                  Some(dir)\n+                                              });\n+\n     // if no file argument is supplied, read from stdin\n     if matches.free.is_empty() {\n \n         let mut buffer = String::new();\n         match io::stdin().read_to_string(&mut buffer) {\n             Ok(..) => (),\n-            Err(e) => return Operation::InvalidInput(e.to_string()),\n+            Err(e) => return Operation::InvalidInput { reason: e.to_string() },\n         }\n \n-        // WriteMode is always plain for Stdin\n-        return Operation::Stdin(buffer, WriteMode::Plain);\n+        return Operation::Stdin {\n+            input: buffer,\n+            config_path: config_path,\n+        };\n     }\n \n-    let write_mode = match matches.opt_str(\"write-mode\") {\n-        Some(mode) => {\n-            match mode.parse() {\n-                Ok(mode) => mode,\n-                Err(..) => return Operation::InvalidInput(\"Unrecognized write mode\".into()),\n-            }\n-        }\n-        None => WriteMode::Replace,\n-    };\n-\n     let files: Vec<_> = matches.free.iter().map(PathBuf::from).collect();\n \n-    Operation::Format(files, write_mode)\n+    Operation::Format {\n+        files: files,\n+        config_path: config_path,\n+    }\n }"}, {"sha": "191b4a2ea4ca118b98abfe47adb0711e2b9c71db", "filename": "src/chains.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/3163071c75bff08e3ea1b4ed0928933415377ca4/src%2Fchains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3163071c75bff08e3ea1b4ed0928933415377ca4/src%2Fchains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fchains.rs?ref=3163071c75bff08e3ea1b4ed0928933415377ca4", "patch": "@@ -94,7 +94,7 @@ pub fn rewrite_chain(mut expr: &ast::Expr,\n \n     let fits_single_line = !veto_single_line &&\n                            match subexpr_list[0].node {\n-        ast::Expr_::ExprMethodCall(ref method_name, ref types, ref expressions)\n+        ast::ExprKind::MethodCall(ref method_name, ref types, ref expressions)\n             if context.config.chains_overflow_last => {\n             let len = rewrites.len();\n             let (init, last) = rewrites.split_at_mut(len - 1);\n@@ -150,28 +150,28 @@ pub fn rewrite_chain(mut expr: &ast::Expr,\n // parens, braces and brackets in its idiomatic formatting.\n fn is_block_expr(expr: &ast::Expr, repr: &str) -> bool {\n     match expr.node {\n-        ast::Expr_::ExprStruct(..) |\n-        ast::Expr_::ExprWhile(..) |\n-        ast::Expr_::ExprWhileLet(..) |\n-        ast::Expr_::ExprIf(..) |\n-        ast::Expr_::ExprIfLet(..) |\n-        ast::Expr_::ExprBlock(..) |\n-        ast::Expr_::ExprLoop(..) |\n-        ast::Expr_::ExprForLoop(..) |\n-        ast::Expr_::ExprMatch(..) => repr.contains('\\n'),\n-        ast::Expr_::ExprParen(ref expr) |\n-        ast::Expr_::ExprBinary(_, _, ref expr) |\n-        ast::Expr_::ExprIndex(_, ref expr) |\n-        ast::Expr_::ExprUnary(_, ref expr) => is_block_expr(expr, repr),\n+        ast::ExprKind::Struct(..) |\n+        ast::ExprKind::While(..) |\n+        ast::ExprKind::WhileLet(..) |\n+        ast::ExprKind::If(..) |\n+        ast::ExprKind::IfLet(..) |\n+        ast::ExprKind::Block(..) |\n+        ast::ExprKind::Loop(..) |\n+        ast::ExprKind::ForLoop(..) |\n+        ast::ExprKind::Match(..) => repr.contains('\\n'),\n+        ast::ExprKind::Paren(ref expr) |\n+        ast::ExprKind::Binary(_, _, ref expr) |\n+        ast::ExprKind::Index(_, ref expr) |\n+        ast::ExprKind::Unary(_, ref expr) => is_block_expr(expr, repr),\n         _ => false,\n     }\n }\n \n fn pop_expr_chain(expr: &ast::Expr) -> Option<&ast::Expr> {\n     match expr.node {\n-        ast::Expr_::ExprMethodCall(_, _, ref expressions) => Some(&expressions[0]),\n-        ast::Expr_::ExprTupField(ref subexpr, _) |\n-        ast::Expr_::ExprField(ref subexpr, _) => Some(subexpr),\n+        ast::ExprKind::MethodCall(_, _, ref expressions) => Some(&expressions[0]),\n+        ast::ExprKind::TupField(ref subexpr, _) |\n+        ast::ExprKind::Field(ref subexpr, _) => Some(subexpr),\n         _ => None,\n     }\n }\n@@ -183,7 +183,7 @@ fn rewrite_chain_expr(expr: &ast::Expr,\n                       offset: Indent)\n                       -> Option<String> {\n     match expr.node {\n-        ast::Expr_::ExprMethodCall(ref method_name, ref types, ref expressions) => {\n+        ast::ExprKind::MethodCall(ref method_name, ref types, ref expressions) => {\n             let inner = &RewriteContext { block_indent: offset, ..*context };\n             rewrite_method_call(method_name.node,\n                                 types,\n@@ -193,15 +193,15 @@ fn rewrite_chain_expr(expr: &ast::Expr,\n                                 width,\n                                 offset)\n         }\n-        ast::Expr_::ExprField(_, ref field) => {\n+        ast::ExprKind::Field(_, ref field) => {\n             let s = format!(\".{}\", field.node);\n             if s.len() <= width {\n                 Some(s)\n             } else {\n                 None\n             }\n         }\n-        ast::Expr_::ExprTupField(_, ref field) => {\n+        ast::ExprKind::TupField(_, ref field) => {\n             let s = format!(\".{}\", field.node);\n             if s.len() <= width {\n                 Some(s)\n@@ -216,7 +216,7 @@ fn rewrite_chain_expr(expr: &ast::Expr,\n // Determines we can continue formatting a given expression on the same line.\n fn is_continuable(expr: &ast::Expr) -> bool {\n     match expr.node {\n-        ast::Expr_::ExprPath(..) => true,\n+        ast::ExprKind::Path(..) => true,\n         _ => false,\n     }\n }"}, {"sha": "02e214864fad31cb52efe1a4edf28ecfa2da8027", "filename": "src/checkstyle.rs", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/3163071c75bff08e3ea1b4ed0928933415377ca4/src%2Fcheckstyle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3163071c75bff08e3ea1b4ed0928933415377ca4/src%2Fcheckstyle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcheckstyle.rs?ref=3163071c75bff08e3ea1b4ed0928933415377ca4", "patch": "@@ -0,0 +1,82 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+use rustfmt_diff::{Mismatch, DiffLine};\n+use std::io::{self, Write, Read};\n+use config::WriteMode;\n+\n+\n+pub fn output_header<T>(out: &mut T, mode: WriteMode) -> Result<(), io::Error>\n+    where T: Write\n+{\n+    if mode == WriteMode::Checkstyle {\n+        let mut xml_heading = String::new();\n+        xml_heading.push_str(\"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?>\");\n+        xml_heading.push_str(\"\\n\");\n+        xml_heading.push_str(\"<checkstyle version=\\\"4.3\\\">\");\n+        try!(write!(out, \"{}\", xml_heading));\n+    }\n+    Ok(())\n+}\n+\n+pub fn output_footer<T>(out: &mut T, mode: WriteMode) -> Result<(), io::Error>\n+    where T: Write\n+{\n+    if mode == WriteMode::Checkstyle {\n+        let mut xml_tail = String::new();\n+        xml_tail.push_str(\"</checkstyle>\");\n+        try!(write!(out, \"{}\", xml_tail));\n+    }\n+    Ok(())\n+}\n+\n+pub fn output_checkstyle_file<T>(mut writer: T,\n+                                 filename: &str,\n+                                 diff: Vec<Mismatch>)\n+                                 -> Result<(), io::Error>\n+    where T: Write\n+{\n+    try!(write!(writer, \"<file name=\\\"{}\\\">\", filename));\n+    for mismatch in diff {\n+        for line in mismatch.lines {\n+            match line {\n+                DiffLine::Expected(ref str) => {\n+                    let message = xml_escape_str(&str);\n+                    try!(write!(writer,\n+                                \"<error line=\\\"{}\\\" severity=\\\"warning\\\" message=\\\"Should be \\\n+                                 `{}`\\\" />\",\n+                                mismatch.line_number,\n+                                message));\n+                }\n+                _ => {\n+                    // Do nothing with context and expected.\n+                }\n+            }\n+        }\n+    }\n+    try!(write!(writer, \"</file>\"));\n+    Ok(())\n+}\n+\n+// Convert special characters into XML entities.\n+// This is needed for checkstyle output.\n+fn xml_escape_str(string: &str) -> String {\n+    let mut out = String::new();\n+    for c in string.chars() {\n+        match c {\n+            '<' => out.push_str(\"&lt;\"),\n+            '>' => out.push_str(\"&gt;\"),\n+            '\"' => out.push_str(\"&quot;\"),\n+            '\\'' => out.push_str(\"&apos;\"),\n+            '&' => out.push_str(\"&amp;\"),\n+            _ => out.push(c),\n+        }\n+    }\n+    out\n+}"}, {"sha": "448ab3b8d514fb6d2c3c0207710c09ead4850984", "filename": "src/config.rs", "status": "modified", "additions": 41, "deletions": 6, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/3163071c75bff08e3ea1b4ed0928933415377ca4/src%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3163071c75bff08e3ea1b4ed0928933415377ca4/src%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconfig.rs?ref=3163071c75bff08e3ea1b4ed0928933415377ca4", "patch": "@@ -73,6 +73,13 @@ configuration_option_enum! { Density:\n     CompressedIfEmpty,\n }\n \n+configuration_option_enum! { TypeDensity:\n+    // No spaces around \"=\" and \"+\"\n+    Compressed,\n+    // Spaces around \" = \" and \" + \"\n+    Wide,\n+}\n+\n impl Density {\n     pub fn to_list_tactic(self) -> ListTactic {\n         match self {\n@@ -113,6 +120,23 @@ configuration_option_enum! { ReportTactic:\n     Never,\n }\n \n+configuration_option_enum! { WriteMode:\n+    // Backsup the original file and overwrites the orignal.\n+    Replace,\n+    // Overwrites original file without backup.\n+    Overwrite,\n+    // Write the output to stdout.\n+    Display,\n+    // Write the diff to stdout.\n+    Diff,\n+    // Display how much of the input file was processed\n+    Coverage,\n+    // Unfancy stdout\n+    Plain,\n+    // Output a checkstyle XML file.\n+    Checkstyle,\n+}\n+\n // This trait and the following impl blocks are there so that we an use\n // UCFS inside the get_docs() function on types for configs.\n pub trait ConfigType {\n@@ -191,12 +215,12 @@ macro_rules! create_config {\n             }\n \n             pub fn from_toml(toml: &str) -> Config {\n-                let parsed = toml.parse().unwrap();\n+                let parsed = toml.parse().expect(\"Could not parse TOML\");\n                 let parsed_config:ParsedConfig = match toml::decode(parsed) {\n                     Some(decoded) => decoded,\n                     None => {\n                         println!(\"Decoding config file failed. Config:\\n{}\", toml);\n-                        let parsed: toml::Value = toml.parse().unwrap();\n+                        let parsed: toml::Value = toml.parse().expect(\"Could not parse TOML\");\n                         println!(\"\\n\\nParsed:\\n{:?}\", parsed);\n                         panic!();\n                     }\n@@ -208,10 +232,14 @@ macro_rules! create_config {\n                 match key {\n                     $(\n                         stringify!($i) => {\n-                            self.$i = val.parse::<$ty>().unwrap();\n+                            self.$i = val.parse::<$ty>()\n+                                .expect(&format!(\"Failed to parse override for {} (\\\"{}\\\") as a {}\",\n+                                                 stringify!($i),\n+                                                 val,\n+                                                 stringify!($ty)));\n                         }\n                     )+\n-                    _ => panic!(\"Bad config key!\")\n+                    _ => panic!(\"Unknown config key in override: {}\", key)\n                 }\n             }\n \n@@ -270,6 +298,7 @@ create_config! {\n     newline_style: NewlineStyle, NewlineStyle::Unix, \"Unix or Windows line endings\";\n     fn_brace_style: BraceStyle, BraceStyle::SameLineWhere, \"Brace style for functions\";\n     item_brace_style: BraceStyle, BraceStyle::SameLineWhere, \"Brace style for structs and enums\";\n+    impl_empty_single_line: bool, true, \"Put empty-body implementations on a single line\";\n     fn_empty_single_line: bool, true, \"Put empty-body functions on a single line\";\n     fn_single_line: bool, false, \"Put single-expression functions on a single line\";\n     fn_return_indent: ReturnIndent, ReturnIndent::WithArgs,\n@@ -278,6 +307,8 @@ create_config! {\n     fn_args_density: Density, Density::Tall, \"Argument density in functions\";\n     fn_args_layout: StructLitStyle, StructLitStyle::Visual, \"Layout of function arguments\";\n     fn_arg_indent: BlockIndentStyle, BlockIndentStyle::Visual, \"Indent on function arguments\";\n+    type_punctuation_density: TypeDensity, TypeDensity::Wide,\n+        \"Determines if '+' or '=' are wrapped in spaces in the punctuation of types\";\n     // Should we at least try to put the where clause on the same line as the rest of the\n     // function decl?\n     where_density: Density, Density::CompressedIfEmpty, \"Density of a where clause\";\n@@ -286,6 +317,7 @@ create_config! {\n     where_layout: ListTactic, ListTactic::Vertical, \"Element layout inside a where clause\";\n     where_pred_indent: BlockIndentStyle, BlockIndentStyle::Visual,\n         \"Indentation style of a where predicate\";\n+    where_trailing_comma: bool, false, \"Put a trailing comma on where clauses\";\n     generics_indent: BlockIndentStyle, BlockIndentStyle::Visual, \"Indentation of generics\";\n     struct_trailing_comma: SeparatorTactic, SeparatorTactic::Vertical,\n         \"If there is a trailing comma on structs\";\n@@ -295,15 +327,16 @@ create_config! {\n     struct_lit_multiline_style: MultilineStyle, MultilineStyle::PreferSingle,\n         \"Multiline style on literal structs\";\n     enum_trailing_comma: bool, true, \"Put a trailing comma on enum declarations\";\n-    report_todo: ReportTactic, ReportTactic::Always,\n+    report_todo: ReportTactic, ReportTactic::Never,\n         \"Report all, none or unnumbered occurrences of TODO in source file comments\";\n     report_fixme: ReportTactic, ReportTactic::Never,\n         \"Report all, none or unnumbered occurrences of FIXME in source file comments\";\n     chain_base_indent: BlockIndentStyle, BlockIndentStyle::Visual, \"Indent on chain base\";\n     chain_indent: BlockIndentStyle, BlockIndentStyle::Visual, \"Indentation of chain\";\n     reorder_imports: bool, false, \"Reorder import statements alphabetically\";\n     single_line_if_else: bool, false, \"Put else on same line as closing brace for if statements\";\n-    format_strings: bool, true, \"Format string literals, or leave as is\";\n+    format_strings: bool, true, \"Format string literals where necessary\";\n+    force_format_strings: bool, false, \"Always format string literals\";\n     chains_overflow_last: bool, true, \"Allow last call in method chain to break the line\";\n     take_source_hints: bool, true, \"Retain some formatting characteristics from the source code\";\n     hard_tabs: bool, false, \"Use tab characters for indentation, spaces for alignment\";\n@@ -313,4 +346,6 @@ create_config! {\n     match_block_trailing_comma: bool, false,\n         \"Put a trailing comma after a block based match arm (non-block arms are not affected)\";\n     match_wildcard_trailing_comma: bool, true, \"Put a trailing comma after a wildcard arm\";\n+    write_mode: WriteMode, WriteMode::Replace,\n+        \"What Write Mode to use when none is supplied: Replace, Overwrite, Display, Diff, Coverage\";\n }"}, {"sha": "6409ab8fdac47ab36ebde4fc44c3ee9aec857b02", "filename": "src/expr.rs", "status": "modified", "additions": 195, "deletions": 89, "changes": 284, "blob_url": "https://github.com/rust-lang/rust/blob/3163071c75bff08e3ea1b4ed0928933415377ca4/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3163071c75bff08e3ea1b4ed0928933415377ca4/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=3163071c75bff08e3ea1b4ed0928933415377ca4", "patch": "@@ -13,14 +13,15 @@ use std::borrow::Borrow;\n use std::mem::swap;\n use std::ops::Deref;\n use std::iter::ExactSizeIterator;\n+use std::fmt::Write;\n \n use {Indent, Spanned};\n use rewrite::{Rewrite, RewriteContext};\n use lists::{write_list, itemize_list, ListFormatting, SeparatorTactic, ListTactic,\n             DefinitiveListTactic, definitive_tactic, ListItem, format_fn_args};\n use string::{StringFormat, rewrite_string};\n-use utils::{span_after, extra_offset, last_line_width, wrap_str, binary_search, first_line_width,\n-            semicolon_for_stmt};\n+use utils::{span_after, span_before, extra_offset, last_line_width, wrap_str, binary_search,\n+            first_line_width, semicolon_for_stmt};\n use visitor::FmtVisitor;\n use config::{Config, StructLitStyle, MultilineStyle};\n use comment::{FindUncommented, rewrite_comment, contains_comment, recover_comment_removed};\n@@ -36,16 +37,16 @@ use syntax::visit::Visitor;\n impl Rewrite for ast::Expr {\n     fn rewrite(&self, context: &RewriteContext, width: usize, offset: Indent) -> Option<String> {\n         let result = match self.node {\n-            ast::Expr_::ExprVec(ref expr_vec) => {\n+            ast::ExprKind::Vec(ref expr_vec) => {\n                 rewrite_array(expr_vec.iter().map(|e| &**e),\n                               mk_sp(span_after(self.span, \"[\", context.codemap), self.span.hi),\n                               context,\n                               width,\n                               offset)\n             }\n-            ast::Expr_::ExprLit(ref l) => {\n+            ast::ExprKind::Lit(ref l) => {\n                 match l.node {\n-                    ast::Lit_::LitStr(_, ast::StrStyle::CookedStr) => {\n+                    ast::LitKind::Str(_, ast::StrStyle::Cooked) => {\n                         rewrite_string_lit(context, l.span, width, offset)\n                     }\n                     _ => {\n@@ -56,18 +57,18 @@ impl Rewrite for ast::Expr {\n                     }\n                 }\n             }\n-            ast::Expr_::ExprCall(ref callee, ref args) => {\n+            ast::ExprKind::Call(ref callee, ref args) => {\n                 let inner_span = mk_sp(callee.span.hi, self.span.hi);\n                 rewrite_call(context, &**callee, args, inner_span, width, offset)\n             }\n-            ast::Expr_::ExprParen(ref subexpr) => rewrite_paren(context, subexpr, width, offset),\n-            ast::Expr_::ExprBinary(ref op, ref lhs, ref rhs) => {\n+            ast::ExprKind::Paren(ref subexpr) => rewrite_paren(context, subexpr, width, offset),\n+            ast::ExprKind::Binary(ref op, ref lhs, ref rhs) => {\n                 rewrite_binary_op(context, op, lhs, rhs, width, offset)\n             }\n-            ast::Expr_::ExprUnary(ref op, ref subexpr) => {\n+            ast::ExprKind::Unary(ref op, ref subexpr) => {\n                 rewrite_unary_op(context, op, subexpr, width, offset)\n             }\n-            ast::Expr_::ExprStruct(ref path, ref fields, ref base) => {\n+            ast::ExprKind::Struct(ref path, ref fields, ref base) => {\n                 rewrite_struct_lit(context,\n                                    path,\n                                    fields,\n@@ -76,79 +77,81 @@ impl Rewrite for ast::Expr {\n                                    width,\n                                    offset)\n             }\n-            ast::Expr_::ExprTup(ref items) => {\n+            ast::ExprKind::Tup(ref items) => {\n                 rewrite_tuple(context,\n                               items.iter().map(|x| &**x),\n                               self.span,\n                               width,\n                               offset)\n             }\n-            ast::Expr_::ExprWhile(ref cond, ref block, label) => {\n+            ast::ExprKind::While(ref cond, ref block, label) => {\n                 Loop::new_while(None, cond, block, label).rewrite(context, width, offset)\n             }\n-            ast::Expr_::ExprWhileLet(ref pat, ref cond, ref block, label) => {\n+            ast::ExprKind::WhileLet(ref pat, ref cond, ref block, label) => {\n                 Loop::new_while(Some(pat), cond, block, label).rewrite(context, width, offset)\n             }\n-            ast::Expr_::ExprForLoop(ref pat, ref cond, ref block, label) => {\n+            ast::ExprKind::ForLoop(ref pat, ref cond, ref block, label) => {\n                 Loop::new_for(pat, cond, block, label).rewrite(context, width, offset)\n             }\n-            ast::Expr_::ExprLoop(ref block, label) => {\n+            ast::ExprKind::Loop(ref block, label) => {\n                 Loop::new_loop(block, label).rewrite(context, width, offset)\n             }\n-            ast::Expr_::ExprBlock(ref block) => block.rewrite(context, width, offset),\n-            ast::Expr_::ExprIf(ref cond, ref if_block, ref else_block) => {\n+            ast::ExprKind::Block(ref block) => block.rewrite(context, width, offset),\n+            ast::ExprKind::If(ref cond, ref if_block, ref else_block) => {\n                 rewrite_if_else(context,\n                                 cond,\n                                 if_block,\n                                 else_block.as_ref().map(|e| &**e),\n+                                self.span,\n                                 None,\n                                 width,\n                                 offset,\n                                 true)\n             }\n-            ast::Expr_::ExprIfLet(ref pat, ref cond, ref if_block, ref else_block) => {\n+            ast::ExprKind::IfLet(ref pat, ref cond, ref if_block, ref else_block) => {\n                 rewrite_if_else(context,\n                                 cond,\n                                 if_block,\n                                 else_block.as_ref().map(|e| &**e),\n+                                self.span,\n                                 Some(pat),\n                                 width,\n                                 offset,\n                                 true)\n             }\n-            ast::Expr_::ExprMatch(ref cond, ref arms) => {\n+            ast::ExprKind::Match(ref cond, ref arms) => {\n                 rewrite_match(context, cond, arms, width, offset, self.span)\n             }\n-            ast::Expr_::ExprPath(ref qself, ref path) => {\n+            ast::ExprKind::Path(ref qself, ref path) => {\n                 rewrite_path(context, true, qself.as_ref(), path, width, offset)\n             }\n-            ast::Expr_::ExprAssign(ref lhs, ref rhs) => {\n+            ast::ExprKind::Assign(ref lhs, ref rhs) => {\n                 rewrite_assignment(context, lhs, rhs, None, width, offset)\n             }\n-            ast::Expr_::ExprAssignOp(ref op, ref lhs, ref rhs) => {\n+            ast::ExprKind::AssignOp(ref op, ref lhs, ref rhs) => {\n                 rewrite_assignment(context, lhs, rhs, Some(op), width, offset)\n             }\n-            ast::Expr_::ExprAgain(ref opt_ident) => {\n+            ast::ExprKind::Again(ref opt_ident) => {\n                 let id_str = match *opt_ident {\n                     Some(ident) => format!(\" {}\", ident.node),\n                     None => String::new(),\n                 };\n                 Some(format!(\"continue{}\", id_str))\n             }\n-            ast::Expr_::ExprBreak(ref opt_ident) => {\n+            ast::ExprKind::Break(ref opt_ident) => {\n                 let id_str = match *opt_ident {\n                     Some(ident) => format!(\" {}\", ident.node),\n                     None => String::new(),\n                 };\n                 Some(format!(\"break{}\", id_str))\n             }\n-            ast::Expr_::ExprClosure(capture, ref fn_decl, ref body) => {\n+            ast::ExprKind::Closure(capture, ref fn_decl, ref body) => {\n                 rewrite_closure(capture, fn_decl, body, self.span, context, width, offset)\n             }\n-            ast::Expr_::ExprField(..) |\n-            ast::Expr_::ExprTupField(..) |\n-            ast::Expr_::ExprMethodCall(..) => rewrite_chain(self, context, width, offset),\n-            ast::Expr_::ExprMac(ref mac) => {\n+            ast::ExprKind::Field(..) |\n+            ast::ExprKind::TupField(..) |\n+            ast::ExprKind::MethodCall(..) => rewrite_chain(self, context, width, offset),\n+            ast::ExprKind::Mac(ref mac) => {\n                 // Failure to rewrite a marco should not imply failure to\n                 // rewrite the expression.\n                 rewrite_macro(mac, context, width, offset).or_else(|| {\n@@ -158,40 +161,43 @@ impl Rewrite for ast::Expr {\n                              offset)\n                 })\n             }\n-            ast::Expr_::ExprRet(None) => {\n+            ast::ExprKind::Ret(None) => {\n                 wrap_str(\"return\".to_owned(), context.config.max_width, width, offset)\n             }\n-            ast::Expr_::ExprRet(Some(ref expr)) => {\n+            ast::ExprKind::Ret(Some(ref expr)) => {\n                 rewrite_unary_prefix(context, \"return \", &**expr, width, offset)\n             }\n-            ast::Expr_::ExprBox(ref expr) => {\n+            ast::ExprKind::Box(ref expr) => {\n                 rewrite_unary_prefix(context, \"box \", &**expr, width, offset)\n             }\n-            ast::Expr_::ExprAddrOf(mutability, ref expr) => {\n+            ast::ExprKind::AddrOf(mutability, ref expr) => {\n                 rewrite_expr_addrof(context, mutability, expr, width, offset)\n             }\n-            ast::Expr_::ExprCast(ref expr, ref ty) => {\n+            ast::ExprKind::Cast(ref expr, ref ty) => {\n                 rewrite_pair(&**expr, &**ty, \"\", \" as \", \"\", context, width, offset)\n             }\n-            ast::Expr_::ExprIndex(ref expr, ref index) => {\n+            // TODO(#848): Handle type ascription; rust tracking issue\n+            //   https://github.com/rust-lang/rust/issues/23416\n+            ast::ExprKind::Type(_, _) => unimplemented!(),\n+            ast::ExprKind::Index(ref expr, ref index) => {\n                 rewrite_pair(&**expr, &**index, \"\", \"[\", \"]\", context, width, offset)\n             }\n-            ast::Expr_::ExprRepeat(ref expr, ref repeats) => {\n+            ast::ExprKind::Repeat(ref expr, ref repeats) => {\n                 rewrite_pair(&**expr, &**repeats, \"[\", \"; \", \"]\", context, width, offset)\n             }\n-            ast::Expr_::ExprRange(Some(ref lhs), Some(ref rhs)) => {\n+            ast::ExprKind::Range(Some(ref lhs), Some(ref rhs)) => {\n                 rewrite_pair(&**lhs, &**rhs, \"\", \"..\", \"\", context, width, offset)\n             }\n-            ast::Expr_::ExprRange(None, Some(ref rhs)) => {\n+            ast::ExprKind::Range(None, Some(ref rhs)) => {\n                 rewrite_unary_prefix(context, \"..\", &**rhs, width, offset)\n             }\n-            ast::Expr_::ExprRange(Some(ref lhs), None) => {\n+            ast::ExprKind::Range(Some(ref lhs), None) => {\n                 Some(format!(\"{}..\",\n                              try_opt!(lhs.rewrite(context,\n                                                   try_opt!(width.checked_sub(2)),\n                                                   offset))))\n             }\n-            ast::Expr_::ExprRange(None, None) => {\n+            ast::ExprKind::Range(None, None) => {\n                 if width >= 2 {\n                     Some(\"..\".into())\n                 } else {\n@@ -200,8 +206,8 @@ impl Rewrite for ast::Expr {\n             }\n             // We do not format these expressions yet, but they should still\n             // satisfy our width restrictions.\n-            ast::Expr_::ExprInPlace(..) |\n-            ast::Expr_::ExprInlineAsm(..) => {\n+            ast::ExprKind::InPlace(..) |\n+            ast::ExprKind::InlineAsm(..) => {\n                 wrap_str(context.snippet(self.span),\n                          context.config.max_width,\n                          width,\n@@ -299,15 +305,15 @@ pub fn rewrite_array<'a, I>(expr_iter: I,\n \n // This functions is pretty messy because of the wrapping and unwrapping of\n // expressions into and from blocks. See rust issue #27872.\n-fn rewrite_closure(capture: ast::CaptureClause,\n+fn rewrite_closure(capture: ast::CaptureBy,\n                    fn_decl: &ast::FnDecl,\n                    body: &ast::Block,\n                    span: Span,\n                    context: &RewriteContext,\n                    width: usize,\n                    offset: Indent)\n                    -> Option<String> {\n-    let mover = if capture == ast::CaptureClause::CaptureByValue {\n+    let mover = if capture == ast::CaptureBy::Value {\n         \"move \"\n     } else {\n         \"\"\n@@ -371,9 +377,8 @@ fn rewrite_closure(capture: ast::CaptureClause,\n         // All closure bodies are blocks in the eyes of the AST, but we may not\n         // want to unwrap them when they only contain a single expression.\n         let inner_expr = match expr.node {\n-            ast::Expr_::ExprBlock(ref inner) if inner.stmts.is_empty() && inner.expr.is_some() &&\n-                                                inner.rules ==\n-                                                ast::BlockCheckMode::DefaultBlock => {\n+            ast::ExprKind::Block(ref inner) if inner.stmts.is_empty() && inner.expr.is_some() &&\n+                                               inner.rules == ast::BlockCheckMode::Default => {\n                 inner.expr.as_ref().unwrap()\n             }\n             _ => expr,\n@@ -395,7 +400,7 @@ fn rewrite_closure(capture: ast::CaptureClause,\n     let body_rewrite = body.expr\n                            .as_ref()\n                            .and_then(|body_expr| {\n-                               if let ast::Expr_::ExprBlock(ref inner) = body_expr.node {\n+                               if let ast::ExprKind::Block(ref inner) = body_expr.node {\n                                    Some(inner.rewrite(&context, 2, Indent::empty()))\n                                } else {\n                                    None\n@@ -424,11 +429,11 @@ impl Rewrite for ast::Block {\n             return Some(user_str);\n         }\n \n-        let mut visitor = FmtVisitor::from_codemap(context.parse_session, context.config, None);\n+        let mut visitor = FmtVisitor::from_codemap(context.parse_session, context.config);\n         visitor.block_indent = context.block_indent;\n \n         let prefix = match self.rules {\n-            ast::BlockCheckMode::UnsafeBlock(..) => {\n+            ast::BlockCheckMode::Unsafe(..) => {\n                 let snippet = context.snippet(self.span);\n                 let open_pos = try_opt!(snippet.find_uncommented(\"{\"));\n                 visitor.last_pos = self.span.lo + BytePos(open_pos as u32);\n@@ -464,7 +469,7 @@ impl Rewrite for ast::Block {\n \n                 prefix\n             }\n-            ast::BlockCheckMode::DefaultBlock => {\n+            ast::BlockCheckMode::Default => {\n                 visitor.last_pos = self.span.lo;\n \n                 String::new()\n@@ -480,14 +485,14 @@ impl Rewrite for ast::Block {\n impl Rewrite for ast::Stmt {\n     fn rewrite(&self, context: &RewriteContext, _width: usize, offset: Indent) -> Option<String> {\n         let result = match self.node {\n-            ast::Stmt_::StmtDecl(ref decl, _) => {\n-                if let ast::Decl_::DeclLocal(ref local) = decl.node {\n+            ast::StmtKind::Decl(ref decl, _) => {\n+                if let ast::DeclKind::Local(ref local) = decl.node {\n                     local.rewrite(context, context.config.max_width, offset)\n                 } else {\n                     None\n                 }\n             }\n-            ast::Stmt_::StmtExpr(ref ex, _) | ast::Stmt_::StmtSemi(ref ex, _) => {\n+            ast::StmtKind::Expr(ref ex, _) | ast::StmtKind::Semi(ref ex, _) => {\n                 let suffix = if semicolon_for_stmt(self) {\n                     \";\"\n                 } else {\n@@ -499,7 +504,7 @@ impl Rewrite for ast::Stmt {\n                            offset)\n                   .map(|s| s + suffix)\n             }\n-            ast::Stmt_::StmtMac(..) => None,\n+            ast::StmtKind::Mac(..) => None,\n         };\n         result.and_then(|res| recover_comment_removed(res, self.span, context, _width, offset))\n     }\n@@ -605,12 +610,33 @@ fn rewrite_label(label: Option<ast::Ident>) -> String {\n     }\n }\n \n+fn extract_comment(span: Span,\n+                   context: &RewriteContext,\n+                   offset: Indent,\n+                   width: usize)\n+                   -> Option<String> {\n+    let comment_str = context.snippet(span);\n+    if contains_comment(&comment_str) {\n+        let comment = try_opt!(rewrite_comment(comment_str.trim(),\n+                                               false,\n+                                               width,\n+                                               offset,\n+                                               context.config));\n+        Some(format!(\"\\n{indent}{}\\n{indent}\",\n+                     comment,\n+                     indent = offset.to_string(context.config)))\n+    } else {\n+        None\n+    }\n+}\n+\n // Rewrites if-else blocks. If let Some(_) = pat, the expression is\n // treated as an if-let-else expression.\n fn rewrite_if_else(context: &RewriteContext,\n                    cond: &ast::Expr,\n                    if_block: &ast::Block,\n                    else_block_opt: Option<&ast::Expr>,\n+                   span: Span,\n                    pat: Option<&ast::Pat>,\n                    width: usize,\n                    offset: Indent,\n@@ -635,27 +661,45 @@ fn rewrite_if_else(context: &RewriteContext,\n     }\n \n     let if_block_string = try_opt!(if_block.rewrite(context, width, offset));\n-    let mut result = format!(\"if {} {}\", pat_expr_string, if_block_string);\n+\n+    let between_if_cond = mk_sp(span_after(span, \"if\", context.codemap),\n+                                pat.map_or(cond.span.lo,\n+                                           |_| span_before(span, \"let\", context.codemap)));\n+\n+    let between_if_cond_comment = extract_comment(between_if_cond, &context, offset, width);\n+\n+    let after_cond_comment = extract_comment(mk_sp(cond.span.hi, if_block.span.lo),\n+                                             context,\n+                                             offset,\n+                                             width);\n+\n+    let mut result = format!(\"if{}{}{}{}\",\n+                             between_if_cond_comment.as_ref().map_or(\" \", |str| &**str),\n+                             pat_expr_string,\n+                             after_cond_comment.as_ref().map_or(\" \", |str| &**str),\n+                             if_block_string);\n \n     if let Some(else_block) = else_block_opt {\n         let rewrite = match else_block.node {\n             // If the else expression is another if-else expression, prevent it\n             // from being formatted on a single line.\n-            ast::Expr_::ExprIfLet(ref pat, ref cond, ref if_block, ref else_block) => {\n+            ast::ExprKind::IfLet(ref pat, ref cond, ref if_block, ref next_else_block) => {\n                 rewrite_if_else(context,\n                                 cond,\n                                 if_block,\n-                                else_block.as_ref().map(|e| &**e),\n+                                next_else_block.as_ref().map(|e| &**e),\n+                                mk_sp(else_block.span.lo, span.hi),\n                                 Some(pat),\n                                 width,\n                                 offset,\n                                 false)\n             }\n-            ast::Expr_::ExprIf(ref cond, ref if_block, ref else_block) => {\n+            ast::ExprKind::If(ref cond, ref if_block, ref next_else_block) => {\n                 rewrite_if_else(context,\n                                 cond,\n                                 if_block,\n-                                else_block.as_ref().map(|e| &**e),\n+                                next_else_block.as_ref().map(|e| &**e),\n+                                mk_sp(else_block.span.lo, span.hi),\n                                 None,\n                                 width,\n                                 offset,\n@@ -664,7 +708,26 @@ fn rewrite_if_else(context: &RewriteContext,\n             _ => else_block.rewrite(context, width, offset),\n         };\n \n-        result.push_str(\" else \");\n+        let between_if_else_block = mk_sp(if_block.span.hi,\n+                                          span_before(mk_sp(if_block.span.hi, else_block.span.lo),\n+                                                      \"else\",\n+                                                      context.codemap));\n+        let between_if_else_block_comment = extract_comment(between_if_else_block,\n+                                                            &context,\n+                                                            offset,\n+                                                            width);\n+\n+        let after_else = mk_sp(span_after(mk_sp(if_block.span.hi, else_block.span.lo),\n+                                          \"else\",\n+                                          context.codemap),\n+                               else_block.span.lo);\n+        let after_else_comment = extract_comment(after_else, &context, offset, width);\n+\n+        try_opt!(write!(&mut result,\n+                        \"{}else{}\",\n+                        between_if_else_block_comment.as_ref().map_or(\" \", |str| &**str),\n+                        after_else_comment.as_ref().map_or(\" \", |str| &**str))\n+                     .ok());\n         result.push_str(&&try_opt!(rewrite));\n     }\n \n@@ -680,7 +743,7 @@ fn single_line_if_else(context: &RewriteContext,\n     let else_block = try_opt!(else_block_opt);\n     let fixed_cost = \"if  {  } else {  }\".len();\n \n-    if let ast::ExprBlock(ref else_node) = else_block.node {\n+    if let ast::ExprKind::Block(ref else_node) = else_block.node {\n         if !is_simple_block(if_node, context.codemap) ||\n            !is_simple_block(else_node, context.codemap) || pat_expr_str.contains('\\n') {\n             return None;\n@@ -733,7 +796,7 @@ pub fn is_empty_block(block: &ast::Block, codemap: &CodeMap) -> bool {\n }\n \n fn is_unsafe_block(block: &ast::Block) -> bool {\n-    if let ast::BlockCheckMode::UnsafeBlock(..) = block.rules {\n+    if let ast::BlockCheckMode::Unsafe(..) = block.rules {\n         true\n     } else {\n         false\n@@ -864,15 +927,15 @@ fn arm_end_pos(arm: &ast::Arm) -> BytePos {\n \n fn arm_comma(config: &Config, arm: &ast::Arm, body: &ast::Expr) -> &'static str {\n     if !config.match_wildcard_trailing_comma {\n-        if arm.pats.len() == 1 && arm.pats[0].node == ast::PatWild && arm.guard.is_none() {\n+        if arm.pats.len() == 1 && arm.pats[0].node == ast::PatKind::Wild && arm.guard.is_none() {\n             return \"\";\n         }\n     }\n \n     if config.match_block_trailing_comma {\n         \",\"\n-    } else if let ast::ExprBlock(ref block) = body.node {\n-        if let ast::DefaultBlock = block.rules {\n+    } else if let ast::ExprKind::Block(ref block) = body.node {\n+        if let ast::BlockCheckMode::Default = block.rules {\n             \"\"\n         } else {\n             \",\"\n@@ -893,9 +956,7 @@ impl Rewrite for ast::Arm {\n         let attr_str = if !attrs.is_empty() {\n             // We only use this visitor for the attributes, should we use it for\n             // more?\n-            let mut attr_visitor = FmtVisitor::from_codemap(context.parse_session,\n-                                                            context.config,\n-                                                            None);\n+            let mut attr_visitor = FmtVisitor::from_codemap(context.parse_session, context.config);\n             attr_visitor.block_indent = context.block_indent;\n             attr_visitor.last_pos = attrs[0].span.lo;\n             if attr_visitor.visit_attrs(attrs) {\n@@ -956,12 +1017,9 @@ impl Rewrite for ast::Arm {\n         }\n \n         let body = match **body {\n-            ast::Expr { node: ast::ExprBlock(ref block), .. } if !is_unsafe_block(block) &&\n-                                                                 is_simple_block(block,\n-                                                                                 context.codemap) &&\n-                                                                 context.config.wrap_match_arms => {\n-                block.expr.as_ref().map(|e| &**e).unwrap()\n-            }\n+            ast::Expr { node: ast::ExprKind::Block(ref block), .. }\n+                if !is_unsafe_block(block) && is_simple_block(block, context.codemap) &&\n+                context.config.wrap_match_arms => block.expr.as_ref().map(|e| &**e).unwrap(),\n             ref x => x,\n         };\n \n@@ -973,7 +1031,7 @@ impl Rewrite for ast::Arm {\n             let budget = context.config.max_width - line_start - comma.len() - 4;\n             let offset = Indent::new(offset.block_indent, line_start + 4 - offset.block_indent);\n             let rewrite = nop_block_collapse(body.rewrite(context, budget, offset), budget);\n-            let is_block = if let ast::ExprBlock(..) = body.node {\n+            let is_block = if let ast::ExprKind::Block(..) = body.node {\n                 true\n             } else {\n                 false\n@@ -1121,8 +1179,15 @@ fn rewrite_string_lit(context: &RewriteContext,\n                       width: usize,\n                       offset: Indent)\n                       -> Option<String> {\n-    if !context.config.format_strings {\n-        return Some(context.snippet(span));\n+    let string_lit = context.snippet(span);\n+\n+    if !context.config.format_strings && !context.config.force_format_strings {\n+        return Some(string_lit);\n+    }\n+\n+    if !context.config.force_format_strings &&\n+       !string_requires_rewrite(context, span, &string_lit, width, offset) {\n+        return Some(string_lit);\n     }\n \n     let fmt = StringFormat {\n@@ -1136,12 +1201,37 @@ fn rewrite_string_lit(context: &RewriteContext,\n         config: context.config,\n     };\n \n-    let string_lit = context.snippet(span);\n-    let str_lit = &string_lit[1..string_lit.len() - 1]; // Remove the quote characters.\n+    // Remove the quote characters.\n+    let str_lit = &string_lit[1..string_lit.len() - 1];\n \n     rewrite_string(str_lit, &fmt)\n }\n \n+fn string_requires_rewrite(context: &RewriteContext,\n+                           span: Span,\n+                           string: &str,\n+                           width: usize,\n+                           offset: Indent)\n+                           -> bool {\n+    if context.codemap.lookup_char_pos(span.lo).col.0 != offset.width() {\n+        return true;\n+    }\n+\n+    for (i, line) in string.lines().enumerate() {\n+        if i == 0 {\n+            if line.len() > width {\n+                return true;\n+            }\n+        } else {\n+            if line.len() > width + offset.width() {\n+                return true;\n+            }\n+        }\n+    }\n+\n+    false\n+}\n+\n pub fn rewrite_call<R>(context: &RewriteContext,\n                        callee: &R,\n                        args: &[ptr::P<ast::Expr>],\n@@ -1216,8 +1306,8 @@ fn rewrite_call_inner<R>(context: &RewriteContext,\n     // indentation. If its first line fits on one line with the other arguments,\n     // we format the function arguments horizontally.\n     let overflow_last = match args.last().map(|x| &x.node) {\n-        Some(&ast::Expr_::ExprClosure(..)) |\n-        Some(&ast::Expr_::ExprBlock(..)) if arg_count > 1 => true,\n+        Some(&ast::ExprKind::Closure(..)) |\n+        Some(&ast::ExprKind::Block(..)) if arg_count > 1 => true,\n         _ => false,\n     } && context.config.chains_overflow_last;\n \n@@ -1311,6 +1401,7 @@ fn rewrite_struct_lit<'a>(context: &RewriteContext,\n \n     // Foo { a: Foo } - indent is +3, width is -5.\n     let h_budget = width.checked_sub(path_str.len() + 5).unwrap_or(0);\n+    // The 1 taken from the v_budget is for the comma.\n     let (indent, v_budget) = match context.config.struct_lit_style {\n         StructLitStyle::Visual => (offset + path_str.len() + 3, h_budget),\n         StructLitStyle::Block => {\n@@ -1355,7 +1446,10 @@ fn rewrite_struct_lit<'a>(context: &RewriteContext,\n                              |item| {\n                                  match *item {\n                                      StructLitField::Regular(ref field) => {\n-                                         rewrite_field(inner_context, &field, v_budget, indent)\n+                                         rewrite_field(inner_context,\n+                                                       &field,\n+                                                       v_budget.checked_sub(1).unwrap_or(0),\n+                                                       indent)\n                                      }\n                                      StructLitField::Base(ref expr) => {\n                                          // 2 = ..\n@@ -1441,7 +1535,19 @@ fn rewrite_field(context: &RewriteContext,\n     let expr = field.expr.rewrite(context,\n                                   try_opt!(width.checked_sub(overhead)),\n                                   offset + overhead);\n-    expr.map(|s| format!(\"{}: {}\", name, s))\n+\n+    match expr {\n+        Some(e) => Some(format!(\"{}: {}\", name, e)),\n+        None => {\n+            let expr_offset = offset.block_indent(&context.config);\n+            let expr = field.expr.rewrite(context,\n+                                          try_opt!(context.config\n+                                                          .max_width\n+                                                          .checked_sub(expr_offset.width())),\n+                                          expr_offset);\n+            expr.map(|s| format!(\"{}:\\n{}{}\", name, expr_offset.to_string(&context.config), s))\n+        }\n+    }\n }\n \n pub fn rewrite_tuple<'a, I>(context: &RewriteContext,\n@@ -1559,9 +1665,9 @@ fn rewrite_unary_op(context: &RewriteContext,\n                     -> Option<String> {\n     // For some reason, an UnOp is not spanned like BinOp!\n     let operator_str = match *op {\n-        ast::UnOp::UnDeref => \"*\",\n-        ast::UnOp::UnNot => \"!\",\n-        ast::UnOp::UnNeg => \"-\",\n+        ast::UnOp::Deref => \"*\",\n+        ast::UnOp::Not => \"!\",\n+        ast::UnOp::Neg => \"-\",\n     };\n     rewrite_unary_prefix(context, operator_str, expr, width, offset)\n }\n@@ -1637,8 +1743,8 @@ fn rewrite_expr_addrof(context: &RewriteContext,\n                        offset: Indent)\n                        -> Option<String> {\n     let operator_str = match mutability {\n-        ast::Mutability::MutImmutable => \"&\",\n-        ast::Mutability::MutMutable => \"&mut \",\n+        ast::Mutability::Immutable => \"&\",\n+        ast::Mutability::Mutable => \"&mut \",\n     };\n     rewrite_unary_prefix(context, operator_str, expr, width, offset)\n }"}, {"sha": "f41915b8cff5f0074cab228ae4bb10c621f272e1", "filename": "src/filemap.rs", "status": "modified", "additions": 58, "deletions": 56, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/3163071c75bff08e3ea1b4ed0928933415377ca4/src%2Ffilemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3163071c75bff08e3ea1b4ed0928933415377ca4/src%2Ffilemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffilemap.rs?ref=3163071c75bff08e3ea1b4ed0928933415377ca4", "patch": "@@ -15,11 +15,11 @@ use strings::string_buffer::StringBuffer;\n \n use std::collections::HashMap;\n use std::fs::{self, File};\n-use std::io::{self, Write, Read, stdout};\n+use std::io::{self, Write, Read, stdout, BufWriter};\n \n-use WriteMode;\n-use config::{NewlineStyle, Config};\n-use rustfmt_diff::{make_diff, print_diff};\n+use config::{NewlineStyle, Config, WriteMode};\n+use rustfmt_diff::{make_diff, print_diff, Mismatch};\n+use checkstyle::{output_header, output_footer, output_checkstyle_file};\n \n // A map of the files of a crate, with their new content\n pub type FileMap = HashMap<String, StringBuffer>;\n@@ -31,59 +31,62 @@ pub fn append_newlines(file_map: &mut FileMap) {\n     }\n }\n \n-pub fn write_all_files(file_map: &FileMap,\n-                       mode: WriteMode,\n-                       config: &Config)\n-                       -> Result<(HashMap<String, String>), io::Error> {\n-    let mut result = HashMap::new();\n+pub fn write_all_files<T>(file_map: &FileMap, mut out: T, config: &Config) -> Result<(), io::Error>\n+    where T: Write\n+{\n+    output_header(&mut out, config.write_mode).ok();\n     for filename in file_map.keys() {\n-        let one_result = try!(write_file(&file_map[filename], filename, mode, config));\n-        if let Some(r) = one_result {\n-            result.insert(filename.clone(), r);\n-        }\n+        try!(write_file(&file_map[filename], filename, &mut out, config));\n     }\n+    output_footer(&mut out, config.write_mode).ok();\n \n-    Ok(result)\n+    Ok(())\n }\n \n-pub fn write_file(text: &StringBuffer,\n-                  filename: &str,\n-                  mode: WriteMode,\n-                  config: &Config)\n-                  -> Result<Option<String>, io::Error> {\n \n-    // prints all newlines either as `\\n` or as `\\r\\n`\n-    fn write_system_newlines<T>(mut writer: T,\n+// Prints all newlines either as `\\n` or as `\\r\\n`.\n+pub fn write_system_newlines<T>(writer: T,\n                                 text: &StringBuffer,\n                                 config: &Config)\n                                 -> Result<(), io::Error>\n-        where T: Write\n-    {\n-        let style = if config.newline_style == NewlineStyle::Native {\n-            if cfg!(windows) {\n-                NewlineStyle::Windows\n-            } else {\n-                NewlineStyle::Unix\n-            }\n+    where T: Write\n+{\n+    // Buffer output, since we're writing a since char at a time.\n+    let mut writer = BufWriter::new(writer);\n+\n+    let style = if config.newline_style == NewlineStyle::Native {\n+        if cfg!(windows) {\n+            NewlineStyle::Windows\n         } else {\n-            config.newline_style\n-        };\n-\n-        match style {\n-            NewlineStyle::Unix => write!(writer, \"{}\", text),\n-            NewlineStyle::Windows => {\n-                for (c, _) in text.chars() {\n-                    match c {\n-                        '\\n' => try!(write!(writer, \"\\r\\n\")),\n-                        '\\r' => continue,\n-                        c => try!(write!(writer, \"{}\", c)),\n-                    }\n+            NewlineStyle::Unix\n+        }\n+    } else {\n+        config.newline_style\n+    };\n+\n+    match style {\n+        NewlineStyle::Unix => write!(writer, \"{}\", text),\n+        NewlineStyle::Windows => {\n+            for (c, _) in text.chars() {\n+                match c {\n+                    '\\n' => try!(write!(writer, \"\\r\\n\")),\n+                    '\\r' => continue,\n+                    c => try!(write!(writer, \"{}\", c)),\n                 }\n-                Ok(())\n             }\n-            NewlineStyle::Native => unreachable!(),\n+            Ok(())\n         }\n+        NewlineStyle::Native => unreachable!(),\n     }\n+}\n+\n+pub fn write_file<T>(text: &StringBuffer,\n+                     filename: &str,\n+                     out: &mut T,\n+                     config: &Config)\n+                     -> Result<Option<String>, io::Error>\n+    where T: Write\n+{\n \n     fn source_and_formatted_text(text: &StringBuffer,\n                                  filename: &str,\n@@ -98,7 +101,15 @@ pub fn write_file(text: &StringBuffer,\n         Ok((ori_text, fmt_text))\n     }\n \n-    match mode {\n+    fn create_diff(filename: &str,\n+                   text: &StringBuffer,\n+                   config: &Config)\n+                   -> Result<Vec<Mismatch>, io::Error> {\n+        let (ori, fmt) = try!(source_and_formatted_text(text, filename, config));\n+        Ok(make_diff(&ori, &fmt, 3))\n+    }\n+\n+    match config.write_mode {\n         WriteMode::Replace => {\n             if let Ok((ori, fmt)) = source_and_formatted_text(text, filename, config) {\n                 if fmt != ori {\n@@ -123,11 +134,6 @@ pub fn write_file(text: &StringBuffer,\n             let file = try!(File::create(filename));\n             try!(write_system_newlines(file, text, config));\n         }\n-        WriteMode::NewFile(extn) => {\n-            let filename = filename.to_owned() + \".\" + extn;\n-            let file = try!(File::create(&filename));\n-            try!(write_system_newlines(file, text, config));\n-        }\n         WriteMode::Plain => {\n             let stdout = stdout();\n             let stdout = stdout.lock();\n@@ -146,13 +152,9 @@ pub fn write_file(text: &StringBuffer,\n                            |line_num| format!(\"\\nDiff at line {}:\", line_num));\n             }\n         }\n-        WriteMode::Return => {\n-            // io::Write is not implemented for String, working around with\n-            // Vec<u8>\n-            let mut v = Vec::new();\n-            try!(write_system_newlines(&mut v, text, config));\n-            // won't panic, we are writing correct utf8\n-            return Ok(Some(String::from_utf8(v).unwrap()));\n+        WriteMode::Checkstyle => {\n+            let diff = try!(create_diff(filename, text, config));\n+            try!(output_checkstyle_file(out, filename, diff));\n         }\n     }\n "}, {"sha": "38720d84cce52204a8b88239483e27f446bf1b2b", "filename": "src/imports.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3163071c75bff08e3ea1b4ed0928933415377ca4/src%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3163071c75bff08e3ea1b4ed0928933415377ca4/src%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fimports.rs?ref=3163071c75bff08e3ea1b4ed0928933415377ca4", "patch": "@@ -51,7 +51,7 @@ impl Rewrite for ast::ViewPath {\n }\n \n fn rewrite_single_use_list(path_str: String, vpi: &ast::PathListItem) -> String {\n-    let path_item_str = if let ast::PathListItem_::PathListIdent{ name, .. } = vpi.node {\n+    let path_item_str = if let ast::PathListItemKind::Ident { name, .. } = vpi.node {\n         // A name.\n         if path_str.is_empty() {\n             name.to_string()\n@@ -74,17 +74,17 @@ fn rewrite_single_use_list(path_str: String, vpi: &ast::PathListItem) -> String\n \n fn rewrite_path_item(vpi: &&ast::PathListItem) -> Option<String> {\n     let path_item_str = match vpi.node {\n-        ast::PathListItem_::PathListIdent{ name, .. } => name.to_string(),\n-        ast::PathListItem_::PathListMod{ .. } => \"self\".to_owned(),\n+        ast::PathListItemKind::Ident { name, .. } => name.to_string(),\n+        ast::PathListItemKind::Mod { .. } => \"self\".to_owned(),\n     };\n \n     Some(append_alias(path_item_str, vpi))\n }\n \n fn append_alias(path_item_str: String, vpi: &ast::PathListItem) -> String {\n     match vpi.node {\n-        ast::PathListItem_::PathListIdent{ rename: Some(rename), .. } |\n-        ast::PathListItem_::PathListMod{ rename: Some(rename), .. } => {\n+        ast::PathListItemKind::Ident { rename: Some(rename), .. } |\n+        ast::PathListItemKind::Mod { rename: Some(rename), .. } => {\n             format!(\"{} as {}\", path_item_str, rename)\n         }\n         _ => path_item_str,"}, {"sha": "40b09fdfca5bd2f6089970d949498b224fd51c6a", "filename": "src/issues.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3163071c75bff08e3ea1b4ed0928933415377ca4/src%2Fissues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3163071c75bff08e3ea1b4ed0928933415377ca4/src%2Fissues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fissues.rs?ref=3163071c75bff08e3ea1b4ed0928933415377ca4", "patch": "@@ -15,8 +15,8 @@\n use std::fmt;\n pub use config::ReportTactic;\n \n-static TO_DO_CHARS: &'static [char] = &['T', 'O', 'D', 'O'];\n-static FIX_ME_CHARS: &'static [char] = &['F', 'I', 'X', 'M', 'E'];\n+const TO_DO_CHARS: &'static [char] = &['T', 'O', 'D', 'O'];\n+const FIX_ME_CHARS: &'static [char] = &['F', 'I', 'X', 'M', 'E'];\n \n // Enabled implementation detail is here because it is\n // irrelevant outside the issues module"}, {"sha": "550a66132417c21d79563b9d588cab91e67be76c", "filename": "src/items.rs", "status": "modified", "additions": 83, "deletions": 33, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/3163071c75bff08e3ea1b4ed0928933415377ca4/src%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3163071c75bff08e3ea1b4ed0928933415377ca4/src%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fitems.rs?ref=3163071c75bff08e3ea1b4ed0928933415377ca4", "patch": "@@ -21,10 +21,12 @@ use comment::{FindUncommented, contains_comment};\n use visitor::FmtVisitor;\n use rewrite::{Rewrite, RewriteContext};\n use config::{Config, BlockIndentStyle, Density, ReturnIndent, BraceStyle, StructLitStyle};\n+use syntax::codemap;\n \n use syntax::{ast, abi};\n use syntax::codemap::{Span, BytePos, mk_sp};\n use syntax::parse::token;\n+use syntax::ast::ImplItem;\n \n // Statements of the form\n // let pat: ty = init;\n@@ -107,7 +109,7 @@ impl<'a> FmtVisitor<'a> {\n         let span = mk_sp(item.span.lo, item.span.hi - BytePos(1));\n \n         match item.node {\n-            ast::ForeignItem_::ForeignItemFn(ref fn_decl, ref generics) => {\n+            ast::ForeignItemKind::Fn(ref fn_decl, ref generics) => {\n                 let indent = self.block_indent;\n                 let rewrite = rewrite_fn_base(&self.get_context(),\n                                               indent,\n@@ -133,7 +135,7 @@ impl<'a> FmtVisitor<'a> {\n                     None => self.format_missing(item.span.hi),\n                 }\n             }\n-            ast::ForeignItem_::ForeignItemStatic(ref ty, is_mutable) => {\n+            ast::ForeignItemKind::Static(ref ty, is_mutable) => {\n                 // FIXME(#21): we're dropping potential comments in between the\n                 // function keywords here.\n                 let mut_str = if is_mutable {\n@@ -180,6 +182,10 @@ impl<'a> FmtVisitor<'a> {\n         let mut newline_brace = newline_for_brace(self.config, &generics.where_clause);\n         let context = self.get_context();\n \n+        let block_snippet = self.snippet(codemap::mk_sp(block.span.lo, block.span.hi));\n+        let has_body = !block_snippet[1..block_snippet.len() - 1].trim().is_empty() ||\n+                       !context.config.fn_empty_single_line;\n+\n         let (mut result, force_newline_brace) = try_opt!(rewrite_fn_base(&context,\n                                                                          indent,\n                                                                          ident,\n@@ -192,7 +198,7 @@ impl<'a> FmtVisitor<'a> {\n                                                                          vis,\n                                                                          span,\n                                                                          newline_brace,\n-                                                                         true));\n+                                                                         has_body));\n \n         if self.config.fn_brace_style != BraceStyle::AlwaysNextLine && !result.contains('\\n') {\n             newline_brace = false;\n@@ -434,12 +440,12 @@ impl<'a> FmtVisitor<'a> {\n }\n \n pub fn format_impl(context: &RewriteContext, item: &ast::Item, offset: Indent) -> Option<String> {\n-    if let ast::Item_::ItemImpl(unsafety,\n-                                polarity,\n-                                ref generics,\n-                                ref trait_ref,\n-                                ref self_ty,\n-                                ref items) = item.node {\n+    if let ast::ItemKind::Impl(unsafety,\n+                               polarity,\n+                               ref generics,\n+                               ref trait_ref,\n+                               ref self_ty,\n+                               ref items) = item.node {\n         let mut result = String::new();\n         result.push_str(format_visibility(item.vis));\n         result.push_str(format_unsafety(unsafety));\n@@ -484,9 +490,20 @@ pub fn format_impl(context: &RewriteContext, item: &ast::Item, offset: Indent) -\n                                                              where_budget,\n                                                              context.config.where_density,\n                                                              \"{\",\n+                                                             true,\n                                                              None));\n-        if !where_clause_str.contains('\\n') &&\n-           result.len() + where_clause_str.len() + offset.width() > context.config.max_width {\n+\n+        if try_opt!(is_impl_single_line(context, &items, &result, &where_clause_str, &item)) {\n+            result.push_str(&where_clause_str);\n+            if where_clause_str.contains('\\n') {\n+                result.push_str(\"\\n{\\n}\");\n+            } else {\n+                result.push_str(\" {}\");\n+            }\n+            return Some(result);\n+        }\n+\n+        if !where_clause_str.is_empty() && !where_clause_str.contains('\\n') {\n             result.push('\\n');\n             let width = context.block_indent.width() + context.config.tab_spaces - 1;\n             let where_indent = Indent::new(0, width);\n@@ -505,13 +522,14 @@ pub fn format_impl(context: &RewriteContext, item: &ast::Item, offset: Indent) -\n                 }\n             }\n         }\n+\n         result.push('{');\n \n         let snippet = context.snippet(item.span);\n         let open_pos = try_opt!(snippet.find_uncommented(\"{\")) + 1;\n \n         if !items.is_empty() || contains_comment(&snippet[open_pos..]) {\n-            let mut visitor = FmtVisitor::from_codemap(context.parse_session, context.config, None);\n+            let mut visitor = FmtVisitor::from_codemap(context.parse_session, context.config);\n             visitor.block_indent = context.block_indent.block_indent(context.config);\n             visitor.last_pos = item.span.lo + BytePos(open_pos as u32);\n \n@@ -531,13 +549,31 @@ pub fn format_impl(context: &RewriteContext, item: &ast::Item, offset: Indent) -\n             result.push_str(&outer_indent_str);\n         }\n \n+        if result.chars().last().unwrap() == '{' {\n+            result.push('\\n');\n+        }\n         result.push('}');\n+\n         Some(result)\n     } else {\n         unreachable!();\n     }\n }\n \n+fn is_impl_single_line(context: &RewriteContext,\n+                       items: &Vec<ImplItem>,\n+                       result: &str,\n+                       where_clause_str: &str,\n+                       item: &ast::Item)\n+                       -> Option<bool> {\n+    let snippet = context.snippet(item.span);\n+    let open_pos = try_opt!(snippet.find_uncommented(\"{\")) + 1;\n+\n+    Some(context.config.impl_empty_single_line && items.is_empty() &&\n+         result.len() + where_clause_str.len() <= context.config.max_width &&\n+         !contains_comment(&snippet[open_pos..]))\n+}\n+\n pub fn format_struct(context: &RewriteContext,\n                      item_name: &str,\n                      ident: ast::Ident,\n@@ -573,7 +609,7 @@ pub fn format_struct(context: &RewriteContext,\n }\n \n pub fn format_trait(context: &RewriteContext, item: &ast::Item, offset: Indent) -> Option<String> {\n-    if let ast::Item_::ItemTrait(unsafety, ref generics, ref type_param_bounds, ref trait_items) =\n+    if let ast::ItemKind::Trait(unsafety, ref generics, ref type_param_bounds, ref trait_items) =\n            item.node {\n         let mut result = String::new();\n         let header = format!(\"{}{}trait {}\",\n@@ -619,6 +655,7 @@ pub fn format_trait(context: &RewriteContext, item: &ast::Item, offset: Indent)\n                                                              where_budget,\n                                                              context.config.where_density,\n                                                              \"{\",\n+                                                             context.config.where_trailing_comma,\n                                                              None));\n         if !where_clause_str.contains('\\n') &&\n            result.len() + where_clause_str.len() + offset.width() > context.config.max_width {\n@@ -650,7 +687,7 @@ pub fn format_trait(context: &RewriteContext, item: &ast::Item, offset: Indent)\n         let open_pos = try_opt!(snippet.find_uncommented(\"{\")) + 1;\n \n         if !trait_items.is_empty() || contains_comment(&snippet[open_pos..]) {\n-            let mut visitor = FmtVisitor::from_codemap(context.parse_session, context.config, None);\n+            let mut visitor = FmtVisitor::from_codemap(context.parse_session, context.config);\n             visitor.block_indent = context.block_indent.block_indent(context.config);\n             visitor.last_pos = item.span.lo + BytePos(open_pos as u32);\n \n@@ -732,7 +769,7 @@ fn format_struct_struct(context: &RewriteContext,\n     }\n \n     let item_indent = offset.block_indent(context.config);\n-    // 2 = \",\"\n+    // 1 = \",\"\n     let item_budget = try_opt!(context.config.max_width.checked_sub(item_indent.width() + 1));\n \n     let items = itemize_list(context.codemap,\n@@ -806,6 +843,7 @@ fn format_tuple_struct(context: &RewriteContext,\n                                           where_budget,\n                                           Density::Compressed,\n                                           \";\",\n+                                          false,\n                                           None))\n         }\n         None => \"\".to_owned(),\n@@ -887,6 +925,7 @@ pub fn rewrite_type_alias(context: &RewriteContext,\n                                                          where_budget,\n                                                          context.config.where_density,\n                                                          \"=\",\n+                                                         false,\n                                                          Some(span.hi)));\n     result.push_str(&where_clause_str);\n     result.push_str(\" = \");\n@@ -985,15 +1024,15 @@ pub fn rewrite_static(prefix: &str,\n impl Rewrite for ast::FunctionRetTy {\n     fn rewrite(&self, context: &RewriteContext, width: usize, offset: Indent) -> Option<String> {\n         match *self {\n-            ast::FunctionRetTy::DefaultReturn(_) => Some(String::new()),\n-            ast::FunctionRetTy::NoReturn(_) => {\n+            ast::FunctionRetTy::Default(_) => Some(String::new()),\n+            ast::FunctionRetTy::None(_) => {\n                 if width >= 4 {\n                     Some(\"-> !\".to_owned())\n                 } else {\n                     None\n                 }\n             }\n-            ast::FunctionRetTy::Return(ref ty) => {\n+            ast::FunctionRetTy::Ty(ref ty) => {\n                 let inner_width = try_opt!(width.checked_sub(3));\n                 ty.rewrite(context, inner_width, offset + 3).map(|r| format!(\"-> {}\", r))\n             }\n@@ -1006,7 +1045,7 @@ impl Rewrite for ast::Arg {\n         if is_named_arg(self) {\n             let mut result = try_opt!(self.pat.rewrite(context, width, offset));\n \n-            if self.ty.node != ast::Ty_::TyInfer {\n+            if self.ty.node != ast::TyKind::Infer {\n                 result.push_str(\": \");\n                 let max_width = try_opt!(width.checked_sub(result.len()));\n                 let ty_str = try_opt!(self.ty.rewrite(context, max_width, offset + result.len()));\n@@ -1025,7 +1064,7 @@ fn rewrite_explicit_self(explicit_self: &ast::ExplicitSelf,\n                          context: &RewriteContext)\n                          -> Option<String> {\n     match explicit_self.node {\n-        ast::ExplicitSelf_::SelfRegion(lt, m, _) => {\n+        ast::SelfKind::Region(lt, m, _) => {\n             let mut_str = format_mutability(m);\n             match lt {\n                 Some(ref l) => {\n@@ -1037,15 +1076,15 @@ fn rewrite_explicit_self(explicit_self: &ast::ExplicitSelf,\n                 None => Some(format!(\"&{}self\", mut_str)),\n             }\n         }\n-        ast::ExplicitSelf_::SelfExplicit(ref ty, _) => {\n+        ast::SelfKind::Explicit(ref ty, _) => {\n             assert!(!args.is_empty(), \"&[ast::Arg] shouldn't be empty.\");\n \n             let mutability = explicit_self_mutability(&args[0]);\n             let type_str = try_opt!(ty.rewrite(context, usize::max_value(), Indent::empty()));\n \n             Some(format!(\"{}self: {}\", format_mutability(mutability), type_str))\n         }\n-        ast::ExplicitSelf_::SelfValue(_) => {\n+        ast::SelfKind::Value(_) => {\n             assert!(!args.is_empty(), \"&[ast::Arg] shouldn't be empty.\");\n \n             let mutability = explicit_self_mutability(&args[0]);\n@@ -1059,7 +1098,7 @@ fn rewrite_explicit_self(explicit_self: &ast::ExplicitSelf,\n // Hacky solution caused by absence of `Mutability` in `SelfValue` and\n // `SelfExplicit` variants of `ast::ExplicitSelf_`.\n fn explicit_self_mutability(arg: &ast::Arg) -> ast::Mutability {\n-    if let ast::Pat_::PatIdent(ast::BindingMode::BindByValue(mutability), _, _) = arg.pat.node {\n+    if let ast::PatKind::Ident(ast::BindingMode::ByValue(mutability), _, _) = arg.pat.node {\n         mutability\n     } else {\n         unreachable!()\n@@ -1076,13 +1115,13 @@ pub fn span_lo_for_arg(arg: &ast::Arg) -> BytePos {\n \n pub fn span_hi_for_arg(arg: &ast::Arg) -> BytePos {\n     match arg.ty.node {\n-        ast::Ty_::TyInfer if is_named_arg(arg) => arg.pat.span.hi,\n+        ast::TyKind::Infer if is_named_arg(arg) => arg.pat.span.hi,\n         _ => arg.ty.span.hi,\n     }\n }\n \n pub fn is_named_arg(arg: &ast::Arg) -> bool {\n-    if let ast::Pat_::PatIdent(_, ident, _) = arg.pat.node {\n+    if let ast::PatKind::Ident(_, ident, _) = arg.pat.node {\n         ident.node != token::special_idents::invalid\n     } else {\n         true\n@@ -1091,9 +1130,9 @@ pub fn is_named_arg(arg: &ast::Arg) -> bool {\n \n fn span_for_return(ret: &ast::FunctionRetTy) -> Span {\n     match *ret {\n-        ast::FunctionRetTy::NoReturn(ref span) |\n-        ast::FunctionRetTy::DefaultReturn(ref span) => span.clone(),\n-        ast::FunctionRetTy::Return(ref ty) => ty.span,\n+        ast::FunctionRetTy::None(ref span) |\n+        ast::FunctionRetTy::Default(ref span) => span.clone(),\n+        ast::FunctionRetTy::Ty(ref ty) => ty.span,\n     }\n }\n \n@@ -1145,13 +1184,14 @@ fn rewrite_fn_base(context: &RewriteContext,\n     let mut result = String::with_capacity(1024);\n     // Vis unsafety abi.\n     result.push_str(format_visibility(vis));\n-    result.push_str(::utils::format_unsafety(unsafety));\n \n     if let ast::Constness::Const = constness {\n         result.push_str(\"const \");\n     }\n \n-    if abi != abi::Rust {\n+    result.push_str(::utils::format_unsafety(unsafety));\n+\n+    if abi != abi::Abi::Rust {\n         result.push_str(&::utils::format_abi(abi));\n     }\n \n@@ -1301,7 +1341,7 @@ fn rewrite_fn_base(context: &RewriteContext,\n                            (context.config.fn_args_layout == StructLitStyle::Block &&\n                             ret_str.is_empty()) ||\n                            (context.config.where_density == Density::CompressedIfEmpty &&\n-                            !has_body) {\n+                            !has_body && !result.contains('\\n')) {\n         Density::Compressed\n     } else {\n         Density::Tall\n@@ -1317,7 +1357,14 @@ fn rewrite_fn_base(context: &RewriteContext,\n                                                          where_budget,\n                                                          where_density,\n                                                          \"{\",\n+                                                         has_body,\n                                                          Some(span.hi)));\n+\n+    if last_line_width(&result) + where_clause_str.len() > context.config.max_width &&\n+       !where_clause_str.contains('\\n') {\n+        result.push('\\n');\n+    }\n+\n     result.push_str(&where_clause_str);\n \n     Some((result, force_new_line_for_brace))\n@@ -1559,7 +1606,7 @@ fn rewrite_trait_bounds(context: &RewriteContext,\n                           .join(\" + \");\n \n     let mut result = String::new();\n-    result.push_str(\" : \");\n+    result.push_str(\": \");\n     result.push_str(&bound_str);\n     Some(result)\n }\n@@ -1572,6 +1619,7 @@ fn rewrite_where_clause(context: &RewriteContext,\n                         width: usize,\n                         density: Density,\n                         terminator: &str,\n+                        allow_trailing_comma: bool,\n                         span_end: Option<BytePos>)\n                         -> Option<String> {\n     if where_clause.predicates.is_empty() {\n@@ -1611,11 +1659,12 @@ fn rewrite_where_clause(context: &RewriteContext,\n     // FIXME: we don't need to collect here if the where_layout isn't\n     // HorizontalVertical.\n     let tactic = definitive_tactic(&item_vec, context.config.where_layout, budget);\n+    let use_trailing_comma = allow_trailing_comma && context.config.where_trailing_comma;\n \n     let fmt = ListFormatting {\n         tactic: tactic,\n         separator: \",\",\n-        trailing_separator: SeparatorTactic::Never,\n+        trailing_separator: SeparatorTactic::from_bool(use_trailing_comma),\n         indent: offset,\n         width: budget,\n         ends_with_newline: true,\n@@ -1677,6 +1726,7 @@ fn format_generics(context: &RewriteContext,\n                                                              budget,\n                                                              Density::Tall,\n                                                              terminator,\n+                                                             true,\n                                                              Some(span.hi)));\n         result.push_str(&where_clause_str);\n         if !force_same_line_brace &&"}, {"sha": "7e074f0512490f974b7ed9f4eae613c7cc94c8f1", "filename": "src/lib.rs", "status": "modified", "additions": 42, "deletions": 63, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/3163071c75bff08e3ea1b4ed0928933415377ca4/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3163071c75bff08e3ea1b4ed0928933415377ca4/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=3163071c75bff08e3ea1b4ed0928933415377ca4", "patch": "@@ -26,15 +26,17 @@ extern crate diff;\n extern crate term;\n \n use syntax::ast;\n-use syntax::codemap::{mk_sp, Span};\n-use syntax::diagnostic::{EmitterWriter, Handler};\n+use syntax::codemap::{mk_sp, CodeMap, Span};\n+use syntax::errors::Handler;\n+use syntax::errors::emitter::{ColorConfig, EmitterWriter};\n use syntax::parse::{self, ParseSess};\n \n+use std::io::stdout;\n use std::ops::{Add, Sub};\n use std::path::Path;\n+use std::rc::Rc;\n use std::collections::HashMap;\n use std::fmt;\n-use std::str::FromStr;\n \n use issues::{BadIssueSeeker, Issue};\n use filemap::FileMap;\n@@ -46,6 +48,7 @@ mod utils;\n pub mod config;\n pub mod filemap;\n mod visitor;\n+mod checkstyle;\n mod items;\n mod missed_spans;\n mod lists;\n@@ -187,42 +190,6 @@ impl Sub<usize> for Indent {\n     }\n }\n \n-#[derive(Copy, Clone)]\n-pub enum WriteMode {\n-    // Backsup the original file and overwrites the orignal.\n-    Replace,\n-    // Overwrites original file without backup.\n-    Overwrite,\n-    // str is the extension of the new file.\n-    NewFile(&'static str),\n-    // Write the output to stdout.\n-    Display,\n-    // Write the diff to stdout.\n-    Diff,\n-    // Return the result as a mapping from filenames to Strings.\n-    Return,\n-    // Display how much of the input file was processed\n-    Coverage,\n-    // Unfancy stdout\n-    Plain,\n-}\n-\n-impl FromStr for WriteMode {\n-    type Err = ();\n-\n-    fn from_str(s: &str) -> Result<Self, Self::Err> {\n-        match s {\n-            \"replace\" => Ok(WriteMode::Replace),\n-            \"display\" => Ok(WriteMode::Display),\n-            \"overwrite\" => Ok(WriteMode::Overwrite),\n-            \"diff\" => Ok(WriteMode::Diff),\n-            \"coverage\" => Ok(WriteMode::Coverage),\n-            \"plain\" => Ok(WriteMode::Plain),\n-            _ => Err(()),\n-        }\n-    }\n-}\n-\n pub enum ErrorKind {\n     // Line has exceeded character limit\n     LineOverflow,\n@@ -299,8 +266,7 @@ impl fmt::Display for FormatReport {\n fn fmt_ast(krate: &ast::Crate,\n            parse_session: &ParseSess,\n            main_file: &Path,\n-           config: &Config,\n-           mode: WriteMode)\n+           config: &Config)\n            -> FileMap {\n     let mut file_map = FileMap::new();\n     for (path, module) in modules::list_files(krate, parse_session.codemap()) {\n@@ -311,7 +277,7 @@ fn fmt_ast(krate: &ast::Crate,\n         if config.verbose {\n             println!(\"Formatting {}\", path);\n         }\n-        let mut visitor = FmtVisitor::from_codemap(parse_session, config, Some(mode));\n+        let mut visitor = FmtVisitor::from_codemap(parse_session, config);\n         visitor.format_separate_mod(module);\n         file_map.insert(path.to_owned(), visitor.buffer);\n     }\n@@ -401,24 +367,32 @@ pub fn fmt_lines(file_map: &mut FileMap, config: &Config) -> FormatReport {\n     report\n }\n \n-pub fn format_string(input: String, config: &Config, mode: WriteMode) -> FileMap {\n+pub fn format_string(input: String, config: &Config) -> FileMap {\n     let path = \"stdin\";\n-    let mut parse_session = ParseSess::new();\n+    let codemap = Rc::new(CodeMap::new());\n+\n+    let tty_handler = Handler::with_tty_emitter(ColorConfig::Auto,\n+                                                None,\n+                                                true,\n+                                                false,\n+                                                codemap.clone());\n+    let mut parse_session = ParseSess::with_span_handler(tty_handler, codemap.clone());\n+\n     let krate = parse::parse_crate_from_source_str(path.to_owned(),\n                                                    input,\n                                                    Vec::new(),\n                                                    &parse_session);\n \n     // Suppress error output after parsing.\n-    let emitter = Box::new(EmitterWriter::new(Box::new(Vec::new()), None));\n-    parse_session.span_diagnostic.handler = Handler::with_emitter(false, emitter);\n+    let silent_emitter = Box::new(EmitterWriter::new(Box::new(Vec::new()), None, codemap.clone()));\n+    parse_session.span_diagnostic = Handler::with_emitter(true, false, silent_emitter);\n \n     // FIXME: we still use a FileMap even though we only have\n     // one file, because fmt_lines requires a FileMap\n     let mut file_map = FileMap::new();\n \n     // do the actual formatting\n-    let mut visitor = FmtVisitor::from_codemap(&parse_session, config, Some(mode));\n+    let mut visitor = FmtVisitor::from_codemap(&parse_session, config);\n     visitor.format_separate_mod(&krate.module);\n \n     // append final newline\n@@ -428,15 +402,23 @@ pub fn format_string(input: String, config: &Config, mode: WriteMode) -> FileMap\n     file_map\n }\n \n-pub fn format(file: &Path, config: &Config, mode: WriteMode) -> FileMap {\n-    let mut parse_session = ParseSess::new();\n+pub fn format(file: &Path, config: &Config) -> FileMap {\n+    let codemap = Rc::new(CodeMap::new());\n+\n+    let tty_handler = Handler::with_tty_emitter(ColorConfig::Auto,\n+                                                None,\n+                                                true,\n+                                                false,\n+                                                codemap.clone());\n+    let mut parse_session = ParseSess::with_span_handler(tty_handler, codemap.clone());\n+\n     let krate = parse::parse_crate_from_file(file, Vec::new(), &parse_session);\n \n     // Suppress error output after parsing.\n-    let emitter = Box::new(EmitterWriter::new(Box::new(Vec::new()), None));\n-    parse_session.span_diagnostic.handler = Handler::with_emitter(false, emitter);\n+    let silent_emitter = Box::new(EmitterWriter::new(Box::new(Vec::new()), None, codemap.clone()));\n+    parse_session.span_diagnostic = Handler::with_emitter(true, false, silent_emitter);\n \n-    let mut file_map = fmt_ast(&krate, &parse_session, file, config, mode);\n+    let mut file_map = fmt_ast(&krate, &parse_session, file, config);\n \n     // For some reason, the codemap does not include terminating\n     // newlines so we must add one on for each file. This is sad.\n@@ -445,28 +427,25 @@ pub fn format(file: &Path, config: &Config, mode: WriteMode) -> FileMap {\n     file_map\n }\n \n-// args are the arguments passed on the command line, generally passed through\n-// to the compiler.\n-// write_mode determines what happens to the result of running rustfmt, see\n-// WriteMode.\n-pub fn run(file: &Path, write_mode: WriteMode, config: &Config) {\n-    let mut result = format(file, config, write_mode);\n+pub fn run(file: &Path, config: &Config) {\n+    let mut result = format(file, config);\n \n     print!(\"{}\", fmt_lines(&mut result, config));\n-\n-    let write_result = filemap::write_all_files(&result, write_mode, config);\n+    let out = stdout();\n+    let write_result = filemap::write_all_files(&result, out, config);\n \n     if let Err(msg) = write_result {\n         println!(\"Error writing files: {}\", msg);\n     }\n }\n \n // Similar to run, but takes an input String instead of a file to format\n-pub fn run_from_stdin(input: String, mode: WriteMode, config: &Config) {\n-    let mut result = format_string(input, config, mode);\n+pub fn run_from_stdin(input: String, config: &Config) {\n+    let mut result = format_string(input, config);\n     fmt_lines(&mut result, config);\n \n-    let write_result = filemap::write_file(&result[\"stdin\"], \"stdin\", mode, config);\n+    let mut out = stdout();\n+    let write_result = filemap::write_file(&result[\"stdin\"], \"stdin\", &mut out, config);\n \n     if let Err(msg) = write_result {\n         panic!(\"Error writing to stdout: {}\", msg);"}, {"sha": "a8da45c6408fe1bdde46a693bc736714535ac71d", "filename": "src/macros.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/3163071c75bff08e3ea1b4ed0928933415377ca4/src%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3163071c75bff08e3ea1b4ed0928933415377ca4/src%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmacros.rs?ref=3163071c75bff08e3ea1b4ed0928933415377ca4", "patch": "@@ -30,10 +30,10 @@ use expr::{rewrite_call, rewrite_array};\n use comment::FindUncommented;\n use utils::{wrap_str, span_after};\n \n-static FORCED_BRACKET_MACROS: &'static [&'static str] = &[\"vec!\"];\n+const FORCED_BRACKET_MACROS: &'static [&'static str] = &[\"vec!\"];\n \n // FIXME: use the enum from libsyntax?\n-#[derive(Clone, Copy)]\n+#[derive(Clone, Copy, PartialEq, Eq)]\n enum MacroStyle {\n     Parens,\n     Brackets,\n@@ -63,9 +63,7 @@ pub fn rewrite_macro(mac: &ast::Mac,\n         original_style\n     };\n \n-    if let MacroStyle::Braces = style {\n-        return None;\n-    } else if mac.node.tts.is_empty() {\n+    if mac.node.tts.is_empty() {\n         return if let MacroStyle::Parens = style {\n             Some(format!(\"{}()\", macro_name))\n         } else {\n@@ -76,22 +74,24 @@ pub fn rewrite_macro(mac: &ast::Mac,\n     let mut parser = tts_to_parser(context.parse_session, mac.node.tts.clone(), Vec::new());\n     let mut expr_vec = Vec::new();\n \n-    loop {\n-        expr_vec.push(match parser.parse_expr() {\n-            Ok(expr) => expr,\n-            Err(..) => return None,\n-        });\n+    if MacroStyle::Braces != style {\n+        loop {\n+            expr_vec.push(match parser.parse_expr() {\n+                Ok(expr) => expr,\n+                Err(..) => return None,\n+            });\n \n-        match parser.token {\n-            Token::Eof => break,\n-            Token::Comma => (),\n-            _ => return None,\n-        }\n+            match parser.token {\n+                Token::Eof => break,\n+                Token::Comma => (),\n+                _ => return None,\n+            }\n \n-        let _ = parser.bump();\n+            let _ = parser.bump();\n \n-        if parser.token == Token::Eof {\n-            return None;\n+            if parser.token == Token::Eof {\n+                return None;\n+            }\n         }\n     }\n "}, {"sha": "092cc0093f170c5d506f91a9676c480a29e0a720", "filename": "src/missed_spans.rs", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/3163071c75bff08e3ea1b4ed0928933415377ca4/src%2Fmissed_spans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3163071c75bff08e3ea1b4ed0928933415377ca4/src%2Fmissed_spans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmissed_spans.rs?ref=3163071c75bff08e3ea1b4ed0928933415377ca4", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use WriteMode;\n+use config::WriteMode;\n use visitor::FmtVisitor;\n use syntax::codemap::{self, BytePos, Span, Pos};\n use comment::{CodeCharKind, CommentCodeSlices, rewrite_comment};\n@@ -103,14 +103,9 @@ impl<'a> FmtVisitor<'a> {\n                   .collect()\n         }\n \n-        let replaced = match self.write_mode {\n-            Some(mode) => {\n-                match mode {\n-                    WriteMode::Coverage => replace_chars(old_snippet),\n-                    _ => old_snippet.to_owned(),\n-                }\n-            }\n-            None => old_snippet.to_owned(),\n+        let replaced = match self.config.write_mode {\n+            WriteMode::Coverage => replace_chars(old_snippet),\n+            _ => old_snippet.to_owned(),\n         };\n         let snippet = &*replaced;\n \n@@ -147,11 +142,11 @@ impl<'a> FmtVisitor<'a> {\n                     if let Some('/') = subslice.chars().skip(1).next() {\n                         // Add a newline after line comments\n                         self.buffer.push_str(\"\\n\");\n-                    } else if line_start < snippet.len() {\n+                    } else if line_start <= snippet.len() {\n                         // For other comments add a newline if there isn't one at the end already\n-                        let c = snippet[line_start..].chars().next().unwrap();\n-                        if c != '\\n' && c != '\\r' {\n-                            self.buffer.push_str(\"\\n\");\n+                        match snippet[line_start..].chars().next() {\n+                            Some('\\n') | Some('\\r') => (),\n+                            _ => self.buffer.push_str(\"\\n\"),\n                         }\n                     }\n "}, {"sha": "e56fa57ac7b911f6957d770b44c3049334107ba7", "filename": "src/modules.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3163071c75bff08e3ea1b4ed0928933415377ca4/src%2Fmodules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3163071c75bff08e3ea1b4ed0928933415377ca4/src%2Fmodules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmodules.rs?ref=3163071c75bff08e3ea1b4ed0928933415377ca4", "patch": "@@ -40,7 +40,7 @@ fn list_submodules<'a>(module: &'a ast::Mod,\n                        result: &mut HashMap<PathBuf, &'a ast::Mod>) {\n     debug!(\"list_submodules: search_dir: {:?}\", search_dir);\n     for item in &module.items {\n-        if let ast::ItemMod(ref sub_mod) = item.node {\n+        if let ast::ItemKind::Mod(ref sub_mod) = item.node {\n             if !utils::contains_skip(&item.attrs) {\n                 let is_internal = codemap.span_to_filename(item.span) ==\n                                   codemap.span_to_filename(sub_mod.inner);"}, {"sha": "a761ad538f544f0b1d6c4b2d72a364a030e47899", "filename": "src/patterns.rs", "status": "modified", "additions": 136, "deletions": 42, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/3163071c75bff08e3ea1b4ed0928933415377ca4/src%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3163071c75bff08e3ea1b4ed0928933415377ca4/src%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fpatterns.rs?ref=3163071c75bff08e3ea1b4ed0928933415377ca4", "patch": "@@ -15,80 +15,160 @@ use lists::{format_item_list, itemize_list};\n use expr::{rewrite_unary_prefix, rewrite_pair, rewrite_tuple};\n use types::rewrite_path;\n \n-use syntax::ast::{BindingMode, Pat, Pat_};\n+use syntax::ast::{BindingMode, Pat, PatKind, FieldPat};\n \n-// FIXME(#18): implement pattern formatting.\n impl Rewrite for Pat {\n     fn rewrite(&self, context: &RewriteContext, width: usize, offset: Indent) -> Option<String> {\n         match self.node {\n-            Pat_::PatBox(ref pat) => rewrite_unary_prefix(context, \"box \", &**pat, width, offset),\n-            Pat_::PatIdent(binding_mode, ident, None) => {\n+            PatKind::Box(ref pat) => rewrite_unary_prefix(context, \"box \", &**pat, width, offset),\n+            PatKind::Ident(binding_mode, ident, ref sub_pat) => {\n                 let (prefix, mutability) = match binding_mode {\n-                    BindingMode::BindByRef(mutability) => (\"ref \", mutability),\n-                    BindingMode::BindByValue(mutability) => (\"\", mutability),\n+                    BindingMode::ByRef(mutability) => (\"ref \", mutability),\n+                    BindingMode::ByValue(mutability) => (\"\", mutability),\n                 };\n                 let mut_infix = format_mutability(mutability);\n-                let result = format!(\"{}{}{}\", prefix, mut_infix, ident.node);\n+                let id_str = ident.node.to_string();\n+\n+                let sub_pat = match *sub_pat {\n+                    Some(ref p) => {\n+                        // 3 - ` @ `.\n+                        let width = try_opt!(width.checked_sub(prefix.len() + mut_infix.len() +\n+                                                               id_str.len() +\n+                                                               3));\n+                        format!(\" @ {}\", try_opt!(p.rewrite(context, width, offset)))\n+                    }\n+                    None => \"\".to_owned(),\n+                };\n+\n+                let result = format!(\"{}{}{}{}\", prefix, mut_infix, id_str, sub_pat);\n                 wrap_str(result, context.config.max_width, width, offset)\n             }\n-            Pat_::PatWild => {\n+            PatKind::Wild => {\n                 if 1 <= width {\n                     Some(\"_\".to_owned())\n                 } else {\n                     None\n                 }\n             }\n-            Pat_::PatQPath(ref q_self, ref path) => {\n+            PatKind::QPath(ref q_self, ref path) => {\n                 rewrite_path(context, true, Some(q_self), path, width, offset)\n             }\n-            Pat_::PatRange(ref lhs, ref rhs) => {\n+            PatKind::Range(ref lhs, ref rhs) => {\n                 rewrite_pair(&**lhs, &**rhs, \"\", \"...\", \"\", context, width, offset)\n             }\n-            Pat_::PatRegion(ref pat, mutability) => {\n+            PatKind::Ref(ref pat, mutability) => {\n                 let prefix = format!(\"&{}\", format_mutability(mutability));\n                 rewrite_unary_prefix(context, &prefix, &**pat, width, offset)\n             }\n-            Pat_::PatTup(ref items) => {\n+            PatKind::Tup(ref items) => {\n                 rewrite_tuple(context,\n                               items.iter().map(|x| &**x),\n                               self.span,\n                               width,\n                               offset)\n             }\n-            Pat_::PatEnum(ref path, Some(ref pat_vec)) => {\n-                let path_str = try_opt!(::types::rewrite_path(context,\n-                                                              true,\n-                                                              None,\n-                                                              path,\n-                                                              width,\n-                                                              offset));\n+            PatKind::Path(ref path) => rewrite_path(context, true, None, path, width, offset),\n+            PatKind::TupleStruct(ref path, ref pat_vec) => {\n+                let path_str = try_opt!(rewrite_path(context, true, None, path, width, offset));\n+\n+                match *pat_vec {\n+                    Some(ref pat_vec) => {\n+                        if pat_vec.is_empty() {\n+                            Some(path_str)\n+                        } else {\n+                            // 1 = (\n+                            let width = try_opt!(width.checked_sub(path_str.len() + 1));\n+                            let offset = offset + path_str.len() + 1;\n+                            let items = itemize_list(context.codemap,\n+                                                     pat_vec.iter(),\n+                                                     \")\",\n+                                                     |item| item.span.lo,\n+                                                     |item| item.span.hi,\n+                                                     |item| item.rewrite(context, width, offset),\n+                                                     span_after(self.span, \"(\", context.codemap),\n+                                                     self.span.hi);\n+                            Some(format!(\"{}({})\",\n+                                         path_str,\n+                                         try_opt!(format_item_list(items,\n+                                                                   width,\n+                                                                   offset,\n+                                                                   context.config))))\n+                        }\n+                    }\n+                    None => Some(format!(\"{}(..)\", path_str)),\n+                }\n+            }\n+            PatKind::Lit(ref expr) => expr.rewrite(context, width, offset),\n+            PatKind::Vec(ref prefix, ref slice_pat, ref suffix) => {\n+                // Rewrite all the sub-patterns.\n+                let prefix = prefix.iter().map(|p| p.rewrite(context, width, offset));\n+                let slice_pat = slice_pat.as_ref().map(|p| {\n+                    Some(format!(\"{}..\", try_opt!(p.rewrite(context, width, offset))))\n+                });\n+                let suffix = suffix.iter().map(|p| p.rewrite(context, width, offset));\n+\n+                // Munge them together.\n+                let pats: Option<Vec<String>> = prefix.chain(slice_pat.into_iter())\n+                                                      .chain(suffix)\n+                                                      .collect();\n+\n+                // Check that all the rewrites succeeded, and if not return None.\n+                let pats = try_opt!(pats);\n+\n+                // Unwrap all the sub-strings and join them with commas.\n+                let result = format!(\"[{}]\", pats.join(\", \"));\n+                wrap_str(result, context.config.max_width, width, offset)\n+            }\n+            PatKind::Struct(ref path, ref fields, elipses) => {\n+                let path = try_opt!(rewrite_path(context, true, None, path, width, offset));\n \n-                if pat_vec.is_empty() {\n-                    Some(path_str)\n+                let (elipses_str, terminator) = if elipses {\n+                    (\", ..\", \"..\")\n                 } else {\n-                    // 1 = (\n-                    let width = try_opt!(width.checked_sub(path_str.len() + 1));\n-                    let offset = offset + path_str.len() + 1;\n-                    let items = itemize_list(context.codemap,\n-                                             pat_vec.iter(),\n-                                             \")\",\n-                                             |item| item.span.lo,\n-                                             |item| item.span.hi,\n-                                             |item| item.rewrite(context, width, offset),\n-                                             span_after(self.span, \"(\", context.codemap),\n-                                             self.span.hi);\n-                    Some(format!(\"{}({})\",\n-                                 path_str,\n-                                 try_opt!(format_item_list(items, width, offset, context.config))))\n+                    (\"\", \"}\")\n+                };\n+\n+                // 5 = `{` plus space before and after plus `}` plus space before.\n+                let budget = try_opt!(width.checked_sub(path.len() + 5 + elipses_str.len()));\n+                // FIXME Using visual indenting, should use block or visual to match\n+                // struct lit preference (however, in practice I think it is rare\n+                // for struct patterns to be multi-line).\n+                // 3 = `{` plus space before and after.\n+                let offset = offset + path.len() + 3;\n+\n+                let items = itemize_list(context.codemap,\n+                                         fields.iter(),\n+                                         terminator,\n+                                         |f| f.span.lo,\n+                                         |f| f.span.hi,\n+                                         |f| f.node.rewrite(context, budget, offset),\n+                                         span_after(self.span, \"{\", context.codemap),\n+                                         self.span.hi);\n+                let mut field_string = try_opt!(format_item_list(items,\n+                                                                 budget,\n+                                                                 offset,\n+                                                                 context.config));\n+                if elipses {\n+                    if field_string.contains('\\n') {\n+                        field_string.push_str(\",\\n\");\n+                        field_string.push_str(&offset.to_string(context.config));\n+                        field_string.push_str(\"..\");\n+                    } else {\n+                        if field_string.len() > 0 {\n+                            field_string.push_str(\", \");\n+                        }\n+                        field_string.push_str(\"..\");\n+                    }\n+                }\n+\n+                if field_string.is_empty() {\n+                    Some(format!(\"{} {{}}\", path))\n+                } else {\n+                    Some(format!(\"{} {{ {} }}\", path, field_string))\n                 }\n             }\n-            Pat_::PatLit(ref expr) => expr.rewrite(context, width, offset),\n-            // FIXME(#8): format remaining pattern variants.\n-            Pat_::PatIdent(_, _, Some(..)) |\n-            Pat_::PatEnum(_, None) |\n-            Pat_::PatStruct(..) |\n-            Pat_::PatVec(..) |\n-            Pat_::PatMac(..) => {\n+            // FIXME(#819) format pattern macros.\n+            PatKind::Mac(..) => {\n                 wrap_str(context.snippet(self.span),\n                          context.config.max_width,\n                          width,\n@@ -97,3 +177,17 @@ impl Rewrite for Pat {\n         }\n     }\n }\n+\n+impl Rewrite for FieldPat {\n+    fn rewrite(&self, context: &RewriteContext, width: usize, offset: Indent) -> Option<String> {\n+        let pat = self.pat.rewrite(context, width, offset);\n+        if self.is_shorthand {\n+            pat\n+        } else {\n+            wrap_str(format!(\"{}: {}\", self.ident.to_string(), try_opt!(pat)),\n+                     context.config.max_width,\n+                     width,\n+                     offset)\n+        }\n+    }\n+}"}, {"sha": "5a08e176618578d2f37276cd488e70b78cafe79b", "filename": "src/types.rs", "status": "modified", "additions": 38, "deletions": 27, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/3163071c75bff08e3ea1b4ed0928933415377ca4/src%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3163071c75bff08e3ea1b4ed0928933415377ca4/src%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftypes.rs?ref=3163071c75bff08e3ea1b4ed0928933415377ca4", "patch": "@@ -21,6 +21,7 @@ use lists::{format_item_list, itemize_list, format_fn_args};\n use rewrite::{Rewrite, RewriteContext};\n use utils::{extra_offset, span_after, format_mutability, wrap_str};\n use expr::{rewrite_unary_prefix, rewrite_pair, rewrite_tuple};\n+use config::TypeDensity;\n \n // Does not wrap on simple segments.\n pub fn rewrite_path(context: &RewriteContext,\n@@ -52,7 +53,7 @@ pub fn rewrite_path(context: &RewriteContext,\n             // 3 = \">::\".len()\n             let budget = try_opt!(width.checked_sub(extra_offset + 3));\n \n-            result = try_opt!(rewrite_path_segments(expr_context,\n+            result = try_opt!(rewrite_path_segments(false,\n                                                     result,\n                                                     path.segments.iter().take(skip_count),\n                                                     span_lo,\n@@ -171,9 +172,9 @@ fn rewrite_segment(expr_context: bool,\n     let offset = offset + ident_len;\n \n     let params = match segment.parameters {\n-        ast::PathParameters::AngleBracketedParameters(ref data) if !data.lifetimes.is_empty() ||\n-                                                                   !data.types.is_empty() ||\n-                                                                   !data.bindings.is_empty() => {\n+        ast::PathParameters::AngleBracketed(ref data) if !data.lifetimes.is_empty() ||\n+                                                         !data.types.is_empty() ||\n+                                                         !data.bindings.is_empty() => {\n             let param_list = data.lifetimes\n                                  .iter()\n                                  .map(SegmentParam::LifeTime)\n@@ -212,10 +213,10 @@ fn rewrite_segment(expr_context: bool,\n \n             format!(\"{}<{}>\", separator, list_str)\n         }\n-        ast::PathParameters::ParenthesizedParameters(ref data) => {\n+        ast::PathParameters::Parenthesized(ref data) => {\n             let output = match data.output {\n-                Some(ref ty) => FunctionRetTy::Return(ty.clone()),\n-                None => FunctionRetTy::DefaultReturn(codemap::DUMMY_SP),\n+                Some(ref ty) => FunctionRetTy::Ty(ty.clone()),\n+                None => FunctionRetTy::Default(codemap::DUMMY_SP),\n             };\n             try_opt!(format_function_type(data.inputs.iter().map(|x| &**x),\n                                           &output,\n@@ -258,13 +259,13 @@ fn format_function_type<'a, I>(inputs: I,\n     let list_str = try_opt!(format_fn_args(items, budget, offset, context.config));\n \n     let output = match *output {\n-        FunctionRetTy::Return(ref ty) => {\n+        FunctionRetTy::Ty(ref ty) => {\n             let budget = try_opt!(width.checked_sub(4));\n             let type_str = try_opt!(ty.rewrite(context, budget, offset + 4));\n             format!(\" -> {}\", type_str)\n         }\n-        FunctionRetTy::NoReturn(..) => \" -> !\".to_owned(),\n-        FunctionRetTy::DefaultReturn(..) => String::new(),\n+        FunctionRetTy::None(..) => \" -> !\".to_owned(),\n+        FunctionRetTy::Default(..) => String::new(),\n     };\n \n     let infix = if output.len() + list_str.len() > width {\n@@ -424,7 +425,12 @@ impl Rewrite for ast::TyParam {\n             result.push_str(&bounds);\n         }\n         if let Some(ref def) = self.default {\n-            result.push_str(\" = \");\n+\n+            let eq_str = match context.config.type_punctuation_density {\n+                TypeDensity::Compressed => \"=\",\n+                TypeDensity::Wide => \" = \",\n+            };\n+            result.push_str(eq_str);\n             let budget = try_opt!(width.checked_sub(result.len()));\n             let rewrite = try_opt!(def.rewrite(context, budget, offset + result.len()));\n             result.push_str(&rewrite);\n@@ -464,24 +470,29 @@ impl Rewrite for ast::TraitRef {\n impl Rewrite for ast::Ty {\n     fn rewrite(&self, context: &RewriteContext, width: usize, offset: Indent) -> Option<String> {\n         match self.node {\n-            ast::TyObjectSum(ref ty, ref bounds) => {\n+            ast::TyKind::ObjectSum(ref ty, ref bounds) => {\n                 let ty_str = try_opt!(ty.rewrite(context, width, offset));\n                 let overhead = ty_str.len() + 3;\n-                Some(format!(\"{} + {}\",\n+                let plus_str = match context.config.type_punctuation_density {\n+                    TypeDensity::Compressed => \"+\",\n+                    TypeDensity::Wide => \" + \",\n+                };\n+                Some(format!(\"{}{}{}\",\n                              ty_str,\n+                             plus_str,\n                              try_opt!(bounds.rewrite(context,\n                                                      try_opt!(width.checked_sub(overhead)),\n                                                      offset + overhead))))\n             }\n-            ast::TyPtr(ref mt) => {\n+            ast::TyKind::Ptr(ref mt) => {\n                 let prefix = match mt.mutbl {\n-                    Mutability::MutMutable => \"*mut \",\n-                    Mutability::MutImmutable => \"*const \",\n+                    Mutability::Mutable => \"*mut \",\n+                    Mutability::Immutable => \"*const \",\n                 };\n \n                 rewrite_unary_prefix(context, prefix, &*mt.ty, width, offset)\n             }\n-            ast::TyRptr(ref lifetime, ref mt) => {\n+            ast::TyKind::Rptr(ref lifetime, ref mt) => {\n                 let mut_str = format_mutability(mt.mutbl);\n                 let mut_len = mut_str.len();\n                 Some(match *lifetime {\n@@ -509,39 +520,39 @@ impl Rewrite for ast::Ty {\n             }\n             // FIXME: we drop any comments here, even though it's a silly place to put\n             // comments.\n-            ast::TyParen(ref ty) => {\n+            ast::TyKind::Paren(ref ty) => {\n                 let budget = try_opt!(width.checked_sub(2));\n                 ty.rewrite(context, budget, offset + 1).map(|ty_str| format!(\"({})\", ty_str))\n             }\n-            ast::TyVec(ref ty) => {\n+            ast::TyKind::Vec(ref ty) => {\n                 let budget = try_opt!(width.checked_sub(2));\n                 ty.rewrite(context, budget, offset + 1).map(|ty_str| format!(\"[{}]\", ty_str))\n             }\n-            ast::TyTup(ref items) => {\n+            ast::TyKind::Tup(ref items) => {\n                 rewrite_tuple(context,\n                               items.iter().map(|x| &**x),\n                               self.span,\n                               width,\n                               offset)\n             }\n-            ast::TyPolyTraitRef(ref trait_ref) => trait_ref.rewrite(context, width, offset),\n-            ast::TyPath(ref q_self, ref path) => {\n+            ast::TyKind::PolyTraitRef(ref trait_ref) => trait_ref.rewrite(context, width, offset),\n+            ast::TyKind::Path(ref q_self, ref path) => {\n                 rewrite_path(context, false, q_self.as_ref(), path, width, offset)\n             }\n-            ast::TyFixedLengthVec(ref ty, ref repeats) => {\n+            ast::TyKind::FixedLengthVec(ref ty, ref repeats) => {\n                 rewrite_pair(&**ty, &**repeats, \"[\", \"; \", \"]\", context, width, offset)\n             }\n-            ast::TyInfer => {\n+            ast::TyKind::Infer => {\n                 if width >= 1 {\n                     Some(\"_\".to_owned())\n                 } else {\n                     None\n                 }\n             }\n-            ast::TyBareFn(ref bare_fn) => {\n+            ast::TyKind::BareFn(ref bare_fn) => {\n                 rewrite_bare_fn(bare_fn, self.span, context, width, offset)\n             }\n-            ast::TyMac(..) | ast::TyTypeof(..) => unreachable!(),\n+            ast::TyKind::Mac(..) | ast::TyKind::Typeof(..) => unreachable!(),\n         }\n     }\n }\n@@ -556,7 +567,7 @@ fn rewrite_bare_fn(bare_fn: &ast::BareFnTy,\n \n     result.push_str(&::utils::format_unsafety(bare_fn.unsafety));\n \n-    if bare_fn.abi != abi::Rust {\n+    if bare_fn.abi != abi::Abi::Rust {\n         result.push_str(&::utils::format_abi(bare_fn.abi));\n     }\n "}, {"sha": "acf758087d4bcffcced9450ffe18e5db830c7d49", "filename": "src/utils.rs", "status": "modified", "additions": 22, "deletions": 14, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/3163071c75bff08e3ea1b4ed0928933415377ca4/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3163071c75bff08e3ea1b4ed0928933415377ca4/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=3163071c75bff08e3ea1b4ed0928933415377ca4", "patch": "@@ -10,7 +10,7 @@\n \n use std::cmp::Ordering;\n \n-use syntax::ast::{self, Visibility, Attribute, MetaItem, MetaItem_};\n+use syntax::ast::{self, Visibility, Attribute, MetaItem, MetaItemKind};\n use syntax::codemap::{CodeMap, Span, BytePos};\n use syntax::abi;\n \n@@ -38,6 +38,14 @@ pub fn span_after(original: Span, needle: &str, codemap: &CodeMap) -> BytePos {\n     original.lo + BytePos(offset as u32)\n }\n \n+#[inline]\n+pub fn span_before(original: Span, needle: &str, codemap: &CodeMap) -> BytePos {\n+    let snippet = codemap.span_to_snippet(original).unwrap();\n+    let offset = snippet.find_uncommented(needle).unwrap();\n+\n+    original.lo + BytePos(offset as u32)\n+}\n+\n #[inline]\n pub fn span_after_last(original: Span, needle: &str, codemap: &CodeMap) -> BytePos {\n     let snippet = codemap.span_to_snippet(original).unwrap();\n@@ -69,8 +77,8 @@ pub fn format_unsafety(unsafety: ast::Unsafety) -> &'static str {\n #[inline]\n pub fn format_mutability(mutability: ast::Mutability) -> &'static str {\n     match mutability {\n-        ast::Mutability::MutMutable => \"mut \",\n-        ast::Mutability::MutImmutable => \"\",\n+        ast::Mutability::Mutable => \"mut \",\n+        ast::Mutability::Immutable => \"\",\n     }\n }\n \n@@ -101,8 +109,8 @@ pub fn last_line_width(s: &str) -> usize {\n #[inline]\n fn is_skip(meta_item: &MetaItem) -> bool {\n     match meta_item.node {\n-        MetaItem_::MetaWord(ref s) => *s == SKIP_ANNOTATION,\n-        MetaItem_::MetaList(ref s, ref l) => *s == \"cfg_attr\" && l.len() == 2 && is_skip(&l[1]),\n+        MetaItemKind::Word(ref s) => *s == SKIP_ANNOTATION,\n+        MetaItemKind::List(ref s, ref l) => *s == \"cfg_attr\" && l.len() == 2 && is_skip(&l[1]),\n         _ => false,\n     }\n }\n@@ -129,26 +137,26 @@ pub fn end_typaram(typaram: &ast::TyParam) -> BytePos {\n #[inline]\n pub fn semicolon_for_expr(expr: &ast::Expr) -> bool {\n     match expr.node {\n-        ast::Expr_::ExprRet(..) |\n-        ast::Expr_::ExprAgain(..) |\n-        ast::Expr_::ExprBreak(..) => true,\n+        ast::ExprKind::Ret(..) |\n+        ast::ExprKind::Again(..) |\n+        ast::ExprKind::Break(..) => true,\n         _ => false,\n     }\n }\n \n #[inline]\n pub fn semicolon_for_stmt(stmt: &ast::Stmt) -> bool {\n     match stmt.node {\n-        ast::Stmt_::StmtSemi(ref expr, _) => {\n+        ast::StmtKind::Semi(ref expr, _) => {\n             match expr.node {\n-                ast::Expr_::ExprWhile(..) |\n-                ast::Expr_::ExprWhileLet(..) |\n-                ast::Expr_::ExprLoop(..) |\n-                ast::Expr_::ExprForLoop(..) => false,\n+                ast::ExprKind::While(..) |\n+                ast::ExprKind::WhileLet(..) |\n+                ast::ExprKind::Loop(..) |\n+                ast::ExprKind::ForLoop(..) => false,\n                 _ => true,\n             }\n         }\n-        ast::Stmt_::StmtExpr(..) => false,\n+        ast::StmtKind::Expr(..) => false,\n         _ => true,\n     }\n }"}, {"sha": "02bc29e326922c5993e8e9202e8d083d4184731c", "filename": "src/visitor.rs", "status": "modified", "additions": 41, "deletions": 42, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/3163071c75bff08e3ea1b4ed0928933415377ca4/src%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3163071c75bff08e3ea1b4ed0928933415377ca4/src%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvisitor.rs?ref=3163071c75bff08e3ea1b4ed0928933415377ca4", "patch": "@@ -15,7 +15,7 @@ use syntax::visit;\n \n use strings::string_buffer::StringBuffer;\n \n-use {Indent, WriteMode};\n+use Indent;\n use utils;\n use config::Config;\n use rewrite::{Rewrite, RewriteContext};\n@@ -31,14 +31,13 @@ pub struct FmtVisitor<'a> {\n     // FIXME: use an RAII util or closure for indenting\n     pub block_indent: Indent,\n     pub config: &'a Config,\n-    pub write_mode: Option<WriteMode>,\n }\n \n impl<'a> FmtVisitor<'a> {\n     fn visit_stmt(&mut self, stmt: &ast::Stmt) {\n         match stmt.node {\n-            ast::Stmt_::StmtDecl(ref decl, _) => {\n-                if let ast::Decl_::DeclItem(ref item) = decl.node {\n+            ast::StmtKind::Decl(ref decl, _) => {\n+                if let ast::DeclKind::Item(ref item) = decl.node {\n                     self.visit_item(item);\n                 } else {\n                     let rewrite = stmt.rewrite(&self.get_context(),\n@@ -48,14 +47,14 @@ impl<'a> FmtVisitor<'a> {\n                     self.push_rewrite(stmt.span, rewrite);\n                 }\n             }\n-            ast::Stmt_::StmtExpr(..) | ast::Stmt_::StmtSemi(..) => {\n+            ast::StmtKind::Expr(..) | ast::StmtKind::Semi(..) => {\n                 let rewrite = stmt.rewrite(&self.get_context(),\n                                            self.config.max_width - self.block_indent.width(),\n                                            self.block_indent);\n \n                 self.push_rewrite(stmt.span, rewrite);\n             }\n-            ast::Stmt_::StmtMac(ref mac, _macro_style, _) => {\n+            ast::StmtKind::Mac(ref mac, _macro_style, _) => {\n                 self.format_missing_with_indent(stmt.span.lo);\n                 self.visit_mac(mac);\n             }\n@@ -184,7 +183,7 @@ impl<'a> FmtVisitor<'a> {\n         // FIXME This is overly conservative and means we miss attributes on\n         // inline modules.\n         match item.node {\n-            ast::Item_::ItemMod(_) => {\n+            ast::ItemKind::Mod(_) => {\n                 if utils::contains_skip(&item.attrs) {\n                     return;\n                 }\n@@ -198,18 +197,18 @@ impl<'a> FmtVisitor<'a> {\n         }\n \n         match item.node {\n-            ast::Item_::ItemUse(ref vp) => {\n+            ast::ItemKind::Use(ref vp) => {\n                 self.format_import(item.vis, vp, item.span);\n             }\n-            ast::Item_::ItemImpl(..) => {\n+            ast::ItemKind::Impl(..) => {\n                 self.format_missing_with_indent(item.span.lo);\n                 if let Some(impl_str) = format_impl(&self.get_context(), item, self.block_indent) {\n                     self.buffer.push_str(&impl_str);\n                     self.last_pos = item.span.hi;\n                 }\n             }\n             // FIXME(#78): format traits.\n-            ast::Item_::ItemTrait(..) => {\n+            ast::ItemKind::Trait(..) => {\n                 self.format_missing_with_indent(item.span.lo);\n                 if let Some(trait_str) = format_trait(&self.get_context(),\n                                                       item,\n@@ -223,13 +222,13 @@ impl<'a> FmtVisitor<'a> {\n                 // }\n                 // self.block_indent = self.block_indent.block_unindent(self.config);\n             }\n-            ast::Item_::ItemExternCrate(_) => {\n+            ast::ItemKind::ExternCrate(_) => {\n                 self.format_missing_with_indent(item.span.lo);\n                 let new_str = self.snippet(item.span);\n                 self.buffer.push_str(&new_str);\n                 self.last_pos = item.span.hi;\n             }\n-            ast::Item_::ItemStruct(ref def, ref generics) => {\n+            ast::ItemKind::Struct(ref def, ref generics) => {\n                 let rewrite = {\n                     let indent = self.block_indent;\n                     let context = self.get_context();\n@@ -250,28 +249,24 @@ impl<'a> FmtVisitor<'a> {\n                 };\n                 self.push_rewrite(item.span, rewrite);\n             }\n-            ast::Item_::ItemEnum(ref def, ref generics) => {\n+            ast::ItemKind::Enum(ref def, ref generics) => {\n                 self.format_missing_with_indent(item.span.lo);\n                 self.visit_enum(item.ident, item.vis, def, generics, item.span);\n                 self.last_pos = item.span.hi;\n             }\n-            ast::Item_::ItemMod(ref module) => {\n+            ast::ItemKind::Mod(ref module) => {\n                 self.format_missing_with_indent(item.span.lo);\n                 self.format_mod(module, item.vis, item.span, item.ident);\n             }\n-            ast::Item_::ItemMac(..) => {\n+            ast::ItemKind::Mac(ref mac) => {\n                 self.format_missing_with_indent(item.span.lo);\n-                let snippet = self.snippet(item.span);\n-                self.buffer.push_str(&snippet);\n-                self.last_pos = item.span.hi;\n-                // FIXME: we cannot format these yet, because of a bad span.\n-                // See rust lang issue #28424.\n+                self.visit_mac(mac);\n             }\n-            ast::Item_::ItemForeignMod(ref foreign_mod) => {\n+            ast::ItemKind::ForeignMod(ref foreign_mod) => {\n                 self.format_missing_with_indent(item.span.lo);\n                 self.format_foreign_mod(foreign_mod, item.span);\n             }\n-            ast::Item_::ItemStatic(ref ty, mutability, ref expr) => {\n+            ast::ItemKind::Static(ref ty, mutability, ref expr) => {\n                 let rewrite = rewrite_static(\"static\",\n                                              item.vis,\n                                              item.ident,\n@@ -281,32 +276,32 @@ impl<'a> FmtVisitor<'a> {\n                                              &self.get_context());\n                 self.push_rewrite(item.span, rewrite);\n             }\n-            ast::Item_::ItemConst(ref ty, ref expr) => {\n+            ast::ItemKind::Const(ref ty, ref expr) => {\n                 let rewrite = rewrite_static(\"const\",\n                                              item.vis,\n                                              item.ident,\n                                              ty,\n-                                             ast::Mutability::MutImmutable,\n+                                             ast::Mutability::Immutable,\n                                              expr,\n                                              &self.get_context());\n                 self.push_rewrite(item.span, rewrite);\n             }\n-            ast::Item_::ItemDefaultImpl(..) => {\n+            ast::ItemKind::DefaultImpl(..) => {\n                 // FIXME(#78): format impl definitions.\n             }\n-            ast::ItemFn(ref declaration, unsafety, constness, abi, ref generics, ref body) => {\n+            ast::ItemKind::Fn(ref decl, unsafety, constness, abi, ref generics, ref body) => {\n                 self.visit_fn(visit::FnKind::ItemFn(item.ident,\n                                                     generics,\n                                                     unsafety,\n                                                     constness,\n                                                     abi,\n                                                     item.vis),\n-                              declaration,\n+                              decl,\n                               body,\n                               item.span,\n                               item.id)\n             }\n-            ast::Item_::ItemTy(ref ty, ref generics) => {\n+            ast::ItemKind::Ty(ref ty, ref generics) => {\n                 let rewrite = rewrite_type_alias(&self.get_context(),\n                                                  self.block_indent,\n                                                  item.ident,\n@@ -325,22 +320,22 @@ impl<'a> FmtVisitor<'a> {\n         }\n \n         match ti.node {\n-            ast::ConstTraitItem(..) => {\n+            ast::TraitItemKind::Const(..) => {\n                 // FIXME: Implement\n             }\n-            ast::MethodTraitItem(ref sig, None) => {\n+            ast::TraitItemKind::Method(ref sig, None) => {\n                 let indent = self.block_indent;\n                 let rewrite = self.rewrite_required_fn(indent, ti.ident, sig, ti.span);\n                 self.push_rewrite(ti.span, rewrite);\n             }\n-            ast::MethodTraitItem(ref sig, Some(ref body)) => {\n+            ast::TraitItemKind::Method(ref sig, Some(ref body)) => {\n                 self.visit_fn(visit::FnKind::Method(ti.ident, sig, None),\n                               &sig.decl,\n                               &body,\n                               ti.span,\n                               ti.id);\n             }\n-            ast::TypeTraitItem(ref type_param_bounds, _) => {\n+            ast::TraitItemKind::Type(ref type_param_bounds, _) => {\n                 let indent = self.block_indent;\n                 let mut result = String::new();\n                 result.push_str(&format!(\"type {}\", ti.ident));\n@@ -408,10 +403,7 @@ impl<'a> FmtVisitor<'a> {\n         self.last_pos = span.hi;\n     }\n \n-    pub fn from_codemap(parse_session: &'a ParseSess,\n-                        config: &'a Config,\n-                        mode: Option<WriteMode>)\n-                        -> FmtVisitor<'a> {\n+    pub fn from_codemap(parse_session: &'a ParseSess, config: &'a Config) -> FmtVisitor<'a> {\n         FmtVisitor {\n             parse_session: parse_session,\n             codemap: parse_session.codemap(),\n@@ -422,7 +414,6 @@ impl<'a> FmtVisitor<'a> {\n                 alignment: 0,\n             },\n             config: config,\n-            write_mode: mode,\n         }\n     }\n \n@@ -482,11 +473,19 @@ impl<'a> FmtVisitor<'a> {\n \n         if is_internal {\n             self.buffer.push_str(\" {\");\n-            self.last_pos = ::utils::span_after(s, \"{\", self.codemap);\n-            self.block_indent = self.block_indent.block_indent(self.config);\n-            self.walk_mod_items(m);\n-            self.format_missing_with_indent(m.inner.hi - BytePos(1));\n-            self.close_block();\n+            // Hackery to account for the closing }.\n+            let mod_lo = ::utils::span_after(s, \"{\", self.codemap);\n+            let body_snippet = self.snippet(codemap::mk_sp(mod_lo, m.inner.hi - BytePos(1)));\n+            let body_snippet = body_snippet.trim();\n+            if body_snippet.is_empty() {\n+                self.buffer.push_str(\"}\");\n+            } else {\n+                self.last_pos = mod_lo;\n+                self.block_indent = self.block_indent.block_indent(self.config);\n+                self.walk_mod_items(m);\n+                self.format_missing_with_indent(m.inner.hi - BytePos(1));\n+                self.close_block();\n+            }\n             self.last_pos = m.inner.hi;\n         } else {\n             self.buffer.push_str(\";\");"}, {"sha": "cb4d5da5274878f1f6fb3e45b6d9a4ec48aaba52", "filename": "tests/config/small_tabs.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3163071c75bff08e3ea1b4ed0928933415377ca4/tests%2Fconfig%2Fsmall_tabs.toml", "raw_url": "https://github.com/rust-lang/rust/raw/3163071c75bff08e3ea1b4ed0928933415377ca4/tests%2Fconfig%2Fsmall_tabs.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fconfig%2Fsmall_tabs.toml?ref=3163071c75bff08e3ea1b4ed0928933415377ca4", "patch": "@@ -12,6 +12,7 @@ where_density = \"Tall\"\n where_indent = \"Tabbed\"\n where_layout = \"Vertical\"\n where_pred_indent = \"Visual\"\n+where_trailing_comma = false\n generics_indent = \"Visual\"\n struct_trailing_comma = \"Vertical\"\n struct_lit_trailing_comma = \"Vertical\""}, {"sha": "8cfde87f8c4db2c1c054a83e444e533255bdba78", "filename": "tests/source/comment.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3163071c75bff08e3ea1b4ed0928933415377ca4/tests%2Fsource%2Fcomment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3163071c75bff08e3ea1b4ed0928933415377ca4/tests%2Fsource%2Fcomment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fcomment.rs?ref=3163071c75bff08e3ea1b4ed0928933415377ca4", "patch": "@@ -45,3 +45,5 @@ fn chains() {\n \n /*\n  * random comment */\n+\n+fn main() {/* Test */}"}, {"sha": "c5002f5ec15fd015ff23a5759250791cbd71017c", "filename": "tests/source/expr.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3163071c75bff08e3ea1b4ed0928933415377ca4/tests%2Fsource%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3163071c75bff08e3ea1b4ed0928933415377ca4/tests%2Fsource%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fexpr.rs?ref=3163071c75bff08e3ea1b4ed0928933415377ca4", "patch": "@@ -233,3 +233,14 @@ fn blocks() {\n         println!(\"yay arithmetix!\");\n     };\n }\n+\n+fn issue767() {\n+    if false {\n+        if false {\n+        } else {\n+            // A let binding here seems necessary to trigger it.\n+            let _ = ();\n+        }\n+    } else if let false = false {\n+    }\n+}"}, {"sha": "6d7f764d28002150f69a6e58e1cbccafce703263", "filename": "tests/source/fn-single-line.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3163071c75bff08e3ea1b4ed0928933415377ca4/tests%2Fsource%2Ffn-single-line.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3163071c75bff08e3ea1b4ed0928933415377ca4/tests%2Fsource%2Ffn-single-line.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Ffn-single-line.rs?ref=3163071c75bff08e3ea1b4ed0928933415377ca4", "patch": "@@ -74,3 +74,6 @@ trait CoolTypes {\n trait CoolerTypes { fn dummy(&self) { \n }\n }\n+\n+fn Foo<T>() where T: Bar {\n+}"}, {"sha": "d04b5ce1eebd6969f9f5cd26111ef7bd844aa7a3", "filename": "tests/source/impls.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3163071c75bff08e3ea1b4ed0928933415377ca4/tests%2Fsource%2Fimpls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3163071c75bff08e3ea1b4ed0928933415377ca4/tests%2Fsource%2Fimpls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fimpls.rs?ref=3163071c75bff08e3ea1b4ed0928933415377ca4", "patch": "@@ -22,6 +22,12 @@ impl<'a, 'b, X, Y: Foo<Bar>> Foo<'a, X> for Bar<'b, Y> where X: Fooooooooooooooo\n     fn foo() { \"hi\" }    \n }\n \n+impl<T> Foo for Bar<T> where T: Baz \n+{\n+}\n+\n+impl<T> Foo for Bar<T> where T: Baz { /* Comment */ }\n+\n impl Foo {\n     fn foo() {}\n }\n@@ -64,3 +70,10 @@ impl X { fn do_parse(  mut  self : X ) {} }\n impl Y5000 {\n     fn bar(self: X< 'a ,  'b >, y: Y) {}\n }\n+\n+pub impl<T> Foo for Bar<T> where T: Foo\n+{\n+    fn foo() { \"hi\" }\n+}\n+\n+pub impl<T, Z> Foo for Bar<T, Z> where T: Foo, Z: Baz {}"}, {"sha": "cc713af3f18bdc14f7a8da5454ddff861008ce8c", "filename": "tests/source/issue-447.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/3163071c75bff08e3ea1b4ed0928933415377ca4/tests%2Fsource%2Fissue-447.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3163071c75bff08e3ea1b4ed0928933415377ca4/tests%2Fsource%2Fissue-447.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fissue-447.rs?ref=3163071c75bff08e3ea1b4ed0928933415377ca4", "patch": "@@ -0,0 +1,37 @@\n+fn main() {\n+\tif /* shouldn't be dropped\n+\tshouldn't be dropped */\n+\t\n+\tcond /* shouldn't be dropped\n+\tshouldn't be dropped */\n+\t\n+\t{\n+\t} /* shouldn't be dropped\n+\tshouldn't be dropped */\n+\t\n+\telse /* shouldn't be dropped\n+\tshouldn't be dropped */\n+\t\n+\tif /* shouldn't be dropped\n+\tshouldn't be dropped */\n+\t\n+\tcond /* shouldn't be dropped\n+\tshouldn't be dropped */\n+\t\n+\t{\n+\t} /* shouldn't be dropped\n+\tshouldn't be dropped */\n+\t\n+\telse /* shouldn't be dropped\n+\tshouldn't be dropped */\n+\t\n+\t{\n+\t}\n+\t\n+\tif /* shouldn't be dropped\n+\tshouldn't be dropped */\n+\tlet Some(x) = y/* shouldn't be dropped\n+\tshouldn't be dropped */\n+\t{\n+\t}\n+}"}, {"sha": "b7a89b5d0f9dc3a10abced001a68abd4d9e864c8", "filename": "tests/source/issue-811.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/3163071c75bff08e3ea1b4ed0928933415377ca4/tests%2Fsource%2Fissue-811.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3163071c75bff08e3ea1b4ed0928933415377ca4/tests%2Fsource%2Fissue-811.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fissue-811.rs?ref=3163071c75bff08e3ea1b4ed0928933415377ca4", "patch": "@@ -0,0 +1,19 @@\n+trait FooTrait<T>: Sized {\n+    type Bar: BarTrait<T>;\n+}\n+\n+trait BarTrait<T>: Sized {\n+    type Baz;\n+    fn foo();\n+}\n+\n+type Foo<T: FooTrait> = <<T as FooTrait<U>>::Bar as BarTrait<U>>::Baz;\n+type Bar<T: BarTrait> = <T as BarTrait<U>>::Baz;\n+\n+fn some_func<T: FooTrait<U>, U>() {\n+    <<T as FooTrait<U>>::Bar as BarTrait<U>>::foo();\n+}\n+\n+fn some_func<T: BarTrait<U>>() {\n+    <T as BarTrait<U>>::foo();\n+}"}, {"sha": "c939716a6a881d2a5063ab0b27c8d7db01ccf73d", "filename": "tests/source/issue-850.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3163071c75bff08e3ea1b4ed0928933415377ca4/tests%2Fsource%2Fissue-850.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3163071c75bff08e3ea1b4ed0928933415377ca4/tests%2Fsource%2Fissue-850.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fissue-850.rs?ref=3163071c75bff08e3ea1b4ed0928933415377ca4", "patch": "@@ -0,0 +1 @@\n+const unsafe fn x() {}"}, {"sha": "261f02e756f57540b74983953fba5c81b0997faf", "filename": "tests/source/macros.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3163071c75bff08e3ea1b4ed0928933415377ca4/tests%2Fsource%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3163071c75bff08e3ea1b4ed0928933415377ca4/tests%2Fsource%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fmacros.rs?ref=3163071c75bff08e3ea1b4ed0928933415377ca4", "patch": "@@ -1,4 +1,8 @@\n-itemmacro!(this, is.not() .formatted(yet));\n+itemmacro!(this, is.now() .formatted(yay));\n+\n+itemmacro!(really, long.aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabbb() .is.formatted());\n+\n+itemmacro!{this, is.bracket().formatted()}\n \n fn main() {\n     foo! ( );"}, {"sha": "75f65806167b5aee82b2be66b129bae93b6c49a0", "filename": "tests/source/pattern.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3163071c75bff08e3ea1b4ed0928933415377ca4/tests%2Fsource%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3163071c75bff08e3ea1b4ed0928933415377ca4/tests%2Fsource%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fpattern.rs?ref=3163071c75bff08e3ea1b4ed0928933415377ca4", "patch": "@@ -11,6 +11,20 @@ fn main() {\n     let Some ( ref   xyz  /*   comment!   */) = opt;\n \n     if let  None  =   opt2 { panic!(\"oh noes\"); }\n+\n+    let foo@bar (f) = 42;\n+    let a::foo ( ..) = 42;\n+    let [ ] = 42;\n+    let [a..,     b,c ] = 42;\n+    let [ a,b,c.. ] = 42;\n+    let [a,    b, c, d..,e,f,     g] = 42;\n+    let foo {   } = 42;\n+    let foo {..} = 42;\n+    let foo { x, y: ref foo,     .. } = 42;\n+    let foo { x, yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy: ref foo,     .. } = 42;\n+    let foo { x,       yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy: ref foo,      } = 42;\n+    let foo { x, yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy: ref foo,     .. };\n+    let foo { x,       yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy: ref foo,      };\n }\n \n impl<'a,'b> ResolveGeneratedContentFragmentMutator<'a,'b> {"}, {"sha": "8ba60ccac1d1269b6a312b4079ba3ab582aa0bac", "filename": "tests/source/string-lit-2.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3163071c75bff08e3ea1b4ed0928933415377ca4/tests%2Fsource%2Fstring-lit-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3163071c75bff08e3ea1b4ed0928933415377ca4/tests%2Fsource%2Fstring-lit-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fstring-lit-2.rs?ref=3163071c75bff08e3ea1b4ed0928933415377ca4", "patch": "@@ -0,0 +1,14 @@\n+fn main() -> &'static str {\n+    let too_many_lines = \"H\\\n+                          e\\\n+                          l\\\n+                          l\\\n+                          o\";\n+    let leave_me = \"sssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss\\\n+                    s\n+                    jjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjj\";\n+    // Crappy formatting :-(\n+    let change_me = \"ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss\\\n+                     s\n+                     jjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjj\";\n+}"}, {"sha": "ca8aa36a90d8f63295e564ffd5b10f8c472f7ceb", "filename": "tests/source/string-lit.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3163071c75bff08e3ea1b4ed0928933415377ca4/tests%2Fsource%2Fstring-lit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3163071c75bff08e3ea1b4ed0928933415377ca4/tests%2Fsource%2Fstring-lit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fstring-lit.rs?ref=3163071c75bff08e3ea1b4ed0928933415377ca4", "patch": "@@ -1,3 +1,4 @@\n+// rustfmt-force_format_strings: true\n // Long string literals\n \n fn main() -> &'static str {"}, {"sha": "c62a355c5ddf2e8bb81d18b1512ff789f99a6b6d", "filename": "tests/source/struct_lits.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3163071c75bff08e3ea1b4ed0928933415377ca4/tests%2Fsource%2Fstruct_lits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3163071c75bff08e3ea1b4ed0928933415377ca4/tests%2Fsource%2Fstruct_lits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fstruct_lits.rs?ref=3163071c75bff08e3ea1b4ed0928933415377ca4", "patch": "@@ -114,3 +114,12 @@ fn issue491() {\n     Foo { a: aaaaaaaaaa, b: bbbbbbbb, c: cccccccccc, d: dddddddddd, /* a comment */\n       e: eeeeeeeee };\n }\n+\n+fn issue698() {\n+    Record {\n+        ffffffffffffffffffffffffffields: aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa,\n+    };\n+    Record {\n+        ffffffffffffffffffffffffffields: aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa,\n+    }\n+}"}, {"sha": "29c2f5a4e3bfe2939967b21a7750d9263a289ea4", "filename": "tests/source/type-punctuation.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3163071c75bff08e3ea1b4ed0928933415377ca4/tests%2Fsource%2Ftype-punctuation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3163071c75bff08e3ea1b4ed0928933415377ca4/tests%2Fsource%2Ftype-punctuation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Ftype-punctuation.rs?ref=3163071c75bff08e3ea1b4ed0928933415377ca4", "patch": "@@ -0,0 +1,5 @@\n+// rustfmt-type_punctuation_density: Compressed\n+\n+fn Foo<T = Foo, Output = Expr<'tcx> + Foo>() {\n+    let i = 6;\n+}"}, {"sha": "8f951d199e42b447135fb4646c2bbe9a7522a81d", "filename": "tests/source/where-trailing-comma.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/3163071c75bff08e3ea1b4ed0928933415377ca4/tests%2Fsource%2Fwhere-trailing-comma.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3163071c75bff08e3ea1b4ed0928933415377ca4/tests%2Fsource%2Fwhere-trailing-comma.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fwhere-trailing-comma.rs?ref=3163071c75bff08e3ea1b4ed0928933415377ca4", "patch": "@@ -0,0 +1,37 @@\n+// rustfmt-where_trailing_comma: true\n+\n+fn f<S, T>(x: T, y: S) -> T where T: P, S: Q\n+{\n+    x\n+}\n+\n+impl Trait for T where T: P\n+{\n+    fn f(x: T) -> T where T: Q + R\n+    {\n+        x\n+    }\n+}\n+\n+struct Pair<S, T> where T: P, S: P + Q {\n+    a: T,\n+    b: S\n+}\n+\n+struct TupPair<S, T> (S, T) where T: P, S: P + Q;\n+\n+enum E<S, T> where S: P, T: P { \n+    A {a: T},\n+}\n+\n+type Double<T> where T: P, T: Q = Pair<T, T>;\n+\n+extern \"C\" {\n+    fn f<S, T>(x: T, y: S) -> T where T: P, S: Q;\n+}\n+\n+// Note: trait declarations are not fully formatted (issue #78)\n+trait Q<S, T> where T: P, S: R\n+{\n+    fn f<U, V>(self, x: T, y: S, z: U) -> Self where U: P, V: P;\n+}"}, {"sha": "bc5298ae22db1de3744e55b0fad6545c38540754", "filename": "tests/system.rs", "status": "modified", "additions": 95, "deletions": 40, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/3163071c75bff08e3ea1b4ed0928933415377ca4/tests%2Fsystem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3163071c75bff08e3ea1b4ed0928933415377ca4/tests%2Fsystem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsystem.rs?ref=3163071c75bff08e3ea1b4ed0928933415377ca4", "patch": "@@ -19,15 +19,16 @@ use std::io::{self, Read, BufRead, BufReader};\n use std::path::Path;\n \n use rustfmt::*;\n-use rustfmt::config::{Config, ReportTactic};\n+use rustfmt::filemap::{write_system_newlines, FileMap};\n+use rustfmt::config::{Config, ReportTactic, WriteMode};\n use rustfmt::rustfmt_diff::*;\n \n-static DIFF_CONTEXT_SIZE: usize = 3;\n+const DIFF_CONTEXT_SIZE: usize = 3;\n \n fn get_path_string(dir_entry: io::Result<fs::DirEntry>) -> String {\n-    let path = dir_entry.ok().expect(\"Couldn't get DirEntry.\").path();\n+    let path = dir_entry.expect(\"Couldn't get DirEntry\").path();\n \n-    path.to_str().expect(\"Couldn't stringify path.\").to_owned()\n+    path.to_str().expect(\"Couldn't stringify path\").to_owned()\n }\n \n // Integration tests. The files in the tests/source are formatted and compared\n@@ -39,11 +40,11 @@ fn get_path_string(dir_entry: io::Result<fs::DirEntry>) -> String {\n #[test]\n fn system_tests() {\n     // Get all files in the tests/source directory.\n-    let files = fs::read_dir(\"tests/source\").ok().expect(\"Couldn't read source dir.\");\n+    let files = fs::read_dir(\"tests/source\").expect(\"Couldn't read source dir\");\n     // Turn a DirEntry into a String that represents the relative path to the\n     // file.\n     let files = files.map(get_path_string);\n-    let (_reports, count, fails) = check_files(files, WriteMode::Return);\n+    let (_reports, count, fails) = check_files(files, None);\n \n     // Display results.\n     println!(\"Ran {} system tests.\", count);\n@@ -54,24 +55,60 @@ fn system_tests() {\n // the only difference is the coverage mode\n #[test]\n fn coverage_tests() {\n-    let files = fs::read_dir(\"tests/coverage-source\").ok().expect(\"Couldn't read source dir.\");\n+    let files = fs::read_dir(\"tests/coverage-source\").expect(\"Couldn't read source dir\");\n     let files = files.map(get_path_string);\n-    let (_reports, count, fails) = check_files(files, WriteMode::Coverage);\n+    let (_reports, count, fails) = check_files(files, Some(WriteMode::Coverage));\n \n     println!(\"Ran {} tests in coverage mode.\", count);\n     assert!(fails == 0, \"{} tests failed\", fails);\n }\n \n+#[test]\n+fn checkstyle_test() {\n+    let filename = \"tests/source/fn-single-line.rs\";\n+    let expected_filename = \"tests/writemode/checkstyle.xml\";\n+    assert_output(filename, expected_filename, Some(WriteMode::Checkstyle));\n+}\n+\n+\n+// Helper function for comparing the results of rustfmt\n+// to a known output file generated by one of the write modes.\n+fn assert_output(source: &str, expected_filename: &str, write_mode: Option<WriteMode>) {\n+    let file_map = run_rustfmt(source.to_string(), write_mode);\n+\n+    let mut config = read_config(&source);\n+    if let Some(write_mode) = write_mode {\n+        config.write_mode = write_mode;\n+    }\n+\n+    // Populate output by writing to a vec.\n+    let mut out = vec![];\n+    let _ = filemap::write_all_files(&file_map, &mut out, &config);\n+    let output = String::from_utf8(out).unwrap();\n+\n+    let mut expected_file = fs::File::open(&expected_filename).expect(\"Couldn't open target\");\n+    let mut expected_text = String::new();\n+    expected_file.read_to_string(&mut expected_text)\n+                 .expect(\"Failed reading target\");\n+\n+    let compare = make_diff(&expected_text, &output, DIFF_CONTEXT_SIZE);\n+    if compare.len() > 0 {\n+        let mut failures = HashMap::new();\n+        failures.insert(source.to_string(), compare);\n+        print_mismatches(failures);\n+        assert!(false, \"Text does not match expected output\");\n+    }\n+}\n+\n // Idempotence tests. Files in tests/target are checked to be unaltered by\n // rustfmt.\n #[test]\n fn idempotence_tests() {\n     // Get all files in the tests/target directory.\n     let files = fs::read_dir(\"tests/target\")\n-                    .ok()\n-                    .expect(\"Couldn't read target dir.\")\n+                    .expect(\"Couldn't read target dir\")\n                     .map(get_path_string);\n-    let (_reports, count, fails) = check_files(files, WriteMode::Return);\n+    let (_reports, count, fails) = check_files(files, None);\n \n     // Display results.\n     println!(\"Ran {} idempotent tests.\", count);\n@@ -83,14 +120,13 @@ fn idempotence_tests() {\n #[test]\n fn self_tests() {\n     let files = fs::read_dir(\"src/bin\")\n-                    .ok()\n-                    .expect(\"Couldn't read src dir.\")\n-                    .chain(fs::read_dir(\"tests\").ok().expect(\"Couldn't read tests dir.\"))\n+                    .expect(\"Couldn't read src dir\")\n+                    .chain(fs::read_dir(\"tests\").expect(\"Couldn't read tests dir\"))\n                     .map(get_path_string);\n     // Hack because there's no `IntoIterator` impl for `[T; N]`.\n     let files = files.chain(Some(\"src/lib.rs\".to_owned()).into_iter());\n \n-    let (reports, count, fails) = check_files(files, WriteMode::Return);\n+    let (reports, count, fails) = check_files(files, None);\n     let mut warnings = 0;\n \n     // Display results.\n@@ -109,7 +145,7 @@ fn self_tests() {\n \n // For each file, run rustfmt and collect the output.\n // Returns the number of files checked and the number of failures.\n-fn check_files<I>(files: I, write_mode: WriteMode) -> (Vec<FormatReport>, u32, u32)\n+fn check_files<I>(files: I, write_mode: Option<WriteMode>) -> (Vec<FormatReport>, u32, u32)\n     where I: Iterator<Item = String>\n {\n     let mut count = 0;\n@@ -144,9 +180,7 @@ fn print_mismatches(result: HashMap<String, Vec<Mismatch>>) {\n     assert!(t.reset().unwrap());\n }\n \n-pub fn idempotent_check(filename: String,\n-                        write_mode: WriteMode)\n-                        -> Result<FormatReport, HashMap<String, Vec<Mismatch>>> {\n+fn read_config(filename: &str) -> Config {\n     let sig_comments = read_significant_comments(&filename);\n     let mut config = get_config(sig_comments.get(\"config\").map(|x| &(*x)[..]));\n \n@@ -158,12 +192,36 @@ pub fn idempotent_check(filename: String,\n \n     // Don't generate warnings for to-do items.\n     config.report_todo = ReportTactic::Never;\n+    config\n+}\n+\n+// Simulate run()\n+fn run_rustfmt(filename: String, write_mode: Option<WriteMode>) -> FileMap {\n+    let mut config = read_config(&filename);\n+    if let Some(write_mode) = write_mode {\n+        config.write_mode = write_mode;\n+    }\n+    format(Path::new(&filename), &config)\n+}\n \n-    let mut file_map = format(Path::new(&filename), &config, write_mode);\n+pub fn idempotent_check(filename: String,\n+                        write_mode: Option<WriteMode>)\n+                        -> Result<FormatReport, HashMap<String, Vec<Mismatch>>> {\n+    let sig_comments = read_significant_comments(&filename);\n+    let config = read_config(&filename);\n+    let mut file_map = run_rustfmt(filename, write_mode);\n     let format_report = fmt_lines(&mut file_map, &config);\n \n-    // Won't panic, as we're not doing any IO.\n-    let write_result = filemap::write_all_files(&file_map, WriteMode::Return, &config).unwrap();\n+    let mut write_result = HashMap::new();\n+    for (filename, text) in file_map.iter() {\n+        let mut v = Vec::new();\n+        // Won't panic, as we're not doing any IO.\n+        write_system_newlines(&mut v, text, &config).unwrap();\n+        // Won't panic, we are writing correct utf8.\n+        let one_result = String::from_utf8(v).unwrap();\n+        write_result.insert(filename.clone(), one_result);\n+    }\n+\n     let target = sig_comments.get(\"target\").map(|x| &(*x)[..]);\n \n     handle_result(write_result, target, write_mode).map(|_| format_report)\n@@ -180,37 +238,32 @@ fn get_config(config_file: Option<&str>) -> Config {\n         }\n     };\n \n-    let mut def_config_file = fs::File::open(config_file_name)\n-                                  .ok()\n-                                  .expect(\"Couldn't open config.\");\n+    let mut def_config_file = fs::File::open(config_file_name).expect(\"Couldn't open config\");\n     let mut def_config = String::new();\n-    def_config_file.read_to_string(&mut def_config).ok().expect(\"Couldn't read config.\");\n+    def_config_file.read_to_string(&mut def_config).expect(\"Couldn't read config\");\n \n     Config::from_toml(&def_config)\n }\n \n // Reads significant comments of the form: // rustfmt-key: value\n // into a hash map.\n fn read_significant_comments(file_name: &str) -> HashMap<String, String> {\n-    let file = fs::File::open(file_name)\n-                   .ok()\n-                   .expect(&format!(\"Couldn't read file {}.\", file_name));\n+    let file = fs::File::open(file_name).expect(&format!(\"Couldn't read file {}\", file_name));\n     let reader = BufReader::new(file);\n     let pattern = r\"^\\s*//\\s*rustfmt-([^:]+):\\s*(\\S+)\";\n-    let regex = regex::Regex::new(&pattern).ok().expect(\"Failed creating pattern 1.\");\n+    let regex = regex::Regex::new(&pattern).expect(\"Failed creating pattern 1\");\n \n     // Matches lines containing significant comments or whitespace.\n     let line_regex = regex::Regex::new(r\"(^\\s*$)|(^\\s*//\\s*rustfmt-[^:]+:\\s*\\S+)\")\n-                         .ok()\n-                         .expect(\"Failed creating pattern 2.\");\n+                         .expect(\"Failed creating pattern 2\");\n \n     reader.lines()\n-          .map(|line| line.ok().expect(\"Failed getting line.\"))\n+          .map(|line| line.expect(\"Failed getting line\"))\n           .take_while(|line| line_regex.is_match(&line))\n           .filter_map(|line| {\n               regex.captures_iter(&line).next().map(|capture| {\n-                  (capture.at(1).expect(\"Couldn't unwrap capture.\").to_owned(),\n-                   capture.at(2).expect(\"Couldn't unwrap capture.\").to_owned())\n+                  (capture.at(1).expect(\"Couldn't unwrap capture\").to_owned(),\n+                   capture.at(2).expect(\"Couldn't unwrap capture\").to_owned())\n               })\n           })\n           .collect()\n@@ -220,20 +273,22 @@ fn read_significant_comments(file_name: &str) -> HashMap<String, String> {\n // TODO: needs a better name, more explanation.\n fn handle_result(result: HashMap<String, String>,\n                  target: Option<&str>,\n-                 write_mode: WriteMode)\n+                 write_mode: Option<WriteMode>)\n                  -> Result<(), HashMap<String, Vec<Mismatch>>> {\n     let mut failures = HashMap::new();\n \n     for (file_name, fmt_text) in result {\n         // If file is in tests/source, compare to file with same name in tests/target.\n         let target = get_target(&file_name, target, write_mode);\n-        let mut f = fs::File::open(&target).ok().expect(\"Couldn't open target.\");\n+        let mut f = fs::File::open(&target).expect(\"Couldn't open target\");\n \n         let mut text = String::new();\n-        f.read_to_string(&mut text).ok().expect(\"Failed reading target.\");\n+        f.read_to_string(&mut text).expect(\"Failed reading target\");\n \n         if fmt_text != text {\n             let diff = make_diff(&text, &fmt_text, DIFF_CONTEXT_SIZE);\n+            assert!(!diff.is_empty(),\n+                    \"Empty diff? Maybe due to a missing a newline at the end of a file?\");\n             failures.insert(file_name, diff);\n         }\n     }\n@@ -246,10 +301,10 @@ fn handle_result(result: HashMap<String, String>,\n }\n \n // Map source file paths to their target paths.\n-fn get_target(file_name: &str, target: Option<&str>, write_mode: WriteMode) -> String {\n+fn get_target(file_name: &str, target: Option<&str>, write_mode: Option<WriteMode>) -> String {\n     let file_path = Path::new(file_name);\n     let (source_path_prefix, target_path_prefix) = match write_mode {\n-        WriteMode::Coverage => {\n+        Some(WriteMode::Coverage) => {\n             (Path::new(\"tests/coverage-source/\"),\n              \"tests/coverage-target/\")\n         }"}, {"sha": "815620234b51437a906fed0399c02aba79c9f087", "filename": "tests/target/chains-no-overlow-2.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3163071c75bff08e3ea1b4ed0928933415377ca4/tests%2Ftarget%2Fchains-no-overlow-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3163071c75bff08e3ea1b4ed0928933415377ca4/tests%2Ftarget%2Fchains-no-overlow-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fchains-no-overlow-2.rs?ref=3163071c75bff08e3ea1b4ed0928933415377ca4", "patch": "@@ -2,14 +2,14 @@\n \n fn main() {\n     reader.lines()\n-          .map(|line| line.ok().expect(\"Failed getting line.\"))\n+          .map(|line| line.expect(\"Failed getting line\"))\n           .take_while(|line| line_regex.is_match(&line))\n           .filter_map(|line| {\n               regex.captures_iter(&line)\n                    .next()\n                    .map(|capture| {\n-                       (capture.at(1).expect(\"Couldn\\'t unwrap capture.\").to_owned(),\n-                        capture.at(2).expect(\"Couldn\\'t unwrap capture.\").to_owned())\n+                       (capture.at(1).expect(\"Couldn\\'t unwrap capture\").to_owned(),\n+                        capture.at(2).expect(\"Couldn\\'t unwrap capture\").to_owned())\n                    })\n           })\n           .collect();"}, {"sha": "646b37e46e2e80d4b1427cb32609d21d88a700f5", "filename": "tests/target/comment-not-disappear.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3163071c75bff08e3ea1b4ed0928933415377ca4/tests%2Ftarget%2Fcomment-not-disappear.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3163071c75bff08e3ea1b4ed0928933415377ca4/tests%2Ftarget%2Fcomment-not-disappear.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fcomment-not-disappear.rs?ref=3163071c75bff08e3ea1b4ed0928933415377ca4", "patch": "@@ -28,12 +28,6 @@ fn foo() -> Vec<i32> {\n         .collect()\n }\n \n-fn d() {\n-    if true /* and ... */ {\n-        a();\n-    }\n-}\n-\n fn calc_page_len(prefix_len: usize, sofar: usize) -> usize {\n     2 // page type and flags\n     + 1 // stored depth"}, {"sha": "98815ac5403783946bab9423644e5315b28132fe", "filename": "tests/target/comment.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3163071c75bff08e3ea1b4ed0928933415377ca4/tests%2Ftarget%2Fcomment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3163071c75bff08e3ea1b4ed0928933415377ca4/tests%2Ftarget%2Fcomment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fcomment.rs?ref=3163071c75bff08e3ea1b4ed0928933415377ca4", "patch": "@@ -46,3 +46,7 @@ fn chains() {\n }\n \n // random comment\n+\n+fn main() {\n+    // Test\n+}"}, {"sha": "04f84a15c957b53bac90f5f3461b98885272edc9", "filename": "tests/target/comment2.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3163071c75bff08e3ea1b4ed0928933415377ca4/tests%2Ftarget%2Fcomment2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3163071c75bff08e3ea1b4ed0928933415377ca4/tests%2Ftarget%2Fcomment2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fcomment2.rs?ref=3163071c75bff08e3ea1b4ed0928933415377ca4", "patch": "@@ -2,5 +2,4 @@\n \n /// This is a long line that angers rustfmt. Rustfmt shall deal with it swiftly\n /// and justly.\n-pub mod foo {\n-}\n+pub mod foo {}"}, {"sha": "3a810590d7b3c820719ad3db9a89e15264115498", "filename": "tests/target/comment3.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3163071c75bff08e3ea1b4ed0928933415377ca4/tests%2Ftarget%2Fcomment3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3163071c75bff08e3ea1b4ed0928933415377ca4/tests%2Ftarget%2Fcomment3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fcomment3.rs?ref=3163071c75bff08e3ea1b4ed0928933415377ca4", "patch": "@@ -3,5 +3,4 @@\n //! This is a long line that angers rustfmt. Rustfmt shall deal with it swiftly\n //! and justly.\n \n-pub mod foo {\n-}\n+pub mod foo {}"}, {"sha": "9c9c65a690cdc0505521f5136e0906e8c57c3742", "filename": "tests/target/expr.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3163071c75bff08e3ea1b4ed0928933415377ca4/tests%2Ftarget%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3163071c75bff08e3ea1b4ed0928933415377ca4/tests%2Ftarget%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fexpr.rs?ref=3163071c75bff08e3ea1b4ed0928933415377ca4", "patch": "@@ -256,3 +256,14 @@ fn blocks() {\n         println!(\"yay arithmetix!\");\n     };\n }\n+\n+fn issue767() {\n+    if false {\n+        if false {\n+        } else {\n+            // A let binding here seems necessary to trigger it.\n+            let _ = ();\n+        }\n+    } else if let false = false {\n+    }\n+}"}, {"sha": "049206b60c8b21b6c859308125f062e6fa2f87d0", "filename": "tests/target/fn-single-line.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3163071c75bff08e3ea1b4ed0928933415377ca4/tests%2Ftarget%2Ffn-single-line.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3163071c75bff08e3ea1b4ed0928933415377ca4/tests%2Ftarget%2Ffn-single-line.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Ffn-single-line.rs?ref=3163071c75bff08e3ea1b4ed0928933415377ca4", "patch": "@@ -61,3 +61,5 @@ trait CoolTypes {\n trait CoolerTypes {\n     fn dummy(&self) {}\n }\n+\n+fn Foo<T>() where T: Bar {}"}, {"sha": "02600f43f2a695195d427019269bc56fcdae6d05", "filename": "tests/target/fn.rs", "status": "modified", "additions": 3, "deletions": 14, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/3163071c75bff08e3ea1b4ed0928933415377ca4/tests%2Ftarget%2Ffn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3163071c75bff08e3ea1b4ed0928933415377ca4/tests%2Ftarget%2Ffn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Ffn.rs?ref=3163071c75bff08e3ea1b4ed0928933415377ca4", "patch": "@@ -2,17 +2,9 @@\n \n fn foo(a: AAAA, b: BBB, c: CCC) -> RetType {}\n \n-fn foo(a: AAAA, b: BBB /* some, weird, inline comment */, c: CCC) -> RetType\n-    where T: Blah\n-{\n+fn foo(a: AAAA, b: BBB /* some, weird, inline comment */, c: CCC) -> RetType where T: Blah {}\n \n-}\n-\n-fn foo(a: AAA /* (comment) */)\n-    where T: Blah\n-{\n-\n-}\n+fn foo(a: AAA /* (comment) */) where T: Blah {}\n \n fn foo(a: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA,\n        b: BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB)\n@@ -35,10 +27,7 @@ fn foo<U, T>(a: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA,\n fn foo<U: Fn(A) -> B /* paren inside generics */>() {}\n \n impl Foo {\n-    fn with_no_errors<T, F>(&mut self, f: F) -> T\n-        where F: FnOnce(&mut Resolver) -> T\n-    {\n-    }\n+    fn with_no_errors<T, F>(&mut self, f: F) -> T where F: FnOnce(&mut Resolver) -> T {}\n \n     fn foo(mut self, mut bar: u32) {}\n "}, {"sha": "33bc7481905016f1b9dd3aa3ec38082a3ebbab0a", "filename": "tests/target/impls.rs", "status": "modified", "additions": 26, "deletions": 2, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/3163071c75bff08e3ea1b4ed0928933415377ca4/tests%2Ftarget%2Fimpls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3163071c75bff08e3ea1b4ed0928933415377ca4/tests%2Ftarget%2Fimpls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fimpls.rs?ref=3163071c75bff08e3ea1b4ed0928933415377ca4", "patch": "@@ -16,7 +16,8 @@ pub impl Foo for Bar {\n     // Comment 3\n }\n \n-pub unsafe impl<'a, 'b, X, Y: Foo<Bar>> !Foo<'a, X> for Bar<'b, Y> where X: Foo<'a, Z>\n+pub unsafe impl<'a, 'b, X, Y: Foo<Bar>> !Foo<'a, X> for Bar<'b, Y>\n+    where X: Foo<'a, Z>\n {\n     fn foo() {\n         \"hi\"\n@@ -31,13 +32,22 @@ impl<'a, 'b, X, Y: Foo<Bar>> Foo<'a, X> for Bar<'b, Y>\n     }\n }\n \n-impl<'a, 'b, X, Y: Foo<Bar>> Foo<'a, X> for Bar<'b, Y> where X: Foooooooooooooooooooooooooooo<'a, Z>\n+impl<'a, 'b, X, Y: Foo<Bar>> Foo<'a, X> for Bar<'b, Y>\n+    where X: Foooooooooooooooooooooooooooo<'a, Z>\n {\n     fn foo() {\n         \"hi\"\n     }\n }\n \n+impl<T> Foo for Bar<T> where T: Baz {}\n+\n+impl<T> Foo for Bar<T>\n+    where T: Baz\n+{\n+    // Comment\n+}\n+\n impl Foo {\n     fn foo() {}\n }\n@@ -80,3 +90,17 @@ impl X {\n impl Y5000 {\n     fn bar(self: X<'a, 'b>, y: Y) {}\n }\n+\n+pub impl<T> Foo for Bar<T>\n+    where T: Foo\n+{\n+    fn foo() {\n+        \"hi\"\n+    }\n+}\n+\n+pub impl<T, Z> Foo for Bar<T, Z>\n+    where T: Foo,\n+          Z: Baz\n+{\n+}"}, {"sha": "7e69c708eb7e71d64862d944df31fa42e960c32e", "filename": "tests/target/issue-447.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/3163071c75bff08e3ea1b4ed0928933415377ca4/tests%2Ftarget%2Fissue-447.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3163071c75bff08e3ea1b4ed0928933415377ca4/tests%2Ftarget%2Fissue-447.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fissue-447.rs?ref=3163071c75bff08e3ea1b4ed0928933415377ca4", "patch": "@@ -0,0 +1,39 @@\n+fn main() {\n+    if\n+    // shouldn't be dropped\n+    // shouldn't be dropped\n+    cond\n+    // shouldn't be dropped\n+    // shouldn't be dropped\n+    {\n+    }\n+    // shouldn't be dropped\n+    // shouldn't be dropped\n+    else\n+    // shouldn't be dropped\n+    // shouldn't be dropped\n+    if\n+    // shouldn't be dropped\n+    // shouldn't be dropped\n+    cond\n+    // shouldn't be dropped\n+    // shouldn't be dropped\n+    {\n+    }\n+    // shouldn't be dropped\n+    // shouldn't be dropped\n+    else\n+    // shouldn't be dropped\n+    // shouldn't be dropped\n+    {\n+    }\n+\n+    if\n+    // shouldn't be dropped\n+    // shouldn't be dropped\n+    let Some(x) = y\n+    // shouldn't be dropped\n+    // shouldn't be dropped\n+    {\n+    }\n+}"}, {"sha": "2b58c06941d93709d72880b03644b7bf481fdabe", "filename": "tests/target/issue-811.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3163071c75bff08e3ea1b4ed0928933415377ca4/tests%2Ftarget%2Fissue-811.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3163071c75bff08e3ea1b4ed0928933415377ca4/tests%2Ftarget%2Fissue-811.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fissue-811.rs?ref=3163071c75bff08e3ea1b4ed0928933415377ca4", "patch": "@@ -0,0 +1,20 @@\n+trait FooTrait<T>: Sized {\n+    type Bar: BarTrait<T>;\n+}\n+\n+trait BarTrait<T>: Sized {\n+    type Baz;\n+    fn foo();\n+}\n+\n+type Foo<T: FooTrait> =\n+    <<T as FooTrait<U>>::Bar as BarTrait<U>>::Baz;\n+type Bar<T: BarTrait> = <T as BarTrait<U>>::Baz;\n+\n+fn some_func<T: FooTrait<U>, U>() {\n+    <<T as FooTrait<U>>::Bar as BarTrait<U>>::foo();\n+}\n+\n+fn some_func<T: BarTrait<U>>() {\n+    <T as BarTrait<U>>::foo();\n+}"}, {"sha": "c939716a6a881d2a5063ab0b27c8d7db01ccf73d", "filename": "tests/target/issue-850.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3163071c75bff08e3ea1b4ed0928933415377ca4/tests%2Ftarget%2Fissue-850.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3163071c75bff08e3ea1b4ed0928933415377ca4/tests%2Ftarget%2Fissue-850.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fissue-850.rs?ref=3163071c75bff08e3ea1b4ed0928933415377ca4", "patch": "@@ -0,0 +1 @@\n+const unsafe fn x() {}"}, {"sha": "4d99ede9f5054a91377fa2e03462000fe67b205f", "filename": "tests/target/macros.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3163071c75bff08e3ea1b4ed0928933415377ca4/tests%2Ftarget%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3163071c75bff08e3ea1b4ed0928933415377ca4/tests%2Ftarget%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fmacros.rs?ref=3163071c75bff08e3ea1b4ed0928933415377ca4", "patch": "@@ -1,4 +1,11 @@\n-itemmacro!(this, is.not() .formatted(yet));\n+itemmacro!(this, is.now().formatted(yay));\n+\n+itemmacro!(really,\n+           long.aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabbb()\n+               .is\n+               .formatted());\n+\n+itemmacro!{this, is.bracket().formatted()}\n \n fn main() {\n     foo!();"}, {"sha": "defcc13ef51adacbaefff2e558ba522bffc331b8", "filename": "tests/target/match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3163071c75bff08e3ea1b4ed0928933415377ca4/tests%2Ftarget%2Fmatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3163071c75bff08e3ea1b4ed0928933415377ca4/tests%2Ftarget%2Fmatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fmatch.rs?ref=3163071c75bff08e3ea1b4ed0928933415377ca4", "patch": "@@ -251,7 +251,7 @@ fn issue280() {\n \n fn issue383() {\n     match resolution.last_private {\n-        LastImport{..} => false,\n+        LastImport { .. } => false,\n         _ => true,\n     };\n }"}, {"sha": "abf25b5e649063e6b3a21855cd4deb885a5e06c6", "filename": "tests/target/mod-1.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3163071c75bff08e3ea1b4ed0928933415377ca4/tests%2Ftarget%2Fmod-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3163071c75bff08e3ea1b4ed0928933415377ca4/tests%2Ftarget%2Fmod-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fmod-1.rs?ref=3163071c75bff08e3ea1b4ed0928933415377ca4", "patch": "@@ -2,8 +2,7 @@\n \n mod foo {\n     mod bar {\n-        mod baz {\n-        }\n+        mod baz {}\n     }\n }\n \n@@ -16,9 +15,7 @@ mod foo {\n         }\n     }\n \n-    mod qux {\n-\n-    }\n+    mod qux {}\n }\n \n mod boxed {"}, {"sha": "d77cb59f4984738b7d8b1b4147424b8e9582a308", "filename": "tests/target/pattern.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/3163071c75bff08e3ea1b4ed0928933415377ca4/tests%2Ftarget%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3163071c75bff08e3ea1b4ed0928933415377ca4/tests%2Ftarget%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fpattern.rs?ref=3163071c75bff08e3ea1b4ed0928933415377ca4", "patch": "@@ -13,6 +13,23 @@ fn main() {\n     if let None = opt2 {\n         panic!(\"oh noes\");\n     }\n+\n+    let foo @ bar(f) = 42;\n+    let a::foo(..) = 42;\n+    let [] = 42;\n+    let [a.., b, c] = 42;\n+    let [a, b, c..] = 42;\n+    let [a, b, c, d.., e, f, g] = 42;\n+    let foo {} = 42;\n+    let foo { .. } = 42;\n+    let foo { x, y: ref foo, .. } = 42;\n+    let foo { x, yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy: ref foo, .. } = 42;\n+    let foo { x, yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy: ref foo } = 42;\n+    let foo { x,\n+              yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy: ref foo,\n+              .. };\n+    let foo { x,\n+              yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy: ref foo };\n }\n \n impl<'a, 'b> ResolveGeneratedContentFragmentMutator<'a, 'b> {"}, {"sha": "08e8be8186c7cd9c254af356ee78b101968f834f", "filename": "tests/target/string-lit-2.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/3163071c75bff08e3ea1b4ed0928933415377ca4/tests%2Ftarget%2Fstring-lit-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3163071c75bff08e3ea1b4ed0928933415377ca4/tests%2Ftarget%2Fstring-lit-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fstring-lit-2.rs?ref=3163071c75bff08e3ea1b4ed0928933415377ca4", "patch": "@@ -0,0 +1,15 @@\n+fn main() -> &'static str {\n+    let too_many_lines = \"H\\\n+                          e\\\n+                          l\\\n+                          l\\\n+                          o\";\n+    let leave_me = \"sssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss\\\n+                    s\n+                    jjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjj\";\n+    // Crappy formatting :-(\n+    let change_me = \"sssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss\n+                     \\\n+                     jjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjj\\\n+                     j\";\n+}"}, {"sha": "e7146a84f9e97c7ba43f7d4443645d6590f38b18", "filename": "tests/target/string-lit.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3163071c75bff08e3ea1b4ed0928933415377ca4/tests%2Ftarget%2Fstring-lit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3163071c75bff08e3ea1b4ed0928933415377ca4/tests%2Ftarget%2Fstring-lit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fstring-lit.rs?ref=3163071c75bff08e3ea1b4ed0928933415377ca4", "patch": "@@ -1,3 +1,4 @@\n+// rustfmt-force_format_strings: true\n // Long string literals\n \n fn main() -> &'static str {"}, {"sha": "299afb422ec998699dd46281a116328bd0674d51", "filename": "tests/target/struct_lits.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3163071c75bff08e3ea1b4ed0928933415377ca4/tests%2Ftarget%2Fstruct_lits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3163071c75bff08e3ea1b4ed0928933415377ca4/tests%2Ftarget%2Fstruct_lits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fstruct_lits.rs?ref=3163071c75bff08e3ea1b4ed0928933415377ca4", "patch": "@@ -149,3 +149,13 @@ fn issue491() {\n         e: eeeeeeeee,\n     };\n }\n+\n+fn issue698() {\n+    Record {\n+        ffffffffffffffffffffffffffields: aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa,\n+    };\n+    Record {\n+        ffffffffffffffffffffffffffields:\n+            aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa,\n+    }\n+}"}, {"sha": "2e5725b3db99c6b692158fe8dec8ff07dbeeaff7", "filename": "tests/target/type-punctuation.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3163071c75bff08e3ea1b4ed0928933415377ca4/tests%2Ftarget%2Ftype-punctuation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3163071c75bff08e3ea1b4ed0928933415377ca4/tests%2Ftarget%2Ftype-punctuation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Ftype-punctuation.rs?ref=3163071c75bff08e3ea1b4ed0928933415377ca4", "patch": "@@ -0,0 +1,5 @@\n+// rustfmt-type_punctuation_density: Compressed\n+\n+fn Foo<T=Foo, Output=Expr<'tcx>+Foo>() {\n+    let i = 6;\n+}"}, {"sha": "bd7108f992a87a4086eaee4b3a50c080f724871c", "filename": "tests/target/where-trailing-comma.rs", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/3163071c75bff08e3ea1b4ed0928933415377ca4/tests%2Ftarget%2Fwhere-trailing-comma.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3163071c75bff08e3ea1b4ed0928933415377ca4/tests%2Ftarget%2Fwhere-trailing-comma.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fwhere-trailing-comma.rs?ref=3163071c75bff08e3ea1b4ed0928933415377ca4", "patch": "@@ -0,0 +1,57 @@\n+// rustfmt-where_trailing_comma: true\n+\n+fn f<S, T>(x: T, y: S) -> T\n+    where T: P,\n+          S: Q,\n+{\n+    x\n+}\n+\n+impl Trait for T\n+    where T: P,\n+{\n+    fn f(x: T) -> T\n+        where T: Q + R,\n+    {\n+        x\n+    }\n+}\n+\n+struct Pair<S, T>\n+    where T: P,\n+          S: P + Q,\n+{\n+    a: T,\n+    b: S,\n+}\n+\n+struct TupPair<S, T>(S, T)\n+    where T: P,\n+          S: P + Q;\n+\n+enum E<S, T>\n+    where S: P,\n+          T: P,\n+{\n+    A {\n+        a: T,\n+    },\n+}\n+\n+type Double<T>\n+    where T: P,\n+          T: Q = Pair<T, T>;\n+\n+extern \"C\" {\n+    fn f<S, T>(x: T, y: S) -> T\n+        where T: P,\n+              S: Q;\n+}\n+\n+// Note: trait declarations are not fully formatted (issue #78)\n+trait Q<S, T> where T: P, S: R\n+{\n+    fn f<U, V>(self, x: T, y: S, z: U) -> Self\n+        where U: P,\n+              V: P;\n+}"}, {"sha": "f655cfb3b6b50c9c5b3bd2409c48b0b16d900091", "filename": "tests/writemode/checkstyle.xml", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3163071c75bff08e3ea1b4ed0928933415377ca4/tests%2Fwritemode%2Fcheckstyle.xml", "raw_url": "https://github.com/rust-lang/rust/raw/3163071c75bff08e3ea1b4ed0928933415377ca4/tests%2Fwritemode%2Fcheckstyle.xml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fwritemode%2Fcheckstyle.xml?ref=3163071c75bff08e3ea1b4ed0928933415377ca4", "patch": "@@ -0,0 +1,2 @@\n+<?xml version=\"1.0\" encoding=\"utf-8\"?>\n+<checkstyle version=\"4.3\"><file name=\"tests/source/fn-single-line.rs\"><error line=\"1\" severity=\"warning\" message=\"Should be `fn foo_expr() { 1 }`\" /><error line=\"1\" severity=\"warning\" message=\"Should be `fn foo_stmt() { foo(); }`\" /><error line=\"1\" severity=\"warning\" message=\"Should be `fn foo_decl_local() { let z = 5; }`\" /><error line=\"1\" severity=\"warning\" message=\"Should be `fn foo_decl_item(x: &amp;mut i32) { x = 3; }`\" /><error line=\"1\" severity=\"warning\" message=\"Should be `fn empty() {}`\" /><error line=\"1\" severity=\"warning\" message=\"Should be `fn foo_return() -&gt; String { &quot;yay&quot; }`\" /><error line=\"1\" severity=\"warning\" message=\"Should be `fn foo_where() -&gt; T`\" /><error line=\"1\" severity=\"warning\" message=\"Should be `    where T: Sync`\" /><error line=\"1\" severity=\"warning\" message=\"Should be `{`\" /><error line=\"50\" severity=\"warning\" message=\"Should be `fn lots_of_space() { 1 }`\" /><error line=\"57\" severity=\"warning\" message=\"Should be `    fn dummy(&amp;self) {}`\" /><error line=\"57\" severity=\"warning\" message=\"Should be `trait CoolerTypes {`\" /><error line=\"57\" severity=\"warning\" message=\"Should be `    fn dummy(&amp;self) {}`\" /><error line=\"57\" severity=\"warning\" message=\"Should be `fn Foo&lt;T&gt;() where T: Bar {}`\" /><error line=\"57\" severity=\"warning\" message=\"Should be ``\" /></file></checkstyle>"}]}