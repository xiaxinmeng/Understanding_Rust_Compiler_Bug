{"sha": "7eae2044b0f4bbb586cd48993d9a4d1853028cc7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdlYWUyMDQ0YjBmNGJiYjU4NmNkNDg5OTNkOWE0ZDE4NTMwMjhjYzc=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-07-16T17:19:39Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-07-16T17:58:12Z"}, "message": "Discuss classes in reference manual\n\nStill could use work, but this is the best I've got for now.", "tree": {"sha": "41e3e3104facc7d80009eea80cfc0dddcc8a04d5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/41e3e3104facc7d80009eea80cfc0dddcc8a04d5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7eae2044b0f4bbb586cd48993d9a4d1853028cc7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7eae2044b0f4bbb586cd48993d9a4d1853028cc7", "html_url": "https://github.com/rust-lang/rust/commit/7eae2044b0f4bbb586cd48993d9a4d1853028cc7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7eae2044b0f4bbb586cd48993d9a4d1853028cc7/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6081eb78f973119967fa659d5348c041783825c5", "url": "https://api.github.com/repos/rust-lang/rust/commits/6081eb78f973119967fa659d5348c041783825c5", "html_url": "https://github.com/rust-lang/rust/commit/6081eb78f973119967fa659d5348c041783825c5"}], "stats": {"total": 150, "additions": 130, "deletions": 20}, "files": [{"sha": "76c99f7b226cc220fde2595e5987ef9567650738", "filename": "doc/rust.md", "status": "modified", "additions": 130, "deletions": 20, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/7eae2044b0f4bbb586cd48993d9a4d1853028cc7/doc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/7eae2044b0f4bbb586cd48993d9a4d1853028cc7/doc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.md?ref=7eae2044b0f4bbb586cd48993d9a4d1853028cc7", "patch": "@@ -1106,11 +1106,12 @@ let a: list<int> = cons(7, @cons(13, @nil));\n \n ### Classes\n \n-TODO: more about classes\n-\n-_Classes_ are named record types that may have a destructor associated\n-with them, as well as fields and methods. For historical reasons, we\n-may call a class with a destructor and a single field a \"resource\".\n+A _class_ is a named record type that collects together fields and\n+methods. It must have a _constructor_ (a function called `new` that\n+returns a new instance of the class), and may have a destructor (a\n+nullary function called `drop` that executes before the memory manager\n+frees the memory for a given class). For historical reasons, we may\n+call a class with a destructor and a single field a \"resource\".\n \n A _class item_ declares a class type:\n \n@@ -1123,21 +1124,130 @@ class file_descriptor {\n ~~~~\n \n Calling the `file_descriptor` constructor function on an integer will\n-produce a value with the `file_descriptor` type. Resource types have a\n-noncopyable [type kind](#type-kinds), and thus may not be\n-copied. Class types that don't have destructors may be copied if all\n-their fields are copyable. The semantics guarantee that for each\n-constructed resource value, the destructor will run once: when the\n-value is disposed of (barring drastic program termination that somehow\n-prevents unwinding from taking place). For stack-allocated values,\n-disposal happens when the value goes out of scope. For values in\n-shared boxes, it happens when the reference count of the box reaches\n-zero.\n-\n-The argument or arguments to the class constructor may be stored in\n-the class's named fields, and can be accessed by a field reference. In\n-this case, the `file_descriptor`'s data field would be accessed like\n-`f.fd`, if `f` is a value of type `file_descriptor`.\n+produce a value with the `file_descriptor` type.\n+\n+_Fields_ are immutable by default, so instances of `file_descriptor`\n+can't have their `fd` fields reassigned. A mutable field declaration\n+looks like:\n+\n+~~~~\n+    let mut fd: libc::c_int;\n+~~~~\n+\n+The only exception is that the body of the class constructor begins\n+with all the class's fields uninitialized, and is allowed to -- in\n+fact, must -- initialize all the fields. A special case in the\n+typestate pass enforces this invariant.\n+\n+Usually, the class constructor stores its argument or arguments in the\n+class's named fields. In this case, the `file_descriptor`'s data field\n+would be accessed like `f.fd`, if `f` is a value of type\n+`file_descriptor`. By default, class fields are _public_: they can be\n+accessed both from methods inside the class, and code outside the\n+class. Classes can also have private fields:\n+\n+~~~~\n+class file_descriptor {\n+    let fd: *libc::FILE;\n+    new(fd: *libc::FILE) {\n+      self.fd = fd; self.name = none;\n+    }\n+    priv {\n+      let mut name: option<str>;\n+    }\n+    fn get_name() -> str {\n+      alt self.name {\n+         none    { fail \"File has no name!\"; }\n+         some(n) { n }\n+      }\n+    }\n+}\n+~~~~\n+\n+Private fields are instance-private: methods in a class `C` can access\n+`self`'s private fields, but not private fields of other values of\n+type `C`. Code outside a class can't access any private fields.\n+\n+A class item may contain _methods_, which take an implicit `self`\n+argument:\n+\n+~~~~\n+class file_descriptor {\n+    let fd: *libc::FILE;\n+    new(fd: *libc::FILE) { self.fd = fd; }\n+    fn flush() {\n+       libc::fflush(self.fd);\n+    }\n+}\n+~~~~\n+\n+In this case, ```open``` is a nullary method that calls the\n+```fopen``` function, defined in another library, on the ```fd```\n+field. As in this example, methods must refer to their self's fields\n+as fields of ```self```; bare references to ```fd``` can't\n+occur. Methods can be public or private; just like fields, they are\n+public by default and private if enclosed in a `priv` section.\n+\n+Classes may be polymorphic:\n+\n+~~~~\n+class file<A: copy> {\n+  let data: A;\n+  let fd: *libc::FILE;\n+  new(data: A, fd: *libc::FILE) { self.data = data; self.fd = fd; }\n+}\n+~~~~\n+\n+Methods may also be polymorphic, and can have additional type\n+parameters other than those bound in the class:\n+\n+~~~~\n+class file<A: copy> {\n+  let data: A;\n+  let fd: *libc::FILE;\n+  new(fd: *libc::FILE, data: A) { self.fd = fd; self.data = data; }\n+  fn map_data<B>(f: fn(A) -> B) -> B {\n+     f(self.data)\n+  }\n+}\n+~~~~\n+\n+Classes do not support inheritance, except through traits. As a\n+result, all class method dispatch is static (non-virtual).\n+\n+A class may implement a trait (see [interfaces](#interfaces)):\n+\n+~~~~\n+trait to_str {\n+  fn to_str() -> str;\n+}\n+\n+class file : to_str {\n+  let fd: *libc::FILE;\n+  new(fd: *libc::FILE) { self.fd = fd; }\n+  fn to_str() -> str { \"a file\" }\n+}\n+~~~~\n+\n+The syntax `class file: to_str` is pronounced \"class `file`\n+implements trait `to_str`\".\n+\n+Class instances may be allocated on the stack, in the exchange heap,\n+or on the task heap. A value with a class type ```C``` has a\n+noncopyable [type kind](#type-kinds) if ```C``` has a destructor, and\n+thus may not be copied. Class types that don't have destructors may be\n+copied if all their fields are copyable.\n+\n+The semantics guarantee that for each constructed resource value, the\n+destructor will run once: when the value is disposed of (barring\n+drastic program termination that somehow prevents unwinding from\n+taking place). For stack-allocated values, disposal happens when the\n+value goes out of scope. For values in shared boxes, it happens when\n+the reference count of the box reaches zero.\n+\n+The order of fields in a class instance is significant; its runtime\n+representation is the same as that of a record with identical fields\n+laid out in the same order.\n \n ### Interfaces\n "}]}