{"sha": "9ba9cd5fd5df75d12225429f5831fb968672c79d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjliYTljZDVmZDVkZjc1ZDEyMjI1NDI5ZjU4MzFmYjk2ODY3MmM3OWQ=", "commit": {"author": {"name": "Andrew Cann", "email": "shum@canndrew.org", "date": "2016-12-01T03:37:03Z"}, "committer": {"name": "Andrew Cann", "email": "shum@canndrew.org", "date": "2017-01-03T07:33:31Z"}, "message": "Improve error message, fix and add tests.\n\nChanges the non-exhaustive match error message to generate more general\nwitnesses.", "tree": {"sha": "8f1ce3cc3033bc92019b793d29ccbd6bdd7c4277", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8f1ce3cc3033bc92019b793d29ccbd6bdd7c4277"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9ba9cd5fd5df75d12225429f5831fb968672c79d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9ba9cd5fd5df75d12225429f5831fb968672c79d", "html_url": "https://github.com/rust-lang/rust/commit/9ba9cd5fd5df75d12225429f5831fb968672c79d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9ba9cd5fd5df75d12225429f5831fb968672c79d/comments", "author": {"login": "canndrew", "id": 5555066, "node_id": "MDQ6VXNlcjU1NTUwNjY=", "avatar_url": "https://avatars.githubusercontent.com/u/5555066?v=4", "gravatar_id": "", "url": "https://api.github.com/users/canndrew", "html_url": "https://github.com/canndrew", "followers_url": "https://api.github.com/users/canndrew/followers", "following_url": "https://api.github.com/users/canndrew/following{/other_user}", "gists_url": "https://api.github.com/users/canndrew/gists{/gist_id}", "starred_url": "https://api.github.com/users/canndrew/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/canndrew/subscriptions", "organizations_url": "https://api.github.com/users/canndrew/orgs", "repos_url": "https://api.github.com/users/canndrew/repos", "events_url": "https://api.github.com/users/canndrew/events{/privacy}", "received_events_url": "https://api.github.com/users/canndrew/received_events", "type": "User", "site_admin": false}, "committer": {"login": "canndrew", "id": 5555066, "node_id": "MDQ6VXNlcjU1NTUwNjY=", "avatar_url": "https://avatars.githubusercontent.com/u/5555066?v=4", "gravatar_id": "", "url": "https://api.github.com/users/canndrew", "html_url": "https://github.com/canndrew", "followers_url": "https://api.github.com/users/canndrew/followers", "following_url": "https://api.github.com/users/canndrew/following{/other_user}", "gists_url": "https://api.github.com/users/canndrew/gists{/gist_id}", "starred_url": "https://api.github.com/users/canndrew/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/canndrew/subscriptions", "organizations_url": "https://api.github.com/users/canndrew/orgs", "repos_url": "https://api.github.com/users/canndrew/repos", "events_url": "https://api.github.com/users/canndrew/events{/privacy}", "received_events_url": "https://api.github.com/users/canndrew/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9c5e86d0cd0185bb1030b95196394adb6c2c7a7a", "url": "https://api.github.com/repos/rust-lang/rust/commits/9c5e86d0cd0185bb1030b95196394adb6c2c7a7a", "html_url": "https://github.com/rust-lang/rust/commit/9c5e86d0cd0185bb1030b95196394adb6c2c7a7a"}], "stats": {"total": 162, "additions": 131, "deletions": 31}, "files": [{"sha": "b6d1d22015e04d313f826b931654bf5d43b6034d", "filename": "src/librustc_const_eval/_match.rs", "status": "modified", "additions": 41, "deletions": 28, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/9ba9cd5fd5df75d12225429f5831fb968672c79d/src%2Flibrustc_const_eval%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ba9cd5fd5df75d12225429f5831fb968672c79d/src%2Flibrustc_const_eval%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2F_match.rs?ref=9ba9cd5fd5df75d12225429f5831fb968672c79d", "patch": "@@ -359,25 +359,6 @@ impl<'tcx> Witness<'tcx> {\n     }\n }\n \n-/// Return the set of constructors from the same type as the first column of `matrix`,\n-/// that are matched only by wildcard patterns from that first column.\n-///\n-/// Therefore, if there is some pattern that is unmatched by `matrix`, it will\n-/// still be unmatched if the first constructor is replaced by any of the constructors\n-/// in the return value.\n-fn missing_constructors<'a, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n-                                      matrix: &Matrix,\n-                                      pcx: PatternContext<'tcx>) -> Vec<Constructor> {\n-    let used_constructors: Vec<Constructor> =\n-        matrix.0.iter()\n-        .flat_map(|row| pat_constructors(cx, row[0], pcx).unwrap_or(vec![]))\n-        .collect();\n-    debug!(\"used_constructors = {:?}\", used_constructors);\n-    all_constructors(cx, pcx).into_iter()\n-        .filter(|c| !used_constructors.contains(c))\n-        .collect()\n-}\n-\n /// This determines the set of all possible constructors of a pattern matching\n /// values of type `left_ty`. For vectors, this would normally be an infinite set\n ///\n@@ -586,10 +567,28 @@ pub fn is_useful<'p, 'a: 'p, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n         ).find(|result| result.is_useful()).unwrap_or(NotUseful)\n     } else {\n         debug!(\"is_useful - expanding wildcard\");\n-        let constructors = missing_constructors(cx, matrix, pcx);\n-        debug!(\"is_useful - missing_constructors = {:?}\", constructors);\n-        if constructors.is_empty() {\n-            all_constructors(cx, pcx).into_iter().map(|c| {\n+\n+        let used_ctors: Vec<Constructor> = rows.iter().flat_map(|row| {\n+            pat_constructors(cx, row[0], pcx).unwrap_or(vec![])\n+        }).collect();\n+        debug!(\"used_ctors = {:?}\", used_ctors);\n+        let all_ctors = all_constructors(cx, pcx);\n+        debug!(\"all_ctors = {:?}\", all_ctors);\n+        let missing_ctors: Vec<Constructor> = all_ctors.iter().filter(|c| {\n+            !used_ctors.contains(*c)\n+        }).cloned().collect();\n+        debug!(\"missing_ctors = {:?}\", missing_ctors);\n+\n+        // `missing_ctors` is the set of constructors from the same type as the\n+        // first column of `matrix` that are matched only by wildcard patterns\n+        // from the first column.\n+        //\n+        // Therefore, if there is some pattern that is unmatched by `matrix`,\n+        // it will still be unmatched if the first constructor is replaced by\n+        // any of the constructors in `missing_ctors`\n+\n+        if missing_ctors.is_empty() {\n+            all_ctors.into_iter().map(|c| {\n                 is_useful_specialized(cx, matrix, v, c.clone(), pcx.ty, witness)\n             }).find(|result| result.is_useful()).unwrap_or(NotUseful)\n         } else {\n@@ -603,11 +602,25 @@ pub fn is_useful<'p, 'a: 'p, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n             match is_useful(cx, &matrix, &v[1..], witness) {\n                 UsefulWithWitness(pats) => {\n                     let cx = &*cx;\n-                    UsefulWithWitness(pats.into_iter().flat_map(|witness| {\n-                        constructors.iter().map(move |ctor| {\n-                            witness.clone().push_wild_constructor(cx, ctor, pcx.ty)\n-                        })\n-                    }).collect())\n+                    let new_witnesses = if used_ctors.is_empty() {\n+                        // All constructors are unused. Add wild patterns\n+                        // rather than each individual constructor\n+                        pats.into_iter().map(|mut witness| {\n+                            witness.0.push(P(hir::Pat {\n+                                id: DUMMY_NODE_ID,\n+                                node: PatKind::Wild,\n+                                span: DUMMY_SP,\n+                            }));\n+                            witness\n+                        }).collect()\n+                    } else {\n+                        pats.into_iter().flat_map(|witness| {\n+                            missing_ctors.iter().map(move |ctor| {\n+                                witness.clone().push_wild_constructor(cx, ctor, pcx.ty)\n+                            })\n+                        }).collect()\n+                    };\n+                    UsefulWithWitness(new_witnesses)\n                 }\n                 result => result\n             }"}, {"sha": "fd4bd1c7b944b7b879e3160f3e1a89cf65cc0dd4", "filename": "src/test/compile-fail/match-slice-patterns.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9ba9cd5fd5df75d12225429f5831fb968672c79d/src%2Ftest%2Fcompile-fail%2Fmatch-slice-patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ba9cd5fd5df75d12225429f5831fb968672c79d/src%2Ftest%2Fcompile-fail%2Fmatch-slice-patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmatch-slice-patterns.rs?ref=9ba9cd5fd5df75d12225429f5831fb968672c79d", "patch": "@@ -12,7 +12,7 @@\n \n fn check(list: &[Option<()>]) {\n     match list {\n-    //~^ ERROR `&[None, Some(_), None, _]` and `&[Some(_), Some(_), None, _]` not covered\n+    //~^ ERROR `&[_, Some(_), None, _]` not covered\n         &[] => {},\n         &[_] => {},\n         &[_, _] => {},"}, {"sha": "4755fdd4fd5e8c1e2a846b8a2692c8482e42b21d", "filename": "src/test/compile-fail/uninhabited-irrefutable.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/9ba9cd5fd5df75d12225429f5831fb968672c79d/src%2Ftest%2Fcompile-fail%2Funinhabited-irrefutable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ba9cd5fd5df75d12225429f5831fb968672c79d/src%2Ftest%2Fcompile-fail%2Funinhabited-irrefutable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funinhabited-irrefutable.rs?ref=9ba9cd5fd5df75d12225429f5831fb968672c79d", "patch": "@@ -0,0 +1,38 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(never_type)]\n+\n+mod foo {\n+    pub struct SecretlyEmpty {\n+        _priv: !,\n+    }\n+\n+    pub struct NotSoSecretlyEmpty {\n+        pub _pub: !,\n+    }\n+}\n+\n+struct NotSoSecretlyEmpty {\n+    _priv: !,\n+}\n+\n+enum Foo {\n+    A(foo::SecretlyEmpty),\n+    B(foo::NotSoSecretlyEmpty),\n+    C(NotSoSecretlyEmpty),\n+    D(u32),\n+}\n+\n+fn main() {\n+    let x: Foo = Foo::D(123);\n+    let Foo::D(_y) = x; //~ ERROR refutable pattern in local binding: `A(_)` not covered\n+}\n+"}, {"sha": "0de29f3a8d7375e1d0d49ed517ddbc94752efb90", "filename": "src/test/compile-fail/uninhabited-patterns.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/9ba9cd5fd5df75d12225429f5831fb968672c79d/src%2Ftest%2Fcompile-fail%2Funinhabited-patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ba9cd5fd5df75d12225429f5831fb968672c79d/src%2Ftest%2Fcompile-fail%2Funinhabited-patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funinhabited-patterns.rs?ref=9ba9cd5fd5df75d12225429f5831fb968672c79d", "patch": "@@ -0,0 +1,49 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(box_patterns)]\n+#![feature(slice_patterns)]\n+#![feature(box_syntax)]\n+#![feature(never_type)]\n+#![deny(unreachable_patterns)]\n+\n+mod foo {\n+    pub struct SecretlyEmpty {\n+        _priv: !,\n+    }\n+}\n+\n+struct NotSoSecretlyEmpty {\n+    _priv: !,\n+}\n+\n+fn main() {\n+    let x: &[!] = &[];\n+\n+    match x {\n+        &[]   => (),\n+        &[..] => (),    //~ ERROR unreachable pattern\n+    };\n+\n+    let x: Result<Box<NotSoSecretlyEmpty>, &[Result<!, !>]> = Err(&[]);\n+    match x {\n+        Ok(box _) => (),    //~ ERROR unreachable pattern\n+        Err(&[]) => (),\n+        Err(&[..]) => (),   //~ ERROR unreachable pattern\n+    }\n+\n+    let x: Result<foo::SecretlyEmpty, Result<NotSoSecretlyEmpty, u32>> = Err(Err(123));\n+    match x {\n+        Ok(_y) => (),\n+        Err(Err(_y)) => (),\n+        Err(Ok(_y)) => (),  //~ ERROR unreachable pattern\n+    }\n+}\n+"}, {"sha": "0aafe3f17b3d0f6310b30d10baedc9eb00d19cef", "filename": "src/test/ui/check_match/issue-35609.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9ba9cd5fd5df75d12225429f5831fb968672c79d/src%2Ftest%2Fui%2Fcheck_match%2Fissue-35609.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9ba9cd5fd5df75d12225429f5831fb968672c79d/src%2Ftest%2Fui%2Fcheck_match%2Fissue-35609.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcheck_match%2Fissue-35609.stderr?ref=9ba9cd5fd5df75d12225429f5831fb968672c79d", "patch": "@@ -4,11 +4,11 @@ error[E0004]: non-exhaustive patterns: `(B, _)`, `(C, _)`, `(D, _)` and 2 more n\n 20 |     match (A, ()) {\n    |           ^^^^^^^ patterns `(B, _)`, `(C, _)`, `(D, _)` and 2 more not covered\n \n-error[E0004]: non-exhaustive patterns: `(A, B)`, `(B, B)`, `(C, B)` and 27 more not covered\n+error[E0004]: non-exhaustive patterns: `(_, B)`, `(_, C)`, `(_, D)` and 2 more not covered\n   --> $DIR/issue-35609.rs:24:11\n    |\n 24 |     match (A, A) {\n-   |           ^^^^^^ patterns `(A, B)`, `(B, B)`, `(C, B)` and 27 more not covered\n+   |           ^^^^^^ patterns `(_, B)`, `(_, C)`, `(_, D)` and 2 more not covered\n \n error[E0004]: non-exhaustive patterns: `((B, _), _)`, `((C, _), _)`, `((D, _), _)` and 2 more not covered\n   --> $DIR/issue-35609.rs:28:11"}]}