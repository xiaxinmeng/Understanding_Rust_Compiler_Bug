{"sha": "0f2571235b4ac60190b9d2dfe745367671c27c0f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBmMjU3MTIzNWI0YWM2MDE5MGI5ZDJkZmU3NDUzNjc2NzFjMjdjMGY=", "commit": {"author": {"name": "Joshua Nelson", "email": "joshua@yottadb.com", "date": "2020-12-26T14:47:11Z"}, "committer": {"name": "Joshua Nelson", "email": "jyn514@gmail.com", "date": "2020-12-26T17:11:44Z"}, "message": "Revert \"Cleanup markdown span handling\"\n\nThis caused a diagnostic regression, originally it was:\n\n```\nwarning: unresolved link to `std::process::Comman`\n --> link.rs:3:10\n  |\n3 | //! [a]: std::process::Comman\n  |          ^^^^^^^^^^^^^^^^^^^^ no item named `Comman` in module `process`\n  |\n  = note: `#[warn(broken_intra_doc_links)]` on by default\n```\nbut after that PR rustdoc now displays\n```\nwarning: unresolved link to `std::process::Comman`\n --> link.rs:1:14\n  |\n1 | //! Links to [a] [link][a]\n  |              ^^^ no item named `Comman` in module `process`\n  |\n  = note: `#[warn(broken_intra_doc_links)]` on by default\n```\nwhich IMO is much less clear.", "tree": {"sha": "72346dac3dc10b03bf23d6031e9f46f7ef729d14", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/72346dac3dc10b03bf23d6031e9f46f7ef729d14"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0f2571235b4ac60190b9d2dfe745367671c27c0f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0f2571235b4ac60190b9d2dfe745367671c27c0f", "html_url": "https://github.com/rust-lang/rust/commit/0f2571235b4ac60190b9d2dfe745367671c27c0f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0f2571235b4ac60190b9d2dfe745367671c27c0f/comments", "author": null, "committer": {"login": "jyn514", "id": 23638587, "node_id": "MDQ6VXNlcjIzNjM4NTg3", "avatar_url": "https://avatars.githubusercontent.com/u/23638587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyn514", "html_url": "https://github.com/jyn514", "followers_url": "https://api.github.com/users/jyn514/followers", "following_url": "https://api.github.com/users/jyn514/following{/other_user}", "gists_url": "https://api.github.com/users/jyn514/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyn514/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyn514/subscriptions", "organizations_url": "https://api.github.com/users/jyn514/orgs", "repos_url": "https://api.github.com/users/jyn514/repos", "events_url": "https://api.github.com/users/jyn514/events{/privacy}", "received_events_url": "https://api.github.com/users/jyn514/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1f5beec3b111560be181283009ef96da6ac5e7a7", "url": "https://api.github.com/repos/rust-lang/rust/commits/1f5beec3b111560be181283009ef96da6ac5e7a7", "html_url": "https://github.com/rust-lang/rust/commit/1f5beec3b111560be181283009ef96da6ac5e7a7"}], "stats": {"total": 215, "additions": 126, "deletions": 89}, "files": [{"sha": "015e8885c1b1b325412c75e88a94c0a77baaea13", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 65, "deletions": 61, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/0f2571235b4ac60190b9d2dfe745367671c27c0f/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f2571235b4ac60190b9d2dfe745367671c27c0f/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=0f2571235b4ac60190b9d2dfe745367671c27c0f", "patch": "@@ -418,7 +418,7 @@ impl<'a, I: Iterator<Item = Event<'a>>> Iterator for LinkReplacer<'a, I> {\n struct HeadingLinks<'a, 'b, 'ids, I> {\n     inner: I,\n     toc: Option<&'b mut TocBuilder>,\n-    buf: VecDeque<(Event<'a>, Range<usize>)>,\n+    buf: VecDeque<Event<'a>>,\n     id_map: &'ids mut IdMap,\n }\n \n@@ -428,48 +428,48 @@ impl<'a, 'b, 'ids, I> HeadingLinks<'a, 'b, 'ids, I> {\n     }\n }\n \n-impl<'a, 'b, 'ids, I: Iterator<Item = (Event<'a>, Range<usize>)>> Iterator\n-    for HeadingLinks<'a, 'b, 'ids, I>\n-{\n-    type Item = (Event<'a>, Range<usize>);\n+impl<'a, 'b, 'ids, I: Iterator<Item = Event<'a>>> Iterator for HeadingLinks<'a, 'b, 'ids, I> {\n+    type Item = Event<'a>;\n \n     fn next(&mut self) -> Option<Self::Item> {\n         if let Some(e) = self.buf.pop_front() {\n             return Some(e);\n         }\n \n         let event = self.inner.next();\n-        if let Some((Event::Start(Tag::Heading(level)), _)) = event {\n+        if let Some(Event::Start(Tag::Heading(level))) = event {\n             let mut id = String::new();\n             for event in &mut self.inner {\n-                match &event.0 {\n+                match &event {\n                     Event::End(Tag::Heading(..)) => break,\n-                    Event::Start(Tag::Link(_, _, _)) | Event::End(Tag::Link(..)) => {}\n                     Event::Text(text) | Event::Code(text) => {\n                         id.extend(text.chars().filter_map(slugify));\n-                        self.buf.push_back(event);\n                     }\n-                    _ => self.buf.push_back(event),\n+                    _ => {}\n+                }\n+                match event {\n+                    Event::Start(Tag::Link(_, _, _)) | Event::End(Tag::Link(..)) => {}\n+                    event => self.buf.push_back(event),\n                 }\n             }\n             let id = self.id_map.derive(id);\n \n             if let Some(ref mut builder) = self.toc {\n                 let mut html_header = String::new();\n-                html::push_html(&mut html_header, self.buf.iter().map(|(ev, _)| ev.clone()));\n+                html::push_html(&mut html_header, self.buf.iter().cloned());\n                 let sec = builder.push(level as u32, html_header, id.clone());\n-                self.buf.push_front((Event::Html(format!(\"{} \", sec).into()), 0..0));\n+                self.buf.push_front(Event::Html(format!(\"{} \", sec).into()));\n             }\n \n-            self.buf.push_back((Event::Html(format!(\"</a></h{}>\", level).into()), 0..0));\n+            self.buf.push_back(Event::Html(format!(\"</a></h{}>\", level).into()));\n \n             let start_tags = format!(\n                 \"<h{level} id=\\\"{id}\\\" class=\\\"section-header\\\">\\\n                     <a href=\\\"#{id}\\\">\",\n                 id = id,\n                 level = level\n             );\n-            return Some((Event::Html(start_tags.into()), 0..0));\n+            return Some(Event::Html(start_tags.into()));\n         }\n         event\n     }\n@@ -560,23 +560,23 @@ impl<'a, I> Footnotes<'a, I> {\n     }\n }\n \n-impl<'a, I: Iterator<Item = (Event<'a>, Range<usize>)>> Iterator for Footnotes<'a, I> {\n-    type Item = (Event<'a>, Range<usize>);\n+impl<'a, I: Iterator<Item = Event<'a>>> Iterator for Footnotes<'a, I> {\n+    type Item = Event<'a>;\n \n     fn next(&mut self) -> Option<Self::Item> {\n         loop {\n             match self.inner.next() {\n-                Some((Event::FootnoteReference(ref reference), range)) => {\n+                Some(Event::FootnoteReference(ref reference)) => {\n                     let entry = self.get_entry(&reference);\n                     let reference = format!(\n                         \"<sup id=\\\"fnref{0}\\\"><a href=\\\"#fn{0}\\\">{0}</a></sup>\",\n                         (*entry).1\n                     );\n-                    return Some((Event::Html(reference.into()), range));\n+                    return Some(Event::Html(reference.into()));\n                 }\n-                Some((Event::Start(Tag::FootnoteDefinition(def)), _)) => {\n+                Some(Event::Start(Tag::FootnoteDefinition(def))) => {\n                     let mut content = Vec::new();\n-                    for (event, _) in &mut self.inner {\n+                    for event in &mut self.inner {\n                         if let Event::End(Tag::FootnoteDefinition(..)) = event {\n                             break;\n                         }\n@@ -607,7 +607,7 @@ impl<'a, I: Iterator<Item = (Event<'a>, Range<usize>)>> Iterator for Footnotes<'\n                             ret.push_str(\"</li>\");\n                         }\n                         ret.push_str(\"</ol></div>\");\n-                        return Some((Event::Html(ret.into()), 0..0));\n+                        return Some(Event::Html(ret.into()));\n                     } else {\n                         return None;\n                     }\n@@ -917,14 +917,13 @@ impl Markdown<'_> {\n         };\n \n         let p = Parser::new_with_broken_link_callback(md, opts(), Some(&mut replacer));\n-        let p = p.into_offset_iter();\n \n         let mut s = String::with_capacity(md.len() * 3 / 2);\n \n         let p = HeadingLinks::new(p, None, &mut ids);\n-        let p = Footnotes::new(p);\n-        let p = LinkReplacer::new(p.map(|(ev, _)| ev), links);\n+        let p = LinkReplacer::new(p, links);\n         let p = CodeBlocks::new(p, codes, edition, playground);\n+        let p = Footnotes::new(p);\n         html::push_html(&mut s, p);\n \n         s\n@@ -935,16 +934,16 @@ impl MarkdownWithToc<'_> {\n     crate fn into_string(self) -> String {\n         let MarkdownWithToc(md, mut ids, codes, edition, playground) = self;\n \n-        let p = Parser::new_ext(md, opts()).into_offset_iter();\n+        let p = Parser::new_ext(md, opts());\n \n         let mut s = String::with_capacity(md.len() * 3 / 2);\n \n         let mut toc = TocBuilder::new();\n \n         {\n             let p = HeadingLinks::new(p, Some(&mut toc), &mut ids);\n+            let p = CodeBlocks::new(p, codes, edition, playground);\n             let p = Footnotes::new(p);\n-            let p = CodeBlocks::new(p.map(|(ev, _)| ev), codes, edition, playground);\n             html::push_html(&mut s, p);\n         }\n \n@@ -960,19 +959,19 @@ impl MarkdownHtml<'_> {\n         if md.is_empty() {\n             return String::new();\n         }\n-        let p = Parser::new_ext(md, opts()).into_offset_iter();\n+        let p = Parser::new_ext(md, opts());\n \n         // Treat inline HTML as plain text.\n-        let p = p.map(|event| match event.0 {\n-            Event::Html(text) => (Event::Text(text), event.1),\n+        let p = p.map(|event| match event {\n+            Event::Html(text) => Event::Text(text),\n             _ => event,\n         });\n \n         let mut s = String::with_capacity(md.len() * 3 / 2);\n \n         let p = HeadingLinks::new(p, None, &mut ids);\n+        let p = CodeBlocks::new(p, codes, edition, playground);\n         let p = Footnotes::new(p);\n-        let p = CodeBlocks::new(p.map(|(ev, _)| ev), codes, edition, playground);\n         html::push_html(&mut s, p);\n \n         s\n@@ -1125,45 +1124,50 @@ crate fn plain_text_summary(md: &str) -> String {\n     s\n }\n \n-crate fn markdown_links(md: &str) -> Vec<(String, Range<usize>)> {\n+crate fn markdown_links(md: &str) -> Vec<(String, Option<Range<usize>>)> {\n     if md.is_empty() {\n         return vec![];\n     }\n \n     let mut links = vec![];\n-    // Used to avoid mutable borrow issues in the `push` closure\n-    // Probably it would be more efficient to use a `RefCell` but it doesn't seem worth the churn.\n     let mut shortcut_links = vec![];\n \n-    let span_for_link = |link: &str, span: Range<usize>| {\n-        // Pulldown includes the `[]` as well as the URL. Only highlight the relevant span.\n-        // NOTE: uses `rfind` in case the title and url are the same: `[Ok][Ok]`\n-        match md[span.clone()].rfind(link) {\n-            Some(start) => {\n-                let start = span.start + start;\n-                start..start + link.len()\n+    {\n+        let locate = |s: &str| unsafe {\n+            let s_start = s.as_ptr();\n+            let s_end = s_start.add(s.len());\n+            let md_start = md.as_ptr();\n+            let md_end = md_start.add(md.len());\n+            if md_start <= s_start && s_end <= md_end {\n+                let start = s_start.offset_from(md_start) as usize;\n+                let end = s_end.offset_from(md_start) as usize;\n+                Some(start..end)\n+            } else {\n+                None\n+            }\n+        };\n+\n+        let mut push = |link: BrokenLink<'_>| {\n+            // FIXME: use `link.span` instead of `locate`\n+            // (doing it now includes the `[]` as well as the text)\n+            shortcut_links.push((link.reference.to_owned(), locate(link.reference)));\n+            None\n+        };\n+        let p = Parser::new_with_broken_link_callback(md, opts(), Some(&mut push));\n+\n+        // There's no need to thread an IdMap through to here because\n+        // the IDs generated aren't going to be emitted anywhere.\n+        let mut ids = IdMap::new();\n+        let iter = Footnotes::new(HeadingLinks::new(p, None, &mut ids));\n+\n+        for ev in iter {\n+            if let Event::Start(Tag::Link(_, dest, _)) = ev {\n+                debug!(\"found link: {}\", dest);\n+                links.push(match dest {\n+                    CowStr::Borrowed(s) => (s.to_owned(), locate(s)),\n+                    s @ (CowStr::Boxed(..) | CowStr::Inlined(..)) => (s.into_string(), None),\n+                });\n             }\n-            // This can happen for things other than intra-doc links, like `#1` expanded to `https://github.com/rust-lang/rust/issues/1`.\n-            None => span,\n-        }\n-    };\n-    let mut push = |link: BrokenLink<'_>| {\n-        let span = span_for_link(link.reference, link.span);\n-        shortcut_links.push((link.reference.to_owned(), span));\n-        None\n-    };\n-    let p = Parser::new_with_broken_link_callback(md, opts(), Some(&mut push));\n-\n-    // There's no need to thread an IdMap through to here because\n-    // the IDs generated aren't going to be emitted anywhere.\n-    let mut ids = IdMap::new();\n-    let iter = Footnotes::new(HeadingLinks::new(p.into_offset_iter(), None, &mut ids));\n-\n-    for ev in iter {\n-        if let Event::Start(Tag::Link(_, dest, _)) = ev.0 {\n-            debug!(\"found link: {}\", dest);\n-            let span = span_for_link(&dest, ev.1);\n-            links.push((dest.into_string(), span));\n         }\n     }\n "}, {"sha": "ea5bf94689bc7c150b626ce45fcb6fdd8a9977a2", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 34, "deletions": 28, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/0f2571235b4ac60190b9d2dfe745367671c27c0f/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f2571235b4ac60190b9d2dfe745367671c27c0f/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=0f2571235b4ac60190b9d2dfe745367671c27c0f", "patch": "@@ -180,7 +180,7 @@ struct DiagnosticInfo<'a> {\n     item: &'a Item,\n     dox: &'a str,\n     ori_link: &'a str,\n-    link_range: Range<usize>,\n+    link_range: Option<Range<usize>>,\n }\n \n #[derive(Clone, Debug, Hash)]\n@@ -920,7 +920,7 @@ impl LinkCollector<'_, '_> {\n         parent_node: Option<DefId>,\n         krate: CrateNum,\n         ori_link: String,\n-        link_range: Range<usize>,\n+        link_range: Option<Range<usize>>,\n     ) -> Option<ItemLink> {\n         trace!(\"considering link '{}'\", ori_link);\n \n@@ -1566,7 +1566,7 @@ fn report_diagnostic(\n     msg: &str,\n     item: &Item,\n     dox: &str,\n-    link_range: &Range<usize>,\n+    link_range: &Option<Range<usize>>,\n     decorate: impl FnOnce(&mut DiagnosticBuilder<'_>, Option<rustc_span::Span>),\n ) {\n     let hir_id = match cx.as_local_hir_id(item.def_id) {\n@@ -1584,26 +1584,31 @@ fn report_diagnostic(\n     cx.tcx.struct_span_lint_hir(lint, hir_id, sp, |lint| {\n         let mut diag = lint.build(msg);\n \n-        let span = super::source_span_for_markdown_range(cx, dox, link_range, attrs);\n-        if let Some(sp) = span {\n-            diag.set_span(sp);\n-        } else {\n-            // blah blah blah\\nblah\\nblah [blah] blah blah\\nblah blah\n-            //                       ^     ~~~~\n-            //                       |     link_range\n-            //                       last_new_line_offset\n-            let last_new_line_offset = dox[..link_range.start].rfind('\\n').map_or(0, |n| n + 1);\n-            let line = dox[last_new_line_offset..].lines().next().unwrap_or(\"\");\n-\n-            // Print the line containing the `link_range` and manually mark it with '^'s.\n-            diag.note(&format!(\n-                \"the link appears in this line:\\n\\n{line}\\n\\\n-                    {indicator: <before$}{indicator:^<found$}\",\n-                line = line,\n-                indicator = \"\",\n-                before = link_range.start - last_new_line_offset,\n-                found = link_range.len(),\n-            ));\n+        let span = link_range\n+            .as_ref()\n+            .and_then(|range| super::source_span_for_markdown_range(cx, dox, range, attrs));\n+\n+        if let Some(link_range) = link_range {\n+            if let Some(sp) = span {\n+                diag.set_span(sp);\n+            } else {\n+                // blah blah blah\\nblah\\nblah [blah] blah blah\\nblah blah\n+                //                       ^     ~~~~\n+                //                       |     link_range\n+                //                       last_new_line_offset\n+                let last_new_line_offset = dox[..link_range.start].rfind('\\n').map_or(0, |n| n + 1);\n+                let line = dox[last_new_line_offset..].lines().next().unwrap_or(\"\");\n+\n+                // Print the line containing the `link_range` and manually mark it with '^'s.\n+                diag.note(&format!(\n+                    \"the link appears in this line:\\n\\n{line}\\n\\\n+                     {indicator: <before$}{indicator:^<found$}\",\n+                    line = line,\n+                    indicator = \"\",\n+                    before = link_range.start - last_new_line_offset,\n+                    found = link_range.len(),\n+                ));\n+            }\n         }\n \n         decorate(&mut diag, span);\n@@ -1623,7 +1628,7 @@ fn resolution_failure(\n     path_str: &str,\n     disambiguator: Option<Disambiguator>,\n     dox: &str,\n-    link_range: Range<usize>,\n+    link_range: Option<Range<usize>>,\n     kinds: SmallVec<[ResolutionFailure<'_>; 3]>,\n ) {\n     report_diagnostic(\n@@ -1857,7 +1862,7 @@ fn anchor_failure(\n     item: &Item,\n     path_str: &str,\n     dox: &str,\n-    link_range: Range<usize>,\n+    link_range: Option<Range<usize>>,\n     failure: AnchorFailure,\n ) {\n     let msg = match failure {\n@@ -1882,7 +1887,7 @@ fn ambiguity_error(\n     item: &Item,\n     path_str: &str,\n     dox: &str,\n-    link_range: Range<usize>,\n+    link_range: Option<Range<usize>>,\n     candidates: Vec<Res>,\n ) {\n     let mut msg = format!(\"`{}` is \", path_str);\n@@ -1931,12 +1936,13 @@ fn suggest_disambiguator(\n     path_str: &str,\n     dox: &str,\n     sp: Option<rustc_span::Span>,\n-    link_range: &Range<usize>,\n+    link_range: &Option<Range<usize>>,\n ) {\n     let suggestion = disambiguator.suggestion();\n     let help = format!(\"to link to the {}, {}\", disambiguator.descr(), suggestion.descr());\n \n     if let Some(sp) = sp {\n+        let link_range = link_range.as_ref().expect(\"must have a link range if we have a span\");\n         let msg = if dox.bytes().nth(link_range.start) == Some(b'`') {\n             format!(\"`{}`\", suggestion.as_help(path_str))\n         } else {\n@@ -1955,7 +1961,7 @@ fn privacy_error(\n     item: &Item,\n     path_str: &str,\n     dox: &str,\n-    link_range: Range<usize>,\n+    link_range: Option<Range<usize>>,\n ) {\n     let sym;\n     let item_name = match item.name {"}, {"sha": "7c1a79722c9935c84b9b6cd6f602e908dd425db7", "filename": "src/test/rustdoc-ui/reference-links.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0f2571235b4ac60190b9d2dfe745367671c27c0f/src%2Ftest%2Frustdoc-ui%2Freference-links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f2571235b4ac60190b9d2dfe745367671c27c0f/src%2Ftest%2Frustdoc-ui%2Freference-links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Freference-links.rs?ref=0f2571235b4ac60190b9d2dfe745367671c27c0f", "patch": "@@ -0,0 +1,7 @@\n+// Test that errors point to the reference, not to the title text.\n+#![deny(broken_intra_doc_links)]\n+//! Links to [a] [link][a]\n+//!\n+//! [a]: std::process::Comman\n+//~^ ERROR unresolved\n+//~| ERROR unresolved"}, {"sha": "6ba73fbdb006de6c38c46b80b694811e9d3cac5e", "filename": "src/test/rustdoc-ui/reference-links.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0f2571235b4ac60190b9d2dfe745367671c27c0f/src%2Ftest%2Frustdoc-ui%2Freference-links.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f2571235b4ac60190b9d2dfe745367671c27c0f/src%2Ftest%2Frustdoc-ui%2Freference-links.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Freference-links.stderr?ref=0f2571235b4ac60190b9d2dfe745367671c27c0f", "patch": "@@ -0,0 +1,20 @@\n+error: unresolved link to `std::process::Comman`\n+  --> $DIR/reference-links.rs:5:10\n+   |\n+LL | //! [a]: std::process::Comman\n+   |          ^^^^^^^^^^^^^^^^^^^^ no item named `Comman` in module `process`\n+   |\n+note: the lint level is defined here\n+  --> $DIR/reference-links.rs:2:9\n+   |\n+LL | #![deny(broken_intra_doc_links)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: unresolved link to `std::process::Comman`\n+  --> $DIR/reference-links.rs:5:10\n+   |\n+LL | //! [a]: std::process::Comman\n+   |          ^^^^^^^^^^^^^^^^^^^^ no item named `Comman` in module `process`\n+\n+error: aborting due to 2 previous errors\n+"}]}