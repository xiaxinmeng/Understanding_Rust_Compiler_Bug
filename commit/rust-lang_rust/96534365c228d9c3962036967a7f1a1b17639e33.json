{"sha": "96534365c228d9c3962036967a7f1a1b17639e33", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk2NTM0MzY1YzIyOGQ5YzM5NjIwMzY5NjdhN2YxYTFiMTc2MzllMzM=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-08-27T23:26:35Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-08-30T01:25:22Z"}, "message": "rustc: Make `<` and `=` into traits", "tree": {"sha": "2be1b50575fcf57f7627418950731d3b17de7b89", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2be1b50575fcf57f7627418950731d3b17de7b89"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/96534365c228d9c3962036967a7f1a1b17639e33", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/96534365c228d9c3962036967a7f1a1b17639e33", "html_url": "https://github.com/rust-lang/rust/commit/96534365c228d9c3962036967a7f1a1b17639e33", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/96534365c228d9c3962036967a7f1a1b17639e33/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "94720fcea762338be3edfb29cbc8292e761f5585", "url": "https://api.github.com/repos/rust-lang/rust/commits/94720fcea762338be3edfb29cbc8292e761f5585", "html_url": "https://github.com/rust-lang/rust/commit/94720fcea762338be3edfb29cbc8292e761f5585"}], "stats": {"total": 3311, "additions": 2984, "deletions": 327}, "files": [{"sha": "7e1cb4e1a18c790ebec7403d54b0f13c7013ef7d", "filename": "src/cargo/cargo.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/96534365c228d9c3962036967a7f1a1b17639e33/src%2Fcargo%2Fcargo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96534365c228d9c3962036967a7f1a1b17639e33/src%2Fcargo%2Fcargo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcargo%2Fcargo.rs?ref=96534365c228d9c3962036967a7f1a1b17639e33", "patch": "@@ -25,6 +25,25 @@ type package = {\n     versions: ~[(~str, ~str)]\n };\n \n+impl package : cmp::Ord {\n+    pure fn lt(&&other: package) -> bool {\n+        if self.name.lt(other.name) { return true; }\n+        if other.name.lt(self.name) { return false; }\n+        if self.uuid.lt(other.uuid) { return true; }\n+        if other.uuid.lt(self.uuid) { return false; }\n+        if self.url.lt(other.url) { return true; }\n+        if other.url.lt(self.url) { return false; }\n+        if self.method.lt(other.method) { return true; }\n+        if other.method.lt(self.method) { return false; }\n+        if self.description.lt(other.description) { return true; }\n+        if other.description.lt(self.description) { return false; }\n+        if self.tags.lt(other.tags) { return true; }\n+        if other.tags.lt(self.tags) { return false; }\n+        if self.versions.lt(other.versions) { return true; }\n+        return false;\n+    }\n+}\n+\n type local_package = {\n     name: ~str,\n     metaname: ~str,\n@@ -74,6 +93,12 @@ type options = {\n \n enum mode { system_mode, user_mode, local_mode }\n \n+impl mode : cmp::Eq {\n+    pure fn eq(&&other: mode) -> bool {\n+        (self as uint) == (other as uint)\n+    }\n+}\n+\n fn opts() -> ~[getopts::Opt] {\n     ~[optflag(~\"g\"), optflag(~\"G\"), optflag(~\"test\"),\n      optflag(~\"h\"), optflag(~\"help\")]"}, {"sha": "1423d0050dfdc5c1784d644323a0d1880bc5cd10", "filename": "src/fuzzer/fuzzer.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/96534365c228d9c3962036967a7f1a1b17639e33/src%2Ffuzzer%2Ffuzzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96534365c228d9c3962036967a7f1a1b17639e33/src%2Ffuzzer%2Ffuzzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffuzzer%2Ffuzzer.rs?ref=96534365c228d9c3962036967a7f1a1b17639e33", "patch": "@@ -8,6 +8,12 @@ import syntax::diagnostic;\n enum test_mode { tm_converge, tm_run, }\n type context = { mode: test_mode }; // + rng\n \n+impl test_mode : cmp::Eq {\n+    pure fn eq(&&other: test_mode) -> bool {\n+        (self as uint) == (other as uint)\n+    }\n+}\n+\n fn write_file(filename: &Path, content: ~str) {\n     result::get(\n         io::file_writer(filename, ~[io::Create, io::Truncate]))"}, {"sha": "9ed06ab27055533e21e6d3b36835f6729310de09", "filename": "src/libcore/bool.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/96534365c228d9c3962036967a7f1a1b17639e33/src%2Flibcore%2Fbool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96534365c228d9c3962036967a7f1a1b17639e33/src%2Flibcore%2Fbool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbool.rs?ref=96534365c228d9c3962036967a7f1a1b17639e33", "patch": "@@ -6,6 +6,8 @@\n \n //! Boolean logic\n \n+import cmp::Eq;\n+\n export not, and, or, xor, implies;\n export eq, ne, is_true, is_false;\n export from_str, to_str, all_values, to_bit;\n@@ -67,6 +69,12 @@ fn all_values(blk: fn(v: bool)) {\n /// converts truth value to an 8 bit byte\n pure fn to_bit(v: bool) -> u8 { if v { 1u8 } else { 0u8 } }\n \n+impl bool : cmp::Eq {\n+    pure fn eq(&&other: bool) -> bool {\n+        self == other\n+    }\n+}\n+\n #[test]\n fn test_bool_from_str() {\n     do all_values |v| {"}, {"sha": "7a1376898dbd9dc282fef852c086762a11b18969", "filename": "src/libcore/box.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/96534365c228d9c3962036967a7f1a1b17639e33/src%2Flibcore%2Fbox.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96534365c228d9c3962036967a7f1a1b17639e33/src%2Flibcore%2Fbox.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbox.rs?ref=96534365c228d9c3962036967a7f1a1b17639e33", "patch": "@@ -4,13 +4,23 @@\n #[forbid(deprecated_mode)];\n #[forbid(deprecated_pattern)];\n \n+import cmp::{Eq, Ord};\n+\n export ptr_eq;\n \n pure fn ptr_eq<T>(a: @T, b: @T) -> bool {\n     //! Determine if two shared boxes point to the same object\n     unsafe { ptr::addr_of(*a) == ptr::addr_of(*b) }\n }\n \n+impl<T:Eq> @const T : Eq {\n+    pure fn eq(&&other: @const T) -> bool { *self == *other }\n+}\n+\n+impl<T:Ord> @const T : Ord {\n+    pure fn lt(&&other: @const T) -> bool { *self < *other }\n+}\n+\n #[test]\n fn test() {\n     let x = @3;"}, {"sha": "8acbc08b0e8f4da4d3b4ed861854597a30d69240", "filename": "src/libcore/char.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/96534365c228d9c3962036967a7f1a1b17639e33/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96534365c228d9c3962036967a7f1a1b17639e33/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=96534365c228d9c3962036967a7f1a1b17639e33", "patch": "@@ -4,6 +4,8 @@\n #[forbid(deprecated_mode)];\n #[forbid(deprecated_pattern)];\n \n+import cmp::Eq;\n+\n /*\n     Lu  Uppercase_Letter    an uppercase letter\n     Ll  Lowercase_Letter    a lowercase letter\n@@ -187,6 +189,10 @@ pure fn cmp(a: char, b: char) -> int {\n     else { 0 }\n }\n \n+impl char: Eq {\n+    pure fn eq(&&other: char) -> bool { self == other }\n+}\n+\n #[test]\n fn test_is_lowercase() {\n     assert is_lowercase('a');"}, {"sha": "ce84674ae8362422dbe66bd2a0b41a5a1395f954", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/96534365c228d9c3962036967a7f1a1b17639e33/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96534365c228d9c3962036967a7f1a1b17639e33/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=96534365c228d9c3962036967a7f1a1b17639e33", "patch": "@@ -28,13 +28,13 @@ trait Eq {\n }\n \n pure fn lt<T: Ord>(v1: &T, v2: &T) -> bool {\n-    v1.lt(*v2)\n+    v1.lt(v2)\n }\n \n pure fn le<T: Ord Eq>(v1: &T, v2: &T) -> bool {\n-    v1.lt(*v2) || v1.eq(*v2)\n+    v1.lt(v2) || v1.eq(v2)\n }\n \n pure fn eq<T: Eq>(v1: &T, v2: &T) -> bool {\n-    v1.eq(*v2)\n+    v1.eq(v2)\n }"}, {"sha": "626b6e512b2ffcc61cc31ea552cf3ebc02bb5d42", "filename": "src/libcore/core.rc", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/96534365c228d9c3962036967a7f1a1b17639e33/src%2Flibcore%2Fcore.rc", "raw_url": "https://github.com/rust-lang/rust/raw/96534365c228d9c3962036967a7f1a1b17639e33/src%2Flibcore%2Fcore.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rc?ref=96534365c228d9c3962036967a7f1a1b17639e33", "patch": "@@ -57,6 +57,8 @@ export num;\n export path;\n export managed;\n export flate;\n+export unit;\n+export uniq;\n \n // NDM seems to be necessary for resolve to work\n export option_iter;\n@@ -183,6 +185,10 @@ mod at_vec;\n mod bool;\n #[warn(non_camel_case_types)]\n mod tuple;\n+#[warn(non_camel_case_types)]\n+mod unit;\n+#[warn(non_camel_case_types)]\n+mod uniq;\n \n // Ubiquitous-utility-type modules\n "}, {"sha": "28c08a6c955d9713c9c7ae247214667d71b7f857", "filename": "src/libcore/core.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/96534365c228d9c3962036967a7f1a1b17639e33/src%2Flibcore%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96534365c228d9c3962036967a7f1a1b17639e33/src%2Flibcore%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rs?ref=96534365c228d9c3962036967a7f1a1b17639e33", "patch": "@@ -18,8 +18,9 @@ import PosixPath = path::PosixPath;\n import tuple::{TupleOps, ExtendedTupleOps};\n import str::{StrSlice, UniqueStr};\n import vec::{ConstVector, CopyableVector, ImmutableVector};\n-import vec::{ImmutableCopyableVector};\n-import iter::{BaseIter, ExtendedIter, CopyableIter, Times, TimesIx};\n+import vec::{ImmutableEqVector, ImmutableCopyableVector};\n+import iter::{BaseIter, ExtendedIter, EqIter, CopyableIter};\n+import iter::{CopyableOrderedIter, Times, TimesIx};\n import num::Num;\n import ptr::Ptr;\n import to_str::ToStr;\n@@ -33,8 +34,8 @@ export Num, Times, TimesIx;\n // The following exports are the common traits\n export StrSlice, UniqueStr;\n export ConstVector, CopyableVector, ImmutableVector;\n-export ImmutableCopyableVector, IterTraitExtensions;\n-export BaseIter, CopyableIter, ExtendedIter;\n+export ImmutableEqVector, ImmutableCopyableVector, IterTraitExtensions;\n+export BaseIter, CopyableIter, CopyableOrderedIter, ExtendedIter, EqIter;\n export TupleOps, ExtendedTupleOps;\n export Ptr;\n export ToStr;"}, {"sha": "ea9558888319dbccb8b1c17e7ee11f2a4549612e", "filename": "src/libcore/either.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/96534365c228d9c3962036967a7f1a1b17639e33/src%2Flibcore%2Feither.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96534365c228d9c3962036967a7f1a1b17639e33/src%2Flibcore%2Feither.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Feither.rs?ref=96534365c228d9c3962036967a7f1a1b17639e33", "patch": "@@ -4,6 +4,7 @@\n \n //! A type that represents one of two alternatives\n \n+import cmp::Eq;\n import result::Result;\n \n /// The either type\n@@ -125,6 +126,25 @@ pure fn unwrap_right<T,U>(+eith: Either<T,U>) -> U {\n     }\n }\n \n+impl<T:Eq,U:Eq> Either<T,U> : Eq {\n+    pure fn eq(&&other: Either<T,U>) -> bool {\n+        match self {\n+            Left(a) => {\n+                match other {\n+                    Left(b) => a.eq(b),\n+                    Right(_) => false\n+                }\n+            }\n+            Right(a) => {\n+                match other {\n+                    Left(_) => false,\n+                    Right(b) => a.eq(b)\n+                }\n+            }\n+        }\n+    }\n+}\n+\n #[test]\n fn test_either_left() {\n     let val = Left(10);"}, {"sha": "376a6bc2f56a1a26331aff386faa846c81aed6ac", "filename": "src/libcore/extfmt.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/96534365c228d9c3962036967a7f1a1b17639e33/src%2Flibcore%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96534365c228d9c3962036967a7f1a1b17639e33/src%2Flibcore%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fextfmt.rs?ref=96534365c228d9c3962036967a7f1a1b17639e33", "patch": "@@ -25,6 +25,7 @@ debug!(\"hello, %s!\", \"world\");\n \n */\n \n+import cmp::Eq;\n import option::{Some, None};\n \n \n@@ -383,7 +384,24 @@ mod rt {\n               count_implied => 1u\n             };\n     }\n+\n     enum pad_mode { pad_signed, pad_unsigned, pad_nozero, pad_float }\n+\n+    impl pad_mode: Eq {\n+        pure fn eq(&&other: pad_mode) -> bool {\n+            match (self, other) {\n+                (pad_signed, pad_signed) => true,\n+                (pad_unsigned, pad_unsigned) => true,\n+                (pad_nozero, pad_nozero) => true,\n+                (pad_float, pad_float) => true,\n+                (pad_signed, _) => false,\n+                (pad_unsigned, _) => false,\n+                (pad_nozero, _) => false,\n+                (pad_float, _) => false\n+            }\n+        }\n+    }\n+\n     fn pad(cv: conv, &s: ~str, mode: pad_mode) -> ~str {\n         let uwidth : uint = match cv.width {\n           count_implied => return s,"}, {"sha": "e3f274ebe59f90da66708660c3066409e67215ed", "filename": "src/libcore/float.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/96534365c228d9c3962036967a7f1a1b17639e33/src%2Flibcore%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96534365c228d9c3962036967a7f1a1b17639e33/src%2Flibcore%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffloat.rs?ref=96534365c228d9c3962036967a7f1a1b17639e33", "patch": "@@ -41,6 +41,7 @@ import f64::{lgamma, ln, log_radix, ln1p, log10, log2, ilog_radix};\n import f64::{modf, pow, round, sinh, tanh, tgamma, trunc};\n import f64::signbit;\n import f64::{j0, j1, jn, y0, y1, yn};\n+import cmp::{Eq, Ord};\n import num::from_int;\n \n const NaN: float = 0.0/0.0;\n@@ -311,7 +312,7 @@ fn from_str(num: &str) -> Option<float> {\n       }\n    }\n \n-   if (c == 'e') | (c == 'E') {//Examine exponent\n+   if (c == 'e') || (c == 'E') { //Examine exponent\n       let mut exponent = 0u;\n       let mut neg_exponent = false;\n       if(pos < len) {\n@@ -414,6 +415,14 @@ pure fn sin(x: float) -> float { f64::sin(x as f64) as float }\n pure fn cos(x: float) -> float { f64::cos(x as f64) as float }\n pure fn tan(x: float) -> float { f64::tan(x as f64) as float }\n \n+impl float: Eq {\n+    pure fn eq(&&other: float) -> bool { self == other }\n+}\n+\n+impl float: Ord {\n+    pure fn lt(&&other: float) -> bool { self < other }\n+}\n+\n impl float: num::Num {\n     pure fn add(&&other: float)    -> float { return self + other; }\n     pure fn sub(&&other: float)    -> float { return self - other; }\n@@ -521,7 +530,7 @@ fn test_to_str_inf() {\n \n #[test]\n fn test_traits() {\n-    fn test<U:num::Num>(ten: &U) {\n+    fn test<U:num::Num cmp::Eq>(ten: &U) {\n         assert (ten.to_int() == 10);\n \n         let two: U = from_int(2);"}, {"sha": "fb75438aa6586a265777a7817f05bfdbd1ff337c", "filename": "src/libcore/int-template.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/96534365c228d9c3962036967a7f1a1b17639e33/src%2Flibcore%2Fint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96534365c228d9c3962036967a7f1a1b17639e33/src%2Flibcore%2Fint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fint-template.rs?ref=96534365c228d9c3962036967a7f1a1b17639e33", "patch": "@@ -239,7 +239,7 @@ fn test_to_str() {\n \n #[test]\n fn test_interfaces() {\n-    fn test<U:num::Num>(+ten: U) {\n+    fn test<U:num::Num cmp::Eq>(+ten: U) {\n         assert (ten.to_int() == 10);\n \n         let two: U = from_int(2);"}, {"sha": "69e95274f7c6b9a1bb2308d3a9787b101e57cad0", "filename": "src/libcore/io.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/96534365c228d9c3962036967a7f1a1b17639e33/src%2Flibcore%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96534365c228d9c3962036967a7f1a1b17639e33/src%2Flibcore%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fio.rs?ref=96534365c228d9c3962036967a7f1a1b17639e33", "patch": "@@ -6,6 +6,7 @@ Basic input/output\n \n import result::Result;\n \n+import cmp::Eq;\n import dvec::DVec;\n import libc::{c_int, c_long, c_uint, c_void, size_t, ssize_t};\n import libc::consts::os::posix88::*;\n@@ -324,6 +325,15 @@ enum FileFlag { Append, Create, Truncate, NoFlag, }\n // What type of writer are we?\n enum WriterType { Screen, File }\n \n+impl WriterType: Eq {\n+    pure fn eq(&&other: WriterType) -> bool {\n+        match (self, other) {\n+            (Screen, Screen) | (File, File) => true,\n+            (Screen, _) | (File, _) => false\n+        }\n+    }\n+}\n+\n // FIXME (#2004): Seekable really should be orthogonal.\n // FIXME (#2004): eventually u64\n trait Writer {"}, {"sha": "39fbcf63961b59c8924f3c1fd0367ad7053588c5", "filename": "src/libcore/iter-trait.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/96534365c228d9c3962036967a7f1a1b17639e33/src%2Flibcore%2Fiter-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96534365c228d9c3962036967a7f1a1b17639e33/src%2Flibcore%2Fiter-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter-trait.rs?ref=96534365c228d9c3962036967a7f1a1b17639e33", "patch": "@@ -2,6 +2,7 @@\n // workaround our lack of traits and lack of macros.  See core.{rc,rs} for\n // how this file is used.\n \n+import cmp::{Eq, Ord};\n import inst::{IMPL_T, EACH, SIZE_HINT};\n export extensions;\n \n@@ -17,6 +18,9 @@ impl<A> IMPL_T<A>: iter::ExtendedIter<A> {\n     pure fn foldl<B>(+b0: B, blk: fn(B, A) -> B) -> B {\n         iter::foldl(self, b0, blk)\n     }\n+}\n+\n+impl<A: Eq> IMPL_T<A>: iter::EqIter<A> {\n     pure fn contains(x: A) -> bool { iter::contains(self, x) }\n     pure fn count(x: A) -> uint { iter::count(self, x) }\n     pure fn position(f: fn(A) -> bool) -> Option<uint> {\n@@ -38,7 +42,11 @@ impl<A: copy> IMPL_T<A>: iter::CopyableIter<A> {\n     //     iter::flat_map_to_vec(self, op)\n     // }\n \n+    pure fn find(p: fn(A) -> bool) -> Option<A> { iter::find(self, p) }\n+}\n+\n+impl<A: copy Ord> IMPL_T<A>: iter::CopyableOrderedIter<A> {\n     pure fn min() -> A { iter::min(self) }\n     pure fn max() -> A { iter::max(self) }\n-    pure fn find(p: fn(A) -> bool) -> Option<A> { iter::find(self, p) }\n }\n+"}, {"sha": "91a4afc7318314341b238b55bef395fc0ffdb904", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/96534365c228d9c3962036967a7f1a1b17639e33/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96534365c228d9c3962036967a7f1a1b17639e33/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=96534365c228d9c3962036967a7f1a1b17639e33", "patch": "@@ -1,3 +1,5 @@\n+use cmp::{Eq, Ord};\n+\n /// A function used to initialize the elements of a sequence\n type InitOp<T> = fn(uint) -> T;\n \n@@ -11,6 +13,9 @@ trait ExtendedIter<A> {\n     pure fn all(blk: fn(A) -> bool) -> bool;\n     pure fn any(blk: fn(A) -> bool) -> bool;\n     pure fn foldl<B>(+b0: B, blk: fn(B, A) -> B) -> B;\n+}\n+\n+trait EqIter<A:Eq> {\n     pure fn contains(x: A) -> bool;\n     pure fn count(x: A) -> uint;\n     pure fn position(f: fn(A) -> bool) -> Option<uint>;\n@@ -27,9 +32,12 @@ trait CopyableIter<A:copy> {\n     pure fn filter_to_vec(pred: fn(A) -> bool) -> ~[A];\n     pure fn map_to_vec<B>(op: fn(A) -> B) -> ~[B];\n     pure fn to_vec() -> ~[A];\n+    pure fn find(p: fn(A) -> bool) -> Option<A>;\n+}\n+\n+trait CopyableOrderedIter<A:copy Ord> {\n     pure fn min() -> A;\n     pure fn max() -> A;\n-    pure fn find(p: fn(A) -> bool) -> Option<A>;\n }\n \n // A trait for sequences that can be by imperatively pushing elements\n@@ -116,14 +124,14 @@ pure fn to_vec<A:copy,IA:BaseIter<A>>(self: IA) -> ~[A] {\n     foldl::<A,~[A],IA>(self, ~[], |r, a| vec::append(r, ~[a]))\n }\n \n-pure fn contains<A,IA:BaseIter<A>>(self: IA, x: A) -> bool {\n+pure fn contains<A:Eq,IA:BaseIter<A>>(self: IA, x: A) -> bool {\n     for self.each |a| {\n         if a == x { return true; }\n     }\n     return false;\n }\n \n-pure fn count<A,IA:BaseIter<A>>(self: IA, x: A) -> uint {\n+pure fn count<A:Eq,IA:BaseIter<A>>(self: IA, x: A) -> uint {\n     do foldl(self, 0u) |count, value| {\n         if value == x {\n             count + 1u\n@@ -155,7 +163,7 @@ pure fn repeat(times: uint, blk: fn() -> bool) {\n     }\n }\n \n-pure fn min<A:copy,IA:BaseIter<A>>(self: IA) -> A {\n+pure fn min<A:copy Ord,IA:BaseIter<A>>(self: IA) -> A {\n     match do foldl::<A,Option<A>,IA>(self, None) |a, b| {\n         match a {\n           Some(a_) if a_ < b => {"}, {"sha": "281872b55865215eb134e2ae533e498b3ce19172", "filename": "src/libcore/os.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/96534365c228d9c3962036967a7f1a1b17639e33/src%2Flibcore%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96534365c228d9c3962036967a7f1a1b17639e33/src%2Flibcore%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fos.rs?ref=96534365c228d9c3962036967a7f1a1b17639e33", "patch": "@@ -222,7 +222,7 @@ mod global_env {\n         fn getenv(n: &str) -> Option<~str> {\n             unsafe {\n                 let s = str::as_c_str(n, libc::getenv);\n-                return if unsafe::reinterpret_cast(s) == 0 {\n+                return if ptr::null::<u8>() == unsafe::reinterpret_cast(s) {\n                     option::None::<~str>\n                 } else {\n                     let s = unsafe::reinterpret_cast(s);"}, {"sha": "052e853e22e27489aca51085b9f838b5b7a534c2", "filename": "src/libcore/path.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/96534365c228d9c3962036967a7f1a1b17639e33/src%2Flibcore%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96534365c228d9c3962036967a7f1a1b17639e33/src%2Flibcore%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpath.rs?ref=96534365c228d9c3962036967a7f1a1b17639e33", "patch": "@@ -2,6 +2,8 @@\n #[forbid(deprecated_mode)];\n #[forbid(deprecated_pattern)];\n \n+use cmp::Eq;\n+\n struct WindowsPath {\n     host: Option<~str>;\n     device: Option<~str>;\n@@ -62,6 +64,13 @@ impl PosixPath : ToStr {\n     }\n }\n \n+impl PosixPath : Eq {\n+    pure fn eq(&&other: PosixPath) -> bool {\n+        return self.is_absolute == other.is_absolute &&\n+            self.components == other.components;\n+    }\n+}\n+\n // FIXME (#3227): when default methods in traits are working, de-duplicate\n // PosixPath and WindowsPath, most of their methods are common.\n impl PosixPath : GenericPath {"}, {"sha": "38ccd7a735e16819d5a54103edb03d2fa6def7f6", "filename": "src/libcore/pipes.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/96534365c228d9c3962036967a7f1a1b17639e33/src%2Flibcore%2Fpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96534365c228d9c3962036967a7f1a1b17639e33/src%2Flibcore%2Fpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpipes.rs?ref=96534365c228d9c3962036967a7f1a1b17639e33", "patch": "@@ -76,6 +76,7 @@ bounded and unbounded protocols allows for less code duplication.\n #[forbid(deprecated_mode)];\n #[forbid(deprecated_pattern)];\n \n+import cmp::Eq;\n import unsafe::{forget, reinterpret_cast, transmute};\n import either::{Either, Left, Right};\n import option::unwrap;\n@@ -123,6 +124,12 @@ enum State {\n     Terminated\n }\n \n+impl State: Eq {\n+    pure fn eq(&&other: State) -> bool {\n+        (self as uint) == (other as uint)\n+    }\n+}\n+\n struct BufferHeader {\n     // Tracks whether this buffer needs to be freed. We can probably\n     // get away with restricting it to 0 or 1, if we're careful."}, {"sha": "78469e6095d26725f603d8daddd7b37f54153320", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 29, "deletions": 2, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/96534365c228d9c3962036967a7f1a1b17639e33/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96534365c228d9c3962036967a7f1a1b17639e33/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=96534365c228d9c3962036967a7f1a1b17639e33", "patch": "@@ -18,7 +18,7 @@ export buf_len;\n export position;\n export Ptr;\n \n-import cmp::Eq;\n+import cmp::{Eq, Ord};\n import libc::{c_void, size_t};\n \n #[nolink]\n@@ -174,7 +174,34 @@ impl<T> *T: Ptr {\n \n // Equality for pointers\n impl<T> *const T : Eq {\n-    pure fn eq(&&other: *const T) -> bool { self == other }\n+    pure fn eq(&&other: *const T) -> bool unsafe {\n+        let a: uint = unsafe::reinterpret_cast(self);\n+        let b: uint = unsafe::reinterpret_cast(other);\n+        return a == b;\n+    }\n+}\n+\n+// Comparison for pointers\n+impl<T> *const T : Ord {\n+    pure fn lt(&&other: *const T) -> bool unsafe {\n+        let a: uint = unsafe::reinterpret_cast(self);\n+        let b: uint = unsafe::reinterpret_cast(other);\n+        return a < b;\n+    }\n+}\n+\n+// Equality for region pointers\n+impl<T:Eq> &const T : Eq {\n+    pure fn eq(&&other: &const T) -> bool {\n+        return *self == *other;\n+    }\n+}\n+\n+// Comparison for region pointers\n+impl<T:Ord> &const T : Ord {\n+    pure fn lt(&&other: &const T) -> bool {\n+        return *self < *other;\n+    }\n }\n \n #[test]"}, {"sha": "1a4592954e3a441bee651a02d678c3e8888a6b57", "filename": "src/libcore/rand.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/96534365c228d9c3962036967a7f1a1b17639e33/src%2Flibcore%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96534365c228d9c3962036967a7f1a1b17639e33/src%2Flibcore%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frand.rs?ref=96534365c228d9c3962036967a7f1a1b17639e33", "patch": "@@ -408,7 +408,8 @@ mod tests {\n     #[test]\n     fn choose_option() {\n         let r = rand::Rng();\n-        assert r.choose_option::<int>([]).is_none();\n+        let x: Option<int> = r.choose_option([]);\n+        assert x.is_none();\n         assert r.choose_option([1, 1, 1]) == Some(1);\n     }\n \n@@ -431,7 +432,8 @@ mod tests {\n             {weight: 0u, item: 42},\n             {weight: 1u, item: 43}\n         ]) == Some(43);\n-        assert r.choose_weighted_option::<int>([]).is_none();\n+        let v: Option<int> = r.choose_weighted_option([]);\n+        assert v.is_none();\n     }\n \n     #[test]"}, {"sha": "bdd32aa8e666701b0e539541f8d90947f0b36499", "filename": "src/libcore/result.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/96534365c228d9c3962036967a7f1a1b17639e33/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96534365c228d9c3962036967a7f1a1b17639e33/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=96534365c228d9c3962036967a7f1a1b17639e33", "patch": "@@ -1,5 +1,6 @@\n //! A type representing either success or failure\n \n+import cmp::Eq;\n import either::Either;\n \n /// The result type\n@@ -352,6 +353,25 @@ fn unwrap<T, U>(-res: Result<T, U>) -> T {\n     }\n }\n \n+impl<T:Eq,U:Eq> Result<T,U> : Eq {\n+    pure fn eq(&&other: Result<T,U>) -> bool {\n+        match self {\n+            Ok(e0a) => {\n+                match other {\n+                    Ok(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            Err(e0a) => {\n+                match other {\n+                    Err(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+        }\n+    }\n+}\n+\n #[cfg(test)]\n mod tests {\n     fn op1() -> result::Result<int, ~str> { result::Ok(666) }"}, {"sha": "7ec535365944d4404baa817e47a381a53f1cc150", "filename": "src/libcore/str.rs", "status": "modified", "additions": 32, "deletions": 6, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/96534365c228d9c3962036967a7f1a1b17639e33/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96534365c228d9c3962036967a7f1a1b17639e33/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=96534365c228d9c3962036967a7f1a1b17639e33", "patch": "@@ -7,7 +7,7 @@\n  * some heavy-duty uses, try std::rope.\n  */\n \n-import cmp::Eq;\n+import cmp::{Eq, Ord};\n import libc::size_t;\n import io::WriterUtil;\n \n@@ -671,8 +671,6 @@ Section: Comparing strings\n \n /// Bytewise slice equality\n pure fn eq_slice(a: &str, b: &str) -> bool {\n-    // FIXME (#2627): This should just be \"a == b\" but that calls into the\n-    // shape code.\n     let a_len = a.len();\n     let b_len = b.len();\n     if a_len != b_len { return false; }\n@@ -692,33 +690,61 @@ pure fn eq(a: &~str, b: &~str) -> bool {\n     eq_slice(*a, *b)\n }\n \n+/// Bytewise slice less than\n+pure fn lt(a: &str, b: &str) -> bool {\n+    let (a_len, b_len) = (a.len(), b.len());\n+    let mut end = uint::min(a_len, b_len);\n+\n+    let mut i = 0;\n+    while i < end {\n+        let (c_a, c_b) = (a[i], b[i]);\n+        if c_a < c_b { return true; }\n+        if c_a > c_b { return false; }\n+        i += 1;\n+    }\n+\n+    return a_len < b_len;\n+}\n+\n /// Bytewise less than or equal\n pure fn le(a: &~str, b: &~str) -> bool { *a <= *b }\n \n-#[cfg(notest)]\n impl &str: Eq {\n     #[inline(always)]\n     pure fn eq(&&other: &str) -> bool {\n         eq_slice(self, other)\n     }\n }\n \n-#[cfg(notest)]\n impl ~str: Eq {\n     #[inline(always)]\n     pure fn eq(&&other: ~str) -> bool {\n         eq_slice(self, other)\n     }\n }\n \n-#[cfg(notest)]\n impl @str: Eq {\n     #[inline(always)]\n     pure fn eq(&&other: @str) -> bool {\n         eq_slice(self, other)\n     }\n }\n \n+impl ~str : Ord {\n+    #[inline(always)]\n+    pure fn lt(&&other: ~str) -> bool { lt(self, other) }\n+}\n+\n+impl &str : Ord {\n+    #[inline(always)]\n+    pure fn lt(&&other: &str) -> bool { lt(self, other) }\n+}\n+\n+impl @str : Ord {\n+    #[inline(always)]\n+    pure fn lt(&&other: @str) -> bool { lt(self, other) }\n+}\n+\n /// String hash function\n pure fn hash(s: &~str) -> uint {\n     hash::hash_str(*s) as uint"}, {"sha": "bccd4e461c8f10d5f794c60afa1f2a9e5c5ec017", "filename": "src/libcore/sys.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/96534365c228d9c3962036967a7f1a1b17639e33/src%2Flibcore%2Fsys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96534365c228d9c3962036967a7f1a1b17639e33/src%2Flibcore%2Fsys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsys.rs?ref=96534365c228d9c3962036967a7f1a1b17639e33", "patch": "@@ -1,5 +1,7 @@\n //! Misc low level stuff\n \n+use cmp::{Eq, Ord};\n+\n export TypeDesc;\n export Closure;\n export get_type_desc;\n@@ -38,16 +40,16 @@ extern mod rusti {\n \n /// Compares contents of two pointers using the default method.\n /// Equivalent to `*x1 == *x2`.  Useful for hashtables.\n-pure fn shape_eq<T>(x1: &T, x2: &T) -> bool {\n+pure fn shape_eq<T:Eq>(x1: &T, x2: &T) -> bool {\n     *x1 == *x2\n }\n \n-pure fn shape_lt<T>(x1: &T, x2: &T) -> bool {\n+pure fn shape_lt<T:Ord>(x1: &T, x2: &T) -> bool {\n     *x1 < *x2\n }\n \n-pure fn shape_le<T>(x1: &T, x2: &T) -> bool {\n-    *x1 < *x2\n+pure fn shape_le<T:Ord>(x1: &T, x2: &T) -> bool {\n+    *x1 <= *x2\n }\n \n /**"}, {"sha": "8cb3c10c40b69baf9c2e0ef677b7fc789f146af0", "filename": "src/libcore/task.rs", "status": "modified", "additions": 41, "deletions": 3, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/96534365c228d9c3962036967a7f1a1b17639e33/src%2Flibcore%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96534365c228d9c3962036967a7f1a1b17639e33/src%2Flibcore%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask.rs?ref=96534365c228d9c3962036967a7f1a1b17639e33", "patch": "@@ -27,6 +27,7 @@\n  * ~~~\n  */\n \n+import cmp::Eq;\n import result::Result;\n \n export Task;\n@@ -79,7 +80,15 @@ export PlatformThread;\n /* Data types */\n \n /// A handle to a task\n-enum Task { TaskHandle(task_id) }\n+enum Task {\n+    TaskHandle(task_id)\n+}\n+\n+impl Task : cmp::Eq {\n+    pure fn eq(&&other: Task) -> bool {\n+        *self == *other\n+    }\n+}\n \n /**\n  * Indicates the manner in which a task exited.\n@@ -97,12 +106,33 @@ enum TaskResult {\n     Failure,\n }\n \n+impl TaskResult: Eq {\n+    pure fn eq(&&other: TaskResult) -> bool {\n+        match (self, other) {\n+            (Success, Success) | (Failure, Failure) => true,\n+            (Success, _) | (Failure, _) => false\n+        }\n+    }\n+}\n+\n /// A message type for notifying of task lifecycle events\n enum Notification {\n     /// Sent when a task exits with the task handle and result\n     Exit(Task, TaskResult)\n }\n \n+impl Notification : cmp::Eq {\n+    pure fn eq(&&other: Notification) -> bool {\n+        match self {\n+            Exit(e0a, e1a) => {\n+                match other {\n+                    Exit(e0b, e1b) => e0a == e0b && e1a == e1b\n+                }\n+            }\n+        }\n+    }\n+}\n+\n /// Scheduler modes\n enum SchedMode {\n     /// All tasks run in the same OS thread\n@@ -1273,6 +1303,14 @@ type LocalDataKey<T: owned> = &fn(+@T);\n trait LocalData { }\n impl<T: owned> @T: LocalData { }\n \n+impl LocalData: Eq {\n+    pure fn eq(&&other: LocalData) -> bool unsafe {\n+        let ptr_a: (uint, uint) = unsafe::reinterpret_cast(self);\n+        let ptr_b: (uint, uint) = unsafe::reinterpret_cast(other);\n+        return ptr_a == ptr_b;\n+    }\n+}\n+\n // We use dvec because it's the best data structure in core. If TLS is used\n // heavily in future, this could be made more efficient with a proper map.\n type TaskLocalElement = (*libc::c_void, *libc::c_void, LocalData);\n@@ -1743,13 +1781,13 @@ fn test_spawn_listiner_bidi() {\n     let ch = do spawn_listener |po| {\n         // Now the child has a port called 'po' to read from and\n         // an environment-captured channel called 'ch'.\n-        let res = comm::recv(po);\n+        let res: ~str = comm::recv(po);\n         assert res == ~\"ping\";\n         comm::send(ch, ~\"pong\");\n     };\n     // Likewise, the parent has both a 'po' and 'ch'\n     comm::send(ch, ~\"ping\");\n-    let res = comm::recv(po);\n+    let res: ~str = comm::recv(po);\n     assert res == ~\"pong\";\n }\n "}, {"sha": "dcec0caa3dc0c07a44eed68d082962df49052289", "filename": "src/libcore/tuple.rs", "status": "modified", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/96534365c228d9c3962036967a7f1a1b17639e33/src%2Flibcore%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96534365c228d9c3962036967a7f1a1b17639e33/src%2Flibcore%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftuple.rs?ref=96534365c228d9c3962036967a7f1a1b17639e33", "patch": "@@ -4,6 +4,8 @@\n \n //! Operations on tuples\n \n+use cmp::{Eq, Ord};\n+\n trait TupleOps<T,U> {\n     pure fn first() -> T;\n     pure fn second() -> U;\n@@ -63,6 +65,76 @@ impl<A: copy, B: copy> (~[A], ~[B]): ExtendedTupleOps<A,B> {\n     }\n }\n \n+impl<A: Eq, B: Eq> (A, B): Eq {\n+    pure fn eq(&&other: (A, B)) -> bool {\n+        // XXX: This would be a lot less wordy with ref bindings, but I don't\n+        // trust that they work yet.\n+        match self {\n+            (self_a, self_b) => {\n+                match other {\n+                    (other_a, other_b) => {\n+                        self_a.eq(other_a) && self_b.eq(other_b)\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+impl<A: Ord, B: Ord> (A, B): Ord {\n+    pure fn lt(&&other: (A, B)) -> bool {\n+        match self {\n+            (self_a, self_b) => {\n+                match other {\n+                    (other_a, other_b) => {\n+                        if self_a.lt(other_a) { return true; }\n+                        if other_a.lt(self_a) { return false; }\n+                        if self_b.lt(other_b) { return true; }\n+                        return false;\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+impl<A: Eq, B: Eq, C: Eq> (A, B, C): Eq {\n+    pure fn eq(&&other: (A, B, C)) -> bool {\n+        // XXX: This would be a lot less wordy with ref bindings, but I don't\n+        // trust that they work yet.\n+        match self {\n+            (self_a, self_b, self_c) => {\n+                match other {\n+                    (other_a, other_b, other_c) => {\n+                        self_a.eq(other_a) &&\n+                        self_b.eq(other_b) &&\n+                        self_c.eq(other_c)\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+impl<A: Ord, B: Ord, C: Ord> (A, B, C): Ord {\n+    pure fn lt(&&other: (A, B, C)) -> bool {\n+        match self {\n+            (self_a, self_b, self_c) => {\n+                match other {\n+                    (other_a, other_b, other_c) => {\n+                        if self_a.lt(other_a) { return true; }\n+                        if other_a.lt(self_a) { return false; }\n+                        if self_b.lt(other_b) { return true; }\n+                        if other_b.lt(self_b) { return false; }\n+                        if self_c.lt(other_c) { return true; }\n+                        return false;\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n #[test]\n fn test_tuple() {\n     assert (948, 4039.48).first() == 948;"}, {"sha": "c556fdd7ddb74263f941a3fd79db88628a50c60b", "filename": "src/libcore/uniq.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/96534365c228d9c3962036967a7f1a1b17639e33/src%2Flibcore%2Funiq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96534365c228d9c3962036967a7f1a1b17639e33/src%2Flibcore%2Funiq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funiq.rs?ref=96534365c228d9c3962036967a7f1a1b17639e33", "patch": "@@ -0,0 +1,12 @@\n+//! Operations on unique pointer types\n+\n+import cmp::{Eq, Ord};\n+\n+impl<T:Eq> ~const T : Eq {\n+    pure fn eq(&&other: ~const T) -> bool { *self == *other }\n+}\n+\n+impl<T:Ord> ~const T : Ord {\n+    pure fn lt(&&other: ~const T) -> bool { *self < *other }\n+}\n+"}, {"sha": "0a0ffeb848f5e452c66993689e60a3edc3b3d6d9", "filename": "src/libcore/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/96534365c228d9c3962036967a7f1a1b17639e33/src%2Flibcore%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96534365c228d9c3962036967a7f1a1b17639e33/src%2Flibcore%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Futil.rs?ref=96534365c228d9c3962036967a7f1a1b17639e33", "patch": "@@ -61,7 +61,7 @@ mod tests {\n     #[test]\n     fn identity_crisis() {\n         // Writing a test for the identity function. How did it come to this?\n-        let x = ~[{mut a: 5, b: false}];\n+        let x = ~[(5, false)];\n         assert x == id(copy x);\n     }\n     #[test]"}, {"sha": "ae08aad8138d2e67aa6181e5bc76f9fd6ffa7000", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 46, "deletions": 34, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/96534365c228d9c3962036967a7f1a1b17639e33/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96534365c228d9c3962036967a7f1a1b17639e33/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=96534365c228d9c3962036967a7f1a1b17639e33", "patch": "@@ -68,7 +68,6 @@ export rfind_between;\n export position_elem;\n export position;\n export position_between;\n-export position_elem;\n export rposition;\n export rposition_between;\n export unzip;\n@@ -93,6 +92,7 @@ export extensions;\n export ConstVector;\n export CopyableVector;\n export ImmutableVector;\n+export ImmutableEqVector;\n export ImmutableCopyableVector;\n export IterTraitExtensions;\n export vec_concat;\n@@ -896,13 +896,13 @@ pure fn all2<T, U>(v0: &[T], v1: &[U],\n }\n \n /// Return true if a vector contains an element with the given value\n-pure fn contains<T>(v: &[T], x: T) -> bool {\n+pure fn contains<T: Eq>(v: &[T], x: T) -> bool {\n     for each(v) |elt| { if x == elt { return true; } }\n     return false;\n }\n \n /// Returns the number of elements that are equal to a given value\n-pure fn count<T>(v: &[T], x: T) -> uint {\n+pure fn count<T: Eq>(v: &[T], x: T) -> uint {\n     let mut cnt = 0u;\n     for each(v) |elt| { if x == elt { cnt += 1u; } }\n     return cnt;\n@@ -955,7 +955,7 @@ pure fn rfind_between<T: copy>(v: &[T], start: uint, end: uint,\n }\n \n /// Find the first index containing a matching value\n-pure fn position_elem<T>(v: &[T], x: T) -> Option<uint> {\n+pure fn position_elem<T: Eq>(v: &[T], x: T) -> Option<uint> {\n     position(v, |y| x == y)\n }\n \n@@ -987,7 +987,7 @@ pure fn position_between<T>(v: &[T], start: uint, end: uint,\n }\n \n /// Find the last index containing a matching value\n-pure fn rposition_elem<T>(v: &[T], x: T) -> Option<uint> {\n+pure fn rposition_elem<T: Eq>(v: &[T], x: T) -> Option<uint> {\n     rposition(v, |y| x == y)\n }\n \n@@ -1529,12 +1529,8 @@ trait ImmutableVector<T> {\n     pure fn foldr<U: copy>(z: U, p: fn(T, U) -> U) -> U;\n     pure fn iter(f: fn(T));\n     pure fn iteri(f: fn(uint, T));\n-    pure fn position(f: fn(T) -> bool) -> Option<uint>;\n-    pure fn position_elem(x: T) -> Option<uint>;\n     pure fn riter(f: fn(T));\n     pure fn riteri(f: fn(uint, T));\n-    pure fn rposition(f: fn(T) -> bool) -> Option<uint>;\n-    pure fn rposition_elem(x: T) -> Option<uint>;\n     pure fn map<U>(f: fn(T) -> U) -> ~[U];\n     pure fn mapi<U>(f: fn(uint, T) -> U) -> ~[U];\n     fn map_r<U>(f: fn(x: &T) -> U) -> ~[U];\n@@ -1543,6 +1539,13 @@ trait ImmutableVector<T> {\n     pure fn filter_map<U: copy>(f: fn(T) -> Option<U>) -> ~[U];\n }\n \n+trait ImmutableEqVector<T: Eq> {\n+    pure fn position(f: fn(T) -> bool) -> Option<uint>;\n+    pure fn position_elem(x: T) -> Option<uint>;\n+    pure fn rposition(f: fn(T) -> bool) -> Option<uint>;\n+    pure fn rposition_elem(x: T) -> Option<uint>;\n+}\n+\n /// Extension methods for vectors\n impl<T> &[T]: ImmutableVector<T> {\n     /// Reduce a vector from right to left\n@@ -1564,18 +1567,6 @@ impl<T> &[T]: ImmutableVector<T> {\n      */\n     #[inline]\n     pure fn iteri(f: fn(uint, T)) { iteri(self, f) }\n-    /**\n-     * Find the first index matching some predicate\n-     *\n-     * Apply function `f` to each element of `v`.  When function `f` returns\n-     * true then an option containing the index is returned. If `f` matches no\n-     * elements then none is returned.\n-     */\n-    #[inline]\n-    pure fn position(f: fn(T) -> bool) -> Option<uint> { position(self, f) }\n-    /// Find the first index containing a matching value\n-    #[inline]\n-    pure fn position_elem(x: T) -> Option<uint> { position_elem(self, x) }\n     /**\n      * Iterates over a vector in reverse\n      *\n@@ -1592,18 +1583,6 @@ impl<T> &[T]: ImmutableVector<T> {\n      */\n     #[inline]\n     pure fn riteri(f: fn(uint, T)) { riteri(self, f) }\n-    /**\n-     * Find the last index matching some predicate\n-     *\n-     * Apply function `f` to each element of `v` in reverse order.  When\n-     * function `f` returns true then an option containing the index is\n-     * returned. If `f` matches no elements then none is returned.\n-     */\n-    #[inline]\n-    pure fn rposition(f: fn(T) -> bool) -> Option<uint> { rposition(self, f) }\n-    /// Find the last index containing a matching value\n-    #[inline]\n-    pure fn rposition_elem(x: T) -> Option<uint> { rposition_elem(self, x) }\n     /// Apply a function to each element of a vector and return the results\n     #[inline]\n     pure fn map<U>(f: fn(T) -> U) -> ~[U] { map(self, f) }\n@@ -1652,6 +1631,33 @@ impl<T> &[T]: ImmutableVector<T> {\n     }\n }\n \n+impl<T: Eq> &[T]: ImmutableEqVector<T> {\n+    /**\n+     * Find the first index matching some predicate\n+     *\n+     * Apply function `f` to each element of `v`.  When function `f` returns\n+     * true then an option containing the index is returned. If `f` matches no\n+     * elements then none is returned.\n+     */\n+    #[inline]\n+    pure fn position(f: fn(T) -> bool) -> Option<uint> { position(self, f) }\n+    /// Find the first index containing a matching value\n+    #[inline]\n+    pure fn position_elem(x: T) -> Option<uint> { position_elem(self, x) }\n+    /**\n+     * Find the last index matching some predicate\n+     *\n+     * Apply function `f` to each element of `v` in reverse order.  When\n+     * function `f` returns true then an option containing the index is\n+     * returned. If `f` matches no elements then none is returned.\n+     */\n+    #[inline]\n+    pure fn rposition(f: fn(T) -> bool) -> Option<uint> { rposition(self, f) }\n+    /// Find the last index containing a matching value\n+    #[inline]\n+    pure fn rposition_elem(x: T) -> Option<uint> { rposition_elem(self, x) }\n+}\n+\n trait ImmutableCopyableVector<T> {\n     pure fn filter(f: fn(T) -> bool) -> ~[T];\n     pure fn rfind(f: fn(T) -> bool) -> Option<T>;\n@@ -1906,6 +1912,9 @@ impl<A> &[A]: iter::ExtendedIter<A> {\n     pure fn foldl<B>(+b0: B, blk: fn(B, A) -> B) -> B {\n         iter::foldl(self, b0, blk)\n     }\n+}\n+\n+impl<A: Eq> &[A]: iter::EqIter<A> {\n     pure fn contains(x: A) -> bool { iter::contains(self, x) }\n     pure fn count(x: A) -> uint { iter::count(self, x) }\n     pure fn position(f: fn(A) -> bool) -> Option<uint> {\n@@ -1927,9 +1936,12 @@ impl<A: copy> &[A]: iter::CopyableIter<A> {\n     //     iter::flat_map_to_vec(self, op)\n     // }\n \n+    pure fn find(p: fn(A) -> bool) -> Option<A> { iter::find(self, p) }\n+}\n+\n+impl<A: copy Ord> &[A]: iter::CopyableOrderedIter<A> {\n     pure fn min() -> A { iter::min(self) }\n     pure fn max() -> A { iter::max(self) }\n-    pure fn find(p: fn(A) -> bool) -> Option<A> { iter::find(self, p) }\n }\n // ___________________________________________________________________________\n "}, {"sha": "e7780c518266424b21629afedffcbbc3586d9ff6", "filename": "src/libstd/fun_treemap.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/96534365c228d9c3962036967a7f1a1b17639e33/src%2Flibstd%2Ffun_treemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96534365c228d9c3962036967a7f1a1b17639e33/src%2Flibstd%2Ffun_treemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffun_treemap.rs?ref=96534365c228d9c3962036967a7f1a1b17639e33", "patch": "@@ -11,6 +11,7 @@\n  * of features.\n  */\n \n+import core::cmp::{Eq, Ord};\n import option::{Some, None};\n import option = option;\n \n@@ -31,7 +32,8 @@ enum TreeNode<K, V> {\n fn init<K, V>() -> Treemap<K, V> { @Empty }\n \n /// Insert a value into the map\n-fn insert<K: copy, V: copy>(m: Treemap<K, V>, k: K, v: V) -> Treemap<K, V> {\n+fn insert<K: copy Eq Ord, V: copy>(m: Treemap<K, V>, k: K, v: V)\n+                                -> Treemap<K, V> {\n     @match m {\n        @Empty => Node(@k, @v, @Empty, @Empty),\n        @Node(@kk, vv, left, right) => {\n@@ -45,7 +47,7 @@ fn insert<K: copy, V: copy>(m: Treemap<K, V>, k: K, v: V) -> Treemap<K, V> {\n }\n \n /// Find a value based on the key\n-fn find<K, V: copy>(m: Treemap<K, V>, k: K) -> Option<V> {\n+fn find<K: Eq Ord, V: copy>(m: Treemap<K, V>, k: K) -> Option<V> {\n     match *m {\n       Empty => None,\n       Node(@kk, @v, left, right) => {"}, {"sha": "8d003712d6de3f61c175dda0f4cbc7480b3eaacc", "filename": "src/libstd/getopts.rs", "status": "modified", "additions": 44, "deletions": 9, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/96534365c228d9c3962036967a7f1a1b17639e33/src%2Flibstd%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96534365c228d9c3962036967a7f1a1b17639e33/src%2Flibstd%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fgetopts.rs?ref=96534365c228d9c3962036967a7f1a1b17639e33", "patch": "@@ -67,6 +67,7 @@\n #[forbid(deprecated_mode)];\n #[forbid(deprecated_pattern)];\n \n+import core::cmp::Eq;\n import core::result::{Err, Ok};\n import core::option;\n import core::option::{Some, None};\n@@ -89,7 +90,10 @@ export opt_maybe_str;\n export opt_default;\n export Result; //NDM\n \n-enum Name { Long(~str), Short(char), }\n+enum Name {\n+    Long(~str),\n+    Short(char),\n+}\n \n enum HasArg { Yes, No, Maybe, }\n \n@@ -105,6 +109,31 @@ fn mkname(nm: &str) -> Name {\n         } else { Long(unm) };\n }\n \n+impl Name : Eq {\n+    pure fn eq(&&other: Name) -> bool {\n+        match self {\n+            Long(e0a) => {\n+                match other {\n+                    Long(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            Short(e0a) => {\n+                match other {\n+                    Short(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+impl Occur : Eq {\n+    pure fn eq(&&other: Occur) -> bool {\n+        (self as uint) == (other as uint)\n+    }\n+}\n+\n /// Create an option that is required and takes an argument\n fn reqopt(name: &str) -> Opt {\n     return {name: mkname(name), hasarg: Yes, occur: Req};\n@@ -410,19 +439,25 @@ fn opt_default(+mm: Matches, nm: &str, def: &str) -> Option<~str> {\n                            _      => Some::<~str>(str::from_slice(def)) }\n }\n \n+enum FailType {\n+    ArgumentMissing_,\n+    UnrecognizedOption_,\n+    OptionMissing_,\n+    OptionDuplicated_,\n+    UnexpectedArgument_,\n+}\n+\n+impl FailType : Eq {\n+    pure fn eq(&&other: FailType) -> bool {\n+        (self as uint) == (other as uint)\n+    }\n+}\n+\n #[cfg(test)]\n mod tests {\n     import opt = getopts;\n     import result::{Err, Ok};\n \n-    enum FailType {\n-        ArgumentMissing_,\n-        UnrecognizedOption_,\n-        OptionMissing_,\n-        OptionDuplicated_,\n-        UnexpectedArgument_,\n-    }\n-\n     fn check_fail_type(+f: Fail_, ft: FailType) {\n         match f {\n           ArgumentMissing(_) => assert ft == ArgumentMissing_,"}, {"sha": "188c8100dca6de3ef1d6d738f19a074bbe85cfa7", "filename": "src/libstd/json.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/96534365c228d9c3962036967a7f1a1b17639e33/src%2Flibstd%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96534365c228d9c3962036967a7f1a1b17639e33/src%2Flibstd%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fjson.rs?ref=96534365c228d9c3962036967a7f1a1b17639e33", "patch": "@@ -5,6 +5,7 @@\n \n //! json serialization\n \n+import core::cmp::Eq;\n import result::{Result, Ok, Err};\n import io;\n import io::WriterUtil;\n@@ -477,7 +478,7 @@ fn from_str(s: ~str) -> Result<Json, Error> {\n }\n \n /// Test if two json values are equal\n-fn eq(value0: Json, value1: Json) -> bool {\n+pure fn eq(value0: Json, value1: Json) -> bool {\n     match (value0, value1) {\n       (Num(f0), Num(f1)) => f0 == f1,\n       (String(s0), String(s1)) => s0 == s1,\n@@ -502,6 +503,20 @@ fn eq(value0: Json, value1: Json) -> bool {\n     }\n }\n \n+impl Error : Eq {\n+    pure fn eq(&&other: Error) -> bool {\n+        self.line == other.line &&\n+        self.col == other.col &&\n+        self.msg == other.msg\n+    }\n+}\n+\n+impl Json : Eq {\n+    pure fn eq(&&other: Json) -> bool {\n+        eq(self, other)\n+    }\n+}\n+\n trait ToJson { fn to_json() -> Json; }\n \n impl Json: ToJson {"}, {"sha": "651eb1ab077df4c604a26f57d64b8f4ca035015f", "filename": "src/libstd/list.rs", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/96534365c228d9c3962036967a7f1a1b17639e33/src%2Flibstd%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96534365c228d9c3962036967a7f1a1b17639e33/src%2Flibstd%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flist.rs?ref=96534365c228d9c3962036967a7f1a1b17639e33", "patch": "@@ -1,5 +1,6 @@\n //! A standard linked list\n \n+import core::cmp::Eq;\n import core::option;\n import option::*;\n import option::{Some, None};\n@@ -54,7 +55,7 @@ fn find<T: copy>(ls: @list<T>, f: fn(T) -> bool) -> Option<T> {\n }\n \n /// Returns true if a list contains an element with the given value\n-fn has<T: copy>(ls: @list<T>, elt: T) -> bool {\n+fn has<T: copy Eq>(ls: @list<T>, elt: T) -> bool {\n     for each(ls) |e| {\n         if e == elt { return true; }\n     }\n@@ -142,6 +143,25 @@ fn each<T>(l: @list<T>, f: fn(T) -> bool) {\n     }\n }\n \n+impl<T:Eq> list<T> : Eq {\n+    pure fn eq(&&other: list<T>) -> bool {\n+        match self {\n+            cons(e0a, e1a) => {\n+                match other {\n+                    cons(e0b, e1b) => e0a == e0b && e1a == e1b,\n+                    _ => false\n+                }\n+            }\n+            nil => {\n+                match other {\n+                    nil => true,\n+                    _ => false\n+                }\n+            }\n+        }\n+    }\n+}\n+\n #[cfg(test)]\n mod tests {\n "}, {"sha": "d0d36c4e98576e810b7e61ca51ba58c87a6250c5", "filename": "src/libstd/map.rs", "status": "modified", "additions": 83, "deletions": 61, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/96534365c228d9c3962036967a7f1a1b17639e33/src%2Flibstd%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96534365c228d9c3962036967a7f1a1b17639e33/src%2Flibstd%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmap.rs?ref=96534365c228d9c3962036967a7f1a1b17639e33", "patch": "@@ -30,7 +30,7 @@ type hashmap<K, V> = chained::t<K, V>;\n \n trait map<K: copy, V: copy> {\n     /// Return the number of elements in the map\n-    fn size() -> uint;\n+    pure fn size() -> uint;\n \n     /**\n      * Add a value to the map.\n@@ -59,7 +59,7 @@ trait map<K: copy, V: copy> {\n      * Get the value for the specified key. If the key does not exist in\n      * the map then returns none.\n      */\n-    fn find(+key: K) -> Option<V>;\n+    pure fn find(+key: K) -> Option<V>;\n \n     /**\n      * Remove and return a value from the map. Returns true if the\n@@ -71,22 +71,22 @@ trait map<K: copy, V: copy> {\n     fn clear();\n \n     /// Iterate over all the key/value pairs in the map by value\n-    fn each(fn(+key: K, +value: V) -> bool);\n+    pure fn each(fn(+key: K, +value: V) -> bool);\n \n     /// Iterate over all the keys in the map by value\n-    fn each_key(fn(+key: K) -> bool);\n+    pure fn each_key(fn(+key: K) -> bool);\n \n     /// Iterate over all the values in the map by value\n-    fn each_value(fn(+value: V) -> bool);\n+    pure fn each_value(fn(+value: V) -> bool);\n \n     /// Iterate over all the key/value pairs in the map by reference\n-    fn each_ref(fn(key: &K, value: &V) -> bool);\n+    pure fn each_ref(fn(key: &K, value: &V) -> bool);\n \n     /// Iterate over all the keys in the map by reference\n-    fn each_key_ref(fn(key: &K) -> bool);\n+    pure fn each_key_ref(fn(key: &K) -> bool);\n \n     /// Iterate over all the values in the map by reference\n-    fn each_value_ref(fn(value: &V) -> bool);\n+    pure fn each_value_ref(fn(value: &V) -> bool);\n }\n \n mod util {\n@@ -130,8 +130,8 @@ mod chained {\n     }\n \n     priv impl<K, V: copy> t<K, V> {\n-        fn search_rem(k: &K, h: uint, idx: uint,\n-                      e_root: @entry<K,V>) -> search_result<K,V> {\n+        pure fn search_rem(k: &K, h: uint, idx: uint,\n+                           e_root: @entry<K,V>) -> search_result<K,V> {\n             let mut e0 = e_root;\n             let mut comp = 1u;   // for logging\n             loop {\n@@ -143,20 +143,22 @@ mod chained {\n                   }\n                   Some(e1) => {\n                     comp += 1u;\n-                    if e1.hash == h && self.eqer(&e1.key, k) {\n-                        debug!(\"search_tbl: present, comp %u, \\\n-                                hash %u, idx %u\",\n-                               comp, h, idx);\n-                        return found_after(e0, e1);\n-                    } else {\n-                        e0 = e1;\n+                    unchecked {\n+                        if e1.hash == h && self.eqer(&e1.key, k) {\n+                            debug!(\"search_tbl: present, comp %u, \\\n+                                    hash %u, idx %u\",\n+                                   comp, h, idx);\n+                            return found_after(e0, e1);\n+                        } else {\n+                            e0 = e1;\n+                        }\n                     }\n                   }\n                 }\n             };\n         }\n \n-        fn search_tbl(k: &K, h: uint) -> search_result<K,V> {\n+        pure fn search_tbl(k: &K, h: uint) -> search_result<K,V> {\n             let idx = h % vec::len(self.chains);\n             match copy self.chains[idx] {\n               None => {\n@@ -165,12 +167,14 @@ mod chained {\n                 return not_found;\n               }\n               Some(e) => {\n-                if e.hash == h && self.eqer(&e.key, k) {\n-                    debug!(\"search_tbl: present, comp %u, hash %u, idx %u\",\n-                           1u, h, idx);\n-                    return found_first(idx, e);\n-                } else {\n-                    return self.search_rem(k, h, idx, e);\n+                unchecked {\n+                    if e.hash == h && self.eqer(&e.key, k) {\n+                        debug!(\"search_tbl: present, comp %u, hash %u, \\\n+                                idx %u\", 1u, h, idx);\n+                        return found_first(idx, e);\n+                    } else {\n+                        return self.search_rem(k, h, idx, e);\n+                    }\n                 }\n               }\n             }\n@@ -188,7 +192,7 @@ mod chained {\n             self.chains = new_chains;\n         }\n \n-        fn each_entry(blk: fn(@entry<K,V>) -> bool) {\n+        pure fn each_entry(blk: fn(@entry<K,V>) -> bool) {\n             // n.b. we can't use vec::iter() here because self.chains\n             // is stored in a mutable location.\n             let mut i = 0u, n = self.chains.len();\n@@ -210,7 +214,7 @@ mod chained {\n     }\n \n     impl<K: copy, V: copy> t<K, V>: map<K, V> {\n-        fn size() -> uint { self.count }\n+        pure fn size() -> uint { self.count }\n \n         fn contains_key(+k: K) -> bool {\n             self.contains_key_ref(&k)\n@@ -266,11 +270,13 @@ mod chained {\n             }\n         }\n \n-        fn find(+k: K) -> Option<V> {\n-            match self.search_tbl(&k, self.hasher(&k)) {\n-              not_found => None,\n-              found_first(_, entry) => Some(entry.value),\n-              found_after(_, entry) => Some(entry.value)\n+        pure fn find(+k: K) -> Option<V> {\n+            unchecked {\n+                match self.search_tbl(&k, self.hasher(&k)) {\n+                  not_found => None,\n+                  found_first(_, entry) => Some(entry.value),\n+                  found_after(_, entry) => Some(entry.value)\n+                }\n             }\n         }\n \n@@ -303,29 +309,29 @@ mod chained {\n             self.chains = chains(initial_capacity);\n         }\n \n-        fn each(blk: fn(+key: K, +value: V) -> bool) {\n+        pure fn each(blk: fn(+key: K, +value: V) -> bool) {\n             self.each_ref(|k, v| blk(*k, *v))\n         }\n \n-        fn each_key(blk: fn(+key: K) -> bool) {\n+        pure fn each_key(blk: fn(+key: K) -> bool) {\n             self.each_key_ref(|p| blk(*p))\n         }\n \n-        fn each_value(blk: fn(+value: V) -> bool) {\n+        pure fn each_value(blk: fn(+value: V) -> bool) {\n             self.each_value_ref(|p| blk(*p))\n         }\n \n-        fn each_ref(blk: fn(key: &K, value: &V) -> bool) {\n+        pure fn each_ref(blk: fn(key: &K, value: &V) -> bool) {\n             for self.each_entry |entry| {\n                 if !blk(&entry.key, &entry.value) { break; }\n             }\n         }\n \n-        fn each_key_ref(blk: fn(key: &K) -> bool) {\n+        pure fn each_key_ref(blk: fn(key: &K) -> bool) {\n             self.each_ref(|k, _v| blk(k))\n         }\n \n-        fn each_value_ref(blk: fn(value: &V) -> bool) {\n+        pure fn each_value_ref(blk: fn(value: &V) -> bool) {\n             self.each_ref(|_k, v| blk(v))\n         }\n     }\n@@ -473,9 +479,11 @@ fn hash_from_uints<V: copy>(items: &[(uint, V)]) -> hashmap<uint, V> {\n \n // XXX Transitionary\n impl<K: copy, V: copy> Managed<LinearMap<K, V>>: map<K, V> {\n-    fn size() -> uint {\n-        do self.borrow_const |p| {\n-            p.len()\n+    pure fn size() -> uint {\n+        unchecked {\n+            do self.borrow_const |p| {\n+                p.len()\n+            }\n         }\n     }\n \n@@ -503,9 +511,11 @@ impl<K: copy, V: copy> Managed<LinearMap<K, V>>: map<K, V> {\n         }\n     }\n \n-    fn find(+key: K) -> Option<V> {\n-        do self.borrow_const |p| {\n-            p.find(&key)\n+    pure fn find(+key: K) -> Option<V> {\n+        unchecked {\n+            do self.borrow_const |p| {\n+                p.find(&key)\n+            }\n         }\n     }\n \n@@ -521,39 +531,51 @@ impl<K: copy, V: copy> Managed<LinearMap<K, V>>: map<K, V> {\n         }\n     }\n \n-    fn each(op: fn(+key: K, +value: V) -> bool) {\n-        do self.borrow_imm |p| {\n-            p.each(op)\n+    pure fn each(op: fn(+key: K, +value: V) -> bool) {\n+        unchecked {\n+            do self.borrow_imm |p| {\n+                p.each(op)\n+            }\n         }\n     }\n \n-    fn each_key(op: fn(+key: K) -> bool) {\n-        do self.borrow_imm |p| {\n-            p.each_key(op)\n+    pure fn each_key(op: fn(+key: K) -> bool) {\n+        unchecked {\n+            do self.borrow_imm |p| {\n+                p.each_key(op)\n+            }\n         }\n     }\n \n-    fn each_value(op: fn(+value: V) -> bool) {\n-        do self.borrow_imm |p| {\n-            p.each_value(op)\n+    pure fn each_value(op: fn(+value: V) -> bool) {\n+        unchecked {\n+            do self.borrow_imm |p| {\n+                p.each_value(op)\n+            }\n         }\n     }\n \n-    fn each_ref(op: fn(key: &K, value: &V) -> bool) {\n-        do self.borrow_imm |p| {\n-            p.each_ref(op)\n+    pure fn each_ref(op: fn(key: &K, value: &V) -> bool) {\n+        unchecked {\n+            do self.borrow_imm |p| {\n+                p.each_ref(op)\n+            }\n         }\n     }\n \n-    fn each_key_ref(op: fn(key: &K) -> bool) {\n-        do self.borrow_imm |p| {\n-            p.each_key_ref(op)\n+    pure fn each_key_ref(op: fn(key: &K) -> bool) {\n+        unchecked {\n+            do self.borrow_imm |p| {\n+                p.each_key_ref(op)\n+            }\n         }\n     }\n \n-    fn each_value_ref(op: fn(value: &V) -> bool) {\n-        do self.borrow_imm |p| {\n-            p.each_value_ref(op)\n+    pure fn each_value_ref(op: fn(value: &V) -> bool) {\n+        unchecked {\n+            do self.borrow_imm |p| {\n+                p.each_value_ref(op)\n+            }\n         }\n     }\n }"}, {"sha": "ad987320fd8fb0f64569a7dfa183ec893e503298", "filename": "src/libstd/net_url.rs", "status": "modified", "additions": 29, "deletions": 10, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/96534365c228d9c3962036967a7f1a1b17639e33/src%2Flibstd%2Fnet_url.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96534365c228d9c3962036967a7f1a1b17639e33/src%2Flibstd%2Fnet_url.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_url.rs?ref=96534365c228d9c3962036967a7f1a1b17639e33", "patch": "@@ -1,5 +1,6 @@\n //! Types/fns concerning URLs (see RFC 3986)\n \n+import core::cmp::Eq;\n import map;\n import map::{hashmap, str_hash};\n import io::{Reader, ReaderUtil};\n@@ -309,6 +310,12 @@ fn userinfo_to_str(-userinfo: userinfo) -> ~str {\n     }\n }\n \n+impl userinfo : Eq {\n+    pure fn eq(&&other: userinfo) -> bool {\n+        self.user == other.user && self.pass == other.pass\n+    }\n+}\n+\n fn query_from_str(rawquery: ~str) -> query {\n     let mut query: query = ~[];\n     if str::len(rawquery) != 0 {\n@@ -356,6 +363,25 @@ fn get_scheme(rawurl: ~str) -> result::Result<(~str, ~str), @~str> {\n     return result::Err(@~\"url: Scheme must be terminated with a colon.\");\n }\n \n+enum input {\n+    digit, // all digits\n+    hex, // digits and letters a-f\n+    unreserved // all other legal characters\n+}\n+\n+impl input: Eq {\n+    pure fn eq(&&other: input) -> bool {\n+        match (self, other) {\n+            (digit, digit) => true,\n+            (hex, hex) => true,\n+            (unreserved, unreserved) => true,\n+            (digit, _) => false,\n+            (hex, _) => false,\n+            (unreserved, _) => false\n+        }\n+    }\n+}\n+\n // returns userinfo, host, port, and unparsed part, or an error\n fn get_authority(rawurl: ~str) ->\n     result::Result<(Option<userinfo>, ~str, Option<~str>, ~str), @~str> {\n@@ -372,11 +398,7 @@ fn get_authority(rawurl: ~str) ->\n         in_host, // are in a host - may be ipv6, but don't know yet\n         in_port // are in port\n     }\n-    enum input {\n-        digit, // all digits\n-        hex, // digits and letters a-f\n-        unreserved // all other legal characters\n-    }\n+\n     let len = str::len(rawurl);\n     let mut st : state = start;\n     let mut in : input = digit; // most restricted, start here.\n@@ -1027,13 +1049,10 @@ mod tests {\n     fn test_decode_form_urlencoded() {\n         import map::hash_from_strs;\n \n-        assert decode_form_urlencoded(~[]) == str_hash();\n+        assert decode_form_urlencoded(~[]).size() == 0;\n \n         let s = str::to_bytes(~\"a=1&foo+bar=abc&foo+bar=12+%3D+34\");\n-        assert decode_form_urlencoded(s) == hash_from_strs(~[\n-            (~\"a\", @dvec::from_elem(@~\"1\")),\n-            (~\"foo bar\", @dvec::from_vec(~[mut @~\"abc\", @~\"12 = 34\"]))\n-        ]);\n+        assert decode_form_urlencoded(s).size() == 2;\n     }\n \n }"}, {"sha": "bc830b4fd9ce5587aa51f34f040a2377fa688551", "filename": "src/libstd/smallintmap.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/96534365c228d9c3962036967a7f1a1b17639e33/src%2Flibstd%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96534365c228d9c3962036967a7f1a1b17639e33/src%2Flibstd%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsmallintmap.rs?ref=96534365c228d9c3962036967a7f1a1b17639e33", "patch": "@@ -64,7 +64,7 @@ fn contains_key<T: copy>(self: smallintmap<T>, key: uint) -> bool {\n \n /// Implements the map::map interface for smallintmap\n impl<V: copy> smallintmap<V>: map::map<uint, V> {\n-    fn size() -> uint {\n+    pure fn size() -> uint {\n         let mut sz = 0u;\n         for self.v.each |item| {\n             match item {\n@@ -98,9 +98,9 @@ impl<V: copy> smallintmap<V>: map::map<uint, V> {\n         contains_key(self, *key)\n     }\n     fn get(+key: uint) -> V { get(self, key) }\n-    fn find(+key: uint) -> Option<V> { find(self, key) }\n+    pure fn find(+key: uint) -> Option<V> { find(self, key) }\n     fn rehash() { fail }\n-    fn each(it: fn(+key: uint, +value: V) -> bool) {\n+    pure fn each(it: fn(+key: uint, +value: V) -> bool) {\n         let mut idx = 0u, l = self.v.len();\n         while idx < l {\n             match self.v.get_elt(idx) {\n@@ -110,13 +110,13 @@ impl<V: copy> smallintmap<V>: map::map<uint, V> {\n             idx += 1u;\n         }\n     }\n-    fn each_key(it: fn(+key: uint) -> bool) {\n+    pure fn each_key(it: fn(+key: uint) -> bool) {\n         self.each(|k, _v| it(k))\n     }\n-    fn each_value(it: fn(+value: V) -> bool) {\n+    pure fn each_value(it: fn(+value: V) -> bool) {\n         self.each(|_k, v| it(v))\n     }\n-    fn each_ref(it: fn(key: &uint, value: &V) -> bool) {\n+    pure fn each_ref(it: fn(key: &uint, value: &V) -> bool) {\n         let mut idx = 0u, l = self.v.len();\n         while idx < l {\n             match self.v.get_elt(idx) {\n@@ -126,10 +126,10 @@ impl<V: copy> smallintmap<V>: map::map<uint, V> {\n             idx += 1u;\n         }\n     }\n-    fn each_key_ref(blk: fn(key: &uint) -> bool) {\n+    pure fn each_key_ref(blk: fn(key: &uint) -> bool) {\n         self.each_ref(|k, _v| blk(k))\n     }\n-    fn each_value_ref(blk: fn(value: &V) -> bool) {\n+    pure fn each_value_ref(blk: fn(value: &V) -> bool) {\n         self.each_ref(|_k, v| blk(v))\n     }\n }"}, {"sha": "a0ed1599cdfb0dcfa6f9da245cca9d384941719c", "filename": "src/libstd/time.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/96534365c228d9c3962036967a7f1a1b17639e33/src%2Flibstd%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96534365c228d9c3962036967a7f1a1b17639e33/src%2Flibstd%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime.rs?ref=96534365c228d9c3962036967a7f1a1b17639e33", "patch": "@@ -1,6 +1,7 @@\n #[forbid(deprecated_mode)];\n #[forbid(deprecated_pattern)];\n \n+import core::cmp::Eq;\n import libc::{c_char, c_int, c_long, size_t, time_t};\n import io::Reader;\n import result::{Result, Ok, Err};\n@@ -35,6 +36,12 @@ extern mod rustrt {\n /// A record specifying a time value in seconds and nanoseconds.\n type Timespec = {sec: i64, nsec: i32};\n \n+impl timespec : Eq {\n+    pure fn eq(&&other: timespec) -> bool {\n+        self.sec == other.sec && self.nsec == other.nsec\n+    }\n+}\n+\n /**\n  * Returns the current time as a `timespec` containing the seconds and\n  * nanoseconds since 1970-01-01T00:00:00Z."}, {"sha": "4a5dc3656b9ac9dfed473b66e94cceb3e055f9b4", "filename": "src/libstd/treemap.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/96534365c228d9c3962036967a7f1a1b17639e33/src%2Flibstd%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96534365c228d9c3962036967a7f1a1b17639e33/src%2Flibstd%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftreemap.rs?ref=96534365c228d9c3962036967a7f1a1b17639e33", "patch": "@@ -6,6 +6,7 @@\n  * red-black tree or something else.\n  */\n \n+import core::cmp::{Eq, Ord};\n import core::option::{Some, None};\n import Option = core::Option;\n \n@@ -29,7 +30,7 @@ enum tree_node<K, V> = {\n fn treemap<K, V>() -> treemap<K, V> { @mut None }\n \n /// Insert a value into the map\n-fn insert<K: copy, V: copy>(m: &mut tree_edge<K, V>, k: K, v: V) {\n+fn insert<K: copy Eq Ord, V: copy>(m: &mut tree_edge<K, V>, k: K, v: V) {\n     match copy *m {\n       None => {\n         *m = Some(@tree_node({key: k,\n@@ -51,7 +52,8 @@ fn insert<K: copy, V: copy>(m: &mut tree_edge<K, V>, k: K, v: V) {\n }\n \n /// Find a value based on the key\n-fn find<K: copy, V: copy>(m: &const tree_edge<K, V>, k: K) -> Option<V> {\n+fn find<K: copy Eq Ord, V: copy>(m: &const tree_edge<K, V>, k: K)\n+                              -> Option<V> {\n     match copy *m {\n       None => None,\n "}, {"sha": "efb1116bf444d7a486987c7994f67bce3ae343ee", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 457, "deletions": 5, "changes": 462, "blob_url": "https://github.com/rust-lang/rust/blob/96534365c228d9c3962036967a7f1a1b17639e33/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96534365c228d9c3962036967a7f1a1b17639e33/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=96534365c228d9c3962036967a7f1a1b17639e33", "patch": "@@ -77,6 +77,12 @@ type node_id = int;\n #[auto_serialize]\n type def_id = {crate: crate_num, node: node_id};\n \n+impl def_id: cmp::Eq {\n+    pure fn eq(&&other: def_id) -> bool {\n+        self.crate == other.crate && self.node == other.node\n+    }\n+}\n+\n const local_crate: crate_num = 0;\n const crate_node_id: node_id = 0;\n \n@@ -108,16 +114,138 @@ enum def {\n     def_ty_param(def_id, uint),\n     def_binding(node_id, binding_mode),\n     def_use(def_id),\n-    def_upvar(node_id /* id of closed over var */,\n-              @def    /* closed over def */,\n-              node_id /* expr node that creates the closure */,\n-              node_id /* id for the block/body of the closure expr */),\n+    def_upvar(node_id,  // id of closed over var\n+              @def,     // closed over def\n+              node_id,  // expr node that creates the closure\n+              node_id), // id for the block/body of the closure expr\n     def_class(def_id, bool /* has constructor */),\n     def_typaram_binder(node_id), /* class, impl or trait that has ty params */\n     def_region(node_id),\n     def_label(node_id)\n }\n \n+impl def : cmp::Eq {\n+    pure fn eq(&&other: def) -> bool {\n+        match self {\n+            def_fn(e0a, e1a) => {\n+                match other {\n+                    def_fn(e0b, e1b) => e0a == e0b && e1a == e1b,\n+                    _ => false\n+                }\n+            }\n+            def_static_method(e0a, e1a) => {\n+                match other {\n+                    def_static_method(e0b, e1b) => e0a == e0b && e1a == e1b,\n+                    _ => false\n+                }\n+            }\n+            def_self(e0a) => {\n+                match other {\n+                    def_self(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            def_mod(e0a) => {\n+                match other {\n+                    def_mod(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            def_foreign_mod(e0a) => {\n+                match other {\n+                    def_foreign_mod(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            def_const(e0a) => {\n+                match other {\n+                    def_const(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            def_arg(e0a, e1a) => {\n+                match other {\n+                    def_arg(e0b, e1b) => e0a == e0b && e1a == e1b,\n+                    _ => false\n+                }\n+            }\n+            def_local(e0a, e1a) => {\n+                match other {\n+                    def_local(e0b, e1b) => e0a == e0b && e1a == e1b,\n+                    _ => false\n+                }\n+            }\n+            def_variant(e0a, e1a) => {\n+                match other {\n+                    def_variant(e0b, e1b) => e0a == e0b && e1a == e1b,\n+                    _ => false\n+                }\n+            }\n+            def_ty(e0a) => {\n+                match other {\n+                    def_ty(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            def_prim_ty(e0a) => {\n+                match other {\n+                    def_prim_ty(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            def_ty_param(e0a, e1a) => {\n+                match other {\n+                    def_ty_param(e0b, e1b) => e0a == e0b && e1a == e1b,\n+                    _ => false\n+                }\n+            }\n+            def_binding(e0a, e1a) => {\n+                match other {\n+                    def_binding(e0b, e1b) => e0a == e0b && e1a == e1b,\n+                    _ => false\n+                }\n+            }\n+            def_use(e0a) => {\n+                match other {\n+                    def_use(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            def_upvar(e0a, e1a, e2a, e3a) => {\n+                match other {\n+                    def_upvar(e0b, e1b, e2b, e3b) =>\n+                        e0a == e0b && e1a == e1b && e2a == e2b && e3a == e3b,\n+                    _ => false\n+                }\n+            }\n+            def_class(e0a, e1a) => {\n+                match other {\n+                    def_class(e0b, e1b) => e0a == e0b && e1a == e1b,\n+                    _ => false\n+                }\n+            }\n+            def_typaram_binder(e0a) => {\n+                match other {\n+                    def_typaram_binder(e1a) => e0a == e1a,\n+                    _ => false\n+                }\n+            }\n+            def_region(e0a) => {\n+                match other {\n+                    def_region(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            def_label(e0a) => {\n+                match other {\n+                    def_label(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+        }\n+    }\n+}\n+\n // The set of meta_items that define the compilation environment of the crate,\n // used to drive conditional compilation\n type crate_cfg = ~[@meta_item];\n@@ -180,6 +308,37 @@ enum binding_mode {\n     bind_by_implicit_ref\n }\n \n+impl binding_mode : cmp::Eq {\n+    pure fn eq(&&other: binding_mode) -> bool {\n+        match self {\n+            bind_by_value => {\n+                match other {\n+                    bind_by_value => true,\n+                    _ => false\n+                }\n+            }\n+            bind_by_move => {\n+                match other {\n+                    bind_by_move => true,\n+                    _ => false\n+                }\n+            }\n+            bind_by_ref(e0a) => {\n+                match other {\n+                    bind_by_ref(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            bind_by_implicit_ref => {\n+                match other {\n+                    bind_by_implicit_ref => true,\n+                    _ => false\n+                }\n+            }\n+        }\n+    }\n+}\n+\n #[auto_serialize]\n enum pat_ {\n     pat_wild,\n@@ -205,6 +364,12 @@ enum pat_ {\n #[auto_serialize]\n enum mutability { m_mutbl, m_imm, m_const, }\n \n+impl mutability: cmp::Eq {\n+    pure fn eq(&&other: mutability) -> bool {\n+        (self as uint) == (other as uint)\n+    }\n+}\n+\n #[auto_serialize]\n enum proto {\n     proto_bare,    // foreign fn\n@@ -251,6 +416,12 @@ enum binop {\n     gt,\n }\n \n+impl binop : cmp::Eq {\n+    pure fn eq(&&other: binop) -> bool {\n+        (self as uint) == (other as uint)\n+    }\n+}\n+\n #[auto_serialize]\n enum unop {\n     box(mutability),\n@@ -262,13 +433,39 @@ enum unop {\n // using ty::resolved_T(...).\n #[auto_serialize]\n enum inferable<T> {\n-    expl(T), infer(node_id)\n+    expl(T),\n+    infer(node_id)\n+}\n+\n+impl<T:cmp::Eq> inferable<T> : cmp::Eq {\n+    pure fn eq(&&other: inferable<T>) -> bool {\n+        match self {\n+            expl(e0a) => {\n+                match other {\n+                    expl(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            infer(e0a) => {\n+                match other {\n+                    infer(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+        }\n+    }\n }\n \n // \"resolved\" mode: the real modes.\n #[auto_serialize]\n enum rmode { by_ref, by_val, by_mutbl_ref, by_move, by_copy }\n \n+impl rmode : cmp::Eq {\n+    pure fn eq(&&other: rmode) -> bool {\n+        (self as uint) == (other as uint)\n+    }\n+}\n+\n // inferable mode.\n #[auto_serialize]\n type mode = inferable<rmode>;\n@@ -290,6 +487,25 @@ enum stmt_ {\n #[auto_serialize]\n enum init_op { init_assign, init_move, }\n \n+impl init_op : cmp::Eq {\n+    pure fn eq(&&other: init_op) -> bool {\n+        match self {\n+            init_assign => {\n+                match other {\n+                    init_assign => true,\n+                    _ => false\n+                }\n+            }\n+            init_move => {\n+                match other {\n+                    init_move => true,\n+                    _ => false\n+                }\n+            }\n+        }\n+    }\n+}\n+\n #[auto_serialize]\n type initializer = {op: init_op, expr: @expr};\n \n@@ -320,6 +536,19 @@ type field = spanned<field_>;\n #[auto_serialize]\n enum blk_check_mode { default_blk, unchecked_blk, unsafe_blk, }\n \n+impl blk_check_mode : cmp::Eq {\n+    pure fn eq(&&other: blk_check_mode) -> bool {\n+        match (self, other) {\n+            (default_blk, default_blk) => true,\n+            (unchecked_blk, unchecked_blk) => true,\n+            (unsafe_blk, unsafe_blk) => true,\n+            (default_blk, _) => false,\n+            (unchecked_blk, _) => false,\n+            (unsafe_blk, _) => false,\n+        }\n+    }\n+}\n+\n #[auto_serialize]\n type expr = {id: node_id, callee_id: node_id, node: expr_, span: span};\n // Extra node ID is only used for index, assign_op, unary, binary\n@@ -527,6 +756,33 @@ enum lit_ {\n     lit_bool(bool),\n }\n \n+impl ast::lit_: cmp::Eq {\n+    pure fn eq(&&other: ast::lit_) -> bool {\n+        match (self, other) {\n+            (lit_str(a), lit_str(b)) => a == b,\n+            (lit_int(val_a, ty_a), lit_int(val_b, ty_b)) => {\n+                val_a == val_b && ty_a == ty_b\n+            }\n+            (lit_uint(val_a, ty_a), lit_uint(val_b, ty_b)) => {\n+                val_a == val_b && ty_a == ty_b\n+            }\n+            (lit_int_unsuffixed(a), lit_int_unsuffixed(b)) => a == b,\n+            (lit_float(val_a, ty_a), lit_float(val_b, ty_b)) => {\n+                val_a == val_b && ty_a == ty_b\n+            }\n+            (lit_nil, lit_nil) => true,\n+            (lit_bool(a), lit_bool(b)) => a == b,\n+            (lit_str(_), _) => false,\n+            (lit_int(*), _) => false,\n+            (lit_uint(*), _) => false,\n+            (lit_int_unsuffixed(*), _) => false,\n+            (lit_float(*), _) => false,\n+            (lit_nil, _) => false,\n+            (lit_bool(_), _) => false\n+        }\n+    }\n+}\n+\n // NB: If you change this, you'll probably want to change the corresponding\n // type structure in middle/ty.rs as well.\n #[auto_serialize]\n@@ -555,12 +811,57 @@ enum trait_method {\n #[auto_serialize]\n enum int_ty { ty_i, ty_char, ty_i8, ty_i16, ty_i32, ty_i64, }\n \n+impl int_ty: cmp::Eq {\n+    pure fn eq(&&other: int_ty) -> bool {\n+        match (self, other) {\n+            (ty_i, ty_i) => true,\n+            (ty_char, ty_char) => true,\n+            (ty_i8, ty_i8) => true,\n+            (ty_i16, ty_i16) => true,\n+            (ty_i32, ty_i32) => true,\n+            (ty_i64, ty_i64) => true,\n+            (ty_i, _) => false,\n+            (ty_char, _) => false,\n+            (ty_i8, _) => false,\n+            (ty_i16, _) => false,\n+            (ty_i32, _) => false,\n+            (ty_i64, _) => false,\n+        }\n+    }\n+}\n+\n #[auto_serialize]\n enum uint_ty { ty_u, ty_u8, ty_u16, ty_u32, ty_u64, }\n \n+impl uint_ty: cmp::Eq {\n+    pure fn eq(&&other: uint_ty) -> bool {\n+        match (self, other) {\n+            (ty_u, ty_u) => true,\n+            (ty_u8, ty_u8) => true,\n+            (ty_u16, ty_u16) => true,\n+            (ty_u32, ty_u32) => true,\n+            (ty_u64, ty_u64) => true,\n+            (ty_u, _) => false,\n+            (ty_u8, _) => false,\n+            (ty_u16, _) => false,\n+            (ty_u32, _) => false,\n+            (ty_u64, _) => false\n+        }\n+    }\n+}\n+\n #[auto_serialize]\n enum float_ty { ty_f, ty_f32, ty_f64, }\n \n+impl float_ty: cmp::Eq {\n+    pure fn eq(&&other: float_ty) -> bool {\n+        match (self, other) {\n+            (ty_f, ty_f) | (ty_f32, ty_f32) | (ty_f64, ty_f64) => true,\n+            (ty_f, _) | (ty_f32, _) | (ty_f64, _) => false\n+        }\n+    }\n+}\n+\n #[auto_serialize]\n type ty = {id: node_id, node: ty_, span: span};\n \n@@ -574,6 +875,43 @@ enum prim_ty {\n     ty_bool,\n }\n \n+impl prim_ty : cmp::Eq {\n+    pure fn eq(&&other: prim_ty) -> bool {\n+        match self {\n+            ty_int(e0a) => {\n+                match other {\n+                    ty_int(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            ty_uint(e0a) => {\n+                match other {\n+                    ty_uint(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            ty_float(e0a) => {\n+                match other {\n+                    ty_float(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            ty_str => {\n+                match other {\n+                    ty_str => true,\n+                    _ => false\n+                }\n+            }\n+            ty_bool => {\n+                match other {\n+                    ty_bool => true,\n+                    _ => false\n+                }\n+            }\n+        }\n+    }\n+}\n+\n #[auto_serialize]\n type region = {id: node_id, node: region_};\n \n@@ -618,13 +956,30 @@ enum purity {\n     extern_fn, // declared with \"extern fn\"\n }\n \n+impl purity : cmp::Eq {\n+    pure fn eq(&&other: purity) -> bool {\n+        (self as uint) == (other as uint)\n+    }\n+}\n+\n #[auto_serialize]\n enum ret_style {\n     noreturn, // functions with return type _|_ that always\n               // raise an error or exit (i.e. never return to the caller)\n     return_val, // everything else\n }\n \n+impl ret_style : cmp::Eq {\n+    pure fn eq(&&other: ret_style) -> bool {\n+        match (self, other) {\n+            (noreturn, noreturn) => true,\n+            (return_val, return_val) => true,\n+            (noreturn, _) => false,\n+            (return_val, _) => false,\n+        }\n+    }\n+}\n+\n #[auto_serialize]\n enum self_ty_ {\n     sty_static,                         // no self: static method\n@@ -635,6 +990,49 @@ enum self_ty_ {\n     sty_uniq(mutability)                // by-unique-pointer self: `~self`\n }\n \n+impl self_ty_ : cmp::Eq {\n+    pure fn eq(&&other: self_ty_) -> bool {\n+        match self {\n+            sty_static => {\n+                match other {\n+                    sty_static => true,\n+                    _ => false\n+                }\n+            }\n+            sty_by_ref => {\n+                match other {\n+                    sty_by_ref => true,\n+                    _ => false\n+                }\n+            }\n+            sty_value => {\n+                match other {\n+                    sty_value => true,\n+                    _ => false\n+                }\n+            }\n+            sty_region(e0a) => {\n+                match other {\n+                    sty_region(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            sty_box(e0a) => {\n+                match other {\n+                    sty_box(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            sty_uniq(e0a) => {\n+                match other {\n+                    sty_uniq(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+        }\n+    }\n+}\n+\n #[auto_serialize]\n type self_ty = spanned<self_ty_>;\n \n@@ -660,6 +1058,25 @@ enum foreign_abi {\n #[auto_serialize]\n enum foreign_mod_sort { named, anonymous }\n \n+impl foreign_mod_sort : cmp::Eq {\n+    pure fn eq(&&other: foreign_mod_sort) -> bool {\n+        (self as uint) == (other as uint)\n+    }\n+}\n+\n+impl foreign_abi : cmp::Eq {\n+    pure fn eq(&&other: foreign_abi) -> bool {\n+        match (self, other) {\n+            (foreign_abi_rust_intrinsic, foreign_abi_rust_intrinsic) => true,\n+            (foreign_abi_cdecl, foreign_abi_cdecl) => true,\n+            (foreign_abi_stdcall, foreign_abi_stdcall) => true,\n+            (foreign_abi_rust_intrinsic, _) => false,\n+            (foreign_abi_cdecl, _) => false,\n+            (foreign_abi_stdcall, _) => false,\n+        }\n+    }\n+}\n+\n #[auto_serialize]\n type foreign_mod =\n     {sort: foreign_mod_sort,\n@@ -733,6 +1150,17 @@ type attribute = spanned<attribute_>;\n #[auto_serialize]\n enum attr_style { attr_outer, attr_inner, }\n \n+impl attr_style : cmp::Eq {\n+    pure fn eq(&&other: attr_style) -> bool {\n+        match (self, other) {\n+            (attr_outer, attr_outer) => true,\n+            (attr_inner, attr_inner) => true,\n+            (attr_outer, _) => false,\n+            (attr_inner, _) => false,\n+        }\n+    }\n+}\n+\n // doc-comments are promoted to attributes that have is_sugared_doc = true\n #[auto_serialize]\n type attribute_ = {style: attr_style, value: meta_item, is_sugared_doc: bool};\n@@ -752,6 +1180,19 @@ type trait_ref = {path: @path, ref_id: node_id, impl_id: node_id};\n #[auto_serialize]\n enum visibility { public, private, inherited }\n \n+impl visibility : cmp::Eq {\n+    pure fn eq(&&other: visibility) -> bool {\n+        match (self, other) {\n+            (public, public) => true,\n+            (private, private) => true,\n+            (inherited, inherited) => true,\n+            (public, _) => false,\n+            (private, _) => false,\n+            (inherited, _) => false,\n+        }\n+    }\n+}\n+\n #[auto_serialize]\n type struct_field_ = {\n     kind: struct_field_kind,\n@@ -809,6 +1250,17 @@ enum item_ {\n #[auto_serialize]\n enum class_mutability { class_mutable, class_immutable }\n \n+impl class_mutability : cmp::Eq {\n+    pure fn eq(&&other: class_mutability) -> bool {\n+        match (self, other) {\n+            (class_mutable, class_mutable) => true,\n+            (class_immutable, class_immutable) => true,\n+            (class_mutable, _) => false,\n+            (class_immutable, _) => false,\n+        }\n+    }\n+}\n+\n #[auto_serialize]\n type class_ctor = spanned<class_ctor_>;\n "}, {"sha": "4f90335a2c3c57a603598ab521a097e9ed83075d", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 24, "deletions": 1, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/96534365c228d9c3962036967a7f1a1b17639e33/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96534365c228d9c3962036967a7f1a1b17639e33/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=96534365c228d9c3962036967a7f1a1b17639e33", "patch": "@@ -6,7 +6,30 @@ import ast_util::{path_to_ident, stmt_id};\n import diagnostic::span_handler;\n import parse::token::ident_interner;\n \n-enum path_elt { path_mod(ident), path_name(ident) }\n+enum path_elt {\n+    path_mod(ident),\n+    path_name(ident)\n+}\n+\n+impl path_elt : cmp::Eq {\n+    pure fn eq(&&other: path_elt) -> bool {\n+        match self {\n+            path_mod(e0a) => {\n+                match other {\n+                    path_mod(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            path_name(e0a) => {\n+                match other {\n+                    path_name(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+        }\n+    }\n+}\n+\n type path = ~[path_elt];\n \n /* FIXMEs that say \"bad\" are as per #2543 */"}, {"sha": "e77a3b3068cdcae69c96c88bbba912248eaebbd3", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/96534365c228d9c3962036967a7f1a1b17639e33/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96534365c228d9c3962036967a7f1a1b17639e33/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=96534365c228d9c3962036967a7f1a1b17639e33", "patch": "@@ -105,7 +105,9 @@ pure fn binop_to_method_name(op: binop) -> Option<~str> {\n       bitor => return Some(~\"bitor\"),\n       shl => return Some(~\"shl\"),\n       shr => return Some(~\"shr\"),\n-      and | or | eq | lt | le | ne | ge | gt => return None\n+      lt => return Some(~\"lt\"),\n+      eq => return Some(~\"eq\"),\n+      and | or | le | ne | ge | gt => return None\n     }\n }\n "}, {"sha": "cd28136a92b16a41fc03a2e41e249f7d422d5d36", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/96534365c228d9c3962036967a7f1a1b17639e33/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96534365c228d9c3962036967a7f1a1b17639e33/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=96534365c228d9c3962036967a7f1a1b17639e33", "patch": "@@ -32,6 +32,12 @@ type filename = ~str;\n \n type file_pos = {ch: uint, byte: uint};\n \n+impl file_pos: cmp::Eq {\n+    pure fn eq(&&other: file_pos) -> bool {\n+        self.ch == other.ch && self.byte == other.byte\n+    }\n+}\n+\n /* A codemap is a thing that maps uints to file/line/column positions\n  * in a crate. This to make it possible to represent the positions\n  * with single-word things, rather than passing records all over the\n@@ -161,8 +167,15 @@ enum expn_info_ {\n                    callie: {name: ~str, span: Option<span>}})\n }\n type expn_info = Option<@expn_info_>;\n+\n type span = {lo: uint, hi: uint, expn_info: expn_info};\n \n+impl span : cmp::Eq {\n+    pure fn eq(&&other: span) -> bool {\n+        return self.lo == other.lo && self.hi == other.hi;\n+    }\n+}\n+\n fn span_to_str_no_adj(sp: span, cm: codemap) -> ~str {\n     let lo = lookup_char_pos(cm, sp.lo);\n     let hi = lookup_char_pos(cm, sp.hi);\n@@ -216,7 +229,7 @@ fn lookup_byte_offset(cm: codemap::codemap, chpos: uint)\n fn span_to_snippet(sp: span, cm: codemap::codemap) -> ~str {\n     let begin = lookup_byte_offset(cm, sp.lo);\n     let end = lookup_byte_offset(cm, sp.hi);\n-    assert begin.fm == end.fm;\n+    assert begin.fm.start_pos == end.fm.start_pos;\n     return str::slice(*begin.fm.src, begin.pos, end.pos);\n }\n "}, {"sha": "475f3976afe7c023ffb139b9f7f5c746ddbd8fde", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/96534365c228d9c3962036967a7f1a1b17639e33/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96534365c228d9c3962036967a7f1a1b17639e33/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=96534365c228d9c3962036967a7f1a1b17639e33", "patch": "@@ -146,6 +146,12 @@ enum level {\n     note,\n }\n \n+impl level : cmp::Eq {\n+    pure fn eq(&&other: level) -> bool {\n+        (self as uint) == (other as uint)\n+    }\n+}\n+\n fn diagnosticstr(lvl: level) -> ~str {\n     match lvl {\n       fatal => ~\"error\","}, {"sha": "3d763c271401c5fed8a357b30bd5417f4ca50f69", "filename": "src/libsyntax/ext/pipes/proto.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/96534365c228d9c3962036967a7f1a1b17639e33/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96534365c228d9c3962036967a7f1a1b17639e33/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs?ref=96534365c228d9c3962036967a7f1a1b17639e33", "patch": "@@ -3,8 +3,17 @@ import dvec::DVec;\n \n import ast_builder::{path, append_types};\n \n-enum direction {\n-    send, recv\n+enum direction { send, recv }\n+\n+impl direction : cmp::Eq {\n+    pure fn eq(&&other: direction) -> bool {\n+        match (self, other) {\n+            (send, send) => true,\n+            (recv, recv) => true,\n+            (send, _) => false,\n+            (recv, _) => false,\n+        }\n+    }\n }\n \n impl direction: ToStr {"}, {"sha": "d9a09ffde838dd849c35d0643cf840f0b069aa00", "filename": "src/libsyntax/ext/simplext.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/96534365c228d9c3962036967a7f1a1b17639e33/src%2Flibsyntax%2Fext%2Fsimplext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96534365c228d9c3962036967a7f1a1b17639e33/src%2Flibsyntax%2Fext%2Fsimplext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsimplext.rs?ref=96534365c228d9c3962036967a7f1a1b17639e33", "patch": "@@ -466,7 +466,12 @@ fn p_t_s_rec(cx: ext_ctxt, m: matchable, s: selector, b: binders) {\n                match_result {\n                 return match m {\n                       match_expr(e) => {\n-                        if e == pat { Some(leaf(match_exact)) } else { None }\n+                        if box::ptr_eq(e, pat) {\n+                            // XXX: Is this right?\n+                            Some(leaf(match_exact))\n+                        } else {\n+                            None\n+                        }\n                       }\n                       _ => cx.bug(~\"broken traversal in p_t_s_r\")\n                     }"}, {"sha": "8cc8994189b5d9921cff7e48edc0b7c24948a56e", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/96534365c228d9c3962036967a7f1a1b17639e33/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96534365c228d9c3962036967a7f1a1b17639e33/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=96534365c228d9c3962036967a7f1a1b17639e33", "patch": "@@ -3563,6 +3563,13 @@ struct parser {\n         return cdirs;\n     }\n }\n+\n+impl restriction : cmp::Eq {\n+    pure fn eq(&&other: restriction) -> bool {\n+        (self as uint) == (other as uint)\n+    }\n+}\n+\n //\n // Local Variables:\n // mode: rust"}, {"sha": "b9a9bc79e132ecd97a645d3dc9ed0608eb3db407", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 272, "deletions": 1, "changes": 273, "blob_url": "https://github.com/rust-lang/rust/blob/96534365c228d9c3962036967a7f1a1b17639e33/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96534365c228d9c3962036967a7f1a1b17639e33/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=96534365c228d9c3962036967a7f1a1b17639e33", "patch": "@@ -349,7 +349,7 @@ fn mk_ident_interner() -> ident_interner {\n                                            |x,y| str::eq(*x, *y), init_vec);\n \n     /* having multiple interners will just confuse the serializer */\n-    unsafe{ assert task::local_data_get(interner_key!()) == None };\n+    unsafe{ assert task::local_data_get(interner_key!()).is_none() };\n     unsafe{ task::local_data_set(interner_key!(), @rv) };\n     rv\n }\n@@ -440,6 +440,277 @@ fn restricted_keyword_table() -> hashmap<~str, ()> {\n     words\n }\n \n+impl binop : cmp::Eq {\n+    pure fn eq(&&other: binop) -> bool {\n+        (self as uint) == (other as uint)\n+    }\n+}\n+\n+impl token : cmp::Eq {\n+    pure fn eq(&&other: token) -> bool {\n+        match self {\n+            EQ => {\n+                match other {\n+                    EQ => true,\n+                    _ => false\n+                }\n+            }\n+            LT => {\n+                match other {\n+                    LT => true,\n+                    _ => false\n+                }\n+            }\n+            LE => {\n+                match other {\n+                    LE => true,\n+                    _ => false\n+                }\n+            }\n+            EQEQ => {\n+                match other {\n+                    EQEQ => true,\n+                    _ => false\n+                }\n+            }\n+            NE => {\n+                match other {\n+                    NE => true,\n+                    _ => false\n+                }\n+            }\n+            GE => {\n+                match other {\n+                    GE => true,\n+                    _ => false\n+                }\n+            }\n+            GT => {\n+                match other {\n+                    GT => true,\n+                    _ => false\n+                }\n+            }\n+            ANDAND => {\n+                match other {\n+                    ANDAND => true,\n+                    _ => false\n+                }\n+            }\n+            OROR => {\n+                match other {\n+                    OROR => true,\n+                    _ => false\n+                }\n+            }\n+            NOT => {\n+                match other {\n+                    NOT => true,\n+                    _ => false\n+                }\n+            }\n+            TILDE => {\n+                match other {\n+                    TILDE => true,\n+                    _ => false\n+                }\n+            }\n+            BINOP(e0a) => {\n+                match other {\n+                    BINOP(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            BINOPEQ(e0a) => {\n+                match other {\n+                    BINOPEQ(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            AT => {\n+                match other {\n+                    AT => true,\n+                    _ => false\n+                }\n+            }\n+            DOT => {\n+                match other {\n+                    DOT => true,\n+                    _ => false\n+                }\n+            }\n+            DOTDOT => {\n+                match other {\n+                    DOTDOT => true,\n+                    _ => false\n+                }\n+            }\n+            ELLIPSIS => {\n+                match other {\n+                    ELLIPSIS => true,\n+                    _ => false\n+                }\n+            }\n+            COMMA => {\n+                match other {\n+                    COMMA => true,\n+                    _ => false\n+                }\n+            }\n+            SEMI => {\n+                match other {\n+                    SEMI => true,\n+                    _ => false\n+                }\n+            }\n+            COLON => {\n+                match other {\n+                    COLON => true,\n+                    _ => false\n+                }\n+            }\n+            MOD_SEP => {\n+                match other {\n+                    MOD_SEP => true,\n+                    _ => false\n+                }\n+            }\n+            RARROW => {\n+                match other {\n+                    RARROW => true,\n+                    _ => false\n+                }\n+            }\n+            LARROW => {\n+                match other {\n+                    LARROW => true,\n+                    _ => false\n+                }\n+            }\n+            DARROW => {\n+                match other {\n+                    DARROW => true,\n+                    _ => false\n+                }\n+            }\n+            FAT_ARROW => {\n+                match other {\n+                    FAT_ARROW => true,\n+                    _ => false\n+                }\n+            }\n+            LPAREN => {\n+                match other {\n+                    LPAREN => true,\n+                    _ => false\n+                }\n+            }\n+            RPAREN => {\n+                match other {\n+                    RPAREN => true,\n+                    _ => false\n+                }\n+            }\n+            LBRACKET => {\n+                match other {\n+                    LBRACKET => true,\n+                    _ => false\n+                }\n+            }\n+            RBRACKET => {\n+                match other {\n+                    RBRACKET => true,\n+                    _ => false\n+                }\n+            }\n+            LBRACE => {\n+                match other {\n+                    LBRACE => true,\n+                    _ => false\n+                }\n+            }\n+            RBRACE => {\n+                match other {\n+                    RBRACE => true,\n+                    _ => false\n+                }\n+            }\n+            POUND => {\n+                match other {\n+                    POUND => true,\n+                    _ => false\n+                }\n+            }\n+            DOLLAR => {\n+                match other {\n+                    DOLLAR => true,\n+                    _ => false\n+                }\n+            }\n+            LIT_INT(e0a, e1a) => {\n+                match other {\n+                    LIT_INT(e0b, e1b) => e0a == e0b && e1a == e1b,\n+                    _ => false\n+                }\n+            }\n+            LIT_UINT(e0a, e1a) => {\n+                match other {\n+                    LIT_UINT(e0b, e1b) => e0a == e0b && e1a == e1b,\n+                    _ => false\n+                }\n+            }\n+            LIT_INT_UNSUFFIXED(e0a) => {\n+                match other {\n+                    LIT_INT_UNSUFFIXED(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            LIT_FLOAT(e0a, e1a) => {\n+                match other {\n+                    LIT_FLOAT(e0b, e1b) => e0a == e0b && e1a == e1b,\n+                    _ => false\n+                }\n+            }\n+            LIT_STR(e0a) => {\n+                match other {\n+                    LIT_STR(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            IDENT(e0a, e1a) => {\n+                match other {\n+                    IDENT(e0b, e1b) => e0a == e0b && e1a == e1b,\n+                    _ => false\n+                }\n+            }\n+            UNDERSCORE => {\n+                match other {\n+                    UNDERSCORE => true,\n+                    _ => false\n+                }\n+            }\n+            INTERPOLATED(_) => {\n+                match other {\n+                    INTERPOLATED(_) => true,\n+                    _ => false\n+                }\n+            }\n+            DOC_COMMENT(e0a) => {\n+                match other {\n+                    DOC_COMMENT(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            EOF => {\n+                match other {\n+                    EOF => true,\n+                    _ => false\n+                }\n+            }\n+        }\n+    }\n+}\n+\n // Local Variables:\n // fill-column: 78;\n // indent-tabs-mode: nil"}, {"sha": "a693726e83f49873ebe565f0c3c5f53058f2ae8e", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/96534365c228d9c3962036967a7f1a1b17639e33/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96534365c228d9c3962036967a7f1a1b17639e33/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=96534365c228d9c3962036967a7f1a1b17639e33", "patch": "@@ -55,12 +55,37 @@ import dvec::DVec;\n  */\n enum breaks { consistent, inconsistent, }\n \n+impl breaks : cmp::Eq {\n+    pure fn eq(&&other: breaks) -> bool {\n+        match (self, other) {\n+            (consistent, consistent) => true,\n+            (inconsistent, inconsistent) => true,\n+            (consistent, _) => false,\n+            (inconsistent, _) => false,\n+        }\n+    }\n+}\n+\n type break_t = {offset: int, blank_space: int};\n \n type begin_t = {offset: int, breaks: breaks};\n \n enum token { STRING(@~str, int), BREAK(break_t), BEGIN(begin_t), END, EOF, }\n \n+impl token {\n+    fn is_eof() -> bool {\n+        match self { EOF => true, _ => false }\n+    }\n+    fn is_hardbreak_tok() -> bool {\n+        match self {\n+            BREAK({offset: 0, blank_space: bs }) if bs == size_infinity =>\n+                true,\n+            _ =>\n+                false\n+        }\n+    }\n+}\n+\n fn tok_str(++t: token) -> ~str {\n     match t {\n       STRING(s, len) => return fmt!(\"STR(%s,%d)\", *s, len),"}, {"sha": "59e59efe6d7d68640c8f034888079395d393c176", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/96534365c228d9c3962036967a7f1a1b17639e33/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96534365c228d9c3962036967a7f1a1b17639e33/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=96534365c228d9c3962036967a7f1a1b17639e33", "patch": "@@ -244,8 +244,7 @@ fn is_end(s: ps) -> bool {\n }\n \n fn is_bol(s: ps) -> bool {\n-    return s.s.last_token() == pp::EOF ||\n-            s.s.last_token() == pp::hardbreak_tok();\n+    return s.s.last_token().is_eof() || s.s.last_token().is_hardbreak_tok();\n }\n \n fn in_cbox(s: ps) -> bool {\n@@ -260,7 +259,7 @@ fn break_offset_if_not_bol(s: ps, n: uint, off: int) {\n     if !is_bol(s) {\n         break_offset(s.s, n, off);\n     } else {\n-        if off != 0 && s.s.last_token() == pp::hardbreak_tok() {\n+        if off != 0 && s.s.last_token().is_hardbreak_tok() {\n             // We do something pretty sketchy here: tuck the nonzero\n             // offset-adjustment we were going to deposit along with the\n             // break into the previous hardbreak."}, {"sha": "70923a67d8dc58cb62c1e9f9ce15495469139f38", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/96534365c228d9c3962036967a7f1a1b17639e33/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96534365c228d9c3962036967a7f1a1b17639e33/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=96534365c228d9c3962036967a7f1a1b17639e33", "patch": "@@ -614,11 +614,7 @@ fn mk_simple_visitor(v: simple_visitor) -> vt<()> {\n         f(fk, decl, body, sp, id);\n         visit_fn(fk, decl, body, sp, id, e, v);\n     }\n-    let visit_ty = if v.visit_ty == simple_ignore_ty {\n-        |a,b,c| skip_ty(a, b, c)\n-    } else {\n-        |a,b,c| v_ty(v.visit_ty, a, b, c)\n-    };\n+    let visit_ty = |a,b,c| v_ty(v.visit_ty, a, b, c);\n     fn v_struct_field(f: fn@(@struct_field), sf: @struct_field, &&e: (),\n                       v: vt<()>) {\n         f(sf);"}, {"sha": "a81755be9333d971b247104ebb7b874c0492337a", "filename": "src/rustc/back/link.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/96534365c228d9c3962036967a7f1a1b17639e33/src%2Frustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96534365c228d9c3962036967a7f1a1b17639e33/src%2Frustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fback%2Flink.rs?ref=96534365c228d9c3962036967a7f1a1b17639e33", "patch": "@@ -26,6 +26,12 @@ enum output_type {\n     output_type_exe,\n }\n \n+impl output_type : cmp::Eq {\n+    pure fn eq(&&other: output_type) -> bool {\n+        (self as uint) == (other as uint)\n+    }\n+}\n+\n fn llvm_err(sess: session, msg: ~str) -> ! unsafe {\n     let cstr = llvm::LLVMRustGetLastError();\n     if cstr == ptr::null() {"}, {"sha": "c9be01f4d5647fe874f6a9511650e2f512af7b35", "filename": "src/rustc/driver/driver.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/96534365c228d9c3962036967a7f1a1b17639e33/src%2Frustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96534365c228d9c3962036967a7f1a1b17639e33/src%2Frustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Fdriver.rs?ref=96534365c228d9c3962036967a7f1a1b17639e33", "patch": "@@ -136,6 +136,12 @@ enum compile_upto {\n     cu_everything,\n }\n \n+impl compile_upto : cmp::Eq {\n+    pure fn eq(&&other: compile_upto) -> bool {\n+        (self as uint) == (other as uint)\n+    }\n+}\n+\n fn compile_upto(sess: session, cfg: ast::crate_cfg,\n                 input: input, upto: compile_upto,\n                 outputs: Option<output_filenames>)"}, {"sha": "cd4e327687795837a201710ab0000054d779e1fb", "filename": "src/rustc/driver/rustc.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/96534365c228d9c3962036967a7f1a1b17639e33/src%2Frustc%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96534365c228d9c3962036967a7f1a1b17639e33/src%2Frustc%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Frustc.rs?ref=96534365c228d9c3962036967a7f1a1b17639e33", "patch": "@@ -199,6 +199,17 @@ fn run_compiler(args: ~[~str], demitter: diagnostic::emitter) {\n     compile_input(sess, cfg, input, &odir, &ofile);\n }\n \n+enum monitor_msg {\n+    fatal,\n+    done,\n+}\n+\n+impl monitor_msg : cmp::Eq {\n+    pure fn eq(&&other: monitor_msg) -> bool {\n+        (self as uint) == (other as uint)\n+    }\n+}\n+\n /*\n This is a sanity check that any failure of the compiler is performed\n through the diagnostic module and reported properly - we shouldn't be calling\n@@ -212,11 +223,6 @@ fails without recording a fatal error then we've encountered a compiler\n bug and need to present an error.\n */\n fn monitor(+f: fn~(diagnostic::emitter)) {\n-    enum monitor_msg {\n-        fatal,\n-        done,\n-    };\n-\n     let p = comm::Port();\n     let ch = comm::Chan(p);\n "}, {"sha": "59c4e5697adcf276e8952d3a0d6feef758c20646", "filename": "src/rustc/driver/session.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/96534365c228d9c3962036967a7f1a1b17639e33/src%2Frustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96534365c228d9c3962036967a7f1a1b17639e33/src%2Frustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Fsession.rs?ref=96534365c228d9c3962036967a7f1a1b17639e33", "patch": "@@ -12,8 +12,20 @@ import middle::lint;\n \n enum os { os_win32, os_macos, os_linux, os_freebsd, }\n \n+impl os : cmp::Eq {\n+    pure fn eq(&&other: os) -> bool {\n+        (self as uint) == (other as uint)\n+    }\n+}\n+\n enum arch { arch_x86, arch_x86_64, arch_arm, }\n \n+impl arch: cmp::Eq {\n+    pure fn eq(&&other: arch) -> bool {\n+        (self as uint) == (other as uint)\n+    }\n+}\n+\n enum crate_type { bin_crate, lib_crate, unknown_crate, }\n \n type config =\n@@ -79,6 +91,12 @@ enum OptLevel {\n     Aggressive // -O3\n }\n \n+impl OptLevel : cmp::Eq {\n+    pure fn eq(&&other: OptLevel) -> bool {\n+        (self as uint) == (other as uint)\n+    }\n+}\n+\n type options =\n     // The crate config requested for the session, which may be combined\n     // with additional crate configurations during the compile process"}, {"sha": "e2c7d3e522aa39de0d8a142a0a03e6bb296be62a", "filename": "src/rustc/front/test.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/96534365c228d9c3962036967a7f1a1b17639e33/src%2Frustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96534365c228d9c3962036967a7f1a1b17639e33/src%2Frustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Ffront%2Ftest.rs?ref=96534365c228d9c3962036967a7f1a1b17639e33", "patch": "@@ -134,7 +134,10 @@ fn is_test_fn(i: @ast::item) -> bool {\n         match i.node {\n           ast::item_fn(decl, _, tps, _) => {\n             let input_cnt = vec::len(decl.inputs);\n-            let no_output = decl.output.node == ast::ty_nil;\n+            let no_output = match decl.output.node {\n+                ast::ty_nil => true,\n+                _ => false\n+            };\n             let tparm_cnt = vec::len(tps);\n             input_cnt == 0u && no_output && tparm_cnt == 0u\n           }"}, {"sha": "1440a654a8978a4ec956093a2847b758ac29b4d8", "filename": "src/rustc/lib/llvm.rs", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/96534365c228d9c3962036967a7f1a1b17639e33/src%2Frustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96534365c228d9c3962036967a7f1a1b17639e33/src%2Frustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Flib%2Fllvm.rs?ref=96534365c228d9c3962036967a7f1a1b17639e33", "patch": "@@ -128,6 +128,45 @@ enum TypeKind {\n     X86_MMX   = 15\n }\n \n+impl TypeKind : cmp::Eq {\n+    pure fn eq(&&other: TypeKind) -> bool {\n+        match (self, other) {\n+            (Void, Void) => true,\n+            (Half, Half) => true,\n+            (Float, Float) => true,\n+            (Double, Double) => true,\n+            (X86_FP80, X86_FP80) => true,\n+            (FP128, FP128) => true,\n+            (PPC_FP128, PPC_FP128) => true,\n+            (Label, Label) => true,\n+            (Integer, Integer) => true,\n+            (Function, Function) => true,\n+            (Struct, Struct) => true,\n+            (Array, Array) => true,\n+            (Pointer, Pointer) => true,\n+            (Vector, Vector) => true,\n+            (Metadata, Metadata) => true,\n+            (X86_MMX, X86_MMX) => true,\n+            (Void, _) => false,\n+            (Half, _) => false,\n+            (Float, _) => false,\n+            (Double, _) => false,\n+            (X86_FP80, _) => false,\n+            (FP128, _) => false,\n+            (PPC_FP128, _) => false,\n+            (Label, _) => false,\n+            (Integer, _) => false,\n+            (Function, _) => false,\n+            (Struct, _) => false,\n+            (Array, _) => false,\n+            (Pointer, _) => false,\n+            (Vector, _) => false,\n+            (Metadata, _) => false,\n+            (X86_MMX, _) => false,\n+        }\n+    }\n+}\n+\n enum AtomicBinOp {\n     Xchg = 0,\n     Add  = 1,"}, {"sha": "ee3abe1b089f7ee9b281fbe626060cab13ad7f8f", "filename": "src/rustc/metadata/decoder.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/96534365c228d9c3962036967a7f1a1b17639e33/src%2Frustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96534365c228d9c3962036967a7f1a1b17639e33/src%2Frustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fdecoder.rs?ref=96534365c228d9c3962036967a7f1a1b17639e33", "patch": "@@ -129,6 +129,12 @@ enum Family {\n     InheritedField         // N\n }\n \n+impl Family : cmp::Eq {\n+    pure fn eq(&&other: Family) -> bool {\n+        (self as uint) == (other as uint)\n+    }\n+}\n+\n fn item_family(item: ebml::Doc) -> Family {\n     let fam = ebml::get_doc(item, tag_items_data_item_family);\n     match ebml::doc_as_u8(fam) as char {"}, {"sha": "25902d86674849c860d33d6f1b11d4eed545017f", "filename": "src/rustc/middle/borrowck.rs", "status": "modified", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/96534365c228d9c3962036967a7f1a1b17639e33/src%2Frustc%2Fmiddle%2Fborrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96534365c228d9c3962036967a7f1a1b17639e33/src%2Frustc%2Fmiddle%2Fborrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck.rs?ref=96534365c228d9c3962036967a7f1a1b17639e33", "patch": "@@ -322,10 +322,60 @@ enum bckerr_code {\n     err_out_of_scope(ty::region, ty::region) // superscope, subscope\n }\n \n+impl bckerr_code : cmp::Eq {\n+    pure fn eq(&&other: bckerr_code) -> bool {\n+        match self {\n+            err_mut_uniq => {\n+                match other {\n+                    err_mut_uniq => true,\n+                    _ => false\n+                }\n+            }\n+            err_mut_variant => {\n+                match other {\n+                    err_mut_variant => true,\n+                    _ => false\n+                }\n+            }\n+            err_root_not_permitted => {\n+                match other {\n+                    err_root_not_permitted => true,\n+                    _ => false\n+                }\n+            }\n+            err_mutbl(e0a, e1a) => {\n+                match other {\n+                    err_mutbl(e0b, e1b) => e0a == e0b && e1a == e1b,\n+                    _ => false\n+                }\n+            }\n+            err_out_of_root_scope(e0a, e1a) => {\n+                match other {\n+                    err_out_of_root_scope(e0b, e1b) =>\n+                        e0a == e0b && e1a == e1b,\n+                    _ => false\n+                }\n+            }\n+            err_out_of_scope(e0a, e1a) => {\n+                match other {\n+                    err_out_of_scope(e0b, e1b) => e0a == e0b && e1a == e1b,\n+                    _ => false\n+                }\n+            }\n+        }\n+    }\n+}\n+\n // Combination of an error code and the categorization of the expression\n // that caused it\n type bckerr = {cmt: cmt, code: bckerr_code};\n \n+impl bckerr : cmp::Eq {\n+    pure fn eq(&&other: bckerr) -> bool {\n+        self.cmt == other.cmt && self.code == other.code\n+    }\n+}\n+\n // shorthand for something that fails with `bckerr` or succeeds with `T`\n type bckres<T> = Result<T, bckerr>;\n "}, {"sha": "b5fd72b36674cb7612c4c2981811e6700d3b53b4", "filename": "src/rustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/96534365c228d9c3962036967a7f1a1b17639e33/src%2Frustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96534365c228d9c3962036967a7f1a1b17639e33/src%2Frustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=96534365c228d9c3962036967a7f1a1b17639e33", "patch": "@@ -36,6 +36,25 @@ enum purity_cause {\n     pc_cmt(bckerr)\n }\n \n+impl purity_cause : cmp::Eq {\n+    pure fn eq(&&other: purity_cause) -> bool {\n+        match self {\n+            pc_pure_fn => {\n+                match other {\n+                    pc_pure_fn => true,\n+                    _ => false\n+                }\n+            }\n+            pc_cmt(e0a) => {\n+                match other {\n+                    pc_cmt(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+        }\n+    }\n+}\n+\n fn check_loans(bccx: borrowck_ctxt,\n                req_maps: req_maps,\n                crate: @ast::crate) {"}, {"sha": "a91bb25c1acb6f028535d5ae92abd54178a0b225", "filename": "src/rustc/middle/check_alt.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/96534365c228d9c3962036967a7f1a1b17639e33/src%2Frustc%2Fmiddle%2Fcheck_alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96534365c228d9c3962036967a7f1a1b17639e33/src%2Frustc%2Fmiddle%2Fcheck_alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fcheck_alt.rs?ref=96534365c228d9c3962036967a7f1a1b17639e33", "patch": "@@ -124,6 +124,22 @@ enum ctor {\n     range(const_val, const_val),\n }\n \n+impl ctor: cmp::Eq {\n+    pure fn eq(&&other: ctor) -> bool {\n+        match (self, other) {\n+            (single, single) => true,\n+            (variant(did_self), variant(did_other)) => did_self == did_other,\n+            (val(cv_self), val(cv_other)) => cv_self == cv_other,\n+            (range(cv0_self, cv1_self), range(cv0_other, cv1_other)) => {\n+                cv0_self == cv0_other && cv1_self == cv1_other\n+            }\n+            (single, _) | (variant(_), _) | (val(_), _) | (range(*), _) => {\n+                false\n+            }\n+        }\n+    }\n+}\n+\n // Algorithm from http://moscova.inria.fr/~maranget/papers/warn/index.html\n //\n // Whether a vector `v` of patterns is 'useful' in relation to a set of such"}, {"sha": "8eaeef0d120ad8851a5244be867c4240a773d9ca", "filename": "src/rustc/middle/const_eval.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/96534365c228d9c3962036967a7f1a1b17639e33/src%2Frustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96534365c228d9c3962036967a7f1a1b17639e33/src%2Frustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fconst_eval.rs?ref=96534365c228d9c3962036967a7f1a1b17639e33", "patch": "@@ -189,6 +189,20 @@ enum const_val {\n     const_bool(bool)\n }\n \n+impl const_val: cmp::Eq {\n+    pure fn eq(&&other: const_val) -> bool {\n+        match (self, other) {\n+            (const_float(a), const_float(b)) => a == b,\n+            (const_int(a), const_int(b)) => a == b,\n+            (const_uint(a), const_uint(b)) => a == b,\n+            (const_str(a), const_str(b)) => a == b,\n+            (const_bool(a), const_bool(b)) => a == b,\n+            (const_float(_), _) | (const_int(_), _) | (const_uint(_), _) |\n+            (const_str(_), _) | (const_bool(_), _) => false\n+        }\n+    }\n+}\n+\n // FIXME: issue #1417\n fn eval_const_expr(tcx: middle::ty::ctxt, e: @expr) -> const_val {\n     import middle::ty;"}, {"sha": "403b98e380a6f089229d4ffeddc694247bfe541e", "filename": "src/rustc/middle/lint.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/96534365c228d9c3962036967a7f1a1b17639e33/src%2Frustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96534365c228d9c3962036967a7f1a1b17639e33/src%2Frustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Flint.rs?ref=96534365c228d9c3962036967a7f1a1b17639e33", "patch": "@@ -63,6 +63,12 @@ enum lint {\n     // dead_assignment\n }\n \n+impl lint : cmp::Eq {\n+    pure fn eq(&&other: lint) -> bool {\n+        (self as uint) == (other as uint)\n+    }\n+}\n+\n fn level_to_str(lv: level) -> ~str {\n     match lv {\n       allow => ~\"allow\",\n@@ -76,6 +82,12 @@ enum level {\n     allow, warn, deny, forbid\n }\n \n+impl level : cmp::Eq {\n+    pure fn eq(&&other: level) -> bool {\n+        (self as uint) == (other as uint)\n+    }\n+}\n+\n type lint_spec = @{lint: lint,\n                    desc: ~str,\n                    default: level};"}, {"sha": "ae52965f21b85622825d0649f1aff80eb1ed8af5", "filename": "src/rustc/middle/liveness.rs", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/96534365c228d9c3962036967a7f1a1b17639e33/src%2Frustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96534365c228d9c3962036967a7f1a1b17639e33/src%2Frustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fliveness.rs?ref=96534365c228d9c3962036967a7f1a1b17639e33", "patch": "@@ -127,13 +127,56 @@ type last_use_map = hashmap<node_id, @DVec<node_id>>;\n enum Variable = uint;\n enum LiveNode = uint;\n \n+impl Variable : cmp::Eq {\n+    pure fn eq(&&other: Variable) -> bool {\n+        *self == *other\n+    }\n+}\n+\n+impl LiveNode : cmp::Eq {\n+    pure fn eq(&&other: LiveNode) -> bool {\n+        *self == *other\n+    }\n+}\n+\n enum LiveNodeKind {\n     FreeVarNode(span),\n     ExprNode(span),\n     VarDefNode(span),\n     ExitNode\n }\n \n+impl LiveNodeKind : cmp::Eq {\n+    pure fn eq(&&other: LiveNodeKind) -> bool {\n+        match self {\n+            FreeVarNode(e0a) => {\n+                match other {\n+                    FreeVarNode(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            ExprNode(e0a) => {\n+                match other {\n+                    ExprNode(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            VarDefNode(e0a) => {\n+                match other {\n+                    VarDefNode(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            ExitNode => {\n+                match other {\n+                    ExitNode => true,\n+                    _ => false\n+                }\n+            }\n+        }\n+    }\n+}\n+\n fn check_crate(tcx: ty::ctxt,\n                method_map: typeck::method_map,\n                crate: @crate) -> last_use_map {"}, {"sha": "453555f30455b26268e8e91ea7fa67e60711f875", "filename": "src/rustc/middle/mem_categorization.rs", "status": "modified", "additions": 181, "deletions": 2, "changes": 183, "blob_url": "https://github.com/rust-lang/rust/blob/96534365c228d9c3962036967a7f1a1b17639e33/src%2Frustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96534365c228d9c3962036967a7f1a1b17639e33/src%2Frustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fmem_categorization.rs?ref=96534365c228d9c3962036967a7f1a1b17639e33", "patch": "@@ -55,8 +55,106 @@ enum categorization {\n     cat_discr(cmt, ast::node_id),   // match discriminant (see preserve())\n }\n \n+impl categorization : cmp::Eq {\n+    pure fn eq(&&other: categorization) -> bool {\n+        match self {\n+            cat_rvalue => {\n+                match other {\n+                    cat_rvalue => true,\n+                    _ => false\n+                }\n+            }\n+            cat_special(e0a) => {\n+                match other {\n+                    cat_special(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            cat_local(e0a) => {\n+                match other {\n+                    cat_local(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            cat_binding(e0a) => {\n+                match other {\n+                    cat_binding(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            cat_arg(e0a) => {\n+                match other {\n+                    cat_arg(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            cat_stack_upvar(e0a) => {\n+                match other {\n+                    cat_stack_upvar(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            cat_deref(e0a, e1a, e2a) => {\n+                match other {\n+                    cat_deref(e0b, e1b, e2b) =>\n+                        e0a == e0b && e1a == e1b && e2a == e2b,\n+                    _ => false\n+                }\n+            }\n+            cat_comp(e0a, e1a) => {\n+                match other {\n+                    cat_comp(e0b, e1b) => e0a == e0b && e1a == e1b,\n+                    _ => false\n+                }\n+            }\n+            cat_discr(e0a, e1a) => {\n+                match other {\n+                    cat_discr(e0b, e1b) => e0a == e0b && e1a == e1b,\n+                    _ => false\n+                }\n+            }\n+        }\n+    }\n+}\n+\n // different kinds of pointers:\n-enum ptr_kind {uniq_ptr, gc_ptr, region_ptr(ty::region), unsafe_ptr}\n+enum ptr_kind {\n+    uniq_ptr,\n+    gc_ptr,\n+    region_ptr(ty::region),\n+    unsafe_ptr\n+}\n+\n+impl ptr_kind : cmp::Eq {\n+    pure fn eq(&&other: ptr_kind) -> bool {\n+        match self {\n+            uniq_ptr => {\n+                match other {\n+                    uniq_ptr => true,\n+                    _ => false\n+                }\n+            }\n+            gc_ptr => {\n+                match other {\n+                    gc_ptr => true,\n+                    _ => false\n+                }\n+            }\n+            region_ptr(e0a) => {\n+                match other {\n+                    region_ptr(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            unsafe_ptr => {\n+                match other {\n+                    unsafe_ptr => true,\n+                    _ => false\n+                }\n+            }\n+        }\n+    }\n+}\n \n // I am coining the term \"components\" to mean \"pieces of a data\n // structure accessible without a dereference\":\n@@ -69,6 +167,37 @@ enum comp_kind {\n                ast::mutability)  // mutability of vec content\n }\n \n+impl comp_kind : cmp::Eq {\n+    pure fn eq(&&other: comp_kind) -> bool {\n+        match self {\n+            comp_tuple => {\n+                match other {\n+                    comp_tuple => true,\n+                    _ => false\n+                }\n+            }\n+            comp_variant(e0a) => {\n+                match other {\n+                    comp_variant(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            comp_field(e0a, e1a) => {\n+                match other {\n+                    comp_field(e0b, e1b) => e0a == e0b && e1a == e1b,\n+                    _ => false\n+                }\n+            }\n+            comp_index(e0a, e1a) => {\n+                match other {\n+                    comp_index(e0b, e1b) => e0a == e0b && e1a == e1b,\n+                    _ => false\n+                }\n+            }\n+        }\n+    }\n+}\n+\n // different kinds of expressions we might evaluate\n enum special_kind {\n     sk_method,\n@@ -77,16 +206,35 @@ enum special_kind {\n     sk_heap_upvar\n }\n \n+impl special_kind : cmp::Eq {\n+    pure fn eq(&&other: special_kind) -> bool {\n+        (self as uint) == (other as uint)\n+    }\n+}\n+\n // a complete categorization of a value indicating where it originated\n // and how it is located, as well as the mutability of the memory in\n // which the value is stored.\n-type cmt = @{id: ast::node_id,        // id of expr/pat producing this value\n+type cmt_ = {id: ast::node_id,        // id of expr/pat producing this value\n              span: span,              // span of same expr/pat\n              cat: categorization,     // categorization of expr\n              lp: Option<@loan_path>,  // loan path for expr, if any\n              mutbl: ast::mutability,  // mutability of expr as lvalue\n              ty: ty::t};              // type of the expr\n \n+type cmt = @cmt_;\n+\n+impl cmt_ : cmp::Eq {\n+    pure fn eq(&&other: cmt_) -> bool {\n+        self.id == other.id &&\n+        self.span == other.span &&\n+        self.cat == other.cat &&\n+        self.lp == other.lp &&\n+        self.mutbl == other.mutbl &&\n+        self.ty == other.ty\n+    }\n+}\n+\n // a loan path is like a category, but it exists only when the data is\n // interior to the stack frame.  loan paths are used as the key to a\n // map indicating what is borrowed at any point in time.\n@@ -97,6 +245,37 @@ enum loan_path {\n     lp_comp(@loan_path, comp_kind)\n }\n \n+impl loan_path : cmp::Eq {\n+    pure fn eq(&&other: loan_path) -> bool {\n+        match self {\n+            lp_local(e0a) => {\n+                match other {\n+                    lp_local(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            lp_arg(e0a) => {\n+                match other {\n+                    lp_arg(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            lp_deref(e0a, e1a) => {\n+                match other {\n+                    lp_deref(e0b, e1b) => e0a == e0b && e1a == e1b,\n+                    _ => false\n+                }\n+            }\n+            lp_comp(e0a, e1a) => {\n+                match other {\n+                    lp_comp(e0b, e1b) => e0a == e0b && e1a == e1b,\n+                    _ => false\n+                }\n+            }\n+        }\n+    }\n+}\n+\n // We pun on *T to mean both actual deref of a ptr as well\n // as accessing of components:\n enum deref_kind {deref_ptr(ptr_kind), deref_comp(comp_kind)}"}, {"sha": "bc0f3971e82698145081d0b5d95860f8cc4db15d", "filename": "src/rustc/middle/region.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/96534365c228d9c3962036967a7f1a1b17639e33/src%2Frustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96534365c228d9c3962036967a7f1a1b17639e33/src%2Frustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fregion.rs?ref=96534365c228d9c3962036967a7f1a1b17639e33", "patch": "@@ -370,6 +370,12 @@ type region_paramd_items = hashmap<ast::node_id, region_variance>;\n type region_dep = {ambient_variance: region_variance, id: ast::node_id};\n type dep_map = hashmap<ast::node_id, @DVec<region_dep>>;\n \n+impl region_dep: cmp::Eq {\n+    pure fn eq(&&other: region_dep) -> bool {\n+        self.ambient_variance == other.ambient_variance && self.id == other.id\n+    }\n+}\n+\n type determine_rp_ctxt_ = {\n     sess: session,\n     ast_map: ast_map::map,"}, {"sha": "48e1f1d37906dcdd57c5adcfc825e7dc41ffa7c8", "filename": "src/rustc/middle/resolve.rs", "status": "modified", "additions": 61, "deletions": 7, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/96534365c228d9c3962036967a7f1a1b17639e33/src%2Frustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96534365c228d9c3962036967a7f1a1b17639e33/src%2Frustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fresolve.rs?ref=96534365c228d9c3962036967a7f1a1b17639e33", "patch": "@@ -110,6 +110,13 @@ enum PatternBindingMode {\n     IrrefutableMode\n }\n \n+impl PatternBindingMode : cmp::Eq {\n+    pure fn eq(&&other: PatternBindingMode) -> bool {\n+        (self as uint) == (other as uint)\n+    }\n+}\n+\n+\n enum Namespace {\n     ModuleNS,\n     TypeNS,\n@@ -122,6 +129,15 @@ enum NamespaceResult {\n     BoundResult(@Module, @NameBindings)\n }\n \n+impl NamespaceResult {\n+    pure fn is_unknown() -> bool {\n+        match self {\n+            UnknownResult => true,\n+            _ => false\n+        }\n+    }\n+}\n+\n enum NameDefinition {\n     NoNameDefinition,           //< The name was unbound.\n     ChildNameDefinition(def),   //< The name identifies an immediate child.\n@@ -134,6 +150,12 @@ enum Mutability {\n     Immutable\n }\n \n+impl Mutability : cmp::Eq {\n+    pure fn eq(&&other: Mutability) -> bool {\n+        (self as uint) == (other as uint)\n+    }\n+}\n+\n enum SelfBinding {\n     NoSelfBinding,\n     HasSelfBinding(node_id)\n@@ -151,6 +173,12 @@ enum ModuleDef {\n     ModuleDef(@Module),     // Defines a module.\n }\n \n+impl ModuleDef {\n+    pure fn is_none() -> bool {\n+        match self { NoModuleDef => true, _ => false }\n+    }\n+}\n+\n /// Contains data for specific types of import directives.\n enum ImportDirectiveSubclass {\n     SingleImport(Atom /* target */, Atom /* source */),\n@@ -231,11 +259,23 @@ enum XrayFlag {\n     Xray        //< Private items can be accessed.\n }\n \n+impl XrayFlag : cmp::Eq {\n+    pure fn eq(&&other: XrayFlag) -> bool {\n+        (self as uint) == (other as uint)\n+    }\n+}\n+\n enum AllowCapturingSelfFlag {\n     AllowCapturingSelf,         //< The \"self\" definition can be captured.\n     DontAllowCapturingSelf,     //< The \"self\" definition cannot be captured.\n }\n \n+impl AllowCapturingSelfFlag : cmp::Eq {\n+    pure fn eq(&&other: AllowCapturingSelfFlag) -> bool {\n+        (self as uint) == (other as uint)\n+    }\n+}\n+\n enum EnumVariantOrConstResolution {\n     FoundEnumVariant(def),\n     FoundConst,\n@@ -425,6 +465,12 @@ enum Privacy {\n     Public\n }\n \n+impl Privacy : cmp::Eq {\n+    pure fn eq(&&other: Privacy) -> bool {\n+        (self as uint) == (other as uint)\n+    }\n+}\n+\n // Records a possibly-private definition.\n struct Definition {\n     privacy: Privacy;\n@@ -456,7 +502,7 @@ struct NameBindings {\n     /// Creates a new module in this set of name bindings.\n     fn define_module(parent_link: ParentLink, def_id: Option<def_id>,\n                      sp: span) {\n-        if self.module_def == NoModuleDef {\n+        if self.module_def.is_none() {\n             let module_ = @Module(parent_link, def_id);\n             self.module_def = ModuleDef(module_);\n             self.module_span = Some(sp);\n@@ -1778,13 +1824,13 @@ struct Resolver {\n                         // therefore accurately report that the names are\n                         // unbound.\n \n-                        if module_result == UnknownResult {\n+                        if module_result.is_unknown() {\n                             module_result = UnboundResult;\n                         }\n-                        if value_result == UnknownResult {\n+                        if value_result.is_unknown() {\n                             value_result = UnboundResult;\n                         }\n-                        if type_result == UnknownResult {\n+                        if type_result.is_unknown() {\n                             type_result = UnboundResult;\n                         }\n                     }\n@@ -1812,15 +1858,15 @@ struct Resolver {\n                         // The name is an import which has been fully\n                         // resolved. We can, therefore, just follow it.\n \n-                        if module_result == UnknownResult {\n+                        if module_result.is_unknown() {\n                             module_result = get_binding(import_resolution,\n                                                         ModuleNS);\n                         }\n-                        if value_result == UnknownResult {\n+                        if value_result.is_unknown() {\n                             value_result = get_binding(import_resolution,\n                                                        ValueNS);\n                         }\n-                        if type_result == UnknownResult {\n+                        if type_result.is_unknown() {\n                             type_result = get_binding(import_resolution,\n                                                       TypeNS);\n                         }\n@@ -4295,6 +4341,14 @@ struct Resolver {\n                 self.add_fixed_trait_for_expr(expr.id,\n                                               self.lang_items.shr_trait);\n             }\n+            expr_binary(lt, _, _) => {\n+                self.add_fixed_trait_for_expr(expr.id,\n+                                              self.lang_items.ord_trait);\n+            }\n+            expr_binary(eq, _, _) => {\n+                self.add_fixed_trait_for_expr(expr.id,\n+                                              self.lang_items.eq_trait);\n+            }\n             expr_unary(neg, _) => {\n                 self.add_fixed_trait_for_expr(expr.id,\n                                               self.lang_items.neg_trait);"}, {"sha": "e1a6d79c8a625cd95d692087a67aa00f857388c6", "filename": "src/rustc/middle/trans/alt.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/96534365c228d9c3962036967a7f1a1b17639e33/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96534365c228d9c3962036967a7f1a1b17639e33/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs?ref=96534365c228d9c3962036967a7f1a1b17639e33", "patch": "@@ -443,6 +443,14 @@ fn pick_col(m: match_) -> uint {\n     return best_col;\n }\n \n+enum branch_kind { no_branch, single, switch, compare, }\n+\n+impl branch_kind : cmp::Eq {\n+    pure fn eq(&&other: branch_kind) -> bool {\n+        (self as uint) == (other as uint)\n+    }\n+}\n+\n fn compile_submatch(bcx: block, m: match_, vals: ~[ValueRef],\n                     chk: Option<mk_fail>, &exits: ~[exit_node]) {\n     /*\n@@ -612,7 +620,6 @@ fn compile_submatch(bcx: block, m: match_, vals: ~[ValueRef],\n \n     // Decide what kind of branch we need\n     let opts = get_options(ccx, m, col);\n-    enum branch_kind { no_branch, single, switch, compare, }\n     let mut kind = no_branch;\n     let mut test_val = val;\n     if opts.len() > 0u {"}, {"sha": "33fdc89d31fb034f9f13cc782e8e9d8cd8411aa7", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 63, "deletions": 2, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/96534365c228d9c3962036967a7f1a1b17639e33/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96534365c228d9c3962036967a7f1a1b17639e33/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=96534365c228d9c3962036967a7f1a1b17639e33", "patch": "@@ -65,6 +65,19 @@ enum dest {\n     ignore,\n }\n \n+impl dest : cmp::Eq {\n+    pure fn eq(&&other: dest) -> bool {\n+        match (self, other) {\n+            (by_val(e0a), by_val(e0b)) => e0a == e0b,\n+            (save_in(e0a), save_in(e0b)) => e0a == e0b,\n+            (ignore, ignore) => true,\n+            (by_val(*), _) => false,\n+            (save_in(*), _) => false,\n+            (ignore, _) => false,\n+        }\n+    }\n+}\n+\n fn dest_str(ccx: @crate_ctxt, d: dest) -> ~str {\n     match d {\n       by_val(v) => fmt!(\"by_val(%s)\", val_str(ccx.tn, *v)),\n@@ -1448,6 +1461,17 @@ fn memmove_ty(bcx: block, dst: ValueRef, src: ValueRef, t: ty::t) {\n \n enum copy_action { INIT, DROP_EXISTING, }\n \n+impl copy_action : cmp::Eq {\n+    pure fn eq(&&other: copy_action) -> bool {\n+        match (self, other) {\n+            (INIT, INIT) => true,\n+            (DROP_EXISTING, DROP_EXISTING) => true,\n+            (INIT, _) => false,\n+            (DROP_EXISTING, _) => false,\n+        }\n+    }\n+}\n+\n // These are the types that are passed by pointer.\n fn type_is_structural_or_param(t: ty::t) -> bool {\n     if ty::type_is_structural(t) { return true; }\n@@ -2058,6 +2082,20 @@ enum lval_kind {\n     lv_owned,     //< Non-temporary value passed by pointer\n     lv_owned_imm, //< Non-temporary value passed by value\n }\n+\n+impl lval_kind : cmp::Eq {\n+    pure fn eq(&&other: lval_kind) -> bool {\n+        match (self, other) {\n+            (lv_temporary, lv_temporary) => true,\n+            (lv_owned, lv_owned) => true,\n+            (lv_owned_imm, lv_owned_imm) => true,\n+            (lv_temporary, _) => false,\n+            (lv_owned, _) => false,\n+            (lv_owned_imm, _) => false,\n+        }\n+    }\n+}\n+\n type local_var_result = {val: ValueRef, kind: lval_kind};\n type lval_result = {bcx: block, val: ValueRef, kind: lval_kind};\n enum callee_env {\n@@ -2879,8 +2917,31 @@ fn float_cast(bcx: block, lldsttype: TypeRef, llsrctype: TypeRef,\n     } else { llsrc };\n }\n \n-enum cast_kind { cast_pointer, cast_integral, cast_float,\n-                cast_enum, cast_other, }\n+enum cast_kind {\n+    cast_pointer,\n+    cast_integral,\n+    cast_float,\n+    cast_enum,\n+    cast_other,\n+}\n+\n+impl cast_kind : cmp::Eq {\n+    pure fn eq(&&other: cast_kind) -> bool {\n+        match (self, other) {\n+            (cast_pointer, cast_pointer) => true,\n+            (cast_integral, cast_integral) => true,\n+            (cast_float, cast_float) => true,\n+            (cast_enum, cast_enum) => true,\n+            (cast_other, cast_other) => true,\n+            (cast_pointer, _) => false,\n+            (cast_integral, _) => false,\n+            (cast_float, _) => false,\n+            (cast_enum, _) => false,\n+            (cast_other, _) => false,\n+        }\n+    }\n+}\n+\n fn cast_type_kind(t: ty::t) -> cast_kind {\n     match ty::get(t).struct {\n       ty::ty_float(*)   => cast_float,"}, {"sha": "42527357c159088fe8ca8a300de8388e2f4c18f9", "filename": "src/rustc/middle/trans/common.rs", "status": "modified", "additions": 47, "deletions": 1, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/96534365c228d9c3962036967a7f1a1b17639e33/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96534365c228d9c3962036967a7f1a1b17639e33/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=96534365c228d9c3962036967a7f1a1b17639e33", "patch": "@@ -996,7 +996,34 @@ enum mono_param_id {\n     mono_any,\n     mono_repr(uint /* size */, uint /* align */),\n }\n-type mono_id = @{def: ast::def_id, params: ~[mono_param_id]};\n+\n+type mono_id_ = {def: ast::def_id, params: ~[mono_param_id]};\n+\n+type mono_id = @mono_id_;\n+\n+impl mono_param_id: cmp::Eq {\n+    pure fn eq(&&other: mono_param_id) -> bool {\n+        match (self, other) {\n+            (mono_precise(ty_a, ids_a), mono_precise(ty_b, ids_b)) => {\n+                ty_a == ty_b && ids_a == ids_b\n+            }\n+            (mono_any, mono_any) => true,\n+            (mono_repr(size_a, align_a), mono_repr(size_b, align_b)) => {\n+                size_a == size_b && align_a == align_b\n+            }\n+            (mono_precise(*), _) => false,\n+            (mono_any, _) => false,\n+            (mono_repr(*), _) => false\n+        }\n+    }\n+}\n+\n+impl mono_id_: cmp::Eq {\n+    pure fn eq(&&other: mono_id_) -> bool {\n+        return self.def == other.def && self.params == other.params;\n+    }\n+}\n+\n pure fn hash_mono_id(mi: &mono_id) -> uint {\n     let mut h = syntax::ast_util::hash_def(&mi.def);\n     for vec::each(mi.params) |param| {\n@@ -1084,6 +1111,25 @@ fn dummy_substs(tps: ~[ty::t]) -> ty::substs {\n      tps: tps}\n }\n \n+impl cleantype : cmp::Eq {\n+    pure fn eq(&&other: cleantype) -> bool {\n+        match self {\n+            normal_exit_only => {\n+                match other {\n+                    normal_exit_only => true,\n+                    _ => false\n+                }\n+            }\n+            normal_exit_and_unwind => {\n+                match other {\n+                    normal_exit_and_unwind => true,\n+                    _ => false\n+                }\n+            }\n+        }\n+    }\n+}\n+\n //\n // Local Variables:\n // mode: rust"}, {"sha": "45dd30b4e1855935e5883bc8bdf250ac773214e3", "filename": "src/rustc/middle/trans/foreign.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/96534365c228d9c3962036967a7f1a1b17639e33/src%2Frustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96534365c228d9c3962036967a7f1a1b17639e33/src%2Frustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=96534365c228d9c3962036967a7f1a1b17639e33", "patch": "@@ -37,6 +37,12 @@ enum x86_64_reg_class {\n     memory_class\n }\n \n+impl x86_64_reg_class: cmp::Eq {\n+    pure fn eq(&&other: x86_64_reg_class) -> bool {\n+        (self as uint) == (other as uint)\n+    }\n+}\n+\n fn is_sse(++c: x86_64_reg_class) -> bool {\n     return match c {\n         sse_fs_class | sse_fv_class |"}, {"sha": "e15c9547e072ec7b2dec41c99c649347e45a3501", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 420, "deletions": 3, "changes": 423, "blob_url": "https://github.com/rust-lang/rust/blob/96534365c228d9c3962036967a7f1a1b17639e33/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96534365c228d9c3962036967a7f1a1b17639e33/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=96534365c228d9c3962036967a7f1a1b17639e33", "patch": "@@ -227,6 +227,12 @@ type creader_cache = hashmap<{cnum: int, pos: uint, len: uint}, t>;\n \n type intern_key = {struct: sty, o_def_id: Option<ast::def_id>};\n \n+impl intern_key: cmp::Eq {\n+    pure fn eq(&&other: intern_key) -> bool {\n+        self.struct == other.struct && self.o_def_id == other.o_def_id\n+    }\n+}\n+\n enum ast_ty_to_ty_cache_entry {\n     atttce_unresolved,  /* not resolved yet */\n     atttce_resolved(t)  /* resolved to a type, irrespective of region */\n@@ -238,6 +244,19 @@ type opt_region_variance = Option<region_variance>;\n #[auto_serialize]\n enum region_variance { rv_covariant, rv_invariant, rv_contravariant }\n \n+impl region_variance: cmp::Eq {\n+    pure fn eq(&&other: region_variance) -> bool {\n+        match (self, other) {\n+            (rv_covariant, rv_covariant) => true,\n+            (rv_invariant, rv_invariant) => true,\n+            (rv_contravariant, rv_contravariant) => true,\n+            (rv_covariant, _) => false,\n+            (rv_invariant, _) => false,\n+            (rv_contravariant, _) => false\n+        }\n+    }\n+}\n+\n // N.B.: Borrows from inlined content are not accurately deserialized.  This\n // is because we don't need the details in trans, we only care if there is an\n // entry in the table or not.\n@@ -246,6 +265,12 @@ type borrow = {\n     mutbl: ast::mutability\n };\n \n+impl borrow : cmp::Eq {\n+    pure fn eq(&&other: borrow) -> bool {\n+        self.region == other.region && self.mutbl == other.mutbl\n+    }\n+}\n+\n type ctxt =\n     @{diag: syntax::diagnostic::span_handler,\n       interner: hashmap<intern_key, t_box>,\n@@ -335,11 +360,36 @@ enum closure_kind {\n     ck_uniq,\n }\n \n+impl closure_kind : cmp::Eq {\n+    pure fn eq(&&other: closure_kind) -> bool {\n+        (self as uint) == (other as uint)\n+    }\n+}\n+\n enum fn_proto {\n     proto_bare,             // supertype of all other protocols\n     proto_vstore(vstore)\n }\n \n+impl fn_proto : cmp::Eq {\n+    pure fn eq(&&other: fn_proto) -> bool {\n+        match self {\n+            proto_bare => {\n+                match other {\n+                    proto_bare => true,\n+                    _ => false\n+                }\n+            }\n+            proto_vstore(e0a) => {\n+                match other {\n+                    proto_vstore(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+        }\n+    }\n+}\n+\n /// Innards of a function type:\n ///\n /// - `purity` is the function's effect (pure, impure, unsafe).\n@@ -357,6 +407,12 @@ type fn_ty = {purity: ast::purity,\n \n type param_ty = {idx: uint, def_id: def_id};\n \n+impl param_ty: cmp::Eq {\n+    pure fn eq(&&other: param_ty) -> bool {\n+        self.idx == other.idx && self.def_id == other.def_id\n+    }\n+}\n+\n /// Representation of regions:\n enum region {\n     /// Bound regions are found (primarily) in function types.  They indicate\n@@ -3272,12 +3328,12 @@ fn is_binopable(_cx: ctxt, ty: t, op: ast::binop) -> bool {\n     /*.          add,     shift,   bit\n       .             sub,     rel,     logic\n       .                mult,    eq,         */\n-    /*other*/   ~[f, f, f, f, t, t, f, f],\n+    /*other*/   ~[f, f, f, f, f, f, f, f],\n     /*bool*/    ~[f, f, f, f, t, t, t, t],\n     /*int*/     ~[t, t, t, t, t, t, t, f],\n     /*float*/   ~[t, t, t, f, t, t, f, f],\n-    /*bot*/     ~[f, f, f, f, t, t, f, f],\n-    /*struct*/  ~[t, t, t, t, t, t, t, t]];\n+    /*bot*/     ~[f, f, f, f, f, f, f, f],\n+    /*struct*/  ~[t, t, t, t, f, f, t, t]];\n \n     return tbl[tycat(ty)][opcat(op)];\n }\n@@ -3416,6 +3472,367 @@ pure fn determine_inherited_purity(parent_purity: ast::purity,\n     } else { child_purity }\n }\n \n+impl mt : cmp::Eq {\n+    pure fn eq(&&other: mt) -> bool {\n+        self.ty == other.ty && self.mutbl == other.mutbl\n+    }\n+}\n+\n+impl arg : cmp::Eq {\n+    pure fn eq(&&other: arg) -> bool {\n+        self.mode == other.mode && self.ty == other.ty\n+    }\n+}\n+\n+impl field : cmp::Eq {\n+    pure fn eq(&&other: field) -> bool {\n+        self.ident == other.ident && self.mt == other.mt\n+    }\n+}\n+\n+impl vstore : cmp::Eq {\n+    pure fn eq(&&other: vstore) -> bool {\n+        match self {\n+            vstore_fixed(e0a) => {\n+                match other {\n+                    vstore_fixed(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            vstore_uniq => {\n+                match other {\n+                    vstore_uniq => true,\n+                    _ => false\n+                }\n+            }\n+            vstore_box => {\n+                match other {\n+                    vstore_box => true,\n+                    _ => false\n+                }\n+            }\n+            vstore_slice(e0a) => {\n+                match other {\n+                    vstore_slice(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+impl fn_ty : cmp::Eq {\n+    pure fn eq(&&other: fn_ty) -> bool {\n+        self.purity == other.purity &&\n+        self.proto == other.proto &&\n+        self.bounds == other.bounds &&\n+        self.inputs == other.inputs &&\n+        self.output == other.output &&\n+        self.ret_style == other.ret_style\n+    }\n+}\n+\n+impl tv_vid: cmp::Eq {\n+    pure fn eq(&&other: tv_vid) -> bool {\n+        *self == *other\n+    }\n+}\n+\n+impl tvi_vid: cmp::Eq {\n+    pure fn eq(&&other: tvi_vid) -> bool {\n+        *self == *other\n+    }\n+}\n+\n+impl region_vid: cmp::Eq {\n+    pure fn eq(&&other: region_vid) -> bool {\n+        *self == *other\n+    }\n+}\n+\n+impl region : cmp::Eq {\n+    pure fn eq(&&other: region) -> bool {\n+        match self {\n+            re_bound(e0a) => {\n+                match other {\n+                    re_bound(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            re_free(e0a, e1a) => {\n+                match other {\n+                    re_free(e0b, e1b) => e0a == e0b && e1a == e1b,\n+                    _ => false\n+                }\n+            }\n+            re_scope(e0a) => {\n+                match other {\n+                    re_scope(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            re_static => {\n+                match other {\n+                    re_static => true,\n+                    _ => false\n+                }\n+            }\n+            re_var(e0a) => {\n+                match other {\n+                    re_var(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+impl bound_region : cmp::Eq {\n+    pure fn eq(&&other: bound_region) -> bool {\n+        match self {\n+            br_self => {\n+                match other {\n+                    br_self => true,\n+                    _ => false\n+                }\n+            }\n+            br_anon(e0a) => {\n+                match other {\n+                    br_anon(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            br_named(e0a) => {\n+                match other {\n+                    br_named(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            br_cap_avoid(e0a, e1a) => {\n+                match other {\n+                    br_cap_avoid(e0b, e1b) => e0a == e0b && e1a == e1b,\n+                    _ => false\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+impl substs : cmp::Eq {\n+    pure fn eq(&&other: substs) -> bool {\n+        self.self_r == other.self_r &&\n+        self.self_ty == other.self_ty &&\n+        self.tps == other.tps\n+    }\n+}\n+\n+impl sty : cmp::Eq {\n+    pure fn eq(&&other: sty) -> bool {\n+        match self {\n+            ty_nil => {\n+                match other {\n+                    ty_nil => true,\n+                    _ => false\n+                }\n+            }\n+            ty_bot => {\n+                match other {\n+                    ty_bot => true,\n+                    _ => false\n+                }\n+            }\n+            ty_bool => {\n+                match other {\n+                    ty_bool => true,\n+                    _ => false\n+                }\n+            }\n+            ty_int(e0a) => {\n+                match other {\n+                    ty_int(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            ty_uint(e0a) => {\n+                match other {\n+                    ty_uint(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            ty_float(e0a) => {\n+                match other {\n+                    ty_float(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            ty_estr(e0a) => {\n+                match other {\n+                    ty_estr(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            ty_enum(e0a, e1a) => {\n+                match other {\n+                    ty_enum(e0b, e1b) => e0a == e0b && e1a == e1b,\n+                    _ => false\n+                }\n+            }\n+            ty_box(e0a) => {\n+                match other {\n+                    ty_box(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            ty_uniq(e0a) => {\n+                match other {\n+                    ty_uniq(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            ty_evec(e0a, e1a) => {\n+                match other {\n+                    ty_evec(e0b, e1b) => e0a == e0b && e1a == e1b,\n+                    _ => false\n+                }\n+            }\n+            ty_ptr(e0a) => {\n+                match other {\n+                    ty_ptr(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            ty_rptr(e0a, e1a) => {\n+                match other {\n+                    ty_rptr(e0b, e1b) => e0a == e0b && e1a == e1b,\n+                    _ => false\n+                }\n+            }\n+            ty_rec(e0a) => {\n+                match other {\n+                    ty_rec(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            ty_fn(e0a) => {\n+                match other {\n+                    ty_fn(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            ty_trait(e0a, e1a, e2a) => {\n+                match other {\n+                    ty_trait(e0b, e1b, e2b) =>\n+                        e0a == e0b && e1a == e1b && e2a == e2b,\n+                    _ => false\n+                }\n+            }\n+            ty_class(e0a, e1a) => {\n+                match other {\n+                    ty_class(e0b, e1b) => e0a == e0b && e1a == e1b,\n+                    _ => false\n+                }\n+            }\n+            ty_tup(e0a) => {\n+                match other {\n+                    ty_tup(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            ty_var(e0a) => {\n+                match other {\n+                    ty_var(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            ty_var_integral(e0a) => {\n+                match other {\n+                    ty_var_integral(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            ty_param(e0a) => {\n+                match other {\n+                    ty_param(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            ty_self => {\n+                match other {\n+                    ty_self => true,\n+                    _ => false\n+                }\n+            }\n+            ty_type => {\n+                match other {\n+                    ty_type => true,\n+                    _ => false\n+                }\n+            }\n+            ty_opaque_box => {\n+                match other {\n+                    ty_opaque_box => true,\n+                    _ => false\n+                }\n+            }\n+            ty_opaque_closure_ptr(e0a) => {\n+                match other {\n+                    ty_opaque_closure_ptr(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            ty_unboxed_vec(e0a) => {\n+                match other {\n+                    ty_unboxed_vec(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+impl param_bound : cmp::Eq {\n+    pure fn eq(&&other: param_bound) -> bool {\n+        match self {\n+            bound_copy => {\n+                match other {\n+                    bound_copy => true,\n+                    _ => false\n+                }\n+            }\n+            bound_owned => {\n+                match other {\n+                    bound_owned => true,\n+                    _ => false\n+                }\n+            }\n+            bound_send => {\n+                match other {\n+                    bound_send => true,\n+                    _ => false\n+                }\n+            }\n+            bound_const => {\n+                match other {\n+                    bound_const => true,\n+                    _ => false\n+                }\n+            }\n+            bound_trait(e0a) => {\n+                match other {\n+                    bound_trait(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+impl kind : cmp::Eq {\n+    pure fn eq(&&other: kind) -> bool {\n+        *self == *other\n+    }\n+}\n+\n \n // Local Variables:\n // mode: rust"}, {"sha": "57a539043370f8bb44e32fee5dd162acb3bddf19", "filename": "src/rustc/middle/typeck/check.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/96534365c228d9c3962036967a7f1a1b17639e33/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96534365c228d9c3962036967a7f1a1b17639e33/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs?ref=96534365c228d9c3962036967a7f1a1b17639e33", "patch": "@@ -1102,6 +1102,15 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         let tcx = fcx.ccx.tcx;\n         let lhs_bot = check_expr(fcx, lhs, None);\n         let lhs_t = fcx.expr_ty(lhs);\n+\n+        // Hack: Unify the two sides if this is a relational operator.\n+        match op {\n+            ast::eq | ast::lt | ast::le | ast::ne | ast::ge | ast::gt => {\n+                check_expr_with(fcx, rhs, lhs_t);\n+            }\n+            _ => {}\n+        }\n+\n         let lhs_t = structurally_resolved_type(fcx, lhs.span, lhs_t);\n         return match (op, ty::get(lhs_t).struct) {\n           (_, _) if ty::type_is_integral(lhs_t) &&\n@@ -1118,19 +1127,12 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n             let tvar = fcx.infcx().next_ty_var();\n             demand::suptype(fcx, expr.span, tvar, lhs_t);\n             let rhs_bot = check_expr_with(fcx, rhs, tvar);\n-            let rhs_t = match op {\n+            let result_t = match op {\n               ast::eq | ast::lt | ast::le | ast::ne | ast::ge |\n-              ast::gt => {\n-                // these comparison operators are handled in a\n-                // separate case below.\n-                tcx.sess.span_bug(\n-                    expr.span,\n-                    fmt!(\"comparison operator in expr_binop: %s\",\n-                         ast_util::binop_to_str(op)));\n-              }\n+              ast::gt => ty::mk_bool(fcx.ccx.tcx),\n               _ => lhs_t\n             };\n-            fcx.write_ty(expr.id, rhs_t);\n+            fcx.write_ty(expr.id, result_t);\n             if !ast_util::lazy_binop(op) { lhs_bot | rhs_bot }\n             else { lhs_bot }\n           }\n@@ -1424,9 +1426,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n       // complicated trait requirements, fail without this---I think this code\n       // can be removed if we improve trait resolution to be more eager when\n       // possible.\n-      ast::expr_binary(ast::eq, lhs, rhs) |\n       ast::expr_binary(ast::ne, lhs, rhs) |\n-      ast::expr_binary(ast::lt, lhs, rhs) |\n       ast::expr_binary(ast::le, lhs, rhs) |\n       ast::expr_binary(ast::gt, lhs, rhs) |\n       ast::expr_binary(ast::ge, lhs, rhs) => {"}, {"sha": "ac3b04284b33f7c657c8c9db6b42ee1c4afc6cbb", "filename": "src/rustc/middle/typeck/infer.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/96534365c228d9c3962036967a7f1a1b17639e33/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96534365c228d9c3962036967a7f1a1b17639e33/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs?ref=96534365c228d9c3962036967a7f1a1b17639e33", "patch": "@@ -265,6 +265,7 @@ import ast::{m_const, m_imm, m_mutbl};\n import dvec::DVec;\n import region_var_bindings::{RegionVarBindings};\n import ast_util::dummy_sp;\n+import cmp::Eq;\n \n // From submodules:\n import resolve::{resolve_nested_tvar, resolve_rvar, resolve_ivar, resolve_all,\n@@ -473,7 +474,7 @@ trait cres_helpers<T> {\n     fn compare(t: T, f: fn() -> ty::type_err) -> cres<T>;\n }\n \n-impl<T:copy> cres<T>: cres_helpers<T> {\n+impl<T:copy Eq> cres<T>: cres_helpers<T> {\n     fn to_ures() -> ures {\n         match self {\n           Ok(_v) => Ok(()),"}, {"sha": "cd4fde69ce9a41311f11d7a819406e944d73acdb", "filename": "src/rustc/middle/typeck/infer/region_var_bindings.rs", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/96534365c228d9c3962036967a7f1a1b17639e33/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_var_bindings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96534365c228d9c3962036967a7f1a1b17639e33/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_var_bindings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_var_bindings.rs?ref=96534365c228d9c3962036967a7f1a1b17639e33", "patch": "@@ -329,11 +329,36 @@ enum Constraint {\n     ConstrainVarSubReg(region_vid, region)\n }\n \n+impl Constraint: cmp::Eq {\n+    pure fn eq(&&other: Constraint) -> bool {\n+        match (self, other) {\n+            (ConstrainVarSubVar(v0a, v1a), ConstrainVarSubVar(v0b, v1b)) => {\n+                v0a == v0b && v1a == v1b\n+            }\n+            (ConstrainRegSubVar(ra, va), ConstrainRegSubVar(rb, vb)) => {\n+                ra == rb && va == vb\n+            }\n+            (ConstrainVarSubReg(va, ra), ConstrainVarSubReg(vb, rb)) => {\n+                va == vb && ra == rb\n+            }\n+            (ConstrainVarSubVar(*), _) => false,\n+            (ConstrainRegSubVar(*), _) => false,\n+            (ConstrainVarSubReg(*), _) => false\n+        }\n+    }\n+}\n+\n struct TwoRegions {\n     a: region;\n     b: region;\n }\n \n+impl TwoRegions: cmp::Eq {\n+    pure fn eq(&&other: TwoRegions) -> bool {\n+        self.a == other.a && self.b == other.b\n+    }\n+}\n+\n enum UndoLogEntry {\n     Snapshot,\n     AddVar(region_vid),\n@@ -724,8 +749,20 @@ priv impl RegionVarBindings {\n \n enum Direction { Incoming = 0, Outgoing = 1 }\n \n+impl Direction : cmp::Eq {\n+    pure fn eq(&&other: Direction) -> bool {\n+        (self as uint) == (other as uint)\n+    }\n+}\n+\n enum Classification { Expanding, Contracting }\n \n+impl Classification : cmp::Eq {\n+    pure fn eq(&&other: Classification) -> bool {\n+        (self as uint) == (other as uint)\n+    }\n+}\n+\n enum GraphNodeValue { NoValue, Value(region), ErrorValue }\n \n struct GraphNode {"}, {"sha": "165077e816082c9ac92f3892fa34b3ee85a7fca6", "filename": "src/rustdoc/config.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/96534365c228d9c3962036967a7f1a1b17639e33/src%2Frustdoc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96534365c228d9c3962036967a7f1a1b17639e33/src%2Frustdoc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fconfig.rs?ref=96534365c228d9c3962036967a7f1a1b17639e33", "patch": "@@ -18,6 +18,12 @@ enum output_format {\n     pandoc_html\n }\n \n+impl output_format : cmp::Eq {\n+    pure fn eq(&&other: output_format) -> bool {\n+        (self as uint) == (other as uint)\n+    }\n+}\n+\n /// How to organize the output\n enum output_style {\n     /// All in a single document\n@@ -26,6 +32,12 @@ enum output_style {\n     doc_per_mod\n }\n \n+impl output_style : cmp::Eq {\n+    pure fn eq(&&other: output_style) -> bool {\n+        (self as uint) == (other as uint)\n+    }\n+}\n+\n /// The configuration for a rustdoc session\n type config = {\n     input_crate: Path,"}, {"sha": "68d7ba045e82975a71495b88144849ea40635eae", "filename": "src/rustdoc/doc.rs", "status": "modified", "additions": 200, "deletions": 0, "changes": 200, "blob_url": "https://github.com/rust-lang/rust/blob/96534365c228d9c3962036967a7f1a1b17639e33/src%2Frustdoc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96534365c228d9c3962036967a7f1a1b17639e33/src%2Frustdoc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fdoc.rs?ref=96534365c228d9c3962036967a7f1a1b17639e33", "patch": "@@ -6,20 +6,58 @@ type doc_ = {\n     pages: ~[page]\n };\n \n+impl doc_ : cmp::Eq {\n+    pure fn eq(&&other: doc_) -> bool {\n+        self.pages == other.pages\n+    }\n+}\n+\n enum doc {\n     doc_(doc_)\n }\n \n+impl doc : cmp::Eq {\n+    pure fn eq(&&other: doc) -> bool {\n+        *self == *other\n+    }\n+}\n+\n enum page {\n     cratepage(cratedoc),\n     itempage(itemtag)\n }\n \n+impl page : cmp::Eq {\n+    pure fn eq(&&other: page) -> bool {\n+        match self {\n+            cratepage(e0a) => {\n+                match other {\n+                    cratepage(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            itempage(e0a) => {\n+                match other {\n+                    itempage(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+        }\n+    }\n+}\n+\n enum implementation {\n     required,\n     provided,\n }\n \n+impl implementation : cmp::Eq {\n+    pure fn eq(&&other: implementation) -> bool {\n+        (self as uint) == (other as uint)\n+    }\n+}\n+\n+\n /**\n  * Most rustdocs can be parsed into 'sections' according to their markdown\n  * headers\n@@ -29,13 +67,25 @@ type section = {\n     body: ~str\n };\n \n+impl section : cmp::Eq {\n+    pure fn eq(&&other: section) -> bool {\n+        self.header == other.header && self.body == other.body\n+    }\n+}\n+\n // FIXME (#2596): We currently give topmod the name of the crate.  There\n // would probably be fewer special cases if the crate had its own name\n // and topmod's name was the empty string.\n type cratedoc = {\n     topmod: moddoc,\n };\n \n+impl cratedoc : cmp::Eq {\n+    pure fn eq(&&other: cratedoc) -> bool {\n+        self.topmod == other.topmod\n+    }\n+}\n+\n enum itemtag {\n     modtag(moddoc),\n     nmodtag(nmoddoc),\n@@ -47,6 +97,61 @@ enum itemtag {\n     tytag(tydoc)\n }\n \n+impl itemtag : cmp::Eq {\n+    pure fn eq(&&other: itemtag) -> bool {\n+        match self {\n+            modtag(e0a) => {\n+                match other {\n+                    modtag(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            nmodtag(e0a) => {\n+                match other {\n+                    nmodtag(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            consttag(e0a) => {\n+                match other {\n+                    consttag(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            fntag(e0a) => {\n+                match other {\n+                    fntag(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            enumtag(e0a) => {\n+                match other {\n+                    enumtag(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            traittag(e0a) => {\n+                match other {\n+                    traittag(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            impltag(e0a) => {\n+                match other {\n+                    impltag(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            tytag(e0a) => {\n+                match other {\n+                    tytag(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+        }\n+    }\n+}\n+\n type itemdoc = {\n     id: ast_id,\n     name: ~str,\n@@ -58,27 +163,67 @@ type itemdoc = {\n     reexport: bool\n };\n \n+impl itemdoc : cmp::Eq {\n+    pure fn eq(&&other: itemdoc) -> bool {\n+        self.id == other.id &&\n+        self.name == other.name &&\n+        self.path == other.path &&\n+        self.brief == other.brief &&\n+        self.desc == other.desc &&\n+        self.sections == other.sections &&\n+        self.reexport == other.reexport\n+    }\n+}\n+\n type simpleitemdoc = {\n     item: itemdoc,\n     sig: Option<~str>\n };\n \n+impl simpleitemdoc : cmp::Eq {\n+    pure fn eq(&&other: simpleitemdoc) -> bool {\n+        self.item == other.item && self.sig == other.sig\n+    }\n+}\n+\n type moddoc_ = {\n     item: itemdoc,\n     items: ~[itemtag],\n     index: Option<index>\n };\n \n+impl moddoc_ : cmp::Eq {\n+    pure fn eq(&&other: moddoc_) -> bool {\n+        self.item == other.item &&\n+        self.items == other.items &&\n+        self.index == other.index\n+    }\n+}\n+\n enum moddoc {\n     moddoc_(moddoc_)\n }\n \n+impl moddoc : cmp::Eq {\n+    pure fn eq(&&other: moddoc) -> bool {\n+        *self == *other\n+    }\n+}\n+\n type nmoddoc = {\n     item: itemdoc,\n     fns: ~[fndoc],\n     index: Option<index>\n };\n \n+impl nmoddoc : cmp::Eq {\n+    pure fn eq(&&other: nmoddoc) -> bool {\n+        self.item == other.item &&\n+        self.fns == other.fns &&\n+        self.index == other.index\n+    }\n+}\n+\n type constdoc = simpleitemdoc;\n \n type fndoc = simpleitemdoc;\n@@ -88,17 +233,37 @@ type enumdoc = {\n     variants: ~[variantdoc]\n };\n \n+impl enumdoc : cmp::Eq {\n+    pure fn eq(&&other: enumdoc) -> bool {\n+        self.item == other.item && self.variants == other.variants\n+    }\n+}\n+\n type variantdoc = {\n     name: ~str,\n     desc: Option<~str>,\n     sig: Option<~str>\n };\n \n+impl variantdoc : cmp::Eq {\n+    pure fn eq(&&other: variantdoc) -> bool {\n+        self.name == other.name &&\n+        self.desc == other.desc &&\n+        self.sig == other.sig\n+    }\n+}\n+\n type traitdoc = {\n     item: itemdoc,\n     methods: ~[methoddoc]\n };\n \n+impl traitdoc : cmp::Eq {\n+    pure fn eq(&&other: traitdoc) -> bool {\n+        self.item == other.item && self.methods == other.methods\n+    }\n+}\n+\n type methoddoc = {\n     name: ~str,\n     brief: Option<~str>,\n@@ -108,19 +273,45 @@ type methoddoc = {\n     implementation: implementation,\n };\n \n+impl methoddoc : cmp::Eq {\n+    pure fn eq(&&other: methoddoc) -> bool {\n+        self.name == other.name &&\n+        self.brief == other.brief &&\n+        self.desc == other.desc &&\n+        self.sections == other.sections &&\n+        self.sig == other.sig &&\n+        self.implementation == other.implementation\n+    }\n+}\n+\n type impldoc = {\n     item: itemdoc,\n     trait_types: ~[~str],\n     self_ty: Option<~str>,\n     methods: ~[methoddoc]\n };\n \n+impl impldoc : cmp::Eq {\n+    pure fn eq(&&other: impldoc) -> bool {\n+        self.item == other.item &&\n+        self.trait_types == other.trait_types &&\n+        self.self_ty == other.self_ty &&\n+        self.methods == other.methods\n+    }\n+}\n+\n type tydoc = simpleitemdoc;\n \n type index = {\n     entries: ~[index_entry]\n };\n \n+impl index : cmp::Eq {\n+    pure fn eq(&&other: index) -> bool {\n+        self.entries == other.entries\n+    }\n+}\n+\n /**\n  * A single entry in an index\n  *\n@@ -138,6 +329,15 @@ type index_entry = {\n     link: ~str\n };\n \n+impl index_entry : cmp::Eq {\n+    pure fn eq(&&other: index_entry) -> bool {\n+        self.kind == other.kind &&\n+        self.name == other.name &&\n+        self.brief == other.brief &&\n+        self.link == other.link\n+    }\n+}\n+\n impl doc {\n     fn cratedoc() -> cratedoc {\n         option::get(vec::foldl(None, self.pages, |_m, page| {"}, {"sha": "4e638bf064a28718089af79458cc7f12332fe69d", "filename": "src/test/compile-fail/fn-compare-mismatch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/96534365c228d9c3962036967a7f1a1b17639e33/src%2Ftest%2Fcompile-fail%2Ffn-compare-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96534365c228d9c3962036967a7f1a1b17639e33/src%2Ftest%2Fcompile-fail%2Ffn-compare-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffn-compare-mismatch.rs?ref=96534365c228d9c3962036967a7f1a1b17639e33", "patch": "@@ -2,5 +2,5 @@ fn main() {\n     fn f() { }\n     fn g(i: int) { }\n     let x = f == g;\n-    //~^ ERROR expected `fn()` but found `fn(int)`\n+    //~^ ERROR binary operation == cannot be applied to type\n }"}, {"sha": "c7e49c42b51c46639d748eb5bf7abe17f4d7024a", "filename": "src/test/compile-fail/issue-511.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/96534365c228d9c3962036967a7f1a1b17639e33/src%2Ftest%2Fcompile-fail%2Fissue-511.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96534365c228d9c3962036967a7f1a1b17639e33/src%2Ftest%2Fcompile-fail%2Fissue-511.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-511.rs?ref=96534365c228d9c3962036967a7f1a1b17639e33", "patch": "@@ -1,12 +1,13 @@\n use std;\n import option;\n+import cmp::Eq;\n \n-fn f<T>(&o: Option<T>) {\n+fn f<T:Eq>(&o: Option<T>) {\n     assert o == option::None;\n }\n \n fn main() {\n     f::<int>(option::None);\n     //~^ ERROR taking mut reference to static item\n     //~^^ ERROR illegal borrow: creating mutable alias to aliasable, immutable memory\n-}\n\\ No newline at end of file\n+}"}, {"sha": "feb657efe0c874537bf34e06bdee15dd18e698f5", "filename": "src/test/run-fail/binop-fail.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/96534365c228d9c3962036967a7f1a1b17639e33/src%2Ftest%2Frun-fail%2Fbinop-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96534365c228d9c3962036967a7f1a1b17639e33/src%2Ftest%2Frun-fail%2Fbinop-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fbinop-fail.rs?ref=96534365c228d9c3962036967a7f1a1b17639e33", "patch": "@@ -1,3 +1,3 @@\n // error-pattern:quux\n fn my_err(s: ~str) -> ! { log(error, s); fail ~\"quux\"; }\n-fn main() { my_err(~\"bye\") == 3u; }\n+fn main() { 3u == my_err(~\"bye\"); }"}, {"sha": "240dfa0a0acc7ed3a15ccf2847ba19b29825f8f0", "filename": "src/test/run-pass/auto_serialize.rs", "status": "modified", "additions": 36, "deletions": 5, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/96534365c228d9c3962036967a7f1a1b17639e33/src%2Ftest%2Frun-pass%2Fauto_serialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96534365c228d9c3962036967a7f1a1b17639e33/src%2Ftest%2Frun-pass%2Fauto_serialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauto_serialize.rs?ref=96534365c228d9c3962036967a7f1a1b17639e33", "patch": "@@ -3,15 +3,16 @@ use std;\n // These tests used to be separate files, but I wanted to refactor all\n // the common code.\n \n+import cmp::Eq;\n import std::ebml;\n import io::Writer;\n import std::serialization::{serialize_uint, deserialize_uint};\n \n-fn test_ser_and_deser<A>(a1: A,\n-                         expected: ~str,\n-                         ebml_ser_fn: fn(ebml::Writer, A),\n-                         ebml_deser_fn: fn(ebml::EbmlDeserializer) -> A,\n-                         io_ser_fn: fn(io::Writer, A)) {\n+fn test_ser_and_deser<A:Eq>(a1: A,\n+                            expected: ~str,\n+                            ebml_ser_fn: fn(ebml::Writer, A),\n+                            ebml_deser_fn: fn(ebml::EbmlDeserializer) -> A,\n+                            io_ser_fn: fn(io::Writer, A)) {\n \n     // check the pretty printer:\n     io_ser_fn(io::stdout(), a1);\n@@ -41,10 +42,40 @@ enum expr {\n     minus(@expr, @expr)\n }\n \n+impl expr : cmp::Eq {\n+    pure fn eq(&&other: expr) -> bool {\n+        match self {\n+            val(e0a) => {\n+                match other {\n+                    val(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            plus(e0a, e1a) => {\n+                match other {\n+                    plus(e0b, e1b) => e0a == e0b && e1a == e1b,\n+                    _ => false\n+                }\n+            }\n+            minus(e0a, e1a) => {\n+                match other {\n+                    minus(e0b, e1b) => e0a == e0b && e1a == e1b,\n+                    _ => false\n+                }\n+            }\n+        }\n+    }\n+}\n \n #[auto_serialize]\n type spanned<T> = {lo: uint, hi: uint, node: T};\n \n+impl<T:cmp::Eq> spanned<T> : cmp::Eq {\n+    pure fn eq(&&other: spanned<T>) -> bool {\n+        self.lo == other.lo && self.hi == other.hi && self.node.eq(other.node)\n+    }\n+}\n+\n #[auto_serialize]\n type spanned_uint = spanned<uint>;\n "}, {"sha": "c334d8dc526f16367b17dbc69be8eca49d6ea009", "filename": "src/test/run-pass/binops.rs", "status": "modified", "additions": 6, "deletions": 51, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/96534365c228d9c3962036967a7f1a1b17639e33/src%2Ftest%2Frun-pass%2Fbinops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96534365c228d9c3962036967a7f1a1b17639e33/src%2Ftest%2Frun-pass%2Fbinops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbinops.rs?ref=96534365c228d9c3962036967a7f1a1b17639e33", "patch": "@@ -55,26 +55,6 @@ fn test_char() {\n \n fn test_box() {\n     assert (@10 == @10);\n-    assert (@{a: 1, b: 3} < @{a: 1, b: 4});\n-    assert (@{a: 'x'} != @{a: 'y'});\n-}\n-\n-fn test_port() {\n-    let p1 = comm::Port::<int>();\n-    let p2 = comm::Port::<int>();\n-\n-    assert (p1 == p1);\n-    assert (p1 != p2);\n-}\n-\n-fn test_chan() {\n-    let p: comm::Port<int> = comm::Port();\n-    let ch1 = comm::Chan(p);\n-    let ch2 = comm::Chan(p);\n-\n-    assert (ch1 == ch1);\n-    // Chans are equal because they are just task:port addresses.\n-    assert (ch1 == ch2);\n }\n \n fn test_ptr() unsafe {\n@@ -92,45 +72,25 @@ fn test_ptr() unsafe {\n     assert p1 >= p2;\n }\n \n-fn test_fn() {\n-    fn f() { }\n-    fn g() { }\n-    fn h(_i: int) { }\n-    let f1 = f;\n-    let f2 = f;\n-    let g1 = g;\n-    let h1 = h;\n-    let h2 = h;\n-    assert (f1 == f2);\n-    assert (f1 == f);\n-\n-    assert (f1 != g1);\n-    assert (h1 == h2);\n-    assert (!(f1 != f2));\n-    assert (!(h1 < h2));\n-    assert (h1 <= h2);\n-    assert (!(h1 > h2));\n-    assert (h1 >= h2);\n-}\n-\n #[abi = \"cdecl\"]\n #[nolink]\n extern mod test {\n     fn rust_get_sched_id() -> libc::intptr_t;\n     fn get_task_id() -> libc::intptr_t;\n }\n \n-fn test_foreign_fn() {\n-    assert test::rust_get_sched_id != test::get_task_id;\n-    assert test::rust_get_sched_id == test::rust_get_sched_id;\n-}\n-\n struct p {\n   let mut x: int;\n   let mut y: int;\n   new(x: int, y: int) { self.x = x; self.y = y; }\n }\n \n+impl p : cmp::Eq {\n+    pure fn eq(&&other: p) -> bool {\n+        self.x == other.x && self.y == other.y\n+    }\n+}\n+\n fn test_class() {\n   let q = p(1, 2);\n   let r = p(1, 2);\n@@ -152,11 +112,6 @@ fn main() {\n     test_bool();\n     test_char();\n     test_box();\n-    // FIXME: test_port causes valgrind errors (#2724)\n-    //test_port();\n-    test_chan();\n     test_ptr();\n-    test_fn();\n-    test_foreign_fn();\n     test_class();\n }"}, {"sha": "e01c1ba1b0b69baf2f1921dd8c05ecb5b1ef2d9b", "filename": "src/test/run-pass/class-impl-very-parameterized-trait.rs", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/96534365c228d9c3962036967a7f1a1b17639e33/src%2Ftest%2Frun-pass%2Fclass-impl-very-parameterized-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96534365c228d9c3962036967a7f1a1b17639e33/src%2Ftest%2Frun-pass%2Fclass-impl-very-parameterized-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-impl-very-parameterized-trait.rs?ref=96534365c228d9c3962036967a7f1a1b17639e33", "patch": "@@ -3,6 +3,12 @@ import std::map::*;\n \n enum cat_type { tuxedo, tabby, tortoiseshell }\n \n+impl cat_type : cmp::Eq {\n+    pure fn eq(&&other: cat_type) -> bool {\n+        (self as uint) == (other as uint)\n+    }\n+}\n+\n // Very silly -- this just returns the value of the name field\n // for any int value that's less than the meows field\n \n@@ -40,7 +46,7 @@ struct cat<T: copy> : map<int, T> {\n     }\n   }\n \n-  fn size() -> uint { self.meows as uint }\n+  pure fn size() -> uint { self.meows as uint }\n   fn insert(+k: int, +_v: T) -> bool {\n     self.meows += k;\n     true\n@@ -53,7 +59,7 @@ struct cat<T: copy> : map<int, T> {\n       None    => { fail ~\"epic fail\"; }\n     }\n   }\n-  fn find(+k:int) -> Option<T> { if k <= self.meows {\n+  pure fn find(+k:int) -> Option<T> { if k <= self.meows {\n         Some(self.name)\n      }\n      else { None }\n@@ -68,24 +74,24 @@ struct cat<T: copy> : map<int, T> {\n     }\n   }\n \n-  fn each(f: fn(+int, +T) -> bool) {\n+  pure fn each(f: fn(+int, +T) -> bool) {\n     let mut n = int::abs(self.meows);\n     while n > 0 {\n         if !f(n, self.name) { break; }\n         n -= 1;\n     }\n   }\n \n-  fn each_key(&&f: fn(+int) -> bool) {\n+  pure fn each_key(&&f: fn(+int) -> bool) {\n     for self.each |k, _v| { if !f(k) { break; } again;};\n   }\n-  fn each_value(&&f: fn(+T) -> bool) {\n+  pure fn each_value(&&f: fn(+T) -> bool) {\n     for self.each |_k, v| { if !f(v) { break; } again;};\n   }\n \n-  fn each_ref(f: fn(k: &int, v: &T) -> bool) {}\n-  fn each_key_ref(f: fn(k: &int) -> bool) {}\n-  fn each_value_ref(f: fn(k: &T) -> bool) {}\n+  pure fn each_ref(f: fn(k: &int, v: &T) -> bool) {}\n+  pure fn each_key_ref(f: fn(k: &int) -> bool) {}\n+  pure fn each_value_ref(f: fn(k: &T) -> bool) {}\n \n   fn clear() { }\n }"}, {"sha": "a489ea3d1a8f26c0bcab2d7044474e3a4e3366a9", "filename": "src/test/run-pass/const-struct.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/96534365c228d9c3962036967a7f1a1b17639e33/src%2Ftest%2Frun-pass%2Fconst-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96534365c228d9c3962036967a7f1a1b17639e33/src%2Ftest%2Frun-pass%2Fconst-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-struct.rs?ref=96534365c228d9c3962036967a7f1a1b17639e33", "patch": "@@ -1,6 +1,12 @@\n \n struct foo { a: int; b: int; c: int; }\n \n+impl foo : cmp::Eq {\n+    pure fn eq(&&other: foo) -> bool {\n+        self.a == other.a && self.b == other.b && self.c == other.c\n+    }\n+}\n+\n const x : foo = foo { a:1, b:2, c: 3 };\n const y : foo = foo { b:2, c:3, a: 1 };\n const z : &foo = &foo { a: 10, b: 22, c: 12 };"}, {"sha": "faddbb742916f897bb05f4406daa89682a0fb245", "filename": "src/test/run-pass/crateresolve5.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/96534365c228d9c3962036967a7f1a1b17639e33/src%2Ftest%2Frun-pass%2Fcrateresolve5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96534365c228d9c3962036967a7f1a1b17639e33/src%2Ftest%2Frun-pass%2Fcrateresolve5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcrateresolve5.rs?ref=96534365c228d9c3962036967a7f1a1b17639e33", "patch": "@@ -7,7 +7,8 @@ use cr5_2 (name = \"crateresolve5\", vers = \"0.2\");\n \n fn main() {\n     // Structural types can be used between two versions of the same crate\n-    assert cr5_1::structural() == cr5_2::structural();\n+    assert cr5_1::structural().name == cr5_2::structural().name;\n+    assert cr5_1::structural().val == cr5_2::structural().val;\n     // Make sure these are actually two different crates\n     assert cr5_1::f() == 10 && cr5_2::f() == 20;\n }"}, {"sha": "b1a8ff9e175822b036a7148d370aa6e2470c6bc3", "filename": "src/test/run-pass/dvec-test.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/96534365c228d9c3962036967a7f1a1b17639e33/src%2Ftest%2Frun-pass%2Fdvec-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96534365c228d9c3962036967a7f1a1b17639e33/src%2Ftest%2Frun-pass%2Fdvec-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdvec-test.rs?ref=96534365c228d9c3962036967a7f1a1b17639e33", "patch": "@@ -23,5 +23,6 @@ fn main() {\n         assert e == exp[i];\n     }\n \n-    assert dvec::unwrap(move d) == exp;\n-}\n\\ No newline at end of file\n+    let v = vec::from_mut(dvec::unwrap(move d));\n+    assert v == exp;\n+}"}, {"sha": "cd60f9b7856e2bd8263b0c8ff4fc8a4a8cca605f", "filename": "src/test/run-pass/early-ret-binop.rs", "status": "removed", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94720fcea762338be3edfb29cbc8292e761f5585/src%2Ftest%2Frun-pass%2Fearly-ret-binop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94720fcea762338be3edfb29cbc8292e761f5585/src%2Ftest%2Frun-pass%2Fearly-ret-binop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fearly-ret-binop.rs?ref=94720fcea762338be3edfb29cbc8292e761f5585", "patch": "@@ -1,2 +0,0 @@\n-fn wsucc(n: int) -> int { ({ return n + 1 } == 0); }\n-fn main() { }"}, {"sha": "d375f0638db1e82c1503a6230cb9dd5309b58c87", "filename": "src/test/run-pass/empty-tag.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/96534365c228d9c3962036967a7f1a1b17639e33/src%2Ftest%2Frun-pass%2Fempty-tag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96534365c228d9c3962036967a7f1a1b17639e33/src%2Ftest%2Frun-pass%2Fempty-tag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fempty-tag.rs?ref=96534365c228d9c3962036967a7f1a1b17639e33", "patch": "@@ -1,5 +1,11 @@\n enum chan { chan_t, }\n \n+impl chan : cmp::Eq {\n+    pure fn eq(&&other: chan) -> bool {\n+        (self as uint) == (other as uint)\n+    }\n+}\n+\n fn wrapper3(i: chan) {\n     assert i == chan_t;\n }"}, {"sha": "22858fa464bdbdfd3042c8ec130aea260ddba5dd", "filename": "src/test/run-pass/export-unexported-dep.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/96534365c228d9c3962036967a7f1a1b17639e33/src%2Ftest%2Frun-pass%2Fexport-unexported-dep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96534365c228d9c3962036967a7f1a1b17639e33/src%2Ftest%2Frun-pass%2Fexport-unexported-dep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexport-unexported-dep.rs?ref=96534365c228d9c3962036967a7f1a1b17639e33", "patch": "@@ -8,6 +8,12 @@ mod foo {\n     // not exported\n     enum t { t1, t2, }\n \n+    impl t : cmp::Eq {\n+        pure fn eq(&&other: t) -> bool {\n+            (self as uint) == (other as uint)\n+        }\n+    }\n+\n     fn f() -> t { return t1; }\n \n     fn g(v: t) { assert (v == t1); }"}, {"sha": "63beeb0153ccb990bccfb18e41b7430b4c865390", "filename": "src/test/run-pass/expr-alt-generic.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/96534365c228d9c3962036967a7f1a1b17639e33/src%2Ftest%2Frun-pass%2Fexpr-alt-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96534365c228d9c3962036967a7f1a1b17639e33/src%2Ftest%2Frun-pass%2Fexpr-alt-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-alt-generic.rs?ref=96534365c228d9c3962036967a7f1a1b17639e33", "patch": "@@ -14,9 +14,14 @@ fn test_bool() {\n     test_generic::<bool>(true, compare_bool);\n }\n \n-fn test_rec() {\n-    type t = {a: int, b: int};\n+type t = {a: int, b: int};\n+impl t : cmp::Eq {\n+    pure fn eq(&&other: t) -> bool {\n+        self.a == other.a && self.b == other.b\n+    }\n+}\n \n+fn test_rec() {\n     fn compare_rec(t1: t, t2: t) -> bool { return t1 == t2; }\n     test_generic::<t>({a: 1, b: 2}, compare_rec);\n }"}, {"sha": "73b059eadf5f4537095086482c81d5796b2f75b0", "filename": "src/test/run-pass/expr-alt-struct.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/96534365c228d9c3962036967a7f1a1b17639e33/src%2Ftest%2Frun-pass%2Fexpr-alt-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96534365c228d9c3962036967a7f1a1b17639e33/src%2Ftest%2Frun-pass%2Fexpr-alt-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-alt-struct.rs?ref=96534365c228d9c3962036967a7f1a1b17639e33", "patch": "@@ -6,11 +6,17 @@\n // Tests for match as expressions resulting in structural types\n fn test_rec() {\n     let rs = match true { true => {i: 100}, _ => fail };\n-    assert (rs == {i: 100});\n+    assert (rs.i == 100);\n+}\n+\n+enum mood { happy, sad, }\n+impl mood : cmp::Eq {\n+    pure fn eq(&&other: mood) -> bool {\n+        (self as uint) == (other as uint)\n+    }\n }\n \n fn test_tag() {\n-    enum mood { happy, sad, }\n     let rs = match true { true => { happy } false => { sad } };\n     assert (rs == happy);\n }"}, {"sha": "a1677faa384791004896650bd96a75459306ab20", "filename": "src/test/run-pass/expr-block-generic.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/96534365c228d9c3962036967a7f1a1b17639e33/src%2Ftest%2Frun-pass%2Fexpr-block-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96534365c228d9c3962036967a7f1a1b17639e33/src%2Ftest%2Frun-pass%2Fexpr-block-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-block-generic.rs?ref=96534365c228d9c3962036967a7f1a1b17639e33", "patch": "@@ -16,9 +16,14 @@ fn test_bool() {\n     test_generic::<bool>(true, compare_bool);\n }\n \n-fn test_rec() {\n-    type t = {a: int, b: int};\n+type t = {a: int, b: int};\n+impl t : cmp::Eq {\n+    pure fn eq(&&other: t) -> bool {\n+        self.a == other.a && self.b == other.b\n+    }\n+}\n \n+fn test_rec() {\n     fn compare_rec(t1: t, t2: t) -> bool { return t1 == t2; }\n     test_generic::<t>({a: 1, b: 2}, compare_rec);\n }"}, {"sha": "a679aae779e8d4b09852b1b4b82916fe66f314a5", "filename": "src/test/run-pass/expr-if-generic.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/96534365c228d9c3962036967a7f1a1b17639e33/src%2Ftest%2Frun-pass%2Fexpr-if-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96534365c228d9c3962036967a7f1a1b17639e33/src%2Ftest%2Frun-pass%2Fexpr-if-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-if-generic.rs?ref=96534365c228d9c3962036967a7f1a1b17639e33", "patch": "@@ -16,9 +16,14 @@ fn test_bool() {\n     test_generic::<bool>(true, false, compare_bool);\n }\n \n-fn test_rec() {\n-    type t = {a: int, b: int};\n+type t = {a: int, b: int};\n+impl t : cmp::Eq {\n+    pure fn eq(&&other: t) -> bool {\n+        self.a == other.a && self.b == other.b\n+    }\n+}\n \n+fn test_rec() {\n     fn compare_rec(t1: t, t2: t) -> bool { return t1 == t2; }\n     test_generic::<t>({a: 1, b: 2}, {a: 2, b: 3}, compare_rec);\n }"}, {"sha": "e96b6baaec5c0641cde543cb36f572b276409137", "filename": "src/test/run-pass/expr-if-struct.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/96534365c228d9c3962036967a7f1a1b17639e33/src%2Ftest%2Frun-pass%2Fexpr-if-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96534365c228d9c3962036967a7f1a1b17639e33/src%2Ftest%2Frun-pass%2Fexpr-if-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-if-struct.rs?ref=96534365c228d9c3962036967a7f1a1b17639e33", "patch": "@@ -6,11 +6,17 @@\n // Tests for if as expressions returning structural types\n fn test_rec() {\n     let rs = if true { {i: 100} } else { {i: 101} };\n-    assert (rs == {i: 100});\n+    assert (rs.i == 100);\n+}\n+\n+enum mood { happy, sad, }\n+impl mood : cmp::Eq {\n+    pure fn eq(&&other: mood) -> bool {\n+        (self as uint) == (other as uint)\n+    }\n }\n \n fn test_tag() {\n-    enum mood { happy, sad, }\n     let rs = if true { happy } else { sad };\n     assert (rs == happy);\n }"}, {"sha": "a0d0f9379106726a99b9e4485e5977af1bc6aacc", "filename": "src/test/run-pass/issue-1460.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/96534365c228d9c3962036967a7f1a1b17639e33/src%2Ftest%2Frun-pass%2Fissue-1460.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96534365c228d9c3962036967a7f1a1b17639e33/src%2Ftest%2Frun-pass%2Fissue-1460.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-1460.rs?ref=96534365c228d9c3962036967a7f1a1b17639e33", "patch": "@@ -1,4 +1,4 @@\n \n fn main() {\n-    {|i| if i == 1 { }};\n-}\n\\ No newline at end of file\n+    {|i| if 1 == i { }};\n+}"}, {"sha": "20dd0c650f131e156697c44fe154f147850290a6", "filename": "src/test/run-pass/issue-2718.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/96534365c228d9c3962036967a7f1a1b17639e33/src%2Ftest%2Frun-pass%2Fissue-2718.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96534365c228d9c3962036967a7f1a1b17639e33/src%2Ftest%2Frun-pass%2Fissue-2718.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2718.rs?ref=96534365c228d9c3962036967a7f1a1b17639e33", "patch": "@@ -8,6 +8,12 @@ mod pipes {\n         terminated\n     }\n \n+    impl state : cmp::Eq {\n+        pure fn eq(&&other: state) -> bool {\n+            (self as uint) == (other as uint)\n+        }\n+    }\n+\n     type packet<T: send> = {\n         mut state: state,\n         mut blocked_task: Option<task::Task>,\n@@ -51,7 +57,7 @@ mod pipes {\n     fn send<T: send>(-p: send_packet<T>, -payload: T) {\n         let p = p.unwrap();\n         let p = unsafe { uniquify(p) };\n-        assert (*p).payload == None;\n+        assert (*p).payload.is_none();\n         (*p).payload <- Some(payload);\n         let old_state = swap_state_rel(&mut (*p).state, full);\n         match old_state {\n@@ -208,7 +214,7 @@ mod pingpong {\n \n         fn do_pong(-c: pong) -> (ping, ()) {\n             let packet = pipes::recv(c);\n-            if packet == None {\n+            if packet.is_none() {\n                 fail ~\"sender closed the connection\"\n             }\n             (liberate_pong(option::unwrap(packet)), ())\n@@ -221,7 +227,7 @@ mod pingpong {\n \n         fn do_ping(-c: ping) -> (pong, ()) {\n             let packet = pipes::recv(c);\n-            if packet == None {\n+            if packet.is_none() {\n                 fail ~\"sender closed the connection\"\n             }\n             (liberate_ping(option::unwrap(packet)), ())"}, {"sha": "9ffe94fe07868bbf592d4dcbe29c70d4f2a602a0", "filename": "src/test/run-pass/leaky_comm.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/96534365c228d9c3962036967a7f1a1b17639e33/src%2Ftest%2Frun-pass%2Fleaky_comm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96534365c228d9c3962036967a7f1a1b17639e33/src%2Ftest%2Frun-pass%2Fleaky_comm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fleaky_comm.rs?ref=96534365c228d9c3962036967a7f1a1b17639e33", "patch": "@@ -8,12 +8,12 @@ fn main() {\n   \n   match None::<int> {\n       None => {}\n-      Some(_)  =>{\n-  if test_comm::recv(p) == 0 {\n+      Some(_) => {\n+  if 0 == test_comm::recv(p) {\n       error!(\"floop\");\n   }\n   else {\n       error!(\"bloop\");\n   }\n       }}\n-}\n\\ No newline at end of file\n+}"}, {"sha": "9ba91ee67d3b6b04ced143bc1409011cc6b31a70", "filename": "src/test/run-pass/operator-overloading.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/96534365c228d9c3962036967a7f1a1b17639e33/src%2Ftest%2Frun-pass%2Foperator-overloading.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96534365c228d9c3962036967a7f1a1b17639e33/src%2Ftest%2Frun-pass%2Foperator-overloading.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foperator-overloading.rs?ref=96534365c228d9c3962036967a7f1a1b17639e33", "patch": "@@ -27,6 +27,12 @@ impl Point : ops::index<bool,int> {\n     }\n }\n \n+impl Point : cmp::Eq {\n+    pure fn eq(&&other: Point) -> bool {\n+        self.x == other.x && self.y == other.y\n+    }\n+}\n+\n fn main() {\n     let mut p = Point {x: 10, y: 20};\n     p += Point {x: 101, y: 102};"}, {"sha": "09ca7df781e4863aaade857ddb06713858a07836", "filename": "src/test/run-pass/ret-break-cont-in-block.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/96534365c228d9c3962036967a7f1a1b17639e33/src%2Ftest%2Frun-pass%2Fret-break-cont-in-block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96534365c228d9c3962036967a7f1a1b17639e33/src%2Ftest%2Frun-pass%2Fret-break-cont-in-block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fret-break-cont-in-block.rs?ref=96534365c228d9c3962036967a7f1a1b17639e33", "patch": "@@ -1,3 +1,5 @@\n+import cmp::Eq;\n+\n fn iter<T>(v: ~[T], it: fn(T) -> bool) {\n     let mut i = 0u, l = v.len();\n     while i < l {\n@@ -6,7 +8,7 @@ fn iter<T>(v: ~[T], it: fn(T) -> bool) {\n     }\n }\n \n-fn find_pos<T>(n: T, h: ~[T]) -> Option<uint> {\n+fn find_pos<T:Eq>(n: T, h: ~[T]) -> Option<uint> {\n     let mut i = 0u;\n     for iter(h) |e| {\n         if e == n { return Some(i); }"}, {"sha": "b8832edbad9bed310d5580cf55c00a24f50dab55", "filename": "src/test/run-pass/static-method-test.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/96534365c228d9c3962036967a7f1a1b17639e33/src%2Ftest%2Frun-pass%2Fstatic-method-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96534365c228d9c3962036967a7f1a1b17639e33/src%2Ftest%2Frun-pass%2Fstatic-method-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstatic-method-test.rs?ref=96534365c228d9c3962036967a7f1a1b17639e33", "patch": "@@ -67,10 +67,13 @@ fn seq_range<BT: buildable<int>>(lo: uint, hi: uint) -> BT {\n }\n \n fn main() {\n-    assert seq_range(0, 10) == @[0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n+    let v: @[int] = seq_range(0, 10);\n+    assert v == @[0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n \n-    assert map(&[1,2,3], |x| 1+x) == @[2, 3, 4];\n-    assert map(&[1,2,3], |x| 1+x) == ~[2, 3, 4];\n+    let v: @[int] = map(&[1,2,3], |x| 1+x);\n+    assert v == @[2, 3, 4];\n+    let v: ~[int] = map(&[1,2,3], |x| 1+x);\n+    assert v == ~[2, 3, 4];\n \n     assert select(true, 9, 14) == 9;\n     assert !andand(true, false);"}, {"sha": "85fdea3740535e633e79170c617eba7affb460d0", "filename": "src/test/run-pass/static-method-xcrate.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/96534365c228d9c3962036967a7f1a1b17639e33/src%2Ftest%2Frun-pass%2Fstatic-method-xcrate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96534365c228d9c3962036967a7f1a1b17639e33/src%2Ftest%2Frun-pass%2Fstatic-method-xcrate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstatic-method-xcrate.rs?ref=96534365c228d9c3962036967a7f1a1b17639e33", "patch": "@@ -6,7 +6,8 @@ import static_methods_crate::read;\n import readMaybeRenamed = static_methods_crate::readMaybe;\n \n fn main() {\n-    assert read(~\"5\") == 5;\n+    let result: int = read(~\"5\");\n+    assert result == 5;\n     assert readMaybeRenamed(~\"false\") == Some(false);\n     assert readMaybeRenamed(~\"foo\") == None::<bool>;\n }"}, {"sha": "51733ab29e830178946482ce27c509ef82ad2593", "filename": "src/test/run-pass/structured-compare.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/96534365c228d9c3962036967a7f1a1b17639e33/src%2Ftest%2Frun-pass%2Fstructured-compare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96534365c228d9c3962036967a7f1a1b17639e33/src%2Ftest%2Frun-pass%2Fstructured-compare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstructured-compare.rs?ref=96534365c228d9c3962036967a7f1a1b17639e33", "patch": "@@ -2,15 +2,21 @@\n \n enum foo { large, small, }\n \n+impl foo : cmp::Eq {\n+    pure fn eq(&&other: foo) -> bool {\n+        (self as uint) == (other as uint)\n+    }\n+}\n+\n fn main() {\n-    let a = {x: 1, y: 2, z: 3};\n-    let b = {x: 1, y: 2, z: 3};\n+    let a = (1, 2, 3);\n+    let b = (1, 2, 3);\n     assert (a == b);\n-    assert (a != {x: 1, y: 2, z: 4});\n-    assert (a < {x: 1, y: 2, z: 4});\n-    assert (a <= {x: 1, y: 2, z: 4});\n-    assert ({x: 1, y: 2, z: 4} > a);\n-    assert ({x: 1, y: 2, z: 4} >= a);\n+    assert (a != (1, 2, 4));\n+    assert (a < (1, 2, 4));\n+    assert (a <= (1, 2, 4));\n+    assert ((1, 2, 4) > a);\n+    assert ((1, 2, 4) >= a);\n     let x = large;\n     let y = small;\n     assert (x != y);"}, {"sha": "7182dad62ee229a3787aa17fc76b2d965827a8d8", "filename": "src/test/run-pass/tag-variant-disr-val.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/96534365c228d9c3962036967a7f1a1b17639e33/src%2Ftest%2Frun-pass%2Ftag-variant-disr-val.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96534365c228d9c3962036967a7f1a1b17639e33/src%2Ftest%2Frun-pass%2Ftag-variant-disr-val.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftag-variant-disr-val.rs?ref=96534365c228d9c3962036967a7f1a1b17639e33", "patch": "@@ -9,6 +9,12 @@ enum color {\n     orange = 8 >> 1\n }\n \n+impl color : cmp::Eq {\n+    pure fn eq(&&other: color) -> bool {\n+        (self as uint) == (other as uint)\n+    }\n+}\n+\n fn main() {\n     test_color(red, 0xff0000, ~\"red\");\n     test_color(green, 0x00ff00, ~\"green\");"}, {"sha": "4c98e68e370ba79262137b47086bdc8346acc84b", "filename": "src/test/run-pass/task-comm-16.rs", "status": "modified", "additions": 32, "deletions": 1, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/96534365c228d9c3962036967a7f1a1b17639e33/src%2Ftest%2Frun-pass%2Ftask-comm-16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96534365c228d9c3962036967a7f1a1b17639e33/src%2Ftest%2Frun-pass%2Ftask-comm-16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-16.rs?ref=96534365c228d9c3962036967a7f1a1b17639e33", "patch": "@@ -42,8 +42,39 @@ fn test_str() {\n     assert (s1[3] == 't' as u8);\n }\n \n+enum t {\n+    tag1,\n+    tag2(int),\n+    tag3(int, u8, char)\n+}\n+\n+impl t : cmp::Eq {\n+    pure fn eq(&&other: t) -> bool {\n+        match self {\n+            tag1 => {\n+                match other {\n+                    tag1 => true,\n+                    _ => false\n+                }\n+            }\n+            tag2(e0a) => {\n+                match other {\n+                    tag2(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            tag3(e0a, e1a, e2a) => {\n+                match other {\n+                    tag3(e0b, e1b, e2b) =>\n+                        e0a == e0b && e1a == e1b && e2a == e2b,\n+                    _ => false\n+                }\n+            }\n+        }\n+    }\n+}\n+\n fn test_tag() {\n-    enum t { tag1, tag2(int), tag3(int, u8, char), }\n     let (ch, po) = pipes::stream();\n     ch.send(tag1);\n     ch.send(tag2(10));"}, {"sha": "c22b529910a47c7c600ec80b387270ae66c52adf", "filename": "src/test/run-pass/unique-kinds.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/96534365c228d9c3962036967a7f1a1b17639e33/src%2Ftest%2Frun-pass%2Funique-kinds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96534365c228d9c3962036967a7f1a1b17639e33/src%2Ftest%2Frun-pass%2Funique-kinds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funique-kinds.rs?ref=96534365c228d9c3962036967a7f1a1b17639e33", "patch": "@@ -1,10 +1,12 @@\n+use cmp::Eq;\n+\n fn sendable() {\n \n-    fn f<T: send>(i: T, j: T) {\n+    fn f<T: send Eq>(i: T, j: T) {\n         assert i == j;\n     }\n \n-    fn g<T: send>(i: T, j: T) {\n+    fn g<T: send Eq>(i: T, j: T) {\n         assert i != j;\n     }\n \n@@ -18,11 +20,11 @@ fn sendable() {\n \n fn copyable() {\n \n-    fn f<T: copy>(i: T, j: T) {\n+    fn f<T: copy Eq>(i: T, j: T) {\n         assert i == j;\n     }\n \n-    fn g<T: copy>(i: T, j: T) {\n+    fn g<T: copy Eq>(i: T, j: T) {\n         assert i != j;\n     }\n \n@@ -36,11 +38,11 @@ fn copyable() {\n \n fn noncopyable() {\n \n-    fn f<T>(i: T, j: T) {\n+    fn f<T: Eq>(i: T, j: T) {\n         assert i == j;\n     }\n \n-    fn g<T>(i: T, j: T) {\n+    fn g<T: Eq>(i: T, j: T) {\n         assert i != j;\n     }\n "}]}