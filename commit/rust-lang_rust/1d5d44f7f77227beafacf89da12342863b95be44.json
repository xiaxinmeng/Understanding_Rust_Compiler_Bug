{"sha": "1d5d44f7f77227beafacf89da12342863b95be44", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFkNWQ0NGY3Zjc3MjI3YmVhZmFjZjg5ZGExMjM0Mjg2M2I5NWJlNDQ=", "commit": {"author": {"name": "Jonas Schievink", "email": "jonasschievink@gmail.com", "date": "2021-03-23T16:23:10Z"}, "committer": {"name": "Jonas Schievink", "email": "jonasschievink@gmail.com", "date": "2021-03-23T16:23:10Z"}, "message": "Merge bang-macros and derives in name resolution", "tree": {"sha": "1beb6d678bf393915d9f3adf7a8561a2f3d94a1a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1beb6d678bf393915d9f3adf7a8561a2f3d94a1a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1d5d44f7f77227beafacf89da12342863b95be44", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1d5d44f7f77227beafacf89da12342863b95be44", "html_url": "https://github.com/rust-lang/rust/commit/1d5d44f7f77227beafacf89da12342863b95be44", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1d5d44f7f77227beafacf89da12342863b95be44/comments", "author": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "065a8e87cd015ccfe5c01ad6b603f4fdad18f768", "url": "https://api.github.com/repos/rust-lang/rust/commits/065a8e87cd015ccfe5c01ad6b603f4fdad18f768", "html_url": "https://github.com/rust-lang/rust/commit/065a8e87cd015ccfe5c01ad6b603f4fdad18f768"}], "stats": {"total": 165, "additions": 79, "deletions": 86}, "files": [{"sha": "d8fabe49ba5c252a73c683950688b4be384ed019", "filename": "crates/hir_def/src/nameres/collector.rs", "status": "modified", "additions": 79, "deletions": 86, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/1d5d44f7f77227beafacf89da12342863b95be44/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d5d44f7f77227beafacf89da12342863b95be44/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs?ref=1d5d44f7f77227beafacf89da12342863b95be44", "patch": "@@ -91,7 +91,6 @@ pub(super) fn collect_defs(\n         resolved_imports: Vec::new(),\n \n         unexpanded_macros: Vec::new(),\n-        unexpanded_attribute_macros: Vec::new(),\n         mod_dirs: FxHashMap::default(),\n         cfg_options,\n         proc_macros,\n@@ -202,15 +201,14 @@ struct ImportDirective {\n #[derive(Clone, Debug, Eq, PartialEq)]\n struct MacroDirective {\n     module_id: LocalModuleId,\n-    ast_id: AstIdWithPath<ast::MacroCall>,\n-    legacy: Option<MacroCallId>,\n     depth: usize,\n+    kind: MacroDirectiveKind,\n }\n \n #[derive(Clone, Debug, Eq, PartialEq)]\n-struct DeriveDirective {\n-    module_id: LocalModuleId,\n-    ast_id: AstIdWithPath<ast::Item>,\n+enum MacroDirectiveKind {\n+    FnLike { ast_id: AstIdWithPath<ast::MacroCall>, legacy: Option<MacroCallId> },\n+    Derive { ast_id: AstIdWithPath<ast::Item> },\n }\n \n struct DefData<'a> {\n@@ -228,7 +226,6 @@ struct DefCollector<'a> {\n     unresolved_imports: Vec<ImportDirective>,\n     resolved_imports: Vec<ImportDirective>,\n     unexpanded_macros: Vec<MacroDirective>,\n-    unexpanded_attribute_macros: Vec<DeriveDirective>,\n     mod_dirs: FxHashMap<LocalModuleId, ModDir>,\n     cfg_options: &'a CfgOptions,\n     /// List of procedural macros defined by this crate. This is read from the dynamic library\n@@ -782,60 +779,58 @@ impl DefCollector<'_> {\n \n     fn resolve_macros(&mut self) -> ReachedFixedPoint {\n         let mut macros = std::mem::replace(&mut self.unexpanded_macros, Vec::new());\n-        let mut attribute_macros =\n-            std::mem::replace(&mut self.unexpanded_attribute_macros, Vec::new());\n         let mut resolved = Vec::new();\n         let mut res = ReachedFixedPoint::Yes;\n         macros.retain(|directive| {\n-            if let Some(call_id) = directive.legacy {\n-                res = ReachedFixedPoint::No;\n-                resolved.push((directive.module_id, call_id, directive.depth));\n-                return false;\n-            }\n+            match &directive.kind {\n+                MacroDirectiveKind::FnLike { ast_id, legacy } => {\n+                    if let Some(call_id) = legacy {\n+                        res = ReachedFixedPoint::No;\n+                        resolved.push((directive.module_id, *call_id, directive.depth));\n+                        return false;\n+                    }\n \n-            match macro_call_as_call_id(\n-                &directive.ast_id,\n-                self.db,\n-                self.def_map.krate,\n-                |path| {\n-                    let resolved_res = self.def_map.resolve_path_fp_with_macro(\n+                    match macro_call_as_call_id(\n+                        ast_id,\n                         self.db,\n-                        ResolveMode::Other,\n-                        directive.module_id,\n-                        &path,\n-                        BuiltinShadowMode::Module,\n-                    );\n-                    resolved_res.resolved_def.take_macros()\n-                },\n-                &mut |_err| (),\n-            ) {\n-                Ok(Ok(call_id)) => {\n-                    resolved.push((directive.module_id, call_id, directive.depth));\n-                    res = ReachedFixedPoint::No;\n-                    return false;\n+                        self.def_map.krate,\n+                        |path| {\n+                            let resolved_res = self.def_map.resolve_path_fp_with_macro(\n+                                self.db,\n+                                ResolveMode::Other,\n+                                directive.module_id,\n+                                &path,\n+                                BuiltinShadowMode::Module,\n+                            );\n+                            resolved_res.resolved_def.take_macros()\n+                        },\n+                        &mut |_err| (),\n+                    ) {\n+                        Ok(Ok(call_id)) => {\n+                            resolved.push((directive.module_id, call_id, directive.depth));\n+                            res = ReachedFixedPoint::No;\n+                            return false;\n+                        }\n+                        Err(UnresolvedMacro) | Ok(Err(_)) => {}\n+                    }\n                 }\n-                Err(UnresolvedMacro) | Ok(Err(_)) => {}\n-            }\n-\n-            true\n-        });\n-        attribute_macros.retain(|directive| {\n-            match derive_macro_as_call_id(&directive.ast_id, self.db, self.def_map.krate, |path| {\n-                self.resolve_derive_macro(&directive, &path)\n-            }) {\n-                Ok(call_id) => {\n-                    resolved.push((directive.module_id, call_id, 0));\n-                    res = ReachedFixedPoint::No;\n-                    return false;\n+                MacroDirectiveKind::Derive { ast_id } => {\n+                    match derive_macro_as_call_id(ast_id, self.db, self.def_map.krate, |path| {\n+                        self.resolve_derive_macro(directive.module_id, &path)\n+                    }) {\n+                        Ok(call_id) => {\n+                            resolved.push((directive.module_id, call_id, 0));\n+                            res = ReachedFixedPoint::No;\n+                            return false;\n+                        }\n+                        Err(UnresolvedMacro) => (),\n+                    }\n                 }\n-                Err(UnresolvedMacro) => (),\n             }\n \n             true\n         });\n-\n         self.unexpanded_macros = macros;\n-        self.unexpanded_attribute_macros = attribute_macros;\n \n         for (module_id, macro_call_id, depth) in resolved {\n             self.collect_macro_expansion(module_id, macro_call_id, depth);\n@@ -844,15 +839,11 @@ impl DefCollector<'_> {\n         res\n     }\n \n-    fn resolve_derive_macro(\n-        &self,\n-        directive: &DeriveDirective,\n-        path: &ModPath,\n-    ) -> Option<MacroDefId> {\n+    fn resolve_derive_macro(&self, module: LocalModuleId, path: &ModPath) -> Option<MacroDefId> {\n         let resolved_res = self.def_map.resolve_path_fp_with_macro(\n             self.db,\n             ResolveMode::Other,\n-            directive.module_id,\n+            module,\n             &path,\n             BuiltinShadowMode::Module,\n         );\n@@ -912,33 +903,35 @@ impl DefCollector<'_> {\n         // Emit diagnostics for all remaining unexpanded macros.\n \n         for directive in &self.unexpanded_macros {\n-            let mut error = None;\n-            match macro_call_as_call_id(\n-                &directive.ast_id,\n-                self.db,\n-                self.def_map.krate,\n-                |path| {\n-                    let resolved_res = self.def_map.resolve_path_fp_with_macro(\n-                        self.db,\n-                        ResolveMode::Other,\n-                        directive.module_id,\n-                        &path,\n-                        BuiltinShadowMode::Module,\n-                    );\n-                    resolved_res.resolved_def.take_macros()\n-                },\n-                &mut |e| {\n-                    error.get_or_insert(e);\n+            match &directive.kind {\n+                MacroDirectiveKind::FnLike { ast_id, .. } => match macro_call_as_call_id(\n+                    ast_id,\n+                    self.db,\n+                    self.def_map.krate,\n+                    |path| {\n+                        let resolved_res = self.def_map.resolve_path_fp_with_macro(\n+                            self.db,\n+                            ResolveMode::Other,\n+                            directive.module_id,\n+                            &path,\n+                            BuiltinShadowMode::Module,\n+                        );\n+                        resolved_res.resolved_def.take_macros()\n+                    },\n+                    &mut |_| (),\n+                ) {\n+                    Ok(_) => (),\n+                    Err(UnresolvedMacro) => {\n+                        self.def_map.diagnostics.push(DefDiagnostic::unresolved_macro_call(\n+                            directive.module_id,\n+                            ast_id.ast_id,\n+                        ));\n+                    }\n                 },\n-            ) {\n-                Ok(_) => (),\n-                Err(UnresolvedMacro) => {\n-                    self.def_map.diagnostics.push(DefDiagnostic::unresolved_macro_call(\n-                        directive.module_id,\n-                        directive.ast_id.ast_id,\n-                    ));\n+                MacroDirectiveKind::Derive { .. } => {\n+                    // FIXME: we might want to diagnose this too\n                 }\n-            };\n+            }\n         }\n \n         // Emit diagnostics for all remaining unresolved imports.\n@@ -1380,9 +1373,11 @@ impl ModCollector<'_, '_> {\n                 Some(derive_macros) => {\n                     for path in derive_macros {\n                         let ast_id = AstIdWithPath::new(self.file_id, ast_id, path);\n-                        self.def_collector\n-                            .unexpanded_attribute_macros\n-                            .push(DeriveDirective { module_id: self.module_id, ast_id });\n+                        self.def_collector.unexpanded_macros.push(MacroDirective {\n+                            module_id: self.module_id,\n+                            depth: self.macro_depth + 1,\n+                            kind: MacroDirectiveKind::Derive { ast_id },\n+                        });\n                     }\n                 }\n                 None => {\n@@ -1497,9 +1492,8 @@ impl ModCollector<'_, '_> {\n \n         self.def_collector.unexpanded_macros.push(MacroDirective {\n             module_id: self.module_id,\n-            ast_id,\n-            legacy: None,\n             depth: self.macro_depth + 1,\n+            kind: MacroDirectiveKind::FnLike { ast_id, legacy: None },\n         });\n     }\n \n@@ -1542,7 +1536,6 @@ mod tests {\n             unresolved_imports: Vec::new(),\n             resolved_imports: Vec::new(),\n             unexpanded_macros: Vec::new(),\n-            unexpanded_attribute_macros: Vec::new(),\n             mod_dirs: FxHashMap::default(),\n             cfg_options: &CfgOptions::default(),\n             proc_macros: Default::default(),"}]}