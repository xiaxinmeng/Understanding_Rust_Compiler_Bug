{"sha": "f0775d7bfe99617892e90e956be65cc80a28e070", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYwNzc1ZDdiZmU5OTYxNzg5MmU5MGU5NTZiZTY1Y2M4MGEyOGUwNzA=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-08-09T23:05:34Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-08-09T23:05:34Z"}, "message": "Finish translating const indexing. Close #1417, close #570, close #571, close #1272, close #2317.", "tree": {"sha": "9f5cf432377aa5f5a97a2b19fe2b55f4a98c2dd7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9f5cf432377aa5f5a97a2b19fe2b55f4a98c2dd7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f0775d7bfe99617892e90e956be65cc80a28e070", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f0775d7bfe99617892e90e956be65cc80a28e070", "html_url": "https://github.com/rust-lang/rust/commit/f0775d7bfe99617892e90e956be65cc80a28e070", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f0775d7bfe99617892e90e956be65cc80a28e070/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "22a14dd700338ed26f78143dfad4325566a3f4ed", "url": "https://api.github.com/repos/rust-lang/rust/commits/22a14dd700338ed26f78143dfad4325566a3f4ed", "html_url": "https://github.com/rust-lang/rust/commit/22a14dd700338ed26f78143dfad4325566a3f4ed"}], "stats": {"total": 87, "additions": 64, "deletions": 23}, "files": [{"sha": "07aba04ca0e53d9444ca015f04fea915ef43f463", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f0775d7bfe99617892e90e956be65cc80a28e070/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0775d7bfe99617892e90e956be65cc80a28e070/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=f0775d7bfe99617892e90e956be65cc80a28e070", "patch": "@@ -5717,6 +5717,7 @@ fn trans_crate(sess: session::session, crate: @ast::crate, tcx: ty::ctxt,\n           type_use_cache: ast_util::new_def_hash(),\n           vtables: map::hashmap(hash_mono_id, sys::shape_eq),\n           const_cstr_cache: map::str_hash(),\n+          const_globals: int_hash::<ValueRef>(),\n           module_data: str_hash::<ValueRef>(),\n           lltypes: ty::new_ty_hash(),\n           names: new_namegen(),"}, {"sha": "363f725b5fc6da345305604f2e8b3195c00a16e5", "filename": "src/rustc/middle/trans/common.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f0775d7bfe99617892e90e956be65cc80a28e070/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0775d7bfe99617892e90e956be65cc80a28e070/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=f0775d7bfe99617892e90e956be65cc80a28e070", "patch": "@@ -107,6 +107,10 @@ type crate_ctxt = {\n      vtables: hashmap<mono_id, ValueRef>,\n      // Cache of constant strings,\n      const_cstr_cache: hashmap<~str, ValueRef>,\n+     // Reverse-direction for const ptrs cast from globals,\n+     // since the ptr -> init association is lost any\n+     // time a GlobalValue is cast.\n+     const_globals: hashmap<int, ValueRef>,\n      module_data: hashmap<~str, ValueRef>,\n      lltypes: hashmap<ty::t, TypeRef>,\n      names: namegen,"}, {"sha": "732d02928c4a988d54e1e7e3605e16d984506724", "filename": "src/rustc/middle/trans/consts.rs", "status": "modified", "additions": 54, "deletions": 14, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/f0775d7bfe99617892e90e956be65cc80a28e070/src%2Frustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0775d7bfe99617892e90e956be65cc80a28e070/src%2Frustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=f0775d7bfe99617892e90e956be65cc80a28e070", "patch": "@@ -32,6 +32,12 @@ fn const_lit(cx: @crate_ctxt, e: @ast::expr, lit: ast::lit)\n // duplicate constants. I think. Maybe LLVM has a magical mode that does so\n // later on?\n \n+fn const_ptrcast(cx: @crate_ctxt, a: ValueRef, t: TypeRef) -> ValueRef {\n+    let b = llvm::LLVMConstPointerCast(a, T_ptr(t));\n+    assert cx.const_globals.insert(b as int, a);\n+    b\n+}\n+\n fn const_vec(cx: @crate_ctxt, e: @ast::expr, es: &[@ast::expr])\n     -> (ValueRef, ValueRef, TypeRef) {\n     let vec_ty = ty::expr_ty(cx.tcx, e);\n@@ -43,17 +49,22 @@ fn const_vec(cx: @crate_ctxt, e: @ast::expr, es: &[@ast::expr])\n     return (v, sz, llunitty);\n }\n \n-fn const_deref(v: ValueRef) -> ValueRef {\n+fn const_deref(cx: @crate_ctxt, v: ValueRef) -> ValueRef {\n+    let v = match cx.const_globals.find(v as int) {\n+        some(v) => v,\n+        none => v\n+    };\n     assert llvm::LLVMIsGlobalConstant(v) == True;\n-    llvm::LLVMGetInitializer(v)\n+    let v = llvm::LLVMGetInitializer(v);\n+    v\n }\n \n fn const_get_elt(v: ValueRef, u: uint) -> ValueRef {\n     let u = u;\n     llvm::LLVMConstExtractValue(v, ptr::addr_of(u), 1 as c_uint)\n }\n \n-fn const_autoderef(ty: ty::t, v: ValueRef)\n+fn const_autoderef(cx: @crate_ctxt, ty: ty::t, v: ValueRef)\n     -> (ty::t, ValueRef) {\n     let mut t1 = ty;\n     let mut v1 = v;\n@@ -62,7 +73,7 @@ fn const_autoderef(ty: ty::t, v: ValueRef)\n         match ty::get(ty).struct {\n             ty::ty_rptr(_, mt) => {\n                 t1 = mt.ty;\n-                v1 = const_deref(v1);\n+                v1 = const_deref(cx, v1);\n             }\n             _ => return (t1,v1)\n         }\n@@ -133,7 +144,7 @@ fn const_expr(cx: @crate_ctxt, e: @ast::expr) -> ValueRef {\n         return match u {\n           ast::box(_)  |\n           ast::uniq(_) |\n-          ast::deref  => const_deref(te),\n+          ast::deref  => const_deref(cx, te),\n           ast::not    => llvm::LLVMConstNot(te),\n           ast::neg    => {\n             if is_float { llvm::LLVMConstFNeg(te) }\n@@ -144,7 +155,7 @@ fn const_expr(cx: @crate_ctxt, e: @ast::expr) -> ValueRef {\n       ast::expr_field(base, field, _) => {\n           let bt = ty::expr_ty(cx.tcx, base);\n           let bv = const_expr(cx, base);\n-          let (bt, bv) = const_autoderef(bt, bv);\n+          let (bt, bv) = const_autoderef(cx, bt, bv);\n           let fields = match ty::get(bt).struct {\n               ty::ty_rec(fs) => fs,\n               ty::ty_class(did, substs) =>\n@@ -159,15 +170,15 @@ fn const_expr(cx: @crate_ctxt, e: @ast::expr) -> ValueRef {\n       ast::expr_index(base, index) => {\n           let bt = ty::expr_ty(cx.tcx, base);\n           let bv = const_expr(cx, base);\n-          let (bt, bv) = const_autoderef(bt, bv);\n+          let (bt, bv) = const_autoderef(cx, bt, bv);\n           let iv = match const_eval::eval_const_expr(cx.tcx, index) {\n               const_eval::const_int(i) => i as u64,\n               const_eval::const_uint(u) => u,\n               _ => cx.sess.span_bug(index.span,\n                                     ~\"index is not an integer-constant \\\n                                       expression\")\n           };\n-          let (arr,len) = match ty::get(bt).struct {\n+          let (arr, _len) = match ty::get(bt).struct {\n               ty::ty_evec(_, vstore) | ty::ty_estr(vstore) =>\n                   match vstore {\n                   ty::vstore_fixed(u) =>\n@@ -177,9 +188,10 @@ fn const_expr(cx: @crate_ctxt, e: @ast::expr) -> ValueRef {\n                       let unit_ty = ty::sequence_element_type(cx.tcx, bt);\n                       let llunitty = type_of::type_of(cx, unit_ty);\n                       let unit_sz = shape::llsize_of(cx, llunitty);\n-                      (const_deref(const_get_elt(bv, 0)),\n+\n+                      (const_deref(cx, const_get_elt(bv, 0)),\n                        llvm::LLVMConstUDiv(const_get_elt(bv, 1),\n-                                            unit_sz))\n+                                           unit_sz))\n                   },\n                   _ => cx.sess.span_bug(base.span,\n                                         ~\"index-expr base must be \\\n@@ -189,13 +201,42 @@ fn const_expr(cx: @crate_ctxt, e: @ast::expr) -> ValueRef {\n                                      ~\"index-expr base must be \\\n                                        a vector or string type\")\n           };\n-          let len = llvm::LLVMConstIntGetZExtValue(len) as u64;\n+\n+          // FIXME #3169: This is a little odd but it arises due to a weird\n+          // wrinkle in LLVM: it doesn't appear willing to let us call\n+          // LLVMConstIntGetZExtValue on the size element of the slice, or\n+          // seemingly any integer-const involving a sizeof() call. Despite\n+          // that being \"a const\", it's not the kind of const you can ask\n+          // for the integer-value of, evidently. This might be an LLVM\n+          // bug, not sure. In any case, to work around this we drop down\n+          // to the array-type level here and just ask how long the\n+          // array-type itself is, ignoring the length we pulled out of the\n+          // slice. This in turn only works because we picked out the\n+          // original globalvar via const_deref and so can recover the\n+          // array-size of the underlying array, and all this will hold\n+          // together exactly as long as we _don't_ support const\n+          // sub-slices (that is, slices that represent something other\n+          // than a whole array).  At that point we'll have more and uglier\n+          // work to do here, but for now this should work.\n+          //\n+          // In the future, what we should be doing here is the\n+          // moral equivalent of:\n+          //\n+          // let len = llvm::LLVMConstIntGetZExtValue(len) as u64;\n+          //\n+          // but we might have to do substantially more magic to\n+          // make it work. Or figure out what is causing LLVM to\n+          // not want to consider sizeof() a constant expression\n+          // we can get the value (as a number) out of.\n+\n+          let len = llvm::LLVMGetArrayLength(val_ty(arr)) as u64;\n           let len = match ty::get(bt).struct {\n               ty::ty_estr(*) => {assert len > 0; len - 1},\n               _ => len\n           };\n           if iv >= len {\n-              // Better late than never for reporting this?\n+              // FIXME #3170: report this earlier on in the const-eval\n+              // pass. Reporting here is a bit late.\n               cx.sess.span_err(e.span,\n                                ~\"const index-expr is out of bounds\");\n           }\n@@ -292,8 +333,7 @@ fn const_expr(cx: @crate_ctxt, e: @ast::expr) -> ValueRef {\n             };\n             llvm::LLVMSetInitializer(gv, cv);\n             llvm::LLVMSetGlobalConstant(gv, True);\n-            let p = llvm::LLVMConstPointerCast(gv, T_ptr(llunitty));\n-\n+            let p = const_ptrcast(cx, gv, llunitty);\n             C_struct(~[p, sz])\n           }\n           _ => cx.sess.span_bug(e.span,"}, {"sha": "8a02ea13186de59946ad774c50f9d7cdb4311d46", "filename": "src/test/run-pass/const-fields-and-indexing.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f0775d7bfe99617892e90e956be65cc80a28e070/src%2Ftest%2Frun-pass%2Fconst-fields-and-indexing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0775d7bfe99617892e90e956be65cc80a28e070/src%2Ftest%2Frun-pass%2Fconst-fields-and-indexing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-fields-and-indexing.rs?ref=f0775d7bfe99617892e90e956be65cc80a28e070", "patch": "@@ -1,20 +1,16 @@\n-// Not quite working on the indexing part yet.\n-/*\n const x : [int]/4 = [1,2,3,4];\n-const y : &[int] = &[1,2,3,4];\n const p : int = x[2];\n+const y : &[int] = &[1,2,3,4];\n const q : int = y[2];\n-*/\n \n const s : {a: int, b: int} = {a: 10, b: 20};\n const t : int = s.b;\n \n fn main() {\n-\n-//    io::println(fmt!(\"%?\", p));\n-//    io::println(fmt!(\"%?\", q));\n+    io::println(fmt!(\"%?\", p));\n+    io::println(fmt!(\"%?\", q));\n     io::println(fmt!(\"%?\", t));\n-//    assert p == 3;\n-//    assert q == 3;\n+    assert p == 3;\n+    assert q == 3;\n     assert t == 20;\n }\n\\ No newline at end of file"}]}