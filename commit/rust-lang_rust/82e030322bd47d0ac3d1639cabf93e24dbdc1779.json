{"sha": "82e030322bd47d0ac3d1639cabf93e24dbdc1779", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgyZTAzMDMyMmJkNDdkMGFjM2QxNjM5Y2FiZjkzZTI0ZGJkYzE3Nzk=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2017-04-16T16:06:26Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2017-04-25T19:38:39Z"}, "message": "Check privacy of trait items in all contexts", "tree": {"sha": "26d784ff69c8536d091e123abf959752025df42d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/26d784ff69c8536d091e123abf959752025df42d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/82e030322bd47d0ac3d1639cabf93e24dbdc1779", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/82e030322bd47d0ac3d1639cabf93e24dbdc1779", "html_url": "https://github.com/rust-lang/rust/commit/82e030322bd47d0ac3d1639cabf93e24dbdc1779", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/82e030322bd47d0ac3d1639cabf93e24dbdc1779/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2b4c911581099e247a68b3a8adc782d778f5190b", "url": "https://api.github.com/repos/rust-lang/rust/commits/2b4c911581099e247a68b3a8adc782d778f5190b", "html_url": "https://github.com/rust-lang/rust/commit/2b4c911581099e247a68b3a8adc782d778f5190b"}], "stats": {"total": 338, "additions": 162, "deletions": 176}, "files": [{"sha": "6a00586a01f82ad1bf6fea2f77cae58f1f7fdff2", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 11, "deletions": 14, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/82e030322bd47d0ac3d1639cabf93e24dbdc1779/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82e030322bd47d0ac3d1639cabf93e24dbdc1779/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=82e030322bd47d0ac3d1639cabf93e24dbdc1779", "patch": "@@ -2156,6 +2156,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n     fn associated_item_from_trait_item_ref(self,\n                                            parent_def_id: DefId,\n+                                           parent_vis: &hir::Visibility,\n                                            trait_item_ref: &hir::TraitItemRef)\n                                            -> AssociatedItem {\n         let def_id = self.hir.local_def_id(trait_item_ref.id.node_id);\n@@ -2170,7 +2171,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         AssociatedItem {\n             name: trait_item_ref.name,\n             kind: kind,\n-            vis: Visibility::from_hir(&hir::Inherited, trait_item_ref.id.node_id, self),\n+            // Visibility of trait items is inherited from their traits.\n+            vis: Visibility::from_hir(parent_vis, trait_item_ref.id.node_id, self),\n             defaultness: trait_item_ref.defaultness,\n             def_id: def_id,\n             container: TraitContainer(parent_def_id),\n@@ -2180,7 +2182,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n     fn associated_item_from_impl_item_ref(self,\n                                           parent_def_id: DefId,\n-                                          from_trait_impl: bool,\n                                           impl_item_ref: &hir::ImplItemRef)\n                                           -> AssociatedItem {\n         let def_id = self.hir.local_def_id(impl_item_ref.id.node_id);\n@@ -2192,14 +2193,11 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             hir::AssociatedItemKind::Type => (ty::AssociatedKind::Type, false),\n         };\n \n-        // Trait impl items are always public.\n-        let public = hir::Public;\n-        let vis = if from_trait_impl { &public } else { &impl_item_ref.vis };\n-\n         ty::AssociatedItem {\n             name: impl_item_ref.name,\n             kind: kind,\n-            vis: ty::Visibility::from_hir(vis, impl_item_ref.id.node_id, self),\n+            // Visibility of trait impl items doesn't matter.\n+            vis: ty::Visibility::from_hir(&impl_item_ref.vis, impl_item_ref.id.node_id, self),\n             defaultness: impl_item_ref.defaultness,\n             def_id: def_id,\n             container: ImplContainer(parent_def_id),\n@@ -2639,21 +2637,20 @@ fn associated_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n     let parent_def_id = tcx.hir.local_def_id(parent_id);\n     let parent_item = tcx.hir.expect_item(parent_id);\n     match parent_item.node {\n-        hir::ItemImpl(.., ref impl_trait_ref, _, ref impl_item_refs) => {\n+        hir::ItemImpl(.., ref impl_item_refs) => {\n             if let Some(impl_item_ref) = impl_item_refs.iter().find(|i| i.id.node_id == id) {\n-                let assoc_item =\n-                    tcx.associated_item_from_impl_item_ref(parent_def_id,\n-                                                            impl_trait_ref.is_some(),\n-                                                            impl_item_ref);\n+                let assoc_item = tcx.associated_item_from_impl_item_ref(parent_def_id,\n+                                                                        impl_item_ref);\n                 debug_assert_eq!(assoc_item.def_id, def_id);\n                 return assoc_item;\n             }\n         }\n \n         hir::ItemTrait(.., ref trait_item_refs) => {\n             if let Some(trait_item_ref) = trait_item_refs.iter().find(|i| i.id.node_id == id) {\n-                let assoc_item =\n-                    tcx.associated_item_from_trait_item_ref(parent_def_id, trait_item_ref);\n+                let assoc_item = tcx.associated_item_from_trait_item_ref(parent_def_id,\n+                                                                         &parent_item.vis,\n+                                                                         trait_item_ref);\n                 debug_assert_eq!(assoc_item.def_id, def_id);\n                 return assoc_item;\n             }"}, {"sha": "5ef79d6ceeb0dda7ab0228fc0c379bb57d7a9365", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/82e030322bd47d0ac3d1639cabf93e24dbdc1779/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82e030322bd47d0ac3d1639cabf93e24dbdc1779/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=82e030322bd47d0ac3d1639cabf93e24dbdc1779", "patch": "@@ -427,14 +427,6 @@ struct PrivacyVisitor<'a, 'tcx: 'a> {\n }\n \n impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n-    fn item_is_accessible(&self, did: DefId) -> bool {\n-        match self.tcx.hir.as_local_node_id(did) {\n-            Some(node_id) =>\n-                ty::Visibility::from_hir(&self.tcx.hir.expect_item(node_id).vis, node_id, self.tcx),\n-            None => self.tcx.sess.cstore.visibility(did),\n-        }.is_accessible_from(self.curitem, self.tcx)\n-    }\n-\n     // Checks that a field is in scope.\n     fn check_field(&mut self, span: Span, def: &'tcx ty::AdtDef, field: &'tcx ty::FieldDef) {\n         if !def.is_enum() && !field.vis.is_accessible_from(self.curitem, self.tcx) {\n@@ -444,20 +436,6 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n                 .emit();\n         }\n     }\n-\n-    // Checks that a method is in scope.\n-    fn check_method(&mut self, span: Span, method_def_id: DefId) {\n-        match self.tcx.associated_item(method_def_id).container {\n-            // Trait methods are always all public. The only controlling factor\n-            // is whether the trait itself is accessible or not.\n-            ty::TraitContainer(trait_def_id) if !self.item_is_accessible(trait_def_id) => {\n-                let msg = format!(\"source trait `{}` is private\",\n-                                  self.tcx.item_path_str(trait_def_id));\n-                self.tcx.sess.span_err(span, &msg);\n-            }\n-            _ => {}\n-        }\n-    }\n }\n \n impl<'a, 'tcx> Visitor<'tcx> for PrivacyVisitor<'a, 'tcx> {\n@@ -483,11 +461,6 @@ impl<'a, 'tcx> Visitor<'tcx> for PrivacyVisitor<'a, 'tcx> {\n \n     fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n         match expr.node {\n-            hir::ExprMethodCall(..) => {\n-                let method_call = ty::MethodCall::expr(expr.id);\n-                let method = self.tables.method_map[&method_call];\n-                self.check_method(expr.span, method.def_id);\n-            }\n             hir::ExprStruct(ref qpath, ref expr_fields, _) => {\n                 let def = self.tables.qpath_def(qpath, expr.id);\n                 let adt = self.tables.expr_ty(expr).ty_adt_def().unwrap();"}, {"sha": "e0c67c1456d02a70224d9ec3329d701a30792088", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/82e030322bd47d0ac3d1639cabf93e24dbdc1779/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82e030322bd47d0ac3d1639cabf93e24dbdc1779/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=82e030322bd47d0ac3d1639cabf93e24dbdc1779", "patch": "@@ -903,10 +903,16 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         let ty = self.projected_ty_from_poly_trait_ref(span, bound, assoc_name);\n         let ty = self.normalize_ty(span, ty);\n \n-        let item = tcx.associated_items(trait_did).find(|i| i.name == assoc_name);\n-        let def_id = item.expect(\"missing associated type\").def_id;\n-        tcx.check_stability(def_id, ref_id, span);\n-        (ty, Def::AssociatedTy(def_id))\n+        let item = tcx.associated_items(trait_did).find(|i| i.name == assoc_name)\n+                                                  .expect(\"missing associated type\");\n+        let def = Def::AssociatedTy(item.def_id);\n+        if !tcx.vis_is_accessible_from(item.vis, ref_id) {\n+            let msg = format!(\"{} `{}` is private\", def.kind_name(), assoc_name);\n+            tcx.sess.span_err(span, &msg);\n+        }\n+        tcx.check_stability(item.def_id, ref_id, span);\n+\n+        (ty, def)\n     }\n \n     fn qpath_to_ty(&self,"}, {"sha": "72fba1ef6ecca825c9fbf279e63170e0da18d947", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/82e030322bd47d0ac3d1639cabf93e24dbdc1779/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82e030322bd47d0ac3d1639cabf93e24dbdc1779/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=82e030322bd47d0ac3d1639cabf93e24dbdc1779", "patch": "@@ -349,15 +349,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         }\n \n         let def = pick.item.def();\n-\n         self.tcx.check_stability(def.def_id(), expr_id, span);\n \n-        if let probe::InherentImplPick = pick.kind {\n-            if !self.tcx.vis_is_accessible_from(pick.item.vis, self.body_id) {\n-                let msg = format!(\"{} `{}` is private\", def.kind_name(), method_name);\n-                self.tcx.sess.span_err(span, &msg);\n-            }\n-        }\n         Ok(def)\n     }\n "}, {"sha": "26e8693d3b2aa441eb6a6e7fabb3471e5b0d0db0", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 30, "deletions": 48, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/82e030322bd47d0ac3d1639cabf93e24dbdc1779/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82e030322bd47d0ac3d1639cabf93e24dbdc1779/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=82e030322bd47d0ac3d1639cabf93e24dbdc1779", "patch": "@@ -369,6 +369,24 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n     ///////////////////////////////////////////////////////////////////////////\n     // CANDIDATE ASSEMBLY\n \n+    fn push_inherent_candidate(&mut self, xform_self_ty: Ty<'tcx>, item: ty::AssociatedItem,\n+                               kind: CandidateKind<'tcx>, import_id: Option<ast::NodeId>) {\n+        if self.tcx.vis_is_accessible_from(item.vis, self.body_id) {\n+            self.inherent_candidates.push(Candidate { xform_self_ty, item, kind, import_id });\n+        } else if self.private_candidate.is_none() {\n+            self.private_candidate = Some(item.def());\n+        }\n+    }\n+\n+    fn push_extension_candidate(&mut self, xform_self_ty: Ty<'tcx>, item: ty::AssociatedItem,\n+                               kind: CandidateKind<'tcx>, import_id: Option<ast::NodeId>) {\n+        if self.tcx.vis_is_accessible_from(item.vis, self.body_id) {\n+            self.extension_candidates.push(Candidate { xform_self_ty, item, kind, import_id });\n+        } else if self.private_candidate.is_none() {\n+            self.private_candidate = Some(item.def());\n+        }\n+    }\n+\n     fn assemble_inherent_candidates(&mut self) {\n         let steps = self.steps.clone();\n         for step in steps.iter() {\n@@ -499,11 +517,6 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                 continue\n             }\n \n-            if !self.tcx.vis_is_accessible_from(item.vis, self.body_id) {\n-                self.private_candidate = Some(item.def());\n-                continue\n-            }\n-\n             let (impl_ty, impl_substs) = self.impl_ty_and_substs(impl_def_id);\n             let impl_ty = impl_ty.subst(self.tcx, impl_substs);\n \n@@ -519,12 +532,8 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n             debug!(\"assemble_inherent_impl_probe: xform_self_ty = {:?}\",\n                    xform_self_ty);\n \n-            self.inherent_candidates.push(Candidate {\n-                xform_self_ty: xform_self_ty,\n-                item: item,\n-                kind: InherentImplCandidate(impl_substs, obligations),\n-                import_id: None,\n-            });\n+            self.push_inherent_candidate(xform_self_ty, item,\n+                                         InherentImplCandidate(impl_substs, obligations), None);\n         }\n     }\n \n@@ -548,12 +557,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n             let xform_self_ty =\n                 this.xform_self_ty(&item, new_trait_ref.self_ty(), new_trait_ref.substs);\n \n-            this.inherent_candidates.push(Candidate {\n-                xform_self_ty: xform_self_ty,\n-                item: item,\n-                kind: ObjectCandidate,\n-                import_id: None,\n-            });\n+            this.push_inherent_candidate(xform_self_ty, item, ObjectCandidate, None);\n         });\n     }\n \n@@ -599,12 +603,8 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n             // `WhereClausePick`.\n             assert!(!trait_ref.substs.needs_infer());\n \n-            this.inherent_candidates.push(Candidate {\n-                xform_self_ty: xform_self_ty,\n-                item: item,\n-                kind: WhereClauseCandidate(poly_trait_ref),\n-                import_id: None,\n-            });\n+            this.push_inherent_candidate(xform_self_ty, item,\n+                                         WhereClauseCandidate(poly_trait_ref), None);\n         });\n     }\n \n@@ -743,12 +743,8 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n \n             debug!(\"xform_self_ty={:?}\", xform_self_ty);\n \n-            self.extension_candidates.push(Candidate {\n-                xform_self_ty: xform_self_ty,\n-                item: item.clone(),\n-                kind: ExtensionImplCandidate(impl_def_id, impl_substs, obligations),\n-                import_id: import_id,\n-            });\n+            self.push_extension_candidate(xform_self_ty, item,\n+                        ExtensionImplCandidate(impl_def_id, impl_substs, obligations), import_id);\n         });\n     }\n \n@@ -833,12 +829,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n             });\n \n             let xform_self_ty = self.xform_self_ty(&item, step.self_ty, substs);\n-            self.inherent_candidates.push(Candidate {\n-                xform_self_ty: xform_self_ty,\n-                item: item.clone(),\n-                kind: TraitCandidate,\n-                import_id: import_id,\n-            });\n+            self.push_inherent_candidate(xform_self_ty, item, TraitCandidate, import_id);\n         }\n \n         Ok(())\n@@ -854,7 +845,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                trait_def_id,\n                item);\n \n-        for step in self.steps.iter() {\n+        for step in Rc::clone(&self.steps).iter() {\n             debug!(\"assemble_projection_candidates: step={:?}\", step);\n \n             let (def_id, substs) = match step.self_ty.sty {\n@@ -889,12 +880,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                            bound,\n                            xform_self_ty);\n \n-                    self.extension_candidates.push(Candidate {\n-                        xform_self_ty: xform_self_ty,\n-                        item: item.clone(),\n-                        kind: TraitCandidate,\n-                        import_id: import_id,\n-                    });\n+                    self.push_extension_candidate(xform_self_ty, item, TraitCandidate, import_id);\n                 }\n             }\n         }\n@@ -918,12 +904,8 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                    bound,\n                    xform_self_ty);\n \n-            self.extension_candidates.push(Candidate {\n-                xform_self_ty: xform_self_ty,\n-                item: item.clone(),\n-                kind: WhereClauseCandidate(poly_bound),\n-                import_id: import_id,\n-            });\n+            self.push_extension_candidate(xform_self_ty, item,\n+                                          WhereClauseCandidate(poly_bound), import_id);\n         }\n     }\n "}, {"sha": "3488310b128834dbbd866cbb4fa43e06addcf8a3", "filename": "src/test/compile-fail/issue-28514.rs", "status": "removed", "additions": 0, "deletions": 47, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/2b4c911581099e247a68b3a8adc782d778f5190b/src%2Ftest%2Fcompile-fail%2Fissue-28514.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b4c911581099e247a68b3a8adc782d778f5190b/src%2Ftest%2Fcompile-fail%2Fissue-28514.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-28514.rs?ref=2b4c911581099e247a68b3a8adc782d778f5190b", "patch": "@@ -1,47 +0,0 @@\n-// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![deny(private_in_public)]\n-\n-pub use inner::C;\n-\n-mod inner {\n-    trait A {\n-        fn a(&self) { }\n-    }\n-\n-    pub trait B {\n-        fn b(&self) { }\n-    }\n-\n-    pub trait C: A + B { //~ ERROR private trait `inner::A` in public interface\n-                         //~^ WARN will become a hard error\n-        fn c(&self) { }\n-    }\n-\n-    impl A for i32 {}\n-    impl B for i32 {}\n-    impl C for i32 {}\n-\n-}\n-\n-fn main() {\n-    // A is private\n-    // B is pub, not reexported\n-    // C : A + B is pub, reexported\n-\n-    // 0.a(); // can't call\n-    // 0.b(); // can't call\n-    0.c(); // ok\n-\n-    C::a(&0); // can call\n-    C::b(&0); // can call\n-    C::c(&0); // ok\n-}"}, {"sha": "a8d97d4674cbb4450f89bbc0c73332fd44e1c4e6", "filename": "src/test/compile-fail/no-method-suggested-traits.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/82e030322bd47d0ac3d1639cabf93e24dbdc1779/src%2Ftest%2Fcompile-fail%2Fno-method-suggested-traits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82e030322bd47d0ac3d1639cabf93e24dbdc1779/src%2Ftest%2Fcompile-fail%2Fno-method-suggested-traits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno-method-suggested-traits.rs?ref=82e030322bd47d0ac3d1639cabf93e24dbdc1779", "patch": "@@ -16,7 +16,7 @@ struct Foo;\n enum Bar { X }\n \n mod foo {\n-    trait Bar {\n+    pub trait Bar {\n         fn method(&self) {}\n \n         fn method2(&self) {}"}, {"sha": "4e8f8d6760a75ee3e593e8b28688c5aebd58b214", "filename": "src/test/compile-fail/trait-item-privacy.rs", "status": "added", "additions": 110, "deletions": 0, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/82e030322bd47d0ac3d1639cabf93e24dbdc1779/src%2Ftest%2Fcompile-fail%2Ftrait-item-privacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82e030322bd47d0ac3d1639cabf93e24dbdc1779/src%2Ftest%2Fcompile-fail%2Ftrait-item-privacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-item-privacy.rs?ref=82e030322bd47d0ac3d1639cabf93e24dbdc1779", "patch": "@@ -0,0 +1,110 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(associated_consts)]\n+#![feature(associated_type_defaults)]\n+\n+struct S;\n+\n+mod method {\n+    trait A {\n+        fn a(&self) { }\n+        const A: u8 = 0;\n+    }\n+\n+    pub trait B {\n+        fn b(&self) { }\n+        const B: u8 = 0;\n+    }\n+\n+    pub trait C: A + B {\n+        fn c(&self) { }\n+        const C: u8 = 0;\n+    }\n+\n+    impl A for ::S {}\n+    impl B for ::S {}\n+    impl C for ::S {}\n+\n+}\n+\n+mod assoc_ty {\n+    trait A {\n+        type A = u8;\n+    }\n+\n+    pub trait B {\n+        type B = u8;\n+    }\n+\n+    pub trait C: A + B {\n+        type C = u8;\n+    }\n+\n+    impl A for ::S {}\n+    impl B for ::S {}\n+    impl C for ::S {}\n+\n+}\n+\n+fn check_assoc_ty<T: assoc_ty::C>() {\n+    // A is private\n+    // B is pub, not in scope\n+    // C : A + B is pub, in scope\n+    use assoc_ty::C;\n+\n+    // Associated types\n+    // A, B, C are resolved as trait items, their traits need to be in scope, not implemented yet\n+    let _: S::A; //~ ERROR ambiguous associated type\n+    let _: S::B; //~ ERROR ambiguous associated type\n+    let _: S::C; //~ ERROR ambiguous associated type\n+    // A, B, C are resolved as inherent items, their traits don't need to be in scope\n+    let _: T::A; //~ ERROR associated type `A` is private\n+    let _: T::B; // OK\n+    let _: T::C; // OK\n+}\n+\n+fn main() {\n+    // A is private\n+    // B is pub, not in scope\n+    // C : A + B is pub, in scope\n+    use method::C;\n+\n+    // Methods, method call\n+    // a, b, c are resolved as trait items, their traits need to be in scope\n+    S.a(); //~ ERROR no method named `a` found for type `S` in the current scope\n+    S.b(); //~ ERROR no method named `b` found for type `S` in the current scope\n+    S.c(); // OK\n+    // a, b, c are resolved as inherent items, their traits don't need to be in scope\n+    let c = &S as &C;\n+    c.a(); //~ ERROR method `a` is private\n+    c.b(); // OK\n+    c.c(); // OK\n+\n+    // Methods, UFCS\n+    // a, b, c are resolved as trait items, their traits need to be in scope\n+    S::a(&S); //~ ERROR no associated item named `a` found for type `S` in the current scope\n+    S::b(&S); //~ ERROR no associated item named `b` found for type `S` in the current scope\n+    S::c(&S); // OK\n+    // a, b, c are resolved as inherent items, their traits don't need to be in scope\n+    C::a(&S); //~ ERROR method `a` is private\n+    C::b(&S); // OK\n+    C::c(&S); // OK\n+\n+    // Associated constants\n+    // A, B, C are resolved as trait items, their traits need to be in scope\n+    S::A; //~ ERROR no associated item named `A` found for type `S` in the current scope\n+    S::B; //~ ERROR no associated item named `B` found for type `S` in the current scope\n+    S::C; // OK\n+    // A, B, C are resolved as inherent items, their traits don't need to be in scope\n+    C::A; //~ ERROR associated constant `A` is private\n+    C::B; // OK\n+    C::C; // OK\n+}"}, {"sha": "5feef0a24eb0e93a717f61d52b5608410a97ef03", "filename": "src/test/compile-fail/trait-not-accessible.rs", "status": "removed", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/2b4c911581099e247a68b3a8adc782d778f5190b/src%2Ftest%2Fcompile-fail%2Ftrait-not-accessible.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b4c911581099e247a68b3a8adc782d778f5190b/src%2Ftest%2Fcompile-fail%2Ftrait-not-accessible.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-not-accessible.rs?ref=2b4c911581099e247a68b3a8adc782d778f5190b", "patch": "@@ -1,28 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-mod m {\n-    trait Priv {\n-        fn f(&self) {}\n-    }\n-    impl Priv for super::S {}\n-    pub trait Pub: Priv {}\n-}\n-\n-struct S;\n-impl m::Pub for S {}\n-\n-fn g<T: m::Pub>(arg: T) {\n-    arg.f(); //~ ERROR: source trait `m::Priv` is private\n-}\n-\n-fn main() {\n-    g(S);\n-}"}]}