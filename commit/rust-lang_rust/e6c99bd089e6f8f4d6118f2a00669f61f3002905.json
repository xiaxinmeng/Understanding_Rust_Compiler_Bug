{"sha": "e6c99bd089e6f8f4d6118f2a00669f61f3002905", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU2Yzk5YmQwODllNmY4ZjRkNjExOGYyYTAwNjY5ZjYxZjMwMDI5MDU=", "commit": {"author": {"name": "llogiq", "email": "bogusandre@gmail.com", "date": "2016-01-29T18:50:18Z"}, "committer": {"name": "llogiq", "email": "bogusandre@gmail.com", "date": "2016-01-29T18:50:18Z"}, "message": "Merge pull request #589 from mcarton/vec\n\nAdd a lint to warn about &vec![_] if &[_] would do", "tree": {"sha": "acdbadbee02e13626c30242037bb0cf51c040fc1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/acdbadbee02e13626c30242037bb0cf51c040fc1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e6c99bd089e6f8f4d6118f2a00669f61f3002905", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e6c99bd089e6f8f4d6118f2a00669f61f3002905", "html_url": "https://github.com/rust-lang/rust/commit/e6c99bd089e6f8f4d6118f2a00669f61f3002905", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e6c99bd089e6f8f4d6118f2a00669f61f3002905/comments", "author": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "committer": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4c14d98c9f05ce9d655c0966a63ab617a8ea99e6", "url": "https://api.github.com/repos/rust-lang/rust/commits/4c14d98c9f05ce9d655c0966a63ab617a8ea99e6", "html_url": "https://github.com/rust-lang/rust/commit/4c14d98c9f05ce9d655c0966a63ab617a8ea99e6"}, {"sha": "afb7e6721797484c704a01ed94ae67c086cdc007", "url": "https://api.github.com/repos/rust-lang/rust/commits/afb7e6721797484c704a01ed94ae67c086cdc007", "html_url": "https://github.com/rust-lang/rust/commit/afb7e6721797484c704a01ed94ae67c086cdc007"}], "stats": {"total": 165, "additions": 163, "deletions": 2}, "files": [{"sha": "212d868c698881d75fc5bbf4c7feba4610aec680", "filename": "README.md", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e6c99bd089e6f8f4d6118f2a00669f61f3002905/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/e6c99bd089e6f8f4d6118f2a00669f61f3002905/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=e6c99bd089e6f8f4d6118f2a00669f61f3002905", "patch": "@@ -6,7 +6,7 @@ A collection of lints to catch common mistakes and improve your Rust code.\n [Jump to usage instructions](#usage)\n \n ##Lints\n-There are 101 lints included in this crate:\n+There are 102 lints included in this crate:\n \n name                                                                                                           | default | meaning\n ---------------------------------------------------------------------------------------------------------------|---------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n@@ -105,6 +105,7 @@ name\n [unused_lifetimes](https://github.com/Manishearth/rust-clippy/wiki#unused_lifetimes)                           | warn    | unused lifetimes in function definitions\n [used_underscore_binding](https://github.com/Manishearth/rust-clippy/wiki#used_underscore_binding)             | warn    | using a binding which is prefixed with an underscore\n [useless_transmute](https://github.com/Manishearth/rust-clippy/wiki#useless_transmute)                         | warn    | transmutes that have the same to and from types\n+[useless_vec](https://github.com/Manishearth/rust-clippy/wiki#useless_vec)                                     | warn    | useless `vec!`\n [while_let_loop](https://github.com/Manishearth/rust-clippy/wiki#while_let_loop)                               | warn    | `loop { if let { ... } else break }` can be written as a `while let` loop\n [while_let_on_iterator](https://github.com/Manishearth/rust-clippy/wiki#while_let_on_iterator)                 | warn    | using a while-let loop instead of a for loop on an iterator\n [wrong_pub_self_convention](https://github.com/Manishearth/rust-clippy/wiki#wrong_pub_self_convention)         | allow   | defining a public method named with an established prefix (like \"into_\") that takes `self` with the wrong convention"}, {"sha": "90625e4bb5caafeb126356664febe43a7febb3d8", "filename": "src/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e6c99bd089e6f8f4d6118f2a00669f61f3002905/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6c99bd089e6f8f4d6118f2a00669f61f3002905/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=e6c99bd089e6f8f4d6118f2a00669f61f3002905", "patch": "@@ -79,6 +79,7 @@ pub mod array_indexing;\n pub mod panic;\n pub mod derive;\n pub mod print;\n+pub mod vec;\n \n mod reexport {\n     pub use syntax::ast::{Name, NodeId};\n@@ -144,6 +145,7 @@ pub fn plugin_registrar(reg: &mut Registry) {\n     reg.register_late_lint_pass(box derive::Derive);\n     reg.register_late_lint_pass(box types::CharLitAsU8);\n     reg.register_late_lint_pass(box print::PrintLint);\n+    reg.register_late_lint_pass(box vec::UselessVec);\n \n \n     reg.register_lint_group(\"clippy_pedantic\", vec![\n@@ -250,6 +252,7 @@ pub fn plugin_registrar(reg: &mut Registry) {\n         types::TYPE_COMPLEXITY,\n         types::UNIT_CMP,\n         unicode::ZERO_WIDTH_SPACE,\n+        vec::USELESS_VEC,\n         zero_div_zero::ZERO_DIVIDED_BY_ZERO,\n     ]);\n }"}, {"sha": "a6dbcfd9e2fbeaa327ebdc54fe5d61351df88b23", "filename": "src/utils.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e6c99bd089e6f8f4d6118f2a00669f61f3002905/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6c99bd089e6f8f4d6118f2a00669f61f3002905/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=e6c99bd089e6f8f4d6118f2a00669f61f3002905", "patch": "@@ -20,6 +20,7 @@ pub type MethodArgs = HirVec<P<Expr>>;\n \n // module DefPaths for certain structs/enums we check for\n pub const BEGIN_UNWIND: [&'static str; 3] = [\"std\", \"rt\", \"begin_unwind\"];\n+pub const BOX_NEW_PATH: [&'static str; 4] = [\"std\", \"boxed\", \"Box\", \"new\"];\n pub const BTREEMAP_ENTRY_PATH: [&'static str; 4] = [\"collections\", \"btree\", \"map\", \"Entry\"];\n pub const BTREEMAP_PATH: [&'static str; 4] = [\"collections\", \"btree\", \"map\", \"BTreeMap\"];\n pub const CLONE_PATH: [&'static str; 3] = [\"clone\", \"Clone\", \"clone\"];\n@@ -36,6 +37,7 @@ pub const OPEN_OPTIONS_PATH: [&'static str; 3] = [\"std\", \"fs\", \"OpenOptions\"];\n pub const OPTION_PATH: [&'static str; 3] = [\"core\", \"option\", \"Option\"];\n pub const RESULT_PATH: [&'static str; 3] = [\"core\", \"result\", \"Result\"];\n pub const STRING_PATH: [&'static str; 3] = [\"collections\", \"string\", \"String\"];\n+pub const VEC_FROM_ELEM_PATH: [&'static str; 3] = [\"std\", \"vec\", \"from_elem\"];\n pub const VEC_PATH: [&'static str; 3] = [\"collections\", \"vec\", \"Vec\"];\n \n /// Produce a nested chain of if-lets and ifs from the patterns:\n@@ -487,7 +489,7 @@ pub fn span_note_and_lint<'a, T: LintContext>(cx: &'a T, lint: &'static Lint, sp\n \n pub fn span_lint_and_then<'a, T: LintContext, F>(cx: &'a T, lint: &'static Lint, sp: Span, msg: &str, f: F)\n                                                  -> DiagnosticWrapper<'a>\n-    where F: Fn(&mut DiagnosticWrapper)\n+    where F: FnOnce(&mut DiagnosticWrapper)\n {\n     let mut db = DiagnosticWrapper(cx.struct_span_lint(lint, sp, msg));\n     if cx.current_level(lint) != Level::Allow {"}, {"sha": "b46795a3cdd734f9aa79b96118053b3e5978e88f", "filename": "src/vec.rs", "status": "added", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/e6c99bd089e6f8f4d6118f2a00669f61f3002905/src%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6c99bd089e6f8f4d6118f2a00669f61f3002905/src%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvec.rs?ref=e6c99bd089e6f8f4d6118f2a00669f61f3002905", "patch": "@@ -0,0 +1,111 @@\n+use rustc::lint::*;\n+use rustc::middle::ty::TypeVariants;\n+use rustc_front::hir::*;\n+use syntax::codemap::Span;\n+use syntax::ptr::P;\n+use utils::{BOX_NEW_PATH, VEC_FROM_ELEM_PATH};\n+use utils::{is_expn_of, match_path, snippet, span_lint_and_then};\n+\n+/// **What it does:** This lint warns about using `&vec![..]` when using `&[..]` would be possible.\n+/// It is `Warn` by default.\n+///\n+/// **Why is this bad?** This is less efficient.\n+///\n+/// **Known problems:** None.\n+///\n+/// **Example:**\n+/// ```rust, ignore\n+/// foo(&vec![1, 2])\n+/// ```\n+declare_lint! {\n+    pub USELESS_VEC,\n+    Warn,\n+    \"useless `vec!`\"\n+}\n+\n+#[derive(Copy, Clone, Debug)]\n+pub struct UselessVec;\n+\n+impl LintPass for UselessVec {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(USELESS_VEC)\n+    }\n+}\n+\n+impl LateLintPass for UselessVec {\n+    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n+        unexpand_vec(cx, expr);\n+\n+        // search for `&!vec[_]` expressions where the adjusted type is `&[_]`\n+        if_let_chain!{[\n+            let TypeVariants::TyRef(_, ref ty) = cx.tcx.expr_ty_adjusted(expr).sty,\n+            let TypeVariants::TySlice(..) = ty.ty.sty,\n+            let ExprAddrOf(_, ref addressee) = expr.node,\n+            let Some(vec_args) = unexpand_vec(cx, addressee)\n+        ], {\n+            let snippet = match vec_args {\n+                VecArgs::Repeat(elem, len) => {\n+                    format!(\"&[{}; {}]\", snippet(cx, elem.span, \"elem\"), snippet(cx, len.span, \"len\")).into()\n+                }\n+                VecArgs::Vec(args) => {\n+                    if let Some(last) = args.iter().last() {\n+                        let span = Span {\n+                            lo: args[0].span.lo,\n+                            hi: last.span.hi,\n+                            expn_id: args[0].span.expn_id,\n+                        };\n+\n+                        format!(\"&[{}]\", snippet(cx, span, \"..\")).into()\n+                    }\n+                    else {\n+                        \"&[]\".into()\n+                    }\n+                }\n+            };\n+\n+            span_lint_and_then(cx, USELESS_VEC, expr.span, \"useless use of `vec!`\", |db| {\n+                db.span_suggestion(expr.span, \"you can use a slice directly\", snippet);\n+            });\n+        }}\n+    }\n+}\n+\n+/// Represent the pre-expansion arguments of a `vec!` invocation.\n+pub enum VecArgs<'a> {\n+    /// `vec![elem, len]`\n+    Repeat(&'a P<Expr>, &'a P<Expr>),\n+    /// `vec![a, b, c]`\n+    Vec(&'a [P<Expr>]),\n+}\n+\n+/// Returns the arguments of the `vec!` macro if this expression was expanded from `vec!`.\n+pub fn unexpand_vec<'e>(cx: &LateContext, expr: &'e Expr) -> Option<VecArgs<'e>> {\n+    if_let_chain!{[\n+        let ExprCall(ref fun, ref args) = expr.node,\n+        let ExprPath(_, ref path) = fun.node,\n+        is_expn_of(cx, fun.span, \"vec\").is_some()\n+    ], {\n+        return if match_path(path, &VEC_FROM_ELEM_PATH) && args.len() == 2 {\n+            // `vec![elem; size]` case\n+            Some(VecArgs::Repeat(&args[0], &args[1]))\n+        }\n+        else if match_path(path, &[\"into_vec\"]) && args.len() == 1 {\n+            // `vec![a, b, c]` case\n+            if_let_chain!{[\n+                let ExprCall(ref fun, ref args) = args[0].node,\n+                let ExprPath(_, ref path) = fun.node,\n+                match_path(path, &BOX_NEW_PATH) && args.len() == 1,\n+                let ExprVec(ref args) = args[0].node\n+            ], {\n+                return Some(VecArgs::Vec(&*args));\n+            }}\n+\n+            None\n+        }\n+        else {\n+            None\n+        };\n+    }}\n+\n+    None\n+}"}, {"sha": "b4f52ecadc521b0bff22a9433a5a10f7a8eb9dcf", "filename": "tests/compile-fail/vec.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/e6c99bd089e6f8f4d6118f2a00669f61f3002905/tests%2Fcompile-fail%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6c99bd089e6f8f4d6118f2a00669f61f3002905/tests%2Fcompile-fail%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fvec.rs?ref=e6c99bd089e6f8f4d6118f2a00669f61f3002905", "patch": "@@ -0,0 +1,44 @@\n+#![feature(plugin)]\n+#![plugin(clippy)]\n+\n+#![deny(useless_vec)]\n+\n+fn on_slice(_: &[u8]) {}\n+#[allow(ptr_arg)]\n+fn on_vec(_: &Vec<u8>) {}\n+\n+fn main() {\n+    on_slice(&vec![]);\n+    //~^ ERROR useless use of `vec!`\n+    //~| HELP you can use\n+    //~| SUGGESTION on_slice(&[])\n+    on_slice(&[]);\n+\n+    on_slice(&vec![1, 2]);\n+    //~^ ERROR useless use of `vec!`\n+    //~| HELP you can use\n+    //~| SUGGESTION on_slice(&[1, 2])\n+    on_slice(&[1, 2]);\n+\n+    on_slice(&vec ![1, 2]);\n+    //~^ ERROR useless use of `vec!`\n+    //~| HELP you can use\n+    //~| SUGGESTION on_slice(&[1, 2])\n+    on_slice(&[1, 2]);\n+\n+    on_slice(&vec!(1, 2));\n+    //~^ ERROR useless use of `vec!`\n+    //~| HELP you can use\n+    //~| SUGGESTION on_slice(&[1, 2])\n+    on_slice(&[1, 2]);\n+\n+    on_slice(&vec![1; 2]);\n+    //~^ ERROR useless use of `vec!`\n+    //~| HELP you can use\n+    //~| SUGGESTION on_slice(&[1; 2])\n+    on_slice(&[1; 2]);\n+\n+    on_vec(&vec![]);\n+    on_vec(&vec![1, 2]);\n+    on_vec(&vec![1; 2]);\n+}"}]}