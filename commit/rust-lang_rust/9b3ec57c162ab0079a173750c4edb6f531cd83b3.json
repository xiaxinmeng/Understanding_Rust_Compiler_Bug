{"sha": "9b3ec57c162ab0079a173750c4edb6f531cd83b3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjliM2VjNTdjMTYyYWIwMDc5YTE3Mzc1MGM0ZWRiNmY1MzFjZDgzYjM=", "commit": {"author": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2018-07-07T03:29:11Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-07-07T03:29:11Z"}, "message": "Rollup merge of #51901 - rust-lang:weak-unboxing, r=alexcrichton\n\nRc: remove unused allocation and fix segfault in Weak::new()\n\nSame as https://github.com/rust-lang/rust/pull/50357 did for `Arc`.\n\nFixes https://github.com/rust-lang/rust/issues/48493", "tree": {"sha": "78988da5a6d286e3ff8584098c88b52f4148af77", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/78988da5a6d286e3ff8584098c88b52f4148af77"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9b3ec57c162ab0079a173750c4edb6f531cd83b3", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJbQDOHCRBK7hj4Ov3rIwAAdHIIAIYPRNGvVIKgLf+wJ6iqHCiu\nMgeHFuXW8Cq3phxtb0VVIxoJDKwive2AZS4MU538rm1g7tQEgAevUJbcTgqQxmf7\nwDeeA0EsuoUV3whIKmoDIQ9WWa2DckTAUWVf9uQ4KvZ3rFgQ8V+6Z9xk9pyP/cqQ\nOXpHhcDDEd81MmQIsBK+LSc42GV6HS1c70LUEyw28UfQA5Du82X8QtXSYh8pi1XI\nGI8P6BNCERqN1G0TOsfi9we4SIN0So5thfO0y7aAN9yLn+YNcH6SICa1ZaC7LAk1\n0tCj4FrvkcukI5DmFoTs0cwIOgONt43G5L+AYt0aPq9vhEFpCnqPFNKrCzltXAE=\n=cxgl\n-----END PGP SIGNATURE-----\n", "payload": "tree 78988da5a6d286e3ff8584098c88b52f4148af77\nparent a178cba9f1be1dc5f9da47a9ed5d291c19821aab\nparent 67202b8b68d93c90e89ca001945865f13bc97154\nauthor Mark Rousskov <mark.simulacrum@gmail.com> 1530934151 -0600\ncommitter GitHub <noreply@github.com> 1530934151 -0600\n\nRollup merge of #51901 - rust-lang:weak-unboxing, r=alexcrichton\n\nRc: remove unused allocation and fix segfault in Weak::new()\n\nSame as https://github.com/rust-lang/rust/pull/50357 did for `Arc`.\n\nFixes https://github.com/rust-lang/rust/issues/48493\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9b3ec57c162ab0079a173750c4edb6f531cd83b3", "html_url": "https://github.com/rust-lang/rust/commit/9b3ec57c162ab0079a173750c4edb6f531cd83b3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9b3ec57c162ab0079a173750c4edb6f531cd83b3/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a178cba9f1be1dc5f9da47a9ed5d291c19821aab", "url": "https://api.github.com/repos/rust-lang/rust/commits/a178cba9f1be1dc5f9da47a9ed5d291c19821aab", "html_url": "https://github.com/rust-lang/rust/commit/a178cba9f1be1dc5f9da47a9ed5d291c19821aab"}, {"sha": "67202b8b68d93c90e89ca001945865f13bc97154", "url": "https://api.github.com/repos/rust-lang/rust/commits/67202b8b68d93c90e89ca001945865f13bc97154", "html_url": "https://github.com/rust-lang/rust/commit/67202b8b68d93c90e89ca001945865f13bc97154"}], "stats": {"total": 236, "additions": 192, "deletions": 44}, "files": [{"sha": "5b71d0b85a03eb06d2d846094821e3461a1b0a16", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 41, "deletions": 23, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/9b3ec57c162ab0079a173750c4edb6f531cd83b3/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b3ec57c162ab0079a173750c4edb6f531cd83b3/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=9b3ec57c162ab0079a173750c4edb6f531cd83b3", "patch": "@@ -253,7 +253,7 @@ use core::hash::{Hash, Hasher};\n use core::intrinsics::abort;\n use core::marker;\n use core::marker::{Unsize, PhantomData};\n-use core::mem::{self, align_of_val, forget, size_of_val, uninitialized};\n+use core::mem::{self, align_of_val, forget, size_of_val};\n use core::ops::Deref;\n use core::ops::CoerceUnsized;\n use core::ptr::{self, NonNull};\n@@ -1153,6 +1153,10 @@ impl<T> From<Vec<T>> for Rc<[T]> {\n /// [`None`]: ../../std/option/enum.Option.html#variant.None\n #[stable(feature = \"rc_weak\", since = \"1.4.0\")]\n pub struct Weak<T: ?Sized> {\n+    // This is a `NonNull` to allow optimizing the size of this type in enums,\n+    // but it is not necessarily a valid pointer.\n+    // `Weak::new` sets this to a dangling pointer so that it doesn\u2019t need\n+    // to allocate space on the heap.\n     ptr: NonNull<RcBox<T>>,\n }\n \n@@ -1165,8 +1169,8 @@ impl<T: ?Sized> !marker::Sync for Weak<T> {}\n impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<Weak<U>> for Weak<T> {}\n \n impl<T> Weak<T> {\n-    /// Constructs a new `Weak<T>`, allocating memory for `T` without initializing\n-    /// it. Calling [`upgrade`] on the return value always gives [`None`].\n+    /// Constructs a new `Weak<T>`, without allocating any memory.\n+    /// Calling [`upgrade`] on the return value always gives [`None`].\n     ///\n     /// [`upgrade`]: struct.Weak.html#method.upgrade\n     /// [`None`]: ../../std/option/enum.Option.html\n@@ -1181,18 +1185,18 @@ impl<T> Weak<T> {\n     /// ```\n     #[stable(feature = \"downgraded_weak\", since = \"1.10.0\")]\n     pub fn new() -> Weak<T> {\n-        unsafe {\n-            Weak {\n-                ptr: Box::into_raw_non_null(box RcBox {\n-                    strong: Cell::new(0),\n-                    weak: Cell::new(1),\n-                    value: uninitialized(),\n-                }),\n-            }\n+        Weak {\n+            ptr: NonNull::dangling(),\n         }\n     }\n }\n \n+pub(crate) fn is_dangling<T: ?Sized>(ptr: NonNull<T>) -> bool {\n+    let address = ptr.as_ptr() as *mut () as usize;\n+    let align = align_of_val(unsafe { ptr.as_ref() });\n+    address == align\n+}\n+\n impl<T: ?Sized> Weak<T> {\n     /// Attempts to upgrade the `Weak` pointer to an [`Rc`], extending\n     /// the lifetime of the value if successful.\n@@ -1222,13 +1226,25 @@ impl<T: ?Sized> Weak<T> {\n     /// ```\n     #[stable(feature = \"rc_weak\", since = \"1.4.0\")]\n     pub fn upgrade(&self) -> Option<Rc<T>> {\n-        if self.strong() == 0 {\n+        let inner = self.inner()?;\n+        if inner.strong() == 0 {\n             None\n         } else {\n-            self.inc_strong();\n+            inner.inc_strong();\n             Some(Rc { ptr: self.ptr, phantom: PhantomData })\n         }\n     }\n+\n+    /// Return `None` when the pointer is dangling and there is no allocated `RcBox`,\n+    /// i.e. this `Weak` was created by `Weak::new`\n+    #[inline]\n+    fn inner(&self) -> Option<&RcBox<T>> {\n+        if is_dangling(self.ptr) {\n+            None\n+        } else {\n+            Some(unsafe { self.ptr.as_ref() })\n+        }\n+    }\n }\n \n #[stable(feature = \"rc_weak\", since = \"1.4.0\")]\n@@ -1258,12 +1274,14 @@ impl<T: ?Sized> Drop for Weak<T> {\n     /// assert!(other_weak_foo.upgrade().is_none());\n     /// ```\n     fn drop(&mut self) {\n-        unsafe {\n-            self.dec_weak();\n+        if let Some(inner) = self.inner() {\n+            inner.dec_weak();\n             // the weak count starts at 1, and will only go to zero if all\n             // the strong pointers have disappeared.\n-            if self.weak() == 0 {\n-                Global.dealloc(self.ptr.cast(), Layout::for_value(self.ptr.as_ref()));\n+            if inner.weak() == 0 {\n+                unsafe {\n+                    Global.dealloc(self.ptr.cast(), Layout::for_value(self.ptr.as_ref()));\n+                }\n             }\n         }\n     }\n@@ -1284,7 +1302,9 @@ impl<T: ?Sized> Clone for Weak<T> {\n     /// ```\n     #[inline]\n     fn clone(&self) -> Weak<T> {\n-        self.inc_weak();\n+        if let Some(inner) = self.inner() {\n+            inner.inc_weak()\n+        }\n         Weak { ptr: self.ptr }\n     }\n }\n@@ -1317,7 +1337,7 @@ impl<T> Default for Weak<T> {\n     }\n }\n \n-// NOTE: We checked_add here to deal with mem::forget safety. In particular\n+// NOTE: We checked_add here to deal with mem::forget safely. In particular\n // if you mem::forget Rcs (or Weaks), the ref-count can overflow, and then\n // you can free the allocation while outstanding Rcs (or Weaks) exist.\n // We abort because this is such a degenerate scenario that we don't care about\n@@ -1370,12 +1390,10 @@ impl<T: ?Sized> RcBoxPtr<T> for Rc<T> {\n     }\n }\n \n-impl<T: ?Sized> RcBoxPtr<T> for Weak<T> {\n+impl<T: ?Sized> RcBoxPtr<T> for RcBox<T> {\n     #[inline(always)]\n     fn inner(&self) -> &RcBox<T> {\n-        unsafe {\n-            self.ptr.as_ref()\n-        }\n+        self\n     }\n }\n "}, {"sha": "6710878b31d945bdc2cfdf7a4cd111ec544bd672", "filename": "src/liballoc/sync.rs", "status": "modified", "additions": 24, "deletions": 21, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/9b3ec57c162ab0079a173750c4edb6f531cd83b3/src%2Fliballoc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b3ec57c162ab0079a173750c4edb6f531cd83b3/src%2Fliballoc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fsync.rs?ref=9b3ec57c162ab0079a173750c4edb6f531cd83b3", "patch": "@@ -34,6 +34,7 @@ use core::convert::From;\n \n use alloc::{Global, Alloc, Layout, box_free, handle_alloc_error};\n use boxed::Box;\n+use rc::is_dangling;\n use string::String;\n use vec::Vec;\n \n@@ -43,9 +44,6 @@ use vec::Vec;\n /// necessarily) at _exactly_ `MAX_REFCOUNT + 1` references.\n const MAX_REFCOUNT: usize = (isize::MAX) as usize;\n \n-/// A sentinel value that is used for the pointer of `Weak::new()`.\n-const WEAK_EMPTY: usize = 1;\n-\n /// A thread-safe reference-counting pointer. 'Arc' stands for 'Atomically\n /// Reference Counted'.\n ///\n@@ -239,9 +237,9 @@ impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<Arc<U>> for Arc<T> {}\n #[stable(feature = \"arc_weak\", since = \"1.4.0\")]\n pub struct Weak<T: ?Sized> {\n     // This is a `NonNull` to allow optimizing the size of this type in enums,\n-    // but it is actually not truly \"non-null\". A `Weak::new()` will set this\n-    // to a sentinel value, instead of needing to allocate some space in the\n-    // heap.\n+    // but it is not necessarily a valid pointer.\n+    // `Weak::new` sets this to a dangling pointer so that it doesn\u2019t need\n+    // to allocate space on the heap.\n     ptr: NonNull<ArcInner<T>>,\n }\n \n@@ -1035,10 +1033,8 @@ impl<T> Weak<T> {\n     /// ```\n     #[stable(feature = \"downgraded_weak\", since = \"1.10.0\")]\n     pub fn new() -> Weak<T> {\n-        unsafe {\n-            Weak {\n-                ptr: NonNull::new_unchecked(WEAK_EMPTY as *mut _),\n-            }\n+        Weak {\n+            ptr: NonNull::dangling(),\n         }\n     }\n }\n@@ -1074,11 +1070,7 @@ impl<T: ?Sized> Weak<T> {\n     pub fn upgrade(&self) -> Option<Arc<T>> {\n         // We use a CAS loop to increment the strong count instead of a\n         // fetch_add because once the count hits 0 it must never be above 0.\n-        let inner = if self.ptr.as_ptr() as *const u8 as usize == WEAK_EMPTY {\n-            return None;\n-        } else {\n-            unsafe { self.ptr.as_ref() }\n-        };\n+        let inner = self.inner()?;\n \n         // Relaxed load because any write of 0 that we can observe\n         // leaves the field in a permanently zero state (so a\n@@ -1109,6 +1101,17 @@ impl<T: ?Sized> Weak<T> {\n             }\n         }\n     }\n+\n+    /// Return `None` when the pointer is dangling and there is no allocated `ArcInner`,\n+    /// i.e. this `Weak` was created by `Weak::new`\n+    #[inline]\n+    fn inner(&self) -> Option<&ArcInner<T>> {\n+        if is_dangling(self.ptr) {\n+            None\n+        } else {\n+            Some(unsafe { self.ptr.as_ref() })\n+        }\n+    }\n }\n \n #[stable(feature = \"arc_weak\", since = \"1.4.0\")]\n@@ -1126,10 +1129,10 @@ impl<T: ?Sized> Clone for Weak<T> {\n     /// ```\n     #[inline]\n     fn clone(&self) -> Weak<T> {\n-        let inner = if self.ptr.as_ptr() as *const u8 as usize == WEAK_EMPTY {\n-            return Weak { ptr: self.ptr };\n+        let inner = if let Some(inner) = self.inner() {\n+            inner\n         } else {\n-            unsafe { self.ptr.as_ref() }\n+            return Weak { ptr: self.ptr };\n         };\n         // See comments in Arc::clone() for why this is relaxed.  This can use a\n         // fetch_add (ignoring the lock) because the weak count is only locked\n@@ -1204,10 +1207,10 @@ impl<T: ?Sized> Drop for Weak<T> {\n         // weak count can only be locked if there was precisely one weak ref,\n         // meaning that drop could only subsequently run ON that remaining weak\n         // ref, which can only happen after the lock is released.\n-        let inner = if self.ptr.as_ptr() as *const u8 as usize == WEAK_EMPTY {\n-            return;\n+        let inner = if let Some(inner) = self.inner() {\n+            inner\n         } else {\n-            unsafe { self.ptr.as_ref() }\n+            return\n         };\n \n         if inner.weak.fetch_sub(1, Release) == 1 {"}, {"sha": "753873dd294ce19564c075a6bf275706e4ba5553", "filename": "src/liballoc/tests/arc.rs", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/9b3ec57c162ab0079a173750c4edb6f531cd83b3/src%2Fliballoc%2Ftests%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b3ec57c162ab0079a173750c4edb6f531cd83b3/src%2Fliballoc%2Ftests%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Farc.rs?ref=9b3ec57c162ab0079a173750c4edb6f531cd83b3", "patch": "@@ -0,0 +1,55 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::any::Any;\n+use std::sync::{Arc, Weak};\n+\n+#[test]\n+fn uninhabited() {\n+    enum Void {}\n+    let mut a = Weak::<Void>::new();\n+    a = a.clone();\n+    assert!(a.upgrade().is_none());\n+\n+    let mut a: Weak<Any> = a;  // Unsizing\n+    a = a.clone();\n+    assert!(a.upgrade().is_none());\n+}\n+\n+#[test]\n+fn slice() {\n+    let a: Arc<[u32; 3]> = Arc::new([3, 2, 1]);\n+    let a: Arc<[u32]> = a;  // Unsizing\n+    let b: Arc<[u32]> = Arc::from(&[3, 2, 1][..]);  // Conversion\n+    assert_eq!(a, b);\n+\n+    // Exercise is_dangling() with a DST\n+    let mut a = Arc::downgrade(&a);\n+    a = a.clone();\n+    assert!(a.upgrade().is_some());\n+}\n+\n+#[test]\n+fn trait_object() {\n+    let a: Arc<u32> = Arc::new(4);\n+    let a: Arc<Any> = a;  // Unsizing\n+\n+    // Exercise is_dangling() with a DST\n+    let mut a = Arc::downgrade(&a);\n+    a = a.clone();\n+    assert!(a.upgrade().is_some());\n+\n+    let mut b = Weak::<u32>::new();\n+    b = b.clone();\n+    assert!(b.upgrade().is_none());\n+    let mut b: Weak<Any> = b;  // Unsizing\n+    b = b.clone();\n+    assert!(b.upgrade().is_none());\n+}"}, {"sha": "2c361598e8928c8389172f86a4a1a93e478825df", "filename": "src/liballoc/tests/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b3ec57c162ab0079a173750c4edb6f531cd83b3/src%2Fliballoc%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b3ec57c162ab0079a173750c4edb6f531cd83b3/src%2Fliballoc%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Flib.rs?ref=9b3ec57c162ab0079a173750c4edb6f531cd83b3", "patch": "@@ -32,12 +32,14 @@ extern crate rand;\n use std::hash::{Hash, Hasher};\n use std::collections::hash_map::DefaultHasher;\n \n+mod arc;\n mod binary_heap;\n mod btree;\n mod cow_str;\n mod fmt;\n mod heap;\n mod linked_list;\n+mod rc;\n mod slice;\n mod str;\n mod string;"}, {"sha": "baa0406acfc3dbcc02cdc8d1f2f2d349cd225349", "filename": "src/liballoc/tests/rc.rs", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/9b3ec57c162ab0079a173750c4edb6f531cd83b3/src%2Fliballoc%2Ftests%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b3ec57c162ab0079a173750c4edb6f531cd83b3/src%2Fliballoc%2Ftests%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Frc.rs?ref=9b3ec57c162ab0079a173750c4edb6f531cd83b3", "patch": "@@ -0,0 +1,55 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::any::Any;\n+use std::rc::{Rc, Weak};\n+\n+#[test]\n+fn uninhabited() {\n+    enum Void {}\n+    let mut a = Weak::<Void>::new();\n+    a = a.clone();\n+    assert!(a.upgrade().is_none());\n+\n+    let mut a: Weak<Any> = a;  // Unsizing\n+    a = a.clone();\n+    assert!(a.upgrade().is_none());\n+}\n+\n+#[test]\n+fn slice() {\n+    let a: Rc<[u32; 3]> = Rc::new([3, 2, 1]);\n+    let a: Rc<[u32]> = a;  // Unsizing\n+    let b: Rc<[u32]> = Rc::from(&[3, 2, 1][..]);  // Conversion\n+    assert_eq!(a, b);\n+\n+    // Exercise is_dangling() with a DST\n+    let mut a = Rc::downgrade(&a);\n+    a = a.clone();\n+    assert!(a.upgrade().is_some());\n+}\n+\n+#[test]\n+fn trait_object() {\n+    let a: Rc<u32> = Rc::new(4);\n+    let a: Rc<Any> = a;  // Unsizing\n+\n+    // Exercise is_dangling() with a DST\n+    let mut a = Rc::downgrade(&a);\n+    a = a.clone();\n+    assert!(a.upgrade().is_some());\n+\n+    let mut b = Weak::<u32>::new();\n+    b = b.clone();\n+    assert!(b.upgrade().is_none());\n+    let mut b: Weak<Any> = b;  // Unsizing\n+    b = b.clone();\n+    assert!(b.upgrade().is_none());\n+}"}, {"sha": "eb57c12ed12c62609f0ee4b70b71dd36e13322f9", "filename": "src/test/run-pass/weak-new-uninhabited-issue-48493.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9b3ec57c162ab0079a173750c4edb6f531cd83b3/src%2Ftest%2Frun-pass%2Fweak-new-uninhabited-issue-48493.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b3ec57c162ab0079a173750c4edb6f531cd83b3/src%2Ftest%2Frun-pass%2Fweak-new-uninhabited-issue-48493.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fweak-new-uninhabited-issue-48493.rs?ref=9b3ec57c162ab0079a173750c4edb6f531cd83b3", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    enum Void {}\n+    std::rc::Weak::<Void>::new();\n+    std::sync::Weak::<Void>::new();\n+}"}]}