{"sha": "52f82354dc1dee723b0b1324dda7ddeabc332830", "node_id": "C_kwDOAAsO6NoAKDUyZjgyMzU0ZGMxZGVlNzIzYjBiMTMyNGRkYTdkZGVhYmMzMzI4MzA", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-12-14T23:53:05Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2023-02-16T03:39:59Z"}, "message": "Make things actually work", "tree": {"sha": "17da5e920389a2d21395431ae15a525ae45a1d0f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/17da5e920389a2d21395431ae15a525ae45a1d0f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/52f82354dc1dee723b0b1324dda7ddeabc332830", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/52f82354dc1dee723b0b1324dda7ddeabc332830", "html_url": "https://github.com/rust-lang/rust/commit/52f82354dc1dee723b0b1324dda7ddeabc332830", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/52f82354dc1dee723b0b1324dda7ddeabc332830/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eff2cb7760ffd1ed06fd5a68ba04dcb6689106f6", "url": "https://api.github.com/repos/rust-lang/rust/commits/eff2cb7760ffd1ed06fd5a68ba04dcb6689106f6", "html_url": "https://github.com/rust-lang/rust/commit/eff2cb7760ffd1ed06fd5a68ba04dcb6689106f6"}], "stats": {"total": 244, "additions": 151, "deletions": 93}, "files": [{"sha": "ae738177d76cbc0cd8e9cecf824b8add139677e3", "filename": "compiler/rustc_hir_analysis/src/astconv/mod.rs", "status": "modified", "additions": 21, "deletions": 6, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/52f82354dc1dee723b0b1324dda7ddeabc332830/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f82354dc1dee723b0b1324dda7ddeabc332830/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs?ref=52f82354dc1dee723b0b1324dda7ddeabc332830", "patch": "@@ -2598,6 +2598,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         &self,\n         opt_self_ty: Option<Ty<'tcx>>,\n         path: &hir::Path<'_>,\n+        hir_id: hir::HirId,\n         permit_variants: bool,\n     ) -> Ty<'tcx> {\n         let tcx = self.tcx();\n@@ -2661,11 +2662,25 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     }\n                 });\n \n-                let def_id = def_id.expect_local();\n-                let item_def_id = tcx.hir().ty_param_owner(def_id);\n-                let generics = tcx.generics_of(item_def_id);\n-                let index = generics.param_def_id_to_index[&def_id.to_def_id()];\n-                tcx.mk_ty_param(index, tcx.hir().ty_param_name(def_id))\n+                match tcx.named_bound_var(hir_id) {\n+                    Some(rbv::ResolvedArg::LateBound(debruijn, index, _)) => {\n+                        let name =\n+                            tcx.hir().name(tcx.hir().local_def_id_to_hir_id(def_id.expect_local()));\n+                        let br = ty::BoundTy {\n+                            var: ty::BoundVar::from_u32(index),\n+                            kind: ty::BoundTyKind::Param(def_id, name),\n+                        };\n+                        tcx.mk_ty(ty::Bound(debruijn, br))\n+                    }\n+                    Some(rbv::ResolvedArg::EarlyBound(_)) => {\n+                        let def_id = def_id.expect_local();\n+                        let item_def_id = tcx.hir().ty_param_owner(def_id);\n+                        let generics = tcx.generics_of(item_def_id);\n+                        let index = generics.param_def_id_to_index[&def_id.to_def_id()];\n+                        tcx.mk_ty_param(index, tcx.hir().ty_param_name(def_id))\n+                    }\n+                    arg => bug!(\"unexpected bound var resolution for {hir_id:?}: {arg:?}\"),\n+                }\n             }\n             Res::SelfTyParam { .. } => {\n                 // `Self` in trait or type alias.\n@@ -2888,7 +2903,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             hir::TyKind::Path(hir::QPath::Resolved(maybe_qself, path)) => {\n                 debug!(?maybe_qself, ?path);\n                 let opt_self_ty = maybe_qself.as_ref().map(|qself| self.ast_ty_to_ty(qself));\n-                self.res_to_ty(opt_self_ty, path, false)\n+                self.res_to_ty(opt_self_ty, path, ast_ty.hir_id, false)\n             }\n             &hir::TyKind::OpaqueDef(item_id, lifetimes, in_trait) => {\n                 let opaque_ty = tcx.hir().item(item_id);"}, {"sha": "97d7556a41dd5f740d45adb950ac7c6138457318", "filename": "compiler/rustc_hir_analysis/src/collect/resolve_bound_vars.rs", "status": "modified", "additions": 120, "deletions": 83, "changes": 203, "blob_url": "https://github.com/rust-lang/rust/blob/52f82354dc1dee723b0b1324dda7ddeabc332830/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fresolve_bound_vars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f82354dc1dee723b0b1324dda7ddeabc332830/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fresolve_bound_vars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fresolve_bound_vars.rs?ref=52f82354dc1dee723b0b1324dda7ddeabc332830", "patch": "@@ -35,14 +35,14 @@ trait RegionExt {\n \n impl RegionExt for ResolvedArg {\n     fn early(param: &GenericParam<'_>) -> (LocalDefId, ResolvedArg) {\n-        debug!(\"Region::early: def_id={:?}\", param.def_id);\n+        debug!(\"ResolvedArg::early: def_id={:?}\", param.def_id);\n         (param.def_id, ResolvedArg::EarlyBound(param.def_id.to_def_id()))\n     }\n \n     fn late(idx: u32, param: &GenericParam<'_>) -> (LocalDefId, ResolvedArg) {\n         let depth = ty::INNERMOST;\n         debug!(\n-            \"Region::late: idx={:?}, param={:?} depth={:?} def_id={:?}\",\n+            \"ResolvedArg::late: idx={:?}, param={:?} depth={:?} def_id={:?}\",\n             idx, param, depth, param.def_id,\n         );\n         (param.def_id, ResolvedArg::LateBound(depth, idx, param.def_id.to_def_id()))\n@@ -278,13 +278,25 @@ fn resolve_bound_vars(tcx: TyCtxt<'_>, local_def_id: hir::OwnerId) -> ResolveBou\n     rl\n }\n \n-fn late_region_as_bound_region(tcx: TyCtxt<'_>, region: &ResolvedArg) -> ty::BoundVariableKind {\n-    match region {\n+fn late_arg_as_bound_arg<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    arg: &ResolvedArg,\n+    param: &GenericParam<'tcx>,\n+) -> ty::BoundVariableKind {\n+    match arg {\n         ResolvedArg::LateBound(_, _, def_id) => {\n             let name = tcx.hir().name(tcx.hir().local_def_id_to_hir_id(def_id.expect_local()));\n-            ty::BoundVariableKind::Region(ty::BrNamed(*def_id, name))\n+            match param.kind {\n+                GenericParamKind::Lifetime { .. } => {\n+                    ty::BoundVariableKind::Region(ty::BrNamed(*def_id, name))\n+                }\n+                GenericParamKind::Type { .. } => {\n+                    ty::BoundVariableKind::Ty(ty::BoundTyKind::Param(*def_id, name))\n+                }\n+                GenericParamKind::Const { .. } => ty::BoundVariableKind::Const,\n+            }\n         }\n-        _ => bug!(\"{:?} is not a late argument\", region),\n+        _ => bug!(\"{:?} is not a late argument\", arg),\n     }\n }\n \n@@ -391,11 +403,10 @@ impl<'a, 'tcx> Visitor<'tcx> for BoundVarContext<'a, 'tcx> {\n             let (bound_vars, binders): (FxIndexMap<LocalDefId, ResolvedArg>, Vec<_>) =\n                 bound_generic_params\n                     .iter()\n-                    .filter(|param| matches!(param.kind, GenericParamKind::Lifetime { .. }))\n                     .enumerate()\n                     .map(|(late_bound_idx, param)| {\n                         let pair = ResolvedArg::late(late_bound_idx as u32, param);\n-                        let r = late_region_as_bound_region(self.tcx, &pair.1);\n+                        let r = late_arg_as_bound_arg(self.tcx, &pair.1, param);\n                         (pair, r)\n                     })\n                     .unzip();\n@@ -481,7 +492,7 @@ impl<'a, 'tcx> Visitor<'tcx> for BoundVarContext<'a, 'tcx> {\n                 }\n             }\n             hir::ItemKind::OpaqueTy(hir::OpaqueTy {\n-                origin: hir::OpaqueTyOrigin::FnReturn(_) | hir::OpaqueTyOrigin::AsyncFn(_),\n+                origin: hir::OpaqueTyOrigin::FnReturn(parent) | hir::OpaqueTyOrigin::AsyncFn(parent),\n                 generics,\n                 ..\n             }) => {\n@@ -490,26 +501,24 @@ impl<'a, 'tcx> Visitor<'tcx> for BoundVarContext<'a, 'tcx> {\n                 let mut bound_vars = FxIndexMap::default();\n                 debug!(?generics.params);\n                 for param in generics.params {\n-                    match param.kind {\n-                        GenericParamKind::Lifetime { .. } => {\n-                            let (def_id, reg) = ResolvedArg::early(&param);\n-                            bound_vars.insert(def_id, reg);\n-                        }\n-                        GenericParamKind::Type { .. } | GenericParamKind::Const { .. } => {}\n-                    }\n+                    let (def_id, reg) = ResolvedArg::early(&param);\n+                    bound_vars.insert(def_id, reg);\n                 }\n \n-                let scope = Scope::Binder {\n-                    hir_id: item.hir_id(),\n-                    bound_vars,\n-                    s: self.scope,\n-                    scope_type: BinderScopeType::Normal,\n-                    where_bound_origin: None,\n-                };\n+                let scope = Scope::Root { opt_parent_item: Some(parent) };\n                 self.with(scope, |this| {\n-                    let scope = Scope::TraitRefBoundary { s: this.scope };\n-                    this.with(scope, |this| intravisit::walk_item(this, item))\n-                });\n+                    let scope = Scope::Binder {\n+                        hir_id: item.hir_id(),\n+                        bound_vars,\n+                        s: this.scope,\n+                        scope_type: BinderScopeType::Normal,\n+                        where_bound_origin: None,\n+                    };\n+                    this.with(scope, |this| {\n+                        let scope = Scope::TraitRefBoundary { s: this.scope };\n+                        this.with(scope, |this| intravisit::walk_item(this, item))\n+                    });\n+                })\n             }\n             hir::ItemKind::TyAlias(_, generics)\n             | hir::ItemKind::Enum(_, generics)\n@@ -519,14 +528,7 @@ impl<'a, 'tcx> Visitor<'tcx> for BoundVarContext<'a, 'tcx> {\n             | hir::ItemKind::TraitAlias(generics, ..)\n             | hir::ItemKind::Impl(&hir::Impl { generics, .. }) => {\n                 // These kinds of items have only early-bound lifetime parameters.\n-                let bound_vars = generics\n-                    .params\n-                    .iter()\n-                    .filter_map(|param| match param.kind {\n-                        GenericParamKind::Lifetime { .. } => Some(ResolvedArg::early(param)),\n-                        GenericParamKind::Type { .. } | GenericParamKind::Const { .. } => None,\n-                    })\n-                    .collect();\n+                let bound_vars = generics.params.iter().map(ResolvedArg::early).collect();\n                 self.record_late_bound_vars(item.hir_id(), vec![]);\n                 let scope = Scope::Binder {\n                     hir_id: item.hir_id(),\n@@ -568,11 +570,10 @@ impl<'a, 'tcx> Visitor<'tcx> for BoundVarContext<'a, 'tcx> {\n                 let (bound_vars, binders): (FxIndexMap<LocalDefId, ResolvedArg>, Vec<_>) = c\n                     .generic_params\n                     .iter()\n-                    .filter(|param| matches!(param.kind, GenericParamKind::Lifetime { .. }))\n                     .enumerate()\n                     .map(|(late_bound_idx, param)| {\n                         let pair = ResolvedArg::late(late_bound_idx as u32, param);\n-                        let r = late_region_as_bound_region(self.tcx, &pair.1);\n+                        let r = late_arg_as_bound_arg(self.tcx, &pair.1, param);\n                         (pair, r)\n                     })\n                     .unzip();\n@@ -725,14 +726,7 @@ impl<'a, 'tcx> Visitor<'tcx> for BoundVarContext<'a, 'tcx> {\n             }\n             Type(bounds, ty) => {\n                 let generics = &trait_item.generics;\n-                let bound_vars = generics\n-                    .params\n-                    .iter()\n-                    .filter_map(|param| match param.kind {\n-                        GenericParamKind::Lifetime { .. } => Some(ResolvedArg::early(param)),\n-                        GenericParamKind::Type { .. } | GenericParamKind::Const { .. } => None,\n-                    })\n-                    .collect();\n+                let bound_vars = generics.params.iter().map(ResolvedArg::early).collect();\n                 self.record_late_bound_vars(trait_item.hir_id(), vec![]);\n                 let scope = Scope::Binder {\n                     hir_id: trait_item.hir_id(),\n@@ -771,14 +765,8 @@ impl<'a, 'tcx> Visitor<'tcx> for BoundVarContext<'a, 'tcx> {\n             }),\n             Type(ty) => {\n                 let generics = &impl_item.generics;\n-                let bound_vars: FxIndexMap<LocalDefId, ResolvedArg> = generics\n-                    .params\n-                    .iter()\n-                    .filter_map(|param| match param.kind {\n-                        GenericParamKind::Lifetime { .. } => Some(ResolvedArg::early(param)),\n-                        GenericParamKind::Const { .. } | GenericParamKind::Type { .. } => None,\n-                    })\n-                    .collect();\n+                let bound_vars: FxIndexMap<LocalDefId, ResolvedArg> =\n+                    generics.params.iter().map(ResolvedArg::early).collect();\n                 self.record_late_bound_vars(impl_item.hir_id(), vec![]);\n                 let scope = Scope::Binder {\n                     hir_id: impl_item.hir_id(),\n@@ -819,13 +807,16 @@ impl<'a, 'tcx> Visitor<'tcx> for BoundVarContext<'a, 'tcx> {\n         }\n     }\n \n-    fn visit_path(&mut self, path: &hir::Path<'tcx>, _: hir::HirId) {\n+    fn visit_path(&mut self, path: &hir::Path<'tcx>, hir_id: hir::HirId) {\n         for (i, segment) in path.segments.iter().enumerate() {\n             let depth = path.segments.len() - i - 1;\n             if let Some(args) = segment.args {\n                 self.visit_segment_args(path.res, depth, args);\n             }\n         }\n+        if let Res::Def(DefKind::TyParam | DefKind::ConstParam, param_def_id) = path.res {\n+            self.resolve_type_ref(param_def_id.expect_local(), hir_id);\n+        }\n     }\n \n     fn visit_fn(\n@@ -874,24 +865,17 @@ impl<'a, 'tcx> Visitor<'tcx> for BoundVarContext<'a, 'tcx> {\n                         origin,\n                         ..\n                     }) => {\n-                        let bound_vars: FxIndexMap<LocalDefId, ResolvedArg> =\n+\n+                        let (bound_vars, binders): (FxIndexMap<LocalDefId, ResolvedArg>, Vec<_>) =\n                             bound_generic_params\n-                                .iter()\n-                                .filter(|param| {\n-                                    matches!(param.kind, GenericParamKind::Lifetime { .. })\n-                                })\n-                                .enumerate()\n-                                .map(|(late_bound_idx, param)| {\n-                                        ResolvedArg::late(late_bound_idx as u32, param)\n-                                })\n-                                .collect();\n-                        let binders: Vec<_> =\n-                            bound_vars\n-                                .iter()\n-                                .map(|(_, region)| {\n-                                     late_region_as_bound_region(this.tcx, region)\n-                                })\n-                                .collect();\n+                            .iter()\n+                            .enumerate()\n+                            .map(|(late_bound_idx, param)| {\n+                                let pair = ResolvedArg::late(late_bound_idx as u32, param);\n+                                let r = late_arg_as_bound_arg(this.tcx, &pair.1, param);\n+                                (pair, r)\n+                            })\n+                            .unzip();\n                         this.record_late_bound_vars(hir_id, binders.clone());\n                         // Even if there are no lifetimes defined here, we still wrap it in a binder\n                         // scope. If there happens to be a nested poly trait ref (an error), that\n@@ -989,14 +973,10 @@ impl<'a, 'tcx> Visitor<'tcx> for BoundVarContext<'a, 'tcx> {\n \n         let initial_bound_vars = binders.len() as u32;\n         let mut bound_vars: FxIndexMap<LocalDefId, ResolvedArg> = FxIndexMap::default();\n-        let binders_iter = trait_ref\n-            .bound_generic_params\n-            .iter()\n-            .filter(|param| matches!(param.kind, GenericParamKind::Lifetime { .. }))\n-            .enumerate()\n-            .map(|(late_bound_idx, param)| {\n+        let binders_iter =\n+            trait_ref.bound_generic_params.iter().enumerate().map(|(late_bound_idx, param)| {\n                 let pair = ResolvedArg::late(initial_bound_vars + late_bound_idx as u32, param);\n-                let r = late_region_as_bound_region(self.tcx, &pair.1);\n+                let r = late_arg_as_bound_arg(self.tcx, &pair.1, param);\n                 bound_vars.insert(pair.0, pair.1);\n                 r\n             });\n@@ -1121,17 +1101,19 @@ impl<'a, 'tcx> BoundVarContext<'a, 'tcx> {\n         let bound_vars: FxIndexMap<LocalDefId, ResolvedArg> = generics\n             .params\n             .iter()\n-            .filter_map(|param| match param.kind {\n+            .map(|param| match param.kind {\n                 GenericParamKind::Lifetime { .. } => {\n                     if self.tcx.is_late_bound(param.hir_id) {\n                         let late_bound_idx = named_late_bound_vars;\n                         named_late_bound_vars += 1;\n-                        Some(ResolvedArg::late(late_bound_idx, param))\n+                        ResolvedArg::late(late_bound_idx, param)\n                     } else {\n-                        Some(ResolvedArg::early(param))\n+                        ResolvedArg::early(param)\n                     }\n                 }\n-                GenericParamKind::Type { .. } | GenericParamKind::Const { .. } => None,\n+                GenericParamKind::Type { .. } | GenericParamKind::Const { .. } => {\n+                    ResolvedArg::early(param)\n+                }\n             })\n             .collect();\n \n@@ -1145,7 +1127,7 @@ impl<'a, 'tcx> BoundVarContext<'a, 'tcx> {\n             .enumerate()\n             .map(|(late_bound_idx, param)| {\n                 let pair = ResolvedArg::late(late_bound_idx as u32, param);\n-                late_region_as_bound_region(self.tcx, &pair.1)\n+                late_arg_as_bound_arg(self.tcx, &pair.1, param)\n             })\n             .collect();\n         self.record_late_bound_vars(hir_id, binders);\n@@ -1182,7 +1164,7 @@ impl<'a, 'tcx> BoundVarContext<'a, 'tcx> {\n                 Scope::Root { opt_parent_item } => {\n                     if let Some(parent_item) = opt_parent_item\n                         && let parent_generics = self.tcx.generics_of(parent_item)\n-                        && parent_generics.param_def_id_to_index.contains_key(&region_def_id.to_def_id())\n+                        && parent_generics.param_def_id_to_index(self.tcx, region_def_id.to_def_id()).is_some()\n                     {\n                         break Some(ResolvedArg::EarlyBound(region_def_id.to_def_id()));\n                     }\n@@ -1334,6 +1316,61 @@ impl<'a, 'tcx> BoundVarContext<'a, 'tcx> {\n         );\n     }\n \n+    fn resolve_type_ref(&mut self, param_def_id: LocalDefId, hir_id: hir::HirId) {\n+        // Walk up the scope chain, tracking the number of fn scopes\n+        // that we pass through, until we find a lifetime with the\n+        // given name or we run out of scopes.\n+        // search.\n+        let mut late_depth = 0;\n+        let mut scope = self.scope;\n+        let result = loop {\n+            match *scope {\n+                Scope::Body { s, .. } => {\n+                    scope = s;\n+                }\n+\n+                Scope::Root { opt_parent_item } => {\n+                    if let Some(parent_item) = opt_parent_item\n+                        && let parent_generics = self.tcx.generics_of(parent_item)\n+                        && parent_generics.param_def_id_to_index(self.tcx, param_def_id.to_def_id()).is_some()\n+                    {\n+                        break Some(ResolvedArg::EarlyBound(param_def_id.to_def_id()));\n+                    }\n+                    break None;\n+                }\n+\n+                Scope::Binder { ref bound_vars, scope_type, s, .. } => {\n+                    if let Some(&def) = bound_vars.get(&param_def_id) {\n+                        break Some(def.shifted(late_depth));\n+                    }\n+                    match scope_type {\n+                        BinderScopeType::Normal => late_depth += 1,\n+                        BinderScopeType::Concatenating => {}\n+                    }\n+                    scope = s;\n+                }\n+\n+                Scope::Elision { s, .. }\n+                | Scope::ObjectLifetimeDefault { s, .. }\n+                | Scope::Supertrait { s, .. }\n+                | Scope::TraitRefBoundary { s, .. } => {\n+                    scope = s;\n+                }\n+            }\n+        };\n+\n+        if let Some(def) = result {\n+            self.map.defs.insert(hir_id, def);\n+            return;\n+        }\n+\n+        span_bug!(\n+            self.tcx.hir().span(hir_id),\n+            \"could not resolve {param_def_id:?}, scopes: {:#?}\",\n+            self.scope\n+        );\n+    }\n+\n     #[instrument(level = \"debug\", skip(self))]\n     fn visit_segment_args(\n         &mut self,"}, {"sha": "74f40d97f2bbd1434e5cf87d505082f5caf6a85e", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/checks.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52f82354dc1dee723b0b1324dda7ddeabc332830/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f82354dc1dee723b0b1324dda7ddeabc332830/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs?ref=52f82354dc1dee723b0b1324dda7ddeabc332830", "patch": "@@ -1669,7 +1669,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         match *qpath {\n             QPath::Resolved(ref maybe_qself, ref path) => {\n                 let self_ty = maybe_qself.as_ref().map(|qself| self.to_ty(qself).raw);\n-                let ty = self.astconv().res_to_ty(self_ty, path, true);\n+                let ty = self.astconv().res_to_ty(self_ty, path, hir_id, true);\n                 (path.res, self.handle_raw_ty(path_span, ty))\n             }\n             QPath::TypeRelative(ref qself, ref segment) => {"}, {"sha": "b96d07e7dc831cd43ec4156b1ade0d1f38d66c4c", "filename": "compiler/rustc_middle/src/middle/resolve_bound_vars.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/52f82354dc1dee723b0b1324dda7ddeabc332830/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fresolve_bound_vars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f82354dc1dee723b0b1324dda7ddeabc332830/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fresolve_bound_vars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fresolve_bound_vars.rs?ref=52f82354dc1dee723b0b1324dda7ddeabc332830", "patch": "@@ -10,8 +10,8 @@ use rustc_macros::HashStable;\n #[derive(Clone, Copy, PartialEq, Eq, Hash, TyEncodable, TyDecodable, Debug, HashStable)]\n pub enum ResolvedArg {\n     StaticLifetime,\n-    EarlyBound(/* lifetime decl */ DefId),\n-    LateBound(ty::DebruijnIndex, /* late-bound index */ u32, /* lifetime decl */ DefId),\n+    EarlyBound(/* decl */ DefId),\n+    LateBound(ty::DebruijnIndex, /* late-bound index */ u32, /* decl */ DefId),\n     Free(DefId, /* lifetime decl */ DefId),\n }\n "}, {"sha": "324de7461cd95431a0a2a6f1e92e4d831d929b55", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/52f82354dc1dee723b0b1324dda7ddeabc332830/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f82354dc1dee723b0b1324dda7ddeabc332830/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=52f82354dc1dee723b0b1324dda7ddeabc332830", "patch": "@@ -2505,7 +2505,13 @@ impl<'a: 'ast, 'b, 'ast, 'tcx> LateResolutionVisitor<'a, 'b, 'ast, 'tcx> {\n \n             let res = match kind {\n                 ItemRibKind(..) | AssocItemRibKind => Res::Def(def_kind, def_id.to_def_id()),\n-                NormalRibKind => Res::Err, /* FIXME(non_lifetime_binder): Resolve this to \"late\" */\n+                NormalRibKind => {\n+                    if self.r.session.features_untracked().non_lifetime_binders {\n+                        Res::Def(def_kind, def_id.to_def_id())\n+                    } else {\n+                        Res::Err\n+                    }\n+                }\n                 _ => span_bug!(param.ident.span, \"Unexpected rib kind {:?}\", kind),\n             };\n             self.r.record_partial_res(param.id, PartialRes::new(res));"}]}