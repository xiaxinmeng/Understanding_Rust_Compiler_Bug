{"sha": "e00bd27953a096929c0a5d6f41b8aca6243eabb2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUwMGJkMjc5NTNhMDk2OTI5YzBhNWQ2ZjQxYjhhY2E2MjQzZWFiYjI=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-09-24T21:45:22Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-09-24T21:45:22Z"}, "message": "Rollup merge of #64622 - ecstatic-morse:cycle-detector, r=oli-obk\n\nAdd a cycle detector for generic `Graph`s and `mir::Body`s\n\nCycle detection is one way to differentiate the upcoming `const_loop` feature flag (#52000) from the `const_if_match` one (#49146). It would be possible to use the existing implementation of strongly-connected components for this but less efficient.\n\nThe [\"tri-color\" terminology](http://www.cs.cornell.edu/courses/cs2112/2012sp/lectures/lec24/lec24-12sp.html) is common in introductory data structures and algorithms courses: black nodes are settled, grey nodes are visited, and white nodes have no state. This particular implementation is iterative and uses a well-known technique where \"node settled\" events are kept on the stack alongside nodes to visit. When a settled event is popped, we know that all successors of that node have been visited and themselves settled. If we encounter a successor node that has been visited (is on the stack) but not yet settled, we have found a cycle.\n\nr? @eddyb", "tree": {"sha": "4b3747aa9c616334516977fd64e9b3c1ecf8bd04", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4b3747aa9c616334516977fd64e9b3c1ecf8bd04"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e00bd27953a096929c0a5d6f41b8aca6243eabb2", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdio5yCRBK7hj4Ov3rIwAAdHIIAFmH5UmE7Moig1IlGdAVzRS9\nCQuQo7ZS7u2M5C3m+xg9hV4t6XvjkYNEtpwERbHbCTnVOraeqT8q8imFn2tBSJRW\njgIT4xWokE9XSJfJkb+Cs8dvcQ8gGPAd9+GrKWjKNvvs16vQP0IPXcBedZ5cn2Ui\nclfP8uCHkygwHobI2VHlUrXV67nU7Sy7r6p/3C4Znv8dAk+8FYJN+vgiRijrpWnW\n9Ed++e/xz2t+mJlkDmiPCNznmQd34FuOyQ/g9vWPpdIMA+MFd+xq/36UDG1jL/r1\n5UX7Nw6Fvlq3rNseebyM1SelS0oUiNDq6iVXKx2F+5zsWjeLjtoWjBu5a01/ka8=\n=9WO4\n-----END PGP SIGNATURE-----\n", "payload": "tree 4b3747aa9c616334516977fd64e9b3c1ecf8bd04\nparent 4a58b14db5ed21654e952f051af2a6c51dfb15fd\nparent c9e4816fe319b2fde83779ff375037c8079d36a2\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1569361522 +0200\ncommitter GitHub <noreply@github.com> 1569361522 +0200\n\nRollup merge of #64622 - ecstatic-morse:cycle-detector, r=oli-obk\n\nAdd a cycle detector for generic `Graph`s and `mir::Body`s\n\nCycle detection is one way to differentiate the upcoming `const_loop` feature flag (#52000) from the `const_if_match` one (#49146). It would be possible to use the existing implementation of strongly-connected components for this but less efficient.\n\nThe [\"tri-color\" terminology](http://www.cs.cornell.edu/courses/cs2112/2012sp/lectures/lec24/lec24-12sp.html) is common in introductory data structures and algorithms courses: black nodes are settled, grey nodes are visited, and white nodes have no state. This particular implementation is iterative and uses a well-known technique where \"node settled\" events are kept on the stack alongside nodes to visit. When a settled event is popped, we know that all successors of that node have been visited and themselves settled. If we encounter a successor node that has been visited (is on the stack) but not yet settled, we have found a cycle.\n\nr? @eddyb\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e00bd27953a096929c0a5d6f41b8aca6243eabb2", "html_url": "https://github.com/rust-lang/rust/commit/e00bd27953a096929c0a5d6f41b8aca6243eabb2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e00bd27953a096929c0a5d6f41b8aca6243eabb2/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4a58b14db5ed21654e952f051af2a6c51dfb15fd", "url": "https://api.github.com/repos/rust-lang/rust/commits/4a58b14db5ed21654e952f051af2a6c51dfb15fd", "html_url": "https://github.com/rust-lang/rust/commit/4a58b14db5ed21654e952f051af2a6c51dfb15fd"}, {"sha": "c9e4816fe319b2fde83779ff375037c8079d36a2", "url": "https://api.github.com/repos/rust-lang/rust/commits/c9e4816fe319b2fde83779ff375037c8079d36a2", "html_url": "https://github.com/rust-lang/rust/commit/c9e4816fe319b2fde83779ff375037c8079d36a2"}], "stats": {"total": 231, "additions": 230, "deletions": 1}, "files": [{"sha": "967d16fa0d902c74a13c1b8682f2e967bc5c9831", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e00bd27953a096929c0a5d6f41b8aca6243eabb2/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e00bd27953a096929c0a5d6f41b8aca6243eabb2/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=e00bd27953a096929c0a5d6f41b8aca6243eabb2", "patch": "@@ -262,6 +262,12 @@ impl<'tcx> Body<'tcx> {\n         dominators(self)\n     }\n \n+    /// Returns `true` if a cycle exists in the control-flow graph that is reachable from the\n+    /// `START_BLOCK`.\n+    pub fn is_cfg_cyclic(&self) -> bool {\n+        graph::is_cyclic(self)\n+    }\n+\n     #[inline]\n     pub fn local_kind(&self, local: Local) -> LocalKind {\n         let index = local.as_usize();"}, {"sha": "cbf6a0a3c03a0810d9c42a4ebe53210569ee99c1", "filename": "src/librustc_data_structures/graph/iterate/mod.rs", "status": "modified", "additions": 203, "deletions": 1, "changes": 204, "blob_url": "https://github.com/rust-lang/rust/blob/e00bd27953a096929c0a5d6f41b8aca6243eabb2/src%2Flibrustc_data_structures%2Fgraph%2Fiterate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e00bd27953a096929c0a5d6f41b8aca6243eabb2/src%2Flibrustc_data_structures%2Fgraph%2Fiterate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fgraph%2Fiterate%2Fmod.rs?ref=e00bd27953a096929c0a5d6f41b8aca6243eabb2", "patch": "@@ -1,5 +1,5 @@\n use super::super::indexed_vec::IndexVec;\n-use super::{DirectedGraph, WithNumNodes, WithSuccessors};\n+use super::{DirectedGraph, WithNumNodes, WithSuccessors, WithStartNode};\n use crate::bit_set::BitSet;\n \n #[cfg(test)]\n@@ -85,3 +85,205 @@ where\n         Some(n)\n     }\n }\n+\n+/// Allows searches to terminate early with a value.\n+#[derive(Clone, Copy, Debug)]\n+pub enum ControlFlow<T> {\n+    Break(T),\n+    Continue,\n+}\n+\n+/// The status of a node in the depth-first search.\n+///\n+/// See the documentation of `TriColorDepthFirstSearch` to see how a node's status is updated\n+/// during DFS.\n+#[derive(Clone, Copy, Debug, PartialEq, Eq)]\n+pub enum NodeStatus {\n+    /// This node has been examined by the depth-first search but is not yet `Settled`.\n+    ///\n+    /// Also referred to as \"gray\" or \"discovered\" nodes in [CLR][].\n+    ///\n+    /// [CLR]: https://en.wikipedia.org/wiki/Introduction_to_Algorithms\n+    Visited,\n+\n+    /// This node and all nodes reachable from it have been examined by the depth-first search.\n+    ///\n+    /// Also referred to as \"black\" or \"finished\" nodes in [CLR][].\n+    ///\n+    /// [CLR]: https://en.wikipedia.org/wiki/Introduction_to_Algorithms\n+    Settled,\n+}\n+\n+struct Event<N> {\n+    node: N,\n+    becomes: NodeStatus,\n+}\n+\n+/// A depth-first search that also tracks when all successors of a node have been examined.\n+///\n+/// This is based on the DFS described in [Introduction to Algorithms (1st ed.)][CLR], hereby\n+/// referred to as **CLR**. However, we use the terminology in [`NodeStatus`][] above instead of\n+/// \"discovered\"/\"finished\" or \"white\"/\"grey\"/\"black\". Each node begins the search with no status,\n+/// becomes `Visited` when it is first examined by the DFS and is `Settled` when all nodes\n+/// reachable from it have been examined. This allows us to differentiate between \"tree\", \"back\"\n+/// and \"forward\" edges (see [`TriColorVisitor::node_examined`]).\n+///\n+/// Unlike the pseudocode in [CLR][], this implementation is iterative and does not use timestamps.\n+/// We accomplish this by storing `Event`s on the stack that result in a (possible) state change\n+/// for each node. A `Visited` event signifies that we should examine this node if it has not yet\n+/// been `Visited` or `Settled`. When a node is examined for the first time, we mark it as\n+/// `Visited` and push a `Settled` event for it on stack followed by `Visited` events for all of\n+/// its predecessors, scheduling them for examination. Multiple `Visited` events for a single node\n+/// may exist on the stack simultaneously if a node has multiple predecessors, but only one\n+/// `Settled` event will ever be created for each node. After all `Visited` events for a node's\n+/// successors have been popped off the stack (as well as any new events triggered by visiting\n+/// those successors), we will pop off that node's `Settled` event.\n+///\n+/// [CLR]: https://en.wikipedia.org/wiki/Introduction_to_Algorithms\n+/// [`NodeStatus`]: ./enum.NodeStatus.html\n+/// [`TriColorVisitor::node_examined`]: ./trait.TriColorVisitor.html#method.node_examined\n+pub struct TriColorDepthFirstSearch<'graph, G>\n+where\n+    G: ?Sized + DirectedGraph + WithNumNodes + WithSuccessors,\n+{\n+    graph: &'graph G,\n+    stack: Vec<Event<G::Node>>,\n+    visited: BitSet<G::Node>,\n+    settled: BitSet<G::Node>,\n+}\n+\n+impl<G> TriColorDepthFirstSearch<'graph, G>\n+where\n+    G: ?Sized + DirectedGraph + WithNumNodes + WithSuccessors,\n+{\n+    pub fn new(graph: &'graph G) -> Self {\n+        TriColorDepthFirstSearch {\n+            graph,\n+            stack: vec![],\n+            visited: BitSet::new_empty(graph.num_nodes()),\n+            settled: BitSet::new_empty(graph.num_nodes()),\n+        }\n+    }\n+\n+    /// Performs a depth-first search, starting from the given `root`.\n+    ///\n+    /// This won't visit nodes that are not reachable from `root`.\n+    pub fn run_from<V>(mut self, root: G::Node, visitor: &mut V) -> Option<V::BreakVal>\n+    where\n+        V: TriColorVisitor<G>,\n+    {\n+        use NodeStatus::{Visited, Settled};\n+\n+        self.stack.push(Event { node: root, becomes: Visited });\n+\n+        loop {\n+            match self.stack.pop()? {\n+                Event { node, becomes: Settled } => {\n+                    let not_previously_settled = self.settled.insert(node);\n+                    assert!(not_previously_settled, \"A node should be settled exactly once\");\n+                    if let ControlFlow::Break(val) = visitor.node_settled(node) {\n+                        return Some(val);\n+                    }\n+                }\n+\n+                Event { node, becomes: Visited } => {\n+                    let not_previously_visited = self.visited.insert(node);\n+                    let prior_status = if not_previously_visited {\n+                        None\n+                    } else if self.settled.contains(node) {\n+                        Some(Settled)\n+                    } else {\n+                        Some(Visited)\n+                    };\n+\n+                    if let ControlFlow::Break(val) = visitor.node_examined(node, prior_status) {\n+                        return Some(val);\n+                    }\n+\n+                    // If this node has already been examined, we are done.\n+                    if prior_status.is_some() {\n+                        continue;\n+                    }\n+\n+                    // Otherwise, push a `Settled` event for this node onto the stack, then\n+                    // schedule its successors for examination.\n+                    self.stack.push(Event { node, becomes: Settled });\n+                    for succ in self.graph.successors(node) {\n+                        self.stack.push(Event { node: succ, becomes: Visited });\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+impl<G> TriColorDepthFirstSearch<'graph, G>\n+where\n+    G: ?Sized + DirectedGraph + WithNumNodes + WithSuccessors + WithStartNode,\n+{\n+    /// Performs a depth-first search, starting from `G::start_node()`.\n+    ///\n+    /// This won't visit nodes that are not reachable from the start node.\n+    pub fn run_from_start<V>(self, visitor: &mut V) -> Option<V::BreakVal>\n+    where\n+        V: TriColorVisitor<G>,\n+    {\n+        let root = self.graph.start_node();\n+        self.run_from(root, visitor)\n+    }\n+}\n+\n+/// What to do when a node is examined or becomes `Settled` during DFS.\n+pub trait TriColorVisitor<G>\n+where\n+    G: ?Sized + DirectedGraph,\n+{\n+    /// The value returned by this search.\n+    type BreakVal;\n+\n+    /// Called when a node is examined by the depth-first search.\n+    ///\n+    /// By checking the value of `prior_status`, this visitor can determine whether the edge\n+    /// leading to this node was a tree edge (`None`), forward edge (`Some(Settled)`) or back edge\n+    /// (`Some(Visited)`). For a full explanation of each edge type, see the \"Depth-first Search\"\n+    /// chapter in [CLR][] or [wikipedia][].\n+    ///\n+    /// If you want to know *both* nodes linked by each edge, you'll need to modify\n+    /// `TriColorDepthFirstSearch` to store a `source` node for each `Visited` event.\n+    ///\n+    /// [wikipedia]: https://en.wikipedia.org/wiki/Depth-first_search#Output_of_a_depth-first_search\n+    /// [CLR]: https://en.wikipedia.org/wiki/Introduction_to_Algorithms\n+    fn node_examined(\n+        &mut self,\n+        _target: G::Node,\n+        _prior_status: Option<NodeStatus>,\n+    ) -> ControlFlow<Self::BreakVal> {\n+        ControlFlow::Continue\n+    }\n+\n+    /// Called after all nodes reachable from this one have been examined.\n+    fn node_settled(&mut self, _target: G::Node) -> ControlFlow<Self::BreakVal> {\n+        ControlFlow::Continue\n+    }\n+}\n+\n+/// This `TriColorVisitor` looks for back edges in a graph, which indicate that a cycle exists.\n+pub struct CycleDetector;\n+\n+impl<G> TriColorVisitor<G> for CycleDetector\n+where\n+    G: ?Sized + DirectedGraph,\n+{\n+    type BreakVal = ();\n+\n+    fn node_examined(\n+        &mut self,\n+        _node: G::Node,\n+        prior_status: Option<NodeStatus>,\n+    ) -> ControlFlow<Self::BreakVal> {\n+        match prior_status {\n+            Some(NodeStatus::Visited) => ControlFlow::Break(()),\n+            _ => ControlFlow::Continue,\n+        }\n+    }\n+}"}, {"sha": "0e038e88b221dfed3f8d3b6aabbdb0b272d9ab96", "filename": "src/librustc_data_structures/graph/iterate/tests.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e00bd27953a096929c0a5d6f41b8aca6243eabb2/src%2Flibrustc_data_structures%2Fgraph%2Fiterate%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e00bd27953a096929c0a5d6f41b8aca6243eabb2/src%2Flibrustc_data_structures%2Fgraph%2Fiterate%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fgraph%2Fiterate%2Ftests.rs?ref=e00bd27953a096929c0a5d6f41b8aca6243eabb2", "patch": "@@ -9,3 +9,14 @@ fn diamond_post_order() {\n     let result = post_order_from(&graph, 0);\n     assert_eq!(result, vec![3, 1, 2, 0]);\n }\n+\n+#[test]\n+fn is_cyclic() {\n+    use super::super::is_cyclic;\n+\n+    let diamond_acyclic = TestGraph::new(0, &[(0, 1), (0, 2), (1, 3), (2, 3)]);\n+    let diamond_cyclic = TestGraph::new(0, &[(0, 1), (1, 2), (2, 3), (3, 0)]);\n+\n+    assert!(!is_cyclic(&diamond_acyclic));\n+    assert!(is_cyclic(&diamond_cyclic));\n+}"}, {"sha": "0a607659f3e246233bc74988269806fee7a9e44e", "filename": "src/librustc_data_structures/graph/mod.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e00bd27953a096929c0a5d6f41b8aca6243eabb2/src%2Flibrustc_data_structures%2Fgraph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e00bd27953a096929c0a5d6f41b8aca6243eabb2/src%2Flibrustc_data_structures%2Fgraph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fgraph%2Fmod.rs?ref=e00bd27953a096929c0a5d6f41b8aca6243eabb2", "patch": "@@ -81,3 +81,13 @@ where\n         + WithNumNodes,\n {\n }\n+\n+/// Returns `true` if the graph has a cycle that is reachable from the start node.\n+pub fn is_cyclic<G>(graph: &G) -> bool\n+where\n+    G: ?Sized + DirectedGraph + WithStartNode + WithSuccessors + WithNumNodes,\n+{\n+    iterate::TriColorDepthFirstSearch::new(graph)\n+        .run_from_start(&mut iterate::CycleDetector)\n+        .is_some()\n+}"}]}